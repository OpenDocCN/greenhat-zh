- en: Chapter 10. MASHUP PROJECTS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 MASHUP项目
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
- en: Throughout this book, I've demonstrated how to perform some common tasks with
    web maps and geographic data. Now I'll put many of these lessons together in example
    projects. The mashups in this chapter show how to retrieve, convert, and utilize
    external data sources.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我演示了如何使用网络地图和地理数据执行一些常见任务。现在，我将把这些课程中的许多结合到示例项目中。本章中的mashup展示了如何检索、转换和利用外部数据源。
- en: We'll also create interfaces that go beyond just showing a few locations on
    a map. Using events to capture clicks and mouse movements, we'll add some interactivity
    to the maps.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建超越仅显示地图上几个位置的界面。使用事件来捕捉点击和鼠标移动，我们将为地图添加一些交互性。
- en: What Is a Mashup?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Mashup？
- en: The Web is much more than a collection of interconnected documents. Millions
    of applications are creating, collecting, and consuming data all the time. When
    these applications talk to each other, sharing this data with application programming
    interfaces (APIs), the resulting feature is called a *mashup*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网远不止是一系列相互连接的文档。数百万个应用程序正在不断创建、收集和消费数据。当这些应用程序通过应用程序编程接口（API）相互交流，共享这些数据时，产生的功能被称为*mashup*。
- en: The name comes from music. Musically, a mashup is created when a DJ layers two
    or more songs together to make something new. This analogy describes what programmers
    and designers are creating with web mashups. They combine APIs to create something
    new, often an enlightening way of envisioning the underlying data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名字来自音乐。在音乐上，当DJ将两首或多首歌曲叠加在一起以创造新事物时，就会产生mashup。这个类比描述了程序员和设计师如何使用网络mashup。他们结合API来创造新事物，通常是一种启发性的数据可视化方式。
- en: We've been using a different type of API throughout this book. Maps, in addition
    to graphing and charting APIs, are used for visualizing data, either from your
    own or other APIs. Most APIs, however, are used to make data available to developers.
    Those that I'll use in this chapter provide publicly available location data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们一直在使用不同类型的API。除了图表API之外，地图还用于可视化数据，这些数据可能来自你自己的或其他API。然而，大多数API都是用来向开发者提供数据的。在本章中，我将使用提供公开可用位置数据的API。
- en: The Projects
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目
- en: 'The five projects in this chapter will get you started creating mashups. They
    were chosen for their conceptual diversity, so you can learn a number of techniques
    in this single chapter. Here''s a brief overview of the projects:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的五个项目将帮助你开始创建mashup。它们被选为概念多样性，因此你可以在单个章节中学习到许多技术。以下是项目的简要概述：
- en: '**Weather**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**天气**'
- en: Just like your daily newspaper, this map shows weather conditions across the
    United States—only this weather map is interactive and updated each time the page
    loads. See [http://mapscripting.com/weather](http://mapscripting.com/weather).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你的日常报纸一样，这张地图显示了美国的天气状况——只是这张天气图是交互式的，并且每次页面加载时都会更新。请参阅[http://mapscripting.com/weather](http://mapscripting.com/weather)。
- en: '**Earthquakes**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**地震**'
- en: You'll get geological and create a map showing last week's earthquakes plotted
    across the globe. Using the Richter scale measure of a quake's intensity, you
    can see where the big ones were and zoom in on the world's seismic hotspots. See
    [http://mapscripting.com/earthquakes](http://mapscripting.com/earthquakes).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得地质信息并创建一张显示上周全球地震分布的地图。使用里氏震级衡量地震的强度，你可以看到大地震发生的位置，并放大查看全球的地震热点。请参阅[http://mapscripting.com/earthquakes](http://mapscripting.com/earthquakes)。
- en: '**Concerts**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**音乐会**'
- en: Turn this mashup to 11! We'll create a tool to search a city or surrounding
    area for concerts. We'll even let users be frugal and declare their budget before
    searching. We'll filter only the results that match their criteria. See [http://mapscripting.com/concerts](http://mapscripting.com/concerts).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个mashup调到11！我们将创建一个工具来搜索城市或周边地区的音乐会。我们甚至允许用户在搜索前声明他们的预算。我们只会过滤出符合他们标准的结果。请参阅[http://mapscripting.com/concerts](http://mapscripting.com/concerts)。
- en: '**Twitter**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Twitter**'
- en: Help users find tweets near their location, or anywhere they search. Optionally,
    users can add a keyword to the search to zero in on both the *what* and *where*
    stored in Twitter status messages. See [http://mapscripting.com/twitter](http://mapscripting.com/twitter).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助用户找到他们所在位置附近的推文，或者他们搜索的任何地方。用户可以选择添加一个关键词到搜索中，以缩小Twitter状态消息中存储的*什么*和*哪里*的范围。请参阅[http://mapscripting.com/twitter](http://mapscripting.com/twitter)。
- en: '**Midpoint search**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**中点搜索**'
- en: Meet in the middle! Just searching for coffee isn't enough. The final mashup
    shows you how to first find the midpoint of a route and then search for coffee
    near that midpoint. That way, you don't have to be the one to drive across town
    when you find a place to meet in the middle. See [http://mapscripting.com/middle](http://mapscripting.com/middle).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间相遇！仅仅搜索咖啡是不够的。最终的混合显示了你如何首先找到路线的中点，然后在该中点附近搜索咖啡。这样，当你找到中间相遇的地方时，你就不必开车穿越整个城镇。参见[http://mapscripting.com/middle](http://mapscripting.com/middle)。
- en: These five projects use many of the concepts you've learned earlier in this
    book. Complete them and you will definitely be on your way to map mashup mastery.
    Let the mashing begin!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个项目使用了本书前面学到的许多概念。完成它们，你将肯定走向地图混合大师的道路。让我们开始混合吧！
- en: '#69: Create a Weather Map'
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#69: 创建天气地图'
- en: A big map with current conditions isn't just for your local meteorologist. Using
    the Yahoo! Weather API, you can make a visual forecast of a region, a country,
    or the whole world. In this example, I'll show how I created a US weather map
    with icons of current conditions marked for major regional cities.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一张显示当前状况的大地图不仅对当地气象学家有用。使用Yahoo!天气API，你可以制作一个区域、国家或整个世界的视觉预报。在这个例子中，我将展示如何创建一个带有主要区域城市当前状况图标的美国天气地图。
- en: As you'll see, most of the effort to create the weather map involves manipulating
    data. Once the data is in a format that JavaScript can easily access, all we need
    is a basic map with some custom markers. Things get a little tricky when we zoom
    in on a city and show its forecast in an overlay, but even that should be a cinch
    for a map master like you. By the end of this project, your map will look like
    [Figure 10-1](ch10s02.html#complete_us_weather_map "Figure 10-1. Complete US weather
    map").
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，创建天气地图的大部分工作都涉及数据处理。一旦数据以JavaScript可以轻松访问的格式，我们只需要一个基本的地图和一些自定义标记。当我们放大到城市并显示其覆盖层中的预报时，事情会变得有点棘手，但对于像你这样的地图大师来说，这应该不成问题。在这个项目结束时，你的地图将看起来像[图10-1](ch10s02.html#complete_us_weather_map
    "图10-1. 完整的美国天气地图")。
- en: '![Complete US weather map](httpatomoreillycomsourcenostarchimages672111.png.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![完整的美国天气地图](httpatomoreillycomsourcenostarchimages672111.png.jpg)'
- en: Figure 10-1. Complete US weather map
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-1. 完整的美国天气地图
- en: Prepare a Basic US Map
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备一张基本的美国地图
- en: What are the essential elements of a web map? A center point and a zoom level.
    Okay, so you also need the HTML with a `div` for your map and some basic styles.
    Plus, you'll need to load some JavaScript files. Once that foundation is in place,
    however, you just need to `setCenterAndZoom`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 网络地图的基本要素是什么？一个中心点和缩放级别。好吧，你还需要带有`div`的HTML以及一些基本样式。此外，你还需要加载一些JavaScript文件。然而，一旦这个基础建立起来，你只需要调用`setCenterAndZoom`。
- en: I decided early on that I only wanted to show the continental United States.
    Sorry Alaska and Hawaii—I'll make it up in the earthquake example later in this
    chapter. I arrived at the center and the zoom level with a little guess and check.
    Drag the map to where you want it and set the zoom to the perfect level. Then,
    call `getCenter` and `getZoom` (or do this automatically whenever the map is dragged).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我很早就决定只展示美国大陆。抱歉阿拉斯加和夏威夷——我将在本章后面的地震示例中弥补这一点。我通过一点猜测和检查找到了中心和缩放级别。将地图拖动到你想要的位置，并将缩放设置为完美的级别。然后，调用`getCenter`和`getZoom`（或者每当地图被拖动时自动执行此操作）。
- en: 'The center I arrived at has a latitude of 38 and a longitude of −98\. Although
    not the exact center of the United States, it looked best. I chose a zoom level
    of four, which is enough to see major cities and highways. Here is the code to
    create the basic map that we''ll build on in upcoming sections:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我到达的中心纬度为38度，经度为-98度。虽然不是美国的精确中心，但看起来最好。我选择了4倍缩放级别，足以看到主要城市和高速公路。以下是创建基本地图的代码，我们将在接下来的章节中在此基础上进行构建：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Most of this code likely looks familiar from other simple maps. We''ll add
    to it soon but you can already spot signs that this code is looking ahead: I included
    *jQuery* ❶, a JavaScript framework that makes applying effects and using Ajax
    to retrieve data easy. I also set `center` ❷ and `zoom` ❸ variables globally,
    so we''ll be able to return users to the original view after zooming in.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的大部分内容可能看起来与其他简单地图相似。我们很快就会添加更多内容，但你已经可以看到这个代码有前瞻性的迹象：我包含了*jQuery* ❶，这是一个使应用效果和使用Ajax检索数据变得容易的JavaScript框架。我还全局设置了`center`
    ❷和`zoom` ❸变量，这样我们就可以在放大后返回用户到原始视图。
- en: The basic map, as seen in [Figure 10-2](ch10s02.html#basic_us_weather_map "Figure 10-2. Basic
    US weather map"), is now ready for markers. Before we can plot the weather conditions
    on the map, however, we'll need some data in an accessible format.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 基本地图，如图10-2所示，现在可以添加标记。然而，在我们能够在地图上绘制天气条件之前，我们需要一些可访问格式的数据。
- en: '![Basic US weather map](httpatomoreillycomsourcenostarchimages672113.png.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![基本的美国天气图](httpatomoreillycomsourcenostarchimages672113.png.jpg)'
- en: Figure 10-2. Basic US weather map
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2. 基本美国天气图
- en: Convert Weather Results to JSON
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将天气结果转换为JSON
- en: To make our map a mashup, we need some data, specifically current weather condition
    data. Yahoo! has an easy-to-use weather API that accepts a postal code or a proprietary
    location identifier. The result comes as GeoRSS, which is a plaintext XML file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的地图成为一个混合体，我们需要一些数据，特别是当前的天气状况数据。Yahoo!有一个易于使用的天气API，它接受邮政编码或专有位置标识符。结果以GeoRSS形式出现，这是一个纯文本XML文件。
- en: 'Let''s look at an example call to the Yahoo! Weather API. To get the current
    conditions and forecast for Minneapolis, Minnesota, we fetch this URL: [http://weather.yahooapis.com/forecastrss?p=USMN0503](http://weather.yahooapis.com/forecastrss?p=USMN0503).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看对Yahoo!天气API的一个示例调用。为了获取明尼苏达州明尼阿波利斯市的当前条件和预报，我们获取这个URL：[http://weather.yahooapis.com/forecastrss?p=USMN0503](http://weather.yahooapis.com/forecastrss?p=USMN0503)。
- en: The bold portion of the URL is the location ID. The API will also accept a postal
    code, but in this example, we'll use the ID. When we plot the conditions on the
    map, I'll explain where to get the location IDs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: URL中的粗体部分是位置ID。API也可以接受邮政编码，但在这个例子中，我们将使用ID。当我们把条件绘制在地图上时，我会解释如何获取位置ID。
- en: 'If you visit this URL, the result will look similar to this abbreviated version
    of the XML that is returned:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问这个URL，结果将类似于以下XML缩略版本的返回结果：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Not to be too picky about the format of free data, but parsing XML with JavaScript
    can be troublesome, as I discussed in [#52: Use XML](ch08.html#number_symble_52_colon_use_xml
    "#52: Use XML") in [#52: Use XML](ch08.html#number_symble_52_colon_use_xml "#52:
    Use XML"). Many APIs now offer JavaScript Object Notation (JSON), a format that
    can be immediately plugged into JavaScript. Yahoo! Weather only provides XML,
    but another Yahoo! product can convert the data for us.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '对于免费数据的格式不必过于挑剔，但正如我在[第52节：使用XML](ch08.html#number_symble_52_colon_use_xml
    "#52: Use XML")中讨论的那样，使用JavaScript解析XML可能会有点麻烦。许多API现在提供JavaScript对象表示法（JSON），这是一种可以直接插入JavaScript的格式。Yahoo!天气只提供XML，但另一个Yahoo!产品可以为我们转换数据。'
- en: Yahoo! Pipes can perform many complex operations to merge, filter, and sort
    data. In this example, we won't be pushing the boundaries. All we want to do is
    read in XML from the API and output JSON. This is easy using Pipes. You could
    also use Yahoo! Query Language or run the XML through a process on your server.
    I'll show the second method in a project later in this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Yahoo! Pipes可以执行许多复杂的操作来合并、过滤和排序数据。在这个例子中，我们不会触及边界。我们只想从API读取XML并输出JSON。使用Pipes很容易做到这一点。你也可以使用Yahoo!查询语言或在你的服务器上运行XML处理。我将在本章后面的项目中展示第二种方法。
- en: Create a New Pipe
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个新的管道
- en: 'Because all we have to do is convert from XML to JSON, we''ll be creating about
    as simple a pipe as we can make. You can see a more in-depth version of this example
    in [#57: Convert from XML to JSON](ch08s06.html "#57: Convert from XML to JSON")
    in [#57: Convert from XML to JSON](ch08s06.html "#57: Convert from XML to JSON"),
    where you''ll also find more advanced uses for Pipes.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '因为我们只需要将XML转换为JSON，我们将创建尽可能简单的管道。你可以在[第57节：从XML转换为JSON](ch08s06.html "#57:
    Convert from XML to JSON")中看到这个例子的更深入版本，在那里你也会找到Pipes的更多高级用法。'
- en: From the Pipes home page at [http://pipes.yahoo.com/](http://pipes.yahoo.com/),
    click **Create a Pipe** to get a brand new, empty pipe. On the left, you'll see
    pieces of "plumbing" that you can use. Drag a **Fetch Feed Source** to the workspace.
    This point is where the data will flow in.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从[Pipes首页](http://pipes.yahoo.com/)，点击**创建管道**以获取一个全新的、空的管道。在左侧，你会看到你可以使用的“管道”组件。将一个**获取源**拖到工作区。这是数据流入的点。
- en: What is the feed's URL? We'll be making several calls to the Weather API, one
    for each city we want to look up. The calls will be routed through Pipes, which
    means the feed URL cannot be static. To accept input to the pipe, drag a **Text
    Input** to the workspace. Name the input **location**, and set the prompt to something
    like, **Enter a location**. For default and debug values, use your postal code
    or city name. You could also use a location ID, such as the one for Minneapolis,
    **USMN0503**. This helps you confirm the pipe is working.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那个馈送的 URL 是什么？我们将对天气 API 进行多次调用，一次针对我们想要查询的每个城市。这些调用将通过管道路由，这意味着馈送 URL 不能是静态的。为了接受管道的输入，将一个**文本输入**拖到工作区。将输入命名为**位置**，并将提示设置为类似于**输入一个位置**的内容。对于默认和调试值，可以使用你的邮政编码或城市名称。你也可以使用位置
    ID，例如明尼阿波利斯的 ID，**USMN0503**。这有助于你确认管道是否正常工作。
- en: 'Now that you''ve set up the text input to provide a location value, you''re
    ready to create the URL. To merge the static and dynamic portions of the URL,
    we''ll use one final piece of piping. Drag a **String Builder** to the workspace.
    For a first value, add the beginning of the Weather API URL: [http://weather.yahooapis.com/forecastrss?p=](http://weather.yahooapis.com/forecastrss?p=).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了文本输入以提供位置值，你准备好创建 URL 了。为了合并 URL 的静态和动态部分，我们将使用最后一部分管道。将一个**字符串构建器**拖到工作区。作为第一个值，添加天气
    API URL 的开头：[http://weather.yahooapis.com/forecastrss?p=](http://weather.yahooapis.com/forecastrss?p=)。
- en: Drag the output of the **Text Input** to the second value of the **String Builder**.
    This action will append the location ID to the end of the call to the Weather
    API. Now you have a complete feed URL. Drag the output of the **String Builder**
    to the **Fetch Feed URL** line. Finally, drag the **Fetch Feed** output to the
    **Pipe Output** at the bottom of the workspace.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将**文本输入**的输出拖到**字符串构建器**的第二个值。这个动作会将位置 ID 添加到对天气 API 的调用末尾。现在你有一个完整的馈送 URL。将**字符串构建器**的输出拖到**获取馈送
    URL**行。最后，将**获取馈送**的输出拖到工作区底部的**管道输出**。
- en: You've just created a Yahoo! Pipe! The final product should look something like
    [Figure 10-3](ch10s02.html#complete_yahoo_exclamation_pipe_to_retri "Figure 10-3. Complete
    Yahoo! Pipe to retrieve weather data"). At the bottom of the screen in the Debug
    Output section, you should see some sample results based on the location you entered
    as the debug value for the Text Input.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建了一个 Yahoo! Pipe！最终产品应该看起来像[图10-3](ch10s02.html#complete_yahoo_exclamation_pipe_to_retri
    "图10-3. 完整的 Yahoo! Pipe 用于获取天气数据")。在屏幕底部的调试输出部分，你应该能看到一些基于你输入的文本输入调试值的样本结果。
- en: 'To use your pipe, you need to save it. Once you''ve saved it, you can run it
    to retrieve more example results by entering different locations. From the sample
    results screen, click **Get as JSON**. You may need to right-click (ctrl-click
    on Mac) and copy the link. The Pipes URL will look something like this: [http://pipes.yahoo.com/pipes/pipe.run?_id=sGDQu...&_render=json&location=USMN0503](http://pipes.yahoo.com/pipes/pipe.run?_id=sGDQu...&_render=json&location=USMN0503).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用你的管道，你需要保存它。一旦保存，你就可以通过输入不同的位置来运行它以获取更多示例结果。从样本结果屏幕，点击**获取 JSON**。你可能需要右键单击（在
    Mac 上按住 Ctrl 键单击）并复制链接。Pipes URL 将类似于这样：[http://pipes.yahoo.com/pipes/pipe.run?_id=sGDQu...&_render=json&location=USMN0503](http://pipes.yahoo.com/pipes/pipe.run?_id=sGDQu...&_render=json&location=USMN0503)。
- en: '![Complete Yahoo! Pipe to retrieve weather data](httpatomoreillycomsourcenostarchimages672115.png.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![完整的 Yahoo! Pipe 用于获取天气数据](httpatomoreillycomsourcenostarchimages672115.png.jpg)'
- en: Figure 10-3. Complete Yahoo! Pipe to retrieve weather data
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-3. 完整的 Yahoo! Pipe 用于获取天气数据
- en: 'This URL will retrieve the weather conditions for Minneapolis in JSON format.
    Here is an abbreviated version of what it returns:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 URL 将以 JSON 格式检索明尼阿波利斯的天气状况。以下是它返回的简略版本：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That URL is what we'll use to get weather conditions for several cities, replacing
    the Minneapolis-specific location ID. In fact, that's what we're ready to do now
    that we've converted the XML results to JSON.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 URL 是我们将用来获取几个城市的天气状况，并替换明尼阿波利斯特定的位置 ID。实际上，这正是我们在将 XML 结果转换为 JSON 后要做的。
- en: Plot Conditions on the Map
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在地图上绘制条件
- en: With our JSON feed ready to go, let's dive into the JavaScript to retrieve the
    weather conditions and plot them on our US map. First, you need to decide which
    cities to plot. I chose 11 prominent places, focusing on geographic diversity.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 JSON 数据源已经准备好了，现在让我们深入 JavaScript 来获取天气状况并将它们绘制在我们的美国地图上。首先，你需要决定要绘制哪些城市。我选择了11个具有代表性的地方，注重地理多样性。
- en: 'To gather the location IDs for my cities, I went to [http://weather.yahoo.com/](http://weather.yahoo.com/)
    and typed each city name into the search box. The result forwards to a URL like
    this: [http://weather.yahoo.com/forecast/USMN0503.html](http://weather.yahoo.com/forecast/USMN0503.html).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了收集我城市的地点ID，我去了[http://weather.yahoo.com/](http://weather.yahoo.com/)并在搜索框中输入每个城市的名称。结果会转发到一个类似这样的URL：[http://weather.yahoo.com/forecast/USMN0503.html](http://weather.yahoo.com/forecast/USMN0503.html)。
- en: 'The part of the filename without the extension, the bold portion, is the location
    ID. Once I had the IDs for all of my cities, I created a variable at the top of
    my JavaScript to hold the values:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名中不带扩展名的那部分，即粗体部分，是位置ID。一旦我有了所有城市的ID，我在JavaScript顶部创建了一个变量来保存这些值：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `weatherids` variable is an array, which holds a list of values. I spread
    the variable declaration over several lines to improve readability and make adding
    or removing cities easy. The city names are comments, so you can easily tell which
    location ID corresponds to which city.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`weatherids`变量是一个数组，它包含一系列值。我将变量声明分散到多行，以提高可读性并使添加或删除城市变得容易。城市名称是注释，因此你可以轻松地知道哪个位置ID对应哪个城市。'
- en: 'When the map loads, we want to cycle through each city and look it up in our
    piped version of the Yahoo! Weather API. Add this loop code to the `create_map`
    function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当地图加载时，我们想要遍历每个城市并在我们的Yahoo!天气API管道版本中查找它。将此循环代码添加到`create_map`函数中：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The variable `i` holds the index of the array, which begins at zero and counts
    up to 10 (Nashville, the 11th item in the array). Each time through the loop,
    we create a URL to call our pipe using the location ID value of the current weather
    station.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`i`持有数组的索引，它从零开始，数到10（数组中的第11项是纳什维尔）。每次循环时，我们都会创建一个URL来调用我们的管道，使用当前天气站的地点ID值。
- en: To fetch the JSON from our pipe, we use jQuery, a small JavaScript framework.
    When we set up the basic map previously, we included a reference to the jQuery
    file, so we're all set; most of the work of creating the Ajax call is done for
    us by jQuery's `getJSON` function with the URL we just created.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的管道中获取JSON，我们使用jQuery，一个小的JavaScript框架。当我们之前设置基本地图时，我们包括了jQuery文件的引用，所以我们已经准备好了；创建Ajax调用的大部分工作都由jQuery的`getJSON`函数和刚刚创建的URL为我们完成。
- en: In addition to the `location` parameter, we add a new argument to the URL, `_callback=?`.
    This security feature lets us get JSON from a site other than our own. Yahoo!
    Pipes will wrap the results so only our callback function has access to the data.
    The question mark is a holding place for the function, which we pass along as
    the second parameter for `getJSON`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`location`参数外，我们还在URL中添加了一个新参数，`_callback=?`。这个安全特性让我们可以从除我们自己的网站之外的网站获取JSON。Yahoo!
    Pipes会将结果包装起来，这样只有我们的回调函数才能访问数据。问号是一个占位符，用于我们作为`getJSON`的第二个参数传递的函数。
- en: 'When jQuery gets results from the Weather API, those results are passed to
    our `add_weather` function, which we now need to write:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当jQuery从天气API获取结果时，这些结果会被传递给我们的`add_weather`函数，我们现在需要编写这个函数：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The JSON data is automatically passed as a parameter to our callback function.
    In this case, I've used a variable called `data` to hold the response from the
    pipe. The weather conditions we want to get at are inside the first result of
    an array called `items`, which is itself inside an object named `value`. Sure,
    we've got some unnecessary overhead, but these are XML remnants.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: JSON数据会自动作为参数传递给我们的回调函数。在这种情况下，我使用了一个名为`data`的变量来保存管道的响应。我们想要获取的天气条件在名为`items`的数组的第一个结果中，而`items`本身又在一个名为`value`的对象中。是的，我们有一些不必要的开销，但这些是XML残留物。
- en: The main data we need is latitude, longitude, and description. Wherever possible,
    I use JavaScript dot notation like `item.description`. Several field names in
    this feed contain a colon, which would be interpreted incorrectly with dot notation.
    In this case, I use the bracket notation to retrieve the properties from `item`
    instead.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的主要数据是纬度、经度和描述。尽可能的情况下，我使用JavaScript点表示法，如`item.description`。在这个数据源中，有几个字段名包含冒号，这在使用点表示法时会被错误地解释。在这种情况下，我使用括号表示法从`item`中检索属性。
- en: Every weather condition has a numbered code that matches a particular description.
    The number allows machines to interpret a forecast easily without needing to parse
    text. The code is also used by Yahoo! Weather to call up the image designated
    for each condition. For example, a code of 30 means the sky is partly cloudy.
    The corresponding graphic is stored at [http://l.yimg.com/a/i/us/we/52/30.gif](http://l.yimg.com/a/i/us/we/52/30.gif).
    I piece together this image URL into the `imgsrc` variable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每种天气状况都有一个与特定描述匹配的编号代码。数字允许机器轻松地解释预报，而无需解析文本。该代码也由 Yahoo! 天气用于调用为每种状况指定的图像。例如，代码
    30 表示天空部分多云。相应的图形存储在 [http://l.yimg.com/a/i/us/we/52/30.gif](http://l.yimg.com/a/i/us/we/52/30.gif)。我将此图像
    URL 拼接到 `imgsrc` 变量中。
- en: 'Once we have the data we need, we wrap it inside an object with curly braces
    and pass it off to the `add_marker` function to do the work of plotting this marker
    on the map:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了所需的数据，我们就将其包裹在一个带有花括号的对象中，并将其传递给 `add_marker` 函数来完成在地图上绘制此标记的工作：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Why did I pass the data as a JavaScript object (the `options` variable) instead
    of individual parameters? You could use parameters, but four parameters would
    be a lot to pass along to a function. Every time we called it, we would need to
    double-check the order. Is description third or fourth? Also, JavaScript objects
    are commonly used to share data between JavaScript functions, so using them is
    good practice.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我传递数据为 JavaScript 对象（`options` 变量）而不是单独的参数？你可以使用参数，但四个参数传递给函数会很多。每次调用它时，我们都需要检查顺序。描述是第三个还是第四个？此外，JavaScript
    对象通常用于在 JavaScript 函数之间共享数据，因此使用它们是良好的实践。
- en: The rest of the `add_marker` function creates a straight-forward custom marker.
    The only line that might look strange is the shadow icon ❶, which I want to be
    empty. Because a shadowless marker is not an option, I used one transparent pixel
    for the shadow icon.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_marker` 函数的其余部分创建了一个简单的自定义标记。唯一可能看起来奇怪的行是阴影图标 ❶，我希望它是空的。因为没有无阴影标记的选项，所以我使用了一个透明的像素作为阴影图标。'
- en: 'Now we have all the pieces to plot the conditions for our list of cities. Put
    them together and you have a complete weather map, with a little graphical representation
    of the current weather hovering above each city. Here''s a brief recap of everything
    that happens as the mashup loads:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了绘制我们城市列表状况的所有部件。将它们组合起来，你就有了一个完整的天气地图，每个城市上方都有当前天气的简略图形表示。以下是混合体加载时发生的所有事情的简要回顾：
- en: The HTML page is loaded, the `create_map` function is called, which sets up
    the basic map and calls the `get_weather` function for each location ID in the
    `weatherids` array.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTML 页面加载后，调用 `create_map` 函数，该函数设置基本地图并为 `weatherids` 数组中的每个位置 ID 调用 `get_weather`
    函数。
- en: The JSON is retrieved from the Yahoo! Pipe, the data gets passed to the `add_weather`
    function.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSON 数据是从 Yahoo! Pipe 中检索的，数据被传递到 `add_weather` 函数。
- en: The important bits get extracted from the JSON into a JavaScript object, which
    is itself passed to the `add_marker` function.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重要信息从 JSON 中提取到 JavaScript 对象中，该对象本身被传递到 `add_marker` 函数。
- en: Custom markers are created and placed on the map.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并放置在地图上的自定义标记。
- en: Now let's make this mashup a little more interactive. When the user clicks a
    marker, the map will zoom in on the forecast details for that location.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使这个混合体更具交互性。当用户点击标记时，地图将放大显示该位置的预报详情。
- en: Add a Forecast Details Pane
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加预报详情面板
- en: A visual representation of current conditions is great, but we cannot show much
    content from the Weather API. In this section, we'll add a Forecast Details pane.
    For added interactivity, we'll make the pane appear when the user clicks a marker,
    as shown in [Figure 10-4](ch10s02.html#forecast_pane_for_our_weather_map "Figure 10-4. Forecast
    pane for our weather map").
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当前条件的视觉表示很棒，但我们无法从天气 API 中展示太多内容。在本节中，我们将添加一个预报详情面板。为了增加交互性，当用户点击标记时，面板将出现，如图
    [图 10-4](ch10s02.html#forecast_pane_for_our_weather_map "图 10-4. 我们天气地图的预报面板")
    所示。
- en: '![Forecast pane for our weather map](httpatomoreillycomsourcenostarchimages672117.png.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![我们天气地图的预报面板](httpatomoreillycomsourcenostarchimages672117.png.jpg)'
- en: Figure 10-4. Forecast pane for our weather map
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-4. 我们天气地图的预报面板
- en: 'To start, we need to add the HTML shell for the new content. Right below the
    map `div`, add this line:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为新内容添加 HTML 壳。在地图 `div` 下方添加此行：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Like the map, the shell is empty. We''ll use JavaScript to load it with content.
    Because we want to overlay the forecast details on the map itself, we''ll use
    CSS to position the new `div`. In the `<style>` section of the header, add these
    lines:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 就像地图一样，外壳是空的。我们将使用JavaScript来填充它。因为我们想在地图本身上叠加预报详情，所以我们将使用CSS来定位新的`div`。在页眉的`<style>`部分添加以下行：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This CSS creates a thin, tall, white box to the right side of the map. In fact,
    save your file, load it in a browser, and from Michigan east will be obscured
    with the box. That's certainly not what we want. We want the forecast pane only
    to show up when a city is selected. By default, we'll need to hide it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此CSS在地图右侧创建了一个细长的白色框。实际上，保存你的文件，在浏览器中加载它，从密歇根州向东将会被这个框遮挡。这显然不是我们想要的。我们只想在选中城市时显示预报面板。默认情况下，我们需要将其隐藏。
- en: 'We can do that by adding this one line of jQuery to the `create_map` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`create_map`函数中添加这一行jQuery来实现这一点：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we call the jQuery `hide` function on the forecast `div`. When the map
    is first loaded, the pane will be hidden, waiting for a user to click.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用jQuery的`hide`函数在预报`div`上。当地图首次加载时，面板将被隐藏，等待用户点击。
- en: Now we can use Mapstraction to fill the Forecast Details pane with content.
    Rather than creating infoBubbles when a marker is clicked, we'll instead call
    `setInfoDiv` with the forecast data from the API.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用Mapstraction来填充预报详情面板的内容。当标记被点击时，我们不会创建infoBubbles，而是使用API中的预报数据调用`setInfoDiv`。
- en: 'First, we actually need to get at that data. An entire description of the current
    conditions plus a forecast is passed from the Weather API in the description field.
    We need a fifth variable in the `add_weather` function. After the `imgsrc` line,
    add this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实际上需要获取那些数据。整个当前条件的描述以及预报都通过Weather API的描述字段传递。在`add_weather`函数中，我们需要第五个变量。在`imgsrc`行之后添加：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now you''ll alter the call to `add_marker` by adding another option to the
    passed object:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将通过向传递的对象中添加另一个选项来修改对`add_marker`的调用：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then you''ll use the new value inside the `add_marker` function. Add this line
    before the call to `addMarker`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将在`add_marker`函数内部使用新值。在调用`addMarker`之前添加这一行：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we set the Forecast Details pane to contain the description ❶ from the
    API, plus a clickable US map image ❷ that calls a new JavaScript function to return
    the map to the center and clear the Forecast Details pane. How does Mapstraction
    know which `div` to use? We pass its `id` as the second variable ❸.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将预报详情面板设置为包含API中的描述❶，以及一个可点击的美国地图图像❷，该图像调用一个新的JavaScript函数以返回地图到中心并清除预报详情面板。Mapstraction如何知道使用哪个`div`？我们通过将其`id`作为第二个变量❸传递。
- en: 'To see the Forecast Details pane in action, we need to write code to show the
    hidden `div` when a marker is clicked. Add this line after the call to `addMarker`,
    as we''ll be working with the marker object we''ve just created:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看预报详情面板的实际效果，我们需要编写代码在标记被点击时显示隐藏的`div`。在调用`addMarker`之后添加此行，因为我们将与刚刚创建的标记对象一起工作：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we are listening for a click event on a marker and then responding with
    a function reference. Let''s write the `marker_clicked` function, which will be
    called whenever any of our markers is clicked:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在监听一个标记上的点击事件，然后通过函数引用进行响应。让我们编写`marker_clicked`函数，该函数将在我们任何标记被点击时被调用：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When any marker is clicked, we set it to the center of the map and zoom in ❹.
    We use the clicked marker's location as the center, which comes to the function
    via the `event_source` argument. Then, to account for the Forecast Details pane
    on the right side of the map, we shift the map center to the west ❺, so the marker
    will appear centered in the visible portion of the map. Finally, we make sure
    the Forecast Details pane is visible ❻.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何标记被点击时，我们将它设置为地图的中心并放大❹。我们使用被点击标记的位置作为中心，该位置通过`event_source`参数传递给函数。然后，为了考虑到地图右侧的预报详情面板，我们将地图中心向西移动❺，这样标记就会出现在地图可见部分的中心。最后，我们确保预报详情面板是可见的❻。
- en: Save your file and load it in a browser. Now you should be able to click a marker
    and zoom in to see the forecast. The only piece that isn't connected is the ability
    to zoom back out and see the whole contiguous United States again. To do this,
    we'll need to write the `return_center` function called whenever you click the
    US map.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的文件并在浏览器中加载它。现在你应该能够点击一个标记并放大以查看预报。唯一没有连接的部分是能够缩回到整个连续的美国地图。为此，我们需要编写一个`return_center`函数，该函数将在你点击美国地图时被调用。
- en: 'Add this function to the JavaScript section:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将此函数添加到JavaScript部分：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This housekeeping function returns the map to its original center and zoom level
    and then hides the Forecast Details pane. Now we can see the whole US map again.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个维护函数将地图返回到其原始中心和缩放级别，然后隐藏预报详情面板。现在我们又能看到整个美国地图了。
- en: With the house cleaned, the mashup is complete. You pulled in data from Yahoo!
    Weather using Yahoo! Pipes to convert to JSON. Then you displayed the conditions
    for several cities, along with a descriptive graphic, on a map. Finally, upon
    clicking the marker, you zoomed the map into the city and displayed the forecast
    in its own overlaid info pane.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 房子打扫干净后，混合应用就完成了。你使用Yahoo! Pipes从Yahoo!天气中提取数据，并将其转换为JSON。然后你在地图上显示几个城市的条件，以及一个描述性的图形。最后，点击标记后，你将地图缩放到城市，并在自己的叠加信息面板中显示预报。
- en: The best part, of course, is that you no longer need to read the weather page
    in the newspaper. You have an online, always-updating replacement.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最好的部分是，你再也不需要阅读报纸上的天气页面了。你有一个在线的、始终更新的替代品。
- en: '#70: Display Recent Earthquakes Worldwide'
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#70: 显示全球最近地震'
- en: Are you an aspiring geologist? Or maybe you're just looking for a quick way
    to see what's shaking in the world? In this mashup, I'll show you how to use a
    public data source to make sense of the world around you. We'll plot a week's
    worth of earthquakes, as tallied by the United States Geological Survey (USGS).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你是一个有抱负的地质学家吗？或者你可能只是想找一个快速查看世界上发生什么震动的方法？在这个混合应用中，我将向你展示如何使用公共数据源来理解你周围的世界。我们将绘制美国地质调查局（USGS）统计的一周内的地震。
- en: Lucky for us, the USGS logs earthquake data not just for the United States,
    but for the whole world. Even luckier for us, they're hip to the latest data formats.
    The organization publishes an XML feed that is geographically encoded as GeoRSS.
    It covers earthquakes that register 2.5 or greater on the Richter scale. That
    should still give us plenty of earthquakes to reveal some interesting trends on
    our map, as shown in [Figure 10-5](ch10s03.html#map_showing_recent_earthquakes_by_magnit
    "Figure 10-5. Map showing recent earthquakes by magnitude").
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，美国地质调查局不仅记录美国的地震数据，还记录了全球的地震数据。更幸运的是，他们熟悉最新的数据格式。该组织发布了一个地理编码为GeoRSS的XML数据流。它涵盖了里氏震级2.5或以上的地震。这应该仍然给我们提供足够的地震数据，以便在我们的地图上揭示一些有趣的趋势，如图10-5所示。
- en: '![Map showing recent earthquakes by magnitude](httpatomoreillycomsourcenostarchimages672119.png.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![显示最近地震震级的地图](httpatomoreillycomsourcenostarchimages672119.png.jpg)'
- en: Figure 10-5. Map showing recent earthquakes by magnitude
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-5. 显示最近地震震级的地图
- en: 'You can load the feed into a web browser to view the content directly: [http://earthquake.usgs.gov/eqcenter/catalogs/7day-M2.5.xml](http://earthquake.usgs.gov/eqcenter/catalogs/7day-M2.5.xml).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将数据流加载到网络浏览器中直接查看内容：[http://earthquake.usgs.gov/eqcenter/catalogs/7day-M2.5.xml](http://earthquake.usgs.gov/eqcenter/catalogs/7day-M2.5.xml)。
- en: 'Many browsers will display a "pretty" version by default. View its source to
    get a glimpse at all the data it sends along with it. Here is an abbreviated version
    of the XML file from the USGS:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 许多浏览器默认会显示一个“美观”版本。查看其源代码，以了解它发送的所有数据。以下是USGS的XML文件的简略版本：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That's some good stuff. Let's start using that data on our maps. First, we'll
    automatically parse GeoRSS, a feature that Mapstraction makes look easy. Then,
    if that basic visualization isn't enough, we'll create a completely custom solution.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些很好的内容。让我们开始在我们的地图上使用这些数据。首先，我们将自动解析GeoRSS，这是Mapstraction使它看起来很容易实现的功能。然后，如果基本的可视化还不够，我们将创建一个完全定制的解决方案。
- en: Show Earthquakes with GeoRSS
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GeoRSS显示地震
- en: Okay, you've chosen the quick version. You simply want to see these earthquakes
    get tossed up on a map. And you want to see this done using the fewest lines of
    code possible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你已经选择了快速版本。你只想看到这些地震被扔在地图上。你希望用尽可能少的代码来实现这一点。
- en: 'Add these very few lines to a new HTML file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将这几行代码添加到一个新的HTML文件中：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As always, remember to use your own API key. Otherwise, the code is ready to
    go. Save and load it in a browser to see something similar to [Figure 10-6](ch10s03.html#earthquakes_shown_with_direct_georss_ove
    "Figure 10-6. Earthquakes shown with direct GeoRSS overlay"). The actual location
    of the markers will differ based on the past week's geological activity.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，记得使用你自己的API密钥。否则，代码就准备好了。在浏览器中保存和加载它，可以看到类似于图10-6的显示。标记的实际位置将根据过去一周的地质活动而有所不同。
- en: '![Earthquakes shown with direct GeoRSS overlay](httpatomoreillycomsourcenostarchimages672121.png.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![使用直接GeoRSS叠加显示的地震](httpatomoreillycomsourcenostarchimages672121.png.jpg)'
- en: Figure 10-6. Earthquakes shown with direct GeoRSS overlay
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-6. 使用直接GeoRSS叠加显示的地震
- en: Did you catch all those zeroes on the line where we set the center and zoom
    ❶? Those aren't typos. A latitude of zero is the equator. A longitude of zero
    is roughly the international dateline, running through London. Finally, a zoom
    level of zero shows the whole world.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到了我们设置中心和缩放时线上的所有零❶？这些不是打字错误。纬度为零是赤道。经度为零大约是国际日期变更线，穿过伦敦。最后，缩放级别为零显示整个世界。
- en: The money line, which loads the earthquake data, is shown in bold. Mapstraction's
    `addOverlay` function does most of the work. It creates dozens of markers and
    even adds infoBubble content to them. Unfortunately, the fun stops here. Once
    we outsource all that work to a single function, we've handcuffed our ability
    to make exactly what we want.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 加载地震数据的“金钱线”被加粗显示。Mapstraction的`addOverlay`函数做了大部分工作。它创建了数十个标记，甚至为它们添加了infoBubble内容。不幸的是，乐趣在这里就结束了。一旦我们将所有这些工作外包给一个单独的函数，我们就限制了制作我们想要的确切内容的能力。
- en: To give this earthquake map our personal touches, we need to get deeper into
    the code. We need to go custom.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给这个地震地图添加个人风格，我们需要更深入地研究代码。我们需要定制化。
- en: Create a Custom Earthquake Map
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义地震地图
- en: If all you want to do is visualize where earthquakes are, using Mapstraction's
    built-in GeoRSS support gets the job done easily. On the other hand, if you want
    to prefilter content or show different icons based on quake intensity, you'll
    need a more custom solution.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想可视化地震的位置，使用Mapstraction的内置GeoRSS支持可以轻松完成任务。另一方面，如果您想预先过滤内容或根据地震强度显示不同的图标，您将需要一个更定制化的解决方案。
- en: In this section, I'll show you how to convert the GeoRSS to JSON using Yahoo!
    Query Language. Then you'll choose a marker icon based on the earthquake's Richter
    value. Finally, you'll get extra clever and zoom in on zones that usually have
    considerable earthquake activity.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示如何使用Yahoo!查询语言将GeoRSS转换为JSON。然后您将根据地震的里氏值选择一个标记图标。最后，您将变得更加聪明，并放大通常有相当多地震活动的区域。
- en: To start, you need a basic view of the world on the map.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要在地图上有一个基本的世界视图。
- en: Prepare Basic World Map
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备基本世界地图
- en: The basic map of the world doesn't need to be much different from the map in
    the GeoRSS version of the earthquake mapper. We need to load the map and then
    set a center and zoom level.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 世界的基本地图不需要与地震映射器的GeoRSS版本中的地图有很大不同。我们需要加载地图，然后设置中心和缩放级别。
- en: 'Add the following code to a new HTML file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到一个新的HTML文件中：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Save the file, load it into a browser, and you'll see a markerless map of the
    world, like [Figure 10-7](ch10s03.html#empty_map_of_the_world_comma_waiting_for
    "Figure 10-7. Empty map of the world, waiting for markers"). I've made a few changes
    to the code to look ahead as we customize the map. For one, I included jQuery
    ❶, the JavaScript framework that makes applying effects and using Ajax to retrieve
    data easy.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，将其加载到浏览器中，您将看到一个没有标记的世界地图，就像[图10-7](ch10s03.html#empty_map_of_the_world_comma_waiting_for
    "图10-7. 空的世界地图，等待标记")所示。我已经对代码做了一些修改，以便我们在定制地图时提前做好准备。其中之一是包括了jQuery❶，这是一个JavaScript框架，它使得应用效果和使用Ajax检索数据变得容易。
- en: '![Empty map of the world, waiting for markers](httpatomoreillycomsourcenostarchimages672123.png.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![空的世界地图，等待标记](httpatomoreillycomsourcenostarchimages672123.png.jpg)'
- en: Figure 10-7. Empty map of the world, waiting for markers
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-7. 空的世界地图，等待标记
- en: I created an object variable to hold the default location and zoom level ❷,
    rather than individual variables. The values I chose were based on guessing and
    then checking to find a good location where the entire world would be visible
    and the location of the earthquakes would make the most sense. Because a world
    map is a two-dimensional view of a three-dimensional object, problems can crop
    up with where markers and polylines wrap. I chose the center of our basic map
    so our hotspot regions are completely within view globally.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个对象变量来保存默认的位置和缩放级别❷，而不是单独的变量。我选择这些值是基于猜测然后检查，以找到一个好的位置，使得整个世界都能可见，并且地震的位置最有意义。因为世界地图是三维物体的二维视图，所以可能会出现标记和多边形缠绕的问题。我选择了我们基本地图的中心，这样我们的热点区域在全球范围内都能完全在视野中。
- en: Finally, I created an entire function ❸ to use the default center and zoom values.
    Later with this mashup, we'll zoom into those hotspot regions, but afterward we
    need a way to zoom back to the original center. We might as well reuse code where
    we can.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我创建了一个完整的函数 ❸ 来使用默认的中心和缩放值。稍后，在这个混合应用中，我们将放大那些热点区域，但之后我们需要一种方式来将缩放回原始中心。我们不妨重用代码。
- en: Convert Earthquake Data to JSON
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将地震数据转换为 JSON
- en: Now that the basic map is set up, we need to start thinking about data. The
    USGS provides an XML feed. JavaScript can parse XML, but we would need to download
    the XML to a server first for security reasons. If we can get the data as JSON,
    our job is so much easier.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本地图已经设置好了，我们需要开始考虑数据。USGS 提供了一个 XML 源。JavaScript 可以解析 XML，但出于安全原因，我们首先需要将
    XML 下载到服务器上。如果我们能以 JSON 格式获取数据，我们的工作就会容易得多。
- en: We have a number of options for converting the earthquake data from XML to JSON.
    In the weather mashup, we used Yahoo! Pipes. In this case, we'll use another Yahoo!
    product, Yahoo! Query Language (YQL). Among many other uses of the technology
    YQL makes converting any GeoRSS feed to JSON easy.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多种将地震数据从 XML 转换为 JSON 的选项。在天气混合应用中，我们使用了 Yahoo! Pipes。在这种情况下，我们将使用另一个 Yahoo!
    产品，即 Yahoo! 查询语言 (YQL)。YQL 技术的许多其他用途中，它使得将任何 GeoRSS 源转换为 JSON 变得非常简单。
- en: 'YQL''s syntax is similar to SQL, the language used to query a database. You
    can try out commands in the YQL console at [http://developer.yahoo.com/yql/console/](http://developer.yahoo.com/yql/console/).
    Instead of querying a database table, we''ll work against the USGS GeoRSS URL
    we used in the previous section. Here''s the query to grab all the data from that
    feed:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: YQL 的语法类似于 SQL，这是查询数据库所使用的语言。您可以在 [http://developer.yahoo.com/yql/console/](http://developer.yahoo.com/yql/console/)
    的 YQL 控制台中尝试命令。我们不会查询数据库表，而是将针对我们在上一节中使用的 USGS GeoRSS URL 进行操作。以下是获取该源所有数据的查询：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Type that command in the YQL console, select the JSON output, and click the
    **Test** button. As shown in [Figure 10-8](ch10s03.html#yql_console_showing_results_from_earthqu
    "Figure 10-8. YQL Console showing results from earthquake feed"), you'll see the
    results in the pane below. If you prefer to see a more structured view, click
    the **Tree View** tab to peruse the data. From there, you can see the items we'll
    have available to us when we load the data into our map.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 YQL 控制台中输入该命令，选择 JSON 输出，并点击 **测试** 按钮。如图 [图 10-8](ch10s03.html#yql_console_showing_results_from_earthqu
    "图 10-8. YQL 控制台显示地震源的结果") 所示，您将在下面的面板中看到结果。如果您更喜欢看到更结构化的视图，请点击 **树视图** 选项卡来浏览数据。从那里，您可以看到当我们将数据加载到地图中时我们将拥有的可用项。
- en: '![YQL Console showing results from earthquake feed](httpatomoreillycomsourcenostarchimages672125.png.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![YQL 控制台显示地震源的结果](httpatomoreillycomsourcenostarchimages672125.png.jpg)'
- en: Figure 10-8. YQL Console showing results from earthquake feed
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-8. YQL 控制台显示地震源的结果
- en: Copy the long URL at the bottom of the console under The REST Query and store
    it somewhere. We'll use that URL in the next section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 复制控制台底部“REST 查询”下的长 URL 并将其存储在某个地方。我们将在下一节中使用该 URL。
- en: Plot Earthquakes on Map
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在地图上绘制地震
- en: As you've seen, simply plotting earthquakes on a map requires a single line
    call to a GeoRSS feed. That's too basic for us, however. The purpose of this mashup
    is to create something more customized. We want to provide a visual way to see
    the intensity of earthquakes at a glance by using bigger icons in places the Richter
    value is higher.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，仅通过调用 GeoRSS 源在地图上绘制地震只需要一行代码。然而，这对我们来说太基础了。这个混合应用的目的是要创建一些更定制化的东西。我们希望通过使用更大图标的方式，在里氏值较高的地方提供一种直观查看地震强度的方法。
- en: 'The following two JavaScript functions will load the data from the YQL JSON
    URL we found in the previous section, determine which icon to use, and plot the
    marker on the world map. Add this code to your basic map following the `create_map`
    function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个 JavaScript 函数将从我们在上一节中找到的 YQL JSON URL 加载数据，确定要使用哪个图标，并在世界地图上绘制标记。请将此代码添加到您的
    `create_map` 函数后的基本地图中：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `get_quakes` function is actually a single line, but it's a really long
    line. It calls the `getJSON` function in jQuery. The JavaScript framework requires
    two variables to retrieve our JSON from YQL. The first is the URL to call. The
    second is a reference to a callback function. I used an anonymous, inline function.
    This callback function is what takes up most of the space in the `get_quakes`
    function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_quakes`函数实际上是一行，但它非常长。它调用jQuery中的`getJSON`函数。JavaScript框架需要两个变量来从YQL检索我们的JSON。第一个是调用的URL。第二个是回调函数的引用。我使用了一个匿名内联函数。这个回调函数占据了`get_quakes`函数的大部分空间。'
- en: The YQL URL ❶ is spread out over a few lines as a single, long string that is
    almost exactly the same as you copied from the YQL console. The only change is
    that the callback argument (the last part of the URL) is a question mark. By including
    a question mark, jQuery replaces it with the callback function for us.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: YQL URL❶被展开成几行作为单个长字符串，几乎与你从YQL控制台复制的内容完全相同。唯一的区别是回调参数（URL的最后一部分）是一个问号。通过包含一个问号，jQuery会为我们替换成回调函数。
- en: Once we have a result, it is passed to the anonymous function as the `data`
    variable, which will be a JavaScript object. Within the object, `data.query.results.entry`
    refers to the array of all earthquake results. Using jQuery's `each` function
    ❷, we iterate through every result. Each earthquake is passed to yet another anonymous
    function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到结果，它就被作为`data`变量传递给匿名函数，它将是一个JavaScript对象。在对象中，`data.query.results.entry`指的是所有地震结果的数组。使用jQuery的`each`函数❷，我们遍历每一个结果。每个地震都被传递给另一个匿名函数。
- en: For each earthquake, we first retrieve the geographic coordinates from the `point`
    value. As you may recall from the USGS XML, both the latitude and longitude are
    stored as a single value, with a space between. Our code splits them into two
    values ❸ and stores the result in an array. The first item in the array (with
    an index of zero) is the latitude; the second is the longitude.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一次地震，我们首先从`point`值中检索地理坐标。如您从USGS XML中回忆起来，纬度和经度都存储为单个值，中间有一个空格。我们的代码将它们分成两个值❸并将结果存储在数组中。数组中的第一个元素（索引为零）是纬度；第二个是经度。
- en: Next, we need to find the Richter value. The *Richter value* is the measurement
    of an earthquake's intensity and is usually given a decimal value less than 10\.
    Unfortunately, the USGS does not directly pass this value, even though it's sitting
    right there in the title. For example, `M 2.6, Washington`. By sucking out a substring
    from the title, we can find the Richter value. In this case, we want 2.6 and nothing
    more.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要找到里氏值。*里氏值*是衡量地震强度的测量值，通常给出小于10的十进制值。不幸的是，USGS并没有直接传递这个值，尽管它就在标题中。例如，`M
    2.6, Washington`。通过从标题中提取子字符串，我们可以找到里氏值。在这种情况下，我们想要2.6，不想要更多。
- en: The Richter value begins at the third character in the string, which is referred
    to as *slot two* because textual strings, like arrays, start counting at zero.
    Then the Richter value continues for three characters. So our call to `substr`
    ❹ begins at slot two and continues three characters. The value of the `richter`
    variable is now 2.6 in this example, just like we wanted.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 里氏值从字符串的第三个字符开始，这被称为*槽位二*，因为文本字符串，就像数组一样，从零开始计数。然后里氏值继续三个字符。因此，我们的`substr`调用❹从槽位二开始，继续三个字符。在这个例子中，`richter`变量的值现在是2.6，正如我们想要的。
- en: With the Richter value in hand, we can determine which icon to use by passing
    it to the `get_icon` function. I selected three levels and created a graphic for
    each of them. If an earthquake is relatively small, less than four, I assign it
    the smallest icon. If the earthquake is between four and five, it gets a medium-sized
    icon. Anything five and greater gets the largest icon. The icons are also colored
    differently among the levels, so the earthquake markers get bigger and redder
    with greater magnitude.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到里氏值后，我们可以通过将其传递给`get_icon`函数来确定使用哪个图标。我选择了三个级别，并为每个级别创建了一个图形。如果地震相对较小，小于四，我分配给它最小的图标。如果地震在四到五之间，它得到一个中等大小的图标。任何五以上的地震都得到最大的图标。这些图标在不同级别上也有不同的颜色，因此地震标记随着震级的增加而变大变红。
- en: Using the latitude/longitude array that we split from the data, we create a
    marker for this earthquake. We give it a custom icon based on the Richter value,
    and then give it no shadow ❺. I used one transparent pixel for the shadow icon
    and set the width and height to be zero. As you'll see, our map will have so many
    earthquakes, we won't have room for shadows.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们从数据中分割出的纬度/经度数组，我们为这次地震创建了一个标记。我们根据里氏值给它一个自定义图标，然后给它不显示阴影 ❺。我使用了一个透明的像素作为阴影图标，并将宽度和高度设置为零。您将看到，我们的地图将包含如此多的地震，以至于我们没有空间为阴影留出位置。
- en: To finish, I added a very simple message inside the infoBubble ❻. The message
    shows the full title, the date, and a link to the page on the USGS site where
    the user can get more information about this earthquake.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我在infoBubble ❻中添加了一条非常简单的信息。这条信息显示了完整的标题、日期以及一个链接，用户可以通过该链接访问USGS网站上的页面，获取更多关于这次地震的信息。
- en: Create a Legend
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建图例
- en: In just a few lines, this map is easier to read than the one generated by the
    GeoRSS. The many earthquakes take up less space because of the smaller markers.
    We have shown that some earthquakes are more noteworthy than others by changing
    the size and color of the icons. Will the map make sense to someone who doesn't
    know the method to our Richter-based madness?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几行代码，这张地图比GeoRSS生成的地图更容易阅读。由于标记较小，许多地震占据的空间更少。我们已经通过改变图标的大小和颜色表明，一些地震比其他地震更有意义。这张地图对不知道我们基于里氏震级方法的某人来说有意义吗？
- en: 'Let''s create a legend, like the one shown in the finished map ([Figure 10-5](ch10s03.html#map_showing_recent_earthquakes_by_magnit
    "Figure 10-5. Map showing recent earthquakes by magnitude")), below the map to
    show what each icon means. Following the map `div`, add this ordered list, which
    describes the different icons:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个图例，就像在完成后的地图([图10-5](ch10s03.html#map_showing_recent_earthquakes_by_magnit
    "图10-5. 显示按震级划分的最近地震的地图"))中显示的那样，在地图下方显示每个图标的意义。在地图`div`之后添加以下有序列表，它描述了不同的图标：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We don''t want the legend to look like an ordered list because that takes up
    too much space. Most of the time, something like this will be shown along one
    line. Enter a little CSS to make it look the way you want. Add this to your stylesheet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望图例看起来像有序列表，因为这会占用太多空间。大多数时候，类似这样的内容会显示在一行中。输入一些CSS来使其看起来符合您的需求。将以下内容添加到您的样式表中：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now the ordered list exists on a single line. Each list item is padded to the
    right, so which icon goes with which description is still obvious. Now that we've
    made it clear what the icons mean, let's add a little interactivity to this map.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有序列表存在于一行中。每个列表项都向右填充，因此哪个图标与哪个描述相对应仍然很明显。既然我们已经清楚地说明了图标的含义，那么让我们给这个地图添加一点交互性。
- en: Zoom to Hotspot Regions
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 放大热点区域
- en: As you can tell from this mashup, some areas of the world are more seismically
    active than others. These spots are fairly predictable regions. Some, like California,
    may be more obvious than others. Due to the clustering of many markers in these
    areas, having a way to zoom in for a better view would be useful.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这次混合体中可以看出，世界上某些地区的地震活动性比其他地区更强。这些区域是相对可预测的区域。有些，比如加利福尼亚，可能比其他地区更明显。由于这些区域有许多标记的聚集，因此有一种方法可以放大以获得更好的视图将会很有用。
- en: 'I identified four of these regions and created a system that makes adding others
    easy. In the variable section of your code, add these lines to create an object
    containing the regions'' boundaries:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我确定了四个这样的区域，并创建了一个系统，使得添加其他区域变得容易。在您的代码变量部分，添加以下行以创建包含区域边界的对象：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At its most basic level, the `regions` variable holds text keys that correspond
    to Mapstraction `BoundingBox` objects. For our purposes, the key is a unique identifier
    for the region. The four numbers used to create the bounds are the minimum necessary
    to describe the region. The first pair describes the southwest corner of the box.
    The second describes the northeast corner. The other two corners of the box can
    be extrapolated from these values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本层面上，`regions`变量包含与Mapstraction `BoundingBox`对象对应的文本键。在我们的用途中，键是区域的唯一标识符。用于创建边界的四个数字是描述该区域所需的最小数字。第一对描述了盒子的西南角。第二对描述了东北角。盒子的其他两个角可以从这些值中推断出来。
- en: As the user mouses around the map, we want to determine when the cursor is hovering
    over one of these regions. If it is, we'll highlight the region by drawing a box
    around it. Then, if the user clicks, we'll zoom in to that region, like in [Figure 10-9](ch10s03.html#zoomed_into_an_earthquake_hotspot_region
    "Figure 10-9. Zoomed into an earthquake hotspot region").
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在地图上移动鼠标时，我们想要确定光标是否悬停在这些区域之一上。如果是，我们将通过围绕它绘制一个框来突出显示该区域。然后，如果用户点击，我们将放大到该区域，就像在[图10-9](ch10s03.html#zoomed_into_an_earthquake_hotspot_region
    "图10-9. 放大到地震热点区域")中所示。
- en: 'To achieve this, we need to listen for two events: mouse moving and clicking.
    Add these lines to your `create_map` function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要监听两个事件：鼠标移动和点击。将这些行添加到你的`create_map`函数中：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first ❶ listens for mouse movement and highlights a region if the mouse
    is within its bounding box. We have to use Google's native `addListener` function,
    because the `mousemove` event is not supported by Mapstraction. An event object
    is passed along to the `check_hover` function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个❶监听鼠标移动，并在鼠标在其边界框内时突出显示区域。我们必须使用谷歌的本地`addListener`函数，因为Mapstraction不支持`mousemove`事件。一个事件对象被传递给`check_hover`函数。
- en: '![Zoomed into an earthquake hotspot region](httpatomoreillycomsourcenostarchimages672127.png.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![放大到地震热点区域](httpatomoreillycomsourcenostarchimages672127.png.jpg)'
- en: Figure 10-9. Zoomed into an earthquake hotspot region
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-9. 放大到地震热点区域
- en: Though we used a little Google-specific code, we are still able to use Mapstraction
    for everything else. The second ❷ event listens for a click somewhere on the map.
    If a region is already highlighted, it zooms in ❸ to give a closer look at the
    quakes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用了少量的谷歌特定代码，但我们仍然能够使用Mapstraction处理其他所有事情。第二个❷事件监听地图上的任何位置的点击。如果某个区域已经被突出显示，它就会❸放大以更仔细地查看地震。
- en: 'Now let''s write the two functions (in bold) that are called from our event
    code. First, we''ll write the code to determine whether the mouse is hovering
    over any of our identified regions. Add this to your JavaScript:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写从我们的事件代码中调用的两个（加粗）函数。首先，我们将编写确定鼠标是否悬停在识别区域上的代码。将此代码添加到你的JavaScript中：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In addition to the `check_hover` function, we also have a helper function. Together,
    this duo determines whether the user is hovering over a region and, if so, which
    region. The `find_region` function does most of this work. It loops through the
    region's array and compares the mouse's latitude/longitude to the four edges of
    the bounding box ❶ using the handy `contains` function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`check_hover`函数外，我们还有一个辅助函数。这两个函数一起确定用户是否悬停在区域上，如果是，是哪个区域。`find_region`函数做了大部分工作。它通过使用方便的`contains`函数将鼠标的纬度/经度与边界框的四条边❶进行比较，遍历区域的数组。
- en: If the user is hovering over a region, the name of the region is returned to
    `check_hover`. Assuming we aren't already highlighting that region❷, we pass the
    name along to the `highlight_region` function, which draws the box. If the mouse
    is not over a region, but one was previously highlighted ❸, then we know the user
    moved the mouse outside of the region. Therefore, we can remove the box from the
    screen ❹.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户悬停在某个区域上，该区域的名称将被返回到`check_hover`。假设我们还没有突出显示该区域❷，我们将名称传递给`highlight_region`函数，该函数绘制框。如果鼠标没有悬停在区域上，但之前已经突出显示❸，那么我们知道用户将鼠标移出了该区域。因此，我们可以从屏幕上移除该框❹。
- en: 'We haven''t created the function to add the box, so we''ll do that now:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有创建添加框的函数，所以我们现在就做：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The process of highlighting is fairly simple, though I have separated it into
    two functions. I have reprinted the second function, `BoundingBox_to_Polyline`,
    from [#19: Draw a Rectangle to Declare an Area](ch04s04.html "#19: Draw a Rectangle
    to Declare an Area") in [#19: Draw a Rectangle to Declare an Area](ch04s04.html
    "#19: Draw a Rectangle to Declare an Area").'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '突出显示的过程相当简单，尽管我已经将其分为两个函数。我已经从[第19节：绘制矩形以声明区域](ch04s04.html "#19: Draw a Rectangle
    to Declare an Area")中重新打印了第二个函数，`BoundingBox_to_Polyline`，在[第19节：绘制矩形以声明区域](ch04s04.html
    "#19: Draw a Rectangle to Declare an Area")。'
- en: The box created in the `highlight_region` function uses a white polyline ❺.
    You may wish to change the polyline to another color. The rest is simply drawing
    the box on the map.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在`highlight_region`函数中创建的框使用白色折线❺。你可能希望将折线颜色改为其他颜色。其余的只是简单地绘制地图上的框。
- en: At this point, as a user moves the mouse around the map, regions will be highlighted.
    Now we need to make something happen when a user clicks while a region is highlighted.
    In other words, we need to set the current region and zoom in, fulfilling the
    second function called by the event listeners.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当用户在地图上移动鼠标时，区域将被突出显示。现在我们需要在用户在突出显示的区域点击时发生某些事情。换句话说，我们需要设置当前区域并放大，以满足事件监听器调用的第二个功能。
- en: 'Add this to your JavaScript:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到您的 JavaScript 中：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Quite simply, if the region exists in our array, we set the map's boundaries
    to include only the selected region. The map zooms in and is centered to show
    the earthquakes in the region.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，如果我们的数组中存在该区域，我们将地图的边界设置为仅包含所选区域。地图会放大并居中显示该区域的地震。
- en: Now we need a way to get back to the world map. Very early on in this mashup,
    we created a `view_world` function. How do we call it? We'll use a graphic of
    the world and call the function whenever the image is clicked.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一种方法回到世界地图。在这个 mashup 的早期阶段，我们创建了一个 `view_world` 函数。我们如何调用它？我们将使用世界地图的图形，并在点击图像时调用该函数。
- en: 'Adding this functionality is something that touches several sections of the
    mashup. So we need to include a few lines in a number of places. First, add the
    graphic to your HTML between the map and the legend:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此功能会影响 mashup 的几个部分。因此，我们需要在多个地方包含几行代码。首先，将图形添加到您的 HTML 中，在地图和图例之间：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can find this image, along with the marker icons I've used in this example
    at [http://mapscripting.com/earthquake-mashup](http://mapscripting.com/earthquake-mashup).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [http://mapscripting.com/earthquake-mashup](http://mapscripting.com/earthquake-mashup)
    找到这张图片，以及我在此示例中使用的标记图标。
- en: 'Next, we need to add some CSS so the graphic appears in the upper-right corner
    of our map:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一些 CSS，以便图形出现在地图的右上角：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s use jQuery to respond to a user clicking the image. Add this code to
    the `create_map` function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 jQuery 来响应用户点击图像。将此代码添加到 `create_map` 函数中：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This retrieves the link element, which surrounds the image using CSS selector
    syntax and tells the browser to call the `view_world` function whenever that object
    is clicked.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过 CSS 选择器语法检索链接元素，并告诉浏览器在点击该对象时调用 `view_world` 函数。
- en: If we weren't picky, we'd stop here. In a perfect world, the clickable graphic
    would only be visible when the map is zoomed in. Let's see if we can't make this
    world a little more perfect, again using some jQuery functions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不挑剔，我们就可以在这里停止。在一个完美的世界中，可点击的图形只有在地图放大时才可见。让我们看看我们是否不能使这个世界更加完美，再次使用一些 jQuery
    函数。
- en: 'Because we want the graphic to disappear whenever we''re viewing the whole
    world, we''ll need to add this line inside the `view_world` function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望图形在我们查看整个世界时消失，所以我们需要在 `view_world` 函数内部添加此行：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The image will now be invisible all the time. Of course, we want it to appear
    when we''ve zoomed in. Inside the `set_region` function, directly under the `setBounds`
    line, we add this line:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图像现在将始终不可见。当然，我们希望它在放大时出现。在 `set_region` 函数中，直接在 `setBounds` 行下方，我们添加此行：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With that, we've incorporated a better interface into our interactive earthquake
    map. Zooming in by region is cool, as long as you can return to the map. We may
    not have made a perfect world, but this world map mashup is close to perfect.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就将一个更好的界面整合到了我们的交互式地震地图中。按区域放大很酷，只要你能够返回到地图。我们可能没有创造一个完美的世界，但这个世界地图 mashup
    几乎是完美的。
- en: We converted USGS data from XML to JSON. Then we read in every earthquake in
    the past week, determined its intensity, and gave it an appropriate icon. Finally,
    we implemented zooming into hotspot regions. The only thing left to do is monitor
    tectonic movements; at least now you have a tool to do that.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 USGS 数据从 XML 转换为 JSON。然后我们读取过去一周内的每一场地震，确定其强度，并给它一个适当的图标。最后，我们实现了热点区域的放大功能。剩下要做的就是监控构造运动；至少现在你有一个工具来做这件事。
- en: '#71: Search Music Events by Location'
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#71：按位置搜索音乐活动'
- en: Want to check out a concert tonight? Where shall we go and who's playing? This
    information is out there. Let's get our hands on it and plot it on a map.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 想要今晚查看一场音乐会吗？我们去哪里，谁在演奏？这些信息都在那里。让我们动手获取它并在地图上绘制。
- en: For this mashup, we'll be using Yahoo!'s Upcoming API. Upcoming is an events
    calendar showing conferences, concerts, user group meetings, and more. We want
    to search only for music, an option made possible by using the API's tag-based
    search.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个混合应用，我们将使用雅虎的Upcoming API。Upcoming是一个显示会议、音乐会、用户组会议等活动的日历。我们只想搜索音乐，这是通过使用基于标签的搜索API实现的选项。
- en: Unless we can count on users all being from the same city, we'll need to provide
    a way to search by location. Lucky us—that's also an option with Upcoming. Because
    some people are willing to drive farther than others, we also want users to be
    able to specify distance. Yep, that option is also supported.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们能确保所有用户都来自同一个城市，否则我们需要提供一种按位置搜索的方法。幸运的是，Upcoming也提供了这个选项。因为有些人愿意比其他人开更远的车，所以我们还希望用户能够指定距离。是的，这个选项也得到了支持。
- en: Some people are more frugal than others. You may be willing to drop $75 to see
    an aging rocker, but I prefer to pay a small cover to see a local band at a bar.
    We'll need to plan for different price ranges. Alas, Upcoming does not directly
    support this option. We can query free concerts, but I'm not a total cheapskate;
    I'll pay five or ten bucks. Seeing as Upcoming does pass along ticket cost, however,
    we can handle price filtering ourselves.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人比其他人更节俭。你可能愿意花75美元去看一位年迈的摇滚明星，但我更喜欢支付一小笔入场费去看在酒吧的当地乐队。我们需要为不同的价格范围做出计划。不幸的是，Upcoming并不直接支持这个选项。我们可以查询免费音乐会，但我不算是个十足的吝啬鬼；我会支付五到十美元。然而，由于Upcoming确实传递了票价信息，我们可以自己处理价格过滤。
- en: This mashups requires a lot of features. You can see in [Figure 10-10](ch10s04.html#shows_within_25_miles_of_san_francisco
    "Figure 10-10. Shows within 25 miles of San Francisco") that they all come together
    nicely.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个混合应用需要很多功能。你可以在[图10-10](ch10s04.html#shows_within_25_miles_of_san_francisco
    "图10-10. 25英里内显示的")中看到，它们都很好地结合在一起。
- en: Now we have a game plan so let's jam! Before we get into the data itself, we'll
    get a feel for the interface we'll create for users.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了行动计划，让我们开始吧！在我们深入研究数据本身之前，我们先了解一下我们将为用户创建的界面。
- en: '![Shows within 25 miles of San Francisco](httpatomoreillycomsourcenostarchimages672129.png.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![25英里内显示的](httpatomoreillycomsourcenostarchimages672129.png.jpg)'
- en: Figure 10-10. Shows within 25 miles of San Francisco
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-10. 25英里内显示的
- en: Prepare HTML for Search Interface
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备搜索界面HTML
- en: This being a map mashup, the map will be the center of our experience. The user
    will need to let us in on his or her whims regarding location and price. We'll
    need to put the search functions close to the map, so it's obvious that one controls
    the other.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个地图混合应用，地图将是我们的体验中心。用户需要告诉我们他们的位置和价格方面的喜好。我们需要将搜索功能放在地图附近，这样就很明显一个控制另一个。
- en: 'Open up a new file and add this code to create a basic map and form fields:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新文件，并添加以下代码以创建一个基本的地图和表单字段：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Much of this HTML will look familiar. As with most maps, I've loaded the Google
    Maps and Mapstraction JavaScript libraries. I also included jQuery ❶, which makes
    applying effects and using Ajax easy.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分HTML看起来都很熟悉。和大多数地图一样，我加载了Google Maps和Mapstraction JavaScript库。我还包括了jQuery❶，这使得应用效果和使用Ajax变得简单。
- en: The search location text defaults to Portland, Oregon, in this example. When
    the map first loads, it is centered on Portland. You can change the center to
    your city, but you'll need to edit multiple places. First, I used geographic coordinates
    ❷ to set the center. You've memorized these for your city now, right? Second,
    you need to change the value of the text field ❸. Of course, your user may edit
    the location, but starting with a logical default makes sense. For me, I used
    my hometown.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，搜索位置文本默认为俄勒冈州的波特兰。当地图首次加载时，它以波特兰为中心。你可以将中心更改为你的城市，但你需要编辑多个地方。首先，我使用了地理坐标❷来设置中心。你现在已经记住了你所在城市的这些坐标，对吧？其次，你需要更改文本字段的值❸。当然，你的用户可能会编辑位置，但从一个合理的默认值开始是有意义的。对我来说，我使用了我的家乡。
- en: The radius and cost fields are drop-down boxes. The values hold the maximums.
    For example, if you choose a radius of five miles ❹, nothing even a foot farther
    than five miles will show in the results. The same goes for price values. For
    the option of showing results regardless of cost ❺, we're hoping no concert is
    charging more than $9,999.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 半径和成本字段是下拉框。值包含最大值。例如，如果你选择五英里的半径❹，那么超过五英里甚至一英尺的距离都不会显示在结果中。价格值也是如此。对于显示不考虑成本的选项❺，我们希望没有音乐会收费超过9999美元。
- en: Creating the basic interface for a mashup, as we have here, can help you figure
    out everything you need to do. Look back at the code listing and note the function
    names in bold. You need to write those—one to search and another to filter—at
    the very least to be able to convert this interface into a working mashup.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个像我们这里这样的基本界面，可以帮助您了解需要做的一切。回顾代码列表，并注意粗体显示的函数名。您至少需要编写这些函数——一个用于搜索，另一个用于过滤——以便将此界面转换为可工作的混合应用。
- en: Before we start building the functions we need, let's look at the data we'll
    be using. To do that, we need to become familiar with the Upcoming API.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建所需的函数之前，让我们看看我们将使用的数据。为此，我们需要熟悉 Upcoming API。
- en: Perform an Upcoming API Search
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行 Upcoming API 搜索
- en: Upcoming uses a REST API, which means we can play around with it in the browser
    before coding anything. As a first step, you need a Yahoo! account to sign into
    Upcoming. Then, you need to get an Upcoming API key. This key is different than
    ones you've used for any other Yahoo! service.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Upcoming 使用 REST API，这意味着我们可以在编码任何东西之前在浏览器中对其进行尝试。作为第一步，您需要一个 Yahoo! 账户来登录 Upcoming。然后，您需要获取一个
    Upcoming API 密钥。这个密钥与您用于任何其他 Yahoo! 服务的密钥不同。
- en: 'While logged into Upcoming, request a key here: [http://upcoming.yahoo.com/api/url](http://upcoming.yahoo.com/api/url).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录 Upcoming 后，请在此处请求密钥：[http://upcoming.yahoo.com/api/url](http://upcoming.yahoo.com/api/url)。
- en: 'Now that you have an API key, try out this Upcoming search by copying this
    URL into your browser: [http://upcoming.yahooapis.com/services/rest/?api_key=YOURKEY&method=event.search&location=Portland,+OR](http://upcoming.yahooapis.com/services/rest/?api_key=YOURKEY&method=event.search&location=Portland,+OR).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了 API 密钥，请通过将此 URL 复制到浏览器中尝试 Upcoming 搜索：[http://upcoming.yahooapis.com/services/rest/?api_key=YOURKEY&method=event.search&location=Portland,+OR](http://upcoming.yahooapis.com/services/rest/?api_key=YOURKEY&method=event.search&location=Portland,+OR)。
- en: 'Here is a sample of the results from this simple search:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是简单搜索结果的示例：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The search term has merely restricted to a location. We need to add more options
    to the search before it will find the data we seek. See [Table 10-1](ch10s04.html#upcoming_api_event_search_option
    "Table 10-1. Upcoming API Event Search Option") for a description of the arguments
    we'll use. Many more are listed in Upcoming's documentation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索词仅限于位置。在找到我们寻求的数据之前，我们需要添加更多搜索选项。请参阅[表 10-1](ch10s04.html#upcoming_api_event_search_option
    "表 10-1. Upcoming API 事件搜索选项")以了解我们将使用的参数描述。Upcoming 的文档中列出了更多参数。
- en: Table 10-1. Upcoming API Event Search Option
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1. Upcoming API 事件搜索选项
- en: '| Argument | Description |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `api_key` | Your API key (required) |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `api_key` | 您的 API 密钥（必需） |'
- en: '| `location` | City and state to search for events |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `location` | 搜索事件的市和州 |'
- en: '| `radius` | How far away from center of location to search |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `radius` | 搜索位置中心多远范围内的搜索 |'
- en: '| `min_date` | What date to start searching for events |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `min_date` | 开始搜索事件的时间 |'
- en: '| `max_date` | What date to stop searching for events |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `max_date` | 停止搜索事件的时间 |'
- en: '| `tags` | The metadata keywords to filter results |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `tags` | 用于过滤结果的元数据关键字 |'
- en: Retrieve Event Data Server-Side
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端检索事件数据
- en: Now that we know what to expect from the Upcoming API, we're ready to connect
    to it. Rather than use JavaScript to get directly at the data, we'll run the data
    through a server-side PHP script. If you're unsure about whether you have PHP
    or how to use it, go check out [Chapter 9](ch09.html "Chapter 9. GO SERVER-SIDE").
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Upcoming API 的预期结果，我们准备连接到它。我们不会直接使用 JavaScript 获取数据，而是将通过服务器端 PHP
    脚本处理数据。如果您不确定是否安装了 PHP 或如何使用它，请查看[第 9 章](ch09.html "第 9 章。GO 服务器端")。
- en: 'We''re using PHP to pass the results to JavaScript for two reasons: First,
    we have to take into account security issues with accessing outside APIs directly
    with JavaScript. In many cases, browsers won''t allow it. Second, we can do some
    preprocessing to the data. We need to find the concert cost and put the price
    in a format that will make filtering results easier. Also, even though the API
    provides XML, we''ll output as JSON with the server-side script. JSON can be read
    directly into a JavaScript object, which again will make our lives easier.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 PHP 将结果传递给 JavaScript 的两个原因是：首先，我们必须考虑到使用 JavaScript 直接访问外部 API 的安全问题。在许多情况下，浏览器不会允许这样做。其次，我们可以对数据进行一些预处理。我们需要找到音乐会成本并将价格格式化为便于过滤结果的形式。此外，尽管
    API 提供了 XML，但我们将通过服务器端脚本输出 JSON 格式。JSON 可以直接读入 JavaScript 对象，这再次会使我们的工作变得更容易。
- en: The PHP code we'll use to access the Upcoming API is about 60 lines long. Rather
    than display it all at once, I'll go through one section at a time. That way I
    can describe what's happening, and you'll understand each piece before moving
    on to the next.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用来访问即将到来的API的PHP代码大约有60行长。为了不一次性显示所有内容，我将一次处理一个部分。这样我就可以描述正在发生的事情，你会在继续到下一个部分之前理解每一部分。
- en: 'To start, let''s create a new PHP file on your server and retrieve arguments
    from the query string:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在你的服务器上创建一个新的PHP文件，并从查询字符串中检索参数：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Even though we're using someone else's API, writing a middleman PHP script like
    this is sort of like creating our own API. Most of our query string arguments
    (in bold) will be passed unchanged to Upcoming. The `timeframe` argument, however,
    is my own creation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们正在使用别人的API，但编写这样的中间人PHP脚本有点像是创建我们自己的API。我们大部分的查询字符串参数（粗体）将不变地传递给即将到来的API。然而，`timeframe`参数是我自己的创造。
- en: 'This argument specifies how far in the future to search. This simple version
    allows three options: one day (`1d`), one week (`1w`), and one month (`1m`). Because
    Upcoming does not have this option, we need to convert the timeframe to a maximum
    date by finding the timestamp that represents a day in the future.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数指定了搜索未来的时间范围。这个简单的版本允许三种选项：一天（`1d`）、一周（`1w`）和一个月（`1m`）。因为即将到来的API没有这个选项，我们需要通过找到代表未来一天的戳记来将时间范围转换为最大日期。
- en: We already set the minimum date to be today ❶. PHP's `date` function, if a second
    argument isn't included, assumes the current date. We can achieve the same result
    by passing `time()` as the second argument. In fact, with a timeframe of one day,
    we simply set the timestamp equal to `time()` ❷. That leaves the minimum date
    as today and the maximum date as today, just like we want.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将最小日期设置为今天 ❶。PHP的`date`函数，如果没有包含第二个参数，则假定当前日期。我们可以通过传递`time()`作为第二个参数来达到相同的结果。实际上，在一天的时间范围内，我们只需将时间戳设置为`time()`
    ❷。这样，最小日期和最大日期都是今天，正如我们想要的。
- en: In the case of a week or month, we need to do a little date math. PHP has a
    `strtotime` function that takes many different types of input. In this example
    ❸, the function starts at today and adds a week. Then it subtracts a day. Why?
    Because otherwise we'd have eight days, which is more than a week. The same is
    true of the month option.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一周或一个月的情况，我们需要进行一些日期计算。PHP有一个`strtotime`函数，它接受许多不同类型的输入。在这个例子 ❸ 中，函数从今天开始并增加一周。然后它减去一天。为什么？因为否则我们会有一周多八天，这比一周还多。对于月份选项也是如此。
- en: Finally we convert our timeframe to a timestamp format the computer understands.
    Now all we need is to set the `$maxdate` variable by passing the `timeframe` to
    the `date` function ❹.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们的时间范围转换为计算机能理解的戳记格式。现在我们只需要通过将`timeframe`传递给`date`函数来设置`$maxdate`变量
    ❹。
- en: 'Now that we''ve figured out all the variables that we''re sending to the Upcoming
    API, we''re ready for the next bit of code. In this section, we actually retrieve
    data and preprocess it:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了要发送给即将到来的API的所有变量，我们已经准备好编写下一部分代码。在本节中，我们实际上检索数据并进行预处理：
- en: '[PRE36]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Using the variables we created in the previous section, we piece together the
    URL to call Upcoming''s API ❺. The content from the URL will come through as XML,
    which we convert into a `SimpleXML` object. In [#61: Retrieve a Web Page](ch09s03.html
    "#61: Retrieve a Web Page") in [#61: Retrieve a Web Page](ch09s03.html "#61: Retrieve
    a Web Page"), we wrote the `get_xml` function to perform this task. We might as
    well save ourselves some time and reuse that function here ❻.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '使用我们在上一节中创建的变量，我们将URL拼凑起来以调用即将到来的API ❺。URL的内容将以XML格式通过，我们将它转换成一个`SimpleXML`对象。在[第61节：检索网页](ch09s03.html
    "#61: Retrieve a Web Page)中，我们编写了`get_xml`函数来完成这个任务。我们不妨节省一些时间，并在这里重用那个函数 ❻。'
- en: 'With the XML now easily accessible, let''s loop through all the events that
    the Upcoming API returned. We''ll grab each `<event>` tag ❼ one at a time. The
    data about the event is stored as the event tag''s attributes. We can grab all
    the attributes at once ❽ and then pick and choose only the ones we want: the unique
    `id` assigned by Upcoming, latitude, longitude, the event''s title, its date,
    and its cost. Most of these are straightforward, but we''ll need to do a little
    voodoo to get the price of the event in the format we want.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在XML数据很容易访问，让我们遍历 Upcoming API 返回的所有活动。我们将逐个抓取 `<event>` 标签 ❼。关于活动的数据存储为事件标签的属性。我们可以一次性抓取所有属性
    ❽，然后挑选我们想要的：Upcoming 分配的唯一 `id`、纬度、经度、活动的标题、日期和成本。大多数这些都是直接的，但我们需要做一些魔法来获取我们想要格式的活动价格。
- en: Upcoming includes a dollar sign in front of the ticket price, and many events
    have a price range instead of a single amount. To filter by the cost in our JavaScript
    code, we need our PHP code to return a simple number.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Upcoming 在票价前包含一个美元符号，许多活动有一个价格范围而不是单一金额。为了在我们的 JavaScript 代码中按成本过滤，我们需要我们的
    PHP 代码返回一个简单的数字。
- en: Here, I used a regular expression to look for all instances of a dollar sign
    followed by one or more digits ❾. This way, we can take the last dollar amount,
    which should be at the highest end of the range if one exists. If tickets are
    just one price, the expression will find that, too. Finally, we remove the dollar
    sign, so we return only a number.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用正则表达式来查找所有以美元符号开头后跟一个或多个数字的实例 ❾。这样，我们可以取最后一个美元金额，如果有的话，它应该是在范围最高端。如果票价只有一个价格，表达式也会找到它。最后，我们移除美元符号，因此我们只返回一个数字。
- en: 'Now that we have the data from the event we need, we put it into an associative
    array, `$eventobj`. That new array then gets "pushed" onto the end of the results
    object ❿, which is a normal array. I''ve named the results object `$outobj` because
    we''ll print it. In fact, with all the preprocessing complete, we can do that
    now:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了所需的活动数据，我们将它放入一个关联数组 `$eventobj` 中。然后这个新数组被“推”到结果对象 ❿ 的末尾，这是一个普通数组。我将其命名为
    `$outobj`，因为我们将会打印它。实际上，在所有预处理完成之后，我们现在就可以这样做：
- en: '[PRE37]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We first print the header to declare that we're sending plain text. PHP defaults
    to HTML. Next, we print out the results object, but we make sure it is JSON-encoded.
    That way, we're giving our JavaScript code something easy to digest.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先打印标题来声明我们正在发送纯文本。PHP 默认为 HTML。接下来，我们打印出结果对象，但我们确保它是 JSON 编码的。这样，我们给 JavaScript
    代码提供了一些容易消化的东西。
- en: 'Remember when we used the `get_xml` function to retrieve the Upcoming URL and
    convert the XML content to a `SimpleXML` object? We never actually included the
    function in our code. Let''s do that now:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们曾经使用 `get_xml` 函数来检索即将到来的 URL 并将 XML 内容转换为 `SimpleXML` 对象吗？我们实际上从未在我们的代码中包含这个函数。现在让我们来做这件事：
- en: '[PRE38]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Hey! That's two functions!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿！这是两个函数！
- en: You caught me. Because one calls the other, we need to include them both. If
    you find yourself using these functions often, adding them to their own file is
    probably worthwhile. Then you can make them part of your project as needed with
    the PHP `include` function.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你抓住了我。因为一个函数调用了另一个，所以我们需要包含它们两个。如果你经常使用这些函数，将它们添加到自己的文件中可能是有益的。然后你可以根据需要使用 PHP
    的 `include` 函数将它们作为项目的一部分。
- en: And that's that. We've written some PHP to call the Upcoming API. From the XML
    returned by Upcoming, we take only the stuff we want and output it as JSON. I
    saved the PHP file as *upcoming.php* in the same directory as the HTML search
    interface we created earlier. Now let's return to that HTML file, so we can use
    JavaScript to connect to our newly created PHP file.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们已经编写了一些 PHP 代码来调用 Upcoming API。从 Upcoming 返回的 XML 中，我们只取我们想要的，并以 JSON
    格式输出。我将 PHP 文件保存为 *upcoming.php*，与之前创建的 HTML 搜索界面在同一目录下。现在让我们回到那个 HTML 文件，这样我们就可以使用
    JavaScript 连接到我们刚刚创建的 PHP 文件。
- en: Plot Event Search Results on a Map
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在地图上绘制事件搜索结果
- en: Now that you know how to get data from Upcoming, let's put that data on our
    map. We'll connect to the PHP file we just created, sending it the information
    it needs.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何从 Upcoming 获取数据，让我们将那些数据放在我们的地图上。我们将连接到我们刚刚创建的 PHP 文件，发送它所需的信息。
- en: 'You may recall from setting up the HTML that we need to create two functions.
    First, we write the `search_upcoming` function to perform the Ajax call to our
    PHP. Add these lines in the JavaScript below the `create_map` function:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在设置 HTML 时，我们需要创建两个函数。首先，我们编写 `search_upcoming` 函数来执行对 PHP 的 Ajax 调用。在
    `create_map` 函数下方添加这些行：
- en: '[PRE39]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Before we can search Upcoming, we need to retrieve the user's values from the
    form. To do this, I used the `document.getElementById` function, doing a little
    data cleanup for the location.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够搜索即将发生的事件之前，我们需要从表单中检索用户的值。为此，我使用了`document.getElementById`函数，并对位置进行了一些数据清理。
- en: I hard-coded some values that are options in our PHP file that we don't currently
    use as input from the user. For example, the tags ❶ that we look for can be changed
    to something else if you aren't looking for concerts. The timeframe defaults to
    one week, which seems the most useful for planning impromptu entertainment.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我硬编码了一些我们目前在PHP文件中不作为用户输入使用的选项值。例如，我们寻找的标签❶可以更改为其他内容，如果你不是在寻找音乐会。时间范围默认为一周，这似乎对计划即兴娱乐最有用。
- en: The values that I hard-coded, plus a couple from the form, are put into a JavaScript
    object ❷. The jQuery `getJSON` function ❸ that calls our PHP file using the `data`
    variable to include values requires this format. The last parameter is a function
    reference to `plot_upcoming` ❹. That's one we need to write.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我硬编码的值，加上表单中的几个值，被放入一个JavaScript对象❷中。调用我们的PHP文件并使用`data`变量包含值的jQuery `getJSON`函数❸需要这种格式。最后一个参数是`plot_upcoming`❹函数的引用。这是我们需要编写的函数之一。
- en: 'In this new function, we want to loop through all the results in the JavaScript
    object. As we find each event, we plot it on the map. Add this code to your JavaScript:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新函数中，我们想要遍历JavaScript对象中的所有结果。当我们找到每个事件时，我们将其绘制在地图上。将此代码添加到您的JavaScript中：
- en: '[PRE40]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This function unpacks the variables that are output by the PHP and uses them
    to add a marker for every Upcoming event the API returned. Remember, we used an
    array holding many associative arrays. The JavaScript object is also an array.
    We iterate through it with the `for` command ❺, putting each event result into
    the `ev` variable.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数解包了PHP输出的变量，并使用它们为API返回的每个即将发生的事件添加一个标记。记住，我们使用了一个包含许多关联数组的数组。JavaScript对象也是一个数组。我们使用`for`命令❺遍历它，将每个事件结果放入`ev`变量中。
- en: Using the `id` returned from Upcoming, we can piece together the URL ❻ where
    the user can find out more information about the event. Other data, like the latitude
    and longitude, we put directly into variables that we use to create the marker.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从Upcoming返回的`id`，我们可以拼凑出用户可以找到更多事件信息的URL❻。其他数据，如纬度和经度，我们直接放入我们用来创建标记的变量中。
- en: If the PHP was able to determine the cost of the event, we add an attribute
    to the marker with that information ❼. This information will be useful when we
    filter by ticket price. In fact, at the end of this function, once all the markers
    have been added to the map, we call that filter function ❽, which means we better
    go write it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果PHP能够确定事件的成本，我们将在标记上添加包含该信息的属性❽。当按票价过滤时，这些信息将很有用。实际上，在这个函数的末尾，一旦所有标记都添加到地图上，我们调用那个过滤器函数❽，这意味着我们最好去编写它。
- en: Filter Results by Ticket Price
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过票价过滤结果
- en: When the results are returned, they contain all the music events in an area,
    not just the ones that match the user's budget. The Upcoming API has no way to
    query for events under a specific ticket price, though it does provide the price
    in the results, if available. The PHP we wrote takes the ticket price and produces
    a numeric cost that we can use as a filter.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当结果返回时，它们包含该区域内的所有音乐事件，而不仅仅是符合用户预算的事件。尽管Upcoming API没有查询特定票价以下事件的方法，但它确实在结果中提供了价格（如果有的话）。我们编写的PHP代码将票价转换为我们可以用作过滤器的数值。
- en: In the previous section, we added a `cost` attribute for every marker containing
    the ticket price. Just having the attribute is not enough to remove overpriced
    concerts. We also need to apply the filter, which comes from a drop-down box in
    the HTML form.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们为每个包含票价属性的标记添加了一个`cost`属性。仅仅有这个属性还不够，我们需要应用过滤器，这个过滤器来自HTML表单中的下拉框。
- en: 'The `filter_select` function is called when all the markers are added to the
    page, or whenever the value in the drop-down box changes. Add these functions
    to your JavaScript code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有标记添加到页面或下拉框中的值更改时，会调用`filter_select`函数。将这些函数添加到您的JavaScript代码中：
- en: '[PRE41]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As with other examples, two functions perform this one task. The first retrieves
    the value from the drop-down box ❶ and then passes the cost to the second. The
    `filter_cost` function does the actual filtering work.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他示例一样，两个函数执行这个任务。第一个从下拉框中检索值❶，然后将成本传递给第二个。`filter_cost`函数执行实际的过滤工作。
- en: Before creating a new filter, we need to remove any previous filters ❷. Why?
    Mapstraction's filtering is additive, meaning a second filter does not replace
    the first, but instead is applied in addition to the first. In this case, we only
    want to use a single filtering method, we remove all filters before adding new
    ones.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的过滤器之前，我们需要删除任何之前的过滤器❷。为什么？Mapstraction的过滤是累加的，这意味着第二个过滤器不会替换第一个，而是附加到第一个之上。在这种情况下，我们只想使用一种过滤方法，所以我们删除所有过滤器后再添加新的。
- en: 'To apply a filter requires three pieces of information: the attribute to be
    filtered by, the operator to use (in this case `le` for less than or equal to
    ❸), and finally the value to compare. Markers don''t actually get filtered until
    Mapstraction''s `doFilter` function is called.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 应用过滤器需要三个信息：要过滤的属性、要使用的运算符（在这种情况下为`le`，表示小于或等于❸），以及最后要比较的值。标记实际上只有在Mapstraction的`doFilter`函数被调用时才会被过滤。
- en: Now with only the markers matching our filter being displayed, we can make sure
    they're all visible on the map. Mapstraction has a function specifically for situations
    like this ❹. We don't want to set the center and zoom based on all the markers;
    we simply want to use the visible markers.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只显示与我们的过滤器匹配的标记，我们可以确保它们都在地图上可见。Mapstraction有一个专门用于这种情况的函数❹。我们不想根据所有标记设置中心点和缩放级别；我们只想使用可见的标记。
- en: These filtering functions are called from our mashup whenever the user searches
    for concerts. We also save a little bandwidth whenever the user changes the value
    in the ticket price drop-down box. Because we've stored concerts for all price
    ranges, we call these filtering functions to show only the ones that match, as
    shown in [Figure 10-11](ch10s04.html#filtered_results_show_only_concerts_that
    "Figure 10-11. Filtered results show only concerts that match the search").
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过滤函数在我们的大杂烩中调用，每当用户搜索演出时。当用户更改票价下拉框中的值时，我们也会节省一点带宽。因为我们已经存储了所有价格范围的演出，所以我们调用这些过滤函数来仅显示匹配的演出，如图[图10-11](ch10s04.html#filtered_results_show_only_concerts_that
    "图10-11。仅显示匹配搜索条件的演出结果")所示。
- en: '![Filtered results show only concerts that match the search](httpatomoreillycomsourcenostarchimages672131.png.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![过滤结果仅显示匹配搜索的演唱会](httpatomoreillycomsourcenostarchimages672131.png.jpg)'
- en: Figure 10-11. Filtered results show only concerts that match the search
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-11。仅显示匹配搜索条件的演出结果
- en: If you look back to [Figure 10-10](ch10s04.html#shows_within_25_miles_of_san_francisco
    "Figure 10-10. Shows within 25 miles of San Francisco"), you can see all the results
    for concerts within 25 miles of San Francisco. Then, in [Figure 10-11](ch10s04.html#filtered_results_show_only_concerts_that
    "Figure 10-11. Filtered results show only concerts that match the search"), you
    see only the two concerts that are $10 or less. The map automatically zooms to
    show only the concerts that match our filter criteria. Pretty slick. Now which
    band are we going to hear?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下[图10-10](ch10s04.html#shows_within_25_miles_of_san_francisco "图10-10。在旧金山25英里范围内的演出结果")，你可以看到旧金山25英里范围内的所有演出结果。然后，在[图10-11](ch10s04.html#filtered_results_show_only_concerts_that
    "图10-11。仅显示匹配搜索条件的演出结果")中，你只能看到票价为10美元或以下的两个演出。地图自动缩放以仅显示符合我们过滤器标准的演出。相当酷。那么我们接下来要听哪支乐队呢？
- en: '#72: Plot Twitter Geo-Tweets'
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#72：绘制Twitter地理推文'
- en: Twitter is a popular service for sharing short messages with friends. In 140
    characters or less, people send rants, links, photos, or whatever else they feel
    like. Optionally, those messages (called *tweets*) can be geo-tagged. When content
    is tied to a location, you can do some interesting things with that data.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter是一个流行的服务，用于与朋友分享简短的消息。在140个字符或更少的情况下，人们发送牢骚、链接、照片或他们想分享的任何内容。可选地，这些消息（称为*tweets*）可以进行地理标记。当内容与位置相关联时，你可以用这些数据做一些有趣的事情。
- en: In this mashup, we'll create a tool for users to search for geo-tagged tweets
    by city name, ZIP Code, or address. We'll also create an optional way to search
    by keyword. Do you want all the geo-tagged tweets nearby that mention *lunch*?
    You can do that! Just take a look at [Figure 10-12](ch10s05.html#where_san_franciscans_like_to_tweet_abou
    "Figure 10-12. Where San Franciscans like to tweet about their lunch").
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个大杂烩中，我们将创建一个工具，让用户可以通过城市名称、ZIP代码或地址搜索地理标记的推文。我们还将创建一个可选的按关键词搜索的方式。你想要查看附近所有提到*lunch*的地理标记推文吗？你可以做到！只需看看[图10-12](ch10s05.html#where_san_franciscans_like_to_tweet_abou
    "图10-12。旧金山人喜欢在哪些地方发推文讨论午餐")。
- en: '![Where San Franciscans like to tweet about their lunch](httpatomoreillycomsourcenostarchimages672133.png.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![旧金山人喜欢在哪些地方发推文讨论午餐](httpatomoreillycomsourcenostarchimages672133.png.jpg)'
- en: Figure 10-12. Where San Franciscans like to tweet about their lunch
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-12. 旧金山人喜欢在哪些地方发午餐推文
- en: 'Along with searching tweets, we''ll integrate a few other projects from earlier
    in the book. Because we need the user to enter a location, we''ll need a geocoder
    to translate the name of a place to latitude and longitude coordinates. For that,
    we''ll use [#12: Geocode with JavaScript](ch03s03.html "#12: Geocode with JavaScript")
    in [#12: Geocode with JavaScript](ch03s03.html "#12: Geocode with JavaScript").
    And because we need to start somewhere, I''ve used [#50: Get Location by IP](ch07s04.html
    "#50: Get Location by IP") in [#50: Get Location by IP](ch07s04.html "#50: Get
    Location by IP") to guess where the user is.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '除了搜索推文，我们还将整合书中早期的一些其他项目。因为我们需要用户输入一个位置，所以我们需要一个地理编码器将地点名称转换为经纬度坐标。为此，我们将使用
    [#12: 使用JavaScript进行地理编码](ch03s03.html "#12: 使用JavaScript进行地理编码") 在 [#12: 使用JavaScript进行地理编码](ch03s03.html
    "#12: 使用JavaScript进行地理编码")。而且因为我们需要从某个地方开始，我已经使用了 [#50: 通过IP获取位置](ch07s04.html
    "#50: 通过IP获取位置") 在 [#50: 通过IP获取位置](ch07s04.html "#50: 通过IP获取位置") 来猜测用户的位置。'
- en: But first we need to create the HTML for the page where our map will reside.
    Let's get started.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先我们需要创建我们的地图将驻留的页面HTML。让我们开始吧。
- en: Prepare the Map with User Location
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备带有用户位置的地图
- en: Most maps we've created start with a default location. That's the biggest difference
    between this map and the others. Here, we'll use Google's `ClientLocation` to
    guess the user's city. If that's not available, we'll instead show a map of the
    entire United States. In either case, the form below the map will be accessible
    to set a new location or other search term.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的大多数地图都以默认位置开始。这是此地图与其他地图之间最大的区别。在这里，我们将使用Google的`ClientLocation`来猜测用户的城市。如果不可用，我们将显示整个美国的地图。在任何情况下，地图下面的表单都可以用来设置新位置或其他搜索词。
- en: 'In an empty file, add the following code:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个空文件中添加以下代码：
- en: '[PRE42]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, we include the jQuery library ❶, which we'll use to make the Ajax call
    to Twitter. Then we load the generic Google JavaScript API script ❷. This distinction
    from the normal way of loading the Google Maps API is important; we use this alternate
    method so we can retrieve the user's location. Because we will also be using the
    JavaScript geocoder, we need to include that, too ❸.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包含jQuery库 ❶，我们将使用它来向Twitter发起Ajax调用。然后我们加载通用的Google JavaScript API脚本 ❷。与正常加载Google
    Maps API的方式相比，这种区别很重要；我们使用这种方法，以便我们可以检索用户的地理位置。因为我们还将使用JavaScript地理编码器，所以我们也需要包含它
    ❸。
- en: At this point, we've loaded all our scripts the standard way. All we've included
    from Google, however, is a script that loads other scripts. The first thing we
    need to do in the JavaScript section is load Google Maps ❹.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已以标准方式加载了所有脚本。然而，我们只从Google包含了加载其他脚本的脚本。在JavaScript部分，我们首先需要加载Google
    Maps ❹。
- en: When we create the map, we need to check whether we can determine the user's
    location. If we can, then we can set the center of the map based on the coordinates
    retrieved from `ClientLocation`. We'll also prepopulate the search form with the
    name of this location ❺ and call to the `get_twitter_geo` function, which retrieves
    search results from Twitter.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建地图时，我们需要检查我们是否可以确定用户的地理位置。如果我们能，那么我们可以根据从`ClientLocation`检索到的坐标设置地图的中心。我们还将预先填充搜索表单，包含此位置的名称
    ❺，并调用`get_twitter_geo`函数，该函数从Twitter检索搜索结果。
- en: If we can't determine the user's location, we'll just zoom out so the entire
    United States is shown on the map ❻. And calling for search results from this
    view is futile, so we'll wait for the user to search manually. How does that happen?
    Read on.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法确定用户的地理位置，我们只需放大地图，使整个美国显示在地图上 ❻。从这种视图调用搜索结果是无用的，因此我们将等待用户手动搜索。这是如何发生的？请继续阅读。
- en: Geocode User Input
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地理编码用户输入
- en: Accepting user input is an important part of this mashup. Users want to interact
    with the map and the data, which requires the ability to look for any location.
    The form we created in the previous section has inputs for a keyword, radius,
    and place. Twitter can use all of these to find tweets, but first we need to convert
    the place into the latitude and longitude coordinates that Twitter expects.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接受用户输入是此混合应用的重要部分。用户希望与地图和数据交互，这需要查找任何位置的能力。我们在上一节中创建的表单有关键词、半径和地点的输入。Twitter可以使用所有这些来查找推文，但首先我们需要将地点转换为Twitter期望的经纬度坐标。
- en: 'When the user submits the form, the browser will call the `geocode_form` function,
    which is used to initiate a call to the JavaScript geocoder. Let''s create this
    function by adding the following lines to your JavaScript section, outside any
    other functions:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提交表单时，浏览器将调用`geocode_form`函数，该函数用于启动对JavaScript地理编码器的调用。让我们通过在JavaScript部分外添加以下行来创建此函数：
- en: '[PRE43]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If the user has left the location field empty ❶, we assume they want to search
    using the center of the current map. Otherwise, we create a geocoder and set the
    callback function ❷. Then, we perform geocoding ❸ using the location the user
    entered.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户留空了位置字段❶，我们假设他们想要使用当前地图的中心进行搜索。否则，我们创建一个地理编码器并设置回调函数❷。然后，我们使用用户输入的位置进行地理编码❸。
- en: 'In either case, the next function that will be called is `call_twitter_geo`
    (either directly or as a callback from the geocoder), which passes the point and
    other criteria to our `get_twitter_geo` function, which does the heavy lifting.
    Let''s create the first and simpler of those two functions now. Add the following
    code within the JavaScript section, but not within another function:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，接下来将被调用的函数是`call_twitter_geo`（直接或作为地理编码器的回调），它将点和其他标准传递给我们的`get_twitter_geo`函数，该函数执行繁重的工作。现在让我们创建这两个函数中的第一个和更简单的函数。在JavaScript部分中添加以下代码，但不要在另一个函数内部：
- en: '[PRE44]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The argument expected is a location object ❹, which is a `point` attribute containing
    a Mapstraction `LatLonPoint`. Even though we sometimes call this function directly,
    it is designed to accept the results of the JavaScript geocoder.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 预期参数是一个位置对象❹，它包含一个Mapstraction `LatLonPoint`的`point`属性。尽管我们有时会直接调用此函数，但它设计为接受JavaScript地理编码器的结果。
- en: We gather the rest of the form fields (keyword, radius) and pass them off to
    be used to retrieve geo-tweets ❺.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收集表单中的其余字段（关键字、半径）并将它们传递出去以用于检索地理推文❺。
- en: With that, we're through with the overhead. Now we're ready to search tweets.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了准备工作。现在我们准备搜索推文。
- en: Retrieve Geo-Tweets from Twitter
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Twitter检索地理推文
- en: 'So far we have only determined (in various ways) a point around which to search,
    but we haven''t performed the actual search. That''s what we''ll do here: Send
    our requirements to Twitter, and receive tweets in return.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只确定了（以各种方式）搜索的某个点，但尚未执行实际的搜索。这正是我们在这里要做的：将我们的要求发送给Twitter，并接收回推文。
- en: Twitter's search API does not require a key, so you can get started right away.
    The base URL is *search.twitter.com/search.json*, and you can use a number of
    parameters to call it. The ones we'll use are listed in [Table 10-2](ch10s05.html#some_twitter_search_parameters
    "Table 10-2. Some Twitter Search Parameters").
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter的搜索API不需要密钥，因此您可以立即开始。基本URL是*search.twitter.com/search.json*，您可以使用多个参数来调用它。我们将使用的是[表10-2](ch10s05.html#some_twitter_search_parameters
    "表10-2. 一些Twitter搜索参数")中列出的参数。
- en: Table 10-2. Some Twitter Search Parameters
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-2. 一些Twitter搜索参数
- en: '| Argument | Description |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `q` | Search query/keyword |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `q` | 搜索查询/关键字 |'
- en: '| `geocode` | Coordinates in `lat,lon,radius` format |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `geocode` | `lat,lon,radius`格式的坐标 |'
- en: '| `page` | Page of results to retrieve |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `page` | 要检索的结果页 |'
- en: '| `rpp` | Results per page |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `rpp` | 每页结果数 |'
- en: 'You can search in your browser by adjusting the URL. Here are some abbreviated
    example results:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调整URL在浏览器中进行搜索。以下是一些简化的示例结果：
- en: '[PRE45]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can see that the results contain the username, tweet text, and date. Also,
    the `geo` attribute contains information about geocoded tweets. Not every tweet
    will contain this data, however, even when we send the `geocode` argument in the
    search query. We'll need to watch for that as we create the function to plot geocoded
    tweets. In fact, because so many non-geocoded tweets are out there, we may need
    to go through many pages of results before we get enough tweets to plot on our
    map.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到结果包含用户名、推文文本和日期。此外，`geo`属性包含有关地理编码推文的信息。然而，并非每个推文都包含这些数据，即使我们在搜索查询中发送了`geocode`参数。在创建绘制地理编码推文的函数时，我们需要注意这一点。事实上，由于存在大量未地理编码的推文，我们可能需要浏览多页结果才能收集到足够多的推文来在地图上绘制。
- en: Much more data than I have shown is sent along with the tweet, such as the client
    used to create the tweet and the profile image of the user who wrote it. You can
    find full documentation of the search API on Twitter's site at [http://dev.twitter.com/doc/get/search](http://dev.twitter.com/doc/get/search).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 与我展示的相比，推文中发送了更多的数据，例如创建推文的客户端和撰写推文的用户的个人资料图片。你可以在Twitter的网站上找到搜索API的完整文档，网址为[http://dev.twitter.com/doc/get/search](http://dev.twitter.com/doc/get/search)。
- en: 'Now that you better understand the data you''ll get from Twitter''s API, let''s
    write the `get_twitter_geo` function that we call from our mashup. Add the following
    code to your JavaScript, outside any other functions:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更好地了解了从Twitter的API中获得的数据，让我们编写 `get_twitter_geo` 函数，这是我们从我们的混合应用中调用的。将以下代码添加到你的JavaScript中，任何其他函数之外：
- en: '[PRE46]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The function contains five parameters, but only one (the location) is required.
    The others—radius, keyword, page, and results per page—are set to defaults if
    need be.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数包含五个参数，但只需要一个（位置）即可。其他参数——半径、关键词、页面和每页结果数——如果需要，则设置为默认值。
- en: 'Whenever the search is for the first page of results, we know that this is
    a new search, so we have to remove previous results from the map. Then, based
    on the center point, we draw a circle around the search area. I''ve used a polygon
    to approximate a circle, as described in [#18: Add Circles to Show Search Radius](ch04s03.html
    "#18: Add Circles to Show Search Radius") in [Set the Fill Color and Opacity](ch04s02.html#set_the_fill_color_and_opacity
    "Set the Fill Color and Opacity"). For convenience, the `polygon_circle` ❶ function
    is reprinted at the end of this section.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '每当搜索结果的第一页时，我们知道这是一个新的搜索，因此我们必须从地图中移除之前的结果。然后，基于中心点，我们在搜索区域周围画一个圆。正如在[第18条：添加圆形以显示搜索半径](ch04s03.html
    "#18: Add Circles to Show Search Radius")中描述的，我使用多边形来近似圆形，该描述在[设置填充颜色和透明度](ch04s02.html#set_the_fill_color_and_opacity
    "设置填充颜色和透明度")章节中。为了方便，`polygon_circle` ❶ 函数在本文节的末尾重新打印。'
- en: Using the function arguments (or the defaults), we then create the URL for a
    Twitter search. At the end, we include the `callback` parameter ❷ with a question
    mark that will be filled in by jQuery with a generated function name.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数参数（或默认值），我们然后创建一个Twitter搜索的URL。最后，我们包括一个带有问号的 `callback` 参数 ❷，jQuery将用生成的函数名填充它。
- en: Once we get query results, we loop through until we find a tweet that is geocoded
    ❸. Then we grab its coordinates (an array, with latitude before longitude) and
    create a marker with them. I've given the marker a message box containing the
    text of the tweet. You could also include more data about the tweet if you want.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到查询结果，我们就循环遍历，直到找到一个地理编码的推文 ❸。然后我们获取其坐标（一个数组，纬度在经度之前）并创建一个带有这些坐标的标记。我已经给标记添加了一个包含推文文本的消息框。如果你想的话，也可以包含更多关于推文的数据。
- en: When we've looped through all the results, we aren't necessarily done. Because
    not every tweet is geocoded, we need to view many pages. Twitter will only return
    1,500 tweets. The number of pages will depend on the results per page. As long
    as we're below the limit and still receiving a full set of tweets ❹, we want to
    keep searching. In some areas, especially without searching by keyword, your tweet
    map will get pretty full, like in [Figure 10-13](ch10s05.html#many_comma_many_tweets_near_downtown_por
    "Figure 10-13. Many, many tweets near downtown Portland").
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历完所有结果后，我们不一定已经完成。因为并非每条推文都有地理编码，我们需要查看许多页面。Twitter只会返回1,500条推文。页数将取决于每页的结果数。只要我们低于限制并且仍然收到完整的推文集合
    ❹，我们就想继续搜索。在某些地区，尤其是在没有按关键词搜索的情况下，你的推文地图可能会非常满，就像在[图10-13](ch10s05.html#many_comma_many_tweets_near_downtown_por
    "图10-13. 波特兰市中心附近有很多推文")中所示。
- en: This `get_twitter_geo` function is what computer scientists call *recursive*,
    meaning it calls itself. This can be dangerous, because if you aren't careful
    about the conditions when you make another call, you've got the potential for
    an infinite loop. Perhaps the most important part of the function is that we increase
    the page number ❺ with each call. Doing so will ensure that eventually we'll stop
    calling the function.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `get_twitter_geo` 函数是计算机科学家所说的**递归**，意味着它调用自己。这可能会很危险，因为如果你在再次调用时没有注意条件，你可能会遇到无限循环。函数最重要的部分可能是我们每次调用时都会增加页面编号
    ❺。这样做将确保我们最终会停止调用该函数。
- en: 'That''s it! Before your code will work, you''ll need to include the code, which
    I am reprinting from [Chapter 4](ch04.html "Chapter 4. LAYER IT ON"):'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！在你代码生效之前，你需要包含以下代码，这些代码是从[第4章](ch04.html "第4章。叠加")中重新打印的：
- en: '[PRE47]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now you've written a mashup that geocodes a location and searches Twitter for
    tweets near that place. You've tapped into the geographic hivemind. Now start
    using it to uncover some interesting data. Where in your city are people tweeting
    about lunch?
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经编写了一个混合应用，它将位置地理编码并搜索该地点附近的推文。你已经触动了地理蜂群智慧。现在开始使用它来揭示一些有趣的数据。在你的城市里，人们在哪里发推文谈论午餐？
- en: '![Many, many tweets near downtown Portland](httpatomoreillycomsourcenostarchimages672135.png.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![波特兰市中心附近有许多许多推文](httpatomoreillycomsourcenostarchimages672135.png.jpg)'
- en: Figure 10-13. Many, many tweets near downtown Portland
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-13. 波特兰市中心附近有许多许多推文
- en: '#73: Find a Coffee Shop to Meet in the Middle'
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#73: 在中间找一个咖啡店见面'
- en: Meeting in the middle is the secret to a happy marriage and the key to passing
    kindergarten. And when it comes to physically finding a place to meet, meeting
    in the middle makes for a great map mashup. Whether you and a friend are just
    across town or many miles apart, we'll make a map that will find coffee shops
    as close to the midpoint between your two locations as possible, as shown in [Figure 10-14](ch10s06.html#a_search_for_coffee_shop_at_the_midpoint
    "Figure 10-14. A search for coffee shop at the midpoint of a route").
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间见面是幸福婚姻的秘密，也是通过幼儿园的关键。当涉及到在物理上找到一个见面地点时，中间见面是制作出色地图混合应用的好方法。无论你和朋友是城里还是相隔千里，我们都会制作一个地图，找到尽可能靠近你两个位置中点的咖啡店，如图[图10-14](ch10s06.html#a_search_for_coffee_shop_at_the_midpoint
    "图10-14. 在路线中点寻找咖啡店")所示。
- en: 'The map we create will use several examples covered earlier in this book. First,
    we''ll take input from the user and determine the route, as I showed in [#37:
    Find True Distance with Routing](ch06s02.html "#37: Find True Distance with Routing")
    in [#37: Find True Distance with Routing](ch06s02.html "#37: Find True Distance
    with Routing"). Then we''ll go through each step of the driving directions to
    determine when we''re about halfway. To find the exact midpoint, we''ll use another
    method described in [#40: Find a Point Along a Line](ch06s05.html "#40: Find a
    Point Along a Line") in [#40: Find a Point Along a Line](ch06s05.html "#40: Find
    a Point Along a Line"). Finally, we''ll use the midpoint to perform a local search
    using the review service Yelp''s API.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '我们创建的地图将使用本书前面提到的几个示例。首先，我们将从用户那里获取输入并确定路线，就像我在[第37条：使用路线查找真实距离](ch06s02.html
    "#37: 使用路线查找真实距离")中展示的那样。然后，我们将遍历驾驶方向的每个步骤，以确定我们何时大约走了一半的路程。为了找到确切的中点，我们将使用[第40条：在一条线上找到一点](ch06s05.html
    "#40: 在一条线上找到一点")中描述的另一种方法。最后，我们将使用中点通过Yelp的API执行本地搜索。'
- en: Armed with this game plan, read on to get started.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个行动计划，继续阅读以开始。
- en: '![A search for coffee shop at the midpoint of a route](httpatomoreillycomsourcenostarchimages672137.png.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![在路线中点寻找咖啡店](httpatomoreillycomsourcenostarchimages672137.png.jpg)'
- en: Figure 10-14. A search for coffee shop at the midpoint of a route
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-14. 在路线中点寻找咖啡店
- en: Prepare the Map and Form
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备地图和表单
- en: Before we can incorporate the other examples from [Chapter 6](ch06.html "Chapter 6. EXPLORE
    PROXIMITY"), we need to think about the pieces to include on our web page. Obviously,
    we need to include a map. We also need a way to get two locations from the user.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够整合[第6章](ch06.html "第6章. 探索邻近性")中的其他示例之前，我们需要考虑在网页上包含哪些部分。显然，我们需要包含一个地图。我们还需要一种方法从用户那里获取两个位置。
- en: 'Open a new file, and add the following HTML to create a map with a view of
    the entire United States and the input fields we need to get user input:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新文件，并添加以下HTML来创建一个包含整个美国视图和获取用户输入所需输入字段的地图：
- en: '[PRE48]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'I have included the jQuery JavaScript library ❶, which we''ll use later to
    connect to Yelp. Looking ahead, I added the `gdir` variable ❷ to hold driving
    directions from Google. Save and load the file, and it will look like [Figure 10-15](ch10s06.html#the_foundation_of_the_mashup_colon_our_m
    "Figure 10-15. The foundation of the mashup: our map and form").'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经包含了jQuery JavaScript库❶，我们稍后会用它来连接到Yelp。展望未来，我添加了`gdir`变量❷来保存来自Google的驾驶方向。保存并加载文件，它将看起来像[图10-15](ch10s06.html#the_foundation_of_the_mashup_colon_our_m
    "图10-15. 混合应用的基础：我们的地图和表单")。
- en: '![The foundation of the mashup: our map and form](httpatomoreillycomsourcenostarchimages672139.png.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![混合应用的基础：我们的地图和表单](httpatomoreillycomsourcenostarchimages672139.png.jpg)'
- en: 'Figure 10-15. The foundation of the mashup: our map and form'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-15. 混合应用的基础：我们的地图和表单
- en: Note that the form doesn't do anything right now. If you click the Submit button
    or press enter within a text field, it will attempt to call the `goDir()` function,
    as instructed in the HTML ❸. The function does not exist yet, however, so the
    next step is to create it. We'll do that and retrieve driving directions from
    the user's input in the next section.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当前这个表单没有任何功能。如果你点击提交按钮或在文本字段中按下回车键，它将尝试调用`goDir()`函数，正如HTML ❸中指示的那样。然而，该函数目前还不存在，所以下一步是创建它。我们将在下一节中完成这个任务，并从用户的输入中检索行驶方向。
- en: Retrieve Driving Directions
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索行驶方向
- en: This mashup *could* have found the midpoint between two start and end points,
    but that would have only been the middle if you and your friends are crows. Or
    pilots. You are much more likely to drive than to fly, so we'll use Google's driving
    directions API.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这个混合应用*可以*找到两个起点和终点之间的中点，但这只有在你和你的朋友都是乌鸦或飞行员的情况下才成立。你更有可能开车而不是飞行，所以我们将使用谷歌的行驶方向API。
- en: 'As you may recall from [Chapter 6](ch06.html "Chapter 6. EXPLORE PROXIMITY"),
    to retrieve driving directions we first need to tell Google to load the appropriate
    code. In the `create_map` function, add the following lines to prepare for driving
    directions:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从[第6章](ch06.html "第6章. 探索邻近性")中可能记得的，要检索行驶方向，我们首先需要告诉谷歌加载适当的代码。在`create_map`函数中，添加以下行以准备行驶方向：
- en: '[PRE49]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: First, we've created a comment ❶ to note that we're writing provider-specific
    code; in this case, the code only works with Google. If you ever need to convert
    this mashup to use a different mapping provider, including this will be helpful.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个注释❶来标记我们正在编写特定提供商的代码；在这种情况下，这段代码只与谷歌兼容。如果你需要将这个混合应用转换为使用不同的地图提供商，这将是有帮助的。
- en: In order to use driving directions, we must create a `DirectionsService` object
    ❷. Later, we can call functions on that object or pass it to other functions.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用行驶方向，我们必须创建一个`DirectionsService`对象❷。稍后，我们可以调用该对象上的函数或将它传递给其他函数。
- en: 'Now that we are ready to look up driving directions, let''s write the `goDir`
    function. This function gets called when the user fills out the form. Add this
    code to the JavaScript section but outside the `create_map` function:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好查找行驶方向，让我们编写`goDir`函数。当用户填写表单时，这个函数会被调用。将此代码添加到JavaScript部分，但不在`create_map`函数内：
- en: '[PRE50]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The purpose of the `goDir` function is to hand off the two locations to the
    driving directions service. We first store the text the user entered into variables.
    In case this is a subsequent search and the map already contains results, we need
    to clear the map of markers and polylines before calling for directions.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`goDir`函数的目的是将两个位置传递给行驶方向服务。我们首先将用户输入的文本存储到变量中。如果这是一个后续搜索，并且地图已经包含结果，在调用方向之前，我们需要清除地图上的标记和折线。'
- en: Now we are ready to pass the locations to Google's directions. We include them
    in a special options object ❸. Then we can call the directions service using the
    options and also give Google a callback function ❹.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好将位置传递给谷歌的方向服务。我们将它们包含在一个特殊选项对象❸中。然后我们可以使用这些选项调用方向服务，并给谷歌提供一个回调函数❹。
- en: 'Before we find the midpoint, let''s add the directions to the map. Here is
    the code for the callback function:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们找到中点之前，让我们将方向添加到地图上。以下是回调函数的代码：
- en: '[PRE51]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This function is passed the results from the Google driving directions service.
    From the results, we can get the points ❺ that make up the route. Then, loop through
    those points, adding each to a new array of points ❻ after converting each into
    a Mapstraction `LatLonPoint`.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接收谷歌行驶方向服务的输出结果。从结果中，我们可以获取构成路线的点❺。然后，遍历这些点，将每个点转换为Mapstraction `LatLonPoint`后，添加到新的点数组❻中。
- en: 'When we have all the points in the route, we can use them to create a new polyline.
    The line will serve as a visual of the entire route between the two locations,
    as shown in [Figure 10-16](ch10s06.html#the_full_directions_shown_while_we_find
    "Figure 10-16. The full directions shown while we find coffee shops"). We''re
    almost ready to find the midpoint, but we need one more thing from the Google
    directions: the total route distance (in km) ❼. Then, we pass the new array of
    points and the distance to the `findMidpoint` function ❽.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有了路线上的所有点后，我们可以使用它们来创建一个新的折线。这条线将作为两个位置之间整个路线的视觉表示，如图[图10-16](ch10s06.html#the_full_directions_shown_while_we_find
    "图10-16. 在我们寻找咖啡馆时显示的完整方向")所示。我们几乎准备好找到中点，但我们需要从谷歌方向中获取一个额外的信息：总路线距离（公里）❽。然后，我们将新的点数组和距离传递给`findMidpoint`函数❽。
- en: In the next section, we'll create that function, which does most of the real
    work involved in this mashup.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建那个函数，它完成了这个混合应用中大部分的实际工作。
- en: '![The full directions shown while we find coffee shops](httpatomoreillycomsourcenostarchimages672141.png.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![在找到咖啡店时显示的完整方向](httpatomoreillycomsourcenostarchimages672141.png.jpg)'
- en: Figure 10-16. The full directions shown while we find coffee shops
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-16. 在找到咖啡店时显示的完整方向
- en: Find the Route's Midpoint
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到路线的中点
- en: Now that we've set up the web page and retrieved the route from Google's directions
    service, we need to write the code to traverse the route data returned. As we
    go through each point in the directions, we'll add the total distance traveled
    so far, stopping when we've gone half the total distance.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了网页并从Google的方向服务中检索了路线，我们需要编写代码来遍历返回的路线数据。当我们遍历方向中的每个点时，我们将添加到目前为止的总行程距离，直到我们走了一半的总距离。
- en: 'The `findMidpoint` function receives two arguments, the route points and the
    total distance. Add the function to your JavaScript code but outside other functions:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`findMidpoint`函数接收两个参数，即路线点和总距离。将此函数添加到您的JavaScript代码中，但放在其他函数之外：'
- en: '[PRE52]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Each time through the loop, we look at two points—the previous point and the
    current one. Because we need two points, our loop begins at 1 (the second point)
    instead of 0\. We calculate the distance between these two points. As long as
    the distance between all points so far is less than half the total distance ❶,
    we just add the distance between the two points to a running total and move on
    to the next point in the loop.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 每次通过循环，我们查看两个点——前一个点和当前点。因为我们需要两个点，所以我们的循环从1（第二个点）开始，而不是从0开始。我们计算这两个点之间的距离。只要到目前为止所有点之间的距离小于总距离的一半
    ❶，我们就将这两个点之间的距离加到运行总和中，然后继续循环到下一个点。
- en: Once we have found a halfway point, the real work begins. Most likely the point
    we found is actually *farther* than halfway. Because we are looking at each point
    in order, however, we know the two points that our midpoint is between. And we
    can calculate how far between the two points ❷ we need to go for the midpoint.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了中点，真正的任务就开始了。我们找到的点很可能实际上比中点更远。然而，因为我们按顺序查看每个点，所以我们知道中点在两个点之间。我们可以计算出我们需要走多远
    ❷ 才能到达中点。
- en: 'Now that we have two points and a distance from the first to the second, we
    have all the information needed to use the example from [#40: Find a Point Along
    a Line](ch06s05.html "#40: Find a Point Along a Line") in [#40: Find a Point Along
    a Line](ch06s05.html "#40: Find a Point Along a Line"). The two functions from
    that project, `get_bearing` and `get_destination`, are reprinted at the end of
    this section.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们有了两个点以及从第一个点到第二个点的距离，我们拥有了使用[第40节：在直线上找到一点](ch06s05.html "#40: Find a Point
    Along a Line")中示例所需的所有信息。[第40节：在直线上找到一点](ch06s05.html "#40: Find a Point Along
    a Line")项目中的两个函数`get_bearing`和`get_destination`在本节末尾重新打印。'
- en: When we have the midpoint, we can use it to create a marker ❸, which we add
    to the map. Then we will also use that point to search Yelp. But first we need
    to determine what radius to send to search. Yelp will accept anything that is
    25 miles or less. If our user is only searching a route across town, 25 miles
    is probably a longer search than the entire route. Yet, if we choose too small
    a radius, we run the risk of there not being any coffee nearby when the midpoint
    is in a more rural area.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有了中点，我们可以用它来创建一个标记 ❸，并将其添加到地图上。然后我们也将使用那个点来搜索Yelp。但首先我们需要确定要发送给搜索的半径。Yelp可以接受25英里或更小的任何东西。如果我们用户只是在镇上搜索路线，25英里的搜索可能比整个路线更长。然而，如果我们选择半径太小，当中点在更乡村地区时，附近可能没有咖啡的风险。
- en: I've chosen to make the search radius at least one mile, but then I add ten
    percent of the total distance. That way, small distances have proportionally small
    search radii. And, if my users are driving across the country, a radius of 25
    miles is reasonable.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择将搜索半径至少设置为1英里，然后再加上总距离的10%。这样，小距离会有相应较小的搜索半径。而且，如果我的用户正在穿越整个国家，25英里的半径是合理的。
- en: 'Finally, we send all this information to Yelp ❹. Before we get to that, here
    are the reprinted functions from [Chapter 6](ch06.html "Chapter 6. EXPLORE PROXIMITY"):'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所有这些信息发送到Yelp ❹。在我们到达那里之前，这里有一些从[第6章](ch06.html "第6章。探索邻近性")重新打印的函数：
- en: '[PRE53]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now the only thing missing from this mashup is the call to Yelp. We'll write
    that in the next section.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一缺少的是对Yelp的调用。我们将在下一节中编写它。
- en: Search for Coffee on Yelp
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Yelp上搜索咖啡
- en: This mashup isn't just about finding a midpoint; it's about finding a place
    to meet near that midpoint. As the title of the mashup suggests, we're searching
    for coffee shops, though you could have your mashup search for any keyword you
    want. To perform the search, we'll use Yelp, a site that catalogues local businesses.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这个混合应用不仅仅是找到中点；它是在中点附近找到一个会面的地方。正如混合应用的标题所暗示的，我们正在搜索咖啡馆，尽管你的混合应用可以搜索任何你想要的关键词。为了执行搜索，我们将使用
    Yelp，这是一个记录本地商业的网站。
- en: Yelp has an API that makes searching based on a latitude and longitude point
    easy. Better yet, the response from Yelp is in JSON, a format that makes incorporating
    it into our mashup quick. Before you can use the API, you'll need to get an access
    key, just as you did for maps. Sign up as a Yelp developer at [http://yelp.com/developers](http://yelp.com/developers).
    Now you're ready to make your first call to the Yelp API. The base URL is *api.yelp.com/business_review_search*,
    but we'll also include the parameters shown in [Table 10-3](ch10s06.html#yelp_api_search_options
    "Table 10-3. Yelp API Search Options").
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Yelp 提供了一个 API，使得基于纬度和经度点的搜索变得简单。更好的是，Yelp 的响应以 JSON 格式返回，这种格式使得将其整合到我们的混合应用中变得快速。在使用
    API 之前，你需要获取一个访问密钥，就像你为地图所做的那样。在 [http://yelp.com/developers](http://yelp.com/developers)
    上注册成为 Yelp 开发者。现在你已准备好对 Yelp API 进行第一次调用。基本 URL 是 *api.yelp.com/business_review_search*，但我们还会包括
    [表 10-3](ch10s06.html#yelp_api_search_options "表 10-3. Yelp API 搜索选项") 中显示的参数。
- en: 'You can try out a few searches in your browser and see the text for the JSON
    results. For example, here''s a snippet response:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在浏览器中尝试一些搜索并查看 JSON 结果的文本。例如，这里是一个响应片段：
- en: '[PRE54]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Table 10-3. Yelp API Search Options
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-3. Yelp API 搜索选项
- en: '| Argument | Description |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ywsid` | Your API key (required) |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `ywsid` | 你的 API 密钥（必需） |'
- en: '| `num_biz_requested` | Number of search results |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `num_biz_requested` | 请求的搜索结果数量 |'
- en: '| `term` | Keyword(s) to search |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| `term` | 搜索的关键词（s） |'
- en: '| `lat` | Latitude of search point |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `lat` | 搜索点的纬度 |'
- en: '| `long` | Longitude of search point |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 搜索点的经度 |'
- en: '| `radius` | Radius to search (in miles—25 or less) |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `radius` | 搜索半径（以英里为单位—25 或更少） |'
- en: 'Let''s dive in and create the `loadYelp` function that we''ve already called
    in earlier code. Add the following function to your JavaScript section, being
    careful to place it outside all other functions:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨并创建之前代码中已经调用的 `loadYelp` 函数。将以下函数添加到你的 JavaScript 部分，注意要将其放置在其他所有函数之外：
- en: '[PRE55]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `loadYelp` function requires three arguments: the keyword to search, the
    location to search (as a Mapstraction `LatLonPoint`), and the radius (in miles).
    The first thing the function does is use the arguments to create the URL for Yelp''s
    API. We include the `callback` parameter ❶ with a question mark that will be filled
    in by jQuery with a generated function name.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadYelp` 函数需要三个参数：搜索的关键词、搜索的位置（作为一个 Mapstraction `LatLonPoint`），以及半径（以英里为单位）。函数的第一件事是使用参数创建
    Yelp API 的 URL。我们包括一个带有问号的 `callback` 参数❶，jQuery 将用生成的函数名填充它。'
- en: To interpret the results from Yelp, we'll use an anonymous, inline function
    ❷ that accepts a single parameter, `x`, to hold the JSON object results. Once
    we've confirmed that we have usable data, we loop through all the results and
    grab each business listing ❸. From there, we can also find the business' location
    ❹ and other information.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释 Yelp 的结果，我们将使用一个匿名内联函数❷，它接受一个名为 `x` 的单一参数来保存 JSON 对象结果。一旦我们确认我们有可用的数据，我们就循环遍历所有结果并获取每个商业列表❸。从那里，我们还可以找到商业的位置❹和其他信息。
- en: In this example, I created a message box with some simple business information
    and basic styling. You could go wild here and include any HTML you want inside
    the message box. Yelp also provides some fun data in its response that I haven't
    included here. You can get the distance from the search point, average reviews,
    and even pictures of some locations.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我创建了一个包含一些简单商业信息和基本样式的消息框。你可以在这里尽情发挥，在消息框内包含任何你想要的 HTML。Yelp 还在其响应中提供了一些有趣的数据，但我没有在这里包括。你可以获取搜索点的距离、平均评论，甚至是一些地点的图片。
- en: 'When we''re done looping through the results, we''ll have a marker for each
    business. Then we center and zoom on just those markers ❺, passing an array of
    points we collected during the loop. This function is different than one shown
    in [#8: Determine the Correct Zoom Level to Use Based on Markers](ch02s08.html
    "#8: Determine the Correct Zoom Level to Use Based on Markers") in [#7: Loop Through
    All Markers](ch02s07.html "#7: Loop Through All Markers"). The `autoCenterAndZoom`
    function takes polylines into consideration, too, which shows the entire route.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们完成对结果的循环遍历后，我们将为每个商业机构设置一个标记。然后我们只针对这些标记进行居中和缩放❺，传递我们在循环过程中收集到的点数组。这个函数与在[第7节：遍历所有标记](ch02s07.html
    "#7: Loop Through All Markers")中展示的[第8节：根据标记确定正确的缩放级别](ch02s08.html "#8: Determine
    the Correct Zoom Level to Use Based on Markers")不同。`autoCenterAndZoom`函数也考虑了多边形，这显示了整个路线。'
- en: You can see an example search in [Figure 10-17](ch10s06.html#meet_in_the_middle_results_show_coffee_s
    "Figure 10-17. Meet in the Middle results show coffee shops in Kansas between
    Boulder, Colorado, and Little Rock, Arkansas."), where the mashup finds a few
    Kansas coffee shops between Boulder and Little Rock.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图10-17](ch10s06.html#meet_in_the_middle_results_show_c "图10-17. 中间相遇的结果显示了堪萨斯州博尔德和Little
    Rock之间的咖啡店。")中看到一个示例搜索，其中混合体在博尔德和Little Rock之间找到了几个堪萨斯州的咖啡店。
- en: '![Meet in the Middle results show coffee shops in Kansas between Boulder, Colorado,
    and Little Rock, Arkansas.](httpatomoreillycomsourcenostarchimages672143.png.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![中间相遇的结果显示了堪萨斯州博尔德和Little Rock之间的咖啡店](httpatomoreillycomsourcenostarchimages672143.png.jpg)'
- en: Figure 10-17. Meet in the Middle results show coffee shops in Kansas between
    Boulder, Colorado, and Little Rock, Arkansas.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-17. 在科罗拉多州的博尔德和阿肯色州的小石城之间的堪萨斯州，中间相遇的结果显示了咖啡店。
- en: The next time you want to meet a friend, either across town or across the country,
    neither of you has to drive the whole way. You can meet halfway, thanks to driving
    directions, a little math, Yelp, and this little mashup you've just created.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 下次你想见一个朋友，无论是城里还是全国范围内，你们中的任何一个人都不需要开车全程。你们可以见个中点，多亏了行车路线、一点数学知识、Yelp以及你刚刚创建的这个小小的混合体。
