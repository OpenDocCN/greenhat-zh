<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Class Hierarchies, Attributes, and Class Variables"><div class="titlepage"><div><div><h1 class="title"><a id="class_hierarchies_comma_attributes_comma"/>Chapter 2. Class Hierarchies, Attributes, and Class Variables</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id2"/><div class="mediaobject"><a id="I_mediaobject2_d1e1329"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>We ended the previous chapter by creating two new classes: a Thing and a Treasure. Despite the fact that these two classes shared some features (notably both had a “name”), there was no connection between them.<a id="IDX-CHP-2-0001" class="indexterm"/></p><p>These two classes are so trivial that this tiny bit of repetition doesn’t really matter much. However, when you start writing real programs of some complexity, your classes will frequently contain numerous variables and methods, and you really don’t want to keep coding the same things over and over again.</p><p>It makes sense to create a class hierarchy in which one class may be a “special type” of some other (ancestor) class, in which case it will automatically inherit the features of its ancestor. In our simple adventure game, for instance, a Treasure is a special type of Thing, so the Treasure class should inherit the features of the Thing class.<a id="IDX-CHP-2-0002" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In this book, I will often talk about descendant classes inheriting features from their ancestor classes. These terms deliberately suggest a kind a family relationship between “related” classes. Each class in Ruby has only one parent. It may, however, descend from a long and distinguished family tree with many generations of parents, grandparents, great-grandparents, and so on.<a id="IDX-CHP-2-0003" class="indexterm"/></p></div><p>The behavior of Things in general will be coded in the Thing class. The Treasure class will automatically “inherit” all the features of the Thing class, so we won’t need to code them all over again; it will then add some additional features, specific to Treasures.</p><p>As a general rule, when creating a class hierarchy, the classes with the most generalized behavior are higher up the hierarchy than classes with more specialist behavior. So, a Thing class with just a name and a description would be the ancestor of a Treasure class that has a name, a description, and, additionally, a value; the Thing class might also be the ancestor of some other specialist class such as a Room that has a name, a description, and exits . . . and so on.</p><div class="sidebar"><a id="one_parent_comma_many_children"/><p class="title">One Parent, Many Children</p><div class="informalfigure"><a id="image_no_caption-id3"/><div class="mediaobject"><a id="I_mediaobject2_d1e1360"/><img src="httpatomoreillycomsourcenostarchimages860142.png" alt="image with no caption"/></div></div><p>This diagram shows a Thing class that has a <span class="emphasis"><em>name</em></span> and a <span class="emphasis"><em>description</em></span> (in a Ruby program, these might be internal variables such as <code class="literal">@name</code> and <code class="literal">@description</code> plus some methods to access them). The Treasure and Room classes both descend from the Thing class, so they automatically “inherit” a <span class="emphasis"><em>name</em></span> and a <span class="emphasis"><em>description</em></span>. The Treasure class adds one new item, <span class="emphasis"><em>value</em></span>, so it now has <span class="emphasis"><em>name</em></span>, <span class="emphasis"><em>description</em></span>, and <span class="emphasis"><em>value</em></span>. The Room class adds <span class="emphasis"><em>exits</em></span>—so it has <span class="emphasis"><em>name</em></span>, <span class="emphasis"><em>description</em></span>, and <span class="emphasis"><em>exits</em></span>.</p></div><p>Let’s see how to create a descendant class in Ruby. Load the <span class="emphasis"><em>1adventure.rb</em></span> program. This starts simply enough with the definition of a Thing class, which has two instance variables, <code class="literal">@name</code> and <code class="literal">@description</code>.</p><p><span class="emphasis"><em>1adventure.rb</em></span></p><a id="I_programlisting2_d1e1426"/><pre class="programlisting">class Thing
    def initialize( aName, aDescription )
      @name         = aName
      @description  = aDescription
    end

    def get_name
        return @name
    end

    def set_name( aName )
        @name = aName
    end

    def get_description
        return @description
    end

    def set_description( aDescription )
        @description = aDescription
    end
end</pre><p>The <code class="literal">@name</code> and <code class="literal">@description</code> variables are assigned values in the <code class="literal">initialize</code> method when a new Thing object is created. Instance variables generally cannot (and should not) be directly accessed from the world outside the class itself, because of the principle of encapsulation (as explained in the previous chapter). To obtain the value of each variable, you need a <span class="emphasis"><em>get</em></span> accessor method such as <code class="literal">get_name</code>; in order to assign a new value, you need a <span class="emphasis"><em>set</em></span> accessor method such as <code class="literal">set_name</code>.<a id="IDX-CHP-2-0004" class="indexterm"/><a id="IDX-CHP-2-0005" class="indexterm"/><a id="IDX-CHP-2-0006" class="indexterm"/></p><div class="sect1" title="Superclasses and Subclasses"><div class="titlepage"><div><div><h1 class="title"><a id="superclasses_and_subclasses"/>Superclasses and Subclasses</h1></div></div></div><p>Now look at the Treasure class, which is also defined in the following program:</p><p><span class="emphasis"><em>1adventure.rb</em></span></p><a id="I_programlisting2_d1e1473"/><pre class="programlisting">class Treasure &lt; Thing
    def initialize( aName, aDescription, aValue )
        super( aName, aDescription )
        @value = aValue
    end

    def get_value
        return @value
    end

    def set_value( aValue )
        @value = aValue
    end
end</pre><p>Notice how the Treasure class is declared:</p><a id="I_programlisting2_d1e1477"/><pre class="programlisting">class Treasure &lt; Thing</pre><p>The left angle bracket (<code class="literal">&lt;</code>) indicates that Treasure is a <span class="emphasis"><em>subclass</em></span>, or descendant, of Thing, and therefore it inherits the data (variables) and behavior (methods) from the Thing class. Since the methods <code class="literal">get_name</code>, <code class="literal">set_name</code>, <code class="literal">get_description</code>, and <code class="literal">set_description</code> already exist in the ancestor class (Thing), these methods don’t need to be recoded in the descendant class (Treasure).<a id="IDX-CHP-2-0007" class="indexterm"/><a id="IDX-CHP-2-0008" class="indexterm"/><a id="IDX-CHP-2-0009" class="indexterm"/><a id="IDX-CHP-2-0010" class="indexterm"/><a id="IDX-CHP-2-0011" class="indexterm"/></p><p>The Treasure class has one additional piece of data, its value (<code class="literal">@value</code>), and I have written <span class="emphasis"><em>get</em></span> and <span class="emphasis"><em>set</em></span> accessors for this. When a new Treasure object is created, its <code class="literal">initialize</code> method is automatically called. A Treasure has three variables to initialize (<code class="literal">@name</code>, <code class="literal">@description</code>, and <code class="literal">@value</code>), so its <code class="literal">initialize</code> method takes three arguments. The first two arguments are passed, using the <code class="literal">super</code> keyword, to the <code class="literal">initialize</code> method of the superclass (Thing) so that the Thing class’s <code class="literal">initialize</code> method can deal with them:</p><a id="I_programlisting2_d1e1555"/><pre class="programlisting">super( aName, aDescription )</pre><p>When used inside a method, the <code class="literal">super</code> keyword calls a method with the same name as the current method in the ancestor or <span class="emphasis"><em>super</em></span>class. If the <code class="literal">super</code> keyword is used on its own, without any arguments being specified, all the arguments sent to the current method are passed to the ancestor method. If, as in the present case, a specific list of arguments (here <code class="literal">aName</code> and <code class="literal">aDescription</code>) is supplied, then only these are passed to the method of the ancestor class.</p></div></div>
<div class="sect1" title="Passing Arguments to the Superclass"><div class="titlepage"><div><div><h1 class="title"><a id="passing_arguments_to_the_superclass"/>Passing Arguments to the Superclass</h1></div></div></div><p>Parentheses matter when calling the superclass! If the argument list is empty and no parentheses are used, <span class="emphasis"><em>all</em></span> arguments are passed to the superclass. But if the argument list is empty and parentheses are used, <span class="emphasis"><em>no</em></span> arguments are passed to the superclass:</p><p><span class="emphasis"><em>super_args.rb</em></span></p><a id="I_programlisting2_d1e1588"/><pre class="programlisting"># This passes a, b, c to the superclass
def initialize( a, b, c, d, e, f )
   super( a, b, c )
end

# This passes a, b, c to the superclass
def initialize( a, b, c )
   super
end

# This passes no arguments to the superclass
def initialize( a, b, c)
   super()
end</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>To gain a better understanding of the use of <code class="literal">super</code>, see <a class="xref" href="ch02s06.html#digging_deeper-id1" title="Digging Deeper">Digging Deeper</a> in <a class="xref" href="ch02s06.html#digging_deeper-id1" title="Digging Deeper">Digging Deeper</a>.</p></div></div>
<div class="sect1" title="Accessor Methods"><div class="titlepage"><div><div><h1 class="title"><a id="accessor_methods"/>Accessor Methods</h1></div></div></div><p>Although the classes in this would-be adventure game work well enough, they are still fairly verbose because of all those <span class="emphasis"><em>get</em></span> and <span class="emphasis"><em>set</em></span> accessors. Let’s see what you can do to remedy this.</p><p>Instead of accessing the value of the <code class="literal">@description</code> instance variable with two different methods, <code class="literal">get_description</code> and <code class="literal">set_description</code>, like this:</p><a id="I_programlisting2_d1e1622"/><pre class="programlisting">puts( t1.get_description )
t1.set_description("Some description" )</pre><p>it would be so much nicer to retrieve and assign values just as you would retrieve and assign values to and from a simple variable, like this:</p><a id="I_programlisting2_d1e1626"/><pre class="programlisting">puts( t1.description )
t1.description = "Some description"</pre><p>To be able to do this, you need to modify the Treasure class definition. One way of accomplishing this would be to rewrite the accessor methods for <code class="literal">@description</code> as follows:<a id="IDX-CHP-2-0012" class="indexterm"/></p><p><span class="emphasis"><em>accessors1.rb</em></span></p><a id="I_programlisting2_d1e1639"/><pre class="programlisting">def description
    return @description
end

def description=( aDescription )
    @description = aDescription
end</pre><p>I have added accessors similar to these in the <span class="emphasis"><em>accessors1.rb</em></span> program. Here, the <span class="emphasis"><em>get</em></span> accessor is called <code class="literal">description</code>, and the <span class="emphasis"><em>set</em></span> accessor is called <code class="literal">description=</code> (that is, it appends an equals sign to the method name used by the corresponding <span class="emphasis"><em>get</em></span> accessor). It is now possible to assign a new string like this:</p><a id="I_programlisting2_d1e1662"/><pre class="programlisting">t.description = "a bit faded and worn around the edges"</pre><p>And you can retrieve the value like this:</p><a id="I_programlisting2_d1e1667"/><pre class="programlisting">puts( t.description )</pre><p>Note that when you write a <span class="emphasis"><em>set</em></span> accessor in this way, you must append the <code class="literal">=</code> character to the method name, not merely place it somewhere between the method name and the arguments. In other words, this is correct:</p><a id="I_programlisting2_d1e1677"/><pre class="programlisting">def name=( aName )</pre><p>but this results in an error:</p><a id="I_programlisting2_d1e1681"/><pre class="programlisting">def name   =  ( aName )</pre></div>
<div class="sect1" title="Attribute Readers and Writers"><div class="titlepage"><div><div><h1 class="title"><a id="attribute_readers_and_writers"/>Attribute Readers and Writers</h1></div></div></div><p>In fact, there is a simpler and shorter way of creating a pair of <span class="emphasis"><em>get</em></span> and <span class="emphasis"><em>set</em></span> accessors simultaneously. All you have to do is use two special methods, <code class="literal">attr_reader</code> and <code class="literal">attr_writer</code>, followed by a <span class="emphasis"><em>symbol</em></span> (a name preceded by a colon):<a id="IDX-CHP-2-0013" class="indexterm"/><a id="IDX-CHP-2-0014" class="indexterm"/></p><a id="I_programlisting2_d1e1710"/><pre class="programlisting">attr_reader :description
attr_writer :description</pre><p>You should add this code inside your class definition like this:</p><a id="I_programlisting2_d1e1714"/><pre class="programlisting">class Thing
   attr_reader :description
   attr_writer :description
    # maybe some more methods here...
end</pre><p>Calling <code class="literal">attr_reader</code> with a symbol has the effect of creating a <span class="emphasis"><em>get</em></span> accessor (here named <code class="literal">description</code>) for an instance variable (<code class="literal">@description</code>) with a name matching the symbol (<code class="literal">:description</code>).</p><p>Calling <code class="literal">attr_writer</code> similarly creates a <span class="emphasis"><em>set</em></span> accessor for an instance variable. Instance variables are considered to be the “attributes” of an object, which is why the <code class="literal">attr_reader</code> and <code class="literal">attr_writer</code> methods are so named.<a id="IDX-CHP-2-0015" class="indexterm"/></p><div class="sidebar"><a id="what_is_a_symbol_question"/><p class="title">What Is a Symbol?</p><p>In Ruby, a <span class="emphasis"><em>symbol</em></span> is a name preceded by a colon (for example, <code class="literal">:description</code>). The Symbol class is defined in the Ruby class library to represent names inside the Ruby interpreter. When you pass one or more symbols as arguments to <code class="literal">attr_reader</code> (which is a method of the Module class), Ruby creates an instance variable and a <span class="emphasis"><em>get</em></span> accessor method. This accessor method returns the value of the corresponding variable; both the instance variable and the accessor method will take the name that was specified by the symbol. So, <code class="literal">attr_reader( :description )</code> creates an instance variable with the name, <code class="literal">@description</code>, and an accessor method named <code class="literal">description()</code>. Symbols are discussed in detail in <a class="xref" href="ch11.html" title="Chapter 11. Symbols">Chapter 11</a>.<a id="IDX-CHP-2-0016" class="indexterm"/></p></div><p>The <span class="emphasis"><em>accessors2.rb</em></span> program contains some examples of attribute readers and writers in action. This is its version of the Thing class:</p><p><span class="emphasis"><em>accessors2.rb</em></span></p><a id="I_programlisting2_d1e1790"/><pre class="programlisting">class Thing

<img src="httpatomoreillycomsourcenostarchimages860146.png" alt=""/>     attr_reader :description
      attr_writer :description
<img src="httpatomoreillycomsourcenostarchimages860150.png" alt=""/>     attr_writer :name

      def initialize( aName, aDescription )
          @name         = aName
          @description  = aDescription
      end

         # get accessor for @name
<img src="httpatomoreillycomsourcenostarchimages860154.png" alt=""/>     def name
          return @name.capitalize
      end

end</pre><p>Here the Thing class explicitly defines a <span class="emphasis"><em>get</em></span> method accessor for the <code class="literal">@name</code> attribute. The advantage of writing a complete method like this is that it gives you the opportunity to do some extra processing rather than simply reading and writing an attribute value. The <span class="emphasis"><em>get</em></span> accessor, <code class="literal">name</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1825"/><img src="httpatomoreillycomsourcenostarchimages860154.png" alt=""/></span>, uses the <code class="literal">String.capitalize</code> method to return the string value of <code class="literal">@name</code> with its initial letter in uppercase.</p><p>When assigning a value to the <code class="literal">@name</code> attribute, I don’t need to do any special processing, so I have given it an attribute writer instead of a <code class="literal">set</code> accessor method <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1846"/><img src="httpatomoreillycomsourcenostarchimages860150.png" alt=""/></span>.</p><p>The <code class="literal">@description</code> attribute needs no special processing at all, so I use <code class="literal">attr_reader</code> and <code class="literal">attr_writer</code> instead of accessor methods in order to get and set the value of the <code class="literal">@description</code> variable <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e1866"/><img src="httpatomoreillycomsourcenostarchimages860146.png" alt=""/></span>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Are they attributes or properties? Don’t be confused by the terminology. In Ruby, an <span class="emphasis"><em>attribute</em></span> is the equivalent of what many programming languages call a <span class="emphasis"><em>property</em></span>.<a id="IDX-CHP-2-0017" class="indexterm"/></p></div><p>When you want both to read and to write a variable, the <code class="literal">attr_accessor</code> method provides a shorter alternative than using both <code class="literal">attr_reader</code> and <code class="literal">attr_writer</code>. I have used this to access the value attribute in the Treasure class:<a id="IDX-CHP-2-0018" class="indexterm"/></p><a id="I_programlisting2_d1e1898"/><pre class="programlisting">attr_accessor :value</pre><p>This is equivalent to the following:</p><a id="I_programlisting2_d1e1902"/><pre class="programlisting">attr_reader :value
attr_writer :value</pre><p>Earlier I said that calling <code class="literal">attr_reader</code> with a symbol actually creates a variable with the same name as the symbol. The <code class="literal">attr_accessor</code> method also does this.</p><p>In the code for the Thing class, this behavior is not obvious since the class has an <code class="literal">initialize</code> method that explicitly creates the variables. The Treasure class, however, makes no reference to the <code class="literal">@value</code> variable in its <code class="literal">initialize</code> method:</p><a id="I_programlisting2_d1e1923"/><pre class="programlisting">class Treasure &lt; Thing
    attr_accessor :value

    def initialize( aName, aDescription )
        super( aName, aDescription )
    end
end</pre><p>The only indication that <code class="literal">@value</code> exists at all is this accessor definition:</p><a id="I_programlisting2_d1e1931"/><pre class="programlisting">attr_accessor :value</pre><p>My code at the bottom of the <span class="emphasis"><em>accessors2.rb</em></span> source file sets the value of each Treasure object as a separate operation, following the creation of the object itself, like this:</p><a id="I_programlisting2_d1e1938"/><pre class="programlisting">t1.value = 800</pre><p>Even though it has never been formally declared, the <code class="literal">@value</code> variable really does exist, and you are able to retrieve its numerical value using the <span class="emphasis"><em>get</em></span> accessor: <code class="literal">t1.value</code>. To be absolutely certain that the attribute accessor really has created <code class="literal">@value</code>, you can always look inside the object using the <code class="literal">inspect</code> method. I have done so in the final two code lines in this program:</p><a id="I_programlisting2_d1e1957"/><pre class="programlisting">puts "This is treasure1: #{t1.inspect}"
puts "This is treasure2: #{t2.inspect}"</pre><p>This displays the data inside the t1 and t2 objects, including the <code class="literal">@value</code> variables:</p><a id="I_programlisting2_d1e1964"/><pre class="programlisting">This is treasure1: #&lt;Treasure:0x33a6c88 @value=100, @name="sword",
 @description="an Elvish weapon forged of gold (now somewhat tarnished)"&gt;
This is treasure2: #&lt;Treasure:0x33a6c4c @value=500, @name="dragon horde",
 @description="a huge pile of jewels"&gt;</pre><p>Attribute accessors can initialize more than one attribute at a time if you send them a list of symbols separated by commas, like this:</p><p><span class="emphasis"><em>accessors3.rb</em></span></p><a id="I_programlisting2_d1e1971"/><pre class="programlisting">attr_reader :name, :description
attr_writer(:name, :description)
attr_accessor(:value, :id, :owner)</pre><p>As always, parentheses around the arguments are optional but, in my view (for reasons of clarity), are to be preferred.<a id="IDX-CHP-2-0019" class="indexterm"/><a id="IDX-CHP-2-0020" class="indexterm"/></p><p>Now let’s see how to put attribute readers and writers to use in my adventure game. Load the <span class="emphasis"><em>2adventure.rb</em></span> program. You will see that I have created two readable attributes in the Thing class: <code class="literal">name</code> and <code class="literal">description</code>. I have also made <code class="literal">description</code> writeable; however, because I don’t plan to change the names of any Thing objects, the <code class="literal">name</code> attribute is not writeable:</p><p><span class="emphasis"><em>2adventure.rb</em></span></p><a id="I_programlisting2_d1e2006"/><pre class="programlisting">attr_reader( :name, :description )
attr_writer( :description )</pre><p>I have created a method called <code class="literal">to_s</code>, which returns a string describing the Treasure object. Recall that all Ruby classes have a <code class="literal">to_s</code> method as standard. The <code class="literal">Thing.to_s</code> method overrides (and replaces) the default one.<a id="IDX-CHP-2-0021" class="indexterm"/></p><a id="I_programlisting2_d1e2022"/><pre class="programlisting">def to_s # override default to_s method
    return "(Thing.to_s):: The #{@name} Thing is #{@description}"
end</pre><p>You can override existing methods when you want to implement new behavior appropriate to the specific class type.<a id="IDX-CHP-2-0022" class="indexterm"/><a id="IDX-CHP-2-0023" class="indexterm"/><a id="IDX-CHP-2-0024" class="indexterm"/><a id="IDX-CHP-2-0025" class="indexterm"/><a id="IDX-CHP-2-0026" class="indexterm"/><a id="IDX-CHP-2-0027" class="indexterm"/></p></div>
<div class="sect1" title="Calling Methods of a Superclass"><div class="titlepage"><div><div><h1 class="title"><a id="calling_methods_of_a_superclass"/>Calling Methods of a Superclass</h1></div></div></div><p>The game in <span class="emphasis"><em>2adventure.rb</em></span> will have two classes descending from Thing: the Treasure class and the Room class. The Treasure class adds a <code class="literal">value</code> attribute, which can be both read and written. Note that its <code class="literal">initialize</code> method calls its superclass in order to initialize the <code class="literal">name</code> and <code class="literal">description</code> attributes before initializing the new <code class="literal">@value</code> variable:<a id="IDX-CHP-2-0028" class="indexterm"/></p><a id="I_programlisting2_d1e2073"/><pre class="programlisting">super( aName, aDescription )
@value = aValue</pre><p>Here, if I had omitted the call to the superclass, the <code class="literal">name</code> and <code class="literal">description</code> attributes would never be initialized. This is because <code class="literal">Treasure.initialize</code> overrides <code class="literal">Thing.initialize</code>, so when a Treasure object is created, the code in <code class="literal">Thing.initialize</code> will <span class="emphasis"><em>not</em></span> automatically be executed.</p><p>On the other hand, the Room class, which also descends from Thing, currently has no <code class="literal">initialize</code> method, so when a new Room object is created, Ruby goes scrambling back up the class hierarchy in search of one. The first <code class="literal">initialize</code> method it finds is in Thing, so a Room object’s <code class="literal">name</code> and <code class="literal">description</code> attributes are initialized there.</p></div>
<div class="sect1" title="Class Variables"><div class="titlepage"><div><div><h1 class="title"><a id="class_variables"/>Class Variables</h1></div></div></div><p>A few other interesting things are going on in this program. Right at the top of the Thing class you will see this:</p><a id="I_programlisting2_d1e2115"/><pre class="programlisting">@@num_things = 0</pre><p>The two <code class="literal">@</code> characters at the start of this variable name, <code class="literal">@@num_things</code>, define this to be a <span class="emphasis"><em>class variable</em></span>. The variables we’ve used inside classes up to now have been instance variables, preceded by a single <code class="literal">@</code>, like <code class="literal">@name</code>. Whereas each new object (or instance) of a class assigns its own values to its own instance variables, all objects derived from a specific class share the same class variables. I have assigned 0 to the <code class="literal">@@num_things</code> variable to ensure that it has a meaningful value at the outset.<a id="IDX-CHP-2-0029" class="indexterm"/></p><p>Here, the <code class="literal">@@num_things</code> class variable is used to keep a running total of the number of Thing objects in the game. It does this simply by incrementing the class variable (by adding 1 to it: <code class="literal">+= 1</code>) in its <code class="literal">initialize</code> method every time a new object is created:<a id="IDX-CHP-2-0030" class="indexterm"/></p><a id="I_programlisting2_d1e2155"/><pre class="programlisting">@@num_things += 1</pre><p>If you look later in the code, you will see that I have created a Map class to contain an array of rooms. This includes a version of the <code class="literal">to_s</code> method that prints information on each room in the array. Don’t worry about the implementation of the Map class right now; we’ll be looking at arrays and their methods in <a class="xref" href="ch04.html" title="Chapter 4. Arrays and Hashes">Chapter 4</a>.</p><a id="I_programlisting2_d1e2164"/><pre class="programlisting">class Map

    def initialize( someRooms )
        @rooms = someRooms
    end

    def to_s
        @rooms.each {
            |a_room|
            puts(a_room)
        }
    end

end</pre><p>Scroll to the code at the bottom of the file, and run the program to see how I have created and initialized all the objects and used the class variable, <code class="literal">@@num_things</code>, to keep a tally of all the Thing objects that have been created.</p><div class="sidebar"><a id="class_variables_and_instance_variables"/><p class="title">Class Variables and Instance Variables</p><div class="informalfigure"><a id="image_no_caption-id4"/><div class="mediaobject"><a id="I_mediaobject2_d1e2175"/><img src="httpatomoreillycomsourcenostarchimages860158.png" alt="image with no caption"/></div></div><p>This diagram shows a Thing class (the rectangle) that contains a class variable, <code class="literal">@@num_things</code>, and an instance variable, <code class="literal">@name</code>. The three oval shapes represent “Thing objects”—that is, instances of the Thing class. When one of these objects assigns a value to its instance variable, <code class="literal">@name</code>, that value affects only the <code class="literal">@name</code> variable in the object itself. So here, each object has a different value for <code class="literal">@name</code>. But when an object assigns a value to the class variable, <code class="literal">@@num_things</code>, that value “lives inside” the Thing class and is shared by all instances of that class. Here <code class="literal">@@num_things</code> equals 3, and that is true for all the Thing objects.</p></div><div class="sidebar"><a id="digging_deeper-id1"/><p class="title">Digging Deeper</p><p>Every class you create will descend from one or more other classes. Here I explain the fundamentals of the Ruby class hierarchy.<a id="IDX-CHP-2-0031" class="indexterm"/><a id="IDX-CHP-2-0032" class="indexterm"/></p><p><span class="bolditalic">Superclasses</span></p><p>To understand how the <code class="literal">super</code> keyword works, take a look at the sample program <span class="emphasis"><em>super.rb</em></span>. This contains five related classes. The Thing class is the ancestor of all the others, and from Thing descends Thing2, from Thing2 descends Thing3, from Thing3 descends Thing4, and from Thing4 descends Thing5.</p><p><span class="emphasis"><em>super.rb</em></span></p><a id="I_programlisting2_d1e2231"/><pre class="programlisting">class Thing
    def initialize( aName, aDescription )
        @name = aName
        @description = aDescription
        puts("Thing.initialize: #{self.inspect}\n\n")
    end

    def aMethod( aNewName )
        @name = aNewName
        puts("Thing.aMethod: #{self.inspect}\n\n")
    end
end

class Thing2 &lt; Thing
    def initialize( aName, aDescription )
        super
        @fulldescription = "This is #{@name}, which is #{@description}"
        puts("Thing2.initialize: #{self.inspect}\n\n")
    end

    def aMethod( aNewName, aNewDescription )
        super( aNewName )
        puts("Thing2.aMethod: #{self.inspect}\n\n")
    end
end

class Thing3 &lt; Thing2
    def initialize( aName, aDescription, aValue )
        super( aName, aDescription )
        @value = aValue
        puts("Thing3.initialize: #{self.inspect}\n\n")
    end

    def aMethod( aNewName, aNewDescription, aNewValue )
        super( aNewName, aNewDescription )
        @value = aNewValue
        puts("Thing3.aMethod: #{self.inspect}\n\n")
    end
end

class Thing4 &lt; Thing3
    def aMethod
        puts("Thing4.aMethod: #{self.inspect}\n\n")
    end
end

class Thing5 &lt; Thing4
end</pre><p>Let’s take a closer look at the first three classes in this hierarchy: The Thing class has two instance variables, <code class="literal">@name</code> and <code class="literal">@description</code>. Thing2 also defines <code class="literal">@fulldescription</code> (a string that contains <code class="literal">@name</code> and <code class="literal">@description</code>); Thing3 adds yet another variable, <code class="literal">@value</code>.</p><p>These three classes each contain an <code class="literal">initialize</code> method that sets the values of the variables when a new object is created; they also each have a method named, rather inventively, <code class="literal">aMethod</code>, which changes the value of one or more variables. The descendant classes, Thing2 and Thing3, both use the <code class="literal">super</code> keyword in their methods.</p><p>At the bottom of this code unit I’ve written a “main” loop that executes when you run the program. Don’t worry about the syntax of this; you’ll be learning about loops in <a class="xref" href="ch05.html" title="Chapter 5. Loops and Iterators">Chapter 5</a>. I’ve added this loop so that you can easily run the different bits of code contained in the methods, <code class="literal">test1</code> to <code class="literal">test5</code>. You can run the program in a command window and enter a number, 1 to 5, when prompted, or Q to quit. When you run it for the first time, type <strong class="userinput"><code>1</code></strong> at the prompt and press the <span class="keycap">enter</span> key. This will run the <code class="literal">test1</code> method containing these two lines of code:</p><a id="I_programlisting2_d1e2285"/><pre class="programlisting">t = Thing.new( "A Thing", "a lovely thing full of thinginess" )
t.aMethod( "A New Thing" )</pre><p>The first line here creates and initializes a Thing object, and the second line calls its <code class="literal">aMethod</code> method. Because the Thing class doesn’t descend from anything special, nothing very new or interesting happens here. In fact, as with all Ruby classes, Thing descends from the Object class, which is the ancestor of all other classes (with the sole exception of the BasicObject class in Ruby 1.9, as explained later in this chapter). The output uses the <code class="literal">inspect</code> method to display the internal structure of the object when the <code class="literal">Thing.initialize</code> and <code class="literal">Thing.aMethod</code> methods are called. This is the result:</p><a id="I_programlisting2_d1e2302"/><pre class="programlisting">Thing.initialize: #&lt;Thing:0x28e0290 @name="A Thing",
 @description="a lovely thing full of thinginess"&gt;
Thing.aMethod: #&lt;Thing:0x28e0290 @name="A New Thing", @description="a
 lovely thing full of thinginess"&gt;</pre><p>The <code class="literal">inspect</code> method can be used with all objects and is an invaluable debugging aid. Here, it shows a hexadecimal number, which identifies this specific object followed by the string values of the <code class="literal">@name</code> and <code class="literal">@description</code> variables.</p><p>Now enter <strong class="userinput"><code>2</code></strong> at the prompt to run <code class="literal">test2</code>, which contains the following code:</p><a id="I_programlisting2_d1e2323"/><pre class="programlisting">t2 = Thing2.new( "A Thing2", "a Thing2 thing of great beauty" )
t2.aMethod( "A New Thing2", "a new Thing2 description" )</pre><p>This creates a Thing2 object, t2, and calls <code class="literal">t2.aMethod</code>. Look carefully at the output. You will see that even though t2 is a Thing2 object, it is the Thing class’s <code class="literal">initialize</code> method that is called first. And only then is the Thing2 class’s <code class="literal">initialize</code> called.</p><a id="I_programlisting2_d1e2336"/><pre class="programlisting">Thing.initialize: #&lt;Thing2:0x2a410a0 @name="A Thing2",
 @description="a Thing2 thing of great beauty"&gt;

Thing2.initialize: #&lt;Thing2:0x2a410a0 @name="A Thing2", @description="a Thing2
 thing of great beauty", @fulldescription="This is A Thing2, which is a Thing2
 thing of great beauty"&gt;</pre><p>To understand why this is so, look at the code of the Thing2 class’s <code class="literal">initialize</code> method:</p><a id="I_programlisting2_d1e2343"/><pre class="programlisting">def initialize( aName, aDescription )
   super
   @fulldescription = "This is #{@name}, which is #{@description}"
   puts("Thing2.initialize: #{self.inspect}\n\n")
end</pre><p>This uses the <code class="literal">super</code> keyword to call the <code class="literal">initialize</code> method of Thing2’s ancestor, or <span class="emphasis"><em>superclass</em></span>. The superclass of Thing2 is Thing, as you can see from its declaration:<a id="IDX-CHP-2-0033" class="indexterm"/></p><a id="I_programlisting2_d1e2359"/><pre class="programlisting">class Thing2 &lt; Thing</pre><p>In Ruby, when the <code class="literal">super</code> keyword is used on its own (that is, without any arguments), it passes all the arguments from the current method (here <code class="literal">Thing2.initialize</code>) to a method with the same name in its superclass (here <code class="literal">Thing.initialize</code>). Alternatively, you can explicitly specify a list of arguments following <code class="literal">super</code>. So, in this case, the following code would have the same effect:</p><a id="I_programlisting2_d1e2376"/><pre class="programlisting">super( aName, aDescription )</pre><p>Although it is permissible to use the <code class="literal">super</code> keyword all on its own, it is often preferable to explicitly specify the list of arguments to be passed to the superclass, for the sake of clarity. If you want to pass only a limited number of the arguments sent to the current method, an explicit argument list is necessary. Thing2’s <code class="literal">aMethod</code>, for example, passes only the <code class="literal">aName</code> argument to the <code class="literal">initialize</code> method of its superclass, Thing1:</p><a id="I_programlisting2_d1e2392"/><pre class="programlisting">super( aNewName )</pre><p>This explains why the <code class="literal">@description</code> variable is not changed when <code class="literal">Thing2.aMethod</code> is called.</p><p>Now if you look at Thing3, you will see that this adds one more variable, <code class="literal">@value</code>. In its implementation of <code class="literal">initialize</code>, it passes the two arguments, <code class="literal">aName</code> and <code class="literal">aDescription</code>, to its superclass, Thing2. In its turn, as you’ve already seen, Thing2’s <code class="literal">initialize</code> method passes these same arguments to the <code class="literal">initialize</code> method of its superclass, Thing.</p><p>With the program running, enter <strong class="userinput"><code>3</code></strong> at the prompt to view the output. The following code will execute:</p><a id="I_programlisting2_d1e2428"/><pre class="programlisting">t3 = Thing3.new("A Thing3", "a Thing3 full of Thing and Thing2iness",500)
t3.aMethod( "A New Thing3", "and a new Thing3 description",1000)</pre><p>Note how the flow of execution goes right up the hierarchy so that code in the <code class="literal">initialize</code> and <code class="literal">aMethod</code> methods of Thing execute before code in the matching methods of Thing2 and Thing3.</p><p>It is not obligatory to override a superclass’s methods as I have done in the examples so far. This is required only when you want to add some new behavior. Thing4 omits the <code class="literal">initialize</code> method but implements the <code class="literal">aMethod</code> method.</p><p>Enter <strong class="userinput"><code>4</code></strong> at the prompt to execute the following code:</p><a id="I_programlisting2_d1e2451"/><pre class="programlisting">t4 = Thing4.new( "A Thing4", "the nicest Thing4 you will ever see", 10 )
t4.aMethod</pre><p>When you run it, notice that the first available <code class="literal">initialize</code> method is called when a Thing4 object is created. This happens to be <code class="literal">Thing3.initialize</code>, which, once again, also calls the <code class="literal">initialize</code> methods of its ancestor classes, Thing2 and Thing. However, the <code class="literal">aMethod</code> method implemented by Thing4 contains no call to its superclasses, so this executes right away, and the code in any other <code class="literal">aMethod</code> methods in the ancestor classes is ignored:</p><a id="I_programlisting2_d1e2471"/><pre class="programlisting">def aMethod
    puts("Thing4.aMethod: #{self.inspect}\n\n")
end</pre><p>Finally, Thing5 inherits from Thing4 and doesn’t introduce any new data or methods. Enter <strong class="userinput"><code>5</code></strong> at the prompt to execute the following:</p><a id="I_programlisting2_d1e2478"/><pre class="programlisting">t5 = Thing5.new( "A Thing5", "a very simple Thing5", 40 )
t5.aMethod</pre><p>This time, you will see that the call to <code class="literal">new</code> causes Ruby to backtrack through the class hierarchy until it finds the first <code class="literal">initialize</code> method. This happens to belong to Thing3 (which also calls the <code class="literal">initialize</code> methods of Thing2 and Thing). The first implementation of <code class="literal">aMethod</code>, however, occurs in Thing4, and there are no calls to <code class="literal">super</code>, so that’s where the trail ends.<a id="IDX-CHP-2-0034" class="indexterm"/><a id="IDX-CHP-2-0035" class="indexterm"/></p><p><span class="bolditalic">The Root of All Classes</span></p><p>As I mentioned earlier, all our Ruby classes will ultimately descend from the Object class. You may think of Object as the “root” or “base” class of the Ruby hierarchy. In Ruby 1.8 this is literally true—there are no classes from which Object itself descends. In Ruby 1.9, however, Object is derived from a new class called BasicObject. This new class was created to provide programmers with a very lightweight class—one that supplies only the bare minimum of methods for creating objects, testing equality, and manipulating special methods called <span class="emphasis"><em>singletons</em></span>. (I’ll talk more about singletons in <a class="xref" href="ch07.html" title="Chapter 7. Methods">Chapter 7</a>.)<a id="IDX-CHP-2-0036" class="indexterm"/><a id="IDX-CHP-2-0037" class="indexterm"/><a id="IDX-CHP-2-0038" class="indexterm"/><a id="IDX-CHP-2-0039" class="indexterm"/></p><p>The Ruby 1.9 Object class inherits the methods from BasicObject and adds a number of new methods of its own. BasicObject does not exist in Ruby 1.8, and the Object class supplies all the methods provided by the combination of BasicObject and Object in Ruby 1.9. Since all normal Ruby classes—both Ruby 1.8 and Ruby 1.9—descend from Object, you may generally think of Object as being the “root” of all other classes. Just bear in mind that in Ruby 1.9, the ultimate ancestor of all classes is BasicObject.</p><p>The root class itself has no superclass, and any attempt to locate its superclass will return <code class="literal">nil</code>. You can see this for yourself by running <span class="emphasis"><em>superclasses.rb</em></span>. This calls the <code class="literal">superclass</code> method to climb up the class hierarchy from the Three class to the Object or BasicObject class. At each turn through the loop, the variable <code class="literal">x</code> is assigned the class of <code class="literal">x</code>’s immediate parent until <code class="literal">x</code> equals <code class="literal">nil</code>. Here <code class="literal">class</code> and <code class="literal">superclass</code> are methods that return references to Ruby classes rather than to objects created from those classes. The <code class="literal">begin..until</code> block is one of Ruby’s looping constructs, which you’ll look at in more detail in <a class="xref" href="ch05.html" title="Chapter 5. Loops and Iterators">Chapter 5</a>.</p><p><span class="emphasis"><em>superclasses.rb</em></span></p><a id="I_programlisting2_d1e2572"/><pre class="programlisting">class One
end

class Two &lt; One
end

class Three &lt; Two
end

# Create ob as instance of class Three
# and display the class name
ob = Three.new
x = ob.class
puts( x )

# now climb back through the hierarchy to
# display all ancestor classes of ob
begin
    x = x.superclass
    puts(x.inspect)
end until x == nil</pre><p>The previous code displays the following output:<a id="IDX-CHP-2-0040" class="indexterm"/><a id="IDX-CHP-2-0041" class="indexterm"/><a id="IDX-CHP-2-0042" class="indexterm"/><a id="IDX-CHP-2-0043" class="indexterm"/><a id="IDX-CHP-2-0044" class="indexterm"/></p><a id="I_programlisting2_d1e2596"/><pre class="programlisting">Three
Two
One
Object
BasicObject    # Ruby 1.9 only!
nil</pre><p><span class="bolditalic">Constants Inside Classes</span></p><p>There may be times when you need to access constants (identifiers beginning with a capital letter, which are used to store nonchanging values) declared inside a class. Let’s assume you have this class:</p><p><span class="emphasis"><em>classconsts.rb</em></span></p><a id="I_programlisting2_d1e2606"/><pre class="programlisting">class X
   A = 10

   class Y
   end
end</pre><p>To access the constant <code class="literal">A</code>, you would need to use the special scope resolution operator <code class="literal">::</code> like this:</p><a id="I_programlisting2_d1e2616"/><pre class="programlisting">X::A</pre><p>Class names are constants, so this same operator gives you access to classes inside other classes. This makes it possible to create objects from “nested” classes such as class <code class="literal">Y</code> inside class <code class="literal">X</code>:</p><a id="I_programlisting2_d1e2626"/><pre class="programlisting">ob = X::Y.new</pre><p><span class="bolditalic">Partial Classes</span></p><p>In Ruby it is not obligatory to define a class all in one place. If you want, you can define a single class in separate parts of your program. When a class descends from a specific superclass, each subsequent partial (or <span class="emphasis"><em>open</em></span>) class definition may optionally repeat the superclass in its definition using the <code class="literal">&lt;</code> operator.<a id="IDX-CHP-2-0045" class="indexterm"/><a id="IDX-CHP-2-0046" class="indexterm"/></p><p>Here I create one class, A, and another that descends from it, B:</p><p><span class="emphasis"><em>partial_classes.rb</em></span></p><a id="I_programlisting2_d1e2655"/><pre class="programlisting">class A
   def a
      puts( "a" )
   end
end

class B &lt; A
   def ba1
      puts( "ba1" )
   end
end

class A
   def b
      puts( "b" )
   end
end

class B &lt; A
   def ba2
      puts( "ba2" )
   end
end</pre><p>Now, if I create a B object, all the methods of both A and B are available to it:</p><a id="I_programlisting2_d1e2659"/><pre class="programlisting">ob = B.new
ob.a
ob.b
ob.ba1
ob.ba2</pre><p>You can also use partial class definitions to add features to Ruby’s standard classes such as Array:</p><a id="I_programlisting2_d1e2663"/><pre class="programlisting">class Array
   def gribbit
      puts( "gribbit" )
   end
end</pre><p>This adds the <code class="literal">gribbit</code> method to the Array class so that the following code can now be executed:</p><a id="I_programlisting2_d1e2670"/><pre class="programlisting">[1,2,3].gribbit</pre></div></div></body></html>