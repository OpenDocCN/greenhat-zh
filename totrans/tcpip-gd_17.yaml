- en: Part III-6. TCP/IP GENERAL FILE TRANSFER PROTOCOLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 72](ch72.html "Chapter 72. FILE TRANSFER PROTOCOL (FTP)")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 73](ch73.html "Chapter 73. TRIVIAL FILE TRANSFER PROTOCOL (TFTP)")'
  prefs: []
  type: TYPE_NORMAL
- en: 'File and message transfer protocols represent the most basic type of network
    communication: the simple movement of blocks of data. Of the many file and message
    transfer methods, the most fundamental application is what I call *general file
    transfer*. General file transfer protocols perform one main function: allowing
    files to be copied from one computer to another.'
  prefs: []
  type: TYPE_NORMAL
- en: Since file transfer protocols move files from place to place without much consideration
    of their contents, they are relatively unsophisticated compared with certain message-processing
    applications. However, the idea of being able to move files around is so important
    that general file transfer protocols were one of the very first applications in
    internetworking. While many people now use electronic mail or web browsers to
    perform the functions formerly performed exclusively using general file transfer,
    these older protocols are still very important and widely used, and important
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part covers the two TCP/IP general file transfer protocols: the File Transfer
    Protocol (FTP) and the Trivial File Transfer Protocol (TFTP). Each is described
    in its own chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between FTP and TFTP is similar to that of the two transport
    protocols, the Transmission Control Protocol (TCP) and the User Datagram Protocol
    (UDP) at layer 4 (discussed in [Part II-8](pt11.html "Part II-8. TCP/IP TRANSPORT
    LAYER PROTOCOLS")). FTP is full-featured, session-oriented, and somewhat complex.
    It is the more often used of the two protocols, providing a full command interface
    and taking advantage of the reliability and stream-transfer functions of TCP,
    over which it runs. TFTP, like the UDP it uses at the transport layer, is a stripped-down
    version of FTP. It has far fewer commands and capabilities than FTP, but it is
    ideal for cases where simplicity and small software program size are important,
    such as in the case of embedded software in devices.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 72. FILE TRANSFER PROTOCOL (FTP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The primary general file transfer protocol in the TCP/IP suite shows its generality
    directly through its unqualified name: the *File Transfer Protocol (FTP)*. FTP
    is one of the most widely used application protocols in the world. It was designed
    to allow the efficient transfer of files between any two devices on a TCP/IP internetwork.
    It automatically takes care of the details of how files are moved, provides a
    rich command syntax to allow various supporting file operations to be performed
    (such as navigating the directory structure and deleting files), and operates
    using the Transmission Control Protocol (TCP) transport service for reliability.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I describe in detail the operation of FTP. I begin with an
    overview of FTP, a discussion of its long history, and the standards that define
    it. I then explain the key concepts related to FTP and how it functions. This
    includes a description of the FTP operational model and a look at how FTP control
    connections are established, how and when normal and passive data connections
    are used, and FTP's transmission modes and data representation methods. I then
    move on to the details of FTP commands and how they work, including a discussion
    of FTP command groups, reply codes, and user commands. Finally, I provide a sample
    illustration of a user FTP session showing the internal commands used for each
    action.
  prefs: []
  type: TYPE_NORMAL
- en: FTP Overview, History, and Standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TCP/IP protocol suite as we know it today was developed in the late 1970s
    and early 1980s, with the watershed event probably the publishing of the version
    4 standards of IP and TCP in 1980\. Modern TCP/IP was the result of experimentation
    and development work that had been underway since the 1960s. This work included
    both the design and implementation of the protocols that would implement internetworks
    and also the creation of the first networking applications to allow users to perform
    different tasks.
  prefs: []
  type: TYPE_NORMAL
- en: FTP Development and Standardization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The developers of early applications conceptually divided methods of network
    use into two categories: *direct* and *indirect*. Direct network applications
    let a user access a remote host and use it as if it were local, creating the illusion
    that the remote network doesn''t even exist (or at least, minimizing the importance
    of distance). Indirect network use meant getting resources from a remote host
    and using them on the local system, and then transferring them back. These two
    methods of use became the models for the first two formalized TCP/IP networking
    applications: Telnet for direct access (see [Chapter 87](ch87.html "Chapter 87. TCP/IP
    INTERACTIVE AND REMOTE APPLICATION PROTOCOLS")) and the FTP for indirect network
    use.'
  prefs: []
  type: TYPE_NORMAL
- en: The first FTP standard was RFC 114, published in April 1971, before TCP and
    IP even existed. This standard defined the basic commands of the protocol and
    the formal means by which devices communicate using it. At this time, the predecessor
    of TCP (called the *Network Control Protocol* or *NCP*) was used for conveying
    network traffic. There was no Internet back then. Its precursor, the ARPAnet,
    was tiny, consisting of only a small group of development computers.
  prefs: []
  type: TYPE_NORMAL
- en: A number of subsequent RFCs refined the operation of this early version of FTP,
    with revisions published as RFC 172 in June 1971 and RFC 265 in November 1971\.
    The first major revision was RFC 354, published in July 1972, which for the first
    time contained a description of the overall communication model used by modern
    TCP and details on many of the current features of the protocol. In subsequent
    months, many additional RFCs were published that defined features for FTP or raised
    issues with it. In RFC 542, published in August 1973, the FTP specification looks
    remarkably similar to the one we use today, more than three decades later, except
    that it was still defined to run over NCP.
  prefs: []
  type: TYPE_NORMAL
- en: After a number of subsequent RFCs that defined and discussed changes, the formal
    standard for modern FTP was published in RFC 765, "File Transfer Protocol Specification,"
    in June 1980\. This was the first standard to define FTP operation over modern
    TCP/IP and was created at around the same time as the other primary defining standards
    for TCP/IP.
  prefs: []
  type: TYPE_NORMAL
- en: RFC 959, "File Transfer Protocol (FTP)," was published in October 1985 and made
    some revisions to RFC 765, including the addition of several new commands, and
    it is now the base specification for FTP. Since that time, a number of other standards
    have been published that define extensions to FTP, better security measures, and
    other features.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of FTP Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FTP was created with the overall goal of allowing indirect use of computers
    on a network by making it easy for users to move files from one place to another.
    Like most TCP/IP protocols, FTP is based on a client/server model, with an FTP
    client on a user machine creating a connection to an FTP server to send and retrieve
    files to and from the server. The main objectives of FTP were to make file transfer
    simple and to shield the user from implementation details of how the files are
    actually moved from one place to another. To this end, FTP is designed to deal
    automatically with many of the issues that can potentially arise due to format
    differences in files stored on differing systems.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that files are sent and received without loss of data that could corrupt
    them, FTP uses the reliable TCP at the transport layer. An authentication system
    is used to ensure that only authorized clients are allowed to access a server.
    At the same time, a feature sometimes called *anonymous FTP* allows an organization
    that wishes it to set up a general information server to provide files to anyone
    who might want to retrieve them.
  prefs: []
  type: TYPE_NORMAL
- en: After a TCP connection is established, an FTP control connection is created.
    Internal FTP commands are passed over this logical connection based on formatting
    rules established by the Telnet Protocol. Each command sent by the client receives
    a reply from the server to indicate whether it succeeded or failed. A data connection
    is established for each individual data transfer to be performed. FTP supports
    normal and passive data connections, allowing either the server or client to initiate
    the data connection. Multiple data types and file types are supported to allow
    flexibility for various types of transfers.
  prefs: []
  type: TYPE_NORMAL
- en: The interface between an FTP user and the protocol is provided in the form of
    a set of interactive user commands. After establishing a connection and completing
    authentication, two basic commands can be used to send or receive files. Additional
    support commands are provided to manage the FTP connection as well as to perform
    support functions such as listing the contents of a directory or deleting or renaming
    files. In recent years, graphical implementations of FTP have been created to
    allow users to transfer files using mouse clicks instead of having to memorize
    commands. Also, other applications can use FTP directly to move files from one
    place to another.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The most important general file transfer protocol in TCP/IP
    is the simply named *File Transfer Protocol (FTP)*. The need to be able to move
    files of any type between machines is so fundamental that FTP''s history goes
    back more than 30 years. FTP runs over TCP to ensure that files are transferred
    reliably with no data loss. The protocol uses a set of *FTP commands* sent from
    an FTP client to an FTP server to perform file-transfer operations; the FTP server
    sends to the client *FTP replies* that indicate the success or failure of commands.'
  prefs: []
  type: TYPE_NORMAL
- en: FTP Operational Model, Protocol Components, and Key Terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standards that define FTP describe its overall operation using a simple
    conceptual tool called the *FTP model*. This model defines the roles of the devices
    that participate in a file transfer and the two communication channels that are
    established between them. It also describes the components of FTP that manage
    these channels and defines the terminology used for the components. This makes
    it an ideal place for us to see how FTP works in broad terms.
  prefs: []
  type: TYPE_NORMAL
- en: The Server-FTP Process and User-FTP Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FTP is a classic client/server protocol, as mentioned earlier. However, the
    client is not called by that name, but rather is called the *user*. The name comes
    from the fact that the human user that issues FTP commands works on the client
    machine. The full set of FTP software operating on a device is called a *process*.
    The FTP software on the server is called the *server-FTP process*, while the software
    on the client is the *user-FTP process*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The FTP client is sometimes called the *user device*, since
    the human user interacts with the client directly. The FTP client software is
    called the *user-FTP process*; the FTP server software is the *server-FTP process*.'
  prefs: []
  type: TYPE_NORMAL
- en: FTP Control Connection and Data Connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A critical concept in understanding FTP is that, although it uses TCP like
    many other applications, it does not use just one TCP connection for all communication
    the way most protocols do. Instead, the FTP model is designed around two logical
    channels of communication between the server and user FTP processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Control Connection** This is the main logical TCP connection that is created
    when an FTP session is established. It is maintained throughout the FTP session
    and is used only for passing control information, such as FTP commands and replies.
    It is not used to send files.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Connection** Each time data is sent from the server to the client or
    vice versa, a distinct TCP data connection is established between them. Data is
    transferred over this connection. When the file transfer is complete, the connection
    is terminated.'
  prefs: []
  type: TYPE_NORMAL
- en: Using separate channels provides flexibility in how the protocol is used, but
    it also adds complexity to FTP.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Unlike most protocols, FTP does not use a single TCP connection.
    When a session is set up, a permanent **control connection** is established using
    TCP for passing commands and replies. When files or other data are to be sent,
    they are passed over separate TCP *data connections* that are created and then
    dismantled as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: FTP Process Components and Terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the control and data functions are communicated using distinct channels,
    the FTP model divides the software on each device into two logical protocol components
    that are responsible for each channel. The *protocol interpreter (PI)* is a piece
    of software that is charged with managing the control connection, issuing and
    receiving commands and replies. The *data transfer process (DTP)* is responsible
    for actually sending and receiving data between the client and server. In addition
    to these two elements, the user FTP process includes a third component, a *user
    interface*, that interacts with the human FTP user; it is not present on the server
    side.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, two server process components and three client (user) process components
    are included in FTP. These components are referred to in the FTP model by specific
    names, which are used in the standard to describe the detailed operation of the
    protocol. I plan to do the same in this chapter, so I will now describe more fully
    the components in each device of this model, which are illustrated in [Figure 72-1](ch72s02.html#ftp_operational_model_ftp_is_a_clientser
    "Figure 72-1. FTP operational model FTP is a client/server protocol, with communication
    taking place between the user-FTP process on the client and the server-FTP process
    on the server. Commands, replies, and status information are passed between the
    user-PI and server-PI over the control connection, which is established once and
    maintained for the session. Data is moved between devices over data connections
    that are set up for each transfer.").
  prefs: []
  type: TYPE_NORMAL
- en: '![FTP operational model FTP is a client/server protocol, with communication
    taking place between the user-FTP process on the client and the server-FTP process
    on the server. Commands, replies, and status information are passed between the
    user-PI and server-PI over the control connection, which is established once and
    maintained for the session. Data is moved between devices over data connections
    that are set up for each transfer.](httpatomoreillycomsourcenostarchimages288261.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 72-1. FTP operational model FTP is a client/server protocol, with communication
    taking place between the user-FTP process on the client and the server-FTP process
    on the server. Commands, replies, and status information are passed between the
    user-PI and server-PI over the control connection, which is established once and
    maintained for the session. Data is moved between devices over data connections
    that are set up for each transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Server-FTP Process Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The server-FTP process contains two protocol elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server Protocol Interpreter (Server-PI)** The protocol interpreter is responsible
    for managing the control connection on the server. It listens on the main reserved
    FTP port for incoming connection requests from users (clients). Once a connection
    is established, it receives commands from the user-PI, sends back replies, and
    manages the server data transfer process.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server Data Transfer Process (Server-DTP)** The DTP on the server side is
    used to send or receive data to or from the user-DTP. The server-DTP may either
    establish a data connection or listen for a data connection coming from the user.
    It interacts with the server''s local file system to read and write files.'
  prefs: []
  type: TYPE_NORMAL
- en: User-FTP Process Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The User-FTP Process contains three protocol elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User Protocol Interpreter (User-PI)** This protocol interpreter is responsible
    for managing the control connection on the client. It initiates the FTP session
    by issuing a request to the server-PI. Once a connection is established, it processes
    commands received from the user interface, sends them to the server-PI, and receives
    replies. It also manages the user data transfer process.'
  prefs: []
  type: TYPE_NORMAL
- en: '**User Data Transfer Process (User-DTP)** The DTP on the user side sends or
    receives data to or from the server-DTP. The user-DTP may either establish a data
    connection or listen for a data connection coming from the server. It interacts
    with the client device''s local file system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**User Interface** The user interface provides a more friendly FTP interface
    to a human user. It allows simpler user-oriented commands to be used for FTP functions
    rather than the somewhat cryptic internal FTP commands, and it allows results
    and information to be conveyed back to the person operating the FTP session.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The server-FTP process and user-FTP process both contain a
    *protocol interpreter (PI)* element and a *data transfer process (DTP)* element.
    The *server-PI* and *user-PI* are logically linked by the FTP control connection;
    the *server-DTP* and *user-DTP* are logically linked by data connections. The
    user-FTP process includes a third component, the *user interface*, which provides
    the means for the human user to issue commands and see responses from the FTP
    software.'
  prefs: []
  type: TYPE_NORMAL
- en: Third-Party File Transfer (Proxy FTP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The FTP standard actually defines a separate model for an alternative way of
    using the protocol. In this technique, a user on one host performs a file transfer
    from one server to another. This is done by opening two control connections: one
    each from the user-PI on the user''s machine to the two server-PIs on the two
    servers. Then, a server-DTP is invoked on each server to send data; the user-DTP
    is not used.'
  prefs: []
  type: TYPE_NORMAL
- en: This method, sometimes called *third-party file transfer* or *proxy FTP*, is
    not widely used today. A major reason for its lack of use is that it raises security
    concerns and has been exploited in the past. Thus, while it is worth mentioning,
    I will not be discussing it further in my coverage of FTP.
  prefs: []
  type: TYPE_NORMAL
- en: FTP Control Connection Establishment, User Authentication, and Anonymous FTP
    Access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You just saw how FTP uses distinct logical data and control channels that are
    established between an FTP client (user) and an FTP server. Before the data connection
    can be used to send actual files, the control connection must be established.
    A specific process is followed to set up this connection and thereby create the
    permanent FTP session between devices that can be used for transferring files.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with other client/server protocols, the FTP server assumes a passive role
    in the control connection process. The server protocol interpreter (server-PI)
    listens on the special well-known TCP port reserved for FTP control connections:
    port 21\. The user-PI initiates the connection by opening a TCP connection from
    the user device to the server on this port. It uses an ephemeral port number as
    its source port in the TCP connection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once TCP has been set up, the control connection between the devices is established,
    allowing commands to be sent from the user-PI to the server-PI and reply codes
    to be sent back in response. The first order of business after the channel is
    operating is *user authentication*, which the FTP standard calls the *login sequence*.
    This process has two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access Control** The authentication process allows access to the server to
    be restricted to only authorized users. It also lets the server control what types
    of access each user has.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource Selection** By identifying the user making the connection, the FTP
    server can make decisions about what resources to make available to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: FTP Login Sequence and Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The FTP''s regular authentication scheme is quite rudimentary: it is a simple
    *user name/password* login scheme, shown in [Figure 72-2](ch72s03.html#ftp_connection_establishment_and_user_au
    "Figure 72-2. FTP connection establishment and user authentication An FTP session
    begins with the establishment of a TCP connection between the client and server.
    The client then sends the user name and password to authenticate with the server.
    Assuming that the information is accepted by the server, it sends a greeting reply
    to the client and the session is open."). Most of us are familiar with this type
    of authentication for various types of access on the Internet and elsewhere. First,
    the user is identified by sending a user name from the user-PI to the server-PI
    using the USER command. Then, the user''s password is sent using the PASS command.'
  prefs: []
  type: TYPE_NORMAL
- en: The server checks the user name and password against its user database to verify
    that the connecting user has valid authority to access the server. If the information
    is valid, the server sends back a greeting to the client to indicate that the
    session is opened. If the user improperly authenticates (by specifying an incorrect
    user name or password), the server will request that the user attempt authorization
    again. After a number of invalid authorization tries, the server may time out
    and terminate the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that the authentication succeeds, the server then sets up the connection
    to allow the type of access to which the user is authorized. Some users may have
    access to only certain files or certain types of files. Some servers may allow
    particular users to read and write files on the server, while other users may
    only retrieve files. The administrator can thus tailor FTP access as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![FTP connection establishment and user authentication An FTP session begins
    with the establishment of a TCP connection between the client and server. The
    client then sends the user name and password to authenticate with the server.
    Assuming that the information is accepted by the server, it sends a greeting reply
    to the client and the session is open.](httpatomoreillycomsourcenostarchimages288263.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 72-2. FTP connection establishment and user authentication An FTP session
    begins with the establishment of a TCP connection between the client and server.
    The client then sends the user name and password to authenticate with the server.
    Assuming that the information is accepted by the server, it sends a greeting reply
    to the client and the session is open.
  prefs: []
  type: TYPE_NORMAL
- en: Once the connection is established, the server can also make resource selection
    decisions based on the user's identity. For example, on a system with multiple
    users, the administrator can set up FTP so that when any user connects, she automatically
    is taken to her own home directory. The optional ACCT (account) command also allows
    a user to select a particular account if she has more than one.
  prefs: []
  type: TYPE_NORMAL
- en: FTP Security Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like most older protocols, the simple login scheme used by FTP is a legacy of
    the relatively closed nature of the early Internet. It is not considered secure
    by today's global Internet standards, because the user name and password are sent
    across the control connection in clear text. This makes it relatively easy for
    login information to be intercepted by intermediate systems and accounts to be
    compromised. RFC 2228, "FTP Security Extensions," defines more sophisticated authentication
    and encryption options for those who need added security in their FTP software.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** An FTP session begins with the establishment of a control connection
    between an FTP client and server. After the TCP connection is made, the user must
    authenticate with the server using a simple user name/password exchange between
    client and server. This provides only rudimentary security, so if more security
    is required, it must be implemented using FTP security extensions or through other
    means.'
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous FTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perhaps surprisingly, many organizations did not see the need for an enhanced
    level of security. These organizations, in fact, went in the opposite direction:
    They used FTP without any authentication at all. But why would any business want
    to allow just anybody access to its FTP server? The answer is pretty simple: Anyone
    who wants to use the server can do so to provide information to the general public.'
  prefs: []
  type: TYPE_NORMAL
- en: Today, most organizations use the World Wide Web to distribute documents, software,
    and other files to customers and others who want to obtain them. But in the 1980s,
    before the Web became popular, FTP was often used to distribute such information.
    For example, today, if you had a 3Com network interface card and wanted to obtain
    a driver for it, you would go to the web server *www.3com.com*, but several years
    ago, you might have accessed the 3Com FTP server *(ftp.3com.com)* to download
    a driver.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, requiring every customer to have a user name and password on such a
    server would be ridiculously difficult. For this reason, RFC 1635, published in
    1994, defined a use for the protocol called *anonymous FTP*. In this technique,
    a client connects to a server and provides a default user name to log in as a
    guest. Usually the names *anonymous* or *ftp* are supported. Seeing this name,
    the server responds back with a special message, saying something like "Guest
    login OK, send your complete email address as password." The password in this
    case isn't really a password; it is used simply to allow the server to log who
    is accessing it.
  prefs: []
  type: TYPE_NORMAL
- en: The guest is then able to access the site, though the server will usually severely
    restrict the access rights of guests on the system. Many FTP servers support both
    identified and anonymous access, with authorized users having more permissions
    (such as being able to traverse the full directory path and having the right to
    delete or rename files) and anonymous users restricted to only reading files from
    a particular directory set up for public access.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Many FTP servers support *anonymous FTP*, which allows a guest
    who has no account on the server to have limited access to server resources. This
    is often used by organizations that wish to make files available to the public
    for purposes such as technical support, customer support, or distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: FTP Data Connection Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The control channel created between the server-PI and the user-PI using the
    FTP connection establishment and authentication process is maintained throughout
    the FTP session. Over the control channel, the protocol interpreters exchange
    commands and replies, but not data.
  prefs: []
  type: TYPE_NORMAL
- en: Each time files or other data need to be sent between the server and user FTP
    processes, a data connection must be created. The data connection links the user-DTP
    with the server-DTP. This connection is required both for explicit file transfer
    actions (getting or receiving a file) and for implicit data transfers, such as
    requesting a list of files from a directory on the server.
  prefs: []
  type: TYPE_NORMAL
- en: The FTP standard specifies two different ways of creating a data connection,
    though it doesn't really explain them in a way that is very easy to understand.
    The two methods differ primarily in which device—the client or the server—initiates
    the connection. This may at first seem like a trivial matter, but as you'll see
    shortly, it is actually quite important.
  prefs: []
  type: TYPE_NORMAL
- en: Normal (Active) Data Connections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first method is sometimes called creating a *normal* data connection (because
    it is the default method) and sometimes an *active* data connection (in contrast
    with the passive method we will discuss in a moment). In this type of connection,
    the server-DTP initiates the data channel by opening a TCP connection to the user-DTP.
    The server uses the special reserved port number 20 (one less than the well-known
    control FTP port number 21) for the data connection. On the client machine, the
    default port number used is the same as the ephemeral port number used for the
    control connection, but as you'll see shortly, the client will often choose a
    different port for each transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use an example to see how this works. Suppose the user-PI established
    a control connection from its ephemeral port number 1678 to the server's FTP control
    port of 21\. Then, to create a data connection for data transfer, the server-PI
    would instruct the server-DTP to initiate a TCP connection from the server's port
    20 to the client's port 1678\. The client would acknowledge this, and then data
    could be transferred (in either direction—remember that TCP is bidirectional).
  prefs: []
  type: TYPE_NORMAL
- en: In practice, having the client's control and data connection on the same port
    is not a good idea; it complicates the operation of FTP and can lead to some tricky
    problems. For this reason, it is strongly recommended that the client specify
    a different port number using the PORT command prior to the data transfer. For
    example, suppose the client specifies port 1742 using PORT. The server-DTP would
    then create a connection from its port 20 to the client's port 1742 instead of
    1678\. This process is shown in [Figure 72-3](ch72s04.html#ftp_active_data_connection_in_a_conventi
    "Figure 72-3. FTP active data connection In a conventional, or active, FTP data
    connection, the server initiates the transfer of data by opening the data connection
    to the client. In this case, the client first sends a PORT command to tell the
    server to use port 1742\. The server then opens the data connection from its default
    port number of 20 to client port 1742\. Data is then exchanged between the devices
    using these ports.").
  prefs: []
  type: TYPE_NORMAL
- en: Passive Data Connections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second method is called a *passive* data connection. The client tells the
    server to be passive—that is, to accept an incoming data connection initiated
    by the client. The server replies, giving the client the server IP address and
    port number that it should use. The server-DTP then listens on this port for an
    incoming TCP connection from the user-DTP. By default, the user machine uses the
    same port number it used for the control connection, as in the active case. However,
    here again, the client can choose to use a different port number for the data
    connection if necessary (typically an ephemeral port number).
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider our example again, with the control connection from port 1678
    on the client to port 21 on the server, but this time consider data transfer using
    a passive connection, as illustrated in [Figure 72-4](ch72s04.html#ftp_passive_data_connection_in_a_passive
    "Figure 72-4. FTP passive data connection In a passive FTP data connection, the
    client uses the PASV command to tell the server to wait for the client to establish
    the data connection. The server responds, telling the client what port it should
    use on the server for the data transmission—in this case, port 2223\. The client
    then opens the data connection using that port number on the server and a client
    port number of its own choosing—in this case, 1742."). The client would issue
    the PASV command to tell the server it wanted to use passive data control. The
    server-PI would reply with a port number for the client to use—say port 2223\.
    The server-PI would then instruct the server-DTP to listen on this port 2223\.
    The user-PI would instruct the user-DTP to create a connection from client port
    1742 to server port 2223\. The server would acknowledge this, and then data could
    be sent and received, again in either direction.
  prefs: []
  type: TYPE_NORMAL
- en: '![FTP active data connection In a conventional, or active, FTP data connection,
    the server initiates the transfer of data by opening the data connection to the
    client. In this case, the client first sends a PORT command to tell the server
    to use port 1742\. The server then opens the data connection from its default
    port number of 20 to client port 1742\. Data is then exchanged between the devices
    using these ports.](httpatomoreillycomsourcenostarchimages288265.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 72-3. FTP active data connection In a conventional, or active, FTP data
    connection, the server initiates the transfer of data by opening the data connection
    to the client. In this case, the client first sends a PORT command to tell the
    server to use port 1742\. The server then opens the data connection from its default
    port number of 20 to client port 1742\. Data is then exchanged between the devices
    using these ports.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency and Security Issues Related to the Connection Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you may be wondering what the practical difference is between
    the active and passive connection types. I already said that in either case, the
    data transfer can go in both directions. So what does it matter who initiates
    the data connection? Isn't this like arguing over who makes a local telephone
    call?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is related to the dreaded "S word:" *security*. The fact that FTP
    uses more than one TCP connection can cause problems for the hardware and software
    that people use to ensure the security of their systems.
  prefs: []
  type: TYPE_NORMAL
- en: Consider what is happening in the case of an active data connection, as described
    in [Figure 72-3](ch72s04.html#ftp_active_data_connection_in_a_conventi "Figure 72-3. FTP
    active data connection In a conventional, or active, FTP data connection, the
    server initiates the transfer of data by opening the data connection to the client.
    In this case, the client first sends a PORT command to tell the server to use
    port 1742\. The server then opens the data connection from its default port number
    of 20 to client port 1742\. Data is then exchanged between the devices using these
    ports."). From the perspective of the client, an established control connection
    exists from the client's port 1678 to the server's port 21\. But the data connection
    is initiated by the server. So the client sees an incoming connection request
    to port 1678 (or some other port). Many clients are suspicious about receiving
    such incoming connections, since under normal circumstances, clients *establish*
    connections—they don't respond to them. Since incoming TCP connections can potentially
    be a security risk, many clients are configured to block them using firewall hardware
    or software.
  prefs: []
  type: TYPE_NORMAL
- en: '![FTP passive data connection In a passive FTP data connection, the client
    uses the PASV command to tell the server to wait for the client to establish the
    data connection. The server responds, telling the client what port it should use
    on the server for the data transmission—in this case, port 2223\. The client then
    opens the data connection using that port number on the server and a client port
    number of its own choosing—in this case, 1742.](httpatomoreillycomsourcenostarchimages288267.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 72-4. FTP passive data connection In a passive FTP data connection, the
    client uses the PASV command to tell the server to wait for the client to establish
    the data connection. The server responds, telling the client what port it should
    use on the server for the data transmission—in this case, port 2223\. The client
    then opens the data connection using that port number on the server and a client
    port number of its own choosing—in this case, 1742.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why not just make it so that the client always accepts connections to the port
    number one above the ephemeral number used for the control connection? The problem
    here is that clients often use different port numbers for each transfer by using
    the PORT command. This is done because of the rules of TCP. As I describe in [Chapter 47](ch47.html
    "Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION"),
    after a connection is closed, a period of time must elapse before the port can
    be used again to prevent mixing up consecutive sessions. This would cause delays
    when sending multiple files one after the other, so to avoid this, clients usually
    use different port numbers for each transfer. This is more efficient, but it means
    a firewall protecting the client would be asked to accept incoming connections
    that appear to be going to many unpredictable port numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: The use of passive connections largely eliminates this problem. Most firewalls
    have a lot more difficulty dealing with incoming connections to odd ports than
    outgoing connections. RFC 1579, "Firewall-Friendly FTP," discusses this issue
    in detail. It recommends that clients use passive data connections by default
    instead of using normal connections with the PORT command to avoid the port-blocking
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, passive data connections don't really eliminate the problem; they
    just push it off onto servers. These servers now must face the issue of incoming
    connections to various ports. Still, it is, generally speaking, easier to deal
    with security issues on a relatively smaller number of servers than on a large
    number of clients. FTP servers must be able to accept passive mode transfers from
    clients anyway, so the usual approach is to set aside a block of ports for this
    purpose, which the server's security provisions allow to accept incoming connections,
    while blocking incoming connection requests on other ports.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** FTP supports two different models for establishing data connections
    between the client and server. In normal, or *active*, data connections, the server
    initiates the connection when the client requests a transfer, and the client responds;
    in a *passive* data connection, the client tells the server it will initiate the
    connection, and the server responds. Since TCP is bidirectional, data can flow
    either way in both cases; the chief difference between the two modes has to do
    with security. In particular, passive mode is often used because many modern client
    devices are not able to accept incoming connections from servers.'
  prefs: []
  type: TYPE_NORMAL
- en: Another point worth mentioning is that it is a significant violation of the
    layering principle of networks to pass IP addresses and port numbers in FTP commands
    such as PORT and PASV and the replies to them. This isn't just a philosophical
    issue. Applications aren't supposed to deal with port numbers, and this creates
    issues when certain lower-layer technologies are used. For example, consider the
    use of Network Address Translation (NAT; see [Chapter 28](ch28.html "Chapter 28. IP
    NETWORK ADDRESS TRANSLATION (NAT) PROTOCOL")), which modifies IP addresses and
    possibly port numbers. To prevent NAT from "breaking" when FTP is used, special
    provisions must be made to handle the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: FTP General Data Communication and Transmission Modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once a data connection has been established between the server-DTP and the user-DTP,
    data is sent directly from the client to the server, or the server to the client,
    depending on the specific command issued. Since control information is sent using
    the distinct control channel, the entire data channel can be used for data communication.
    (These two logical channels are multiplexed at lower layers along with all other
    TCP and User Datagram Protocol (UDP) connections on both devices, so this doesn't
    actually represent a performance improvement over a single channel.)
  prefs: []
  type: TYPE_NORMAL
- en: 'FTP defines three different *transmission modes* (also called *transfer modes*)
    that specify exactly how data is sent from one device to another over an open
    data channel: *stream mode, block mode*, and *compressed mode*.'
  prefs: []
  type: TYPE_NORMAL
- en: Stream Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In stream mode, data is sent simply as a continuous stream of unstructured bytes.
    The sending device simply starts pushing data across the TCP data connection to
    the recipient. No message format with distinct header fields is used, making this
    method quite different from the way many other protocols send information in discrete
    chunks. It relies strongly on the data streaming and reliable transport services
    of TCP. Since there is no header structure, the end of the file is indicated simply
    by the sending device closing the data connection when it is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of the three modes, stream is by far the most widely used in real FTP implementations,
    for three main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It is the default and also the simplest method, so it is the easiest to implement
    and is required for compatibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is the most general, because it treats all files as simple streams of bytes
    without paying attention to their content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is the most efficient method because no bytes are wasted on overhead such
    as headers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Block mode is a more conventional data transmission mode, in which data is broken
    into data blocks and encapsulated into individual FTP blocks, or records. Each
    record has a three-byte header that indicates its length and contains information
    about the data blocks being sent. A special algorithm is used to keep track of
    the transmitted data and to detect and restart an interrupted transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Compressed Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compressed mode is a transmission mode in which a relatively simple compression
    technique called *run-length encoding* is used to detect repeated patterns in
    the data being sent, which then represents data in such a way that the overall
    message takes fewer bytes. The compressed information is sent in a way similar
    to block mode, using a header-plus-payload record format.
  prefs: []
  type: TYPE_NORMAL
- en: Compressed mode seems on the surface to be useful. In practice, however, compression
    is often implemented in other places in a typical networking software stack, making
    it unnecessary in FTP. For example, if you are transferring a file over the Internet
    using an analog modem, your modem normally performs compression down at layer
    1\. Large files on FTP servers are also often already compressed using something
    like the ZIP format, meaning further compression would serve no purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** FTP includes three different *transmission modes: stream, block*,
    and *compressed*. In stream mode, the most commonly used mode, data is sent as
    a continuous sequence of bytes. In block mode, data is formatted into blocks with
    headers. In compressed mode, bytes are compacted using run-length encoding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'FTP Data Representation: Data Types, Format Control, and Data Structures'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most general way of designing FTP would have been to make it treat all files
    as "black boxes." A file would be represented as just as a set of bytes. FTP would
    pay no attention to what the file contained and would simply move the file, one
    byte at a time, from one place to another. In this scenario, FTP would seem to
    be very similar to the Copy command that is implemented on most file systems,
    which likewise creates a copy without looking into the file to see what it contains.
  prefs: []
  type: TYPE_NORMAL
- en: So what would be the problem with that, you may wonder? Well, for some types
    of files, this is exactly what we want, but for others, it introduces a problem.
    Certain types of files use different representations on different systems. If
    you copy a file from one place to another on the same computer using a Copy command,
    there is no problem, because the same representation for files is used everywhere
    within that computer. But when you copy it to a computer that uses a different
    representation, you may encounter difficulties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common example of this is a type of file that may surprise you: simple
    text files. All ASCII text files use the ASCII character set, but they differ
    in the control characters used to mark the end of a line of text. On UNIX, a line
    feed (LF) character is used; on Apple computers, a carriage return (CR) is used;
    and Windows machines use both (CR+LF).'
  prefs: []
  type: TYPE_NORMAL
- en: If you move a text file from one type of system to another using regular FTP,
    the data will all get moved exactly as it is. Moving a text file from a UNIX system
    to a PC as just a set of bytes would mean programs would not properly recognize
    end-of-line markers. To avoid this predicament, FTP moves past the idea that all
    files are just bytes and incorporates some intelligence to handle different types
    of files. The FTP standard recognizes this by allowing the specification of certain
    details about a file's internal representation prior to transfer.
  prefs: []
  type: TYPE_NORMAL
- en: FTP Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first piece of information that can be provided about a file is its *data
    type*, which dictates the overall representation of the file. Four different data
    types are specified in the FTP standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ASCII** This data type defines an ASCII text file, with lines marked by some
    sort of end-of-line marker.'
  prefs: []
  type: TYPE_NORMAL
- en: '**EBCDIC** Conceptually, EBCDIC is the same as the ASCII type, but it is used
    for files using IBM''s EBCDIC character set.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Image** With the image data type, the file has no formal internal structure
    and is sent one byte at a time without any processing; this is the black box mode
    mentioned earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local** This data type is used to handle files that may store data in logical
    bytes containing a number of bits other than eight. Specifying this type along
    with the way the data is structured allows the data to be stored on the destination
    system in a manner consistent with its local representation.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The term byte conventionally refers to eight bits, but strictly speaking,
    the term used to describe eight bits is octet. A byte may in fact contain a number
    of bits other than eight on certain systems. For details, see "Binary Information
    and Representation: Bits, Bytes, Nibbles, Octets, and Characters" in [Chapter 4](ch04.html
    "Chapter 4. A REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS OF COMPUTING")*.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the two data types most often used are ASCII and image. The ASCII
    type is used for text files, and allows them to be moved between systems with
    line-end codes converted automatically. The Image type is used for generic binary
    files, such as graphical images, ZIP files, and other data that is represented
    in a universal manner. It is also often called the *binary* type for that reason.
  prefs: []
  type: TYPE_NORMAL
- en: ASCII Data Type Line-Delimiting Issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the ASCII data type is used, differences in internal representations between
    systems are handled by using a universal external representation that acts as
    a common language. Lines of the file being transmitted are converted by the sending
    FTP process from the sender's internal representation to the neutral ASCII representation
    used by the Telnet Protocol (NETASCII), with each line ending in CR+LF. The receiving
    device then converts from this neutral representation to the internal format used
    by the recipient file system.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when using FTP to move a text file from a Macintosh to a UNIX system,
    each line would have the CR changed to a CR+LF for transmission over the FTP data
    channel. The receiving UNIX system would change each CR+LF to just LF so UNIX
    programs could read it properly.
  prefs: []
  type: TYPE_NORMAL
- en: Note that because of these changes, the resulting file can be bigger or smaller
    than the original if it is transferred between systems using ASCII mode. Also,
    since FTP works by converting to a neutral representation for universality, sending
    an ASCII file from a UNIX system to a UNIX system means each LF is changed to
    CR+LF for transmission, and then it's changed back to LF by the recipient. It's
    slightly inefficient, but not that big a deal.
  prefs: []
  type: TYPE_NORMAL
- en: It's very important that the correct data type be specified with the appropriate
    user command. Sending a text file between dissimilar systems without setting the
    ASCII mode will result in either a file that cannot be properly read on the destination
    or one that contains stray characters. Conversely, binary files must be sent in
    binary mode. If you send something like a ZIP file or a JPG graphic in ASCII mode,
    the FTP software will think it is a text file. It will treat the file as if it
    were text, and each time it encounters bytes in the file that look like CR, LF,
    or CR+LF, it will convert them, which you do not want. (Having the wrong data
    type set is a leading cause of corrupted files when using FTP to move files between
    PCs and UNIX systems. I know from experience!)
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** FTP defines four data types: *ASCII, EBCDIC, image*, and *local.
    ASCII* and *EBCDIC* are used for text files in the ASCII and EBCDIC character
    sets, respectively. The *image* type is used for files with no specific structure.
    The local type is used for local representation. The ASCII type is important because
    it allows text files to be transferred successfully between file systems that
    may use different methods of indicating the end of a line of text. The image type,
    also called binary, is used for files that must be sent and received byte-for-byte
    with no transformation, such as executable files, graphics, and files with arbitrary
    formats.'
  prefs: []
  type: TYPE_NORMAL
- en: FTP Format Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the ASCII and EBCDIC types, FTP defines an optional parameter called *format
    control*, which allows a user to specify a particular representation for how vertical
    formatting is used to describe a file. The format control option was created to
    handle files transferred from host devices to printers. It is not used today,
    to my knowledge (or if it is used, it is used only in special applications).
  prefs: []
  type: TYPE_NORMAL
- en: 'Three options can be used in this control:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Non Print** This is the default, indicating no vertical formatting.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Telnet Format** The file uses vertical format control characters, as specified
    in the Telnet Protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Carriage Control/FORTRAN** The file uses format control characters given
    as the first character of each line, as specified for the FORTRAN programming
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: FTP Data Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to specifying a file''s data type, it is also possible to specify
    the file''s *data structure* in three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File Structure** The file is a contiguous stream of bytes with no internal
    structure. This is the default and is used for most types of files.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Record Structure** The file consists of a set of sequential records, each
    of which is delimited by an end-of-record marker. The record structure can be
    used for ASCII text files, but these are more commonly sent with the regular file
    structure using the ASCII data type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Page Structure** The file contains a set of special indexed data pages. This
    structure is not commonly used; it was initially created for a now archaic type
    of computer used in the early ARPAnet.'
  prefs: []
  type: TYPE_NORMAL
- en: FTP Internal Command Groups and Protocol Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once a connection is established between an FTP server and user, all communication
    to manage the operation of the protocol takes place over the control channel.
    The user-PI sends *protocol commands* to the server-PI, which processes them and
    takes appropriate action. The server-PI responds with *reply codes* to tell the
    user-PI the result of the commands it issued and convey other important information.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the actual transmission of FTP commands over the control channel
    is done using specifications based on the Telnet Protocol. You may recall from
    the "FTP Overview, History, and Standards" section earlier in this chapter that
    Telnet and FTP are two of the very oldest TCP/IP applications, the former being
    for direct network use and the latter for indirect resource access. They were
    developed at around the same time, and setting up the FTP control channel to act
    as a type of Telnet connection is a good example of how Internet standards try
    not to reinvent the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: FTP Command Groups and Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each command is identified by a short, three- or four-letter *command code*
    for convenience, and the command performs a specific task in the overall functionality
    of FTP. Several dozen of these protocol commands are available, and to help organize
    them, the FTP standard categorizes them into three groups, based on overall function
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access Control Commands** Commands that are part of the user login and authentication
    process, are used for resource access, or are part of general session control.
    See [Table 72-1](ch72s07.html#ftp_access_control_commands "Table 72-1. FTP Access
    Control Commands").'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transfer Parameter Commands** Commands that specify parameters for how data
    transfers should occur. For example, commands in this group specify the data type
    of a file to be sent, indicate whether passive or active data connections will
    be used, and so forth. See [Table 72-2](ch72s07.html#ftp_transfer_parameter_commands
    "Table 72-2. FTP Transfer Parameter Commands").'
  prefs: []
  type: TYPE_NORMAL
- en: '**FTP Service Commands** Commands that actually perform file operations, such
    as sending and receiving files, and to implement support functions, such as deleting
    or renaming files. This is the largest group. See [Table 72-3](ch72s07.html#ftp_protocol_service_commands
    "Table 72-3. FTP Protocol Service Commands").'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** FTP operation is controlled through the issuing of *protocol
    commands* from the FTP client to the FTP server. Each command has a three- or
    four-letter command code that indicates its function. The commands are organized
    into three groups: *access control commands* used for login and general session
    control, *transfer parameter commands* that control how transfers are performed,
    and *FTP service commands* that are used to perform actual file operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the commands are based on the Telnet specifications, they are sent as
    plain text, as specified by Telnet's Network Virtual Terminal (NVT) conventions.
    Tables [Table 72-1](ch72s07.html#ftp_access_control_commands "Table 72-1. FTP
    Access Control Commands"), [Table 72-2](ch72s07.html#ftp_transfer_parameter_commands
    "Table 72-2. FTP Transfer Parameter Commands"), and [Table 72-3](ch72s07.html#ftp_protocol_service_commands
    "Table 72-3. FTP Protocol Service Commands") list and describe the FTP internal
    protocol commands in the access control, transfer parameters, and service command
    groups. They are shown in the order that they appear in the FTP standard (RFC
    959).
  prefs: []
  type: TYPE_NORMAL
- en: Table 72-1. FTP Access Control Commands
  prefs: []
  type: TYPE_NORMAL
- en: '| Command Code | Command | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| USER | User name | Identifies the user attempting to establish an FTP session.
    |'
  prefs: []
  type: TYPE_TB
- en: '| PASS | Password | Specifies the password for the user given previously by
    the USER command during login authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| ACCT | Account | Specifies an account for an authenticated user during the
    FTP session. Used only on systems that require this to be separately identified;
    most select an account automatically based on the name entered in the USER command.
    |'
  prefs: []
  type: TYPE_TB
- en: '| CWD | Change working directory | Allows the user to specify a different directory
    for file transfer during an FTP session. |'
  prefs: []
  type: TYPE_TB
- en: '| CDUP | Change to parent directory ("change directory up") | A special case
    of the CWD command that goes to the directory one level up in the server''s directory
    structure. It is implemented separately to abstract out differences in directory
    structures between file systems; the user can use CDUP instead of knowing the
    specific syntax for navigating up the directory tree on the server. |'
  prefs: []
  type: TYPE_TB
- en: '| SMNT | Structure mount | Allows the user to mount a particular file system
    for access to different resources. |'
  prefs: []
  type: TYPE_TB
- en: '| REIN | Reinitialize | Reinitializes the FTP session, flushing all set parameters
    and user information. This returns the session to the state when the control connection
    is just established. It is, in essence, the opposite of the USER command. The
    next command issued is often USER, to log in a different user. |'
  prefs: []
  type: TYPE_TB
- en: '| QUIT | Logout | Terminates the FTP session and closes the control connection.
    Note that the naming of this command was unfortunate. The REIN command is really
    most similar to a conventional logout command, as it terminates a logged-in user
    and allows another user to log in. In contrast, the QUIT command shuts down the
    entire session. |'
  prefs: []
  type: TYPE_TB
- en: Table 72-2. FTP Transfer Parameter Commands
  prefs: []
  type: TYPE_NORMAL
- en: '| Command Code | Command | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| PORT | Data port | Used to tell the FTP server that the client wants to accept
    an active data connection on a specific port number. |'
  prefs: []
  type: TYPE_TB
- en: '| PASV | Passive | Requests that the FTP server allow the user-DTP to initiate
    passive data connections. |'
  prefs: []
  type: TYPE_TB
- en: '| TYPE | Representation type | Specifies for the file to be transferred the
    data type (ASCII, EBCDIC, image, or local), and optionally the format control
    (Non Print, Telnet, or Carriage Control). |'
  prefs: []
  type: TYPE_TB
- en: '| STRU | File structure | Specifies the data structure for the file (file,
    record, or page). |'
  prefs: []
  type: TYPE_TB
- en: '| MODE | Transfer mode | Specifies the transmission mode to be used (stream,
    block, or compressed). |'
  prefs: []
  type: TYPE_TB
- en: Table 72-3. FTP Protocol Service Commands
  prefs: []
  type: TYPE_NORMAL
- en: '| Command Code | Command | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| RETR | Retrieve | Tells the server to send the user a file. |'
  prefs: []
  type: TYPE_TB
- en: '| STOR | Store | Sends a file to the server. |'
  prefs: []
  type: TYPE_TB
- en: '| STOU | Store unique | Like STOR, but instructs the server to make sure the
    file has a unique name in the current directory. This is used to prevent overwriting
    a file that may already exist with the same name. The server replies back with
    the name used for the file. |'
  prefs: []
  type: TYPE_TB
- en: '| APPE | Append (with create) | Like STOR, but if a file with the name specified
    already exists, the data being sent is appended to it instead of replacing it.
    |'
  prefs: []
  type: TYPE_TB
- en: '| ALLO | Allocate | An optional command used to reserve storage on the server
    before a file is sent. |'
  prefs: []
  type: TYPE_TB
- en: '| REST | Restart | Restarts a file transfer at a particular server marker.
    Used only for block or compressed transfer modes. |'
  prefs: []
  type: TYPE_TB
- en: '| RNFR | Rename from | Specifies the old name of a file to be renamed. See
    the RNTO command. |'
  prefs: []
  type: TYPE_TB
- en: '| RNTO | Rename to | Specifies the new name of a file to be renamed. Used with
    the RNFR command. |'
  prefs: []
  type: TYPE_TB
- en: '| ABOR | Abort | Tells the server to abort the last FTP command and/or the
    current data transfer. |'
  prefs: []
  type: TYPE_TB
- en: '| DELE | Delete | Deletes a specified file on the server. |'
  prefs: []
  type: TYPE_TB
- en: '| RMD | Remove directory | Deletes a directory on the server. |'
  prefs: []
  type: TYPE_TB
- en: '| MKD | Make directory | Creates a directory. |'
  prefs: []
  type: TYPE_TB
- en: '| PWD | Print working directory | Displays the current server working directory
    for the FTP session; shows the users where they are in the server''s file system.
    |'
  prefs: []
  type: TYPE_TB
- en: '| LIST | List | Requests a list of the contents of the current directory from
    the server, including both names and other information. Similar in concept to
    the `DIR` command in DOS/Windows or the `ls` command in UNIX. |'
  prefs: []
  type: TYPE_TB
- en: '| NLST | Name list | Like LIST, but returns only the names in a directory.
    |'
  prefs: []
  type: TYPE_TB
- en: '| SITE | Site parameters | Used to implement site-specific functions. |'
  prefs: []
  type: TYPE_TB
- en: '| SYST | System | Requests that the server send to the client information about
    the server''s operating system. |'
  prefs: []
  type: TYPE_TB
- en: '| STAT | Status | Prompts the server to send an indication of the status of
    a file or the transfer currently in progress. |'
  prefs: []
  type: TYPE_TB
- en: '| HELP | Help | Asks the server for any help information that might be useful
    in allowing the user to determine how the server should be used. |'
  prefs: []
  type: TYPE_TB
- en: '| NOOP | No operation | Does nothing, other than prompting the server to send
    an "OK" response to verify that the control channel is alive. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*FTP commands are not case-sensitive, but they have been shown in uppercase
    for clarity in Tables [Table 72-1](ch72s07.html#ftp_access_control_commands "Table 72-1. FTP
    Access Control Commands"), [Table 72-2](ch72s07.html#ftp_transfer_parameter_commands
    "Table 72-2. FTP Transfer Parameter Commands"), and [Table 72-3](ch72s07.html#ftp_protocol_service_commands
    "Table 72-3. FTP Protocol Service Commands")*.'
  prefs: []
  type: TYPE_NORMAL
- en: FTP commands are all sent between FTP elements; they are not usually issued
    directly by users. Instead, a special set of user commands is employed for this
    purpose. The FTP user interface implements the link between the user and the user-FTP
    process, including the translation of user commands into FTP commands. We'll explore
    these commands later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: FTP Replies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each time the user-PI sends a command to the server-PI over the control connection,
    the server sends back a reply. FTP replies serve three main purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: They serve as confirmation that the server received a command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They tell the user device whether or not the command was accepted, and if an
    error occurred, what it was.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They communicate various types of information to the user of the session, such
    as the status of a transfer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of Using Both Text and Numeric Replies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a human user, a string of reply text would be sufficient to satisfy the
    requirements just mentioned, and FTP replies do include descriptive text. But
    having only a text string would make it difficult or impossible for FTP software
    on the client side to interpret results coming from the server. FTP was designed
    to allow software applications to interact with each other over the FTP command
    link. For this reason, the protocol's reply system uses *reply codes*.
  prefs: []
  type: TYPE_NORMAL
- en: FTP reply codes are three-digit numeric responses that can be easily interpreted
    by a computer program. They are also useful for human users who are familiar with
    FTP, because they communicate at a glance the results of various operations. While
    each FTP server implementation may differ in the text sent for each type of reply,
    the reply codes are used in a consistent manner based on the specifications of
    the FTP standard. It is, therefore, the codes that are examined to determine the
    results of a command; the text is just descriptive.
  prefs: []
  type: TYPE_NORMAL
- en: Reply Code Structure and Digit Interpretation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make reply codes even more useful, they are not just assigned in a linear
    or random order. Rather, a special encoding scheme is used, in which each code
    has three digits that each communicate a particular type of information and categorize
    replies. A code can be considered to be of the form *xyz*, where *x* is the first
    digit, *y* is the second, and *z* is the third.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first digit indicates the success or failure of the command in general
    terms, whether a successful command is complete or incomplete, and whether or
    not an unsuccessful command should be retried. [Table 72-4](ch72s08.html#ftp_reply_code_format_first_digit_interp
    "Table 72-4. FTP Reply Code Format: First Digit Interpretation") shows the possible
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 72-4. FTP Reply Code Format: First Digit Interpretation'
  prefs: []
  type: TYPE_NORMAL
- en: '| Reply Code Format | Meaning | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1yz | Positive preliminary reply | An initial response indicating that the
    command has been accepted and processing is still in progress. The user should
    expect another reply before a new command may be sent. |'
  prefs: []
  type: TYPE_TB
- en: '| 2yz | Positive completion reply | The command has been successfully processed
    and completed. |'
  prefs: []
  type: TYPE_TB
- en: '| 3yz | Positive intermediate reply | The command was accepted, but processing
    has been delayed, pending receipt of additional information. This type of reply
    is used in the middle of command sequences. For example, it is used as part of
    the authentication sequence after receiving a USER command but before the matching
    PASS command is sent. |'
  prefs: []
  type: TYPE_TB
- en: '| 4yz | Transient negative completion reply | The command was not accepted
    and no action was taken, but the error is temporary and the command may be tried
    again. This is used for errors that may be a result of temporary glitches or conditions
    that may change—for example, a file being busy due to another resource accessing
    it at the time a request was made for it. |'
  prefs: []
  type: TYPE_TB
- en: '| 5yz | Permanent negative completion reply | The command was not accepted
    and no action was taken. Trying the same command again is likely to result in
    another error. For example, a request for a file that is not found on the server,
    or sending an invalid command like BUGU, would fall into this category. |'
  prefs: []
  type: TYPE_TB
- en: 'The second digit of the reply code is used to categorize messages into functional
    groups. These groups are shown in [Table 72-5](ch72s08.html#ftp_reply_code_format_second_digit_inter
    "Table 72-5. FTP Reply Code Format: Second Digit Interpretation").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 72-5. FTP Reply Code Format: Second Digit Interpretation'
  prefs: []
  type: TYPE_NORMAL
- en: '| Reply Code Format | Meaning | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| x0z | Syntax | Syntax errors or miscellaneous messages |'
  prefs: []
  type: TYPE_TB
- en: '| x1z | Information | Replies to requests for information, such as status requests
    |'
  prefs: []
  type: TYPE_TB
- en: '| x2z | Connections | Replies related to the control connection or data connection
    |'
  prefs: []
  type: TYPE_TB
- en: '| x3z | Authentication and accounting | Replies related to login procedures
    and accounting |'
  prefs: []
  type: TYPE_TB
- en: '| x4z | Unspecified | Not defined |'
  prefs: []
  type: TYPE_TB
- en: '| x5z | File system | Replies related to the server''s file system |'
  prefs: []
  type: TYPE_TB
- en: The third digit indicates a specific type of message within each of the functional
    groups described by the second digit. The third digit allows each functional group
    to have ten different reply codes for each reply type given by the first code
    digit (preliminary success, transient failure, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: These *x, y*, and *z* digit meanings are combined to make specific reply codes.
    For example, consider reply code 530, diagrammed in [Figure 72-5](ch72s08.html#ftp_reply_code_format_this_diagram_shows
    "Figure 72-5. FTP reply code format This diagram shows how the three-digit FTP
    reply code format is interpreted. In reply code 530, the 5 indicates a permanent
    error, the 3 specifies that the error is related to authentication or accounting,
    and the 0 is the specific error type. A similar method is used for reply codes
    in many other TCP/IP application protocols, including the Simple Mail Transfer
    Protocol (SMTP) and Hypertext Transfer Protocol (HTTP)."). The first digit tells
    you that this is a permanent negative reply, and the second indicates that it
    is related to login or accounting. (It is, in fact, an error message received
    when a login fails.) The third digit tells you the specific type of error that
    has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: '![FTP reply code format This diagram shows how the three-digit FTP reply code
    format is interpreted. In reply code 530, the 5 indicates a permanent error, the
    3 specifies that the error is related to authentication or accounting, and the
    0 is the specific error type. A similar method is used for reply codes in many
    other TCP/IP application protocols, including the Simple Mail Transfer Protocol
    (SMTP) and Hypertext Transfer Protocol (HTTP).](httpatomoreillycomsourcenostarchimages288269.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 72-5. FTP reply code format This diagram shows how the three-digit FTP
    reply code format is interpreted. In reply code 530, the 5 indicates a permanent
    error, the 3 specifies that the error is related to authentication or accounting,
    and the 0 is the specific error type. A similar method is used for reply codes
    in many other TCP/IP application protocols, including the Simple Mail Transfer
    Protocol (SMTP) and Hypertext Transfer Protocol (HTTP).
  prefs: []
  type: TYPE_NORMAL
- en: Using encoded reply codes allows the code itself to communicate information
    immediately and provides a way of keeping different types of responses organized.
    This idea was adapted for use by several other application protocols, including
    the Simple Mail Transfer Protocol (SMTP) for email, the Network News Transfer
    Protocol (NNTP) for network news, and the Hypertext Transfer Protocol (HTTP) for
    the World Wide Web.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 72-6](ch72s08.html#ftp_reply_codes "Table 72-6. FTP Reply Codes") contains
    a list of some of the more common FTP reply codes taken from RFC 959\. They are
    shown in numerical order, along with the reply text presented as typical in that
    document and additional descriptive information as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 72-6. FTP Reply Codes
  prefs: []
  type: TYPE_NORMAL
- en: '| Reply Code | Typical Reply Text | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 110 | Restart marker reply. | Used as part of the marker restart feature
    when transferring in block mode. |'
  prefs: []
  type: TYPE_TB
- en: '| 120 | Service ready in *nnn* minutes. | *nnn* indicates the number of minutes
    until the service will be available. |'
  prefs: []
  type: TYPE_TB
- en: '| 125 | Data connection already open; transfer starting. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 150 | File status okay; about to open data connection. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 200 | Command okay. | Sometimes the text indicates the name of the command
    that was successful. |'
  prefs: []
  type: TYPE_TB
- en: '| 202 | Command not implemented, or superfluous at this site. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 211 | System status, or system help reply. | Will contain system-specific
    status or help information. |'
  prefs: []
  type: TYPE_TB
- en: '| 212 | Directory status. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 213 | File status. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 214 | Help message. | Includes help information of use to a human user of
    this server. |'
  prefs: []
  type: TYPE_TB
- en: '| 215 | *NAME* system type. | *NAME* is the name of a type of operating system.
    Often sent as a reply to the SYST command. |'
  prefs: []
  type: TYPE_TB
- en: '| 220 | Service ready for new user. | Sent when the command channel is established
    before the USER command is sent. |'
  prefs: []
  type: TYPE_TB
- en: '| 221 | Service closing control connection. | A "goodbye" message is sent when
    the session is closed. |'
  prefs: []
  type: TYPE_TB
- en: '| 225 | Data connection open; no transfer in progress. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 226 | Closing data connection. | Sent after a successful file transfer or
    a file abort. |'
  prefs: []
  type: TYPE_TB
- en: '| 227 | Entering Passive Mode (h1,h2,h3,h4,p1,p2). | Sent in reply to the PASV
    command, indicates the IP address and port to use for the data connection. |'
  prefs: []
  type: TYPE_TB
- en: '| 230 | User logged in, proceed. | Sent after successful USER and PASS authentication.
    Systems often include additional greeting or other information with this code
    after a login. |'
  prefs: []
  type: TYPE_TB
- en: '| 250 | Requested file action okay, completed. | The text description will
    provide more details about what was successfully done, such as confirming a change
    of directory or deleted file. |'
  prefs: []
  type: TYPE_TB
- en: '| 257 | *PATHNAME* created. | *PATHNAME* is replaced by the path created. |'
  prefs: []
  type: TYPE_TB
- en: '| 331 | User name okay, need password. | Intermediate result after sending
    USER but before sending PASS. |'
  prefs: []
  type: TYPE_TB
- en: '| 332 | Need account for login. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 350 | Requested file action pending further information. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 421 | Service not available, closing control connection. | Sometimes sent
    if the FTP server is in the process of shutting down. |'
  prefs: []
  type: TYPE_TB
- en: '| 425 | Can''t open data connection. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 426 | Connection closed; transfer aborted. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 450 | Requested file action not taken. File unavailable. | The file is not
    available; for example, it may be locked by another user. Contrast to reply code
    550. |'
  prefs: []
  type: TYPE_TB
- en: '| 451 | Requested action aborted: local error in processing. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 452 | Requested action not taken. Insufficient storage space in system. |
    The file system is full. |'
  prefs: []
  type: TYPE_TB
- en: '| 500 | Syntax error, command unrecognized. | Bad or excessively long command
    line was sent. |'
  prefs: []
  type: TYPE_TB
- en: '| 501 | Syntax error in parameters or arguments. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 502 | Command not implemented. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 503 | Bad sequence of commands. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 504 | Command not implemented for that parameter. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 530 | Not logged in. | Sent if authentication fails due to a bad user name
    or incorrect password. |'
  prefs: []
  type: TYPE_TB
- en: '| 550 | Requested action not taken. File unavailable. | File was not found
    or user does not have access to it. This error code may be sent in reply to any
    file transfer command if the user has not successfully logged in yet. Contrast
    to reply code 450. |'
  prefs: []
  type: TYPE_TB
- en: '| 551 | Requested action aborted: page type unknown. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 552 | Requested file action aborted. Exceeded storage allocation. |   |'
  prefs: []
  type: TYPE_TB
- en: '| 553 | Requested action not taken. File name not allowed. |   |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Each command sent by the FTP client results in a reply sent
    by the FTP server. FTP replies consist of a three-digit numeric *reply code*,
    along with a line of descriptive text. The reply code serves to standardize FTP
    replies, both so they can be interpreted by client software and so experienced
    users can see at a glance the results of a command. The reply code is structured
    so that the first two digits indicate the type of reply and to what category it
    belongs.'
  prefs: []
  type: TYPE_NORMAL
- en: FTP Multiple-Line Text Replies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible for a reply to contain more than one line of text. In this case,
    each line starts with the reply code, and all lines but the last have a hyphen
    between the reply code and the reply text, to indicate that the reply continues.
    The last line includes a space between the reply code and reply text, just like
    a single-line reply. This facility is often used to provide additional response
    information after a user logs in, via the 230 reply code. [Example 72-1](ch72s08.html#ftp_multiple-line_text_reply_example
    "Example 72-1. FTP multiple-line text reply example") contains an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 72-1. FTP multiple-line text reply example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As I mentioned, the actual text string for each reply code is implementation-specific.
    You can sometimes find some rather humorous text strings associated with some
    of these error messages. For example, I tried some commands using the FreeBSD
    FTP client on one of my Internet accounts. I tried to send or receive a file before
    I was logged in, and it didn''t return an error like "Requested action not taken.
    File unavailable." Instead, it told me this: "Login first, then I might let you
    do that."'
  prefs: []
  type: TYPE_NORMAL
- en: FTP User Interface and User Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The FTP command set provides a rich, complete set of instructions for implementing
    FTP. A human user could employ these commands to perform file-transfer functions
    directly with an FTP server. But to do this, the user must have an intimate knowledge
    of how FTP works. The user must know exactly which commands to send at which time,
    and in what order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gaining knowledge of internal FTP commands might be a reasonable assignment
    for an internetworking expert, but not for a typical TCP/IP application user.
    For this reason, the FTP protocol defines an additional protocol component as
    part of the user-FTP process: the FTP *user interface*. It provides three main
    benefits to the FTP user:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User Friendliness** The FTP user interface presents FTP to the human user
    in a way that is easier and simpler to use than issuing protocol commands. Instead
    of requiring the knowledge of all those four-letter codes, the user interface
    can allow functions to be performed with more intuitive human-language commands.
    For example, we can say `get` a file instead of having to use the command RETR.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Customization** The command used to perform a particular function can be
    customized based on common parlance in the networking industry, without requiring
    changes to be made to FTP itself. For example, the image transfer mode is now
    also commonly called binary mode, so a user command called `binary` has been created
    to set this mode.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Detail Abstraction and Command Sequence Simplification** A single user command
    can be made to issue multiple FTP protocol commands, hiding internal FTP details
    and making the protocol easier to use. In particular, commands that are related
    to the maintenance of the connection and other overhead issues that users don''t
    want to deal with can be automated. For example, an FTP client normally issues
    a PASV or PORT command prior to each data transfer. The user interface can take
    care of issuing this command automatically prior to a RETR or STOR command when
    a user tells FTP to get or send a file.'
  prefs: []
  type: TYPE_NORMAL
- en: Command-Line and Graphical FTP Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditionally, FTP clients have used a *command-line interface*. In this familiar
    arrangement, an FTP client is invoked and the user is automatically asked for
    a user name and password to establish an FTP session. Then the user is presented
    with a command prompt, where the user can type various FTP commands to perform
    different functions. Text responses from the server are displayed to the user
    to indicate the results of various commands. Normally, the internal protocol commands
    (such as PASV and STOR) sent by the client are suppressed to avoid screen clutter,
    but their display can be enabled in a debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line utilities are efficient, but some folks don't care for them. They
    are rather "old school" in the context of modern graphical operating systems and
    applications. Thus, many modern FTP clients are graphical in nature. They allow
    actions to be performed by the user clicking buttons instead of typing commands.
    Some FTP clients allow files to be transferred by dragging and dropping from a
    local file system display to one on a remote server. These make FTP even easier
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The FTP *user interface* is the component on the FTP client
    that acts as an intermediary between the human user and the FTP software. The
    existence of the user interface allows FTP to be used in a friendly manner without
    requiring knowledge of FTP''s internal protocol commands. Most FTP software uses
    either a *command-line interface* that understands English-like user commands
    or a *graphical interface*, where mouse clicks and other graphical operations
    are translated into FTP commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Typical FTP User Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To discover the specific commands supported by an FTP client, consult its documentation.
    In a command-line client, you can enter the command `?` to see a list of supported
    commands. [Table 72-7](ch72s09.html#common_ftp_user_commands "Table 72-7. Common
    FTP User Commands") shows some of the common commands encountered in typical FTP
    command-line clients, along with the typical parameters they require.
  prefs: []
  type: TYPE_NORMAL
- en: Note how many of these commands are actually synonyms, such as `bye`, `exit`,
    and `quit`. Similarly, you can use the command `type ascii` to set the ASCII data
    type or use the `ascii` command. This is all done for the user's convenience and
    is one of the benefits of having a flexible user interface that is distinct from
    the FTP command set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, an alternative way of using FTP is through the specification of an
    FTP Uniform Resource Locator (URL). While FTP is at its heart an interactive system,
    FTP URLs allow simple functions, such as retrieving a single file, to be done
    quickly and easily. They also allow FTP file references to be integrated with
    hypertext (World Wide Web) documents. See "URL Schemes and Scheme-Specific Syntaxes"
    in [Chapter 70](ch70.html "Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING: UNIFORM
    RESOURCE IDENTIFIERS, LOCATORS, AND NAMES (URIS, URLS, AND URNS)") for more on
    how FTP uses URLs.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 72-7. Common FTP User Commands
  prefs: []
  type: TYPE_NORMAL
- en: '| User Command | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `account <account-name>` | Sends the ACCT command to access a particular
    account on the server. |'
  prefs: []
  type: TYPE_TB
- en: '| `append <file-name>` | Appends data to a file using APPE. |'
  prefs: []
  type: TYPE_TB
- en: '| `ascii` | Sets the ASCII data type for subsequent transfers. |'
  prefs: []
  type: TYPE_TB
- en: '| `binary` | Sets the image data type for subsequent transfers. Same as the
    `image` command. |'
  prefs: []
  type: TYPE_TB
- en: '| `bye` | Terminates FTP session and exits the FTP client (same as `exit` and
    `quit`). |'
  prefs: []
  type: TYPE_TB
- en: '| `cd <directory-path>` | Changes the remote server working directory (using
    CWD protocol command). |'
  prefs: []
  type: TYPE_TB
- en: '| `cdup` | Goes to parent of current working directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `chmod <file-name>` | On UNIX systems, changes file permissions of a file.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `close` | Closes a particular FTP session but user stays at FTP command line.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `debug` | Sets debug mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `delete <file-name>` | Deletes a file on the FTP server. |'
  prefs: []
  type: TYPE_TB
- en: '| `dir [<optional-file-specification>]` | Lists contents of current working
    directory (or files matching the specification). |'
  prefs: []
  type: TYPE_TB
- en: '| `exit` | Another synonym for `bye` and `quit`. |'
  prefs: []
  type: TYPE_TB
- en: '| `form <format>` | Sets the transfer format. |'
  prefs: []
  type: TYPE_TB
- en: '| `ftp <ftp-server>` | Opens session to the FTP server. |'
  prefs: []
  type: TYPE_TB
- en: '| `get <file-name> [<dest-file-name>]` | Gets a file. If the *`<dest-file-name>`*
    parameter is specified, it is used for the name of the file retrieved; otherwise,
    the source filename is used. |'
  prefs: []
  type: TYPE_TB
- en: '| `help [<optional-command-name>]` | Displays FTP client help information.
    Same as `?`. |'
  prefs: []
  type: TYPE_TB
- en: '| `image` | Sets the image data type, like the `binary` command. |'
  prefs: []
  type: TYPE_TB
- en: '| `ls [<optional-file-specification>]` | Lists contents of current working
    directory (or files matching the specification). Same as `dir`. |'
  prefs: []
  type: TYPE_TB
- en: '| `mget <file-specification>` | Gets multiple files from the server. |'
  prefs: []
  type: TYPE_TB
- en: '| `mkdir <directory-name>` | Creates a directory on the remote server. |'
  prefs: []
  type: TYPE_TB
- en: '| `mode` **`<transfer-mode>`** | Sets the file transfer mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `mput <file-specification>` | Sends (puts) multiple files to the server.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `msend <file-specification>` | Same as `mput`. |'
  prefs: []
  type: TYPE_TB
- en: '| `open <ftp-server>` | Opens a session to the FTP server (same as `ftp`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `passive` | Turns passive transfer mode on and off. |'
  prefs: []
  type: TYPE_TB
- en: '| `put <file-name> [<dest-file-name>]` | Sends a file to the server. If the
    *`<dest-file-name>`* parameter is specified, it is used as the name for the file
    on the destination host; otherwise, the source filename is used. |'
  prefs: []
  type: TYPE_TB
- en: '| `pwd` | Prints current working directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `quit` | Terminates FTP session and exits FTP client (same as `bye` and `exit`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `recv <file-name> [<dest-file-name>]` | Receives file (same as `get`). If
    the *`<dest-file-name>`* parameter is specified, it is used for the name of the
    file retrieved; otherwise, the source filename is used. |'
  prefs: []
  type: TYPE_TB
- en: '| `rename <old-file-name> <new-file-name>` | Renames a file. |'
  prefs: []
  type: TYPE_TB
- en: '| `rhelp` | Displays remote help information, obtained using FTP `HELP` command.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `rmdir <directory-name>` | Removes a directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `send <file-name> [<dest-file-name>]` | Sends a file (same as `put`). If
    the *`<dest-file-name>`* parameter is specified, it is used as the name for the
    file on the destination host; otherwise, the source file name is used. |'
  prefs: []
  type: TYPE_TB
- en: '| `site` | Sends a site-specific command to the server. |'
  prefs: []
  type: TYPE_TB
- en: '| `size <file-name>` | Shows the size of a remote file. |'
  prefs: []
  type: TYPE_TB
- en: '| `status` | Displays current session status. |'
  prefs: []
  type: TYPE_TB
- en: '| `struct <structure-type>` | Sets the file structure. |'
  prefs: []
  type: TYPE_TB
- en: '| `system` | Shows the server''s operating system type. |'
  prefs: []
  type: TYPE_TB
- en: '| `type <data-type>` | Sets the data type for transfers. |'
  prefs: []
  type: TYPE_TB
- en: '| `user <user-name>` | Logs in to server as a new user. Server will prompt
    for a password. |'
  prefs: []
  type: TYPE_TB
- en: '| `? [<optional-command-name>]` | Displays FTP client help information. Same
    as `help`. |'
  prefs: []
  type: TYPE_TB
- en: Sample FTP Session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having now seen all the details of how FTP works, let's tie everything together
    by looking at a sample FTP session between an FTP client and server, to see FTP
    commands and replies in action. In this example, I will invoke FTP from a client
    to retrieve a text file from an FTP server, and then I'll delete the file from
    the server and the directory that contained it. In the process, I will issue some
    additional commands to illustrate more of how FTP works. I will enable debug mode
    in the FTP client so that for each user command, you can see the actual FTP commands
    generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 72-8](ch72s10.html#sample_ftp_session-id001 "Table 72-8. Sample FTP
    Session") shows the sample FTP session, slightly simplified. The first column
    contains commands entered by the user (that''s me, of course) on the FTP client.
    The second shows the actual protocol command(s) sent to the FTP server in highlighted
    text and the reply returned from the server to the client in plain text. The third
    column contains descriptive comments.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 72-8. Sample FTP Session
  prefs: []
  type: TYPE_NORMAL
- en: '| User Command | FTP Protocol Command/FTP Server Reply | Comments |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '| This is the command to start up FTP. The `-d` enables debug mode. In this
    initial step, the TCP control connection is made and the server replies with a
    220 reply code indicating that it''s ready for user identification. The FTP client
    automatically prompts for the user name. |'
  prefs: []
  type: TYPE_TB
- en: '| `ixl` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '| I use `ixl` for user names commonly. Here, the FTP client sends the user
    name and the server responds, asking for the password. |'
  prefs: []
  type: TYPE_TB
- en: '| `****` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| I enter my password, which is sent to the FTP server, and the server authenticates
    me and sends back a 230 message. This tells me the login was successful. It also
    provides additional information.The FTP client then automatically sends a SYST
    command to tell me what type of system the server is using, which is UNIX in this
    case. The client tells me that binary mode has been selected by default; this
    is often the default when doing FTP from UNIX to UNIX (as I am doing here), since
    there is no need for ASCII mode when moving text files between similar systems.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pwd` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| I check the current working directory (`cwd`), which the server tells me
    is my own home directory on this system. |'
  prefs: []
  type: TYPE_TB
- en: '| `cd ftptest` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| I try to go to a directory called ftptest, but that was the wrong name, so
    I get a 550 error for my trouble. (I wasn''t trying to do this; I forgot the directory
    name but figured I might as well show it to you anyway!) |'
  prefs: []
  type: TYPE_TB
- en: '| `cd ftpdemo` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| I got the name right this time, and the server confirms the new working directory.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `dir` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '| I request a list of files from the server. The FTP client automatically issues
    a PASV command, and the server responds with a port number and IP address for
    it to use. (I have not shown the IP here for security reasons.) The directory
    listing is then transferred from the server to the client. |'
  prefs: []
  type: TYPE_TB
- en: '| `asc` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '| I set ASCII mode, although I didn''t really need to do that. Note that this
    client allowed me to abbreviate the `ascii` command as `asc`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '| I get the file in this demo directory using a `get` command. The server accepts
    the PASV command and sends the file. It initially sends a 150 reply as the transfer
    starts (initial positive reply), and then sends 226 when it is done. Note that
    the port numbers used here are different (for both server and client) than they
    were for the directory listing I did earlier. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '| I delete the original file on the server. |'
  prefs: []
  type: TYPE_TB
- en: '| `cdup` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '| I go up to the parent directory. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '| I remove the directory that the file was in. |'
  prefs: []
  type: TYPE_TB
- en: '| `quit` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| I end the FTP session. The `quit` command also automatically closes the FTP
    client and returns me to the UNIX shell. |'
  prefs: []
  type: TYPE_TB
- en: Chapter 73. TRIVIAL FILE TRANSFER PROTOCOL (TFTP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 72](ch72.html "Chapter 72. FILE TRANSFER PROTOCOL (FTP)"), you saw
    how the File Transfer Protocol (FTP) implements a full set of commands and reply
    functionalities that enables a user to perform a wide range of file movement and
    manipulation tasks. Although FTP is ideal as a general-purpose protocol for file
    transfer between computers, on certain types of hardware, it is too complex to
    implement easily and provides more capabilities than are really needed. In cases
    where only the most basic file transfer functions are required while simplicity
    and small program size is of paramount importance, a companion to FTP called the
    *Trivial File Transfer Protocol (TFTP)* can be used.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides a description of the operation of TFTP, beginning with
    an overview description of the protocol, its history and motivation, and the relevant
    standards that describe it. I discuss its operation in general terms, cover how
    TFTP clients and servers communicate, and explain TFTP messaging in detail. I
    then discuss TFTP options and the TFTP option negotiation mechanism. The chapter
    concludes by showing the various TFTP message formats.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**BACKGROUND INFORMATION** *While TFTP is a distinct protocol from FTP, explaining
    the former is easier when the reader is familiar with the latter. I assume that
    the reader has some understanding of FTP, since it is the more commonly used protocol.
    If you have come to this chapter prior to reading [Chapter 72](ch72.html "Chapter 72. FILE
    TRANSFER PROTOCOL (FTP)"), I recommend at least reading the section "FTP Overview,
    History, and Standards" in that chapter before proceeding here*.'
  prefs: []
  type: TYPE_NORMAL
- en: TFTP Overview, History, and Standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FTP is the main protocol used for the majority of general file transfers in
    TCP/IP internetworks. One of the objectives of the designers of FTP was to keep
    the protocol relatively simple, but that was possible only to a limited extent.
    To enable the protocol to be useful in a variety of cases and between many kinds
    of devices, FTP needed a fairly large set of features and capabilities. As a result,
    while FTP is not as complex as certain other protocols, it is still fairly complicated
    in a number of respects.
  prefs: []
  type: TYPE_NORMAL
- en: Why TFTP Was Needed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complexity of FTP is partly due to the protocol itself, with its dozens
    of commands and reply codes, and partly due to the need of using TCP for connections
    and data transport. The reliance on TCP means that any device wanting to use FTP
    needs not only the FTP program but a full TCP implementation as well. It must
    handle FTP's need for simultaneous data and control channel connections and other
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: For a conventional computer, such as a regular PC, Macintosh, or UNIX workstation,
    none of this is really an issue, especially with today's large hard disks and
    fast, cheap memory. But remember that FTP was developed more than three decades
    ago, when hardware was slow and memory was expensive. Furthermore, even today,
    regular computers are not the only devices used on networks. Some networked devices
    do not have the capabilities of true computers, but they still need to be able
    to perform file transfers. For these devices, a full FTP and TCP implementation
    is a nontrivial matter.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most notable examples of such devices are *diskless workstations*—computers
    that have no permanent storage, so when they start up, they cannot read a whole
    TCP/IP implementation from a hard disk like most computers easily do. They start
    with only a small amount of built-in software and must obtain configuration information
    from a server and then download the rest of their software from another network
    device. The same issue arises for certain other hardware devices with no hard
    disks.
  prefs: []
  type: TYPE_NORMAL
- en: The process of starting up these devices is commonly called *bootstrapping*
    and occurs in two phases. First, the workstation is provided with an IP address
    and other parameters through the use of a host configuration protocol such as
    the Bootstrap Protocol (BOOTP; see [Chapter 60](ch60.html "Chapter 60. TCP/IP
    BOOTSTRAP PROTOCOL (BOOTP)")) or the Dynamic Host Control Protocol (DHCP; see
    Chapters [Chapter 61](ch61.html "Chapter 61. DHCP OVERVIEW AND ADDRESS ALLOCATION
    CONCEPTS") to [Chapter 64](ch64.html "Chapter 64. DHCP CLIENT/SERVER IMPLEMENTATION,
    FEATURES, AND IPV6 SUPPORT")). Second, the client downloads software, such as
    an operating system and drivers, that let it function on the network like any
    other device. This requires that the device have the ability to transfer files
    quickly and easily. The instructions to perform this bootstrapping must fit onto
    a read-only memory (ROM) chip, and this makes the size of the software an important
    issue—again, especially many years ago.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this need was to create a "light" version of FTP that would
    emphasize small program size and simplicity over functionality. This new protocol,
    TFTP, was initially developed in the late 1970s and first standardized in 1980\.
    The modern version, *TFTP version 2*, was documented in RFC 783 in 1981, which
    was revised and published as RFC 1350, "The TFTP Protocol (Revision 2)," in 1992\.
    This is the current version of the standard.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing FTP and TFTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably the best way to understand the relationship between TFTP and FTP is
    to compare it to the relationship between the Transmission Control Protocol (TCP)
    and User Datagram Protocol (UDP) at the transport layer. UDP is a simplified,
    stripped-down alternative to TCP that is used when simplicity is more important
    than rich functionality. Similarly, TFTP is a greatly simplified version of FTP
    that allows only basic operations and lacks some of FTP's fancy capabilities in
    order to keep its implementation easy (even trivial) and its program size small.
  prefs: []
  type: TYPE_NORMAL
- en: Due to its limitations, TFTP is a complement to FTP, not a replacement for it.
    TFTP is used only when its simplicity is important and its lack of features is
    not. Its most common application is bootstrapping, as described above, though
    it can be used for other purposes. One specific application that the TFTP standard
    describes for the protocol is the transport of electronic mail (email). While
    the protocol supports this explicitly, TFTP is not generally used for this purpose
    today.
  prefs: []
  type: TYPE_NORMAL
- en: 'FTP and TFTP have significant differences in at least four significant areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transport** The comparison to TCP and UDP is apt not only based on the features/simplicity
    trade-off, but because FTP uses TCP for transport while TFTP uses UDP. Like TFTP,
    UDP is simple, and this makes the two ideal for embedding together as a hardware
    program set in a network device.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Limited Command Set** FTP includes a rich set of commands to allow files
    to be sent, received, renamed, deleted, and so forth. TFTP allows files only to
    be sent and received.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Limited Data Representations** TFTP does not include some of FTP''s fancy
    data representation options; it allows only simple ASCII or binary file transfers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lack of Authentication** UDP uses no login mechanism or other means of authentication.
    This is again a simplification, though it means the operators of TFTP servers
    must severely restrict the files they make available for access. (It is also part
    of why TFTP specifically does not allow the client to perform dangerous file operations
    such as deletion.)'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of TFTP Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Communication and messaging in TFTP is very different from FTP because of the
    different transport layer protocols used by each. FTP makes use of TCP's rich
    functionality, including its stream data orientation, to allow it to send bytes
    of data directly over the FTP data connection. TCP also takes care of reliable
    delivery of data for FTP, ensuring that files are received correctly. In contrast,
    since TFTP uses UDP, it must package data into individual messages for both protocol
    control and data communication. TFTP must also take care of timing transmissions
    to detect lost datagrams and then retransmitting as needed.
  prefs: []
  type: TYPE_NORMAL
- en: TFTP servers allow connections from TFTP clients to perform file send and receive
    operations. Many hosts that run FTP servers will also run a separate TFTP server
    module. TFTP users initiate connections by starting a TFTP client program, which
    generally uses a command-line interface similar to that of many FTP clients; the
    main difference is the much smaller number of commands in TFTP.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** For situations in which the full FTP is either unnecessary
    or impractical, the simpler *Trivial File Transfer Protocol (TFTP)* was developed.
    TFTP is like FTP in that it is used for general file transfer between a client
    and server device, but it is stripped down in its capabilities. Rather than including
    a full command set and using TCP for communication, like FTP, TFTP can be used
    only for reading or writing a single file, and it uses the fast but unreliable
    UDP for transport. It is often preferred in situations where small files must
    be transferred quickly and simply, such as for bootstrapping diskless workstations.'
  prefs: []
  type: TYPE_NORMAL
- en: The basic operation of TFTP has not changed since RFC 1350 was published, but
    a new feature was added to the protocol in 1995\. RFC 1782, "TFTP Option Extension,"
    defines a mechanism by which a TFTP client and TFTP server can negotiate certain
    parameters that will control a file transfer prior to the transfer commencing.
    This allows more flexibility in how TFTP is used, adding a slight amount of complexity
    to TFTP, but not a great deal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The option extension is backward-compatible with regular TFTP and is used only
    if both server and client support it. Two subsequent RFCs define the actual options
    that can be negotiated: RFC 1783, "TFTP Blocksize Option," and RFC 1784, "TFTP
    Timeout Interval and Transfer Size Options." This set of three RFCs (1782, 1783,
    and 1784) was replaced in 1998 by updated versions in RFCs 2347, 2348, and 2349.'
  prefs: []
  type: TYPE_NORMAL
- en: TFTP General Operation, Connection Establishment, and Client/Server Communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the *T* in *TF TP* stands for *Trivial*, and the protocol was specifically
    designed to be simple, you would think that describing how it works would, in
    fact, be simple, wouldn''t you? And, actually, that''s pretty much true. TFTP
    communication is client/server based, as discussed in the overview. The process
    of transferring a file consists of three main phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial Connection** The TFTP client establishes the connection by sending
    an initial request to the server. The server responds back to the client, and
    the connection is effectively opened.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Transfer** Once the connection is established, the client and server
    exchange TFTP messages. One device sends data, and the other sends acknowledgments.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connection Termination** When the last TFTP message containing data has been
    sent and acknowledged, the connection is terminated.'
  prefs: []
  type: TYPE_NORMAL
- en: Connection Establishment and Identification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The matter of a connection is somewhat different in TFTP than it is with a protocol
    like FTP that uses TCP. FTP must establish a connection at the TCP level before
    anything can be done by FTP itself. TFTP, however, uses the connectionless UDP
    for transport, so there is no connection in the sense that one exists in TCP.
    In TFTP, the connection is more in a *logical* sense, meaning that the client
    and server are participating in the protocol and exchanging TFTP messages.
  prefs: []
  type: TYPE_NORMAL
- en: The TFTP server listens continuously for requests on well-known UDP port number
    69, which is reserved for TFTP. The client chooses for its initial communication
    an ephemeral port number, as is usually the case in TCP/IP. This port number actually
    identifies the data transfer and is called a *transfer identifier (TID)*.
  prefs: []
  type: TYPE_NORMAL
- en: What's different about TFTP, however, is that the server also selects a pseudorandom
    TID that it uses for sending responses back to the client; it doesn't send them
    from port number 69\. This is done because by using a unique client port number
    and source port number, multiple TFTP exchanges can be conducted simultaneously
    by a server. Each transfer is identified automatically by the source and destination
    port number, so there is no need to identify in data messages the transfer to
    which each block data belongs. This keeps the TFTP header size down, allowing
    more of each UDP message to contain actual data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose the TFTP client selects a TID of 3145 for its initial message.
    It would send a UDP transmission from its port 3145 to the server's port 69\.
    Say the server selects a TID of 1114\. It would send its reply from its port 1114
    to the client's port 3145\. From then on, the client would send messages back
    to server port 1114 until the TFTP session was completed.
  prefs: []
  type: TYPE_NORMAL
- en: Lock-Step Client/Server Messaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the initial exchange, the client and server exchange data and acknowledgment
    messages in *lock-step* fashion. Each device sends a message for each message
    it receives: one device sends data messages and waits for acknowledgments; the
    other sends acknowledgments and waits for data messages. This form of rigid communication
    is less efficient than allowing the transmitter to fire away with one data message
    after another, but it is important because it keeps TFTP simple when it comes
    to an important issue: retransmissions.'
  prefs: []
  type: TYPE_NORMAL
- en: Like all protocols using the unreliable UDP, TFTP has no assurances that any
    messages sent will actually arrive at their destination, so it must use timers
    to detect lost transmissions and resend them. What is different about TFTP is
    that both clients and servers perform retransmission. The device that is sending
    data messages will resend the data message if it doesn't receive an acknowledgment
    in a reasonable period of time; the device sending the acknowledgments will resend
    the acknowledgment if it doesn't receive the next data message promptly. The lock-step
    communication greatly simplifies this process, since each device needs to keep
    track of only one outstanding message at a time. It also eliminates the need to
    deal with complications such as reorganizing blocks received out of order (which
    protocols like FTP rely on TCP to manage).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Since TFTP uses UDP rather than TCP, no explicit concept of
    a connection exists as in FTP. A TFTP session instead uses the concept of a logical
    connection, which is opened when a client sends a request to a server to read
    or write a file. Communication between the client and server is performed in lock-step
    fashion: one device sends data messages and receives acknowledgments so it knows
    the data messages were received; the other sends acknowledgments and receives
    data messages so it knows the acknowledgments were received.'
  prefs: []
  type: TYPE_NORMAL
- en: Difficulties with TFTP's Simplified Messaging Mechanism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important drawbacks with this technique is that while it simplifies
    communication, it does so at the cost of performance. Since only one message can
    be in transit at a time, this limits throughput to a maximum of 512 bytes for
    exchange of messages between the client and server. In contrast, when using FTP,
    large amounts of data can be pipelined; there is no need to wait for an acknowledgment
    for the first piece of data before sending the second.
  prefs: []
  type: TYPE_NORMAL
- en: Another complication is that if a data or an acknowledgment message is resent
    and the original was not lost but rather just delayed, two copies will show up.
    The original TFTP rules stated that upon receipt of a duplicate datagram, the
    device receiving it may resend the current datagram. So, receipt of a duplicate
    block 2 by a client doing a read would result in the client sending a duplicate
    acknowledgment for block 2\. This would result in two acknowledgments being received
    by the server, which would in turn send block 3 twice. Then there would be two
    acknowledgments for block 3, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The end result of this is that once the initial duplication occurs, every message
    thereafter is sent twice. This has been affectionately dubbed the *Sorcerer's
    Apprentice bug*, after the story used as the basis of the famous scene in the
    movie *Fantasia*, where Mickey Mouse cuts animated brooms in half only to find
    that each half comes to life. This problem was fixed by changing the rules so
    that only the device receiving a duplicate data message may send a duplicate acknowledgment.
    Receipt of a duplicate acknowledgment does not result in sending a duplicate data
    message. Since only one of the two devices can send duplicates, this fixes the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: It's also worth emphasizing that TFTP includes absolutely no security, so no
    login or authentication process is in place. As mentioned earlier, administrators
    must use caution in deciding what files to make available via TFTP and in allowing
    write access to TFTP servers.
  prefs: []
  type: TYPE_NORMAL
- en: TFTP Detailed Operation and Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You saw earlier that TFTP operation consists of three general steps: initial
    connection, data transfer, and connection termination. All operations are performed
    through the exchange of specific TFTP messages. Let''s take a more detailed look
    now at these three phases of operation and the specifics of TFTP messaging.'
  prefs: []
  type: TYPE_NORMAL
- en: Initial Message Exchange
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first message sent by the client to initiate TFTP is either a read request
    (RRQ) message or a write request (WRQ) message. This message serves implicitly
    to establish the logical TFTP connection and to indicate whether the file is to
    be sent from the server to the client (read request) or the client to the server
    (write request). The message also specifies the type of file transfer to be performed.
    TFTP supports two transfer modes: *netascii* mode (ASCII text files as used by
    the Telnet Protocol) and *octet* mode (binary files).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Originally, a third file type option existed, called mail mode, but TFTP was
    never really designed for transmitting mail and this option is now obsolete*.'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming no problem occurred with the request (such as a server problem, inability
    to find the file, and so on), the server will respond with a positive reply. In
    the case of a read request, the server will immediately send the first data message
    back to the client. In the case of a write request, the server will send an acknowledgment
    message to the client, telling it that it may proceed to send the first data message.
  prefs: []
  type: TYPE_NORMAL
- en: After the initial exchange, the client and server exchange data and acknowledgment
    messages in lock-step fashion as described earlier. For a read, the server sends
    one data message and waits for an acknowledgment from the client before sending
    the next one. For a write, the client sends one data message and the server sends
    an acknowledgment for it, before the client sends the next data message.
  prefs: []
  type: TYPE_NORMAL
- en: Data Block Numbering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each data message contains a block of between 0 and 512 bytes of data. The blocks
    are numbered sequentially, starting with 1\. The number of each block is placed
    in the header of the data message carrying that block and then used in the acknowledgment
    for that block so the original sender knows it was received. The device sending
    the data will always send 512 bytes of data at a time for as long as it has enough
    data to fill the message. When it gets to the end of the file and has fewer than
    512 bytes to send, it will send only as many bytes as remain. (Interestingly,
    this means that if the size of the file is an exact multiple of 512, the last
    message sent will have zero bytes of data!)
  prefs: []
  type: TYPE_NORMAL
- en: The receipt of a data message with between 0 and 511 bytes of data signals that
    this is the last data message. Once this is acknowledged, it automatically signals
    the end of the data transfer. There is no need to terminate the connection explicitly,
    just as it was not necessary to establish it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: TFTP Read Process Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at an example that shows how TFTP messaging works. Suppose the
    client wants to read a particular file that is 1200 bytes long. Here are the steps
    in simplified form (also displayed in [Figure 73-1](ch73s03.html#tftp_read_process_in_this_example_the_cl
    "Figure 73-1. TFTP read process In this example, the client starts the process
    of reading a file by sending a request for it to the server. The server acknowledges
    this request by immediately sending a DATA message carrying block 1, containing
    the first 512 bytes of the file. The client acknowledges this with an ACK message
    for block 1\. The server then sends block 2, containing bytes 513 to 1024, which
    the client acknowledges. When the client receives block 3, it realizes it has
    only 176 bytes, which marks it as the last block of the file.")):'
  prefs: []
  type: TYPE_NORMAL
- en: The client sends a read request to the server, specifying the name of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server sends back a data message containing block 1, carrying 512 bytes
    of data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client receives the data and sends back an acknowledgment for block 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server sends block 2, with 512 bytes of data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client receives block 2 and sends back an acknowledgment for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server sends block 3, containing 176 bytes of data. It waits for an acknowledgment
    before terminating the logical connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client receives the data and sends an acknowledgment for block 3\. Since
    this data message had fewer than 512 bytes, it knows the file is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server receives the acknowledgment and knows the file was received successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![TFTP read process In this example, the client starts the process of reading
    a file by sending a request for it to the server. The server acknowledges this
    request by immediately sending a DATA message carrying block 1, containing the
    first 512 bytes of the file. The client acknowledges this with an ACK message
    for block 1\. The server then sends block 2, containing bytes 513 to 1024, which
    the client acknowledges. When the client receives block 3, it realizes it has
    only 176 bytes, which marks it as the last block of the file.](httpatomoreillycomsourcenostarchimages288271.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 73-1. TFTP read process In this example, the client starts the process
    of reading a file by sending a request for it to the server. The server acknowledges
    this request by immediately sending a DATA message carrying block 1, containing
    the first 512 bytes of the file. The client acknowledges this with an ACK message
    for block 1\. The server then sends block 2, containing bytes 513 to 1024, which
    the client acknowledges. When the client receives block 3, it realizes it has
    only 176 bytes, which marks it as the last block of the file.
  prefs: []
  type: TYPE_NORMAL
- en: TFTP Write Process Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps in the same process, but where the client is writing the
    file (see [Figure 73-2](ch73s03.html#tftp_write_process_this_example_shows_th
    "Figure 73-2. TFTP write process This example shows the client sending the same
    1200-byte file to the server that it read in Figure 73-1\. The client sends a
    write request to the server, which acknowledges it; it uses block 0 to represent
    acknowledgment of the request prior to receipt of any data. The client then sends
    blocks of data one at a time, each of which is acknowledged by the server. When
    the server receives block 3 containing fewer than 512 bytes of data, it knows
    it has received the whole file.")):'
  prefs: []
  type: TYPE_NORMAL
- en: The client sends a write request to the server, specifying the name of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server sends back an acknowledgment. Since this acknowledgment is prior
    to the receipt of any data, it uses block 0 in the acknowledgment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client sends a data message containing block 1, with 512 bytes of data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server receives the data and sends back an acknowledgment for block 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client sends block 2, containing 512 bytes of data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server receives the data and sends back an acknowledgment for block 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client sends block 3, containing 176 bytes of data. It waits for an acknowledgment
    before terminating the logical connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server receives block 3 and sends an acknowledgment for it. Since this data
    message had fewer than 512 bytes, the transfer is done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client receives the acknowledgment for block 3 and knows the file write
    was completed successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![TFTP write process This example shows the client sending the same 1200-byte
    file to the server that it read in . The client sends a write request to the server,
    which acknowledges it; it uses block 0 to represent acknowledgment of the request
    prior to receipt of any data. The client then sends blocks of data one at a time,
    each of which is acknowledged by the server. When the server receives block 3
    containing fewer than 512 bytes of data, it knows it has received the whole file.](httpatomoreillycomsourcenostarchimages288273.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 73-2. TFTP write process This example shows the client sending the same
    1200-byte file to the server that it read in [Figure 73-1](ch73s03.html#tftp_read_process_in_this_example_the_cl
    "Figure 73-1. TFTP read process In this example, the client starts the process
    of reading a file by sending a request for it to the server. The server acknowledges
    this request by immediately sending a DATA message carrying block 1, containing
    the first 512 bytes of the file. The client acknowledges this with an ACK message
    for block 1\. The server then sends block 2, containing bytes 513 to 1024, which
    the client acknowledges. When the client receives block 3, it realizes it has
    only 176 bytes, which marks it as the last block of the file."). The client sends
    a write request to the server, which acknowledges it; it uses block 0 to represent
    acknowledgment of the request prior to receipt of any data. The client then sends
    blocks of data one at a time, each of which is acknowledged by the server. When
    the server receives block 3 containing fewer than 512 bytes of data, it knows
    it has received the whole file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** A TFTP *read operation* begins with the client sending a read
    request message to the TFTP server; the server then sends the file in 512-byte
    data messages, waiting after each one for the client to acknowledge receipt before
    sending the next. A TFTP *write operation* starts with a write request sent by
    the client to the server, which the server acknowledges. The client then sends
    the file in 512-byte data blocks, waiting after each for the server to acknowledge
    receipt. In both cases, there is no explicit means by which the end of a transfer
    is marked; the device receiving the file simply knows the transfer is complete
    when it receives a data message containing fewer than 512 bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: If a problem is encountered at any stage of the connection establishment or
    transfer process, a device may reply with an error message instead of a data or
    acknowledgment message, as appropriate. An error message normally results in the
    failure of the data transfer; this is one of the prices paid for the simplicity
    of TFTP.
  prefs: []
  type: TYPE_NORMAL
- en: Each TFTP file transfer proceeds using the process described, which transfers
    a single file. If another file needs to be sent or received, a new logical communication
    is established, in a manner analogous to how FTP creates data connections. The
    main difference is that TFTP has no persistent control connection, as FTP does.
  prefs: []
  type: TYPE_NORMAL
- en: TFTP Options and Option Negotiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the difficulties that designers of simple protocols and applications
    seem to have is keeping them simple. Many protocols start out small, but over
    time well-intentioned users suggest improvements that are added slowly but surely.
    Eventually, the program that was once lean and mean has become, shall we say,
    "well-marbled." In the software industry, this is called *feature creep* and has
    happened to many protocols and applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The temptation to add features is especially strong when the program or protocol
    has few to begin with. Given this, the maintainers of TFTP have done a good job
    over the years of avoiding this pitfall. However, they did allow one new feature
    to be added to the protocol in 1995: the "TFTP Option Extension," which describes
    how a TFTP client and server can negotiate *options* before transferring a file.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason for adding this capability is that the original TFTP provided no
    way at all for the client and server to exchange important control information
    prior to sending a file. This limited the flexibility of the protocol to deal
    with special cases, such as the transfer of data over unusual network types. The
    TFTP option negotiation feature allows additional parameters to be exchanged between
    the client and server that govern how data is transferred. It does this without
    significantly complicating the protocol and is backward-compatible with normal
    TFTP. It is used only if both client and server support it, and one device trying
    to use the feature will not cause problems if the other doesn't support it.
  prefs: []
  type: TYPE_NORMAL
- en: TFTP Option Negotiation Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client begins the negotiation by sending a modified TFTP read request or
    write request message. In addition to the normal information that appears in this
    message (described in the "TFTP Message Formats" section later in this chapter),
    a list of options may also be included. Each is specified with an option code
    and an option value. The names and values are expressed as ASCII strings, terminated
    by a null character (0 byte). Multiple options may be specified in the request
    message.
  prefs: []
  type: TYPE_NORMAL
- en: The server receives the request containing the options, and if it supports the
    option extension, it processes them. It then returns a *special option acknowledgment
    (OACK*) message to the client, where it lists all the options that the client
    specified that the server recognizes and accepts. Any options that the client
    requested but the server rejects are not included in the OACK. The client may
    use only the options that the server accepts. If the client rejects the server's
    response, it may send back an error message (with error code 8) upon receipt of
    the unacceptable OACK message.
  prefs: []
  type: TYPE_NORMAL
- en: The server may specify an alternative value in its response for certain options,
    if it recognizes the option but doesn't like the client's suggested value. Obviously,
    if the server doesn't support options at all, it will ignore the client's option
    requests and respond with a data message (for a read) or a regular acknowledgment
    (for a write) as in normal TFTP.
  prefs: []
  type: TYPE_NORMAL
- en: If the server did send an OACK, the client proceeds to send messages using the
    regular messaging exchange described in the previous section. In the case of a
    write, the OACK replaces the regular acknowledgment in the message dialog. In
    the case of a read, the OACK is the server's first message instead of the first
    data block that it would normally send. TFTP doesn't allow the same device to
    send two datagrams in a row, so a reply from the client must be received before
    that first block can be sent. The client does this by sending a regular acknowledgment
    with a block number of 0 in it—the same form of acknowledgment a server normally
    sends for a write.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** TFTP is supposed to be a small and simple protocol, so it includes
    few extra features. One that it does support is *option negotiation*, where a
    TFTP client and server attempt to come to agreement on additional parameters that
    they will use in transferring a file. The TFTP client includes one or more options
    in its read request or write request message; the TFTP server then sends an option
    acknowledgment (OACK) message listing each option the server agrees to use. The
    use of options when reading a file means that an extra acknowledgment must be
    sent by the client—to acknowledge the OACK—before the server sends the first block
    of the file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For review, let''s take a look at each of the four possible cases: read and
    write, with and without options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial message exchange for a normal read (without option negotiation),
    as shown in [Figure 73-1](ch73s03.html#tftp_read_process_in_this_example_the_cl
    "Figure 73-1. TFTP read process In this example, the client starts the process
    of reading a file by sending a request for it to the server. The server acknowledges
    this request by immediately sending a DATA message carrying block 1, containing
    the first 512 bytes of the file. The client acknowledges this with an ACK message
    for block 1\. The server then sends block 2, containing bytes 513 to 1024, which
    the client acknowledges. When the client receives block 3, it realizes it has
    only 176 bytes, which marks it as the last block of the file."), is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Client sends read request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Server sends data block 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Client acknowledges data block 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And so on …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With option negotiation, a read is as follows (see [Figure 73-3](ch73s04.html#tftp_read_process_with_option_negotiatio
    "Figure 73-3. TFTP read process with option negotiation This diagram shows the
    same example illustrated in Figure 73-1, but with one added message exchange used
    for option negotiation. The client''s initial read request here includes options
    that it wants to use for this transfer. The server responds not immediately with
    the first data block, but with an OACK. The client indicates receipt of the OACK
    by sending an acknowledgment using block 0\. The server sends data block 1, and
    the rest of the exchange proceeds as normal.")):'
  prefs: []
  type: TYPE_NORMAL
- en: Client sends read request with options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Server sends OACK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Client sends regular acknowledgment for block 0; that is, it acknowledges the
    OACK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Server sends data block 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Client acknowledges data block 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And so on …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![TFTP read process with option negotiation This diagram shows the same example
    illustrated in , but with one added message exchange used for option negotiation.
    The client''s initial read request here includes options that it wants to use
    for this transfer. The server responds not immediately with the first data block,
    but with an OACK. The client indicates receipt of the OACK by sending an acknowledgment
    using block 0\. The server sends data block 1, and the rest of the exchange proceeds
    as normal.](httpatomoreillycomsourcenostarchimages288275.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 73-3. TFTP read process with option negotiation This diagram shows the
    same example illustrated in [Figure 73-1](ch73s03.html#tftp_read_process_in_this_example_the_cl
    "Figure 73-1. TFTP read process In this example, the client starts the process
    of reading a file by sending a request for it to the server. The server acknowledges
    this request by immediately sending a DATA message carrying block 1, containing
    the first 512 bytes of the file. The client acknowledges this with an ACK message
    for block 1\. The server then sends block 2, containing bytes 513 to 1024, which
    the client acknowledges. When the client receives block 3, it realizes it has
    only 176 bytes, which marks it as the last block of the file."), but with one
    added message exchange used for option negotiation. The client's initial read
    request here includes options that it wants to use for this transfer. The server
    responds not immediately with the first data block, but with an OACK. The client
    indicates receipt of the OACK by sending an acknowledgment using block 0\. The
    server sends data block 1, and the rest of the exchange proceeds as normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial message exchange for a normal write (without option negotiation)
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Client sends write request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Server sends acknowledgment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Client sends data block 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Server acknowledges data block 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And so on …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And here''s a write with option negotiation:'
  prefs: []
  type: TYPE_NORMAL
- en: Client sends write request with options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Server sends option acknowledgment (instead of regular acknowledgment).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Client sends data block 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Server acknowledges data block 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And so on …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TFTP Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 73-1](ch73s04.html#tftp_options-id001 "Table 73-1. TFTP Options") contains
    a summary of the three TFTP options currently defined.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 73-1. TFTP Options
  prefs: []
  type: TYPE_NORMAL
- en: '| TFTP Option Name | TFTP Option Code (Used in Request Messages) | Defining
    RFC | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Block Size | blksize | 2348 | Allows the client and server to send data blocks
    of a size other than 512 bytes to improve efficiency or address limitations of
    a particular type of network. |'
  prefs: []
  type: TYPE_TB
- en: '| Timeout Interval | interval | 2349 | Permits the client and server to agree
    on a specified number of seconds to use for their retransmission timers. Again,
    may be of value on certain networks with high latency or other special requirements.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Transfer Size | tsize | 2349 | Lets the device sending the file (client on
    a write, server on a read) tell the other device the size of the file before the
    transfer commences. This allows the receiving device to allocate space for it
    in advance. |'
  prefs: []
  type: TYPE_TB
- en: TFTP Message Formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike FTP, all communication in TFTP is accomplished in the form of discrete
    messages that follow a particular message format. The reason why TFTP and FTP
    are so different in this regard is because of the different transport protocols
    they use. FTP uses TCP, which allows data to be streamed a byte at a time; FTP
    also makes use of a dedicated channel for commands. TFTP runs on UDP, which uses
    a conventional header/data formatting scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original TFTP standard defines five different types of messages: read request
    (RRQ), write request (WRQ), data (DATA), acknowledgment (ACK), and error (ERROR).
    The TFTP option extension feature defines a sixth message: option acknowledgment
    (OACK). Of these six messages, the first two share the same message format. The
    only common field in every TFTP message is the operation code (Opcode), which
    tells the recipient of the message what type it is.'
  prefs: []
  type: TYPE_NORMAL
- en: TFTP's message formats are different than those used for certain other protocols,
    because many of the fields in TFTP are variable in length. Usually, variable-length
    fields in messages are expressed using a preceding length field that specifies
    the length of the variable-sized field. Instead, TFTP sends such fields as strings
    of ASCII characters using netascii, the Telnet version of ASCII. The end of the
    string is marked by a zero byte. The exception to this is the data field in data
    messages, the content of which depends on the transfer mode.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the chapter contains the details on each of the TFTP messages.
  prefs: []
  type: TYPE_NORMAL
- en: Read Request and Write Request Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These messages use a common message format, described in [Table 73-2](ch73s05.html#tftp_rrqwrq_message_format
    "Table 73-2. TFTP RRQ/WRQ Message Format") and shown graphically in [Figure 73-4](ch73s05.html#tftp_rrqwrq_message_format-id001
    "Figure 73-4. TFTP RRQ/WRQ message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 73-2. TFTP RRQ/WRQ Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Opcode | 2 | Operation Code: Specifies the TFTP message type. A value of
    1 indicates a RRQ message, while a value of 2 is a WRQ message. |'
  prefs: []
  type: TYPE_TB
- en: '| Filename | Variable | The name of the file to be read or written. |'
  prefs: []
  type: TYPE_TB
- en: '| Mode | Variable | Transfer Mode: The string netascii or octet, zero-terminated.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Options | Variable | When the client supports TFTP options, it will encode
    them in sequence following the Mode field. Each option consists of two variable-length
    subfields. The optN subfield is the option code for option N, containing a string
    specifying the name of the option; currently, blksize, interval, and tsize are
    supported. The valueN subfield is the option value for option N, containing the
    value the client is requesting for this option. (Note that this is a zero-terminated
    string just like other TFTP variable-length fields, even for a numeric value.)
    |'
  prefs: []
  type: TYPE_TB
- en: '![TFTP RRQ/WRQ message format](httpatomoreillycomsourcenostarchimages288277.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 73-4. TFTP RRQ/WRQ message format
  prefs: []
  type: TYPE_NORMAL
- en: Data Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data blocks are sent using the simplified format shown in [Table 73-3](ch73s05.html#tftp_data_message_format
    "Table 73-3. TFTP Data Message Format") and [Figure 73-5](ch73s05.html#tftp_data_message_format-id001
    "Figure 73-5. TFTP data message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 73-3. TFTP Data Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Opcode | 2 | Operation Code: Specifies the TFTP message type. A value of
    3 indicates a data message. |'
  prefs: []
  type: TYPE_TB
- en: '| Block # | 2 | Block Number: The number of the data block being sent. |'
  prefs: []
  type: TYPE_TB
- en: '| Data | Variable | Data: 0 to 512 bytes of data. |'
  prefs: []
  type: TYPE_TB
- en: '![TFTP data message format](httpatomoreillycomsourcenostarchimages288279.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 73-5. TFTP data message format
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgment Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Acknowledgments have the simplest format of any TFTP message, as you can see
    in [Table 73-4](ch73s05.html#tftp_acknowledgment_message_format "Table 73-4. TFTP
    Acknowledgment Message Format") and [Figure 73-6](ch73s05.html#tftp_acknowledgment_message_format-id001
    "Figure 73-6. TFTP acknowledgment message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 73-4. TFTP Acknowledgment Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Opcode | 2 | Operation Code: Specifies the TFTP message type. A value of
    4 indicates an ACK message. |'
  prefs: []
  type: TYPE_TB
- en: '| Block # | 2 | Block Number: The number of the data block being acknowledged;
    a value of 0 is used to acknowledge receipt of a write request without options
    or to acknowledge receipt of an OACK. |'
  prefs: []
  type: TYPE_TB
- en: '![TFTP acknowledgment message format](httpatomoreillycomsourcenostarchimages288281.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 73-6. TFTP acknowledgment message format
  prefs: []
  type: TYPE_NORMAL
- en: Error Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Error messages can be sent by either the client or server in cases where a problem
    is detected in the communication. They have the format indicated in [Table 73-5](ch73s05.html#tftp_error_message_format-id001
    "Table 73-5. TFTP Error Message Format") and [Figure 73-7](ch73s05.html#tftp_error_message_format
    "Figure 73-7. TFTP error message format").
  prefs: []
  type: TYPE_NORMAL
- en: '![TFTP error message format](httpatomoreillycomsourcenostarchimages288283.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 73-7. TFTP error message format
  prefs: []
  type: TYPE_NORMAL
- en: Table 73-5. TFTP Error Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Opcode | 2 | Operation Code: Specifies the TFTP message type. A value of
    5 indicates an error message. |'
  prefs: []
  type: TYPE_TB
- en: '| Error Code | 2 | A numeric code indicating the type of message being communicated.
    Values 0 to 7 are defined by the TFTP standard, while value 8 was added by the
    TFTP option extension:0 = Not defined; see error message field for details1 =
    File not found2 = Access violation3 = Disk full or allocation exceeded4 = Illegal
    TFTP operation5 = Unknown transfer ID6 = File already exists7 = No such user8
    = Client transfer termination due to unacceptable option negotiation |'
  prefs: []
  type: TYPE_TB
- en: '| Error Msg | Variable | Error Message: A descriptive text error message string,
    intended for "human consumption," as the standard puts it. |'
  prefs: []
  type: TYPE_TB
- en: Option Acknowledgment Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OACK messages are used to acknowledge receipt of TFTP options. They are structured
    as shown in [Table 73-6](ch73s05.html#tftp_oack_message_format "Table 73-6. TFTP
    OACK Message Format") and [Figure 73-8](ch73s05.html#tftp_oack_message_format-id001
    "Figure 73-8. TFTP OACK message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 73-6. TFTP OACK Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Opcode | 2 | Operation Code: Specifies the TFTP message type. A value of
    6 indicates an OACK message. |'
  prefs: []
  type: TYPE_TB
- en: '| Options | Variable | A list of options being acknowledged by the server.
    Each option consists of two variable-length subfields. The optN subfield is the
    option code for option N, containing a string specifying the name of the option,
    copied from the RRQ or WRQ message. The valueN subfield is the option value for
    option N, containing the acknowledged value for the option, which may be the value
    that the client specified or an alternative value, depending on the type of option.
    |'
  prefs: []
  type: TYPE_TB
- en: '![TFTP OACK message format](httpatomoreillycomsourcenostarchimages288285.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 73-8. TFTP OACK message format
  prefs: []
  type: TYPE_NORMAL
