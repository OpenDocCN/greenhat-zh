<html><head></head><body><div class="part" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_shape_of_code"/>Part III. THE SHAPE OF CODE</h1></div></div></div><div class="partintro" xml:lang="en"><div/><p>Unlike a fine wine, your code is not likely to get any better the longer you leave it. If it starts like a small pile of something that the dog produced, then it will no doubt end up like a large pile of something an elephant produced.</p><p>This is no secret, yet software factories continually churn out elephantine creations and then suffer the consequences. Their products are neither adaptable, extensible, or malleable enough to suit their future requirements, nor easy enough to develop: They fail to deliver on time and to budget. As programmers, this hurts our pride—but it hurts managers' wallets, hard.</p><p>The answer? One solution is to never attempt code development in the first place, but that's hardly practical. The other is to develop code with a view to the entire system's structure. Good code doesn't happen by accident; it is the product of careful crafting, with much emphasis placed on prior planning and design. But it also stems from a nimble development approach, from being agile enough to cope with the inevitable problems and changes that you'll encounter en route.</p><p>This section explores this process. We'll look at:</p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch13.html" title="Chapter 13. GRAND DESIGNS">Chapter 13</a></span></dt><dd><p>Code micro design: low-level construction tips for individual code modules.</p></dd><dt><span class="term"><a class="xref" href="ch14.html" title="Chapter 14. SOFTWARE ARCHITECTURE">Chapter 14</a></span></dt><dd><p>Larger-scale system design—the first construction stage of any software development.</p></dd><dt><span class="term"><a class="xref" href="ch15.html" title="Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?">Chapter 15</a></span></dt><dd><p>A look at how software grows and expands over time, with some practical suggestions for grafting new work into an old codebase.</p></dd></dl></div><p>These are not optional extras or nice-to-haves. They are essential stages of our craft and are therefore crucial to the production of quality software. Ignore this stuff at your peril.</p></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="grand_designs"/>Chapter 13. GRAND DESIGNS</h1></div><div><h3 class="subtitle"><i>How to Produce Good Software Designs</i></h3></div></div></div><div class="epigraph"><p>A camel is a horse designed by committee.</p><div class="attribution"><span>--<span class="attribution">Sir Alec Issigonis</span></span></div></div><p>Some code just makes you sigh.</p><p>I once had to write a device driver for an embedded product. The driver's interface to the OS was quite complex. The interface to the hardware I was using was also complex. To keep myself sane, I split the code into two sections. The first was an internal library that accessed the hardware, performed some data buffering, and provided a simple API to access that buffered data. Then I wrote a second, distinct layer that implemented the finicky OS driver interface in terms of this internal library. The structure of the device driver looked like <a class="xref" href="ch13.html#petes_sane_software_design" title="Figure 13-1. Pete's sane software design">Figure 13-1</a>.</p><p>Later, the manufacturer of the hardware sent me a sample implementation of the same device driver. The author of this code had clearly not thought it out at all. The code was a sprawling mess, tightly intermingling the complex OS interface with the hardware logic in a completely incomprehensible manner. An approximation of its structure is shown in <a class="xref" href="ch13.html#how_not_to_design_software" title="Figure 13-2. How not to design software">Figure 13-2</a>.</p><div class="figure"><a id="petes_sane_software_design"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e18163"/><img alt="Pete's sane software design" src="tagoreillycom20080909nostarchimages207482.png"/></div></div><p class="title"><b>Figure 13-1. Pete's sane software design</b></p></div><br class="figure-break"/><div class="figure"><a id="how_not_to_design_software"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e18171"/><img alt="How not to design software" src="tagoreillycom20080909nostarchimages207484.png"/></div></div><p class="title"><b>Figure 13-2. How not to design software</b></p></div><br class="figure-break"/><p>Now, I'm not trying to toot my own horn (any more than is necessary, anyway). The point of this illustration is clear. The first design is better. It is easier to understand because it's so straightforward, it is easier to implement, and consequently it is easier to maintain.</p><p>C.A.R. Hoare wrote, "There are two ways of constructing a software design: One way is to make it so simple that there are <span class="emphasis"><em>obviously</em></span> no deficiencies, and the other way is to make it so complicated that there are no <span class="emphasis"><em>obvious</em></span> deficiencies. The first method is far more difficult." (Hoare 81)</p><p>One of the signs of a mature programmer is the design quality of his or her code. In this chapter, we'll look at what constitutes a good design and investigate how to craft high-quality software designs.</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="programming_as_design"/>Programming as Design</h1></div></div></div><p>It's a popular belief that "design" is a stage you complete before moving on to writing code. Its product is some form of <span class="emphasis"><em>design specification</em></span>, which is sufficient for a generic code monkey to implement.<a class="indexterm" id="IDX-CHP-13-0976"/><a class="indexterm" id="IDX-CHP-13-0977"/><a class="indexterm" id="IDX-CHP-13-0975"/></p><p>The truth is very different. Programming—the act of writing code—is a <span class="emphasis"><em>design activity</em></span>.</p><p>Even the most detailed specification has holes, or else it would <span class="emphasis"><em>be</em></span> the code—you can't describe every minuscule detail in a design document. The act of programming verifies the initial design decisions and performs the remaining design work. It exposes holes, inconsistencies, and errors and allows you to find a route around them. "Some programmers don't think they're doing design when they program, but whenever you write code, you're always doing design, either explicitly or implicitly." (Page Jones 96)</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Programming is a design activity. It's a creative and artistic act, not mechanical code generation</em></span>.</p></dd></dl></div><p>A good development process recognizes this and doesn't shy away from writing code when it's appropriate. Practitioners of Extreme Programming advocate that design <span class="emphasis"><em>is</em></span> the code. (Beck 99) There is no separate design activity; there is no team of designers. It's the programmers who constantly refine and extend the design by refining and extending the code. This is enshrined in their <span class="emphasis"><em>test-driven design</em></span> approach: Code tests are written before any code, as a design verification tool. This is a wise idea.</p><p>Does this mean that you don't need to think before starting to hack at code? Not at all! Deep inside a text editor is not the place to plan what you're writing. That's like trying to drive from Berlin to Rome without deciding a route first. You'll end up in Moscow before you've worked out which way is north. By definition, design is something you do <span class="emphasis"><em>first</em></span>.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Think before you type; establish a coherent design. Otherwise you'll end up with chaotic code</em></span>.</p></dd></dl></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_do_we_design_question"/>What Do We Design?</h1></div></div></div><p>Programmers design code structures, obviously. But this means different things at different stages of the development process. At each stage, design is a process of decomposing the task into its constituent parts and figuring out how each part works.<a class="indexterm" id="IDX-CHP-13-0978"/><a class="indexterm" id="IDX-CHP-13-0979"/><a class="indexterm" id="IDX-CHP-13-0980"/><a class="indexterm" id="IDX-CHP-13-0981"/><a class="indexterm" id="IDX-CHP-13-0982"/></p><p>These levels of software design are:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>The system architecture</strong></span></span></dt><dd><p>Here we look at the system as a whole, identify the main subsystems, and work out how they communicate. The architectural design has the most influence on the performance and characteristics of the system <span class="emphasis"><em>as a whole</em></span> and the least impact on specific lines of code. It is the most important design act and is covered in the next chapter. In this chapter, we're concerned with the internal design of code, which involves the subsequent design levels.<a class="indexterm" id="IDX-CHP-13-0984"/><a class="indexterm" id="IDX-CHP-13-0983"/><a class="indexterm" id="IDX-CHP-13-0974"/></p></dd><dt><span class="term"><span class="strong"><strong>Modules/components</strong></span></span></dt><dd><p>The architectural subsystems are usually too large to directly implement in code, so the next step is to break each one down into comprehensible modules. It's very easy to be vague about design at the module level. In some ways, a "module" does not really exist. <span class="emphasis"><em>Module</em></span> may mean something different depending on the design approach; it might be a logical clump of code, perhaps some physical unit like a Java package, C++/C# namespace, or a reusable library. It might be a class hierarchy or maybe even a free-standing executable.</p><p>This design stage often produces published interfaces. These can't be easily changed later on, since they form strict contracts between code modules and between the teams of programmers writing them.</p></dd><dt><span class="term"><span class="strong"><strong>Classes and data types</strong></span></span></dt><dd><p>Next, we break a module into bite-sized chunks. Interface design tends to be less formal and easier to change behind the module. The tendency is to do this micro design at the keyboard. This urge should be resisted, or else you'll write the first code that comes into your head, not the best code for the problem.<a class="indexterm" id="IDX-CHP-13-0985"/></p></dd><dt><span class="term"><span class="strong"><strong>Functions</strong></span></span></dt><dd><p>This may be the lowest design level in the food chain, but it's of no less importance. A program is built from routines: If the routines are poorly designed, then the entire system will suffer. After having established exactly which functions are required, we design how they work internally, how the flow of control is routed, and which algorithms are used.<sup>[<a class="footnote" href="#ftn.CHP-13-FN-1" id="CHP-13-FN-1">1</a>]</sup> This is usually a mental exercise rather than a documented procedure, but a diligent design is essential.</p></dd></dl></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-13-FN-1" id="ftn.CHP-13-FN-1">1</a>] </sup>Key algorithms will often span multiple functions; they'll be determined at the module design stage.<a class="indexterm" id="IDX-CHP-13-0986"/><a class="indexterm" id="IDX-CHP-13-0987"/><a class="indexterm" id="IDX-CHP-13-0988"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="whats_all_the_fuss_about_question"/>What's All the Fuss About?</h1></div></div></div><p>You won't find anyone arguing <span class="emphasis"><em>for</em></span> bad design, but nonetheless, there's a lot of badly designed code out there. After a few years on the front line, any developer has the scars to prove it. (Battle-hardened veterans are already nodding their heads and mentally rehearsing their war stories.) But why is this the case?<a class="indexterm" id="IDX-CHP-13-0989"/></p><p>Sloppy design can be the product of inexperienced programmers, but more often it is caused by the commercial pressures of the software factory squeezing out any time that might have been spent on good design. No one listens to the poor, protesting coders. Programming in the Real World is necessarily bound by the drive to ship software—any software—on time. The irony is that in almost every case, a lack of a good design ultimately costs more than doing it properly would have. As they say, "There's never time to do it right, but there's always time to do it twice."</p><p>Getting design right is really <span class="emphasis"><em>very</em></span> important. The design of your code is the foundation upon which it is built. If it's wrong, then the code will be unstable, unsafe, and not fit for purpose—dangerous. A bad design foundation leads to the software equivalent of the Leaning Tower of Pisa. While novel that it manages to stand up under the strain of real use, it will never be as good as it ought to be, and in time this inevitably shows.</p><p>A sound design makes code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Easier to write (there's a well-defined plan of attack, and it's clear how it's all going to fit together)</p></li><li class="listitem"><p>Easier to understand</p></li><li class="listitem"><p>Easier to fix (you can identify the location of problems)</p></li><li class="listitem"><p>Less likely to harbor bugs (program errors are not hidden behind mystifying design problems)</p></li><li class="listitem"><p>More resilient to change (the design will encourage extensions and accommodate modification)</p></li></ul></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="good_software_design"/>Good Software Design</h1></div></div></div><p>For any programming problem, there will be <span class="emphasis"><em>many</em></span> potential code designs. Your job is to find one. The best one. Or at least a sufficiently good one. It's not an easy task. . . .<a class="indexterm" id="IDX-CHP-13-0990"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>How do you know that your design will work? After completing a bulletproof plan of attack, you confidently begin implementing it. Later, an unexpected problem will show its ugly head. Back to the drawing board.</p></li><li class="listitem"><p>How do you know when your design is finished? You can't know until you've actually implemented it and found that it works. Many issues can't be fore-guessed; you have to step out, implement the design, and see whether or not it's complete. It's only by attempting a solution that you even <span class="emphasis"><em>begin</em></span> to understand the original problem. Armed with this new knowledge, you can then try to solve it again properly.</p></li><li class="listitem"><p>How do you know it's the <span class="emphasis"><em>best</em></span> design solution for the problem? You can't tell unless you try out every possibility. This isn't practical. Instead, how do you know it's good <span class="emphasis"><em>enough</em></span>? If performance is a requirement, you won't really know until the system <span class="emphasis"><em>is</em></span> performing.</p></li></ul></div><p>The best design approaches address these problems. They are:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Iterative</strong></span></span></dt><dd><p>Avoid too many nasty surprises by doing a small amount of design, implementing it, assessing the implications, and feeding this into to the next design round. This incremental construction approach is very powerful.</p></dd><dt><span class="term"><span class="strong"><strong>Cautious</strong></span></span></dt><dd><p>Don't try to design too much at once. If something fails, it might be because of any number of design decisions. Limit the room for failure, and you'll find it easier to progress. Small, sure design steps are more likely to succeed than large, clumsy ones.</p></dd><dt><span class="term"><span class="strong"><strong>Realistic</strong></span></span></dt><dd><p>A prescriptive design process will not work all of the time, every time. The outcome depends on the quality of the requirements established, the experience of the team, and the rigor with which the process is applied. A pragmatic approach takes the best of all methodologies and admits that it relies on the programmers' gut feeling—experience has a lot to do with shaping good design.<a class="indexterm" id="IDX-CHP-13-0991"/></p></dd><dt><span class="term"><span class="strong"><strong>Informed</strong></span></span></dt><dd><p>You must fully understand all requirements and motivating principles to be clear about the problem you're solving, and also about the important qualities of the right solution. If you don't, you'll solve the wrong problem. You need this information to get early design decisions right, and some are hard to reverse.</p></dd></dl></div><p>Your design approach is inevitably affected by the overall development methodology in use (see "<a class="xref" href="ch22.html#programming_styles" title="Programming Styles">Programming Styles</a>" on page 420 for a description of these). A good design <span class="emphasis"><em>process</em></span> is a step towards creating a good design, but no guarantee. It still comes down to the quality of the design <span class="emphasis"><em>decisions</em></span> you make. Different trade-offs lead to different designs. A design for speed will differ from design for extensibility, for example. Ultimately, there is no <span class="emphasis"><em>right</em></span> or <span class="emphasis"><em>wrong</em></span> design. At best, there are <span class="emphasis"><em>good</em></span> designs and <span class="emphasis"><em>bad</em></span> designs.<a class="indexterm" id="IDX-CHP-13-0992"/></p><p>Good designs have a number of attractive characteristics, whose opposites are sure indicators of bad design. We'll discuss these next.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="simplicity-id1"/>Simplicity</h2></div></div></div><p>This is the single most important characteristic of well-designed code. A simple design is easy to understand, has no unnecessary warts or blemishes, and is easy to implement. It is coherent and consistent.<a class="indexterm" id="IDX-CHP-13-0993"/></p><p>Simple code is as small as possible but no smaller. This takes some doing, as the mathematician Blaise Pascal appreciated: "I am sorry for the length of my letter, but I had not the time to write a short one." Carefully work out how <span class="emphasis"><em>little</em></span> code is needed, and then write just that. Remember, you can always add more code later for extra functionality, but you can rarely remove something that has become intimately entwined.<a class="indexterm" id="IDX-CHP-13-0994"/></p><div class="sidebar"><a id="making_a_trade"/><p class="title"><b>MAKING A TRADE</b></p><p>Software design is a process of making decisions—of decomposing the system into its constituent parts, but also balancing the contending forces that pull in different directions. There are trade-offs to be made that shape the final design.</p><p>These are common examples of such tightropes and games of tug-of-war:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Extensibility vs. simplicity</strong></span></span></dt><dd><p>A design for extensibility provides plenty of interface points for future code to be plugged into and ensures the scaffolding is sufficiently general to support any later requirements. Simplicity avoids the complication of extra levels of indirection and needless generality.</p></dd><dt><span class="term"><span class="strong"><strong>Efficiency vs. safety</strong></span></span></dt><dd><p>Gains in performance often come by sacrificing purity of design—putting in special back doors for certain important operations or adding lots of coupling to prevent too much indirect access. Highly optimized systems are generally less clear and more brittle in the face of change.<a class="indexterm" id="IDX-CHP-13-0995"/></p><p>Not all efficient designs are bad, though; many good designs naturally perform well <span class="emphasis"><em>because</em></span> of their simplicity.</p></dd><dt><span class="term"><span class="strong"><strong>Features vs. development effort</strong></span></span></dt><dd><p>At project initiation, there are a thousand desired features and a reasonable idea of when they should be delivered by (tomorrow, if not sooner). Without an infinite number of monkeys and their infinite number of PCs, you'll never get it all done.</p><p>More features take more time to implement.</p></dd></dl></div><p>Which of these characteristics is most important depends on the project requirements. That's why it's so important to be clear about them up front.</p></div><p>Laziness <span class="emphasis"><em>can</em></span> pay off. Work your design so you can defer as much work as possible, and only concentrate on the immediate problems.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p>Less is more. <span class="emphasis"><em>Strive for simple code that does a lot with a little</em></span>.</p></dd></dl></div><p>A simple design is not necessarily easy to create. It takes time. For all but the most basic programs, a great deal of information must be sifted through to reach a final solution. Well-designed code <span class="emphasis"><em>looks</em></span> obvious, but it probably took an awful lot of thought (and a lot of refactoring) to make it that simple.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>It's a complicated job to make something simple. If a code structure looks obvious, don't assume that it was easy to design</em></span>.</p></dd></dl></div><p>There are many ways to make a design unnecessarily complex, including incorrect component decomposition, the thoughtless proliferation of threads, inappropriate choice of algorithms, complex naming schemes, and excessive or inappropriate module dependencies.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="elegance"/>Elegance</h2></div></div></div><p>Elegance embodies the aesthetic aspects of design and often goes hand in hand with simplicity. It means that your code isn't baroque, confusingly clever, or overly complex. Well-designed code has a beauty in its structure. These are desirable characteristics:<a class="indexterm" id="IDX-CHP-13-0996"/><a class="indexterm" id="IDX-CHP-13-0997"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Control flowing gracefully around the system. A single operation doesn't pass through every module, converting the format of its parameter between 16 different representations, before finally ignoring it.</p></li><li class="listitem"><p>Each part complements the others, adding something distinct and valuable.</p></li><li class="listitem"><p>The design is not riddled with special cases.</p></li><li class="listitem"><p>It associates similar things.</p></li><li class="listitem"><p>No nasty surprises lurk around the corner.</p></li><li class="listitem"><p>There is a small locality of change: A single, simple change in one place doesn't lead to modifications of the code in many other places.</p></li></ul></div><p>Good design has a lot to do with balance and aesthetics. I won't go so far as to say programming is art, although some could argue a convincing case for this. Elegance and simplicity underpin most of the remaining characteristics in this list.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="modularity"/>Modularity</h2></div></div></div><p>As we attack a design problem, we naturally divide it into parts called <span class="emphasis"><em>modules</em></span> or <span class="emphasis"><em>components</em></span>. We decompose into subsystems, libraries, packages, classes, and so on. Each part is less complex than the original problem, but put together, they form a complete solution. The quality of this decomposition is paramount.<a class="indexterm" id="IDX-CHP-13-0998"/><a class="indexterm" id="IDX-CHP-13-0999"/></p><p>Key qualities of modularity are <span class="emphasis"><em>cohesion</em></span> and <span class="emphasis"><em>coupling</em></span>. We aim for modules with:<a class="indexterm" id="IDX-CHP-13-1000"/><a class="indexterm" id="IDX-CHP-13-1001"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Strong cohesion</strong></span></span></dt><dd><p><span class="emphasis"><em>Cohesion</em></span> is a measure of how related functionality is gathered together and how well the parts <span class="emphasis"><em>inside</em></span> a module work as a whole. Cohesion is the glue holding a module together.</p><p>Weakly cohesive modules are a sign of bad decomposition. Each module must have a clearly defined role and not be a grab bag of unrelated functionality (like the pitifully common <code class="literal">utils</code> namespace—why <span class="emphasis"><em>do</em></span> people write these things?).</p></dd><dt><span class="term"><span class="strong"><strong>Low coupling</strong></span></span></dt><dd><p><span class="emphasis"><em>Coupling</em></span> is a measure of the interdependency <span class="emphasis"><em>between</em></span> modules—the amount of wiring to and from them. In the simplest designs, modules have little coupling and so are less reliant on one another. Obviously, modules can't be totally decoupled, or they wouldn't be working together at all!</p><p>Modules interconnect in many ways—some direct, some indirect. A module can call functions on other modules or be called by other modules. It may use another module's data types or share some data (perhaps variables or files). Good software design limits the lines of communication to only those absolutely necessary. These communication lines are part of what determines the code design.</p></dd></dl></div><p>Once identified, each module can be worked on in isolation and tested separately. This is an advantage of modularity; it allows you to split tasks between programmers. Take care, though; Conway's Law warns that software structure may follow team structure: "If you have four teams working together to build a compiler, it will become a four-pass compiler" (see "<a class="xref" href="ch17s02.html#organization_and_code_structure" title="Organization and Code Structure">Organization and Code Structure</a>" on page 320). Make sure the decomposition is sensible and based on the problem, not the team organization.<a class="indexterm" id="IDX-CHP-13-1002"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Design modules that are internally cohesive with minimal coupling. The decomposition must represent a valid partition of the problem space</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="good_interfaces"/>Good Interfaces</h2></div></div></div><p>Modules help us separate concerns and partition the problem. Each module defines an <span class="emphasis"><em>interface</em></span>, the public façade behind which it hides an internal implementation. This set of available operations is often called an <span class="emphasis"><em>application programming interface (API)</em></span>. It is the sole route to a module's functionality, and its quality determines the quality of that module, at least as seen from the outside.<a class="indexterm" id="IDX-CHP-13-1009"/><a class="indexterm" id="IDX-CHP-13-1010"/><a class="indexterm" id="IDX-CHP-13-1003"/><a class="indexterm" id="IDX-CHP-13-1004"/><a class="indexterm" id="IDX-CHP-13-1005"/><a class="indexterm" id="IDX-CHP-13-1006"/><a class="indexterm" id="IDX-CHP-13-1007"/><a class="indexterm" id="IDX-CHP-13-1008"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Draw lines in the sand that people don't need to cross: Identify clear APIs and interfaces</em></span>.<a class="indexterm" id="IDX-CHP-13-1011"/><a class="indexterm" id="IDX-CHP-13-1012"/></p></dd></dl></div><p>To create a good interface, follow these steps.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Identify the client and what it <span class="emphasis"><em>wants</em></span> to do.</p></li><li class="listitem"><p>Identify the supplier and what it's <span class="emphasis"><em>able</em></span> to do.<a class="indexterm" id="IDX-CHP-13-1013"/></p><p>You can only successfully separate the user and implementer with an interface if both parties have been correctly identified and their individual needs are understood. Once you're clear about this, you stand a chance of creating an interface that will satisfy its users and is actually implementable.</p><p>Bad design puts operations in the wrong place, making it a nightmare to follow the application logic and difficult to extend the design. It leads to increased module coupling and reduced cohesion.</p></li><li class="listitem"><p>Infer the type of interface required.</p><p>Is it a function, a class, a network protocol, or something else? This is probably dictated by who supplies the functionality, but an interface may also be wrapped up to present it in different ways. For example, wrapping a CORBA object around a library publishes its functionality to a network of collaborating computers.</p></li><li class="listitem"><p>Determine the nature of operation.</p><p>What functionality <span class="emphasis"><em>really</em></span> needs to be provided—is it more general than this client's specific requirement? Inside every function, there is often a more useful operation waiting to get out.</p></li></ol></div><p>There are a few key principles that help us to reason about the nature and quality of our interfaces. As illustrated in <a class="xref" href="ch13s04.html#the_interfaces_provided_by_a_house" title="Figure 13-3. The interfaces provided by a house">Figure 13-3</a>, these are:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Partitioning</strong></span></span></dt><dd><p>An interface forms a point of contact, but also a line of separation between client and implementer. They can only communicate in the defined manner, not in any other ad hoc way.</p><p>Well-designed code clearly defines <span class="emphasis"><em>roles and responsibilities</em></span>. Knowing who the main actors are in a system and what they are all supposed to do ensures that interfaces are crisp and effective.<a class="indexterm" id="IDX-CHP-13-1014"/></p><p>A good example is my house: Its main interface is the front door. The door partitions occupants from visitors and determines where they meet. There are a number of other interfaces for other operations: windows, telephones, the chimney, and so on.</p></dd><dt><span class="term"><span class="strong"><strong>Abstraction</strong></span></span></dt><dd><p>An abstraction allows the viewer to concentrate on important decisions, selectively ignoring certain details. It neatly organizes reality behind a simpler representation, helping us to cope with complexity. It's a particularly important concept in OO design. When designing an interface, you create an abstraction by carefully choosing exactly what is important for the user and what can be usefully hidden from them.<a class="indexterm" id="IDX-CHP-13-1015"/></p><p>Given a bowl of fruit, you can happily say, "<span class="emphasis"><em>Eat</em></span> the item on top," and then "<span class="emphasis"><em>Eat</em></span> the next one," without worrying exactly what that entails; a grapefruit needs to be peeled, while rhubarb needs to be boiled and smothered in sugar. These details are hidden behind the abstraction <span class="emphasis"><em>eat</em></span>; you only care that the fruit <span class="emphasis"><em>was</em></span> eaten, not how.<sup>[<a class="footnote" href="#ftn.CHP-13-FN-2" id="CHP-13-FN-2">2</a>]</sup></p><div class="figure"><a id="the_interfaces_provided_by_a_house"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e18842"/><img alt="The interfaces provided by a house" src="tagoreillycom20080909nostarchimages207486.png.jpg"/></div></div><p class="title"><b>Figure 13-3. The interfaces provided by a house</b></p></div><br class="figure-break"/><p>Abstractions can form a hierarchy. You can view my house at different <span class="emphasis"><em>levels of abstraction</em></span>, depending on whether you're a builder, a particle physicist, or a bank manager. It can be considered:<a class="indexterm" id="IDX-CHP-13-1017"/><a class="indexterm" id="IDX-CHP-13-1018"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A collection of rooms</p></li><li class="listitem"><p>An arrangement of walls, floors, and ceilings</p></li><li class="listitem"><p>A construction of bricks and timber</p></li><li class="listitem"><p>A collection of molecules, or even atoms</p></li><li class="listitem"><p>A mortgage that needs to be paid</p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Compression</strong></span></span></dt><dd><p>This is the ability of an interface to represent a large operation with something simpler. Compression is often the result of making good abstractions, but bad abstractions can lead to more verbose code.</p></dd><dt><span class="term"><span class="strong"><strong>Substitutability</strong></span></span></dt><dd><p>You can substitute one implementation of an interface with another, if it meets the same contract. If you define a sort interface in your program, then any algorithm can sit behind it: It could be a quicksort, a heapsort, or (heaven forbid) a bubblesort. You can change it at any point, as long as the visible behavior through the interface is the same.<a class="indexterm" id="IDX-CHP-13-1019"/></p><p>In class inheritance hierarchies, any object can be substituted for its supertype.<a class="indexterm" id="IDX-CHP-13-1020"/></p></dd></dl></div><p>If you want me to open my front door, you'll ring the doorbell. It used to be a wired switch that ran to the bell mechanism, but I've just invested in a new-fangled wireless doorbell. This doesn't affect you at all, in fact you won't even know I've changed it; you push a button, and I appear.</p><div class="sidebar"><a id="about_face"/><p class="title"><b>ABOUT FACE</b></p><p>Most of computer science is built around defining interfaces and organizing complexity around them. The infamous maxim is, "Any problem can be solved by adding an extra level of indirection"—that is, hiding new complexity behind another interface.<a class="indexterm" id="IDX-CHP-13-1021"/></p><p>There are many types of interfaces. They all present some <span class="emphasis"><em>public</em></span> face to their clients and hide the gory implementation details behind this façade.</p><p>Common forms of interfaces that you'll create are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Libraries</p></li><li class="listitem"><p>Classes</p></li><li class="listitem"><p>Functions</p></li><li class="listitem"><p>Data structures (particularly more exotic ones with additional behavior, like semaphores)</p></li><li class="listitem"><p>OS interfaces</p></li><li class="listitem"><p>Protocols (network communications, for example)</p></li></ul></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="extensibility"/>Extensibility</h2></div></div></div><p>Well-designed code allows extra functionality to be slotted in at appropriate places, when necessary. The danger is that this may lead to over-engineered code, trying to cope with any potential future modification.<a class="indexterm" id="IDX-CHP-13-1022"/><a class="indexterm" id="IDX-CHP-13-1023"/><a class="indexterm" id="IDX-CHP-13-1024"/></p><p>Extensibility can be accommodated through software scaffolding: dynamically loaded plug-ins, carefully chosen class hierarchies with abstract interfaces at the top, the provision of useful callback functions, and even a fundamentally logical and malleable code structure.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Design for extensibility, but don't be hopelessly general—you'll end up writing an OS, not a program</em></span>.</p></dd></dl></div><p>A good designer thinks carefully about how his or her software will be extended. Randomly sprinkling code with hooks for extensibility may actually degrade quality. You should balance the functionality needed now, what will definitely need to be added later, and what might be needed to determine how extensible the design should be.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="avoid_duplication"/>Avoid Duplication</h2></div></div></div><p>Well-designed code contains no duplication; it never has to repeat itself. Duplication is the enemy of elegant and simple design. Unnecessary redundant code leads to a brittle program: Given two similar pieces of code that differ only in minor details, you may find and fix a bug in one and then forget to fix the same bug in the other. This clearly compromises code safety.<a class="indexterm" id="IDX-CHP-13-1025"/></p><p>Most duplication comes through <span class="emphasis"><em>cut-and-paste programming</em></span>—copying code in the editor. It can arise more subtly through the reinvention of wheels by programmers who don't understand the whole system.<a class="indexterm" id="IDX-CHP-13-1026"/><a class="indexterm" id="IDX-CHP-13-1027"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If you see strikingly similar things being done by separate sections of code, generalize it in a function with appropriate parameters. There's now a single place to fix any faults. This has the benefit of making the code's intent clearer with a descriptive function name.</p></li><li class="listitem"><p>Classes that are strikingly similar indicate that some functionality could be pushed up to a superclass or that there's a missing interface to describe the common behavior.</p></li></ul></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Do it once. Do it well. Avoid duplication</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="portability"/>Portability</h2></div></div></div><p>A good design is not <span class="emphasis"><em>necessarily</em></span> portable; it depends on the code's requirements. A lot <span class="emphasis"><em>can</em></span> be done to prevent platform dependence, but compromising code for unnecessary portability is bad design. A good design is <span class="emphasis"><em>appropriately</em></span> portable and manages portability concerns when they are an issue.<a class="indexterm" id="IDX-CHP-13-1028"/><a class="indexterm" id="IDX-CHP-13-1029"/><a class="indexterm" id="IDX-CHP-13-1030"/><a class="indexterm" id="IDX-CHP-13-1031"/></p><p>The story is familiar: Your code was never intended to run in any other environment, so it wasn't designed to cope. Later development unexpectedly required a new runtime platform; it was simpler to adapt the old program than write a new one. The code didn't lend itself to portability, and there wasn't enough time to refactor or redesign for cross-platform support. The result? A tangled mess of code, whose design has been irreparably warped, riddled with <code class="literal">#ifdef NEW_PLATFORM</code> constructions. It has not been programmed by an engineer; it has been plumbed by a philosopher.</p><p>Make careful choices about the structure of your OS-dependent or hardware-dependent sections of code. It will pay dividends in the future, and need not affect performance or clarity (sometimes it may even improve clarity). It's important to think about this as early in the design as possible; it is expensive to rework old assumptions.</p><p>The common approach is to create a platform abstraction layer (which may be a simple veneer over a few OS interface functions). You can implement this layer differently on each platform.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Manage the portability of your code in its design, rather than hacking it in as an afterthought</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="idiomatic-id1"/>Idiomatic</h2></div></div></div><p>A good design naturally employs best practices, fitting in with both the design methodology (see "<a class="xref" href="ch22.html#programming_styles" title="Programming Styles">Programming Styles</a>" on page 420) and the implementation language's idioms. This allows other programmers to immediately understand the code's structure.<a class="indexterm" id="IDX-CHP-13-1032"/></p><p>Given the implementation language (which may be fixed or may be part of the design domain) you must understand how to use it <span class="emphasis"><em>well</em></span>. C++, for example, has idioms like <span class="emphasis"><em>Resource Acquisition Is Initialization (RAII)</em></span> and operator overloading, which make a big difference to how you design code. Learn them. Understand them. Use them.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="well-documented"/>Well-Documented</h2></div></div></div><p>Last, but by no means least, a good design should be documented. Don't leave readers to infer the structure by themselves. This is particularly important at the higher levels of design. The documentation should be small because the design is so simple.<a class="indexterm" id="IDX-CHP-13-1033"/><a class="indexterm" id="IDX-CHP-13-1034"/></p><p>At one end of the spectrum, architectural designs are documented in a specification. At the other end, functions employ self-documenting code. In the middle, you'll probably use literate programming for API documentation.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-13-FN-2" id="ftn.CHP-13-FN-2">2</a>] </sup>This ability to hide multiple physical behaviors behind a single logical abstraction is known as <span class="emphasis"><em>polymorphism</em></span> and is described in "Polymorphism" on page 423 .<a class="indexterm" id="IDX-CHP-13-1016"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="how_to_design_code"/>How to Design Code</h1></div></div></div><div class="epigraph"><p>Always design a thing by considering it in its next larger context—a chair in a room, a room in a house, a house in an environment, an environment in a city plan.</p><div class="attribution"><span>--<span class="attribution">Eliel Saarinen</span></span></div></div><p>How do you learn to design well? Are good designers born or made? Can design be taught or caught? Some programmers have a natural flair for good design; it fits the way their brains work. They naturally appreciate aesthetics and can comprehend enough of a problem to make balanced judgments. Nevertheless, you <span class="emphasis"><em>can</em></span> learn to design more effectively.</p><p>When I was born, I wasn't very good at pottery. (I've never met anyone who was.) I'm still terrible now, but I took some lessons once. I understand the mechanics and can produce (almost recognizable) pots. I'd probably be much better if I practiced a little, but I'll never become a master artisan.</p><p>Similarly, no one is born able to design code: We learn. We are taught design methodologies and good engineering practice. These aim to make design a repeatable process, but they are no substitute for <span class="emphasis"><em>craftsmanship</em></span>. The creative thought process and construction of innovative designs is much harder to convey; there will always be better designers who grasp this.</p><p>Good software design is aesthetic; to create this digital art requires skill, experience, and practice. This chapter cannot attempt a paint-by-numbers description of how to design software. A shame: If I could bottle good design, I'd be a millionaire. To be a good designer, you must understand what constitutes a good design and learn to avoid the characteristics of bad design. Then practice. For a long time.</p><p>Apart from personal ability, there are design methods and tools that promise much to the programmer. We'll conclude by investigating how they can (or can't) help us.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="design_methods_and_processes"/>Design Methods and Processes</h2></div></div></div><p>There are many software design methodologies. Some emphasize a notation, others the process. A systematic approach is better than <span class="emphasis"><em>seat of your pants</em></span> design; which method you use is usually dictated by company practice and culture. I'm always wary of getting too bogged down in a <span class="emphasis"><em>particular</em></span> process—satisfying its minuscule details tends to stifle creativity.<a class="indexterm" id="IDX-CHP-13-1035"/><a class="indexterm" id="IDX-CHP-13-1036"/><a class="indexterm" id="IDX-CHP-13-1037"/><a class="indexterm" id="IDX-CHP-13-1038"/><a class="indexterm" id="IDX-CHP-13-1039"/><a class="indexterm" id="IDX-CHP-13-1040"/><a class="indexterm" id="IDX-CHP-13-1041"/></p><p>Modern design methods fall into two main families, the fundamental design philosophies upon which they are based:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Structured design</strong></span></span></dt><dd><p>This is primarily about <span class="emphasis"><em>functional decomposition</em></span>, breaking up the functionality of the system into a series of smaller operations. Routines are the main structuring devices; the design is composed of a hierarchy of routines. Structured design is characterized by the <span class="emphasis"><em>divide-and-conquer</em></span> approach, splitting a problem into successively smaller procedures until each piece can be decomposed no more.<a class="indexterm" id="IDX-CHP-13-1042"/></p><p>There are two main lines of attack: <span class="emphasis"><em>top-down</em></span> and <span class="emphasis"><em>bottom-up</em></span>.<a class="indexterm" id="IDX-CHP-13-1043"/><a class="indexterm" id="IDX-CHP-13-1044"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Not surprisingly, a top-down approach starts with the entire problem and breaks it down to smaller activities. These, in turn, are designed as self-contained units, until no more division is necessary.</p></li><li class="listitem"><p>In contrast, bottom-up design starts with the smallest units of functionality, the simple things you know the system <span class="emphasis"><em>must</em></span> do. It then stitches these functions together until it arrives at an entire solution.<a class="indexterm" id="IDX-CHP-13-1045"/></p></li></ul></div><p>In practice, these are used in tandem, and the design process ends where they meet, somewhere in the middle.</p></dd><dt><span class="term"><span class="strong"><strong>Object-oriented design</strong></span></span></dt><dd><p>Whereas structured design focuses on representing the operations a system must perform, OO design focuses on the data within that system. It models the software as an interacting set of individual units, known as <span class="emphasis"><em>objects</em></span>.<a class="indexterm" id="IDX-CHP-13-1046"/></p><p>An OO design identifies the primary objects in the problem domain and determines what their characteristics are. The behavior of these objects is established, including the operations they provide and which other objects they each relate to. The objects are weaved into a design, incorporating any implementation domain objects needed. Design is complete when all object behavior and interaction is determined.<a class="indexterm" id="IDX-CHP-13-1047"/></p><p>Object-oriented programming was hailed as the savior of the software design world, a new paradigm to usher in world peace, so much so that people are often embarrassed to not be performing OO design. But it has largely lived up to the hype, allowing software designs to manage the complexity of far bigger problems.</p></dd></dl></div><p>See "<a class="xref" href="ch22.html#programming_styles" title="Programming Styles">Programming Styles</a>" on page 420 for a more detailed description of design methods and processes.</p><div class="sidebar"><a id="design_patterns"/><p class="title"><b>DESIGN PATTERNS</b></p><p><span class="emphasis"><em>Patterns</em></span> have become a buzzword in the OO programming community over the last few years. Popularized by the book <span class="emphasis"><em>Design Patterns: Elements of Reusable Software</em></span> (Gamma et al. 94) by the authors affectionately known as the "Gang of Four" (hence it's often known as the <span class="emphasis"><em>GoF</em></span> book), design patterns are the software version of Christopher Alexander's architectural work. (Alexander 99)<a class="indexterm" id="IDX-CHP-13-1048"/><a class="indexterm" id="IDX-CHP-13-1049"/></p><p>Patterns establish a vocabulary of proven design solutions, and each pattern describes a recognizable structure of collaborating objects. These aren't clever invented designs, but recurring patterns found in <span class="emphasis"><em>real code</em></span> that have been shown to work. <span class="emphasis"><em>Pattern languages</em></span> collate a catalog of design patterns, showing how they relate to and complement one another. Each pattern in a language follows a common form, describing the <span class="emphasis"><em>context</em></span>, the <span class="emphasis"><em>problem</em></span>, and the <span class="emphasis"><em>solution</em></span>. This information allows you to apply the pattern appropriately in your designs.</p><p>Patterns crop up at several levels in a software system. Architectural patterns have a profound influence on the organization of a system. Design patterns are midlevel collaborations of software components. Language-level patterns are specific code techniques, known more commonly as language <span class="emphasis"><em>idioms</em></span>.<a class="indexterm" id="IDX-CHP-13-1050"/></p><p>The names of design patterns have entered common parlance, a testament to their usefulness. You'll hear programmers happily talking about <span class="emphasis"><em>adaptors</em></span>, <span class="emphasis"><em>observers</em></span>, <span class="emphasis"><em>factories</em></span>, and <span class="emphasis"><em>singletons</em></span>.</p><p>There is far more to design patterns than this quick description can do justice. They are a genuinely useful concept, and it's worth devoting some time to learn about them. Read the GoF book and material beyond it.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="design_tools"/>Design Tools</h2></div></div></div><p>Our designs are ultimately expressed in code, but it can often be helpful to work at a more abstract level. Tools help us to reason about a design, help us produce more effective designs, and help us to communicate those designs to other programmers—documenting what we <span class="emphasis"><em>intend</em></span> to produce and what we have <span class="emphasis"><em>already</em></span> created.<a class="indexterm" id="IDX-CHP-13-1051"/><a class="indexterm" id="IDX-CHP-13-1052"/><a class="indexterm" id="IDX-CHP-13-1053"/><a class="indexterm" id="IDX-CHP-13-1054"/><a class="indexterm" id="IDX-CHP-13-1055"/><a class="indexterm" id="IDX-CHP-13-1056"/></p><p>In a sense, methodologies are tools, but there's a broad range of other design aids that complement them.<a class="indexterm" id="IDX-CHP-13-1057"/><a class="indexterm" id="IDX-CHP-13-1058"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Notations</strong></span></span></dt><dd><p>Pretty pictures are worth their weight in words. Many graphical notations exist to help us express our designs pictorially. Most became fleetingly fashionable and then quietly slunk out of the limelight to be replaced by an even sexier way of drawing boxes and lines. The <span class="emphasis"><em>Unified Modeling Language (UML)</em></span> is currently the most popular and well-specified notation. It provides a standard way to model and document practically every artifact generated by the software development process. In fact, it has grown so comprehensive that you can use it to visualize far more than just software; it has been used to model hardware, business processes, and even organizational structures.<a class="indexterm" id="IDX-CHP-13-1059"/><a class="indexterm" id="IDX-CHP-13-1060"/><a class="indexterm" id="IDX-CHP-13-1061"/></p><p>Notations provide a medium to help you express, think about, and discuss your software design. They serve two purposes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>They allow you to scrawl quick "back of an envelope" designs and share thoughts around a whiteboard.</p></li><li class="listitem"><p>They allow you to formally document designs.</p></li></ul></div><p>To maintain your sanity in the latter case, diagram creation must be automated with a dedicated drawing tool. Otherwise, diagrams will be hard to update and will diverge from reality as you develop the code. Spend your time doing something useful, not drawing boxes and lines.</p><p>I prefer to not be bogged down by overly formal use of a notation, happily using it as a method of communicating the essential elements of a design. Knowing enough to be able to communicate is good enough for me; I don't want to get too concerned about what <span class="emphasis"><em>every</em></span> diamond and dotted line means in <span class="emphasis"><em>every</em></span> type of picture.</p></dd><dt><span class="term"><span class="strong"><strong>Design patterns</strong></span></span></dt><dd><p>A powerful design tool providing a vocabulary of proven design techniques, and showing how to apply them in practice. "<a class="xref" href="ch13s05.html#design_patterns" title="DESIGN PATTERNS">DESIGN PATTERNS</a>" on page 255 discusses design patterns in more depth.</p></dd><dt><span class="term"><span class="strong"><strong>Flowcharts</strong></span></span></dt><dd><p>A particular kind of graphical notation, used to visualize algorithms. They're good for giving a high-level overview but are less precise than code and become another thing to be kept in sync with code changes. For this reason, it's best to use them sparingly.</p></dd><dt><span class="term"><span class="strong"><strong>Pseudocode</strong></span></span></dt><dd><p>Pseudocode helps you draft function implementations. It's one of the most curious inventions in software design—halfway between a natural language and a programming language, a sort of pidgin English. Its advantage is the freedom from any particular language's syntax and semantics. You can concentrate on what needs to be done, not on language mechanics, and you can include arbitrary amounts of descriptive prose for clarity.</p><p>These aren't incredible benefits compared to the downsides. The pseudocode will require translation into an implementation language. You could have started to write in <span class="emphasis"><em>that</em></span> language anyway and saved yourself some effort. If pseudocode is being used as design documentation, then you'll have to keep it in sync with code.<a class="indexterm" id="IDX-CHP-13-1062"/></p><p><span class="emphasis"><em>Program Design Language (PDL)</em></span> is an even more absurd invention—a formalized pseudocode. I guess it made sense to somebody at the time. I'd love to have seen their pseudocode compiler.<a class="indexterm" id="IDX-CHP-13-1063"/></p></dd><dt><span class="term"><span class="strong"><strong>Design in code</strong></span></span></dt><dd><p>This is a useful informal approach to code design. During the initial design stages, you capture all APIs and the lower-level interfaces in code, but without implementing any of them—you just write stubs that return plausible values, putting comments inside each describing what should be done. When you have reached a sufficiently mature design, the system already has a lot of code written.</p><p>This can be a mixed blessing, as it can lead to less fluid designs. The more you change the design, the more stubbed code you have to alter.</p></dd><dt><span class="term"><span class="strong"><strong>CASE tools</strong></span></span></dt><dd><p><span class="emphasis"><em>Computer-aided software engineering (CASE)</em></span> tools assist in all or part of the design process, automating tedious jobs and managing the workflow. Most are capable of generating code (of variable quality) from your pretty pictures. Some even update the pictures when you modify the code; this is known as <span class="emphasis"><em>round-trip engineering</em></span> (or <span class="emphasis"><em>round-tripping</em></span>). Many CASE tools support collaborative work, allowing teams of programmers to contribute to a single large-scale design.<a class="indexterm" id="IDX-CHP-13-1064"/></p></dd></dl></div><p>A breed of CASE tool worthy of mention is <span class="emphasis"><em>Rapid Application Development (RAD)</em></span> tools: environments for quickly building applications. They tend to work well in their specific domain (usually simple UI-focused applications) but aren't good general-purpose software design models.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Take a pragmatic approach to design tools and methodologies—use them when they are genuinely helpful—but don't become a slave to them</em></span>.</p></dd></dl></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id12"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>Out of intense complexities, intense simplicities emerge.<a class="indexterm" id="IDX-CHP-13-1065"/><a class="indexterm" id="IDX-CHP-13-1066"/></p><div class="attribution"><span>--<span class="attribution">Winston Churchill</span></span></div></div><p>Good code is well designed. It has a certain aesthetic appeal that makes it <span class="emphasis"><em>feel good</em></span>. You must plan a design before beginning to write code, or you'll end up with an unpleasant mess. Consider things like clean structure, possible future extensions, correct interfaces, appropriate abstractions, and portability requirements. Aim for simplicity and elegance.</p><p>Design involves a strong element of craftsmanship. The best designs come from experienced and skilled hands. Ultimately, a good designer is what makes a good design. Mediocre programmers do not produce excellent designs.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Want to leave anything they touch in a good state</p></li><li class="listitem"><p>Think of programming as a creative process and weave an element of artistry into their work</p></li><li class="listitem"><p>Think about the structure of code before they start working on it</p></li><li class="listitem"><p>Feel the need to tidy up and refactor messy code before they do any extra work on it</p></li><li class="listitem"><p>Constantly learn about the design of other software, building up knowledge of successes and failures</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Keep knitting more and more code into a tight ball until they think they've done enough and then complain about the result</p></li><li class="listitem"><p>Don't notice a bad design or feel any distaste when working with dense code</p></li><li class="listitem"><p>Are happy to hack quickly and run away, leaving someone else to clean up the mess</p></li><li class="listitem"><p>Don't appreciate or respect the internal design of code they're working on; they trample over it in an unsympathetic manner</p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id12"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch08.html" title="Chapter 8. TESTING TIMES">Chapter 8</a></span></dt><dd><p>Describes how to <span class="emphasis"><em>design code for testing</em></span>—making it easier to prove that your code works properly.</p></dd><dt><span class="term"><a class="xref" href="ch14.html" title="Chapter 14. SOFTWARE ARCHITECTURE">Chapter 14</a></span></dt><dd><p>The highest level of software design is known as <span class="emphasis"><em>software architecture</em></span>. It provides its own specific problems and is dealt with in this chapter.</p></dd><dt><span class="term"><a class="xref" href="ch19.html" title="Chapter 19. BEING SPECIFIC">Chapter 19</a></span></dt><dd><p>Software designs are often captured in a specification document.</p></dd><dt><span class="term"><a class="xref" href="ch22.html" title="Chapter 22. RECIPE FOR A PROGRAM">Chapter 22</a></span></dt><dd><p>Design fits into the overall software development process.</p></dd><dt><span class="term"><a class="xref" href="ch23.html" title="Chapter 23. THE OUTER LIMITS">Chapter 23</a></span></dt><dd><p>The type of system you're building has an inevitable influence on the software's internal design.</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e19565"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207488.png.jpg"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id13"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 519.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id12"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How does project size affect your software design and the work involved in creating it?</p></li><li class="listitem"><p>Is a well-documented bad design better than an undocumented good one?</p></li><li class="listitem"><p>How can you measure the design quality of a piece of code? How can you quantify its simplicity, elegance, modularity, and so on?</p></li><li class="listitem"><p>Is design a team activity? How important are teamworking skills in creating a good design?</p></li><li class="listitem"><p>Are different methodologies more suitable to different projects?</p></li><li class="listitem"><p>In what ways can you determine whether a design is highly cohesive or weakly coupled?</p></li><li class="listitem"><p>If you've solved a similar design problem in the past, how good an indicator is it of how difficult <span class="emphasis"><em>this</em></span> problem will be?</p></li><li class="listitem"><p>Is there a place for experimentation in design?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id12"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Look back and think about how you learned to design code. How could you convey the knowledge you've gained to a total novice?<a class="indexterm" id="IDX-CHP-13-1067"/><a class="indexterm" id="IDX-CHP-13-1068"/><a class="indexterm" id="IDX-CHP-13-1069"/></p></li><li class="listitem"><p>What experience do you have with using particular design methodologies? Were these good or bad experiences? What was the resulting code like? What might have worked better?</p></li><li class="listitem"><p>Do you find it important to stick rigidly to the methodology you're using?</p></li><li class="listitem"><p>What was the best designed code you've ever seen? What was the worst designed?</p></li><li class="listitem"><p>A programming language is essentially a tool to implement your design, not a religion to argue about. How important is it <span class="emphasis"><em>really</em></span> to know language idioms?</p></li><li class="listitem"><p>Do you think programming is an <span class="emphasis"><em>engineering discipline</em></span>, a <span class="emphasis"><em>craft</em></span>, or an <span class="emphasis"><em>art</em></span>?</p></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="software_architecture"/>Chapter 14. SOFTWARE ARCHITECTURE</h1></div><div><h3 class="subtitle"><i>Laying the Foundations of Software Design</i></h3></div></div></div><div class="epigraph"><p>Architecture is the art of how to waste space.</p><div class="attribution"><span>--<span class="attribution">Philip Johnson</span></span></div></div><p>Go into a city. Stand in the middle of it. Look around. Unless you've picked an unusual place, you will be surrounded by a large number of buildings of varying ages and styles of construction. Some fit into their surroundings sympathetically. Others look totally out of place. Some are aesthetically pleasing and seem well proportioned. Others are downright ugly. Some will still be there in 100 years' time. Many will not.</p><p>The architects who designed these buildings took a lot into consideration before they put pencil to paper. During the process of design, they worked carefully and methodically to ensure that the building was feasible to fabricate, and they balanced all the contending forces: user requirements, construction methods, maintainability, aesthetics, and so on.</p><p>Software is not made of bricks and mortar, but the same careful thought is requiredto ensure that a system meets similar sets of requirements. We have been erecting buildings far longer than we've been writing software, and it shows. We're still learning about what makes goodsoftware architecture.</p><p>In this little foray into the world of software architecture, we'll investigate some common architectural patterns and look at what software architecture really is, what itreally isn't, and what it's used for.</p><div class="sidebar"><a id="underground_movement"/><p class="title"><b>UNDERGROUND MOVEMENT</b></p><p>I joined a project that had produced a large amount of undocumented software, erected without plan or purpose, with no architect to guide the construction process. Naturally, it had become an unsightly carbuncle. The time came when we needed to understand how it all <span class="emphasis"><em>really</em></span> worked, and an architectural diagram of the system was drawn up. There were so many different components (many largely redundant), inappropriate interconnections, and different methods of communication that the diagram was an intense jumble of tightly woven lines in many interpretive colors—almost as if a spider had fallen into a few different cans of paint and then spun psychedelic webs across the office.<a class="indexterm" id="IDX-CHP-14-1074"/></p><p>Then it struck me. We had all but drawn a map of the London Underground. Our systembore such a striking resemblance, it was uncanny—it was practically incomprehensible to an outsider, with many routes to achieve the same end, and the plan was still a gross simplification of reality. This was the kind of system that would vex a traveling salesman.<a class="indexterm" id="IDX-CHP-14-1075"/></p><p>The lack of architectural vision had clearly made its mark on the software. It was hard to work with and hard to understand, with bits of functionality strewn across completely random modules. It had gotten to the point where the only useful thing you could do with it was throw it away.<a class="indexterm" id="IDX-CHP-14-1076"/></p><p>In software construction, as in building construction, the <span class="emphasis"><em>architecture really matters</em></span>.</p></div><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_is_software_architecture_question"/>What Is Software Architecture?</h1></div></div></div><p>Is this just another term that stretches the <span class="emphasis"><em>building</em></span> metaphor a little thinner (see "<a class="xref" href="ch10.html#do_we_really_build_software_question" title="DO WE REALLY BUILD SOFTWARE?">DO WE REALLY BUILD SOFTWARE?</a>" on page 177)? Maybe so, but it is a genuinely useful concept. Software architecture is sometimes known as <span class="emphasis"><em>high-level design</em></span>; regardless of the terms used, the meaning is the same. Architecture is a more evocative description of the concept.<a class="indexterm" id="IDX-CHP-14-1080"/><a class="indexterm" id="IDX-CHP-14-1077"/><a class="indexterm" id="IDX-CHP-14-1078"/><a class="indexterm" id="IDX-CHP-14-1079"/><a class="indexterm" id="IDX-CHP-14-1070"/><a class="indexterm" id="IDX-CHP-14-1071"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="software_blueprints"/>Software Blueprints</h2></div></div></div><p>As an architect prepares his blueprint for a building, the software architect prepares a blueprint for the software system. However, while a building's blueprint is a rigorously detailed plan with all the important features included, our software architecture is a top-level definition, an overview of the system that specifically avoids too much detail. It is macro, not micro.</p><p>In this high-level view, all implementation details are hidden; we just see the essential internal structure of the software and its fundamental behavioral characteristics. The architectural view does the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Identifies the key software modules (or components, or libraries; at this point call them what you like—<span class="emphasis"><em>blobs</em></span>)</p></li><li class="listitem"><p>Identifies which components communicate with each other</p></li><li class="listitem"><p>Helps to identify and determine the nature of all the important interfaces in the system, clarifying the correct <span class="emphasis"><em>roles and responsibilities</em></span> of the various subsystems<a class="indexterm" id="IDX-CHP-14-1081"/></p></li></ul></div><p>This information allows us to reason about the system as a whole without having to understand how every individual part will work. The architecture provides a framework into which the later development fits. It shows how work can be split between teams and allows you to weigh different implementation strategies.</p><p>Not only does the architecture give a picture of how the system is composed, it also shows how it should be extended over time. In large teams, a program will develop more elegantly when there's a clear, unified vision of how the software should be adapted, of what should be put in each module, and of how modules connect.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>The architecture is the single largest influence on the design and future growth of a software system. It is therefore</em></span> essential <span class="emphasis"><em>to get it right in the early stages of development</em></span>.</p></dd></dl></div><p>As an up-front activity, the architecture is our first chance to map the <span class="emphasis"><em>problem domain</em></span> (the Real World problem we are solving) to a <span class="emphasis"><em>solutiondomain</em></span>. There isn't always a simple one-to-one mapping of objects and activities between the two, so the architecture shows how to think about one in terms of the other.<a class="indexterm" id="IDX-CHP-14-1082"/></p><p>Exactly what needs to be addressed by the software architecture will differ from project to project. The target platform is not important at this stage; it may be possible to implement the architecture on a number of different machines using different languagesand technologies. However:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>For certain projects, it may be important to specify particular hardware components, most likely for embedded designs.<a class="indexterm" id="IDX-CHP-14-1083"/></p></li><li class="listitem"><p>For a distributed system, the number of machines and processors and the split of work between them might be an architectural issue. Minimum and average system configurations should be considered.<a class="indexterm" id="IDX-CHP-14-1084"/></p></li><li class="listitem"><p>The architecture may also describe specific algorithms or data structures if they are fundamental to the overall design (although this is far less likely).<a class="indexterm" id="IDX-CHP-14-1085"/><a class="indexterm" id="IDX-CHP-14-1086"/></p></li></ul></div><p>There is always a trade-off. The more information that is set in stone at the architectural level, the less room for maneuverability there is at a later design or implementation stage.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="points_of_view"/>Points of View</h2></div></div></div><p>In physical architecture, we use a number of different drawings or views of the same building: one for the physical structure, one for the wiring, one for the plumbing, andso on. Similarly, we develop different software views in the architectural process. Four views are commonly recognized:<a class="indexterm" id="IDX-CHP-14-1087"/><a class="indexterm" id="IDX-CHP-14-1088"/><a class="indexterm" id="IDX-CHP-14-1089"/><a class="indexterm" id="IDX-CHP-14-1090"/><a class="indexterm" id="IDX-CHP-14-1091"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>The conceptual view</strong></span></span></dt><dd><p>Sometimes called the <span class="emphasis"><em>logical view</em></span>, this shows the major parts of the system and their interconnections.<a class="indexterm" id="IDX-CHP-14-1092"/></p></dd><dt><span class="term"><span class="strong"><strong>The implementation view</strong></span></span></dt><dd><p>This view is seen in terms of the real implementation modules, which may have to differ from the neat conceptual model.<a class="indexterm" id="IDX-CHP-14-1093"/><a class="indexterm" id="IDX-CHP-14-1094"/></p></dd><dt><span class="term"><span class="strong"><strong>The process view</strong></span></span></dt><dd><p>Designed to show the dynamic structure in terms of tasks, processes, and communication, this view is best used when there's a high degree of concurrency involved.</p></dd><dt><span class="term"><span class="strong"><strong>The deployment view</strong></span></span></dt><dd><p>Use this view to show the allocation of tasks to physical nodes, in a distributed system. For example, you may split functionality between a database server and afarm of web interface gateways.<a class="indexterm" id="IDX-CHP-14-1095"/></p></dd></dl></div><p>You don't start with all of these. Particular views arise as development work progresses. The main result of the initial architectural phase is the <span class="emphasis"><em>conceptual view</em></span>, and that's what we're concentrating on here.</p><div class="sidebar"><a id="for_what_it_apos_s_worth"/><p class="title"><b>FOR WHAT IT'S WORTH</b></p><p>Software architecture has wide-ranging implications—far beyond the initial structure of the code, right into the heart of the software factory. The architecture will be a lasting legacy, both in the technological and practical realms. Architecture affects how the code will grow and how teams of people will work together to extend it;software designaffects workflow. With a three-tiered architecture, you'll end up with <span class="emphasis"><em>three</em></span> teams of people working on the separate parts. There will probably be <span class="emphasis"><em>three</em></span> sets of admin staff too, and <span class="emphasis"><em>three</em></span> management reporting lines. Someone's early design decision will affect which desk you sit at.<a class="indexterm" id="IDX-CHP-14-1096"/></p><p>Since the architecture determines how malleable the software is and how well the codebase can accommodate future requirements, it ultimately influences the commercial success of your company. A bad architecture is more than just inconvenient—it could cost you your livelihood. Serious stuff.</p><p>As programmers, it affects us most directly—it will affect how fun our work will be. No one wants to labor intensely to add a minuscule feature that would have taken two seconds with a correct initial design. At conception, check that the architecture supports what you think it should, not just what the architects believe.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="where_and_when_do_you_do_it_question"/>Where and When Do You Do It?</h2></div></div></div><p>The architecture is captured in a high-level document called something imaginative like the <span class="emphasis"><em>architecture specification</em></span>. This specification explains the system's structure and shows how it fulfills the requirements, including important issues like the strategy to reach any performance requirements and how acceptable fault tolerance will be achieved.<a class="indexterm" id="IDX-CHP-14-1099"/><a class="indexterm" id="IDX-CHP-14-1097"/><a class="indexterm" id="IDX-CHP-14-1098"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Capture system architecture in a known place; a document accessible to everyone involved—programmers, maintainers, installers, managers (perhaps even customers)</em></span>.</p></dd></dl></div><p>The architecture is the initial system design. It is therefore the <span class="emphasis"><em>first</em></span> developmental step after the requirements have been agreed upon. It's important to generate a specification up front because it provides a first chance to review and validate the design decisions that will have the most significant impact on the project. It will expose weaknesses and potential problems. Reversing a bad decision this early on will save a lot of time, effort, and money. It's expensive to changethe foundation of a system once a lot of code has been built upon it.</p><p>Architectural work is a form of design, but it is separate from the module design phase, and distinct from low-level code design, although it certainly overlaps somewhat. Later work on detailed design may feed changes back up to the system architecture. This isnatural and healthy.</p><div class="sidebar"><a id="whose_job_question"/><p class="title"><b>WHOSE JOB?</b></p><p>We've seen that software architecture affects <span class="emphasis"><em>everyone</em></span> on the project—not just the programmers. In contrast, the architecture is determined by a far smaller group of people. What a responsibility.</p><p>The architecture designer is called a <span class="emphasis"><em>software architect</em></span>. This is a grandiose titleand, like <span class="emphasis"><em>engineer</em></span>, somewhat contentious. "Real" architects must study, qualify, and reach levels of professional excellence to even be called architects. There are no such requirements in the software world.<a class="indexterm" id="IDX-CHP-14-1100"/><a class="indexterm" id="IDX-CHP-14-1101"/></p><p>Software architects are among the project initiators, working right at the beginning of the development cycle. As development ramps up, programmers will join the effort to implement this established architecture.</p><p>However, on smaller projects requiring less specialized architectural experience, the programmers themselves will devise the architecture. No big guns are drafted in. Be ready to contribute to architectural design.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="what_is_it_used_for_question"/>What Is It Used For?</h2></div></div></div><p>Architecture is the initial system design. But its uses stretch even further. We use the system architecture to:<a class="indexterm" id="IDX-CHP-14-1102"/><a class="indexterm" id="IDX-CHP-14-1103"/><a class="indexterm" id="IDX-CHP-14-1104"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Validate</strong></span></span></dt><dd><p>The architecture is our first chance to validate what is going to be built. With it, we can mentally check that the system will meet all requirements. We can check that it really is feasible to build. We can ensure that the design is internally consistent and hangs together well with no special cases or gratuitous hacks. Nasty blemishes in the high-level design will only lead to more dangerous hacks at lower levels.</p><p>The architecture helps to ensure that there is no duplication of work, wasted effort, or redundancy. We use it to check that there are no gaps in the strategy, that we haveincluded all the necessary pieces. We ensure that there will be no mismatches as separatesections are brought together.</p></dd><dt><span class="term"><span class="strong"><strong>Communicate</strong></span></span></dt><dd><p>We use the architecture specification to communicate the design to all interested parties. These may be system designers, implementers, maintainers, testers, customers, or managers. It's the primary route to understand the system and is an important piece of documentation that should <span class="emphasis"><em>always</em></span> be kept up to date as changes are made.</p></dd><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>An architecture specification is an essential device to communicate the shape of your system. Ensure that you keep it in sync with the software</em></span>.</p><p>The architecture conveys the vision of your system, mapping the problem domain to the solution domain. It should neatly identify how future extensions fit in, helping to maintain the system's <span class="emphasis"><em>conceptual integrity</em></span>. (Brooks 95) It implicitly provides a set of conventions and contains an element of style. For example, it's clear that you shouldn't introduce a new component with custom socket-based communication if the rest of the design uses a CORBA infrastructure.</p><p>The architecture provides a natural route into the next level of design without being too prescriptive.</p></dd><dt><span class="term"><span class="strong"><strong>Discriminate</strong></span></span></dt><dd><p>We use the architecture to help us make decisions. For example, it identifies build versus buy decisions, determines whether a database is required, and clarifiesthe error-handling strategy. It will flag problem areas, areas of particular risk on the project, and help us plan to minimize this risk. Just as an architect's primary goal is to ensure his building stays up when it's built—under all expected conditions (and some unusual conditions too)—so should we ensure the resillience of our software structure. A little wind or extra load shouldn't topple the thing over.</p><p>We need this systemwide perspective to make the appropriate trade-offs, ensuring that the design meets its required properties. These important issues are considered at thebeginning rather than grafted in toward the end of development.</p></dd><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Make all software design decisions in the context of the architecture. Always check that you're working in line with the system vision and strategy. Don't create a little wart on the side that doesn't complement anything else</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="of_components_and_connections"/>Of Components and Connections</h2></div></div></div><p>Architecture mostly concerns itself with <span class="emphasis"><em>components</em></span> and <span class="emphasis"><em>connections</em></span>. It determines the number and type of each.<a class="indexterm" id="IDX-CHP-14-1105"/></p><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="components"/>Components</h3></div></div></div><p>Architecture captures information about each component, whatever <span class="emphasis"><em>component</em></span> means inthe architecture's context. It could be an object, a process, a library, a database, or athird party product. Each of the system's components is identified as a clear and logicalunit. Each performs one task and does it well. No component includes a kitchen sink unless there's a specific kitchen-sink module.</p><p>While it won't dwell on component implementation issues, the architecture will describe all exposed facilities and perhaps the important externally visible interfaces. It defines the <span class="emphasis"><em>visibility</em></span> of the component: what it can see and what it can't, and what can see it and what can't. Different architectural styles imply differentvisibility rules, as we'll see later.</p><div class="sidebar"><a id="architects_vs._marketers"/><p class="title"><b>ARCHITECTS VS. MARKETERS</b></p><p>An architecture is inadequate if it doesn't fulfill the product requirements for initial deployment or any future development; design quality is about more than just technical excellence. Technical issues must be addressed alongside product management and marketing considerations.<a class="indexterm" id="IDX-CHP-14-1106"/></p><p>There is no point in developing a product that no one wants; it would obviously be a huge waste of time. But you can miss vital business opportunities by omitting marketingrequirements from technical consideration. The marketing department identifies core business objectives including sales strategies (do you charge a one-off fee or employ a licensing/billing model?), the product's position in the marketplace (is it a high-end, feature-packed, high-cost product or a cheap, mass-produced item?), and the importance of a uniquebrand running through the system.</p><p>In some situations, visibly good architecture may be a <span class="emphasis"><em>unique selling point</em></span> and mayprovide a strong competitive advantage. Other markets care less about the internal systemstructure, but an architecture that anticipates and handles future customer requirements is still essential to establish and maintain a strong market position.</p><p>Technical architects must work closely with the marketing decision makers to understand how new software will fit into the company's overall strategy and what the customer requires for a truly exceptional solution. The software architecture will address marketing issues such as usability, reliability, upgradeablity, and extensibility. Each of these has a real influence on the software design. Support for different charging methods alonemay have a huge impact on the profitability of the project—the inclusion of rich logging support will pave the way for per-transaction billing, which may lead to increased product revenue. However, it may mandate the inclusion of additional security and fraud-prevention measures in the architectural planning.</p><p>Marketing requirements feed into the technical architecture. Technical considerations will also feed back to the marketing strategy. A truly great architecture is born when technical and strategic visions meet to create a product that stands out from its competitors.</p></div></div><div class="sect3" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="connections"/>Connections</h3></div></div></div><p>The architecture identifies all the inter-component connections and describes the connection properties. A connection may be a simple function call or data flow through a pipe. It may be an event handler or a message passing through some OS or network mechanism. A connection can be <span class="emphasis"><em>synchronous</em></span> (blocking the caller until the implementation has completed the request) or <span class="emphasis"><em>asynchronous</em></span> (returning control to the caller immediately and arranging for a reply to be posted back at a later date). This is important, since it affects the flow of control around the system.<a class="indexterm" id="IDX-CHP-14-1107"/><a class="indexterm" id="IDX-CHP-14-1108"/><a class="indexterm" id="IDX-CHP-14-1109"/></p><p>Some communication is indirect (and consequently quite subtle). For example, components can share certain resources and talk through them—rather like posting messageson a shared whiteboard. Examples of shared communication channels are: a subordinate component, a shared memory region, or something as basic as the contents of a file.</p></div></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_is_good_architecture_question"/>What Is Good Architecture?</h1></div></div></div><p>The key to good architecture is <span class="emphasis"><em>simplicity</em></span>. A few well-chosen modules and sensible communication paths are the aim. It also needs to be <span class="emphasis"><em>comprehensible</em></span>, which often means visually represented. We all know that <span class="emphasis"><em>a picture speaks a thousand words</em></span>.<a class="indexterm" id="IDX-CHP-14-1110"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Good system architecture is</em></span> simple. <span class="emphasis"><em>It can be described in a single paragraph and summarized in one elegant diagram</em></span>.</p></dd></dl></div><p>In a well-designed system, there should be neither too few nor too many components. This criterion scales with the size of the problem. For a small program, the architecturemay fit on (or even be done on) the back of an envelope, with just a few modules and somesimple interconnections. A large system naturally requires more effort and more envelopes.<a class="indexterm" id="IDX-CHP-14-1111"/></p><p><span class="emphasis"><em>Too many</em></span> fine-grained components lead to an architecture that is bewildering and hard to work with. It implies that the architect has gone into too much detail. <span class="emphasis"><em>Too few</em></span> components means that each module is doing far too much work; this makes the structure unclear, hard to maintain, and hard to extend. The correct balance is somewhere between the two.</p><p>The architecture does not dictate the inner workings of each module—that's what module design is for. The goal is that each module should know very little about the other parts of the system. We aim for low coupling and high cohesion (see "<a class="xref" href="ch13s04.html#modularity" title="Modularity">Modularity</a>" on page 247) at this level of design, as with all others.<a class="indexterm" id="IDX-CHP-14-1112"/><a class="indexterm" id="IDX-CHP-14-1113"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Architecture</em></span> identifies <span class="emphasis"><em>the key components of the system and how they interact. It doesn't define</em></span> how <span class="emphasis"><em>they work</em></span>.</p></dd></dl></div><p>The architecture specification lists the design decisions made and makes it clear why this approach is being favored over any alternative strategies. It doesn't need to labor these other approaches, but should justify the chosen architecture and prove that some serious thought went into it. It must have correctly identified the primary goal of the system: For example, <span class="emphasis"><em>extensibility</em></span> is a different game from <span class="emphasis"><em>performance</em></span> and will lead to different architectural design decisions.<a class="indexterm" id="IDX-CHP-14-1114"/><a class="indexterm" id="IDX-CHP-14-1115"/></p><p>A good architecture leaves room for maneuverability; it allows you to change your mind. It may specify that we wrap third party components with abstract interfaces so we can swap one version out for another. It may suggest technologies that make it easy to select different implementations during deployment. As a project gains momentum, the correct implementation choices become clear—they aren't always obvious at first. A successful architecture is flexible, providing a mechanism for nimble design during these initial uncertainties. The architecture is the first pivot on which to balance contending forces; it will show how we trade one quality for another.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>A good architecture leaves space for maneuverability, extension, and modification. But it isn't hopelessly general</em></span>.</p></dd></dl></div><p>The architecture must be clear and unambiguous. Preexisting, well-known architectural styles or well-known frameworks are best (see the next section for more on these). Architecture must be easy to understand and work with.</p><p>Like a good design, good architecture has a certain aesthetic appeal that makes it <span class="emphasis"><em>feel</em></span> right.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="architectural_styles"/>Architectural Styles</h1></div></div></div><div class="epigraph"><p><span class="emphasis"><em>Form ever follows function</em></span>.<a class="indexterm" id="IDX-CHP-14-1116"/></p><div class="attribution"><span>--<span class="attribution">Louis Henry Sullivan</span></span></div></div><p>Just as an immense gothic cathedral and a quaint Victorian chapel, or an imposing tower block and a 1970s public lavatory employ different architectural styles, there are anumber of recognized software architectural styles that a system may be built upon. A style may be chosen for various reasons, good or bad—perhaps on sound technological grounds, or perhaps based on the architect's prior experience, perhaps even by what style is currently in fashion. Each architecture has different characteristics:<a class="indexterm" id="IDX-CHP-14-1117"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Its resilience to changes in the data representation, algorithms, and required functionality</p></li><li class="listitem"><p>Its method of module separation and connection</p></li><li class="listitem"><p>Its comprehensibility</p></li><li class="listitem"><p>Its accommodation of performance requirements</p></li><li class="listitem"><p>Its consideration of component reusability</p></li></ul></div><p>In practice, we might see a mixture of architectural styles in one system. Some data processing may progress through a pipe and filter process, while the rest of the systememploys a component-based architecture.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Recognize the key architectural styles and appreciate their pros and cons. This will help you to sympathetically work with existing software and perform appropriate system design</em></span>.</p></dd></dl></div><p>The following sections describe some of the common architectural styles. And then compare them to pasta.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="no_architecture"/>No Architecture</h2></div></div></div><p>A system always has an architecture, but like my London Underground project, it maynot have a <span class="emphasis"><em>planned</em></span> architecture. Before long, this state of affairs becomes an albatross around the neck of your development team. The resulting software will be a mess.</p><p>Defining an architecture is essential if you want to build good software. Not planning an architecture is a surefire way to doom development before you've even started.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e20298"/><img alt="No Architecture" src="tagoreillycom20080909nostarchimages207490.png"/></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="layered_architecture"/>Layered Architecture</h2></div></div></div><p>This is probably the most commonly used architectural style in conceptual views. Itdescribes the system as a hierarchy of layers, with a building-block approach. It is a very simple model to comprehend; even a non-techie can quickly grasp what it's telling him.<a class="indexterm" id="IDX-CHP-14-1118"/><a class="indexterm" id="IDX-CHP-14-1119"/><a class="indexterm" id="IDX-CHP-14-1120"/><a class="indexterm" id="IDX-CHP-14-1121"/><a class="indexterm" id="IDX-CHP-14-1122"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e20334"/><img alt="Layered Architecture" src="tagoreillycom20080909nostarchimages207492.png"/></div></div><p>Each component is represented by a single block in the stack. The positions in the stack indicate what lives where, how the components relate to each other, and which components can "see" which other components. Blocks may be placed alongside each other on the same level and can even become tall enough to span two layers.</p><p>A famous example of this is the OSI seven-layer reference model for network communication systems. (ISO 84) A more interesting example is the Goodliffe seven-layer trifle reference model shown in <a class="xref" href="ch14s03.html#the_goodliffe_seven-layer_trifle_reference_model" title="Figure 14-1. The Goodliffe seven-layer trifle reference model">Figure 14-1</a>.<a class="indexterm" id="IDX-CHP-14-1123"/><a class="indexterm" id="IDX-CHP-14-1124"/></p><div class="figure"><a id="the_goodliffe_seven-layer_trifle_reference_model"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e20354"/><img alt="The Goodliffe seven-layer trifle reference model" src="tagoreillycom20080909nostarchimages207494.png"/></div></div><p class="title"><b>Figure 14-1. The Goodliffe seven-layer trifle reference model</b></p></div><br class="figure-break"/><p>At the lowest level of the stack, we find the hardware interface, if the system does indeed interact with physical devices. Otherwise, this level is reserved for the most basic service, perhaps the OS or a middleware technology like CORBA. The highest level will likely be occupied by the fancy interface that the user interacts with. As you rise further up the stack, you move further away from the hardware, happily insulated by the layers in between in the same way that the roof of a house doesn't have to worry about the magma at the earth's core.<a class="indexterm" id="IDX-CHP-14-1125"/></p><p>At any point, you can brush out all the lower layers and slot in a new implementation of the layer below—the system will function as before. This is a key point: It means that you can run the same C++ code on any computing platform that supports your C++ environment. You can swap the hardware platform without touching your application code—relying on the OS layer (for example) to swallow the technical differences. Handy.</p><p>Higher levels use the public interfaces of the layer directly below. Whether they can use the public interfaces of the lower levels depends of your definition of layering. Sometimes the diagram is fiddled to represent this, like the sherry brick in the trifle stack. Whether or not components on the same layer can interconnect is also not rigidly defined. You certainly can't use anything from ahigher level; if you break this edict, you no longer have a layered architecture, just a meaningless diagram drawn in stack form.<a class="indexterm" id="IDX-CHP-14-1126"/><a class="indexterm" id="IDX-CHP-14-1127"/></p><p>As you can see, most layer diagrams are informal. The relative size and position ofboxes gives a clue as to importance of a component, and that is generally sufficient as an overview. Component connections are implicit, and the methods of communication irrelevant. (However, this can be a key architectural concern for the efficiency of the system—you won't send gigabytes of data down an RS232 serial port.)</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="pipe_and_filter_architecture"/>Pipe and Filter Architecture</h2></div></div></div><p>This architecture models the logical flow of data through the system. It is implemented as a string of sequential modules that each read some data, process it, and spit it out again. At the start of the chain is a data generator (maybe a user interface or perhaps some hardware harvesting logic). At the end is a data sink (perhaps the computer display or a log file). It's the old through-the-grapevine telephone game in digital form. Thedata flows down the pipe, encountering the various filters en route. The transformations are usually incremental; each filter does a single simple process and tends to have very little internal state.<a class="indexterm" id="IDX-CHP-14-1128"/><a class="indexterm" id="IDX-CHP-14-1129"/><a class="indexterm" id="IDX-CHP-14-1130"/><a class="indexterm" id="IDX-CHP-14-1131"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e20402"/><img alt="Pipe and Filter Architecture" src="tagoreillycom20080909nostarchimages207496.png"/></div></div><p>The pipe and filter architecture requires a well-defined data structure between each filter; it has the implicit overhead of repeatedly encoding the output data for transmission down the pipe and parsing it back again in each subsequent filter. For this reason, the data stream is usually very simple—just a plaintext format.<a class="indexterm" id="IDX-CHP-14-1132"/></p><p>This architecture makes it easy to add functionality by just plugging a new filter into the pipeline. Its main downside is error handling. It is hard to determine where an error originated in the pipeline by the time a problem manifests itself at the sink. It'scumbersome to pass error codes down the chain toward the output stage; they need extra encoding and are hard to handle uniformly over several separate modules. The filters may use a separate error channel (e.g., <code class="literal">stderr</code>), but error messages can get mixed up all too easily.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="client_foreword_slash_server_architecture"/>Client/Server Architecture</h2></div></div></div><p>A typically network-based architecture, the client/server model separates functionality into two key pieces: the <span class="emphasis"><em>client</em></span> and the <span class="emphasis"><em>server</em></span>. It differs from the older <span class="emphasis"><em>mainframe</em></span> style of networked design in the division of work between each part; a mainframe "client" is a dumb terminal—little more than a means to capture and transmit keypresses, with some output display.<a class="indexterm" id="IDX-CHP-14-1133"/><a class="indexterm" id="IDX-CHP-14-1134"/><a class="indexterm" id="IDX-CHP-14-1135"/><a class="indexterm" id="IDX-CHP-14-1136"/><a class="indexterm" id="IDX-CHP-14-1137"/><a class="indexterm" id="IDX-CHP-14-1138"/><a class="indexterm" id="IDX-CHP-14-1139"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e20468"/><img alt="Client/Server Architecture" src="tagoreillycom20080909nostarchimages207498.png"/></div></div><div class="sidebar"><a id="a_slap_in_the_interface"/><p class="title"><b>A SLAP IN THE INTERFACE</b></p><p>A key software construction principle is <span class="emphasis"><em>modularity</em></span>, designing systems from replaceable components. This is almost a "LEGO brick" approach to construction. Done correctly, you should be able to take out a square, blue brick and replace it with a slightly fancier red one. If the bricks are the same size and shape and have the same kinds of connector, they will fit into the same hole and do the same job.<a class="indexterm" id="IDX-CHP-14-1140"/><a class="indexterm" id="IDX-CHP-14-1141"/></p><p>How do we implement this in software? We define <span class="emphasis"><em>interfaces</em></span>; these are our connection points and component barriers. They define the size and shape of each component (as seen from the outside, at least) and determine what you have to do to provide a like-for-like replacement. Key types of interfaces are:<a class="indexterm" id="IDX-CHP-14-1142"/><a class="indexterm" id="IDX-CHP-14-1143"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>APIs</strong></span></span></dt><dd><p><span class="emphasis"><em>Application programming interfaces (APIs)</em></span> are specified as collections offunctions in a physically linked application. To replace a component that implements a particular API, you just reimplement all the functions and relink the code.<a class="indexterm" id="IDX-CHP-14-1144"/><a class="indexterm" id="IDX-CHP-14-1145"/></p></dd><dt><span class="term"><span class="strong"><strong>Class hierarchies</strong></span></span></dt><dd><p>You can design an abstract "interface" class (in Java and C#, you'd actually define an <code class="literal">interface</code>). Then provide any number of concrete implementations that derivefrom it and implement that interface.</p></dd><dt><span class="term"><span class="strong"><strong>Component technologies</strong></span></span></dt><dd><p>Technologies such as COM and CORBA allow your program to determine the correct implementation component at run time. Typically, interfaces are defined in an abstract <span class="emphasis"><em>Interface Definition Language (IDL)</em></span>. The beauty of this approach is that components can be written in any language. It requires middleware or OS support.<a class="indexterm" id="IDX-CHP-14-1146"/><a class="indexterm" id="IDX-CHP-14-1147"/></p></dd><dt><span class="term"><span class="strong"><strong>Data formats</strong></span></span></dt><dd><p>These formats can form a connection point in designs focused on the movement of data rather than the flow of control. You can replace any component in the data chain with an analog that interacts with the same data types.<a class="indexterm" id="IDX-CHP-14-1148"/></p></dd></dl></div><p>As you can see, architecture—indeed, most of software design—is about crafting appropriate interfaces. Each of these interface techniques maps to a particular architecturalstyle. Pick an interface mechanism that complements the architecture.</p></div><p>The clients of a client/server architecture are richer, more intelligent, and generally able to present data in an interactive, graphical manner. Here is a more detailed look at the role of the two elements:<a class="indexterm" id="IDX-CHP-14-1149"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Server</strong></span></span></dt><dd><p>The server provides certain well-defined services to clients. It will generally be a powerful computer dedicated to providing specific functionality or to managing a resource (shared files, printers, a database, or pooled processing power).</p><p>The server provides certain well-defined services to clients. It will generally be a powerful computer dedicated to providing specific functionality or to managing a resource (shared files, printers, a database, or pooled processing power).</p></dd><dt><span class="term"><span class="strong"><strong>Client</strong></span></span></dt><dd><p>The client consumes a server's services. It sends off requests and processes the results that are returned. Some clients are dedicated terminals which only fulfill one role; other clients serve many functions (for example, a "client" application may run on a standard desktop PC that can also browse the web and view email).</p><p>There can be many different types of clients using one server, all performing the same set of requests but in different ways. One client might be web based, one might have a GUI interface, while another might provide command line access.</p></dd></dl></div><p>This client/server approach is sometimes known as a <span class="emphasis"><em>two-tier</em></span> architecture, for obvious reasons. It's very common and is seen throughout the software development world. The means of communication between client and server varies—it's simplest to use standard network protocols, but you may also see use of remote procedure calls (RPC), remote SQL database queries, or even proprietary application-specific protocols.<a class="indexterm" id="IDX-CHP-14-1150"/></p><p>There are various ways of splitting work between the two components. The main application logic (also known as <span class="emphasis"><em>business logic</em></span>) may run on either the client or server, depending on how intelligent and specialized the client is supposed to be. As more application logic is pushed down to the client, the design becomes less flexible—separate clients have to reimplement similar features, negating the benefit of the central server. Clients are generally concerned with providing sensible human interfaces to the published server functionality.<a class="indexterm" id="IDX-CHP-14-1151"/><a class="indexterm" id="IDX-CHP-14-1152"/></p><p>We sometimes see an extension of this two-tier design, which introduces another layer (the <span class="emphasis"><em>middle tier</em></span>). This component is explicitly designed to contain the business logic, separating it from both the client application (which is now most definitely only an interface) and the back-end data storage. This is a <span class="emphasis"><em>three-tier</em></span> architecture.<a class="indexterm" id="IDX-CHP-14-1153"/></p><p>A client/server approach is different from a <span class="emphasis"><em>peer-to-peer</em></span> architecture, where no network node has more capability or importance than any other. Peer-to-peer architectures are harder to deploy but more tolerant of faults. The client/server design is crippled when the server is unavailable (through some software fault or routine maintenance): No client will be able to operate until the server comes back to life. For this reason, client/server installations generally require a designated administrator to keep all systems running smoothly.<a class="indexterm" id="IDX-CHP-14-1154"/><a class="indexterm" id="IDX-CHP-14-1155"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="component-based_architecture"/>Component-Based Architecture</h2></div></div></div><p>This architecture decentralizes control and splits it into a number of separate collaborating <span class="emphasis"><em>components</em></span> rather than a single monolithic structure. It is an object-oriented approach, but doesn't necessarily require implementation in an OO language. Each component's public interface is typically defined in an <span class="emphasis"><em>Interface Definition Language (IDL)</em></span> and is separate from any implementation, although some component technologies (like .NET's built-in component support) can determine this from the implementation code itself.<a class="indexterm" id="IDX-CHP-14-1156"/><a class="indexterm" id="IDX-CHP-14-1157"/><a class="indexterm" id="IDX-CHP-14-1158"/><a class="indexterm" id="IDX-CHP-14-1159"/><a class="indexterm" id="IDX-CHP-14-1160"/><a class="indexterm" id="IDX-CHP-14-1161"/><a class="indexterm" id="IDX-CHP-14-1162"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e20674"/><img alt="Component-Based Architecture" src="tagoreillycom20080909nostarchimages207500.png"/></div></div><p>Component-based design arrived with the lure of assembling applications quickly out of prefabricated components, supposedly enabling plug-and-play solutions. It's still up for debate how much of a success this has been. Not all components are designed for reuse (it's hard work), and it's not always easy to find a component that does what you want it to do. It's easiest for UIs, where popular frameworks and established marketplaces exist.<a class="indexterm" id="IDX-CHP-14-1163"/><a class="indexterm" id="IDX-CHP-14-1164"/><a class="indexterm" id="IDX-CHP-14-1165"/></p><p>The core of a component-based architecture is a communication infrastructure, or <span class="emphasis"><em>middleware</em></span>, which allows components to be plugged in, to broadcast their existence, and to advertise the services they provide. Components are used by looking up this information through a middleware mechanism, rather than by hardwiring a direct connection between two components. Common middleware platforms include CORBA, JavaBeans, and COM; each have different strengths and weaknesses.<a class="indexterm" id="IDX-CHP-14-1166"/><a class="indexterm" id="IDX-CHP-14-1167"/><a class="indexterm" id="IDX-CHP-14-1168"/><a class="indexterm" id="IDX-CHP-14-1169"/></p><p>A component<sup>[<a class="footnote" href="#ftn.CHP-14-FN-1" id="CHP-14-FN-1">1</a>]</sup> is essentially an implementation unit. It honors one (maybe more) specific published IDL interfaces. This interface is how clients of the component interact with it. There are no back doors. The client is concerned with dealing with an instance of that interface, rather than in how the component is implemented.</p><p>Each component is an individual, independent piece of code. Behind its interface, it implements some logic (perhaps business logic or user interface activity) and contains some data, which may just be local or may be published (say a filestore or database component). Components don't need to know much about one another. If they <span class="emphasis"><em>are</em></span> tightly coupled, then the architecture is just an obfuscated monolithic system.<a class="indexterm" id="IDX-CHP-14-1170"/></p><p>Component-based architectures can be deployed in a networked environment with components on different machines, but they can just as easily exist as a single machine installation. This may depend on the type of middleware in use.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="frameworks"/>Frameworks</h2></div></div></div><p>Instead of developing a new architecture for a specific project, it may be appropriate to use an existing <span class="emphasis"><em>application framework</em></span> and add development into that skeleton. A framework is an extensible library of code (usually a set of co-operating classes) that forms a reusable design solution for a particular problem domain. Most of the work in a framework has been done for you, with the remaining pieces following a fill-in-the-blanks approach. Different frameworks follow different architectural models; by using a framework, you commit to its particular style.<a class="indexterm" id="IDX-CHP-14-1171"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e20741"/><img alt="Frameworks" src="tagoreillycom20080909nostarchimages207502.png"/></div></div><p>Frameworks differ from traditional libraries in the way they interact with your code. When using a library, you make explicit calls into the library components under your own thread of control. A framework turns this around; it is responsible for the structure and flow of control. It calls into your supplied code as and when necessary.</p><p>Sitting alongside off-the-shelf frameworks are architectural <span class="emphasis"><em>design patterns</em></span>. While not an architectural style in their own right, patterns are small-scale architectural templates. They are micro-architectures for a few collaborating components, distilling a recurring structure of communication. Architectural patterns describe common component structures at the architectural design level, explaining how they fulfill the requirements of a given context. Patterns are a set of design best practices, described in the ubiquitous GoF book (Gamma et al. 94) and numerous subsequent publications (see "<a class="xref" href="ch13s05.html#design_patterns" title="DESIGN PATTERNS">DESIGN PATTERNS</a>" on page 255).<a class="indexterm" id="IDX-CHP-14-1172"/><a class="indexterm" id="IDX-CHP-14-1173"/><a class="indexterm" id="IDX-CHP-14-1174"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-14-FN-1" id="ftn.CHP-14-FN-1">1</a>] </sup>We've already talked about components as modules, ephemeral implementation units. But this is a new definition for the word, quite specific to the world of component-based architecture. Sadly, the terms are overloaded with multiple meanings.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id13"/>In a Nutshell</h1></div></div></div><p>The Roman architect Vitruvius made a timeless statement of what constitutes good architectural design: strength (<span class="emphasis"><em>firmitas</em></span>), utility (<span class="emphasis"><em>utilitas</em></span>), and beauty (<span class="emphasis"><em>venustas</em></span>). (Vitruvius) This holds true forour software architectures. Without a well-defined, well-communicated architecture, a software project will lack a cohesive internal structure. It will become brittle, unstable, and ugly. Eventually, it will reach a breaking point.<a class="indexterm" id="IDX-CHP-14-1175"/></p><p>All this talk of pasta has made me hungry. I'm off to build a seven-layer reference trifle. . . .</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Understand their software architecture and write new code within it</p></li><li class="listitem"><p>Can apply the appropriate architecture to each design scenario</p></li><li class="listitem"><p>Create simple architectures that are beautiful and elegant—they appreciate the aesthetics of software design</p></li><li class="listitem"><p>Capture the system architecture in a live document that is continuously updated</p></li><li class="listitem"><p>Relay problems with the structure back to the system architects in an attempt to improve the design</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Write code regardless of any overall architectural vision—resultingin unsympathetic blemishes and unintegrated components</p></li><li class="listitem"><p>Fail to perform any high-level design before ploughing into code, ignoring any architectural alternatives</p></li><li class="listitem"><p>Leave architectural information locked inaccessibly in people's heads or in a dangerously out-of-date specification</p></li><li class="listitem"><p>Put up with inadequate architectures, adding more badly designed code rather than fixing the underlying problems—they can't be bothered to open a larger canof worms</p></li></ul></div>
</td></tr></tbody></table></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e20842"/><img alt="In a Nutshell" src="tagoreillycom20080909nostarchimages207504.png.jpg"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id13"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch12.html" title="Chapter 12. AN INSECURITY COMPLEX">Chapter 12</a></span></dt><dd><p>Security concerns must be addressed by a system architecture.</p></dd><dt><span class="term"><a class="xref" href="ch13.html" title="Chapter 13. GRAND DESIGNS">Chapter 13</a></span></dt><dd><p>Code <span class="emphasis"><em>design</em></span> is the subsequent level of code construction.</p></dd><dt><span class="term"><a class="xref" href="ch15.html" title="Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?">Chapter 15</a></span></dt><dd><p>Architecture is the start of your software's life, but it is by no means the only thing that steers its development.</p></dd><dt><span class="term"><a class="xref" href="ch22.html" title="Chapter 22. RECIPE FOR A PROGRAM">Chapter 22</a></span></dt><dd><p>Where architectural design fits into the software development process.</p></dd></dl></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id14"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 522.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id13"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Define where <span class="emphasis"><em>architecture</em></span> ends and <span class="emphasis"><em>software design</em></span> begins.</p></li><li class="listitem"><p>In what ways can a bad architecture affect a system? Are there parts thatwouldn't be affected by architectural flaws?</p></li><li class="listitem"><p>How easy is it to repair architectural deficiencies once they become apparent?</p></li><li class="listitem"><p>To what extent does architecture affect the following things?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>System configuration</p></li><li class="listitem"><p>Logging</p></li><li class="listitem"><p>Error handling</p></li><li class="listitem"><p>Security</p></li></ol></div></li><li class="listitem"><p>What experience or qualifications are required to be called a <span class="emphasis"><em>software architect</em></span>?</p></li><li class="listitem"><p>Should sales strategy influence architecture? If so, how? If not, why?</p></li><li class="listitem"><p>How would you architect for <span class="emphasis"><em>extensibility</em></span>? How wouldyou architect for <span class="emphasis"><em>performance</em></span>? How do these design goals affect the system, and how do they complement one another?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id13"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How diverse is the range of architectural styles to which you are accustomed? What do you have the most experience with—how does it affect the software you write?<a class="indexterm" id="IDX-CHP-14-1176"/><a class="indexterm" id="IDX-CHP-14-1177"/><a class="indexterm" id="IDX-CHP-14-1178"/><a class="indexterm" id="IDX-CHP-14-1179"/><a class="indexterm" id="IDX-CHP-14-1180"/><a class="indexterm" id="IDX-CHP-14-1181"/><a class="indexterm" id="IDX-CHP-14-1182"/></p></li><li class="listitem"><p>What personal experience do you have of architectures that succeeded or failed? What made them winning solutions or a hindrances?</p></li><li class="listitem"><p>Get every developer on your current project to draw a picture of the system architecture—individually (without talking to anyone) and without any reference to system documentation or the code. Compare the pictures. See what strikes you about each developer's efforts—aside from the relative artistic merit!</p></li><li class="listitem"><p>Do you have an architectural description that's commonly available for your current project? How up to date is it? Which kinds of view are you using? If you needed to explain the system to a newcomer or a potential customer, what would you really need to have documented?</p></li><li class="listitem"><p>How does your system's architecture compare to the architecture of your competitors in the marketplace? How has your architecture been defined to determine your project's success?</p></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="software_evolution_or_software_revolution_question"/>Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?</h1></div><div><h3 class="subtitle"><i>How Does Code Grow?</i></h3></div></div></div><div class="epigraph"><p>I cannot say whether things will get better if we change; what I can say is they must change if they are to get better.<a class="indexterm" id="IDX-CHP-15-1183"/></p><div class="attribution"><span>--<span class="attribution">G.C. Lichtenberg</span></span></div></div><p>If only software grew like a plant. You'd put the seed of an idea into some fertile programming soil, add a little water, and wait. You'd tend it carefully: Fertilize it, keep it in good light, and cover it to keep the birds off. In time, a code seedling would sprout, and when the program plant was big enough, you could release it to the world. For extra functionality you'd keep watering and add some more fertilizer, and it would continue to develop. The trunk would strengthen in order to support the new branches and the program would stay in perfect balance. If it grew in a direction you didn't like, a little pruning would soon set it straight.</p><p>Unfortunately, the Real World does not work like this. Not by a long shot.</p><p>Software <span class="emphasis"><em>is</em></span> a live entity. It's not sentient or organic, but it has its own kind of life: It is conceived, develops steadily, and eventually reaches maturity. Then it's sent out into the Big Wide World to make a living and hopefully garner respect and admiration. It may continue to develop, perhaps to the point where it gains a middle age spread and loses its youthful looks. Over time, it grows tired and old and is eventually retired, put out to pasture in a digital farmyard where it can gracefully die.</p><p>This chapter looks at how we cultivate software, especially after the initial round of development. Programs require thoughtful tending and seldom receive the care and attention they really deserve. What can we do to prevent a slowly spreading code cancer that leads to early death?</p><p>To answer this, we'll work backward. We'll take a look at the symptoms of bad code growth, explore how we grow our code, and determine some strategies to develop healthier software.<a class="indexterm" id="IDX-CHP-15-1184"/></p><div class="sidebar"><a id="more_metaphors_for_software_construction"/><p class="title"><b>MORE METAPHORS FOR SOFTWARE CONSTRUCTION</b></p><p>We've already examined the metaphor of <span class="emphasis"><em>building</em></span> and discussed what it tells us about the software construction process (see "<a class="xref" href="ch10.html#do_we_really_build_software_question" title="DO WE REALLY BUILD SOFTWARE?">DO WE REALLY BUILD SOFTWARE?</a>" on page 177 ). In this chapter, I'll introduce some more metaphors. They provide different insights into our programming methods:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Growing software</strong></span></span></dt><dd><p>This relates to how we extend existing software, usually by adding new features. Bug fixing isn't growth: It is tending to diseased parts of the code.</p><p>Our code does grow as we add to it, but programming is not a perfect analog of plant growth—we have far more control and influence over code growth than over a seedling. Code grows more like an oyster making a pearl: slowly, by the progressive accretion of small extra parts.</p></dd><dt><span class="term"><span class="strong"><strong>Evolving software</strong></span></span></dt><dd><p>Another common construction metaphor is the <span class="emphasis"><em>evolution</em></span> of software. We start with a single-celled code organism and gradually see it develop into a larger, more complex beast. This is an incremental process; the software develops through a number of evolutionary stages. However, there are a few key differences to biological evolution:<a class="indexterm" id="IDX-CHP-15-1185"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>We are the ones deliberately making changes; the software doesn't develop by itself.</p></li><li class="listitem"><p>We don't employ <span class="emphasis"><em>natural selection</em></span> to choose the best design. We have neither the time nor the inclination to develop many different variants of the same program.</p></li></ul></div><p>We do have the opportunity to iteratively improve the quality of our code, mimicing evolutionary development somewhat. We can use experience gained from previous releases to adapt the code to its natural habitat, ensuring its longterm survival.</p></dd></dl></div></div><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="software_rot"/>Software Rot</h1></div></div></div><div class="epigraph"><p>When you're green, you're growing. When you're ripe, you rot.<a class="indexterm" id="IDX-CHP-15-1186"/><a class="indexterm" id="IDX-CHP-15-1187"/><a class="indexterm" id="IDX-CHP-15-1188"/></p><div class="attribution"><span>--<span class="attribution">Ray Kroc</span></span></div></div><p>Bad things happen to good code. No matter how well you start, no matter how honorable your intentions, no matter how pure your design and how clean the first release's implementation, time will warp and twist your masterpiece. Never underestimate the ability of code to acquire warts and blemishes during its life.</p><p>There is a misconception that software only develops during its initial stages of life. The <span class="emphasis"><em>maintenance</em></span> phase of software development<sup>[<a class="footnote" href="#ftn.CHP-15-FN-1" id="CHP-15-FN-1">1</a>]</sup> is always the longest. It's where most of the overall effort goes—even if this effort is not scrunched into a compact ball, like the initial design and development work. B.W. Boehm, a respected computer science professor, observed that 40 to 80 percent of total development time is spent in maintenance. (Boehm 76)</p><p>Software is never expected to stand still after a release. There will always be odd faults to fix, no matter how much testing went on. Customers demand new features. Requirements change under the development team's feet. Assumptions that were made during development prove to be incorrect in the Real World and require adjustments. The upshot: More code is written <span class="emphasis"><em>after</em></span> the project is considered complete.</p><p>During the initial development stages, you can keep a firm grip on your code and play with it as much as you like within the available time constraints. After it has been released, you're more restricted. These restrictions may be practical:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Changes have to be minimized to reduce their impact on the carefully tested codebase.</p></li><li class="listitem"><p>Published APIs are already being used by clients, so they are harder to modify.</p></li><li class="listitem"><p>The UI is familiar to users and can't be changed gratuitously.</p></li></ul></div><p>The restrictions may also be psychological, based on the developers' (potentially erroneous) preconceptions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The code has always worked <span class="emphasis"><em>this</em></span> way, so we can't change it like <span class="emphasis"><em>that</em></span>.</p></li><li class="listitem"><p>It's too hard to revise the architecture at this late stage.</p></li><li class="listitem"><p>It's not worth the time or expense to make this modification properly now; the product won't be around for very much longer.</p></li></ul></div><p>The restriction might even be a simple lack of understanding—a maintenance programmer may not understand original author's mental model of the code; this leads to inappropriate modifications.</p><p>There is a fine line between maintaining an existing product and developing the next version. Where it lies is a moot point. But whatever you're doing, the original codebase gets modified—sometimes by the original author, often by someone else. This is where the rot sets in. It's a <span class="emphasis"><em>damned if you do, damned if you don't</em></span> scenario; whatever you do, the code will rot.</p><p>If you never touch the code again, if you don't keep it up to date with fixes and modifications, the program will degrade. In the worse case, it will stop working as the OS changes or its assumptions become outdated. The Y2K bug is a glorious example of this.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-2" id="CHP-15-FN-2">2</a>]</sup> Or the program will putrefy as competing solutions develop more features and gain more popularity. Untouched code slowly rots away.</p><p>If you do make extensions and fixes as the code grows, it might still rot. When fixing a fault, the programmer often introduces more faults as a side effect. Brooks found that as many as 40 percent of fixes introduced new faults. (Brooks 95) "The Programmer's Drinking Song" (sung to the tune of "99 Bottles of Beer on the Wall"), written by a minstrel unknown, sums this up neatly:<a class="indexterm" id="IDX-CHP-15-1190"/></p><div class="blockquote"><blockquote class="blockquote"><p>99 little bugs in the code, 99 bugs in the code,</p><p>Fix one bug, compile it again, 101 little bugs in the code.</p><p>(Repeat until BUGS == 0)</p></blockquote></div><p>Even bug-free modifications can cause code turmoil. Quick-and-dirty fixes pile atop one another, putting nail after nail into the original design's coffin, making future maintenance harder. The plant analogy is useful here: If more heavy branches grow at the top and nothing is reinforcing the trunk, the entire codebase becomes less stable. Eventually, and inevitably, it totters over. Healthy plants don't grow like that; why should we expect our code to?</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Be aware of how easily code degrades as it is modified. Don't be satisfied with changes that leave the system in a worse state</em></span>.</p></dd></dl></div><p>Does all this sound unduly pessimistic? Surely code won't rot if you're careful? Perhaps, but adequate care is not taken in today's software factories. It's a culture thing. Fixes must be quick and cheap. Programs have a habit of hanging around longer than they were ever intended to. Many quick hacks live on, well past their expected lifetimes.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-1" id="ftn.CHP-15-FN-1">1</a>] </sup>That is, work done after initial delivery that isn't considered a major new release.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-2" id="ftn.CHP-15-FN-2">2</a>] </sup>Many old programs were never expected to be operational in the year 2000, so programmers considered it safe to encode years in two digits—<code class="literal">76</code> rather than <code class="literal">1976</code>. As the digits rolled over to <code class="literal">00</code>, all their date calculations went awry.<a class="indexterm" id="IDX-CHP-15-1189"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_warning_signs"/>The Warning Signs</h1></div></div></div><p>Switch on your code radar, and constantly look out for rotten code. Beware of the telltale signs: Rot sets in with any change that leads to a lack of clarity or that makes the system more complex. Unnecessary complexity comes in many guises.<a class="indexterm" id="IDX-CHP-15-1191"/><a class="indexterm" id="IDX-CHP-15-1192"/></p><p>Here are some, the flashing red lights and Klaxon calls:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The code is littered with many large classes and convoluted functions.</p></li><li class="listitem"><p>Function names are cryptic or misleading. Functions have suprising side effects not implied by their names.</p></li><li class="listitem"><p>There is no structure: It's not clear where to look for a certain bit of functionality.</p></li><li class="listitem"><p>There is duplication: Many separate bits of code crop up to do the same thing.</p></li><li class="listitem"><p>There is high coupling: Complex module interconnections and dependencies mean that a small change in one place ripples out across the entire code, even into seemingly unrelated modules. (See "<a class="xref" href="ch13s04.html#modularity" title="Modularity">Modularity</a>" on page 247).</p></li><li class="listitem"><p>As data flows through the system it is repeatedly converted between different representations (e.g., display data is transferred between <code class="literal">std::string</code>, <code class="literal">char*</code>, Unicode, UTF-8, and back again).</p></li><li class="listitem"><p>APIs become blurred; once neat interfaces are now far too broad in scope, with new features being thoughtlessly added.</p></li><li class="listitem"><p>APIs change rapidly between code revisions.</p></li><li class="listitem"><p>Bits of private implementation leak out of public APIs to enable other quick hacks.</p></li><li class="listitem"><p>The code is littered with work-arounds: fixes for symptoms but not for causes. They hide the real problems. The edges of the system are cluttered with these, leaving faults lurking at the core.</p></li><li class="listitem"><p>There are functions with enormous parameter lists. Many don't use these parameters, passing them through to subordinate function calls.</p></li><li class="listitem"><p>You find code that's too scary to even think about improving. You have no idea if you'll improve it, break it subtly, or make it even worse.</p></li><li class="listitem"><p>New features are added with no supporting documentation; the existing documents are out of date.</p></li><li class="listitem"><p>The code compiles noisily, with many warnings generated.<a class="indexterm" id="IDX-CHP-15-1193"/><a class="indexterm" id="IDX-CHP-15-1194"/></p></li><li class="listitem"><p>You find comments saying, <span class="emphasis"><em>Don't touch this</em></span>. . . .</p></li></ul></div><p>Many of these forms of rot are particularly visible in the code and can be seen with a quick inspection or using certain tools. However, there is a class of more subtle, invisible degradations that usually manifest at a higher level than syntactic gunk. Modifications that fudge the original code architecture or that subtly circumvent program conventions are much harder to spot until you're deeply immersed immersed in the system.<a class="indexterm" id="IDX-CHP-15-1195"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Learn to detect putrid code. Know the warning signs and handle rotten code with the utmost care</em></span>.</p></dd></dl></div><p>Why do we make such a big mess of code? The answer is simple: <span class="emphasis"><em>complexity</em></span>. A program is a huge collection of information organized on many levels: the architecture, its component design, the interfaces, the implementation of each bit of code, and so on. That's a lot to understand before you start work on a project. With tight deadlines, there isn't enough time to work out how a few lines actually work, let alone how they fit into the overall picture. We haven't yet learned to manage this vast complexity.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="how_does_code_grow_question"/>How Does Code Grow?</h1></div></div></div><p>No code development ever follows the classic model of lock down all requirements, design completely, code completely, integrate, test, release. Unexpected modifications happen to an existing codebase. New pieces are grafted in somehow. It's an incremental development cycle toward ever shifting goalposts.<a class="indexterm" id="IDX-CHP-15-1196"/><a class="indexterm" id="IDX-CHP-15-1197"/></p><p>Code growth happens by one of the following mechanisms, loosely ranked in order of disgust:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Luck</strong></span></span></dt><dd><p>This is the most frightening way to make code, and far too common. Code that grows by luck never had any design. It was modified without thought. Its structure is down to happenstance, and it's a miracle it works at all.</p><p>Even if your code originally <span class="emphasis"><em>was</em></span> designed carefully, maintenance modifications can follow this happy-go-lucky approach. Hit-and-hope fixes may just mask the immediate problem and make the real fix harder later on.</p></dd><dt><span class="term"><span class="strong"><strong>Accretion</strong></span></span></dt><dd><p>We need to add a new feature. Doing it properly would involve ripping up the interfaces between a few key modules and revising a lot of code. There's no time to do all this and, even if we did, it would probably still be too complicated. We'll just graft on another clump of code. It'll hang off one of the existing modules—well, perhaps a few of them—and use its own special back door interface to talk to them. We'll have something working really quickly.</p><p>Okay, it's a monstrous kludge. Oh, and the performance will be awful. And the modules will no longer have clear roles and responsibilities. There won't be a neat design anymore, and maintaining it in the future will be a nightmare. But we'll get this version out quickly, and we don't have any time to do it the right way now, anyway.</p><p>Maybe we'll come back later and do it properly. . . .</p></dd><dt><span class="term"><span class="strong"><strong>Rewrite</strong></span></span></dt><dd><p>When you recognize that the code you're working on is truly awful—unintelligible, fragile, and inextensible—it needs a rewrite. Based on prior experience, a rewrite is often quicker and safer than hacking at the original mess. However, rewrites are rarely done. It takes courage and vision.</p><p>Rewrites get riskier as you attack more code at once. Rewriting a whole product is a different prospect from rewriting a troublesome function or class. Good modularity and separation of concerns means that you needn't rewrite the whole system, just the module you're working on, keeping its original interface. If the interface is terrible, or you need to rewrite because the system isn't actually modular enough, then a lot more work is involved.<a class="indexterm" id="IDX-CHP-15-1198"/></p><div class="sidebar"><a id="doubling_up"/><p class="title"><b>DOUBLING UP</b></p><p>The software had reached a major crossroad. There wasn't much future in the existing codebase—it really needed to be rewritten. Finally the management accepted this fact, and a plan was formed. The developers were split into two teams. Some continued to hack away at the existing codebase to try and limp it along for just a bit longer. The rest of the programmers got to start the entire application again from scratch.</p><p>One task was glamorous: devising a sleek new design with interesting implementation challenges and the chance to work on a fresh, cruft-free codebase. The other task was menial: patching up holes in a sinking ship until the new cruise liner was ready (at which time all the old work would be left for scrap). Which team would you rather have been on?</p><p>Not surprisingly, this led to a build up of resentment and frustration and a rivalry between the teams. Many programmers relegated to the old application asked to change projects or left the company to seek greener pastures. The work on the old codebase was second rate, as it was the second-rate project.</p></div></dd><dt><span class="term"><span class="strong"><strong>Refactor</strong></span></span></dt><dd><p>A formalized cousin of rewrite. If your code is mostly okay, but bits of it need some work, you can <span class="emphasis"><em>refactor</em></span> these unpleasant parts. Refactoring is a process of making small changes to a body of code in order to improve its internal structure without changing its external behavior. It improves the design so that you can work with it more easily in the future. It's not about performance improvement, just design enhancement. Not as drastic as a complete rewrite, refactoring is a series of gentle massages of what you already have.<a class="indexterm" id="IDX-CHP-15-1199"/></p><p>This is a fancy name for particular kinds of code modification. Martin Fowler has formalized it, documenting a number of small, understandable code refinements. (Fowler 99)</p></dd><dt><span class="term"><span class="strong"><strong>Design for growth</strong></span></span></dt><dd><p>You'll often have an idea how your code will expand in the future; perhaps some features have been deferred until the next release. You can carefully design the system so that it's easy to make these future additions. Most of the time, this won't make the design work much harder.<a class="indexterm" id="IDX-CHP-15-1200"/></p><p>Even if you don't know the set of future additions, careful design affords room for growth. An extensible system provides hinge points for new functionality to be plugged in. Be careful that this isn't an exercise in chasing the wind, though,<sup>[<a class="footnote" href="#ftn.CHP-15-FN-3" id="CHP-15-FN-3">3</a>]</sup> trying to guess the future when you don't have a clue how the system will expand. Extensibility comes at the cost of complexity. If you correctly guess where this complexity is needed, you win; if you guess incorrectly, then you'll make an unnecessarily complicated system. This is the danger of <span class="emphasis"><em>over-design</em></span>, and it's especially likely when design occurs by committee.<a class="indexterm" id="IDX-CHP-15-1201"/><a class="indexterm" id="IDX-CHP-15-1202"/></p><p>There is a school of thought, exemplified in Extreme Programming, that insists on the absolute simplest design that can possibly work in any given situation. This could be at odds with the design for growth mentality (depending on how malleable the initial simple design is). Exactly how much design for growth you should employ can be a hard—but important—balance to strike.</p><div class="sidebar"><a id="chaos_theory"/><p class="title"><b>CHAOS THEORY</b></p><p>Code is obviously shaped by design, but the organization that built it and its life history also play a large role. Years ago, I joined a project with particularly disgusting user interface code. It worked (usually), but was unfathomable, an intense lump of intertwining logic with no discernible architecture and labyrinthine paths of execution. And it was like that for a reason: history.</p><p>The code was initially created as a simple one-off television UI for a single customer, with minimal specifications. Successfully built, it served its purpose well. Sadly, the story didn't end there.</p><p>It was then sold to a second customer, who wanted it to look different. A second skin (visual appearance) was hacked on. Then it was sold to another customer in a different country. Internationalization was bolted on, with another skin. Then it was sold to a third customer, who wanted some new UI facilities—these were shoehorned in. This story continued. For a long time. Today the UI is unrecognizable from its former self, and it's now also unmaintainable: Each addition has been a quick hack since the whole thing was always a temporary system.</p><p>If the initial design had incorporated all these features, then the code would still be lean and logical. However, it would have been far too much work up front, and the company would never have started the project. Pity the poor programmers that work under these Real World conditions.</p></div></dd></dl></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-3" id="ftn.CHP-15-FN-3">3</a>] </sup>Ecclesiastes 2:11</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="believe_the_impossible"/>Believe the Impossible</h1></div></div></div><p>Perhaps the reason we see so much bad code and so many dirty hacks is the mistaken belief that it takes longer to do the job properly. When you factor in the time spent debugging and the ease of making later modifications, this proves to be a false assumption. You may be able to close a single fault report quickly by hacking out a fix, but it's not a good solution. True craftsmen take responsibility for what they do to code.<a class="indexterm" id="IDX-CHP-15-1203"/></p><p>In the corporate world, there is often a management expectation of quick fixes. It's reasonably easy to show a manager that a five-ton block of concrete stuck on top of a flimsily erected flagpole won't stay up for verylong. It's harder to make him stand underneath the thing. And it's <span class="emphasis"><em>much</em></span> harder to get the same message across when we're talking about software. Managers just don't get it. As far as they're concerned, programmers are magicians who practice dark mystical arts and have limitless powers. Tell them what to do, provide a deadline, and it will happen, however many all-night coding sessions are required.</p><p>Being gifted and dedicated, sometimes we meet these expectations. This actually makes matters worse, as management now expects that this tactic will always work. Worse, they assume that it's <span class="emphasis"><em>our</em></span> fault when it doesn't. Sadly, there comes a time when hastily hacked software just cannot be made to expand any more, when it really just wants to keel over and find its final resting place in a quiet corner somewhere. Management will not be happy.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-4" id="CHP-15-FN-4">4</a>]</sup></p><p>Code growth is easier if the company's culture is to develop software in small incremental steps (see "Iterative" on page 245 and "<a class="xref" href="ch22s03.html#iterative_and_incremental_development" title="Iterative and Incremental Development">Iterative and Incremental Development</a>" on page 432). This way, evolution is built into the design strategy, and rewriting code to accommodate change is expected. The alternative, when you have to attack a monolithic code edifice with a small pickaxe in 20 seconds flat, is unreasonable—but not unusual.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-4" id="ftn.CHP-15-FN-4">4</a>] </sup>Of course this is a gross generalization, but not too inaccurate. Many managers used to be programmers themselves and understand the tensions. A good manager listens to the programmers' objections. A good programmer will make his or her boss listen. Too often, neither happens, and the software suffers.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_can_we_do_about_this_question"/>What Can We Do About This?</h1></div></div></div><div class="epigraph"><p>God grant me the serenity to accept the things I cannot change, the courage to change the things I can, and the wisdom to know the difference.</p><div class="attribution"><span>--<span class="attribution">Reinhold Niebuhr</span></span></div></div><p>Now that we've identified some of the problems of an evolving codebase, how do we manage the mess? What strategies can we adopt to avoid this?</p><p>The first and most important step is to recognize the problem. Too many programmers hack away without thinking about the quality of their code. As long as they silence the users' screams in the shortest time possible, they don't care what state they leave the code in. Someone else can deal with it next time.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Code conscientiously. Good programmers care more about how their code will look after a few years' work than how much effort it takes to write now</em></span>.</p></dd></dl></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="writing_new_code"/>Writing New Code</h2></div></div></div><p>Before we think about how to work with <span class="emphasis"><em>legacy</em></span> (existing) code, here are a few tactics for creating brand-new code that will greatly aid later maintenance:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Consider the interconnection of modules, and reduce coupling as much as possible. Avoid having one central module that every other module depends on; a change there will affect every other module in the system.</p></li><li class="listitem"><p>Modularity and information hiding (see page "<a class="xref" href="ch13s04.html#modularity" title="Modularity">Modularity</a>" on page 247) are the cornerstones of modern software engineering. Isolate any likely changes to a small part of the system, making your system more viscous and therefore stable under change.</p></li><li class="listitem"><p>Extension and malleability need to be designed in—but, as we've seen, not at the expense of complexity. Modern component/object based paradigms promise greater reuse and extensibility. They give clear interface points between code modules. However, if the interfaces don't support later extension, then the code can't grow. Think very carefully about your system interfaces as you create them.</p></li><li class="listitem"><p>Write neat, clear code that can easily be understood and worked with, accompanied by good documentation and well-defined, clearly named APIs. Consider literate programming tools to document interfaces.</p></li><li class="listitem"><p><span class="emphasis"><em>KISS</em></span>. That is, <span class="emphasis"><em>Keep It Simple, Stupid</em></span>. Don't over-complicate; don't over-engineer. Optimize an algorithm only when you <span class="emphasis"><em>know</em></span> that there are performance issues, not just because you think you know a good way to make code run faster. Simplicity is nearly always more desirable than performance, and it certainly makes later maintenance easier.<a class="indexterm" id="IDX-CHP-15-1204"/><a class="indexterm" id="IDX-CHP-15-1205"/></p></li></ul></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Write new code with a view to its modifiability. Make it readable, extensible, and simple</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="maintenance_of_existing_code"/>Maintenance of Existing Code</h2></div></div></div><p>Maintaining <span class="emphasis"><em>good</em></span> code requires a different battle plan than maintaining <span class="emphasis"><em>bad</em></span> code. With the former, you must carefully preserve the integrity of the design and ensure that you don't introduce anything out of place. With the latter, you must try to not make the mess any worse and, if possible, improve things on your way through. If you can't rewrite the offending code, a little refactoring will go a long way.<a class="indexterm" id="IDX-CHP-15-1206"/><a class="indexterm" id="IDX-CHP-15-1207"/><a class="indexterm" id="IDX-CHP-15-1208"/><a class="indexterm" id="IDX-CHP-15-1209"/><a class="indexterm" id="IDX-CHP-15-1210"/><a class="indexterm" id="IDX-CHP-15-1211"/><a class="indexterm" id="IDX-CHP-15-1212"/><a class="indexterm" id="IDX-CHP-15-1213"/></p><p>Before you touch any code, these organizational issues should be considered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Prioritize</em></span> any changes that are needed. Balance the importance of each task against its complexity, and decide which should be done first. What early changes will have an impact on later work?</p></li><li class="listitem"><p>Only change what's necessary. <span class="emphasis"><em>If it ain't broke, don't fix it</em></span>. Don't gratuitously "improve" bits of code because you think they need it—only make the changes that are really required. Refactor the bad code you need to work with. Give the rest a wide berth.</p></li><li class="listitem"><p>Monitor how many modifications are being made at once. Making several parallel modifications <span class="emphasis"><em>yourself</em></span> is either incredibly clever or foolish; most likely the latter. Do one thing at a time. Carefully.</p><p>If several people are working on the code at once, be aware of what's changing around you. There is a danger of too many separate hacks causing odd conflicts. Methodical change by a single developer gives clearest visibility of where the code is being stretched and where the most care is needed. Several simultaneous modifications might stretch the code thin without anyone understanding or noticing.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Manage changes carefully. Make sure you know who else is trying to modify code near where you're working</em></span>.</p></dd></dl></div></li><li class="listitem"><p>Just as the initial code should be reviewed during its development, subsequent changes should also be reviewed. Organize formal reviews, and try to include the code's original author and reviewers. It's very easy to introduce subtle new bugs with small code extensions; reviews will catch many of these errors.<a class="indexterm" id="IDX-CHP-15-1214"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Review sensitive changes, especially in the run-up to a release. Even the simplest change can break other code</em></span>.</p></dd></dl></div><p>Once at the codeface, how do we tackle existing source? Here are practical suggestions:</p></li><li class="listitem"><p>To make good modifications, you must be informed about the code you're working on. Before you modify a file or code module, understand:<a class="indexterm" id="IDX-CHP-15-1215"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Where it sits within the whole system</p></li><li class="listitem"><p>What interdependencies it has (i.e., which components might be affected by your change)</p></li><li class="listitem"><p>What assumptions were made when the code was created (hopefully documented in the code's specifications)</p></li><li class="listitem"><p>The history of modifications that have already been made</p></li></ul></div><p>Inspect the code's quality. This is surprisingly easy to do, and rapidly gives you a sense of how easy the code is going to be to work with. You may find it helpful to use tools that visualize the code and generate quality metrics; this will highlight where hidden gotchas could be lurking. Collate all relevant documentation.<a class="indexterm" id="IDX-CHP-15-1216"/><a class="indexterm" id="IDX-CHP-15-1217"/><a class="indexterm" id="IDX-CHP-15-1218"/></p></li><li class="listitem"><p>Adopt the correct attitude—avoid the <span class="emphasis"><em>just one more hack</em></span> mentality. Don't dismiss code, thinking that it will be thrown away or rewritten in the future. It won't be.</p><p>Be constantly aware of the warning signs cataloged in "<a class="xref" href="ch15s02.html" title="The Warning Signs">The Warning Signs</a>" on page 282. If your modification moves the codebase nearer to one of those states, refactor the code to alleviate the problem. Take responsibility for these problems.</p><p>Be prepared to do some redesign work. Don't be afraid to unpick the code and perform major surgery when necessary. Sometimes a modification will be costly right now (in terms of your time and effort), but the investment will pay off later: Future work with the code will be much, much easier. For legacy code, this may be considered uneconomical. Sadly, it's legacy code that makes cash and is unlikely to be phased out. If you know that you'll be working on a section of code a lot in the future, make sure that the code structure will support future extension.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Don't mindlessly fiddle with code. Step back and look at what you're doing</em></span>.</p></dd></dl></div></li><li class="listitem"><p>Try not to introduce extra dependencies with newly added code. An increase in coupling makes code more complicated and harder to change next time.</p></li><li class="listitem"><p>When maintaining any code, retain the programming style of the source files you are working with, even if it's not your favorite style or the house style. A file with code in several formats is confusing and hard to work with. Apply presentation tidy-ups as you go if they're not too gratuitous, but be aware that source code diffs across versions will be harder if you do so. Maintain the comments around the code you're working on (see "<a class="xref" href="ch05s07.html#maintenance_and_the_inane_comment" title="Maintenance and the Inane Comment">Maintenance and the Inane Comment</a>" on page 86).<a class="indexterm" id="IDX-CHP-15-1219"/></p></li><li class="listitem"><p>Use the code's test suite to check that you don't break anything. Exhaustive regression testing is the only real way to have confidence in the changes you've made.<a class="indexterm" id="IDX-CHP-15-1220"/><a class="indexterm" id="IDX-CHP-15-1221"/></p><p>Ensure that you have an adequate test suite, and run it regularly.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Carefully test any modification you make, no matter how simple. It's really easy for silly faults to slip past unnoticed</em></span>.</p></dd></dl></div></li><li class="listitem"><p>If you are fixing a fault, do you really understand the cause? Write a test harness to trigger it; this demonstrates your understanding and will prove that you have made the fix. Add it to the suite of regression tests.</p><p>Once you have made a successful fix, look around the codebase for similar faults. This overlooked step can make a big difference: Many problems hang around in packs, and it's much easier to defeat them in one crushing blow than to slowly chip away as they each individually manifest.</p></li><li class="listitem"><p>If you make a bad change, back it out quickly. Don't litter code with unnecessary dead wood.</p></li></ul></div><p>As a code craftsman, you should always shy away from the pressure to do a quick bodge job. Strive to make careful, considered changes. Unfortunately, we don't work in ivory towers, and compromise is sometimes required on the battle front; it's not always commercially feasible to complete a task in the theologically correct way.</p><p>This explains why so much code is brittle, flaky, and dangerous. But it also explains why there's any code out there at all. If there wasn't the commercial drive to get software shipped, programmers would spend forever tweaking their software to get it just right, writing and rewriting. The company would have collapsed around them long before they'd finished.</p><p>However, don't introduce pragmatic (but distasteful) modifications without a plan to fix them at a later date. Place a tidy-up task on the development schedule.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id14"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>Change in all things is sweet.<a class="indexterm" id="IDX-CHP-15-1222"/><a class="indexterm" id="IDX-CHP-15-1223"/><a class="indexterm" id="IDX-CHP-15-1224"/></p><div class="attribution"><span>--<span class="attribution">Aristotle</span></span></div></div><p>I'm not sure that I agree with Aristotle. Change can be a real pain in the rear end. We should manage code changes carefully. Then a good program will evolve into something greater, rather than degrade into an unstable mess.</p><p>It's important to maintain software well and expand it correctly, preserving the code design and making sympathetic modifications. Don't expect maintenance to be easy. You may need to invest a lot of time to rewrite, redesign, or refactor.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id14"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch17.html" title="Chapter 17. TOGETHER WE STAND">Chapter 17</a></span></dt><dd><p>We build and maintain software as a team. Team dynamics inevitably affect the final shape of your code.</p></dd><dt><span class="term"><a class="xref" href="ch18.html" title="Chapter 18. PRACTICING SAFE SOURCE">Chapter 18</a></span></dt><dd><p>A history of your code's development is recorded in the <span class="emphasis"><em>revision control system</em></span>.</p></dd><dt><span class="term"><a class="xref" href="ch22.html" title="Chapter 22. RECIPE FOR A PROGRAM">Chapter 22</a></span></dt><dd><p>The software development lifecycle: the procedures we follow to create and grow software.</p></dd></dl></div><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Write maintainable software with clean structure and logical layout</p></li><li class="listitem"><p>Recognize and are prepared to deal with bade code</p></li><li class="listitem"><p>Try to understand as much of the code and the author's original mental model as possible, prior to working on it</p></li><li class="listitem"><p>Care about the quality of code they're working on; they refuse to clumsily patch code</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Create complex code without thinking about the needs of maintenance programmers</p></li><li class="listitem"><p><span class="emphasis"><em>Avoid</em></span> maintaining old code, preferring to ignore problems rather than fix them</p></li><li class="listitem"><p>Favor an easy patch over thinking about a good solution</p></li><li class="listitem"><p>Litter code with quick and dirty hacks; they employ every shortcut they can find</p></li><li class="listitem"><p>Focus attention in the wrong places, tinkering with code that didn't actually need to be fixed</p></li></ul></div>
</td></tr></tbody></table></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e21793"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207506.png"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id15"/>Get Thinking</h1></div></div></div><p>A detailed discussion of the following questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 527.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id14"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>What is the best metaphor for software growth?</p></li><li class="listitem"><p>Looking at a program's development through the colorful lifetime metaphor I talked about in the introduction, what Real World events correspond to a program's:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Conception</p></li><li class="listitem"><p>Birth</p></li><li class="listitem"><p>Growth</p></li><li class="listitem"><p>Coming of age</p></li><li class="listitem"><p>Sending out into the Big Wide World</p></li><li class="listitem"><p>Middle age</p></li><li class="listitem"><p>Growing tired</p></li><li class="listitem"><p>Retirement</p></li><li class="listitem"><p>Death</p></li></ul></div></li><li class="listitem"><p>Is there a limit to software life—how long can you keep developing and working on a program before you have to start afresh?</p></li><li class="listitem"><p>Does the size of a codebase correspond to the maturity of the project?</p></li><li class="listitem"><p>How important is <span class="emphasis"><em>backward compatibility</em></span> when maintaining code?</p></li><li class="listitem"><p>Is code likely to rot more quickly if you alter it or if you leave it alone?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id14"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Is the majority of the code you write brand new or a modification of existing source?<a class="indexterm" id="IDX-CHP-15-1225"/><a class="indexterm" id="IDX-CHP-15-1226"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If it's brand-new code, do you create entirely new systems or new extensions to existing systems?</p></li><li class="listitem"><p>Does this affect <span class="emphasis"><em>how</em></span> you write? In what ways?</p></li></ol></div></li><li class="listitem"><p>Do you have experience of working with preexisting codebases? If so:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How has it shaped your current skill set? What lessons did you learn?</p></li><li class="listitem"><p>Was it predominantly good or bad code? What did you have to judge it against?</p></li></ol></div></li><li class="listitem"><p>Have you ever made changes that degraded the quality of code? Why?</p></li><li class="listitem"><p>How many revisions has your current project gone through?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How much changed functionally between revisions? How did the code change?</p></li><li class="listitem"><p>Has it grown by <span class="emphasis"><em>luck</em></span>, by <span class="emphasis"><em>design</em></span>, or something between the two? How is this evident now?</p></li></ol></div></li><li class="listitem"><p>How does your team safeguard code so that it can't be changed by more than one programmer at once?</p></li></ol></div></div></div></body></html>