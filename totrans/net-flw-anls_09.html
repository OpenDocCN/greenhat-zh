<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;EDGES AND ANALYSIS"><div class="titlepage"><div><div><h1 class="title"><a id="edges_and_analysis"/>Chapter 9. EDGES AND ANALYSIS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject9_d1e15213"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages651574.png.jpg"/></div></div><p>With the tools I've discussed throughout this book, you can analyze and present your data in just about any way you might need. In this chapter, you'll consider a couple of similar systems and learn how to connect them to your flow collector. Then you'll look at a couple of common use cases that illustrate what you can accomplish with flow analysis.</p><div class="sect1" title="NetFlow v9"><div class="titlepage"><div><div><h1 class="title"><a id="netflow_v9"/>NetFlow v9</h1></div></div></div><p>NetFlow version 9 is mostly used for IPv6 (although it can be extended to include other types of information as well) and is only rarely deployed. Although most NetFlow sensors support multiple versions, such as 5 or 7 in addition to 9, a few manufacturers make hardware that speaks only version 9. When version 9 becomes more widely used, flow-tools and its brethren will probably develop support for it. Until that time, however, how can you cope with NetFlow version 9 data?<a class="indexterm" id="IDX-CHP-9-0001"/></p><p>Other free flow collectors accept version 9 flows. You can translate version 9 data into flow-tools format. I'll show how to use <code class="literal">flowd</code><sup>[<a class="footnote" href="#ftn.CHP-9-FN-1" id="CHP-9-FN-1">11</a>]</sup> (<a class="ulink" href="http://www.mindrot.org/projects/flowd/">http://www.mindrot.org/projects/flowd/</a>), by the author of <code class="literal">softflowd</code>. To transform your data into a <code class="literal">flow-capture</code> record file, you first need to install <code class="literal">flowd</code>.<a class="indexterm" id="IDX-CHP-9-0002"/><a class="indexterm" id="IDX-CHP-9-0003"/><a class="indexterm" id="IDX-CHP-9-0004"/><a class="indexterm" id="IDX-CHP-9-0005"/><a class="indexterm" id="IDX-CHP-9-0006"/><a class="indexterm" id="IDX-CHP-9-0007"/></p><div class="sect2" title="Installing flowd"><div class="titlepage"><div><div><h2 class="title"><a id="installing_flowd"/>Installing flowd</h2></div></div></div><p>If your operating system includes a <code class="literal">flowd</code> package, use it. If not, you should install <code class="literal">flowd</code>, but before you do, install the following software:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>BSD <code class="literal">yacc</code> (usually packaged as <code class="literal">byacc</code> on Linux systems)<a class="indexterm" id="IDX-CHP-9-0008"/></p></li><li class="listitem"><p>GNU <code class="literal">make</code></p></li></ul></div><p>Yes, that's GNU-style <code class="literal">make</code> plus BSD-style <code class="literal">yacc</code>.</p><p>The <code class="literal">flowd</code> software expects to run as the unprivileged user <span class="emphasis"><em>_flowd</em></span>. Create this user before building the software.</p><p>Once <code class="literal">yacc</code> and <code class="literal">make</code> are installed, build <code class="literal">flowd</code> much like you would flow-tools or <code class="literal">softflowd</code>. The <code class="literal">configure</code> script includes a variety of options. Here, I build and install <code class="literal">flowd</code> under <span class="emphasis"><em>/usr/local/flowd</em></span><code class="literal">:</code></p><a id="I_programlisting9_d1e15355"/><pre class="programlisting"># <strong class="userinput"><code>configure --prefix=/usr/local/flowd</code></strong>
# <strong class="userinput"><code>gmake</code></strong>
# <strong class="userinput"><code>gmake install</code></strong></pre><p>That's it! You should get a configuration file and the program itself.</p></div><div class="sect2" title="Configuring flowd"><div class="titlepage"><div><div><h2 class="title"><a id="configuring_flowd"/>Configuring flowd</h2></div></div></div><p>Where you control <code class="literal">flow-capture</code> with command-line arguments, <code class="literal">flowd</code> uses a configuration file. Most <code class="literal">flowd</code> configuration options are similar to options offered by <code class="literal">flow-capture</code>.</p><a id="I_programlisting9_d1e15384"/><pre class="programlisting">❶ logfile "/var/flow/router-v9/current"
❷ pidfile "/var/run/flowd.pid"
❸ listen on 0.0.0.0:6789
❹ flow source 192.0.2.1
❺ store ALL
❻ accept all</pre><p><code class="literal">flowd</code> stores flow records in the logfile at ❶. Like <code class="literal">flow-capture</code>'s <code class="literal">ft-</code> files, a <code class="literal">flowd</code> log is a compressed binary file that you cannot view directly. Like most other software, <code class="literal">flowd</code> records its process ID in a PID file, as shown at ❷. Most systems store PID files in the directory <span class="emphasis"><em>/var/run</em></span>.</p><p><code class="literal">flowd</code> must listen to the network, and at ❸ you specify an IP address and a UDP port, separated by a colon. If you were to use an IP of 0.0.0.0, <code class="literal">flowd</code> would listen for incoming flow data on all IP addresses on the system. To restrict the IP addresses <code class="literal">flowd</code> accepts flow data from, list a router's IP address as a flow source, as shown at ❹.<a class="indexterm" id="IDX-CHP-9-0009"/><a class="indexterm" id="IDX-CHP-9-0010"/><a class="indexterm" id="IDX-CHP-9-0011"/><a class="indexterm" id="IDX-CHP-9-0012"/><a class="indexterm" id="IDX-CHP-9-0013"/></p><p>Although <code class="literal">flowd</code> has comprehensive filtering features to let you record only certain types of flows, you tell <code class="literal">flowd</code> at ❺ to record everything and at ❻ to accept everything the sensor transmits.</p><p>Once you've finished editing your configuration file, start <code class="literal">flowd</code>, and tell your version 9 sensor to transmit data to this collector's IP address and port. When version 9 flow data arrives, <code class="literal">flowd</code> should record it in the logfile. Once you see the logfile grow larger, it's time to convert data to flow-tools format.</p></div><div class="sect2" title="Converting flowd Data to Flow-tools"><div class="titlepage"><div><div><h2 class="title"><a id="converting_flowd_data_to_flow-tools"/>Converting flowd Data to Flow-tools</h2></div></div></div><p>NetFlow version 9 includes the information expected in a NetFlow v5 record: source and destination addresses and ports, protocol numbers, packet counts, and so on. You need to automatically extract this information from the <code class="literal">flowd</code> log and import it into a <code class="literal">flow-capture ft-</code> file. Fortunately, Craig Weinhold's <code class="literal">flowd2ft</code> script does this for you. You can copy the script from the following listing or download it from <a class="ulink" href="http://www.networkflowanalysis.com/">http://www.networkflowanalysis.com/</a>. Let's look at it.</p><a id="I_programlisting9_d1e15468"/><pre class="programlisting">#!/usr/bin/perl
  # "flowd2ft" crontab script to move flowd capture files into flow-tools

  # -- flow-tools variables
  # where ft's flow-import is
❶ our $ftImport = "/usr/local/bin/flow-import";
  # put a copy of the flow file here, for flowscan
❷ our $ftDir = "/var/flow/router-v5/ft";
  # timezone for ft capture files
❸ our $ftTZ = "-0500";
  # seconds per ft capture file and cron interval
❹ our $ftPeriod = 300;

  # -- flowd variables
  # where flowd-reader is
❺ our $flowdReader = "/usr/local/bin/flowd-reader";
  # where flowd.conf is
❻ our $flowdConf = "/usr/local/etc/flowd.conf";
  # SIGUSR1
  our $flowdHup = "10";
  our ($flowdPid, $flowdLog);

  our ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
  localtime(time - $ftPeriod);
  our $ftFile = sprintf("ft-v05.%04d-%02d-%02d.%02d%02d%02d$ftTZ",
 $year + 1900, $mon + 1, $mday, $hour, $min, $sec);

❼   open(IN, $flowdConf) || die "Could not read $flowdConf";
  while ( &lt;IN&gt; ) {
          if (/^\s*logfile ["]?([^"\s]+)/) { $flowdLog = $1; }
          if (/^\s*pidfile ["]?([^"\s]+)/) { $flowdPid = $1; }
  }
  close(IN);

  exit if (! -f $flowdLog); # exit silently on empty file

  die "$flowdPid does not exist: $!" if (! -f $flowdPid);
  my $pid = `cat $flowdPid`;
❽  `mv $flowdLog $flowdLog.tmp`;
  die "$flowdPid ($pid) invalid: $!" if (! kill $flowdHup, $pid);
❾  `$flowdReader -c $flowdLog.tmp | $ftImport -f 2 -V 5 -z 1 &gt; $ftDir/$ftFile`;</pre><p>Before using this script, you'll need to set the configuration variables. At ❶ you hard-code the location of the <code class="literal">flow-import</code> program. At ❷ you point the script to the directory you want to use to store your created <code class="literal">flow-capture</code> files. At ❸ you give the script the time zone offset in minutes so that it can include that information in the filename just like <code class="literal">flow-capture</code> would. At ❹ you tell the script to create a new <code class="literal">ft-</code> file every 300 seconds, just as your usual <code class="literal">flow-capture</code> instances do.</p><p>The script also needs to know where the <code class="literal">flowd-reader</code> program (❺) is installed and where to find the <code class="literal">flowd</code> configuration (❻). At ❼ the script reads the <code class="literal">flowd</code> configuration file for the rest of its settings and then at ❽ moves the existing <code class="literal">flowd</code> file out of the way so that it can restart <code class="literal">flowd</code> and close the existing logfile. Finally, at ❾ it reads the freshly closed logfile and creates a new <code class="literal">flow-capture</code> file.</p><p>After configuring the script, run it once by hand. It should create a new <code class="literal">ft-</code> logfile in the destination directory and tell you how many flows it processed. If the script doesn't run correctly, check your settings and error and log messages. Once you're sure that your script is running properly, have your system run it every five minutes by making the appropriate entry in <code class="literal">cron</code>, as shown here:</p><a id="I_programlisting9_d1e15516"/><pre class="programlisting">*/5  *  *   *   *       /usr/local/bin/convert-flowd-ft.pl &gt; /tmp/convert.log</pre><p>You will now have flow records that are compatible with the rest of your flow reporting system. You can use these records to set up FlowScan, run <code class="literal">flow-report</code>, or do anything else you like.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-1" id="ftn.CHP-9-FN-1">11</a>] </sup>I seriously considered using <code class="literal">flowd</code> for this book, but it doesn't yet have the variety of canned reports that <code class="literal">flow-capture</code> supports. I expect this to change over time, however, and if you need an IPv6 flow collector and are comfortable writing reports in Perl or Python, you should consider <code class="literal">flowd</code>.</p></div></div></div>
<div class="sect1" title="sFlow"><div class="titlepage"><div><div><h1 class="title"><a id="sflow"/>sFlow</h1></div></div></div><p>sFlow is a flow export technology invented by InMon that competes with Cisco's NetFlow. Many vendors, such as HP and Extreme, offer equipment that exports sFlow but not NetFlow. No need to despair, though: You can translate sFlow packets into NetFlow version 5 data and feed that to flow-tools.<a class="indexterm" id="IDX-CHP-9-0014"/><a class="indexterm" id="IDX-CHP-9-0015"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>If you have a lot of sFlow-based equipment, however, you should really look into an sFlow reporting system. I recommend converting sFlow to NetFlow when you have an existing <code class="literal">flow-tools</code> setup and a couple of sFlow devices that you'd like to integrate into that system, not when you have a data center full of sFlow hardware.</p></div><div class="sect2" title="Configuring sFlow Export with sflowenable"><div class="titlepage"><div><div><h2 class="title"><a id="configuring_sflow_export_with_sflowenabl"/>Configuring sFlow Export with sflowenable</h2></div></div></div><p>Some sFlow sensors can be configured through the GUI or command line, but a few sFlow sensors require configuration via SNMP. Although you could manually use SNMP GET and SET commands to set up sFlow, the fine folks at InMon offer a script to automate this process for you. Grab a copy of <code class="literal">sflowenable</code> from <a class="ulink" href="http://www.inmon.com/technology/sflowenable/">http://www.inmon.com/technology/sflowenable/</a>.<a class="indexterm" id="IDX-CHP-9-0016"/><a class="indexterm" id="IDX-CHP-9-0017"/><a class="indexterm" id="IDX-CHP-9-0018"/><a class="indexterm" id="IDX-CHP-9-0019"/><a class="indexterm" id="IDX-CHP-9-0020"/></p><p><code class="literal">sflowenable</code> requires the net-snmp tools you probably already have installed on your network management workstation. It also requires GNU <code class="literal">awk</code>, also known as <code class="literal">gawk</code>. Some operating systems include <code class="literal">gawk</code> as the default <code class="literal">awk</code>; others have it as an add-on package. If <code class="literal">sflowenable</code> fails with cryptic <code class="literal">awk</code> errors, you have the wrong <code class="literal">awk</code>. Install <code class="literal">gawk</code>, and either edit the script to use <code class="literal">gawk</code> instead of <code class="literal">awk</code> or alias <code class="literal">awk</code> to <code class="literal">gawk</code> in your shell. Now say that three times fast.<a class="indexterm" id="IDX-CHP-9-0021"/></p><p>Running <code class="literal">sflowenable</code> requires the sensor hostname and a read-write SNMP community, the collector IP, and the UDP port you want to receive sFlow data on.</p><a id="I_programlisting9_d1e15619"/><pre class="programlisting">sflowenable.sh <em class="replaceable"><code>sFlow-sensor community collector_IP collector_port</code></em></pre><p>For example, to activate sFlow on the device bigSwitch, using the SNMP community LucasRulez, and to transmit the data to a sFlow collector on the host 192.0.2.15 on port 5515, I would run the following:</p><a id="I_programlisting9_d1e15625"/><pre class="programlisting"># <strong class="userinput"><code>sflowenable.sh bigSwitch LucasRulez 192.0.2.15 5515</code></strong></pre><p>You should see data coming to port 5515 on your collector almost immediately. But wait a minute—you have nothing that can listen to sFlow, let alone do anything with it! You'll handle that detail now.</p></div><div class="sect2" title="Convert sFlow to NetFlow"><div class="titlepage"><div><div><h2 class="title"><a id="convert_sflow_to_netflow"/>Convert sFlow to NetFlow</h2></div></div></div><p>The <code class="literal">sflowtool</code> program is a free sFlow collector, capture, and converter available from <a class="ulink" href="http://www.inmon.com/technology/sflowTools.php">http://www.inmon.com/technology/sflowTools.php</a>. Among its features, it can convert a sFlow data stream to NetFlow version 5 and send it to a NetFlow collector. This is perfect for these purposes.</p><p><code class="literal">sflowtool</code> is a simple program with no special prerequisites. Build it with the familiar <code class="literal">./configure</code>, <code class="literal">make</code>, <code class="literal">make install</code> routine you've used repeatedly.</p><p>To have <code class="literal">sflowtool</code> convert and retransmit data, you need a port to listen for sFlow connections, a <code class="literal">flow-capture</code> host, and the <code class="literal">flow-capture</code> port.</p><a id="I_programlisting9_d1e15665"/><pre class="programlisting">sflowtool -p <em class="replaceable"><code>sflow_port</code></em> -c flow-capture-host -d <em class="replaceable"><code>flow-capture-port</code></em> &gt; /dev/null &amp;</pre><p>In the earlier example, I assumed that you had a sFlow collector on port 5515. Let's assume you want to accept those sFlow packets, convert them to NetFlow, and retransmit them to a <code class="literal">flow-capture</code> instance running on the same host on port 5516. You would run <code class="literal">sflowtool</code> like this:</p><a id="I_programlisting9_d1e15681"/><pre class="programlisting">sflowtool -p 5515 -c localhost -d 5516 &gt; /dev/null &amp;</pre><p>Now configure a <code class="literal">flow-capture</code> instance to record the flow data, and you have data from your sFlow-only device with no local scripts or conversion routines necessary.<a class="indexterm" id="IDX-CHP-9-0022"/><a class="indexterm" id="IDX-CHP-9-0023"/><a class="indexterm" id="IDX-CHP-9-0024"/><a class="indexterm" id="IDX-CHP-9-0025"/></p></div></div>
<div class="sect1" title="Problem Solving with Flow Data"><div class="titlepage"><div><div><h1 class="title"><a id="problem_solving_with_flow_data"/>Problem Solving with Flow Data</h1></div></div></div><p>You've explored the usefulness of various flow analysis features throughout this book. Now you'll look at a few case studies of real problems and possible solutions. Some of these I've touched on earlier; others are completely new.</p><div class="sect2" title="Finding Busted Software"><div class="titlepage"><div><div><h2 class="title"><a id="finding_busted_software"/>Finding Busted Software</h2></div></div></div><p>Under normal circumstances, a small percentage of TCP connections break regularly on every network. Software stacks misbehave, clients try to connect to defunct printers, and users who ought to know better install freeware that behaves unspeakably. Perhaps the fastest way to use flow data to improve your network is to check for these broken connections, identify their sources and destinations, and discover what software on the affected machines is causing the problems. The following are two common groups of "broken" TCP connections:<a class="indexterm" id="IDX-CHP-9-0026"/><a class="indexterm" id="IDX-CHP-9-0027"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>SYN-only flows</strong></span></span></dt><dd><p>A machine attempts to connect to a remote host that doesn't answer.</p></dd><dt><span class="term"><span class="strong"><strong>RST-only flows</strong></span></span></dt><dd><p>A machine attempts to connect to a remote host that refuses the connection. You can write filters for each of these and report on them separately.</p></dd></dl></div><div class="sect3" title="Broken Connection Filters"><div class="titlepage"><div><div><h3 class="title"><a id="broken_connection_filters"/>Broken Connection Filters</h3></div></div></div><p>The following filters will capture these two types of broken TCP connection:</p><a id="I_programlisting9_d1e15742"/><pre class="programlisting">❶ filter-primitive syn-only
      type ip-tcp-flags
      permit 0x2
❷ filter-primitive rst-only
      type ip-tcp-flags
      permit 0x4

❸ filter-definition syn-only
      match ip-tcp-flags syn-only
❹ filter-definition rst-only
      match ip-tcp-flags rst-only</pre><p>Here you define a primitive for SYN-only flows at ❶, a corresponding filter at ❸, an RST-only primitive at ❷, and its matching filter at ❹.<a class="indexterm" id="IDX-CHP-9-0028"/></p></div><div class="sect3" title="Checking for Resets"><div class="titlepage"><div><div><h3 class="title"><a id="checking_for_resets"/>Checking for Resets</h3></div></div></div><p>Now use the <code class="literal">rst-only</code> filter on a sample of typical traffic.<a class="indexterm" id="IDX-CHP-9-0029"/><a class="indexterm" id="IDX-CHP-9-0030"/></p><a id="I_programlisting9_d1e15763"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat</code></strong> ❶ <strong class="userinput"><code>ft-v05.2010-01-22.10* | flow-nfilter -F rst-only | flow-report -v</code></strong> ❷
 <strong class="userinput"><code>TYPE=ip-address -v</code></strong> ❸ <strong class="userinput"><code>SORT=+flows</code></strong>
  ip-address      flows octets packets duration
❹ 192.0.2.184    1186   14880  372     100
  192.0.2.197     1186  14880  372     100
  198.22.63.8     39    1720   43      4
  72.21.91.20     23    920    23      0
  192.0.6.197     23    1920   48      16
  192.0.64.69     16    640    16      0
  ...</pre><p>Choose records from a time where you expect "typical" traffic. For example, if your office is open only from 9 <span class="keycap"><strong>am</strong></span> to 5 <span class="keycap"><strong>pm</strong></span>, the flow records from 2 <span class="keycap"><strong>am</strong></span> will not represent normal use (although they're probably interesting to look at separately). On my network, I'm analyzing records at ❶ from 10 <span class="keycap"><strong>am</strong></span> to 11 <span class="keycap"><strong>am</strong></span>.</p><p>You're hunting for machines that are either sending or receiving abnormally large numbers of SYN-only or RST-only flows. Although you might initially view the data with <code class="literal">flow-print</code>, what you really want is a list of IP addresses and the number of matching flows, as offered by the <code class="literal">ip-address</code> report at ❷. I want to sort in decreasing order, as shown at ❸. In this hour, the first two hosts have 30 times more RST-only flows than the host in third place, as you can see at ❹. Something isn't behaving well there.</p><p>The next step is to check a few more time windows to see whether this behavior is consistent or whether these two hosts were just having trouble at a particular time. Assuming that the behavior is consistent, take a closer look at the RST-only traffic from the first host. In this example, I'm using the <code class="literal">ip-addr</code> report created in <a class="xref" href="ch04.html" title="Chapter 4. FILTERING FLOWS">Chapter 4</a>, so I don't need to differentiate between source and destination addresses yet:</p><a id="I_programlisting9_d1e15809"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-v05.2010-01-22.10* | flow-nfilter</code></strong>
 <strong class="userinput"><code>-F rst-only | flow-nfilter -F ip-addr -v ADDR=192.0.2.184 | flow-print | less</code></strong>
srcIP            dstIP            prot  srcPort  dstPort  octets      packets
192.0.2.184      192.0.2.197      6     443      33171    80          2
192.0.2.184      192.0.2.197      6     443      17866    80          2
192.0.2.184      192.0.2.197      6     443      64447    80          2
192.0.2.184      192.0.2.197      6     443      60076    80          2
192.0.2.184      192.0.2.197      6     443      13839    80          2
...</pre><p>As you can see in the previous listing, each flow appears basically identical at first glance. The host 192.0.2.184 sends two TCP RSTs to 192.0.2.197, from port 443 to a high-numbered port. These are rejected HTTPS requests. If you were to view all traffic between these two hosts, you'd see that 192.0.2.197 makes HTTPS requests to 192.0.2.184, which then rejects them.</p><p>Running <code class="literal">flow-print</code> a second time with a format that includes timestamps, such as the following, shows that the client makes this request every few seconds:<a class="indexterm" id="IDX-CHP-9-0031"/><a class="indexterm" id="IDX-CHP-9-0032"/></p><a id="I_programlisting9_d1e15832"/><pre class="programlisting">flow-print -f 5</pre><p>The host 192.0.2.197 is running a piece of software that is broken or misconfigured. Now go ask the system administrator what's going on.</p><p>Note that my test network is fairly small. In an enterprise data center, you might find dozens of different software packages behaving badly; I've personally seen misconfigured software try to contact other hosts hundreds of times a second. Although TCP RSTs don't usually consume enough bandwidth to cause problems, resolving these problems makes the software more efficient, reduces hardware requirements, and might reduce network traffic and service delays in unexpected ways.</p></div><div class="sect3" title="Checking for Failed Connections"><div class="titlepage"><div><div><h3 class="title"><a id="checking_for_failed_connections"/>Checking for Failed Connections</h3></div></div></div><p>SYN-only flows show that a host requested a connection but nothing answered. Either the requested address is not on the network, the host at that address cannot answer the request, or the host is silently ignoring the request. Although you probably know whether your equipment is configured to silently ignore requests, identifying the first two types of hosts can be very useful. You'll identify IP addresses with high levels of SYN-only flows much like you checked for RST-only flows; only the filter changes.</p><a id="I_programlisting9_d1e15844"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-v05.2011-01-22.10* | flow-nfilter -F</code></strong>
 <strong class="userinput"><code>hamlin | flow-nfilter -F syn-only | flow-report -v TYPE=ip-address -v SORT=+flows</code></strong>
  ip-address      flows octets packets duration
❶ 192.0.2.13      8306  526240 16998   2390732
  118.126.4.66    256   10240  256     0
  112.110.75.169  224   40640  635     1828064
  192.0.2.158     193   24624  513     1430236
  192.0.2.233     158   24648  474     1421304
  ...</pre><p>In this report, once again you have a clear outlier: the host 192.0.2.13 shown at ❶ has many more SYN-only flows than any other host. To see why, look at that host's traffic using the same technique you used for a particular RST-only host, as shown here:</p><a id="I_programlisting9_d1e15854"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat ft-v05.2011-01-22.10* | flow-nfilter</code></strong>
 <strong class="userinput"><code>-F rst-only | flow-nfilter -F ip-addr -v ADDR=192.0.2.13 | flow-print | less</code></strong>
  srcIP            dstIP            prot  srcPort  dstPort  octets      packets
❶ 192.0.2.13       192.0.2.16       6     26064    24       64          1
❷ 192.0.2.13       192.0.2.16       6     26064    26       64          1
❸ 192.0.2.13       192.0.2.16       6     26147    27       64          1
❹ 192.0.2.13       192.0.2.16       6     26148    28       64          1
  192.0.2.13       192.0.2.16       6     26152    29       64          1
  192.0.2.13       192.0.2.16       6     26149    30       64          1
  192.0.2.13       192.0.2.16       6     26246    31       64          1
  192.0.2.13       192.0.2.16       6     26248    32       64          1
  192.0.2.13       192.0.2.16       6     26253    33       64          1
  ...</pre><p>As you can see, the host 192.0.2.13 repeatedly tries to contact 192.0.2.16, first on port 24 at ❶ and then port 26 (❷), port 27 (❸), port 28 (❹), and so on. This particular data shows that 192.0.2.13 is trying every port between 1 and 1024 on 192.0.2.16. The connection attempts then move to 192.0.2.17.</p><p>This activity is indicative of a port scanner. Remember, not all port scanners scan ports sequentially—the key is to look for the same IP being hit at many ports in a relatively brief time. If 192.0.2.13 is your security workstation and you habitually scan your own network, this might be normal behavior. However, worms and intruders also use port scanners to identify vulnerable targets. If you don't know why this machine is scanning the network, find out!<a class="indexterm" id="IDX-CHP-9-0033"/></p><p>One interesting thing in this output is that the port scan appears to skip port 25. Remember, you're checking for flows that reset immediately. If a host responds on a port, it won't appear on this list. In this case, 192.0.2.16 runs a mail server; viewing all the traffic between these hosts would show a flow to port 25 and an answering flow.</p><p>Investigating another IP with a high SYN-only count might produce results like these:</p><a id="I_programlisting9_d1e15873"/><pre class="programlisting">srcIP            dstIP            prot  srcPort  dstPort  octets      packets
221.194.136.17   192.0.2.158      6     35628    80       432         8
66.249.67.245    192.0.2.158      6     44008    80       240         4
221.194.136.17   192.0.2.158      6     35628    80       48          1
66.249.67.245    192.0.2.158      6     44008    80       60          1
65.55.207.118    192.0.2.158      6     52684    80       144         3
65.55.106.137    192.0.2.158      6     54180    80       144         3
65.55.106.185    192.0.2.158      6     21976    80       144         3
...</pre><p>Each of these different source IP addresses is trying to connect to 192.0.2.158, all on TCP port 80. A quick check shows that this machine is a web server, and it does answer requests on port 80. Why do you see these SYN-only flows?</p><p>If your network equipment is reporting a flow, it certainly delivered the packet to the network node because delivering packets is a much higher-priority task than flow reporting! In this particular case, removing the <code class="literal">syn-only</code> filter from the <code class="literal">flow-print</code> command showed that the web server answered thousands of requests. <code class="literal">flow-report</code> told you that this host had 193 SYN-only flows during the hour you checked, but the web server just didn't answer these 193 requests. Maybe it ran out of memory or CPU. Perhaps the network card was saturated, or the web server software was reloaded.</p><p>Graphing the times the SYN-only packets appeared might give some answers, especially when compared with a graph of the number of connections opened at that time or list of times the server performs internal maintenance. As the network administrator, all you can say is that during this hour users got a "Page Cannot Be Displayed" or some similar error 193 times. Is this acceptable in your environment and situation? Probably not.<a class="indexterm" id="IDX-CHP-9-0034"/><a class="indexterm" id="IDX-CHP-9-0035"/></p><p>The nice thing with this type of result is that you know what part of the delivery system failed. The network delivered the packets, and the web server didn't answer. If the web server administrator reports that he's getting complaints about network timeouts, you can provide evidence that the timeouts aren't actually network problems and offer suggestions on how to fix the issues.</p></div></div><div class="sect2" title="Identifying Worms"><div class="titlepage"><div><div><h2 class="title"><a id="identifying_worms"/>Identifying Worms</h2></div></div></div><p>If you're on an enterprise network, worms cause something worse than system trouble. They cause meetings. With management. And because your antivirus software probably kicked up desktop alarms as the worm tried to propagate, those meetings will probably include senior managers who will ask inconvenient questions about how you spend your time.</p><p>Your best response is to find the worm source as quickly as possible. For example, in spring 2009, my employer's antivirus systems began spewing warnings about infection attempts from the Conficker virus. At a global company with tens of thousands of desktops, manually identifying virus sources could take countless man-hours and would require cooperation across umpteen time zones and multiple language barriers. Even though I had flow data for only three plants out of dozens around the world, flow analysis identified the sources in about 15 minutes and spared most of those meetings.<a class="indexterm" id="IDX-CHP-9-0036"/></p><p>To find a worm, first identify the worm's propagation method. A few minutes on Google tells me that Conficker spreads through Microsoft's file-sharing port, on TCP/445. The worm probes every IP on its network to identify Windows hosts and infects any it finds. This is unusual behavior: Although many servers will receive connections from many different hosts, very few systems will try to reach every other host on a network.</p><p>You can use the <code class="literal">ip-source-address-destination-count</code> report to count the number of hosts a system tries to contact, as shown here:</p><a id="I_programlisting9_d1e15918"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat</code></strong> ❶ <strong class="userinput"><code>ft-v05.2009-05-29.* | flow-nfilter -F ip-port -v</code></strong> ❷
 <strong class="userinput"><code>PORT=445 | flow-report -v</code></strong> ❸
 <strong class="userinput"><code>TYPE=ip-source-address-destination-count -v OPTIONS=-header -v</code></strong> ❹
 <strong class="userinput"><code>FIELDS=-duration,-packets,-octets |</code></strong> ❺
 <strong class="userinput"><code>sort -rnk 2 | less</code></strong>ip-source-address ip-destination-address-count flows
❻ 172.17.84.14      1851                         1711
❼ 172.17.84.13      1591                         1483
❽ 172.19.11.65      59                           225
  172.19.11.8       44                           60
  172.19.11.4       17                           38
  ...</pre><p>As you can see, I begin at ❶ with the flow files for the time window when the worm attacked my local network. I then search at ❷ only for the flows going to or from port 445, and I run these flows through the <code class="literal">ip-source-address-destination-count</code> report at ❸. Unnecessary fields are removed at ❹ to make the output easier to read.<a class="indexterm" id="IDX-CHP-9-0037"/><a class="indexterm" id="IDX-CHP-9-0038"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Remember that this report and its counterpart, <code class="literal">ip-destination-address-source-count</code>, do not have built-in sorting functions. You must sort these externally, as shown at ❺. (One consequence of sorting externally is that the header for each column appears at the bottom of the list. I've restored the header to the top of this example to make it easier to understand. Do the same for your managers.)</p></div><p>This report reveals two hosts that try to connect to a remarkably large number of other hosts: 172.17.84.14 connected or tried to connect to 1,851 different hosts on my data center network, as shown at ❻. Because the network has fewer than 500 active computers, this is immediately suspicious. The second host shown at ❼ has a similar profile, while the third at ❽ is my corporate file server, which has many fewer connections.</p><p>These two machines turned out to be on a test network in a different hemisphere. Without flow analysis, I could never have identified these machines. With analysis, an email documenting the results got me out of having to attend any of the follow-up meetings.</p></div><div class="sect2" title="Traffic to Illegal Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="traffic_to_illegal_addresses"/>Traffic to Illegal Addresses</h2></div></div></div><p>Is your firewall misconfigured? Yes. Yes, it is. You just don't know it.</p><p>Most firewalls use Network Address Translation (NAT) to connect hosts on private addresses to ones on the public Internet. If you have a complicated firewall policy and a firewall platform that encourages complicated or downright bizarre NAT rules,<sup>[<a class="footnote" href="#ftn.CHP-9-FN-2" id="CHP-9-FN-2">12</a>]</sup> it's easy to accidentally leak untranslated addresses onto your Internet-facing network. If you're running multiple firewalls using one policy, it becomes almost inevitable. Your ISP should filter internal addresses from your Internet circuits, so any traffic with private IP addresses on your external network is coming from you (or you and your ISP need to have a little talk).<a class="indexterm" id="IDX-CHP-9-0039"/></p><p>It's easy to track down traffic from private addresses. First, define a filter that includes your internal addresses.</p><a id="I_programlisting9_d1e15980"/><pre class="programlisting">filter-primitive internal
     type ip-address-prefix
❶    permit 172.16.0.0/16
     permit 172.17.0.0/16
     permit 172.18.0.0/16

 filter-definition internal
   match ip-source-address internal
   or
   match ip-destination-address internal</pre><p>Here you identify at ❶ three blocks of IP addresses that are used internally and define a filter for them. Next, go to the directory where you store flow records for your Internet-facing network, filter for these addresses, and print the results.<a class="indexterm" id="IDX-CHP-9-0040"/><a class="indexterm" id="IDX-CHP-9-0041"/><a class="indexterm" id="IDX-CHP-9-0042"/></p><a id="I_programlisting9_d1e15995"/><pre class="programlisting"># <strong class="userinput"><code>flow-cat * | flow-nfilter -F internal | flow-print | less</code></strong>
  srcIP            dstIP            prot  srcPort  dstPort  octets      packets
❶ 172.16.84.151    137.118.232.3    6     33892    25        40         1
  172.16.84.151    94.190.193.162   6     43729    25       309         1
  172.16.84.151    123.118.100.174  6     25051    25       339         1
  172.16.84.151    189.70.172.2     6     33724    2015     133         1
  172.16.84.151    212.242.180.151  6     33724    11906    133         1
❷ 172.16.84.130    198.22.66.10     17    4132     53       132         1
  172.16.84.130    198.22.62.19     17    38897    53       132         1
  ...</pre><p>Each of these flows passed through a firewall rule with an improper NAT configuration. In other words, these rules are broken, and they will impact you in unexpected ways. For example, the line at ❶ shows a host trying to send email from a private address. The connection never completes, of course. If this is your backup mail exchanger, you'll have a nasty surprise when your primary breaks. Similarly, at ❷ you also have a host trying to make name service queries from a private address. Fixing these in advance will reduce future outages.</p></div><div class="sect2" title="Traffic to Nonexistent Hosts"><div class="titlepage"><div><div><h2 class="title"><a id="traffic_to_nonexistent_hosts"/>Traffic to Nonexistent Hosts</h2></div></div></div><p>Theoretically, removing network servers should reduce network usage. Unfortunately, that's not always true.</p><p>At one point, certain desktops on my employer's corporate network would not become useful until more than five minutes after the user entered their username and password. This is slow even for commodity operating systems. Although not every workstation was affected, most of those that were impacted were at remote locations where I lacked diagnostic equipment. I had a user try one of these workstations at a specific time and then checked the flow records to see whether that workstation had tried to contact anything at my data center during that window.</p><p>As it turned out, most of the traffic from that workstation during that time was trying to reach my Novell login server, which had been turned off a few days before. The workstation still had the client installed, however. Apparently the Novell client software insisted on trying to contact the login server even though it had been told to shut down. Removing the Novell client from that client resolved the slow login issues.</p><p>With one problem identified, I next used FlowGrapher to diagram traffic from that remote plant to the disconnected server's IP address. For two hours every morning, this traffic consumed almost 25 percent of the plant's network connection. Although removing the disabled client had previously been considered unnecessary, this evidence changed people's minds.<a class="indexterm" id="IDX-CHP-9-0043"/></p><p>Strictly speaking, this wasn't a network problem, but diagnosing it required involvement by a network administrator and resolving it reduced the number of network complaints. And remember, all a network engineer wants is for his users to shut up.<a class="indexterm" id="IDX-CHP-9-0044"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-2" id="ftn.CHP-9-FN-2">12</a>] </sup>(Cough.) Checkpoint. (Cough.)</p></div></div></div>
<div class="sect1" title="Afterword"><div class="titlepage"><div><div><h1 class="title"><a id="afterword"/>Afterword</h1></div></div></div><p>I'm certain that most of you get along fabulously with each and every one of your co-workers, your work environment is a delight and a joy, and your IT group is a seamless, cohesive team without bitter bickering or belabored backbiting. Those of you unfortunate enough to work in a less supportive environment should read this.</p><p>Flow analysis will change your problem-solving capacities. You'll solve odd issues that have haunted your network for years. You'll conclusively show that problems that everyone has comfortably blamed on the network are actually server or software problems. You'll even be able to dig up a whole list of weird problems that other people are causing on the network. All of this will quickly change your relationship with your co-workers and management.</p><p>Systems administration and network engineers have a long tradition of being difficult to work with; we even have archetypes like the Bastard Operator from Hell. Now that you have evidence, it's tempting to make those who doubted you suffer for their intransigence. Now that you have evidence, though, you can afford to be generous. When something is your problem, admit it. When you show that something isn't your problem, however, say something like "Here's the evidence identifying the problem. Although this is clearly not a network issue, I'm happy to help you solve your problem." Admittedly, this is much less satisfying than using words like "you loser." Unlikely as it seems, a positive attitude can change co-worker and management attitudes about the network staff and can improve your life.</p><p>And if not, well, at least you'll know for certain that it's not your problem. And it's <span class="emphasis"><em>never</em></span> too late to call someone a doofus.</p></div></body></html>