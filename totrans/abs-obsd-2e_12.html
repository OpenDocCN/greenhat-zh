<html><head></head><body><section class="chapter" epub:type="chapter" id="connecting_to_the_network" title="Chapter&#xA0;12.&#xA0;Connecting to the Network"><div class="titlepage"><div><div><h2 class="title">Chapter 12. Connecting to the Network</h2></div></div></div><div class="epigraph" epub:type="epigraph"><div class="literallayout"><p><span class="emphasis"><em>My tunnel is now up.</em></span><br/>
<span class="emphasis"><em>I can do IPv6.</em></span><br/>
<span class="emphasis"><em>Me and three others.</em></span></p></div></div><p><a class="indexterm" id="idx0781"/><a class="indexterm" id="idx1477"/><span class="inlinemediaobject"><a id="inline_id00013"/><img alt="" src="httpatomoreillycomsourcenostarchimages1616079.png"/></span> All that theory of IPv4 and IPv6 is fine. Now let’s do something with it, and actually connect to a network. While dial-up connections work with OpenBSD, they’re not used much these days, so we’ll focus on Ethernet connections. Ethernet is the most common network type today, and the most common network interface on OpenBSD systems.</p><p>Most people have IPv4 connectivity, but IPv6 is increasingly important. If you can’t get native IPv6 to your network, you can use a tunnel to reach IPv6 address space and provide IPv6 to your clients. I’ll cover acquiring and configuring such a tunnel in this chapter.</p><p>Finally, OpenBSD can combine network connections into trunks or split them into virtual local area networks (VLANs). This chapter covers both approaches.</p><div class="sect1" title="DNS Resolution"><div class="titlepage"><div><div><h2 class="title" id="dns_resolution" style="clear: both">DNS Resolution</h2></div></div></div><p><a class="indexterm" id="idx0394"/><a class="indexterm" id="idx0506"/><a class="indexterm" id="idx0516"/><a class="indexterm" id="idx0732"/><a class="indexterm" id="idx0859"/><a class="indexterm" id="idx0985"/><a class="indexterm" id="idx0988"/><a class="indexterm" id="idx1478"/><a class="indexterm" id="idx1801"/><a class="indexterm" id="idx1962"/><a class="indexterm" id="idx2036"/><a class="indexterm" id="idx2037"/>You’ll probably want to use hostnames rather than IP addresses, so that you’ll be able to browse to <span class="emphasis"><em><a class="ulink" href="http://www.cnn.com/" target="_top">http://www.cnn.com/</a></em></span> instead of <span class="emphasis"><em><a class="ulink" href="http://157.166.255.18" target="_top">http://157.166.255.18</a></em></span>. Unix-like systems use the <span class="emphasis"><em>resolver</em></span> to accomplish this feat.</p><p>Most hosts use two tools to map between IP addresses and hostnames: the <span class="emphasis"><em>hosts</em></span> file and DNS. (Different operating systems support additional name services, such as YP, LDAP, NIS, and so on, but dang near every system supports these two.)</p><p>The <span class="emphasis"><em>hosts</em></span> file is a text file on the local machine that contains static IP address and hostname lists. DNS is a more dynamic service that reaches across the network to find information. You can specify DNS servers by IP address, but we’ll look at the <span class="emphasis"><em>hosts</em></span> file in a little more detail.</p><p>What if you prefer IPv4 or IPv6 addresses? Or you want the <span class="emphasis"><em>hosts</em></span> file to override DNS? Maybe you have a default domain that your queries should use. The resolver searches until it either finds the first answer or has exhausted its information sources, so these questions matter. Tell your resolver your needs in <span class="emphasis"><em>/etc/resolv.conf</em></span>.</p><div class="sect2" title="The /etc/resolv.conf File"><div class="titlepage"><div><div><h3 class="title" id="the_etc_resolv_conf_file">The /etc/resolv.conf File</h3></div></div></div><p>You configure the resolver behavior in <span class="emphasis"><em>/etc/resolv.conf</em></span>. A system without <span class="emphasis"><em>/etc/resolv.conf</em></span> can find only hostnames listed in the <span class="emphasis"><em>hosts</em></span> file. Because the <span class="emphasis"><em>hosts</em></span> file starts off empty, that’s probably not what you want. Start by specifying domain names.</p><div class="sect3" title="Default Search Domains"><div class="titlepage"><div><div><h4 class="title" id="default_search_domains">Default Search Domains</h4></div></div></div><p>If you wanted to ping a host on a remote network, you might expect to need to specify the whole domain. Entering <span class="strong"><strong><code class="literal">ping www.openbsd.org</code></strong></span> should work. But if you wanted to ping your company’s web server, it would make more sense to just type <span class="strong"><strong><code class="literal">ping www</code></strong></span>. And you can, because OpenBSD allows you to specify default domains, so that when you type in a short hostname, it will try to find the proper host.</p><p>For example, if you have only one local domain, you would list the domain keyword in <span class="emphasis"><em>/etc/resolv.conf</em></span> like this:</p><a id="I_programlisting12_id461556"/><pre class="programlisting">domain michaelwlucas.com</pre><p>Now, when I enter <code class="literal">ping ftp</code>, the resolver should get the IP address of the host <span class="emphasis"><em>ftp.michaelwlucas.com</em></span>.</p><p>If you have more than one local domain, use the <code class="literal">search</code> keyword and a list of domains, like this:</p><a id="I_programlisting12_id461580"/><pre class="programlisting">search michaelwlucas.com openbsd.org</pre><p>If I enter <code class="literal">ping ftp</code> now, the resolver should get the IP of the host <span class="emphasis"><em>ftp.michaelwlucas.com</em></span>. Once the resolver learns that no such host exists, it will check for <span class="emphasis"><em>ftp.openbsd.org</em></span>. Because that host exists, <code class="literal">ping</code> will start to work. The <code class="literal">search</code> keyword can have up to six domains, and can be no longer than 1024 characters.</p></div><div class="sect3" title="Using Domain and Search"><div class="titlepage"><div><div><h4 class="title" id="using_domain_and_search">Using Domain and Search</h4></div></div></div><p><a class="indexterm" id="idx0119"/><a class="indexterm" id="idx0134"/><a class="indexterm" id="idx1243"/><a class="indexterm" id="idx1426"/>You can only use either <code class="literal">domain</code> or <code class="literal">search</code>. If you use both, the last entry in the file wins. If you list multiple search or domain lines, the last one in the file takes effect. Here’s how not to do it:</p><a id="I_programlisting12_id461656"/><pre class="programlisting">search cnn.com openbsd.org
search sluggy.com michaelwlucas.com
domain blackhelicopters.org</pre><p>You might as well get rid of the two <code class="literal">search</code> statements. The resolver will never go through those domain lists; it will use only the <code class="literal">domain</code> list because it’s the last one.</p></div><div class="sect3" title="Name Servers"><div class="titlepage"><div><div><h4 class="title" id="name_servers">Name Servers</h4></div></div></div><p>Now that the resolver knows which domains to check by default, tell it which name servers to use. List each name server on its own line, by IP address, in order of preference.</p><a id="I_programlisting12_id461689"/><pre class="programlisting">nameserver 192.0.2.5
nameserver 198.51.100.5
nameserver 2001:db8::5</pre><p>You can list up to three name servers, by IP address. (Hostnames in a <code class="literal">nameserver</code> entry won’t work, for fairly obvious reasons.)</p><p>If your <span class="emphasis"><em>resolv.conf</em></span> doesn’t list a name server, the resolver should check for a name server on the local machine.</p></div><div class="sect3" title="Lookup Order"><div class="titlepage"><div><div><h4 class="title" id="lookup_order">Lookup Order</h4></div></div></div><p>You might get host information from DNS or from the <span class="emphasis"><em>hosts</em></span> file. The resolver should stop once it finds an answer to a query. If you check the <span class="emphasis"><em>hosts</em></span> file and then DNS, entries in the <span class="emphasis"><em>hosts</em></span> file override the name server. If you check the name server before the <span class="emphasis"><em>hosts</em></span> file, the <span class="emphasis"><em>hosts</em></span> file is used only when no DNS record is available. Either approach has its uses, but by default, the resolver checks the <span class="emphasis"><em>hosts</em></span> file, and then checks DNS. To reverse this, use the <code class="literal">lookup</code> keyword.</p><a id="I_programlisting12_id461749"/><pre class="programlisting">lookup bind file</pre><p>The <code class="literal">file</code> option represents <span class="emphasis"><em>/etc/hosts</em></span>, while due to a historical accident, <code class="literal">bind</code> represents DNS. (The first DNS server software was the Berkeley Internet Name Domain server, or BIND.)The reverse (<code class="literal">file bind</code>) is the default, so there’s no need to explicitly specify it.</p></div><div class="sect3" title="Preferred IP Protocol"><div class="titlepage"><div><div><h4 class="title" id="preferred_ip_protocol">Preferred IP Protocol</h4></div></div></div><p><a class="indexterm" id="idx0441"/><a class="indexterm" id="idx0507"/><a class="indexterm" id="idx0508"/><a class="indexterm" id="idx0532"/><a class="indexterm" id="idx0620"/><a class="indexterm" id="idx0810"/><a class="indexterm" id="idx1108"/><a class="indexterm" id="idx1963"/>The resolver defaults to searching for IPv4 records first, and then looking for IPv6 records. To reverse this, use the <code class="literal">family</code> keyword.</p><a id="I_programlisting12_id461854"/><pre class="programlisting">family inet6 inet4</pre><p>Again, the reverse is the default, so there’s no need to use this keyword in that case.</p></div></div><div class="sect2" title="The /etc/hosts File"><div class="titlepage"><div><div><h3 class="title" id="the_etc_hosts_file">The /etc/hosts File</h3></div></div></div><p>The <span class="emphasis"><em>/etc/hosts</em></span> file matches IP addresses to hostnames. While the <span class="emphasis"><em>hosts</em></span> file is very simple, its contents are available only on the local machine. A <span class="emphasis"><em>hosts</em></span> file is most useful on a small private network, such as in your home or test lab. You can also use a <span class="emphasis"><em>hosts</em></span> file to override data from the DNS server, such as when you want to test a new system.</p><p>Each line in <span class="emphasis"><em>/etc/hosts</em></span> represents one host. The first entry on each line is an IP address. The second is the fully qualified domain name of the host. Following these two entries, you can have an arbitrary number of aliases for that host. I often add comments at the end of the line, prefixed with a hash mark (<code class="literal">#</code>).</p><p>There was a time when I had a small network at home with only four machines: the proxy/firewall, the wife’s desktop, my laptop, and the crash machine where I did stupid things. The <span class="emphasis"><em>hosts</em></span> file looked like this:</p><a id="I_programlisting12_id461915"/><pre class="programlisting">192.0.2.1 <span class="strong"><strong>1</strong></span>nat.blackhelicopters.org    <span class="strong"><strong>2</strong></span>nat firewall gateway
192.0.2.8   boss.blackhelicopters.org     boss wife  <span class="strong"><strong>3</strong></span>#don't crash
192.0.2.20  crashbox.blackhelicopters.org crashbox test
192.0.10.21 laptop.blackhelicopters.org   laptop mwlucas</pre><p>The machine <code class="literal">nat.blackhelicopters.org</code> at <span class="strong"><strong>1</strong></span> also had the names <code class="literal">firewall</code> and <code class="literal">gateway</code> at <span class="strong"><strong>2</strong></span>. I added a note to remind myself at <span class="strong"><strong>3</strong></span> not to run security scanners against my wife’s desktop. (The machine <code class="literal">crashbox</code> is also called <code class="literal">test</code>.)</p><p>Any machine with this <span class="emphasis"><em>hosts</em></span> table could find any machine listed in the <span class="emphasis"><em>hosts</em></span> table by name. For example, I could run <code class="literal">ping boss</code> or <code class="literal">ssh crashbox</code> and reach the desired machine.</p><p>The <span class="emphasis"><em>hosts</em></span> file works just fine for finding networked hosts, but whenever you add, remove, or change a machine, you must edit <span class="emphasis"><em>/etc/hosts</em></span> on every computer. And every time you change an IP address, you must edit <span class="emphasis"><em>/etc/hosts</em></span> on every machine.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note01"/>Note</h3><p>Unfortunately, <span class="emphasis"><em>/etc/hosts</em></span> does not scale. When I got a fifth machine, I added an internal-only DNS server and emptied the <span class="emphasis"><em>hosts</em></span> file on all of my systems.</p></div></div><div class="sect2" title="Resolver vs. Dynamic Configuration"><div class="titlepage"><div><div><h3 class="title" id="resolver_vs_dynamic_configuration">Resolver vs. Dynamic Configuration</h3></div></div></div><p>If your OpenBSD system roams between networks, like a laptop, you probably use DHCP to configure your network connection.</p><p><a class="indexterm" id="idx0198"/><a class="indexterm" id="idx0263"/><a class="indexterm" id="idx0734"/><a class="indexterm" id="idx0782"/><a class="indexterm" id="idx0992"/><a class="indexterm" id="idx1253"/><a class="indexterm" id="idx1342"/><a class="indexterm" id="idx1479"/><a class="indexterm" id="idx2286"/>DHCP overwrites <span class="emphasis"><em>/etc/resolv.conf</em></span> with the information for its network. This is appropriate for most users, but if you’re carrying an OpenBSD laptop, you’re not normal. You probably want some of your resolver configuration, such as your domain search list, to remain in effect no matter what network you’re on.</p><p>OpenBSD supports permanent resolver configuration in the file <span class="emphasis"><em>/etc/resolv.conf.tail</em></span>. When OpenBSD’s DHCP client gets <span class="emphasis"><em>/etc/resolv.conf</em></span> information from the server, it writes to <span class="emphasis"><em>/etc/resolv.conf</em></span> and adds <code class="literal">/etc/resolv.conf.tail</code> to the end.</p><p>Remember how only the last <code class="literal">search</code> or <code class="literal">domain</code> keyword works? <span class="emphasis"><em>resolv.conf.tail</em></span> takes advantage of that, allowing you to override your network administrator’s search order.</p></div></div><div class="sect1" title="Ethernet"><div class="titlepage"><div><div><h2 class="title" id="ethernet" style="clear: both">Ethernet</h2></div></div></div><p>Ethernet is a shared network, meaning that many different machines can connect to the same Ethernet and can communicate directly with each other. I’m going to assume that you’re using Ethernet as found in an average office or datacenter. Also, although Ethernet has been implemented over many different physical media, I’ll assume you’re working with CAT5 or better cable—today’s most popular choice. If you use some unusual media type, or your card supports multiple media, you might need to manually set your preferred media on your interface.</p><div class="sect2" title="Protocol and Hardware"><div class="titlepage"><div><div><h3 class="title" id="protocol_and_hardware">Protocol and Hardware</h3></div></div></div><p>Ethernet is a <span class="emphasis"><em>broadcast protocol</em></span>, which means that every packet you transmit can be sent to every host on the network (although most Ethernet hardware limits recipients). Either your network card or your device driver separates the data intended for your computer from the data meant for other computers. A section of Ethernet where all hosts can communicate directly with all other hosts, without involving a router, is called a <span class="emphasis"><em>collision domain</em></span> or <span class="emphasis"><em>segment</em></span>.</p><p>You connect Ethernet segments with <span class="emphasis"><em>hubs</em></span>, which are hardware items that can physically connect many Ethernet hosts. Network hubs forward all received frames to all other network devices, and each host is responsible for filtering traffic. This is old-school Ethernet, which can be useful for debugging network issues.</p><p><span class="emphasis"><em>Switches</em></span> have largely supplanted hubs. Every Ethernet connection needs a unique identifier, called a <span class="emphasis"><em>MAC address</em></span> (or sometimes an <span class="emphasis"><em>Ethernet address</em></span>), which is a 48-bit number. Switches control the traffic sent to each host by filtering on the MAC and IP address of attached devices and (mostly) forwarding frames only to the devices they are meant for. Switching reduces the amount of traffic and load on each individual system by decreasing the amount of traffic each host must sort through.</p><p>On i386 and amd64 hardware, the MAC address is a property of the card. On some other platforms, such as SPARC, the MAC address is a property of the server itself. Both IPv4 and IPv6 use the MAC address to find other hosts on the local network.</p><div class="sect3" title="IPv4 and ARP"><div class="titlepage"><div><div><h4 class="title" id="ipv4_and_arp">IPv4 and ARP</h4></div></div></div><p><a class="indexterm" id="idx0028"/><a class="indexterm" id="idx0074"/><a class="indexterm" id="idx0075"/><a class="indexterm" id="idx1104"/><a class="indexterm" id="idx1119"/><a class="indexterm" id="idx1451"/><a class="indexterm" id="idx1452"/><a class="indexterm" id="idx1457"/>When a system needs to transmit data to another IP-based host on the local Ethernet, it first broadcasts an Ethernet request asking, “Which MAC address is responsible for this IP address?” If a host responds, further data for that IP is transmitted to that MAC address. This process is handled by ARP.</p><p>Use <code class="literal">arp(8)</code> to view your system’s ARP table, which is the list of hosts that your system knows. Enter <code class="literal">arp -a</code> to show all of the MAC addresses and IPv4 hostnames your computer knows.</p><a id="I_programlisting12_id462319"/><pre class="programlisting">$ <span class="strong"><strong>arp -a</strong></span>
fly.blackhelicopters.org (192.0.2.225) at 00:a0:c8:10:eb:82 on fxp0
caddis.blackhelicopters.org (192.0.2.226) at 00:16:36:c0:58:a5 on fxp0 static
treble.blackhelicopters.org (192.0.2.227) at 00:0c:42:5a:58:ae on fxp0
salmon.blackhelicopters.org (192.0.2.232) at (incomplete) on fxp0</pre><p>Here, you see the three hosts on my Ethernet network that this host has communicated with. I have more hosts, but because this machine hasn’t spoken with them lately, they aren’t in the local ARP table.</p><p>If a MAC address shows up as <code class="literal">incomplete</code>, your machine has attempted to communicate with this host but cannot get its MAC address. In this example, I’ve tried to send data to the host <code class="literal">salmon</code>, but my computer can’t reach it. (Turning <code class="literal">salmon</code> back on would help.)</p></div><div class="sect3" title="IPv6 and Neighbor Discovery"><div class="titlepage"><div><div><h4 class="title" id="ipv6_and_neighbor_discovery">IPv6 and Neighbor Discovery</h4></div></div></div><p>IPv6 hosts also use MAC addresses to find each other through ND, an IPv6 protocol introduced in the previous chapter. Interrogate your ND cache with <code class="literal">ndp(8)</code>. The command-line flags used for <code class="literal">ndp</code> are intentionally similar to those for <code class="literal">arp</code>.</p><a id="I_programlisting12_id462379"/><pre class="programlisting">$ <span class="strong"><strong>ndp -a</strong></span>
Neighbor                             Linklayer Address  Netif Expire    S Flags
2001:db8:0:12:20c:29ff:feb5:7565     0:c:29:b5:75:65    vic0  permanent R
2001:db8:0:12:5446:fbc:fca0:f2e9     0:c:29:b5:75:65    vic0  permanent R
…
fe80::20c:29ff:feb5:7565%vic0        0:c:29:b5:75:65    vic0  permanent R
fe80::20c:42ff:fe20:7f42%vic0        0:c:42:20:7f:42    vic0  11h20m47s S R
fe80::1%lo0                          (incomplete)       lo0   permanent R</pre><p>Like the ARP cache, the ND cache shows an IPv6 address, a physical address, the interface, and other details for each host. You’ll see more ND entries than ARP entries because all of the link local addresses show up in the ND cache.</p><p>If you try to reach a host that is directly attached to your local network and it doesn’t respond, check the ND cache. If an ND cache entry shows up as <code class="literal">(incomplete)</code>, as with ARP, there’s some sort of basic connectivity issue.</p></div><div class="sect3" title="Speed and Duplex"><div class="titlepage"><div><div><h4 class="title" id="speed_and_duplex">Speed and Duplex</h4></div></div></div><p><a class="indexterm" id="idx0097"/><a class="indexterm" id="idx0783"/><a class="indexterm" id="idx0788"/><a class="indexterm" id="idx0906"/><a class="indexterm" id="idx0935"/>Ethernet supports a variety of speeds. The slowest speed you’re likely to find today is 10 megabits per second (Mbps), but it’s quickly disappearing. Most people use either 10/100Mbps or 1 gigabit per second (Gbps), although you’ll see 10Gbps, 40Gbps, and 100Gbps Ethernet emerging.</p><p>The hosts and switch it’s connected to on your network must agree on the speed of their connection. If the OpenBSD host thinks that it’s connected at 100Mbps, but the switch thinks that the connection is 1Gbps, the connection will be flaky. While <span class="emphasis"><em>autonegotiation</em></span> usually makes both sides agree on common settings (and is absolutely required for gigabit connections), you can manually set duplex and speed for 10/100Mbps connections. Although some switch vendors are notorious for poor autonegotiation, you should let your Ethernet configure itself whenever possible.</p><p><span class="emphasis"><em>Duplex</em></span> determines if a card can both transmit and receive data simultaneously. A <span class="emphasis"><em>half-duplex</em></span> connection means that the Ethernet card is either transmitting or receiving at a given instant; it cannot do both. A <span class="emphasis"><em>full-duplex</em></span> connection can both send and receive simultaneously. As with connection speed, if the switch and host disagree on the duplex setting, the connection will be flaky. Gigabit Ethernet connections involve much more than speed and duplex, and they <span class="emphasis"><em>must</em></span> be autonegotiated.</p><p>Just because a device says that it can use the protocol defined as 10/100Mbps Ethernet doesn’t mean that it can use that protocol with any speed. Also, a card labeled “1Gbps” might not actually pass a gigabit per second. Some network cards will pass their stated amount of traffic, while others will stagger and stumble at a few percent of that. Switch quality varies widely, too.</p><p>This may make more sense if you think of an Ethernet’s stated speed as a language. For example, I could claim that I speak Russian and German, but I stopped studying foreign languages in 1985. When I went to Germany in 2007, I managed about three words a minute—with the aid of a translation card and phrase book. If I were an Ethernet card, the manufacturer would claim I spoke German and Russian, and ship me to Siberia.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id309258" id="id309258">33</a>]</sup></p><p>Get decent hardware. Don’t ask on the OpenBSD mailing list, though. Someone has asked about hardware recommendations in the past few months. Check the archives. The advice hasn’t changed.</p></div></div></div><div class="sect1" title="Configuring Ethernet"><div class="titlepage"><div><div><h2 class="title" id="configuring_ethernet" style="clear: both">Configuring Ethernet</h2></div></div></div><p>When configuring Ethernet for client computers, if your IPv4 network offers DHCP, you should be able to plug right in. If you’re using IPv6, you should be able to attach the cable and let autoconfiguration take over.</p><p><a class="indexterm" id="idx0551"/><a class="indexterm" id="idx1012"/><a class="indexterm" id="idx1200"/><a class="indexterm" id="idx1202"/><a class="indexterm" id="idx1224"/><a class="indexterm" id="idx2244"/>If a particular machine will be a server, a static IP address probably makes more sense. Before assigning a static address, you’ll need the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>An IP address (IPv4, IPv6 or both)</p></li><li class="listitem"><p>The netmask/prefix length(s)</p></li><li class="listitem"><p>The IP address(es) of the default gateway</p></li></ul></div><p>Armed with this information, attach your system to the network and keep reading. I’ll first discuss using <code class="literal">ifconfig(8)</code> and <code class="literal">route(8)</code> to perform changes manually, and then review how to set these automatically at boot. In any case, you must configure the resolver as discussed at the beginning of this chapter.</p><div class="sect2" title="Using ifconfig(8)"><div class="titlepage"><div><div><h3 class="title" id="using_ifconfig8">Using ifconfig(8)</h3></div></div></div><p>If you installed OpenBSD over a network, your Ethernet connection should already be working, but it might not be set up exactly the way you like. To manage your network interfaces, use the <code class="literal">ifconfig(8)</code> tool.</p><p>Let’s look at your Ethernet card and see what it has to say. Start by asking your system about all of the interfaces it has installed, by running <code class="literal">ifconfig</code>.</p><p>All OpenBSD systems have three logical interfaces out of the box: <code class="literal">lo0</code>, <code class="literal">enc0</code>, and <code class="literal">pflog0</code>. The <code class="literal">lo0</code> interface is the loopback interface, referring to the local machine. The <code class="literal">enc0</code> interface is an encapsulation interface, intended for IPsec traffic. Finally, <code class="literal">pflog0</code> is for logging PF traffic, as discussed in <a class="xref" href="ch22.html" title="Chapter 22. Advanced PF">Chapter 22</a>. The rest of the interfaces are physical ones.</p><p>Unlike some operating systems, OpenBSD network interfaces are named after the device driver of the underlying hardware. Here’s a sample list:</p><a id="I_programlisting12_id462674"/><pre class="programlisting">$ <span class="strong"><strong>ifconfig</strong></span>
fxp0: flags=8843&lt;<span class="strong"><strong>1</strong></span>UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        lladdr 00:16:36:c0:58:a5
        priority: 0
        groups: egress
        media: Ethernet autoselect (100baseTX full-duplex)
     <span class="strong"><strong>2</strong></span> status: active
     <span class="strong"><strong>3</strong></span> inet 192.0.2.226 netmask 0xffffff00 broadcast 192.0.2.255
        inet6 2001:db8::216:36ff:fec0:58a5 prefixlen 64
        inet6 fe80::216:36ff:fec0:58a5%fxp0 prefixlen 64 scopeid 0x2</pre><p>The interface <code class="literal">fxp0</code> uses the <code class="literal">fxp(4)</code> device driver, which the man page says is an Intel EtherExpress PRO 10/100 card. As you can see at <span class="strong"><strong>1</strong></span>, the interface is up, meaning that it’s active and ready to use. The <code class="literal">lladdr</code> is the link local address, or the MAC address of the card. This card is in the <code class="literal">egress</code> group. OpenBSD uses interface groups in several places, including the packet filter, as discussed in <a class="xref" href="ch22.html" title="Chapter 22. Advanced PF">Chapter 22</a>.</p><p>To see the type of physical media underlying the connection, check the <code class="literal">media</code> line. This particular connection runs at 100Mbps full-duplex. The connection is active, as shown at <span class="strong"><strong>2</strong></span>; the physical layer has not only been configured, but it also has a link light and is ready to go. The connection has been assigned an IPv4 address and netmask, as shown at <span class="strong"><strong>3</strong></span>. You can see on the two lines that follow that both an IPv6 address and a link local IPv6 address have been assigned.</p><p><a class="indexterm" id="idx1014"/><a class="indexterm" id="idx1088"/><a class="indexterm" id="idx1091"/>Use <code class="literal">ifconfig</code> to assign, change, or remove IP addresses from a network interface. The OpenBSD installer offers to configure your network cards at boot, but if you didn’t configure all of your interfaces during installation, or if you add or remove network interfaces after installation, you will need to do so manually.</p><div class="sect3" title="Adding an IP Address"><div class="titlepage"><div><div><h4 class="title" id="adding_an_ip_address">Adding an IP Address</h4></div></div></div><p>To add an IP address for IPv4, start with the interface’s assigned IP address and netmask.</p><a id="I_programlisting12_id462815"/><pre class="programlisting"># <span class="strong"><strong>ifconfig <span class="emphasis"><em>interface-name IP-address netmask</em></span></strong></span></pre><p>For example, if your network card is <code class="literal">fxp0</code>, your IP address is 192.0.2.55, and the netmask is 255.255.255.128, you would run this:</p><a id="I_programlisting12_id462833"/><pre class="programlisting"># <span class="strong"><strong>ifconfig fxp0 192.0.2.55 255.255.255.128</strong></span></pre><p>Specify the netmask in dotted-quad notation, hexadecimal, or even slash notation, like this:</p><a id="I_programlisting12_id462846"/><pre class="programlisting"># <span class="strong"><strong>ifconfig fxp0 192.0.2.55/25</strong></span></pre><p>You don’t need to specify a netmask separately if you use a slash.</p><p>Adding an IP address with IPv6 is a little different. Specify the address, a slash, and the prefix length, but don’t try to add a separate netmask; just use the slash that’s part of the address. Here’s an example:</p><a id="I_programlisting12_id462864"/><pre class="programlisting"># <span class="strong"><strong>ifconfig fxp0 inet6 2001:db8:0:12::2/64</strong></span></pre></div><div class="sect3" title="Removing IP Addresses"><div class="titlepage"><div><div><h4 class="title" id="removing_ip_addresses">Removing IP Addresses</h4></div></div></div><p>If you need to remove an IP address from an interface, use the <code class="literal">delete</code> option of <code class="literal">ifconfig</code> for both IPv4 and IPv6 addresses.</p><a id="I_programlisting12_id462891"/><pre class="programlisting"># <span class="strong"><strong>ifconfig fxp0 192.0.2.55 delete</strong></span></pre><p>The effect is immediate, so be sure you don’t lock yourself out of the system by removing all of its reachable IP addresses, or by removing the only address your SSH daemon is attached to. (In certain rare cases, existing connections to deleted addresses might continue to work, but they probably won’t, so don’t count on it.)</p></div><div class="sect3" title="Multiple IP Addresses on One Ethernet Card"><div class="titlepage"><div><div><h4 class="title" id="multiple_ip_addresses_on_one_ethernet_ca">Multiple IP Addresses on One Ethernet Card</h4></div></div></div><p><a class="indexterm" id="idx0787"/><a class="indexterm" id="idx1089"/><a class="indexterm" id="idx1094"/><a class="indexterm" id="idx1469"/>One network interface can respond to requests for multiple IP addresses, which is important because a server might support hundreds or thousands of domains and need an IP address for each. (This isn’t so important for plain websites, but it can be important for SSL-based websites and protocols that rely on reverse DNS.)</p><p>To add extra IP addresses to an interface, use <span class="emphasis"><em>IP aliases</em></span>. IP aliases tell a network card to “answer requests for this IP address as well as your own.” To add aliased IP addresses, use <code class="literal">ifconfig</code> with the keyword <code class="literal">alias</code> after the interface name to tell <code class="literal">ifconfig</code> this is an alias. Be sure to always use a netmask of 255.255.255.255, or /32, for alias addresses.</p><a id="I_programlisting12_id462976"/><pre class="programlisting"># <span class="strong"><strong>ifconfig fxp0 alias 192.0.2.230/32</strong></span>
# <span class="strong"><strong>ifconfig fxp0</strong></span>
…
        inet 192.0.2.226 netmask 0xfffffff0 broadcast 192.0.2.239
        inet 192.0.2.230 netmask 0xffffffff</pre><p>The interface listed here has a main IP address of 192.0.2.226 and an alias IP address of 192.0.2.230.</p><p>When working with IPv6, add the <code class="literal">inet6</code> keyword, like this:</p><a id="I_programlisting12_id463004"/><pre class="programlisting"># <span class="strong"><strong>ifconfig fxp0 inet6 alias 2001:db8:0:12::3/64</strong></span></pre><p>It’s important to realize that all outgoing connections on a host with one network connection use the host’s primary IP address. For example, you might have 2000 IP addresses bound to one interface, but when you <code class="literal">ssh</code> out, the connection comes from the primary address. Remember this when writing firewall rules and access control lists, because while some programs have an option to set a different source IP address, they’re the exception.</p><p>The OpenBSD kernel doesn’t really differentiate between the primary IP addresses and aliases—it just keeps a list of IP addresses—but it will use the first address on its list as the source address unless told otherwise. If a host has multiple network connections, the source address of outgoing connections is the main IP address of the network interface on which packets leave the system.</p><p>To remove an alias, use the <code class="literal">delete</code> option of <code class="literal">ifconfig</code> and give the IP address, without the netmask.</p><a id="I_programlisting12_id463043"/><pre class="programlisting"># <span class="strong"><strong>ifconfig fxp0 delete 192.0.2.230</strong></span></pre><p>For IPv6, use <code class="literal">inet6 delete</code> instead.</p><a id="I_programlisting12_id463059"/><pre class="programlisting"># <span class="strong"><strong>ifconfig fxp0 inet6 delete 2001:db8:0:12::3</strong></span></pre><div class="note" title="Note"><h3 class="title"><a id="ch12note02"/>Note</h3><p>If you delete the main IP address on an interface, the first alias becomes the main IP address. If you have no IP address aliases remaining and you remove the interface’s main IP address, that interface stops passing IP traffic.</p></div></div></div><div class="sect2" title="Configuring Default Routes"><div class="titlepage"><div><div><h3 class="title" id="configuring_default_routes">Configuring Default Routes</h3></div></div></div><p><a class="indexterm" id="idx0171"/><a class="indexterm" id="idx0392"/><a class="indexterm" id="idx0440"/><a class="indexterm" id="idx0442"/><a class="indexterm" id="idx0619"/><a class="indexterm" id="idx0675"/><a class="indexterm" id="idx0784"/><a class="indexterm" id="idx0785"/><a class="indexterm" id="idx0786"/><a class="indexterm" id="idx0984"/><a class="indexterm" id="idx1013"/><a class="indexterm" id="idx1028"/><a class="indexterm" id="idx2000"/>Use <code class="literal">route(8)</code> to configure the default route for each protocol.</p><a id="I_programlisting12_id463202"/><pre class="programlisting"># <span class="strong"><strong>route add default 192.0.2.1</strong></span>
add net default: gateway 192.0.2.1</pre><p>An IPv6 default route is almost identical, but you must add the <code class="literal">-inet6</code> modifier.</p><a id="I_programlisting12_id463219"/><pre class="programlisting"># <span class="strong"><strong>route add -inet6 default 2001:db8:0:12::1</strong></span>
add net default: gateway 2001:db8:0:12::1</pre><p>Once you add IP addresses and default routes to your host, you should be able to reach the rest of your network and the Internet. Now let’s see how to make those changes across reboots.</p></div><div class="sect2" title="Using Dynamic Configuration"><div class="titlepage"><div><div><h3 class="title" id="using_dynamic_configuration">Using Dynamic Configuration</h3></div></div></div><p>To have OpenBSD get an IPv4 address from a DHCP server, run <code class="literal">dhclient(8)</code> and give it the name of the interface you want to configure.</p><a id="I_programlisting12_id463252"/><pre class="programlisting"># <span class="strong"><strong>dhclient fxp0</strong></span></pre><p><code class="literal">dhclient</code> gets an IP address, overwrites <span class="emphasis"><em>/etc/resolv.conf</em></span>, and configures the default route.</p><p>For IPv6, run <code class="literal">rtsol(8)</code> instead.</p><a id="I_programlisting12_id463279"/><pre class="programlisting"># <span class="strong"><strong>rtsol fxp0</strong></span></pre><p>Remember that IPv6 autoconfiguration will not configure your resolver. You’ll need to piggyback off your IPv4 DNS servers or manually configure <span class="emphasis"><em>/etc/resolv.conf</em></span>.</p></div><div class="sect2" title="Configuring the Network at Boot"><div class="titlepage"><div><div><h3 class="title" id="configuring_the_network_at_boot">Configuring the Network at Boot</h3></div></div></div><p>While <code class="literal">ifconfig(8)</code> is fine for changes on the fly, your system should configure its interfaces correctly at boot, including any aliases on the interface, any routes added when the interface comes up, and so on.</p><p>Each interface has a configuration file, <span class="emphasis"><em>/etc/hostname.interfacename</em></span>, generically called <span class="emphasis"><em>hostname.if</em></span>. The <code class="literal">fxp0</code> interface on my desktop uses a configuration file <span class="emphasis"><em>/etc/hostname.fxp0</em></span>, my wireless interface <code class="literal">wpi0</code> uses <span class="emphasis"><em>/etc/hostname.wpi0</em></span>, and so on. At boot, OpenBSD’s <span class="emphasis"><em>/etc/netstart</em></span> script reads all of the <span class="emphasis"><em>hostname.if</em></span> files and, if it finds a matching physical interface or can create a matching logical interface, it configures the interface accordingly.</p><p>To configure an interface’s IPv4 address, enter a line in <span class="emphasis"><em>hostname.if</em></span> in this format:</p><a id="I_programlisting12_id463363"/><pre class="programlisting"> inet <span class="emphasis"><em>ipaddress netmask broadcastaddress ifconfig-options</em></span></pre><p><a class="indexterm" id="idx1070"/>The broadcast address and options are optional. To use options but not specify a broadcast address, use <code class="literal">NONE</code> for the broadcast address. You can also use a slash for the netmask instead of the decimal equivalent.</p><p>Similarly, add an IPv6 address with the following:</p><a id="I_programlisting12_id463390"/><pre class="programlisting">inet6 <span class="emphasis"><em>ipv6address/prefix ifconfig-options</em></span></pre><p>To give <code class="literal">fxp0</code> the IPv4 address of 192.0.2.226 255.255.255.240 and the IPv6 address of 2001:db8:0:12::2/64 at boot, use the following in <span class="emphasis"><em>/etc/hostname.fxp0</em></span>:</p><a id="I_programlisting12_id463408"/><pre class="programlisting">inet 192.0.2.226 255.255.255.240 NONE description 'top card'
inet6 2001:db8:0:12::2/64</pre><p>Here, I also define an interface description that will show up in <code class="literal">ifconfig</code> output.</p><p>To create an IP address alias at boot, use the <code class="literal">alias</code> keyword in <span class="emphasis"><em>hostname.if</em></span>.</p><a id="I_programlisting12_id463431"/><pre class="programlisting">inet alias 192.0.2.230/32
inet6 alias 2001:db8:0:12::3/64</pre><p>To run a command when the interface comes up, put an exclamation point in front of the command. Any commands run must be available on the root partition (for example, in <span class="emphasis"><em>/bin</em></span> or <span class="emphasis"><em>/sbin</em></span>). This feature is most commonly used for routing, but you could use other commands as well.</p><a id="I_programlisting12_id463448"/><pre class="programlisting">!route add 192.0.2.128/25 192.0.2.2</pre><p>To configure an interface dynamically, via DHCP (IPv4) or <code class="literal">rtsol</code> (IPv6), put the string <code class="literal">dhcp</code> or <code class="literal">rtsol</code> on a line by itself.</p><a id="I_programlisting12_id463468"/><pre class="programlisting">dhcp
rtsol</pre><p>Anything that’s not formatted as shown here is passed unedited to <code class="literal">ifconfig(8)</code>. For example, to run a specific <code class="literal">ifconfig</code> command, put the arguments on their own line in <span class="emphasis"><em>hostname.if</em></span>.</p><a id="I_programlisting12_id463487"/><pre class="programlisting">description 'lower card'</pre><p>If you simply want to activate a card, but not configure it, use the word <code class="literal">up</code> on a line by itself to activate the interface.</p><a id="I_programlisting12_id463499"/><pre class="programlisting">up</pre><p>And remember, you can test <span class="emphasis"><em>hostname.if</em></span> changes with <span class="emphasis"><em>/etc/netstart</em></span>, specifying an interface name if appropriate, like so:</p><a id="I_programlisting12_id463515"/><pre class="programlisting"># <span class="strong"><strong>/bin/sh /etc/netstart fxp0</strong></span></pre><p><a class="indexterm" id="idx0151"/><a class="indexterm" id="idx0808"/><a class="indexterm" id="idx1182"/><a class="indexterm" id="idx1193"/><a class="indexterm" id="idx1194"/><a class="indexterm" id="idx1473"/><a class="indexterm" id="idx1480"/><a class="indexterm" id="idx1996"/><a class="indexterm" id="idx2463"/>Not including the interface name reconfigures all interfaces on the system.</p></div></div><div class="sect1" title="Trunking"><div class="titlepage"><div><div><h2 class="title" id="trunking" style="clear: both">Trunking</h2></div></div></div><p>Servers can have redundant hard drives, power supplies, and so on. OpenBSD supports redundant network connections by combining multiple Ethernet links into a single virtual link, or <span class="emphasis"><em>trunk</em></span>. You might also know of this as <span class="emphasis"><em>link aggregation</em></span>, <span class="emphasis"><em>network adapter teaming</em></span>, or <span class="emphasis"><em>bonding</em></span>.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note03"/>Note</h3><p>Cisco people know of <span class="emphasis"><em>trunks</em></span> as Ethernet links that support multiple concurrent VLANs. Most vendors, including OpenBSD, don’t use the word <span class="emphasis"><em>trunk</em></span> in that way. OpenBSD supports sending multiple VLANs over a single link outside the <code class="literal">trunk(4)</code> functionality.</p></div><div class="sect2" title="Link Aggregation Protocols"><div class="titlepage"><div><div><h3 class="title" id="link_aggregation_protocols">Link Aggregation Protocols</h3></div></div></div><p>To use multiple physical links as a single large link, you need a way to distribute traffic between the links. OpenBSD supports five different ways to distribute frames between trunk members, though not all will work in all environments. For a complete list see <code class="literal">trunk(4)</code>, but the protocols I recommend for real-world use are Link Aggregation Control Protocol (LACP), roundrobin, and failover. LACP is the industry standard for link aggregation. The physical interfaces are bonded into a single virtual interface with roughly the same bandwidth as the sum of the individual interfaces. LACP is very fault-tolerant, and just about every high-end managed switch should support it. If your switch supports LACP, use it, but you must configure LACP on the switch ports before this kind of trunk will pass traffic.</p><p>In the roundrobin method, OpenBSD sends frames across the trunk’s active connections using a roundrobin scheduler. The trunk accepts incoming packets on any port, and a roundrobin scheduler rotates between the trunk connections, with error and edge handling added on top. Roundrobin trunks don’t need any special switch configuration; they just need two ports in the same VLAN.</p><p>In the case of failover, OpenBSD sends and receives all traffic over the first port in the trunk, and if that port fails, it switches to another active port. The failover method doesn’t give you any additional bandwidth, but requires absolutely no support from the switch, and it even works on old-fashioned hubs.</p></div><div class="sect2" title="Trunk Configuration"><div class="titlepage"><div><div><h3 class="title" id="trunk_configuration">Trunk Configuration</h3></div></div></div><p>As an example, let’s configure ports <code class="literal">em0</code> and <code class="literal">em1</code> into failover trunk <code class="literal">trunk0</code>. The underlying ports have never been configured before, so begin by activating these interfaces without any configuration.</p><a id="I_programlisting12_id463694"/><pre class="programlisting"># <span class="strong"><strong>ifconfig em0 up</strong></span>
# <span class="strong"><strong>ifconfig em1 up</strong></span></pre><p><a class="indexterm" id="idx0184"/>Now create the failover trunk with <code class="literal">ifconfig(8)</code> and add these ports to it to make the <code class="literal">trunk0</code> interface usable.</p><a id="I_programlisting12_id463728"/><pre class="programlisting"># <span class="strong"><strong>ifconfig trunk0 trunkproto failover</strong></span>
# <span class="strong"><strong>ifconfig trunk0 trunkport em0</strong></span>
# <span class="strong"><strong>ifconfig trunk0 trunkport em1</strong></span></pre><p>You could do this all in one long <code class="literal">ifconfig</code> command, but I find simpler, shorter commands easier to understand when learning.</p><p>Assign the interface an IP address just as you would a physical interface, and add a default gateway to your system.</p><a id="I_programlisting12_id463761"/><pre class="programlisting"># <span class="strong"><strong>ifconfig trunk0 192.0.2.8 netmask 255.255.255.0</strong></span>
# <span class="strong"><strong>route add default 192.0.2.1</strong></span></pre><p>You should now have a failover trunk attached to your local network. To configure another trunk protocol, just specify the desired trunk protocol when you create the trunk. You’ll find a complete list of trunk protocols in <code class="literal">trunk(4)</code>.</p></div><div class="sect2" title="Trunks at Boot"><div class="titlepage"><div><div><h3 class="title" id="trunks_at_boot">Trunks at Boot</h3></div></div></div><p>Configure your trunk in <span class="emphasis"><em>/etc/hostname.if</em></span>. For example, suppose you need to edit <span class="emphasis"><em>hostname.em0</em></span>, <span class="emphasis"><em>hostname.em1</em></span>, and <span class="emphasis"><em>hostname.trunk0</em></span>. Both of the <span class="emphasis"><em>em</em></span> files contain only a single word:</p><a id="I_programlisting12_id463818"/><pre class="programlisting">up</pre><p>This activates the interfaces, but does no configuration.</p><p><span class="emphasis"><em>hostname.trunk0</em></span> is more complicated.</p><a id="I_programlisting12_id463832"/><pre class="programlisting">trunkproto failover
trunkport em0
trunkport em1
192.0.2.8 netmask 255.255.255.0</pre><p>You can put all of these entries in a single line, just as you can configure the trunk with a single <code class="literal">ifconfig</code> command, but again, I find multiple lines easier to read and understand.</p><p>Your trunk should now start at boot.</p><p>Note that trunks do not necessarily need to consist of interfaces that use the same type of physical medium. If you’re feeling adventurous, you could try to replicate what some OpenBSD developers and users have been known to do: Trunk together a wired and a wireless network interface, and have all your connections survive (graceful failover, remember?) when you yank the plug out of your Ethernet port, or if you plug yourself back in and take your access point down for maintenance.</p></div></div><div class="sect1" title="VLANs"><div class="titlepage"><div><div><h2 class="title" id="vlans" style="clear: both">VLANs</h2></div></div></div><p><a class="indexterm" id="idx1482"/><a class="indexterm" id="idx2287"/><a class="indexterm" id="idx2611"/><a class="indexterm" id="idx2624"/>VLANs are a way to get multiple Ethernet segments on a single piece of wire. You’ll sometimes see this referred to as <span class="emphasis"><em>802.1q</em></span>, <span class="emphasis"><em>tagging</em></span>, or a combination of these terms.</p><p>In OpenBSD terms, one wire can carry multiple networks, and by configuring an additional interface, you can talk to those additional networks as if they had their own private wire. The wire can still carry only so much data, however, so all VLANs and the regular network (or <span class="emphasis"><em>native VLAN</em></span>) that share the wire share the same pool of bandwidth.</p><p>VLAN frames that arrive at your network card are like regular Ethernet frames, with an additional header before the Ethernet frame that says “This is part of VLAN number such-and-such.” Each VLAN is identified by a number. VLAN number 1 is usually the native VLAN—the VLAN that arrives without any tagging whatsoever. For convenience, I’ll use the word “tagged” to describe how the VLAN is delivered to your host.</p><p>How would you use VLANs in OpenBSD? Perhaps you have a network divided into multiple Ethernet segments, such as outside the firewall, server area, and desktop clients. Or you might have one OpenBSD host that needs direct access to all of these segments. You could route all of these networks over a single physical wire. You might eventually hit bandwidth problems, but if you’re pushing more than 1Gpbs through your server, you can afford a second network card.</p><div class="sect2" title="Configuring Switches"><div class="titlepage"><div><div><h3 class="title" id="configuring_switches">Configuring Switches</h3></div></div></div><p>You must configure your switch to send the VLANs to your OpenBSD box as 802.1q or tagged, depending on the switch’s syntax. Cisco uses <span class="emphasis"><em>802.1q</em></span>, HP’s Procurve switches use <span class="emphasis"><em>tagged</em></span>, and other vendors use whatever their prejudices dictate. There are dozens of different syntaxes to do this, so I won’t give a specific example. If the switch can’t send tagged VLANs to your server, you cannot use VLANs.</p></div><div class="sect2" title="Configuring VLAN Devices"><div class="titlepage"><div><div><h3 class="title" id="configuring_vlan_devices">Configuring VLAN Devices</h3></div></div></div><p>OpenBSD creates <code class="literal">vlan(4)</code> interfaces upon request. To create the device, you need to know which physical device you want to attach the VLAN to and the number of the VLAN you’re expecting.</p><p>Create the <code class="literal">vlan</code> interface with <code class="literal">ifconfig</code>.</p><a id="I_programlisting12_id463986"/><pre class="programlisting"># <span class="strong"><strong>ifconfig vlan<span class="emphasis"><em>X</em></span> vlan <span class="emphasis"><em>vlan#</em></span> vlandev <span class="emphasis"><em>interface</em></span></strong></span></pre><p>I number my <code class="literal">vlan</code> interfaces after the VLAN number they’re used for. (You could create interface <code class="literal">vlan0</code> and attach it to VLAN 3, but that’s too confusing for my feeble brain.) If you don’t specify the VLAN number, OpenBSD assigns the VLAN number from the number on the interface.</p><p>For example, here I create interface <code class="literal">vlan3</code> and use it to access VLAN 3 over interface <code class="literal">fxp0</code>.</p><a id="I_programlisting12_id464028"/><pre class="programlisting"># ifconfig vlan3 vlandev fxp0</pre><p><a class="indexterm" id="idx0169"/><a class="indexterm" id="idx0993"/><a class="indexterm" id="idx1015"/><a class="indexterm" id="idx1123"/><a class="indexterm" id="idx2465"/>That’s really all there is to it. Now you can use <code class="literal">ifconfig</code> to display your new interface:</p><a id="I_programlisting12_id464079"/><pre class="programlisting">$ <span class="strong"><strong>ifconfig vlan3</strong></span>
vlan3: flags=48843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST,INET6_PRIVACY&gt; mtu 1500
        lladdr 00:16:36:c0:58:a5
        priority: 0
        vlan: 3 parent interface: fxp0
        groups: vlan
        status: active
        inet6 fe80::216:36ff:fec0:58a5%vlan3 prefixlen 64 scopeid 0x7</pre><p>This looks exactly like any physical interface, and from your point of view, it is. You can add IP addresses just as you would to any other interface, assign routes, and get on with your life.</p></div><div class="sect2" title="Configuring VLANs at Boot"><div class="titlepage"><div><div><h3 class="title" id="configuring_vlans_at_boot">Configuring VLANs at Boot</h3></div></div></div><p>To configure a VLAN interface at boot time, create a <span class="emphasis"><em>hostname.if</em></span> file for it. For example, here’s the contents of a <span class="emphasis"><em>/etc/hostname.vlan3</em></span> that creates the <code class="literal">vlan3</code> interface demonstrated in the previous section, assigns it to VLAN 3, and configures it automatically for both IPv4 and IPv6:</p><a id="I_programlisting12_id464120"/><pre class="programlisting">vlandev fxp0
dhcp
rtsol</pre><p>OpenBSD should find this file at boot and create the interface according to your commands.</p></div></div><div class="sect1" title="IPv6 Over Tunnels"><div class="titlepage"><div><div><h2 class="title" id="ipv6_over_tunnels" style="clear: both">IPv6 Over Tunnels</h2></div></div></div><p>Let’s say you’ve taken my badgering to heart and decided to experiment with IPv6, but your ISP doesn’t offer IPv6. How can you play with IPv6 when all you get is an IPv4 feed?</p><p>Many companies offer a free IPv6 tunnel service, where they will route you through an IPv6 tunnel over IPv4. They will even give you an IPv6 /64 at no charge, so you can configure your home network for IPv6.</p><p>While I generally avoid recommending vendors in this book, I do recommend Hurricane Electric’s IPv6 tunnel service at <span class="emphasis"><em><a class="ulink" href="http://www.tunnelbroker.net/" target="_top">http://www.tunnelbroker.net/</a></em></span>. Its web interface is intuitive, and it even provides configurations for OpenBSD clients.</p><p>You should now have some understanding of managing IPv4 and IPv6 on OpenBSD. While your brain is recovering from all this stuff, we’ll turn to the topic of managing add-on software in OpenBSD.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.id309258"><p><sup>[<a class="para" href="#id309258">33</a>] </sup>Many people offer to ship me to Siberia. But they all forget to include a return ticket. Strange.</p></div></div></section></body></html>