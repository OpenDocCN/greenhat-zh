- en: Chapter 16. Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章。正则表达式
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: Regular expressions provide you with powerful ways to find and modify patterns
    in text—not only short bits of text such as might be entered at a command prompt
    but also huge stores of text such as might be found in files on disk.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式为你提供了强大的方法来在文本中查找和修改模式——不仅是在命令提示符中可能输入的短文本片段，还包括在磁盘上的文件中可能找到的大量文本。
- en: A regular expression takes the form of a pattern that is compared with a string.
    Regular expressions also provide the means by which you can modify strings so
    that, for example, you might change specific characters by putting them into uppercase,
    you might replace every occurrence of “Diamond” with “Ruby,” or you might read
    in a file of programming code, extract all the comments, and write out a new documentation
    file containing all the comments but none of the code. You’ll find out how to
    write a comment-extraction tool shortly. First, though, let’s take a look at some
    very simple regular expressions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式采用与字符串进行比较的模式的形式。正则表达式还提供了修改字符串的手段，例如，你可能通过将它们转换为大写来更改特定字符，你可能将“Diamond”的每个出现替换为“Ruby”，或者你可能读取一个编程代码文件，提取所有注释，并输出一个包含所有注释但不含代码的新文档文件。你将很快了解到如何编写注释提取工具。不过，首先，让我们看看一些非常简单的正则表达式。
- en: Making Matches
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配
- en: 'Just about the simplest regular expression is a sequence of characters (such
    as “abc”) that you want to find in a string. A regular expression to match “abc”
    can be created by placing those letters between two forward slash delimiters,
    like this: `/abc/`. You can test for a match using the `=˜` operator method like
    this:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎最简单的正则表达式是想要在字符串中找到的一系列字符（例如“abc”）。要匹配“abc”，可以通过在两个正斜杠分隔符之间放置这些字母来创建正则表达式：`/abc/`。你可以使用`=˜`运算符方法来测试匹配，如下所示：
- en: '*regex0.rb*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*regex0.rb*'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If a match is made, an integer representing the character position in the string
    is returned. If no match is made, `nil` is returned.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配成功，将返回一个表示字符串中字符位置的整数。如果没有匹配成功，将返回`nil`。
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can also specify a group of characters, between square brackets, in which
    case a match will be made with any one of those characters in the string. Here,
    for example, the first match is made with “c”; then that character’s position
    in the string is returned:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以指定一个字符组，放在方括号内，在这种情况下，匹配将在字符串中的任何一个字符上完成。例如，第一个匹配是在“c”上完成的；然后返回该字符在字符串中的位置：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Although I’ve used forward-slash delimiters in the previous examples, there
    are alternative ways of defining regular expressions: You can specifically create
    a new Regexp object initialized with a string, or you can precede the regular
    expression with `%r` and use custom delimiters—nonalphanumeric characters—as you
    can with strings (see [Chapter 3](ch03.html "Chapter 3. Strings and Ranges")).
    In the following example, I use curly bracket delimiters:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我在之前的例子中使用了正斜杠作为分隔符，但定义正则表达式还有其他方法：你可以创建一个新的以字符串初始化的Regexp对象，或者你可以在正则表达式前加上`%r`并使用自定义的分隔符——非字母数字字符，就像在字符串中使用的那样（参见[第3章](ch03.html
    "第3章。字符串和范围")）。在下面的例子中，我使用了花括号作为分隔符：
- en: '*regex1.rb*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*regex1.rb*'
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Each of the previous examples defines a regular expression that matches an
    all-lowercase string (I’ll explain the details of the expressions shortly). These
    expressions can be used to test strings like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个之前的例子都定义了一个正则表达式，用于匹配全小写字符串（我将在稍后解释表达式的细节）。这些表达式可以用来测试如下字符串：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To test for a match, you can use `if` and the `=˜` operator:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试匹配，你可以使用`if`和`=˜`运算符：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The previous expression evaluates to true if a match is made (and an integer
    is returned); it would evaluate to false if no match were made (and `nil` were
    returned):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配成功（并返回一个整数），则前面的表达式计算结果为真；如果没有匹配成功（并返回`nil`），则计算结果为假：
- en: '*if_test.rb*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*if_test.rb*'
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Frequently, it is useful to attempt to match some expression from the very start
    of a string; you can use the character `^` followed by a match term to specify
    this. It may also be useful to make a match from the end of the string; you use
    the character `$` preceded by a match term to specify that.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，尝试从字符串的起始位置匹配某些表达式是有用的；你可以使用字符`^`后跟一个匹配项来指定这一点。也可能有用的是从字符串的末尾进行匹配；你使用字符`$`后跟一个匹配项来指定这一点。
- en: '*start_end1.rb*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*start_end1.rb*'
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned previously, when a `nil` value is passed to `print` or `puts` in
    Ruby 1.9, nothing is displayed. In Ruby 1.8, `nil` is displayed. To be sure that
    `nil` is displayed in Ruby 1.9, use `p` instead of `puts`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当将 `nil` 值传递给 Ruby 1.9 中的 `print` 或 `puts` 时，不会显示任何内容。在 Ruby 1.8 中，会显示
    `nil`。为了确保在 Ruby 1.9 中显示 `nil`，请使用 `p` 而不是 `puts`。
- en: 'Matching from the start or end of a string becomes more useful when it forms
    part of a more complex expression. Often such an expression tries to match zero
    or more instances of a specified pattern. The `*` character is used to indicate
    zero or more matches of the pattern that it follows. Formally, this is known as
    a *quantifier*. Consider this example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从字符串的开始或结束进行匹配，当它成为更复杂表达式的一部分时更有用。通常这样的表达式试图匹配零个或多个指定的模式实例。`*` 字符用于表示它后面的模式的零个或多个匹配。形式上，这被称为
    *量词*。考虑以下示例：
- en: '*start_end2.rb*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*start_end2.rb*'
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, the regular expression specifies a range of characters between square
    brackets. This range includes all lowercase characters (a–z), all digits (0–9),
    and the space character (that’s the space between the `z` and the `0` in the expression
    shown earlier). The `^` character means the match must be made from the start
    of the string, the `*` character after the range means that zero or more matches
    with the characters in the range must be made, and the `$` character means that
    the matches must be made right up to the end of the string. In other words, this
    pattern will only match a string containing lowercase characters, digits, and
    spaces from the start right to the end of the string:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，正则表达式指定了方括号之间的字符范围。这个范围包括所有小写字母（a–z）、所有数字（0–9）以及空格字符（这是表达式中 `z` 和 `0` 之间的空格）。`^`
    字符表示匹配必须从字符串的开头开始，范围后面的 `*` 字符表示必须匹配零个或多个该范围内的字符，而 `$` 字符表示匹配必须一直进行到字符串的末尾。换句话说，这个模式只会匹配从字符串开头到末尾包含小写字母、数字和空格的字符串：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Actually, this pattern will also match an empty string, since `*` indicates
    that *zero or more* matches are acceptable:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个模式也会匹配空字符串，因为 `*` 表示零个或多个匹配是可以接受的：
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you want to exclude empty strings, use `+` (to match *one or more* occurrences
    of the pattern):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要排除空字符串，请使用 `+`（以匹配 *一个或多个* 模式出现）：
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Try the code in *start_end2.rb* for more examples of ways in which `^`, `$`,
    `*` and `+` may be combined with ranges to create a variety of different match
    patterns.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行 *start_end2.rb* 以获取更多关于如何将 `^`、`$`、`*` 和 `+` 与范围结合以创建不同匹配模式的示例。
- en: 'You could use these techniques to determine specific characteristics of strings,
    such as whether a given string is uppercase, lowercase, or mixed case:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些技术来确定字符串的特定特征，例如，确定一个给定的字符串是大写、小写还是混合大小写：
- en: '*regex2.rb*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*regex2.rb*'
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since the string assigned to `aStr` is currently all uppercase, the previous
    code displays the “Uppercase” string. But if `aStr` were assigned `hello world`,
    it would display “Lowercase,” and if `aStr` were assigned `Hello World`, it would
    display “Mixed case.”
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分配给 `aStr` 的字符串目前全部为大写，所以前面的代码显示“大写”字符串。但如果 `aStr` 被分配为 `hello world`，它将显示“小写”，如果
    `aStr` 被分配为 `Hello World`，它将显示“混合大小写”。
- en: Often regular expressions are used to process the text in a file on disk. Let’s
    suppose, for example, that you want to display all the full-line comments in a
    Ruby file but omit all the code and partial-line comments. You could do this by
    trying to match from the start of each line (`^`) zero or more whitespace characters
    (a whitespace character is represented by `\s`) up to a comment character (`#`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 经常使用正则表达式来处理磁盘上文件中的文本。例如，假设你想显示 Ruby 文件中的所有完整行注释，但省略所有代码和部分行注释。你可以通过尝试从每行的开头（`^`）匹配零个或多个空白字符（空白字符用
    `\s` 表示）直到注释字符（`#`）来实现这一点。
- en: '*regex3a.rb*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*regex3a.rb*'
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Match Groups
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配组
- en: 'You can also use a regular expression to match one or more substrings. To do
    this, you should put part of the regular expression between parentheses. Here
    I have two groups (sometimes called *captures*): The first tries to match the
    string “hi”, and the second tries to match a string starting with “h” followed
    by any three characters (a dot means “match any single character,” so the three
    dots here will match any three consecutive characters) and ending with “o”:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用正则表达式来匹配一个或多个子字符串。为此，你应该将正则表达式的一部分放在括号内。这里我有两个组（有时称为 *捕获*）：第一个尝试匹配字符串“hi”，第二个尝试匹配以“h”开头后跟任意三个字符（点表示“匹配任意单个字符”，所以这里的三个点将匹配任意三个连续字符）并以“o”结尾的字符串：
- en: '*groups.rb*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*groups.rb*'
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After evaluating groups in a regular expression, a number of variables, equal
    to the number of groups, will be assigned the matched value of those groups. These
    variables take the form of a `$` followed by a number: `$1`, `$2`, `$3`, and so
    on. After executing the previous code, I can access the variables `$1` and `$2`
    like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中评估组之后，将分配若干变量，其数量等于组的数量。这些变量采用以下形式：一个 `$` 符号后跟一个数字：`$1`、`$2`、`$3`，依此类推。执行前面的代码后，我可以这样访问变量
    `$1` 和 `$2`：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that if the entire regular expression is unmatched, none of the group variables
    will be initialized. This would be the case if, for example, “hi” were in the
    string but “hello” was not. Both group variables would then be `nil`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果整个正则表达式没有匹配，则不会初始化任何组变量。例如，如果字符串中包含“hi”但“hello”不包含，就会发生这种情况。两个组变量都将为 `nil`。
- en: 'Here is another example, which returns three groups, indicated by pairs of
    parentheses (`()`), each of which contains a single character given by the dot:
    `(.)`. Groups `$1` and `$3` are then displayed:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，它返回三个组，由一对括号（`()`）表示，每个括号包含一个由点表示的单个字符：`(.)`。然后显示组 `$1` 和 `$3`：
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is a new version of the comment-matching program that was given earlier
    (*regex3a.rb*); this has now been adapted to use the value of the group `()` containing
    a dot followed by an asterisk `(.*)` to return all the characters (zero or more)
    following the string matched by the preceding part of the regular expression (which
    here is `^\s*#`). This new version reads the text from the specified file and
    matches zero or more whitespace (`\s*`) characters from the start of the current
    line (`^`) up to the first occurrence of a hash mark: `#`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是之前给出的注释匹配程序的新版本（*regex3a.rb*）；现在它已经被修改为使用包含点后跟星号（`(.*)`）的组 `()` 的值，以返回正则表达式前一部分匹配的字符串（此处为
    `^\s*#`）之后的所有字符（零个或多个）。这个新版本从指定的文件中读取文本，并匹配从当前行开始（`^`）到第一个出现井号（`#`）之前的零个或多个空白字符（`\s*`）：
- en: '*regex3b.rb*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*regex3b.rb*'
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The end result of this is that only lines in which the first printable character
    is `#` are matched; `$1` prints out the text of those lines minus the `#` character
    itself. As you will see shortly, this simple technique provides the basis of a
    useful tool for extracting documentation from a Ruby file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，只有第一可打印字符是 `#` 的行才会匹配；`$1` 打印出这些行的文本，减去 `#` 字符本身。您很快就会看到，这种简单技术为从 Ruby 文件中提取文档提供了一个有用的工具的基础。
- en: 'You aren’t limited merely to extracting and displaying characters verbatim;
    you can also modify text. This example displays the text from a Ruby file but
    changes all Ruby line-comment characters (`#`) preceding full-line comments to
    C-style line comments (`//`):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您不仅限于提取和显示字符；您还可以修改文本。这个例子显示了 Ruby 文件中的文本，但将所有 Ruby 行注释字符（`#`）更改为 C 风格的行注释（`//`）：
- en: '*regex4.rb*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*regex4.rb*'
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this example, the `sub` method of the String class has been used; this takes
    a regular expression as its first argument (`/(^\s*)#(.*)/`) and a replacement
    string as the second argument (`''\1//\2''`). The replacement string may contain
    numbered placeholders such as `\1` and `\2` to match any groups in the regular
    expression—here there are two groups between parentheses: `(^\s*)` and `(.*)`.
    The `sub` method returns a new string in which the matches made by the regular
    expression are substituted into the replacement string, while any unmatched elements
    (here the `#` character) are omitted. So, for example, let’s assume that the following
    comments are found in the input file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用了 String 类的 `sub` 方法；它将正则表达式作为其第一个参数（`/(^\s*)#(.*)/`）和替换字符串作为第二个参数（`'\1//\2'`）。替换字符串可以包含编号占位符，如
    `\1` 和 `\2`，以匹配正则表达式中的任何组——这里有两个括号之间的组：（`^\s*`）和（`(.*)`）。`sub` 方法返回一个新的字符串，其中正则表达式所做的匹配被替换到替换字符串中，而任何未匹配的元素（此处为
    `#` 字符）被省略。例如，假设在输入文件中找到了以下注释：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After substitution using our regular expression, the displayed output is as
    follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的正则表达式替换后，显示的输出如下：
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: MatchData
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MatchData
- en: The `=˜` operator is not the only means of finding a match. The Regexp class
    also has a `match` method. This works in similar way to `=˜`, but when a match
    is made, it returns a MatchData object rather than an integer. A MatchData object
    contains the result of a pattern match. At first sight, this may appear to be
    a string.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`=˜` 运算符不是找到匹配的唯一方法。Regexp 类还有一个 `match` 方法。这与 `=˜` 的工作方式类似，但在匹配成功时，它返回一个 MatchData
    对象而不是一个整数。MatchData 对象包含模式匹配的结果。乍一看，这似乎是一个字符串。'
- en: '*match.rb*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*match.rb*'
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In fact, it is an instance of the MatchData class that contains a string:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这是一个包含字符串的 MatchData 类的实例：
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A MatchData object may contain groups, or *captures*, and these can be returned
    in an array using either the `to_a` or `captures` method, like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: MatchData 对象可能包含组，或 *捕获*，并且可以使用 `to_a` 或 `captures` 方法以数组的形式返回它们，如下所示：
- en: '*matchdata.rb*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*matchdata.rb*'
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The previous displays the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的显示如下：
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that there is a subtle difference between the `captures` and `to_a` methods.
    The first returns only the captures:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`captures` 和 `to_a` 方法之间存在细微的区别。第一个只返回捕获的内容：
- en: '[PRE25]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second returns the original string (at index 0) followed by the captures:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个返回原始字符串（索引 0）后跟捕获的内容：
- en: '[PRE26]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Prematch and Postmatch
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预匹配和后匹配
- en: 'The MatchData class supplies the `pre_match` and `post_match` methods to return
    the strings preceding or following a match. Here, for example, I am making a match
    on the comment character, `#`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: MatchData 类提供了 `pre_match` 和 `post_match` 方法来返回匹配之前或之后的字符串。例如，我正在对注释字符 `#` 进行匹配：
- en: '*pre_post_match.rb*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*pre_post_match.rb*'
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, you can use the special variables, `` $` `` (with a backquote)
    and `$''` (with a normal quote), to access pre- and postmatches, respectively:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用特殊变量 `` $` ``（带有反引号）和 `$'`（带有普通引号），分别访问前匹配和后匹配：
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When using `match` with groups, you can use array-style indexing to obtain
    specific items. Index 0 is the original string; higher indexes are the groups:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `match` 与组一起使用时，您可以使用数组样式索引来获取特定项。索引 0 是原始字符串；更高的索引是组：
- en: '*match_groups.rb*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*match_groups.rb*'
- en: '[PRE29]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can use the special variable `$˜` to access the last MatchData object,
    and once again you can refer to groups using array-style indexing:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用特殊变量 `$˜` 来访问最后一个 MatchData 对象，并且您还可以通过数组样式索引来引用组：
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, to use the full range of methods of the Array class, you must use
    `to_a` or `captures` to return the match groups as an array:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使用 Array 类的全部方法，您必须使用 `to_a` 或 `captures` 来将匹配组作为数组返回：
- en: '[PRE31]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Greedy Matching
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贪婪匹配
- en: When a string contains more than one potential match, you may sometimes want
    to return the string up to the *first* match (that is, as little of the string
    as possible consistent with the match pattern), and at other times you may want
    the string up to the *last* match (that is, as much of the string as possible).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个字符串包含多个潜在的匹配时，您有时可能希望返回到 *第一个* 匹配的字符串（即与匹配模式一致的最小字符串），而在其他时候，您可能希望返回到 *最后一个*
    匹配的字符串（即尽可能多的字符串）。
- en: 'In the latter case (getting as much of the string as possible), the match is
    said to be *greedy*. The `*` and `+` pattern quantifiers are greedy. However,
    you can put them on a diet, to make them return the least possible, by putting
    `?` after them:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在后一种情况下（尽可能多地获取字符串），匹配被称为 *贪婪的*。`*` 和 `+` 模式量词是贪婪的。然而，您可以通过在它们后面放置 `?` 来限制它们的贪婪程度，使它们返回尽可能少的内容：
- en: '*greedy1.rb*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*greedy1.rb*'
- en: '[PRE32]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can control the greediness of pattern matching to do things such as process
    directory paths (here matching on the `\` character):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以控制模式匹配的贪婪性，以执行诸如处理目录路径（这里匹配 `\` 字符）之类的操作：
- en: '*greedy2.rb*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*greedy2.rb*'
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: String Methods
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串方法
- en: 'Up to now, I’ve used methods of the Regexp class when processing strings. In
    fact, pattern matching can go both ways because the String class has a few regular
    expression methods of its own. These include `=˜` and `match` (so you can switch
    the order of the String and Regexp objects when matching), plus the `scan` method
    that iterates through a string looking for as many matches as possible. Each match
    is added to an array. Here, for example, I am looking for matches on the letters
    *a*, *b*, or *c*. The `match` method returns the first match (“a”) wrapped up
    in a MatchData object, but the `scan` method keeps scanning along the string and
    returns all the matches it finds as elements in an array:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我在处理字符串时使用了 Regexp 类的方法。实际上，模式匹配可以双向进行，因为 String 类本身也有一些正则表达式方法。这些包括 `=˜`
    和 `match`（因此你可以在匹配时切换 String 和 Regexp 对象的顺序），以及 `scan` 方法，它遍历字符串寻找尽可能多的匹配项。每个匹配项都被添加到一个数组中。例如，我正在寻找字母
    *a*、*b* 或 *c* 的匹配项。`match` 方法返回第一个匹配项（“a”）并封装在 MatchData 对象中，但 `scan` 方法会继续扫描字符串，并返回它找到的所有匹配项作为数组的元素：
- en: '*match_scan.rb*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*match_scan.rb*'
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `scan` method may optionally be passed a block so that the elements of
    the array created by `scan` can be processed in some way:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`scan` 方法可以可选地传递一个块，以便 `scan` 创建的数组元素可以被以某种方式处理：'
- en: '[PRE35]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A number of other String methods can be used with regular expressions. One
    version of the `String.slice` method takes a regular expression as an argument
    and returns any matched substring, leaving the original (*receiver*) string unmodified.
    The `String.slice!` method (note the `!` at the end) deletes the matched substring
    from the receiver string and returns the substring:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用正则表达式与许多其他 String 方法一起使用。`String.slice` 方法的一个版本接受一个正则表达式作为参数，并返回任何匹配的子字符串，同时不修改原始（接收者）字符串。`String.slice!`
    方法（注意末尾的 `!`）从接收者字符串中删除匹配的子字符串，并返回该子字符串：
- en: '*string_slice.rb*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*string_slice.rb*'
- en: '[PRE36]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `split` method splits a string into substrings, based on a pattern. The
    results (minus the pattern) are returned as an array:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`split` 方法根据模式将字符串分割成子字符串。结果（减去模式）作为数组返回：'
- en: '*string_ops.rb*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*string_ops.rb*'
- en: '[PRE37]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can also split on an empty pattern (`//`):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以根据空模式（`//`）进行分割：
- en: '[PRE38]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this case, an array of characters is returned:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，返回一个字符数组：
- en: '[PRE39]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can use the `sub` method to match a regular expression and replace its
    first occurrence with a string. If no match is made, the string is returned unchanged:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `sub` 方法来匹配正则表达式，并将其第一次出现替换为字符串。如果没有匹配，则返回未更改的字符串：
- en: '[PRE40]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `sub!` method works like `sub` but modifies the original (receiver) string.
    Alternatively, you can use the `gsub` method (or `gsub!` to modify the receiver)
    to substitute all occurrences of the pattern with a string:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub!` 方法与 `sub` 方法类似，但修改了原始（接收者）字符串。或者，你可以使用 `gsub` 方法（或 `gsub!` 来修改接收者）来替换模式的所有出现：'
- en: '[PRE41]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: File Operations
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件操作
- en: 'I said earlier that regular expressions are often used to process data stored
    in files on disk. In some earlier examples, I read in data from a disk file, did
    some pattern matching, and displayed the results on the screen. Here is one more
    example in which I count the words in a file. You do this by scanning each line
    in order to create an array of words (that is, sequences of alphanumeric characters)
    and then adding the size of each array to the variable, `count`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到正则表达式通常用于处理存储在磁盘文件中的数据。在一些早期的例子中，我从磁盘文件中读取数据，进行了一些模式匹配，并将结果显示在屏幕上。这里有一个额外的例子，其中我统计文件中的单词。你这样做是通过按顺序扫描每一行来创建一个单词数组（即数字字符序列），然后将每个数组的长度添加到变量
    `count` 中：
- en: '*wordcount.rb*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*wordcount.rb*'
- en: '[PRE42]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you want to verify that the word count is correct, you could display a numbered
    list of words read in from the file. This is what is do here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要验证单词计数是否正确，你可以显示从文件中读取的单词的编号列表。这就是我在这里所做的事情：
- en: '*wordcount2.rb*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*wordcount2.rb*'
- en: '[PRE43]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now let’s see how to deal with two files at once—one for reading, another for
    writing. The next example opens the file *testfile1.txt* for writing and passes
    the file variable, `f`, into a block. I now open a second file, *regex1.rb*, for
    reading and use `File.foreach` to pass into a second block each line of text read
    from this file. I use a simple regular expression to create a new string to match
    lines with Ruby-style comments; the code substitutes C-style comment characters
    (`//`) for the Ruby comment character (`#`) when that character is the first nonwhitespace
    character on a line and writes each line to *testfile1.txt* with code lines unmodified
    (because there are no matches on those) and with comment lines changed to C-style
    comment lines:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何同时处理两个文件——一个用于读取，另一个用于写入。下一个示例打开 *testfile1.txt* 文件进行写入，并将文件变量 `f`
    传递到一个块中。我现在打开第二个文件 *regex1.rb* 进行读取，并使用 `File.foreach` 将从该文件读取的每一行文本传递到第二个块中。我使用一个简单的正则表达式来创建一个新的字符串以匹配具有
    Ruby 风格注释的行；当注释字符（`//`）是行上的第一个非空白字符时，代码将 C 风格注释字符替换为 Ruby 注释字符（`#`），并将每一行写入 *testfile1.txt*，代码行保持不变（因为没有匹配项），而注释行则改为
    C 风格注释行：
- en: '*regexp_file1.rb*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*regexp_file1.rb*'
- en: '[PRE44]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This illustrates just how much can be done with regular expressions and very
    little coding. The next example shows how you might read in one file (here the
    file *regex1.rb*) and write out two new files—one of which (*comments.txt*) contains
    only line comments, while the other (*nocomments.txt*) contains all the other
    lines.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了使用正则表达式和非常少的代码可以完成多少工作。下一个示例展示了你可能如何读取一个文件（这里是指文件 *regex1.rb*）并写入两个新文件——其中一个（*comments.txt*）只包含行注释，而另一个（*nocomments.txt*）包含所有其他行。
- en: '*regexp_file2.rb*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*regexp_file2.rb*'
- en: '[PRE45]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Digging Deeper
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: This section provides a handy summary of regular expressions followed by some
    short examples in ready-to-use Ruby code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了一个正则表达式的便捷总结，后面是一些 Ruby 代码中的简短示例。
- en: Regular Expression Elements
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式元素
- en: 'This is a list of some of the elements that can be used in regular expressions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以使用在正则表达式中的元素列表：
- en: '| `^` | Beginning of a line or string |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 行或字符串的开始 |'
- en: '| `$` | End of a line or string |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 行或字符串的末尾 |'
- en: '| `.` | Any character except newline |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 任何字符（除了换行符） |'
- en: '| `*` | Zero or more previous regular expression |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 前一个正则表达式的零个或多个重复 |'
- en: '| `*?` | Zero or more previous regular expression (nongreedy) |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `*?` | 零个或多个前面的正则表达式（非贪婪） |'
- en: '| `+` | One or more previous regular expression |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 前一个正则表达式的多个重复 |'
- en: '| `+?` | One or more previous regular expression (nongreedy) |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `+?` | 前一个正则表达式的多个重复（非贪婪） |'
- en: '| `[]` | Range specification (for example, `[a-z]` means a character in the
    range a-z) |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `[]` | 范围指定（例如，`[a-z]` 表示 a-z 范围内的字符） |'
- en: '| `\w` | An alphanumeric character |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 一个字母数字字符 |'
- en: '| `\W` | A nonalphanumeric character |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `\W` | 一个非字母数字字符 |'
- en: '| `\s` | A whitespace character |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 一个空白字符 |'
- en: '| `\S` | A nonwhitespace character |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `\S` | 一个非空白字符 |'
- en: '| `\d` | A digit |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 一个数字 |'
- en: '| `\D` | A nondigit character |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `\D` | 一个非数字字符 |'
- en: '| `\b` | A backspace (when in a range specification) |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 退格符（当在范围指定中时） |'
- en: '| `\b` | Word boundary (when not in a range specification) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 单词边界（当不在范围指定中时） |'
- en: '| `\B` | Nonword boundary |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `\B` | 非单词边界 |'
- en: '| `*` | Zero or more repetitions of the preceding |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 前一个字符的零个或多个重复 |'
- en: '| `+` | One or more repetitions of the preceding |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 前一个字符的一个或多个重复 |'
- en: '| `{m,n}` | At least `m` and at most `n` repetitions of the preceding |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `{m,n}` | 前一个字符至少重复 m 次，最多重复 n 次 |'
- en: '| `?` | At most one repetition of the preceding |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 前一个字符最多重复一次 |'
- en: '| `&#124;` | Either the preceding or next expression may match |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 前一个或下一个表达式可以匹配 |'
- en: '| `()` | A group |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `()` | 一个分组 |'
- en: Regular Expression Examples
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式示例
- en: 'Here are a few more sample regular expressions:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多的示例正则表达式：
- en: '*overview.rb*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*overview.rb*'
- en: '[PRE46]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Symbols and Regular Expressions
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 符号和正则表达式
- en: Ruby 1.9 permits you to use `match` with a symbol. The symbol is converted to
    a string, and the index of the match is returned. Symbols cannot be used in this
    manner with Ruby 1.8.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.9 允许你使用 `match` 与符号。符号将被转换为字符串，并返回匹配的索引。在 Ruby 1.8 中不能以这种方式使用符号。
- en: '*regexp_symbols.rb*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*regexp_symbols.rb*'
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
