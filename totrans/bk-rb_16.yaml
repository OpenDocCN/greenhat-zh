- en: Chapter 16. Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Regular expressions provide you with powerful ways to find and modify patterns
    in text—not only short bits of text such as might be entered at a command prompt
    but also huge stores of text such as might be found in files on disk.
  prefs: []
  type: TYPE_NORMAL
- en: A regular expression takes the form of a pattern that is compared with a string.
    Regular expressions also provide the means by which you can modify strings so
    that, for example, you might change specific characters by putting them into uppercase,
    you might replace every occurrence of “Diamond” with “Ruby,” or you might read
    in a file of programming code, extract all the comments, and write out a new documentation
    file containing all the comments but none of the code. You’ll find out how to
    write a comment-extraction tool shortly. First, though, let’s take a look at some
    very simple regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Making Matches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just about the simplest regular expression is a sequence of characters (such
    as “abc”) that you want to find in a string. A regular expression to match “abc”
    can be created by placing those letters between two forward slash delimiters,
    like this: `/abc/`. You can test for a match using the `=˜` operator method like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*regex0.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If a match is made, an integer representing the character position in the string
    is returned. If no match is made, `nil` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify a group of characters, between square brackets, in which
    case a match will be made with any one of those characters in the string. Here,
    for example, the first match is made with “c”; then that character’s position
    in the string is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Although I’ve used forward-slash delimiters in the previous examples, there
    are alternative ways of defining regular expressions: You can specifically create
    a new Regexp object initialized with a string, or you can precede the regular
    expression with `%r` and use custom delimiters—nonalphanumeric characters—as you
    can with strings (see [Chapter 3](ch03.html "Chapter 3. Strings and Ranges")).
    In the following example, I use curly bracket delimiters:'
  prefs: []
  type: TYPE_NORMAL
- en: '*regex1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the previous examples defines a regular expression that matches an
    all-lowercase string (I’ll explain the details of the expressions shortly). These
    expressions can be used to test strings like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To test for a match, you can use `if` and the `=˜` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous expression evaluates to true if a match is made (and an integer
    is returned); it would evaluate to false if no match were made (and `nil` were
    returned):'
  prefs: []
  type: TYPE_NORMAL
- en: '*if_test.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Frequently, it is useful to attempt to match some expression from the very start
    of a string; you can use the character `^` followed by a match term to specify
    this. It may also be useful to make a match from the end of the string; you use
    the character `$` preceded by a match term to specify that.
  prefs: []
  type: TYPE_NORMAL
- en: '*start_end1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned previously, when a `nil` value is passed to `print` or `puts` in
    Ruby 1.9, nothing is displayed. In Ruby 1.8, `nil` is displayed. To be sure that
    `nil` is displayed in Ruby 1.9, use `p` instead of `puts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Matching from the start or end of a string becomes more useful when it forms
    part of a more complex expression. Often such an expression tries to match zero
    or more instances of a specified pattern. The `*` character is used to indicate
    zero or more matches of the pattern that it follows. Formally, this is known as
    a *quantifier*. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*start_end2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the regular expression specifies a range of characters between square
    brackets. This range includes all lowercase characters (a–z), all digits (0–9),
    and the space character (that’s the space between the `z` and the `0` in the expression
    shown earlier). The `^` character means the match must be made from the start
    of the string, the `*` character after the range means that zero or more matches
    with the characters in the range must be made, and the `$` character means that
    the matches must be made right up to the end of the string. In other words, this
    pattern will only match a string containing lowercase characters, digits, and
    spaces from the start right to the end of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, this pattern will also match an empty string, since `*` indicates
    that *zero or more* matches are acceptable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to exclude empty strings, use `+` (to match *one or more* occurrences
    of the pattern):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Try the code in *start_end2.rb* for more examples of ways in which `^`, `$`,
    `*` and `+` may be combined with ranges to create a variety of different match
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could use these techniques to determine specific characteristics of strings,
    such as whether a given string is uppercase, lowercase, or mixed case:'
  prefs: []
  type: TYPE_NORMAL
- en: '*regex2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since the string assigned to `aStr` is currently all uppercase, the previous
    code displays the “Uppercase” string. But if `aStr` were assigned `hello world`,
    it would display “Lowercase,” and if `aStr` were assigned `Hello World`, it would
    display “Mixed case.”
  prefs: []
  type: TYPE_NORMAL
- en: Often regular expressions are used to process the text in a file on disk. Let’s
    suppose, for example, that you want to display all the full-line comments in a
    Ruby file but omit all the code and partial-line comments. You could do this by
    trying to match from the start of each line (`^`) zero or more whitespace characters
    (a whitespace character is represented by `\s`) up to a comment character (`#`).
  prefs: []
  type: TYPE_NORMAL
- en: '*regex3a.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Match Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also use a regular expression to match one or more substrings. To do
    this, you should put part of the regular expression between parentheses. Here
    I have two groups (sometimes called *captures*): The first tries to match the
    string “hi”, and the second tries to match a string starting with “h” followed
    by any three characters (a dot means “match any single character,” so the three
    dots here will match any three consecutive characters) and ending with “o”:'
  prefs: []
  type: TYPE_NORMAL
- en: '*groups.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After evaluating groups in a regular expression, a number of variables, equal
    to the number of groups, will be assigned the matched value of those groups. These
    variables take the form of a `$` followed by a number: `$1`, `$2`, `$3`, and so
    on. After executing the previous code, I can access the variables `$1` and `$2`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that if the entire regular expression is unmatched, none of the group variables
    will be initialized. This would be the case if, for example, “hi” were in the
    string but “hello” was not. Both group variables would then be `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example, which returns three groups, indicated by pairs of
    parentheses (`()`), each of which contains a single character given by the dot:
    `(.)`. Groups `$1` and `$3` are then displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a new version of the comment-matching program that was given earlier
    (*regex3a.rb*); this has now been adapted to use the value of the group `()` containing
    a dot followed by an asterisk `(.*)` to return all the characters (zero or more)
    following the string matched by the preceding part of the regular expression (which
    here is `^\s*#`). This new version reads the text from the specified file and
    matches zero or more whitespace (`\s*`) characters from the start of the current
    line (`^`) up to the first occurrence of a hash mark: `#`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*regex3b.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The end result of this is that only lines in which the first printable character
    is `#` are matched; `$1` prints out the text of those lines minus the `#` character
    itself. As you will see shortly, this simple technique provides the basis of a
    useful tool for extracting documentation from a Ruby file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You aren’t limited merely to extracting and displaying characters verbatim;
    you can also modify text. This example displays the text from a Ruby file but
    changes all Ruby line-comment characters (`#`) preceding full-line comments to
    C-style line comments (`//`):'
  prefs: []
  type: TYPE_NORMAL
- en: '*regex4.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `sub` method of the String class has been used; this takes
    a regular expression as its first argument (`/(^\s*)#(.*)/`) and a replacement
    string as the second argument (`''\1//\2''`). The replacement string may contain
    numbered placeholders such as `\1` and `\2` to match any groups in the regular
    expression—here there are two groups between parentheses: `(^\s*)` and `(.*)`.
    The `sub` method returns a new string in which the matches made by the regular
    expression are substituted into the replacement string, while any unmatched elements
    (here the `#` character) are omitted. So, for example, let’s assume that the following
    comments are found in the input file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After substitution using our regular expression, the displayed output is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: MatchData
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `=˜` operator is not the only means of finding a match. The Regexp class
    also has a `match` method. This works in similar way to `=˜`, but when a match
    is made, it returns a MatchData object rather than an integer. A MatchData object
    contains the result of a pattern match. At first sight, this may appear to be
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: '*match.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, it is an instance of the MatchData class that contains a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A MatchData object may contain groups, or *captures*, and these can be returned
    in an array using either the `to_a` or `captures` method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*matchdata.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is a subtle difference between the `captures` and `to_a` methods.
    The first returns only the captures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The second returns the original string (at index 0) followed by the captures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Prematch and Postmatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MatchData class supplies the `pre_match` and `post_match` methods to return
    the strings preceding or following a match. Here, for example, I am making a match
    on the comment character, `#`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*pre_post_match.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the special variables, `` $` `` (with a backquote)
    and `$''` (with a normal quote), to access pre- and postmatches, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `match` with groups, you can use array-style indexing to obtain
    specific items. Index 0 is the original string; higher indexes are the groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '*match_groups.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the special variable `$˜` to access the last MatchData object,
    and once again you can refer to groups using array-style indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, to use the full range of methods of the Array class, you must use
    `to_a` or `captures` to return the match groups as an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Greedy Matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a string contains more than one potential match, you may sometimes want
    to return the string up to the *first* match (that is, as little of the string
    as possible consistent with the match pattern), and at other times you may want
    the string up to the *last* match (that is, as much of the string as possible).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the latter case (getting as much of the string as possible), the match is
    said to be *greedy*. The `*` and `+` pattern quantifiers are greedy. However,
    you can put them on a diet, to make them return the least possible, by putting
    `?` after them:'
  prefs: []
  type: TYPE_NORMAL
- en: '*greedy1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can control the greediness of pattern matching to do things such as process
    directory paths (here matching on the `\` character):'
  prefs: []
  type: TYPE_NORMAL
- en: '*greedy2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: String Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up to now, I’ve used methods of the Regexp class when processing strings. In
    fact, pattern matching can go both ways because the String class has a few regular
    expression methods of its own. These include `=˜` and `match` (so you can switch
    the order of the String and Regexp objects when matching), plus the `scan` method
    that iterates through a string looking for as many matches as possible. Each match
    is added to an array. Here, for example, I am looking for matches on the letters
    *a*, *b*, or *c*. The `match` method returns the first match (“a”) wrapped up
    in a MatchData object, but the `scan` method keeps scanning along the string and
    returns all the matches it finds as elements in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '*match_scan.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `scan` method may optionally be passed a block so that the elements of
    the array created by `scan` can be processed in some way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'A number of other String methods can be used with regular expressions. One
    version of the `String.slice` method takes a regular expression as an argument
    and returns any matched substring, leaving the original (*receiver*) string unmodified.
    The `String.slice!` method (note the `!` at the end) deletes the matched substring
    from the receiver string and returns the substring:'
  prefs: []
  type: TYPE_NORMAL
- en: '*string_slice.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `split` method splits a string into substrings, based on a pattern. The
    results (minus the pattern) are returned as an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '*string_ops.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also split on an empty pattern (`//`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, an array of characters is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `sub` method to match a regular expression and replace its
    first occurrence with a string. If no match is made, the string is returned unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sub!` method works like `sub` but modifies the original (receiver) string.
    Alternatively, you can use the `gsub` method (or `gsub!` to modify the receiver)
    to substitute all occurrences of the pattern with a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: File Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I said earlier that regular expressions are often used to process data stored
    in files on disk. In some earlier examples, I read in data from a disk file, did
    some pattern matching, and displayed the results on the screen. Here is one more
    example in which I count the words in a file. You do this by scanning each line
    in order to create an array of words (that is, sequences of alphanumeric characters)
    and then adding the size of each array to the variable, `count`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*wordcount.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to verify that the word count is correct, you could display a numbered
    list of words read in from the file. This is what is do here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*wordcount2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s see how to deal with two files at once—one for reading, another for
    writing. The next example opens the file *testfile1.txt* for writing and passes
    the file variable, `f`, into a block. I now open a second file, *regex1.rb*, for
    reading and use `File.foreach` to pass into a second block each line of text read
    from this file. I use a simple regular expression to create a new string to match
    lines with Ruby-style comments; the code substitutes C-style comment characters
    (`//`) for the Ruby comment character (`#`) when that character is the first nonwhitespace
    character on a line and writes each line to *testfile1.txt* with code lines unmodified
    (because there are no matches on those) and with comment lines changed to C-style
    comment lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '*regexp_file1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This illustrates just how much can be done with regular expressions and very
    little coding. The next example shows how you might read in one file (here the
    file *regex1.rb*) and write out two new files—one of which (*comments.txt*) contains
    only line comments, while the other (*nocomments.txt*) contains all the other
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: '*regexp_file2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: This section provides a handy summary of regular expressions followed by some
    short examples in ready-to-use Ruby code.
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expression Elements
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a list of some of the elements that can be used in regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `^` | Beginning of a line or string |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | End of a line or string |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Any character except newline |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Zero or more previous regular expression |'
  prefs: []
  type: TYPE_TB
- en: '| `*?` | Zero or more previous regular expression (nongreedy) |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | One or more previous regular expression |'
  prefs: []
  type: TYPE_TB
- en: '| `+?` | One or more previous regular expression (nongreedy) |'
  prefs: []
  type: TYPE_TB
- en: '| `[]` | Range specification (for example, `[a-z]` means a character in the
    range a-z) |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | An alphanumeric character |'
  prefs: []
  type: TYPE_TB
- en: '| `\W` | A nonalphanumeric character |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | A whitespace character |'
  prefs: []
  type: TYPE_TB
- en: '| `\S` | A nonwhitespace character |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | A digit |'
  prefs: []
  type: TYPE_TB
- en: '| `\D` | A nondigit character |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | A backspace (when in a range specification) |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Word boundary (when not in a range specification) |'
  prefs: []
  type: TYPE_TB
- en: '| `\B` | Nonword boundary |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Zero or more repetitions of the preceding |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | One or more repetitions of the preceding |'
  prefs: []
  type: TYPE_TB
- en: '| `{m,n}` | At least `m` and at most `n` repetitions of the preceding |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | At most one repetition of the preceding |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Either the preceding or next expression may match |'
  prefs: []
  type: TYPE_TB
- en: '| `()` | A group |'
  prefs: []
  type: TYPE_TB
- en: Regular Expression Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few more sample regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*overview.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Symbols and Regular Expressions
  prefs: []
  type: TYPE_NORMAL
- en: Ruby 1.9 permits you to use `match` with a symbol. The symbol is converted to
    a string, and the index of the match is returned. Symbols cannot be used in this
    manner with Ruby 1.8.
  prefs: []
  type: TYPE_NORMAL
- en: '*regexp_symbols.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
