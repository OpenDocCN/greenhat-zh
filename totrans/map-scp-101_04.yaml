- en: Chapter 4. LAYER IT ON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mapping is like painting on a geo-referenced canvas. The most common brushes
    are markers and message boxes, which is the bulk of what we've used so far. To
    achieve a different texture, you'll need to switch it up. In this chapter, we'll
    branch out with some specialized layers that will improve the look of your maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we''ll simply draw lines. A lot can be represented simply by connecting
    geographic coordinates together: routes, political boundaries, and even individual
    buildings. This chapter even has a project to color states or countries on a map,
    which could be used to make an election map like the ones that have become popular
    in recent US presidential races.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll also add images to the map. Didn't we do that with custom markers? Yes,
    but the images we'll be adding will be larger and act like your own map's imagery.
    In fact, we'll also create custom tiles, still utilizing a mapping API but bypassing
    (or augmenting) its own maps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating layers on your map is a huge step toward making your maps stand out
    as a masterpiece. Get out those new brushes and let's start mapping.
  prefs: []
  type: TYPE_NORMAL
- en: '#16: Draw Lines on a Map'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What''s the shortest distance from point A to point B? Here''s a hint: After
    reading this section, you''ll be able to represent it on a map.'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing lines, which Mapstraction calls *polylines*, is very useful. With them,
    you can outline a route, such as driving directions or a hiking trail. Like a
    marker, a line uses latitude and longitude points. Of course, you can't have a
    line with a single point, so you'll need at least two pairs of coordinates to
    draw a line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mapstraction lets you have an unlimited number of points, but let''s start
    simply. This example will draw a line between the capitals of Georgia (the US
    state) and Georgia (the country). Add the following code to your `create_map`
    function after your map has been initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first thing I've done is declare the two points ❶, storing them in an array
    variable. Note the square brackets—`[` and `]`—that create the array and that
    the two `LatLonPoints` inside the array are separated by a comma. Mapstraction
    requires an array with at least two `LatLonPoints` to create a polyline.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I actually create the `Polyline` object ❷ using the array. Like a marker
    object, this object is Mapstraction's way of representing the data so it can be
    reproduced with multiple mapping providers, if necessary. Creating a polyline
    is not enough to draw the line, however. I also need to add it to the map ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I automatically center the map using the same function described in
    [#8: Determine the Correct Zoom Level to Use Based on Markers](ch02s08.html "#8:
    Determine the Correct Zoom Level to Use Based on Markers") in [#7: Loop Through
    All Markers](ch02s07.html "#7: Loop Through All Markers"). In this case, Mapstraction
    uses polylines instead of markers to determine the zoom level.'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting map is shown in [Figure 4-1](ch04.html#a_line_drawn_between_two_georgian_capita
    "Figure 4-1. A line drawn between two Georgian capitals") with a line drawn across
    the Atlantic Ocean, connecting the two Georgias. Let's see if we can make something
    a little more useful by adding more points to our line.
  prefs: []
  type: TYPE_NORMAL
- en: '![A line drawn between two Georgian capitals](httpatomoreillycomsourcenostarchimages671987.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1. A line drawn between two Georgian capitals
  prefs: []
  type: TYPE_NORMAL
- en: Draw Multiple Line Segments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you think of a line, you probably picture something like what we created
    in the previous section: the connection between two points. Polylines, however,
    can have unlimited segments, which means you can use them to create paths and
    routes.'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, Google uses a polyline to display its driving directions. Using polylines
    makes sense because very few streets are perfectly straight. Most have at least
    slight meanderings from side to side. In San Francisco, a couple of streets are
    even known for their crookedness, most notably a short section of Lombard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some code to create a polyline that very roughly follows the curves
    of Lombard Street, from the top to the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from [Figure 4-2](ch04.html#a_polyline_with_several_points_to_trace
    "Figure 4-2. A polyline with several points to trace San Francisco's famous Lombard
    Street"), those 11 latitude and longitude points create a polyline that traces
    along Lombard's eight turns. As with the Georgia example, the points are stored
    within brackets to create the JavaScript array that Mapstraction needs to make
    a polyline.
  prefs: []
  type: TYPE_NORMAL
- en: '![A polyline with several points to trace San Francisco''s famous Lombard Street](httpatomoreillycomsourcenostarchimages671989.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2. A polyline with several points to trace San Francisco's famous Lombard
    Street
  prefs: []
  type: TYPE_NORMAL
- en: Lombard Street is still a fairly simple example. We've covered less than a quarter
    mile—and that includes the twists and turns. You could use polylines to trace
    entire highways, rivers that flow for hundreds of miles, or even the Great Wall
    of China.
  prefs: []
  type: TYPE_NORMAL
- en: Set the Color and Thickness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like markers and other aspects of a map, polylines come with a standard look
    you may want to change. For example, you can alter the color and thickness of
    the lines you draw.
  prefs: []
  type: TYPE_NORMAL
- en: Mapstraction has individual functions to set the criteria you want. Each can
    be applied after you have created a polyline, but before you have added it to
    the map. This process is similar to the order in which Marker options have to
    be added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that makes a purple polyline that is five pixels thick (it
    assumes your polyline is stored in the `poly` variable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that the color is set as a hexadecimal value ❶, similar to how colors are
    declared in HTML. Either a six- or three-character value works, and you can even
    precede it with a hash mark, `#`, if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some browsers, especially older ones, have trouble with colored polylines. Be
    sure to check thoroughly across all browsers your user base commonly employs,
    especially if the color of the polyline is integral to your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because you''ll often want to set several attributes at once, Mapstraction
    has a function that accepts many options, storing their values in a JavaScript
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The curly brackets `{` and `}` are important, as they declare the JavaScript
    object. Then an attribute is set with the name of the option, a colon, and the
    value. You'll see more examples of adding styling options to polylines in the
    next project.
  prefs: []
  type: TYPE_NORMAL
- en: '#17: Draw Shapes on a Map'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Are you ready for a little philosophy? I hope so, because I have a philosophical
    question for you: What is a shape?'
  prefs: []
  type: TYPE_NORMAL
- en: Before you answer that, let's list some names of shapes. Shapes include circles
    and triangles. Squares are popular, as are their relative the rectangles. If we
    continue to increase the number of sides, the names may sound familiar—pentagon,
    hexagon, heptagon, octagon—and then the names get a little strange.
  prefs: []
  type: TYPE_NORMAL
- en: Your philosophical answer may be different, but for our purposes, we'll create
    a shape with some number of sides. This shape is called a *polygon*. A polygon
    is made up of line segments that start and end at the same point. If you have
    mastered the previous project, you probably have a pretty good idea of how you
    could create a polygon using Mapstraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Surprisingly, creating shapes on a map is essentially the same process as drawing
    polylines. Take a look at this code, which draws an outline around the US Department
    of Defense headquarters ("The Pentagon"—get it?):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As with standard polylines, we need to declare an array of `LatLonPoint`s using
    square brackets `[` and `]` to show a JavaScript array. The big difference is
    that the first and last points (both shown in bold) are identical, signaling to
    Mapstraction that you are creating a polygon.
  prefs: []
  type: TYPE_NORMAL
- en: The outcome, as shown in [Figure 4-3](ch04s02.html#the_pentagon_building_outlined_with_a_po
    "Figure 4-3. The Pentagon building outlined with a polygon"), is that the polyline
    is filled in to show that it's more than just a line—it's a shape. Shapes bring
    up a few more styling issues than normal lines, so Mapstraction provides some
    additional options.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Pentagon building outlined with a polygon](httpatomoreillycomsourcenostarchimages671991.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3. The Pentagon building outlined with a polygon
  prefs: []
  type: TYPE_NORMAL
- en: Set the Fill Color and Opacity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that your polyline has turned into a polygon, let's declare the color that
    fills its center. Also, with the fill covering such a large area, you may want
    to leave bits of the map under the polygon visible. That's where opacity comes
    in—it determines the opaqueness of the fill color.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with graphics programs, you'll likely be comfortable with
    opacity. You declare it with a percentage from 0 to 100, where 0 is invisible
    and 100 is not transparent at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use a single function in Mapstraction to set all the options for the
    pentagon we made earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have declared an opacity of 90 percent ❶, so we can barely see through
    it. Notice that we use a decimal between 0 and 1 to show the percentage. Though
    mathematically correct, you may find this a little confusing.
  prefs: []
  type: TYPE_NORMAL
- en: The fill color is declared with a CSS-like hexadecimal value ❷. This value is
    separate from the color of the polyline, which can be the same or different. In
    this example, the fill color is a bright green, whereas the border is a slightly
    darker green.
  prefs: []
  type: TYPE_NORMAL
- en: '#18: Add Circles to Show Search Radius'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drawing lines and polygons is fairly easy. They are made up of a series of connected
    points. A circle is a little more difficult to express. A circle has no points
    that make up its border. Instead, it's declared by a center point and a radius.
  prefs: []
  type: TYPE_NORMAL
- en: Circles are useful in mapping, because you can use them to show an area you
    are searching. For example, if you are looking for places within five miles of
    a point, your circle would be ten miles wide (and tall—a circle is perfectly round),
    with the search point right at the center.
  prefs: []
  type: TYPE_NORMAL
- en: Mapstraction offers two ways to create a circle. First, we can approximate with
    a many-sided polygon. Second, we could use a graphic and layer it on top of the
    map. In this section, I'll show you how to do both.
  prefs: []
  type: TYPE_NORMAL
- en: Approximate with a Polygon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a fake circle by connecting points along the circle looks better than
    you might imagine it would. Of course, the more points you use, the better the
    circle looks. Mapstraction has a built-in function to perform the computations,
    and you can set the quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, a circle requires two pieces of information: a center and a radius.
    In this example, we''ll show just how big the state of Texas is by drawing a circle
    500 miles in diameter starting from its capital near the center of the state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these lines to your map initialization function, which I''ve called `create_map`
    throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is all that''s necessary to add a circle-ish polygon to your map.
    First, you need to create a `Radius` object ❶, which is part of the Mapstraction
    library. This object does some important calculations to determine the circle''s
    edges. Then you pass the object two values: the center point (downtown Austin,
    Texas) and a quality number ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: The lower the quality number, the more your polygon will look like a circle.
    The number represents the degrees between each point in the polygon. You can use
    this to determine the number of sides your "circle" will have. A circle is 360
    degrees total, so if you divide by 10, that's 36 points, which means you're creating
    a 36-sided polygon in this instance. Using this method, you've done a pretty good
    job of approximating a circle, as you can see in [Figure 4-4](ch04s03.html#circle_approximated_by_36-sided_polygon
    "Figure 4-4. Circle approximated by 36-sided polygon"). The more sides you have,
    the longer it takes to create the circle, so you have to make a trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: '![Circle approximated by 36-sided polygon](httpatomoreillycomsourcenostarchimages671993.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4. Circle approximated by 36-sided polygon
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a `Radius` object, you can create the polygon, which is a
    `Polyline` object. You use a Mapstraction function to convert miles to kilometers
    ❸. Here, I've passed it the number of miles of the radius, which is half of the
    diameter of the eventual circle. Also, I've passed a hexadecimal value for the
    color ❹ of the circle, in this case, a shade of purple.
  prefs: []
  type: TYPE_NORMAL
- en: You can create as many circles as you want from the radius object, so you could
    show several levels of distance from Austin. If you want to move the center (or
    change the quality of the circle), however, you'll need to re-create the radius
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Overlay a Circle Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The polygonized circle may still be too jagged for you, or perhaps you want
    more control over how the circle looks. In that case, overlaying an image on your
    map is your best choice.
  prefs: []
  type: TYPE_NORMAL
- en: First, you'll need a circle image, likely saved as a transparent PNG file. Transparency
    is important because graphics are stored as rectangles, so you definitely don't
    want the area outside of the circle to be visible. Also, since you'll be referencing
    this on the map as a rectangle, your circle should be up against the four edges
    of the graphic. I've included several sample circle graphics for download on the
    book's website at [http://mapscripting.com/circle-overlays](http://mapscripting.com/circle-overlays).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your circle graphic, you can figure out where to place it on the
    map. A graphic is referenced by the four sides of its rectangle, so you need to
    determine the north, south, east, and west points. Usually, a circle is determined
    by its center and radius. You can calculate the side values by measuring in four
    directions from the center.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these lines to your map code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To be able to determine the geographic borders of your circle image, you need
    to calculate how many degrees of latitude and longitude make up the radius, which
    is 250 miles. The latitude distance ❶ is easier, because latitude is nearly constant
    throughout the world at 69.2 miles per degree.
  prefs: []
  type: TYPE_NORMAL
- en: Longitude depends on where you are on earth because the degrees are closer to
    each other as you near a pole. Mapstraction has a handy function ❷ for converting
    meters to longitude based on a latitude. In order to pass the function 250 miles
    in meters, you must first convert to kilometers ❸ and then multiply by 1000.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have your distances, so now you just need to calculate the
    four sides. For example, the northern border ❹ of the graphic will be at the center
    point latitude plus the number of degrees latitude we determined are in 250 miles.
    South will also use that latitude distance (only this distance is subtracted from
    the center's latitude. East and west borders will use the longitude distance.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with your four geographic borders, you can apply your image overlay. Mapstraction
    needs a lot of information, including an identifier for the image ❺ and an opacity
    level ❻ (for this example, I've chosen 75 percent). The results are shown in [Figure 4-5](ch04s03.html#transparent_circle_image_overlay
    "Figure 4-5. Transparent circle image overlay"), where you can see a perfect circle
    atop Texas. The area it covers, you'll notice, is identical to the area covered
    by the polygon circle in [Figure 4-4](ch04s03.html#circle_approximated_by_36-sided_polygon
    "Figure 4-4. Circle approximated by 36-sided polygon").
  prefs: []
  type: TYPE_NORMAL
- en: '![Transparent circle image overlay](httpatomoreillycomsourcenostarchimages671995.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5. Transparent circle image overlay
  prefs: []
  type: TYPE_NORMAL
- en: No matter which type of circle you choose to use, Texas is a big state.
  prefs: []
  type: TYPE_NORMAL
- en: '#19: Draw a Rectangle to Declare an Area'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. PLOTTING MARKERS AND MESSAGE BOXES"), I
    discussed the bounding box, a set of coordinates that roughly describes a geographic
    area. I write *roughly* because bounds are visually rectangular, so they can only
    be used to declare the simplest of areas. Of course, with every map we have been
    indirectly creating bounds. The visible portion of the map is a rectangular portion
    of the greater map.
  prefs: []
  type: TYPE_NORMAL
- en: Mapstraction uses the `BoundingBox` class to describe an area. As a data structure,
    this class is made up of two `LatLonPoint`s. One declares the southwest corner
    (the lower left) and the other the northeast corner (the upper left). From those
    two values, we can figure out the remaining two corners. And we'll do just that
    in this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may find yourself wanting to declare an area of the map visually. Because
    a `BoundingBox` is simply a data representation of an area, we need to convert
    to a `Polyline`. Add this function to your JavaScript (outside the `create_map`
    function) to perform the conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Drawing a rectangle on a map requires five points. At first, this requirement
    may seem a bit strange—doesn't a rectangle have four corners? Of course. We aren't
    violating basic rules of geometry. We need to declare the start and the finish
    points separately, however. And because these are the same point (or, as you'll
    see, nearly the same), we include it twice.
  prefs: []
  type: TYPE_NORMAL
- en: The array of points begins, simply enough, with the southwest point ❶. Then
    we want to draw a line directly north, which means we need to keep the same longitude
    while increasing the latitude. We only have two points to work with, so we create
    a new point ❷ using the southwest's longitude and the northeast's latitude.
  prefs: []
  type: TYPE_NORMAL
- en: The third point is the northeast point itself. Then we can use a similar process
    to determine the fourth point. Finally, we need to draw the final side of the
    rectangle back to the southwest point. But this is where things get strange. If
    we use exactly the southwest point, Mapstraction will fill in the area. To get
    an unfilled box, we create a final point with a longitude almost imperceptibly
    off ❸ from the starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve written our new function, we need to call it. From within your
    `create_map` function, add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We could create new bounds if we wanted, but instead we are taking them from
    the map itself ❹. Then we use those bounds to call our function to convert to
    a `Polyline` ❺. As you saw earlier, creating the object is just the first step.
    We also need to add it to the map. The final line zooms out so we can see the
    rectangle, as shown in [Figure 4-6](ch04s04.html#bounding_box_converted_to_a_polyline
    "Figure 4-6. Bounding box converted to a polyline"). Without zooming, the rectangle
    would be right at the edges of our map.
  prefs: []
  type: TYPE_NORMAL
- en: '![Bounding box converted to a polyline](httpatomoreillycomsourcenostarchimages671997.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6. Bounding box converted to a polyline
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this snippet of code to clearly show bounds. For an example of this project
    in action, see [#7: Loop Through All Markers](ch02s07.html "#7: Loop Through All
    Markers") in [Other Useful Parameters](ch06s07.html#other_useful_parameters "Other
    Useful Parameters").'
  prefs: []
  type: TYPE_NORMAL
- en: '#20: Draw Lines Along Clicks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The biggest stumbling block to creating your own lines on a map is finding the
    latitude and longitude points. With this project, you (or your users) will be
    able to draw lines simply by clicking the map. Gmap Pedometer ([http://gmap-pedometer.com/](http://gmap-pedometer.com/))
    popularized this technique in the earliest days of mapping APIs, and now you can
    use it, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reacting to a click event is at the center of this method. You will find events
    covered in detail in [Chapter 5](ch05.html "Chapter 5. HANDLE MAP EVENTS"). We
    want to store all the click points in an array. Because we''ll be accessing this
    from an event, the variable we create needs to be public, meaning it is declared
    outside of any function. Include this line at the beginning of your JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This variable will hold every point that is clicked. Right now it is an empty
    array (there's nothing between those square brackets). With every click, however,
    we'll add a new `LatLonPoint` to the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'From within your map initialization code, add these lines to react to clicks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, I have included the code that runs when the user clicks the map in an
    anonymous, inline function. This is about as long as I would make a function without
    explicitly naming it.
  prefs: []
  type: TYPE_NORMAL
- en: The very first thing that happens is we "push" the new point into the array
    ❶. The `push` function is built into JavaScript for every array variable and always
    adds it on to the end of the array.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum number of points before we can draw a line is two. This requirement
    causes a bit of an issue because we need the user to know we have recorded the
    first click. To deal with this, we added a marker ❷ to the map only if the length
    of the array is one. In other words, a marker is added only on the first click.
  prefs: []
  type: TYPE_NORMAL
- en: On subsequent clicks, we create a new polyline ❸ with the two most recent points.
    To do this, we connect the last point in the array ❹ to the next-to-last point
    in the array (because arrays in JavaScript begin counting at zero, the last element
    is always one less than the length). Also, remember that a polyline is created
    with an array itself, so we need to surround those two numbers with brackets.
    The code starts to look a little messy.
  prefs: []
  type: TYPE_NORMAL
- en: After several clicks, the map will look something like [Figure 4-7](ch04s05.html#connecting_clicks_with_polyline_segments
    "Figure 4-7. Connecting clicks with polyline segments"). Internally, we'll have
    all the points stored in our array. Mapstraction, however, is treating each line
    segment as its own polyline. From a visual perspective, it still looks like one
    big line.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting clicks with polyline segments](httpatomoreillycomsourcenostarchimages671999.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7. Connecting clicks with polyline segments
  prefs: []
  type: TYPE_NORMAL
- en: '#21: Color States/Countries on a Map'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've paid attention to recent US politics, you've likely seen red and blue
    state maps. During the 2004 and 2008 presidential campaigns, these became common
    across the Web. And believe it or not, if you've read this far in the chapter,
    you already know how to make a colored map of your own.
  prefs: []
  type: TYPE_NORMAL
- en: All you need are the points that make up the outline of each state. Then, you
    create a polygon for each state, giving it the proper fill color. Before you can
    start coloring states, you'll need the points that make up the outline of each
    state. You can get this data in a number of ways. For example, you could create
    it on your own using code similar to that in the previous project.
  prefs: []
  type: TYPE_NORMAL
- en: You could also take it directly from the government, but you'd likely need to
    convert it to a format that's easy for Mapstraction to use. I have data sources
    available at the book's website at [http://mapscripting.com/state-boundaries](http://mapscripting.com/state-boundaries).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to try it out, start with just a few states. In this example, I''ll
    use the four-corner states of Utah, Colorado, Arizona, and New Mexico. They have
    relatively few points, and they all come together neatly. The first step is declaring
    the points that make up each state boundary as a JavaScript array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Arizona is just a little too complex to show all of its points in the book,
    but the others are complete. Like declaring other shapes using points, we include
    a list of `LatLonPoint`s within square brackets to designate an array. To create
    a complete shape (and, therefore, include a fill color), the first and last points
    in the array must be identical. The identical points tell Mapstraction that the
    polyline begins and ends at the same place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are going to be performing the same actions multiple times, this
    is an appropriate occasion to create our own function. Here is the code to color
    in a state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We'll call this function four times—once for each state. Or, if you're doing
    the whole United States, you'd call the function fifty times. This function's
    three lines mean our code will only take up one-third of the space. If you're
    going to run the same code many times, you'll want to avoid duplication and create
    your own function.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to pass the function two arguments. First, we pass it a list of points
    ❶—a state boundary array. Then, because we're filling in the map with different
    colored states, we'll need to let the function know what color ❷ to make the current
    state.
  prefs: []
  type: TYPE_NORMAL
- en: The function then goes to work creating a `Polyline` and adding data to it.
    We've set the opacity to 90 percent ❸, which means the filled state shape will
    be slightly transparent, just enough to see the state name underneath. The color
    is set ❹ to the argument that we received. We made the width zero ❺, meaning the
    state will not have a border. You may prefer to have a border, so try out a few
    different values. This argument takes integers, which refer to thickness in number
    of pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nothing we''ve done so far will actually do anything yet. For that, we need
    to call this function, passing a state boundary array and color. Add this code
    to your map initialization section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you see, this calls the `color_state` function four times, using a different
    point array variable and color each time. To keep this example apolitical, I've
    used shades of green. Feel free to insert your own red (`'ff0000'`) or blue (`'0000ff'`)
    values.
  prefs: []
  type: TYPE_NORMAL
- en: To be sure every state is within view, I autocentered the map after adding the
    four states. As you can see from [Figure 4-8](ch04s07.html#polygons_of_four_us_states
    "Figure 4-8. Polygons of four US states"), our map looks pretty snazzy. But if
    you zoom in, the borders of each state might not completely touch. That's a precision
    issue, which you may not care about. Its importance depends on how closely you
    expect users to view your borders. For the case of a colored election map, which
    is viewed at country-level, we don't need perfection.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue you may notice with creating a state map is that not all states
    are one perfect shape. Hawaii is a series of islands, and Michigan's two pieces
    are separated by a Great Lake. Again, how you handle this depends on how big of
    a deal it is to you. You may be fine connecting the portions so they can be one
    state. Or, you may use multiple polygons to represent these complex states.
  prefs: []
  type: TYPE_NORMAL
- en: '#22: Add Custom Controls'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything we have layered on the map so far has been geo-referenced. In other
    words, when the user drags the map to the side, the thing we've layered also moves.
    In this section, we'll create some interface elements that don't move, but instead
    are anchored to a specific spot in the map window.
  prefs: []
  type: TYPE_NORMAL
- en: The controls we'll be creating are similar to map type controls, which are in
    the upper-right corner of the map. In [Add Zoom and Other Controls](ch01s06.html
    "Add Zoom and Other Controls") in [Add Zoom and Other Controls](ch01s06.html "Add
    Zoom and Other Controls"), I showed how to include these (and other) controls.
    Now, we'll be making our own buttons that live in the same spot.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we'll make a button that gives users the option to center
    the map automatically so all the markers and lines are visible. Better yet, we'll
    write the code so you can create any number of these custom controls with a simple
    function call.
  prefs: []
  type: TYPE_NORMAL
- en: '![Polygons of four US states](httpatomoreillycomsourcenostarchimages672001.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-8. Polygons of four US states
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for creating a control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This function needs two pieces of data in order to create the control and add
    it to the map: It needs the text ❶ that will be written inside the button, and
    it needs the function ❷ that it will call when the button is clicked.'
  prefs: []
  type: TYPE_NORMAL
- en: With those pieces of information, we can go about creating this control. In
    terms of how the browser interprets it, we are creating a simple `<a>` tag programmatically
    ❸. We give it a class name ❹ so we can style it with CSS. Then we add the label
    to it ❺.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the control has been created, but it isn't on the map, nor does
    it do anything. To fix these two issues, we set the function ❻ that will be called
    when the user clicks and then append the object as a child of the map object ❼.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can style the control. Add these CSS lines to your style sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This CSS is designed to make our controls look similar to Google's map type
    controls. Only the first two lines (in bold) are necessary to position it in the
    upper-right corner. Everything else is styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the hard work is now done, and we''re ready to use our custom control.
    From within the initialization code for our map, add these lines to create an
    autocentering control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This code passes the label for our new control (autocenter) and an anonymous,
    inline function reference, which decides what to do when the user clicks the new
    control button. In this case, it fires off the Mapstraction code to show all the
    markers and lines on the map automatically. See [Figure 4-9](ch04s07.html#a_custom_control_looks_like_a_google_con
    "Figure 4-9. A custom control looks like a Google control") for a before and after
    example of clicking the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could do anything you want when the user clicks your custom control button.
    One common choice might be showing only markers of a particular type. I demonstrate
    how to do this in [#9: Filter Out Certain Markers](ch02s09.html "#9: Filter Out
    Certain Markers") in [#9: Filter Out Certain Markers](ch02s09.html "#9: Filter
    Out Certain Markers"). With a marker-filled map, you might also create specific
    areas to zoom into, as I do in [#70: Display Recent Earthquakes Worldwide](ch10s03.html
    "#70: Display Recent Earthquakes Worldwide") in [#70: Display Recent Earthquakes
    Worldwide](ch10s03.html "#70: Display Recent Earthquakes Worldwide").'
  prefs: []
  type: TYPE_NORMAL
- en: '![A custom control looks like a Google control](httpatomoreillycomsourcenostarchimages672003.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-9. A custom control looks like a Google control
  prefs: []
  type: TYPE_NORMAL
- en: '#23: Create Your Own Zoom Interface'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you choose a mapping provider, certain elements of how the map looks cannot
    be easily changed. The zoom interface may be one of these things you've accepted
    as being unchangeable. In this project, I'll show how you can include your own
    zoom in/out buttons to give you even more control over the look of your map.
  prefs: []
  type: TYPE_NORMAL
- en: The approach is similar to the previous project. We'll make a function that
    adds a new object to the page, and we'll position and style it using CSS. Instead
    of a text button, we'll make an image button. And, as before, each new object
    will react to a click.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need two images: one will be your zooming-in button and the other
    the zooming-out button. You can see the two unassuming graphics I chose in [Figure 4-10](ch04s08.html#two_zoom_graphics_to_be_used_as_custom_c
    "Figure 4-10. Two zoom graphics to be used as custom controls").'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two zoom graphics to be used as custom controls](httpatomoreillycomsourcenostarchimages672005.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-10. Two zoom graphics to be used as custom controls
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the generic code for creating an image control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This function needs two pieces of data in order to create the control and add
    it to the map. It needs the image source ❶, which is a path to the image file
    we'll be using for this control. It also needs the function ❷ that it will call
    when the image is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Now we're ready to create this control. We create an image element programmatically
    ❸, just as we did with the `<a>` tag when making a custom control. Then we give
    the image a class name ❹ so we can style it with CSS. Finally we add the image
    URL ❺. This URL can be full or relative to the current page.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the image is created, but it's neither on the map, nor does it
    do anything. To fix those two issues, we set the function ❻ to be called when
    the user clicks and then append the image object as a child of the map object
    ❼.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make sure our new image controls are positioned correctly. Add these
    CSS lines to your style sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add our custom zoom controls to the map. From within the initialization
    code for your map, add these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, I've created two image controls, as shown in [Figure 4-11](ch04s08.html#custom_zoom_images_on_a_map
    "Figure 4-11. Custom zoom images on a map"). The first is for zooming in. The
    CSS will place the control furthest to the right. I send it the name of my image
    ❶, which assumes it is stored in the same directory as the HTML page. Then I pass
    it an anonymous, inline function. Here, I set the zoom level ❷ using Mapstraction,
    passing a number one greater than the current zoom level.
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom zoom images on a map](httpatomoreillycomsourcenostarchimages672007.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-11. Custom zoom images on a map
  prefs: []
  type: TYPE_NORMAL
- en: The second image control is similar. It is given a different image, and when
    clicked, it sets the zoom to one *less* than the current zoom level.
  prefs: []
  type: TYPE_NORMAL
- en: '#24: Plot Image Thumbnails on a Map'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A picture may not be quite worth a thousand geographic points, but it's close.
    A map is a great way to show photos that have been *geo-tagged*. Geo-tagging is
    associating latitude and longitude coordinates with images. Full-size photos may
    not be ideal, however, as they would take up too much space. Instead, a popular
    method is to display much smaller versions—thumbnails—that the viewer can expand.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you'll need photos. You can use some that you have as a test or search
    the photo sharing site Flickr. I was able to find some good shots, already geo-tagged,
    by searching for Orlando, Florida. I looked specifically for photos that are licensed
    as Creative Commons, meaning they have less rigid copyright restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Though we will link to larger versions of each picture, we'll need separate
    files to store the smaller versions. Another plus to using Flickr is that it creates
    these thumbnails and a midsize image, too, automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each Orlando photo we plot, we''re going to need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Photo thumbnail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Latitude and longitude
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Medium-sized photo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dimensions of medium photo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Link to full photo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the very least you need the first two items, though you'll create a better
    user experience the more items from this list you can include. If, like me, you're
    using Flickr, then you'll need that link to avoid violating Creative Commons.
  prefs: []
  type: TYPE_NORMAL
- en: 'My three plotted thumbnails are shown on a map in [Figure 4-12](ch04s09.html#thumbnails_overlaid_as_custom_markers_op
    "Figure 4-12. Thumbnails overlaid as custom markers (Photos by Ron Miguel, Kok
    Leng Yeo, and LancerE)"). As in other situations where we may be doing one action
    many times, creating a function is best. Add this to your JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As arguments to the function, we need to pass all the items I mentioned in the
    list. Then we create a custom marker using the thumbnail image ❶. Notice that
    I set the dimensions of the marker to be 50×50\. You can use whatever size you
    want, but make sure the image itself is close to that size. Flickr's are 75 pixels
    square, so a little downsizing is okay.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to set a shadow ❷ or else the default will be used (in Google
    Maps the default is a reverse teardrop, which would look funny underneath a square
    photo). I've created an outline graphic that gives a slight border to the image.
    I set the size to be slightly bigger than the thumbnail itself.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add a message box. Remember, you can include any HTML inside, so
    we'll link to the full image ❸, as well as display the medium image ❹. To help
    the mapping provider determine how big to make the message box, we include the
    width ❺ and height ❻ of the midsized image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''re ready to call the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Thumbnails overlaid as custom markers (Photos by Ron Miguel, Kok Leng Yeo,
    and LancerE)](httpatomoreillycomsourcenostarchimages672009.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-12. Thumbnails overlaid as custom markers (Photos by Ron Miguel, Kok
    Leng Yeo, and LancerE)
  prefs: []
  type: TYPE_NORMAL
- en: This function plots a single photo thumbnail on the map. Click the tiny version
    and it opens a message box showing the midsized version. Then, when you click
    the image, the Flickr link opens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now simply call that function two more times—or twenty. You can use the Flickr
    shots from my map as examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.flickr.com/photos/kamoteus/2421383748/](http://www.flickr.com/photos/kamoteus/2421383748/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.flickr.com/photos/yeowatzup/461692550/](http://www.flickr.com/photos/yeowatzup/461692550/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a more advanced project, you could automate the process of finding images
    by tapping into the Flickr API to search near a geographic point. The API then
    responds back with XML or JSON, both of which you can parse using the techniques
    shown in [Chapter 8](ch08.html "Chapter 8. DATA FORMATS").
  prefs: []
  type: TYPE_NORMAL
- en: '#25: Overlay an Image on a Map'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can add an image to a map in a number of ways. In [#5: Create a Custom
    Icon Marker](ch02s05.html "#5: Create a Custom Icon Marker") in [#4: Show and
    Hide Message Boxes Without Clicking the Marker](ch02s04.html "#4: Show and Hide
    Message Boxes Without Clicking the Marker"), you used an image as the icon for
    a Placemark. In this section, we''ll do something a bit different—overlaying an
    image over a larger area of the map, where it will replace or augment the existing
    map.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''re actually familiar with this process, as we used it earlier in this
    chapter, in [#18: Add Circles to Show Search Radius](ch04s03.html "#18: Add Circles
    to Show Search Radius") in [Set the Fill Color and Opacity](ch04s02.html#set_the_fill_color_and_opacity
    "Set the Fill Color and Opacity"). There, we used a circle image and geo-referenced
    it so the image was centered on a point and covered a specific area. That example
    was easier than what we want to do now because a circle is the same distance in
    every direction and it doesn''t matter where it''s pointing.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider, for example, the map of New York's Central Park in [Figure 4-13](ch04s10.html#central_park_source_graphic
    "Figure 4-13. Central Park source graphic"). It contains some buildings and landmarks
    that may not be on your standard web map. This map has the park perfectly oriented
    to be running north and south. In reality, the streets that border the long side
    of the park are slightly east of north (and west of south).
  prefs: []
  type: TYPE_NORMAL
- en: '![Central Park source graphic](httpatomoreillycomsourcenostarchimages672011.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-13. Central Park source graphic
  prefs: []
  type: TYPE_NORMAL
- en: Mapstraction is only able to overlay a graphic if the top of its rectangle is
    at north exactly. To get the Central Park map to match the rest of New York, we
    need to geo-reference it.
  prefs: []
  type: TYPE_NORMAL
- en: Geo-Reference Your Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the heart of the geo-referencing technique is the ability to determine the
    latitude and longitude of points on the graphic. Then, using those points, you
    can bend and warp the map so the top and bottom borders of the graphic are static
    latitudes (and the other two static longitudes).
  prefs: []
  type: TYPE_NORMAL
- en: This process is often called *rubbersheeting*, because you are taking a two-dimensional
    reference, stretching it across a spherical earth, and then unfolding it so it's
    flat again. The result is a warped image, as if it were made of rubber.
  prefs: []
  type: TYPE_NORMAL
- en: You can geo-reference a graphic to a map in a number of ways. Microsoft has
    a program called MapCruncher that works well. In this case, you'll need a Windows
    machine and the resulting graphic can only be used for noncommercial purposes.
    MetaCarta also has a web tool called Map Rectifier.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, I'll be using a web application called Map Warper, which can
    be found at [http://warper.geothings.net/](http://warper.geothings.net/). Map
    Warper was built by Tim Waters and is open source and meant to free you from worries
    over how you can use the end result. You will need to create a free account to
    store your map images. Once you do, click the **Add Map** link to start a new
    map.
  prefs: []
  type: TYPE_NORMAL
- en: After you provide the name and other metadata to the map, you include a graphic.
    Browse your hard drive for the image you want to use. You can find the Central
    Park graphic that I'm using in this example at [http://mapscripting.com/image-overlay/](http://mapscripting.com/image-overlay/).
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Rectify** tab and you'll see your image on the left and a map on
    the right (see [Figure 4-14](ch04s10.html#map_warper_interface "Figure 4-14. Map
    Warper interface")). Move and zoom the map provided until you can see Central
    Park or the area you are geo-referencing. Now you want to add *control points*
    wherever you can identify a spot in the left graphic whose coordinates you can
    determine in the map on the right.
  prefs: []
  type: TYPE_NORMAL
- en: '![Map Warper interface](httpatomoreillycomsourcenostarchimages672013.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-14. Map Warper interface
  prefs: []
  type: TYPE_NORMAL
- en: For example, I chose my first point at Columbus Circle in the lower left of
    the Central Park graphic. Once I can see Columbus Circle on both screens, I click
    the marker button (see the circle in [Figure 4-14](ch04s10.html#map_warper_interface
    "Figure 4-14. Map Warper interface")) and the spot on the left. Then I click the
    same spot on the right side. Finally, I click the **Add Control Point** button
    and the marker changes so the number 1 appears inside it, as shown in [Figure 4-15](ch04s10.html#first_control_point_for_geo-referencing
    "Figure 4-15. First control point for geo-referencing").
  prefs: []
  type: TYPE_NORMAL
- en: '![First control point for geo-referencing](httpatomoreillycomsourcenostarchimages672015.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-15. First control point for geo-referencing
  prefs: []
  type: TYPE_NORMAL
- en: To find additional points that are off the screen, remember to switch from the
    marker to the hand, which will allow you to move the image again. You'll need
    to do the same thing with the map on the right. Continue this process until you
    have a handful of points. Map Warper suggests at least three points, but I've
    found it often takes more.
  prefs: []
  type: TYPE_NORMAL
- en: The Central Park example is easier than some, as New York City has a nice set
    of grid streets to use as references. [Figure 4-16](ch04s10.html#more_control_points_produces_a_better_re
    "Figure 4-16. More control points produces a better rectified map") shows the
    seven points I chose for this example. When you are finished adding control points,
    scroll to the bottom and click **Warp Image**.
  prefs: []
  type: TYPE_NORMAL
- en: '![More control points produces a better rectified map](httpatomoreillycomsourcenostarchimages672017.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-16. More control points produces a better rectified map
  prefs: []
  type: TYPE_NORMAL
- en: The system will whirl and whiz for a bit. When it responds that the map has
    been rectified, you can scroll back to the top and click the **Preview Rectified**
    tab. A map with your image warped and overlaid on top will appear, as shown in
    [Figure 4-17](ch04s10.html#preview_of_geo-referenced_central_park_m "Figure 4-17. Preview
    of geo-referenced Central Park map"). You can move the slider at the bottom to
    change your image's opacity. Moving the marker all the way to the right makes
    the image completely opaque, meaning it completely covers the original map.
  prefs: []
  type: TYPE_NORMAL
- en: '![Preview of geo-referenced Central Park map](httpatomoreillycomsourcenostarchimages672019.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-17. Preview of geo-referenced Central Park map
  prefs: []
  type: TYPE_NORMAL
- en: Move the slider back and forth to determine how well your image matches the
    source map. If you aren't satisfied with the results, click the **Rectify** tab
    and add a few more points.
  prefs: []
  type: TYPE_NORMAL
- en: Apply Warped Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you're happy with the result of your warped image, click the **Export**
    link to download the image to use it in your own project. You'll want to get the
    PNG-formatted version. [Figure 4-18](ch04s10.html#central_park_image_comma_warped_from_geo
    "Figure 4-18. Central Park image, warped from geo-referencing") shows how different
    my Central Park graphic is now that it has been geo-referenced.
  prefs: []
  type: TYPE_NORMAL
- en: '![Central Park image, warped from geo-referencing](httpatomoreillycomsourcenostarchimages672021.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-18. Central Park image, warped from geo-referencing
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to overlay the warped image on your map using Mapstraction, you need
    to know the boundaries of the image rectangle. To find this information within
    Map Warper, click the **Activity** tab, where you''ll see a table showing the
    timeline of your geo-referencing session. The topmost item is likely Map Successfully
    Rectified. Click the **Further Details** link for that row and you''ll see more
    details, including a box with a list of four decimal numbers. Highlight and copy
    these, which should already be in order: west, north, east, and south.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can add the overlay code to your Mapstraction map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In order to add our warped image to the map, we need to give it an identifier
    ❶. We let Mapstraction know the path to the warped image ❷ (here, I've assumed
    the image is in the same directory as the HTML file). Then, we give an opacity
    percentage ❸ between 0 (invisible) and 100 (hidden—no map can be seen under the
    image). Finally, we add the four numbers from Map Warper ❹ that describe the geographic
    box where the image will reside.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-19](ch04s10.html#central_park_geo-referenced_image_overla "Figure 4-19. Central
    Park geo-referenced image overlay on a Google Map") shows the finished map, with
    the Central Park graphic completely obscuring the Google Map under it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Central Park geo-referenced image overlay on a Google Map](httpatomoreillycomsourcenostarchimages672023.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-19. Central Park geo-referenced image overlay on a Google Map
  prefs: []
  type: TYPE_NORMAL
- en: You can use your own map imagery over larger areas as well. Storing an entire
    city or more of data in a single image won't work very well, however. Instead,
    see the next project, which shows how to create your own imagery to display a
    little bit at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '#26: Use Custom Tiles'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most providers allow you to choose from a handful of imagery types for your
    maps. You can show satellite view, road maps, or a hybrid version. You're not
    the cookie-cutter type though, are you? You like the glitz and glamour of choosing
    your own shade of green for parks or your own thickness for roads. To do this,
    you'll need custom tiles. And what better place for your glitz and glamour than
    the Las Vegas strip?
  prefs: []
  type: TYPE_NORMAL
- en: To create Vegas tiles, we'll need the data about streets and other features.
    Although mapping providers are liberal in what they allow you to do with their
    APIs, most hold the underlying data like a poker player does his or her cards.
    One that makes its data widely available is OpenStreetMap, the free editable map
    of the world. Of course, distributing the details of every street on earth means
    the file is pretty big, so region-specific downloads are also available. In this
    project, for example, we'll just use the data for Nevada, the state where Las
    Vegas is located.
  prefs: []
  type: TYPE_NORMAL
- en: To create the tiles, we'll plug the data into an open source program called
    Mapnik. Because Mapnik can be a bit complicated to install and configure, we'll
    take advantage of another project called Tile Drawer, which provides an Amazon
    EC2 machine image to do much of the technical work. First, let's get a feel for
    how tiles are used by mapping providers.
  prefs: []
  type: TYPE_NORMAL
- en: How Many Pixels Wide Is the Earth?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As described in [Chapter 1](ch01.html "Chapter 1. MAPPING BASICS"), a map is
    made up of tiles arranged to appear as one large image. Each tile is 256 pixels
    square and organized as a grid. Most providers reference the grid left to right
    and north to south, beginning in the Arctic Ocean above Alaska. Tiles are referenced
    by their number in the grid, such as `(14, 34)`.
  prefs: []
  type: TYPE_NORMAL
- en: The number of tiles required to display the entire earth depends on the zoom
    level. For example, at its most zoomed out, which is zoom level 0 in Mapstraction,
    the earth can be shown on a single tile. Each time you zoom in, it takes four
    tiles to show the detail that was previously displayed on one tile. You can find
    the number of tiles used in each direction by determining 2 to the *zoom level*
    power (2*zoom level*). [Table 4-1](ch04s11.html#tiles_and_pixels_at_each_zoom_level
    "Table 4-1. Tiles and Pixels at Each Zoom Level") shows tile and pixel information
    at each zoom level.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a mapping provider loads map tiles, it uses three numbers: the zoom level,
    the number of tiles from the left, and the number of tiles from the top. All of
    these numbers begin at zero, so the upper left of the map at every zoom level
    is `(0, 0)`. The upper right at level 6, for example, is `(16383, 0)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1. Tiles and Pixels at Each Zoom Level
  prefs: []
  type: TYPE_NORMAL
- en: '| Zoom level | Tiles wide/tall | Pixels wide/tall |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 256 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2 | 512 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 4 | 1,024 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 8 | 2,048 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 16 | 4,096 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 32 | 8,192 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 64 | 16,384 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 128 | 32,768 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 256 | 65,536 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 512 | 131,072 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1,024 | 262,144 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 2,048 | 524,288 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 4,096 | 1,048,576 |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | 8,192 | 2,097,152 |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | 16,384 | 4,194,304 |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | 32,768 | 8,388,608 |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | 65,536 | 16,777,216 |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | 131,072 | 33,554,432 |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | 262,144 | 67,108,864 |'
  prefs: []
  type: TYPE_TB
- en: Thankfully, you don't need to reference the tiles by their grid location. The
    mapping provider does all this for you. Understanding how it works is important
    because you'll need to use this knowledge to create custom tile URLs later in
    this project.
  prefs: []
  type: TYPE_NORMAL
- en: As for the question at the top of this section—how many pixels wide is the earth?
    It depends on the zoom level, but for most providers, the earth is between 256
    and 67,108,864 pixels wide.
  prefs: []
  type: TYPE_NORMAL
- en: Start a Tile Drawer EC2 Instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tile Drawer helps you create your own custom map tiles and runs a tile server
    in the cloud. It runs on top of Amazon EC2, which is an *elastic compute cloud*,
    that is, an expandable web server. Another feature of EC2 is the ability to save
    preconfigured servers, Amazon Machine Images (AMIs), and make them available to
    others. That's what the creators of Tile Drawer have done. Handy!
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need an Amazon account (be prepared to provide your email address
    and a few other bits of information) and then sign up for EC2\. Amazon charges
    for this service, but does so for cents per hour, so you''ll be able to try this
    project for less than a dollar. This page will walk you through the signup process:
    [http://aws.amazon.com/ec2/](http://aws.amazon.com/ec2/).'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the AWS Management Console from this page. Click the **Launch Instance**
    button. Then search the Community AMIs for the Tile Drawer machine image. Look
    for *tiledrawer*, or find the ID, such as `ami-e1ea0a88`, listed on [http://tiledrawer.com/](http://tiledrawer.com/).
    When you find the Tile Drawer AMI, click the **Select** button.
  prefs: []
  type: TYPE_NORMAL
- en: On the Instance Details screen, only create one instance, as shown in [Figure 4-20](ch04s11.html#create_a_single_amazon_ec2_tile_drawer_i
    "Figure 4-20. Create a single Amazon EC2 Tile Drawer instance"). Because you'll
    be using a very small area to start, you can get away with a small instance type.
    Click the **Continue** button, and then on the next screen, you mostly leave the
    default settings in place. You'll need to add some user data, however.
  prefs: []
  type: TYPE_NORMAL
- en: '![Create a single Amazon EC2 Tile Drawer instance](httpatomoreillycomsourcenostarchimages672025.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-20. Create a single Amazon EC2 Tile Drawer instance
  prefs: []
  type: TYPE_NORMAL
- en: Declare User Data for Your Instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Tile Drawer server is fairly plug and play. Just a few settings are necessary
    to make it run. As you'll see later, these settings also allow you to fully customize
    your map tiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the wizard on [http://tiledrawer.com/](http://tiledrawer.com/)
    to help you create the user data automatically. Or to continue following along
    with this example, paste the following data in the User Data box on the EC2 setup
    page (see [Figure 4-21](ch04s11.html#adding_user_data_to_the_ec2_instance "Figure 4-21. Adding
    user data to the EC2 instance")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This data has four preferences. First, the style of the map, which uses a CSS-like
    style sheet. We'll stick with the basic look from Tile Drawer for this first example
    and make changes later. Next, we declare a `BoundingBox`, similar to those we've
    used with Mapstraction. The difference here is that longitudes are listed before
    latitudes. The two points we use are still southwest followed by northeast.
  prefs: []
  type: TYPE_NORMAL
- en: The last two items are URLs to files that Tile Drawer will download and use.
    The first is the data itself. We're using the data for Nevada, which is hosted
    by CloudMade. You can find the data you need at [http://downloads.cloudmade.com/](http://downloads.cloudmade.com/).
    Look for files of type *.osm.bz2*. The final URL is the coastline data, which
    is hosted separately.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding user data to the EC2 instance](httpatomoreillycomsourcenostarchimages672027.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-21. Adding user data to the EC2 instance
  prefs: []
  type: TYPE_NORMAL
- en: With the user data set, click **Continue** again. The next screen will prompt
    you to create a key pair. The key pair enables you to connect to the server's
    backend. This advanced feature may be useful at some point in the future. For
    now, select **Proceed without a Key Pair**, and click **Continue**.
  prefs: []
  type: TYPE_NORMAL
- en: On the firewall screen, make sure you select the webserver security group. This
    group opens up the appropriate ports for running a web server, which is necessary
    for accessing your tiles from any computer, including your own. Click **Continue**
    and you'll be on the final screen. Take a deep breath and then click **Launch**.
  prefs: []
  type: TYPE_NORMAL
- en: Tile Drawer Does Its Job
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your EC2 instance will not instantly start up. Although it's a virtual computer,
    it still takes a few minutes to boot. Once it is available, creating all the tiles
    will take some additional time. This is a great time for a break!
  prefs: []
  type: TYPE_NORMAL
- en: But you shouldn't need *too* long of a break. With only one state of data to
    download and a small area to prepare, Tile Drawer should be ready in less than
    15 minutes. From your EC2 dashboard, you should be able to click the **Running
    Instances** link under My Resources. From there, you can see the status of your
    new instance. When the server has booted up, it should switch from yellow and
    pending to green and running.
  prefs: []
  type: TYPE_NORMAL
- en: When the server is running, click your instance and a description will appear
    in the pane below. Scroll down and locate the Public DNS address, as shown in
    [Figure 4-22](ch04s11.html#instance_details_shows_your_public_dns_a "Figure 4-22. Instance
    details shows your Public DNS address."). This address is the equivalent of a
    domain name for your new virtual server. Enter that address in your web browser
    and you should see a page that says, "It works!"
  prefs: []
  type: TYPE_NORMAL
- en: '![Instance details shows your Public DNS address.](httpatomoreillycomsourcenostarchimages672029.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-22. Instance details shows your Public DNS address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add */status.php* to the end of your address to get Tile Drawer''s status.
    Tile Drawer goes through to create tiles: Getting Started, Downloading Source,
    Extracting Data, Creating Tables, Importing Coastline, Downloading Stylesheet,
    and Creating TileCache. As it completes each step, it will become grayed out,
    as shown in [Figure 4-23](ch04s11.html#tile_drawer_apostrophy_s_status_updates
    "Figure 4-23. Tile Drawer''s status updates as each section finishes."). When
    Tile Dawer is done, you can click the link or go to your address followed by */preview.php*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tile Drawer''s status updates as each section finishes.](httpatomoreillycomsourcenostarchimages672031.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-23. Tile Drawer's status updates as each section finishes.
  prefs: []
  type: TYPE_NORMAL
- en: You'll see a quick preview of your new tiles on the Tile Drawer server. You
    can double-click to zoom in. If everything looks good, the time has come to put
    those tiles on a Mapstraction map.
  prefs: []
  type: TYPE_NORMAL
- en: Add Tile Overlays to Your Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of including your tiles in Mapstraction is as easy as a single line
    of code. The hard work is behind you with setting up the tile server—and also
    ahead of you in creating the styles, which can be a tedious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new basic map using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]*`yourserver`*[PRE26]'
  prefs: []
  type: TYPE_NORMAL
- en: Here we have created a map centered on the Las Vegas strip. Then, in the line
    in bold, we tell Mapstraction where to find our tiles. Our URL contains placeholders
    for zoom level ❶ and the tile grid coordinates. These values, `{Z}`, `{X}`, and
    `{Y}`, are filled in with actual numbers. You can see an example tile by going
    to *yourserver.amazonaws.com/tilecache/1.0.0/osm/13/1475/3213.png*. Be sure to
    replace *yourserver* with the Public DNS address of your EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second argument that we pass to Mapstraction''s tile layer function is
    an opacity. Like in [#25: Overlay an Image on a Map](ch04s10.html "#25: Overlay
    an Image on a Map") in [#25: Overlay an Image on a Map](ch04s10.html "#25: Overlay
    an Image on a Map"), we can make our tiles semitransparent so we can still see
    some of the provider imagery underneath. Here I made our tiles completely opaque
    ❷ by choosing a value of one. A number between zero and one sets the percentage.
    For example, 0.6 would be 60 percent opaque.'
  prefs: []
  type: TYPE_NORMAL
- en: Save your map and load it in a browser. You should now see your custom Las Vegas
    tiles instead of the Google imagery, like in [Figure 4-24](ch04s11.html#custom_tiles_using_tile_drawer_apostroph
    "Figure 4-24. Custom tiles using Tile Drawer's "scratch" style sheet"). You may
    catch a glimpse of the default look before your tiles load. That's because the
    custom tiles are being placed on top of Google, so both sets still need to load.
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom tiles using Tile Drawer''s "scratch" style sheet](httpatomoreillycomsourcenostarchimages672033.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-24. Custom tiles using Tile Drawer's "scratch" style sheet
  prefs: []
  type: TYPE_NORMAL
- en: Create Your Own Tile Styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are familiar with CSS for styling web pages, you will likely feel comfortable
    with the way Tile Drawer applies colors and other styles to maps. It uses Cascadenik
    to convert into the file format necessary to work with the Mapnik tile generator.
    Earlier in this project, we used a basic example provided by Tile Drawer. Now
    we'll try changing a few of the colors and road widths.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you'll need is to copy [http://tiledrawer.com/mapscratch.mml](http://tiledrawer.com/mapscratch.mml)
    to your own server. Or you can use the version I have edited for this section
    at [http://mapscripting.com/examples/tiledrawer/mapscratch-edits.mml](http://mapscripting.com/examples/tiledrawer/mapscratch-edits.mml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Vegas is famous for its neon lights, let''s aim to make the roads pop
    out from the map. To do this, we''ll use bright colors and a dark background.
    Find the line that begins with `#land` and change it, using this styling data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This data changes the land, which is essentially the background color, from
    a very light color to nearly black. Black is very Vegas, especially when we include
    the bright colors. For these next changes, you''ll need to use the styles that
    begin with the `#lines`. Be sure your code matches these settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Cascadenik style sheets use OpenStreetMap tags inside the square brackets to
    determine which elements you want to style. In all these examples, we're styling
    highways, a generic term for any road. In the first set, we apply the styles only
    to motorways ❶ and motorway "links" (such as off-ramps). Since everything is bigger
    and brighter in Vegas, we make the motorways wider ❷ and then color them a bright
    red ❸.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two sections, we set the larger streets to be yellow ❹. Residential
    and other small streets are set to blue ❺. As the streets get smaller, so do their
    widths on the map. Seeing as we're doing this Vegas-style, however, they're still
    larger than the styles we're editing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do some powerful things with these styles to make your maps look unlike
    any imagery available. As one example of how specific you can get with styles,
    try adding these lines to your style sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this code is similar to some we've already done. Pay attention
    to the bolded section; it tells the tile server to only apply this style when
    the zoom level is 13\. At all other zoom levels, our other styles will take precedence.
    But when our map is at level 13, the motorways will be orange instead of red.
  prefs: []
  type: TYPE_NORMAL
- en: I didn't reset the line width, as I did in other sections, which means the line
    width already set for motorways will remain the same for zoom level 13\. Only
    the color will change. In addition to `=`, you can use `>`, `>=`, `<`, and `<=`
    to style at certain zoom levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a few styles changed, let''s see Tile Drawer in action. Create a new EC2
    instance (remember to terminate those not in use to avoid the hourly charges)
    with the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you've made changes that I didn't include here, good for you! In that case,
    replace the URL in bold with the address of the map style sheet on your own server.
    To get a feel for how these few changes alters the look of our tiles, see [Figure 4-25](ch04s11.html#big_roads_and_bright_colors_style_the_la
    "Figure 4-25. Big roads and bright colors style the Las Vegas map").
  prefs: []
  type: TYPE_NORMAL
- en: '![Big roads and bright colors style the Las Vegas map](httpatomoreillycomsourcenostarchimages672035.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-25. Big roads and bright colors style the Las Vegas map
  prefs: []
  type: TYPE_NORMAL
- en: After a short wait as your virtual server boots and Tile Drawer does its work,
    your newly styled Las Vegas tiles should be ready. Update the address of your
    server in the Mapstraction file you used to create a tile layer. Load it up and
    you should see the bright roads of Vegas popping out from your new map.
  prefs: []
  type: TYPE_NORMAL
