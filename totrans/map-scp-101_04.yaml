- en: Chapter 4. LAYER IT ON
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: Mapping is like painting on a geo-referenced canvas. The most common brushes
    are markers and message boxes, which is the bulk of what we've used so far. To
    achieve a different texture, you'll need to switch it up. In this chapter, we'll
    branch out with some specialized layers that will improve the look of your maps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we''ll simply draw lines. A lot can be represented simply by connecting
    geographic coordinates together: routes, political boundaries, and even individual
    buildings. This chapter even has a project to color states or countries on a map,
    which could be used to make an election map like the ones that have become popular
    in recent US presidential races.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We'll also add images to the map. Didn't we do that with custom markers? Yes,
    but the images we'll be adding will be larger and act like your own map's imagery.
    In fact, we'll also create custom tiles, still utilizing a mapping API but bypassing
    (or augmenting) its own maps.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Creating layers on your map is a huge step toward making your maps stand out
    as a masterpiece. Get out those new brushes and let's start mapping.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '#16: Draw Lines on a Map'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What''s the shortest distance from point A to point B? Here''s a hint: After
    reading this section, you''ll be able to represent it on a map.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Drawing lines, which Mapstraction calls *polylines*, is very useful. With them,
    you can outline a route, such as driving directions or a hiking trail. Like a
    marker, a line uses latitude and longitude points. Of course, you can't have a
    line with a single point, so you'll need at least two pairs of coordinates to
    draw a line.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Mapstraction lets you have an unlimited number of points, but let''s start
    simply. This example will draw a line between the capitals of Georgia (the US
    state) and Georgia (the country). Add the following code to your `create_map`
    function after your map has been initialized:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first thing I've done is declare the two points ❶, storing them in an array
    variable. Note the square brackets—`[` and `]`—that create the array and that
    the two `LatLonPoints` inside the array are separated by a comma. Mapstraction
    requires an array with at least two `LatLonPoints` to create a polyline.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Next, I actually create the `Polyline` object ❷ using the array. Like a marker
    object, this object is Mapstraction's way of representing the data so it can be
    reproduced with multiple mapping providers, if necessary. Creating a polyline
    is not enough to draw the line, however. I also need to add it to the map ❸.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I automatically center the map using the same function described in
    [#8: Determine the Correct Zoom Level to Use Based on Markers](ch02s08.html "#8:
    Determine the Correct Zoom Level to Use Based on Markers") in [#7: Loop Through
    All Markers](ch02s07.html "#7: Loop Through All Markers"). In this case, Mapstraction
    uses polylines instead of markers to determine the zoom level.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The resulting map is shown in [Figure 4-1](ch04.html#a_line_drawn_between_two_georgian_capita
    "Figure 4-1. A line drawn between two Georgian capitals") with a line drawn across
    the Atlantic Ocean, connecting the two Georgias. Let's see if we can make something
    a little more useful by adding more points to our line.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![A line drawn between two Georgian capitals](httpatomoreillycomsourcenostarchimages671987.png.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1. A line drawn between two Georgian capitals
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Draw Multiple Line Segments
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you think of a line, you probably picture something like what we created
    in the previous section: the connection between two points. Polylines, however,
    can have unlimited segments, which means you can use them to create paths and
    routes.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In fact, Google uses a polyline to display its driving directions. Using polylines
    makes sense because very few streets are perfectly straight. Most have at least
    slight meanderings from side to side. In San Francisco, a couple of streets are
    even known for their crookedness, most notably a short section of Lombard.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some code to create a polyline that very roughly follows the curves
    of Lombard Street, from the top to the bottom:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see from [Figure 4-2](ch04.html#a_polyline_with_several_points_to_trace
    "Figure 4-2. A polyline with several points to trace San Francisco's famous Lombard
    Street"), those 11 latitude and longitude points create a polyline that traces
    along Lombard's eight turns. As with the Georgia example, the points are stored
    within brackets to create the JavaScript array that Mapstraction needs to make
    a polyline.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![A polyline with several points to trace San Francisco''s famous Lombard Street](httpatomoreillycomsourcenostarchimages671989.png.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2. A polyline with several points to trace San Francisco's famous Lombard
    Street
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Lombard Street is still a fairly simple example. We've covered less than a quarter
    mile—and that includes the twists and turns. You could use polylines to trace
    entire highways, rivers that flow for hundreds of miles, or even the Great Wall
    of China.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Set the Color and Thickness
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like markers and other aspects of a map, polylines come with a standard look
    you may want to change. For example, you can alter the color and thickness of
    the lines you draw.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Mapstraction has individual functions to set the criteria you want. Each can
    be applied after you have created a polyline, but before you have added it to
    the map. This process is similar to the order in which Marker options have to
    be added.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that makes a purple polyline that is five pixels thick (it
    assumes your polyline is stored in the `poly` variable):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the color is set as a hexadecimal value ❶, similar to how colors are
    declared in HTML. Either a six- or three-character value works, and you can even
    precede it with a hash mark, `#`, if you prefer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some browsers, especially older ones, have trouble with colored polylines. Be
    sure to check thoroughly across all browsers your user base commonly employs,
    especially if the color of the polyline is integral to your application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Because you''ll often want to set several attributes at once, Mapstraction
    has a function that accepts many options, storing their values in a JavaScript
    object:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The curly brackets `{` and `}` are important, as they declare the JavaScript
    object. Then an attribute is set with the name of the option, a colon, and the
    value. You'll see more examples of adding styling options to polylines in the
    next project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '#17: Draw Shapes on a Map'
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Are you ready for a little philosophy? I hope so, because I have a philosophical
    question for you: What is a shape?'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Before you answer that, let's list some names of shapes. Shapes include circles
    and triangles. Squares are popular, as are their relative the rectangles. If we
    continue to increase the number of sides, the names may sound familiar—pentagon,
    hexagon, heptagon, octagon—and then the names get a little strange.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Your philosophical answer may be different, but for our purposes, we'll create
    a shape with some number of sides. This shape is called a *polygon*. A polygon
    is made up of line segments that start and end at the same point. If you have
    mastered the previous project, you probably have a pretty good idea of how you
    could create a polygon using Mapstraction.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Surprisingly, creating shapes on a map is essentially the same process as drawing
    polylines. Take a look at this code, which draws an outline around the US Department
    of Defense headquarters ("The Pentagon"—get it?):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As with standard polylines, we need to declare an array of `LatLonPoint`s using
    square brackets `[` and `]` to show a JavaScript array. The big difference is
    that the first and last points (both shown in bold) are identical, signaling to
    Mapstraction that you are creating a polygon.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The outcome, as shown in [Figure 4-3](ch04s02.html#the_pentagon_building_outlined_with_a_po
    "Figure 4-3. The Pentagon building outlined with a polygon"), is that the polyline
    is filled in to show that it's more than just a line—it's a shape. Shapes bring
    up a few more styling issues than normal lines, so Mapstraction provides some
    additional options.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![The Pentagon building outlined with a polygon](httpatomoreillycomsourcenostarchimages671991.png.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3. The Pentagon building outlined with a polygon
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Set the Fill Color and Opacity
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that your polyline has turned into a polygon, let's declare the color that
    fills its center. Also, with the fill covering such a large area, you may want
    to leave bits of the map under the polygon visible. That's where opacity comes
    in—it determines the opaqueness of the fill color.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with graphics programs, you'll likely be comfortable with
    opacity. You declare it with a percentage from 0 to 100, where 0 is invisible
    and 100 is not transparent at all.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use a single function in Mapstraction to set all the options for the
    pentagon we made earlier:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Mapstraction中的一个单一函数来设置我们之前制作的五边形的所有选项：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we have declared an opacity of 90 percent ❶, so we can barely see through
    it. Notice that we use a decimal between 0 and 1 to show the percentage. Though
    mathematically correct, you may find this a little confusing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了90%的不透明度❶，所以我们几乎看不到它。请注意，我们使用0到1之间的十进制数来表示百分比。虽然从数学上是正确的，但你可能会觉得有点困惑。
- en: The fill color is declared with a CSS-like hexadecimal value ❷. This value is
    separate from the color of the polyline, which can be the same or different. In
    this example, the fill color is a bright green, whereas the border is a slightly
    darker green.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 填充颜色使用类似CSS的十六进制值声明❷。此值与折线颜色分开，可以是相同的也可以是不同的。在这个例子中，填充颜色是一种明亮的绿色，而边框则是一种略深的绿色。
- en: '#18: Add Circles to Show Search Radius'
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#18：添加圆以显示搜索半径'
- en: Drawing lines and polygons is fairly easy. They are made up of a series of connected
    points. A circle is a little more difficult to express. A circle has no points
    that make up its border. Instead, it's declared by a center point and a radius.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制线和多边形相对简单。它们由一系列连接的点组成。圆稍微有点难以表达。圆没有组成其边界的点。相反，它通过一个中心点和半径来声明。
- en: Circles are useful in mapping, because you can use them to show an area you
    are searching. For example, if you are looking for places within five miles of
    a point, your circle would be ten miles wide (and tall—a circle is perfectly round),
    with the search point right at the center.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 圆在地图上很有用，因为你可以用它们来显示你正在搜索的区域。例如，如果你正在寻找距离一个点五英里内的地点，你的圆将宽十英里（并且高——圆是完美圆形的），搜索点正好位于中心。
- en: Mapstraction offers two ways to create a circle. First, we can approximate with
    a many-sided polygon. Second, we could use a graphic and layer it on top of the
    map. In this section, I'll show you how to do both.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Mapstraction提供了两种创建圆的方法。首先，我们可以用多边形进行近似。其次，我们可以使用图形并将其叠加在地图上。在本节中，我将向你展示如何做这两件事。
- en: Approximate with a Polygon
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用多边形进行近似
- en: Creating a fake circle by connecting points along the circle looks better than
    you might imagine it would. Of course, the more points you use, the better the
    circle looks. Mapstraction has a built-in function to perform the computations,
    and you can set the quality.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过连接圆上的点来创建一个假圆看起来比你想象的要好。当然，你使用的点越多，圆看起来就越好。Mapstraction有一个内置函数来执行计算，你可以设置质量。
- en: 'Remember, a circle requires two pieces of information: a center and a radius.
    In this example, we''ll show just how big the state of Texas is by drawing a circle
    500 miles in diameter starting from its capital near the center of the state.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一个圆需要两个信息：一个中心和半径。在这个例子中，我们将通过画一个直径为500英里的圆来展示德克萨斯州的大小，这个圆从州的首府开始，位于州中心的附近。
- en: 'Add these lines to your map initialization function, which I''ve called `create_map`
    throughout this book:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些行添加到你的地图初始化函数中，我在整本书中将其称为`create_map`：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code is all that''s necessary to add a circle-ish polygon to your map.
    First, you need to create a `Radius` object ❶, which is part of the Mapstraction
    library. This object does some important calculations to determine the circle''s
    edges. Then you pass the object two values: the center point (downtown Austin,
    Texas) and a quality number ❷.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是添加类似圆形的多边形到地图上所必需的。首先，你需要创建一个`Radius`对象❶，它是Mapstraction库的一部分。这个对象进行一些重要的计算来确定圆的边缘。然后你传递给这个对象两个值：中心点（德克萨斯州奥斯汀市中心）和一个质量数字❷。
- en: The lower the quality number, the more your polygon will look like a circle.
    The number represents the degrees between each point in the polygon. You can use
    this to determine the number of sides your "circle" will have. A circle is 360
    degrees total, so if you divide by 10, that's 36 points, which means you're creating
    a 36-sided polygon in this instance. Using this method, you've done a pretty good
    job of approximating a circle, as you can see in [Figure 4-4](ch04s03.html#circle_approximated_by_36-sided_polygon
    "Figure 4-4. Circle approximated by 36-sided polygon"). The more sides you have,
    the longer it takes to create the circle, so you have to make a trade-off.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Circle approximated by 36-sided polygon](httpatomoreillycomsourcenostarchimages671993.png.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4. Circle approximated by 36-sided polygon
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a `Radius` object, you can create the polygon, which is a
    `Polyline` object. You use a Mapstraction function to convert miles to kilometers
    ❸. Here, I've passed it the number of miles of the radius, which is half of the
    diameter of the eventual circle. Also, I've passed a hexadecimal value for the
    color ❹ of the circle, in this case, a shade of purple.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: You can create as many circles as you want from the radius object, so you could
    show several levels of distance from Austin. If you want to move the center (or
    change the quality of the circle), however, you'll need to re-create the radius
    object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Overlay a Circle Image
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The polygonized circle may still be too jagged for you, or perhaps you want
    more control over how the circle looks. In that case, overlaying an image on your
    map is your best choice.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: First, you'll need a circle image, likely saved as a transparent PNG file. Transparency
    is important because graphics are stored as rectangles, so you definitely don't
    want the area outside of the circle to be visible. Also, since you'll be referencing
    this on the map as a rectangle, your circle should be up against the four edges
    of the graphic. I've included several sample circle graphics for download on the
    book's website at [http://mapscripting.com/circle-overlays](http://mapscripting.com/circle-overlays).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your circle graphic, you can figure out where to place it on the
    map. A graphic is referenced by the four sides of its rectangle, so you need to
    determine the north, south, east, and west points. Usually, a circle is determined
    by its center and radius. You can calculate the side values by measuring in four
    directions from the center.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these lines to your map code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To be able to determine the geographic borders of your circle image, you need
    to calculate how many degrees of latitude and longitude make up the radius, which
    is 250 miles. The latitude distance ❶ is easier, because latitude is nearly constant
    throughout the world at 69.2 miles per degree.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Longitude depends on where you are on earth because the degrees are closer to
    each other as you near a pole. Mapstraction has a handy function ❷ for converting
    meters to longitude based on a latitude. In order to pass the function 250 miles
    in meters, you must first convert to kilometers ❸ and then multiply by 1000.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have your distances, so now you just need to calculate the
    four sides. For example, the northern border ❹ of the graphic will be at the center
    point latitude plus the number of degrees latitude we determined are in 250 miles.
    South will also use that latitude distance (only this distance is subtracted from
    the center's latitude. East and west borders will use the longitude distance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Armed with your four geographic borders, you can apply your image overlay. Mapstraction
    needs a lot of information, including an identifier for the image ❺ and an opacity
    level ❻ (for this example, I've chosen 75 percent). The results are shown in [Figure 4-5](ch04s03.html#transparent_circle_image_overlay
    "Figure 4-5. Transparent circle image overlay"), where you can see a perfect circle
    atop Texas. The area it covers, you'll notice, is identical to the area covered
    by the polygon circle in [Figure 4-4](ch04s03.html#circle_approximated_by_36-sided_polygon
    "Figure 4-4. Circle approximated by 36-sided polygon").
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![Transparent circle image overlay](httpatomoreillycomsourcenostarchimages671995.png.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5. Transparent circle image overlay
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: No matter which type of circle you choose to use, Texas is a big state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '#19: Draw a Rectangle to Declare an Area'
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. PLOTTING MARKERS AND MESSAGE BOXES"), I
    discussed the bounding box, a set of coordinates that roughly describes a geographic
    area. I write *roughly* because bounds are visually rectangular, so they can only
    be used to declare the simplest of areas. Of course, with every map we have been
    indirectly creating bounds. The visible portion of the map is a rectangular portion
    of the greater map.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Mapstraction uses the `BoundingBox` class to describe an area. As a data structure,
    this class is made up of two `LatLonPoint`s. One declares the southwest corner
    (the lower left) and the other the northeast corner (the upper left). From those
    two values, we can figure out the remaining two corners. And we'll do just that
    in this project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'You may find yourself wanting to declare an area of the map visually. Because
    a `BoundingBox` is simply a data representation of an area, we need to convert
    to a `Polyline`. Add this function to your JavaScript (outside the `create_map`
    function) to perform the conversion:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Drawing a rectangle on a map requires five points. At first, this requirement
    may seem a bit strange—doesn't a rectangle have four corners? Of course. We aren't
    violating basic rules of geometry. We need to declare the start and the finish
    points separately, however. And because these are the same point (or, as you'll
    see, nearly the same), we include it twice.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The array of points begins, simply enough, with the southwest point ❶. Then
    we want to draw a line directly north, which means we need to keep the same longitude
    while increasing the latitude. We only have two points to work with, so we create
    a new point ❷ using the southwest's longitude and the northeast's latitude.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The third point is the northeast point itself. Then we can use a similar process
    to determine the fourth point. Finally, we need to draw the final side of the
    rectangle back to the southwest point. But this is where things get strange. If
    we use exactly the southwest point, Mapstraction will fill in the area. To get
    an unfilled box, we create a final point with a longitude almost imperceptibly
    off ❸ from the starting point.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve written our new function, we need to call it. From within your
    `create_map` function, add the following lines:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We could create new bounds if we wanted, but instead we are taking them from
    the map itself ❹. Then we use those bounds to call our function to convert to
    a `Polyline` ❺. As you saw earlier, creating the object is just the first step.
    We also need to add it to the map. The final line zooms out so we can see the
    rectangle, as shown in [Figure 4-6](ch04s04.html#bounding_box_converted_to_a_polyline
    "Figure 4-6. Bounding box converted to a polyline"). Without zooming, the rectangle
    would be right at the edges of our map.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![Bounding box converted to a polyline](httpatomoreillycomsourcenostarchimages671997.png.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6. Bounding box converted to a polyline
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this snippet of code to clearly show bounds. For an example of this project
    in action, see [#7: Loop Through All Markers](ch02s07.html "#7: Loop Through All
    Markers") in [Other Useful Parameters](ch06s07.html#other_useful_parameters "Other
    Useful Parameters").'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '#20: Draw Lines Along Clicks'
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The biggest stumbling block to creating your own lines on a map is finding the
    latitude and longitude points. With this project, you (or your users) will be
    able to draw lines simply by clicking the map. Gmap Pedometer ([http://gmap-pedometer.com/](http://gmap-pedometer.com/))
    popularized this technique in the earliest days of mapping APIs, and now you can
    use it, too.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Reacting to a click event is at the center of this method. You will find events
    covered in detail in [Chapter 5](ch05.html "Chapter 5. HANDLE MAP EVENTS"). We
    want to store all the click points in an array. Because we''ll be accessing this
    from an event, the variable we create needs to be public, meaning it is declared
    outside of any function. Include this line at the beginning of your JavaScript:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This variable will hold every point that is clicked. Right now it is an empty
    array (there's nothing between those square brackets). With every click, however,
    we'll add a new `LatLonPoint` to the array.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'From within your map initialization code, add these lines to react to clicks:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, I have included the code that runs when the user clicks the map in an
    anonymous, inline function. This is about as long as I would make a function without
    explicitly naming it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The very first thing that happens is we "push" the new point into the array
    ❶. The `push` function is built into JavaScript for every array variable and always
    adds it on to the end of the array.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The minimum number of points before we can draw a line is two. This requirement
    causes a bit of an issue because we need the user to know we have recorded the
    first click. To deal with this, we added a marker ❷ to the map only if the length
    of the array is one. In other words, a marker is added only on the first click.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: On subsequent clicks, we create a new polyline ❸ with the two most recent points.
    To do this, we connect the last point in the array ❹ to the next-to-last point
    in the array (because arrays in JavaScript begin counting at zero, the last element
    is always one less than the length). Also, remember that a polyline is created
    with an array itself, so we need to surround those two numbers with brackets.
    The code starts to look a little messy.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: After several clicks, the map will look something like [Figure 4-7](ch04s05.html#connecting_clicks_with_polyline_segments
    "Figure 4-7. Connecting clicks with polyline segments"). Internally, we'll have
    all the points stored in our array. Mapstraction, however, is treating each line
    segment as its own polyline. From a visual perspective, it still looks like one
    big line.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting clicks with polyline segments](httpatomoreillycomsourcenostarchimages671999.png.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7. Connecting clicks with polyline segments
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '#21: Color States/Countries on a Map'
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've paid attention to recent US politics, you've likely seen red and blue
    state maps. During the 2004 and 2008 presidential campaigns, these became common
    across the Web. And believe it or not, if you've read this far in the chapter,
    you already know how to make a colored map of your own.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: All you need are the points that make up the outline of each state. Then, you
    create a polygon for each state, giving it the proper fill color. Before you can
    start coloring states, you'll need the points that make up the outline of each
    state. You can get this data in a number of ways. For example, you could create
    it on your own using code similar to that in the previous project.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: You could also take it directly from the government, but you'd likely need to
    convert it to a format that's easy for Mapstraction to use. I have data sources
    available at the book's website at [http://mapscripting.com/state-boundaries](http://mapscripting.com/state-boundaries).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to try it out, start with just a few states. In this example, I''ll
    use the four-corner states of Utah, Colorado, Arizona, and New Mexico. They have
    relatively few points, and they all come together neatly. The first step is declaring
    the points that make up each state boundary as a JavaScript array:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Arizona is just a little too complex to show all of its points in the book,
    but the others are complete. Like declaring other shapes using points, we include
    a list of `LatLonPoint`s within square brackets to designate an array. To create
    a complete shape (and, therefore, include a fill color), the first and last points
    in the array must be identical. The identical points tell Mapstraction that the
    polyline begins and ends at the same place.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 亚利桑那州过于复杂，无法在书中展示其所有点，但其他州的信息是完整的。就像使用点声明其他形状一样，我们使用方括号包含一个`LatLonPoint`列表来指定一个数组。为了创建一个完整的形状（因此包括填充颜色），数组中的第一个和最后一个点必须相同。相同的点告诉Mapstraction多边形开始和结束在同一个地方。
- en: 'Because we are going to be performing the same actions multiple times, this
    is an appropriate occasion to create our own function. Here is the code to color
    in a state:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将多次执行相同的操作，这是一个创建我们自己的函数的合适时机。以下是填充状态的代码：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll call this function four times—once for each state. Or, if you're doing
    the whole United States, you'd call the function fifty times. This function's
    three lines mean our code will only take up one-third of the space. If you're
    going to run the same code many times, you'll want to avoid duplication and create
    your own function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用这个函数四次——一次针对每个州。或者，如果你要绘制整个美国，你需要调用这个函数五十次。这个函数的三行意味着我们的代码只需占用三分之一的篇幅。如果你打算多次运行相同的代码，你将想要避免重复并创建自己的函数。
- en: We'll need to pass the function two arguments. First, we pass it a list of points
    ❶—a state boundary array. Then, because we're filling in the map with different
    colored states, we'll need to let the function know what color ❷ to make the current
    state.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将函数传递两个参数。首先，我们传递给它一个点的列表❶——一个状态边界数组。然后，因为我们将在地图上用不同颜色的状态填充，我们需要让函数知道当前状态应该使用什么颜色❷。
- en: The function then goes to work creating a `Polyline` and adding data to it.
    We've set the opacity to 90 percent ❸, which means the filled state shape will
    be slightly transparent, just enough to see the state name underneath. The color
    is set ❹ to the argument that we received. We made the width zero ❺, meaning the
    state will not have a border. You may prefer to have a border, so try out a few
    different values. This argument takes integers, which refer to thickness in number
    of pixels.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 函数随后开始创建一个`Polyline`并添加数据到它。我们已将不透明度设置为90%，这意味着填充的状态形状将略微透明，足以看到下面的州名。颜色设置为❹为我们接收到的参数。我们将宽度设置为零❺，这意味着州将没有边界。你可能更喜欢有边界，所以尝试几个不同的值。这个参数接受整数，表示像素厚度。
- en: 'Nothing we''ve done so far will actually do anything yet. For that, we need
    to call this function, passing a state boundary array and color. Add this code
    to your map initialization section:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所做的一切实际上还没有做任何事情。为了做到这一点，我们需要调用这个函数，传递一个状态边界数组和颜色。将以下代码添加到你的地图初始化部分：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you see, this calls the `color_state` function four times, using a different
    point array variable and color each time. To keep this example apolitical, I've
    used shades of green. Feel free to insert your own red (`'ff0000'`) or blue (`'0000ff'`)
    values.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这调用了`color_state`函数四次，每次使用不同的点数组变量和颜色。为了保持这个例子不涉及政治，我使用了绿色的不同色调。你可以自由地插入你自己的红色（`'ff0000'`）或蓝色（`'0000ff'`）值。
- en: To be sure every state is within view, I autocentered the map after adding the
    four states. As you can see from [Figure 4-8](ch04s07.html#polygons_of_four_us_states
    "Figure 4-8. Polygons of four US states"), our map looks pretty snazzy. But if
    you zoom in, the borders of each state might not completely touch. That's a precision
    issue, which you may not care about. Its importance depends on how closely you
    expect users to view your borders. For the case of a colored election map, which
    is viewed at country-level, we don't need perfection.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每个州都在视野中，我在添加了四个州之后自动居中了地图。正如你在[图4-8](ch04s07.html#polygons_of_four_us_states
    "图4-8. 四个美国州的多边形")中看到的那样，我们的地图看起来相当漂亮。但如果你放大查看，每个州的边界可能不会完全接触。这是一个精度问题，你可能并不关心。它的重要性取决于你期望用户多接近地查看边界。对于查看国家级别的彩色选举地图的情况，我们不需要完美。
- en: Another issue you may notice with creating a state map is that not all states
    are one perfect shape. Hawaii is a series of islands, and Michigan's two pieces
    are separated by a Great Lake. Again, how you handle this depends on how big of
    a deal it is to you. You may be fine connecting the portions so they can be one
    state. Or, you may use multiple polygons to represent these complex states.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会注意到创建州地图时的问题，并不是所有州都是完美的形状。夏威夷是一系列岛屿，密歇根的两个部分被一个大湖分隔。再次强调，您如何处理这取决于这对您有多重要。您可能觉得将部分连接起来以形成一个州是可以接受的。或者，您可能使用多个多边形来表示这些复杂的州。
- en: '#22: Add Custom Controls'
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#22: 添加自定义控制'
- en: Everything we have layered on the map so far has been geo-referenced. In other
    words, when the user drags the map to the side, the thing we've layered also moves.
    In this section, we'll create some interface elements that don't move, but instead
    are anchored to a specific spot in the map window.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在地图上叠加的所有内容都进行了地理参照。换句话说，当用户将地图拖到一边时，我们叠加的内容也会移动。在本节中，我们将创建一些不移动，而是锚定在地图窗口特定位置的用户界面元素。
- en: The controls we'll be creating are similar to map type controls, which are in
    the upper-right corner of the map. In [Add Zoom and Other Controls](ch01s06.html
    "Add Zoom and Other Controls") in [Add Zoom and Other Controls](ch01s06.html "Add
    Zoom and Other Controls"), I showed how to include these (and other) controls.
    Now, we'll be making our own buttons that live in the same spot.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的控制类似于地图类型控制，它们位于地图的右上角。在[添加缩放和其他控制](ch01s06.html "添加缩放和其他控制")中，我展示了如何包含这些（以及其他）控制。现在，我们将制作自己的按钮，它们将位于相同的位置。
- en: For this example, we'll make a button that gives users the option to center
    the map automatically so all the markers and lines are visible. Better yet, we'll
    write the code so you can create any number of these custom controls with a simple
    function call.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将创建一个按钮，用户可以通过它自动将地图居中，以便所有标记和线条都可见。更好的是，我们将编写代码，让您可以通过简单的函数调用创建任意数量的这些自定义控制。
- en: '![Polygons of four US states](httpatomoreillycomsourcenostarchimages672001.png.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![四个美国州的区域](httpatomoreillycomsourcenostarchimages672001.png.jpg)'
- en: Figure 4-8. Polygons of four US states
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-8. 四个美国州的区域
- en: 'Here''s the code for creating a control:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建控制的代码：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function needs two pieces of data in order to create the control and add
    it to the map: It needs the text ❶ that will be written inside the button, and
    it needs the function ❷ that it will call when the button is clicked.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建控制并将其添加到地图中，此函数需要两份数据：它需要写入按钮内的文本❶，以及当按钮被点击时它将调用的函数❷。
- en: With those pieces of information, we can go about creating this control. In
    terms of how the browser interprets it, we are creating a simple `<a>` tag programmatically
    ❸. We give it a class name ❹ so we can style it with CSS. Then we add the label
    to it ❺.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们可以着手创建这个控制。从浏览器如何解释的角度来看，我们正在程序化地创建一个简单的`<a>`标签❸。我们给它一个类名❹，以便我们可以用CSS来样式化它。然后我们向它添加标签❺。
- en: At this point, the control has been created, but it isn't on the map, nor does
    it do anything. To fix these two issues, we set the function ❻ that will be called
    when the user clicks and then append the object as a child of the map object ❼.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，控制已经创建，但它还没有在地图上，也没有执行任何操作。为了解决这两个问题，我们设置了当用户点击时将被调用的函数❻，然后将对象作为地图对象的子对象❼添加。
- en: 'Now we can style the control. Add these CSS lines to your style sheet:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为控制添加样式。将这些CSS行添加到您的样式表中：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This CSS is designed to make our controls look similar to Google's map type
    controls. Only the first two lines (in bold) are necessary to position it in the
    upper-right corner. Everything else is styling.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这段CSS旨在使我们的控制看起来与谷歌地图类型控制相似。只有前两行（加粗）是必要的，用于将其定位在右上角。其余的都是样式。
- en: 'All of the hard work is now done, and we''re ready to use our custom control.
    From within the initialization code for our map, add these lines to create an
    autocentering control:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所有艰苦的工作现在都完成了，我们准备好使用我们的自定义控制。在我们的地图初始化代码中，添加以下行以创建一个自动居中控制：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code passes the label for our new control (autocenter) and an anonymous,
    inline function reference, which decides what to do when the user clicks the new
    control button. In this case, it fires off the Mapstraction code to show all the
    markers and lines on the map automatically. See [Figure 4-9](ch04s07.html#a_custom_control_looks_like_a_google_con
    "Figure 4-9. A custom control looks like a Google control") for a before and after
    example of clicking the button.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'You could do anything you want when the user clicks your custom control button.
    One common choice might be showing only markers of a particular type. I demonstrate
    how to do this in [#9: Filter Out Certain Markers](ch02s09.html "#9: Filter Out
    Certain Markers") in [#9: Filter Out Certain Markers](ch02s09.html "#9: Filter
    Out Certain Markers"). With a marker-filled map, you might also create specific
    areas to zoom into, as I do in [#70: Display Recent Earthquakes Worldwide](ch10s03.html
    "#70: Display Recent Earthquakes Worldwide") in [#70: Display Recent Earthquakes
    Worldwide](ch10s03.html "#70: Display Recent Earthquakes Worldwide").'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![A custom control looks like a Google control](httpatomoreillycomsourcenostarchimages672003.png.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: Figure 4-9. A custom control looks like a Google control
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '#23: Create Your Own Zoom Interface'
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you choose a mapping provider, certain elements of how the map looks cannot
    be easily changed. The zoom interface may be one of these things you've accepted
    as being unchangeable. In this project, I'll show how you can include your own
    zoom in/out buttons to give you even more control over the look of your map.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The approach is similar to the previous project. We'll make a function that
    adds a new object to the page, and we'll position and style it using CSS. Instead
    of a text button, we'll make an image button. And, as before, each new object
    will react to a click.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need two images: one will be your zooming-in button and the other
    the zooming-out button. You can see the two unassuming graphics I chose in [Figure 4-10](ch04s08.html#two_zoom_graphics_to_be_used_as_custom_c
    "Figure 4-10. Two zoom graphics to be used as custom controls").'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Two zoom graphics to be used as custom controls](httpatomoreillycomsourcenostarchimages672005.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Figure 4-10. Two zoom graphics to be used as custom controls
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the generic code for creating an image control:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function needs two pieces of data in order to create the control and add
    it to the map. It needs the image source ❶, which is a path to the image file
    we'll be using for this control. It also needs the function ❷ that it will call
    when the image is clicked.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Now we're ready to create this control. We create an image element programmatically
    ❸, just as we did with the `<a>` tag when making a custom control. Then we give
    the image a class name ❹ so we can style it with CSS. Finally we add the image
    URL ❺. This URL can be full or relative to the current page.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the image is created, but it's neither on the map, nor does it
    do anything. To fix those two issues, we set the function ❻ to be called when
    the user clicks and then append the image object as a child of the map object
    ❼.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make sure our new image controls are positioned correctly. Add these
    CSS lines to your style sheet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we can add our custom zoom controls to the map. From within the initialization
    code for your map, add these lines:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, I've created two image controls, as shown in [Figure 4-11](ch04s08.html#custom_zoom_images_on_a_map
    "Figure 4-11. Custom zoom images on a map"). The first is for zooming in. The
    CSS will place the control furthest to the right. I send it the name of my image
    ❶, which assumes it is stored in the same directory as the HTML page. Then I pass
    it an anonymous, inline function. Here, I set the zoom level ❷ using Mapstraction,
    passing a number one greater than the current zoom level.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom zoom images on a map](httpatomoreillycomsourcenostarchimages672007.png.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: Figure 4-11. Custom zoom images on a map
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The second image control is similar. It is given a different image, and when
    clicked, it sets the zoom to one *less* than the current zoom level.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '#24: Plot Image Thumbnails on a Map'
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A picture may not be quite worth a thousand geographic points, but it's close.
    A map is a great way to show photos that have been *geo-tagged*. Geo-tagging is
    associating latitude and longitude coordinates with images. Full-size photos may
    not be ideal, however, as they would take up too much space. Instead, a popular
    method is to display much smaller versions—thumbnails—that the viewer can expand.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you'll need photos. You can use some that you have as a test or search
    the photo sharing site Flickr. I was able to find some good shots, already geo-tagged,
    by searching for Orlando, Florida. I looked specifically for photos that are licensed
    as Creative Commons, meaning they have less rigid copyright restrictions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Though we will link to larger versions of each picture, we'll need separate
    files to store the smaller versions. Another plus to using Flickr is that it creates
    these thumbnails and a midsize image, too, automatically.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'For each Orlando photo we plot, we''re going to need the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Photo thumbnail
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Latitude and longitude
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Medium-sized photo
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dimensions of medium photo
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Link to full photo
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the very least you need the first two items, though you'll create a better
    user experience the more items from this list you can include. If, like me, you're
    using Flickr, then you'll need that link to avoid violating Creative Commons.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'My three plotted thumbnails are shown on a map in [Figure 4-12](ch04s09.html#thumbnails_overlaid_as_custom_markers_op
    "Figure 4-12. Thumbnails overlaid as custom markers (Photos by Ron Miguel, Kok
    Leng Yeo, and LancerE)"). As in other situations where we may be doing one action
    many times, creating a function is best. Add this to your JavaScript code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As arguments to the function, we need to pass all the items I mentioned in the
    list. Then we create a custom marker using the thumbnail image ❶. Notice that
    I set the dimensions of the marker to be 50×50\. You can use whatever size you
    want, but make sure the image itself is close to that size. Flickr's are 75 pixels
    square, so a little downsizing is okay.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to set a shadow ❷ or else the default will be used (in Google
    Maps the default is a reverse teardrop, which would look funny underneath a square
    photo). I've created an outline graphic that gives a slight border to the image.
    I set the size to be slightly bigger than the thumbnail itself.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add a message box. Remember, you can include any HTML inside, so
    we'll link to the full image ❸, as well as display the medium image ❹. To help
    the mapping provider determine how big to make the message box, we include the
    width ❺ and height ❻ of the midsized image.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''re ready to call the function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Thumbnails overlaid as custom markers (Photos by Ron Miguel, Kok Leng Yeo,
    and LancerE)](httpatomoreillycomsourcenostarchimages672009.png.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: Figure 4-12. Thumbnails overlaid as custom markers (Photos by Ron Miguel, Kok
    Leng Yeo, and LancerE)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: This function plots a single photo thumbnail on the map. Click the tiny version
    and it opens a message box showing the midsized version. Then, when you click
    the image, the Flickr link opens.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Now simply call that function two more times—or twenty. You can use the Flickr
    shots from my map as examples:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.flickr.com/photos/kamoteus/2421383748/](http://www.flickr.com/photos/kamoteus/2421383748/)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.flickr.com/photos/yeowatzup/461692550/](http://www.flickr.com/photos/yeowatzup/461692550/)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a more advanced project, you could automate the process of finding images
    by tapping into the Flickr API to search near a geographic point. The API then
    responds back with XML or JSON, both of which you can parse using the techniques
    shown in [Chapter 8](ch08.html "Chapter 8. DATA FORMATS").
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '#25: Overlay an Image on a Map'
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can add an image to a map in a number of ways. In [#5: Create a Custom
    Icon Marker](ch02s05.html "#5: Create a Custom Icon Marker") in [#4: Show and
    Hide Message Boxes Without Clicking the Marker](ch02s04.html "#4: Show and Hide
    Message Boxes Without Clicking the Marker"), you used an image as the icon for
    a Placemark. In this section, we''ll do something a bit different—overlaying an
    image over a larger area of the map, where it will replace or augment the existing
    map.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'You''re actually familiar with this process, as we used it earlier in this
    chapter, in [#18: Add Circles to Show Search Radius](ch04s03.html "#18: Add Circles
    to Show Search Radius") in [Set the Fill Color and Opacity](ch04s02.html#set_the_fill_color_and_opacity
    "Set the Fill Color and Opacity"). There, we used a circle image and geo-referenced
    it so the image was centered on a point and covered a specific area. That example
    was easier than what we want to do now because a circle is the same distance in
    every direction and it doesn''t matter where it''s pointing.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '你实际上已经熟悉这个过程，因为我们在本章前面已经使用过它，在[第18节：添加圆圈以显示搜索半径](ch04s03.html "#18: 添加圆圈以显示搜索半径")和[设置填充颜色和透明度](ch04s02.html#set_the_fill_color_and_opacity
    "设置填充颜色和透明度")中。在那里，我们使用了一个圆形图像并将其地理参照，使图像以一个点为中心并覆盖特定区域。那个例子比我们现在想要做的要简单，因为圆在各个方向上的距离相同，而且它指向哪里并不重要。'
- en: Consider, for example, the map of New York's Central Park in [Figure 4-13](ch04s10.html#central_park_source_graphic
    "Figure 4-13. Central Park source graphic"). It contains some buildings and landmarks
    that may not be on your standard web map. This map has the park perfectly oriented
    to be running north and south. In reality, the streets that border the long side
    of the park are slightly east of north (and west of south).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下[图4-13](ch04s10.html#central_park_source_graphic "图4-13. 中央公园源图形")中纽约中央公园的地图。它包含了一些可能不在你标准网络地图上的建筑和地标。这张地图将公园完美地定位，使其南北方向延伸。实际上，环绕公园长边街道的位置稍微偏东（相对于北边，相对于南边）。
- en: '![Central Park source graphic](httpatomoreillycomsourcenostarchimages672011.png.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![中央公园源图形](httpatomoreillycomsourcenostarchimages672011.png.jpg)'
- en: Figure 4-13. Central Park source graphic
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-13. 中央公园源图形
- en: Mapstraction is only able to overlay a graphic if the top of its rectangle is
    at north exactly. To get the Central Park map to match the rest of New York, we
    need to geo-reference it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Mapstraction只能在其矩形顶部正好位于北边时覆盖图形。为了使中央公园地图与纽约的其他部分匹配，我们需要对其进行地理参照。
- en: Geo-Reference Your Map
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地理参照您的地图
- en: At the heart of the geo-referencing technique is the ability to determine the
    latitude and longitude of points on the graphic. Then, using those points, you
    can bend and warp the map so the top and bottom borders of the graphic are static
    latitudes (and the other two static longitudes).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 地理参照技术的核心是确定图形上点的纬度和经度。然后，使用这些点，你可以弯曲和扭曲地图，使图形的顶部和底部边界成为静态纬度（以及另外两个静态经度）。
- en: This process is often called *rubbersheeting*, because you are taking a two-dimensional
    reference, stretching it across a spherical earth, and then unfolding it so it's
    flat again. The result is a warped image, as if it were made of rubber.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程通常被称为*橡皮膜法*，因为你正在将二维参照拉伸到球形地球上，然后将其展开使其再次变平。结果是扭曲的图像，就像它是由橡皮制成的。
- en: You can geo-reference a graphic to a map in a number of ways. Microsoft has
    a program called MapCruncher that works well. In this case, you'll need a Windows
    machine and the resulting graphic can only be used for noncommercial purposes.
    MetaCarta also has a web tool called Map Rectifier.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式将图形与地图进行地理参照。微软有一个名为MapCruncher的程序，效果很好。在这种情况下，你需要一台Windows机器，并且生成的图形只能用于非商业用途。MetaCarta还有一个名为Map
    Rectifier的Web工具。
- en: For this project, I'll be using a web application called Map Warper, which can
    be found at [http://warper.geothings.net/](http://warper.geothings.net/). Map
    Warper was built by Tim Waters and is open source and meant to free you from worries
    over how you can use the end result. You will need to create a free account to
    store your map images. Once you do, click the **Add Map** link to start a new
    map.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我将使用一个名为Map Warper的Web应用程序，可以在[http://warper.geothings.net/](http://warper.geothings.net/)找到。Map
    Warper是由Tim Waters开发的，是开源的，旨在让你摆脱对如何使用最终结果的担忧。你需要创建一个免费账户来存储你的地图图像。一旦你创建了账户，点击**添加地图**链接开始创建新地图。
- en: After you provide the name and other metadata to the map, you include a graphic.
    Browse your hard drive for the image you want to use. You can find the Central
    Park graphic that I'm using in this example at [http://mapscripting.com/image-overlay/](http://mapscripting.com/image-overlay/).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在你为地图提供名称和其他元数据后，你可以包含一个图形。浏览你的硬盘以找到你想要使用的图像。你可以在本例中使用的中央公园图形在[http://mapscripting.com/image-overlay/](http://mapscripting.com/image-overlay/)找到。
- en: Click the **Rectify** tab and you'll see your image on the left and a map on
    the right (see [Figure 4-14](ch04s10.html#map_warper_interface "Figure 4-14. Map
    Warper interface")). Move and zoom the map provided until you can see Central
    Park or the area you are geo-referencing. Now you want to add *control points*
    wherever you can identify a spot in the left graphic whose coordinates you can
    determine in the map on the right.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Map Warper interface](httpatomoreillycomsourcenostarchimages672013.png.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: Figure 4-14. Map Warper interface
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: For example, I chose my first point at Columbus Circle in the lower left of
    the Central Park graphic. Once I can see Columbus Circle on both screens, I click
    the marker button (see the circle in [Figure 4-14](ch04s10.html#map_warper_interface
    "Figure 4-14. Map Warper interface")) and the spot on the left. Then I click the
    same spot on the right side. Finally, I click the **Add Control Point** button
    and the marker changes so the number 1 appears inside it, as shown in [Figure 4-15](ch04s10.html#first_control_point_for_geo-referencing
    "Figure 4-15. First control point for geo-referencing").
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![First control point for geo-referencing](httpatomoreillycomsourcenostarchimages672015.png.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: Figure 4-15. First control point for geo-referencing
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: To find additional points that are off the screen, remember to switch from the
    marker to the hand, which will allow you to move the image again. You'll need
    to do the same thing with the map on the right. Continue this process until you
    have a handful of points. Map Warper suggests at least three points, but I've
    found it often takes more.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The Central Park example is easier than some, as New York City has a nice set
    of grid streets to use as references. [Figure 4-16](ch04s10.html#more_control_points_produces_a_better_re
    "Figure 4-16. More control points produces a better rectified map") shows the
    seven points I chose for this example. When you are finished adding control points,
    scroll to the bottom and click **Warp Image**.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![More control points produces a better rectified map](httpatomoreillycomsourcenostarchimages672017.png.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: Figure 4-16. More control points produces a better rectified map
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The system will whirl and whiz for a bit. When it responds that the map has
    been rectified, you can scroll back to the top and click the **Preview Rectified**
    tab. A map with your image warped and overlaid on top will appear, as shown in
    [Figure 4-17](ch04s10.html#preview_of_geo-referenced_central_park_m "Figure 4-17. Preview
    of geo-referenced Central Park map"). You can move the slider at the bottom to
    change your image's opacity. Moving the marker all the way to the right makes
    the image completely opaque, meaning it completely covers the original map.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![Preview of geo-referenced Central Park map](httpatomoreillycomsourcenostarchimages672019.png.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: Figure 4-17. Preview of geo-referenced Central Park map
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Move the slider back and forth to determine how well your image matches the
    source map. If you aren't satisfied with the results, click the **Rectify** tab
    and add a few more points.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 拖动滑块来确定你的图像与源地图的匹配程度。如果你对结果不满意，点击**Rectify**标签并添加几个更多点。
- en: Apply Warped Map
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用扭曲地图
- en: When you're happy with the result of your warped image, click the **Export**
    link to download the image to use it in your own project. You'll want to get the
    PNG-formatted version. [Figure 4-18](ch04s10.html#central_park_image_comma_warped_from_geo
    "Figure 4-18. Central Park image, warped from geo-referencing") shows how different
    my Central Park graphic is now that it has been geo-referenced.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对扭曲图像的结果满意时，点击**Export**链接下载图像以用于你自己的项目。你想要的是PNG格式的版本。[图4-18](ch04s10.html#central_park_image_comma_warped_from_geo
    "图4-18. 从地理参考扭曲的中央公园图像")显示了经过地理参考后我的中央公园图形现在看起来有多不同。
- en: '![Central Park image, warped from geo-referencing](httpatomoreillycomsourcenostarchimages672021.png.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![从地理参考扭曲的中央公园图像](httpatomoreillycomsourcenostarchimages672021.png.jpg)'
- en: Figure 4-18. Central Park image, warped from geo-referencing
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-18. 从地理参考扭曲的中央公园图像
- en: 'In order to overlay the warped image on your map using Mapstraction, you need
    to know the boundaries of the image rectangle. To find this information within
    Map Warper, click the **Activity** tab, where you''ll see a table showing the
    timeline of your geo-referencing session. The topmost item is likely Map Successfully
    Rectified. Click the **Further Details** link for that row and you''ll see more
    details, including a box with a list of four decimal numbers. Highlight and copy
    these, which should already be in order: west, north, east, and south.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Mapstraction在地图上叠加扭曲的图像，你需要知道图像矩形的边界。要在Map Warper中找到这些信息，请点击**Activity**标签，在那里你会看到一个显示地理参考会话时间线的表格。最上面的条目可能是Map
    Successfully Rectified。点击该行的**Further Details**链接，你会看到更多详细信息，包括一个包含四个十进制数字的框。突出显示并复制这些数字，它们应该已经按顺序排列：西、北、东、南。
- en: 'Now you can add the overlay code to your Mapstraction map:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以将叠加代码添加到你的Mapstraction地图中：
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In order to add our warped image to the map, we need to give it an identifier
    ❶. We let Mapstraction know the path to the warped image ❷ (here, I've assumed
    the image is in the same directory as the HTML file). Then, we give an opacity
    percentage ❸ between 0 (invisible) and 100 (hidden—no map can be seen under the
    image). Finally, we add the four numbers from Map Warper ❹ that describe the geographic
    box where the image will reside.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的扭曲图像添加到地图中，我们需要给它一个标识符 ❶。我们让Mapstraction知道扭曲图像的路径 ❷（这里，我假设图像与HTML文件在同一个目录中）。然后，我们给出一个介于0（不可见）和100（隐藏——图像下无法看到地图）之间的不透明度百分比
    ❸。最后，我们添加Map Warper ❹中的四个数字，这些数字描述了图像将驻留的地理框。
- en: '[Figure 4-19](ch04s10.html#central_park_geo-referenced_image_overla "Figure 4-19. Central
    Park geo-referenced image overlay on a Google Map") shows the finished map, with
    the Central Park graphic completely obscuring the Google Map under it.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-19](ch04s10.html#central_park_geo-referenced_image_overla "图4-19. 在谷歌地图上叠加的中央公园地理参考图像")显示了完成的地图，中央公园的图形完全遮挡了其下的谷歌地图。'
- en: '![Central Park geo-referenced image overlay on a Google Map](httpatomoreillycomsourcenostarchimages672023.png.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![在谷歌地图上叠加的中央公园地理参考图像](httpatomoreillycomsourcenostarchimages672023.png.jpg)'
- en: Figure 4-19. Central Park geo-referenced image overlay on a Google Map
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-19. 在谷歌地图上叠加的中央公园地理参考图像
- en: You can use your own map imagery over larger areas as well. Storing an entire
    city or more of data in a single image won't work very well, however. Instead,
    see the next project, which shows how to create your own imagery to display a
    little bit at a time.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在更大的区域内使用你自己的地图图像。然而，将整个城市或更多的数据存储在单个图像中效果不会很好。相反，请看下一个项目，它展示了如何一次显示一点来创建自己的图像。
- en: '#26: Use Custom Tiles'
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#26: 使用自定义瓦片'
- en: Most providers allow you to choose from a handful of imagery types for your
    maps. You can show satellite view, road maps, or a hybrid version. You're not
    the cookie-cutter type though, are you? You like the glitz and glamour of choosing
    your own shade of green for parks or your own thickness for roads. To do this,
    you'll need custom tiles. And what better place for your glitz and glamour than
    the Las Vegas strip?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数提供商允许你为你的地图选择几种图像类型。你可以显示卫星视图、道路地图或混合版本。但你不是那种千篇一律的类型，对吧？你喜欢选择自己公园的绿色或自己道路的厚度。为此，你需要自定义瓦片。而且，哪里比拉斯维加斯大道更适合你的光彩和华丽呢？
- en: To create Vegas tiles, we'll need the data about streets and other features.
    Although mapping providers are liberal in what they allow you to do with their
    APIs, most hold the underlying data like a poker player does his or her cards.
    One that makes its data widely available is OpenStreetMap, the free editable map
    of the world. Of course, distributing the details of every street on earth means
    the file is pretty big, so region-specific downloads are also available. In this
    project, for example, we'll just use the data for Nevada, the state where Las
    Vegas is located.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: To create the tiles, we'll plug the data into an open source program called
    Mapnik. Because Mapnik can be a bit complicated to install and configure, we'll
    take advantage of another project called Tile Drawer, which provides an Amazon
    EC2 machine image to do much of the technical work. First, let's get a feel for
    how tiles are used by mapping providers.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: How Many Pixels Wide Is the Earth?
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As described in [Chapter 1](ch01.html "Chapter 1. MAPPING BASICS"), a map is
    made up of tiles arranged to appear as one large image. Each tile is 256 pixels
    square and organized as a grid. Most providers reference the grid left to right
    and north to south, beginning in the Arctic Ocean above Alaska. Tiles are referenced
    by their number in the grid, such as `(14, 34)`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The number of tiles required to display the entire earth depends on the zoom
    level. For example, at its most zoomed out, which is zoom level 0 in Mapstraction,
    the earth can be shown on a single tile. Each time you zoom in, it takes four
    tiles to show the detail that was previously displayed on one tile. You can find
    the number of tiles used in each direction by determining 2 to the *zoom level*
    power (2*zoom level*). [Table 4-1](ch04s11.html#tiles_and_pixels_at_each_zoom_level
    "Table 4-1. Tiles and Pixels at Each Zoom Level") shows tile and pixel information
    at each zoom level.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'When a mapping provider loads map tiles, it uses three numbers: the zoom level,
    the number of tiles from the left, and the number of tiles from the top. All of
    these numbers begin at zero, so the upper left of the map at every zoom level
    is `(0, 0)`. The upper right at level 6, for example, is `(16383, 0)`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1. Tiles and Pixels at Each Zoom Level
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '| Zoom level | Tiles wide/tall | Pixels wide/tall |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 256 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2 | 512 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| 2 | 4 | 1,024 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| 3 | 8 | 2,048 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| 4 | 16 | 4,096 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| 5 | 32 | 8,192 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| 6 | 64 | 16,384 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| 7 | 128 | 32,768 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| 8 | 256 | 65,536 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| 9 | 512 | 131,072 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1,024 | 262,144 |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| 11 | 2,048 | 524,288 |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| 12 | 4,096 | 1,048,576 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| 13 | 8,192 | 2,097,152 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '| 14 | 16,384 | 4,194,304 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: '| 15 | 32,768 | 8,388,608 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '| 16 | 65,536 | 16,777,216 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| 17 | 131,072 | 33,554,432 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '| 18 | 262,144 | 67,108,864 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: Thankfully, you don't need to reference the tiles by their grid location. The
    mapping provider does all this for you. Understanding how it works is important
    because you'll need to use this knowledge to create custom tile URLs later in
    this project.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: As for the question at the top of this section—how many pixels wide is the earth?
    It depends on the zoom level, but for most providers, the earth is between 256
    and 67,108,864 pixels wide.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Start a Tile Drawer EC2 Instance
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tile Drawer helps you create your own custom map tiles and runs a tile server
    in the cloud. It runs on top of Amazon EC2, which is an *elastic compute cloud*,
    that is, an expandable web server. Another feature of EC2 is the ability to save
    preconfigured servers, Amazon Machine Images (AMIs), and make them available to
    others. That's what the creators of Tile Drawer have done. Handy!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need an Amazon account (be prepared to provide your email address
    and a few other bits of information) and then sign up for EC2\. Amazon charges
    for this service, but does so for cents per hour, so you''ll be able to try this
    project for less than a dollar. This page will walk you through the signup process:
    [http://aws.amazon.com/ec2/](http://aws.amazon.com/ec2/).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the AWS Management Console from this page. Click the **Launch Instance**
    button. Then search the Community AMIs for the Tile Drawer machine image. Look
    for *tiledrawer*, or find the ID, such as `ami-e1ea0a88`, listed on [http://tiledrawer.com/](http://tiledrawer.com/).
    When you find the Tile Drawer AMI, click the **Select** button.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: On the Instance Details screen, only create one instance, as shown in [Figure 4-20](ch04s11.html#create_a_single_amazon_ec2_tile_drawer_i
    "Figure 4-20. Create a single Amazon EC2 Tile Drawer instance"). Because you'll
    be using a very small area to start, you can get away with a small instance type.
    Click the **Continue** button, and then on the next screen, you mostly leave the
    default settings in place. You'll need to add some user data, however.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Create a single Amazon EC2 Tile Drawer instance](httpatomoreillycomsourcenostarchimages672025.png.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: Figure 4-20. Create a single Amazon EC2 Tile Drawer instance
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Declare User Data for Your Instance
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Tile Drawer server is fairly plug and play. Just a few settings are necessary
    to make it run. As you'll see later, these settings also allow you to fully customize
    your map tiles.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the wizard on [http://tiledrawer.com/](http://tiledrawer.com/)
    to help you create the user data automatically. Or to continue following along
    with this example, paste the following data in the User Data box on the EC2 setup
    page (see [Figure 4-21](ch04s11.html#adding_user_data_to_the_ec2_instance "Figure 4-21. Adding
    user data to the EC2 instance")):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This data has four preferences. First, the style of the map, which uses a CSS-like
    style sheet. We'll stick with the basic look from Tile Drawer for this first example
    and make changes later. Next, we declare a `BoundingBox`, similar to those we've
    used with Mapstraction. The difference here is that longitudes are listed before
    latitudes. The two points we use are still southwest followed by northeast.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The last two items are URLs to files that Tile Drawer will download and use.
    The first is the data itself. We're using the data for Nevada, which is hosted
    by CloudMade. You can find the data you need at [http://downloads.cloudmade.com/](http://downloads.cloudmade.com/).
    Look for files of type *.osm.bz2*. The final URL is the coastline data, which
    is hosted separately.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding user data to the EC2 instance](httpatomoreillycomsourcenostarchimages672027.png.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: Figure 4-21. Adding user data to the EC2 instance
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: With the user data set, click **Continue** again. The next screen will prompt
    you to create a key pair. The key pair enables you to connect to the server's
    backend. This advanced feature may be useful at some point in the future. For
    now, select **Proceed without a Key Pair**, and click **Continue**.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: On the firewall screen, make sure you select the webserver security group. This
    group opens up the appropriate ports for running a web server, which is necessary
    for accessing your tiles from any computer, including your own. Click **Continue**
    and you'll be on the final screen. Take a deep breath and then click **Launch**.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Tile Drawer Does Its Job
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your EC2 instance will not instantly start up. Although it's a virtual computer,
    it still takes a few minutes to boot. Once it is available, creating all the tiles
    will take some additional time. This is a great time for a break!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: But you shouldn't need *too* long of a break. With only one state of data to
    download and a small area to prepare, Tile Drawer should be ready in less than
    15 minutes. From your EC2 dashboard, you should be able to click the **Running
    Instances** link under My Resources. From there, you can see the status of your
    new instance. When the server has booted up, it should switch from yellow and
    pending to green and running.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: When the server is running, click your instance and a description will appear
    in the pane below. Scroll down and locate the Public DNS address, as shown in
    [Figure 4-22](ch04s11.html#instance_details_shows_your_public_dns_a "Figure 4-22. Instance
    details shows your Public DNS address."). This address is the equivalent of a
    domain name for your new virtual server. Enter that address in your web browser
    and you should see a page that says, "It works!"
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '![Instance details shows your Public DNS address.](httpatomoreillycomsourcenostarchimages672029.png.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: Figure 4-22. Instance details shows your Public DNS address.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add */status.php* to the end of your address to get Tile Drawer''s status.
    Tile Drawer goes through to create tiles: Getting Started, Downloading Source,
    Extracting Data, Creating Tables, Importing Coastline, Downloading Stylesheet,
    and Creating TileCache. As it completes each step, it will become grayed out,
    as shown in [Figure 4-23](ch04s11.html#tile_drawer_apostrophy_s_status_updates
    "Figure 4-23. Tile Drawer''s status updates as each section finishes."). When
    Tile Dawer is done, you can click the link or go to your address followed by */preview.php*.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![Tile Drawer''s status updates as each section finishes.](httpatomoreillycomsourcenostarchimages672031.png.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: Figure 4-23. Tile Drawer's status updates as each section finishes.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: You'll see a quick preview of your new tiles on the Tile Drawer server. You
    can double-click to zoom in. If everything looks good, the time has come to put
    those tiles on a Mapstraction map.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Add Tile Overlays to Your Map
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of including your tiles in Mapstraction is as easy as a single line
    of code. The hard work is behind you with setting up the tile server—and also
    ahead of you in creating the styles, which can be a tedious.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new basic map using the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]*`yourserver`*[PRE26]'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Here we have created a map centered on the Las Vegas strip. Then, in the line
    in bold, we tell Mapstraction where to find our tiles. Our URL contains placeholders
    for zoom level ❶ and the tile grid coordinates. These values, `{Z}`, `{X}`, and
    `{Y}`, are filled in with actual numbers. You can see an example tile by going
    to *yourserver.amazonaws.com/tilecache/1.0.0/osm/13/1475/3213.png*. Be sure to
    replace *yourserver* with the Public DNS address of your EC2 instance.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'The second argument that we pass to Mapstraction''s tile layer function is
    an opacity. Like in [#25: Overlay an Image on a Map](ch04s10.html "#25: Overlay
    an Image on a Map") in [#25: Overlay an Image on a Map](ch04s10.html "#25: Overlay
    an Image on a Map"), we can make our tiles semitransparent so we can still see
    some of the provider imagery underneath. Here I made our tiles completely opaque
    ❷ by choosing a value of one. A number between zero and one sets the percentage.
    For example, 0.6 would be 60 percent opaque.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Save your map and load it in a browser. You should now see your custom Las Vegas
    tiles instead of the Google imagery, like in [Figure 4-24](ch04s11.html#custom_tiles_using_tile_drawer_apostroph
    "Figure 4-24. Custom tiles using Tile Drawer's "scratch" style sheet"). You may
    catch a glimpse of the default look before your tiles load. That's because the
    custom tiles are being placed on top of Google, so both sets still need to load.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom tiles using Tile Drawer''s "scratch" style sheet](httpatomoreillycomsourcenostarchimages672033.png.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: Figure 4-24. Custom tiles using Tile Drawer's "scratch" style sheet
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Create Your Own Tile Styles
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are familiar with CSS for styling web pages, you will likely feel comfortable
    with the way Tile Drawer applies colors and other styles to maps. It uses Cascadenik
    to convert into the file format necessary to work with the Mapnik tile generator.
    Earlier in this project, we used a basic example provided by Tile Drawer. Now
    we'll try changing a few of the colors and road widths.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you'll need is to copy [http://tiledrawer.com/mapscratch.mml](http://tiledrawer.com/mapscratch.mml)
    to your own server. Or you can use the version I have edited for this section
    at [http://mapscripting.com/examples/tiledrawer/mapscratch-edits.mml](http://mapscripting.com/examples/tiledrawer/mapscratch-edits.mml).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Vegas is famous for its neon lights, let''s aim to make the roads pop
    out from the map. To do this, we''ll use bright colors and a dark background.
    Find the line that begins with `#land` and change it, using this styling data:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This data changes the land, which is essentially the background color, from
    a very light color to nearly black. Black is very Vegas, especially when we include
    the bright colors. For these next changes, you''ll need to use the styles that
    begin with the `#lines`. Be sure your code matches these settings:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Cascadenik style sheets use OpenStreetMap tags inside the square brackets to
    determine which elements you want to style. In all these examples, we're styling
    highways, a generic term for any road. In the first set, we apply the styles only
    to motorways ❶ and motorway "links" (such as off-ramps). Since everything is bigger
    and brighter in Vegas, we make the motorways wider ❷ and then color them a bright
    red ❸.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: In the next two sections, we set the larger streets to be yellow ❹. Residential
    and other small streets are set to blue ❺. As the streets get smaller, so do their
    widths on the map. Seeing as we're doing this Vegas-style, however, they're still
    larger than the styles we're editing.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do some powerful things with these styles to make your maps look unlike
    any imagery available. As one example of how specific you can get with styles,
    try adding these lines to your style sheet:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At first glance, this code is similar to some we've already done. Pay attention
    to the bolded section; it tells the tile server to only apply this style when
    the zoom level is 13\. At all other zoom levels, our other styles will take precedence.
    But when our map is at level 13, the motorways will be orange instead of red.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: I didn't reset the line width, as I did in other sections, which means the line
    width already set for motorways will remain the same for zoom level 13\. Only
    the color will change. In addition to `=`, you can use `>`, `>=`, `<`, and `<=`
    to style at certain zoom levels.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'With a few styles changed, let''s see Tile Drawer in action. Create a new EC2
    instance (remember to terminate those not in use to avoid the hourly charges)
    with the following data:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you've made changes that I didn't include here, good for you! In that case,
    replace the URL in bold with the address of the map style sheet on your own server.
    To get a feel for how these few changes alters the look of our tiles, see [Figure 4-25](ch04s11.html#big_roads_and_bright_colors_style_the_la
    "Figure 4-25. Big roads and bright colors style the Las Vegas map").
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您做了我没有在这里包括的更改，那真是太好了！在这种情况下，用您自己的服务器上地图样式表的地址替换粗体中的URL。为了了解这些少数更改如何改变我们瓦片的外观，请参阅[图4-25](ch04s11.html#big_roads_and_bright_colors_style_the_la
    "图4-25. 大路和鲜艳的色彩风格化的拉斯维加斯地图")。
- en: '![Big roads and bright colors style the Las Vegas map](httpatomoreillycomsourcenostarchimages672035.png.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![大路和鲜艳的色彩风格化的拉斯维加斯地图](httpatomoreillycomsourcenostarchimages672035.png.jpg)'
- en: Figure 4-25. Big roads and bright colors style the Las Vegas map
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-25. 大路和鲜艳的色彩风格化的拉斯维加斯地图
- en: After a short wait as your virtual server boots and Tile Drawer does its work,
    your newly styled Las Vegas tiles should be ready. Update the address of your
    server in the Mapstraction file you used to create a tile layer. Load it up and
    you should see the bright roads of Vegas popping out from your new map.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的虚拟服务器启动并Tile Drawer完成其工作后稍作等待，您新设计的拉斯维加斯瓷砖应该就绪了。更新您用于创建瓦片层的Mapstraction文件中服务器的地址。加载它，您应该会看到从您的新地图中跳出的明亮的拉斯维加斯道路。
