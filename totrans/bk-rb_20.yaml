- en: Chapter 20. Dynamic Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the past 19 chapters, I’ve covered a huge range of features of the Ruby language.
    One thing I haven’t covered in any detail is Ruby’s dynamic programming capability.
  prefs: []
  type: TYPE_NORMAL
- en: If you have used only a nondynamic language (say one of the languages from the
    C or Pascal family), it is likely that dynamism in programming may take a little
    getting used to. Before going any further, I’ll clarify what I mean by a *dynamic*
    language. The definition is, in fact, a bit vague, and not all languages that
    lay claim to being dynamic share all the same features. In a general sense, however,
    a language that provides some means by which programs may be modified at runtime
    can be considered to be dynamic. Another quality of a dynamic language is its
    ability to change the type of a given variable—something you have done countless
    times in the examples throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: A further distinction may also be made between a *dynamically typed* language
    such as Ruby and a *statically typed* language (one in which the type of a variable
    is predeclared and fixed) such as C, Java, or Pascal. In this chapter, I will
    concentrate on the self-modifying capabilities of Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In formal computer science, the term *dynamic programming* is sometimes used
    to describe an analytic approach to solving complex problems. That is not the
    sense in which the term is used in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Self-Modifying Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most compiled languages and many interpreted languages, writing programs
    and running programs are two completely distinct operations: The code you write
    is fixed, and it is beyond any possibility of further alteration by the time the
    program is run.'
  prefs: []
  type: TYPE_NORMAL
- en: That is not the case with Ruby. A program—by which I mean *the Ruby code itself*—can
    be modified while the program is running. It is even possible to enter new Ruby
    code at runtime and execute the new code without restarting the program.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to treat data as executable code is called *metaprogramming*. You’ve
    been doing metaprogramming, albeit of a rather simple sort, throughout this book.
    Every time you embed an expression inside a double-quoted string, you are doing
    metaprogramming. After all, the embedded expression is not really program code—it
    is a string—and yet Ruby clearly has to “turn it into” program code in order to
    be able to evaluate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time you will probably embed rather simple bits of code between
    the `#{` and `}` delimiters in double-quoted strings. Often you might embed variable
    names, say, or mathematical expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*str_eval.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But you aren’t limited to such simple expressions. You could, if you wanted,
    embed just about anything into a double-quoted string. You could, in fact, write
    an entire program in a string. You don’t even need to display the end result using
    `print` or `puts`. Just placing a double-quoted string into your program will
    cause Ruby to evaluate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the previous code fragment is a string, the Ruby interpreter will
    evaluate its embedded code and display the result, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Interesting as this may be, writing a whole program inside a string would probably
    be a pretty pointless endeavor. However, there are other occasions when this,
    and similar, features can be used much more productively. For example, you might
    use metaprogramming to explore artificial intelligence and “machine learning.”
    In fact, any application that would benefit from having a program’s behavior modified
    in response to user interaction is a prime candidate for metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dynamic (metaprogramming) features are ubiquitous in Ruby. Consider, for example,
    attribute accessors: Passing a symbol (such as `:aValue`) to the `attr_accessor`
    method causes two methods (`aValue` and `aValue=`) to be created.'
  prefs: []
  type: TYPE_NORMAL
- en: eval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `eval` method provides a simple way of evaluating a Ruby expression in
    a string. At first sight, `eval` may appear to do the same job as the `#{ }` delimiters
    in a double-quoted string. These two lines of code produce identical results:'
  prefs: []
  type: TYPE_NORMAL
- en: '*eval.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, however, the results may not be what you are expecting. Look at
    the following, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '*eval_string.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s suppose you enter `2 * 4`, and this is assigned to `exp`. When you evaluate
    `exp` with `eval`, the result is 8, but when you evaluate `exp` in a double-quoted
    string, the result is `"2*4"`. This is because anything read in by `gets()` is
    a string and `"#{exp}"` evaluates it *as a string* and not as an expression, whereas
    `eval( exp )` evaluates a string *as an expression*. To force evaluation inside
    a string, you could place `eval` in the string (though that, admittedly, might
    defeat the object of the exercise):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example. Try it, and follow the instructions when prompted:'
  prefs: []
  type: TYPE_NORMAL
- en: '*eval2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `eval` method can evaluate strings spanning many lines, making it possible
    to execute an entire program embedded in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '*eval3.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Look carefully at the previous code. It contains just one executable expression,
    which is a call to the `eval()` method. Everything else, which at first sight
    *looks* like code, is in fact a single-quoted string that is passed as an argument
    to `eval()`. The `eval()` method “unpacks” the contents of the string and turns
    it into real Ruby code that is then executed. This is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With all this `eval` cleverness, let’s now see how easy it is to write a program
    that can itself write programs. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*eval4.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This may not look like much, and yet this little program lets you both create
    and execute Ruby code from a prompt. Try it. Run the program, and enter the two
    methods shown here one line at a time (but *don’t hit*q *to quit yet*—you’ll be
    writing some more code in a moment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you have to enter each whole method on a single line since the program
    evaluates every line as it is entered. I’ll explain how to get around that limitation
    later. Thanks to `eval`, each method is turned into real, workable Ruby code.
    You can prove this by entering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you press enter after each line in the previous code, the expressions
    are evaluated, and they call the two methods, `x()` and y`()`, which you wrote
    a moment ago, resulting in this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That’s not bad for just five lines of code!
  prefs: []
  type: TYPE_NORMAL
- en: Special Types of eval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some variations on the `eval` theme in the form of the methods named
    `instance_eval`, `module_eval`, and `class_eval`. The `instance_eval` method can
    be called from a specific object, and it provides access to the instance variables
    of that object. It can be called either with a block or with a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '*instance_eval.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `eval` method, on the other hand, cannot be called from an object in this
    way because it is a private method of Object (whereas `instance_eval` is public):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, you could explicitly change the visibility of `eval` by sending its
    name (the symbol `:eval`) to the `public` method. Here I am adding `eval` as a
    public method of the Object class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, bearing in mind that when you write “free-standing” code you are actually
    working within the scope of Object, simply entering the following code (without
    the Object class “wrapper”) would have the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use `eval` as a method of the `ob` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strictly speaking, `eval` is a method of the `Kernel` module that is mixed into
    the Object class. In fact, it is the `Kernel` module that provides most of the
    functions available as methods of Object.
  prefs: []
  type: TYPE_NORMAL
- en: The modification of class definitions at runtime is sometimes called *monkey
    patching*. This may have a part to play in certain highly specialized types of
    programming, but as a general principle, gratuitous messing about with standard
    Ruby classes is definitely *not* recommended. Changing the visibility of methods
    and adding new behavior to base classes are excellent ways of creating inscrutable
    code dependencies (in which, for example, your own programs work because you happen
    to know how you’ve changed a base class, but your colleagues’ programs don’t work
    because they don’t know how the classes have been changed).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `module_eval` and `class_eval` methods operate on modules and classes rather
    than on objects. For example, the code shown next adds the `xyz` method to the
    `X` module (here `xyz` is defined in a block and added as an instance method of
    the receiver by `define_method`, which is a method of the Module class), and it
    adds the `abc` method to the Y class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*module_eval.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When accessing class and module methods, you can use the scope resolution operator
    `::` or a single dot. The scope resolution operator is obligatory when accessing
    constants and optional when accessing methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now an object that is an instance of Y will have access to both the `abc`
    method of the Y class and the `xyz` method of the `X` module that has been mixed
    into the Y class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In spite of their names, `module_eval` and `class_eval` are functionally identical,
    and each can be used with either a module or a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add methods into Ruby’s standard classes in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Adding Variables and Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also use the `module_eval` and `class_eval` methods to retrieve the
    values of class variables (but bear in mind that the more you do this, the more
    your code becomes dependent on the implementation details of a class, thereby
    compromising encapsulation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, `class_eval` can evaluate expressions of arbitrary complexity. You
    could, for example, use it to add new methods to a class by evaluating a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Returning to the earlier example of adding and retrieving class variables from
    *outside* a class (using `class_eval`), it turns out that there are also methods
    designed to do this from *inside* a class. The methods are called `class_variable_get`
    (this takes a symbol argument representing the variable name, and it returns the
    variable’s value) and `class_variable_set` (this takes a symbol argument representing
    a variable name and a second argument that is the value to be assigned to the
    variable).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of these methods in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '*classvar_getset.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To obtain a list of class variable names as an array of strings, use the `class_variables`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add instance variables to classes and objects after they have
    been created using `instance_variable_set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*dynamic.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'By combining this with the ability to add methods, the bold (or maybe reckless?)
    programmer can completely alter the internals of a class “from the outside.” Here
    I have implemented this in the form of a method called `addMethod` in class X,
    which uses the `send` method to create the new method `m` using `define_method`
    with the method body, defined by `&block`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `send` method invokes the method identified by the first argument (a symbol),
    passing to it any arguments specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, an X object can call `addMethod` to insert a new method into the X class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this method is called from a specific instance of the class (here
    `ob`), it affects the class itself, so the newly defined method will also be available
    to any subsequent instances (here `ob2`) created from the X class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t care about the encapsulation of data in your objects (my definition
    of *encapsulation* assumes the hiding of internal data, though some people have
    less rigorous definitions), you can also retrieve the value of instance variables
    using the `instance_variable_get` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can similarly *set* and *get* constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `const_get` returns the value of a constant, you could use this method
    to get the value of a class name, which is itself a constant, and then append
    the `new` method to create a new object from that class. This could even give
    you a way of creating objects at runtime by prompting the user to enter class
    names and method names. Try this by running this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '*dynamic2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Creating Classes at Runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, you have modified classes and created new objects from existing classes.
    But how would you go about creating a completely new class at runtime? Well, just
    as you can use `const_get` to access an existing class, you can use `const_set`
    to create a new class. Here’s an example of how to prompt the user for the name
    of a new class before creating that class, adding a method (`myname`) to it, creating
    an instance (`x`) of that class, and calling its `myname` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*create_class.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If you run this program and enter `Xxx` when prompted for the name of a new
    class, the code will use `const_set` to create the constant `Xxx` as a new class;
    then `module_eval` is called on this class, and `define_method` is used to create
    a method whose name matches the symbol `:myname` and whose contents are given
    by the code in the curly brace-delimited block; here this happens to be a single
    `puts` statement that displays the class name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this code, and enter `Xxx` when prompted. An object, `x`, is created from
    the `Xxx` class; its `myname()` method is called; and, sure enough, it displays
    the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `eval` method may take an optional “binding” argument that, if provided,
    causes the evaluation to be done within a specific scope or “context.” It probably
    won’t come as any surprise to discover that, in Ruby, a binding is an object that
    is an instance of the Binding class. You can return a binding using the `binding`
    method. The documentation of `eval` in the Ruby class library provides this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*binding.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple as it may look, this example may take a bit of thinking about in order
    to understand what’s going on. Essentially, the first call to `puts` evaluates
    `str` in the current scope where it has a “hello” value. The second call to `puts`
    evaluates `str` in the scope of the `getBinding()` method where it has a “bye”
    value. In this example, `str` happens to be passed as an argument, but this is
    not a requirement. In the rewritten version here, I’ve made `str` a local variable
    inside `getBinding()`. The effect is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '*binding2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that `binding` is a private method of Kernel. The `getBinding` method is
    able to call `binding` within the current context and return the current value
    of `str`. At the time of the first call to `eval`, the context is the *main* object,
    and the value of the local variable, `str`, is used; in the second call, the context
    moves inside the `getBinding` method, and the local value of `str` is now that
    of the `str` argument or variable within that method. The context may also be
    defined by a class. In *binding3.rb*, you can see that the values of the instance
    variable `@mystr` varies according to the class. So, what happens when you `eval`
    those variables with different bindings?
  prefs: []
  type: TYPE_NORMAL
- en: '*binding3.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In Ruby 1.8, you see the following output, showing that the bindings for both
    the instance variable, `@mystr`, and the class variable, `@@x`, are applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'But in Ruby 1.9, only the binding of the instance variable is applied; the
    class variable in the current (*main*) context is always used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Does this mean class variables in given bindings are ignored? Let’s try an
    experiment. Just comment out the assignment to `@@x` in the main context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the program again. This time, Ruby 1.9 displays this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, Ruby 1.9 *does* evaluate class variables within a binding. However,
    it gives preference to class variables, if they exist, in the *current* binding.
    You need to be aware of this difference if you are migrating Ruby 1.8 programs
    to Ruby 1.9 or newer.
  prefs: []
  type: TYPE_NORMAL
- en: send
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the `send` method to call a method with the same name as the specified
    symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*send1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the `send` method is documented as requiring a symbol argument, you
    can also use a string argument. Or, for consistency, you could use `to_sym` to
    transform the string to a symbol and then call the method with the same name as
    that symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a working example of using `send` to execute a named method entered
    at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '*send2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Removing Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall you created a new method earlier (*dynamic.rb*) using `send` to call
    `define_method` and passed to it the name, `m`, of the method to be created plus
    a block, `&block`, containing the code of the new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*dynamic.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to creating new methods, sometimes you may want to remove existing
    methods. You can do this using `remove_method` within the scope of a given class.
    This removes the method specified by a symbol from a specific class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*rem_methods1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If a method with the same name is defined for an ancestor of that class, the
    ancestor class method is *not* removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '*rem_methods2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `somemethod` is removed from the Z class, so when `zob.somemethod`
    is subsequently called on a Z object, Ruby executes the first method with that
    name in the *ancestor* classes of Z. Here, Y is the ancestor of Z, so its `somemethod`
    method is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `undef_method`, by contrast, prevents the specified class from responding
    to a method call even if a method with the same name is defined in one of its
    ancestors. The following example uses the same Y and Z classes used in the previous
    example. The only difference is that this time `somemethod` is *undefined* using
    `undef_method` rather than merely *removed* from the current class using `remove_method`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*undef_methods.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Handling Missing Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Ruby tries to execute an undefined method (or, in object-oriented terms,
    when an object is sent a message that it cannot handle), the error causes the
    program to exit. You may prefer your program to recover from such an error. You
    can do this by writing a method named `method_missing`, with an argument to which
    the missing method’s name is assigned. This will execute when a nonexistent method
    is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '*nomethod1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `method_missing` method can also take a list of incoming arguments (`*args`)
    after the missing method name:'
  prefs: []
  type: TYPE_NORMAL
- en: '*nomethod2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming the previous `method_missing` method were written into a class called
    X, you could now attempt to call any method on an X object, whether or not that
    method exists and whether or not it is passed any arguments. If, for example,
    you were to attempt to call a nonexistent method called `aaa`, first with no arguments
    and then with three integer arguments, the `method_missing` method would respond
    to the invalid method call and display an appropriate error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `method_missing` method could even create an undefined method dynamically
    so that a call to a nonexistent method automatically brings that method into existence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the `lambda` method turns a block (here the code between curly
    brackets) into a Proc object. This is explained in [Chapter 10](ch10.html "Chapter 10. Blocks,
    Procs, and Lambdas"). The code is then able to pass this object as an argument
    to `send`, defining a new method with the same name as the `methodname` argument
    passed to `method_missing`. The effect is that when an unknown method is called
    on a Z object, a method with that name is created. Run the *nomethod2.rb* program,
    which contains this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Writing Programs at Runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let’s return to the program you looked at earlier: *eval4.rb*. This,
    you may recall, prompts the user to enter strings to define code at runtime, evaluates
    those strings, and creates new runnable methods from them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One drawback of that program was that it insists that each method be entered
    on a single line. It is, in fact, pretty simple to write a program that allows
    the user to enter methods spanning many lines. Here, for example, is a program
    that evaluates all the code entered up until a blank line is entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '*writeprog.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can try this by entering whole methods followed by blank lines, like this
    (just enter the code, of course, not the comments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: After each line entered, a prompt (`?-`) appears except when the program is
    in the process of evaluating code, in which case it displays “Evaluating,” or
    when it shows the result of an evaluation, such as `olleh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you enter the text exactly as indicated earlier, this is what you should
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This program is still very simple. It doesn’t even have any basic error recovery
    let alone fancy stuff such as file saving and loading. Even so, this small example
    demonstrates just how easy it is to write self-modifying programs in Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the techniques outlined in this chapter, you could create anything from
    a natural-language parser that can be taught rules of grammar to an adventure
    game that can learn new puzzles.
  prefs: []
  type: TYPE_NORMAL
- en: In this book I’ve covered a lot of ground—from “hello world” to dynamic programming.
    You’ve explored most of the important and powerful features of the Ruby language.
    The rest is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the adventure really begins.
  prefs: []
  type: TYPE_NORMAL
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: There may be times when you want to make sure that your Ruby objects cannot
    be modified in the ways described in this chapter. Here you will learn how to
    do this.
  prefs: []
  type: TYPE_NORMAL
- en: Freezing Objects
  prefs: []
  type: TYPE_NORMAL
- en: With all these ways of modifying objects at your disposal, you may be concerned
    that objects are at risk of being modified unintentionally. In fact, you can specifically
    fix the state of an object by “freezing” it using the `freeze` method, which you
    first encountered in [Chapter 12](ch12.html "Chapter 12. Modules and Mixins").
    Once frozen, the data contained by an object cannot be modified, and if an attempt
    is made to do so, a TypeError exception will be raised. Take care when freezing
    an object, however, because, once frozen, it cannot be “unfrozen.”
  prefs: []
  type: TYPE_NORMAL
- en: '*freeze.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specifically check whether an object is frozen using the `frozen?`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Be aware that although the data of a frozen object cannot be modified, the
    class from which it is defined can be modified. Let’s suppose you have a class
    X that contains the method `addMethod`, which can create new methods with the
    name given by the symbol `m`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*cant_freeze.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you have an object, `ob`, created from the M class, then it is perfectly
    legitimate to call `addMethod` to add a new method to class M:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to prevent a frozen object from modifying its class, you could,
    of course, test its state using the `frozen?` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also freeze the class itself (remember, a class is also an object):'
  prefs: []
  type: TYPE_NORMAL
- en: '*freeze_class.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
