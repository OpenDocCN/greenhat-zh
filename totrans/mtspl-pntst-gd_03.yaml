- en: Chapter 3. Intelligence Gathering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Intelligence gathering follows the pre-engagement activities as the second step
    in a penetration test. Your goals during intelligence gathering should be to gain
    accurate information about your targets without revealing your presence or your
    intentions, to learn how the organization operates, and to determine the best
    route of entry. If you don’t do a thorough job of intelligence gathering, you
    may miss vulnerable systems or viable attack vectors. It takes time and patience
    to sort through web pages, perform Google hacking, and map systems thoroughly
    in an attempt to understand the infrastructure of a particular target. Intelligence
    gathering requires careful planning, research, and, most importantly, the ability
    to think like an attacker. At this step, you will attempt to collect as much information
    about the target environment as possible. This can be an expansive amount of information,
    and even the most trivial data gathered during this stage can prove useful later
    on, so pay attention.
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin intelligence gathering, consider how you will record everything
    you do and the results you achieve. You must remember and record as many details
    of your penetration test as possible. Most security professionals quickly learn
    that detailed notes can mean the difference between a successful and a failed
    penetration test. Just as a scientist needs to achieve reproducible results, other
    experienced penetration testers should be able to reproduce your work using your
    documentation alone.
  prefs: []
  type: TYPE_NORMAL
- en: Intelligence gathering is arguably the most important aspect of a penetration
    test, because it provides the foundation for all work that follows. When recording
    your work, be methodical, accurate, and precise. And, as stated earlier, be sure
    that before you fire off your exploits, you have learned all that you can about
    your target.
  prefs: []
  type: TYPE_NORMAL
- en: The excitement for most people comes in exploiting systems and getting to root,
    but you need to learn to walk before you can run.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you follow the procedures in this chapter, you can actually damage your system
    and your target’s system, so be sure to set up your test environment now. (For
    help, see [Appendix A](part0022.html#configuring_your_target_machines).) Many
    of the examples in these chapters can be destructive and make a target system
    unusable. The activities discussed in this chapter could be considered illegal
    if they are undertaken by someone with bad intentions, so follow the rules and
    don’t be stupid.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Passive Information Gathering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using *passive* and *indirect* information gathering, you can discover information
    about targets without touching their systems. For example, you can use these techniques
    to identify network boundaries, identify the network maintainers, and even learn
    what operating system and web server software is in use on the target network.
  prefs: []
  type: TYPE_NORMAL
- en: '*Open source intelligence (OSINT)* is a form of intelligence collection that
    uses open or readily available information to find, select, and acquire information
    about a target. Several tools make passive information gathering almost painless,
    including complex tools such as Yeti and the humble *whois*. In this section,
    we’ll explore the process of passive information gathering and the tools that
    you might use for this step.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine, for example, an attack against [http://www.secmaniac.net/](http://www.secmaniac.net/).
    Our goal is to determine, as a part of a penetration test, what systems the company
    owns and what systems we can attack. Some systems may not be owned by the company
    and could be considered out of scope and unavailable for attack.
  prefs: []
  type: TYPE_NORMAL
- en: whois Lookups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s begin by using Back|Track’s *whois* lookup to find the names of [secmaniac.net](http://secmaniac.net)’s
    domain servers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We learn at ![](../images/00002.gif) that the Domain Name System (DNS) servers
    are hosted by *DOMAINCONTROL.COM*, so this is a good example of systems that would
    not be included in a penetration test because we would have no authority to attack
    them. In most large organizations, the DNS servers are housed within the company
    and are viable attack vectors. Zone transfers and similar DNS attacks can often
    be used to learn more about a network from both the inside and outside. In this
    scenario, because *DOMAINCONTROL.COM* is not owned by [secmaniac.net](http://secmaniac.net),
    we should not attack these systems and will instead move on to a different attack
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: Netcraft
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Netcraft ([http://searchdns.netcraft.com/](http://searchdns.netcraft.com/))
    is a web-based tool that we can use to find the IP address of a server hosting
    a particular website, as shown in [Figure 3-1](part0007.html#use_netcraft_to_find_the_ip_address_of_t).
  prefs: []
  type: TYPE_NORMAL
- en: '![Use Netcraft to find the IP address of the server hosting a particular website.](../images/00003.jpeg)Figure 3-1. Use
    Netcraft to find the IP address of the server hosting a particular website.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having identified [secmaniac.net](http://secmaniac.net)’s IP address as 75.118.185.142,
    we do another *whois* lookup on that IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We see from the *whois* lookup and a quick search that this IP (*WIDEOPENWEST*)
    appears to be a legitimate service provider. While the actual subnet range isn’t
    specifically registered to [secmaniac.net](http://secmaniac.net) or [secmaniac.com](http://secmaniac.com),
    we can tell that this site appears to be hosted inside the author’s home, because
    the IP block appears to be part of a residential range.
  prefs: []
  type: TYPE_NORMAL
- en: NSLookup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get additional server information, we’ll use Back|Track to leverage `nslookup`,
    a tool built into most operating systems, to find information about [secmaniac.net](http://secmaniac.net).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We see in this listing that the mail servers are pointing to *mailstore1.secureserver.net*
    and *smtp.secureserver.net*. Some quick research on these mail servers tells us
    that this website is hosted by a third party, which would not be within the scope
    of our penetration test.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have gathered some valuable information that we might be able
    to use against the target later on. Ultimately, however, we have to resort to
    active information gathering techniques to determine the actual target IP, which
    is 75.118.185.142.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Passive information gathering is an art that is not easily mastered in just
    a few pages of discussion. See the *Penetration Testing Execution Standard (PTES;*
    [http://www.pentest-standard.org/](http://www.pentest-standard.org/)) for a list
    of potential ways to perform additional passive intelligence gathering.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Active Information Gathering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In active information gathering, we interact directly with a system to learn
    more about it. We might, for example, conduct port scans for open ports on the
    target or conduct scans to determine what services are running. Each system or
    running service that we discover gives us another opportunity for exploitation.
    But beware: If you get careless while active information gathering, you might
    be nabbed by an IDS or intrusion prevention system (IPS) — not a good outcome
    for the covert penetration tester.'
  prefs: []
  type: TYPE_NORMAL
- en: Port Scanning with Nmap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having identified the target IP range with passive information gathering as
    well as the [secmaniac.net](http://secmaniac.net) target IP address, we can begin
    to scan for open ports on the target by *port scanning*, a process whereby we
    meticulously connect to ports on the remote host to identify those that are active.
    (Obviously, in a larger enterprise, we would have multiple IP ranges and things
    to attack instead of only one IP.)
  prefs: []
  type: TYPE_NORMAL
- en: '*Nmap* is, by far, the most popular port scanning tool. It integrates with
    Metasploit quite elegantly, storing scan output in a database backend for later
    use. *Nmap* lets you scan hosts to identify the services running on each, any
    of which might offer a way in.'
  prefs: []
  type: TYPE_NORMAL
- en: For this example, let’s leave [secmaniac.net](http://secmaniac.net) behind and
    turn to the virtual machine described in [Appendix A](part0022.html#configuring_your_target_machines),
    with IP address 172.16.32.131\. Before we get started, take a quick look at the
    basic *nmap* syntax by entering **`nmap`** from the command line on your Back|Track
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see immediately that *nmap* has a quite a few options, but you’ll use
    just a few of them for the most part.
  prefs: []
  type: TYPE_NORMAL
- en: One of our preferred *nmap* options is `-sS`. This runs a stealth TCP scan that
    determines whether a specific TCP-based port is open. Another preferred option
    is `-Pn`, which tells *nmap* not to use `ping` to determine whether a system is
    running; instead, it considers all hosts “alive.” If you’re performing Internet-based
    penetration tests, you should use this flag, because most networks don’t allow
    Internet Control Message Protocol (ICMP), which is the protocol that `ping` uses.
    If you’re performing this scan internally, you can probably ignore this flag.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s run a quick *nmap* scan against our Windows XP machine using both
    the `-sS` and `-Pn` flags.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, *nmap* reports a list of open ports, along with a description
    of the associated service for each.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more detail, try using the `-A` flag. This option will attempt advanced
    service enumeration and banner grabbing, which may give you even more details
    about the target system. For example, here’s what we’d see if we were to call
    *nmap* with the `-sS` and `-A` flags, using our same target system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Working with Databases in Metasploit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you’re running a complex penetration test with a lot of targets, keeping
    track of everything can be a challenge. Luckily, Metasploit has you covered with
    expansive support for multiple database systems.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that database support is available for your system, you should first
    decide which database system you want to run. Metasploit supports MySQL and PostgreSQL;
    because PostgreSQL is the default, we’ll stick with it in this discussion.
  prefs: []
  type: TYPE_NORMAL
- en: First, we start the database subsystem using the built-in Back|Track *init.d*
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After PostgreSQL has started, we tell the Framework to connect to the database
    instance. This connection requires a username, password, name of the host on which
    the database is running, and the database name we want to use. Back|Track’s default
    PostgreSQL username is *postgres* with the password *toor*, but we’ll use *msfbook*
    as the database name. Let’s make the connection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If this were the first time we connected to the database name, we would see
    a lot of text output as Metasploit sets up all the necessary tables. Otherwise,
    the command will return to the `msfconsole` prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit provides a number of commands that we can use to interact with the
    database, as you’ll see throughout this book. (For a complete list, enter **`help`**.)
    For now, we’ll use `db_status` to make sure that we’re connected correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Everything seems to be set up just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Nmap Results into Metasploit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you are working with other team members, with various individuals scanning
    at different times and from different locations, it helps to know how to run *nmap*
    on its own and then import its results into the Framework. Next, we’ll examine
    how to import a basic *nmap*-generated XML export file (generated with *nmap*’s
    `-oX` option) into the Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we scan the Windows virtual machine using the `-oX` option to generate
    a *Subnet1.xml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After generating the XML file, we use the `db_import` command to import it
    into our database. We can then verify that the import worked by using the `db_hosts`
    command, which lists the systems entries that have been created, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that we’ve successfully imported the output of our *nmap* scans
    into Metasploit, as evidenced by the IP addresses populated when we run the `db_hosts`
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advanced Nmap Scanning: TCP Idle Scan'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A more advanced *nmap* scan method, *TCP idle scan*, allows us to scan a target
    stealthily by spoofing the IP address of another host on the network. For this
    type of scan to work, we first need to locate an idle host on the network that
    uses incremental IP IDs (which are used to track packet order). When we discover
    an idle system that uses incremental IP IDs, the IP IDs become predictable, and
    we can then predict the next ID. However, when spoofing the address of an idle
    host while scanning a target’s responses from open ports, we can see a break in
    the predictability of the IP ID sequence, which indicates that we have discovered
    an open port. (To learn more about this module and IP ID sequences, visit [http://www.metasploit.com/modules/auxiliary/scanner/ip/ipidseq/](http://www.metasploit.com/modules/auxiliary/scanner/ip/ipidseq/).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the Framework’s *scanner/ip/ipidseq* module to scan for a host that fits
    the TCP idle scan requirements, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This listing displays the required options for the *ipidseq* scan. One notable
    one, `RHOSTS` at ![](../images/00002.gif), can take IP ranges (such as 192.168.1.20–192.168.1.30);
    Classless Inter-Domain Routing (CIDR) ranges (such as 192.168.1.0/24); multiple
    ranges separated by commas (such as 192.168.1.0/24, 192.168.3.0/24); and a text
    file with one host per line (such as *file:/tmp/hostlist.txt*). All these options
    give us quite a bit of flexibility in specifying our targets.
  prefs: []
  type: TYPE_NORMAL
- en: The `THREADS` value at ![](../images/00004.gif) sets the number of concurrent
    threads to use while scanning. By default, all scanner modules have their `THREADS`
    value initially set to 1\. We can raise this value to speed up our scans or lower
    it to reduce network traffic. In general, you should not set the `THREADS` value
    greater 16 when running Metasploit on Windows, and not greater than 128 on UNIX-like
    operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s set our values and run the module. We’ll set the value for `RHOSTS`
    to 192.168.1.0/24, set `THREADS` to 50, and then run the scan.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Judging by the results of our scan, we see a number of potential idle hosts
    that we can use to perform idle scanning. We’ll try scanning a host using the
    system at 192.168.1.109 shown at ![](../images/00002.gif) by using the `-sI` command
    line flag to specify the idle host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By using the idle host, we were able to discover a number of open ports on our
    target system without sending a single packet to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Running Nmap from MSFconsole
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve performed advanced enumeration on our target, let’s connect
    *nmap* with Metasploit. To do this, we first connect to the *msfbook* database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now we should be able to enter the `db_nmap` command from within *msfconsole*
    to run *nmap* and have its results automatically stored in our new database.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll be attacking only one system in this instance, but you can specify IPs
    by CIDR notation and even ranges (for example, 192.168.1.1/24 or 192.168.1.1–254).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice a series of open ports ![](../images/00002.gif), software versions ![](../images/00004.gif),
    and even a prediction about the target’s operating system ![](../images/00005.gif).
  prefs: []
  type: TYPE_NORMAL
- en: 'To check that the results from the scan are stored in the database, we run
    `db_services`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We’re beginning to develop a picture of our target and exposed ports for use
    as potential attack vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Port Scanning with Metasploit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to its ability to use third-party scanners, Metasploit has several
    port scanners built into its auxiliary modules that directly integrate with most
    aspects of the Framework. In later chapters, we’ll use these port scanners to
    leverage compromised systems to access and attack; his process, often called *pivoting*,
    allows us to use internally connected systems to route traffic to a network that
    would otherwise be inaccessible.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose you compromise a system behind a firewall that is using
    Network Address Translation (NAT). The system behind the NAT-based firewall uses
    private IP addresses, which you cannot contact directly from the Internet. If
    you use Metasploit to compromise a system behind a NAT, you might be able to use
    that compromised internal system to pass traffic (pivot) to internally hosted
    and private IP-based systems to penetrate the network farther behind the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the list of port scanning tools that the Framework offers, enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let’s conduct a simple scan of a single host using Metasploit’s SYN Port Scanner.
    In the following listing, we start the scan with `use scanner/portscan/syn`, set
    `RHOSTS` to 192.168.1.155, set `THREADS` to 50, and then run the scan.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: From the results, you can see at ![](../images/00002.gif) that ports 135, 139,
    and 445 are open on IP address 192.168.1.155, leveraging the *portscan syn* module
    within Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: Targeted Scanning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are conducting a penetration test, there is no shame in looking for
    an easy win. A *targeted scan* looks for specific operating systems, services,
    program versions, or configurations that are known to be exploitable and that
    provide an easy door into a target network. For example, it is common to scan
    a target network quickly for the vulnerability MS08-067, as this is (still) an
    extremely common hole that will give you SYSTEM access much more quickly than
    scanning an entire target network for vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Server Message Block Scanning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Metasploit can scour a network and attempt to identify versions of Microsoft
    Windows using its *smb_version* module.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are not familiar with Server Message Block (SMB, a common file-sharing
    protocol), study up a bit on the different protocols and their purposes before
    you continue. You will need to understand basic port information to learn how
    to attack a system successfully.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'We run the module, list our options, set `RHOSTS`, and begin scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see at ![](../images/00002.gif) the `smb_version` scanner has pinpointed
    the operating system as Windows XP with Service Pack 2\. Because we are scanning
    only one system, we leave `THREADS` set to 1\. If we had been scanning a number
    of systems, such as a class C subnet range, we might consider upping the `THREADS`
    using the `set THREADS` *`number`* option. The results of this scan are stored
    in the Metasploit database for use at a later time and to be accessed with the
    `db_hosts` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have discovered a system running Windows XP without having to do a full scan
    of the network. This is a great way to target hosts quickly and quietly that are
    likely to be more vulnerable when our goal is avoid being noticed.
  prefs: []
  type: TYPE_NORMAL
- en: Hunting for Poorly Configured Microsoft SQL Servers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Poorly configured Microsoft SQL Server (MS SQL) installations often provide
    an initial way into a target network. In fact, many system administrators don’t
    even realize that they have MS SQL servers installed on their workstations at
    all, because the service is installed as a prerequisite for some common software,
    such as Microsoft Visual Studio. These installations are often unused, unpatched,
    or never even configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'When MS SQL is installed, it listens by default either on TCP port 1433 or
    on a random dynamic TCP port. If MS SQL is listening on a dynamic port, simply
    query UDP port 1434 to discover on what dynamic TCP port MS SQL is listening.
    Of course, Metasploit has a module that can make use of this “feature”: *mssql_ping*.'
  prefs: []
  type: TYPE_NORMAL
- en: Because *mssql_ping* uses UDP, it can be quite slow to run across entire subnets
    because of issues with timeouts. But on a local LAN, setting `THREADS` to 255
    will greatly speed up the scan. As Metasploit finds MS SQL servers, it displays
    all the details it can extract from them including, perhaps most importantly,
    the TCP port on which the server is listening.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how you might run an *mssql_ping* scan, which includes starting the scan,
    listing and setting options, and the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, not only does the scanner locate a MS SQL server at ![](../images/00002.gif),
    but it also identifies the instance name at ![](../images/00004.gif), the SQL
    server version at ![](../images/00005.gif), and the TCP port number at ![](../images/00006.gif)
    on which it is listening. Just think of how much time this targeted scan for SQL
    servers would save over running *nmap* against all ports on all machines in a
    target subnet in search of the elusive TCP port.
  prefs: []
  type: TYPE_NORMAL
- en: SSH Server Scanning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If during your scanning you encounter machines running Secure Shell (SSH), you
    should determine which version is running on the target. SSH is a secure protocol,
    but vulnerabilities in various implementations have been identified. You never
    know when you might get lucky and come across an old machine that hasn’t been
    updated. You can use the Framework’s *ssh_version* module to determine the SSH
    version running on the target server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This output tells us that a few different servers are running with various patch
    levels. This information could prove useful if, for example, we wanted to attack
    a specific version of OpenSSH as found with the *ssh_version* scan.
  prefs: []
  type: TYPE_NORMAL
- en: FTP Scanning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FTP is a complicated and insecure protocol. FTP servers are often the easiest
    way into a target network, and you should always scan for, identify, and fingerprint
    any FTP servers running on your target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we scan our XP box for FTP services using the Framework’s *ftp_version*
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The scanner successfully identifies an FTP server at ![](../images/00002.gif).
    Now let’s see if this FTP server allows anonymous logins using the Framework’s
    *scanner/ftp/anonymous*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The scanner reports at ![](../images/00002.gif) that anonymous access is allowed
    and that anonymous users have both read and write access to the server; in other
    words, we have full access to the remote system and the ability to upload or download
    any file that can be accessed by the FTP server software.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Network Management Protocol Sweeping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Simple Network Management Protocol (SNMP) is typically used in network devices
    to report information such as bandwidth utilization, collision rates, and other
    information. However, some operating systems also have SNMP servers that can provide
    information such as CPU utilization, free memory, and other system-specific details.
  prefs: []
  type: TYPE_NORMAL
- en: Convenience for the system administrator can be a gold mine for the penetration
    tester, and accessible SNMP servers can offer considerable information about a
    specific system or even make it possible to compromise a remote device. If, for
    instance, you can get the read/write SNMP community string for a Cisco router,
    you can download the router’s entire configuration, modify it, and upload it back
    to the router.
  prefs: []
  type: TYPE_NORMAL
- en: The Metasploit Framework includes a built-in auxiliary module called *scanner/snmp/snmp_enum*
    that is designed specifically for SNMP sweeps. Before you start the scan, keep
    in mind that the read-only (RO) and read/write (RW) community strings will play
    an important role in the type of information you will be able to extract from
    a given device. On Windows-based devices configured with SNMP, you can often use
    the RO or RW community strings to extract patch levels, running services, usernames,
    uptime, routes, and other information that can make things much easier for you
    during a pen test. (*Community strings* are essentially passwords used to query
    a device for information or to write configuration information to the device.)
  prefs: []
  type: TYPE_NORMAL
- en: After you guess the community strings, SNMP itself (depending on the version)
    can allow anything from excessive information disclosure to full system compromise.
    SNMPv1 and v2 are inherently flawed protocols. SNMPv3, which incorporates encryption
    and better check mechanisms, is significantly more secure. To gain access to a
    switch, you’ll first need to attempt to find its community strings. The Framework’s
    *use scanner/snmp/snmp_login* module will try a word list against one or a range
    of IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A quick Google search for *GSM7224* from the output tells us that the scanner
    has found both the public ![](../images/00002.gif) and private ![](../images/00004.gif)
    community strings for a Netgear switch. This result, believe it or not, has not
    been staged for this book. These are the default factory settings for this switch.
  prefs: []
  type: TYPE_NORMAL
- en: You will encounter many jaw-dropping situations like these throughout your pen
    testing career, because many administrators simply attach devices to a network
    with all their defaults still in place. The situation is even scarier when you
    find these devices accessible from the Internet within a large corporation.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Custom Scanner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many applications and services lack custom modules in Metasploit. Thankfully,
    the Framework has many features that can be useful when you’re building a custom
    scanner, including offering access to all of its exploit classes and methods,
    and support for proxies, Secure Sockets Layer (SSL), reporting, and threading.
    It can be very useful to write your own scanner during security assessments, because
    doing so will allow you to locate every instance of a bad password or unpatched
    service quickly on a target system.
  prefs: []
  type: TYPE_NORMAL
- en: The Metasploit Framework scanner modules include various mixins, such as exploit
    mixins for TCP, SMB, and so on, and the auxiliary `scanner` mixin that is built
    into the Framework. *Mixins* are portions of code with predefined functions and
    calls that are preconfigured for you. The `Auxiliary::Scanner` mixin overloads
    the Auxiliary `run` method; calls the module method at runtime with `run_host(ip)`,
    `run_range(range)`, or `run_batch(batch)`; and then processes the IP addresses.
    We can leverage `Auxiliary::Scanner` to call additional, built-in Metasploit functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Following is a Ruby script for a simple TCP scanner that will connect to a remote
    host on a default port of 12345 and upon connecting, send “HELLO SERVER,” receive
    the server response, and print it out along with the server’s IP address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This simple scanner uses the `Msf::Exploit::Remote::Tcp` ![](../images/00002.gif)
    mixin to handle the TCP networking, and the `Msf::Auxiliary::Scanner` mixin exposes
    the various settings that are required for scanners within the Framework ![](../images/00004.gif).
    This scanner is configured to use the default port of 12345 ![](../images/00005.gif),
    and upon connecting to the server, it sends a message ![](../images/00006.gif),
    receives the reply from the server, and then prints it out to the screen along
    with the server IP address ![](../images/00007.gif).
  prefs: []
  type: TYPE_NORMAL
- en: We have saved this custom script under *modules/auxiliary/scanner/* as *simple_tcp.rb*.
    The saved location is important in Metasploit. For example, if the module is saved
    under *modules/auxiliary/scanner/http/*, it would show up in the modules list
    as *scanner/http/simple_tcp*.
  prefs: []
  type: TYPE_NORMAL
- en: To test this rudimentary scanner, we set up a *netcat* listener on port 12345
    and pipe in a text file to act as the server response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next, we load up *msfconsole*, select our scanner module, set its parameters,
    and run it to see if it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Although this is only a simple example, the level of versatility afforded by
    the Metasploit Framework can be of great assistance when you need to get some
    custom code up and running quickly in the middle of a pen test. Hopefully, this
    simple example demonstrates the power of the Framework and modular code. But,
    of course, you don’t have to do everything by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Looking Ahead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to leverage the Metasploit Framework for intelligence
    gathering, as outlined in the PTES. Intelligence gathering takes practice and
    requires a deep understanding of how an organization operates and how to identify
    the best potential attack vectors. As with anything, you should adapt and improve
    your own methodologies throughout your penetration-testing career. Just remember
    that your main focus for this phase is to learn about the organization you’re
    attacking and its overall footprint. Regardless of whether your work occurs over
    the Internet, on an internal network, wirelessly, or via social engineering, the
    goals of intelligence gathering will always be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll move on to another important step during the vulnerability
    analysis phase: automated vulnerability scanning. In later chapters, we will explore
    more in-depth examples of how to create your own modules, exploits, and Meterpreter
    scripts.'
  prefs: []
  type: TYPE_NORMAL
