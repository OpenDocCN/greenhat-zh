<html><head></head><body>
  <h1><span class="chapter">Chapter 6</span> -<br/>
  The Best Xbox Game: Security Hacking</h1>

  <p>The next step beyond modifying and tweaking the Xbox hardware is taking <span style="font-size: 1em;">control of the Xbox hardware. Unfortunately, gaining control of the</span> <span style="font-size: 1em;">hardware is not as easy as one might think. The designers of the Xbox put a great deal of thought into securing the hardware against sophisticated</span> <span style="font-size: 1em;">software attacks as well as most simple hardware attacks. The Xbox’s security mechanisms are an artifact of its digital rights management architecture.</span></p>

  <div class="note">
    <h3 class="sigil_not_in_toc">Note</h3><img alt="" class="calibre2 note" src="../Images/index-107_1.png" style="height: auto; width: auto;"/>

    <p>In principle, applying hardware to “fair-use” purposes, such as running your own homebrew programs, should not be illegal. However, the relationship between fair use, secured hardware, and the relatively new copyright control circumvention laws is still unclear. Chapter 12, “Caveat Hacker,” discusses the legal issues of hacking in more detail.</p>
  </div>

  <p style="clear: left;">There are many ways around the Xbox’s security measures. In this chapter <span style="font-size: 1em;">and in Chapter 8, “Reverse Engineering Xbox Security,” I tell the story</span> <span style="font-size: 1em;">of my adventures mapping out the Xbox security system. I write not</span> <span style="font-size: 1em;">only about the successes, but also about the failures I encountered, so that you can learn from my experiences. Chapter 9, “Sneaking in the</span> <span style="font-size: 1em;">Backdoor,” explains some approaches taken by others to get around the</span> <span style="font-size: 1em;">Xbox’s security measures. Chapter 7, “A Brief Primer on Security,”</span> <span style="font-size: 1em;">provides the background necessary to appreciate Chapters 8 and 9.</span></p>

  <h2 id="sigil_toc_id_49" style="clear: left;"><b class="calibre3" style="font-size: 1em;">First Encounters with a Paranoid Design</b></h2>

  <p>When the Xbox was announced in the Spring of 2000, excitement rippled <span style="font-size: 1em;">through the hardware enthusiast community. The cause for this excite</span><span style="font-size: 1em;">ment was not just the Xbox’s gaming potential, but its potential for use as a high performance, network-enabled x86-architecture PC at the affordable price of $300. Price cuts a few months after its introduction have since dropped the cost of an Xbox to below $200. The similarity of the X</span><span style="font-size: 1em;">box to an x86 PC meant that a huge base of existing applications and</span> <span style="font-size: 1em;">expertise could, in theory, be easily ported to the console.</span></p>

  <p>My first look inside an Xbox was in late November 2001 when my <span style="font-size: 1em;">girlfriend (now fianceé) gave it to me as an early Christmas gift. I immediately got down to business. In order to take control of the Xbox hard</span><span style="font-size: 1em;">ware, the first task is to extract the boot ROM and analyze its contents:</span> <span style="font-size: 1em;">Recall from the discussion on Xbox architecture in Chapter 2 that the</span> <span style="font-size: 1em;">boot ROM of the Xbox contains all of the code for establishing the</span> <span style="font-size: 1em;">Xbox’s operating environment.</span></p>

  <h3 id="sigil_toc_id_50"><b class="calibre3">To Snarf a ROM</b></h3>

  <p>The type of ROM used in the Xbox is an electrically erasable and program<span style="font-size: 1em;">mable variety known as FLASH ROM. FLASH ROM typically comes in one</span> <span style="font-size: 1em;">of a few package types, and the Xbox uses one of the most popular</span> <span style="font-size: 1em;">packages, the TSOP (Thin Small Outline Package). It is located in sector U7</span> <span style="font-size: 1em;">on the top side of the Xbox motherboard, and the reference designator for</span> <span style="font-size: 1em;">the part is U7D1. The TSOP package is very recognizable because it is one of the few chip packages that is rectangular and has pins only on the</span> <i class="calibre4" style="font-size: 1em;">narrow</i> <span style="font-size: 1em;">edges of the package. Most other packages put pins on the long edge or all edges to maximize connectivity, but FLASH ROM has relatively low I/O</span> <span style="font-size: 1em;">requirements per silicon area. A quick check on the base part number,</span> <span style="font-size: 1em;">29F080, with a Web search engine verifies that this part is indeed an 8 Mbit FLASH ROM.</span></p>

  <p>There are a few techniques that one can use to read out ( <i class="calibre4">snarf</i>) the contents of the FLASH ROM. The no-solder approach is to buy a test clip that snaps onto the FLASH ROM, and read out its contents by powering up and <span style="font-size: 1em;">controlling the ROM through the test clip, while the rest of the Xbox is</span> <span style="font-size: 1em;">powered off. A suitable test clip for this purpose can be purchased from</span> <span style="font-size: 1em;">Emulation Technology, www.emulationtechnology.com. (The test clip</span> <span style="font-size: 1em;">override approach has a few problems with it, the biggest being the</span> <span style="font-size: 1em;">possibility of permanently damaging chips connected to the FLASH</span> <span style="font-size: 1em;">ROM that are not receiving power through the test clip. However, in the</span> <span style="font-size: 1em;">case of the Xbox, this does not seem to be a problem and those who</span> <span style="font-size: 1em;">attempted this approach did meet with success.<sup>1</sup> I did not initially take</span> <span style="font-size: 1em;">this approach as I did not want to risk damaging the motherboard, and</span> <span style="font-size: 1em;">because I could not afford the $300 test clip required for the job.)</span></p>

  <p><span style="font-size: 1em;">Another ingenious approach is to solder wires to the test points around</span> <span style="font-size: 1em;">the FLASH ROM to eavesdrop on the Xbox as it reads the ROM’s</span> <span style="font-size: 1em;">contents. Eavesdropping can be accomplished by either connecting the</span> <span style="font-size: 1em;">wires to a custom board that can interface with the ROM, or by using a</span> <span style="font-size: 1em;">logic analyzer to capture the data as it is accessed by the Xbox CPU. The</span> <span style="font-size: 1em;">latter approach was used with success as well, and in fact some back</span> <span style="font-size: 1em;">doors in the Xbox boot sequence were discovered as a consequence of</span> <span style="font-size: 1em;">this methodology.<sup>2</sup> I chose not to use this approach either, as I did not</span> <span style="font-size: 1em;">have a logic analyzer when I got my first Xbox, and because soldering all</span> <span style="font-size: 1em;">the wires down can be very tedious, difficult, and error-prone. My</span> <span style="font-size: 1em;">approach was more traditional: just remove the FLASH ROM and drop</span> <span style="font-size: 1em;">it into a ROM reader. I also placed a socket on the motherboard, so that</span> <span style="font-size: 1em;">future removal and programming of the ROM would be very quick and</span> <span style="font-size: 1em;">reliable.</span></p>

  <p><img alt="" class="calibre2" src="../Images/index-109_1.png"/><br/></p>

  <p class="caption"><b class="calibre3">Figure 6-1</b>: Removing the Xbox FLASH ROM with a tweezer-style soldering iron.<br/></p>

  <p><span style="font-size: 1em;">Removing the FLASH ROM in a manner that preserves the integrity of</span> <span style="font-size: 1em;">its fine-pitched pins simple if you have the right tools, and nearly</span> <span style="font-size: 1em;">impossible with the wrong tools. The key is to heat all of the pins of the FLASH ROM simultaneously; once uniform heating is achieved, the</span> <span style="font-size: 1em;">FLASH ROM will fall right off the motherboard. Clearly, the standard</span> <span style="font-size: 1em;">pencil-style soldering iron is not going to be able to heat all of the pins simultaneously. The proper tool for the job is a “tong” or “tweezer” style</span> <span style="font-size: 1em;">soldering iron as shown in Figure 6-1 below. These soldering irons have</span> <span style="font-size: 1em;">two heating elements, so they can heat both sides of the chip simulta</span><span style="font-size: 1em;">neously. Furthermore, the soldering iron must have a paddle-tip that is</span> <span style="font-size: 1em;">wide enough to heat the length of the chip all at once.</span></p>

  <p>A soldering iron with these features can cost quite a bit (hundreds of <span style="font-size: 1em;">dollars), but it is a worthwhile investment as it comes in handy in all kinds of situations. I use an Ersa SMT Unit 60A soldering iron that I bought for a good discount on the floor of a tradeshow, and it quickly paid for itself through the few board assembly jobs that I picked up on the side while</span> <span style="font-size: 1em;">finishing my degree. A more affordable iron by Xytronic can be purchased</span> <span style="font-size: 1em;">through Jameco (#168410) for about $70, but I have not used it so I</span> <span style="font-size: 1em;">cannot vouch for its quality. Another budget approach that is very simple</span> <span style="font-size: 1em;">and straightforward is to use a desoldering alloy, as described in Appendix B, “Soldering Techniques.” (Note that a suitable socket for the ROM<sup>3</sup> is</span> <span style="font-size: 1em;">relatively cheap — under $20 — although installing it does require a</span> <span style="font-size: 1em;">steady hand and an optical magnifying device of some kind.)</span></p>

  <p>Once the ROM is removed and its pins cleaned and inspected, its contents <span style="font-size: 1em;">can be read out in a ROM reader. Of course ROM readers can be purchased,</span> <span style="font-size: 1em;">but it is always a good learning experience to build your own. You can read up a little bit on ROM programmers that I’ve built at my website, http://</span><span style="font-size: 1em;">www.xenatera.com/bunnie. My original Flashburner<sup>4</sup> programmer is a</span> <span style="font-size: 1em;">simple device that is easier to understand and build than its second revi</span><span style="font-size: 1em;">sion<sup>5</sup>, but it is less powerful.</span></p>

  <p>However, if your goal is to read out ROMs as quickly as possible, just <span style="font-size: 1em;">purchase a ROM reader outright. A good ROM reader is an essential tool in</span> <span style="font-size: 1em;">any serious hardware hacker’s toolbox. Needham’s Electronics (http://</span><span style="font-size: 1em;">www.needhams.com) makes a great line of ROM programmers/readers</span> <span style="font-size: 1em;">that fit a wide range of budgets.</span></p>

  <h3 id="sigil_toc_id_51"><b class="calibre3">An Encounter with Microsoft</b></h3>

  <p>After extracting the ROM contents, the next step is to share its contents <span style="font-size: 1em;">with fellow hackers for analysis. Or is it? Within twelve hours of posting the contents of the ROM to my website, I received a call from an engineer at</span> <span style="font-size: 1em;">Microsoft politely requesting that I remove their copyrighted content</span> <span style="font-size: 1em;">from my website. Of course, I immediately removed their content from</span> <span style="font-size: 1em;">my website; I should have known better before posting it in the first</span> <span style="font-size: 1em;">place.</span></p>

  <p>This first brush with Microsoft was a sobering warning that reverse <span style="font-size: 1em;">engineering the Xbox was not going to be like any other home appliance</span> <span style="font-size: 1em;">reverse engineering project. There are laws that protect aspects of reverse engineering, and a vast body of copyright law that protects the intellectual property (IP) owner. Collaborative reverse engineering of the Xbox while respecting Microsoft’s rights is a legal minefield.</span></p>

  <p>On the one hand, Microsoft should be able to invest in a product and take a risk in hopes of a profit. However, profitability is not guaranteed by law. <span style="font-size: 1em;">For example, selling the consoles at a huge loss, as Microsoft has done, in hopes of selling software to make up the difference (as a “loss leader”) is a risky proposition, and there is no guarantee by law that Microsoft has to come out ahead in the end. On the other hand, we as hackers have the right</span> <span style="font-size: 1em;">to tinker (“fair use”) with hardware purchased with our own hard-earned</span> <span style="font-size: 1em;">cash, and if Microsoft wants to basically sell PCs at a huge discount to us, that’s fine. Whether or not we purchase enough games (around ten or</span> <span style="font-size: 1em;">more) to compensate for Microsoft’s losses on the Xbox is entirely up to</span> <span style="font-size: 1em;">Microsoft’s business and marketing strategy.</span></p>

  <p>In my view, Microsoft’s large loss-to-revenue ratio is a bit of an anomaly in this industry. Sony and Nintendo roughly break-even on the cost of their console hardware. Also, cell phone providers often sell their phones at a loss comparable to that of the Xbox, but require the subscriber to enter a <span style="font-size: 1em;">contract to ensure that the cost of the phone is recouped; breaking the</span> <span style="font-size: 1em;">contract implies termination fees. Perhaps this is a reflection of Microsoft’s confidence in the Xbox Live business model.</span></p>

  <p>Somewhere in the middle of all of this is the interplay of cryptographic <span style="font-size: 1em;">copyright protection mechanisms and the right to fair use. It turns out that the Xbox makes extensive use of cryptography to enforce copy protections</span> <span style="font-size: 1em;">as well as console usage policies, which brings us to the Digital Millennium Copyright Act of 1998 (DMCA), a relatively new, untested body of law.</span> <span style="font-size: 1em;">With little established court precedent and plenty of gray area in between the letters of the law, you as a hacker must assess the potential liabilities that you could face. Chapter 12, “Caveat Hacker,” explores in greater detail the legal issues of hacking in the new millennium.</span></p>

  <p><b class="calibre3">Analyzing the ROM Contents</b></p>

  <p>Rebuffed by Microsoft, but ROM contents still in hand, I proceeded to <span style="font-size: 1em;">analyze the ROM contents. One would expect that the boot ROM contains</span> <span style="font-size: 1em;">a hardware initialization procedure, followed by instructions that load up</span> <span style="font-size: 1em;">the operating system, and possibly the operating system code itself. But</span> <span style="font-size: 1em;">where to start?</span></p>

  <p>The program inside the ROM can be thought of as a ball of yarn: Once <span style="font-size: 1em;">you find the starting point of the thread, it is just a matter of time and</span> <span style="font-size: 1em;">perseverance until you unwind the ball of yarn to its core.</span></p>

  <p>Fortunately, the starting point of the Xbox’s Pentium processor is very <span style="font-size: 1em;">well documented by Intel. On power-up, the processor starts running</span> <span style="font-size: 1em;">code at a special hard-wired location, called the</span> <i class="calibre4" style="font-size: 1em;">reset vector</i><span style="font-size: 1em;">. This reset vector is at address 0xFFFF.FFF0, near the top of memory. Let’s look at the data contained at this location (in hexadecimal):</span></p>

  <p>0xFFFF.FFF0 EBC6 8BFF 1800 D8FF FFFF 80C2 04B0 02EE</p>
  <pre> 
// key initialization routine
  unsigned char K[256]; // 0xFFFFC80 in flash
  unsigned char S[256]; // 0x10000 in SDRAM

  for( i = 0; i &lt; 256; i++ ) {
    S[i] = i;
  }
  j = 0;
  for( i = 0; i &lt; 256; i++ ) {
    // RC-4 would do j = (j + K[i] + S[i]) % 256
    j = (j + K[i] + S[j]) % 256;
    // swap S[i], S[j]
    temp = S[i];
    S[i] = S[j];
    S[j] = temp;
  }

  // decryption routine
  unsigned char cipherText[16384]; // 0xFFFFA000 in FLASH
  unsigned char plainText[16384];  // 0x400000   in SDRAM

  for( index = 0x4000, i = 0, k = 0; index &gt; 0; index— ) {
    // xbox version
    t = (S[i] ^ cipherText[k]) % 256;
    plainText[k] = t;
    
    // swap( S[i], S[t] );
    temp = S[i];
    S[i] = S[t];
    S[t] = temp;
    i = (i + 1) % 256;
    k++;
  }

</pre>

  <p class="caption"><b class="calibre3">Listing 6-1</b>: Decompilation of the dummy cipher found in the FLASH ROM.</p>

  <p><span style="font-size: 1em;">The first two bytes, EBC6, are a jump instruction to location</span> <span style="font-size: 1em;">0xFFFF.FFB8. The first byte, EB, is the specific opcode for a “jump,</span> <span style="font-size: 1em;">short, relative, displacement relative to next instruction;” the second</span> <span style="font-size: 1em;">byte, C6, is the 8-bit signed offset of the jump. In other words, the first thing the processor does is jump to another location — something every</span> <span style="font-size: 1em;">boot program does, since you only have 16 bytes of runway in the reset</span> <span style="font-size: 1em;">vector before you fall off the high end of memory. Since this code is</span> <span style="font-size: 1em;">typical for a reset vector, it is okay to reprint the code here for educa</span><span style="font-size: 1em;">tional purposes.</span></p>

  <p>The next chunk of code is a piece that initializes the processor’s GDT <span style="font-size: 1em;">(Global Descriptor Table) and IDT (Interrupt Descriptor Table) state. The</span> <span style="font-size: 1em;">GDT and IDT set up the processor’s memory management scheme and</span> <span style="font-size: 1em;">interrupt handling scheme. You do not need to understand exactly what</span> <span style="font-size: 1em;">these registers do, but if you are curious, Intel’s “IA-32 Intel Architecture Software Developer’s Manual, Volume 3: System Programming Guide”</span> <span style="font-size: 1em;">explains the function of these registers in detail. This manual is available at Intel’s developer website, http://developer.intel.com.</span></p>

  <p>After setting up these registers, the processor gets kicked into protected <span style="font-size: 1em;">mode and jumps to 0xFFFF.FE00 — a region exactly 512 bytes below</span> <span style="font-size: 1em;">the top of memory — and this is where things start to get interesting.</span> <span style="font-size: 1em;">After a short snippet of code that sets up the segment registers, a</span> <span style="font-size: 1em;">program called a</span> <i class="calibre4" style="font-size: 1em;">jam table interpreter</i> <span style="font-size: 1em;">(also known as the X-Code interpreter in the Xbox community) is executed. A jam table is industry</span> <span style="font-size: 1em;">vernacular for a table of values that contains opcodes for reads, writes,</span> <span style="font-size: 1em;">and simple decision operations, used in the context of hardware</span> <span style="font-size: 1em;">initializations. Hundreds of operations are required to initialize a typical PC, and jam tables help cope with this complexity without bloating the</span> <span style="font-size: 1em;">core initialization code base. Using jam tables also helps make initialization more flexible and capable of dealing with user-configurable hard</span><span style="font-size: 1em;">ware parameters, such as the type and amount of memory installed. In the</span> <span style="font-size: 1em;">case of the Xbox, the jam table interpreter starts fetching jam table</span> <span style="font-size: 1em;">opcodes from a location near the bottom of the FLASH ROM. (Keep in</span> <span style="font-size: 1em;">mind that the opcodes implemented by the jam table interpreter are quite</span> <span style="font-size: 1em;">powerful; one can write and read data from any location in the Xbox</span> <span style="font-size: 1em;">using jam table opcodes.)</span></p>

  <p>Once the terminal opcode is executed by the jam table interpreter, the <span style="font-size: 1em;">processor clears the MTRRs (Memory Type Range Registers, used to declare</span> <span style="font-size: 1em;">the cacheability of various regions of memory) and starts to decrypt a 16 kB</span> <span style="font-size: 1em;">region of memory starting at 0xFFFF.A000. The cipher used to decrypt</span> <span style="font-size: 1em;">this region of memory looks very similar to RC-4, with some subtle</span> <span style="font-size: 1em;">differences. Listing 6-1 shows the cipher reverse-engineered into C code,</span> <span style="font-size: 1em;">with the help of a tool called IDA Pro by Data Rescue corporation (more</span> <span style="font-size: 1em;">about this tool in the next couple of chapters).</span></p>

  <p>The data decrypted by this cipher is actually a block of code that is executed at the end of the decryption process, but something goes very wrong here. <span style="font-size: 1em;">The decrypted code is garbage. It doesn’t work.</span></p>

  <div class="infobox">
    <h2 class="sigil_not_in_toc"><b class="calibre3" style="font-size: 1em;">Memory Address Decoding Tricks</b><br/></h2>

    <p>A number of tricks exist that can be used to make regions of <span style="font-size: 1em;">memory appear different in some way than their physical</span> <span style="font-size: 1em;">representation would indicate. The two tricks relevant to</span> <span style="font-size: 1em;">the analysis of the Xbox boot sequence are aliasing and</span> <span style="font-size: 1em;">overlaying.</span></p>

    <p>Memory locations are aliased when two addresses refer to <span style="font-size: 1em;">the same memory location, typically accomplished by ig</span><span style="font-size: 1em;">noring a few address bits. To illustrate aliasing, consider a</span> <span style="font-size: 1em;">system using a 3-bit address. There are only 23 = 8 unique</span> <span style="font-size: 1em;">locations addressable in a 3-bit system: 000, 001, 010, 011,</span> <span style="font-size: 1em;">100, 101, 110, and 111. Now suppose that you have a</span> <span style="font-size: 1em;">memory with four locations; it requires only two bits to distin</span><span style="font-size: 1em;">guish each of the four locations: 00, 01, 10, and 11. If you use</span> <span style="font-size: 1em;">our 3-bit address scheme to talk to this four-location memory,</span> <span style="font-size: 1em;">one of the address bits must be ignored. If the highest bit is</span> <span style="font-size: 1em;">ignored, then address 000 and 100 will both map to loca</span><span style="font-size: 1em;">tion 00 in memory. In other words, location 00 is aliased to</span> <span style="font-size: 1em;">addresses 000 and 100.</span></p>

    <p><span style="font-size: 1em;">Memory overlaying is a technique where out-of-band infor</span><span style="font-size: 1em;">mation is used to select between different banks of memory.</span> <span style="font-size: 1em;">Let’s suppose that we wish to have a bank of secret memory.</span> <span style="font-size: 1em;">To do this, we insert a selector between our public and</span> <span style="font-size: 1em;">secret memories, and the CPU. This selector can choose to</span> <span style="font-size: 1em;">present the CPU with data from either the secret memory or</span> <span style="font-size: 1em;">the public memory, as indicated in Figure 6-2. As a result,</span> <span style="font-size: 1em;">the program that controls the address selector also controls</span> <span style="font-size: 1em;">who has access to the secret block. If the computer starts</span> <span style="font-size: 1em;">up running code located in the secret bank of memory, a</span> <span style="font-size: 1em;">program in the secret code region can use this mechanism</span> <span style="font-size: 1em;">to hide itself by setting the selector to point at public memory</span> <span style="font-size: 1em;">before running programs located in public memory.</span></p>

    <p><img alt="figure_6-2" src="../Images/figure_6-2.png" style="width:100%;"/><br/></p>

    <p class="caption"><b class="calibre3">Figure 6-2</b>: Memory overlaying to hide secret regions.</p>
  </div>

  <p><span style="font-size: 1em;">Furthermore, the jam table opcodes seem to be corrupted. This phe</span><span style="font-size: 1em;">nomenon was corroborated by other hackers working on the problem,</span> <span style="font-size: 1em;">thus ruling out a code translation error. Clearly, there is more to the</span> <span style="font-size: 1em;">Xbox than meets the eye.</span></p>

  <p>Theories and rumors started to emerge to explain this strange behavior. <span style="font-size: 1em;">Some of the popular theories included:</span></p>

  <p>• <b class="calibre3">Address and/or data line scrambling.</b> Somewhere, the address or <span style="font-size: 1em;">data lines were being inverted or permuted with some 1:1 mapping</span> <span style="font-size: 1em;">function. The scrambling function could be programmed into the</span> <span style="font-size: 1em;">chipset as part of the initialization procedure, so that the initial</span> <span style="font-size: 1em;">boot block would read like plaintext while the rest of the data</span> <span style="font-size: 1em;">would be scrambled.</span></p>

  <p>• <b class="calibre3">Secondary crypto processor.</b> Another processor on the <span style="font-size: 1em;">Xbox was actual y handling the Xbox’s initialization, and the boot</span> <span style="font-size: 1em;">code in the ROM is bogus.</span></p>

  <p>• <b class="calibre3">Boot code contained in the processor.</b> The processor is <span style="font-size: 1em;">actually initialized by a chunk of code sitting on the processor die,</span> <span style="font-size: 1em;">and the boot code in the ROM is bogus.</span></p>

  <p>• <b class="calibre3">Boot code contained in the chipset.</b> The processor <span style="font-size: 1em;">functions identically to a standard Pentium, but the chipset contains</span> <span style="font-size: 1em;">boot code that overrides the bogus code inside the ROM.</span></p>

  <p>For almost all of these theories, the only way to prove or disprove them is to perform experiments on the hardware. For example, in order to ensure <span style="font-size: 1em;">that the SMC (System Management Controller, an 8-bit self-contained</span> <span style="font-size: 1em;">processor that is always on when the Xbox is plugged in) played no role in</span> <span style="font-size: 1em;">the secure boot sequence of the machine, hackers captured traces of the</span> <span style="font-size: 1em;">waveforms on al of the SMC’s pins and analyzed them against the expected</span> <span style="font-size: 1em;">sequence of events if the SMC were to play a crucial role in machine</span> <span style="font-size: 1em;">initialization.</span></p>

  <p>A crucial observation from a fellow hacker was that the Xbox booted <span style="font-size: 1em;">perfectly even when the reset vector code at 0xFFFF.FFF0 was changed.</span> <span style="font-size: 1em;">One would expect that if the first instruction executed by the processor at 0xFFFF.FFF0 were corrupted, then the machine would crash. Rather, the</span> <span style="font-size: 1em;">machine operated flawlessly. This observation was verified by a set of</span> <span style="font-size: 1em;">experiments where various parts of the FLASH ROM were intentionally</span> <span style="font-size: 1em;">corrupted. The results were that corrupting surprisingly large regions of the FLASH ROM had no effect on the booting of the Xbox. In particular, the</span> <span style="font-size: 1em;">entire boot initialization sequence from 0xFFFF.FE00 to 0xFFFF.FFFF</span> <span style="font-size: 1em;">could be nulled out and the Xbox would boot just fine.</span></p>

  <p>This finding alone strongly supported the theory of a bogus boot block in <span style="font-size: 1em;">FLASH ROM. The question remained, however, about where the real boot</span> <span style="font-size: 1em;">code was stored. There were three options: in a secondary crypto-processor, in the processor, and in the chipset. The secondary crypto-processor theory was discounted on the basis that there were no chips on the motherboard that were powerful enough or active enough at boot time to play the role</span> of a crypto processor. Storing the boot block in the processor was also <span style="font-size: 1em;">deemed a less likely option than storing the boot block in the chipset.</span></p>

  <p><span style="font-size: 1em;">The rationale for this analysis is based on the economics of building</span> <span style="font-size: 1em;">chips. A Pentium III processor is very complex with many handcrafted</span> <span style="font-size: 1em;">blocks, and modifying the silicon to include a secure boot block would</span> <span style="font-size: 1em;">require significant engineering resources as well as an upfront investment</span> <span style="font-size: 1em;">of about a quarter of a million dollars just for the masks needed to</span> <span style="font-size: 1em;">produce the custom silicon. In addition, it was rumored that Microsoft</span> <span style="font-size: 1em;">had originally chosen an AMD processor for the Xbox, and switched to</span> <span style="font-size: 1em;">Intel at the last minute. If custom blocks were integrated into the</span> <span style="font-size: 1em;">processor core, Microsoft could not have switched between CPU</span> <span style="font-size: 1em;">vendors so easily. On the other hand, nVidia’s chipsets are designed</span> <span style="font-size: 1em;">modularly using silicon compilers, so it is technically easier to add warts like a secure boot block. Furthermore, the chipset in the Xbox is a</span> <span style="font-size: 1em;">custom build of the nForce made just for Microsoft, tailored specifically</span> <span style="font-size: 1em;">for an Intel front-side bus (FSB). As a result, the cost of adding a secure boot block could be rolled into the engineering resources and the mask</span> <span style="font-size: 1em;">sets already allocated to such a project.</span></p>

  <p>Operating under the theory that the real boot code is located in a secret <span style="font-size: 1em;">ROM overlay in the chipset, the challenges remaining were to determine in</span> <span style="font-size: 1em;">which chip (Northbridge or Southbridge) the code was stored, and how to</span> <span style="font-size: 1em;">extract this secret ROM. A few strategies for extracting the secret ROM</span> <span style="font-size: 1em;">presented themselves:</span></p>

  <p>• <b class="calibre3">Use the JTAG “boundary scan” feature</b> on the Pentium to try <span style="font-size: 1em;">to capture the initial boot code. JTAG is a diagnostic bus that</span> <span style="font-size: 1em;">allows you to read and set the state of every pin on a chip</span> <span style="font-size: 1em;">through a special serial port. It is a very powerful and versatile</span> <span style="font-size: 1em;">debugging tool.</span></p>

  <p>• <b class="calibre3">Probe the processor FSB (Front Side Bus)</b> to try and capture <span style="font-size: 1em;">the boot code as it enters the processor.</span></p>

  <p><span style="font-size: 1em;">•</span> <b class="calibre3" style="font-size: 1em;">Install a memory sniffer</b> <span style="font-size: 1em;">to try and capture the decrypted data</span> <span style="font-size: 1em;">stream as it is written into memory.</span></p>

  <p>• <b class="calibre3">Use microscopy</b> to read out the contents of the secure boot <span style="font-size: 1em;">area from the chip surface.</span></p>

  <p>• <b class="calibre3">Probe the bus between the Southbridge and the</b> <b class="calibre3" style="font-size: 1em;">Northbridge</b> <span style="font-size: 1em;">chips to try and capture the boot code being sent</span> <span style="font-size: 1em;">to the processor by the chipset. This would only work if the boot</span> <span style="font-size: 1em;">data is stored somewhere in the Southbridge chip.</span></p>

  <p style="font-size: medium;"><img alt="" class="calibre2" src="../Images/index-116_1.png"/><br/></p>

  <p class="caption" style="font-size: medium;"><b class="calibre3">Figure 6-3</b>: Missing JTAG via. Note how the fil ed in copper region (lighter area) has a hole where a via used to be. This is the result of a last-minute change to the board layout without recalculation of the fill regions.</p>

  <p>None of these theories were trivial to test, so the Xbox hacking effort slowly ground down to a halt as frustrated hackers gave up trying to cryptanalyze the FLASH ROM image. I would have been one of the quitters (after all, I <span style="font-size: 1em;">had a doctoral thesis to finish</span> <i class="calibre4" style="font-size: 1em;">and</i> <span style="font-size: 1em;">write in just a few months) had it not been for the community of determined hackers feeding me encouragement.</span> <span style="font-size: 1em;">Over Christmas break in December 2001, I kept in touch with my hacker</span> <span style="font-size: 1em;">friends via IRC channels and web fora. Hackers from all over the world and</span> <span style="font-size: 1em;">all walks of life pervaded the Xbox hacking IRC channel, and I enjoyed</span> <span style="font-size: 1em;">learning from them and chatting with them about their various experiences,</span> <span style="font-size: 1em;">both technical and personal.</span></p>

  <p>Even though I was determined to spend all of January writing my PhD <span style="font-size: 1em;">thesis<sup>6</sup> and avoiding Xbox hacking, I was still pulled in by the intriguingly complex security employed by the Xbox. As time went on, the need for a</span> <span style="font-size: 1em;">hardware guy to join the small group of hardcore hackers hanging out on</span> <span style="font-size: 1em;">the IRC channel became increasingly clear. By the end of January, the reports I was hearing about the Xbox security scheme were too interesting to</span> <span style="font-size: 1em;">ignore.</span></p>

  <p>I purchased a second Xbox and I started removing all of its key parts using a hot air gun. Stripping down the Xbox served many purposes. First, <span style="font-size: 1em;">removing the chips exposed all of the traces and connections on the Xbox</span> <span style="font-size: 1em;">so that I could easily follow the connections between chips using the</span> <span style="font-size: 1em;">continuity test mode on my multimeter. Second, I was able to drop all of</span> <span style="font-size: 1em;">the interesting chips into a hot acid bath and remove their plastic encapsulation for analysis under a microscope. Finally, buying an Xbox and totally</span> <span style="font-size: 1em;">ripping it apart gave me a sort of peace of mind when it comes to probing</span> <span style="font-size: 1em;">and modifying a working Xbox. (Reverse engineering is like gardening.</span> <span style="font-size: 1em;">Planting a garden is much more challenging if you’re trying to keep your</span> <span style="font-size: 1em;">hands and knees clean, so you might as well get over it and start rolling in the dirt.)</span></p>

  <p>The results of the Xbox tear-down revealed some of the measures that <span style="font-size: 1em;">Microsoft took to secure the box against hardware hackers. For example, I</span> <span style="font-size: 1em;">first checked the JTAG connections on the Pentium CPU. All of the JTAG</span> <span style="font-size: 1em;">signals were conveniently routed to a set of easy-to-tap resistors near the processor, except for one, the TRST# signal. TRST# plays a critical role in</span> <span style="font-size: 1em;">initializing the JTAG interface. Interestingly, TRST# was tied to the</span> <span style="font-size: 1em;">internal ground plane, in a difficult to access area, permanently deactivating the JTAG mechanism. Further inspection of the Xbox motherboard</span> <span style="font-size: 1em;">revealed hints that the TRST# signal was stripped out at the last minute.</span> <span style="font-size: 1em;">(The biggest hint of a missing via is a hole in a power trace perfectly</span> <span style="font-size: 1em;">sized for a via near a cluster of vias dedicated to JTAG signals, as shown in Figure 6-3.)</span></p>

  <p><span style="font-size: 1em;">Another blow to the JTAG approach for extracting the secret ROM is</span> <span style="font-size: 1em;">the fact that Intel’s JTAG scan codes are proprietary. Reverse engineering</span> <span style="font-size: 1em;">the codes to a level where I could use them for extracting the secret boot</span> <span style="font-size: 1em;">data was a major project on its own.</span></p>

  <p>Giving up on the JTAG approach, the next method for extracting the secret <span style="font-size: 1em;">ROM was to strip the packaging off of the CPU, GPU, and MCPX and to</span> <span style="font-size: 1em;">inspect the bare die with a microscope and search for any candidate ROM</span> <span style="font-size: 1em;">structures. Package removal or “decapsulation” was accomplished by bathing</span> <span style="font-size: 1em;">the chips in fuming hot sulfuric acid. (I don’t recommend trying this</span> <span style="font-size: 1em;">approach at home; one time I spilled the toxic, corrosive solution all over myself and thankfully, my protective gear was consumed instead of my</span> <span style="font-size: 1em;">skin. Fuming sulfuric consumes organic material faster than a burning</span> <span style="font-size: 1em;">flame.) Fuming nitric, also very toxic and dangerous, can also be used. While I have not tried it myself, reports indicate that fuming nitric is more effective at removing the epoxy encapsulation, especially in situations where selective package removal is desired.</span></p>

  <p><span style="font-size: 1em;">The manual inspection approach using a traditional visible light microscope offered some hope; however, the technique is limited by the physics of</span> <span style="font-size: 1em;">light. Not even the best visible microscopy technology can resolve a 150 nm transistor, since the shortest wavelength of light is 450 nm (corresponding to the color blue). I was hoping the secret code would be stored on the chips using a traditional array ROM structure, with the metal lines defining a 1 or a 0 etched into the top metal layers which can be identified with an optical microscope. The use of a hard-wired ROM structure is motivated by</span> <span style="font-size: 1em;">cost: FLASH ROMs and fuse-based PROMs require extra processing and</span> <span style="font-size: 1em;">manufacturing steps that can add significantly to the cost of the system,</span> <span style="font-size: 1em;">whereas the use of top metal layers would be motivated by risk manage</span><span style="font-size: 1em;">ment on the designer’s part. Top metal layers are the coarsest layers (so</span> <span style="font-size: 1em;">coarse that an optical microscope may resolve them), and are thus the</span> <span style="font-size: 1em;">cheapest layers to change if there is a bug in the ROM code. Also, during</span> <span style="font-size: 1em;">initial bring-up, the top layer is the easiest to cut and jumper using a chip repair machine knows as a FIB (focused ion beam) machine. Unfortunately,</span> <span style="font-size: 1em;">a quick glance at the chip under the microscope revealed no such structures.</span></p>

  <p><span style="font-size: 1em;">At this point, the only remaining option for extracting the secret ROM</span> <span style="font-size: 1em;">was to probe the live Xbox hardware, in an effort to capture the code</span> <span style="font-size: 1em;">during loading into the Xbox processor. Eavesdropping for code</span> <span style="font-size: 1em;">upstream of the Southbridge chip and the FLASH ROM meant probing</span> <span style="font-size: 1em;">either the Front Side bus, the Northbridge-Southbridge bus, or the main</span> <span style="font-size: 1em;">memory bus. We’ll discuss the trade-offs of executing these probing</span> <span style="font-size: 1em;">approaches in Chapter 8, after a short introduction to basic security</span> <span style="font-size: 1em;">concepts in the next chapter.</span></p>
  <hr class="sigil_split_marker"/>

  <p><sup>1</sup> Andy Green has an excellent page that documents his <span style="font-size: 1em;">experiences with the test clip approach at http://</span><span style="font-size: 1em;">www.warmcat.com/milksop/milksop.html</span></p>

  <p><sup>2</sup> Visor has written up his experiences with the logic analyzer snooping approach at http://www.xboxhacker.net/visor/aXventure1.txt</p>

  <p><sup>3</sup> Emulation Technologies (http://www.emulation.com) makes a <span style="font-size: 1em;">wide line of affordable sockets for purposes just like these. The</span> <span style="font-size: 1em;">specific model for the Xbox is the S-TS-SM-040-A.</span></p>

  <p><sup>4</sup> http://www.xenatera.com/bunnie/proj/flashburn/fb.html</p>

  <p><sup>5</sup> http://www.xenatera.com/bunnie/proj/fb2/</p>

  <p><span style="font-size: 1em;"><sup>6</sup> For those interested in supercomputer architecture, data and thread migration, fault tolerance, high speed low-latency</span> <span style="font-size: 1em;">networks, or massively multithreaded machines, check out my</span> <span style="font-size: 1em;">thesis at http://www.xenatera.com/bunnie/phdthesis.pdf.</span><br/></p>
</body></html>