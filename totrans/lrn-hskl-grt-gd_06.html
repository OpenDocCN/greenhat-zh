<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Modules"><div class="titlepage"><div><div><h1 class="title"><a id="modules"/>Chapter 6. Modules</h1></div></div></div><p>A Haskell <span class="emphasis"><em>module</em></span> is essentially a file that defines some functions, types, and type classes. A Has-kell <span class="emphasis"><em>program</em></span> is a collection of modules.<a id="IDX-CHP-6-0001" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e8311"/><img src="httpatomoreillycomsourcenostarchimages802574.png.jpg" alt="image with no caption"/></div></div><p>A module can have many functions and types defined inside it, and it <span class="emphasis"><em>exports</em></span> some of them. This means that it makes them available for the outside world to see and use.</p><p>Having code split up into several modules has many advantages. If a module is generic enough, the functions it exports can be used in a multitude of different programs. If your own code is separated into self-contained modules that don’t rely on each other too much (we also say they are <span class="emphasis"><em>loosely coupled</em></span>), you can reuse them later. Your code is more manageable when you split it into several parts.<a id="IDX-CHP-6-0002" class="indexterm"/><a id="IDX-CHP-6-0003" class="indexterm"/></p><p>The Haskell standard library is split into modules, and each of them contains functions and types that are somehow related and serve some common purpose. There are modules for manipulating lists, concurrent programming, dealing with complex numbers, and so on. All the functions, types, and type classes that we’ve dealt with so far are part of the <code class="literal">Prelude</code> module, which is imported by default.<a id="IDX-CHP-6-0004" class="indexterm"/><a id="IDX-CHP-6-0005" class="indexterm"/><a id="IDX-CHP-6-0006" class="indexterm"/><a id="IDX-CHP-6-0007" class="indexterm"/><a id="IDX-CHP-6-0008" class="indexterm"/><a id="IDX-CHP-6-0009" class="indexterm"/></p><p>In this chapter, we’re going to examine a few useful modules and their functions. But first, you need to know how to import modules.</p><div class="sect1" title="Importing Modules"><div class="titlepage"><div><div><h1 class="title"><a id="importing_modules"/>Importing Modules</h1></div></div></div><p>The syntax for importing modules in a Haskell script is <code class="literal">import ModuleName</code>. This must be done before defining any functions, so imports are usually at the top of the file. One script can import several modules—just put each <code class="literal">import</code> statement on a separate line.<a id="IDX-CHP-6-0010" class="indexterm"/><a id="IDX-CHP-6-0011" class="indexterm"/></p><p>An example of a useful module is <code class="literal">Data.List</code>, which has a bunch of functions for working with lists. Let’s import that module and use one of its functions to create our own function that tells us how many unique elements a list has.</p><a id="I_programlisting6_d1e8389"/><pre class="programlisting">import Data.List

numUniques :: (Eq a) =&gt; [a] -&gt; Int
numUniques = length . nub</pre><p>When you import <code class="literal">Data.List</code>, all the functions that <code class="literal">Data.List</code> exports become available; you can call them from anywhere in the script. One of those functions is <code class="literal">nub</code>, which takes a list and weeds out duplicate elements. Composing <code class="literal">length</code> and <code class="literal">nub</code> with <code class="literal">length . nub</code> produces a function that’s the equivalent of <code class="literal">\xs -&gt; length (nub xs)</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>To search for functions or to find out where they’re located, use Hoogle, which can be found at <a class="ulink" href="http://www.haskell.org/hoogle/">http://www.haskell.org/hoogle/</a>. It’s a really awesome Haskell search engine that allows you to search by function name, module name, or even type signature.</p></div><p>You can also get access to functions of modules when using GHCi. If you’re in GHCi and you want to be able to call the functions exported by <code class="literal">Data.List</code>, enter this:</p><a id="I_programlisting6_d1e8425"/><pre class="programlisting">ghci&gt; :m + Data.List</pre><p>If you want to access several modules from GHCi, you don’t need to enter <code class="literal">:m +</code> several times. You can load several modules at once, as in this example:</p><a id="I_programlisting6_d1e8432"/><pre class="programlisting">ghci&gt; :m + Data.List Data.Map Data.Set</pre><p>However, if you’ve loaded a script that already imports a module, you don’t need to use <code class="literal">:m +</code> to access that module. If you need only a couple of functions from a module, you can selectively import just those functions. For example, here’s how you could import only the <code class="literal">nub</code> and <code class="literal">sort</code> functions from <code class="literal">Data.List</code>:<a id="IDX-CHP-6-0012" class="indexterm"/><a id="IDX-CHP-6-0013" class="indexterm"/><a id="IDX-CHP-6-0014" class="indexterm"/><a id="IDX-CHP-6-0015" class="indexterm"/><a id="IDX-CHP-6-0016" class="indexterm"/><a id="IDX-CHP-6-0017" class="indexterm"/><a id="IDX-CHP-6-0018" class="indexterm"/><a id="IDX-CHP-6-0019" class="indexterm"/><a id="IDX-CHP-6-0020" class="indexterm"/><a id="IDX-CHP-6-0021" class="indexterm"/><a id="IDX-CHP-6-0022" class="indexterm"/></p><a id="I_programlisting6_d1e8497"/><pre class="programlisting">import Data.List (nub, sort)</pre><p>You can also choose to import all of the functions of a module except a few select ones. That’s often useful when several modules export functions with the same name and you want to get rid of the offending ones. Say you already have your own function called <code class="literal">nub</code> and you want to import all the functions from <code class="literal">Data.List</code> except the <code class="literal">nub</code> function. Here’s how to do that:</p><a id="I_programlisting6_d1e8510"/><pre class="programlisting">import Data.List hiding (nub)</pre><p>Another way of dealing with name clashes is to do <span class="emphasis"><em>qualified imports</em></span>. Consider the <code class="literal">Data.Map</code> module, which offers a data structure for looking up values by key. This module exports a lot of functions with the same name as <code class="literal">Prelude</code> functions, such as <code class="literal">filter</code> and <code class="literal">null</code>. So if we imported <code class="literal">Data.Map</code> and then called <code class="literal">filter</code>, Haskell wouldn’t know which function to use. Here’s how we solve this:</p><a id="I_programlisting6_d1e8536"/><pre class="programlisting">import qualified Data.Map</pre><p>Now if we want to reference <code class="literal">Data.Map</code>’s <code class="literal">filter</code> function, we must use <code class="literal">Data.Map.filter</code>. Entering just <code class="literal">filter</code> still refers to the normal <code class="literal">filter</code> we all know and love. But typing <code class="literal">Data.Map</code> in front of every function from that module is kind of tedious. That’s why we can rename the qualified import to something shorter:</p><a id="I_programlisting6_d1e8559"/><pre class="programlisting">import qualified Data.Map as M</pre><p>Now to reference <code class="literal">Data.Map</code>’s <code class="literal">filter</code> function, we just use <code class="literal">M.filter</code>.</p><p>As you’ve seen, the <code class="literal">.</code> symbol is used to reference functions from modules that have been imported as qualified, such as <code class="literal">M.filter</code>. We also use it to perform function composition. So how does Haskell know what we mean when we use it? Well, if we place it between a qualified module name and a function, without whitespace, it’s regarded as just referring to the imported function; otherwise, it’s treated as function composition.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>A great way to pick up new Haskell knowledge is to just click through the standard library documentation and explore the modules and their functions. You can also view the Haskell source code for each module. Reading the source code of some modules will give you a solid feel for Haskell.</p></div></div></div>
<div class="sect1" title="Solving Problems with Module Functions"><div class="titlepage"><div><div><h1 class="title"><a id="solving_problems_with_module_functions"/>Solving Problems with Module Functions</h1></div></div></div><p>The modules in the standard libraries provide many functions that can make our lives easier when coding in Haskell. Let’s look at some examples of how to use functions from various Haskell modules to solve problems.<a id="IDX-CHP-6-0023" class="indexterm"/><a id="IDX-CHP-6-0024" class="indexterm"/><a id="IDX-CHP-6-0025" class="indexterm"/><a id="IDX-CHP-6-0026" class="indexterm"/><a id="IDX-CHP-6-0027" class="indexterm"/></p><div class="sect2" title="Counting Words"><div class="titlepage"><div><div><h2 class="title"><a id="counting_words"/>Counting Words</h2></div></div></div><p>Suppose we have a string that contains a bunch of words, and we want to know how many times each word appears in the string. The first module function we’ll use is <code class="literal">words</code> from <code class="literal">Data.List</code>. The <code class="literal">words</code> function converts a string into a list of strings where each string is one word. Here’s a quick demonstration:</p><a id="I_programlisting6_d1e8623"/><pre class="programlisting">ghci&gt; words "hey these are the words in this sentence"
["hey","these","are","the","words","in","this","sentence"]
ghci&gt; words "hey these           are    the words in this sentence"
["hey","these","are","the","words","in","this","sentence"]</pre><p>Then we’ll use the <code class="literal">group</code> function, which also lives in <code class="literal">Data.List</code>, to group together words that are identical. This function takes a list and groups adjacent elements into sublists if they are equal:</p><a id="I_programlisting6_d1e8633"/><pre class="programlisting">ghci&gt; group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
[[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]</pre><p>But what happens if the elements that are equal aren’t adjacent in our list?</p><a id="I_programlisting6_d1e8637"/><pre class="programlisting">ghci&gt; group ["boom","bip","bip","boom","boom"]
[["boom"],["bip","bip"],["boom","boom"]]</pre><p>We get two lists that contain the string <code class="literal">"boom"</code>, even though we want all occurrences of some word to end up in the same list. What are we to do? Well, we could sort our list of words beforehand! For that, we’ll use the <code class="literal">sort</code> function, which hangs its hat in <code class="literal">Data.List</code>. It takes a list of things that can be ordered and returns a new list that is like the old one, but ordered from smallest to largest:</p><a id="I_programlisting6_d1e8650"/><pre class="programlisting">ghci&gt; sort [5,4,3,7,2,1]
[1,2,3,4,5,7]
ghci&gt; sort ["boom","bip","bip","boom","boom"]
["bip","bip","boom","boom","boom"]</pre><p>Notice that the strings are put in an alphabetical order.</p><p>We have all the ingredients for our recipe. Now we just need to write it down. We’ll take a string, break it down into a list of words, sort those words, and then group them. Finally, we’ll use some mapping magic to get tuples like <code class="literal">("boom", 3)</code>, meaning that the word <code class="literal">"boom"</code> occurs three times.<a id="IDX-CHP-6-0028" class="indexterm"/><a id="IDX-CHP-6-0029" class="indexterm"/><a id="IDX-CHP-6-0030" class="indexterm"/><a id="IDX-CHP-6-0031" class="indexterm"/><a id="IDX-CHP-6-0032" class="indexterm"/><a id="IDX-CHP-6-0033" class="indexterm"/><a id="IDX-CHP-6-0034" class="indexterm"/></p><a id="I_programlisting6_d1e8693"/><pre class="programlisting">import Data.List

wordNums :: String -&gt; [(String,Int)]
wordNums = map (\ws -&gt; (head ws, length ws)) . group . sort . words</pre><p>We used function composition to make our final function. It takes a string, such as <code class="literal">"wa wa wee wa"</code>, and then applies <code class="literal">words</code> to that string, resulting in <code class="literal">["wa","wa","wee","wa"]</code>. Then <code class="literal">sort</code> is applied to that, and we get <code class="literal">["wa","wa","wa","wee"]</code>. Applying <code class="literal">group</code> to this result groups adjacent words that are equal, so we get a list of lists of strings: <code class="literal">[["wa","wa","wa"],["wee"]]</code>. Then we map a function that takes a list and returns a tuple, where the first component is the head of the list and the second component is its length, over the grouped words. Our final result is <code class="literal">[("wa",3),("wee",1)]</code>.</p><p>Here’s how we could write this function without function composition:</p><a id="I_programlisting6_d1e8724"/><pre class="programlisting">wordNums xs = map (\ws -&gt; (head ws,length ws)) (group (sort (words xs)))</pre><p>Wow, parentheses overload! I think it’s easy to see how function composition makes this function more readable.</p></div><div class="sect2" title="Needle in the Haystack"><div class="titlepage"><div><div><h2 class="title"><a id="needle_in_the_haystack"/>Needle in the Haystack</h2></div></div></div><p>For our next mission, should we choose to accept it, we will make a function that takes two lists and tells us if the first list is wholly contained anywhere in the second list. For instance, the list <code class="literal">[3,4]</code> is contained in <code class="literal">[1,2,3,4,5]</code>, whereas <code class="literal">[2,5]</code> isn’t. We’ll refer to the list that’s being searched as the <span class="emphasis"><em>haystack</em></span> and the list that we’re searching for as the <span class="emphasis"><em>needle</em></span>.</p><p>For this escapade, we’ll use the <code class="literal">tails</code> function, which dwells in <code class="literal">Data.List</code>. <code class="literal">tails</code> takes a list and successively applies the <code class="literal">tail</code> function to that list. Here’s an example:</p><a id="I_programlisting6_d1e8762"/><pre class="programlisting">ghci&gt; tails "party"
["party","arty","rty","ty","y",""]
ghci&gt; tails [1,2,3]
[[1,2,3],[2,3],[3],[]]</pre><p>At this point, it may not be obvious why we need <code class="literal">tails</code> at all. Another example will clarify this.</p><p>Let’s say that we’re searching for the string <code class="literal">"art"</code> inside the string <code class="literal">"party"</code>. First, we use <code class="literal">tails</code> to get all the tails of the list. Then we examine each tail, and if any one starts with the string <code class="literal">"art"</code>, we’ve found the needle in our haystack! If we were looking for <code class="literal">"boo"</code> inside <code class="literal">"party"</code>, no tail would start with the string <code class="literal">"boo"</code>.</p><p>To see if one string starts with another, we’ll use the <code class="literal">isPrefixOf</code> function, which is also found in <code class="literal">Data.List</code>. It takes two lists and tells us if the second one starts with the first one.<a id="IDX-CHP-6-0035" class="indexterm"/><a id="IDX-CHP-6-0036" class="indexterm"/><a id="IDX-CHP-6-0037" class="indexterm"/><a id="IDX-CHP-6-0038" class="indexterm"/><a id="IDX-CHP-6-0039" class="indexterm"/></p><a id="I_programlisting6_d1e8820"/><pre class="programlisting">ghci&gt; "hawaii" `isPrefixOf` "hawaii joe"
True
ghci&gt; "haha" `isPrefixOf` "ha"
False
ghci&gt; "ha" `isPrefixOf` "ha"
True</pre><p>Now we just need to check if any tail of our haystack starts with our needle. For that, we can use the <code class="literal">any</code> function from <code class="literal">Data.List</code>. It takes a predicate and a list, and it tells us if any element from the list satisfies the predicate. Behold:</p><a id="I_programlisting6_d1e8830"/><pre class="programlisting">ghci&gt; any (&gt; 4) [1,2,3]
False
ghci&gt; any (=='F') "Frank Sobotka"
True
ghci&gt; any (\x -&gt; x &gt; 5 &amp;&amp; x &lt; 10) [1,4,11]
False</pre><p>Let’s put these functions together:</p><a id="I_programlisting6_d1e8835"/><pre class="programlisting">import Data.List

isIn :: (Eq a) =&gt; [a] -&gt; [a] -&gt; Bool
needle `isIn` haystack = any (needle `isPrefixOf`) (tails haystack)</pre><p>That’s all there is to it! We use <code class="literal">tails</code> to generate a list of tails of our haystack and then see if any of them starts with our needle. Let’s give it a test run:</p><a id="I_programlisting6_d1e8842"/><pre class="programlisting">ghci&gt; "art" `isIn` "party"
True
ghci&gt; [1,2] `isIn` [1,3,5]
False</pre><p>Oh, wait a minute! It turns out that the function that we just made is already in <code class="literal">Data.List</code>! Curses! It’s called <code class="literal">isInfixOf</code>, and it does the same work as our <code class="literal">isIn</code> function.</p></div><div class="sect2" title="Caesar Cipher Salad"><div class="titlepage"><div><div><h2 class="title"><a id="caesar_cipher_salad"/>Caesar Cipher Salad</h2></div></div></div><p>Gaius Julius Caesar has entrusted upon us an important task. We must transport a top-secret message to Mark Antony in Gaul. Just in case we get captured, we’re going to use some functions from <code class="literal">Data.Char</code> to be a bit sneaky and encode messages by using the <span class="emphasis"><em>Caesar cipher</em></span>.<a id="IDX-CHP-6-0040" class="indexterm"/><a id="IDX-CHP-6-0041" class="indexterm"/><a id="IDX-CHP-6-0042" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e8878"/><img src="httpatomoreillycomsourcenostarchimages802576.png.jpg" alt="image with no caption"/></div></div><p>The Caesar cipher is a primitive method of encoding messages by shifting each character by a fixed number of positions in the alphabet. We can easily create a sort of Caesar cipher of our own, and we won’t constrict ourselves to the alphabet—we’ll use the whole range of Unicode characters.<a id="IDX-CHP-6-0043" class="indexterm"/><a id="IDX-CHP-6-0044" class="indexterm"/><a id="IDX-CHP-6-0045" class="indexterm"/></p><p>To shift characters forward and backward in the alphabet, we’re going to use the <code class="literal">Data.Char</code> module’s <code class="literal">ord</code> and <code class="literal">chr</code> functions, which convert characters to their corresponding numbers and vice versa:</p><a id="I_programlisting6_d1e8911"/><pre class="programlisting">ghci&gt; ord 'a'
97
ghci&gt; chr 97
'a'
ghci&gt; map ord "abcdefgh"
[97,98,99,100,101,102,103,104]</pre><p><code class="literal">ord 'a'</code> returns <code class="literal">97</code> because <code class="literal">'a'</code> is the ninety-seventh character in the Unicode table of characters.</p><p>The difference between the <code class="literal">ord</code> values of two characters is equal to how far apart they are in the Unicode table.</p><p>Let’s write a function that takes a number of positions to shift and a string, and returns that string where every character is shifted forward in the alphabet by that many positions.</p><a id="I_programlisting6_d1e8930"/><pre class="programlisting">import Data.Char

encode :: Int -&gt; String -&gt; String
encode offset msg = map (\c -&gt; chr $ ord c + offset) msg</pre><p>Encoding a string is as simple as taking our message and mapping over it a function that takes a character, converts it to its corresponding number, adds an offset, and then converts it back to a character. A composition cowboy would write this function as <code class="literal">(chr . (+ offset) . ord)</code>.</p><a id="I_programlisting6_d1e8938"/><pre class="programlisting">ghci&gt; encode 3 "hey mark"
"kh|#pdun"
ghci&gt; encode 5 "please instruct your men"
"uqjfxj%nsxywzhy%~tzw%rjs"
ghci&gt; encode 1 "to party hard"
"up!qbsuz!ibse"</pre><p>That’s definitely encoded!<a id="IDX-CHP-6-0046" class="indexterm"/><a id="IDX-CHP-6-0047" class="indexterm"/></p><p>Decoding a message is basically just shifting it back by the number of places it was shifted by in the first place.<a id="IDX-CHP-6-0048" class="indexterm"/></p><a id="I_programlisting6_d1e8957"/><pre class="programlisting">decode :: Int -&gt; String -&gt; String
decode shift msg = encode (negate shift) msg</pre><p>Now we can test it by decoding Caesar’s message:</p><a id="I_programlisting6_d1e8961"/><pre class="programlisting">ghci&gt; decode 3 "kh|#pdun"
"hey mark"
ghci&gt; decode 5 "uqjfxj%nsxywzhy%~tzw%rjs"
"please instruct your men"
ghci&gt; decode 1 "up!qbsuz!ibse"
"to party hard"</pre></div><div class="sect2" title="On Strict Left Folds"><div class="titlepage"><div><div><h2 class="title"><a id="on_strict_left_folds"/>On Strict Left Folds</h2></div></div></div><p>In the previous chapter, you saw how <code class="literal">foldl</code> works and how you can use it to implement all sorts of cool functions. However, there’s a catch to <code class="literal">foldl</code> that we haven’t yet explored: Using <code class="literal">foldl</code> can sometimes lead to so-called stack overflow errors, which occur when your program uses too much space in a specific part of your computer’s memory. To demonstrate, let’s use <code class="literal">foldl</code> with the <code class="literal">+</code> function to sum a list that consists of a hundred <code class="literal">1</code>s:<a id="IDX-CHP-6-0049" class="indexterm"/><a id="IDX-CHP-6-0050" class="indexterm"/></p><a id="I_programlisting6_d1e8995"/><pre class="programlisting">ghci&gt; foldl (+) 0 (replicate 100 1)
100</pre><p>This seems to work. What if we want to use <code class="literal">foldl</code> to sum a list that has, as Dr. Evil would put it, <span class="emphasis"><em>one million</em></span> <code class="literal">1</code>s?</p><a id="I_programlisting6_d1e9008"/><pre class="programlisting">ghci&gt; foldl (+) 0 (replicate 1000000 1)
*** Exception: stack overflow</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e9011"/><img src="httpatomoreillycomsourcenostarchimages802578.png.jpg" alt="image with no caption"/></div></div><p>Ooh, that is truly evil! Now why does this happen? Haskell is lazy, and so it defers actual computation of values for as long as possible. When we use <code class="literal">foldl</code>, Haskell doesn’t compute (that is, evaluate) the actual accumulator on every step. Instead, it defers its evaluation. In the next step, it again doesn’t evaluate the accumulator, but defers the evaluation. It also keeps the old deferred computation in memory, because the new one often refers to its result. So as the fold merrily goes along its way, it builds up a bunch of deferred computations, each taking a not insignificant amount of memory. Eventually, this can cause a stack overflow error.</p><p>Here’s how Haskell evaluates the expression <code class="literal">foldl (+) 0 [1,2,3]</code>:<a id="IDX-CHP-6-0051" class="indexterm"/><a id="IDX-CHP-6-0052" class="indexterm"/></p><a id="I_programlisting6_d1e9036"/><pre class="programlisting">foldl (+) 0 [1,2,3] =
foldl (+) (0 + 1) [2,3] =
foldl (+) ((0 + 1) + 2) [3] =
foldl (+) (((0 + 1) + 2) + 3) [] =
((0 + 1) + 2) + 3 =
(1 + 2) + 3 =
3 + 3 =
6</pre><p>As you can see, it first builds up a big stack of deferred computations. Then, once it reaches the empty list, it goes about actually evaluating those deferred computations. This isn’t a problem for small lists, but for large lists that contain upward of a million elements, you get a stack overflow, because evaluating all these deferred computations is done recursively. Wouldn’t it be nice if there was a function named, say, <code class="literal">foldl'</code>, that didn’t defer computations? It would work like this:</p><a id="I_programlisting6_d1e9043"/><pre class="programlisting">foldl' (+) 0 [1,2,3] =
foldl' (+) 1 [2,3] =
foldl' (+) 3 [3] =
foldl' (+) 6 [] =
6</pre><p>Computations wouldn’t be deferred between steps of <code class="literal">foldl</code>, but would get evaluated immediately. Well, we’re in luck, because <code class="literal">Data.List</code> offers this stricter version of <code class="literal">foldl</code>, and it is indeed called <code class="literal">foldl'</code>. Let’s try to compute the sum of a million <code class="literal">1</code>s with <code class="literal">foldl'</code>:</p><a id="I_programlisting6_d1e9067"/><pre class="programlisting">ghci&gt; foldl' (+) 0 (replicate 1000000 1)
1000000</pre><p>Great success! So, if you get stack overflow errors when using <code class="literal">foldl</code>, try switching to <code class="literal">foldl'</code>. There’s also a stricter version of <code class="literal">foldl1</code>, named <code class="literal">foldl1'</code>.</p></div><div class="sect2" title="Let's Find Some Cool Numbers"><div class="titlepage"><div><div><h2 class="title"><a id="let_apostrophy_s_find_some_cool_numbers"/>Let's Find Some Cool Numbers</h2></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e9087"/><img src="httpatomoreillycomsourcenostarchimages802580.png.jpg" alt="image with no caption"/></div></div><p>You’re walking along the street, and an old lady comes up to you and says, “Excuse me, what’s the first natural number such that the sum of its digits equals 40?”</p><p>Well, what now, hotshot? Let’s use some Has-kell magic to find such a number. For instance, if we sum the digits of the number 123, we get 6, because 1 + 2 + 3 equals 6. So, what is the first number that has such a property that its digits add up to 40?</p><p>First, let’s make a function that takes a number and tells us the sum of its digits. We’re going to use a cool trick here. First, we’ll convert our number to a string by using the <code class="literal">show</code> function. Once we have a string, we’ll turn each character in that string into a number and then just sum that list of numbers. To turn a character into a number, we’ll use a handy function from <code class="literal">Data.Char</code> called <code class="literal">digitToInt</code>. It takes a <code class="literal">Char</code> and returns an <code class="literal">Int</code>:<a id="IDX-CHP-6-0053" class="indexterm"/><a id="IDX-CHP-6-0054" class="indexterm"/><a id="IDX-CHP-6-0055" class="indexterm"/><a id="IDX-CHP-6-0056" class="indexterm"/><a id="IDX-CHP-6-0057" class="indexterm"/></p><a id="I_programlisting6_d1e9133"/><pre class="programlisting">ghci&gt; digitToInt '2'
2
ghci&gt; digitToInt 'F'
15
ghci&gt; digitToInt 'z'
*** Exception: Char.digitToInt: not a digit 'z'</pre><p>It works on the characters in the range from <code class="literal">'0'</code> to <code class="literal">'9'</code> and from <code class="literal">'A'</code> to <code class="literal">'F'</code> (they can also be in lowercase).<a id="IDX-CHP-6-0058" class="indexterm"/></p><p>Here’s our function that takes a number and returns the sum of its digits:</p><a id="I_programlisting6_d1e9154"/><pre class="programlisting">import Data.Char
import Data.List

digitSum :: Int -&gt; Int
digitSum = sum . map digitToInt . show</pre><p>We convert it to a string, map <code class="literal">digitToInt</code> over that string, and then sum the resulting list of numbers.</p><p>Now we need to find the first natural number such that when we apply <code class="literal">digitSum</code> to it, we get <code class="literal">40</code> as the result. To do that, we’ll use the <code class="literal">find</code> function, which resides in <code class="literal">Data.List</code>. It takes a predicate and a list and returns the first element of the list that matches the predicate. However, it has a rather peculiar type declaration:</p><a id="I_programlisting6_d1e9176"/><pre class="programlisting">ghci&gt; :t find
find :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e9179"/><img src="httpatomoreillycomsourcenostarchimages802582.png.jpg" alt="image with no caption"/></div></div><p>The first parameter is a predicate, and the second parameter is a list—no big deal here. But what about the return value? It says <code class="literal">Maybe a</code>. That’s a type you haven’t met before. A value with a type of <code class="literal">Maybe a</code> is sort of like a list of type <code class="literal">[a]</code>. Whereas a list can have zero, one, or many elements, a <code class="literal">Maybe a</code> typed value can have either zero elements or just one element. We use it when we want to represent possible failure. To make a value that holds nothing, we just use <code class="literal">Nothing</code>. This is analogous to the empty list. To construct a value that holds something, say the string <code class="literal">"hey"</code>, we write <code class="literal">Just "hey"</code>. Here’s a quick demonstration:</p><a id="I_programlisting6_d1e9208"/><pre class="programlisting">ghci&gt; Nothing
Nothing
ghci&gt; Just "hey"
Just "hey"
ghci&gt; Just 3
Just 3
ghci&gt; :t Just "hey"
Just "hey" :: Maybe [Char]
ghci&gt; :t Just True
Just True :: Maybe Bool</pre><p>As you can see, a value of <code class="literal">Just True</code> has a type of <code class="literal">Maybe Bool</code>, kind of like how a list that holds Booleans would have a type of <code class="literal">[Bool]</code>.</p><p>If <code class="literal">find</code> finds an element that satisfies the predicate, it will return that element wrapped in a <code class="literal">Just</code>. If it doesn’t, it will return a <code class="literal">Nothing</code>:</p><a id="I_programlisting6_d1e9232"/><pre class="programlisting">ghci&gt; find (&gt; 4) [3,4,5,6,7]
Just 5
ghci&gt; find odd [2,4,6,8,9]
Just 9
ghci&gt; find (=='z') "mjolnir"
Nothing</pre><p>Now let’s get back to making our function. We have our <code class="literal">digitSum</code> function and know how <code class="literal">find</code> works, so all that’s left to do is put these two together. Remember that we want to find the first number whose digits add up to 40.</p><a id="I_programlisting6_d1e9242"/><pre class="programlisting">firstTo40 :: Maybe Int
firstTo40 = find (\x -&gt; digitSum x == 40) [1..]</pre><p>We just take the infinite list <code class="literal">[1..]</code>, and then find the first number whose <code class="literal">digitSum</code> is 40.</p><a id="I_programlisting6_d1e9252"/><pre class="programlisting">ghci&gt; firstTo40
Just 49999</pre><p>There’s our answer! If we want to make a more general function that is not fixed on 40 but takes our desired sum as the parameter, we can change it like so:</p><a id="I_programlisting6_d1e9257"/><pre class="programlisting">firstTo :: Int -&gt; Maybe Int
firstTo n = find (\x -&gt; digitSum x == n) [1..]</pre><p>Here’s a quick test:<a id="IDX-CHP-6-0059" class="indexterm"/><a id="IDX-CHP-6-0060" class="indexterm"/></p><a id="I_programlisting6_d1e9269"/><pre class="programlisting">ghci&gt; firstTo 27
Just 999
ghci&gt; firstTo 1
Just 1
ghci&gt; firstTo 13
Just 49</pre></div></div>
<div class="sect1" title="Mapping Keys to Values"><div class="titlepage"><div><div><h1 class="title"><a id="mapping_keys_to_values"/>Mapping Keys to Values</h1></div></div></div><p>When dealing with data in some sort of collection, we often don’t care if it’s in some kind of order; we just want to be able to access it by a certain key. For example, if we want to know who lives at a certain address, we want to look up the name based on the address. When doing such things, we say that we looked up our desired value (someone’s name) by some sort of key (that person’s address).</p><div class="sect2" title="Almost As Good: Association Lists"><div class="titlepage"><div><div><h2 class="title"><a id="almost_as_good_colon_association_lists"/>Almost As Good: Association Lists</h2></div></div></div><p>There are many ways to achieve key/value mappings. One of them is the <span class="emphasis"><em>association list</em></span>. Association lists (also called <span class="emphasis"><em>dictionaries</em></span>) are lists that are used to store key/value pairs where ordering doesn’t matter. For instance, we might use an association list to store phone numbers, where phone numbers would be the values and people’s names would be the keys. We don’t care in which order they’re stored; we just want to get the right phone number for the right person.<a id="IDX-CHP-6-0061" class="indexterm"/><a id="IDX-CHP-6-0062" class="indexterm"/></p><p>The most obvious way to represent association lists in Haskell would be by having a list of pairs. The first component in the pair would be the key, and the second component would be the value. Here’s an example of an association list with phone numbers:</p><a id="I_programlisting6_d1e9295"/><pre class="programlisting">phoneBook =
    [("betty", "555-2938")
    ,("bonnie", "452-2928")
    ,("patsy", "493-2928")
    ,("lucille", "205-2928")
    ,("wendy", "939-8282")
    ,("penny", "853-2492")
    ]</pre><p>Despite this seemingly odd indentation, this is just a list of pairs of strings.</p><p>The most common task when dealing with association lists is looking up some value by key. Let’s make a function that looks up some value given a key.</p><a id="I_programlisting6_d1e9301"/><pre class="programlisting">findKey :: (Eq k) =&gt; k -&gt; [(k, v)] -&gt; v
findKey key xs = snd . head . filter (\(k, v) -&gt; key == k) $ xs</pre><p>This is pretty simple. The function takes a key and a list, filters the list so that only matching keys remain, gets the first key/value pair that matches, and returns the value.<a id="IDX-CHP-6-0063" class="indexterm"/><a id="IDX-CHP-6-0064" class="indexterm"/><a id="IDX-CHP-6-0065" class="indexterm"/><a id="IDX-CHP-6-0066" class="indexterm"/><a id="IDX-CHP-6-0067" class="indexterm"/></p><p>But what happens if the key we’re looking for isn’t in the association list? Hmm. Here, if a key isn’t in the association list, we’ll end up trying to get the head of an empty list, which throws a runtime error. We should avoid making our programs so easy to crash, so let’s use the <code class="literal">Maybe</code> data type. If we don’t find the key, we’ll return a <code class="literal">Nothing</code>. If we find it, we’ll return <code class="literal">Just</code> <em class="replaceable"><code>something</code></em>, where <em class="replaceable"><code>something</code></em> is the value corresponding to that key.</p><a id="I_programlisting6_d1e9343"/><pre class="programlisting">findKey :: (Eq k) =&gt; k -&gt; [(k, v)] -&gt; Maybe v
findKey key [] = Nothing
findKey key ((k,v):xs)
    | key == x  = Just v
    | otherwise = findKey key xs</pre><p>Look at the type declaration. It takes a key that can be equated and an association list, and then it maybe produces a value. Sounds about right.</p><p>This is a textbook recursive function that operates on a list. Base case, splitting a list into a head and a tail, recursive calls—they’re all there. This is the classic fold pattern, so let’s see how this would be implemented as a fold.</p><a id="I_programlisting6_d1e9350"/><pre class="programlisting">findKey :: (Eq k) =&gt; k -&gt; [(k, v)] -&gt; Maybe v
findKey key xs = foldr (\(k, v) acc -&gt; if key == k then Just v else acc) Nothing xs</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>It’s usually better to use folds for this standard list recursion pattern, rather than explicitly writing the recursion, because they’re easier to read and identify. Everyone knows it’s a fold when they see the <code class="literal">foldr</code> call, but it takes some more thinking to read explicit recursion.</p></div><a id="I_programlisting6_d1e9358"/><pre class="programlisting">ghci&gt; findKey "penny" phoneBook
Just "853-2492"
ghci&gt; findKey "betty" phoneBook
Just "555-2938"
ghci&gt; findKey "wilma" phoneBook
Nothing</pre><p>This works like a charm! If we have the girl’s phone number, we <code class="literal">Just</code> get the number; otherwise, we get <code class="literal">Nothing</code>.</p></div><div class="sect2" title="Enter Data.Map"><div class="titlepage"><div><div><h2 class="title"><a id="enter_data.map"/>Enter Data.Map</h2></div></div></div><p>We just implemented the <code class="literal">lookup</code> function from <code class="literal">Data.List</code>. If we want the value that corresponds to a key, we need to traverse all the elements of the list until we find it.<a id="IDX-CHP-6-0068" class="indexterm"/><a id="IDX-CHP-6-0069" class="indexterm"/><a id="IDX-CHP-6-0070" class="indexterm"/><a id="IDX-CHP-6-0071" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e9398"/><img src="httpatomoreillycomsourcenostarchimages802584.png.jpg" alt="image with no caption"/></div></div><p>It turns out that the <code class="literal">Data.Map</code> module offers association lists that are much faster, and it also provides a lot of utility functions. From now on, we’ll say we’re working with <span class="emphasis"><em>maps</em></span> instead of association lists.</p><p>Because <code class="literal">Data.Map</code> exports functions that clash with the <code class="literal">Prelude</code> and <code class="literal">Data.List</code> ones, we’ll do a qualified import.</p><a id="I_programlisting6_d1e9422"/><pre class="programlisting">import qualified Data.Map as Map</pre><p>Put this <code class="literal">import</code> statement into a script, and then load the script via GHCi.</p><p>We’re going to turn an association list into a map by using the <code class="literal">fromList</code> function from <code class="literal">Data.Map</code>. <code class="literal">fromList</code> takes an association list (in the form of a list) and returns a map with the same associations. Let’s play around a bit with <code class="literal">fromList</code> first:</p><a id="I_programlisting6_d1e9443"/><pre class="programlisting">ghci&gt; Map.fromList [(3,"shoes"),(4,"trees"),(9,"bees")]
fromList [(3,"shoes"),(4,"trees"),(9,"bees")]
ghci&gt; Map.fromList [("kima","greggs"),("jimmy","mcnulty"),("jay","landsman")]
fromList [("jay","landsman"),("jimmy","mcnulty"),("kima","greggs")]</pre><p>When a map from <code class="literal">Data.Map</code> is displayed on the terminal, it’s shown as <code class="literal">fromList</code> and then an association list that represents the map, even though it’s not a list anymore.</p><p>If there are duplicate keys in the original association list, the duplicates are just discarded:</p><a id="I_programlisting6_d1e9456"/><pre class="programlisting">ghci&gt; Map.fromList [("MS",1),("MS",2),("MS",3)]
fromList [("MS",3)]</pre><p>This is the type signature of <code class="literal">fromList</code>:</p><a id="I_programlisting6_d1e9463"/><pre class="programlisting">Map.fromList :: (Ord k) =&gt; [(k, v)] -&gt; Map.Map k v</pre><p>It says that it takes a list of pairs of type <code class="literal">k</code> and <code class="literal">v</code>, and returns a map that maps from keys of type <code class="literal">k</code> to values of type <code class="literal">v</code>. Notice that when we were doing association lists with normal lists, the keys only needed to be equatable (their type belonging to the <code class="literal">Eq</code> type class), but now they must be orderable. That’s an essential constraint in the <code class="literal">Data.Map</code> module. It needs the keys to be orderable so it can arrange and access them more efficiently.</p><p>Now we can modify our original <code class="literal">phoneBook</code> association list to be a map. We’ll also add a type declaration, just because we can:<a id="IDX-CHP-6-0072" class="indexterm"/><a id="IDX-CHP-6-0073" class="indexterm"/><a id="IDX-CHP-6-0074" class="indexterm"/></p><a id="I_programlisting6_d1e9504"/><pre class="programlisting">import qualified Data.Map as Map

phoneBook :: Map.Map String String
phoneBook = Map.fromList $
    [("betty", "555-2938")
    ,("bonnie", "452-2928")
    ,("patsy", "493-2928")
    ,("lucille", "205-2928")
    ,("wendy", "939-8282")
    ,("penny", "853-2492")
    ]</pre><p>Cool! Let’s load this script into GHCi and play around with our <code class="literal">phoneBook</code>. First, we’ll use <code class="literal">lookup</code> to search for some phone numbers. <code class="literal">lookup</code> takes a key and a map, and tries to find the corresponding value in the map. If it succeeds, it returns the value wrapped in a <code class="literal">Just</code>; otherwise, it returns a <code class="literal">Nothing</code>:</p><a id="I_programlisting6_d1e9523"/><pre class="programlisting">ghci&gt; :t Map.lookup
Map.lookup :: (Ord k) =&gt; k -&gt; Map.Map k a -&gt; Maybe a
ghci&gt; Map.lookup "betty" phoneBook
Just "555-2938"
ghci&gt; Map.lookup "wendy" phoneBook
Just "939-8282"
ghci&gt; Map.lookup "grace" phoneBook
Nothing</pre><p>For our next trick, we’ll make a new map from <code class="literal">phoneBook</code> by inserting a number. <code class="literal">insert</code> takes a key, a value, and a map, and returns a new map that’s just like the old one, but with the key and value inserted:</p><a id="I_programlisting6_d1e9533"/><pre class="programlisting">ghci&gt; :t Map.insert
Map.insert :: (Ord k) =&gt; k -&gt; a -&gt; Map.Map k a -&gt; Map.Map k a
ghci&gt; Map.lookup "grace" phoneBook
Nothing
ghci&gt; let newBook = Map.insert "grace" "341-9021" phoneBook
ghci&gt; Map.lookup "grace" newBook
Just "341-9021"</pre><p>Let’s check how many numbers we have. We’ll use the <code class="literal">size</code> function from <code class="literal">Data.Map</code>, which takes a map and returns its size. This is pretty straightforward:</p><a id="I_programlisting6_d1e9544"/><pre class="programlisting">ghci&gt; :t Map.size
Map.size :: Map.Map k a -&gt; Int
ghci&gt; Map.size phoneBook
6
ghci&gt; Map.size newBook
7</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e9547"/><img src="httpatomoreillycomsourcenostarchimages802586.png.jpg" alt="image with no caption"/></div></div><p>The numbers in our phone book are represented as strings. Suppose we would rather use lists of <code class="literal">Int</code>s to represent phone numbers. So, instead of having a number like <code class="literal">"939-8282"</code>, we want to have <code class="literal">[9,3,9,8,2,8,2]</code>. First, we’re going to make a function that converts a phone number string to a list of <code class="literal">Int</code>s. We can try to map <code class="literal">digitToInt</code> from <code class="literal">Data.Char</code> over our string, but it won’t know what to do with the dash! That’s why we need to get rid of anything in that string that isn’t a number. To do this, we’ll seek help from the <code class="literal">isDigit</code> function from <code class="literal">Data.Char</code>, which takes a character and tells us if it represents a digit. Once we’ve filtered our string, we’ll just map <code class="literal">digitToInt</code> over it.</p><a id="I_programlisting6_d1e9582"/><pre class="programlisting">string2digits :: String -&gt; [Int]
string2digits = map digitToInt . filter isDigit</pre><p>Oh, be sure to <code class="literal">import Data.Char</code>, if you haven’t already.</p><p>Let’s try this out:</p><a id="I_programlisting6_d1e9591"/><pre class="programlisting">ghci&gt; string2digits "948-9282"
[9,4,8,9,2,8,2]</pre><p>Very cool! Now, let’s use the <code class="literal">map</code> function from <code class="literal">Data.Map</code> to map <code class="literal">string2digits</code> over our <code class="literal">phoneBook</code>:</p><a id="I_programlisting6_d1e9607"/><pre class="programlisting">ghci&gt; let intBook = Map.map string2digits phoneBook
ghci&gt; :t intBook
intBook :: Map.Map String [Int]
ghci&gt; Map.lookup "betty" intBook
Just [5,5,5,2,9,3,8]</pre><p>The <code class="literal">map</code> from <code class="literal">Data.Map</code> takes a function and a map, and applies that function to each value in the map.</p><p>Let’s extend our phone book. Say that a person can have several numbers, and we have an association list set up like this:</p><a id="I_programlisting6_d1e9620"/><pre class="programlisting">phoneBook =
    [("betty", "555-2938")
    ,("betty", "342-2492")
    ,("bonnie", "452-2928")
    ,("patsy", "493-2928")
    ,("patsy", "943-2929")
    ,("patsy", "827-9162")
    ,("lucille", "205-2928")
    ,("wendy", "939-8282")
    ,("penny", "853-2492")
    ,("penny", "555-2111")
    ]</pre><p>If we just use <code class="literal">fromList</code> to put that into a map, we’ll lose a few numbers! Instead, we’ll use another function found in <code class="literal">Data.Map</code>: <code class="literal">fromListWith</code>. This function acts like <code class="literal">fromList</code>, but instead of discarding duplicate keys, it uses a function supplied to it to decide what to do with them.<a id="IDX-CHP-6-0075" class="indexterm"/><a id="IDX-CHP-6-0076" class="indexterm"/></p><a id="I_programlisting6_d1e9644"/><pre class="programlisting">phoneBookToMap :: (Ord k) =&gt; [(k, String)] -&gt; Map.Map k String
phoneBookToMap xs = Map.fromListWith add xs
    where add number1 number2 = number1 ++ ", " ++ number2</pre><p>If <code class="literal">fromListWith</code> finds that the key is already there, it uses the function supplied to it to join those two values into one and replaces the old value with the one it got by passing the conflicting values to the function:</p><a id="I_programlisting6_d1e9651"/><pre class="programlisting">ghci&gt; Map.lookup "patsy" $ phoneBookToMap phoneBook
"827-9162, 943-2929, 493-2928"
ghci&gt; Map.lookup "wendy" $ phoneBookToMap phoneBook
"939-8282"
ghci&gt; Map.lookup "betty" $ phoneBookToMap phoneBook
"342-2492, 555-2938"</pre><p>We could also first make all the values in the association list singleton lists and then use <code class="literal">++</code> to combine the numbers:</p><a id="I_programlisting6_d1e9658"/><pre class="programlisting">phoneBookToMap :: (Ord k) =&gt; [(k, a)] -&gt; Map.Map k [a]
phoneBookToMap xs = Map.fromListWith (++) $ map (\(k, v) -&gt; (k, [v])) xs</pre><p>Let’s test this in GHCi:</p><a id="I_programlisting6_d1e9662"/><pre class="programlisting">ghci&gt; Map.lookup "patsy" $ phoneBookToMap phoneBook
["827-9162","943-2929","493-2928"]</pre><p>Pretty neat!</p><p>Now suppose we’re making a map from an association list of numbers, and when a duplicate key is found, we want the biggest value for the key to be kept. We can do that like so:</p><a id="I_programlisting6_d1e9669"/><pre class="programlisting">ghci&gt; Map.fromListWith max [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]
fromList [(2,100),(3,29),(4,22)]</pre><p>Or we could choose to add together values that share keys:<a id="IDX-CHP-6-0077" class="indexterm"/><a id="IDX-CHP-6-0078" class="indexterm"/><a id="IDX-CHP-6-0079" class="indexterm"/><a id="IDX-CHP-6-0080" class="indexterm"/><a id="IDX-CHP-6-0081" class="indexterm"/><a id="IDX-CHP-6-0082" class="indexterm"/></p><a id="I_programlisting6_d1e9697"/><pre class="programlisting">ghci&gt; Map.fromListWith (+) [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]
fromList [(2,108),(3,62),(4,37)]</pre><p>So, you’ve seen that <code class="literal">Data.Map</code> and the other modules provided by Haskell are pretty cool. Next, we’ll look at how to make your own module.</p></div></div>
<div class="sect1" title="Making Our Own Modules"><div class="titlepage"><div><div><h1 class="title"><a id="making_our_own_modules"/>Making Our Own Modules</h1></div></div></div><p>As I said at the beginning of this chapter, when you’re writing programs, it’s good practice to take functions and types that work toward a similar purpose and put them in a separate module. That way, you can easily reuse those functions in other programs by just importing your module.<a id="IDX-CHP-6-0083" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e9715"/><img src="httpatomoreillycomsourcenostarchimages802588.png.jpg" alt="image with no caption"/></div></div><p>We say that a module <span class="emphasis"><em>exports</em></span> functions. When you import a module, you can use the functions that it exports. A module can also define functions that it uses internally, but we can see and use only the ones that it exports.</p><div class="sect2" title="A Geometry Module"><div class="titlepage"><div><div><h2 class="title"><a id="a_geometry_module"/>A Geometry Module</h2></div></div></div><p>To demonstrate, we’ll create a little module that provides some functions for calculating the volume and area of a few geometrical objects. We’ll start by creating a file called <span class="emphasis"><em>Geometry.hs</em></span>.</p><p>At the beginning of a module, we specify the module name. If we have a file called <span class="emphasis"><em>Geometry.hs</em></span>, then we should name our module <code class="literal">Geometry</code>. We specify the functions that it exports, and then we can add the functions. So we’ll start with this:</p><a id="I_programlisting6_d1e9741"/><pre class="programlisting">module Geometry
( sphereVolume
, sphereArea
, cubeVolume
, cubeArea
, cuboidArea
, cuboidVolume
) where</pre><p>As you can see, we’ll be doing areas and volumes for spheres, cubes, and cuboids. A sphere is a round thing like a grapefruit, a cube is like a game die, and a (rectangular) cuboid is like a box of cigarettes. (Kids, don’t smoke!)</p><p>Now let’s define our functions:</p><a id="I_programlisting6_d1e9747"/><pre class="programlisting">module Geometry
( sphereVolume
, sphereArea
, cubeVolume
, cubeArea
, cuboidArea
, cuboidVolume
) where

sphereVolume :: Float -&gt; Float
sphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3)

sphereArea :: Float -&gt; Float
sphereArea radius = 4 * pi * (radius ^ 2)

cubeVolume :: Float -&gt; Float
cubeVolume side = cuboidVolume side side side

cubeArea :: Float -&gt; Float
cubeArea side = cuboidArea side side side

cuboidVolume :: Float -&gt; Float -&gt; Float -&gt; Float
cuboidVolume a b c = rectArea a b * c

cuboidArea :: Float -&gt; Float -&gt; Float -&gt; Float
cuboidArea a b c = rectArea a b * 2 + rectArea a c * 2 +
rectArea c b * 2

rectArea :: Float -&gt; Float -&gt; Float
rectArea a b = a * b</pre><p>This is pretty standard geometry, but there are a few items to note. One is that because a cube is only a special case of a cuboid, we define its area and volume by treating it as a cuboid whose sides are all of the same length. We also define a helper function called <code class="literal">rectArea</code>, which calculates a rectangle’s area based on the lengths of its sides. It’s rather trivial because it’s just multiplication. Notice that we used it in our functions in the module (in <code class="literal">cuboidArea</code> and <code class="literal">cuboidVolume</code>), but we didn’t export it! This is because we want our module to present just functions for dealing with three-dimensional objects.</p><p>When making a module, we usually export only those functions that act as a sort of interface to our module so that the implementation is hidden. People who use our <code class="literal">Geometry</code> module don’t need to concern themselves with functions that we don’t export. We can decide to change those functions completely or delete them in a newer version (we could delete <code class="literal">rectArea</code> and just use <code class="literal">*</code> instead), and no one will mind, because we didn’t export them in the first place.<a id="IDX-CHP-6-0084" class="indexterm"/><a id="IDX-CHP-6-0085" class="indexterm"/></p><p>To use our module, we just do this:</p><a id="I_programlisting6_d1e9779"/><pre class="programlisting">import Geometry</pre><p>However, <span class="emphasis"><em>Geometry.hs</em></span> must be in the same folder as the module that’s importing it.</p></div><div class="sect2" title="Hierarchical Modules"><div class="titlepage"><div><div><h2 class="title"><a id="hierarchical_modules"/>Hierarchical Modules</h2></div></div></div><p>Modules can also be given a hierarchical structure. Each module can have a number of submodules, which can have submodules of their own. Let’s section our geometry functions so that <code class="literal">Geometry</code> is a module that has three submodules: one for each type of object.<a id="IDX-CHP-6-0086" class="indexterm"/></p><p>First, we’ll make a folder called <span class="emphasis"><em>Geometry</em></span>. In it, we’ll place three files: <span class="emphasis"><em>Sphere.hs</em></span>, <span class="emphasis"><em>Cuboid.hs</em></span>, and <span class="emphasis"><em>Cube.hs</em></span>. Let’s look at what each of the files contains.</p><p>Here are the contents of <span class="emphasis"><em>Sphere.hs</em></span>:</p><a id="I_programlisting6_d1e9819"/><pre class="programlisting">module Geometry.Sphere
( volume
, area
) where

volume :: Float -&gt; Float
volume radius = (4.0 / 3.0) * pi * (radius ^ 3)

area :: Float -&gt; Float
area radius = 4 * pi * (radius ^ 2)</pre><p>The <span class="emphasis"><em>Cuboid.hs</em></span> file looks like this:</p><a id="I_programlisting6_d1e9826"/><pre class="programlisting">module Geometry.Cuboid
( volume
, area
) where

volume :: Float -&gt; Float -&gt; Float -&gt; Float
volume a b c = rectArea a b * c

area :: Float -&gt; Float -&gt; Float -&gt; Float
area a b c = rectArea a b * 2 + rectArea a c * 2 + rectArea c b * 2

rectArea :: Float -&gt; Float -&gt; Float
rectArea a b = a * b</pre><p>And our last file, <span class="emphasis"><em>Cube.hs</em></span>, has these contents:<a id="IDX-CHP-6-0087" class="indexterm"/></p><a id="I_programlisting6_d1e9836"/><pre class="programlisting">module Geometry.Cube
( volume
, area
) where

import qualified Geometry.Cuboid as Cuboid

volume :: Float -&gt; Float
volume side = Cuboid.volume side side side

area :: Float -&gt; Float
area side = Cuboid.area side side side</pre><p>Notice how we placed <span class="emphasis"><em>Sphere.hs</em></span> in a folder called <span class="emphasis"><em>Geometry</em></span>, and then defined the module name as <code class="literal">Geometry.Sphere</code>. We did the same for the cube and cuboid objects. Also notice how in all three sub-modules, we defined functions with the same names. We can do this because they’re in separate modules.</p><p>So, now we can do this:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e9853"/><img src="httpatomoreillycomsourcenostarchimages802590.png.jpg" alt="image with no caption"/></div></div><a id="I_programlisting6_d1e9858"/><pre class="programlisting">import Geometry.Sphere</pre><p>And then we can call <code class="literal">area</code> and <code class="literal">volume</code>, and they’ll give us the area and volume for a sphere.</p><p>If we want to juggle two or more of these modules, we need to do qualified imports because they export functions with the same names. Here’s an example:</p><a id="I_programlisting6_d1e9870"/><pre class="programlisting">import qualified Geometry.Sphere as Sphere
import qualified Geometry.Cuboid as Cuboid
import qualified Geometry.Cube as Cube</pre><p>And then we can call <code class="literal">Sphere.area</code>, <code class="literal">Sphere.volume</code>, <code class="literal">Cuboid.area</code>, and so on, and each will calculate the area or volume for its corresponding object.</p><p>The next time you find yourself writing a file that’s really big and has a lot of functions, look for functions that serve some common purpose and consider putting them in their own module. Then you’ll be able to just import your module the next time you’re writing a program that requires some of the same functionality.</p></div></div></body></html>