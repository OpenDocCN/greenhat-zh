<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Case Study: Intelligent Platform Management Interface Driver"><div class="titlepage"><div><div><h1 class="title"><a id="case_study_colon_intelligent_platform_ma"/>Chapter 11. Case Study: Intelligent Platform Management Interface Driver</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id11"/><div class="mediaobject"><a id="I_mediaobject11_d1e20078"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1137497.png.jpg"/></div></div><p>This chapter examines parts of <code class="literal">ipmi(4)</code>, the Intelligent Platform Management Interface (IPMI) driver. The IPMI specification defines a standard for monitoring and managing system hardware.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>For our purposes, this description of IPMI is sufficient, as the point of this chapter is to demonstrate how PCI drivers such as <code class="literal">ipmi(4)</code> employ PMIO and MMIO.</p></div><p>The code base for <code class="literal">ipmi(4)</code> is composed of 10 source files and 1 header file. In this chapter, we’ll walk through one of these files, <span class="emphasis"><em>ipmi_pci.c</em></span>, which contains code that’s related to the PCI bus.</p><div class="sect1" title="Code Analysis"><div class="titlepage"><div><div><h1 class="title"><a id="code_analysis-id2"/>Code Analysis</h1></div></div></div><p><a class="xref" href="ch11.html#ipmi_underscore_pci.c" title="Example 11-1. ipmi_pci.c">Example 11-1</a> provides a terse, source-level overview of <span class="emphasis"><em>ipmi_pci.c</em></span>.</p><div class="example"><a id="ipmi_underscore_pci.c"/><p class="title">Example 11-1. ipmi_pci.c</p><div class="example-contents"><pre class="programlisting">#include &lt;sys/param.h&gt;
  #include &lt;sys/module.h&gt;
  #include &lt;sys/kernel.h&gt;
  #include &lt;sys/systm.h&gt;

  #include &lt;sys/bus.h&gt;
  #include &lt;sys/condvar.h&gt;
  #include &lt;sys/eventhandler.h&gt;
  #include &lt;sys/selinfo.h&gt;

  #include &lt;machine/bus.h&gt;
  #include &lt;sys/rman.h&gt;
  #include &lt;machine/resource.h&gt;

  #include &lt;dev/pci/pcireg.h&gt;
  #include &lt;dev/pci/pcivar.h&gt;

  #include &lt;dev/ipmi/ipmivars.h&gt;

  static struct ipmi_ident {
          u_int16_t       vendor;
          u_int16_t       device;
          char            *description;
  } ipmi_identifiers[] = {
          { 0x1028, 0x000d, "Dell PE2650 SMIC interface" },
          { 0, 0, 0 }
  };

  const char *
  ipmi_pci_match(uint16_t vendor, uint16_t device)
  {
  ...
  }

  static int
  ipmi_pci_probe(device_t dev)
  {
  ...
  }

  static int
  ipmi_pci_attach(device_t dev)
  {
  ...
  }

  static device_method_t ipmi_methods[] = {
          /* Device interface. */
          DEVMETHOD(device_probe,         ipmi_pci_probe),
          DEVMETHOD(device_attach,        ipmi_pci_attach),
          DEVMETHOD(device_detach,        ipmi_detach),
          { 0, 0 }
  };

  static driver_t ipmi_pci_driver = {
          "ipmi",
          ipmi_methods,
          sizeof(struct ipmi_softc)
  };

<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/> DRIVER_MODULE(ipmi_pci, pci, ipmi_pci_driver, ipmi_devclass, 0, 0);


  static int
  ipmi2_pci_probe(device_t dev)
  {
  ...
  }

  static int
  ipmi2_pci_attach(device_t dev)
  {
  ...
  }

  static device_method_t ipmi2_methods[] = {
          /* Device interface. */
          DEVMETHOD(device_probe,         ipmi2_pci_probe),
          DEVMETHOD(device_attach,        ipmi2_pci_attach),
          DEVMETHOD(device_detach,        ipmi_detach),
          { 0, 0 }
  };

  static driver_t ipmi2_pci_driver = {
          "ipmi",
          ipmi2_methods,
          sizeof(struct ipmi_softc)
  };

<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/> DRIVER_MODULE(ipmi2_pci, pci, ipmi2_pci_driver, ipmi_devclass, 0, 0);</pre></div></div><p>Before I describe the functions in <a class="xref" href="ch11.html#ipmi_underscore_pci.c" title="Example 11-1. ipmi_pci.c">Example 11-1</a>, note that it contains two <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20132"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20138"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">DRIVER_MODULE</code> calls. In other words, <a class="xref" href="ch11.html#ipmi_underscore_pci.c" title="Example 11-1. ipmi_pci.c">Example 11-1</a> declares two Newbus drivers; each designed to handle a distinct group of devices (as you’ll soon see).<a class="indexterm" id="IDX-CHP-11-0001"/><a class="indexterm" id="IDX-CHP-11-0002"/></p><p>Now let’s discuss the functions found in <a class="xref" href="ch11.html#ipmi_underscore_pci.c" title="Example 11-1. ipmi_pci.c">Example 11-1</a>.</p><div class="sect2" title="ipmi_pci_probe Function"><div class="titlepage"><div><div><h2 class="title"><a id="ipmi_underscore_pci_underscore_probe_fun"/>ipmi_pci_probe Function</h2></div></div></div><p>The <code class="literal">ipmi_pci_probe</code> function is the <code class="literal">device_probe</code> implementation for the first Newbus driver found in <a class="xref" href="ch11.html#ipmi_underscore_pci.c" title="Example 11-1. ipmi_pci.c">Example 11-1</a>. Here is its function definition:</p><a id="I_programlisting11_d1e20175"/><pre class="programlisting">static int
ipmi_pci_probe(device_t <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>dev)
{
        const char *desc;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>if (ipmi_attached)
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>return (ENXIO);

        desc = <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>ipmi_pci_match(pci_get_vendor(dev), pci_get_device(dev));
        if (desc != NULL) {
                device_set_desc(dev, desc);
                return (BUS_PROBE_DEFAULT);
        }

        return (ENXIO);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20203"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> checks the value of the global variable <code class="literal">ipmi_attached</code>. If it is nonzero, which signifies that <code class="literal">ipmi(4)</code> is currently in use, the error code <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20215"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">ENXIO</code> is returned; otherwise, <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20225"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">ipmi_pci_match</code> is called to determine whether this driver can handle <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20234"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">dev</code>.<a class="indexterm" id="IDX-CHP-11-0003"/><a class="indexterm" id="IDX-CHP-11-0004"/><a class="indexterm" id="IDX-CHP-11-0005"/><a class="indexterm" id="IDX-CHP-11-0006"/></p></div><div class="sect2" title="ipmi_pci_match Function"><div class="titlepage"><div><div><h2 class="title"><a id="ipmi_underscore_pci_underscore_match_fun"/>ipmi_pci_match Function</h2></div></div></div><p>The <code class="literal">ipmi_pci_match</code> function takes in a PCI Vendor ID/Device ID (VID/DID) pair and verifies whether it recognizes those IDs. Before I define (and subsequently walk through) this function, a description of the <code class="literal">ipmi_identifiers</code> array is needed. This array is defined near the beginning of <a class="xref" href="ch11.html#ipmi_underscore_pci.c" title="Example 11-1. ipmi_pci.c">Example 11-1</a> like so:</p><a id="I_programlisting11_d1e20271"/><pre class="programlisting">static struct ipmi_ident {
        <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>u_int16_t       vendor;
        <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>u_int16_t       device;
        <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>char            *description;
} ipmi_identifiers[] = {
        { 0x1028, 0x000d, "Dell PE2650 SMIC interface" },
        { 0, 0, 0 }
};</pre><p>As you can see, the <code class="literal">ipmi_identifiers</code> array is composed of <code class="literal">ipmi_ident</code> structures. Each <code class="literal">ipmi_ident</code> structure includes a <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20302"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20308"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> VID/DID pair and a <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20315"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> description of the PCI device. As you may have guessed, <code class="literal">ipmi_identifiers</code> lists the devices that the first Newbus driver in <a class="xref" href="ch11.html#ipmi_underscore_pci.c" title="Example 11-1. ipmi_pci.c">Example 11-1</a> supports.</p><p>Now that we’ve discussed <code class="literal">ipmi_identifiers</code>, let’s walk through <code class="literal">ipmi_pci_match</code>.</p><a id="I_programlisting11_d1e20334"/><pre class="programlisting">const char *
ipmi_pci_match(uint16_t vendor, uint16_t device)
{
        struct ipmi_ident *m;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>for (m = ipmi_identifiers; m-&gt;vendor != 0; m++)
                <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>if (m-&gt;vendor == vendor &amp;&amp; m-&gt;device == device)
                        <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>return (m-&gt;description);

        return (NULL);
}</pre><p>This function determines whether a specific <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20356"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> VID/DID pair is listed in <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20362"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">ipmi_identifiers</code>. If so, its <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20371"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> description is returned.</p></div><div class="sect2" title="ipmi_pci_attach Function"><div class="titlepage"><div><div><h2 class="title"><a id="ipmi_underscore_pci_underscore_attach_fu"/>ipmi_pci_attach Function</h2></div></div></div><p>The <code class="literal">ipmi_pci_attach</code> function is the <code class="literal">device_attach</code> implementation for the first Newbus driver found in <a class="xref" href="ch11.html#ipmi_underscore_pci.c" title="Example 11-1. ipmi_pci.c">Example 11-1</a>. Here is its function definition:<a class="indexterm" id="IDX-CHP-11-0007"/><a class="indexterm" id="IDX-CHP-11-0008"/></p><a id="I_programlisting11_d1e20398"/><pre class="programlisting">static int
ipmi_pci_attach(device_t dev)
{
        struct ipmi_softc *sc = device_get_softc(dev);
        struct ipmi_get_info info;
        const char *mode;
        int error, type;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (!ipmi_smbios_identify(&amp;info))
                return (ENXIO);

        sc-&gt;ipmi_dev = dev;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>switch (info.iface_type) {
        case KCS_MODE:
                mode = "KCS";
                break;
        case SMIC_MODE:
                mode = "SMIC";
                break;
        case BT_MODE:
                device_printf(dev, "BT mode is unsupported\n");
                return (ENXIO);
        default:
                device_printf(dev, "No IPMI interface found\n");
                return (ENXIO);
        }

        device_printf(dev,
            "%s mode found at %s 0x%jx alignment 0x%x on %s\n",
            mode,
            info.io_mode ? "I/O port" : "I/O memory",
            (uintmax_t)info.address,
            info.offset,
            device_get_name(device_get_parent(dev)));

        if (info.io_mode)
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>type = SYS_RES_IOPORT;
        else
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>type = SYS_RES_MEMORY;

        sc-&gt;ipmi_io_rid = <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>PCIR_BAR(0);
        sc-&gt;ipmi_io_res[0] = bus_alloc_resource_any(dev, type,
          <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>&amp;sc-&gt;ipmi_io_rid, RF_ACTIVE);
        sc-&gt;ipmi_io_type = type;
        sc-&gt;ipmi_io_spacing = info.offset;

        if (sc-&gt;ipmi_io_res[0] == NULL) {
                device_printf(dev, "could not configure PCI I/O resource\n");
                return (ENXIO);
        }

        sc-&gt;ipmi_irq_rid = 0;
        sc-&gt;ipmi_irq_res = <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>bus_alloc_resource_any(dev, SYS_RES_IRQ,
            &amp;sc-&gt;ipmi_irq_rid, RF_SHAREABLE | RF_ACTIVE);

        switch (info.iface_type) {
        case KCS_MODE:
                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>ipmi_kcs_attach(sc);
                if (error)
                        goto bad;
                break;
        case SMIC_MODE:
                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>ipmi_smic_attach(sc);
                if (error)
                        goto bad;
                break;
        }

        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>ipmi_attach(dev);
        if (error)
                goto bad;

        return (0);

bad:
        ipmi_release_resources(dev);
        return (error);
}</pre><p>This function begins by <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20463"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> retrieving the IPMI data structure stored in the computer’s <span class="emphasis"><em>System Management BIOS (SMBIOS)</em></span>, which is responsible for maintaining hardware configuration information.<a class="indexterm" id="IDX-CHP-11-0009"/><a class="indexterm" id="IDX-CHP-11-0010"/><a class="indexterm" id="IDX-CHP-11-0011"/><a class="indexterm" id="IDX-CHP-11-0012"/></p><p>Based on the SMBIOS data, <code class="literal">ipmi_pci_attach</code> determines <code class="literal">ipmi(4)</code>’s <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20492"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> mode of operation and whether it requires <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20498"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> I/O port or <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20504"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> I/O memory access. Currently, <code class="literal">ipmi(4)</code> supports only Keyboard Controller Style (KCS) and Server Management Interface Chip (SMIC) modes. These modes dictate how IPMI messages are transferred. For our purposes, you won’t need to understand the specifics of either mode.<a class="indexterm" id="IDX-CHP-11-0013"/></p><p>The next block of code acquires I/O region access for <code class="literal">ipmi(4)</code>. Before I describe this code, some background on PCI devices is needed. After bootup, PCI devices can remap their device registers to a different location, thus avoiding address conflicts with other devices. Because of this, PCI devices store the size and current location of their I/O-mapped registers in their base address registers (BARs). Thus, this block of code first calls <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20522"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">PCIR_BAR(0)</code> to get the address of the first BAR. Then it passes that address as the <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20531"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">rid</code> argument to <code class="literal">bus_alloc_resource_any</code>, thereby acquiring I/O access to the device’s registers.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>To be accurate, the <code class="literal">PCIR_BAR(x</code>) macro returns the RID of the <code class="literal">x</code>th BAR.<a class="indexterm" id="IDX-CHP-11-0014"/><a class="indexterm" id="IDX-CHP-11-0015"/><a class="indexterm" id="IDX-CHP-11-0016"/><a class="indexterm" id="IDX-CHP-11-0017"/><a class="indexterm" id="IDX-CHP-11-0018"/><a class="indexterm" id="IDX-CHP-11-0019"/></p></div><p>The remainder of <code class="literal">ipmi_pci_attach</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20580"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> acquires an IRQ, starts up <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20586"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> KCS or <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20592"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> SMIC mode, and calls <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20598"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> <code class="literal">ipmi_attach</code> to finish initializing the device.</p></div><div class="sect2" title="ipmi2_pci_probe Function"><div class="titlepage"><div><div><h2 class="title"><a id="ipmi2_underscore_pci_underscore_probe_fu"/>ipmi2_pci_probe Function</h2></div></div></div><p>The <code class="literal">ipmi2_pci_probe</code> function is the <code class="literal">device_probe</code> implementation for the second Newbus driver found in <a class="xref" href="ch11.html#ipmi_underscore_pci.c" title="Example 11-1. ipmi_pci.c">Example 11-1</a>. Here is its function definition:</p><a id="I_programlisting11_d1e20621"/><pre class="programlisting">static int
ipmi2_pci_probe(device_t dev)
{
        if (pci_get_class(dev) == PCIC_SERIALBUS &amp;&amp;
            pci_get_subclass(dev) == <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>PCIS_SERIALBUS_IPMI) {
                <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>device_set_desc(dev, "IPMI System Interface");
                <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>return (BUS_PROBE_GENERIC);
        }

        return (ENXIO);
}</pre><p>This function determines if <code class="literal">dev</code> is a <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20646"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> generic IPMI device on the PCI bus. If so, its verbose description is <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20652"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> set, and the success code <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20658"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">BUS_PROBE_GENERIC</code> is returned. In short, this driver handles any standard IPMI device on the PCI bus.</p><p>As you may have guessed, the first Newbus driver is a hack (that is to say, a workaround) for the Dell PE2650, because it does not adhere to the IPMI specification.</p></div><div class="sect2" title="ipmi2_pci_attach Function"><div class="titlepage"><div><div><h2 class="title"><a id="ipmi2_underscore_pci_underscore_attach_f"/>ipmi2_pci_attach Function</h2></div></div></div><p>The <code class="literal">ipmi2_pci_attach</code> function is the <code class="literal">device_attach</code> implementation for the second Newbus driver found in <a class="xref" href="ch11.html#ipmi_underscore_pci.c" title="Example 11-1. ipmi_pci.c">Example 11-1</a>. Here is its function definition:</p><a id="I_programlisting11_d1e20682"/><pre class="programlisting">static int
ipmi2_pci_attach(device_t dev)
{
        struct ipmi_softc *sc = device_get_softc(dev);
        int error, iface, type;

        sc-&gt;ipmi_dev = dev;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>switch (pci_get_progif(dev)) {
        case PCIP_SERIALBUS_IPMI_SMIC:
                iface = SMIC_MODE;
                break;
        case PCIP_SERIALBUS_IPMI_KCS:
                iface = KCS_MODE;
                break;
        case PCIP_SERIALBUS_IPMI_BT:
                device_printf(dev, "BT interface is unsupported\n");
                return (ENXIO);
        default:
                device_printf(dev, "unsupported interface: %d\n",
                    pci_get_progif(dev));
                return (ENXIO);
        }

        sc-&gt;ipmi_io_rid = <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>PCIR_BAR(0);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>if (PCI_BAR_IO(pci_read_config(dev, PCIR_BAR(0), 4)))
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>type = SYS_RES_IOPORT;
        else
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>type = SYS_RES_MEMORY;
        sc-&gt;ipmi_io_type = type;
        sc-&gt;ipmi_io_spacing = 1;
        sc-&gt;ipmi_io_res[0] = <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>bus_alloc_resource_any(dev, type,
            &amp;sc-&gt;ipmi_io_rid, RF_ACTIVE);
        if (sc-&gt;ipmi_io_res[0] == NULL) {
                device_printf(dev, "could not configure PCI I/O resource\n");
                return (ENXIO);
        }

        sc-&gt;ipmi_irq_rid = 0;
        sc-&gt;ipmi_irq_res = <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>bus_alloc_resource_any(dev, SYS_RES_IRQ,
            &amp;sc-&gt;ipmi_irq_rid, RF_SHAREABLE | RF_ACTIVE);

        switch (iface) {
        case KCS_MODE:
                device_printf(dev, "using KCS interface\n");

                if (!ipmi_kcs_probe_align(sc)) {
                        device_printf(dev,
                            "unable to determine alignment\n");
                        error = ENXIO;
                        goto bad;
                }

                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>ipmi_kcs_attach(sc);
                if (error)
                        goto bad;
                break;
        case SMIC_MODE:
                device_printf(dev, "using SMIC interface\n");

                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>ipmi_smic_attach(sc);
                if (error)
                        goto bad;
                break;
        }

        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>ipmi_attach(dev);
        if (error)
                goto bad;

        return (0);

bad:
        ipmi_release_resources(dev);
        return (error);
}</pre><p>This function begins by <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20747"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> examining <code class="literal">dev</code>’s programming interface to determine <code class="literal">ipmi(4)</code>’s mode of operation (either SMIC or KCS). Then <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20759"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">PCIR_BAR(0)</code> is called to obtain the address of the first BAR. From this BAR, <code class="literal">ipmi2_pci_attach</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20772"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> identifies whether <code class="literal">ipmi(4)</code> requires <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20781"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> I/O port or <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20787"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> I/O memory access before <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20793"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> acquiring it. Lastly, <code class="literal">ipmi2_pci_attach</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20803"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> obtains an IRQ, starts up <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20809"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> KCS or <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20815"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> SMIC mode, and calls <span class="inlinemediaobject"><a id="I_inlinemediaobject11_d1e20821"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> <code class="literal">ipmi_attach</code> to finish initializing <code class="literal">dev</code>.</p></div></div></div>
<div class="sect1" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="conclusion-id10"/>Conclusion</h1></div></div></div><p>This chapter examined the PCI code base for <code class="literal">ipmi(4)</code> and introduced two fundamentals. First, a single source file can contain more than one driver. Second, to acquire I/O region access, PCI drivers must first call <code class="literal">PCIR_BAR</code>.</p></div></body></html>