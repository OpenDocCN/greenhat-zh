- en: Part III-8. TCP/IP WORLD WIDE WEB AND THE HYPERTEXT TRANSFER PROTOCOL (HTTP)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分-8. TCP/IP 万维网和超文本传输协议 (HTTP)
- en: '[Chapter 79](ch79.html "Chapter 79. WORLD WIDE WEB AND HYPERTEXT OVERVIEW AND
    CONCEPTS")'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第79章](ch79.html "第79章. 万维网和超文本概述和概念")'
- en: '[Chapter 80](ch80.html "Chapter 80. HTTP GENERAL OPERATION AND CONNECTIONS")'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第80章](ch80.html "第80章. HTTP 通用操作和连接")'
- en: '[Chapter 81](ch81.html "Chapter 81. HTTP MESSAGES, METHODS, AND STATUS CODES")'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第81章](ch81.html "第81章. HTTP 消息、方法和状态码")'
- en: '[Chapter 82](ch82.html "Chapter 82. HTTP MESSAGE HEADERS")'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第82章](ch82.html "第82章. HTTP 消息头")'
- en: '[Chapter 83](ch83.html "Chapter 83. HTTP Entities, Transfers, Coding Methods,
    and Content Management")'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第83章](ch83.html "第83章. HTTP 实体、传输、编码方法和内容管理")'
- en: '[Chapter 84](ch84.html "Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES")'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[第84章](ch84.html "第84章. HTTP 特性、能力和问题")'
- en: In my overview of file and message transfer protocols in [Chapter 71](ch71.html
    "Chapter 71. FILE AND MESSAGE TRANSFER OVERVIEW AND APPLICATION CATEGORIES"),
    I said that the World Wide Web was "almost certainly" the most important TCP/IP
    application. If anything, I was probably understating the case. The Web is not
    only quite clearly the most important TCP/IP application today, it is arguably
    the single most important application in the history of networking, and perhaps
    even computing as a whole.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我对 [第71章](ch71.html "第71章. 文件和消息传输概述和应用类别") 中文件和消息传输协议的概述中，我说万维网“几乎肯定”是最重要的
    TCP/IP 应用。如果有什么不同的话，我可能还低估了情况。万维网不仅非常明显是今天最重要的 TCP/IP 应用，它可以说是网络历史上最重要的单一应用，甚至可能是整个计算领域最重要的应用。
- en: This may sound a little melodramatic, but consider what the Web has done in
    the decade or so that it has been around. It has transformed not only how internetworks
    are used, but in many ways, it has also changed society itself. The Web put the
    Internet on the map, so to speak, moving it from the realm of technicians and
    academics to the mainstream world.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有些夸张，但考虑一下万维网在存在十年左右的时间里所做的事情。它不仅改变了互联网的使用方式，而且在许多方面也改变了社会本身。可以说，万维网将互联网推上了地图，将其从技术人员和学者的领域转移到了主流世界。
- en: This part contains six chapters that describe the World Wide Web and the all-important
    *Hypertext Transfer Protocol (HTTP)*, the TCP/IP application layer protocol that
    makes the Web work. The first chapter discusses the Web and the concepts behind
    hypertext and hypertext documents in general terms. The second chapter provides
    an overview of HTTP and describes its operation in general terms, focusing on
    how connections are established and maintained. The third chapter outlines HTTP
    messages and how they are formatted, and describes HTTP methods (commands) and
    status codes. The fourth chapter details the many HTTP headers, which are critically
    important because they are the primary way that information is communicated between
    HTTP servers and clients. The fifth chapter provides information about how resources,
    called *entities*, are encoded and transferred in HTTP. The sixth and final chapter
    explores special features and capabilities of the modern HTTP protocol.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含六个章节，描述了万维网以及至关重要的 *超文本传输协议 (HTTP)*，这是使万维网运行工作的 TCP/IP 应用层协议。第一章从一般意义上讨论了万维网以及超文本和超文本文档背后的概念。第二章概述了
    HTTP 并以一般性描述其操作，重点关注连接的建立和维护。第三章概述了 HTTP 消息及其格式化方式，并描述了 HTTP 方法（命令）和状态码。第四章详细介绍了许多
    HTTP 头部，这些头部至关重要，因为它们是 HTTP 服务器和客户端之间信息传递的主要方式。第五章提供了关于资源（称为 *实体*）在 HTTP 中编码和传输的信息。第六章和最后一章探讨了现代
    HTTP 协议的特殊功能和能力。
- en: 'Like so many TCP/IP protocols, when HTTP was designed, its creators borrowed
    elements from other application protocols. In this case, HTTP uses certain elements
    from email, especially the Multipurpose Internet Mail Extensions (MIME). I would
    recommend familiarity with both the RFC 822 email message format and MIME, especially
    MIME headers and media types, before reading this part (both topics are covered
    in [Chapter 76](ch76.html "Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS
    AND MESSAGE PROCESSING: RFC 822 AND MIME")). The relationship between HTTP and
    MIME is covered more fully in [Chapter 83](ch83.html "Chapter 83. HTTP Entities,
    Transfers, Coding Methods, and Content Management"), which discusses HTTP entities
    and media types.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多TCP/IP协议一样，当HTTP被设计时，其创造者借鉴了其他应用协议的元素。在这种情况下，HTTP使用了电子邮件中的某些元素，特别是多用途互联网邮件扩展（MIME）。在阅读这部分内容之前，我建议您熟悉RFC
    822电子邮件消息格式和MIME，特别是MIME头和媒体类型（这两个主题在[第76章](ch76.html "第76章。TCP/IP 电子邮件消息格式和消息处理：RFC
    822 和 MIME")中都有涉及）。HTTP与MIME之间的关系在[第83章](ch83.html "第83章。HTTP 实体、传输、编码方法和内容管理")中有更全面的讨论，该章节讨论了HTTP实体和媒体类型。
- en: Chapter 79. WORLD WIDE WEB AND HYPERTEXT OVERVIEW AND CONCEPTS
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第79章。万维网和超文本概述与概念
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The World Wide Web (the Web) expands the concepts of messaging beyond the limits
    of simple text file transfer of electronic mail (email), File Transfer Protocol
    (FTP), and Usenet. Its power is in its combination of *hypertext*, a system that
    allows related documents to be linked together, its rich document format that
    supports not just text but graphics and multimedia, and the special protocol that
    allows efficient movement of those media. The result is a powerful system that,
    once introduced, caught on almost immediately among everyone from large company
    users to individuals. In a few short years, the Web came to dominate all other
    applications on the Internet.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网（简称Web）扩展了消息的概念，超越了简单文本文件传输的电子邮箱（email）、文件传输协议（FTP）和Usenet的界限。它的力量在于其结合了*超文本*，这是一个允许相关文档相互链接的系统，其丰富的文档格式不仅支持文本，还支持图形和多媒体，以及允许这些媒体高效传输的特殊协议。结果是，一个一旦推出就几乎立即被从大型公司用户到个人在内的所有人所接受的强大系统。在短短几年内，Web就占据了互联网上所有其他应用的主导地位。
- en: In this chapter, I take a high-level, summarized look at the concepts behind
    the Web. I begin with a short overview and history of the Web and hypertext and
    a discussion of the components that make up the Web system. I briefly describe
    the documents and media used on the Web and explain the importance of the Hypertext
    Markup Language (HTML). I conclude with an overview of how documents are addressed
    on the Web using Uniform Resource Locators (URLs).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我以高层次的视角概述了构成万维网的概念。我首先简要介绍了万维网和超文本的概述和历史，并讨论了构成万维网系统的组件。我简要描述了在万维网上使用的文档和媒体，并解释了超文本标记语言（HTML）的重要性。最后，我概述了在万维网上使用统一资源定位符（URL）对文档进行寻址的方法。
- en: World Wide Web and Hypertext Overview and History
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 万维网和超文本概述与历史
- en: The World Wide Web is one of the members of the class of Internet messaging
    applications. But for some reason, it just doesn't seem like a message transfer
    protocol to me. This led me to wonder, what is so special about the Web that caused
    it to become popular in a way that no prior messaging applications ever had?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网是互联网消息应用类别中的一员。但不知何故，它在我眼中并不像是一个消息传输协议。这让我想弄清楚，万维网有什么特别之处，使得它以一种先前任何消息应用都没有的方式变得流行？
- en: 'There is no truly accurate one-word answer to this question. However, if I
    had to give one anyway, it would be this: *hypertext*. Sure, applications like
    email and Usenet allow users to send and receive information, and FTP lets a user
    access a set of files on a server. But what these methods lack is any way of easily
    representing the *relationship* between documents or providing a way of moving
    from one to another. Highly simplified, hypertext does exactly that: It allows
    the creator of a document to include links to related information, either elsewhere
    in that document or in other documents. With the appropriate software, a user
    can easily move from one location to another. So why is this a big deal? In fact,
    this is more important than it may initially seem.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，没有一个真正准确的单一词回答。然而，如果无论如何我都必须给出一个答案，那将是这个：*超文本*。当然，像电子邮件和Usenet这样的应用允许用户发送和接收信息，而FTP则允许用户访问服务器上的文件集。但这些方法缺乏任何易于表示文档之间*关系*的方法，或者提供一种从一份文档移动到另一份文档的方式。高度简化地说，超文本正是这样做的：它允许文档的创建者包含指向相关信息的链接，无论是该文档的其它部分还是其他文档。有了适当的软件，用户可以轻松地在不同位置之间移动。那么这为什么是个大问题呢？事实上，这比最初看起来更重要。
- en: Without some way of linking documents together, they remain in unconnected islands.
    In some ways, hypertext-linked documents are to unlinked documents what networked
    computers are to those that are not networked.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有某种方式将文档链接在一起，它们将保持未连接的孤岛状态。在某种程度上，超文本链接的文档与未链接的文档的关系，就像联网的计算机与未联网的计算机的关系一样。
- en: History of Hypertext
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超文本的历史
- en: The ideas behind hypertext actually go back far beyond the Web and even electronic
    computers. Vannevar Bush (1890–1974) is generally credited with introducing the
    idea in his 1945 description of a theoretical device called the *Memex*, which
    was intended to be used to store and retrieve documents. He described the concept
    of a *trail* that would link together related information to make it easier to
    organize and access the information in the device.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本背后的思想实际上远早于互联网甚至电子计算机。范内瓦·布什（1890-1974）通常被归功于他在1945年描述一个名为*Memex*的理论装置时引入了这个想法，该装置旨在用于存储和检索文档。他描述了*轨迹*的概念，它将相关联的信息链接起来，以便更容易地组织和访问设备中的信息。
- en: Bush's ideas were used as the basis of the work of several researchers who followed.
    One of these was Ted Nelson, who coined the term *hypertext* and, in 1960, first
    described a system called *Xanadu*, which is considered one of the original hypertext
    software models.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 布什的思想被后续几位研究人员作为工作的基础。其中之一是特德·纳尔逊，他提出了*超文本*这个术语，并在1960年首次描述了一个名为*Xanadu*的系统，该系统被认为是原始的超文本软件模型之一。
- en: The history of the Web itself goes back to 1989 at *CERN*, the European Organization
    for Nuclear Research, in Geneva. (The acronym stands for *Conseil Européen pour
    la Recherche Nucléaire*, the French name of the organization.) Many of the projects
    undertaken at CERN were large and complex, and they took many years to complete.
    They also involved many scientists who had to work with and share related documents.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网本身的历史可以追溯到1989年的欧洲核子研究中心（CERN），位于日内瓦。该缩写代表*Conseil Européen pour la Recherche
    Nucléaire*，即该组织的法语名称。CERN进行的项目大多规模庞大且复杂，需要多年才能完成。它们还涉及许多必须共同工作和共享相关文档的科学家。
- en: A researcher at CERN, Tim Berners-Lee, proposed the idea of creating a "web"
    of electronically linked documents. The rapidly growing Internet was the obvious
    conduit for this project. He designed the first (very crude and simple) version
    of HTTP for TCP/IP in 1990\. He was also responsible for developing or co-developing
    several of the other key concepts and components behind the Web, such as Uniform
    Resource Identifiers (URIs) and HTML.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 欧洲核子研究中心（CERN）的研究员蒂姆·伯纳斯-李提出了创建一个“网络”的电子链接文档的想法。快速增长的互联网显然是这个项目的明显渠道。他在1990年设计了TCP/IP的最初（非常粗糙和简单）版本的HTTP。他还负责开发或共同开发Web背后的其他一些关键概念和组件，例如统一资源标识符（URIs）和HTML。
- en: The ability to link documents and files had tremendous appeal, and it took little
    time before creative individuals found many different uses for this new technology.
    The early 1990s saw a flurry of development activity. Web server and client software
    was developed and refined, and the first graphical web browser, *Mosaic*, was
    created by the National Center for Supercomputer Applications (NCSA) in 1993\.
    (The developer of this program, Marc Andreessen, eventually formed Netscape Communications.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将文档和文件链接起来的能力具有巨大的吸引力，创意人士很快就发现了这种新技术的大量用途。20世纪90年代初，开发活动迅速展开。Web服务器和客户端软件得到了开发和完善，1993年，国家超级计算应用中心（NCSA）创建了第一个图形化Web浏览器*Mosaic*。（该程序的开发者马克·安德森最终成立了网景通信公司。）
- en: Once the Web started to form, it grew very quickly indeed. In fact, to call
    the growth of the Web anything but *explosive* would not do it justice. In early
    1993, only 50 active HTTP web servers existed. By late 1993, more than 1,000 were
    in service. By late 1995, thousands of new websites were coming online every day,
    and HTTP requests and responses had overtaken all other TCP/IP application traffic.
    By the end of the decade, *millions* of websites and more than a billion documents
    were available on the Web.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦万维网开始形成，它就迅速发展。事实上，如果将万维网的增长称为其他任何非爆炸性的东西，那都不足以描述其真实情况。1993年初，只有50个活跃的HTTP
    Web服务器。到1993年底，服务器数量超过1000个。到1995年底，每天都有成千上万的新的网站上线，HTTP请求和响应已经超过了所有其他TCP/IP应用流量。到本世纪末，*数百万*个网站和超过十亿份文档可在互联网上获取。
- en: The World Wide Web Today
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 今天的万维网
- en: While the rapid growth in the size of the Web is amazing, what is even more
    fascinating is its growth in *scope*. Since you are reading a book about networking,
    you are most likely a Web user who is familiar with the incredible array of different
    types of information you can find on the Web today. Early hypertext systems were
    based on the use of only text documents; today the Web is a world of many media
    including pictures, sounds, and movies. The term *hypertext* has in many contexts
    been replaced with the more generic *hypermedia*—functionally, if not officially.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然互联网规模的快速增长令人惊叹，但更令人着迷的是其范围的扩展。既然你在阅读一本关于网络的书，你很可能是一个熟悉今天互联网上可以找到的令人难以置信的各种类型信息的Web用户。早期的超文本系统仅基于文本文档的使用；今天，互联网是一个包含图片、声音和电影等多种媒体的全球世界。在许多情况下，*超文本*这一术语已被更通用的*超媒体*所取代——在功能上，如果不是在官方上。
- en: The Web has also moved beyond providing simple document retrieval to providing
    a myriad of services. A website can serve up much more than just documents, allowing
    users to run thousands of kinds of programs to do everything from shop to play
    music or games online. Websites are also blurring the lines between different
    types of applications, offering Web-based email, Web-based Usenet access, bulletin
    boards, and other interactive forums for discussion.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网已经超越了提供简单文档检索的功能，提供了各种各样的服务。一个网站可以提供不仅仅是文档的服务，使用户能够运行成千上万种程序，从购物到在线播放音乐或游戏。网站也在模糊不同类型应用之间的界限，提供基于Web的电子邮件、基于Web的Usenet访问、公告板以及其他用于讨论的互动论坛。
- en: The Web has had an impact on both networking and society as a whole that even
    its most enthusiastic early fans could never have anticipated. In fact, the Web
    was the ultimate "killer application" for the Internet as a whole. In the early
    1990s, big corporations viewed the Web as an amusing curiosity; by the end of
    the decade, it was for many a business necessity. Millions of individuals and
    families discovered the wealth of information at their fingertips, and Internet
    access became for many another necessary utility, like telephone service. In fact,
    the huge increase in Web traffic volume spawned the spending of billions of dollars
    on Internet infrastructure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网对网络和社会整体的影响，即使是其最热情的早期粉丝也未曾预料到。事实上，互联网的终极“杀手级应用”就是万维网。在20世纪90年代初，大公司把互联网视为一种有趣的奇观；到本世纪末，对许多人来说，它已经成为一种商业必需品。数百万个人和家庭发现了他们指尖上的信息财富，互联网接入对许多人来说成为另一种必需的公用事业，就像电话服务一样。事实上，互联网流量的大幅增加催生了数十亿美元用于互联网基础设施的投资。
- en: The dot-com collapse of the early twenty-first century took some of the wind
    out of the Web's sails. The incredible growth of the Web could not continue at
    its original pace and has slowed somewhat. But the Web as a whole continues to
    expand and mature, and it will likely be the most important information and service
    resource on the Internet for some time to come.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 21世纪初的互联网泡沫破灭削弱了互联网的势头。互联网的惊人增长无法以原来的速度继续，并且已经有所放缓。但总体而言，互联网仍在持续扩展和成熟，它很可能会在相当长一段时间内成为互联网上最重要的信息和资源。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The World Wide Web (the Web or WWW) began in 1989 as a project
    designed to facilitate the representation of relationships between documents and
    the sharing of information between researchers. The main feature of the Web that
    makes it so powerful is hypertext, which allows links to be made from one document
    to another. The many benefits of the Web caused it to grow in only a few short
    years from a small application to the largest and arguably most important application
    in the world of networking. It is largely responsible for bringing the Internet
    into the mainstream of society.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 万维网（Web或WWW）始于1989年，是一个旨在促进文档之间关系表示和研究人员之间信息共享的项目。使万维网如此强大的主要特征是超文本，它允许从一个文档链接到另一个文档。万维网的许多好处使得它仅在短短几年内从一个小型应用发展到世界上最大、也许是最重要的网络应用。它主要负责将互联网带入社会的主流。'
- en: World Wide Web System Concepts and Components
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 万维网系统概念和组件
- en: Hypertext is the main concept that makes the Web more than just another message
    transfer system. However, the idea behind hypertext had been around for decades
    before the Web was born, as had certain software products based on that idea.
    Obviously, more than just a concept is needed for an idea to be developed into
    a successful system.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本是使万维网不仅仅是一个消息传输系统的核心概念。然而，超文本背后的想法在万维网出现之前就已经存在了几十年，以及基于该想法的某些软件产品。显然，一个想法要发展成为成功的系统，需要的不仅仅是概念。
- en: The Web became a phenomenon because it combined the basic idea of hypertext
    with several other concepts and technologies to create a rich, comprehensive mechanism
    for interactive communication. This system today encompasses so many different
    concepts and software elements, and is so integrated with other technologies,
    that it's difficult to find any two people who agree on what exactly the Web comprises,
    and which parts are most critical.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网之所以成为现象，是因为它将超文本的基本思想与几个其他概念和技术相结合，创造了一个丰富、全面的交互式通信机制。这个系统今天包含了如此多的不同概念和软件元素，并且与其他技术如此集成，以至于很难找到两个对互联网究竟包含什么以及哪些部分最为关键达成共识的人。
- en: For example, one of the keys to the success of the Web is undeniably the combination
    of the TCP/IP internetworking protocol suite and the Internet infrastructure that
    connects together the computers of the world. Is the Internet then an essential
    component of the Web? In many ways, it is; and, in fact, due to how popular the
    Web is today, it is common to hear people refer to the Web as *the Internet*.
    We know that this is not a precise use of terms, of course, but it shows how important
    the Web has become and how closely it is tied to the Internet.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，不可否认，互联网成功的关键之一是TCP/IP互联网互连协议套件与连接全世界计算机的互联网基础设施的结合。那么，互联网是否是互联网的必要组成部分呢？在许多方面，是的；实际上，由于互联网今天如此受欢迎，人们常常将互联网称为*互联网*。当然，我们知道这并不是精确的术语使用，但它显示了互联网变得多么重要，以及它与互联网的紧密联系。
- en: Major Functional Components of the Web
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 万维网的主要功能组件
- en: 'While the Internet and TCP/IP are obviously important parts of the Web''s success,
    they are generic in nature. When it comes to defining the Web system itself more
    specifically, three particular components are usually considered most essential
    (see [Figure 79-1](ch79s02.html#major_functional_components_of_the_world "Figure 79-1. Major
    functional components of the World Wide Web")):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然互联网和TCP/IP显然是互联网成功的重要部分，但它们本质上是通用的。当具体定义万维网系统本身时，通常认为有三个特定的组件最为关键（参见[图79-1](ch79s02.html#major_functional_components_of_the_world
    "图79-1. 万维网的主要功能组件"))：
- en: '**Hypertext Markup Language** HTML is a text language used to define hypertext
    documents. The idea behind HTML was to add simple constructs, called *tags*, to
    regular text documents, to enable the linking of one document to another, as well
    as to allow special data formatting and the combining of different types of media.
    HTML has become the standard language for implementing information in hypertext
    and has spawned the creation of numerous related languages.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本标记语言** HTML是一种用于定义超文本文档的文本语言。HTML背后的想法是向常规文本文档中添加简单的结构，称为**标签**，以便将一个文档链接到另一个文档，并允许特殊数据格式化以及不同类型媒体的组合。HTML已经成为实现超文本信息的标准语言，并催生了众多相关语言的创建。'
- en: '**Hypertext Transfer Protocol** HTTP is the TCP/IP application layer protocol
    that implements the Web, by enabling the transfer of hypertext documents and other
    files between a client and server. HTTP began as a very crude protocol for transferring
    HTML documents between computers, and it has evolved to a full-featured and sophisticated
    messaging protocol. It supports transfers of many different kinds of documents,
    streaming of multiple files on a connection, and various advanced features including
    caching, proxying, and authentication.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本传输协议** HTTP是TCP/IP应用层协议，通过实现客户端和服务器之间超文本文档和其他文件的传输来实施网络。HTTP最初是一种非常原始的协议，用于在计算机之间传输HTML文档，并且它已经发展成为一个功能齐全且复杂的消息协议。它支持多种不同类型文档的传输，连接上的多个文件的流式传输，以及包括缓存、代理和认证在内的各种高级功能。'
- en: '**Uniform Resource Identifiers** URIs are used to define labels that identify
    resources on an internetwork so that they can be easily found and referenced.
    URIs were originally developed to provide a means by which the users of the Web
    could locate hypertext documents so they could be retrieved. URIs are actually
    not specific to the Web, though they are most often associated with the Web and
    HTTP.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一资源标识符** URIs用于定义标识因特网上资源的标签，以便它们可以轻松找到和引用。URIs最初是为了提供一种方式，让网络用户能够定位超文本文档，以便检索它们。尽管URIs并非特定于网络，但它们通常与网络和HTTP相关联。'
- en: '![Major functional components of the World Wide Web](httpatomoreillycomsourcenostarchimages288305.png.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![万维网的主要功能组件](httpatomoreillycomsourcenostarchimages288305.png.jpg)'
- en: Figure 79-1. Major functional components of the World Wide Web
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图79-1. 万维网的主要功能组件
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Uniform Resource Locators (URLs) are actually a subset of Uniform Resource
    Identifiers (URIs). The terms are often used interchangeably in World Wide Web
    discussions*.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*统一资源定位符（URLs）实际上是统一资源标识符（URIs）的一个子集。在万维网讨论中，这两个术语经常被互换使用*。'
- en: All three of these components were created and developed at around the same
    time, and taken together they represent the key technologies that define the Web.
    In this chapter, I'll describe HTML and the use of URIs in the context of the
    Web. HTTP is really the heart of the Web and is covered in the remaining five
    chapters of this part of the book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个组件都是在同一时间创建和开发的，并且综合起来代表了定义网络的关键技术。在本章中，我将描述HTML以及在网络环境中URI的使用。HTTP实际上是网络的中心，并在本书本部分的剩余五章中进行介绍。
- en: Web Servers and Web Browsers
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络服务器和网络浏览器
- en: 'These three main Web components are supplemented by a number of other elements
    that play supporting roles in rounding out the system as a whole. Chief among
    these are the hardware and software used to implement client/server communication
    that makes the Web work, also illustrated in [Figure 79-1](ch79s02.html#major_functional_components_of_the_world
    "Figure 79-1. Major functional components of the World Wide Web"): *web servers*
    and *web browsers*.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个主要的网络组件由许多其他元素补充，这些元素在完善整个系统方面发挥着辅助作用。其中最重要的是用于实现客户端/服务器通信的硬件和软件，这使得网络能够工作，也如图[图79-1](ch79s02.html#major_functional_components_of_the_world
    "图79-1. 万维网的主要功能组件")所示：**网络服务器**和**网络浏览器**。
- en: Web servers are computers that run special server software that allows them
    to provide hypertext documents and other files to clients who request them. Millions
    of such machines around the world now serve as a virtual distributed repository
    of the enormous wealth of information that the Web represents.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器是运行特殊服务器软件的计算机，这使得它们能够向请求它们的客户端提供超文本文档和其他文件。现在，全世界有成千上万的此类机器作为网络所代表的巨大信息财富的虚拟分布式存储库。
- en: Web browsers are HTTP client software programs that run on TCP/IP client computers
    to access web documents on web servers. These browser programs retrieve hypertext
    documents and display them, and they also implement many of the Web's advanced
    features, such as caching. Today's browsers support a wide variety of media, allowing
    the Web to implement many different functions aside from hypertext document transfer.
    Examples include displaying images, playing sounds, and implementing interactive
    programs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器是在TCP/IP客户端计算机上运行的HTTP客户端软件程序，用于访问网络服务器上的网络文档。这些浏览器程序检索超文本文档并显示它们，并且它们还实现了许多网络的先进功能，如缓存。今天的浏览器支持广泛的媒体，使网络能够实现许多不同的功能，除了超文本文档传输之外。例如，显示图像、播放声音和实现交互式程序。
- en: Last, but certainly not least, the *users* of the Web are perhaps its most important
    component. User involvement has had more of a role in shaping the development
    of Web technology than any other networking application. The Web began as a simple
    means of exchanging documents; today, it has grown to encompass thousands of different
    applications and services, largely as a result of the creativity of its users.
    Content providers have pushed the boundaries of what the Web can do by creating
    new ideas for information and services to satisfy the insatiable demands of the
    end-user community.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，*用户*是万维网最重要的组成部分。用户参与在塑造网络技术发展方面发挥了比任何其他网络应用更大的作用。万维网最初是一种简单的交换文档的手段；如今，它已经发展到包括数千种不同的应用和服务，这主要归功于其用户的创造力。内容提供商通过创造新的信息和服务的想法来推动万维网所能做到的边界，以满足终端用户群体的无尽需求。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The World Wide Web is a complete system comprising a number
    of related components, of which three are most essential. Hypertext Markup Language
    (HTML) describes how hypertext documents are constructed. HTML allows links between
    documents to be represented. The Hypertext Transfer Protocol (HTTP) is the application
    layer protocol that moves hypertext and other documents over the Web. The Uniform
    Resource Identifier (URI) mechanism provides a consistent means of identifying
    resources, both on the Web and more generally on the Internet as a whole.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 万维网是一个由许多相关组件组成的完整系统，其中三个是最基本的。超文本标记语言（HTML）描述了超文本文档是如何构建的。HTML允许在文档之间表示链接。超文本传输协议（HTTP）是在网络上移动超文本和其他文档的应用层协议。统一资源标识符（URI）机制提供了一种一致的方法来标识资源，无论是在万维网上还是在更广泛的互联网上。'
- en: World Wide Web Media and the Hypertext Markup Language
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 万维网媒体和超文本标记语言
- en: I've said the Web is based around the central concept of *hypertext*. The prefix
    *hyper* usually means above or beyond, and thus *hypertext* is like text but goes
    beyond it in terms of functionality. Documents written in hypertext are similar
    to regular text files but include information that implements hypertext functions.
    These are usually called *hypertext documents* or *hypertext files*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经说过，网络是基于中心概念*超文本*的。前缀*hyper*通常意味着在之上或超越，因此*超文本*就像文本，但在功能上超越了它。用超文本编写的文档与常规文本文件类似，但包括实现超文本功能的信息。这些通常被称为*超文本文档*或*超文本文件*。
- en: The extra information in a hypertext document is used to tell the computer program
    that displays the file how to format it. This information takes the form of special
    instructions that are interspersed with the actual text of the document itself,
    which are written according to the syntax of a defining language. This addition
    of extra elements to the content of a document is commonly called *marking up*
    the document.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本文档中的额外信息用于告诉显示文件的计算机程序如何格式化它。这些信息以特殊指令的形式出现，穿插在文档的实际文本中，这些指令是根据定义语言的语法编写的。这种向文档内容添加额外元素的行为通常被称为*标记文档*。
- en: Overview of HTML
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML概述
- en: HTML is one of the three primary system components of the Web and was invented
    in 1990 by the creator of the Web, Tim Berners-Lee. It was not created in a vacuum;
    rather, it is a specific application of the general concept of a markup language
    that is described in ISO standard 8879:1986—the *Standard Generalized Markup Language
    (SGML)*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: HTML是万维网的三个主要系统组件之一，由万维网的创造者蒂姆·伯纳斯-李于1990年发明。它不是在真空中创造的；相反，它是ISO标准8879:1986中描述的通用标记语言概念的特定应用——*标准通用标记语言（SGML）*。
- en: A markup language defines special items that provide information to the software
    displaying the document about how it should be presented. For the purposes of
    hypertext, the most basic type of information in a document is a special instruction
    that specifies how one document can be linked to another—after all, this linking
    process is the defining attribute of hypertext.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 标记语言定义了特殊的项目，为显示文档的软件提供有关如何展示的信息。在超文本的目的上，文档中最基本的信息类型是特殊的指令，指定如何将一个文档链接到另一个文档——毕竟，链接过程是超文本的定义属性。
- en: However, HTML goes far beyond just this; it defines a full set of text codes
    used for describing nearly every aspect of how a document is shown to a user.
    This includes instructions for formatting text (such as defining its color, size,
    and alignment), interactive forms, methods for displaying tabular data, specifications
    for how to present images and other media along with the document, and much more.
    In theory, the language is only supposed to define the document and leave how
    it should be displayed up to the browser, but in practice, modern HTML documents
    also usually contain rather specific instructions for how their information should
    be presented.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，HTML的功能远不止于此；它定义了一套完整的文本代码，用于描述文档如何向用户展示的几乎所有方面。这包括格式化文本的指令（例如定义其颜色、大小和对齐方式）、交互式表单、显示表格数据的方法、如何展示图像和其他媒体与文档一起的规范，以及更多。理论上，这种语言只应该定义文档，而将如何展示留给浏览器，但在实践中，现代HTML文档通常也包含相当具体的指令，说明它们的信息应该如何展示。
- en: To do justice to HTML, I would need to devote several dozen pages to the subject.
    I have decided not to do this, because even though HTML is an important part of
    the Web, it is actually not that important in understanding how the Web works.
    Knowing HTML is essential if you are writing Web content, and it is also critical
    if you want to understand how to write Web software. Perhaps ironically, though,
    to the actual mechanisms that make the Web work, such as HTTP, a document is a
    document. HTTP is not designed under the assumption that it will transfer HTML,
    and in most cases, servers do not even look at the contents of an HTML file—they
    just transfer it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要公正地对待HTML，我可能需要为这个主题写上几十页。我决定不这样做，因为尽管HTML是网络的一个重要部分，但在理解网络如何工作方面，它实际上并不是那么重要。如果你在编写网络内容，了解HTML是必不可少的，如果你想要了解如何编写网络软件，它也是至关重要的。然而，具有讽刺意味的是，对于使网络工作的实际机制，如HTTP，文档就是文档。HTTP并不是在假设它会传输HTML的情况下设计的，在大多数情况下，服务器甚至不会查看HTML文件的内容——它们只是传输它。
- en: That said, a basic understanding of HTML is important, and it just wouldn't
    seem right not to provide at least an overview of the language, so I will do that
    here. I encourage you to seek out one of the many good HTML resources if you want
    to learn more—you'll find dozens of them on the Web (where else?).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，对HTML的基本理解很重要，而且似乎不提供至少对该语言的概述是不合适的，所以我将在这里这样做。我鼓励你寻找许多优秀的HTML资源之一，如果你想要了解更多——你可以在网上找到成百上千的资源（还能在哪里？）。
- en: HTML Elements and Tags
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML元素和标签
- en: In simplest terms, an HTML document is a plain ASCII text file, like an email
    message or other text document. The biggest difference between HTML and regular
    text is that HTML documents are *structured*; that is, the document is logically
    organized into a series of *elements* that are arranged according to the rules
    of the language. Each element defines one part of the document as a whole. The
    title of a document, a paragraph, a table, and a hyperlink to another document
    are all examples of elements.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，HTML文档是一个普通的ASCII文本文件，就像一封电子邮件或其他文本文件。HTML与普通文本的最大区别在于HTML文档是*结构化的*；也就是说，文档逻辑上组织成一系列*元素*，这些元素按照语言的规则排列。每个元素定义了文档整体的一部分。文档的标题、段落、表格以及指向另一个文档的超链接都是元素的例子。
- en: 'Each element is described using special text *tags* that follow a particular
    syntax. Each tag begins with the < symbol, which is then followed by the (case-insensitive)
    element name, and optionally, additional parameters that describe the element.
    The tag ends with the > symbol. Here''s how a tag looks generally:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素都使用特殊的文本*标签*来描述，这些标签遵循特定的语法。每个标签以<符号开始，然后是（不区分大小写）元素名称，以及可选的描述元素的参数。标签以>符号结束。一般来说，标签看起来是这样的：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Some elements are entirely described by the presence of a tag, and in such
    cases, that tag is the entire element. More often, tags occur in pairs surrounding
    the actual content of the element; the *start tag* begins with the name of the
    element, and the *end tag* begins with a slash symbol followed by the name of
    the element. For example, the title of a document is an element that can be defined
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些元素完全由标签的存在来描述，在这种情况下，该标签就是整个元素。更常见的是，标签成对出现，包围着元素的真正内容；*开始标签*以元素名称开头，*结束标签*以一个斜杠符号开头，后跟元素名称。例如，文档的标题是一个可以定义为以下内容的元素：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The content of each element can contain other elements, which causes tags to
    be nested within each other. For example, if we wanted to highlight the word *Great*
    in our title by displaying it in bold letters, we can add the `<b>` tag as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素的 内容可以包含其他元素，这导致标签在彼此之间嵌套。例如，如果我们想通过将单词 *Great* 以粗体字母的形式显示来突出显示标题中的该词，我们可以添加以下
    `<b>` 标签：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Each whole HTML document is defined as a single element called `html`; the
    whole document is enclosed in `<html>` and `</html>` tags. Within this element,
    the document is divided into two standard subelements that must be present in
    each document: the `head` and the `body`. The `head` of the document contains
    information that describes the document and how it is to be processed; it most
    commonly contains the title of the document. The `body` contains the actual content
    of the document. These three elements define the basic HTML document structure,
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个完整的 HTML 文档都定义为单个名为 `html` 的元素；整个文档被 `<html>` 和 `</html>` 标签包围。在这个元素内部，文档被分为两个标准子元素，每个文档都必须包含这些子元素：`head`
    和 `body`。文档的 `head` 包含描述文档及其处理方式的信息；它最常见地包含文档的标题。`body` 包含文档的实际内容。这三个元素定义了基本的
    HTML 文档结构，如下所示：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The bulk of the document consists of the body elements that are placed between
    the `<body>` and `</body>` tags. HTML documents can range from very simple bodies
    containing only elements such as text paragraphs and perhaps a few links, to very
    sophisticated documents that are computer-generated and contain hundreds or even
    thousands of nested tags of various sorts.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的大部分内容由放置在 `<body>` 和 `</body>` 标签之间的主体元素组成。HTML 文档可以从非常简单的只包含文本段落和几个链接的简单主体，到由计算机生成且包含数百甚至数千个嵌套标签的复杂文档。
- en: Common HTML Elements
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见 HTML 元素
- en: '[Table 79-1](ch79s03.html#common_html_elements-id001 "Table 79-1. Common HTML
    Elements") provides a brief description of some of the more common elements used
    in the body of an HTML message and the tags that define them, to give you a feel
    for how the language works.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 79-1](ch79s03.html#common_html_elements-id001 "表 79-1. 常见 HTML 元素") 提供了一些在
    HTML 消息主体中常用元素及其定义的标签的简要描述，以帮助您了解该语言的工作方式。'
- en: Table 79-1. Common HTML Elements
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 表 79-1. 常见 HTML 元素
- en: '| Element | Example Element and Tags | Description |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 示例元素和标签 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Paragraph |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 段落 |'
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| Delineates a paragraph of text. Note that everything between the start and
    end tags will be considered one paragraph, even if split onto multiple lines as
    I have done here. Line breaks are not significant in HTML formatting; only tags
    are recognized. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 标记一段文本。请注意，从开始标签到结束标签之间的所有内容都将被视为一个段落，即使它们被分成多行，就像我在这里所做的那样。在 HTML 格式化中，换行符并不重要；只有标签被识别。|'
- en: '| Line Break |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 换行 |'
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| Forces a line break. Used instead of the paragraph tag to present lines close
    together, such as addresses. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 强制换行。用于将行紧密排列，例如地址。|'
- en: '| Heading |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 标题 |'
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| Defines section headings to allow information in a long document to be displayed
    in hierarchical form. Six sets of tags are defined, from `<h1>` and `</h1>` to
    `<h6>` and `</h6>`. Browsers will automatically display the higher-level headings
    in more prominent ways, by using larger fonts, underlining the text, or similar
    treatment. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 定义文档中的部分标题，以便在长文档中以分层形式显示信息。定义了六组标签，从 `<h1>` 和 `</h1>` 到 `<h6>` 和 `</h6>`。浏览器会自动以更突出的方式显示高级标题，例如使用更大的字体、下划线文本或类似处理。|'
- en: '| List |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 列表 |'
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| Allows information to be presented as a list. The tag `<ul>` means unnumbered
    list and causes the list items to be shown usually as bullet points. Alternatively,
    `<ol>` (ordered list) can be used to show the items preceded by 1, 2, 3, and so
    on. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 允许以列表的形式呈现信息。标签 `<ul>` 表示无序列表，导致列表项通常以项目符号显示。另可使用 `<ol>`（有序列表）来显示前面带有 1、2、3
    等的项。|'
- en: '| Horizontal Rule |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 水平线 |'
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| Draws a horizontal line across the page; the `size` parameter controls its
    thickness. Used to separate logical sections in a document. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 在页面上绘制一条水平线；`size` 参数控制其厚度。用于在文档中分隔逻辑部分。|'
- en: '| Image |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 图片 |'
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '| Displays an inline image in the appropriate section of the text. The `src`
    parameter is a relative or absolute URL for the image, and numerous other parameters
    can be included to define the image''s alignment, size, alternate text to display
    if the browser is nongraphical (as shown here with the `alt` parameter), and much
    more. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 在文本的适当部分显示内联图像。`src` 参数是图像的相对或绝对 URL，可以包含多个其他参数来定义图像的对齐方式、大小、如果浏览器是非图形的则显示的替代文本（如这里所示，使用
    `alt` 参数），以及更多。|'
- en: '| Link |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 链接 |'
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '| Hyperlinks to another document. The *a* in the tag stands for anchor, which
    is the formal name for a hyperlink. The `href` parameter specifies the URL of
    the link. Most browsers will underline or otherwise highlight text between the
    start and end tags to make it clear that the text represents a hyperlink. It is
    also possible to give a hyperlink to an image by combining the `<img>` and `<a>`
    tags. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 指向另一个文档的超链接。标签中的 *a* 代表锚点，这是超链接的正式名称。`href` 参数指定链接的 URL。大多数浏览器会在开始和结束标签之间的文本下划线或以其他方式突出显示，以清楚地表明该文本代表超链接。也可以通过结合
    `<img>` 和 `<a>` 标签来给图像创建超链接。|'
- en: '| Bookmark |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 书签 |'
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '| Creates a bookmark that can be used to hyperlink to a particular section
    in a document. For example, if the bookmark in this example was in a document
    at URL [http://www.homefixitup.com/repainting.htm](http://www.homefixitup.com/repainting.htm),
    the URL [http://www.homefixitup.com/repainting.htm#Step4](http://www.homefixitup.com/repainting.htm#Step4)
    refers to this particular place in the document. See the discussion of URLs later
    in this chapter for more details. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 创建一个书签，可以用来指向文档中的特定部分。例如，如果这个示例中的书签在一个 URL 为 [http://www.homefixitup.com/repainting.htm](http://www.homefixitup.com/repainting.htm)
    的文档中，那么 URL [http://www.homefixitup.com/repainting.htm#Step4](http://www.homefixitup.com/repainting.htm#Step4)
    就指向文档中的这个特定位置。有关更多详细信息，请参阅本章后面的 URL 讨论部分。|'
- en: '| Table |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 表格 |'
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '| Displays information in tabular form. Each `<tr>` and `</tr>` tag set defines
    one row of the table; within each row, each `<td>` and `</td>` pair defines one
    table data element. Many different parameters can be provided for each of these
    tags to control table size and appearance. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 以表格形式显示信息。每个 `<tr>` 和 `</tr>` 标签集定义表格的一行；在每一行中，每个 `<td>` 和 `</td>` 对定义一个表格数据元素。可以为这些标签中的每一个提供多个不同的参数来控制表格的大小和外观。|'
- en: '| Form |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 表格形式 |'
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| Defines an HTML form, allowing various sorts of information to be submitted
    by a client to a program on a website designed to process forms. The form consists
    of the initial `<form>` tag that describes what action to be taken when the submission
    button is pressed, and other form items such as predefined variables, text-entry
    fields, and buttons. One example of each of these items is shown here. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 定义一个 HTML 表单，允许客户端向处理表单的网站上的程序提交各种类型的信息。表单由描述提交按钮按下时要采取的操作的初始 `<form>` 标签组成，以及其他表单项，如预定义变量、文本输入字段和按钮。这里展示了这些项的每个示例。|'
- en: '| Script |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 脚本 |'
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| Allows instructions in a scripting language to be included in an HTML document.
    It is most often used for JavaScript. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 允许在 HTML 文档中包含脚本语言的指令。它最常用于 JavaScript。|'
- en: Common Text Formatting Tags
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见文本格式化标签
- en: 'Numerous tags are used to format the appearance of text within a document;
    here are some of the more common ones:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档中格式化文本外观的标签有很多，这里列出了一些更常见的标签：
- en: '**`<b>text</b>`** Present the enclosed text in boldface.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**`<b>文本</b>`** 以粗体形式呈现包含的文本。'
- en: '**`<i>text</i>`** Present the enclosed text in italics.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**`<i>文本</i>`** 以斜体形式呈现包含的文本。'
- en: '**`<u>text</u>`** Present the enclosed text underlined.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**`<u>文本</u>`** 以下划线呈现包含的文本。'
- en: '**`<font (parameters)>text</font>`** Present the enclosed text using the indicated
    font type, size, or color.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**`<font (参数)>文本</font>`** 使用指定的字体类型、大小或颜色来呈现包含的文本。'
- en: This is just the tip of the iceberg when it comes to HTML. If you are not familiar
    with HTML, however, knowing these basic tags should help you interpret basic HTML
    documents and learn how HTTP works.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是冰山一角，当涉及到 HTML 时。如果你不熟悉 HTML，然而，了解这些基本标签应该有助于你解释基本的 HTML 文档并学习 HTTP 的工作原理。
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The language used by World Wide Web hypertext documents is
    called HTML. HTML documents are like ASCII text files, but they are arranged using
    a special structure of HTML elements that define the different parts of the document
    and how they should be displayed to the user. Each element is described using
    special text tags that define it and its characteristics.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 互联网超文本文档使用的语言称为HTML。HTML文档类似于ASCII文本文件，但它们使用HTML元素的特殊结构来排列，这些元素定义了文档的不同部分以及它们应该如何显示给用户。每个元素都使用特殊的文本标签来描述，这些标签定义了它及其特征。'
- en: 'World Wide Web Addressing: HTTP Uniform Resource Locators'
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 万维网寻址：HTTP统一资源定位符
- en: The main reason that hypertext is so powerful and useful is that it allows related
    documents to be linked together. In the case of the Web, this is done using a
    special set of HTML tags that specifies in one document the name of another document
    that is related in some important way. A user can move from one document to the
    next using a simple mouse click. The Web has succeeded largely on the basis of
    this simple and elegant method of referral.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本之所以强大且有用，主要原因是它允许相关文档相互链接。在万维网的情况下，这是通过一组特殊的HTML标签来实现的，这些标签在一篇文档中指定了另一篇与之在某些重要方面相关的文档的名称。用户可以通过简单的鼠标点击从一个文档跳转到另一个文档。万维网在很大程度上是基于这种简单而优雅的引用方法而成功的。
- en: The notion of hyperlinking has some important implications on how Web documents
    and other resources are addressed. Even though the Web is at its heart a message
    transfer protocol similar to FTP, the need to be able to define hyperlinks meant
    that the traditional FTP model of using a set of commands to specify how to retrieve
    a resource had to be abandoned. Instead, a system was needed whereby a resource
    could be uniquely specified using a simple, compact string.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 超链接的概念对万维网文档和其他资源的寻址方式有重要影响。尽管万维网本质上是一种类似于FTP的消息传输协议，但需要能够定义超链接意味着必须放弃传统的FTP模型，即使用一系列命令来指定如何检索资源。相反，需要一个系统，通过一个简单紧凑的字符串可以唯一地指定资源。
- en: 'The result of this need was the definition of one of the three primary elements
    of the Web: the *URI*. URIs are divided into two categories: *Uniform Resource
    Locators (URLs)* and *Uniform Resource Names (URNs)*. While URIs, URLs, and URNs
    grew out of the development of the Web, they have now been generalized to provide
    an addressing mechanism for a wide assortment of TCP/IP application layer protocols.
    They are described in detail in [Chapter 70](ch70.html "Chapter 70. TCP/IP APPLICATION
    LAYER ADDRESSING: UNIFORM RESOURCE IDENTIFIERS, LOCATORS, AND NAMES (URIS, URLS,
    AND URNS)"). Here, we will look at how they are used specifically for the Web.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种需求的结果是定义了万维网三个主要元素之一：*URI*。URI分为两类：*统一资源定位符（URLs）*和*统一资源名称（URNs）*。虽然URI、URL和URN起源于万维网的发展，但现在它们已经被推广，为各种TCP/IP应用层协议提供寻址机制。它们在[第70章](ch70.html
    "第70章。TCP/IP应用层寻址：统一资源标识符、定位符和名称（URIs、URLs和URNs）")中进行了详细描述。在这里，我们将探讨它们在万维网中具体是如何使用的。
- en: Currently, the Web uses URLs almost exclusively; URNs are still in development.
    Web URLs specify the use of HTTP for resource retrieval and are thus normally
    called *HTTP URLs*. These URLs allow a resource such as a document, graphical
    image, or multimedia file to be uniquely addressed by specifying the host name,
    directory path, and filename where it is located.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，万维网几乎完全使用URLs；URNs仍在开发中。万维网URL指定了使用HTTP进行资源检索，因此通常被称为*HTTP URLs*。这些URL允许通过指定资源所在的主机名、目录路径和文件名来唯一地寻址资源，如文档、图形图像或多媒体文件。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Uniform Resource Identifiers (URIs) were developed to allow
    World Wide Web resources to be easily and consistently identified; they are also
    now used for other protocols and applications. The type of URI currently used
    on the Web is the Uniform Resource Locator (URL), which identifies the use of
    HTTP to retrieve a resource, and provides information on where and how it can
    be found and retrieved.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 统一资源标识符（URIs）的开发是为了使万维网资源能够轻松且一致地被识别；它们现在也被用于其他协议和应用。目前万维网上使用的URI类型是统一资源定位符（URL），它标识了使用HTTP来检索资源，并提供了关于资源的位置和检索方式的信息。'
- en: HTTP URL Syntax
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP URL 语法
- en: 'HTTP URLs may be absolute or relative (see "URL Relative Syntax and Base URLs"
    in [Chapter 70](ch70.html "Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING: UNIFORM
    RESOURCE IDENTIFIERS, LOCATORS, AND NAMES (URIS, URLS, AND URNS)") for details
    on the difference between them). Absolute URLs are usually used for hyperlinks
    from one website to another or by users requesting a new document without any
    prior context. Absolute HTTP URLs are based on the following common Internet URL
    syntax:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP URL可以是绝对路径或相对路径（有关它们之间的区别，请参阅[第70章](ch70.html "第70章. TCP/IP 应用层寻址：统一资源标识符、定位符和名称
    (URIs, URLs 和 URNs)")中的“URL 相对语法和基本 URL”）。绝对路径通常用于从一个网站链接到另一个网站，或者用户在没有任何先前上下文的情况下请求新文档。绝对
    HTTP URL基于以下常见的互联网 URL 语法：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For the Web, the scheme is `http:`, and the semantics of the different URL
    elements are defined to have meanings that are relevant to the Web. The general
    structure of an HTTP URL looks like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web，方案是 `http:`，不同 URL 元素的语义被定义为与Web相关的含义。HTTP URL的一般结构如下所示：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These syntactic elements are specifically defined for HTTP absolute URLs as
    follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些句法元素被专门定义为 HTTP 绝对 URL 如下：
- en: '**`<user> and <password>`** Optional authentication information, for resources
    located on password-protected servers. This construct is rarely used in practice,
    so most people don''t realize it is an option. It has thus become a target of
    abuse by con artists who use it to obscure undesirable URLs.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**`<用户> 和 <密码>`** 可选的认证信息，用于位于受密码保护的服务器上的资源。这种结构在实际应用中很少使用，因此大多数人没有意识到这是一个选项。因此，它成为了骗子们用来隐藏不良
    URL 的目标。'
- en: '**`<host>`** The host name of the web server where the resource is located.
    This is usually a fully qualified Domain Name System (DNS) domain name, but it
    may also be an IP address.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**`<主机>`** 存放资源的 Web 服务器的主机名。这通常是一个完全合格的域名系统 (DNS) 域名，但它也可能是一个 IP 地址。'
- en: '**`<port>`** The TCP port number to use for connecting to the web server. This
    defaults to port 80 for HTTP and is usually omitted. In rare cases, you may see
    some other port number used, sometimes to allow two copies of web server software
    devoted to different uses on the same IP address. Port 8080 is especially common
    as an alternative.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**`<端口>`** 用于连接到 Web 服务器的 TCP 端口号。对于 HTTP，默认端口是 80，通常省略。在罕见的情况下，您可能会看到使用其他端口号的情况，有时是为了在同一
    IP 地址上允许两个用于不同用途的 Web 服务器软件副本。端口 8080 特别常见作为替代方案。'
- en: '**`<url-path>`** The path pointing to the specific resource to be retrieved
    using HTTP. This is usually a full directory path expressing the sequence of directories
    to be traversed from the root directory to the place where the resource is located,
    and then the resource''s name. It''s important to remember that the path is case-sensitive,
    even though DNS domain names are not.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**`<url-path>`** 使用 HTTP 获取特定资源的路径。这通常是一个完整的目录路径，表示从根目录到资源所在位置的目录序列，然后是资源名称。重要的是要记住，路径是区分大小写的，尽管
    DNS 域名不是。'
- en: '**`<query>`** An optional query or other information to be passed to the web
    server. This feature is commonly used to implement interactive functions, because
    the query value can be specified by the user and then be passed from the web browser
    to the web server. The alternative method is by using the HTTP POST method.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**`<查询>`** 可选的查询或其他要传递给 Web 服务器的信息。此功能通常用于实现交互式功能，因为查询值可以由用户指定，然后从 Web 浏览器传递到
    Web 服务器。另一种方法是使用 HTTP POST 方法。'
- en: '**`<bookmark>`** Identifies a particular location within an HTML document.
    This is commonly used in very large HTML documents to allow a user to click a
    hyperlink and scroll to a particular place in the document. See the example near
    the end of [Table 79-1](ch79s03.html#common_html_elements-id001 "Table 79-1. Common
    HTML Elements").'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**`<书签>`** 识别 HTML 文档中的特定位置。这在非常大的 HTML 文档中很常见，允许用户点击超链接并滚动到文档中的特定位置。请参阅[表79-1](ch79s03.html#common_html_elements-id001
    "表79-1. 常见 HTML 元素")末尾的示例。'
- en: 'Although the URL syntax for the Web is quite rich and potentially complex,
    most Web URLs are actually quite short. The vast majority of these components
    are omitted, especially the user, password, port, and bookmark elements. Queries
    are used only for special purposes. This leaves the more simplified form you will
    usually encounter for URLs:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Web的URL语法相当丰富且可能复杂，但大多数Web URL实际上相当简短。这些组件中的绝大多数都被省略了，特别是用户、密码、端口和书签元素。查询仅用于特殊目的。这留下了您通常遇到的更简化的URL形式：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Resource Paths and Directory Listings
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源路径和目录列表
- en: The `<url-path>` used to reference a particular document can also be omitted.
    This provides a convenient way for a user to see what content is offered on a
    website without needing to know what particular document to request. For example,
    a user who wants to see the current headlines on CNN would go to [http://www.cnn.com](http://www.cnn.com).
    In this case, the request is sent to the web server for the null document (represented
    by /, which is implied if it is not specified; technically, you are supposed to
    specify [http://www.cnn.com/](http://www.cnn.com/)).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 用来引用特定文档的`<url-path>`也可以省略。这为用户提供了一个方便的方法，可以在不知道要请求哪个特定文档的情况下查看网站提供的内容。例如，想要查看CNN当前头条新闻的用户会访问[http://www.cnn.com](http://www.cnn.com)。在这种情况下，请求被发送到Web服务器上的空文档（由/表示，如果未指定则隐含；技术上，你应该指定[http://www.cnn.com/](http://www.cnn.com/))。
- en: How a / request is handled depends on the server. Technically, such a request
    is actually asking the server, "Please show me the contents of the root directory
    of the server." However, this is both ugly (a listing of filenames is not the
    best way to make a first impression) and a potential security issue (as anyone
    can see the name of every file on the server). Instead, most HTTP servers are
    set up to recognize such requests automatically and return a default document,
    often named something like index.html or default.html. Many servers will similarly
    return a default document of some sort if any other directory is specified in
    a URL; for example, typing [http://www.pcguide.com/ref](http://www.pcguide.com/ref)
    in the URL address bar of a web browser actually returns [http://www.pcguide.com/ref/index.htm](http://www.pcguide.com/ref/index.htm).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如何处理/请求取决于服务器。技术上，这样的请求实际上是在询问服务器：“请显示服务器根目录的内容。”然而，这既不美观（文件名列表不是留下最佳第一印象的方式）也潜在存在安全风险（因为任何人都可以看到服务器上每个文件的名称）。因此，大多数HTTP服务器都设置为自动识别此类请求并返回默认文档，通常命名为index.html或default.html。许多服务器在URL中指定任何其他目录时也会返回某种类型的默认文档；例如，在Web浏览器的URL地址栏中键入[http://www.pcguide.com/ref](http://www.pcguide.com/ref)实际上返回[http://www.pcguide.com/ref/index.htm](http://www.pcguide.com/ref/index.htm)。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*While it is technically incorrect to leave the http:// off an HTTP URL, most
    web browsers will add it automatically if it''s omitted. As a result, many Web
    users are in the habit of entering URLs that are simply a host name, such as [www.tcpipguide.com](http://www.tcpipguide.com)*.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然从技术上讲，在HTTP URL中省略http://是不正确的，但大多数Web浏览器如果省略了它，会自动添加。因此，许多Web用户习惯于输入仅包含主机名的URL，例如[www.tcpipguide.com](http://www.tcpipguide.com)*。'
- en: 'The forms shown here apply to absolute HTTP URLs. URLs may also be relative,
    which is the norm for links between closely related documents, such as graphics
    that go with a document, or between documents in a set or project. In this case,
    usually only a fractional portion of a URL path is specified. This is described
    fully in [Chapter 70](ch70.html "Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING:
    UNIFORM RESOURCE IDENTIFIERS, LOCATORS, AND NAMES (URIS, URLS, AND URNS)").'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的格式适用于绝对HTTP URL。URL也可以是相对的，这在紧密相关的文档之间是常见的，例如与文档一起的图形，或者在一组或项目中的文档之间。在这种情况下，通常只指定URL路径的一部分。这将在[第70章](ch70.html
    "第70章。TCP/IP应用层寻址：统一资源标识符、定位符和名称（URIs、URLs和URNs）")中详细描述。
- en: Chapter 80. HTTP GENERAL OPERATION AND CONNECTIONS
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第80章。HTTP一般操作和连接
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: 'The Hypertext Transfer Protocol (HTTP) began as an extremely basic protocol,
    designed to do just one thing: allow a client to send a simple request for a hypertext
    file and receive it back from the server. Modern HTTP remains at its heart a straightforward
    request/reply protocol, but now includes many new features and capabilities to
    support the growing size of the World Wide Web (the Web) and the ever-increasing
    variety of ways that people have found to use the Web. Therefore, the best place
    to start explaining HTTP is by looking at its operation as a whole and how communication
    takes place between a web server and a web client.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本传输协议（HTTP）最初是一个非常基础的协议，设计用来做一件事：允许客户端发送一个简单的请求来获取超文本文件，并从服务器接收它。现代HTTP在本质上仍然是一个简单的请求/回复协议，但现在包括了众多新特性和功能，以支持不断增长的万维网（Web）规模以及人们不断发现的新用途。因此，解释HTTP的最佳起点是查看其整体操作以及Web服务器和Web客户端之间通信的方式。
- en: In this chapter, I introduce HTTP by describing its operation in general terms.
    I start with an overview of HTTP, discussing its versions and the standards that
    define them. I then discuss its operational model, which is important to understanding
    how HTTP works. I explain the two types of connections that are supported between
    HTTP clients and servers, and the method by which requests can be pipelined in
    the current version of HTTP, HTTP/1.1\. I then provide more information about
    how persistent connections are established, managed, and terminated in HTTP/1.1.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我通过描述其一般操作来介绍HTTP。我首先概述了HTTP，讨论了其版本和定义它们的规范。然后，我讨论了其操作模型，这对于理解HTTP的工作方式非常重要。我解释了HTTP客户端和服务器之间支持的两个类型的连接，以及如何在当前版本的HTTP（HTTP/1.1）中通过流水线请求。然后，我提供了更多关于如何在HTTP/1.1中建立、管理和终止持久连接的信息。
- en: HTTP Versions and Standards
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP版本和标准
- en: 'The World Wide Web had humble beginnings as a research project at the Swiss
    research institute, CERN, the European Organization for Nuclear Research. The
    primary goal of the project was to allow hypertext documents to be electronically
    linked, so selecting a reference in one document to a second document would cause
    the reference document to be retrieved. To implement this system, the researchers
    needed some sort of mechanism to allow a client computer to tell a server to send
    it a document. To fill this function, the early developers of the Web created
    a new TCP/IP application layer protocol: the *Hypertext Transfer Protocol (HTTP)*.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网起源于瑞士研究机构欧洲核子研究组织CERN的一个研究项目。该项目的首要目标是允许超文本文档通过电子方式相互链接，因此在一个文档中选择一个引用到第二个文档会导致引用文档被检索。为了实现这个系统，研究人员需要某种机制来允许客户端计算机告诉服务器发送它一个文档。为了填补这个功能，早期的网络开发者创建了一个新的TCP/IP应用层协议：*超文本传输协议（HTTP）*。
- en: This first version is now known as HTTP/0.9\. Subsequent versions are HTTP/1.0
    and HTTP/1.1.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个版本现在被称为HTTP/0.9。随后的版本是HTTP/1.0和HTTP/1.1。
- en: HTTP/0.9
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP/0.9
- en: The original version of HTTP was intended only for the transfer of hypertext
    documents, and it was designed to be very simple to make implementation of the
    fledgling Web easier. This early HTTP specifies that an HTTP client establishes
    a connection to an HTTP server using the Transmission Control Protocol (TCP).
    The client then issues a single GET request specifying a resource to be retrieved.
    The server responds by sending the file as a stream of text bytes, and the connection
    is terminated. The entire document defining this version of HTTP is only a couple
    of pages long!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的HTTP版本仅用于传输超文本文档，并且设计得非常简单，以便更容易实现新兴的Web。这个早期的HTTP规定，HTTP客户端使用传输控制协议（TCP）与HTTP服务器建立连接。然后客户端发出一个GET请求，指定要检索的资源。服务器通过发送文本字节流作为文件来响应，然后断开连接。定义这个版本HTTP的整个文档只有几页长！
- en: This first version of HTTP was functional but extremely limited in its capabilities.
    It didn't support the transfer of any types of data other than hypertext, and
    it didn't provide any mechanism for any sort of intelligent communication between
    the client and server. This early HTTP prototype was not up to the task of providing
    the basis for data transfer for the future of the Web. It was never made an official
    RFC standard, and, in fact, never even had a formal version number; it is known
    today as HTTP version 0.9, or HTTP/0.9, using the HTTP version format. I believe
    this number has no particular significance, other than being a bit smaller than
    the number of the first official version of the protocol.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTTP的第一个版本在功能上是可行的，但在其能力上极为有限。它不支持传输除超文本之外的其他类型的数据，并且没有提供任何机制来实现客户端和服务器之间的任何智能通信。这个早期的HTTP原型无法为Web的未来数据传输提供基础。它从未成为官方的RFC标准，实际上甚至没有正式的版本号；它今天被称为HTTP版本0.9，或HTTP/0.9，使用HTTP版本格式。我相信这个数字没有特别的意义，除了比协议的第一个官方版本号小一点。
- en: HTTP/1.0
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP/1.0
- en: 'HTTP/0.9''s skeleton of functionality formed the basis for a rapid evolution
    of HTTP in the early 1990s. As the Web grew in size and acceptance, many new ideas
    and features were incorporated into HTTP. The result of a great deal of development
    effort was the formalization of the first HTTP standard: version 1.0\. The standard
    for this much enhanced HTTP was published in May 1996 as RFC 1945, "Hypertext
    Transfer Protocol—HTTP/1.0." It had been in use for several years prior to that
    formal publication date, however.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/0.9 的功能框架为 1990 年代初 HTTP 的快速演变奠定了基础。随着网络的规模和接受度的增长，许多新想法和功能被纳入 HTTP。大量开发工作的结果是第一个
    HTTP 标准的正式化：版本 1.0。这个增强后的 HTTP 标准于 1996 年 5 月作为 RFC 1945 发布，即“超文本传输协议——HTTP/1.0”。然而，在正式发布日期之前，它已经使用了几年。
- en: 'HTTP/1.0 transformed HTTP from a trivial request/response application to a
    true messaging protocol. It described a complete message format for HTTP, and
    explained how it should be used for client requests and server responses. One
    of the most important changes in HTTP/1.0 was the generalization of the protocol
    to handle many types of different media, as opposed to strictly hypertext documents.
    To broaden HTTP''s scope, its developers borrowed concepts and header constructs
    from the Multipurpose Internet Mail Extensions (MIME) standard defined for email
    (discussed in [Chapter 76](ch76.html "Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE
    FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME")). At the same time that it
    defined much more capable web servers and web clients, HTTP/1.0 retained backward-compatibility
    with servers and clients still using HTTP/0.9.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.0 将 HTTP 从一个简单的请求/响应应用程序转变为一个真正的消息协议。它描述了 HTTP 的完整消息格式，并解释了它应该如何用于客户端请求和服务器响应。HTTP/1.0
    最重要的变化之一是将协议泛化以处理多种不同类型的媒体，而不是严格限于超文本文档。为了拓宽 HTTP 的范围，其开发者从为电子邮件定义的多用途互联网邮件扩展（MIME）标准中借鉴了概念和头部结构（在[第
    76 章](ch76.html "第 76 章。TCP/IP 电子邮件消息格式和消息处理：RFC 822 和 MIME")中讨论）。与此同时，它定义了更强大的网页服务器和客户端，HTTP/1.0
    还保留了与仍在使用 HTTP/0.9 的服务器和客户端的向后兼容性。
- en: HTTP/1.0 was the version of HTTP that was widely implemented in the mid-1990s
    as the Web exploded in popularity. After only a couple of years, HTTP accounted
    for the majority of the traffic on the burgeoning Internet. The popularity of
    HTTP was so great that it single-handedly prompted the installation of a lot of
    new hardware to handle the load of browser requests and web server replies.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.0 是 1990 年代中期广泛实施的 HTTP 版本，当时网络在流行度上爆炸式增长。仅仅几年后，HTTP 就占有了新兴互联网上大部分的流量。HTTP
    的普及如此之大，以至于它单方面促使安装了大量新硬件来处理浏览器请求和网页服务器响应的负载。
- en: 'Unfortunately, much of this huge load of traffic was due to some limitations
    in HTTP itself. These only became apparent due to the tremendous growth in the
    use of the protocol, which, combined with the normal growing pains of the Internet,
    led to many frustrated Web users. The inefficiencies of HTTP/1.0 were a result
    of design limitations, such as the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，大量流量中的很大一部分是由于 HTTP 本身的一些限制造成的。这些限制只有在协议使用量激增的情况下才变得明显，这结合了互联网的正常成长痛，导致许多网络用户感到沮丧。HTTP/1.0
    的低效是设计限制的结果，例如以下内容：
- en: The need for each site to be hosted on a different server.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个网站都需要托管在不同的服务器上。
- en: The fact that each HTTP session handled only one client request.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 HTTP 会话只处理一个客户端请求。
- en: A general lack of support for necessary performance-enhancing features such
    as caching, proxying, and partial resource retrieval.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对必要的性能增强功能（如缓存、代理和部分资源检索）的支持普遍不足。
- en: HTTP/1.1
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP/1.1
- en: 'While impatient pundits coined sarcastic terms such as the "World Wide Wait,"
    the Internet Engineering Task Force (IETF) continued to work to improve HTTP.
    In January 1997, the first draft version of HTTP/1.1 appeared, in RFC 2068\. This
    document was later revised and published as RFC 2616, "Hypertext Transfer Protocol—HTTP/1.1,"
    in June 1999\. HTTP/1.1 retains backward-compatibility with both HTTP/1.0 and
    HTTP/0.9\. It is accompanied by RFC 2617, "HTTP Authentication: Basic and Digest
    Access Authentication," which deals with security and authentication issues.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不耐烦的评论家们提出了讽刺性的术语，如“全球等待”，但互联网工程任务组（IETF）继续努力改进 HTTP。1997 年 1 月，HTTP/1.1 的第一个草案版本在
    RFC 2068 中出现。该文件后来经过修订并于 1999 年 6 月作为 RFC 2616 发布，即“超文本传输协议——HTTP/1.1”。HTTP/1.1
    与 HTTP/1.0 和 HTTP/0.9 都保持向后兼容性。它还伴随着 RFC 2617，“HTTP 认证：基本和摘要访问认证”，该文件处理安全和认证问题。
- en: 'HTTP/1.1 introduces several significant improvements over version 1.0 of the
    protocol, most of which specifically address the performance problems I just described.
    Some of the more important improvements in HTTP1/1 include the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.1 相比于协议的 1.0 版本引入了几个显著的改进，其中大部分专门针对我刚才描述的性能问题。HTTP1/1 中一些更重要改进包括以下内容：
- en: '**Multiple Host Name Support** In HTTP/1.0, there was no way to specify the
    host name of the server to which the client needed to connect. As a result, the
    web server at a particular IP address could support only one domain name. This
    was not only inefficient, but it also was exacerbating the depletion of IP addresses
    in the 1990s, because each new web server to come online required a new IP address.
    HTTP/1.1 allows one web server to handle requests for dozens or even hundreds
    of different virtual hosts.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**多主机名支持** 在 HTTP/1.0 中，没有方法可以指定客户端需要连接的服务器的名称。因此，特定 IP 地址的 Web 服务器只能支持一个域名。这不仅效率低下，而且在
    1990 年代还加剧了 IP 地址的枯竭，因为每个上线的新 Web 服务器都需要一个新的 IP 地址。HTTP/1.1 允许一个 Web 服务器处理数十个甚至数百个不同虚拟主机的请求。'
- en: '**Persistent Connections** HTTP/1.1 allows a client to send multiple requests
    for related documents to a server in a single TCP session. This greatly improves
    performance over HTTP/1.0, where each request required a new connection to the
    server.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**持久连接** HTTP/1.1 允许客户端在一个 TCP 会话中向服务器发送多个相关文档的请求。这比 HTTP/1.0 的性能有了很大提升，在 HTTP/1.0
    中，每个请求都需要一个新的连接到服务器。'
- en: '**Partial Resource Selection** In HTTP/1.1, a client can ask for only part
    of a resource, rather than needing the get the entire document, which reduces
    the load on the server and saves transfer bandwidth.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**部分资源选择** 在 HTTP/1.1 中，客户端可以请求资源的部分，而不是需要获取整个文档，这减少了服务器的负载并节省了传输带宽。'
- en: '**Better Caching and Proxying Support** HTTP/1.1 includes many provisions to
    make caching and proxying more efficient and effective than they were in HTTP/1.0\.
    These techniques can improve performance by providing clients with faster replies
    to their requests while reducing the load on servers, as well as enhancing security
    and implementing other functionality.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的缓存和代理支持** HTTP/1.1 包含了许多规定，使得缓存和代理比 HTTP/1.0 更有效率且更有效。这些技术可以通过为客户端提供更快地回复其请求来提高性能，同时减少服务器的负载，以及增强安全性和实现其他功能。'
- en: '**Content Negotiation** HTTP/1.1 has an additional negotiation feature that
    allows the client and server to exchange information to help select the best resource
    or version of a resource when multiple variants are available.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容协商** HTTP/1.1 有一个额外的协商功能，允许客户端和服务器交换信息，以帮助在多个变体可用时选择最佳资源或资源的版本。'
- en: '**Better Security** HTTP/1.1 defines authentication methods and is generally
    more security-aware than HTTP/1.0 was.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的安全性** HTTP/1.1 定义了身份验证方法，并且通常比 HTTP/1.0 更注重安全性。'
- en: In addition to these notable improvements, many other minor enhancements were
    made in HTTP/1.1\. Several of these take the form of new headers that can be included
    in client requests to better control under what circumstances resources are retrieved
    from the server, and headers in server responses to provide additional information
    to the client.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些显著的改进之外，HTTP/1.1 还进行了许多其他小的增强。其中一些以新头部的形式出现，可以包含在客户端请求中，以更好地控制在什么情况下从服务器检索资源，以及服务器响应中的头部提供额外的信息给客户端。
- en: Future HTTP Versions
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来HTTP版本
- en: HTTP/1.1 continues to be the current version of HTTP, even though it is now
    several years old. This may seem somewhat surprising, given how widely used HTTP
    is. Then again, it may because so many millions of servers and clients implement
    HTTP/1.1 that no new version has been created. For a while, there was speculation
    that version 1.2 of HTTP would be developed, but this has not happened yet.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管HTTP/1.1现在已经几年了，但它仍然是当前的HTTP版本。考虑到HTTP的广泛使用，这可能会让人有些惊讶。然而，这也可能是因为有数以百万计的服务器和客户端实现了HTTP/1.1，因此没有创建新的版本。曾经有过关于HTTP
    1.2版本将会开发的猜测，但到目前为止这还没有发生。
- en: In the late 1990s, work began on a method of expanding HTTP through extensions
    to the existing version 1.1\. Development of the *HTTP Extension Framework* proceeded
    for a number of years, and in 1998, a proposed draft for a new Internet standard
    was created. However, HTTP/1.1 is so widely deployed and so important that it
    was very difficult to achieve consensus on any proposal to modify it. As a result,
    when the HTTP Extension Framework was finally published in February 2000 as RFC
    2774, the universal acceptance required for a new standard did not exist. The
    framework was given experimental status and never became a formal standard.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1990 年代末，开始研究通过扩展现有版本 1.1 来扩展 HTTP 的方法。*HTTP 扩展框架* 的开发持续了多年，到 1998 年，为一个新的互联网标准创建了一个提议的草案。然而，由于
    HTTP/1.1 非常广泛部署且非常重要，因此很难就任何修改它的提议达成共识。因此，当 HTTP 扩展框架最终在 2000 年 2 月作为 RFC 2774
    发布时，新的标准所需的普遍接受度并不存在。该框架被赋予实验性状态，从未成为正式标准。
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The engine of the World Wide Web (the Web) is the application
    protocol that defines how web servers and clients exchange information: the *Hypertext
    Transfer Protocol (HTTP)*. The first version of HTTP, HTTP/0.9, was part of the
    early Web and was a very simple request/response protocol with limited capabilities
    that could transfer only text files. The first widely used version was HTTP/1.0,
    which is a more complete protocol that allows the transport of many types of files
    and resources. The current version is HTTP/1.1, which expands HTTP/1.0''s capabilities
    with several features that improve the efficiency of transfers and address many
    of the needs of the rapidly growing modern Web.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 互联网（Web）的引擎是定义服务器和客户端如何交换信息的应用协议：*超文本传输协议（HTTP）*。HTTP 的第一个版本是 HTTP/0.9，它是早期
    Web 的一部分，是一个非常简单的请求/响应协议，只能传输文本文件。第一个广泛使用的版本是 HTTP/1.0，这是一个更完整的协议，允许传输许多类型的文件和资源。当前版本是
    HTTP/1.1，它通过几个提高传输效率并解决许多现代 Web 快速增长需求的功能扩展了 HTTP/1.0 的功能。'
- en: HTTP Operational Model and Client/Server Communication
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 操作模型和客户端/服务器通信
- en: 'While the Web itself has many different facets, HTTP is concerned with only
    one basic function: the transfer of hypertext documents and other files from web
    servers to web clients. In terms of actual communication, clients are chiefly
    concerned with making requests to servers, which respond to those requests.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Web 本身有许多不同的方面，但 HTTP 只关注一个基本功能：从网页服务器向网页客户端传输超文本文档和其他文件。在实际情况中，客户端主要关注向服务器发出请求，服务器对这些请求进行响应。
- en: Thus, even though HTTP includes a lot of functionality to meet the needs of
    clients and servers, when you boil it down, you get a very simple, client/server,
    request/response protocol. In this respect, HTTP more closely resembles a rudimentary
    protocol like the Boot Protocol (BOOTP) or the Address Resolution Protocol (ARP)
    than it does other application layer protocols like the File Transfer Protocol
    (FTP) and the Simple Mail Transfer Protocol (SMTP), which involve multiple communication
    steps and command/reply sequences.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管 HTTP 包含了许多功能以满足客户端和服务器需求，但当你将其简化时，你会得到一个非常简单、客户端/服务器、请求/响应协议。在这方面，HTTP
    更类似于像引导协议（BOOTP）或地址解析协议（ARP）这样的基本协议，而不是像文件传输协议（FTP）和简单邮件传输协议（SMTP）这样的其他应用层协议，后者涉及多个通信步骤和命令/回复序列。
- en: Basic HTTP Client/Server Communication
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本HTTP客户端/服务器通信
- en: 'In its simplest form, the operation of HTTP involves only an HTTP client, usually
    a *web browser* on a client machine, and an HTTP server, more commonly known as
    a *web server*. After a TCP connection is created, the two steps in communication
    are as follows (see [Figure 80-1](ch80s02.html#http_clientserver_communication_in_its_s
    "Figure 80-1. HTTP client/server communication In its simplest form, HTTP communication
    consists of an HTTP Request message sent by a client to a server, which replies
    with an HTTP Response message.")):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，HTTP 的操作仅涉及一个 HTTP 客户端，通常是一个客户端机器上的 *网页浏览器*，以及一个 HTTP 服务器，更常被称为 *网页服务器*。在创建
    TCP 连接之后，通信的步骤如下（参见 [图 80-1](ch80s02.html#http_clientserver_communication_in_its_s
    "图 80-1. HTTP 客户端/服务器通信 在其最简单的形式中，HTTP 通信包括客户端向服务器发送的 HTTP 请求消息，服务器以 HTTP 响应消息回复。"））：
- en: '**Client Request** The HTTP client sends a request message formatted according
    to the rules of the HTTP standard—an *HTTP Request*. This message specifies the
    resource that the client wishes to retrieve or includes information to be provided
    to the server.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端请求** HTTP 客户端发送一个按照 HTTP 标准规则格式化的请求消息——*HTTP 请求*。此消息指定了客户端希望检索的资源，或者包含了要提供给服务器的信息。'
- en: '**Server Response** The server reads and interprets the request. It takes action
    relevant to the request and creates an *HTTP Response* message, which it sends
    back to the client. The response message indicates whether the request was successful,
    and it may also contain the content of the resource that the client requested,
    if appropriate.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器响应** 服务器读取并解释请求。它采取与请求相关的行动，并创建一个 *HTTP 响应* 消息，将其发送回客户端。响应消息指示请求是否成功，如果适当，它还可能包含客户端请求的资源内容。'
- en: '![HTTP client/server communication In its simplest form, HTTP communication
    consists of an HTTP Request message sent by a client to a server, which replies
    with an HTTP Response message.](httpatomoreillycomsourcenostarchimages288307.png.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP 客户端/服务器通信 在其最简单形式中，HTTP 通信包括一个客户端发送给服务器的 HTTP 请求消息，服务器以 HTTP 响应消息回复。](httpatomoreillycomsourcenostarchimages288307.png.jpg)'
- en: Figure 80-1. HTTP client/server communication In its simplest form, HTTP communication
    consists of an HTTP Request message sent by a client to a server, which replies
    with an HTTP Response message.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 80-1. HTTP 客户端/服务器通信 在其最简单形式中，HTTP 通信包括一个客户端发送给服务器的 HTTP 请求消息，服务器以 HTTP 响应消息回复。
- en: In HTTP/1.0, each TCP connection involves only one such exchange, as shown in
    [Figure 80-1](ch80s02.html#http_clientserver_communication_in_its_s "Figure 80-1. HTTP
    client/server communication In its simplest form, HTTP communication consists
    of an HTTP Request message sent by a client to a server, which replies with an
    HTTP Response message."). In HTTP/1.1, multiple exchanges are possible, as you'll
    see soon. Note also that, in some cases, the server may respond with one or preliminary
    responses prior to sending the full response. This may occur if the server sends
    a preliminary response using the 100 Continue status code prior to the actual
    reply. See the description of HTTP status codes in [Chapter 81](ch81.html "Chapter 81. HTTP
    MESSAGES, METHODS, AND STATUS CODES") for more information.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP/1.0 中，每个 TCP 连接仅涉及这样一个交换，如 [图 80-1](ch80s02.html#http_clientserver_communication_in_its_s
    "图 80-1. HTTP 客户端/服务器通信 在其最简单形式中，HTTP 通信包括一个客户端发送给服务器的 HTTP 请求消息，服务器以 HTTP 响应消息回复。")
    所示。在 HTTP/1.1 中，可能存在多个交换，您很快就会看到。注意，在某些情况下，服务器可能在发送完整响应之前，先发送一个或多个初步响应。这可能发生在服务器在发送实际回复之前，使用
    100 Continue 状态码发送一个初步响应。有关 HTTP 状态码的更多描述，请参阅 [第 81 章](ch81.html "第 81 章. HTTP
    消息、方法和状态码")。
- en: Tip
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** HTTP is a client/server-oriented, request/reply protocol. Basic
    communication consists of an *HTTP Request* message sent by an HTTP client to
    an HTTP server, which returns an *HTTP Response* message back to the client.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** HTTP 是一种面向客户端/服务器的请求/回复协议。基本通信包括一个由 HTTP 客户端发送到 HTTP 服务器的 *HTTP 请求*
    消息，服务器随后返回一个 *HTTP 响应* 消息给客户端。'
- en: Intermediaries and the HTTP Request/Response Chain
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理和 HTTP 请求/响应链
- en: The simple request/response pair between a client and server becomes more complex
    when *intermediaries* are placed in the virtual communication path between the
    client and server. These are devices such as *proxies, gateways*, or *tunnels*
    that are used to improve performance, provide security, or perform other necessary
    functions for particular clients or servers. Proxies are particularly commonly
    used on the Web, because they can greatly improve response time for groups of
    related client computers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当在客户端和服务器之间的虚拟通信路径中放置 *代理* 时，客户端和服务器之间的简单请求/响应对会变得更加复杂。这些设备如 *代理、网关* 或 *隧道*
    用于提高性能、提供安全性或为特定客户端或服务器执行其他必要功能。代理在互联网上尤其常用，因为它们可以大大提高相关客户端计算机组的响应时间。
- en: 'When an intermediary is involved in HTTP communication, it acts as a middleman.
    Rather than the client speaking directly to the server and vice versa, each talks
    to the intermediary. This allows the intermediary to perform functions such as
    caching, translation, aggregation, and encapsulation. For example, consider an
    exchange through a single intermediary device. The two-step communication process
    described in the preceding section would become four steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当中间件参与 HTTP 通信时，它充当中间人。而不是客户端直接与服务器通信，反之亦然，每个都通过中间件进行交流。这允许中间件执行诸如缓存、翻译、聚合和封装等功能。例如，考虑通过单个中间设备进行交换。前面章节中描述的两步通信过程将变为四步：
- en: '**Client Request** The HTTP client sends a request message to the intermediary
    device.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端请求** HTTP 客户端向中间设备发送请求消息。'
- en: '**Intermediary Request** The intermediary processes the request, making changes
    to it if necessary. It then forwards the request to the server.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**中间请求** 中间件处理请求，如果需要则对其进行更改。然后它将请求转发到服务器。'
- en: '**Server Response** The server reads and interprets the request, takes appropriate
    action, and then sends a response. Since it received its request from the intermediary,
    its reply goes back to the intermediary.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务器响应** 服务器读取并解释请求，采取适当的行动，然后发送响应。由于它从中间件接收请求，所以它的回复返回到中间件。'
- en: '**Intermediary Response** The intermediary processes the request, again possibly
    making changes, and then forwards it back to the client.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**中间件响应** 中间件处理请求，再次可能进行更改，然后将它转发回客户端。'
- en: As you can see, the intermediary acts as if it were a server from the client's
    perspective and as a client from the server's viewpoint. Many intermediaries are
    designed to be able to intercept a variety of TCP/IP protocols, by posing as the
    server to a client and the client to a server. Most protocols are unaware of the
    existence of intermediaries. HTTP, however, includes special support for certain
    intermediaries such as proxy servers, providing headers that control how intermediaries
    handle HTTP requests and replies. (Proxy servers are discussed in [Chapter 84](ch84.html
    "Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES").)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，从客户端的角度来看，中间件表现得像服务器，从服务器的角度来看，它表现得像客户端。许多中间件被设计成能够拦截各种 TCP/IP 协议，通过充当客户端对服务器和服务器对客户端。大多数协议对中间件的存在一无所知。然而，HTTP
    包含对某些中间件（如代理服务器）的特殊支持，提供控制中间件如何处理 HTTP 请求和响应的头部信息。（代理服务器在[第 84 章](ch84.html "第
    84 章。HTTP 功能、能力和问题")中讨论。）
- en: 'It is possible for two or more intermediaries to be linked together between
    the client and server. For example, the client might send a request to intermediary
    1, which then forwards to intermediary 2, which then talks to the server, as illustrated
    in [Figure 80-2](ch80s02.html#http_requestresponse_chain_using_interme "Figure 80-2. HTTP
    request/response chain using intermediaries Instead of being connected directly,
    an HTTP client and server may be linked using one or more intermediary devices
    such as proxies. In this example, two intermediaries are present. The HTTP Request
    message sent by the client will actually be transferred three times: from the
    client to the first intermediary, then to the second, and finally to the server.
    The HTTP Response message will be created once but transmitted three distinct
    times. The full set of devices participating in the message exchange is called
    the request/response chain."). The process is reversed for the reply. The HTTP
    standard uses the phrase *request/response chain* to refer collectively to the
    entire set of devices involved in an HTTP message exchange.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端和服务器之间，可能存在两个或更多中间件相互连接。例如，客户端可能向中间件 1 发送请求，然后中间件 1 转发到中间件 2，然后中间件 2 与服务器通信，如[图
    80-2](ch80s02.html#http_requestresponse_chain_using_interme "图 80-2. 使用中间件的 HTTP
    请求/响应链。HTTP 客户端和服务器可能通过一个或多个中间设备（如代理服务器）连接。在这个例子中，存在两个中间件。客户端发送的 HTTP 请求消息实际上会被传输三次：从客户端到第一个中间件，然后到第二个，最后到服务器。HTTP
    响应消息只创建一次，但会传输三次。参与消息交换的所有设备集合称为请求/响应链。")所示。回复的过程是相反的。HTTP 标准使用短语“请求/响应链”来指代参与
    HTTP 消息交换的所有设备集合。
- en: '![HTTP request/response chain using intermediaries Instead of being connected
    directly, an HTTP client and server may be linked using one or more intermediary
    devices such as proxies. In this example, two intermediaries are present. The
    HTTP Request message sent by the client will actually be transferred three times:
    from the client to the first intermediary, then to the second, and finally to
    the server. The HTTP Response message will be created once but transmitted three
    distinct times. The full set of devices participating in the message exchange
    is called the request/response chain.](httpatomoreillycomsourcenostarchimages288309.png.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![使用中介的HTTP请求/响应链](httpatomoreillycomsourcenostarchimages288309.png.jpg)'
- en: 'Figure 80-2. HTTP request/response chain using intermediaries Instead of being
    connected directly, an HTTP client and server may be linked using one or more
    intermediary devices such as proxies. In this example, two intermediaries are
    present. The HTTP Request message sent by the client will actually be transferred
    three times: from the client to the first intermediary, then to the second, and
    finally to the server. The HTTP Response message will be created once but transmitted
    three distinct times. The full set of devices participating in the message exchange
    is called the request/response chain.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图80-2. 使用中介的HTTP请求/响应链 与直接连接不同，HTTP客户端和服务器可能通过一个或多个中介设备（如代理）连接。在这个例子中，有两个中介设备。客户端发送的HTTP请求消息实际上会被传输三次：从客户端到第一个中介，然后到第二个，最后到服务器。HTTP响应消息只创建一次，但会传输三次。参与消息交换的全部设备集合称为请求/响应链。
- en: Tip
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The simple client/server operational model of HTTP becomes
    more complicated when *intermediary devices* such as proxies, tunnels, or gateways
    are inserted in the communication path between the HTTP client and server. HTTP/1.1
    is specifically designed with features to support the efficient conveyance of
    requests and responses through a series of steps from the client through the intermediaries
    to the server, and back again. The entire set of devices involved in such a communication
    is called the *request/response* chain.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 当在HTTP客户端和服务器之间的通信路径中插入*中介设备*，如代理、隧道或网关时，简单的客户端/服务器操作模型变得更加复杂。HTTP/1.1特别设计了一些功能，以支持通过一系列步骤高效地传输请求和响应，从客户端通过中介到服务器，然后再返回。参与此类通信的所有设备统称为*请求/响应链*。'
- en: The Impact of Caching on HTTP Communication
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存对HTTP通信的影响
- en: The normal HTTP communication model is changed through the application of *caching*
    to client requests. Various devices on the Web employ caching to store recently
    retrieved resources so they can be quickly supplied in reply to a request. The
    client itself will cache recently accessed web documents, so that if the user
    asks for them again, they can be displayed without even making a request to a
    server. If a request is required, any intermediary device can satisfy a request
    for a file if the file is in its cache.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的HTTP通信模型通过应用*缓存*到客户端请求而改变。网络上的各种设备使用缓存来存储最近检索的资源，以便在响应请求时可以快速提供。客户端本身也会缓存最近访问的网页文档，这样如果用户再次请求它们，它们可以在不向服务器发出请求的情况下显示。如果需要请求，任何中介设备都可以在它的缓存中满足对文件的请求。
- en: 'When a cache is used, the device that has the cached resource requested returns
    it directly, circumventing the normal HTTP communication process. In the example
    shown in [Figure 80-2](ch80s02.html#http_requestresponse_chain_using_interme "Figure 80-2. HTTP
    request/response chain using intermediaries Instead of being connected directly,
    an HTTP client and server may be linked using one or more intermediary devices
    such as proxies. In this example, two intermediaries are present. The HTTP Request
    message sent by the client will actually be transferred three times: from the
    client to the first intermediary, then to the second, and finally to the server.
    The HTTP Response message will be created once but transmitted three distinct
    times. The full set of devices participating in the message exchange is called
    the request/response chain."), if intermediary 1 has the file the client needs,
    it will supply it to the client directly, and intermediary 2 and the web server
    that the client was trying to reach originally will not even be aware that a request
    was ever made. [Chapter 84](ch84.html "Chapter 84. HTTP FEATURES, CAPABILITIES,
    AND ISSUES") provides details on HTTP caching.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用缓存时，拥有请求的缓存资源的设备会直接返回它，绕过了正常的HTTP通信过程。在[图80-2](ch80s02.html#http_requestresponse_chain_using_interme
    "图80-2. 使用中间件的HTTP请求/响应链。HTTP客户端和服务器可能通过一个或多个中间设备（如代理）连接，而不是直接连接。在这个例子中，有两个中间设备。客户端发送的HTTP请求实际上会被传输三次：从客户端到第一个中间设备，然后到第二个，最后到服务器。HTTP响应消息只创建一次，但会传输三次。参与消息交换的所有设备集合称为请求/响应链。"),如果中间件1拥有客户端需要的文件，它将直接提供给客户端，而中间件2以及客户端最初试图到达的原始Web服务器甚至都不会意识到曾经有请求被发起。[第84章](ch84.html
    "第84章. HTTP特性、能力和问题")提供了关于HTTP缓存的详细信息。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Most requests for web resources are made using HTTP URLs based on a Domain
    Name System (DNS) host name. The first step in satisfying such requests is to
    resolve the DNS domain name into an IP address, but this process is separate from
    the HTTP communication itself.*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*大多数对网络资源的请求都是使用基于域名系统（DNS）主机名的HTTP URL进行的。满足此类请求的第一步是将DNS域名解析为IP地址，但这个过程与HTTP通信本身是分开的。*'
- en: HTTP Transitory and Persistent Connections and Pipelining
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP的临时性连接、持久性连接和流水线
- en: 'You just learned that the basic HTTP communication process is a simple two-step
    procedure: A client sends a request to a server, and the server replies back to
    the client. Since this was all that HTTP was intended to do, the first version
    of the protocol was designed so that after a TCP connection was established between
    the client and server, a single request/response exchange was performed. After
    the request was satisfied, the TCP connection was terminated. These *transitory*
    connections were the only type supported by the original HTTP/0.9, and the same
    model was maintained in the more widely deployed HTTP/1.0.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚了解到基本的HTTP通信过程是一个简单的两步程序：客户端向服务器发送请求，服务器回复客户端。由于HTTP原本就是为了做这件事而设计的，因此该协议的第一个版本被设计成在客户端和服务器之间建立TCP连接后，只执行一次请求/响应交换。请求得到满足后，TCP连接就被终止了。这些*临时性*连接是原始HTTP/0.9所支持的唯一类型，在更广泛部署的HTTP/1.0中也保持了同样的模型。
- en: The advantage of this connection model is its conceptual simplicity. The problem
    with it is that it is inefficient when the client needs to make many requests
    to the same server. This is often the case with modern hypertext documents, which
    usually carry inline references to images and other media. A typical client request
    for the home page of a website begins with a single request for a Hypertext Markup
    Language (HTML) file, but then leads to subsequent requests for each of the other
    related files that go with that document.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这种连接模型的优势在于其概念上的简单性。问题是，当客户端需要向同一服务器发送多个请求时，它是不高效的。这在现代超文本文档中很常见，这些文档通常包含对图像和其他媒体的内联引用。一个典型的客户端对网站主页的请求开始于对一个超文本标记语言（HTML）文件的单一请求，但随后会引发对该文档相关其他文件的后续请求。
- en: With transitory connections, each of these requests made by the client requires
    a new, distinct TCP connection to be set up between the client and server. Every
    connection takes server resources and network bandwidth, so needing to establish
    a new one for each file is woefully inefficient. Suppose that you were having
    a conversation with someone whom you needed to ask a series of questions. Now
    imagine that after answering each question, the other person hung up the phone,
    and you had to call her again! You get the picture.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在临时连接中，客户端发出的每个请求都需要在客户端和服务器之间建立一个全新的、独立的TCP连接。每个连接都消耗服务器资源和网络带宽，因此为每个文件建立新的连接效率极低。假设你正在与某人交谈，你需要连续提出一系列问题。现在想象一下，在回答完每个问题后，对方挂断了电话，你不得不再次拨通她！你就能理解这个情况了。
- en: 'There are some people who consider the temporary nature of HTTP/0.9 and HTTP/1.0
    connections to be a design flaw of these early versions of HTTP, but I don''t
    think that this is fair. In the early days, this model of operation was really
    not a big issue; it became problematic only when the use of the Web and hypertext
    evolved. For the first few years of its existence, hypertext was primarily that:
    *text*. Having an HTTP session last just long enough for one request/response
    was generally sufficient, since the whole resource was in one file. It was only
    in the 1990s that hypertext became *hypermedia*, with a heavy emphasis on embedded
    graphics and other files. When web pages changed from simple text to multimedia
    marvels sporting dozens or even hundreds of embedded images, the limitations of
    HTTP/1.0 became obvious.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为HTTP/0.9和HTTP/1.0连接的临时性是这些早期HTTP版本的设计缺陷，但我不认为这是公平的。在早期，这种操作模式并不是一个大问题；只有在Web和超文本的使用演变后，才变得有问题。在其存在的最初几年，超文本主要是这样的：*文本*。HTTP会话只需持续足够长的时间来完成一次请求/响应就足够了，因为整个资源都在一个文件中。只有在20世纪90年代，超文本才变成了*超媒体*，强调嵌入图形和其他文件。当网页从简单的文本变为多媒体奇迹，拥有数十甚至数百个嵌入图像时，HTTP/1.0的限制变得明显。
- en: The solution to the problem came in HTTP/1.1, which allows an HTTP client and
    server to set up a *persistent connection*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 问题解决方案出现在HTTP/1.1中，它允许HTTP客户端和服务器建立一种**持久连接**。
- en: Persistent Connections
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久连接
- en: With persistent connections, the basic operation of HTTP is not changed. The
    main difference is that, by default, the TCP connection is kept open after each
    request/response set, so that the next request and response can be exchanged immediately.
    The session is closed only when the client is finished requesting all the documents
    it needs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在持久连接下，HTTP的基本操作并未改变。主要区别在于，默认情况下，每次请求/响应集之后，TCP连接保持开启状态，以便下一个请求和响应可以立即交换。会话仅在客户端完成请求所有需要的文档后关闭。
- en: Keeping the TCP connection between an HTTP client and server alive between requests
    is probably the single most important way that HTTP/1.1 improves performance over
    HTTP/1.0\. Clients are able to get their files more quickly because they don't
    need to wait for a TCP connection before each resource is retrieved. Server load
    is reduced, and memory use in busy servers is conserved. Network congestion is
    reduced through the elimination of unnecessary TCP handshaking segments.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求之间保持HTTP客户端和服务器之间的TCP连接活跃，可能是HTTP/1.1相对于HTTP/1.0性能提升的最重要方式。客户端能够更快地获取文件，因为它们不需要在检索每个资源之前等待TCP连接。服务器负载减少，繁忙服务器中的内存使用得到节约。通过消除不必要的TCP握手段，减少了网络拥塞。
- en: Pipelining
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道化
- en: 'Persistent connections offer another important performance-enhancing option
    to HTTP clients: the ability to *pipeline* requests. Suppose the client needs
    to send a request for Files A, B, and C to a server. Since the requests for all
    of these files will be sent in the same TCP session, there is no need for the
    client to wait for a response to its request for File A before sending the request
    for File B. The client can send requests in a rapid-fire fashion, one after the
    other. This also improves the efficiency of the server, which will be able to
    fill the requests in the order in which they are received, as soon as it is able,
    without needing to pause to wait for each new request to be sent.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 持久连接为 HTTP 客户端提供了另一个重要的性能提升选项：能够 *管线化* 请求。假设客户端需要向服务器发送对文件 A、B 和 C 的请求。由于所有这些文件的请求都将发送在同一个
    TCP 会话中，客户端在发送对文件 B 的请求之前无需等待对文件 A 请求的响应。客户端可以连续快速地发送请求。这也提高了服务器的效率，服务器将能够按照接收到的顺序尽快填充请求，无需等待每个新请求的发送。
- en: Tip
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** HTTP/0.9 and HTTP/1.0 supported only *transitory connections*
    between an HTTP client and server, where just a single request and response could
    be exchanged on a TCP connection. This is very inefficient for the modern Web,
    where clients frequently need to make dozens of requests to a server. By default,
    HTTP/1.1 operates using *persistent connections*. This means that once a TCP connection
    is established, the client can send many requests to the server and receive replies
    to each in turn. This allows files to be retrieved more quickly, and conserves
    server resources and Internet bandwidth. The client can even *pipeline* its requests,
    sending the second request immediately, without needing to wait for a reply to
    the first request. HTTP/1.1 still supports transitory connections for backward-compatibility,
    when needed.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** HTTP/0.9 和 HTTP/1.0 只支持 HTTP 客户端和服务器之间的 *临时连接*，在 TCP 连接上只能交换一个请求和响应。这对于现代网络来说非常低效，因为客户端经常需要向服务器发送数十个请求。默认情况下，HTTP/1.1
    使用 *持久连接*。这意味着一旦建立了 TCP 连接，客户端就可以向服务器发送多个请求，并依次接收每个请求的回复。这允许更快地检索文件，并节省服务器资源和互联网带宽。客户端甚至可以在发送第一个请求的回复之前发送第二个请求。HTTP/1.1
    仍然支持临时连接以实现向后兼容性，当需要时。'
- en: 'The obvious advantages of persistent connections make them the default for
    modern HTTP communication, but they do have one drawback: They complicate the
    process of sending data from the server to the client. With transitory connections,
    the client knows that all of the data it receives back from the server is in reply
    to the one request it sent. Once it has all the bytes the server sent and the
    TCP session ends, the client knows the file is complete.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 持久连接的明显优势使它们成为现代 HTTP 通信的默认选项，但它们确实有一个缺点：它们使从服务器向客户端发送数据的过程复杂化。在临时连接中，客户端知道它从服务器接收到的所有数据都是对它发送的一个请求的回复。一旦它收到了服务器发送的所有字节并且
    TCP 会话结束，客户端就知道文件已经完成。
- en: With persistent connections, and especially when pipelining is used, the server
    will typically be sending one file after the other to the client, which must differentiate
    them. Remember that TCP sends data as just a series of unstructured bytes; the
    application must take care of specifying where the dividing points are between
    files. This means that persistent connections and pipelining lead to data length
    issues that must be specially addressed in HTTP.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用持久连接，尤其是当使用管线化时，服务器通常会向客户端连续发送一个文件接着另一个文件，客户端必须区分它们。记住 TCP 将数据作为一系列无结构的字节发送；应用程序必须负责指定文件之间的分隔点。这意味着持久连接和管线化导致的数据长度问题必须在
    HTTP 中特别处理。
- en: To provide compatibility with older versions of the software, HTTP/1.1 servers
    still support transitory connections, and they will automatically close the TCP
    connection after one response if they receive an HTTP/0.9 or HTTP/1.0 request.
    HTTP/1.1 clients may also specify in their initial request that they do not want
    to use persistent connections.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与旧版本的软件保持兼容性，HTTP/1.1 服务器仍然支持临时连接，并且如果它们收到 HTTP/0.9 或 HTTP/1.0 请求，它们将自动在发送一个响应后关闭
    TCP 连接。HTTP/1.1 客户端也可以在其初始请求中指定它们不想使用持久连接。
- en: HTTP Persistent Connection Establishment and Management
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 持久连接的建立和管理
- en: As with most TCP/IP client/server protocols, in establishing a persistent connection,
    the HTTP server plays the passive role by listening for requests on a particular
    port number. The default port number for HTTP is well-known TCP port number 80,
    and is used by web browsers for most HTTP requests, unless a different port number
    is specified in the Uniform Resource Locator (URL). The client initiates an HTTP
    connection by opening a TCP connection from itself to the server it wishes to
    contact.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数TCP/IP客户端/服务器协议一样，在建立持久连接时，HTTP服务器通过监听特定端口号上的请求来扮演被动角色。HTTP的默认端口号是众所周知的TCP端口号80，并且被网页浏览器用于大多数HTTP请求，除非在统一资源定位符（URL）中指定了不同的端口号。客户端通过从自身到它希望联系的服务器打开一个TCP连接来启动HTTP连接。
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*A DNS name resolution step may precede the entire HTTP connection, since most
    URLs contain a host name, while HTTP requires that the client know the server''s
    IP address. This can lead to confusion, because DNS uses the User Datagram Protocol
    (UDP), but HTTP uses TCP. This causes some people to think that HTTP uses UDP.*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*DNS名称解析步骤可能在整个HTTP连接之前进行，因为大多数URL包含一个主机名，而HTTP要求客户端知道服务器的IP地址。这可能会导致混淆，因为DNS使用用户数据报协议（UDP），但HTTP使用TCP。这导致一些人认为HTTP使用UDP。*'
- en: 'Once the TCP connection is active, the client sends its first request message.
    The request specifies which version of HTTP the client is using. If this is HTTP/0.9
    or HTTP/1.0, the server will automatically work in the transitory connection model,
    and it will send only one reply and then close the link. If it is HTTP/1.1, the
    assumption is that a persistent connection is desired. An HTTP/1.1 client can
    override this by including the special Connection: Close header in its initial
    request, which tells the server it does not want to keep the session active after
    the request it is sending has been fulfilled.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦TCP连接激活，客户端就会发送它的第一个请求消息。请求指定客户端正在使用哪个版本的HTTP。如果是HTTP/0.9或HTTP/1.0，服务器将自动在过渡连接模式下工作，并且它只会发送一个回复然后关闭连接。如果是HTTP/1.1，假设希望持久连接。一个HTTP/1.1客户端可以通过在其初始请求中包含特殊的Connection:
    Close头来自定义这个假设，这告诉服务器它不希望在发送的请求得到满足后保持会话活跃。'
- en: Assuming that a persistent connection is being used, the client may begin pipelining
    subsequent requests after sending its first request, while waiting for a response
    from the server to the initial query. As the server starts to respond to requests,
    the client processes them and takes action, such as displaying the data retrieved
    to the user. The data received from the server may also prompt the client to request
    more files on the same connection, as in the case of an HTML document that contains
    references to images.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 假设正在使用持久连接，客户端在发送第一个请求并等待服务器对初始查询的响应时，可以开始管道后续请求。随着服务器开始响应请求，客户端处理它们并采取行动，例如向用户显示检索到的数据。从服务器接收到的数据也可能促使客户端在相同的连接上请求更多文件，例如包含图像引用的HTML文档。
- en: The server will generally buffer a certain number of pipelined requests from
    the client. In the case where the client sends too many requests too quickly,
    the server may throttle back the client using the flow-control mechanism built
    into TCP. In theory, the server could also just decided to terminate the connection
    with the client, but it is better for it to use TCP's existing features. Closing
    the connection will cause the client to initiate a new connection, potentially
    exacerbating any overloading problem.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器通常会在客户端缓冲一定数量的管道请求。在客户端发送请求过于频繁的情况下，服务器可能会使用TCP内置的流量控制机制来限制客户端。理论上，服务器也可以选择与客户端终止连接，但最好还是使用TCP现有的功能。关闭连接将导致客户端启动一个新的连接，这可能会加剧任何过载问题。
- en: 'The flow of requests and responses continues for as long as the client has
    requests. The connection can be gracefully terminated by the client by including
    the Connection: Close header in the last request it needs to send to the server.
    All requests are filled in order, so the server will satisfy all outstanding requests,
    and then close the session.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '请求和响应的流动将持续到客户端有请求为止。客户端可以通过在其需要发送给服务器的最后一个请求中包含Connection: Close头来优雅地终止连接。所有请求都是按顺序填充的，因此服务器将满足所有未完成的请求，然后关闭会话。'
- en: Since HTTP/1.1 supports pipelining of requests, there is usually no need for
    a client to establish more than one simultaneous connection to the same server.
    Clients occasionally do this anyway to allow them to get information from a server
    more quickly. This is considered by many to be "antisocial," because it can lead
    to a busy server's resources being monopolized by one client to the exclusion
    of others that want to access it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTTP/1.1支持请求管线化，通常客户端不需要与同一服务器建立多个并发连接。客户端偶尔也会这样做，以便更快地从服务器获取信息。许多人认为这是“反社会的”，因为它可能导致一个繁忙的服务器资源被一个客户端垄断，而其他想要访问它的客户端则无法访问。
- en: Under special circumstances, either the client or the server may unexpectedly
    close an active persistent connection. For example, if the client detects that
    too much time has elapsed since the server last replied, it may conclude that
    the server has crashed and terminate the connection. Similarly, the server might
    receive a shutdown command from its administrator or for other reasons end a session
    with a client abruptly. Servers normally avoid closing down a link during the
    middle of sending a response.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在特殊情况下，客户端或服务器可能会意外地关闭一个活跃的持久连接。例如，如果客户端检测到自服务器上次回复以来已经过去太多时间，它可能会得出结论，服务器已崩溃并终止连接。同样，服务器可能会收到管理员发出的关闭命令或其他原因突然结束与客户端的会话。服务器通常避免在发送响应过程中关闭连接。
- en: Both clients and servers must be able to handle abrupt session termination.
    For servers, there is not much to do; if the client terminates the connection,
    the server simply cleans up any resources associated with the connection, and
    then goes on to service the next client.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器都必须能够处理突然的会话终止。对于服务器来说，没有太多的事情要做；如果客户端终止连接，服务器只需清理与连接相关的任何资源，然后继续为下一个客户端提供服务。
- en: Clients have more to do when a server prematurely terminates a session, and
    this is especially the case when requests are pipelined. The client must keep
    track of all requests sent to the server to ensure that each is filled. If the
    server closes the session unexpectedly, the client will usually attempt to establish
    a new connection to retransmit the unfilled requests. Since an abrupt session
    termination is often a sign of a busy server, the HTTP standard specifies that
    clients use a binary exponential back-off algorithm to wait a variable but increasing
    amount of time before resubmitting requests for files (similar in concept to the
    method used to deal with collisions in Ethernet). This helps prevent clients from
    piling on requests to a device that is already overwhelmed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器提前终止会话时，客户端需要做更多的工作，尤其是在请求管线化时更是如此。客户端必须跟踪发送给服务器的所有请求，以确保每个请求都被满足。如果服务器意外关闭会话，客户端通常会尝试建立一个新的连接来重新传输未满足的请求。由于突然的会话终止通常是一个繁忙服务器的标志，HTTP标准指定客户端使用二进制指数退避算法，在重新提交文件请求之前等待一个可变但逐渐增加的时间（与处理以太网中的冲突所使用的方法类似）。这有助于防止客户端向已经超负荷的设备堆积请求。
- en: Chapter 81. HTTP MESSAGES, METHODS, AND STATUS CODES
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第81章 HTTP 消息、方法和状态码
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: As you saw in the previous chapter, the Hypertext Transfer Protocol (HTTP) is
    entirely oriented around the sending of client requests and server responses.
    These take the form of *HTTP messages* sent between clients and servers. As with
    all protocols, HTTP uses a special format that dictates the structure of both
    client Request messages and server Response messages. Understanding how these
    messages work is a big part of comprehending HTTP as a whole.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中看到的，超文本传输协议（HTTP）完全围绕发送客户端请求和服务器响应而构建。这些是以客户端和服务器之间发送的*HTTP消息*的形式出现的。与所有协议一样，HTTP使用一种特殊的格式，该格式规定了客户端请求消息和服务器响应消息的结构。理解这些消息的工作原理是理解HTTP整体的重要组成部分。
- en: In this chapter, I describe the messages used by HTTP and the specific commands
    and responses issued by clients and servers. I begin with a look at the generic
    HTTP message format and the major components of every HTTP message. I then discuss
    the specific formats used for both Request and Response messages. I explain the
    different types of HTTP methods (commands) used in client requests and the HTTP
    status codes used in server replies.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将描述HTTP使用的消息以及客户端和服务器发出的特定命令和响应。我首先查看通用HTTP消息格式和每个HTTP消息的主要组成部分。然后，我讨论请求和响应消息的具体格式。我解释了客户端请求中使用的不同类型的HTTP方法（命令）以及服务器回复中使用的HTTP状态码。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Much of the functionality of HTTP is implemented using header fields that
    appear at the start of each HTTP Request and Response message. Headers are covered
    in detail in the next chapter*.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*HTTP的大部分功能都是通过在每个HTTP请求和响应消息的开始处出现的标题字段实现的。标题将在下一章中详细讨论*。'
- en: HTTP Generic Message Format
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP通用消息格式
- en: 'As you learned in the previous chapter, all of the communication between devices
    using HTTP takes place via HTTP messages, of which there are only two types: *Request*
    and *Response messages*. Clients usually send requests and receive responses,
    while servers receive requests and send responses. Intermediate devices such as
    gateways or proxies may send and receive both types of messages.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在上一章所学，使用HTTP的设备之间的所有通信都通过HTTP消息进行，其中只有两种类型：*请求*和*响应消息*。客户端通常发送请求并接收响应，而服务器接收请求并发送响应。中间设备，如网关或代理，可以发送和接收这两种类型的消息。
- en: 'All HTTP messages are created to fit a message structure that the standard
    calls the *generic message format*. Like most of the other TCP/IP messaging protocols,
    HTTP does not use a binary message format; rather, the messages are text-based.
    HTTP messages are based loosely on the electronic mail (email) RFC 822 and 2822
    message standards, as well as the Multipurpose Internet Mail Extensions (MIME)
    standard (described in [Chapter 76](ch76.html "Chapter 76. TCP/IP ELECTRONIC MAIL
    MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME")). I say "loosely" because
    HTTP messages are similar in construction to email messages but do not strictly
    follow all of the email or MIME format requirements. One difference is that not
    all of the RFC 822 and MIME headers are used; there are other differences as well,
    which we will soon examine.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 所有HTTP消息都是为了适应标准称为*通用消息格式*的消息结构而创建的。像大多数其他TCP/IP消息协议一样，HTTP不使用二进制消息格式；相反，消息是基于文本的。HTTP消息基于电子邮件（email）RFC
    822和2822消息标准，以及多用途互联网邮件扩展（MIME）标准（在第76章中描述）。我说“基于”，因为HTTP消息在结构上与电子邮件消息相似，但并不严格遵循所有电子邮件或MIME格式要求。一个区别是，并不是所有RFC
    822和MIME标题都被使用；还有其他区别，我们很快就会探讨。
- en: 'The HTTP generic message format is as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP通用消息格式如下：
- en: '| <*start-line*> |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| <*起始行*> |'
- en: '| <*message-headers*> |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| <*消息头*> |'
- en: '| <*empty-line*> |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| <*空行*> |'
- en: '| [<*message-body*>] |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| [<*消息体*>] |'
- en: '| [<*message-trailers*>] |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| [<*消息尾部*>] |'
- en: 'You can see that this is pretty much the same as the format used for email
    messages: headers, an empty line, and then a message body. All text lines are
    terminated with the standard carriage return-line feed (CRLF) control character
    sequence. The empty line contains just those two characters and nothing else.
    The headers are always sent as regular text. The body, however, may be either
    text or 8-bit binary information, depending on the nature of the data to be sent.
    (This is another way that HTTP does not adhere strictly to the RFC 822 standard;
    see the discussion of entities and media types in [Chapter 83](ch83.html "Chapter 83. HTTP
    Entities, Transfers, Coding Methods, and Content Management") for a full discussion.)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这基本上与用于电子邮件消息的格式相同：标题、一个空行，然后是消息体。所有文本行都以标准的回车换行（CRLF）控制字符序列结束。空行只包含这两个字符，没有其他内容。标题始终以常规文本发送。然而，正文可以是文本或8位二进制信息，具体取决于要发送的数据的性质。（这是HTTP不完全遵循RFC
    822标准的一种方式；有关实体和媒体类型的详细讨论，请参阅[第83章](ch83.html "第83章。HTTP实体、传输、编码方法和内容管理")。）
- en: 'The generic message format has the following components:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通用消息格式有以下组成部分：
- en: '**Start Line** The *start line* is a special text line that conveys the nature
    of the message. In a request, this line indicates the nature of the request, in
    the form of a *method*, as well as specifying a Uniform Resource Identifier (URI)
    to indicate the resource that is the object of the request. Responses use the
    start line to indicate status information in reply to a request. You can find
    more details on the use of the start line in the following sections in this chapter
    that detail HTTP Request messages and Response messages.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**起始行** *起始行* 是一个特殊的文本行，它传达了消息的性质。在请求中，这一行以 *方法* 的形式表明请求的性质，并指定一个统一资源标识符 (URI)，以指示请求的对象资源。响应使用起始行来指示对请求的响应状态信息。您可以在本章以下各节中找到更多关于起始行使用的详细信息，这些节详细介绍了
    HTTP 请求消息和响应消息。'
- en: '**Message Headers** Many dozens of message headers are defined in HTTP. These
    headers are organized into groups by function, as described in the following sections
    in this chapter. Almost all of these headers are optional; the one exception is
    the Host header, which must be present in each request in HTTP/1.1\. Headers may
    be sent in any order, and they all follow the same header format used in email
    messages: <*header-name*>: <*header-value*>.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息头** HTTP 中定义了许多十几个消息头。这些头根据功能分组，如本章以下各节所述。几乎所有这些头都是可选的；唯一的例外是 Host 头，在
    HTTP/1.1 的每个请求中都必须存在。头可以按任何顺序发送，并且它们都遵循在电子邮件消息中使用的相同头格式：`<header-name>: <header-value>`。'
- en: '**Message Body** The message body is optional, because it is needed only for
    certain types of messages. The body may carry a set of information to be communicated
    between the client and server, such as a detailed error message in a response.
    More commonly, it carries a file or other resource, which is formally called an
    *entity* in the HTTP standard. Entities are most often found in the body of a
    Response message, since most client requests ask for a server to send a file or
    other resource. However, they can also be found in certain Request messages. HTTP
    supports many kinds of entities, as described in detail in [Chapter 83](ch83.html
    "Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management").'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息体** 消息体是可选的，因为它只适用于某些类型的消息。消息体可以携带一组需要在客户端和服务器之间传递的信息，例如响应中的详细错误消息。更常见的是，它携带一个文件或其他资源，在
    HTTP 标准中正式称为 *实体*。实体通常在响应消息的体中找到，因为大多数客户端请求要求服务器发送一个文件或其他资源。然而，它们也可以在某些请求消息中找到。HTTP
    支持许多类型的实体，如[第 83 章](ch83.html "第 83 章。HTTP 实体、传输、编码方法和内容管理")中详细描述。'
- en: '**Message Trailers** As described in the previous chapter, HTTP/1.1 uses persistent
    connections by default, so messages are sent in a steady stream from client to
    server and server to client. This requires some means to mark where one message
    ends and the next begins, which is usually accomplished in one of two ways. The
    first is using a special header that indicates the length of the message, so the
    receiving device knows when the entire message has been received. The second is
    a method called *chunking*, where a message is broken into pieces for transmission,
    and the length of each piece is indicated in the message body. When chunking is
    done, a set of message *trailers* may follow the body of the message. Trailers
    are actually the same as headers, except for their position in the file, but they
    may only be used for entity headers. See [Chapter 83](ch83.html "Chapter 83. HTTP
    Entities, Transfers, Coding Methods, and Content Management") for more details
    on trailers and chunked data.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息尾** 如前一章所述，HTTP/1.1 默认使用持久连接，因此消息从客户端到服务器再到客户端以稳定的流发送。这需要某种方法来标记一条消息的结束和下一条消息的开始，这通常通过两种方式之一实现。第一种是使用一个特殊头，它指示消息的长度，这样接收设备就知道整个消息已经接收完毕。第二种是称为
    *分块传输* 的方法，其中消息被分成几部分进行传输，每部分的长度在消息体中指示。当进行分块传输时，可能有一组消息 *尾* 随着消息体发送。尾实际上与头相同，只是它们在文件中的位置不同，但它们只能用于实体头。有关尾和分块数据的更多详细信息，请参阅[第
    83 章](ch83.html "第 83 章。HTTP 实体、传输、编码方法和内容管理")。'
- en: Tip
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** All HTTP messages conform to a structure called the *generic
    message format*. This format is based on the RFC 822 and MIME electronic mail
    message standards, although HTTP does not follow those formats precisely. Each
    HTTP message begins with a start line, then contains a number of message headers,
    followed by an empty line and optionally a message body. The body of the message
    may contain a resource such as a file to be communicated between client and server,
    called an *entity*.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 所有 HTTP 消息都符合称为 *通用消息格式* 的结构。此格式基于 RFC 822 和 MIME 电子邮件消息标准，尽管 HTTP
    并不完全遵循这些格式。每个 HTTP 消息都以一个起始行开始，然后包含多个消息头部，接着是一个空行，然后可选地包含一个消息体。消息体可能包含一个资源，例如一个在客户端和服务器之间通信的文件，称为
    *实体*。'
- en: HTTP Request Message Format
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 请求消息格式
- en: The client initiates an HTTP session by opening a TCP connection to the HTTP
    server with which it wishes to communicate. It then sends *HTTP Request messages*
    to the server, each of which specifies a particular type of action that the user
    of the HTTP client would like the server to take. Requests can be generated either
    by specific user action (such as clicking a hyperlink in a web browser) or indirectly
    as a result of a prior action (such as a reference to an inline image in an HTML
    document leading to a request for that image).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通过向它希望通信的 HTTP 服务器打开一个 TCP 连接来启动一个 HTTP 会话。然后，它向服务器发送 *HTTP 请求消息*，每条消息都指定了
    HTTP 客户端用户希望服务器执行的一种特定类型的操作。请求可以由特定的用户操作（例如在网页浏览器中点击超链接）或先前操作的结果（例如在 HTML 文档中引用内联图像导致对该图像的请求）间接生成。
- en: 'HTTP Request messages use a format that is based on the generic message format
    described in the previous section, but specific to the needs of requests. The
    structure of this format is as follows (see [Figure 81-1](ch81s02.html#http_request_message_format_this_diagram
    "Figure 81-1. HTTP Request message format This diagram shows the structural elements
    of an HTTP Request message and an example of the sorts of headers a Request message
    might contain. Like most HTTP requests, this one carries no entity, so there are
    no entity headers and the message body is empty. See Figure 81-2 for the HTTP
    Response message format.")):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'HTTP 请求消息使用一种基于上一节中描述的通用消息格式的格式，但针对请求的具体需求。此格式的结构如下（参见[图 81-1](ch81s02.html#http_request_message_format_this_diagram
    "图 81-1. HTTP 请求消息格式 此图展示了 HTTP 请求消息的结构元素以及请求消息可能包含的头部示例。像大多数 HTTP 请求一样，此请求不携带实体，因此没有实体头部，消息体为空。有关
    HTTP 响应消息格式的详细信息，请参阅图 81-2。")):'
- en: '| <*request-line*> |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| [<*请求行*>] |'
- en: '| <*general-headers*> |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| [<*通用头部*>] |'
- en: '| <*request-headers*> |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| [<*请求头部*>] |'
- en: '| <*entity-headers*> |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| [<*实体头部*>] |'
- en: '| <*empty-line*> |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| [<*空行*>] |'
- en: '| [<*message-body*>] |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| [<*消息体*>] |'
- en: '| [<*message-trailers*>] |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| [<*消息尾部*>] |'
- en: '![HTTP Request message format This diagram shows the structural elements of
    an HTTP Request message and an example of the sorts of headers a Request message
    might contain. Like most HTTP requests, this one carries no entity, so there are
    no entity headers and the message body is empty. See for the HTTP Response message
    format.](httpatomoreillycomsourcenostarchimages288311.png.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP 请求消息格式 此图展示了 HTTP 请求消息的结构元素以及请求消息可能包含的头部示例。像大多数 HTTP 请求一样，此请求不携带实体，因此没有实体头部，消息体为空。有关
    HTTP 响应消息格式的详细信息，请参阅。](httpatomoreillycomsourcenostarchimages288311.png.jpg)'
- en: Figure 81-1. HTTP Request message format This diagram shows the structural elements
    of an HTTP Request message and an example of the sorts of headers a Request message
    might contain. Like most HTTP requests, this one carries no entity, so there are
    no entity headers and the message body is empty. See [Figure 81-2](ch81s03.html#http_response_message_format_this_figure
    "Figure 81-2. HTTP Response message format This figure illustrates the construction
    of an HTTP Response message and includes an example of both message headers and
    body. The status code 200 indicates that this is a successful response to a request;
    it contains a brief text HTML entity in the message body. See Figure 81-1 for
    the HTTP Request message format.") for the HTTP Response message format.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 81-1. HTTP 请求消息格式 此图展示了 HTTP 请求消息的结构元素以及请求消息可能包含的头部示例。像大多数 HTTP 请求一样，此请求不携带实体，因此没有实体头部，消息体为空。有关
    HTTP 响应消息格式的信息，请参阅[图 81-2](ch81s03.html#http_response_message_format_this_figure
    "图 81-2. HTTP 响应消息格式 此图说明了 HTTP 响应消息的构建，并包括消息头部和主体的示例。状态码 200 表示这是一个对请求的成功响应；消息体包含一个简短的文本
    HTML 实体。有关 HTTP 请求消息格式的信息，请参阅图 81-1。")。
- en: Request Line
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求行
- en: 'The generic *start line* that begins all HTTP messages is called a *request
    line* in Request messages. Its has three main purposes:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 HTTP 消息开始处的通用 *起始行* 在请求消息中称为 *请求行*。它有三个主要目的：
- en: To indicate the command or action that the client wants performed
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示客户端希望执行的操作
- en: To specify a resource on which the action should be taken
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要指定应执行操作的资源
- en: To indicate to the server what version of HTTP the client is using
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向服务器指示客户端正在使用 HTTP 的哪个版本
- en: 'The formal syntax for the request line is as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 请求行的正式语法如下：
- en: <*METHOD* > <*request-uri*> <*HTTP-VERSION*>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: <*METHOD* > <*request-uri*> <*HTTP-VERSION*>
- en: Each of the request line components is discussed in the following sections.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节将讨论请求行组件。
- en: Method
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: 'The *method* is simply the type of action that the client wants the server
    to take; it is always specified in uppercase letters. There are eight standard
    methods defined in HTTP/1.1, of which three are widely used: *GET, HEAD*, and
    *POST*. They are called *methods*, rather than *commands*, because the HTTP standard
    uses terminology from object-oriented programming. I explain this and also describe
    the methods themselves in the "HTTP Methods" section later in this chapter.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法* 简单地是客户端希望服务器执行的动作类型；它始终以大写字母指定。HTTP/1.1 定义了八个标准方法，其中三个被广泛使用：*GET, HEAD*
    和 *POST*。它们被称为 *方法* 而不是 *命令*，因为 HTTP 标准使用了面向对象编程的术语。我将在本章后面的 "HTTP 方法" 部分解释这一点，并描述这些方法本身。'
- en: Request URI
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求 URI
- en: 'The *request URI* is the URI of the resource to which the request applies.
    While URIs can theoretically refer to either Uniform Resource Locators (URLs)
    or Uniform Resource Names (URNs), currently, a URI is almost always an HTTP URL
    that follows the standard syntax rules of Web URLs, as described in [Chapter 70](ch70.html
    "Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING: UNIFORM RESOURCE IDENTIFIERS,
    LOCATORS, AND NAMES (URIS, URLS, AND URNS)").'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*请求 URI* 是请求所应用的资源的 URI。虽然 URI 从理论上可以指代统一资源定位符 (URL) 或统一资源名称 (URN)，但目前，URI
    几乎总是遵循 Web URL 的标准语法规则，即 HTTP URL，如[第 70 章](ch70.html "第 70 章。TCP/IP 应用层寻址：统一资源标识符、定位符和名称
    (URIs, URLs, 和 URNs)")所述。'
- en: Interestingly, the exact form of the URL used in the HTTP request line usually
    differs from that used in HTML documents or entered by users. This is because
    some of the information in a full URL is used to control HTTP itself. It is needed
    as part of the communication between the user and the HTTP client, but not in
    the request from the client to the server. The standard method of specifying a
    resource in a request is to include the path and filename in the request line
    (as well as any optional query information), while specifying the host in the
    special Host header that must be used in HTTP/1.1 Request messages.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，HTTP 请求行中使用的 URL 的确切形式通常与 HTML 文档中使用的或用户输入的 URL 不同。这是因为完整 URL 中的某些信息用于控制
    HTTP 本身。它是用户与 HTTP 客户端之间通信的一部分，但不在客户端向服务器的请求中使用。在请求中指定资源的标准方法是在请求行中包含路径和文件名（以及任何可选的查询信息），同时在
    HTTP/1.1 请求消息中必须使用的特殊 Host 头部中指定主机。
- en: 'For example, suppose the user enters a URL such as `http://www.myfavoritewebsite.com:8080/chatware/chatroom.php`.
    We obviously don''t need to send the `http`: to the server. The client would take
    the remaining information and split it so the URI was specified as `/chatware/chatroom.php`
    and the Host line would contain `www.myfavoritewebsite.com:8080`. Thus, the start
    of the request would look like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设用户输入了一个像`http://www.myfavoritewebsite.com:8080/chatware/chatroom.php`这样的URL。显然，我们不需要将`http:`发送到服务器。客户端将取剩余的信息，将其分割，使URI指定为`/chatware/chatroom.php`，而Host行将包含`www.myfavoritewebsite.com:8080`。因此，请求的开始看起来像这样：
- en: '[PRE18]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The exception to this rule is when a request is being made to a proxy server.
    In that case, the request is made using the full URL in its original form, so
    that it can be processed by the proxy just as the original client processed it.
    The request would look like this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则的例外情况是当请求是发送给代理服务器时。在这种情况下，请求使用其原始形式的完整URL，这样它就可以像原始客户端处理它一样被代理处理。请求看起来像这样：
- en: '[PRE19]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, there is one special case where a single asterisk can be used instead
    of a real URL. This is for the OPTIONS method, which does not require the specification
    of a resource. (Nominally, the asterisk means the method refers to the server
    itself.)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一种特殊情况，可以使用单个星号代替实际的URL。这是用于OPTIONS方法的，该方法不需要指定资源。（名义上，星号表示方法指的是服务器本身。）
- en: HTTP Version
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP版本
- en: The *HTTP version* element tells the server which version the client is using,
    so the server knows how to interpret the request, and what to send and not to
    send the client in its response. For example, a server receiving a request from
    a client using HTTP/0.9 or HTTP/1.0 will assume that a transitory connection is
    being used rather than a persistent one (as explained in the previous section),
    and the server will avoid using HTTP/1.1 headers in its reply. The version token
    is sent in uppercase letters, as HTTP/0.9, HTTP/1.0, or HTTP/1.1—just the way
    I've been doing throughout my discussion of the protocol.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*HTTP版本* 元素告诉服务器客户端正在使用哪个版本，这样服务器就知道如何解释请求，以及在其响应中向客户端发送什么内容，不发送什么内容。例如，接收来自使用HTTP/0.9或HTTP/1.0的客户端请求的服务器将假设正在使用临时连接而不是持久连接（如前所述），并且服务器将避免在其回复中使用HTTP/1.1头。版本令牌以大写字母发送，如HTTP/0.9、HTTP/1.0或HTTP/1.1——正如我在讨论协议时一直所做的那样。'
- en: Headers
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头部
- en: 'After the request line come any of the headers that the client wants to include
    in the message. In these headers, details are provided to the server about the
    request. The headers all use the same structure, but are organized into the following
    categories based on the functions they serve and whether they are specific to
    one kind of message:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求行之后，可以包含客户端想要包含在消息中的任何头。在这些头中，向服务器提供了有关请求的详细信息。所有头都使用相同的结构，但根据它们所执行的功能以及是否特定于某种消息，被组织成以下几类：
- en: '**General Headers** General headers refer mainly to the message itself, as
    opposed to its contents, and they are used to control its processing or provide
    the recipient with extra information. They are not particular to either Request
    or Response messages, so they can appear in either. Also, they are not specifically
    relevant to any entity the message may be carrying.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用头** 通用头主要指的是消息本身，而不是其内容，它们用于控制消息的处理或向接收者提供额外信息。它们既不是请求消息也不是响应消息特有的，因此它们可以出现在任何一种消息中。此外，它们与消息可能携带的任何实体没有特别的相关性。'
- en: '**Request Headers** These headers convey to the server more details about the
    nature of the client''s request, and they give the client more control over how
    the request is handled. For example, special request headers can be used by the
    client to specify a conditional request—one that is filled only if certain criteria
    are met. Others can tell the server which formats or encodings the client is able
    to process in a Response message.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求头** 这些头向服务器传达了更多关于客户端请求性质的信息，并使客户端能够更多地控制请求的处理方式。例如，客户端可以使用特殊的请求头指定一个条件请求——只有当满足某些标准时才会被填充。其他头可以告诉服务器客户端能够处理响应消息中的哪些格式或编码。'
- en: '**Entity Headers** These are headers that describe the entity contained in
    the body of the request, if any.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体头** 这些头描述了请求体中包含的实体（如果有的话）。'
- en: Tip
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** *HTTP Request messages* are the means by which HTTP clients
    ask servers to take a particular type of action, such as sending a file or processing
    user input. Each Request message begins with a *request line*, which contains
    three critical pieces of information: the *method* (type of action) the client
    is requesting, the *URI* of the resource on which the client wishes the action
    to be performed, and the version of HTTP that the client is using. After the request
    line comes a set of message headers related to the request, followed by a blank
    line, and then optionally, the message body of the request.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *HTTP请求消息*是HTTP客户端请求服务器执行特定类型操作的手段，例如发送文件或处理用户输入。每个请求消息以一个*请求行*开始，该行包含三个关键信息：客户端请求的*方法*（动作类型）、客户端希望执行动作的资源*URI*以及客户端使用的HTTP版本。请求行之后是一系列与请求相关的消息头，然后是一个空行，然后是可选的请求消息体。'
- en: Request headers are obviously used only in Request messages, but both general
    headers and entity headers can appear in either a Request or a Response message.
    Since there are so many headers and most are not particular to one message type,
    I describe them in detail in the next chapter.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 请求头显然仅在请求消息中使用，但通用头和实体头都可以出现在请求或响应消息中。由于存在如此多的头信息，并且大多数头信息并不特定于某一种消息类型，我在下一章中详细描述了它们。
- en: HTTP Response Message Format
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP响应消息格式
- en: 'Each Request message sent by an HTTP client to a server prompts the server
    to send back a *Response message*. Actually, in certain cases, the server may
    send two responses: a preliminary response, followed by the real one. Usually
    though, one request yields one response, which indicates the results of the server''s
    processing of the request, and a response often also carries an entity (file or
    resource) in the message body.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP客户端向服务器发送的请求消息都会促使服务器发送回一个*响应消息*。实际上，在某些情况下，服务器可能会发送两个响应：一个初步响应，然后是真正的响应。通常情况下，一个请求会产生一个响应，这表明服务器处理请求的结果，响应通常还携带一个实体（文件或资源）在消息体中。
- en: 'Like Request messages, Response messages use their own specific format that
    is based on the HTTP generic message format described earlier in this chapter.
    The format Response message format header is as follows (see [Figure 81-2](ch81s03.html#http_response_message_format_this_figure
    "Figure 81-2. HTTP Response message format This figure illustrates the construction
    of an HTTP Response message and includes an example of both message headers and
    body. The status code 200 indicates that this is a successful response to a request;
    it contains a brief text HTML entity in the message body. See Figure 81-1 for
    the HTTP Request message format.")):'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 与请求消息一样，响应消息使用它们自己的特定格式，该格式基于本章前面描述的HTTP通用消息格式。响应消息格式的头部如下（参见[图81-2](ch81s03.html#http_response_message_format_this_figure
    "图81-2. HTTP响应消息格式 此图说明了HTTP响应消息的构建，并包括消息头和体的示例。状态码200表示这是一个对请求的成功响应；它包含消息体中的简短文本HTML实体。有关HTTP请求消息格式，请参阅图81-1。"））：
- en: '| <*status-line*> |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| <*status-line*> |'
- en: '| <*general-headers*> |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| <*general-headers*> |'
- en: '| <*response-headers*> |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| <*response-headers*> |'
- en: '| <*entity-headers*> |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| <*entity-headers*> |'
- en: '| <*empty-line*> |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| <*empty-line*> |'
- en: '| [<*message-body*>] |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| [<*message-body*>] |'
- en: '| [<*message-trailers*>] |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| [<*message-trailers*>] |'
- en: '![HTTP Response message format This figure illustrates the construction of
    an HTTP Response message and includes an example of both message headers and body.
    The status code 200 indicates that this is a successful response to a request;
    it contains a brief text HTML entity in the message body. See for the HTTP Request
    message format.](httpatomoreillycomsourcenostarchimages288313.png.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP响应消息格式 此图说明了HTTP响应消息的构建，并包括消息头和体的示例。状态码200表示这是一个对请求的成功响应；它包含消息体中的简短文本HTML实体。有关HTTP请求消息格式，请参阅。](httpatomoreillycomsourcenostarchimages288313.png.jpg)'
- en: Figure 81-2. HTTP Response message format This figure illustrates the construction
    of an HTTP Response message and includes an example of both message headers and
    body. The status code 200 indicates that this is a successful response to a request;
    it contains a brief text HTML entity in the message body. See [Figure 81-1](ch81s02.html#http_request_message_format_this_diagram
    "Figure 81-1. HTTP Request message format This diagram shows the structural elements
    of an HTTP Request message and an example of the sorts of headers a Request message
    might contain. Like most HTTP requests, this one carries no entity, so there are
    no entity headers and the message body is empty. See Figure 81-2 for the HTTP
    Response message format.") for the HTTP Request message format.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图 81-2. HTTP 响应消息格式 此图说明了 HTTP 响应消息的构建，并包括消息头部和主体的示例。状态码 200 表示这是对请求的成功响应；它包含消息主体中的简短文本
    HTML 实体。参见[图 81-1](ch81s02.html#http_request_message_format_this_diagram "图 81-1.
    HTTP 请求消息格式 此图显示了 HTTP 请求消息的结构元素和请求消息可能包含的头部示例。像大多数 HTTP 请求一样，此请求不携带实体，因此没有实体头部，消息主体为空。参见图
    81-2 以了解 HTTP 响应消息格式。")了解 HTTP 请求消息格式。
- en: Status Line
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态行
- en: 'The *status line* (note that this is not called the *response line*) is the
    start line used for Response messages. It has two functions: to tell the client
    what version of the protocol the server is using and to communicate a summary
    of the results of processing the client''s request. The formal syntax for the
    status line is as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*状态行*（注意这并不被称为*响应行*）是用于响应消息的起始行。它有两个功能：告诉客户端服务器正在使用哪个版本的协议，以及传达处理客户端请求的结果摘要。状态行的正式语法如下：'
- en: '| <*HTTP-VERSION*> <*status-code*> <*reason-phrase*> |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| <*HTTP-VERSION*> <*status-code*> <*reason-phrase*> |'
- en: Each of the status line components is discussed in the following sections.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的各节将讨论状态行各组成部分。
- en: HTTP Version
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 版本
- en: The *HTTP-VERSION* label in the status line serves the same purpose as it does
    in the request line of a Request message (described in the previous section).
    Here, it tells the client the version number that the server is using for its
    response. It uses the same format as in the request line, with the version in
    uppercase as HTTP/0.9, HTTP/1.0, or HTTP/1.1\. The server is required to return
    an HTTP version number that is no greater than the number the client sent in its
    request.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 状态行中的 *HTTP-VERSION* 标签在请求消息的请求行中起到相同的作用（如前节所述）。在这里，它告诉客户端服务器正在使用哪个版本号进行响应。它使用与请求行相同的格式，版本号为大写，如
    HTTP/0.9、HTTP/1.0 或 HTTP/1.1。服务器必须返回一个 HTTP 版本号，该版本号不大于客户端在其请求中发送的版本号。
- en: Status Code and Reason Phrase
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态码和原因短语
- en: The *status code* and *reason phrase* provide information about the results
    of processing the client's request in two different forms. The status code is
    a three-digit number that indicates the formal result that the server is communicating
    to the client. It is intended for the client HTTP implementation to process so
    the software can take appropriate action. The reason phrase is an additional,
    descriptive text string, which can be displayed to the human users of the HTTP
    client so they can see how the server responded. I describe status codes and reason
    phrases later in this chapter, and also list all of the standard codes.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*状态码*和*原因短语*以两种不同的形式提供有关处理客户端请求结果的信息。状态码是一个三位数，表示服务器向客户端传达的正式结果。它旨在让客户端 HTTP
    实现处理，以便软件可以采取适当的行动。原因短语是一个额外的描述性文本字符串，可以显示给 HTTP 客户端的人类用户，以便他们可以看到服务器如何响应。我在本章后面描述状态码和原因短语，并列出所有标准代码。'
- en: Headers
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头部
- en: 'The Response message will always include a number of headers that provide extra
    information about it. Response message headers fall into three categories:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 响应消息将始终包含一些头部，提供有关其的额外信息。响应消息头部分为三类：
- en: '**General Headers** General headers that refer to the message itself and are
    not specific to Response messages or the entity in the message body. These are
    the same as the generic headers that can appear in Request messages (though certain
    headers appear more often in responses, and others are more common in requests).'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用头部** 指的是消息本身且不特定于响应消息或消息主体中的实体的通用头部。这些与可以出现在请求消息中的通用头部相同（尽管某些头部在响应中出现得更频繁，而其他头部在请求中出现得更常见）。'
- en: '**Response Headers** These headers provide additional data that expands on
    the summary result information in the status line. The server may also return
    extra result information in the body of the message, especially when an error
    occurs.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应头** 这些头信息提供了对状态行中总结结果信息的扩展数据。服务器还可能在消息体中返回额外的结果信息，尤其是在发生错误时。'
- en: '**Entity Headers** These are headers that describe the entity contained in
    the body of the response, if any. These are the same entity headers that can appear
    in a Request message, but they are seen more often in response messages.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体头** 这些是描述响应体中包含的实体（如果有的话）的头信息。这些与请求消息中可能出现的实体头相同，但它们在响应消息中出现的频率更高。'
- en: Most Response messages contain an entity in the message body. In the case of
    a successful request to retrieve a resource, this is the resource itself. Responses
    indicating unsuccessful requests usually contain detailed error information, often
    in the form of an HTML-formatted error message.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数响应消息在消息体中包含实体。在成功请求检索资源的情况下，这本身就是资源。表示请求不成功的响应通常包含详细的错误信息，通常以HTML格式化的错误消息的形式出现。
- en: Note
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Entity headers may appear in a Response message to describe the resource that
    is the subject of the request, even if the entity itself is not sent in the message.
    This occurs when the HEAD method is used to request only the headers associated
    with an entity*.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*实体头可能出现在响应消息中，用于描述请求的主题资源，即使实体本身没有在消息中发送。这发生在使用HEAD方法请求仅与实体关联的头信息时*。'
- en: Response headers are used only in Response messages, while the others are general
    with respect to message type. See [Chapter 82](ch82.html "Chapter 82. HTTP MESSAGE
    HEADERS") for more details about HTTP headers.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 响应头仅用于响应消息，而其他头信息在消息类型方面是通用的。有关HTTP头信息的更多详细信息，请参阅[第82章](ch82.html "第82章。HTTP消息头")。
- en: Tip
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Each HTTP Request message sent by a client leads to a server
    returning one or more *HTTP Response messages*. Each Response message starts with
    a *status line* that contains the server''s HTTP version number, and a numeric
    *status code* and text *reason phrase* that indicate the result of processing
    the client''s request. The message then contains headers related to the response,
    followed by a blank line, and then the optional message body. Since most HTTP
    Request messages ask for a server to return a file or other resource, many HTTP
    Response messages carry an entity in the message body.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 客户端发送的每个HTTP请求消息都会导致服务器返回一个或多个*HTTP响应消息*。每个响应消息都以*状态行*开始，其中包含服务器的HTTP版本号、一个数字*状态码*和文本*原因短语*，这些指示了处理客户端请求的结果。然后是有关响应的头信息，接着是一个空行，然后是可选的消息体。由于大多数HTTP请求消息要求服务器返回文件或其他资源，因此许多HTTP响应消息在消息体中携带实体。'
- en: HTTP Methods
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP方法
- en: An HTTP Request message sent by a client to a server obviously requests that
    the server do something. All client/server protocols provide a way for the client
    to prompt the server to take action, generally by having the client give the server
    a series of commands. HTTP, in contrast, has *methods*, rather than commands.
    Each client Request message begins with the specification of the method that is
    the subject of the request.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端向服务器发送的HTTP请求消息显然是要求服务器执行某些操作。所有客户端/服务器协议都提供了一种方式，允许客户端提示服务器采取行动，通常是通过客户端向服务器提供一系列命令。与HTTP不同，HTTP有*方法*而不是命令。每个客户端请求消息都以指定请求主题的方法开始。
- en: What is the difference between a method and a command? In practical terms, nothing;
    they are the same. So why does HTTP use the term *method* instead of *command*?
    That's a good question. The answer can be found in the abstract of the standard
    defining HTTP/1.0, RFC 1945\. It states, in part, that HTTP is "a generic, stateless,
    object-oriented protocol which can be used for many tasks…." In highly simplified
    terms, object-oriented programming is a technique in which software modules are
    described not as sets of procedures, but as *objects* that possess attributes.
    These modules send messages to each other to communicate and to cause actions
    to be performed, where the action taken depends on the nature of the object. In
    object-oriented programming, the procedures each object can perform are called
    *methods*.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 方法和命令之间的区别是什么？在实用意义上，没有区别；它们是相同的。那么为什么 HTTP 使用“方法”这个词而不是“命令”呢？这是一个好问题。答案可以在定义
    HTTP/1.0 的标准摘要中找到，即 RFC 1945。它部分指出，HTTP 是“一种通用的、无状态的、面向对象的协议，可用于许多任务……”。用高度简化的术语来说，面向对象编程是一种技术，其中软件模块不是描述为一系列过程，而是描述为具有属性的*对象*。这些模块通过发送消息相互通信并执行操作，其中执行的操作取决于对象的性质。在面向对象编程中，每个对象可以执行的过程称为*方法*。
- en: HTTP is considered to be object-oriented because, in many cases, the action
    taken by a server depends on the object that is the subject of the request. For
    example, if you ask a server to retrieve a text document, it will send that document;
    but if you ask for a directory, the server may instead return a default document
    for that directory. In contrast, a request that specifies the name of a program
    will result in the program being executed and its output returned (as opposed
    to the program's source code being returned).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 被认为是面向对象的，因为在许多情况下，服务器执行的操作取决于请求的主题对象。例如，如果你要求服务器检索一个文本文档，它将发送该文档；但如果你要求目录，服务器可能会返回该目录的默认文档。相比之下，指定程序名称的请求将导致程序执行并返回其输出（而不是返回程序的源代码）。
- en: Common Methods
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见方法
- en: 'Each method allows the client to specify a particular type of action to be
    taken by the server. Method names are always in uppercase letters. There are three
    methods that are commonly used in HTTP: GET, HEAD, and POST.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都允许客户端指定服务器要执行的一种特定类型的操作。方法名称始终为大写字母。在 HTTP 中常用的三种方法是：GET、HEAD 和 POST。
- en: GET
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GET
- en: The GET method requests that server retrieve the resource specified by the URL
    on the HTTP request line and send it in a response back to the client. This is
    the most basic type of request and the one that accounts for the majority of HTTP
    traffic. When you enter a conventional URL or click a link to a document or other
    file, you are usually prompting your web browser to send a GET request.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: GET 方法请求服务器根据 HTTP 请求行中的 URL 检索指定的资源，并将其作为响应发送回客户端。这是最基本的请求类型，也是占 HTTP 流量大多数的类型。当你输入一个常规
    URL 或点击链接到文档或其他文件时，你通常是在提示你的网页浏览器发送一个 GET 请求。
- en: The handling of a GET request depends on a number of factors. If the URL is
    correct and the server can find the resource, it will send back the appropriate
    response to the client. The exact resource returned depends on the nature of the
    object requested. If the request cannot be processed properly, an error message
    may result. Caching (discussed in [Chapter 84](ch84.html "Chapter 84. HTTP FEATURES,
    CAPABILITIES, AND ISSUES")) also comes into play, as a proxy server or even the
    client itself might satisfy the request before it gets to the server.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: GET 请求的处理取决于许多因素。如果 URL 正确且服务器可以找到资源，它将向客户端发送适当的响应。返回的确切资源取决于请求的对象的性质。如果请求无法正确处理，可能会产生错误消息。缓存（在第
    84 章中讨论）也起作用，因为代理服务器甚至客户端本身可能在请求到达服务器之前就满足请求。
- en: It's important to remember that the meaning of a GET request may change if certain
    headers, such as If-Modified-Since or If-Match, are used. These tell the server
    to send the resource only if certain conditions are met. A request of this sort
    is sometimes called a *conditional GET*. Similarly, the client may use the Range
    header to request that the server send it only part of a resource; this is usually
    used for large files. When this header is included, the request may be called
    a *partial GET*.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住，如果使用某些头部信息，例如 If-Modified-Since 或 If-Match，GET 请求的含义可能会改变。这些头部信息指示服务器仅在满足某些条件时发送资源。这种类型的请求有时被称为
    *条件 GET*。同样，客户端可以使用 Range 头部信息请求服务器只发送资源的一部分；这通常用于大文件。当包含此头部信息时，请求可能被称为 *部分 GET*。
- en: HEAD
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HEAD
- en: The HEAD method is identical to the GET method, but it tells the server not
    to send the actual body of the message. Thus, the response will contain all of
    the headers that would have accompanied a reply to the equivalent GET message,
    including entity headers describing the entity that the server would have sent
    had the method been GET. The client often uses this method to check the existence,
    status, or size of a file before deciding whether it wants the server to send
    the whole file.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: HEAD 方法与 GET 方法相同，但它告诉服务器不要发送消息的实际主体。因此，响应将包含所有伴随等效 GET 消息的头部信息，包括描述服务器在方法为
    GET 时将发送的实体的头部信息。客户端通常使用此方法在决定是否希望服务器发送整个文件之前，检查文件的存在、状态或大小。
- en: HEAD requests are processed in the same way as GET requests, except that only
    the headers are returned, not the actual resource.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: HEAD 请求的处理方式与 GET 请求相同，但除了只返回头部信息外，不返回实际资源。
- en: POST
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POST
- en: The POST method allows the client to send an entity containing arbitrary data
    to the server for processing. It is commonly used to enable a client to submit
    information such as an interactive HTML form to a program on the server, which
    then takes action based on that input and sends a response. This capability is
    now used for all sorts of online programs. The URL in the request specifies the
    name of the program on the server that is to accept the data. Contrast this with
    the PUT method described in the next section.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: POST 方法允许客户端向服务器发送包含任意数据的实体以进行处理。它通常用于允许客户端将信息，如交互式 HTML 表单，提交给服务器上的程序，然后该程序根据该输入采取行动并发送响应。现在这种能力被用于各种在线程序。请求中的
    URL 指定了服务器上要接受数据的程序名称。这与下一节中描述的 PUT 方法形成对比。
- en: Other Methods
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他方法
- en: 'The other methods defined by the HTTP standard are not used as often, but I
    will describe them briefly, as you may still encounter them. Other HTTP methods
    include the following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 标准定义的其他方法使用得不太频繁，但我将简要描述它们，因为您可能还会遇到它们。其他 HTTP 方法包括以下内容：
- en: '**OPTIONS** This method allows the client to request that the server send it
    information about available communication options. A URI of a resource may be
    specified to request information relevant to accessing that resource, or an asterisk
    (*) may be used to indicate that the query is about the server itself. The response
    includes headers that give the client more details about how the server may be
    accessed.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**OPTIONS** 此方法允许客户端请求服务器发送有关可用通信选项的信息。可以指定资源的 URI 以请求与访问该资源相关的信息，或者使用星号 (*)
    来表示查询是关于服务器本身的。响应包括头部信息，这些头部信息向客户端提供了更多关于如何访问服务器细节。'
- en: '**PUT** This method requests that the server store the entity enclosed in the
    body of the request at the URL specified in the request line. In a PUT, the URI
    identifies the entity in the request; thus a PUT allows a file to be copied to
    a server, in the exact complement to how a GET requests that a file be copied
    to the client. In contrast, with a POST, the URI identifies a program intended
    to *process* the entity in the request, so it''s used for interactive programs.
    Now, would you like people to be able to store files on your server in the same
    way that they request them? Neither would I. This is one primary reason why PUT
    is not often used. It has valid uses, such as uploading content to a website,
    and it must be used with authentication in this case. However, storing files on
    a site is more often accomplished using other means, like the File Transfer Protocol
    (FTP).'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**PUT** 此方法请求服务器将请求行中指定的URL存储在请求体中的实体。在PUT方法中，URI标识请求中的实体；因此，PUT允许将文件复制到服务器，这与GET请求将文件复制到客户端的方式正好相反。相比之下，使用POST时，URI标识一个旨在*处理*请求中实体的程序，因此它用于交互式程序。现在，你希望人们能够以请求文件的方式将文件存储在你的服务器上吗？我也不希望。这是PUT方法不常使用的一个主要原因。它有有效的用途，例如上传网站内容，在这种情况下必须使用身份验证。然而，在网站上存储文件通常使用其他方式，如文件传输协议（FTP）。'
- en: '**DELETE** This method requests that the specified resource be deleted. This
    has the same issues as PUT and is not often used for similar reasons.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**DELETE** 此方法请求删除指定的资源。这与PUT方法存在相同的问题，并且由于类似的原因不常使用。'
- en: '**TRACE** This method allows a client to receive back a copy of the request
    that it sent to the server, for diagnostic purposes.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**TRACE** 此方法允许客户端接收到它发送给服务器的请求的副本，用于诊断目的。'
- en: In addition to these, the standard reserves the method name CONNECT for future
    use. An earlier version of HTTP/1.1, RFC 2068, defined the methods PATCH, LINK,
    and UNLINK. These were removed in the final version, but you may still see references
    to them.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，标准为未来的使用保留了方法名称CONNECT。HTTP/1.1的早期版本RFC 2068定义了方法PATCH、LINK和UNLINK。这些在最终版本中被删除了，但你可能仍然会看到对它们的引用。
- en: Tip
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Each HTTP client request specifies a particular type of action
    that the server should perform; in HTTP, these are called *methods*, rather than
    commands. The three most common HTTP methods are *GET*, which prompts a server
    to return a resource; *HEAD*, which returns just the headers associated with a
    resource; and *POST*, which allows a client to submit data to a server for processing.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 每个HTTP客户端请求都指定服务器应执行的一种特定操作；在HTTP中，这些被称为*方法*，而不是命令。最常用的三种HTTP方法是*GET*，它提示服务器返回一个资源；*HEAD*，它只返回与资源关联的头部信息；以及*POST*，它允许客户端向服务器提交数据以进行处理。'
- en: Safe and Idempotent Methods
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全和幂等方法
- en: 'As you''ve seen, methods vary greatly in the type of behavior they cause the
    server to take. The HTTP standard defines two characteristics that can be used
    to differentiate methods based on the impact they have on a server:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，方法在导致服务器采取的行为类型上差异很大。HTTP标准定义了两个可以用来根据方法对服务器的影响进行区分的特性：
- en: '**Safe Methods** These are methods that an administrator of a server can feel
    reasonably comfortable permitting a client to send because they are very unlikely
    to have any negative side effects. The methods usually put into this category
    are GET, HEAD, OPTIONS, and TRACE. The methods that cause data to be accepted
    by the server for processing, or lead to changes on the server, are deemed unsafe:
    POST, PUT, and DELETE. (The fact that they are considered unsafe doesn''t mean
    a server never allows them—just that they require more care and detail in handling
    than the others.)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全方法** 这些是管理员可以合理地允许客户端发送的方法，因为它们极不可能产生任何负面副作用。通常被归入此类的方法是GET、HEAD、OPTIONS和TRACE。导致服务器接受数据进行处理或导致服务器上发生变化的方法被认为是不可安全的：POST、PUT和DELETE。（它们被认为是不可安全的并不意味着服务器永远不会允许它们——只是它们在处理上比其他方法需要更多的注意和细节。）'
- en: '**Idempotent Methods** A method is said to be *idempotent* if repeating the
    same method request numerous times causes the exact same results, as if the method
    were issued only once. For example, if you load a web page in your browser, and
    then type the same URL in again, you get the same result, at least most of the
    time. In general, all of the methods in HTTP have this property inherently except
    one: POST.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**幂等方法** 如果重复执行相同的方法请求多次会产生完全相同的结果，就像该方法只被发出一次一样，那么这种方法就被称作是 *幂等的*。例如，如果你在浏览器中加载一个网页，然后再次输入相同的
    URL，你通常会得到相同的结果，至少大多数时候是这样。一般来说，HTTP 中的所有方法都具有这种属性，除了 POST 方法。'
- en: The POST method is not idempotent because each instance of a POST request causes
    the receiving server to process the data in the Request message's body. Submitting
    a POST request two or more times can often lead to undesirable results. The classic
    example is clicking the Submit button on a form more than once, which can lead
    to annoyances such as a duplicate message on an Internet forum or a double order
    at an online store.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: POST 方法不是幂等的，因为每个 POST 请求的实例都会导致接收服务器处理请求消息体中的数据。提交两次或更多次的 POST 请求通常会导致不希望的结果。一个经典的例子是在表单上多次点击提交按钮，这可能会导致诸如在互联网论坛上出现重复消息或在在线商店中重复订单等烦恼。
- en: There are also situations where a method that is normally idempotent may not
    be. A GET request for a simple document is idempotent, but a GET for a script
    can change files on the server and therefore is not idempotent. Similarly, a sequence
    of idempotent methods may not be idempotent. For example, consider a situation
    where a PUT request is followed by a GET for the same resource. This sequence
    is not idempotent because the second request depends on the results of the first.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 也存在一种情况，即通常幂等的方法可能不是幂等的。对简单文档的 GET 请求是幂等的，但对脚本的 GET 请求可能会更改服务器上的文件，因此不是幂等的。同样，一系列幂等方法可能也不是幂等的。例如，考虑一种情况，其中
    PUT 请求后面跟着对同一资源的 GET 请求。这个序列不是幂等的，因为第二个请求依赖于第一个请求的结果。
- en: The significance of nonidempotence is that clients must handle such requests
    or sequences specially. The client must keep track of them, making sure that they
    are filled in order and only once. The HTTP standard also specifies that nonidempotent
    methods should not be pipelined, to avoid problems if an HTTP session is unexpectedly
    terminated. For example, if two POST requests were pipelined and the server got
    hung up handling them, the client would need to reissue them but might not know
    how many of the original requests had been successfully processed.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 非幂等性的重要性在于客户端必须特别处理此类请求或序列。客户端必须跟踪它们，确保它们按顺序填写且只填写一次。HTTP 标准还规定，非幂等方法不应进行管道化，以避免在
    HTTP 会话意外终止时出现问题。例如，如果两个 POST 请求被管道化，并且服务器在处理它们时出现故障，客户端需要重新发出它们，但可能不知道原始请求中有多少已经成功处理。
- en: HTTP Status Codes and Reason Phrases
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 状态码和原因短语
- en: Every request sent by an HTTP client causes one or more responses to be returned
    by the server that receives it. As you saw earlier in the discussion of the Response
    message format, the first line of the response is a status line that contains
    a summary of the results of processing the request. The purpose of this line is
    to communicate quickly whether or not the request was successful and why.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 每个由 HTTP 客户端发送的请求都会导致接收它的服务器返回一个或多个响应。正如你在之前关于响应消息格式的讨论中看到的，响应的第一行是一个状态行，其中包含处理请求结果的摘要。这一行的目的是快速传达请求是否成功以及原因。
- en: HTTP status lines contain both a numeric status code and a text reason phrase.
    The reason for having both a number and a text string is that computers can more
    easily understand the results of a request by looking at a number and then can
    quickly respond accordingly. Humans, on the other hand, find text descriptions
    easier to comprehend. The idea of using both forms was taken directly from earlier
    application layer protocols such as FTP, the Simple Mail Transfer Protocol (SMTP),
    and the Network News Transfer Protocol (NNTP). The explanation of FTP reply codes
    in [Chapter 72](ch72.html "Chapter 72. FILE TRANSFER PROTOCOL (FTP)") discusses
    more completely the reasons why numeric reply codes are used in addition to descriptive
    text.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 状态行包含一个数字状态码和一个文本原因短语。使用数字和文本字符串的原因是，计算机可以通过查看数字来更容易地理解请求的结果，并相应地快速响应。另一方面，人类发现文本描述更容易理解。使用这两种形式的思想直接来源于早期的应用层协议，如
    FTP、简单邮件传输协议 (SMTP) 和网络新闻传输协议 (NNTP)。[第 72 章](ch72.html "第 72 章。文件传输协议 (FTP)")
    中对 FTP 响应代码的解释更完整地讨论了为什么除了描述性文本外还使用数字响应代码。
- en: Status Code Format
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态码格式
- en: 'HTTP status codes are three digits in length and follow a particular format,
    where the first digit has particular significance. Unlike the reply codes used
    by FTP and other protocols, the second digit does not stand for a functional grouping;
    the second and third digits together just make 100 different options for each
    of the categories indicated by the first digit. Thus, the general form of an HTTP
    status code is *xyy*, where the first digit, *x*, is specified as shown in [Table 81-1](ch81s05.html#http_status_code_format_first-digit_inte
    "Table 81-1. HTTP Status Code Format: First-Digit Interpretation").'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 状态码长度为三位，遵循特定的格式，其中第一位数字具有特定的意义。与 FTP 和其他协议使用的响应代码不同，第二位数字不代表功能分组；第二位和第三位数字一起为第一位数字表示的每个类别提供
    100 种不同的选项。因此，HTTP 状态码的一般形式为 *xyy*，其中第一位数字 *x* 如 [表 81-1](ch81s05.html#http_status_code_format_first-digit_inte
    "表 81-1. HTTP 状态码格式：第一位数字解释") 所示。
- en: 'Table 81-1. HTTP Status Code Format: First-Digit Interpretation'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 表 81-1. HTTP 状态码格式：第一位数字解释
- en: '| Status Code Format | Meaning | Description |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 状态码格式 | 含义 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1yy | Informational message | Provides general information; does not indicate
    success or failure of a request. |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 1yy | 信息性消息 | 提供一般信息；不指示请求的成功或失败。 |'
- en: '| 2yy | Success | The method was received, understood, and accepted by the
    server. |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 2yy | 成功 | 服务器已接收、理解并接受该方法。 |'
- en: '| 3yy | Redirection | The request did not fail outright, but additional action
    is needed before it can be successfully completed. |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 3yy | 重定向 | 请求并未直接失败，但在成功完成之前需要采取额外的操作。 |'
- en: '| 4yy | Client error | The request was invalid, contained bad syntax, or could
    not be completed for some other reason that the server believes was the client''s
    fault. |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| 4yy | 客户端错误 | 请求无效，包含语法错误，或由于其他原因无法完成，服务器认为这是客户端的过错。 |'
- en: '| 5yy | Server error | The request was valid, but the server was unable to
    complete it due to a problem of its own. |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 5yy | 服务器错误 | 请求是有效的，但由于服务器自身的问题无法完成。 |'
- en: In each of these five groups, the code where *yy* is 00 is defined as a generic
    status code for that group, while other two-digit combinations are more specific
    responses. For example, 404 is the well-known specific error message that means
    the requested resource was not found by the server, and 400 is the less specific
    Bad Request error. This system was set up to allow the definition of new status
    codes that certain clients might not comprehend. If a client receives a strange
    code, it just treats it as the equivalent of the generic response in the appropriate
    category. So, if a server response starts with the code 491, and the client has
    no idea what this is, it treats it as a 400 Bad Request reply.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这五个组中的每一个组中，*yy* 为 00 的代码被定义为该组的通用状态码，而其他两位数组合则是更具体的响应。例如，404 是众所周知的特定错误消息，表示服务器未找到请求的资源，而
    400 是不太具体的错误请求。该系统被建立起来以允许定义某些客户端可能不理解的新状态码。如果客户端收到一个奇怪的代码，它就将其视为适当类别中通用响应的等效物。因此，如果服务器响应以代码
    491 开头，而客户端不知道这是什么，它就将其视为 400 错误请求响应。
- en: Reason Phrases
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原因短语
- en: The reason phrase is a text string that provides a more meaningful description
    of the error for people who are bad at remembering what cryptic codes stand for
    (which would be most of us!). The HTTP standard includes sample reason phrases
    for each status code, but server administrators can customize these phrases if
    desired. When a server returns a more detailed HTML error message in the body
    of its Response message, the reason phrase is often used for the title tag in
    that message body.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 原因短语是一个文本字符串，为那些不擅长记住这些晦涩代码代表什么的人提供了更有意义的错误描述（这将是大多数我们中的人）。HTTP标准为每个状态码提供了示例原因短语，但服务器管理员可以根据需要自定义这些短语。当服务器在其响应消息的主体中返回更详细的HTML错误消息时，原因短语通常用于该消息主体的标题标签。
- en: Tip
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Each HTTP Response message includes both a numeric *status
    code* and a text *reason phrase*, both of which indicate the disposition of the
    corresponding client request. The numeric code allows software programs to easily
    interpret the results of a request, while the text phrase provides more useful
    information to human users. HTTP status codes are three digits in length, with
    the first digit indicating the general class of the reply.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 每个HTTP响应消息都包含一个数字 *状态码* 和一个文本 *原因短语*，这两个都指示相应客户端请求的处理情况。数字代码允许软件程序轻松解释请求的结果，而文本短语则向人类用户提供更有用的信息。HTTP状态码长度为三位数字，第一位数字表示响应的一般类别。'
- en: '[Table 81-2](ch81s05.html#http_status_codes_and_reason_phras-id001 "Table 81-2. HTTP
    Status Codes and Reason Phrases") lists in numerical order the status codes defined
    by the HTTP/1.1 standard, along with the standard reason phrase and a brief description
    of each.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 81-2](ch81s05.html#http_status_codes_and_reason_phras-id001 "表 81-2. HTTP
    状态码和原因短语") 按数字顺序列出了HTTP/1.1标准定义的状态码，以及标准原因短语和每个的简要描述。'
- en: Table 81-2. HTTP Status Codes and Reason Phrases
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 表 81-2. HTTP 状态码和原因短语
- en: '| Status Code | Reason Phrase | Description |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| 状态码 | 原因短语 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 100 | Continue | The client should continue sending its request. This is
    a special status code; see the next section in this chapter for details. |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| 100 | Continue | 客户端应继续发送其请求。这是一个特殊的状态码；请参阅本章下一节以获取详细信息。|'
- en: '| 101 | Switching Protocols | The client has used the Upgrade header to request
    the use of an alternative protocol and the server has agreed. |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| 101 | Switching Protocols | 客户端已使用Upgrade头请求使用替代协议，并且服务器已同意。|'
- en: '| 200 | OK | This is the generic successful Request message response, which
    is the code sent most often when a request is filled normally. |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| 200 | OK | 这是一个通用的成功请求消息响应，这是在请求正常完成时发送的最常见的代码。|'
- en: '| 201 | Created | The request was successful and resulted in a resource being
    created. This is a typical response to a PUT method. |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| 201 | Created | 请求成功并导致资源被创建。这是对PUT方法的典型响应。|'
- en: '| 202 | Accepted | The request was accepted by the server, but it has not yet
    been processed. This is an intentionally noncommittal response that does not tell
    the client whether or not the request will be carried out. The client determines
    the eventual disposition of the request in some unspecified way. It is used only
    in special circumstances. |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| 202 | Accepted | 服务器已接受请求，但尚未处理。这是一个故意不承诺的响应，不会告诉客户端请求是否会被执行。客户端以某种未指定的方式确定请求的最终处理。它仅在特殊情况下使用。|'
- en: '| 203 | Non-Authoritative Information | The request was successful, but some
    of the information returned by the server came from a third party, rather than
    from the original server associated with the resource. |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 203 | Non-Authoritative Information | 请求成功，但服务器返回的一些信息来自第三方，而不是来自与资源关联的原始服务器。|'
- en: '| 204 | No Content | The request was successful, but the server has determined
    that it does not need to return to the client an entity body. |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 204 | No Content | 请求成功，但服务器已确定不需要向客户端返回实体主体。|'
- en: '| 205 | Reset Content | The request was successful; the server is telling the
    client that it should reset the document from which the request was generated
    so that a duplicate request is not sent. This code is intended for use with forms.
    |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 205 | Reset Content | 请求成功；服务器正在告诉客户端它应该重置生成请求的文档，以便不发送重复请求。此代码旨在与表单一起使用。|'
- en: '| 206 | Partial Content | The server has successfully fulfilled a partial GET
    request. See the section on methods earlier in this chapter for more details on
    this, as well as the description of the Range header in the next chapter. |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 206 | 部分内容 | 服务器已成功满足部分GET请求。有关此内容的更多详细信息，请参阅本章前面的方法部分，以及下一章中关于Range头的描述。|'
- en: '| 300 | Multiple Choices | The resource is represented in more than one way
    on the server. The server is returning information describing these representations,
    so the client can pick the most appropriate one, a process called agent-driven
    negotiation (discussed in [Chapter 83](ch83.html "Chapter 83. HTTP Entities, Transfers,
    Coding Methods, and Content Management")). |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 300 | 多种选择 | 服务器上以多种方式表示资源。服务器正在返回描述这些表示的信息，以便客户端可以选择最合适的一个，这个过程称为代理驱动协商（在第83章中讨论）。|'
- en: '| 301 | Moved Permanently | The resource requested has been moved to a new
    URL permanently. Any future requests for this resource should use the new URL.
    This is the proper method of handling situations where a file on a server is renamed
    or moved to a new directory. Most people don''t bother setting this up, which
    is why URLs break so often, resulting in 404 errors. |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| 301 | 永久移动 | 请求的资源已永久移动到新的URL。任何未来对该资源的请求都应该使用新的URL。这是处理服务器上文件重命名或移动到新目录等情况的正确方法。大多数人懒得设置这个，这就是为什么URL经常损坏，导致404错误。|'
- en: '| 302 | Found | The resource requested is temporarily using a different URL.
    The client should continue to use the original URL. See code 307. |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 302 | 找到 | 请求的资源临时使用不同的URL。客户端应继续使用原始URL。参见代码307。|'
- en: '| 303 | See Other | The response for the request can be found at a different
    URL, which the server specifies. The client must do a fresh GET on that URL to
    see the results of the prior request. |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| 303 | 另见 | 请求的响应可以在服务器指定的不同URL找到。客户端必须对该URL进行新的GET请求以查看先前请求的结果。|'
- en: '| 304 | Not Modified | The client sent a conditional GET request, but the resource
    has not been modified since the specified date/time, so the server has not sent
    it. |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 304 | 未修改 | 客户端发送了一个条件GET请求，但资源自指定日期/时间以来未修改，因此服务器未发送它。|'
- en: '| 305 | Use Proxy | To access the requested resource, the client must use a
    proxy, whose URL is given by the server in its response. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| 305 | 使用代理 | 要访问请求的资源，客户端必须使用服务器在响应中给出的代理，其URL由服务器提供。|'
- en: '| 306 | (unused) | Defined in an earlier version of HTTP and no longer used.
    |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 306 | (未使用) | 定义在HTTP的早期版本中，现已不再使用。|'
- en: '| 307 | Temporary Redirect | The resource is temporarily located at a different
    URL than the one the client specified. Note that 302 and 307 are basically the
    same status code. Code 307 was created to clear up some confusion related to 302
    that occurred in earlier versions of HTTP. |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| 307 | 临时重定向 | 资源临时位于客户端指定的不同URL。请注意，302和307基本上是相同的状态码。代码307是为了澄清在HTTP早期版本中发生的与302相关的某些混淆而创建的。|'
- en: '| 400 | Bad Request | This is a generic response when the request cannot be
    understood or carried out due to a problem on the client''s end. |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| 400 | 错误请求 | 这是一个通用的响应，当请求因客户端端的问题无法理解或执行时。|'
- en: '| 401 | Unauthorized | The client is not authorized to access the resource.
    This is often returned if an attempt is made to access a resource protected by
    a password or some other means without the appropriate credentials. |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| 401 | 未授权 | 客户端无权访问资源。如果尝试无适当凭据访问受密码或其他方式保护的资源，通常会返回此响应。|'
- en: '| 402 | Payment Required | This is reserved for future use. Its mere presence
    in the HTTP standard has caused a lot of people to scratch their chins and go
    "hmm…." |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| 402 | 需要支付 | 这是为了将来使用而保留的。它在HTTP标准中的存在让很多人挠头思考“嗯……”。|'
- en: '| 403 | Forbidden | The request has been disallowed by the server. This is
    a generic "no way" response that is not related to authorization. For example,
    if the maintainer of website blocks access to it from a particular client, any
    requests from that client will result in a 403 reply. |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| 403 | 禁止访问 | 服务器拒绝请求。这是一个通用的“无权访问”响应，与授权无关。例如，如果网站维护者阻止特定客户端访问网站，任何来自该客户端的请求都将导致403回复。|'
- en: '| 404 | Not Found | The most common HTTP error message, this is returned when
    the server cannot locate the requested resource. It usually occurs due to the
    server having moved (or removed) the resource or the client giving an invalid
    URL (usually due to misspellings). |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| 404 | 未找到 | 这是最常见的HTTP错误消息，当服务器无法找到请求的资源时返回。这通常是由于服务器已移动（或删除）资源或客户端提供了一个无效的URL（通常是由于拼写错误）造成的。|'
- en: '| 405 | Method Not Allowed | The requested method is not allowed for the specified
    resource. The response includes an Allow header that indicates which methods the
    server will permit. |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| 405 | 方法不允许 | 请求的方法对于指定的资源是不允许的。响应包括一个Allow头，指示服务器将允许哪些方法。|'
- en: '| 406 | Not Acceptable | The client sent a request that specifies limitations
    that the server cannot meet for the specified resource. This error may occur if
    an overly restrictive list of conditions is placed into a request such that the
    server cannot return any part of the resource. |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| 406 | 不接受 | 客户端发送的请求指定了服务器无法满足的特定资源的限制条件。如果请求中放入了一个过于严格的条件列表，以至于服务器无法返回资源的任何部分，则可能会发生此错误。|'
- en: '| 407 | Proxy Authentication Required | This is similar to 401, but the client
    must first authenticate itself with the proxy. |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| 407 | 代理认证必需 | 这与401类似，但客户端必须首先通过代理进行认证。|'
- en: '| 408 | Request Timeout | The server was expecting the client to send a request
    within a particular time frame and the client didn''t send it. |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| 408 | 请求超时 | 服务器期望客户端在特定时间内发送请求，但客户端没有发送。|'
- en: '| 409 | Conflict | The request could not be filled because of a conflict of
    some sort related to the resource. This most often occurs in response to a PUT
    method, such as if one user tries to PUT a resource that another user has open
    for editing. |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| 409 | 冲突 | 由于与资源相关的某种冲突，请求无法完成。这种情况通常在响应PUT方法时发生，例如，如果一个用户试图PUT另一个用户已打开进行编辑的资源。|'
- en: '| 410 | Gone | The resource is no longer available at the server, which does
    not know its new URL. This is a more specific version of the 404 code that is
    used only if the server knows that the resource was intentionally removed. It
    is seen rarely (if ever). |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| 410 | 已删除 | 资源在服务器上不再可用，服务器不知道其新的URL。这是404代码的一个更具体版本，仅在服务器知道资源被有意删除时使用。这种情况很少见（如果有的话）。|'
- en: '| 411 | Length Required | The request requires a Content-Length header field
    and one was not included. |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| 411 | 长度必需 | 请求需要Content-Length头字段，但没有包含。|'
- en: '| 412 | Precondition Failed | This indicates that the client specified a precondition
    in its request, such as the use of an If-Match header, which evaluated to a false
    value. This indicates that the condition was not satisfied, so the request is
    not being filled. This is used by clients in special cases to ensure that they
    do not accidentally receive the wrong resource. |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| 412 | 预先条件失败 | 这表示客户端在其请求中指定了一个预先条件，例如使用If-Match头，其评估结果为假值。这表明条件未满足，因此请求没有被处理。客户端在特殊情况下使用此方法以确保他们不会意外地收到错误资源。|'
- en: '| 413 | Request Entity Too Large | The server has refused to fulfill the request
    because the entity that the client is requesting is too large. |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| 413 | 请求实体过大 | 服务器拒绝完成请求，因为客户端请求的实体太大。|'
- en: '| 414 | Request-URI Too Long | The server has refused to fulfill the request
    because the URL specified is longer than the server can process. This rarely occurs
    with properly formed URLs, but may be seen if clients try to send gibberish to
    the server. |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 414 | 请求URI过长 | 服务器拒绝完成请求，因为指定的URL超过了服务器可以处理的最大长度。这通常不会在正确构造的URL中发生，但如果客户端尝试向服务器发送乱码，可能会看到这种情况。|'
- en: '| 415 | Unsupported Media Type | The request cannot be processed because it
    contains an entity using a media type the server does not support. |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| 415 | 不支持的媒体类型 | 由于请求包含服务器不支持的媒体类型的实体，无法处理请求。|'
- en: '| 416 | Requested Range Not Satisfiable | The client included a Range header
    specifying a range of values that is not valid for the resource. An example might
    be requesting bytes 3000 through 4000 of a 2400-byte file. |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| 416 | 请求范围不满足 | 客户端包含了一个Range头，指定了一个对于资源无效的值范围。一个例子可能是请求一个2400字节的文件的3000到4000字节。|'
- en: '| 417 | Expectation Failed | The request included an Expect header that could
    not be satisfied by the server. |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| 417 | 期望失败 | 请求包含了一个服务器无法满足的Expect头。|'
- en: '| 500 | Internal Server Error | This is a generic error message indicating
    that the request could not be fulfilled due to a server problem. |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| 500 | 内部服务器错误 | 这是一个通用错误消息，表示请求无法完成，因为服务器出现问题。|'
- en: '| 501 | Not Implemented | The server does not know how to carry out the request,
    so it cannot satisfy it. |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| 501 | 未实现 | 服务器不知道如何执行请求，因此无法满足它。|'
- en: '| 502 | Bad Gateway | The server, while acting as a gateway or proxy, received
    an invalid response from another server it tried to access on the client''s behalf.
    |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| 502 | 网关错误 | 服务器在充当网关或代理时，从它试图代表客户端访问的另一个服务器接收到了无效的响应。|'
- en: '| 503 | Service Unavailable | The server is temporarily unable to fulfill the
    request for internal reasons. This is often returned when a server is overloaded
    or down for maintenance. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| 503 | 服务不可用 | 服务器因内部原因暂时无法满足请求。这通常在服务器过载或维护时返回。|'
- en: '| 504 | Gateway Timeout | The server, while acting as a gateway or proxy, timed
    out while waiting for a response from another server it tried to access on the
    client''s behalf. |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| 504 | 网关超时 | 服务器在充当网关或代理时，在等待从它试图代表客户端访问的另一个服务器获取响应时超时。|'
- en: '| 505 | HTTP Version Not Supported | The request used a version of HTTP that
    the server does not understand. |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| 505 | HTTP版本不受支持 | 请求使用了服务器不理解的HTTP版本。|'
- en: The 100 (Continue) Preliminary Reply
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 100（继续）初步回复
- en: Now, let's go back to the top of the list in [HTTP Status Codes and Reason Phrases](ch81s05.html
    "HTTP Status Codes and Reason Phrases") and look at the special status code 100\.
    Normally, a client sends a complete request to the server and waits for a response
    to it (while optionally pipelining additional requests, as described in the previous
    chapter). In certain circumstances, however, the client might wish to check in
    advance if the server is willing to accept the request before it bothers sending
    the whole message. This is not a common occurrence, because most requests are
    quite small, so checking first isn't worth the bother. However, in cases where
    a user wants to submit a very large amount of data to an online program or use
    PUT to store a large file, for example, checking with the server first can be
    a useful optimization.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到列表的顶部，查看[HTTP状态码和原因短语](ch81s05.html "HTTP状态码和原因短语")，并查看特殊的状态码100。通常，客户端会向服务器发送一个完整的请求并等待响应（同时可选地管道化其他请求，如前一章所述）。然而，在某些情况下，客户端可能希望在发送整个消息之前先检查服务器是否愿意接受该请求。这种情况并不常见，因为大多数请求都很小，所以先检查并不值得麻烦。但是，在用户想要向在线程序提交大量数据或使用PUT存储大文件等情况下，先与服务器检查可能是一种有用的优化。
- en: 'In this situation, the client sends a request containing the special header
    Expect: 100-Continue. Assuming that the server supports the feature, it will process
    the request''s headers and immediately send back the 100 Continue preliminary
    reply. This tells the client to continue sending the rest of the request. The
    server then processes it and responds normally. If the server doesn''t send the
    100 response after a certain amount of time, the client will typically just send
    the rest of the request anyway. Note that in some cases, servers send these preliminary
    replies even when they are not supposed to, so clients must be prepared to deal
    with them (they are simply discarded, since they contain no information).'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，客户端发送一个包含特殊头Expect: 100-Continue的请求。假设服务器支持该功能，它将处理请求的头部并立即发送100 Continue初步回复。这告诉客户端继续发送剩余的请求。然后服务器处理它并正常响应。如果在一定时间内服务器没有发送100响应，客户端通常会发送剩余的请求。请注意，在某些情况下，即使服务器不应该这样做，也会发送这些初步回复，因此客户端必须准备好处理它们（它们被简单地丢弃，因为它们不包含任何信息）。'
- en: Chapter 82. HTTP MESSAGE HEADERS
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第82章. HTTP消息头
- en: '![](httpatomoreillycomsourcenostarchimages287681.png.jpg)As you have seen in
    the preceding two chapters, Hypertext Transfer Protocol (HTTP) communication takes
    place through the relatively simple exchange of request and response messages.
    There are only a small number of methods (commands) supported by the protocol,
    which might give you the impression that the protocol is quite limited. Looks
    can be deceiving, however. Much of the functionality in HTTP is actually implemented
    in the form of *message headers*, which convey important details between clients
    and servers.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)正如你在前两章中看到的，超文本传输协议（HTTP）的通信是通过相对简单的请求和响应消息的交换来进行的。该协议支持的方法（命令）数量很少，这可能会让你觉得该协议相当有限。然而，外表可能会欺骗人。HTTP中的许多功能实际上是以*消息标题*的形式实现的，这些标题在客户端和服务器之间传递重要细节。'
- en: Some headers can appear in only HTTP requests, some in only HTTP responses,
    and some in either type of message. Understanding these headers is important to
    learning how HTTP works. There are literally dozens of them, and many apply to
    both Request and Response messages.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 一些标题只能出现在HTTP请求中，一些只能出现在HTTP响应中，还有一些可以出现在这两种类型的消息中。理解这些标题对于学习HTTP的工作方式非常重要。实际上有数十个这样的标题，其中许多适用于请求和响应消息。
- en: 'In this chapter, I provide a description of each of the many headers used in
    HTTP Request and Response messages. The chapter is organized by the four basic
    types of HTTP headers: general headers, request headers, response headers, and
    entity headers.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我提供了对HTTP请求和响应消息中使用的许多标题的描述。本章按照HTTP标题的四种基本类型组织：通用标题、请求标题、响应标题和实体标题。
- en: Tip
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**BACKGROUND INFORMATION** *I assume here that you have already read the preceding
    chapter describing HTTP message formats*.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** *在此，我假设你已经阅读了描述HTTP消息格式的上一章*。'
- en: Note
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*For the purpose of determining how web caches treat HTTP messages, HTTP headers
    are categorized as either end-to-end or hop-by-hop headers. The former are meaningful
    only to the ultimate recipient of a message, while the latter are relevant to
    each device in the chain of devices (such as proxies) connecting a client and
    server. To avoid unnecessary complication, I have not categorized the headers
    using these categories; see the full discussion of caching in [Chapter 84](ch84.html
    "Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES") for more information. In
    the descriptions of the individual headers, I indicate which headers are hop-by-hop;
    all others are end-to-end*.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了确定Web缓存如何处理HTTP消息，HTTP标题被分为端到端标题和跳转标题。前者只对消息的最终接收者有意义，而后者与连接客户端和服务器的一系列设备（如代理）中的每个设备都相关。为了避免不必要的复杂性，我没有使用这些类别对标题进行分类；有关缓存的全讨论，请参阅[第84章](ch84.html
    "第84章。HTTP功能、能力和问题")以获取更多信息。在个别标题的描述中，我指出了哪些是跳转标题；所有其他都是端到端标题*。'
- en: HTTP General Headers
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP通用标题
- en: HTTP *general headers* are so named because, unlike headers in the other three
    categories, they are not specific to any particular kind of message or message
    component (request, response, or message entity). General headers are used primarily
    to communicate information about the message itself, as opposed to what content
    it carries. They provide general information and control how a message is processed
    and handled.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP *通用标题*之所以被称为通用标题，是因为与其它三个类别的标题不同，它们并不特定于任何特定类型的信息或信息组件（请求、响应或消息实体）。通用标题主要用于传达有关消息本身的信息，而不是它所携带的内容。它们提供一般信息，并控制消息的处理和操作。
- en: Despite not being specific to either requests or replies, some general headers
    are used either mostly or entirely in one or the other type of message. There
    are also some general headers that can appear in either a Request or a Reply message,
    but have a somewhat different meaning in each.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些通用标题既不特定于请求也不特定于回复，但它们在一种或另一种类型的信息中要么主要使用，要么完全使用。还有一些通用标题可以出现在请求或回复消息中，但在每种情况下都有不同的含义。
- en: Here, I describe the Cache-Control and Warning headers and then the other more
    straightforward headers.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我描述了Cache-Control和Warning标题，然后是其他更直接的标题。
- en: Cache-Control Headers
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cache-Control标题
- en: A Cache-Control header specifies directives that manage how caching is performed
    either for an HTTP request or response. These directives affect the handling of
    a request or response by all devices in the request/response chain from the HTTP
    client, through any present intermediaries, to the HTTP server (or the other way,
    from the server, through intermediaries, to the client). They override any default
    caching behavior performed by a device. See the discussion of caching in [Chapter 84](ch84.html
    "Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES") for a full exposition of
    the subject.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: Cache-Control头部指定了管理缓存如何执行指令，这些指令适用于HTTP请求或响应。这些指令影响请求或响应在请求/响应链中所有设备（从HTTP客户端，通过任何中间代理，到HTTP服务器，或相反，从服务器，通过中间代理，到客户端）的处理。它们覆盖了设备执行的任何默认缓存行为。有关该主题的全面讨论，请参阅[第84章](ch84.html
    "第84章. HTTP特性、能力和问题")。
- en: There are a dozen individual directives that can appear in this header, the
    full details of which can be found in RFC 2616\. Even though this is a general
    header, some directives can appear only in a request or a response. Some also
    include an additional parameter, such as a number of seconds, that control their
    interpretation. [Table 82-1](ch82.html#http_cache-control_directives "Table 82-1. HTTP
    Cache-Control Directives") provides a brief summary of the different Cache-Control
    options and how they are used.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在此头部中可以出现一打单独的指令，其完整细节可以在RFC 2616中找到。尽管这是一个通用头部，但某些指令只能出现在请求或响应中。一些还包括一个额外的参数，例如秒数，以控制它们的解释。[表82-1](ch82.html#http_cache-control_directives
    "表82-1. HTTP Cache-Control指令")提供了不同Cache-Control选项的简要总结以及它们的使用方法。
- en: Note that only one directive may appear in a Cache-Control header, but more
    than one such header can appear in a message.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Cache-Control头部中只能出现一个指令，但一个消息中可以出现多个这样的头部。
- en: Table 82-1. HTTP Cache-Control Directives
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 表82-1. HTTP Cache-Control指令
- en: '| Cache-Control Directive | HTTP Message Type | Description |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| Cache-Control指令 | HTTP消息类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| no-cache | Request or Response | When present, forces a caching device to
    forward any subsequent requests for the same content to the server for revalidation;
    that is, the cache must check with the server to ensure that the cached data is
    still valid. Also see the Pragma header description, for an alternative way of
    accomplishing the same thing. |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| no-cache | 请求或响应 | 当存在时，强制缓存设备将任何后续请求相同内容转发到服务器进行重新验证；也就是说，缓存必须与服务器联系以确保缓存的数据仍然有效。另外，请参阅Pragma头部描述，了解完成同一任务的另一种方法。|'
- en: '| public | Response | Indicates that the response may be cached by any cache,
    including a shared one (a cache used by many clients). See [Chapter 84](ch84.html
    "Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES") for more details on shared
    caches. |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| public | 响应 | 表示响应可以被任何缓存存储，包括共享缓存（由多个客户端使用的缓存）。有关共享缓存的更多详细信息，请参阅[第84章](ch84.html
    "第84章. HTTP特性、能力和问题")。|'
- en: '| private | Response | Specifies that the response is intended for only a particular
    user and should not be placed into a shared cache. |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| private | 响应 | 指定响应仅针对特定用户，不应放入共享缓存中。|'
- en: '| no-store | Request or Response | Specifies that the entire request or response
    should not be stored in a cache. This is used sometimes to prevent the storing
    of sensitive documents in caches where unauthorized people might be able to access
    them. However, as the HTTP standard points out, this is really a very rudimentary
    security measure and should not be trusted a great deal (since a malicious cache
    operator could simply ignore the directive). |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| no-store | 请求或响应 | 指定整个请求或响应不应存储在缓存中。有时用于防止将敏感文档存储在缓存中，这些缓存可能被未经授权的人访问。然而，正如HTTP标准所指出的，这实际上是一个非常基本的保护措施，不应过分信任（因为恶意缓存操作员可以简单地忽略该指令）。|'
- en: '| max-age | Request or Response | In a request, indicates that the client is
    willing to accept a response whose age is no greater than the value specified.
    In a response, indicates the maximum age of the response before it is considered
    stale. This is an alternative to the use of the Expires header and takes precedence
    over it. |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| max-age | 请求或响应 | 在请求中，表示客户端愿意接受年龄不超过指定值的响应。在响应中，表示在被视为过时之前响应的最大年龄。这是使用Expires头部的替代方法，并且具有优先权。|'
- en: '| s-maxage | Response | If present, specifies the maximum age for shared caches
    receiving the response. Private caches (ones that serve only a single client)
    use the max-age value (see the preceding description). |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| s-maxage | 响应 | 如果存在，指定接收响应的共享缓存的最大年龄。私有缓存（仅服务于单个客户端的缓存）使用max-age值（参见前面的描述）。|'
- en: '| min-fresh | Request | Specifies that the client wants a response that is
    not only not stale at the time the request is received, but that will remain fresh
    for the specified number of seconds. |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| min-fresh | 请求 | 指定客户端想要一个响应，不仅在该请求收到时未过时，而且将在指定的秒数内保持新鲜。|'
- en: '| max-stale | Request | If sent without a parameter, indicates that the client
    is willing to accept a stale reply (one that has expired). If a numeric parameter
    is included, it indicates how stale, in seconds, the response may be. |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| max-stale | 请求 | 如果未发送参数，表示客户端愿意接受一个过时的回复（一个已过期的回复）。如果包含一个数值参数，表示响应可能过时的秒数。|'
- en: '| only-if-cached | Request | Used only in special circumstances, forces the
    reply to come from a cache only; the content may not come from the actual specified
    HTTP server. |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| only-if-cached | 请求 | 仅在特殊情况下使用，强制回复只能来自缓存；内容可能不会来自实际指定的HTTP服务器。|'
- en: '| must-revalidate | Response | Instructs a cache to revalidate its cache entry
    for the given response with the original server after it becomes stale. This is
    used to prevent problems with certain types of transactions that can occur if
    stale cache entries are sent to a client (perhaps as a result of the client using
    the max-stale directive). |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| must-revalidate | 响应 | 指示缓存在条目过时后，与原始服务器重新验证给定响应的缓存条目。这用于防止将过时的缓存条目发送给客户端（可能是由于客户端使用max-stale指令）可能引起的问题。|'
- en: '| proxy-revalidate | Response | Similar to must-revalidate, but applies only
    to proxies that service many users. Private caches, such as those on individual
    client computers, are not affected. |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| proxy-revalidate | 响应 | 与must-revalidate类似，但仅适用于为许多用户服务的代理。私有缓存（如个人客户端计算机上的缓存）不受影响。|'
- en: '| no-transform | Request or Response | Some caches will, by default, change
    the form in which certain cached entries are stored, to save space or improve
    performance. In cases where this might cause problems, the client or server can
    use this directive to request that this transformation not be performed. |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| no-transform | 请求或响应 | 一些缓存默认会更改某些已缓存条目存储的格式，以节省空间或提高性能。在可能引起问题的场合，客户端或服务器可以使用此指令请求不要执行此转换。|'
- en: Warning
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 警告
- en: A Warning header is used when it's needed to provide additional information
    about the status of a message. Many of the defined warning header types are related
    to caching. More than one Warning header may appear in a message, and each typically
    includes a three-digit numeric code as well as a plain text message, following
    the same basic format used in HTTP response status codes (described in [Chapter 81](ch81.html
    "Chapter 81. HTTP MESSAGES, METHODS, AND STATUS CODES")). [Table 82-2](ch82.html#http_warning_header_codes
    "Table 82-2. HTTP Warning Header Codes") briefly lists the warnings defined in
    RFC 2616.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要提供有关消息状态的额外信息时，使用警告头。许多定义的警告头类型都与缓存相关。一个消息中可能包含多个警告头，每个通常包括一个三位数的代码以及一个纯文本消息，遵循与HTTP响应状态代码相同的格式（在[第81章](ch81.html
    "第81章。HTTP 消息、方法和状态代码")中描述）。[表82-2](ch82.html#http_warning_header_codes "表82-2。HTTP
    警告头代码")简要列出了RFC 2616中定义的警告。|
- en: Table 82-2. HTTP Warning Header Codes
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 表82-2. HTTP 警告头代码
- en: '| Warning Code | Warning Text | Description |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| 警告代码 | 警告文本 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 110 | Response is stale | Must be included when a response provided by a
    cache is stale (that is, has passed the expiration time set for it). |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| 110 | 响应已过时 | 当缓存提供的响应已过时（即，已超过为其设置的过期时间）时必须包含。|'
- en: '| 111 | Revalidation failed | A cache attempted to revalidate a cached entry
    but was unsuccessful, so it returned its (stale) cached entry. |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| 111 | 重验证失败 | 缓存尝试重验证一个已缓存条目但未成功，因此返回了其（过时）的已缓存条目。|'
- en: '| 112 | Disconnected operation | The cache is disconnected from the rest of
    the network. |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| 112 | 断开连接操作 | 缓存与网络的其他部分断开连接。|'
- en: '| 113 | Heuristic expiration | Included if the cache chose a freshness lifetime
    of more than 24 hours, and the age of the response is also greater than 24 hours.
    |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| 113 | 启发式过期 | 如果缓存选择了一个超过24小时的 freshness lifetime，并且响应的年龄也大于24小时，则包含。|'
- en: '| 199 | Miscellaneous warning | Catchall code for other, nonspecific warnings.
    |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| 199 | 其他警告 | 其他非特定警告的通用代码。|'
- en: '| 214 | Transformation applied | Warns the recipient that an intermediate cache
    or proxy applied a transformation of some type to change the content coding or
    media type of the message or message body. |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| 214 | 应用了转换 | 警告接收者，中间缓存或代理对消息或消息体的内容编码或媒体类型进行了某种类型的转换。|'
- en: '| 299 | Miscellaneous persistent warning | Similar to code 199, but indicates
    a persistent warning. |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| 299 | 其他持久性警告 | 与代码 199 类似，但表示一个持久性警告。|'
- en: Other HTTP General Headers
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他 HTTP 通用标题
- en: 'The following are the other types of HTTP general headers:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其他类型的 HTTP 通用标题：
- en: '**Connection** Contains instructions that pertain only to this particular connection,
    and must not be retained by proxies and used for further connections. The most
    common use of this header is with the `close` parameter, as follows: `Connection:
    close`. This overrides the default persistent connection behavior of HTTP/1.1
    (described in [Chapter 80](ch80.html "Chapter 80. HTTP GENERAL OPERATION AND CONNECTIONS")),
    forcing the connection to terminate after the server''s response. Connection is
    a hop-by-hop header.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接** 包含仅适用于此特定连接的指令，并且代理不得保留这些指令用于后续连接。此标题最常见的使用是与 `close` 参数一起使用，如下所示：`Connection:
    close`。这覆盖了 HTTP/1.1 的默认持久连接行为（在[第 80 章](ch80.html "第 80 章。HTTP 通用操作和连接")中描述），强制在服务器响应后终止连接。连接是一个跳段标题。'
- en: '**Date** Indicates the date and time when the message originated. This is the
    same as the Date header in the RFC 822 email format (described in [Chapter 76](ch76.html
    "Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC
    822 AND MIME")). A typical example is `Date: Wed, 17 May 2006 16:43:50 GMT`.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '**日期** 表示消息产生的日期和时间。这与 RFC 822 电子邮件格式中的日期头相同（在[第 76 章](ch76.html "第 76 章。TCP/IP
    电子邮件消息格式和消息处理：RFC 822 和 MIME")中描述）。一个典型的例子是 `Date: Wed, 17 May 2006 16:43:50 GMT`。'
- en: '**Pragma** Used to enable implementation-specific directives to be applied
    to all devices in the request/response chain. One common use of this header is
    to suppress caching by including `Pragma: no-cache` in a message. This has the
    same meaning as a `Cache-Control: no-cache` header, and is included in HTTP/1.1
    for backward-compatibility with HTTP/1.0 (which supports Pragma but not Cache-Control).'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pragma** 用于在请求/响应链中的所有设备上应用特定实现的指令。此标题的一个常见用途是在消息中包含 `Pragma: no-cache` 以抑制缓存。这与
    `Cache-Control: no-cache` 头的含义相同，并且包含在 HTTP/1.1 中以实现与 HTTP/1.0 的向后兼容性（HTTP/1.0
    支持 Pragma 但不支持 Cache-Control）。'
- en: '**Trailer** When chunked transfers are used (as described in [Chapter 83](ch83.html
    "Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management")),
    certain headers may be placed as trailers, after the data being sent. In this
    case, the Trailer header is included before the data, and it lists the names of
    the headers that are actually trailers in that message. This warns the recipient
    to look for them after the data. Trailer is a hop-by-hop header.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '**Trailer** 当使用分块传输（如[第 83 章](ch83.html "第 83 章。HTTP 实体、传输、编码方法和内容管理")中所述）时，某些标题可以作为尾随标题放置在发送的数据之后。在这种情况下，Trailer
    标题在数据之前包含，并列出该消息中实际为尾随标题的标题名称。这警告接收者数据之后查找它们。Trailer 是一个跳段标题。'
- en: '**Transfer-Encoding** Indicates what encoding has been used for the body of
    the message, to ensure that it is able to be transferred properly between devices.
    This header is most often used with the chunked transfer method. Note that this
    header describes encoding applied to an entire message, and is thus not the same
    as the Content-Encoding entity header, which specifically describes the entity
    carried in a message. See [Chapter 83](ch83.html "Chapter 83. HTTP Entities, Transfers,
    Coding Methods, and Content Management") for a full discussion. This header applies
    only to a single transfer, so it is a hop-by-hop header.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输编码** 表示消息体所使用的编码，以确保它能够在设备之间正确传输。此标题通常与分块传输方法一起使用。请注意，此标题描述的是应用于整个消息的编码，因此它与特定描述消息中实体的
    Content-Encoding 实体标题不同。有关完整讨论，请参阅[第 83 章](ch83.html "第 83 章。HTTP 实体、传输、编码方法和内容管理")。此标题仅适用于单个传输，因此它是一个跳段标题。'
- en: '**Upgrade** Allows a client device to specify which additional protocols it
    supports. If the server also supports one of the protocols the client listed,
    the server may agree to upgrade the connection to the alternative protocol. It
    indicates the protocol to which it is upgrading by including an Upgrade header
    in a 101 (Switching Protocols) response to the client. This is a hop-by-hop header.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '**Upgrade** 允许客户端指定它支持哪些附加协议。如果服务器也支持客户端列出的协议之一，则服务器可以同意将连接升级到替代协议。它通过在客户端的
    101（切换协议）响应中包含一个 Upgrade 头来指示它升级到的协议。这是一个端到端头。'
- en: '**Via** Included by intermediary devices to indicate to the recipient which
    gateways, proxies, and/or tunnels were used in conveying a request or response.
    This header allows easy tracing of the path a message took over a potentially
    complex chain of devices between a client and server.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '**Via** 由中介设备包含，以向接收者指示在传达请求或响应时使用了哪些网关、代理和/或隧道。此头允许轻松追踪消息在客户端和服务器之间可能复杂的设备链中走过的路径。'
- en: Tip
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** HTTP *general headers* can appear in either an HTTP Request
    or HTTP Response message. They are used to communicate information about the message
    itself, as opposed to its contents. General headers are used for functions such
    as specifying the date and time of a message, controlling how the message is cached,
    and indicating its transfer encoding method.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** HTTP **通用头** 可以出现在 HTTP 请求或 HTTP 响应消息中。它们用于传达有关消息本身的信息，而不是其内容。通用头用于指定消息的日期和时间、控制消息的缓存方式以及指示其传输编码方法等功能。'
- en: HTTP Request Headers
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 请求头
- en: HTTP *request headers*, as you might imagine, are used only in HTTP Request
    messages, where they serve a number of functions. First, they allow the client
    to provide information about itself to the server. Second, they give additional
    details about the nature of the request that the client is making. Third, they
    allow the client to have greater control over how its request is processed and
    how (or even if) a response is returned by the server or intermediary.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象的那样，HTTP **请求头** 仅用于 HTTP 请求消息中，它们在消息中执行多个功能。首先，它们允许客户端向服务器提供有关自己的信息。其次，它们提供了有关客户端正在进行的请求性质的额外细节。第三，它们允许客户端对其请求的处理方式以及服务器或中介返回响应的方式（甚至是否返回）有更大的控制权。
- en: 'This is the largest of the four categories of HTTP headers, containing more
    than a dozen different types, as follows:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 HTTP 头四个类别中最大的一个，包含十几种不同的类型，如下所示：
- en: '**Accept** Allows the client to tell the server which Internet media types
    it is willing to accept in a response. The header may list several different Multipurpose
    Internet Mail Extensions (MIME) media types and subtypes that the client knows
    how to deal with. Each may be prepended with a quality value (`q` parameter) to
    indicate the client''s preference. If this header is not specified, the default
    is for the server to assume any media type may be sent to the client. See the
    discussion of entity media types and content negotiation in [Chapter 83](ch83.html
    "Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management")
    for more information about how this header is used.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '**Accept** 允许客户端告诉服务器它愿意在响应中接受哪些互联网媒体类型。该头可以列出客户端知道如何处理的多个不同的多用途互联网邮件扩展（MIME）媒体类型和子类型。每个都可以通过一个质量值（`q`
    参数）开头，以表示客户端的偏好。如果此头未指定，则默认为服务器假设可以发送给客户端的任何媒体类型。有关此头如何使用的更多信息，请参阅关于实体媒体类型和内容协商的讨论，见[第83章](ch83.html
    "第83章。HTTP 实体、传输、编码方法和内容管理")。'
- en: '**Accept-Charset** Similar to Accept, but specifies which character sets (charsets)
    the client is willing to accept in a response, rather than which media types.
    Again, the listed charsets may use a `q` value, and again, the default if the
    header is omitted is for the client to accept any charset.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**Accept-Charset** 与 Accept 类似，但指定客户端愿意在响应中接受哪些字符集（charsets），而不是媒体类型。同样，列出的字符集可以使用
    `q` 值，同样，如果省略了头，则默认为客户端接受任何字符集。'
- en: '**Accept-Encoding** Similar to Accept and Accept-Charset, but specifies which
    content encodings the client is willing to accept. This is often used to control
    whether the server may send content in compressed form. (As you''ll learn in [Chapter 83](ch83.html
    "Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management"),
    content codings are not the same as transfer encodings.)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '**Accept-Encoding** 与 Accept 和 Accept-Charset 类似，但指定了客户端愿意接受的内容编码。这通常用于控制服务器是否可以发送压缩形式的内容。（正如你将在[第83章](ch83.html
    "第83章。HTTP实体、传输、编码方法和内容管理")中学习到的，内容编码与传输编码不同。）'
- en: '**Accept-Language** Similar to the preceding Accept-type headers, but provides
    a list of *language tags* that indicates which languages the client supports or
    expects the server to use in its response.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '**Accept-Language** 与前面的 Accept-type 头部类似，但提供了一组 *语言标签*，表示客户端支持或期望服务器在其响应中使用哪些语言。'
- en: '**Authorization** Used by the client to present authentication information
    (called *credentials*) to the server to allow the client to be authenticated.
    This is required only when the server requests authentication, often by sending
    a 401 (Unauthorized) response to the client''s initial request. This response
    will contain a WWW-Authenticate header providing the client with details on how
    to authenticate with the server. See the discussion of security and privacy in
    [Chapter 84](ch84.html "Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES")
    for more information.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**Authorization** 由客户端用于向服务器提供身份验证信息（称为 *凭证*），以允许客户端进行身份验证。仅在服务器请求身份验证时才需要此信息，通常是通过向客户端的初始请求发送一个401（未授权）响应来实现的。此响应将包含一个WWW-Authenticate头部，向客户端提供有关如何与服务器进行身份验证的详细信息。有关安全和隐私的讨论，请参阅[第84章](ch84.html
    "第84章。HTTP功能、能力和问题")以获取更多信息。'
- en: '**Expect** Indicates certain types of actions that the client is expecting
    the server to perform. Usually, the server will accept the indicated parameters;
    if not, it will send back a 417 (Expectation Failed) response. The most common
    use of this field is to control when the server sends a 100 (Continue) response.
    The client indicates that it wants the server to send this preliminary reply by
    including the Expect: 100-Continue header in its request. (See the discussion
    of status codes at the end of [Chapter 81](ch81.html "Chapter 81. HTTP MESSAGES,
    METHODS, AND STATUS CODES") for details.)'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '**Expect** 表示客户端期望服务器执行的一些特定类型的操作。通常，服务器将接受指示的参数；如果不接受，它将发送一个417（期望失败）响应。此字段的常见用途是控制服务器何时发送100（继续）响应。客户端通过在其请求中包含Expect:
    100-Continue头部来指示它希望服务器发送此初步回复。（有关状态代码的讨论，请参阅[第81章](ch81.html "第81章。HTTP消息、方法和状态代码")末尾。）'
- en: '**From** Contains the email address of the human user making the request. This
    is optional, and since it is easily spoofed, should be used only for informational
    purposes, and not for any type of access rights determination or authentication.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**From** 包含发起请求的人类用户的电子邮件地址。这是可选的，并且由于它很容易被伪造，因此仅应用于信息目的，而不应用于任何类型的访问权限确定或身份验证。'
- en: '**Host** Specifies the Internet host as a Domain Name System (DNS) domain name
    and may also contain a port number specification as well (typically, only if a
    port other than the HTTP default of 80 is to be used). This header is used to
    allow multiple domains to be served by the same web server on a particular Internet
    Protocol (IP) host. It has the distinction of being the only mandatory header—it
    must be present in all HTTP/1.1 requests.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**Host** 指定互联网主机作为域名系统（DNS）域名，并且还可以包含端口号的指定（通常，只有当需要使用除HTTP默认端口80之外的端口号时）。此头部用于允许在特定的互联网协议（IP）主机上由同一个Web服务器为多个域名提供服务。它具有区别于其他头部的特点——它是唯一必需的头部——必须在所有HTTP/1.1请求中存在。'
- en: '**If-Match** Makes a method conditional by specifying the *entity tag* (or
    tags) corresponding to the specific entity that the client wishes to access. This
    is usually used in a GET method, and the server responds with the entity only
    if it matches the one specified in this header. Otherwise, the server sends a
    412 (Precondition Failed) reply.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '**If-Match** 通过指定客户端希望访问的特定实体的 *实体标签*（或标签）来使方法条件化。这通常用于GET方法，并且只有当服务器收到的实体与该头部中指定的实体匹配时，才会响应实体。否则，服务器会发送一个412（预条件失败）回复。'
- en: '**If-Modified-Since** Makes a method conditional by telling the server to return
    the requested entity only if it has been modified since the time specified in
    this header. Otherwise, the server sends a 304 (Not Modified) response. This is
    used to check if a resource has changed since it was last accessed, to avoid unnecessary
    transfers.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '**If-Modified-Since** 通过告诉服务器仅在自该头中指定的时间以来实体已修改的情况下返回请求的实体，使方法条件化。否则，服务器发送
    304 (未修改) 响应。这用于检查资源自上次访问以来是否已更改，以避免不必要的传输。'
- en: '**If-None-Match** The opposite of If-Match; it creates a conditional request
    that is only filled if the specified tag(s) do not match the requested entity.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '**If-None-Match** If-Match 的对立面；它创建一个条件请求，仅在指定的标签不匹配请求的实体时才填充。'
- en: '**If-Range** Used in combination with the Range header to effectively allow
    a client to both check for whether an entity has changed and request that a portion
    of it be sent in a single request. (The alternative is to first issue a conditional
    request, and if it fails, issue a second request.) When present, If-Range tells
    the server to send to the client the part of the entity indicated in the Range
    header if the entity has not changed. If the entity has changed, the server sends
    the entire entity in response.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**If-Range** 与 Range 头结合使用，有效地允许客户端在单个请求中同时检查实体是否已更改并请求发送其一部分。 (另一种选择是首先发出一个条件请求，如果它失败，再发出第二个请求。)
    当存在时，If-Range 告诉服务器如果实体未更改，则向客户端发送 Range 头中指示的实体部分。如果实体已更改，服务器将发送整个实体作为响应。'
- en: '**If-Unmodified-Since** The logical opposite of the If-Modified-Since header;
    the request is filled only if the resource has *not* been modified since the specified
    time. Otherwise, the server sends a 412 reply.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '**If-Unmodified-Since** If-Modified-Since 头的逻辑对立面；只有在自指定时间以来资源未修改的情况下才填充请求。否则，服务器发送
    412 回复。'
- en: '**Max-Forwards** Specifies a limit on the number of times a request can be
    forwarded to the next device in the request chain. This header is used with the
    TRACE or OPTIONS methods only, to permit diagnosis of forwarding failures or looping.
    When present in one of these methods, each time a device forwards the request,
    the number in this header is decremented. If a device receives a request with
    a Max-Forwards value of 0, it must not forward it, but rather it should respond
    back to the client. (In a way, this is somewhat analogous to how the Time to Live
    field is used in the IP datagram format, as described in [Chapter 21](ch21.html
    "Chapter 21. INTERNET PROTOCOL DATAGRAM ENCAPSULATION AND FORMATTING").)'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '**Max-Forwards** 指定请求可以转发到请求链中下一个设备的次数限制。此头仅与 TRACE 或 OPTIONS 方法一起使用，以允许诊断转发失败或循环。当存在于这些方法之一中时，每次设备转发请求，此头中的数字就会递减。如果设备收到一个
    Max-Forwards 值为 0 的请求，它必须不转发它，而应该向客户端响应。 (从某种意义上说，这与 IP 数据报格式中 Time to Live 字段的使用方式类似，如第
    21 章所述。[第 21 章](ch21.html "第 21 章。互联网协议数据报封装和格式化")。)'
- en: '**Proxy-Authorization** Like the Authorization header, but used to present
    credentials to a proxy server for authentication, rather than to the end server.
    It is created using information sent by a proxy in a response containing a Proxy-Authenticate
    header. This is a hop-by-hop header, sent only to the first proxy that receives
    the request. If authentication is required with more than one proxy, multiple
    Proxy-Authorization headers may be put in a message, with each proxy consuming
    one of the headers.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '**Proxy-Authorization** 与 Authorization 头类似，但用于向代理服务器提供用于身份验证的凭据，而不是向最终服务器。它使用包含
    Proxy-Authenticate 头的响应中发送的信息创建。这是一个跳到跳的头，仅发送到接收请求的第一个代理。如果需要通过多个代理进行身份验证，可以在消息中放置多个
    Proxy-Authorization 头，每个代理消耗一个头。'
- en: '**Range** Allows the client to request that the server send it only a portion
    of an entity, by specifying a range of bytes in the entity to be retrieved. If
    the requested range is valid, the server sends only the indicated part of the
    file, using a 206 (Partial Content) status code; if the range requested cannot
    be filled, the reply is 416 (Requested Range Not Satisfiable).'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**Range** 允许客户端请求服务器只发送实体的一部分，通过指定要检索的实体中的字节数范围。如果请求的范围有效，服务器将只发送指示的文件部分，使用
    206 (部分内容) 状态码；如果请求的范围无法满足，则回复是 416 (请求范围无法满足)。'
- en: '**Referer** Tells the server the Uniform Resource Locator (URL) of the resource
    from which the URL of the current request was obtained. Typically, when a user
    clicks a link on one web page to load another, the address of the original web
    page is put into the Referer line when the request for the clicked link is sent.
    This allows tracking and logging of how the server is accessed. If a human user
    manually enters a Uniform Resource Identifier (URI) into a web browser, this header
    is not included in the request. Since this header provides information related
    to how web pages are used, it has certain privacy implications.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '**Referer** 告诉服务器当前请求的URL是从哪个资源的URL获得的。通常，当用户点击一个网页上的链接以加载另一个网页时，原始网页的地址会在发送点击链接的请求时放入Referer行。这允许跟踪和记录服务器是如何被访问的。如果人工用户手动将统一资源标识符（URI）输入到网络浏览器中，则此头不会包含在请求中。由于此头提供有关网页使用方式的信息，因此它具有某些隐私影响。'
- en: Note
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The proper spelling of this word is referrer. It was misspelled years ago
    in an earlier version of the HTTP standard, and before this was noticed and corrected,
    this spelling became incorporated into so much software that the Internet Engineering
    Task Force (IETF) chose not to correct the spelling in HTTP/1.1*.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个词的正确拼写是referrer。在HTTP标准的早期版本中多年以前被误拼，在此拼写被发现并纠正之前，这种拼写已经融入了大量的软件中，因此互联网工程任务组（IETF）选择不在HTTP/1.1中纠正拼写*。'
- en: '**TE** Provides information to the server about how the client wishes to deal
    with transfer encodings for entities sent by the server. If extensions to the
    standard HTTP transfer encodings are defined, the client can indicate its willingness
    to accept them in this header. The client can also use the header `TE: trailers`
    to indicate its ability to handle having headers sent as trailers following data
    when chunking of data is done. This is a hop-by-hop header and applies only to
    the immediate connection.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**TE** 向服务器提供有关客户端希望如何处理服务器发送的实体传输编码的信息。如果定义了标准HTTP传输编码的扩展，客户端可以使用此头指示其愿意接受它们。客户端还可以使用头
    `TE: trailers` 来指示其处理在分块数据时作为拖车发送的头的功能。这是一个跳过跳（hop-by-hop）的头，仅适用于直接连接。'
- en: '**User-Agent** Provides information about the client software. This is normally
    the name and version number of the web browser or other program sending the request.
    It is used for server access statistic logging and also may be used to tailor
    how the server responds to the needs of different clients. Note that proxies do
    not modify this field when forwarding a request; rather, they use the Via header.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '**User-Agent** 提供有关客户端软件的信息。这通常是发送请求的网页浏览器或其他程序的名称和版本号。它用于服务器访问统计日志记录，也可能被用来调整服务器如何响应不同客户端的需求。请注意，代理在转发请求时不会修改此字段；相反，它们使用Via头。 '
- en: Tip
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** HTTP *request headers* are used only in HTTP Request messages.
    They allow a client to provide information about itself to a server, provide more
    details about a request, and allow control over how the request is carried out.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** HTTP *请求头* 仅用于HTTP请求消息中。它们允许客户端向服务器提供有关自己的信息，提供更多关于请求的细节，并允许控制请求的执行方式。'
- en: HTTP Response Headers
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP响应头
- en: The counterpart to request headers, *response headers*, appear only in HTTP
    responses sent by servers or intermediaries. They provide additional data that
    expands on the summary information that is present in the status line at the beginning
    of each server reply. Many of the response headers are sent only in response to
    the receipt of specific types of requests or even to particular headers within
    certain requests.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 请求头（request headers）的对应项，*响应头（response headers*），仅出现在服务器或中间件发送的HTTP响应中。它们提供了额外的数据，这些数据扩展了每个服务器回复开始时的状态行中存在的摘要信息。许多响应头仅在收到特定类型的请求或甚至某些请求中的特定头时发送。
- en: 'There are nine response headers defined for HTTP/1.1:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.1定义了九个响应头：
- en: '**Accept-Ranges** Tells the client whether the server accepts partial content
    requests using the Range request header, and if so, what type. For example, include
    `Accept-Range: bytes` indicates the server accepts byte ranges, and `Accept-Range:
    none` indicates range requests are not supported. Note that this is header is
    different from the other Accept- headers, which are used in HTTP requests to perform
    content negotiation.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '**Accept-Ranges** 告诉客户端服务器是否接受使用Range请求标题的局部内容请求，以及如果接受，接受哪种类型。例如，包含`Accept-Range:
    bytes`表示服务器接受字节范围，而`Accept-Range: none`表示不支持范围请求。请注意，此标题与其他Accept-标题不同，这些标题用于HTTP请求以执行内容协商。'
- en: '**Age** Tells the client the approximate age of the resource, as calculated
    by the device sending the response.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '**Age** 告诉客户端资源的大致年龄，这是由发送响应的设备计算的。'
- en: '**ETag** Specifies the entity tag for the entity included in the response.
    This value can be used by the client in future requests to uniquely identify an
    entity, using the If-Match (or similar) request header.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '**ETag** 指定包含在响应中的实体标签。此值可以在客户端未来的请求中使用，以唯一标识一个实体，使用If-Match（或类似）请求标题。'
- en: '**Location** Indicates a new URL that the server is instructing the client
    to use in place of the one the client initially requested. This header is normally
    used when the server redirects a client request to a new location, using a 301,
    302, or 307 reply. It is also used to indicate the location of a created resource
    in a 201 (Created) response to a PUT request. Note that this is not the same as
    the Content-Location entity header, which is used to indicate the location of
    the originally requested resource.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置** 指示服务器指示客户端使用的新URL，以替代客户端最初请求的URL。此标题通常在服务器使用301、302或307响应将客户端请求重定向到新位置时使用。它还用于在PUT请求的201（已创建）响应中指示创建的资源的位置。请注意，这与用于指示原始请求资源位置的Content-Location实体标题不同。'
- en: '**Proxy-Authenticate** The proxy version of the WWW-Authenticate header (described
    next). It is included in a 407 (Proxy Authentication Required) response, to indicate
    how the proxy is requiring the client to perform authentication. The header specifies
    an authentication method, as well as any other parameters needed for authentication.
    The client will use this to generate a new request containing a Proxy-Authorization
    header. This is a hop-by-hop header.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '**Proxy-Authenticate** 是WWW-Authenticate标题的代理版本（将在下面描述）。它包含在407（代理身份验证所需）响应中，以指示代理如何要求客户端执行身份验证。标题指定了身份验证方法以及身份验证所需的任何其他参数。客户端将使用此信息生成一个包含Proxy-Authorization标题的新请求。这是一个跳转-跳转标题。'
- en: '**Retry-After** Sometimes included in unsuccessful requests—such as those resulting
    in a 503 (Service Unavailable) response—to tell the client when it should try
    its request again. It may also be used with a redirection response such as 301,
    302, or 307 to indicate how long the client should wait before sending a request
    for the redirected URL. The Retry-After header may specify either a time interval
    to wait (in seconds) or a full date/time when the server suggests the client try
    again.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**Retry-After** 有时包含在失败的请求中——例如，导致503（服务不可用）响应的请求——以告诉客户端何时应再次尝试其请求。它还可以与重定向响应（如301、302或307）一起使用，以指示客户端在发送重定向URL的请求之前应等待多长时间。Retry-After标题可以指定一个等待的时间间隔（以秒为单位）或服务器建议客户端再次尝试的完整日期/时间。'
- en: '**Server** The server''s version of the User-Agent request header. It identifies
    the type and version of the server software generating the response. Note that
    proxies do not modify this field when forwarding a response; they put their identification
    information into a Via header instead.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器** 服务器版本的User-Agent请求标题。它标识生成响应的服务器软件的类型和版本。请注意，当代理转发响应时，代理不会修改此字段；它们将标识信息放入Via标题中。'
- en: '**Vary** Specifies which request header fields fully determine whether a cache
    is allowed to use this response to reply to subsequent requests for the same resource
    without revalidation. A caching device inspects the Vary header to ascertain which
    other headers it needs to examine when the client makes its next request for the
    resource in this reply, to determine whether it can respond with a cached entry.
    (See [Chapter 84](ch84.html "Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES")
    for more information about caching, which should make the use of this header easier
    to understand.)'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vary** 指定哪些请求头部字段完全确定缓存是否可以使用此响应来回复后续请求同一资源而不进行重新验证。缓存设备检查 Vary 头部以确定当客户端发出对此次响应中资源的下一个请求时，它需要检查哪些其他头部，以确定它是否可以使用缓存条目进行响应。（有关缓存的更多信息，请参阅[第
    84 章](ch84.html "第 84 章。HTTP 功能、能力和问题")，这将有助于理解此头部的使用。）'
- en: '**WWW-Authenticate** Included in a 401 (Unauthorized) response to indicate
    how the server wants the client to authenticate. The header specifies an authentication
    method as well as any other parameters needed for authentication. The client will
    use this to generate a new request containing an Authorization header.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '**WWW-Authenticate** 包含在 401 (未授权) 响应中，以指示服务器希望客户端如何进行身份验证。该头部指定了身份验证方法以及任何其他用于身份验证的参数。客户端将使用此信息生成一个新的请求，其中包含一个授权头部。'
- en: Tip
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** HTTP *response headers* appear in HTTP Response messages, where
    they provide additional information about HTTP server capabilities and requirements,
    and the results of processing a client request.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** HTTP *响应头部* 出现在 HTTP 响应消息中，其中它们提供了有关 HTTP 服务器能力和要求的附加信息，以及处理客户端请求的结果。'
- en: HTTP Entity Headers
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 实体头部
- en: 'Last, but not least, we come to the fourth group of HTTP headers: *entity headers*.
    These headers provide information about the resource carried in the body of an
    HTTP message, called an *entity* in the HTTP standards. They serve the overall
    purpose of conveying to the recipient of a message the information it needs to
    properly process and display the entity, such as its type and encoding method.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，我们来到了第四组 HTTP 头部：*实体头部*。这些头部提供了有关 HTTP 消息主体中携带的资源的信息，在 HTTP 标准中称为
    *实体*。它们服务于传达给消息接收者所需的信息，以便正确处理和显示实体，例如其类型和编码方法。
- en: The most common type of entity is a file or another set of information that
    has been requested by a client, and for this reason, entity headers most often
    appear in HTTP Response messages. However, they can also appear in HTTP Request
    messages, especially those using the PUT and POST methods, which are the ones
    that transfer data from a client to a server.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的实体类型是客户端请求的文件或其他信息集，因此实体头部最常出现在 HTTP 响应消息中。然而，它们也可以出现在 HTTP 请求消息中，特别是使用
    PUT 和 POST 方法的请求，这些方法是从客户端向服务器传输数据。
- en: At least one entity header should appear in any HTTP message that carries an
    entity. However, they may also be present in certain responses that do not have
    an actual entity in them. Most notably, a response to a HEAD request will contain
    all the entity headers associated with the resource specified in the request;
    these are the same headers that would have been included with the entity had the
    GET method been used instead of the HEAD method on the same resource. Entity headers
    may also be present in certain error responses to provide information to help
    the client make a successful follow-up request.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 任何携带实体的 HTTP 消息至少应包含一个实体头部。然而，它们也可能出现在某些没有实际实体的响应中。最值得注意的是，对 HEAD 请求的响应将包含与请求中指定的资源相关联的所有实体头部；这些头部与在相同资源上使用
    GET 方法而不是 HEAD 方法时包含在实体中的头部相同。实体头部也可能出现在某些错误响应中，以提供帮助客户端成功发出后续请求的信息。
- en: Note
  id: totrans-528
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Many of the entity headers have the same names as certain MIME headers, but
    they are often used in different ways. See the topic on HTTP Internet media types
    in [Chapter 83](ch83.html "Chapter 83. HTTP Entities, Transfers, Coding Methods,
    and Content Management") for a full discussion of the relationship between HTTP
    and MIME*.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多实体头部与某些 MIME 头部具有相同的名称，但它们通常以不同的方式使用。请参阅[第 83 章](ch83.html "第 83 章。HTTP
    实体、传输、编码方法和内容管理")中关于 HTTP 互联网媒体类型的主题，以全面了解 HTTP 与 MIME 之间的关系*。'
- en: 'There are ten entity headers defined for HTTP/1.1:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.1 定义了十个实体头部：
- en: '**Allow** Lists all the methods that are supported for a particular resource.
    This header may be provided in a server response as a guide to the client regarding
    what methods it may use on the resource in the future. The header must be included
    when a server returns a 405 (Method Not Allowed) response to a request containing
    an unsupported method.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '**允许** 列出特定资源支持的所有方法。此报头可以作为服务器响应的一部分提供，以指导客户端关于将来可以在资源上使用哪些方法。当服务器返回一个包含不支持方法的请求的405（方法不允许）响应时，必须包含此报头。'
- en: '**Content-Encoding** Describes any optional method that may have been used
    to encode the entity. This header is most often used when transferring entities
    that have been compressed. It tells the recipient which algorithm has been used
    so the entity can be uncompressed. Note that this header describes only transformations
    performed on the entity in a message; the Transfer-Encoding header describes encodings
    done on the message as a whole. See the discussion of content codings and transfer
    codings in [Chapter 83](ch83.html "Chapter 83. HTTP Entities, Transfers, Coding
    Methods, and Content Management") for more details.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容编码** 描述可能已用于编码实体的任何可选方法。此报头最常用于传输已压缩的实体。它告诉接收者使用了哪种算法，以便可以解压缩实体。请注意，此报头仅描述在消息中对实体执行的转换；传输编码报头描述对整个消息执行的编码。有关内容编码和传输编码的更多详细信息，请参阅[第83章](ch83.html
    "第83章。HTTP实体、传输、编码方法和内容管理")中的讨论。'
- en: '**Content-Language** Specifies the natural (human) language intended for using
    the entity. This is an optional header, and it may not be appropriate for all
    resource types. Multiple languages may be specified, if needed. This header is
    intended to provide guidance so the entity can be presented to the correct audience;
    thus, the language should be selected based on who would best use the material,
    which may not necessarily include all of the languages used in the entity. For
    example, a German analysis of Italian operas would probably be best tagged only
    with the language *de*.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容语言** 指定用于使用实体的自然（人类）语言。这是一个可选的报头，并且可能不适合所有资源类型。如果需要，可以指定多种语言。此报头旨在提供指导，以便实体可以呈现给正确的受众；因此，应根据谁最能使用材料来选择语言，这不一定包括实体中使用的所有语言。例如，对意大利歌剧的德国分析可能最好只标记为语言
    *de*。'
- en: '**Content-Length** Indicates the size of the entity in octets. This header
    is important, as it is used by the recipient to determine the end of a message.
    However, it may be included only in cases where the length of a message can be
    fully determined prior to transmitting the entity. This is not always possible
    in the case of dynamically generated content, which complicates message-length
    calculation; the discussion of data length and chunked transfer encoding in [Chapter 83](ch83.html
    "Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management")
    contains a full exploration of this issue.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容长度** 指示实体的大小（以字节为单位）。此报头很重要，因为它被接收者用来确定消息的结束。然而，只有在可以在传输实体之前完全确定消息长度的情况下才包含此报头。在动态生成内容的情况下，这通常是不可能的，这使消息长度计算复杂化；[第83章](ch83.html
    "第83章。HTTP实体、传输、编码方法和内容管理")中关于数据长度和分块传输编码的讨论全面探讨了这个问题。'
- en: '**Content-Location** Specifies the resource location of the entity, in the
    form of an absolute or relative URL. This is an optional header, and it is normally
    included only in cases where the entity has been supplied from a location different
    from the one specified in the request. This may occur if a particular resource
    is stored in multiple places.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容位置** 指定实体资源的位置，形式为绝对或相对URL。这是一个可选的报头，通常仅在实体是从与请求中指定的位置不同的位置提供时才包含。如果特定资源存储在多个位置，可能会发生这种情况。'
- en: '**Content-MD5** Contains a Message Digest 5 (MD5) digest for the entity, used
    for checking message integrity.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容-MD5** 包含实体的消息摘要5（MD5）摘要，用于检查消息完整性。'
- en: '**Content-Range** Sent when a message contains an entity that is only part
    of a complete resource—for example, a fragment of a file sent in response to an
    HTTP GET request containing the Range header. The Content-Range header indicates
    which portion of the overall file this message contains, as well as the total
    size of the resource. This information is given as a byte range, with the first
    byte numbered 0\. For example, if the entity contains the first 1200 bytes of
    a 2000-byte file, this header would have a value of 0-1199/2000.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容范围** 当消息包含仅是完整资源的一部分的实体时发送——例如，在包含Range标题的HTTP GET请求中发送的文件片段。Content-Range标题指示此消息包含整体文件的哪个部分，以及资源的总大小。此信息以字节范围的形式给出，第一个字节编号为0。例如，如果实体包含一个2000字节文件的第一个1200字节，则此标题的值将为0-1199/2000。'
- en: '**Content-Type** Specifies the media type and subtype of the entity, in a manner
    very similar to how this header is used in MIME. See [Chapter 83](ch83.html "Chapter 83. HTTP
    Entities, Transfers, Coding Methods, and Content Management") for a full discussion.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容类型** 指定实体的媒体类型和子类型，其方式与MIME中此标题的使用非常相似。参见[第83章](ch83.html "第83章。HTTP实体、传输、编码方法和内容管理")以获取全面讨论。'
- en: '**Expires** Specifies a date and time after which the entity in the message
    should be considered stale. This may be used to identify certain entities that
    should be held in HTTP caches for longer or shorter periods of time than usual.
    This header is ignored if a Cache-Control header containing the max-age directive
    is present in the message.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**过期时间** 指定一个日期和时间，在此之后，消息中的实体应被视为过时。这可以用来标识某些实体，这些实体在HTTP缓存中应比通常更长时间或更短时间保留。如果消息中存在包含max-age指令的Cache-Control标题，则忽略此标题。'
- en: '**Last-Modified** Indicates the date and time when the server believes the
    entity was last changed. This header is often used to determine if a resource
    has been modified since it was last retrieved. For example, suppose a client machine
    already contains a copy of a very large file that was obtained two months ago,
    and its user wants to check if an update to the file is available. The client
    can send a HEAD request for the file, and compare the value of the returned Last-Modified
    header to the date of the copy of the file it already has. Then it needs to request
    the entire file only if it has changed.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**最后修改时间** 指示服务器认为实体最后一次被修改的日期和时间。此标题通常用于确定资源自上次检索以来是否已被修改。例如，假设客户端机器已经包含了一个两个月前获得的非常大的文件的副本，并且其用户想要检查文件是否有更新。客户端可以为该文件发送一个HEAD请求，并将返回的Last-Modified标题的值与其已有的文件副本的日期进行比较。然后，只有在文件已更改的情况下，它才需要请求整个文件。'
- en: Note the use of the word "believes" in the preceding description of the Last-Modified
    header. The reason for this wording is that the server cannot always be certain
    of the time that a resource was modified. With files this is fairly simple—it
    is usually the last-modified time stored for the file by the operating system.
    For other more complex resources such as database records or virtual objects,
    however, it may be more difficult to ascertain when the last change occurred to
    a particular piece of information. In the case of dynamically generated content,
    the Last-Modified date/time may be the same as that of the message as a whole,
    as specified in the Date field.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在Last-Modified标题的前面描述中使用了“相信”这个词。这种措辞的原因是服务器不能总是确定资源被修改的时间。对于文件来说，这相对简单——通常是操作系统为文件存储的最后一次修改时间。然而，对于其他更复杂的资源，如数据库记录或虚拟对象，确定特定信息最后一次更改的时间可能更困难。在动态生成内容的情况下，Last-Modified日期/时间可能与整个消息的日期相同，如Date字段中指定的。
- en: Tip
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** HTTP *entity headers* appear in either Request or Response
    messages that carry an entity in the message body. They describe the nature of
    the entity, including its type, language, and encoding, to facilitate the proper
    processing and presentation of the entity by the device receiving it.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** HTTP *实体标题* 出现在包含消息主体的请求或响应消息中。它们描述了实体的性质，包括其类型、语言和编码，以便接收设备的正确处理和展示。'
- en: Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第83章。HTTP实体、传输、编码方法和内容管理
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: Hypertext Transfer Protocol (HTTP) message headers are very important, because
    they are the mechanism that HTTP uses to allow devices to specify the details
    of client requests and server responses. These headers, however, are only the
    means to an end, which is the transfer of resources (such as files, form input,
    and program output) from one device to another. When a resource is carried in
    the body of an HTTP message, it is called an *entity*. HTTP defines special rules
    for how these entities are identified, encoded, and transferred.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本传输协议（HTTP）的消息头非常重要，因为它们是 HTTP 用来允许设备指定客户端请求和服务器响应细节的机制。然而，这些头信息只是达到目的的手段，目的是将资源（如文件、表单输入和程序输出）从一个设备传输到另一个设备。当一个资源包含在
    HTTP 消息体中时，它被称为 *实体*。HTTP 定义了特殊的规则来规定这些实体的识别、编码和传输方式。
- en: In this chapter, I explain how HTTP handles entities. I begin with a discussion
    of entities in general terms and a look at how their contents are identified.
    This includes an examination of the relationship between HTTP and Multipurpose
    Internet Mail Extensions (MIME). I discuss the issues behind the transfer of entities
    between clients and servers, and the difference between content encodings and
    transfer encodings. I describe the special issues associated with identifying
    the length of entities in HTTP messages, and detail the special chunked transfer
    coding and message trailers. Finally, I describe the methods by which devices
    can perform content negotiation and how quality values allow clients to intelligently
    select different variations of a resource.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我解释了 HTTP 如何处理实体。我首先从一般意义上讨论实体，并查看其内容是如何被识别的。这包括对 HTTP 和多用途互联网邮件扩展（MIME）之间关系的考察。我讨论了实体在客户端和服务器之间传输的问题，以及内容编码和传输编码之间的区别。我描述了与在
    HTTP 消息中识别实体长度相关的特殊问题，并详细说明了特殊的分块传输编码和消息尾迹。最后，我描述了设备如何执行内容协商的方法，以及质量值如何允许客户端智能地选择资源的不同变体。
- en: HTTP Entities and Internet Media Types
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 实体和互联网媒体类型
- en: 'The presence of the word *text* in the name Hypertext Transfer Protocol is
    a reminder of the legacy of HTTP. As I explained in [Chapter 80](ch80.html "Chapter 80. HTTP
    GENERAL OPERATION AND CONNECTIONS"), HTTP was originally created to allow text
    documents to be linked together. This made sense, because at the time that the
    Web was being created, most computing was being done with text. Accordingly, the
    first version of HTTP (HTTP/0.9) supported only one type of message body: a plain
    ASCII text document.'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本传输协议（HTTP）名称中的“text”一词是对 HTTP 传统的提醒。正如我在[第 80 章](ch80.html "第 80 章。HTTP 一般操作和连接")中解释的那样，HTTP
    最初被创建是为了允许文本文档相互链接。这在当时是有意义的，因为当时网络被创建时，大多数计算都是用文本进行的。因此，HTTP 的第一个版本（HTTP/0.9）只支持一种类型的消息体：纯
    ASCII 文本文档。
- en: In the early 1990s, the rapid increase in computing power and networking performance
    transformed the world of information technology from text to multimedia. These
    were also the Web's formative years, and it did not take long before many users
    wanted to exploit the power of the Web to share not only text files, but also
    pictures, drawings, sound clips, movies, and much more. Thus, HTTP had to evolve
    as well. Starting with HTTP/1.0, the protocol's developers made significant changes
    to allow HTTP to transport and process much more than just text. Today, HTTP really
    would be better described as dealing with *hypermedia* than *hypertext*.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在 20 世纪 90 年代初期，计算能力和网络性能的迅速增长将信息技术世界从文本转变为多媒体。这些也是网络的成型时期，不久之后，许多用户都希望利用网络的力量来分享不仅仅是文本文件，还有图片、绘图、声音剪辑、电影等等。因此，HTTP
    也必须随之发展。从 HTTP/1.0 开始，该协议的开发者做出了重大改变，允许 HTTP 传输和处理比文本多得多的内容。今天，HTTP 实际上更应该被描述为处理
    *超媒体* 而不是 *超文本*。
- en: 'One drawback of supporting many types of files in HTTP is added complexity.
    Previously, every message recipient knew the body contained ASCII text; now any
    message can contain any of many kinds of data. When HTTP was expanded to support
    flexible media, it needed a system that would address two specific issues: encoding
    entities of various types into an HTTP message body and clearly identifying the
    entity''s characteristics for the recipient of the message.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 中支持许多类型的文件的一个缺点是增加了复杂性。以前，每个消息接收者都知道消息体包含 ASCII 文本；现在任何消息都可能包含许多种类的数据。当
    HTTP 扩展到支持灵活的媒体时，它需要一个系统来解决两个具体问题：将各种类型的实体编码到 HTTP 消息体中，并清楚地识别实体特性以便消息的接收者。
- en: 'At the same time that HTTP was being changed to support nontext entities, another
    important TCP/IP application was also moving away from its decades-long role as
    a text-messaging medium to one that could transport multimedia: electronic mail
    (email). This was accomplished using a technology called MIME (introduced in [Chapter 76](ch76.html
    "Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC
    822 AND MIME")), which define a mechanism for encoding and identifying nontext
    data—exactly what HTTP needed to do. Since TCP/IP developers wisely reuse technologies
    that work, the creators of HTTP borrowed many concepts from MIME, including many
    of the MIME email headers that are used to identify the contents of a MIME message.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 当 HTTP 正在改变以支持非文本实体时，另一个重要的 TCP/IP 应用也在从其数十年的文本消息媒介角色转变为能够传输多媒体的角色：电子邮件（email）。这是通过一种称为
    MIME 的技术（在第 76 章[介绍](ch76.html "第76章。TCP/IP 电子邮件消息格式和消息处理：RFC 822 和 MIME")）实现的，该技术定义了一种编码和标识非文本数据的方法——这正是
    HTTP 需要做的。由于 TCP/IP 开发者明智地重用了有效的工作技术，HTTP 的创造者借鉴了 MIME 的许多概念，包括许多用于标识 MIME 消息内容的
    MIME 电子邮件头。
- en: Media Types and Subtypes
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 媒体类型和子类型
- en: 'The most important concept that HTTP adopted from MIME was the use of standardized
    Internet media types, which describe the contents of an HTTP entity. The formal
    syntax of an HTTP media type is the same as that used in MIME:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 从 MIME 中采纳的最重要概念是使用标准化的互联网媒体类型，这些类型描述了 HTTP 实体的内容。HTTP 媒体类型的正式语法与 MIME
    中使用的语法相同：
- en: '| <*type*>/<*subtype*> [; *parameter1* ; *parameter2* … ; *parameterN* ] |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| <*type*>/<*subtype*> [; *parameter1* ; *parameter2* … ; *parameterN* ] |'
- en: Each media type consists of a top-level media type that defines its general
    nature and a more specific subtype that indicates its form or structure. For example,
    text documents use the top-level media type `text`, with subtypes such as `plain`
    for regular unformatted text and `html` for HTML documents. So, an HTML document
    of the type commonly transported using HTTP will be identified with a media type
    of `text/html`. Similarly, `image` is a top-level media type, with subtypes such
    as `jpeg`, `gif`, and `tiff`. Photographs usually are identified as `image/jpeg`,
    while line drawings are often seen as `image/gif`. Additional parameters may also
    be supplied to provide more information to help a recipient interpret the entity.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 每种媒体类型由一个顶层媒体类型定义其一般性质，以及一个更具体的子类型，该子类型指示其形式或结构。例如，文本文档使用顶层媒体类型 `text`，子类型包括
    `plain` 用于常规未格式化文本和 `html` 用于 HTML 文档。因此，使用 HTTP 常见传输的 HTML 文档将被标识为 `text/html`
    媒体类型。同样，`image` 是一个顶层媒体类型，子类型包括 `jpeg`、`gif` 和 `tiff`。照片通常被标识为 `image/jpeg`，而线图通常被看作
    `image/gif`。还可以提供额外的参数，以提供更多信息，帮助接收者解释实体。
- en: HTTP's Use of Media Types
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 对媒体类型的运用
- en: 'In HTTP, media types are most often seen in a special Content-Type entity header,
    which is present in any HTTP message that carries an entity. This header uses
    the same format as the header of the same name in MIME:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 中，媒体类型最常见于特殊的 `Content-Type` 实体头，该头出现在任何携带实体的 HTTP 消息中。此头使用与 MIME 中同名头的相同格式：
- en: '| Content-Type: <*type*>/<*subtype*> [; *parameter1* ; *parameter2* … ; *parameterN*
    ] |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| Content-Type: <*type*>/<*subtype*> [; *parameter1* ; *parameter2* … ; *parameterN*
    ] |'
- en: Tip
  id: totrans-560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tip
- en: '**RELATED INFORMATION** *I provide a more complete description of both the
    Content-Type header and Internet media types, including a description of many
    types and subtypes, in [Chapter 76](ch76.html "Chapter 76. TCP/IP ELECTRONIC MAIL
    MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME"). HTTP can also support
    composite media types, such as the multipart media type*.'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**相关信息** *我在[第76章](ch76.html "第76章。TCP/IP 电子邮件消息格式和消息处理：RFC 822 和 MIME")提供了对内容类型头和互联网媒体类型的更完整描述，包括许多类型和子类型的描述。HTTP
    也可以支持复合媒体类型，例如多部分媒体类型*。'
- en: The other place where media types are used in HTTP is in the Accept request
    header, which may appear in an HTTP request sent by a client. If present, the
    purpose of this header is to tell the server what sorts of media types the client
    can handle, so the server will not send a response that cannot be processed. For
    example, if a client can process only text documents, it might send a request
    specifying this in an Accept header. This is part of the overall content negotiation
    process supported by HTTP, which I describe in the "HTTP Content Negotiation and
    Quality Values" section later in this chapter.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP中媒体类型被使用的另一个地方是在客户端发送的HTTP请求中的Accept请求头部。如果存在，此头部的目的是告诉服务器客户端可以处理哪些媒体类型，以便服务器不会发送无法处理的响应。例如，如果客户端只能处理文本文档，它可能会在Accept头部中指定这一点。这是HTTP支持的整体内容协商过程的一部分，我将在本章后面的“HTTP内容协商和质量值”部分中描述。
- en: When a media type is specified in an Accept header, either the subtype or both
    the type and subtype can be replaced by the asterisk (*) wildcard to represent
    any acceptable type. For example, in an Accept header, the specification `text/html`
    refers to an HTML document, while `text/*` means any text type. The string `*/*`
    means any type of media; this is usually used in combination with a `q` value,
    as explained in the discussion of the HTTP content negotiation process later in
    this chapter.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Accept头部中指定媒体类型时，子类型或类型和子类型都可以用星号 (*) 通配符替换，以表示任何可接受类型。例如，在Accept头部中，指定`text/html`指的是HTML文档，而`text/*`表示任何文本类型。字符串`*/*`表示任何媒体类型；这通常与一个`q`值一起使用，如本章后面关于HTTP内容协商过程的讨论中所述。
- en: Tip
  id: totrans-564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** While HTTP is most often associated with hypertext, its messages
    can transport a large variety of different types of files, including images, audio,
    video, and much more. To indicate the type of entity contained in an HTTP message,
    its sender must identify its media *type* and *subtype*. This is done using the
    HTTP Content-Type header, which was borrowed from the Multipurpose Internet Mail
    Extensions (MIME) specification.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 虽然HTTP通常与超文本相关联，但其消息可以传输各种不同类型的文件，包括图像、音频、视频等等。为了指示HTTP消息中包含的实体类型，其发送者必须识别其媒体
    *类型* 和 *子类型*。这是通过使用HTTP Content-Type头部来完成的，该头部是从多用途互联网邮件扩展（MIME）规范中借用的。'
- en: Differences in HTTP and MIME Constructs
  id: totrans-566
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP和MIME结构之间的差异
- en: In addition to media types, HTTP also borrows from MIME in several other ways,
    such as MIME's notion of content codings and the use of a header to indicate the
    length of an entity. It's important to recognize, however, that even though HTTP's
    handling of Internet media is very similar to that of MIME, it is not identical.
    In fact, there was an early proposal that HTTP use MIME exactly as defined, but
    HTTP's developers specifically decided not to do this. We will explore a possible
    reason why HTTP is not strictly MIME-compliant in the next section.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 除了媒体类型外，HTTP还在其他几个方面借鉴了MIME，例如MIME的内容编码概念以及使用头部来指示实体的长度。然而，重要的是要认识到，尽管HTTP处理互联网媒体的方式与MIME非常相似，但它们并不相同。事实上，曾有一个早期建议HTTP使用MIME的精确定义，但HTTP的开发者明确决定不这样做。我们将在下一节探讨HTTP不是严格符合MIME规范的可能原因。
- en: The bottom line is that HTTP's developers chose to adopt concepts from MIME
    that made sense and to leave other parts out. As a result, HTTP messages are not
    MIME-compliant, even though you may see several headers in HTTP messages starting
    with MIME's Content- prefix. For example, even though HTTP has a Content-Encoding
    header, its use is quite different from that of MIME's. The fact that HTTP does
    not use the MIME-Version header that is required in MIME messages confirms the
    difference between HTTP and MIME.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，HTTP的开发者选择了从MIME中采用有意义的概念，并省略了其他部分。因此，尽管你可能在HTTP消息中看到以MIME的Content-前缀开始的几个头部，但HTTP消息并不符合MIME规范。例如，尽管HTTP有一个Content-Encoding头部，但其使用方式与MIME的完全不同。HTTP不使用MIME消息中必需的MIME-Version头部，这证实了HTTP和MIME之间的差异。
- en: Tip
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Even though HTTP borrows several concepts and header types
    from MIME, the protocol is not MIME-compliant.'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 尽管HTTP从MIME中借鉴了几个概念和头部类型，但该协议并不符合MIME规范。'
- en: HTTP Content and Transfer Encodings
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP内容和传输编码
- en: Two specific issues that HTTP must address in order to carry a wide variety
    of media types in its messages are encoding the data and identifying its type
    and characteristics. HTTP borrows from MIME the notion of media types and the
    Content-Type header to handle type identification, as explained in the previous
    section. It similarly borrows concepts and headers from MIME to deal with the
    encoding issue. Here, however, we run into some of the important differences between
    HTTP and MIME.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 必须解决两个具体问题，以便在其消息中携带各种媒体类型：数据编码以及识别其类型和特征。HTTP 从 MIME 借用了媒体类型和 Content-Type
    报头的概念，如前所述，以处理类型识别。它还从 MIME 借用了概念和报头来处理编码问题。然而，在这里，我们遇到了 HTTP 和 MIME 之间的一些重要差异。
- en: 'Encoding was a significant issue for MIME, because it was created for the specific
    purpose of sending nontext data using the old RFC 822 email message standard (discussed
    in [Chapter 76](ch76.html "Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS
    AND MESSAGE PROCESSING: RFC 822 AND MIME")). RFC 822 imposes several significant
    restrictions on the messages it carries, the most important of which is that data
    must be encoded using 7-bit ASCII. RFC 822 messages are also limited to lines
    of no more than 1,000 characters that end in a carriage return/line feed (CRLF)
    sequence.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '对 MIME 而言，编码是一个重要的问题，因为它是为了特定的目的而创建的，即使用旧的 RFC 822 电子邮件消息标准（在第 76 章中讨论，[Chapter 76](ch76.html
    "Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC
    822 AND MIME")）发送非文本数据。RFC 822 对其携带的消息施加了几个重要的限制，其中最重要的是数据必须使用 7 位 ASCII 编码。RFC
    822 消息的行长度也限制在最多 1,000 个字符，并以回车/换行（CRLF）序列结束。'
- en: 'These limitations mean that arbitrary binary files, which have no concept of
    lines and consist of bytes that can each contain a value from 0 to 255, cannot
    be sent using RFC 822 in their native format. In order for MIME to transfer binary
    files, they must be encoded using a method such as base64 (described in [Chapter 76](ch76.html
    "Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC
    822 AND MIME")), which converts three 8-bit characters to a set of four 6-bit
    characters that can be represented in ASCII. When this sort of transformation
    is done, the MIME Content-Transfer-Encoding header is included in the message,
    so the recipient can reverse the encoding to return the data to its normal form.
    Although this technique works, it is less efficient than sending the data directly
    in binary, because base64 encoding increases the size of the message by 33 percent
    (three bytes are encoded using four ASCII characters, each of which takes one
    byte to transmit).'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '这些限制意味着任意二进制文件，它们没有行的概念，由可以包含从 0 到 255 的值的字节组成，不能以它们的原生格式使用 RFC 822 发送。为了使
    MIME 能够传输二进制文件，它们必须使用类似 base64（在第 76 章中描述，[Chapter 76](ch76.html "Chapter 76. TCP/IP
    ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME")）的方法进行编码，该方法将三个
    8 位字符转换为可以表示在 ASCII 中的四个 6 位字符集。当进行这种转换时，消息中会包含 MIME Content-Transfer-Encoding
    报头，以便接收者可以反转编码，将数据恢复到其正常形式。尽管这种技术可行，但它不如直接以二进制形式发送数据高效，因为 base64 编码将消息的大小增加了 33%（三个字节使用四个
    ASCII 字符进行编码，每个字符需要一字节来传输）。'
- en: HTTP messages are transmitted directly between the client and server over a
    Transmission Control Protocol (TCP) connection, and they do not use the RFC 822
    standard. Thus, binary data can be sent between HTTP clients and servers without
    the need for base64 encoding or other transformation techniques. Since it is more
    efficient to send the data unencoded, this may be one reason why HTTP's developers
    decided not to make the protocol strictly MIME-compliant.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 消息直接在客户端和服务器之间通过传输控制协议（TCP）连接传输，并且不使用 RFC 822 标准。因此，可以在 HTTP 客户端和服务器之间发送二进制数据，而无需进行
    base64 编码或其他转换技术。由于发送未编码的数据更高效，这可能是 HTTP 开发者决定不使协议严格遵循 MIME 标准的一个原因。
- en: HTTP's Two-Level Encoding Scheme
  id: totrans-576
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 的双层编码方案
- en: So, encoding would seem to be an area where HTTP is simpler than MIME. There
    is no need to encode the entity, and thus no need for the Content-Transfer-Encoding
    header, so we have one less thing to worry about. It is true that HTTP could have
    been designed so that all entities were just sent one byte at a time with no need
    to specify encodings, but the developers of the protocol recognized that this
    would have made the protocol inflexible. There are situations where it might be
    useful to transform or encode an entity or message for transmission, and then
    reverse the operation on receipt.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编码似乎是一个HTTP比MIME更简单的领域。不需要对实体进行编码，因此不需要“内容传输编码”标题，所以我们少了一件要担心的事情。确实，HTTP本可以设计成所有实体一次只发送一个字节，无需指定编码，但协议的开发者认识到这将使协议缺乏灵活性。有些情况下，可能需要转换或编码实体或消息以进行传输，然后在接收时反转操作。
- en: 'This effort to make HTTP flexible resulted in a system of representing encodings
    that is actually more complicated than MIME''s! The key to understanding it is
    to recognize that HTTP/1.1 actually splits MIME''s notion of content transfer
    encoding into two different encoding levels:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使HTTP灵活的努力导致了一个表示编码的系统，实际上比MIME的更复杂！理解它的关键是认识到HTTP/1.1实际上将MIME的内容传输编码概念分为两个不同的编码级别：
- en: '**Content Encoding** This encoding is applied specifically to the entity carried
    in an HTTP message, to prepare or package it prior to transmission. Content encodings
    are said to be *end-to-end,* because the encoding of the entity is done once before
    it sent by the client or server, and decoded only on receipt by the ultimate recipient:
    server or client. When this type of encoding is done, the method is identified
    in the special Content-Encoding entity header. A client may also specify which
    content encodings it can handle, using the Accept-Encoding header, as you will
    see in the section on content negotiation later in this chapter.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容编码** 这种编码专门应用于HTTP消息中携带的实体，以便在传输之前对其进行准备或打包。内容编码被称为**端到端**的，因为实体的编码在客户端或服务器发送之前只进行一次，并且仅在最终接收者（服务器或客户端）接收时解码。当进行此类编码时，方法将在特殊的“内容编码”实体标题中标识。客户端还可以通过使用“接受编码”标题来指定它可以处理的内容编码，正如你将在本章后面的内容协商部分中看到的。'
- en: '**Transfer Encoding** This encoding is done specifically for the purpose of
    ensuring that data can be safely transferred between devices. It is applied across
    an entire HTTP message and not specifically to the entity. This type of encoding
    is *hop-by-hop*, because a different transfer encoding may be used for each hop
    of a message that is transmitted through many intermediaries in the request/response
    chain. The transfer encoding method, if any, is indicated in the Transfer-Encoding
    general header.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输编码** 这种编码专门用于确保数据可以在设备之间安全传输。它应用于整个HTTP消息，而不是特定于实体。这种类型的编码是**逐跳**的，因为对于通过多个中间代理在请求/响应链中传输的消息的每一跳，可能使用不同的传输编码。如果有传输编码方法，它将在“传输编码”通用标题中指示。'
- en: Use of Content and Transfer Encodings
  id: totrans-581
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容和传输编码的使用
- en: Since the content and transfer encodings are applied at different levels, it
    is possible for both to be used at the same time. A content encoding may be applied
    to an entity and then placed into a message. On some or all of the hops that are
    used to move the message containing that entity, a transfer encoding may be applied
    to the entire message (including the entity). The transfer encoding is removed
    first, and then the content encoding is removed.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内容编码和传输编码在不同的级别上应用，因此它们可以同时使用。内容编码可以应用于实体，然后将其放入消息中。在用于移动包含该实体的消息的一些或所有跳中，可以对整个消息（包括实体）应用传输编码。首先移除传输编码，然后移除内容编码。
- en: So, what are these types of encodings used for in practice? The answer is not
    a great deal. The HTTP standard defines a small number of content and transfer
    encodings, and specifies that additional methods may be registered with the Internet
    Assigned Numbers Authority (IANA). Currently, only the ones defined in the HTTP/1.1
    standard are in use.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些编码类型在实际应用中是用来做什么的呢？答案是并不多。HTTP标准定义了少量内容编码和传输编码，并规定可以通过互联网数字分配机构（IANA）注册额外的编码方法。目前，只有HTTP/1.1标准中定义的编码正在使用。
- en: 'Content encodings are used only to implement compression. This is a good example
    of an encoding that, while not strictly necessary, can be useful since it improves
    performance dramatically for some types of data. RFC 2616 defines three different
    encoding algorithms:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 内容编码仅用于实现压缩。这是一个虽然不是严格必要的，但由于它可以显著提高某些类型数据的性能而可能很有用的编码示例。RFC 2616 定义了三种不同的编码算法：
- en: '`gzip`, which is the compression used by the UNIX `gzip` program, described
    in RFC 1952'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gzip`，这是由 RFC 1952 描述的 UNIX `gzip` 程序所使用的压缩方法'
- en: '`compress`, which also represents the compression method used by the UNIX program
    of that name'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compress`，它也代表了同名 UNIX 程序所使用的压缩方法'
- en: '`deflate`, which is a method defined in RFCs 1950 and 1951'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deflate`，这是在 RFC 1950 和 1951 中定义的方法'
- en: Note
  id: totrans-588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*It is also possible to apply compression to an entire HTTP message as a transfer
    encoding. Obviously, if the entity is already compressed using content encoding,
    this will result in some duplication of effort. Since the size of HTTP headers
    is not that large compared to some entities that HTTP messages carry, it is usually
    simpler just to compress the entity using content encoding*.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '*也可以将压缩应用于整个 HTTP 消息作为传输编码。显然，如果实体已经使用内容编码进行了压缩，这将导致一些工作重复。由于 HTTP 头的大小与 HTTP
    消息携带的一些实体相比并不大，通常只需使用内容编码压缩实体就足够简单了*。'
- en: 'Since transfer encodings are intended to be used to make data safe for transfer,
    and we''ve already discussed the fact that HTTP can handle arbitrary binary data,
    this suggests that transfer encodings are not really necessary. However, there
    is one situation where safe transport does become an issue: the matter of identifying
    the end of a message. This issue is the subject of the next section.'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传输编码旨在用于使数据安全传输，并且我们已经讨论了 HTTP 可以处理任意二进制数据的事实，这表明传输编码实际上并不是必需的。然而，有一种情况，安全传输确实成为一个问题：识别消息结束的问题。这个问题是下一节的主题。
- en: Tip
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** HTTP supports two levels of codings for data transfer. The
    first is *content encoding*, which is used in certain circumstances to transform
    the entity carried in an HTTP message. The second is *transfer encoding*, which
    is used to encode an entire HTTP message to ensure its safe transport. Content
    encodings are often employed when entities are compressed to improve communication
    efficiency. Transfer encoding is used primarily to deal with the problem of identifying
    the end of a message.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** HTTP 支持数据传输的两个编码级别。第一个是*内容编码*，在特定情况下用于转换 HTTP 消息中携带的实体。第二个是*传输编码*，用于对整个
    HTTP 消息进行编码以确保其安全传输。当实体被压缩以提高通信效率时，通常会使用内容编码。传输编码主要用于处理识别消息结束的问题。'
- en: HTTP Data Length Issues, Chunked Transfers, and Message Trailers
  id: totrans-593
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 数据长度问题、分块传输和消息尾迹
- en: 'As you''ve learned, two different levels of encodings are used in HTTP: *content
    encodings*, which are applied to HTTP entities, and *transfer encodings*, which
    are used over entire HTTP messages. Content encodings are used for convenience
    to package entities for transmission. Transfer encodings are hop-specific, and
    they are intended for use in situations where data needs to be made safe for transfer.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，HTTP 中使用了两种不同的编码级别：*内容编码*，它应用于 HTTP 实体，以及*传输编码*，它用于整个 HTTP 消息。内容编码用于方便地将实体打包以进行传输。传输编码是跳数特定的，并且旨在用于需要使数据安全传输的情况。
- en: 'However, we''ve already seen that HTTP can transport arbitrary binary data,
    so unlike the situation where MIME needed to make binary data safe (as defined
    in RFC 822), this is not an issue with HTTP. Therefore, why are transport encodings
    needed at all? In theory, they are not, and HTTP/1.0 did not even have a Transfer-Encoding
    header (though it did use content encodings). The concept of transfer encoding
    became important in HTTP/1.1 due to another key feature of that version of HTTP:
    persistent connections (described in [Chapter 80](ch80.html "Chapter 80. HTTP
    GENERAL OPERATION AND CONNECTIONS")).'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们已经看到 HTTP 可以传输任意二进制数据，因此与 MIME 需要使二进制数据安全（如 RFC 822 中定义的）的情况不同，这并不是 HTTP
    的问题。因此，为什么传输编码是必需的呢？从理论上讲，它们不是必需的，而且 HTTP/1.0 甚至没有传输编码头（尽管它确实使用了内容编码）。传输编码的概念在
    HTTP/1.1 中变得重要，这要归因于该版本 HTTP 的另一个关键特性：持久连接（在第 80 章[Chapter 80. HTTP GENERAL OPERATION
    AND CONNECTIONS]中描述）。
- en: Dynamic Data Length
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态数据长度
- en: Recall that HTTP uses TCP for connections. One of the key characteristics of
    TCP is that it transmits all data as a stream of unstructured bytes (see [Chapter 46](ch46.html
    "Chapter 46. TRANSMISSION CONTROL PROTOCOL (TCP) FUNDAMENTALS AND GENERAL OPERATION")).
    TCP itself does not provide any way of differentiating between the end of one
    piece of data and the start of the next; this is left up to each application.
    In HTTP/1.0 (and HTTP/0.9), this was not a problem, because those versions used
    only transitory connections. Each HTTP session consisted of only one request and
    one response. Since the client and server each sent only one piece of data, there
    was no need to worry about differentiating HTTP messages on a connection.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，HTTP使用TCP进行连接。TCP的一个关键特性是它将所有数据作为无结构的字节流传输（参见[第46章](ch46.html "第46章。传输控制协议（TCP）的基本原理和一般操作"））。TCP本身不提供区分一个数据块的结束和下一个数据块的开始的方法；这留给每个应用程序自行处理。在HTTP/1.0（和HTTP/0.9）中，这不是一个问题，因为那些版本只使用临时连接。每个HTTP会话只包含一个请求和一个响应。由于客户端和服务器各自只发送一块数据，因此没有必要担心在连接上区分HTTP消息。
- en: 'HTTP/1.1''s persistent connections improve performance by letting devices send
    requests and responses one after the other over a single TCP connection. However,
    the fact that messages are sent in sequence makes differentiating them a concern.
    There are two usual approaches to dealing with this sort of data length issue:
    using an explicit delimiter to mark the end of the message, or including a length
    header or field to tell the recipient how long each message is. The first approach
    could not really have been done easily while maintaining compatibility with older
    versions of the protocol. This left the second approach. Since HTTP already had
    a Content-Length entity header, the solution was to use this to indicate the length
    of each message at transmission time.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.1的持久连接通过允许设备在一个TCP连接上依次发送请求和响应来提高性能。然而，消息按顺序发送的事实使得区分它们成为一个问题。处理这种数据长度问题的两种常用方法：使用显式分隔符来标记消息的结束，或者包含长度头或字段来告知接收者每个消息的长度。第一种方法在保持与旧版本协议的兼容性时难以轻易实现。这留下了第二种方法。由于HTTP已经有了Content-Length实体头，因此解决方案是在传输时使用这个头来指示每个消息的长度。
- en: Using the Content-Length header works fine in cases where the size of the entity
    to be transferred is known in advance, such as when transmitting a text document,
    an image, or an executable program needs. However, there are many types of resources
    that are generated dynamically. In those cases, the total size of such a resource
    is not known until it has been completely processed.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 当事先知道要传输的实体大小时，使用Content-Length头信息效果很好，例如在传输文本文档、图像或可执行程序时。然而，有许多类型的资源是动态生成的。在这些情况下，直到资源完全处理完毕，其总大小才为人所知。
- en: While not typical in HTTP's early days, dynamic resources account for a large
    percentage of Web traffic today. Many web pages are often not static Hypertext
    Markup Language (HTML) files, but instead are created as output from scripts or
    programs based on user input; discussion forums are a good example. Even modern
    HTML files are often not static. They usually contain program elements such as
    *server-side includes (SSIs)* that cause code to be generated on the fly, so their
    exact size cannot be determined in advance.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在HTTP早期并不典型，但动态资源现在占网络流量的很大一部分。许多网页通常不是静态的超文本标记语言（HTML）文件，而是根据用户输入从脚本或程序创建的输出；论坛讨论是一个很好的例子。即使是现代的HTML文件也往往不是静态的。它们通常包含程序元素，如*服务器端包含（SSIs）*，这会导致代码即时生成，因此它们的精确大小无法预先确定。
- en: The problem of unknown message length could be resolved by buffering the entire
    resource before transmission. However, this would be wasteful of server memory
    and would delay the transmission of the entity unnecessarily, since no part could
    be sent until the entire entity was ready. Instead, a special transfer encoding
    method was developed to handle the particular problem of not knowing the length
    of a file. The method is called *chunking*.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输前缓冲整个资源可以解决未知消息长度的问题。然而，这样做会浪费服务器内存，并且不必要地延迟实体的传输，因为直到整个实体准备就绪，任何部分都无法发送。相反，开发了一种特殊的传输编码方法来处理不知道文件长度的问题。这种方法被称为*分块*。
- en: Chunked Transfers and Message Trailers
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分块传输和消息尾迹
- en: 'When the chunking technique is used, instead of sending an entity as a raw
    sequence of bytes, it is broken into, well, chunks. This allows HTTP to send a
    dynamically generated resource, such as output from a script, a piece at a time
    as the data becomes available from the software processing it. To indicate that
    this method has been used, the special header `Transfer-Encoding: chunked` is
    placed in the message. A special format is also used for the body of the HTTP
    message to delineate the chunks:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '当使用分块技术时，不是将实体作为一个原始的字节序列发送，而是将其分成，嗯，块。这允许HTTP将动态生成的资源，如脚本的输出，一次发送一部分，当从处理它的软件中获取数据时。为了指示已使用此方法，特殊头`Transfer-Encoding:
    chunked`被放置在消息中。HTTP消息的正文也使用特殊格式来界定块：'
- en: '| <*chunk-1-length*> |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| <*chunk-1-length*> |'
- en: '| <*chunk-1-data*> |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '| <*chunk-1-data*> |'
- en: '| <*chunk-2-length*> |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '| <*chunk-2-length*> |'
- en: '| <*chunk-2-data*> |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '| <*chunk-2-data*> |'
- en: '| … |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| … |'
- en: '| 0 |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '| 0 |'
- en: '| <*message-trailers*> |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '| <*message-trailers*> |'
- en: Basically, instead of putting the whole entity in the body and indicating its
    length in a Content-Length header, each chunk is placed in the body sequentially,
    each preceded by the length of the chunk. The length is specified in hexadecimal
    and represented using ASCII characters. All chunk lengths and chunk data are terminated
    with a CRLF sequence. The recipient knows it has received the last chunk when
    it sees a chunk length of zero.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，不是将整个实体放在正文中，并在内容长度头中指示其长度，而是将每个块按顺序放在正文中，每个块之前都标有块长度。长度以十六进制指定，并使用ASCII字符表示。所有块长度和块数据都以CRLF序列终止。当接收者看到块长度为零时，就知道已经接收到了最后一个块。
- en: Note
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*An HTTP/1.1 client can specify that it does not want to use persistent connections
    by including the* `Connection: close` *header in its request. In this case, the
    server does not have to use chunking in its response. Since the server will close
    the connection after the first response message, the client knows that everything
    it receives from the server is part of that response. However, some servers may
    use chunked transfers anyway, even in this situation*.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '*HTTP/1.1客户端可以通过在其请求中包含* `Connection: close` *头来指定它不想使用持久连接。在这种情况下，服务器不需要在其响应中使用分块。由于服务器将在第一个响应消息后关闭连接，客户端知道从服务器接收到的所有内容都是该响应的一部分。然而，一些服务器可能仍然使用分块传输，即使在这种情况下也是如此*。'
- en: 'When chunked transfer encoding is used, the sender of the message may also
    choose to specify one or more *message trailers*. These are the same as entity
    headers, describing the contents of the message body, but appear *after* the entity,
    rather than *before* it. Message trailers provide flexibility in the same way
    that chunking itself does: They allow a device to include an HTTP header that
    may contain information that was not available when the HTTP message transmission
    began. A good example would be an integrity check field calculated based on the
    byte values of the entire entity.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用分块传输编码时，消息的发送者还可以选择指定一个或多个*消息片段*。这些与实体头相同，描述消息体的内容，但出现在实体之后，而不是之前。消息片段提供与分块本身相同的灵活性：它们允许设备包含一个可能包含在HTTP消息传输开始时不可用的信息的HTTP头。一个很好的例子是基于整个实体的字节值计算出的完整性检查字段。
- en: Trailers are optional, and they will not always be needed. When they are used,
    they are processed just like regular entity headers. To give the recipient of
    a message a "heads up" that trailers have been used, the special Trailer header
    is included at the start of the message, which lists the names of each header
    that appears as a trailer.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 片段是可选的，并不总是需要。当使用片段时，它们就像常规实体头一样被处理。为了通知消息的接收者已经使用了片段，特殊片段头被包含在消息的开头，列出了作为片段出现的每个头的名称。
- en: Yes, I really did say that headers can actually be trailers, in which case,
    a header called Trailer lists each header that is actually a trailer. An example
    will help clarify matters somewhat. Suppose we have a server that contains a program
    that, when supplied with a filename, returns a simple HTML response that contains
    the size and last modification date of the file. This is obviously dynamic content,
    so the length of the response cannot be determined in advance. If the server were
    to buffer the entire output of this program (since it is small), it could construct
    a conventional HTTP response using the Content-Length header, as shown in the
    sample output of [Example 83-1](ch83s03.html#example_of_an_http_response_using_a_cont
    "Example 83-1. Example of an HTTP Response using a Content-Length header").
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我确实说过标题实际上可以是尾部，在这种情况下，一个名为 Trailer 的标题会列出每个实际上是尾部的标题。一个例子可以帮助澄清一些问题。假设我们有一个服务器，它包含一个程序，当提供文件名时，返回一个包含文件大小和最后修改日期的简单
    HTML 响应。这显然是动态内容，因此无法预先确定响应的长度。如果服务器要缓冲整个程序的输出（因为它很小），它可以使用 Content-Length 头构建一个传统的
    HTTP 响应，就像[示例 83-1](ch83s03.html#example_of_an_http_response_using_a_cont "示例
    83-1. 使用 Content-Length 头的 HTTP 响应示例")的样本输出所示。
- en: Example 83-1. Example of an HTTP Response using a Content-Length header
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 83-1. 使用 Content-Length 头的 HTTP 响应示例
- en: '[PRE20]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using chunking instead allows the server to send out parts of the response as
    soon as they become available from the program. The equivalent output of the example
    shown in [Example 83-1](ch83s03.html#example_of_an_http_response_using_a_cont
    "Example 83-1. Example of an HTTP Response using a Content-Length header") using
    chunked transfers is shown in [Example 83-2](ch83s03.html#example_of_an_http_response_using_chunke
    "Example 83-2. Example of an HTTP Response using chunked transfer encoding").
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分块传输而不是一次性发送整个响应，允许服务器在程序中部分响应可用时立即发送它们。使用分块传输的[示例 83-1](ch83s03.html#example_of_an_http_response_using_a_cont
    "示例 83-1. 使用 Content-Length 头的 HTTP 响应示例")的等效输出显示在[示例 83-2](ch83s03.html#example_of_an_http_response_using_chunke
    "示例 83-2. 使用分块传输编码的 HTTP 响应示例")中。
- en: Example 83-2. Example of an HTTP Response using chunked transfer encoding
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 83-2. 使用分块传输编码的 HTTP 响应示例
- en: '[PRE21]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In [Example 83-2](ch83s03.html#example_of_an_http_response_using_chunke "Example 83-2. Example
    of an HTTP Response using chunked transfer encoding"), notice that the Expires
    header is now a trailer, so it can be calculated based on the output of the program,
    and this is indicated by the Trailer: Expires header. Remember that the Content-Length
    header specifies the length as a decimal number while chunking specifies chunk
    lengths in hexadecimal; the chunks in this example are 41, 5, 35, 29, and 19 decimal
    bytes, respectively.'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '在[示例 83-2](ch83s03.html#example_of_an_http_response_using_chunke "示例 83-2.
    使用分块传输编码的 HTTP 响应示例")中，请注意，Expires 头现在是一个尾部，因此可以根据程序的输出进行计算，并且这由 Trailer: Expires
    头指示。记住，Content-Length 头指定长度为十进制数字，而分块传输指定分块长度为十六进制；本例中的分块长度分别为 41、5、35、29 和 19
    个十进制字节。'
- en: Tip
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Since HTTP/1.1 uses persistent connections that allow multiple
    requests and responses to be sent over a TCP connection, clients and servers need
    some way to identify where one message ends and the next begins. The easier solution
    is to use the Content-Length header to indicate the size of a message, but this
    works only when the length of a message can be determined in advance. For dynamic
    content or other cases where message length cannot be easily computed before sending
    the data, the special *chunked* transfer encoding can be used, where the message
    body is sent as a sequence of chunks, each preceded by the length of the chunk.
    When chunked transfer encoding is used, the sender of the message may move certain
    headers from the start of the message to the end, where they are known as *trailers*.
    Trailers are interpreted in the same way as normal headers by the recipient. The
    special Trailer header is used in such messages to tell the recipient to look
    for trailers after the body of the message.'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 由于 HTTP/1.1 使用持久连接，允许通过 TCP 连接发送多个请求和响应，因此客户端和服务器需要某种方式来识别一条消息的结束和下一条消息的开始。更简单的解决方案是使用
    Content-Length 头部来指示消息的大小，但这仅在可以预先确定消息长度的情况下有效。对于动态内容或其他在发送数据之前无法轻松计算消息长度的案例，可以使用特殊的
    *分块* 传输编码，其中消息体作为一系列块发送，每个块前面都带有块的大小。当使用分块传输编码时，消息发送者可以将某些头部从消息的开始移动到末尾，在那里它们被称为
    *尾部*。尾部被接收者以与正常头部相同的方式解释。特殊的 Trailer 头部用于此类消息，以告知接收者在消息体之后查找尾部。'
- en: HTTP Content Negotiation and Quality Values
  id: totrans-625
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 内容协商和质量值
- en: Many Internet resources have only one representation, meaning a single way in
    which they are stored or made available. In this situation, a client request to
    a server is an all-or-nothing proposition. The client may specify conditions under
    which it would like the server to send the resource, using the If- series of request
    headers described in the previous chapter. If the condition is met, the resource
    will be sent in the server's response in the one form in which it exists; if the
    condition is not met, no entity will be returned.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 许多互联网资源只有一个表示形式，意味着它们只以一种方式存储或提供。在这种情况下，客户端对服务器的请求是一个全有或全无的提议。客户端可以指定条件，在满足这些条件的情况下，它希望服务器发送资源，使用上一章中描述的
    If- 系列请求头部。如果条件得到满足，资源将以服务器存在的一种形式发送；如果条件未得到满足，则不会返回任何实体。
- en: 'Other resources, however, may have multiple representations. The most common
    example is a document that is available in multiple languages, or one that is
    stored using more than one character set. Similarly, a graphical image might exist
    in two different formats: a Tagged Image File Format (TIFF) file, for those who
    want maximum image quality despite the large size of TIFF images, and a more compact
    JPEG file, for those who need to see the image quickly and don''t care as much
    about its quality level.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其他资源可能有多个表示形式。最常见的一个例子是可用多种语言的文档，或者使用多个字符集存储的文档。同样，一个图形图像可能存在两种不同的格式：一个用于希望图像质量最大化但图像大小较大的
    Tagged Image File Format (TIFF) 文件，以及一个更紧凑的 JPEG 文件，用于那些需要快速查看图像且不太关心其质量级别的人。
- en: To provide flexibility in allowing clients to obtain the best version of resources
    that exist in multiple forms, HTTP/1.1 defines a set of features that are collectively
    called *content negotiation*.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供灵活性，允许客户端获取存在于多种形式的最佳资源版本，HTTP/1.1 定义了一系列功能，统称为 *内容协商*。
- en: Content Negotiation Techniques
  id: totrans-629
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容协商技术
- en: The HTTP/1.1 standard defines two basic methods by which this negotiation may
    be performed.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.1 标准定义了两种基本方法来执行这种协商。
- en: '**Server-Driven Negotiation** In this technique, the client includes headers
    in its request that provide guidance to the server about its desired representation
    for the resource. The server uses an algorithm that processes this information
    and provides the version of the resource that it feels best matches the client''s
    preferences.'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器驱动协商** 在这种技术中，客户端在其请求中包含头部信息，为服务器提供关于其期望的资源表示形式的指导。服务器使用一个算法处理这些信息，并提供与客户端偏好最匹配的资源版本。'
- en: '**Agent-Driven Negotiation** This method puts the client in charge of the negotiation
    process. It first sends a preliminary request for the resource to the server.
    If the resource is available in multiple forms, the server typically sends back
    a 300 (Multiple Choices) response, which contains a list of the various representations
    in which the resource is available. The client then sends a second request for
    the one that it prefers.'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理驱动协商** 这种方法将客户端置于协商过程的主导地位。它首先向服务器发送一个初步的资源请求。如果资源以多种形式可用，服务器通常会发送一个300（多种选择）响应，其中包含资源可用的各种表示形式列表。然后客户端发送第二个请求，以获取它偏好的那个。'
- en: To draw an analogy, suppose a co-worker offers to go out at lunchtime to pick
    up lunch for the two of you. He is going to a new restaurant, where neither of
    you have eaten before. You could provide him with some parameters regarding what
    you like to eat—"I like roast beef sandwiches, fish and chips, and pizza, but
    not chicken"—and then trust him to pick something you will like. Alternatively,
    he could go to the restaurant, call you on his cell phone, read the menu to you,
    and let you make a selection. This former approach is like server-driven negotiation;
    the latter is like agent-driven negotiation.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行类比，假设一个同事提出在午餐时间出去为你们两人买午餐。他将去一家你们都没有吃过的餐厅。你可以给他一些关于你喜好的参数——“我喜欢烤牛肉三明治、炸鱼薯条和披萨，但不吃鸡肉”——然后信任他为你挑选一些你会喜欢的。或者，他可以去餐厅，用手机给你打电话，读菜单给你听，让你做出选择。这种前一种方法类似于基于服务器的协商；后一种方法类似于基于代理的协商。
- en: This analogy not only points out the differences between the two methods, but
    it also highlights the key advantages and disadvantages of each. Trusting your
    co-worker with your lunch selection is simple and efficient, but not foolproof.
    It's possible that the restaurant may not have any of the items you specified,
    or that your friend may get you something containing another ingredient that you
    don't like but forgot to mention. Similarly, server-based negotiation is a best-guess
    process that does not guarantee that the client will receive the resource in the
    format it wants. This is exacerbated by the fact that there are only so many ways
    for the client to specify its preferences using a handful of request headers.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类比不仅指出了两种方法之间的区别，而且还突出了每种方法的关键优缺点。将午餐选择托付给你的同事既简单又高效，但并非万无一失。可能的情况是，餐厅没有你指定的任何菜品，或者你的朋友可能会给你一些含有你不喜欢但忘记提及的另一种成分的东西。同样，基于服务器的协商是一个最佳猜测的过程，并不能保证客户端将以它想要的格式接收到资源。这一点由于客户端只能通过有限的几种方式使用少量请求头来指定其偏好而加剧。
- en: Agent-based negotiation, on the other hand, allows the client to select exactly
    what it wants from the available choices, just as you can choose your favorite
    dish from the menu of the restaurant. The problem here is that it is inefficient,
    because two requests and responses are required for each resource access. (Would
    you really want to read a restaurant's menu over the phone to someone so he could
    choose his ideal dish?)
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，基于代理的协商允许客户端从可用的选项中选择它想要的，就像你可以从餐厅的菜单中选择你最喜欢的菜品一样。这里的问题是它效率不高，因为每个资源访问都需要两个请求和响应。（你真的愿意在电话里读餐厅的菜单给某人听，以便他可以选择他理想的菜品吗？）
- en: 'In practice, server-based negotiation is the type that is most commonly used
    today. The client specifies its preferences using a set of four request headers
    that indicate what it would prefer in the representation of the resource. The
    headers each represents one characteristic of a resource: Accept (media type),
    Accept-Charset (character set), Accept-Encoding (content encoding), and Accept-Language
    (resource language). Any or all of these may be included in the request. Each
    Accept- header contains a list of acceptable values that is appropriate to the
    characteristic that it specifies, separated by a comma. For example, the Accept
    header lists media types the client considers acceptable, and Accept-Language
    contains language tags.'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，基于服务器的协商是目前最常用的类型。客户端使用一组四个请求头来指定它对资源表示的偏好。每个头代表资源的一个特征：Accept（媒体类型）、Accept-Charset（字符集）、Accept-Encoding（内容编码）和Accept-Language（资源语言）。这些头中的任何一个或所有都可以包含在请求中。每个Accept头包含一个适当的值列表，这些值与它所指定的特征相匹配，并用逗号分隔。例如，Accept头列出了客户端认为可接受的媒体类型，而Accept-Language包含语言标签。
- en: 'For example, suppose you have a friend who is trilingual in English, French,
    and Spanish. She can read a particular document in any of these languages, so
    she might instruct her browser to include the following header in her requests:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个朋友，她懂英语、法语和西班牙语。她可以用这些语言中的任何一种阅读特定的文档，因此她可能指示她的浏览器在她的请求中包含以下头信息：
- en: '[PRE22]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** HTTP includes a feature called *content negotiation* that allows
    the selection of a particular variation of a resource that has more than one representation.
    There are two negotiation techniques: *server-driven*, where the client includes
    headers in its request that indicate what it wants and the server does its best
    to select the most appropriate variant, and *agent-driven*, where the server sends
    the client a list of the available resource alternatives and the client chooses
    one.'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** HTTP 包含一个名为 *内容协商* 的功能，允许选择具有多个表示形式的资源的一个特定变体。有两种协商技术：*服务器驱动*，其中客户端在其请求中包含表示其需求的头信息，服务器尽力选择最合适的变体，以及*代理驱动*，其中服务器向客户端发送可用资源替代品的列表，客户端选择其中一个。'
- en: Quality Values for Preference Weights
  id: totrans-641
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偏好权重质量值
- en: To improve the results of server-driven negotiation, HTTP allows the client
    to *weight* each of the items in such a list, to indicate which is preferred of
    the alternatives. The client specifies weights by adding a decimal *quality value*
    after each parameter using the syntax `q=`<*`value`*>, which represents the relative
    priority of that parameter relative to others. The highest priority is 1, and
    the lowest priority is 0\. The default if no value is indicated is 1\. A value
    of 0 means that the client will not accept documents with that characteristic.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高服务器驱动协商的结果，HTTP 允许客户端为列表中的每个项目分配权重，以表明对替代方案的偏好。客户端通过在每个参数后添加一个十进制 *质量值*
    来指定权重，使用语法 `q=`<*`value`*>，这表示该参数相对于其他参数的相对优先级。最高优先级是 1，最低优先级是 0。如果没有指定值，则默认为
    1。值为 0 表示客户端不会接受具有该特性的文档。
- en: 'For example, suppose your trilingual friend knows English, French, and Spanish,
    but her French is a bit rusty. Furthermore, she may need to share the document
    she is requesting with a friend of hers who knows only a little Spanish, so it
    would be best if she got the document in English. Finally, she knows there is
    a German version of the resource that she definitely does not want. This could
    be represented as follows:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你的三语朋友懂英语、法语和西班牙语，但她的法语有点生疏。此外，她可能需要与只知道一点西班牙语的她的一个朋友分享她请求的文档，因此最好她能收到英文版本的文档。最后，她知道有一个她肯定不想要的资源德语版本。这可以表示如下：
- en: '[PRE23]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Translated to English, this means, "I would prefer if you sent me the document
    in English. If not, Spanish is okay, or French if that is all you have, but definitely
    don't send it to me in German."
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译成英语，这意味着：“我更希望您用英语发送文档给我。如果不是，西班牙语也可以，或者如果您只有法语，那就法语吧，但绝对不要用德语发给我。”
- en: Incidentally, the name *quality value* is the one used in the HTTP standard,
    but it is really a poor choice of terminology (a point which, to be fair, is also
    mentioned in the standard). These values do not have anything to do with quality;
    for all we know, the German version of this document may be the original and the
    others could be lousy translations. The `q` values specify only the relative preference
    of the client making the request.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，*质量值* 这个名称是 HTTP 标准中使用的，但实际上这是一个不恰当的术语选择（公平地说，这一点在标准中也有提及）。这些值与质量无关；据我们所知，这份文档的德语版本可能是原始版本，而其他版本可能是糟糕的翻译。`q`
    值仅指定发出请求的客户端的相对偏好。
- en: 'Finally, the asterisk (*) wildcard can be used in the Accept family of headers
    to represent any value or everything else. This is often used to tell the server,
    "If you can''t find what I specifically asked for, then here are my preferences
    for the alternatives." Let''s take an example using the Accept header:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，星号 (*) 通配符可以在 Accept 头字段的家族中使用，以表示任何值或所有其他值。这通常用来告诉服务器：“如果您找不到我具体要求的内容，那么这里是我的替代品偏好。”让我们用一个
    Accept 头的例子来说明：
- en: '[PRE24]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This header represents the client saying, "My preference (`q=1`, the default
    since no `q` value is indicated) is an HTML text document. If not available, I
    would prefer some other type of text document. Failing that, you may send me any
    other type of document relevant to the requested resource."
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标题表示客户端表示：“我的首选是HTML文本文档（`q=1`，默认值，因为没有指定`q`值）。如果不可用，我更喜欢其他类型的文本文档。如果这些都不行，你可以发送与我请求的资源相关的任何其他类型的文档。”
- en: Tip
  id: totrans-650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Server-driven content negotiation is the type most often used
    in HTTP. A client sending a request can include up to four different headers that
    provide information about how the server should fill its request. These may include
    optional *quality* values that specify the client''s relative preference among
    a set of alternative resource characteristics such as media type, language, character
    set, and encoding.'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 服务器驱动的协商是HTTP中最常用的类型。发送请求的客户端可以包含最多四个不同的标题，这些标题提供了有关服务器如何填充其请求的信息。这些可能包括可选的**质量**值，这些值指定了客户端在一系列替代资源特征（如媒体类型、语言、字符集和编码）中的相对偏好。'
- en: Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES
  id: totrans-652
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第84章 HTTP功能、能力和问题
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The previous chapters covered the fundamental concepts and basic operation of
    the Hypertext Transfer Protocol (HTTP). Modern HTTP, however, goes beyond the
    simple mechanics by which HTTP requests and responses are exchanged. It includes
    a number of features and capabilities that extend the basic protocol to improve
    performance and meet the various needs of organizations using modern TCP/IP internetworks.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章涵盖了超文本传输协议（HTTP）的基本概念和基本操作。然而，现代HTTP不仅超越了HTTP请求和响应交换的简单机制，还包括了许多功能和能力，这些功能和能力扩展了基本协议，以提高性能并满足使用现代TCP/IP互联网的组织的需求。
- en: In this chapter, I complete my description of HTTP by discussing several important
    matters that are essential to the operation of the modern World Wide Web. I begin
    with an overview of HTTP caching, which is the single most important feature that
    promotes efficiency in web transactions. I discuss the different uses of proxies
    in HTTP and some of the issues associated with them. I briefly examine the issues
    related to security and privacy in HTTP and conclude with a discussion of the
    matter of state management and how it is implemented despite HTTP being an inherently
    stateless protocol.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我通过讨论几个对现代万维网操作至关重要的重要问题来完成对HTTP的描述。我首先概述了HTTP缓存，这是促进Web事务效率的最重要功能。我讨论了HTTP中代理的不同用途以及与之相关的一些问题。我简要检查了与HTTP中的安全和隐私相关的问题，并以讨论状态管理问题以及如何在本质上是无状态的HTTP协议中实现它作为结论。
- en: HTTP Caching Features and Issues
  id: totrans-656
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP缓存功能和问题
- en: The explosive growth of the Web was a marvel for its users but a nightmare for
    networking engineers. The biggest problem that the burgeoning Web created was
    an overloading of the internetworks over which it ran. Many of the features that
    were added to HTTP/1.1 were designed specifically to improve the efficiency of
    the protocol and reduce unnecessary bandwidth consumed by HTTP requests and responses.
    Arguably, the most important of these is a set of features designed to support
    *caching*.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网的爆炸性增长对用户来说是一个奇迹，但对网络工程师来说却是一场噩梦。互联网创建的最大问题是它运行的互联网的过载。添加到HTTP/1.1中的许多功能都是专门设计来提高协议效率并减少HTTP请求和响应消耗的不必要带宽的。可以说，其中最重要的是一系列旨在支持**缓存**的功能。
- en: 'The subject of caching comes up again and again in discussions of computers
    and networking, because of a phenomenon that is widely observed in these technologies:
    Whenever a user, hardware device, or software process requests a particular piece
    of data, there is a good chance it will ask for that same data again in the near
    future. Thus, by storing recently retrieved items in a cache, we can eliminate
    duplicated effort. This is the reason that caching plays an important role in
    the efficiency of protocols such as the Address Resolution Protocol (ARP) and
    the Domain Name System (DNS).'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存问题在计算机和网络讨论中反复出现，这是因为在这些技术中广泛观察到的现象：每当用户、硬件设备或软件进程请求特定数据时，有很大可能性在不久的将来会再次请求相同的数据。因此，通过在缓存中存储最近检索到的项目，我们可以消除重复的工作。这就是为什么缓存在诸如地址解析协议（ARP）和域名系统（DNS）等协议的效率中起着重要作用。
- en: Benefits of HTTP Caching
  id: totrans-659
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP缓存的益处
- en: Caching is important to HTTP because Web users tend to request the same documents
    over and over again. For example, in writing this section on HTTP, I made reference
    to RFC 2616 many, many times. Each time, I loaded it from a particular web server.
    Since the document never changes, it would have been more efficient to just load
    it from a local cache rather than needing to retrieve it from the distant web
    server each time.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存对于HTTP来说非常重要，因为网络用户往往会反复请求相同的文档。例如，在撰写关于HTTP的这一节时，我多次引用了RFC 2616。每次，我都会从特定的网络服务器上加载它。由于该文档从未改变，直接从本地缓存加载它将更加高效，而不是每次都需要从远程网络服务器检索它。
- en: However, caching is even more essential to HTTP than to most other protocols
    or technologies where it used. The reason is that web documents tend to be structured
    so that a request for one resource leads to a request for many others. Even if
    you load a number of *different* documents, they may each refer to common elements
    that do not change between your requests. Thus, caching can be of benefit in HTTP
    even if a user never asks for the same document twice, or if a single document
    changes over time so that caching the document itself would be of little value.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，缓存对于HTTP来说甚至比用于其他大多数协议或技术的缓存更为重要。原因是网络文档往往被组织成这样：对一个资源的请求会导致对许多其他资源的请求。即使你加载了多个*不同*的文档，它们也可能各自引用在请求之间不发生变化的共同元素。因此，即使在用户从未两次请求相同的文档，或者单个文档随时间变化而缓存文档本身价值不大的情况下，HTTP中的缓存也能带来好处。
- en: For example, suppose that each morning, you load CNN's website to see what is
    going on in the world. Obviously, the headlines will be different every day, so
    caching of the main CCN.com home page won't be of much value. However, many of
    the graphical elements on the page (CNN's logo, dividing bars, perhaps a "breaking
    news" graphic, and so on) will be the same every day, and these can be cached.
    Another example would be a set of discussion forums on a website. As you load
    different topics to read, each one is different, but they have common elements
    (such as icons and other images) that would be wasteful to need to retrieve over
    and over again.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你每天早上都会加载CNN的网站，看看世界上发生了什么。显然，每天的头条新闻都会不同，所以缓存CNN.com主页的价值不会很大。然而，页面上的许多图形元素（CNN的标志、分隔栏、可能是一个“突发新闻”图形等）每天都会相同，并且这些可以缓存。另一个例子是一个网站上的讨论论坛集。当你加载不同的主题来阅读时，每个主题都是不同的，但它们有共同元素（如图标和其他图像），如果需要反复检索，将会造成浪费。
- en: 'Caching in HTTP yields two main benefits:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP中的缓存带来两大主要好处：
- en: Reduced bandwidth use, by eliminating unneeded transfers of requests and responses
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过消除不必要的请求和响应传输，减少带宽使用
- en: Faster response time for the user loading a resource
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载资源时用户响应时间更快
- en: Consider that on many web pages today, the image files are much larger than
    the HTML page that references them. Caching these graphics will allow the entire
    page to load far more quickly. [Figure 84-1](ch84.html#impact_of_caching_on_the_http_requestres
    "Figure 84-1. Impact of caching on the HTTP request/response chain This diagram
    illustrates the impact of caching on the request/response chain of (see Figure 80-2
    in Chapter 80). In this example, intermediary 2 is able to satisfy the client's
    request from its cache. This short-circuits the communication chain after two
    transfers, which means the client gets its resource more quickly, and the HTTP
    server is spared the need to process the client's request.") illustrates how caching
    reduces bandwidth and speeds up resource retrieval by short-circuiting the request/response
    chain.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到如今许多网页上，图像文件的大小往往比引用它们的HTML页面要大得多。缓存这些图形将允许整个页面更快地加载。[图84-1](ch84.html#impact_of_caching_on_the_http_requestres
    "图84-1. 缓存对HTTP请求/响应链的影响 此图说明了缓存对请求/响应链的影响（参见第80章中的图80-2）。在这个例子中，中间件2能够从其缓存中满足客户端的请求。这绕过了两次传输后的通信链，这意味着客户端可以更快地获取其资源，HTTP服务器也无需处理客户端的请求。")
- en: '![Impact of caching on the HTTP request/response chain This diagram illustrates
    the impact of caching on the request/response chain of (see in ). In this example,
    intermediary 2 is able to satisfy the client''s request from its cache. This short-circuits
    the communication chain after two transfers, which means the client gets its resource
    more quickly, and the HTTP server is spared the need to process the client''s
    request.](httpatomoreillycomsourcenostarchimages288315.png.jpg)'
  id: totrans-667
  prefs: []
  type: TYPE_IMG
  zh: '![缓存对HTTP请求/响应链的影响 此图说明了缓存对请求/响应链的影响（见[图84-1](http://atomoreilly.com/source/nostarch/images/288315.png.jpg)）。在这个例子中，中间件2能够从其缓存中满足客户端的请求。这缩短了通信链在两次传输后的长度，这意味着客户端可以更快地获取其资源，并且HTTP服务器无需处理客户端的请求。](http://atomoreilly.com/source/nostarch/images/288315.png.jpg)'
- en: 'Figure 84-1. Impact of caching on the HTTP request/response chain This diagram
    illustrates the impact of caching on the request/response chain of (see [Figure 80-2](ch80s02.html#http_requestresponse_chain_using_interme
    "Figure 80-2. HTTP request/response chain using intermediaries Instead of being
    connected directly, an HTTP client and server may be linked using one or more
    intermediary devices such as proxies. In this example, two intermediaries are
    present. The HTTP Request message sent by the client will actually be transferred
    three times: from the client to the first intermediary, then to the second, and
    finally to the server. The HTTP Response message will be created once but transmitted
    three distinct times. The full set of devices participating in the message exchange
    is called the request/response chain.") in [Chapter 80](ch80.html "Chapter 80. HTTP
    GENERAL OPERATION AND CONNECTIONS")). In this example, intermediary 2 is able
    to satisfy the client''s request from its cache. This short-circuits the communication
    chain after two transfers, which means the client gets its resource more quickly,
    and the HTTP server is spared the need to process the client''s request.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 图84-1. 缓存对HTTP请求/响应链的影响 此图说明了缓存对请求/响应链的影响（见[图80-2](ch80s02.html#http_requestresponse_chain_using_interme
    "图80-2. 使用中间件的HTTP请求/响应链 HTTP客户端和服务器可能通过一个或多个中间设备（如代理）连接，而不是直接连接。在这个例子中，有两个中间件。客户端发送的HTTP请求消息实际上会被传输三次：从客户端到第一个中间件，然后到第二个，最后到服务器。HTTP响应消息只创建一次，但会传输三次。参与消息交换的完整设备集合称为请求/响应链。")
    [第80章](ch80.html "第80章. HTTP一般操作和连接"))。在这个例子中，中间件2能够从其缓存中满足客户端的请求。这缩短了通信链在两次传输后的长度，这意味着客户端可以更快地获取其资源，并且HTTP服务器无需处理客户端的请求。
- en: The obvious advantages of caching have made it a part of the Web since pretty
    much the beginning. However, it was not until HTTP/1.1 that the importance of
    caching was really recognized in the protocol itself, and many features were added
    to support it. Where the HTTP/1.0 standard makes passing mention of caching and
    some of the issues related to it, HTTP/1.1 devotes 26 full pages to caching (more
    than 20 percent of the main body of the document!).
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的明显优势使其从互联网的早期开始就成为了其中的一部分。然而，直到HTTP/1.1，缓存在协议本身中的重要性才真正得到认可，并且添加了许多功能来支持它。HTTP/1.0标准只是简单提及缓存及其相关问题，而HTTP/1.1则用26页的篇幅专门讨论缓存（占文档主体超过20%！）。
- en: Cache Locations
  id: totrans-670
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存位置
- en: 'HTTP caching can be implemented in a variety of places in the request/response
    chain. The choice of location involves the fundamental trade-off that always occurs
    in caching: proximity versus universality. Simply put, the closer the cache is
    to the requester of the information, the more savings that result when data is
    pulled from the cache, rather than being fetched from the source. However, the
    further the cache is from the requester (and thus closer to the source), the greater
    the number of devices that can benefit from the cache. Let''s see how this manifests
    itself in the three classes of devices where caches may be found: the web client,
    intermediary, and web server.'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP缓存可以在请求/响应链的多个位置实现。选择位置涉及到缓存中始终存在的根本权衡：邻近性与普遍性。简单来说，缓存越靠近信息请求者，从缓存中提取数据而不是从源获取时节省就越多。然而，缓存离请求者越远（因此越接近源），能够从缓存中受益的设备数量就越多。让我们看看这种影响如何在可能发现缓存的三个设备类别中体现出来：网络客户端、中间件和网络服务器。
- en: Caching on the Web Client
  id: totrans-672
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络客户端上的缓存
- en: The cache with which most Internet users are familiar is that found on the local
    client. It is usually built into the web browser software, and for this reason,
    it's called a *web browser cache*. This cache stores recent documents and files
    accessed by a particular user, so that they can be made quickly available if that
    user requests them again.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数互联网用户熟悉的缓存是本地客户端上的缓存。它通常内置在Web浏览器软件中，因此被称为*Web浏览器缓存*。这个缓存存储了特定用户最近访问的文档和文件，以便在用户再次请求时可以快速提供。
- en: Since the cache is in the user's own machine, a request for an item that the
    cache contains is filled instantly, resulting in no network transaction and instant
    gratification for the user. However, that user is the only one who can benefit
    from the cache, so it's sometimes called a *private cache*.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓存位于用户的机器上，因此请求缓存中包含的项目可以立即得到满足，从而避免了网络事务，并为用户提供即时的满足感。然而，只有该用户能够从缓存中受益，因此有时它被称为*私有缓存*。
- en: Caching on the Intermediary
  id: totrans-675
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间件上的缓存
- en: Devices such as proxy servers that reside between web clients and servers are
    also often equipped with a cache. If users want documents that are not in their
    local client cache, the intermediary may be able to provide it, as shown in [Figure 84-1](ch84.html#impact_of_caching_on_the_http_requestres
    "Figure 84-1. Impact of caching on the HTTP request/response chain This diagram
    illustrates the impact of caching on the request/response chain of (see Figure 80-2
    in Chapter 80). In this example, intermediary 2 is able to satisfy the client's
    request from its cache. This short-circuits the communication chain after two
    transfers, which means the client gets its resource more quickly, and the HTTP
    server is spared the need to process the client's request."). This is not as efficient
    as retrieving from the local cache, but far better than going back to the web
    server.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 位于Web客户端和服务器之间的设备，如代理服务器，也经常配备缓存。如果用户想要不在其本地客户端缓存中的文档，中间件可能能够提供它，如图[图84-1](ch84.html#impact_of_caching_on_the_http_requestres
    "图84-1. 缓存对HTTP请求/响应链的影响 此图说明了缓存对请求/响应链的影响（参见第80章中的图80-2）。在这个例子中，中间件2能够从其缓存中满足客户端的请求。这缩短了通信链在两次传输后的长度，这意味着客户端可以更快地获取其资源，并且HTTP服务器无需处理客户端的请求。")所示。这不如从本地缓存检索高效，但远比回到Web服务器要好。
- en: An advantage is that all devices using the intermediary can benefit from its
    cache, which may be termed a *public* or *shared cache*. This can be useful, because
    members of an organization often access similar documents. For example, in an
    organization developing a hardware product to be used on Apple computers, many
    different people might be accessing documents on Apple's website. With a shared
    cache, a request from User A would often result in items being cached that could
    be used by User B as well.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优点是，所有使用中间件的设备都可以从其缓存中受益，这种缓存可能被称为*公共*或*共享缓存*。这可能是有用的，因为组织成员经常访问类似的文档。例如，在一个为在苹果电脑上使用的硬件产品开发组织的例子中，许多人可能正在访问苹果网站上的文档。使用共享缓存，用户A的请求通常会缓存可以供用户B使用的项目。
- en: Caching on the Web Server
  id: totrans-678
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web服务器上的缓存
- en: Web servers themselves may also implement a cache. While it may seem a bit strange
    to have a server maintain a cache of its own documents, this can be of benefit
    in some circumstances. A resource might require a significant amount of server
    resources to create. For example, consider a web page that is generated using
    a complex database query. If this page is retrieved frequently by many clients,
    there can be a large benefit to creating it periodically and caching it, rather
    than generating it on the fly for each request.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器本身也可能实现缓存。虽然让服务器维护其自己的文档缓存看起来有些奇怪，但在某些情况下这可能是有益的。资源可能需要大量的服务器资源来创建。例如，考虑一个使用复杂数据库查询生成的网页。如果这个页面被许多客户端频繁检索，那么定期创建并缓存它，而不是为每个请求即时生成，可以带来很大的好处。
- en: Since the web server cache is the farthest from the users, this results in the
    least savings for a cache hit, as the client request and server response must
    still travel the full path over the network between the client and server. However,
    this distance from the client also means that all users of the server can benefit
    from the cache.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Web服务器缓存距离用户最远，因此缓存命中的节省最少，因为客户端请求和服务器响应仍然必须通过网络在客户端和服务器之间完整路径传输。然而，这个距离对于客户端来说也意味着服务器上的所有用户都可以从缓存中受益。
- en: Tip
  id: totrans-681
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The most important feature that improves the efficiency of
    operation of HTTP is *caching*—the storing of recently requested resources in
    a temporary area. If the same resource is then needed again a short time later,
    it can be retrieved from the cache rather than requiring a fresh request to the
    server, resulting in a savings of both time and bandwidth. Caching can be performed
    by web clients, web servers, and intermediaries. The closer the cache is to the
    user, the greater the efficiency benefits; the farther from the user, the greater
    the number of users who can benefit from the cache.'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 提高HTTP操作效率的最重要特性是*缓存*——将最近请求的资源存储在临时区域。如果稍后再次需要相同的资源，它可以从缓存中检索，而不是需要向服务器发出新的请求，从而节省时间和带宽。缓存可以由Web客户端、Web服务器和中间代理执行。缓存离用户越近，效率效益就越大；离用户越远，能从缓存中受益的用户数量就越多。'
- en: Cache Control
  id: totrans-683
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存控制
- en: 'Caching in clients and servers is controlled in the same manner as most other
    types of control are implemented in HTTP: through the use of special headers.
    The most important of these is the Cache-Control general header, which has a number
    of directives that allow the operation of caches to be managed. There are other
    important caching-related headers, including Expires and Vary. For a great deal
    of more specific information related to HTTP caching, see RFC 2616, section 13.'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端和服务器中，缓存的控制方式与HTTP中大多数其他类型的控制方式相同：通过使用特殊的首部。其中最重要的是Cache-Control通用首部，它包含多个指令，允许管理缓存的操作。还有其他一些重要的与缓存相关的首部，包括Expires和Vary。有关HTTP缓存的更多具体信息，请参阅RFC
    2616，第13节。
- en: Important Caching Issues
  id: totrans-685
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重要缓存问题
- en: 'While the performance advantages of caching are obvious, caching has one significant
    drawback: it complicates the operation of HTTP in a number of ways. The following
    are some of the more important issues that HTTP/1.1 clients, servers, and intermediaries
    need to address. This list is not exhaustive, but it gives you an idea of what
    is involved with caching in HTTP.'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然缓存的性能优势很明显，但缓存有一个显著的缺点：它在许多方面使HTTP的操作复杂化。以下是一些HTTP/1.1客户端、服务器和中间代理需要解决的问题。这个列表并不详尽，但它让你了解HTTP中缓存涉及的内容。
- en: '**Cache Aging and Staleness** When users retrieve a document directly from
    its original source on the server, they are assured of getting the current version
    of that resource. When caching is used, that is no longer the case. While many
    resources change infrequently, almost all will change at some point. For example,
    at CNN''s website, it is probable that the CNN logo won''t change very often,
    but it''s possible that the site may be redesigned periodically and the logo modified
    in some way, such as its size or color. For this reason, a device cannot keep
    items in an HTTP cache indefinitely. The longer an item is held in a cache—a process
    called *aging*—the more likely it is that the resource on the server has changed
    and the cache has become stale. To make matters even more complex, some resources
    become stale more quickly than others. As a result, much of the caching-related
    functionality of HTTP involves dealing with this matter of cache aging.'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存老化与过时** 当用户直接从服务器上的原始源检索文档时，他们可以确保获得该资源的当前版本。当使用缓存时，情况就不再是这样了。虽然许多资源变化不频繁，但几乎所有的资源都会在某个时候发生变化。例如，在CNN网站上，CNN标志不太可能经常改变，但网站可能会定期重新设计，标志可能会以某种方式修改，例如大小或颜色。因此，设备不能无限期地保留HTTP缓存中的项目。一个项目在缓存中保留的时间越长——这个过程称为*老化*——服务器上的资源发生变化并且缓存过时的可能性就越大。更复杂的是，一些资源比其他资源更快地过时。因此，HTTP中与缓存相关的许多功能都涉及处理这个问题，即缓存老化。'
- en: '**Cache Expiration and Validation** One of the ways that HTTP deals with the
    cache aging issue is through headers and logic that allow caches, clients, and
    servers to specify how long items should be cached before they expire and must
    be refreshed. A validation process allows a cache to check with a server at appropriate
    times to see if an item it has stored has been modified.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存过期与验证** HTTP处理缓存老化问题的一种方式是通过首部和逻辑，允许缓存、客户端和服务器指定项目在过期并需要刷新之前应该被缓存多长时间。验证过程允许缓存在不适当的时间与服务器检查，以查看它存储的项目是否已被修改。'
- en: '**Communication of Cache Status to the User** In most cases, the fact that
    an item has been retrieved from a cache rather than its source is transparent
    to users (though they may notice that the resource loads faster than expected).
    In certain cases, however, the user may need to be informed that a resource came
    from a cache and not its original source. This is especially true when a cached
    item may be stale; in which case, the client should warn the user that the information
    might be out-of-date.'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '**向用户传达缓存状态** 在大多数情况下，一个项目是从缓存而不是其源检索的事实对用户来说是透明的（尽管他们可能会注意到资源加载速度比预期快）。然而，在某些情况下，用户可能需要被告知资源来自缓存而不是原始源。特别是当缓存项可能已过时时，客户端应警告用户信息可能已过时。'
- en: '**Header Caching** Caching in HTTP is complicated by the fact that it can occur
    in multiple places, and some HTTP headers are treated differently than others.
    HTTP headers are divided into two general categories: *end-to-end headers* that
    are intended to accompany a resource all the way to its ultimate recipient, and
    *hop-by-hop headers* that are used only for a particular communication between
    two devices (by the client, server, or intermediary device). End-to-end headers
    must be stored with a cached resource. Hop-by-hop headers have meaning only for
    a particular transfer and are not cached.'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '**头部缓存** HTTP 中的缓存复杂化是由于它可以在多个地方发生，并且某些 HTTP 头部与其他头部处理方式不同。HTTP 头部分为两大类：*端到端头部*，这些头部旨在伴随资源一直到达其最终接收者，以及*跳到跳头部*，这些头部仅用于两个设备（客户端、服务器或中间设备）之间的特定通信。端到端头部必须与缓存资源一起存储。跳到跳头部只对特定的传输有意义，不会被缓存。'
- en: '**Impact of Resource Updates** Some HTTP methods (discussed in [Chapter 81](ch81.html
    "Chapter 81. HTTP MESSAGES, METHODS, AND STATUS CODES")) will automatically cause
    cache entries to become invalidated, because they inherently cause a change to
    the underlying resource. For example, if a user performs a PUT on a resource that
    was previously retrieved using GET, any cached copies of that resource should
    be automatically invalidated to prevent the old version from being supplied from
    the cache.'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源更新的影响** 一些 HTTP 方法（在第 81 章[Chapter 81](ch81.html "Chapter 81. HTTP MESSAGES,
    METHODS, AND STATUS CODES")中讨论）将自动使缓存条目失效，因为这些方法本质上会导致底层资源发生变化。例如，如果用户对一个之前使用
    GET 方法检索的资源执行 PUT 操作，那么该资源的任何缓存副本都应该自动失效，以防止从缓存中提供旧版本。'
- en: '**Privacy Concerns** In the case of shared caches (such as might exist in a
    proxy), there are potential privacy issues. In most cases, having User A''s cached
    resource be made available to User B is advantageous, but we must be careful not
    to cache any items that might be specific to User A, which User B should not see.'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐私问题** 在共享缓存（如代理中可能存在的情况）的情况下，存在潜在的隐私问题。在大多数情况下，让用户 A 的缓存资源对用户 B 可用是有利的，但我们必须小心不要缓存任何可能特定于用户
    A、而用户 B 不应该看到的项目。'
- en: HTTP Proxy Servers and Proxying
  id: totrans-693
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 代理服务器和代理
- en: In my overview of the HTTP operational model in [Chapter 80](ch80.html "Chapter 80. HTTP
    GENERAL OPERATION AND CONNECTIONS"), I described how HTTP was designed to support
    not just communication between a client and server, but also the inclusion of
    intermediaries that may sit in the communication path between them. One of the
    most important types of intermediary is a device called a *proxy server*, or more
    simply, just a *proxy*.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在我对第 80 章[Chapter 80](ch80.html "Chapter 80. HTTP GENERAL OPERATION AND CONNECTIONS")中
    HTTP 操作模型的概述中，我描述了 HTTP 是如何被设计来支持不仅客户端和服务器之间的通信，还包括可能位于他们之间通信路径上的中间件的。最重要的一种中间件是称为*代理服务器*的设备，或者更简单地说，就是*代理*。
- en: A proxy is a middleman that acts as both a client and a server. It accepts requests
    from a client as if it were a server, then forwards those requests (possibly modifying
    them) to the real server, which sees the proxy as a client. The server responds
    back to the proxy, which forwards the reply back to the client. Proxies can be
    either *transparent*, meaning that they do not modify requests and responses,
    or *nontransparent*, if they do modify messages in order to provide a particular
    service.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是一个充当客户端和服务器双重角色的中间人。它像服务器一样接受来自客户端的请求，然后将这些请求（可能对其进行修改）转发到真实服务器，服务器将代理视为客户端。服务器响应代理，代理再将回复转发回客户端。代理可以是*透明的*，这意味着它们不会修改请求和响应，或者*非透明的*，如果它们修改消息以提供特定服务。
- en: Note
  id: totrans-696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The term transparent proxy can also be used to refer to a proxy that is interposed
    automatically between a client and server—such as an organization-wide firewall—as
    opposed to one that a user manually configures*.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '*“透明代理”这个术语也可以用来指代自动插入在客户端和服务器之间——例如组织范围内的防火墙——的代理，而不是用户手动配置的代理*。'
- en: Benefits of Proxies
  id: totrans-698
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理的好处
- en: 'Since proxies have the ability to fully process all client requests and server
    responses, they can be extremely useful in a number of circumstances. They can
    be used to implement or enhance many important capabilities, such as the following:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代理能够完全处理所有客户端请求和服务器响应，它们在许多情况下都非常有用。它们可以用来实现或增强许多重要功能，例如以下内容：
- en: '**Security** Proxies can be set up to examine both outgoing requests and incoming
    responses, to address various security concerns. For example, filtering can be
    set up to prevent users from requesting objectionable content or to screen out
    harmful replies, such as files containing hidden viruses.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全性** 代理可以被配置为检查出站请求和入站响应，以解决各种安全问题。例如，可以设置过滤来防止用户请求令人反感的内容，或筛选出有害的回复，例如包含隐藏病毒的文件。'
- en: '**Caching** As you saw earlier, it can be advantageous to set up a shared cache
    that is implemented on an intermediary, so resources requested by one client can
    be made available to another. This can be done within a proxy server.'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存** 如您之前所见，在中介上设置共享缓存是有利的，这样请求的资源就可以提供给另一个客户端。这可以在代理服务器中完成。'
- en: '**Performance** In some circumstances, using a proxy server can significantly
    improve performance, particularly by reducing latency.'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能** 在某些情况下，使用代理服务器可以显著提高性能，尤其是通过减少延迟。'
- en: An excellent example of how a proxy server can improve performance is how proxying
    is used by my own satellite Internet connection. Due to the distance from the
    Earth to the satellite, it takes more than 500 milliseconds for a round-trip request/response
    cycle between my PC and my Internet server provider (ISP). If I loaded a web page
    containing images, I would need to wait 500+ milliseconds to get the HTML page,
    and then my browser would need to generate new requests for each graphical element,
    meaning another 500+ millisecond delay for each. Instead, my ISP has a proxy server
    to which I send my requests for web pages. The proxy server looks through the
    HTML of these pages and automatically requests any elements such as graphics for
    me. It then sends them straight back to my machine, thus drastically reducing
    the time required to display a full web page.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 代理服务器如何提高性能的一个很好的例子是，我的卫星互联网连接是如何使用代理的。由于地球到卫星的距离，我的PC和我的互联网服务提供商（ISP）之间的往返请求/响应周期需要超过500毫秒。如果我加载包含图像的网页，我需要等待500+毫秒才能获取HTML页面，然后我的浏览器需要为每个图形元素生成新的请求，这意味着每个图形元素又会有500+毫秒的延迟。相反，我的ISP有一个代理服务器，我将我的网页请求发送给它。代理服务器会查看这些页面的HTML，并自动为我请求任何元素，例如图形。然后，它将这些元素直接发送回我的机器，从而大大减少了显示完整网页所需的时间。
- en: Tip
  id: totrans-704
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** One of the most important types of intermediary devices in
    HTTP is a *proxy server*, which acts as a middleman between the client and server,
    handling both requests and responses. A proxy server may transport messages unchanged
    or may modify them to implement certain features and capabilities. Proxies are
    often used to increase the security and/or performance of Web access.'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** HTTP中最重要的一种中介设备是*代理服务器*，它充当客户端和服务器之间的中间人，处理请求和响应。代理服务器可能传输未更改的消息，也可能修改它们以实现某些功能和能力。代理通常用于提高Web访问的安全性和/或性能。'
- en: Comparing Proxies and Caches
  id: totrans-706
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较代理和缓存
- en: Proxying and caching are concepts that have a number of similarities, especially
    in terms of the impact that they have on basic HTTP operation. Like caching, proxying
    has become more important in recent years, and it also complicates HTTP in a number
    of ways. The HTTP/1.1 standard includes a number of specific features to support
    proxies, and it also addresses a number of concerns related to proxying.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 代理和缓存是具有许多相似性的概念，尤其是在它们对基本HTTP操作的影响方面。像缓存一样，代理在近年来变得更加重要，并且它也在许多方面使HTTP变得复杂。HTTP/1.1标准包括许多特定功能来支持代理，同时也解决了与代理相关的一些问题。
- en: The fact that both proxying and caching represent ways in which basic HTTP client/server
    communication is changed, combined with the ability of proxies to perform caching,
    sometimes leads people to think caches and proxies are the same, which is not
    true. A proxy is a separate element that resides in the HTTP request/response
    chain. Caches can be implemented within any device in that chain, including a
    proxy.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 代理和缓存都代表了基本HTTP客户端/服务器通信发生变化的方式，加上代理执行缓存的能力，有时会导致人们认为缓存和代理是相同的，这并不正确。代理是一个位于HTTP请求/响应链中的独立元素。缓存可以在该链中的任何设备中实现，包括代理。
- en: Another key way that caches and proxies differ is that caches are used automatically
    when they are enabled, but proxies are not. To use a proxy, client software must
    be told to use the proxy and supplied with its IP address or domain name. The
    client then sends all requests to the proxy, rather than to the actual server
    that the user specifies.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存和代理之间另一个关键的差异是，当启用时，缓存会自动使用，但代理不会。要使用代理，客户端软件必须被告知使用代理，并提供了其IP地址或域名。然后客户端将所有请求发送到代理，而不是用户指定的实际服务器。
- en: Note
  id: totrans-710
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Most of my explanations here have focused on hardware proxy servers, but proxies
    are also commonly implemented as software in a client device. A software proxy
    performs the same tasks of processing requests and responses. A software proxy
    is much cheaper to implement than a hardware proxy, but it cannot be shared by
    many devices*.'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '*我这里的许多解释都集中在硬件代理服务器上，但代理也通常在客户端设备中作为软件实现。软件代理执行处理请求和响应的相同任务。与硬件代理相比，软件代理的实现成本要低得多，但它不能被许多设备共享*。'
- en: Important Proxying Issues
  id: totrans-712
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重要代理问题
- en: As with caching, issues arise when proxies are used in HTTP. The following are
    some of the more important ones. (For much more information about proxying, refer
    to RFC 2616).
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 与缓存一样，当在HTTP中使用代理时，也会出现问题。以下是一些更重要的问题。（有关代理的更多信息，请参阅RFC 2616）。
- en: '**Capability Inconsistencies** Issues arise when a client and server don''t
    use the same version of HTTP or don''t support the same features. For example,
    some servers may not support all of the methods that a client may try to use.
    This becomes more complex when a proxy enters the picture. Of particular concern
    is the situation where a client and server may agree on a particular feature that
    the proxy does not. The proxy must make sure that it passes along headers or other
    elements that it may not comprehend.'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '**能力不一致问题** 当客户端和服务器不使用相同的HTTP版本或不支持相同的功能时，会出现问题。例如，一些服务器可能不支持客户端尝试使用的所有方法。当代理介入时，这个问题变得更加复杂。特别需要注意的是，客户端和服务器可能就某个代理不支持的功能达成一致。代理必须确保它传递了它可能不理解的头信息或其他元素。'
- en: '**Authentication Requirements** The use of proxy servers often introduces new
    authentication or security requirements. In addition to authenticating with an
    end server, the proxy may specify that the client needs to present separate authentication
    credentials to it as well. This is done using the HTTP Proxy-Authorization and
    Proxy-Authenticate headers, as discussed in the next section in this chapter.'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证要求** 使用代理服务器通常会引入新的认证或安全要求。除了对端服务器进行认证外，代理可能还指定客户端需要向它提供单独的认证凭据。这是通过HTTP
    Proxy-Authorization和Proxy-Authenticate头信息实现的，如本章下一节所述。'
- en: '**Caching Interaction** Not only do both caching and proxying both complicate
    HTTP, they can complicate each other. Many of the issues in handling caching—such
    as header caching, expiration, and validation—become more complex when proxies
    are involved. Some of the Cache-Control general header directives are specific
    to proxying. Another issue is that the use of proxying and caching together can
    lead to distortions in the apparent number of times that a web resource is accessed.
    This is important in situations where web pages are supported by advertising,
    based on the number of times the page is accessed. In some cases, special codes
    called *cache busters* are placed in URLs to force pages not to be stored in shared
    caches.'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存交互** 不仅缓存和代理都会使HTTP复杂化，它们还可以相互复杂化。在处理缓存时，许多问题（如头信息缓存、过期和验证）在涉及代理时变得更加复杂。一些Cache-Control通用头指令是针对代理的。另一个问题是，同时使用代理和缓存可能导致对Web资源访问次数的明显数量扭曲。在网页由广告支持的情况下，这些广告基于页面访问次数，这种情况尤为重要。在某些情况下，在URL中放置称为*缓存破坏者*的特殊代码，以强制页面不被存储在共享缓存中。'
- en: '**Encodings** Content encodings (discussed in [Chapter 83](ch83.html "Chapter 83. HTTP
    Entities, Transfers, Coding Methods, and Content Management")) are applied end-to-end
    and so should not be affected by proxies. Transfer encoding is done hop-by-hop,
    so a proxy may use different encodings in handling different transfers of a single
    request or response.'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码** 内容编码（在第 83 章讨论，[Chapter 83](ch83.html "Chapter 83. HTTP Entities, Transfers,
    Coding Methods, and Content Management"））是端到端应用的，因此不应受代理的影响。传输编码是跳过跳过进行的，因此代理可能在处理单个请求或响应的不同传输时使用不同的编码。'
- en: '**Tracing Proxy Handling** It is useful in some circumstances, especially when
    multiple proxies may be in the request/response chain, to be able to trace which
    proxies have processed a particular message. To this end, HTTP/1.1 requires that
    each proxy that handles a message identify itself in the Via header.'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '**跟踪代理处理** 在某些情况下很有用，尤其是在多个代理可能存在于请求/响应链中时，能够追踪哪些代理处理了特定的消息。为此，HTTP/1.1 要求处理消息的每个代理在
    Via 头中标识自己。'
- en: HTTP Security and Privacy
  id: totrans-719
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 安全和隐私
- en: Many TCP/IP protocols lack security measures, largely because they were developed
    when security wasn't a big concern. As the Internet has developed, security has
    become extremely important, however. In the case of the Web, the issue is even
    more important due to the significance of the changes that have occurred in the
    content of HTTP messages since the protocol was first developed.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 TCP/IP 协议缺乏安全措施，这主要是因为它们是在安全不是一个大问题的时候开发的。然而，随着互联网的发展，安全已经变得极其重要。在 Web 的情况下，由于自协议首次开发以来
    HTTP 消息内容发生的变化的重要性，这个问题甚至更加重要。
- en: HTTP has become the vehicle for transporting any and every kind of information,
    including a large amount of personal data. HTTP was initially designed to carry
    academic documents such as memos about research projects. Today, an HTTP message
    is more likely to carry someone's mortgage application, credit card number, or
    medical details. Thus, not only does HTTP have the usual security issues such
    as preventing unauthorized access, but it also needs to deal with privacy concerns.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 已经成为传输任何类型信息的工具，包括大量个人数据。HTTP 最初是为了携带学术文件而设计的，例如关于研究项目的备忘录。如今，HTTP 消息更有可能携带某人的抵押贷款申请、信用卡号码或医疗细节。因此，HTTP
    不仅存在防止未经授权访问等常见安全问题，还需要处理隐私问题。
- en: HTTP Authentication Methods
  id: totrans-722
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 认证方法
- en: 'The main HTTP/1.1 standard, RFC 2616, does not deal extensively with security
    matters. These are addressed in detail instead in the companion document, RFC
    2617, which explains the two methods of HTTP authentication:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的 HTTP/1.1 标准，RFC 2616，并没有广泛处理安全问题。这些问题在配套文档 RFC 2617 中有详细说明，该文档解释了 HTTP 认证的两种方法：
- en: '**Basic Authentication** This is a conventional user name/password type of
    authentication. When a client sends a request to a server that requires authentication
    to access a resource, the server sends a response to the client''s initial request
    that contains a WWW-Authenticate header. The client then sends a new request containing
    the Authorization header, which carries a base64-encoded user name and password
    combination. Basic authentication is not considered strong security because it
    sends credentials unencrypted, which means that they can be intercepted.'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本认证** 这是一种传统的用户名/密码类型的认证。当客户端向需要认证才能访问资源的服务器发送请求时，服务器向客户端的初始请求发送响应，其中包含一个
    WWW-Authenticate 头。然后客户端发送一个新的请求，其中包含一个 Authorization 头，该头携带一个 base64 编码的用户名和密码组合。基本认证被认为不是强安全，因为它以未加密的形式发送凭据，这意味着它们可以被拦截。'
- en: '**Digest Authentication** Digest authentication uses the same headers as basic
    authentication, but employs more sophisticated techniques, including encryption,
    that protect against a malicious person snooping credentials information. Digest
    authentication is not considered as strong as public key encryption, but it is
    a lot better than basic authentication. It''s also a lot more complicated. The
    full details of how it works are in RFC 2617.'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '**摘要认证** 摘要认证使用与基本认证相同的头信息，但采用了更复杂的技巧，包括加密，以保护恶意人员窃取凭据信息。摘要认证被认为不如公钥加密强大，但它比基本认证要好得多。它也更加复杂。它的工作原理的完整细节可以在
    RFC 2617 中找到。'
- en: Security and Privacy Concerns and Issues
  id: totrans-726
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全和隐私关注点及问题
- en: Both RFC 2616 and 2617 address some of the specific security concerns and threats
    that can potentially affect HTTP clients and servers. These include actions such
    as spoofing, counterfeit servers, replay attacks, and much more. One concern addressed
    is the potential for man-in-the-middle attacks, where an attacker interposes between
    the client and server. Since proxies are inherently middlemen, they represent
    a security concern in this area. The same authentication methods used for servers
    can also be applied to authentication with proxies. In this case, the Proxy-Authenticate
    and Proxy-Authorization headers are used instead of WWW-Authenticate and Authorization
    headers.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 2616和2617都解决了一些可能影响HTTP客户端和服务器的一些特定安全担忧和威胁。这些包括诸如欺骗、伪造服务器、重放攻击等等。其中解决的一个问题是中间人攻击的可能性，攻击者介于客户端和服务器之间。由于代理本质上就是中间人，因此它们在这个领域代表了安全担忧。用于服务器的相同认证方法也可以应用于代理认证。在这种情况下，使用Proxy-Authenticate和Proxy-Authorization头部代替WWW-Authenticate和Authorization头部。
- en: The HTTP standards also discuss a number of privacy issues. The following are
    particularly worthy of examining.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP标准还讨论了许多隐私问题。以下是一些特别值得检查的问题。
- en: '**Sensitive Information Handling** The HTTP protocol can carry any type of
    information, and it does not inherently protect the privacy of data in HTTP message
    entities. To ensure the privacy of sensitive information, other techniques must
    be used (as described in the next section).'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '**敏感信息处理** HTTP协议可以携带任何类型的信息，并且它本身并不保护HTTP消息实体中的数据隐私。为了确保敏感信息的隐私，必须使用其他技术（如下一节所述）。'
- en: '**Information in URLs** One issue that sometimes arises in HTTP is that poorly
    designed websites may inadvertently encode private information into URLs. These
    URLs may be recorded in web logs, where they could fall into the hands of people
    who could abuse them. An example of this is a website that submits a user name
    and password to a server by encoding them as parameters of a GET request such
    as this: `GET http://www.somesite.com/login?name=xxx&password=yyy`. The POST method
    should be used instead for this sort of functionality, because it transmits its
    data in the body of the message instead of putting it into the URL.'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '**URL中的信息** 在HTTP中有时会出现的一个问题是，设计不良的网站可能会无意中将私有信息编码到URL中。这些URL可能会被记录在网页日志中，可能落入那些可能滥用它们的人手中。一个例子是，一个网站通过将用户名和密码编码为GET请求的参数来提交给服务器，如下所示：`GET
    http://www.somesite.com/login?name=xxx&password=yyy`。对于这种功能，应该使用POST方法，因为它在消息体中传输数据，而不是将其放入URL中。'
- en: '**Information in Accept Headers** While this may seem strange at first, it
    is possible that private information about the user could be transmitted through
    the use of certain Accept headers used for content negotiation. For example, some
    users might not want others to know what languages they speak, so they may be
    concerned about who looks at the Accept-Language header.'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '**Accept头部中的信息** 虽然这乍一看可能有些奇怪，但通过使用某些用于内容协商的Accept头部，可能会传输有关用户的私有信息。例如，一些用户可能不希望其他人知道他们说什么语言，因此他们可能对查看Accept-Language头部的人表示担忧。'
- en: '**Information in Referer Headers** The Referer (yes, that''s how it''s spelled;
    see my note in [Chapter 82](ch82.html "Chapter 82. HTTP MESSAGE HEADERS")) request
    header is a double-edged sword. It can be very useful to those who operate websites
    because it lets them see the sources of links to their resources. At the same
    time, it can be abused by those who might employ it to study users'' Web-access
    patterns. There are also potential privacy issues that the HTTP standard raises.
    For example, a user might not want the name of a private document that references
    a public web page to be transmitted in a Referer header.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '**Referer头部中的信息** Referer（是的，拼写就是这样；参见我在[第82章](ch82.html "第82章. HTTP消息头部")中的注释）请求头部是一把双刃剑。对于运营网站的人来说，它非常有用，因为它让他们可以看到指向其资源的链接来源。同时，它也可能被那些可能利用它来研究用户网络访问模式的人滥用。HTTP标准也提出了潜在的隐私问题。例如，用户可能不希望引用公共网页的私有文档的名称通过Referer头部传输。'
- en: Methods for Ensuring Privacy in HTTP
  id: totrans-733
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保HTTP隐私的方法
- en: 'As mentioned earlier, HTTP does not include any mechanism to protect the privacy
    of transmitted documents or messages. There are two different methods by which
    this is normally accomplished:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，HTTP不包含任何保护传输文档或消息隐私的机制。通常有两种不同的方法来完成这项任务：
- en: '**Encryption** The simplest way is to encrypt the resource on the server and
    supply valid decryption keys only to authorized users. Even if the entire message
    is intercepted, the entity itself will still be secured. The level of protection
    here depends on the quality of the encryption.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密** 最简单的方法是在服务器上加密资源，并且只向授权用户提供有效的解密密钥。即使整个消息被截获，实体本身仍然会被保护。这里的保护水平取决于加密的质量。'
- en: '**Secure Sockets Layer (SSL)** Another more common method is to use a protocol
    designed specifically to ensure the privacy of HTTP transactions. The one often
    used today is called *Secure Sockets Layer (SSL)*. Servers employ SSL to protect
    sensitive resources, such as those associated with financial transactions. They
    are accessed by using the URL scheme *https* rather than *http* in a web browser
    that supports the protocol. SSL was originally developed by Netscape and is now
    widely used across the Web.'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全套接字层（SSL）** 另一种更常见的方法是使用专门设计来确保HTTP事务隐私的协议。今天经常使用的一种称为*安全套接字层（SSL）*。服务器使用SSL来保护敏感资源，例如与金融交易相关的资源。在支持该协议的网页浏览器中，它们通过使用URL方案*https*而不是*http*来访问。SSL最初由Netscape开发，现在在互联网上被广泛使用。'
- en: HTTP State Management Using Cookies
  id: totrans-737
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cookies进行HTTP状态管理
- en: Even though modern HTTP has a lot of capabilities and features, it is still,
    at its heart, a simple request/reply protocol. One of the unfortunate problems
    that results from this is that HTTP is entirely *stateless*. This means that each
    time a server receives a request from a client, it processes the request, sends
    a response, and then forgets about the request. The next request from the client
    is treated as independent of any previous ones.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现代HTTP有很多功能和特性，但它的核心仍然是一个简单的请求/回复协议。由此产生的一个不幸问题是HTTP是完全无状态的。这意味着每次服务器从客户端收到一个请求时，它都会处理该请求，发送一个响应，然后忘记该请求。来自客户端的下一个请求被视为与之前的请求无关。
- en: Note
  id: totrans-739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The persistent connection feature of HTTP/1.1 (described in [Chapter 80](ch80.html
    "Chapter 80. HTTP GENERAL OPERATION AND CONNECTIONS")) does not change the stateless
    nature of the protocol. Even though multiple requests and responses can be sent
    on a single Transmission Control Protocol (TCP) connection, they are still not
    treated as being related in any way*.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '*HTTP/1.1的持久连接功能（在第80章中描述，见[第80章](ch80.html "第80章。HTTP一般操作和连接")）并没有改变协议的无状态性质。尽管可以在单个传输控制协议（TCP）连接上发送多个请求和响应，但它们仍然不被视为以任何方式相关*。'
- en: So why is HTTP being stateless a problem? Isn't this what we would expect of
    a protocol designed to allow a client to quickly and efficiently retrieve resources
    from a server? Well, this is, yet again, another place where HTTP's behavior was
    well suited to its original intended uses but not to how the Web is used today.
    Sure, if all we want to do is to say, "Hey server, please give me that file over
    there," then the server doesn't need to care about whether or not it may have
    previously provided that client with any other files in the past. This is how
    HTTP was originally intended to be used.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么HTTP的无状态性会成为一个问题呢？这难道不是我们对于一个旨在允许客户端快速高效地从服务器检索资源的协议的期望吗？好吧，这又是HTTP的行为与其最初的设计用途非常契合，但并不适应今天网络使用方式的另一个例子。当然，如果我们只是想告诉服务器，“嘿，请给我那里的文件”，那么服务器不需要关心它是否以前已经向该客户端提供了其他文件。这就是HTTP最初被设计成这样使用的。
- en: Today, the Web is much more than a simple resource-retrieval protocol. If you
    go to an online store, you want to be able to select a number of items to put
    into a "shopping cart" and have the store's server remember them. You might also
    want to participate in a discussion forum, which requires you to provide a user
    name and password in order to post a message. Ideally, the server should let you
    log in once, and then remember who you are so you can post many messages, without
    needing to enter your login information each and every time. (I have used forums
    where the latter is required—it gets old very quickly, believe me.)
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，网络已经不仅仅是一个简单的资源检索协议。如果你去在线商店，你希望能够选择多个商品放入“购物车”，并且商店的服务器能够记住它们。你也可能想参与一个讨论论坛，这要求你提供用户名和密码才能发帖。理想情况下，服务器应该让你登录一次，然后记住你是谁，这样你就可以发很多帖子，而不需要每次都输入登录信息。（我使用过需要每次都输入登录信息的论坛——这很快就会变得很烦人，相信我。）
- en: For these and other interactive applications, the stateless nature of HTTP is
    a serious problem. The solution was the addition of a new technology called *state
    management*, which allows the state of a client session with a server to be maintained
    across a series of HTTP transactions. Initially developed by Netscape, this technique
    was later made a formal Internet standard in RFC 2109, later revised in RFC 2965,
    "HTTP State Management Mechanism." This feature is actually not part of HTTP;
    it is an optional element, but one that has been implemented in most web browsers
    due to its usefulness.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些和其他交互式应用，HTTP的无状态特性是一个严重的问题。解决方案是添加一种名为*状态管理*的新技术，它允许客户端与服务器之间的会话状态在一系列HTTP事务中保持。最初由网景开发，这项技术后来在RFC
    2109中正式成为互联网标准，后来在RFC 2965中进行了修订，“HTTP状态管理机制”。这个特性实际上不是HTTP的一部分；它是一个可选元素，但由于其有用性，大多数网络浏览器都实现了它。
- en: The idea behind state management is very simple. When a server implements a
    function that requires state to be maintained across a set of transactions, it
    sends a small amount of data called a *cookie* to the web client. The cookie contains
    important information relevant to the particular web application, such as a customer
    name, items in a shopping cart, or a user name and password. The client stores
    the information in the cookie, and then uses it in subsequent requests to the
    server that set the cookie. The server can then update the cookie based on the
    information in the new request and send it back to the client. In this manner,
    state information can be maintained indefinitely, allowing the client and server
    to have a memory that persists over a period of time.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理的理念非常简单。当服务器实现一个需要在一系列事务中维护状态的功能时，它会向网络客户端发送一小块数据，称为*饼干*。饼干包含与特定网络应用相关的关键信息，例如客户姓名、购物车中的商品，或用户名和密码。客户端将信息存储在饼干中，然后在随后的请求中将其用于设置饼干的服务器。然后，服务器可以根据新请求中的信息更新饼干，并将其发送回客户端。通过这种方式，状态信息可以无限期地保持，使客户端和服务器能够保持一段时间的记忆。
- en: Note
  id: totrans-745
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Cookie *may seem like an odd term, but it is used in a few contexts to refer
    to a small piece of significant data. Another example is found in the Boot Protocol
    (BOOTP) and Dynamic Host Configuration Protocol (DHCP) message format. Today,
    most knowledgeable web users would blink at you if you mentioned the "HTTP state
    management mechanism," but they usually know what cookies are*.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 饼干*可能听起来有些奇怪，但在某些上下文中，它被用来指代一小块重要的数据。另一个例子可以在引导协议（BOOTP）和动态主机配置协议（DHCP）的消息格式中找到。今天，如果你提到“HTTP状态管理机制”，大多数有知识的网络用户可能会对你皱眉，但他们通常知道什么是饼干*。
- en: Issues with Cookies
  id: totrans-747
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 饼干的問題
- en: Cookies sound like a great idea, right? Cookies are absolutely essential for
    many of the applications that make the Web the powerhouse it is today. Online
    shopping and discussion forums are just two of the many interactive applications
    that benefit from cookies. Most of the time, cookies are used for these sorts
    of useful and benign purposes. Unfortunately, some people have turned cookies
    to the "dark side" by finding ways to abuse them. There can even be potential
    problems with cookies when there is no nefarious intent. For this reason, cookies
    are rather controversial.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 饼干听起来是个不错的想法，对吧？饼干对于许多使网络成为今天这样强大动力的应用来说绝对是必不可少的。在线购物和讨论论坛只是从饼干中受益的众多交互式应用中的两个。大多数时候，饼干被用于这些有用且良性的目的。不幸的是，有些人通过找到滥用它们的方法，将饼干转向了“黑暗面”。即使没有恶意意图，饼干也可能存在潜在问题。因此，饼干相当有争议。
- en: 'Here are some of the issues with cookies:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于饼干的问题：
- en: '**Transmission of Sensitive Information** Suppose you use an online banking
    system. You log in to the server, which then stores your user name and password
    (which controls access to your account) in a cookie. If the application is not
    implemented carefully, the message containing that cookie could be intercepted,
    giving someone access to your account. Even if it is not intercepted, someone
    knowledgeable who gained access to your computer could retrieve the information
    from the file where cookies are stored.'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '**敏感信息的传输** 假设你使用在线银行系统。你登录到服务器，服务器随后将你的用户名和密码（控制对账户的访问）存储在饼干中。如果应用程序没有谨慎实现，包含该饼干的短信可能会被截获，从而让某人能够访问你的账户。即使没有被截获，一个有知识的、能够访问你的电脑的人也可能从存储饼干信息的文件中检索到信息。'
- en: '**Undesirable Use of Cookies** In theory, cookies should be a help to the user,
    not a hindrance. However, any server can set a cookie for any reason. In some
    cases, a server could set a cookie for the purpose of tracking the websites that
    a user visits, which some people consider a violation of their privacy. Since
    some web browsers do not inform the user when a cookie is being set, the user
    may not even be aware that this is happening.'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cookies的不当使用** 理论上，Cookies应该对用户有帮助，而不是阻碍。然而，任何服务器都可以出于任何原因设置Cookies。在某些情况下，服务器可能会设置Cookies以追踪用户访问的网站，这被一些人视为侵犯隐私。由于一些网络浏览器在设置Cookies时不会通知用户，用户甚至可能没有意识到这种情况正在发生。'
- en: '**Third-Party or Unintentional Cookies** While most people think of cookies
    as being set in the context of a resource they specifically request, a cookie
    may be set by any server to which a request is sent, whether the user realizes
    it or not. Suppose you send a request to [http://www.myfavoritesite.com/index.htm/](http://www.myfavoritesite.com/index.htm/),
    and that page contains a reference to a tiny image that is on the server [http://www.bigbrotherishere.com/](http://www.bigbrotherishere.com/).
    The second site can set a cookie on your machine even though you never intended
    to visit it. This is called a *third-party cookie*.'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '**第三方或非故意设置的Cookies** 当大多数人认为Cookies是在请求特定资源时设置的，但实际上，任何服务器都可以在用户发送请求时设置Cookies，无论用户是否意识到这一点。假设你向[http://www.myfavoritesite.com/index.htm/](http://www.myfavoritesite.com/index.htm/)发送了一个请求，并且该页面包含了一个位于服务器[http://www.bigbrotherishere.com/](http://www.bigbrotherishere.com/)上的小图像的引用。第二个网站可以在你的机器上设置一个Cookies，即使你从未打算访问它。这被称为*第三方Cookies*。'
- en: Tip
  id: totrans-753
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** HTTP is an inherently *stateless* protocol, because a server
    treats each request from a client independently, forgetting about all prior requests.
    This characteristic of HTTP is not an issue for most routine uses of the Web,
    but is a problem for interactive applications such as online shopping where the
    server needs to keep track of a user''s information over time. To support these
    applications, most HTTP implementations include an optional feature called *state
    management*. When enabled, a server sends to a client a small amount of information
    called a *cookie*, which is stored on the client machine. The data in the cookie
    is returned to the server with each subsequent request, allowing the server to
    update it and send it back to the client again. Cookies thus enable servers to
    remember user data between requests. However, they are controversial, because
    of certain potential privacy and security concerns related to their use.'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** HTTP是一个本质上*无状态*的协议，因为服务器独立地处理来自客户端的每个请求，忘记所有之前的请求。HTTP的这个特性对于大多数常规的Web使用来说不是问题，但对于需要服务器在一段时间内跟踪用户信息的交互式应用程序（如在线购物）来说是一个问题。为了支持这些应用程序，大多数HTTP实现包括一个可选功能，称为*状态管理*。当启用时，服务器向客户端发送一小块信息，称为*Cookies*，该信息存储在客户端机器上。Cookies中的数据在随后的每个请求中返回给服务器，允许服务器更新它并将其再次发送回客户端。因此，Cookies使服务器能够在请求之间记住用户数据。然而，由于与它们的使用相关的某些潜在的隐私和安全问题，它们是有争议的。'
- en: Managing Cookie Use
  id: totrans-755
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理Cookies的使用
- en: The RFCs describing the cookie state management technique deal extensively with
    these and other issues, but there is no clear-cut resolution to these concerns.
    Like most security and privacy matters, the most important determinant of how
    significant potential cookie abuse may be is your own personal comfort level.
    Millions of people browse the Web every day letting any and all sites set whatever
    cookies they want and never have a problem. Others consider cookies an offensive
    idea and disable all cookies, which eliminates the privacy concerns but can cause
    problems with useful applications like interactive websites. As usual, the best
    approach is usually something in the middle, where you choose when and how you
    will allow cookies to be set.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 描述Cookies状态管理技术的RFC详细讨论了这些问题以及其他问题，但并没有明确的解决方案。像大多数安全和隐私问题一样，潜在Cookies滥用的重要决定因素是您个人的舒适度。每天有成千上万的人浏览网络，允许任何网站设置他们想要的Cookies，并且从未遇到问题。其他人认为Cookies是一种侵犯性的想法，并禁用了所有Cookies，这消除了隐私问题，但可能会影响像交互式网站这样的有用应用程序。通常，最好的方法通常是折中方案，即您选择何时以及如何允许设置Cookies。
- en: The degree to which cookie control is possible depends greatly on the quality
    and feature set of your web client software. Many browsers do not provide a great
    deal of control in how and when cookies are set; others are much better in this
    regard. Some browsers allow cookies to be disabled, but come with them turned
    on by default. Since many people are not even aware of the issues associated with
    cookies, they do not realize when cookies are being sent. Most notable in this
    regard is the popular Microsoft Internet Explorer, which normally comes set by
    default to accept all cookies without complaint or even comment.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: cookie控制的程度在很大程度上取决于您的网络客户端软件的质量和功能集。许多浏览器在如何和何时设置cookies方面提供的控制能力有限；而其他浏览器在这方面则要好得多。一些浏览器允许禁用cookies，但默认情况下它们是开启的。由于许多人甚至没有意识到与cookies相关的问题，他们没有意识到cookies正在被发送。在这方面最值得注意的是流行的Microsoft
    Internet Explorer，它通常默认设置为接受所有cookies，没有任何抱怨或评论。
- en: Internet Explorer does allow you to disable cookies, but you must do it yourself.
    It also allows you to differentiate between first-party and third-party cookies,
    but again, you must turn on this feature. Other browsers have more sophisticated
    settings, which will let you dictate conditions under which cookies may be set
    and others when they may not. Some browser will even let you allow certain websites
    to send cookies while prohibiting them from others. Better browsers will also
    let you visually inspect cookies, and selectively clear the ones you do not want
    on your machine.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: Internet Explorer允许您禁用cookies，但您必须自己操作。它还允许您区分第一方和第三方cookies，但同样，您必须手动开启这个功能。其他浏览器有更复杂的设置，这可以让您规定cookies可以设置的条件和不可以设置的条件。一些浏览器甚至允许您允许某些网站发送cookies，同时禁止其他网站发送。更好的浏览器还会让您能够直观地检查cookies，并选择性地清除您不希望在您的机器上的cookies。
- en: Third-party cookies can be used by online advertising companies and others to
    track the sites that a Web user visits. For this reason, they are considered by
    many people to fall into the general category of undesirable software called *spyware*.
    There are numerous tools that will allow you to identify and remove tracking cookies
    from your computer; many are available free on the Web.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方cookies可以被在线广告公司和其他公司用来追踪网络用户访问的网站。因此，许多人认为它们属于一类不希望使用的软件，即所谓的*间谍软件*。有许多工具可以帮助您识别和从您的计算机中删除跟踪cookies；许多工具在网络上都是免费提供的。
