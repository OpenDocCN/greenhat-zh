<html><head></head><body><div class="part" title="Part&#xA0;III.&#xA0;A Glimpse of Things to Come"><div class="titlepage"><div><div><h1 class="title"><a id="a_glimpse_of_things_to_come"/>Part III. A Glimpse of Things to Come</h1></div></div></div><div class="partintro" id="id2724343" title="A Glimpse of Things to Come"><div/><p>Following nearly a decade of stagnation, the world of browsers is once more a raging battlefield. In a manner all too reminiscent of the First Browser Wars in the late 1990s, vendors compete by bringing new features to market monthly. The main difference is that security is now seen as a clear selling point.<a class="indexterm" id="IDX-CHP-15-0044"/><a class="indexterm" id="IDX-CHP-15-0045"/><a class="indexterm" id="IDX-CHP-15-0046"/></p><p>Of course, objectively measuring the robustness of any sufficiently complex piece of software is an unsolved problem in computing, doubly so if your codebase happens to carry almost two decades worth of bloat. Therefore, much of the competitive effort goes into inventing and then rapidly deploying new security-themed additions, often with little consideration for how well they actually solve the problem they were supposed to address.</p><p>In the meantime, standards bodies, mindful of their earlier misadventures, have ditched much of their academic rigor in favor of just letting a dedicated group of contributors tweak the specifications as they see fit. There is talk of making HTML5 the last numbered version of the standard and transitioning to a living document that changes every day—often radically. The relaxation of the requirement has helped keep ongoing much of the work around W3C and WHATWG, but it has also undermined some of the benefits of having a central organization to begin with. Many recent proposals gravitate toward quick, narrowly scoped hacks that do not even try to form a consistent and well-integrated framework. When this happens, no robust feedback mechanism is in place to allow external experts to review reasonably stable specifications and voice concerns before any implementation work takes place. The only way to stay on top of the changes is to immerse oneself in the day-to-day dynamics of the working group.</p><p>It is difficult to say if this new approach to standardization is a bad thing. In fact, its benefits may easily outweigh any of the speculative risks; for one, we now have a chance at a standard that is reasonably close to what browsers actually do. Nevertheless, the results of this frantic and largely unsupervised process can be unpredictable, and they require the security community to be very alert.</p><p>In this spirit, the last part of the book will explore some of the more plausible and advanced proposals that may shape the future of the Web . . . or that may just as likely end up in the dustbin of history a few years from now.</p></div></div>
<div class="chapter" title="Chapter&#xA0;16.&#xA0;New and Upcoming Security Features"><div class="titlepage"><div><div><h1 class="title"><a id="new_and_upcoming_security_features"/>Chapter 16. New and Upcoming Security Features</h1></div></div></div><p>You will soon find out that there is little rhyme and reason to how all the new browser features mesh, but we still need to organize the discussion in some way. Perhaps the best approach is to look at their intended purposes and begin with all the mechanisms created specifically to tweak the Web’s security model for a well-defined gain.<a class="indexterm" id="IDX-CHP-16-0001"/></p><p>The dream of inventing a brand-new browser security model is strong within the community, but it is always followed by the realization that it would require rebuilding the entire Web. Therefore, much of the practical work focuses on more humble extensions to the existing approach, necessarily increasing the complexity of the security-critical sections of the browser codebase. This complexity is unwelcome, but its proponents invariably see it as justified, whether because they aim to mitigate a class of vulnerabilities, build a stopgap for some other hard problem that nobody wants to tackle right now,<sup>[<a class="footnote" href="#ftn.CHP-16-FN-1" id="CHP-16-FN-1">77</a>]</sup> or simply enable new types of applications to be built in the future. All these benefits usually trump the vague risk.<a class="indexterm" id="IDX-CHP-16-0002"/><a class="indexterm" id="IDX-CHP-16-0003"/><a class="indexterm" id="IDX-CHP-16-0004"/><a class="indexterm" id="IDX-CHP-16-0005"/><a class="indexterm" id="IDX-CHP-16-0006"/><a class="indexterm" id="IDX-CHP-16-0007"/><a class="indexterm" id="IDX-CHP-16-0008"/><a class="indexterm" id="IDX-CHP-16-0009"/></p><div class="sect1" title="Security Model Extension Frameworks"><div class="titlepage"><div><div><h1 class="title"><a id="security_model_extension_frameworks"/>Security Model Extension Frameworks</h1></div></div></div><p>Some of the most successful security enhancements proposed in the past few years boil down to adding flexibility to the original constraints imposed by the same-origin policy and its friends. For example, one formerly experimental proposal that has now crossed into the mainstream is the <span class="emphasis"><em>postMessage(...)</em></span> API for communicating across origins, discussed in <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a>. Surprisingly, the act of relaxing SOP checks in certain carefully chosen scenarios is more intuitive and less likely to cause problems than locking the policy down. So, to begin on a lighter note, we’ll focus on this class of frameworks first.</p><div class="sect2" title="Cross-Domain Requests"><div class="titlepage"><div><div><h2 class="title"><a id="cross-domain_requests"/>Cross-Domain Requests</h2></div></div></div><p>Under the original constraints of the same-origin policy, scripts associated with one origin have no clean and secure way to communicate with client-side scripts executing in any other origin and no safe way to retrieve potentially useful data from a willing third-party server.</p><p>Web developers have long complained about these constraints, and in recent years, browser vendors have begun to listen to their demands. As you recall, the more pressing task of arranging client-side communications between scripts was solved with <span class="emphasis"><em>postMessage(...)</em></span>. The client-to-server scenario was found to be less urgent and still awaits a canonical solution, but there has been some progress to report.</p><p>The most successful attempt to create a method for retrieving documents from non-same-origin servers began in 2005. Under the auspices of W3C, several developers working on VoiceXML, an obscure document format for building Interactive Voice Response (IVR) systems, drafted a proposal for <span class="emphasis"><em>Cross-Origin Resource Sharing (CORS)</em></span>.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-1">240</a>]</sup> Between 2007 and 2009, their awkward, XML-based design gradually morphed into a much simpler and more widely useful scheme, which relied on HTTP header-level signaling to communicate consent to cross-origin content retrieval using a natural extension of the <span class="emphasis"><em>XMLHttpRequest</em></span> API.<a class="indexterm" id="IDX-CHP-16-0010"/><a class="indexterm" id="IDX-CHP-16-0011"/><a class="indexterm" id="IDX-CHP-16-0012"/></p><div class="sect3" title="CORS Request Types"><div class="titlepage"><div><div><h3 class="title"><a id="cors_request_types"/>CORS Request Types</h3></div></div></div><p>As specified today, CORS relies on differentiating between two types of calls to the <span class="emphasis"><em>XMLHttpRequest</em></span> API. When the site attempts to load a cross-origin document through the API, the browser first needs to distinguish between <span class="emphasis"><em>simple requests</em></span>, where the resulting HTTP traffic is deemed close enough to what can be generated through other, existing methods of navigation, and <span class="emphasis"><em>non-simple requests</em></span>, which encompass everything else. The operation of these two classes of requests vary significantly, as we’ll see.<a class="indexterm" id="IDX-CHP-16-0013"/><a class="indexterm" id="IDX-CHP-16-0014"/><a class="indexterm" id="IDX-CHP-16-0015"/><a class="indexterm" id="IDX-CHP-16-0016"/></p><p>The current specification says that simple requests must have a method of GET, POST, or HEAD. Additionally, if any custom headers are specified by the caller, they must belong to the following set:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Cache-Control</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>Content-Language</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>Content-Type</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>Expires</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>Last-Modified</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>Pragma</em></span></p></li></ul></div><p>Today, browsers that support CORS simply do not allow methods other than GET, POST, and HEAD. At the same time, they ignore the recommended whitelist of headers, unconditionally demoting any requests with custom header values to non-simple status. The implementation in WebKit also considers any payload-bearing requests to be non-simple. (It is not clear whether this is an intentional design decision or a bug.)</p></div><div class="sect3" title="Security Checks for Simple Requests"><div class="titlepage"><div><div><h3 class="title"><a id="security_checks_for_simple_requests"/>Security Checks for Simple Requests</h3></div></div></div><p>The CORS specification allows simple requests to be submitted to the destination server immediately, without attempting to confirm whether the destination is willing to engage in cross-domain communications to begin with. This decision is based on the fact that the attacker may initiate fairly similar cookie-authenticated traffic by other means (for example, by automatically submitting a form) and, therefore, that there is no point in introducing an additional handshake specifically for CORS.<sup>[<a class="footnote" href="#ftn.CHP-16-FN-2" id="CHP-16-FN-2">78</a>]</sup></p><p>The crucial security check is carried out only after the response is retrieved from the server: The data is revealed to the caller through the <span class="emphasis"><em>XMLHttpRequest</em></span> API only if the response includes a suitable, well-formed <span class="emphasis"><em>Access-Control-Allow-Origin</em></span> header. To assist the server, the original request will include a mandatory <span class="emphasis"><em>Origin</em></span> header, specifying the origin associated with the calling script.</p><p>To illustrate this behavior, consider the following cross-domain <span class="emphasis"><em>XMLHttpRequest</em></span> call performed from <a class="ulink" href="http://www.bunnyoutlet.com/">http://www.bunnyoutlet.com/</a>:</p><a id="I_programlisting1_d1e17802"/><pre class="programlisting">var x = XMLHttpRequest();
x.open('GET', 'http://fuzzybunnies.com/get_message.php?id=42', false);
x.send(null);</pre><p>The result will be an HTTP request that looks roughly like this:<a class="indexterm" id="IDX-CHP-16-0017"/></p><a id="I_programlisting1_d1e17811"/><pre class="programlisting">GET /get_message.php?id=42 HTTP/1.0
Host: fuzzybunnies.com
Cookie: FUZZYBUNNIES_SESSION_ID=EA7E8167CE8B6AD93D43AC5AA869A920
<strong class="userinput"><code>Origin: http://www.bunnyoutlet.com</code></strong></pre><p>To indicate that the response should be readable across domains, the server needs to respond with</p><a id="I_programlisting1_d1e17817"/><pre class="programlisting">HTTP/1.0 200 OK
Access-Control-Allow-Origin: <strong class="userinput"><code>http://www.bunnyoutlet.com</code></strong>

The secret message is: "It's a cold day for pontooning."</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>It is possible to use a wildcard (“*”) in <span class="emphasis"><em>Access-Control-Allow-Origin</em></span>, but do so with care. It is certainly unwise to indiscriminately set <span class="emphasis"><em>Access-Control-Allow-Origin: *</em></span> on all HTTP responses, because this step largely eliminates any assurances of the same-origin policy in CORS-compliant browsers.</p></div></div><div class="sect3" title="Non-simple Requests and Preflight"><div class="titlepage"><div><div><h3 class="title"><a id="non-simple_requests_and_preflight"/>Non-simple Requests and Preflight</h3></div></div></div><p>In the early drafts of the CORS protocol, almost all requests were meant to be submitted without first checking to see if the server was actually willing to accept them. Unfortunately, this design undermined an interesting property leveraged by some web applications to prevent cross-site request forgery: Prior to CORS, attackers could not inject arbitrary HTTP headers into cross-domain requests, so the presence of a custom header often served as a proof that the request came from the same origin as the destination and was issued through <span class="emphasis"><em>XMLHttpRequest</em></span>.</p><p>Later CORS revisions corrected this problem by requiring a more complicated two-step handshake for requests that did not meet the strict “simple request” criteria outlined in <a class="xref" href="ch16.html#cors_request_types" title="CORS Request Types">CORS Request Types</a> in <a class="xref" href="ch16.html#security_model_extension_frameworks" title="Security Model Extension Frameworks">Security Model Extension Frameworks</a>. The handshake for non-simple requests aims to confirm that the destination server is CORS compliant and that it wants to receive nonstandard traffic from that particular caller. The handshake is implemented by sending a vanilla OPTIONS request (“preflight”) to the target URL containing an outline of the parameters of the underlying <span class="emphasis"><em>XMLHttpRequest</em></span> call. The most important information is conveyed to the server in three self-explanatory headers: <span class="emphasis"><em>Origin</em></span>, <span class="emphasis"><em>Access-Control-Request-Method</em></span>, and <span class="emphasis"><em>Access-Control-Request-Headers</em></span>.</p><p>This handshake is considered successful only if these parameters are properly acknowledged in the response through the use of <span class="emphasis"><em>Access-Control-Allow-Origin</em></span>, <span class="emphasis"><em>Access-Control-Allow-Method</em></span>, and <span class="emphasis"><em>Access-Control-Allow-Headers</em></span>. Following a correct handshake, the actual request is made. For performance reasons, the result of the preflight check for a particular URL may be cached by the client for a set period of time.</p></div><div class="sect3" title="Current Status of CORS"><div class="titlepage"><div><div><h3 class="title"><a id="current_status_of_cors"/>Current Status of CORS</h3></div></div></div><p>As of this writing, CORS is available only in Firefox and WebKit-based browsers and is notably absent in Opera or Internet Explorer. The most important factor hindering its adoption may be simply that the API is not as critical as <span class="emphasis"><em>postMessage(...)</em></span>, its client-side counterpart, because it can be often replaced by a content-fetching proxy on the server side. But the scheme is also facing three principal, if weak, criticisms, some of which come directly from one of the vendors. Obviously, these criticisms don’t help matters.<a class="indexterm" id="IDX-CHP-16-0018"/><a class="indexterm" id="IDX-CHP-16-0019"/><a class="indexterm" id="IDX-CHP-16-0020"/><a class="indexterm" id="IDX-CHP-16-0021"/><a class="indexterm" id="IDX-CHP-16-0022"/><a class="indexterm" id="IDX-CHP-16-0023"/><a class="indexterm" id="IDX-CHP-16-0024"/><a class="indexterm" id="IDX-CHP-16-0025"/><a class="indexterm" id="IDX-CHP-16-0026"/></p><p>The first complaint, voiced chiefly by Microsoft developers and echoed by some academics, is that the scheme needlessly abuses ambient authority. They argue that there are very few cases where data shared across domains would need to be tailored based on the credentials available for the destination site. The critics believe that the risks of accidentally leaking sensitive information far outweigh any benefits and that a scheme permitting only nonauthenticated requests to be made would be preferable. In their view, any sites that need a form of authentication should instead rely on explicitly exchanged authentication tokens.<sup>[<a class="footnote" href="#ftn.CHP-16-FN-3" id="CHP-16-FN-3">79</a>]</sup></p><p>The other, more pragmatic criticism of CORS is that the scheme is needlessly complicated: It extends an already problematic and error-prone API without clearly explaining the benefits of some of the tweaks. In particular, it is not clear if the added complexity of preflight requests is worth the peripheral benefit of being able to issue cross-domain requests with unorthodox methods or random headers.</p><p>The last of the weak complaints hinges on the fact that CORS is susceptible to header injection. Unlike some other recently proposed browser features, such as WebSockets (<a class="xref" href="ch17.html" title="Chapter 17. Other Browser Mechanisms of Note">Chapter 17</a>), CORS does not require the server to echo back an unpredictable challenge string to complete the handshake. Particularly in conjunction with preflight caching, this may worsen the impact of certain header-splitting vulnerabilities in the server-side code.<a class="indexterm" id="IDX-CHP-16-0027"/></p></div></div><div class="sect2" title="XDomainRequest"><div class="titlepage"><div><div><h2 class="title"><a id="xdomainrequest"/>XDomainRequest</h2></div></div></div><p>Microsoft’s objection to CORS appears to stem from the aforementioned concerns over the use of ambient authority, but it also bears subtle overtones of their dissatisfaction with interactions with W3C. In 2008, Sunava Dutta, a program manager at Microsoft, offered this somewhat cryptic insight:<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-2">241</a>]</sup></p><div class="blockquote"><blockquote class="blockquote"><p>During the [Internet Explorer 8] Beta 1 timeframe there were many security based concerns raised for cross domain access of third party data using cross site XMLHttpRequest and the Access Control framework. Since Beta 1, we had the chance to work with other browsers and attendees at a W3C face-to-face meeting to improve the server-side experience and security of the W3C’s Access Control framework.</p></blockquote></div><p>Instead of embracing the CORS extensions to <span class="emphasis"><em>XMLHttpRequest</em></span>, Microsoft decided to implement a counterproposal, dubbed <span class="emphasis"><em>XDomainRequest</em></span>.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-3">242</a>]</sup> This remarkably simple, new API differs from the variant available in other browsers in that the resulting requests are always anonymous (that is, devoid of any browser-managed credentials) and that it does not allow for any custom HTTP headers or methods to be used.<a class="indexterm" id="IDX-CHP-16-0028"/><a class="indexterm" id="IDX-CHP-16-0029"/><a class="indexterm" id="IDX-CHP-16-0030"/><a class="indexterm" id="IDX-CHP-16-0031"/><a class="indexterm" id="IDX-CHP-16-0032"/><a class="indexterm" id="IDX-CHP-16-0033"/><a class="indexterm" id="IDX-CHP-16-0034"/></p><p>The use of Microsoft’s API is otherwise very similar to <span class="emphasis"><em>XMLHttpRequest</em></span>:</p><a id="I_programlisting1_d1e17977"/><pre class="programlisting">var x = new XDomainRequest();
x.open("GET", "http://www.fuzzybunnies.com/get_data.php?id=1234");
x.send();</pre><p>Borrowing from W3C’s proposal, the resulting request will bear an <span class="emphasis"><em>Origin</em></span> header, and the response data will be revealed to the caller only if a matching <span class="emphasis"><em>Access-Control-Allow-Origin</em></span> header is present in the response.<sup>[<a class="footnote" href="#ftn.CHP-16-FN-4" id="CHP-16-FN-4">80</a>]</sup> Preflight requests and permission caching are not a part of the design.</p><p>For all intents and purposes, Microsoft’s solution is far more reasonable than CORS: It is simpler, safer, and probably just as functional in all the plausible uses. That said, it is also unpopular. It is supported only in Internet Explorer 8 and up, and owing to W3C backing CORS, others have no reason to embrace <span class="emphasis"><em>XDomainRequest</em></span> anytime soon.</p><p>In the meantime, a separate group of researchers have proposed a third solution, again acting under the auspices of W3C. Their design, known as Uniform Messaging Policy (complete with a corresponding <span class="emphasis"><em>UniformRequest</em></span> API),<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-4">243</a>]</sup> embraces an approach nearly identical to Microsoft’s. It is not supported in any existing browser, but there is some talk of unifying it with CORS.<a class="indexterm" id="IDX-CHP-16-0035"/></p></div><div class="sect2" title="Other Uses of the Origin Header"><div class="titlepage"><div><div><h2 class="title"><a id="other_uses_of_the_origin_header"/>Other Uses of the Origin Header</h2></div></div></div><p>The <span class="emphasis"><em>Origin</em></span> header is an essential part of CORS, <span class="emphasis"><em>XDomainRequest</em></span>, and UMP, but it actually evolved somewhat independently with other uses in mind. In their 2008 paper, Adam Barth, Collin Jackson, and John C. Mitchell<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-5">244</a>]</sup> advocated the introduction of a new HTTP header that would offer a more reliable and privacy-conscious alternative to <span class="emphasis"><em>Referer</em></span>. It would also serve as a way to prevent cross-site request vulnerabilities by providing the server with the information needed to identify the SOP-level origin of a request, without disclosing the potentially more sensitive path or query data.<a class="indexterm" id="IDX-CHP-16-0036"/></p><p>Of course, it was unclear whether the subtle improvement between <span class="emphasis"><em>Referer</em></span> and its proposed successor would actually make a difference for the small but nonnegligible population of users who block that first header on privacy grounds. The proposal consequently ended up in a virtual limbo, not being deployed in any existing browsers but also discouraging others from pursuing other solutions such as XSRF or XSSI.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-6">245</a>]</sup> (To be fair, the concept was very recently revived under the new name of <span class="emphasis"><em>From-Origin</em></span> and may not be completely dead yet.)<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-7">246</a>]</sup></p><p>The fate of the original idea aside, the utility of the <span class="emphasis"><em>Origin</em></span> header in specialized cases such as CORS was pretty clear. Around 2009, this led to Barth submitting an IETF draft specifying the syntax of the header,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-8">247</a>]</sup> while shying away from making any statements about when the header should be sent, or what specific security problems it might solve:<a class="indexterm" id="IDX-CHP-16-0037"/><a class="indexterm" id="IDX-CHP-16-0038"/></p><div class="blockquote"><blockquote class="blockquote"><p>The user agent MAY include an Origin header in any HTTP request.</p><p>[...]</p><p>Whenever a user agent issues an HTTP request from a “privacy-sensitive” context, the user agent MUST send the value “null” in the Origin header.</p><p>NOTE: This document does not define the notion of a privacy-sensitive context. Applications that generate HTTP requests can designate contexts as privacy-sensitive to impose restrictions on how user agents generate Origin headers.</p></blockquote></div><p>The bottom line of this specification is that whatever the decision process is, once the client chooses to provide the header, the value is required to accurately represent the SOP origin from which the request is being made. For example, when a particular operation takes place from <a class="ulink" href="http://www.bunnyoutlet.com:1234/bunny_reports.php">http://www.bunnyoutlet.com:1234/bunny_reports.php</a>, the transmitted value should be</p><a id="I_programlisting1_d1e18064"/><pre class="programlisting">Origin: http://www.bunnyoutlet.com:1234</pre><p>For origins that do not meaningfully map to a protocol-host-port tuple, the browser must send the value of <span class="emphasis"><em>null</em></span> instead.<a class="indexterm" id="IDX-CHP-16-0039"/></p><p>Despite all of these plans, as of this writing only one browser includes the <span class="emphasis"><em>Origin</em></span> header on non-CORS navigation: WebKit-based implementations send it when submitting HTML forms. Firefox seems to be considering a different approach, but nothing specific seems to have been implemented yet.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-16-FN-1" id="ftn.CHP-16-FN-1">77</a>] </sup>Malicious URL blacklists, a feature supported by (and usually enabled in) all modern browsers, are a prime example of this trend. The blacklist is a lightweight, crude substitute for an antivirus, which is, in turn, a poor substitute for up-to-date and well-designed software. Antimalware features do not make individual attacks any more difficult; they are simply meant to stop the large-scale distribution of unsophisticated malware, based on the assumption that most users are not interesting enough to be specifically targeted or attacked with something clever.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-16-FN-2" id="ftn.CHP-16-FN-2">78</a>] </sup>That assumption is not completely correct. For example, prior to the introduction of this scheme, attackers would not have been able to initiate a cross-domain request completely indistinguishable from the submission of a file upload form, but under CORS, such forgery is possible.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-16-FN-3" id="ftn.CHP-16-FN-3">79</a>] </sup>The same claim can be made about the use of HTTP cookies in any other setting and seems equally futile. It is true that ambient credentials cause problems more frequently than some other forms of explicit authentication would, but they are also a lot more convenient to use and are simply not going away.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-16-FN-4" id="ftn.CHP-16-FN-4">80</a>] </sup>The reason for this check, even if the response is not authenticated, is to prevent the use of the browser as a proxy (for example, to crawl internal networks or send out spam).</p></div></div></div>
<div class="sect1" title="Security Model Restriction Frameworks"><div class="titlepage"><div><div><h1 class="title"><a id="security_model_restriction_frameworks"/>Security Model Restriction Frameworks</h1></div></div></div><p>Designs that extend the bounds of the same-origin policy are fairly simple to understand and typically fail securely. If the proposed change is not accounted for in one of the possible code paths, or is simply not supported in a particular browser, the previously implemented, more restrictive logic will kick in. Compared with this, it is far more dangerous to try to erect new boundaries on top of the existing browser security model. That’s because every security-sensitive code path must be tweaked to recognize the new scheme and every browser must comply right away, or unexpected problems will arise.</p><p>In this section, we will take a quick look at some of the more accomplished attempts to take this dangerous but potentially rewarding path—and explore where they come apart.</p><div class="sect2" title="Content Security Policy"><div class="titlepage"><div><div><h2 class="title"><a id="content_security_policy"/>Content Security Policy</h2></div></div></div><p><span class="emphasis"><em>Content Security Policy</em></span> (<span class="emphasis"><em>CSP</em></span>) is an unusually comprehensive security framework first proposed by Brandon Sterne of Mozilla in 2008.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-9">248</a>]</sup> The framework was originally envisioned as an all-encompassing way to mitigate the impact of common web vulnerabilities, from XSRF to XSS, and as a tool for website owners to perform a variety of non-security content-policing tasks.<a class="indexterm" id="IDX-CHP-16-0040"/><a class="indexterm" id="IDX-CHP-16-0041"/><a class="indexterm" id="IDX-CHP-16-0042"/><a class="indexterm" id="IDX-CHP-16-0043"/><a class="indexterm" id="IDX-CHP-16-0044"/><a class="indexterm" id="IDX-CHP-16-0045"/><a class="indexterm" id="IDX-CHP-16-0046"/><a class="indexterm" id="IDX-CHP-16-0047"/></p><p>In the years that followed, CSP evolved rapidly, and on several occasions, its scope changed in major ways. (For example, the author quickly abandoned the plan to address XSRF vulnerabilities, delegating the job to the yet unrealized extensions of the <span class="emphasis"><em>Origin</em></span> header.) In fact, as of this writing, the canonical Mozilla specification is being rewritten as a W3C draft,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-10">249</a>]</sup> resulting in substantial differences in the implementation shipped in Firefox and the partial support implemented in WebKit by Adam Barth. (Internet Explorer and Opera do not support CSP and have not announced any specific plans to embrace it.)<a class="indexterm" id="IDX-CHP-16-0048"/></p><div class="sect3" title="Primary CSP Directives"><div class="titlepage"><div><div><h3 class="title"><a id="primary_csp_directives"/>Primary CSP Directives</h3></div></div></div><p>At its core, Sterne’s design permits site owners to specify per-document policies that constrain the ability of the subject document to perform actions that would normally be permitted under the same-origin policy. For example, CSP may prevent a page from loading any external subresources except for images and restrict image sources to only a set of trusted origins, like so:</p><a id="I_programlisting1_d1e18140"/><pre class="programlisting">X-Content-Security-Policy: default-src 'none'; img-src http://*.example.com</pre><p>As should be evident from this example, the policies may be encoded in an HTTP header. Under the W3C draft, it is also possible to embed them in the document itself (using <span class="emphasis"><em>&lt;meta&gt;</em></span> tags) or host the policy at an external URL and point to it with <span class="emphasis"><em>policy-uri</em></span>.</p><p>For every content source directive, the author of the policy may specify any number of fully qualified origins or wildcard expressions that match multiple hosts, protocols, or ports. Three special keywords (<span class="emphasis"><em>none</em></span>, <span class="emphasis"><em>self</em></span>, and <span class="emphasis"><em>data:</em></span>) correspond to an empty set, the origin associated with the policy-bearing page, or all inline <span class="emphasis"><em>data:</em></span> URLs, in corresponding order.</p><p>As of today, the following behaviors can be controlled with CSP directives:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Script execution</strong></span> A <span class="emphasis"><em>script-src</em></span> directive can be used to specify the protocol, host, and port for permissible <span class="emphasis"><em>&lt;script src=...&gt;</em></span> URLs. Normally, the CSP disables the ability to embed scripts inline in the document (whether through standalone <span class="emphasis"><em>&lt;script&gt;</em></span> blocks or via event handlers) and of existing scripts to carelessly pass strings to functions such as <span class="emphasis"><em>eval(...)</em></span>, <span class="emphasis"><em>setTimeout(...)</em></span>, <span class="emphasis"><em>setInterval(...)</em></span>, and so on. Because of this, the <span class="emphasis"><em>script-src</em></span> directive is useful for limiting the impact of XSS vulnerabilities: Any markup injected by the attacker will be limited to loading scripts legitimately hosted in one of the approved origins.<sup>[<a class="footnote" href="#ftn.CHP-16-FN-5" id="CHP-16-FN-5">81</a>]</sup><a class="indexterm" id="IDX-CHP-16-0049"/><a class="indexterm" id="IDX-CHP-16-0050"/></p></li><li class="listitem"><p><span class="strong"><strong>Plug-in content</strong></span> This is controlled through <span class="emphasis"><em>object-src</em></span>. Because plug-ins such as Java or Flash may have unconstrained access to the embedding page, the directive should be considered largely analogous to <span class="emphasis"><em>script-src</em></span>, and the two directives must be restricted in a comparable way to achieve any security benefits.<a class="indexterm" id="IDX-CHP-16-0051"/><a class="indexterm" id="IDX-CHP-16-0052"/><a class="indexterm" id="IDX-CHP-16-0053"/><a class="indexterm" id="IDX-CHP-16-0054"/><a class="indexterm" id="IDX-CHP-16-0055"/><a class="indexterm" id="IDX-CHP-16-0056"/><a class="indexterm" id="IDX-CHP-16-0057"/><a class="indexterm" id="IDX-CHP-16-0058"/><a class="indexterm" id="IDX-CHP-16-0059"/></p></li><li class="listitem"><p><span class="strong"><strong>Stylesheets and fonts</strong></span> This is controlled by <span class="emphasis"><em>style-src</em></span> and <span class="emphasis"><em>font-src</em></span>. Unlike its handling of scripts, CSP originally did not prevent inline <span class="emphasis"><em>&lt;style&gt;</em></span> blocks or <span class="emphasis"><em>style=</em></span> parameters from appearing on the page. Therefore, any attacker exploiting an XSS flaw could dramatically alter the appearance and function of the vulnerable page (or worse),<sup>[<a class="footnote" href="#ftn.CHP-16-FN-6" id="CHP-16-FN-6">82</a>]</sup> and these two directives only served nonsecurity goals, with the possible exception of limiting mixed-content bugs. Only moments before the publication of the book, the specifications have been amended to include a more robust approach to CSS.<a class="indexterm" id="IDX-CHP-16-0060"/><a class="indexterm" id="IDX-CHP-16-0061"/></p></li><li class="listitem"><p><span class="strong"><strong>Passive multimedia</strong></span> Directives such as <span class="emphasis"><em>img-src</em></span> or <span class="emphasis"><em>media-src</em></span> control the ability to embed multimedia content from specific origins. As with the original design of CSS controls, this could not have been considered a security feature. For example, in the case of an XSS bug, CSP would not have prevented the attacker from leveraging stylesheets to draw arbitrary shapes on the vulnerable page or even animating them to some extent.</p></li><li class="listitem"><p><span class="strong"><strong>Subframes</strong></span> The <span class="emphasis"><em>frame-src</em></span> directive specifies the acceptable destinations for any <span class="emphasis"><em>&lt;iframe&gt;</em></span> tags encountered on the page; the policy of the parent page is not inherited by the framed document. To preserve the value of other XSS mitigations, steps must be taken not to allow <span class="emphasis"><em>data:</em></span> URLs here (see <a class="xref" href="ch10.html" title="Chapter 10. Origin Inheritance">Chapter 10</a>).</p></li><li class="listitem"><p><span class="strong"><strong>Default policy</strong></span> Known as <span class="emphasis"><em>default-src</em></span> in the W3C draft, and under a more cryptic name (<span class="emphasis"><em>allow</em></span>) in Mozilla documentation, the directive specifies fallback behavior for any content not covered by a more specific directive. The directive is required, even in cases where it is technically unnecessary.</p></li></ul></div><div class="note" title="Note"><h3 class="title">Note</h3><p>It may be unfortunate that CSP directives are selected to map very closely to individual HTML tags, instead of grouping functionally similar behaviors. Because of this, it is difficult to appreciate the tricky interactions among settings such as <span class="emphasis"><em>script-src</em></span>, <span class="emphasis"><em>frame-src</em></span>, and <span class="emphasis"><em>object-src</em></span>. Also, the approach is simply not very future-safe: There already are some peripheral classes of subresources (such as “favicons”) that are excluded from CSP altogether, and that list will probably unintentionally grow.</p></div><p>In an unusual departure from the subresource-driven model outlined thus far, CSP also features an oddball directive called <span class="emphasis"><em>frame-ancestors</em></span>. This parameter is meant to mitigate the impact of clickjacking by specifying the allowed ancestors for the current document in a manner similar to the better-established <span class="emphasis"><em>X-Frame-Options</em></span> header (outlined in <a class="xref" href="ch11.html" title="Chapter 11. Life Outside Same-Origin Rules">Chapter 11</a>). The <span class="emphasis"><em>frame-ancestors</em></span> logic is completely independent of <span class="emphasis"><em>default-src</em></span> or any other parts of CSP; its default value is “*”.</p><p>Many other possible extensions of the policy are being discussed as of this writing. These include a <span class="emphasis"><em>script-nonce</em></span> directive that could be used to more securely embed inline scripts (every script block must begin with a policy-specified, unpredictable token, often making XSS exploitation harder) and a <span class="emphasis"><em>sandbox</em></span> directive, which offers an alternative interface to another security mechanism, discussed in <a class="xref" href="ch16s02.html#sandboxed_frames" title="Sandboxed Frames">Sandboxed Frames</a> in <a class="xref" href="ch16s02.html#sandboxed_frames" title="Sandboxed Frames">Sandboxed Frames</a>.<a class="indexterm" id="IDX-CHP-16-0062"/><a class="indexterm" id="IDX-CHP-16-0063"/><a class="indexterm" id="IDX-CHP-16-0064"/></p></div><div class="sect3" title="Policy Violations"><div class="titlepage"><div><div><h3 class="title"><a id="policy_violations"/>Policy Violations</h3></div></div></div><p>The policy specified according to these rules constrains the behavior of the underlying document. Violations normally result in a failed subresource load, the failure to execute an inline script, or the inhibition of page rendering (in the special case of <span class="emphasis"><em>frame-ancestors</em></span>).<a class="indexterm" id="IDX-CHP-16-0065"/></p><p>Because CSP controls a wide range of content behaviors, and because the default failure mode is fairly brutal, the authors perceived a need to ease the worries of webmasters. To make CSP more user-friendly, and perhaps also in a naïve attempt to offer exploit detection, an optional feature of CSP allows the browser to report all policy violations immediately back to the owner of the site. This feature can be enabled through the <span class="emphasis"><em>report-uri</em></span> keyword in the policy. To further simplify deployment, it is also possible to roll out any policy—or part thereof—in a “soft” mode, where violations result only in an HTTP notification but do not actually break the page. This is achieved by specifying the policy inside a header named <span class="emphasis"><em>X-Content-Security-Policy-Report-Only</em></span>.<sup>[<a class="footnote" href="#ftn.CHP-16-FN-7" id="CHP-16-FN-7">83</a>]</sup></p></div><div class="sect3" title="Criticisms of CSP"><div class="titlepage"><div><div><h3 class="title"><a id="criticisms_of_csp"/>Criticisms of CSP</h3></div></div></div><p>CSP is a remarkably sensible and consistent design compared to most of the one-off security features proposed or deployed in the browser world. Nevertheless, from its inception, the proposal has been haunted by recurring design and implementation concerns.</p><p>Perhaps the most prosaic complaint about CSP is a nonsecurity one: In order to benefit from the XSS defenses offered by the framework, webmasters have to move all inline scripts on the page (often hundreds of individual snippets of code) to a separately requested document; in the new drafts of CSP, the same will be required for all stylesheets. The complexity of retrofitting existing pages to work with CSP and the performance penalty of an additional HTTP request are often prohibitive. (It may be possible to resolve this problem with the <span class="emphasis"><em>script-nonce</em></span> extension proposed in the most recent drafts.)</p><p>A more fundamental concern with the design of CSP is that the currently envisioned origin-level granularity of the rulesets may not offer a sufficiently robust defense against XSS. Consider the fact that any complex, real-life domain may well host a dozen largely separate web applications, each consisting of hundreds of possibly unrelated static scripts and JavaScript APIs. Attackers exploiting an XSS vulnerability in a CSP-protected site are prevented from directly executing a malicious script, but they may be able to put the application into an inconsistent and possibly dangerous state by loading the existing scripts in the wrong context or in an incorrect sequence. The history of vulnerabilities in nonweb software suggests that such state corruption conditions are exploitable more often than we may think.<a class="indexterm" id="IDX-CHP-16-0066"/><a class="indexterm" id="IDX-CHP-16-0067"/><a class="indexterm" id="IDX-CHP-16-0068"/><a class="indexterm" id="IDX-CHP-16-0069"/></p><p>An even more troubling prospect is that an attacker can load a subresource that is not truly a script but that might be mistaken for one. An extreme example of this may be a browser supporting E4X (see <a class="xref" href="ch06.html" title="Chapter 6. Browser-Side Scripts">Chapter 6</a>): Any valid XHTML document in which the attacker can place a nominally harmless string—say, <span class="emphasis"><em>{alert("Hi mom!")}</em></span>—may result in code execution when loaded via <span class="emphasis"><em>&lt;script src=...&gt;</em></span>. Recognizing this problem, the developers decided to require whitelisted <span class="emphasis"><em>Content-Type</em></span> values for any scripts loaded under CSP, but even this approach is often insufficient.</p><p>To understand what may go wrong, consider the exceedingly common practice of hosting public JSONP APIs in which the client can specify the name of the callback function:</p><a id="I_programlisting1_d1e18446"/><pre class="programlisting">GET /store_locator_api.cgi?zip=90210&amp;callback=<strong class="userinput"><code>myResultParser</code></strong> HTTP/1.0
...

HTTP/1.0 200 OK
Content-Type: application/x-javascript
...
<strong class="userinput"><code>myResultParser</code></strong>({ "store_name": "Spacely Space Sprockets",
                 "street": ... });</pre><p>Such an API anywhere within a CSP-permitted origin may be leveraged by an attacker to call arbitrary existing functions in the client-side code, perhaps together with attacker-controlled parameters. And if the <span class="emphasis"><em>callback</em></span> string is not constrained to alphanumerics (and why should it be?), specifying <span class="emphasis"><em>callback=alert(1);//</em></span> will lead to straightforward code injection.</p><p>Issues with granularity aside, CSP deserves some gentle criticism for its sometimes puzzling and detrimental lack of focus. On one hand, through the inclusion of directives such as <span class="emphasis"><em>frame-descendants</em></span> or <span class="emphasis"><em>sandbox</em></span>, it seems to be flirting with the idea of building a single, unifying browser security framework—only to unexpectedly exclude XSRF flaws from its scope without offering a viable alternative beyond a vague mention of <span class="emphasis"><em>Origin</em></span>. On the other hand, the proposal often aspires to be just a “Content Policy,” with no special attention paid to offering sufficiently robust and intuitive security properties. The ease of creating dangerous script policies, coupled with the originally ineffective policing of stylesheets and images, is a testament to this trend.</p></div></div><div class="sect2" title="Sandboxed Frames"><div class="titlepage"><div><div><h2 class="title"><a id="sandboxed_frames"/>Sandboxed Frames</h2></div></div></div><p>Sandboxed frames<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-11">250</a>]</sup> are an extension of the normal <span class="emphasis"><em>&lt;iframe&gt;</em></span> behavior. They allow the owner of the top-level page to place certain additional restrictions on the embedded document along with any of that document’s subframes. The goal is to make it safer for web applications to embed potentially untrusted advertisements, gadgets, or preformatted HTML documents on an otherwise sensitive site. The refinement of the design and the initial implementation of this feature in WebKit (which is currently the only engine supporting it) was driven by Adam Barth.<a class="indexterm" id="IDX-CHP-16-0070"/><a class="indexterm" id="IDX-CHP-16-0071"/><a class="indexterm" id="IDX-CHP-16-0072"/><a class="indexterm" id="IDX-CHP-16-0073"/><a class="indexterm" id="IDX-CHP-16-0074"/><a class="indexterm" id="IDX-CHP-16-0075"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Curiously, sandboxed frames are not exactly a novel idea: Microsoft came up with a similar proposal almost a decade earlier. Since version 6, Internet Explorer has supported a proprietary <span class="emphasis"><em>security=restricted</em></span> parameter, which forces the target frame to be rendered in the Restricted Zone, effectively removing its ability to execute scripts, navigate to other locations, and so on. However, no one seemed interested in using this feature for anything other than bypassing certain client-side JavaScript security mechanisms (most notably, anticlickjacking checks). We will soon know whether the HTML5 successor fares any better.</p></div><p>The design of sandboxed frames is fairly simple: Any frame embedded in a document may be constrained by specifying the <span class="emphasis"><em>sandbox</em></span> parameter on the appropriate <span class="emphasis"><em>&lt;iframe&gt;</em></span> tag. By default, the document subject to this restriction is prevented from executing scripts and performing certain types of navigations. The permissions may be fine-tuned with one or more whitespace-delimited keywords, specified as a value for the <span class="emphasis"><em>sandbox</em></span> parameter itself:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bolditalic">Allow-scripts</span> In the absence of this keyword, the document displayed inside the frame will be unable to execute JavaScript code. The primary function of this feature is to prevent the embedded document from performing DoS attacks, opening browser dialogs, or employing any other complex automation of the page.</p></li><li class="listitem"><p><span class="bolditalic">Allow-forms</span> When this keyword is absent, any HTML forms encountered in the embedded document will not work. This mechanism is designed to prevent the framed content from exploiting its placement on a trusted website to phish for sensitive information. (Note that with <span class="emphasis"><em>allow-scripts</em></span> enabled, there is little or no point in <span class="emphasis"><em>allow-forms</em></span>. Scripts may easily construct form-like controls and automatically relay the collected information to another site without the need for a functioning <span class="emphasis"><em>&lt;form&gt;</em></span> tag.)</p></li><li class="listitem"><p><span class="bolditalic">Allow-top-navigation</span> This keyword re-enables the ability of the embedded page to navigate the top-level window. This type of navigation is normally permitted as one of the exceptions to the same-origin policy (see <a class="xref" href="ch11.html" title="Chapter 11. Life Outside Same-Origin Rules">Chapter 11</a>), and it may be abused simply to prevent the user from interacting with the embedding site or to carry out phishing attacks.</p></li><li class="listitem"><p><span class="bolditalic">Allow-same-origin</span> Without this flag, the content inside a sandboxed frame is assigned a unique, randomly selected, synthetic origin. This prevents the page from accessing any origin-bound content that would normally be available to scripts executing in the domain it is nominally hosted in. The inclusion of <span class="emphasis"><em>allow-same-origin</em></span> removes the synthetic origin and permits same-origin data access.</p></li></ul></div><div class="sect3" title="Scripting, Forms, and Navigation"><div class="titlepage"><div><div><h3 class="title"><a id="scripting_comma_forms_comma_and_navigati"/>Scripting, Forms, and Navigation</h3></div></div></div><p>The first three restrictions available to sandboxed frames—scripting, forms, and navigation—are fairly intuitive and safe to use. Their value is diminished only by the need to also disable all plug-ins whenever the <span class="emphasis"><em>sandbox</em></span> attribute is used, because frameworks such as Flash or Java do not honor the extension and would allow any embedded applets to bypass the newly added browser checks. Unfortunately, the three most obvious use cases for sandboxed frames—embedded advertisements, videos, and games—rely heavily on Flash, thus rendering this security mechanism much less useful than it might otherwise be.<a class="indexterm" id="IDX-CHP-16-0076"/><a class="indexterm" id="IDX-CHP-16-0077"/></p></div><div class="sect3" title="Synthetic Origins"><div class="titlepage"><div><div><h3 class="title"><a id="synthetic_origins"/>Synthetic Origins</h3></div></div></div><p>The last mechanism on the list, synthetic origins, is far more problematic and is likely misguided. It is envisioned primarily as a way to make it possible for untrusted documents (such as incoming HTML-based emails in a webmail interface) to be served as is, along with the rest of the application, while preventing these untrusted documents from accessing sensitive data.<a class="indexterm" id="IDX-CHP-16-0078"/></p><p>Unfortunately, the concept of synthetic origins creates more problems than it solves. For one, unless the URL of the embedded document is unpredictable, the attacker may simply navigate to it directly in a new browser window, in which case the browser will not see the <span class="emphasis"><em>sandbox</em></span> attribute at all.</p><p>As an attempt to work around this problem, the authors of the specification eventually proposed the use of a specialized MIME type (<span class="emphasis"><em>text/html-sandboxed</em></span>) for content meant to be shown only in a sandboxed frame. Their reasoning is that browsers will normally not recognize this MIME type and will not display it inline and that a special case may be created in the <span class="emphasis"><em>&lt;iframe&gt;</em></span> handling code. Of course, as should be clear from <a class="xref" href="ch13.html" title="Chapter 13. Content Recognition Mechanisms">Chapter 13</a>, such a defense is inadequate, because some browsers and plug-ins will render <span class="emphasis"><em>text/html-sandboxed</em></span> responses inline or interpret the returned data in other troubling ways (say, as <span class="emphasis"><em>crossdomain.xml</em></span>).</p><p>The concept of synthetic origins is also highly problematic given the fragmentation of origin- or domain-level security mechanisms in a typical browser. For example, dangerous interactions are possible with password managers, which must be explicitly prevented from autocompleting login forms in the sandboxed documents. Also, special logic must be added to security prompts, such as the one associated with the geolocation API.</p><p>After some trial and error, the implementation currently available in WebKit resolved many of these issues on a case-by-case basis. That said, future implementations are likely to fall for this trap repeatedly, especially since the HTML5 specification considers the behavior of these features to be out of scope and does not specify the required behavior in any way.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Removing synthetic origins leads to trouble, too: If the user clicks on a same-site link in a sandboxed advertisement and that link opens in a new window, the browser probably should prevent the unrestricted scripts in the new window from traversing the <span class="emphasis"><em>opener</em></span> object to perform actions that its parent is prohibited from performing on its own.</p></div></div></div><div class="sect2" title="Strict Transport Security"><div class="titlepage"><div><div><h2 class="title"><a id="strict_transport_security"/>Strict Transport Security</h2></div></div></div><p>One of the most significant weaknesses in the design of HTTPS is that users often begin navigation by typing in a protocol-less URL in the address bar (such as <a class="ulink" href="http://bankofamerica.com">bankofamerica.com</a> rather than <a class="ulink" href="https://www.bankofamerica.com">https://www.bankofamerica.com</a>), in which case the browser will presume HTTP and send the initial request in plaintext. Even if the site immediately redirects this traffic to HTTPS, any active attacker on the victim’s network may intercept and modify that initial response, preventing the user from ever upgrading to a secure protocol. In such case, the absence of a tiny lock icon in the browser UI will be very easy to miss.<a class="indexterm" id="IDX-CHP-16-0079"/><a class="indexterm" id="IDX-CHP-16-0080"/><a class="indexterm" id="IDX-CHP-16-0081"/><a class="indexterm" id="IDX-CHP-16-0082"/><a class="indexterm" id="IDX-CHP-16-0083"/><a class="indexterm" id="IDX-CHP-16-0084"/><a class="indexterm" id="IDX-CHP-16-0085"/><a class="indexterm" id="IDX-CHP-16-0086"/></p><p>This problem, as well as several peripheral issues related to mixed content and cookie scoping, prompted Jeff Hodges and several other researchers to draft a proposal for HTTP Strict Transport Security (HSTS, or STS for short).<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-12">251</a>]</sup> Their approach (currently supported in WebKit and Firefox) allows any site on the Internet to instruct the browser that all future requests made to a particular hostname or domain should always use HTTPS and that any HTTP traffic should be automatically upgraded and submitted only over HTTPS.</p><p>The reasoning behind the design of HSTS is that the user’s first interaction with a particular domain is unlikely to occur over a connection that is being actively tampered with—but that, over time, as the user roams on open wireless networks, the chances of encountering an attacker increase rapidly. HSTS is, therefore, an imperfect defense, but in practice it is usually good enough.</p><p>The HSTS opt-in header may appear in HTTPS responses, looking something like this:</p><a id="I_programlisting1_d1e18665"/><pre class="programlisting">Strict-Transport-Security: max-age=3000000; includeSubDomains</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>For HSTS to offer reasonable protection, <span class="emphasis"><em>max-age</em></span> (the number of seconds that the STS record may be stored in the browser) must be set to a value substantially higher than the usual worst-case time between visits to the site. Because there is no easy way to disable or override HSTS when something goes wrong with the HTTPS site, website owners will be tempted to choose a value small enough to minimize disruption when they mess something up and have to revert. It is not clear whether this conflict of interests will lead web programmers to make optimal choices.</p></div><p>The negative security consequences of this design are fairly unremarkable: There is a slightly elevated risk of DoS attacks, because an attacker could inject this response header into a domain that is not fully HTTPS enabled. There is also the possibility of using a unique combination of HSTS settings for several decoy hostnames to tag a particular instance of a browser, offering yet another alternative to cookie-based user tracking. Neither of these concerns is particularly pronounced, however.</p><p>Unfortunately, as with other restriction-adding frameworks discussed in this section of the book, the mechanism sounds great in principle, but it’s difficult to fully account for how it may interact with other legacy code. In particular, unless the <span class="emphasis"><em>includeSubDomains</em></span> flag is used, HSTS offers unexpectedly little protection for HTTP cookies: Cookies not marked as <span class="emphasis"><em>secure</em></span> may still be intercepted simply by inventing a nonexistent subdomain and intercepting the HTTP request made to that destination.<sup>[<a class="footnote" href="#ftn.CHP-16-FN-8" id="CHP-16-FN-8">84</a>]</sup> (Even <span class="emphasis"><em>secure</em></span> cookies could be clobbered in a similar fashion, just not read back.)<a class="indexterm" id="IDX-CHP-16-0087"/><a class="indexterm" id="IDX-CHP-16-0088"/></p><p>In a similar vein, the enforcement of HSTS on requests originating from plug-in-based content is unlikely to work well.</p></div><div class="sect2" title="Private Browsing Modes"><div class="titlepage"><div><div><h2 class="title"><a id="private_browsing_modes"/>Private Browsing Modes</h2></div></div></div><p>Private browsing, colloquially known as the “porn mode,” is a nonstandardized feature available in most up-to-date browsers. It is meant to create a nonpersistent browsing sandbox, isolated from the main browser session, which is completely discarded as soon as the last private browsing window is closed. In a sense, this mechanism can be considered a form of content isolation added on top of the existing browser security paradigms, so it seems fitting to briefly mention it now.</p><p>With the exception of Chrome, most browser vendors do not accurately explain the security assurances associated with private browsing. Unfortunately, the intuitive understanding of the term is quite different from what browsers can actually deliver.</p><p>Arguably, the most straightforward interpretation of the feature is that a private browsing session should be perfectly anonymous and that no data about the user’s activity will persist on the system. These two assumptions are already partly undermined by the constraints imposed by the networking stacks and the memory management practices of modern operating systems. But even within the browser itself, the goal of reasonable anonymity is nearly impossible to achieve. Almost every stateful browser mechanism, from geolocation or pop-up permissions to Strict Transport Security to form autocompletion to plug-in-based persistent data storage, must be modified in order to properly account for the distinction between the two browsing modes, and for each vendor, achieving that goal is an uphill battle. Perhaps more frustratingly, anonymity is also undermined by the ability of scripts to uniquely fingerprint any given system simply by examining its characteristics—such as the set of installed plug-ins, fonts, screen resolutions, window sizes, clock drift, or even the behavior of noncryptographically secure PRNGs.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-13">252</a>]</sup></p><p>In the end, despite appearances to the contrary, private browsing mode is suitable only for preventing casual data disclosure to other nontechnical users of the same machine, and even that goal is sometimes difficult to achieve.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-16-FN-5" id="ftn.CHP-16-FN-5">81</a>] </sup>CSP offers several ways to shoot yourself in the foot here. For one, it is possible to re-enable script execution with settings such as <span class="emphasis"><em>inline-script</em></span> (Mozilla’s naming, changed to <span class="emphasis"><em>disable-xss-protection</em></span> in W3C draft) or <span class="emphasis"><em>eval-script</em></span>. Perhaps less obviously, it is also possible to make the mistake of permitting <span class="emphasis"><em>data:</em></span> or <span class="emphasis"><em>*</em></span> as a permissible origin or allowing an HTTP origin on an HTTPS site.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-16-FN-6" id="ftn.CHP-16-FN-6">82</a>] </sup>Remember advanced selectors in CSS3? By cleverly leveraging them in injected stylesheets, some information about the strings appearing on the page may be conveniently relayed to a third-party server without the use of JavaScript.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-16-FN-7" id="ftn.CHP-16-FN-7">83</a>] </sup>As a side note, this feature is useful not only for short-term experiments but also for detecting noncritical issues on an ongoing basis. For example, the owner of a site may leverage it to detect mixed-content issues by creating a report-only policy for HTTPS pages that will be violated by any HTTP scripts.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-16-FN-8" id="ftn.CHP-16-FN-8">84</a>] </sup>Recall from <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a> that host-scoped cookies are fairly tricky to create in some browsers and outright impossible to have in Internet Explorer.</p></div></div></div>
<div class="sect1" title="Other Developments"><div class="titlepage"><div><div><h1 class="title"><a id="other_developments"/>Other Developments</h1></div></div></div><p>The security features discussed previously in this chapter aim to shift the boundaries between web applications and change the way sites interact with each other. Another group of proposed mechanisms escapes this simple classification yet is important or mature enough to briefly mention here. We’ll review some of them now.<a class="indexterm" id="IDX-CHP-16-0089"/><a class="indexterm" id="IDX-CHP-16-0090"/><a class="indexterm" id="IDX-CHP-16-0091"/><a class="indexterm" id="IDX-CHP-16-0092"/><a class="indexterm" id="IDX-CHP-16-0093"/><a class="indexterm" id="IDX-CHP-16-0094"/><a class="indexterm" id="IDX-CHP-16-0095"/><a class="indexterm" id="IDX-CHP-16-0096"/><a class="indexterm" id="IDX-CHP-16-0097"/></p><div class="sect2" title="In-Browser HTML Sanitizers"><div class="titlepage"><div><div><h2 class="title"><a id="in-browser_html_sanitizers"/>In-Browser HTML Sanitizers</h2></div></div></div><p>XSS vulnerabilities are by far the most common security issue encountered in modern web applications. It must be surprising, then, that so few of the proposed security frameworks aim to address the problem in a comprehensive way. True, CSP is a strong contender, but it requires a radical change in how web applications are written, and it can’t be deployed particularly gradually or selectively. Sandboxed frames, on the other hand, are probably too resource-intensive and too awkward to use for the most common task of displaying hundreds of individual, short snippets of user-supplied data.<a class="indexterm" id="IDX-CHP-16-0098"/></p><p>Perhaps the best solution to many XSS woes would be a method for web frameworks to provide the browser with a parsed, unambiguous, binary DOM tree. Such a solution would eliminate many of the issues associated with template escaping and HTML sanitization. A more down-to-earth alternative might be to equip web developers with a robust tool to mark the boundaries of an attacker-supplied string and restrict the behavior or appearance of the embedded payload without having to escape or sanitize it. One might think of syntax such as this:<a class="indexterm" id="IDX-CHP-16-0099"/></p><a id="I_programlisting1_d1e18763"/><pre class="programlisting">&lt;sandbox token="random_value12345" settings="allow_static_html"&gt;
   ...any unsanitized text or HTML...
&lt;/sandbox token="random_value12345"&gt;</pre><p>Were such a tool to be used, the attacker would be unable to escape such a sandbox and remove the restriction on scripting without guessing the correct value of the randomly generated <span class="emphasis"><em>token</em></span> boundary.</p><p>Sadly, such a proposal is unlikely to become a part of HTML5 or to ship in any browser, because this serialization is fundamentally incompatible with XML, and revising XML itself to allow an obscure use case in HTML is a difficult act to pull off. Depressingly, XML already offers a similar method of encapsulating arbitrary data inside a <span class="emphasis"><em>&lt;![CDATA[...]]&gt;</em></span> block, but absent a token-based guard, this sandbox can be escaped easily when exploiting XSS.</p><p>On the flip side, it is considerably easier to restrict the privileges of any HTML generated by scripts on the client side. Beginning with Internet Explorer 8, Microsoft offers a simple and somewhat inflexible <span class="emphasis"><em>toStaticHTML(...)</em></span> API,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-14">253</a>]</sup> which promises to remove JavaScript from any fully qualified bit of HTML passed to it as a parameter. The output of this method is designed to be safe to assign to the <span class="emphasis"><em>innerHTML</em></span> property somewhere in the existing DOM.<sup>[<a class="footnote" href="#ftn.CHP-16-FN-9" id="CHP-16-FN-9">85</a>]</sup></p><p>Microsoft’s proposal is fine, but it dances around the most common and problematic task of safely displaying server-supplied documents. And its API has a minor but entirely unnecessary weakness: It makes it unexpectedly dangerous to trim or concatenate the sanitized <span class="emphasis"><em>toStaticHTML(...)</em></span> output after the call but before the <span class="emphasis"><em>innerHTML</em></span> assignment, a practice that many web developers will probably attempt. A more sensible approach would be to allow content sanitization only upon assignment to <span class="emphasis"><em>innerHTML</em></span>. In fact, WebKit engineers briefly discussed a proposal for such an API (alternately named <span class="emphasis"><em>innerStaticHTML</em></span> or <span class="emphasis"><em>safeInnerHTML</em></span>), but the effort seems to have fizzled out long ago.<a class="indexterm" id="IDX-CHP-16-0100"/><a class="indexterm" id="IDX-CHP-16-0101"/><a class="indexterm" id="IDX-CHP-16-0102"/><a class="indexterm" id="IDX-CHP-16-0103"/><a class="indexterm" id="IDX-CHP-16-0104"/><a class="indexterm" id="IDX-CHP-16-0105"/></p></div><div class="sect2" title="XSS Filtering"><div class="titlepage"><div><div><h2 class="title"><a id="xss_filtering"/>XSS Filtering</h2></div></div></div><p>Reducing the incidence of cross-site vulnerabilities is difficult, and so is limiting their impact. Because of this, some researchers have concluded that detecting and stopping the exploitation of such flaws may be a better choice. And so, around 2008, David Ross of Microsoft announced the inclusion of XSS-detection logic in the upcoming release of Internet Explorer 8;<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-15">254</a>]</sup> several months later, Adam Barth implemented a similar feature in WebKit. The implementations compare portions of the current URL with any strings appearing on the retrieved page or passed to APIs such as <span class="emphasis"><em>document.write(...)</em></span> and <span class="emphasis"><em>innerHTML</em></span>. If that comparison reveals that a portion of JavaScript present on the page may have originated with an improperly escaped URL parameter, the relevant portion of the page may be substituted with a harmless string.<a class="indexterm" id="IDX-CHP-16-0106"/><a class="indexterm" id="IDX-CHP-16-0107"/></p><p>Sadly, this seemingly elegant idea is known to cause serious problems. Accidental false positives aside (users of Internet Explorer 8 will have unexpected trouble visiting <span class="emphasis"><em>http://www.google.com/search?q=&lt;script&gt;</em></span>), the filter may also be tripped for ill purposes by appending a legitimate portion of the page as a nonfunctional parameter in the URL. In one extreme and now resolved case, this behavior was leveraged to create XSS vectors where none had existed before, simply by tricking the browser into haphazardly rearranging the markup.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-16-FT-16">255</a>]</sup> But more fundamentally, it’s risky for any complex web application to selectively disable attacker-selected script blocks, even if the structure of the page is otherwise correctly preserved, and such a tweak may easily put the client-side code in an inconsistent or dangerous state. For example, consider an online document editor that implements each of the following in a separate <span class="emphasis"><em>&lt;script&gt;</em></span> block:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Initializes the internal state of the editor and creates the UI with an empty starting document.</p></li><li class="listitem"><p>Loads the current version of the document requested by the user in a URL parameter with error checking to catch any potential network problems.</p></li><li class="listitem"><p>If no errors are detected, enters an interactive editing mode and automatically saves the current state of the document every 30 seconds under the URL-derived ID.</p></li></ol></div><p>In this not entirely unreasonable design, the ability to remove step two can be disastrous because the next step could overwrite the existing, server-stored document with a blank copy. D’oh.</p><p>This problem could have been avoided by using much simpler design whereby any suspected XSS attacks would result in the browser simply refusing to render the document. Alas, the relatively high incidence of accidental false positives prevented the authors from taking this route. Only after some debate did Microsoft decide to offer a “strict” blocking mode on an opt-in basis, toggled by a response header such as this:</p><a id="I_programlisting1_d1e18878"/><pre class="programlisting">XSS-Protection: 1; mode=block</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>In addition to the risk of false positives, XSS filters are also prone to false negatives, a situation that probably can’t be improved by much. By design, these filters will never be able to detect the arguably more dangerous stored XSS vulnerabilities, where incorrectly escaped data comes from a source other than the followed link. But even beyond that, the multitude of (often implicit) input escaping schemes and the growing use of <span class="emphasis"><em>location.hash</em></span> or <span class="emphasis"><em>pushState</em></span> (<a class="xref" href="ch17.html" title="Chapter 17. Other Browser Mechanisms of Note">Chapter 17</a>) as a method to store application state make it difficult to formulate an accurate connection between what the browser sees in the address bar and what the application makes of the received URL.</p></div><div class="sidebar"><a id="security_engineering_cheat_sheet-id14"/><p class="title">Security Engineering Cheat Sheet</p><p>Approach experimental browser security features with care, particularly when dealing with mechanisms that create finer-grained security boundaries. Ensure that any application leveraging these mechanisms will degrade safely in a noncompliant browser.<a class="indexterm" id="IDX-CHP-16-0108"/><a class="indexterm" id="IDX-CHP-16-0109"/><a class="indexterm" id="IDX-CHP-16-0110"/><a class="indexterm" id="IDX-CHP-16-0111"/><a class="indexterm" id="IDX-CHP-16-0112"/><a class="indexterm" id="IDX-CHP-16-0113"/><a class="indexterm" id="IDX-CHP-16-0114"/><a class="indexterm" id="IDX-CHP-16-0115"/><a class="indexterm" id="IDX-CHP-16-0116"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bolditalic">Cross-domain XMLHttpRequest (CORS):</span> Fairly safe, but easy to misuse. Avoid non-simple requests and do not permit arbitrary headers or methods. If you have control over the server-side application framework, consider automatically stripping <span class="emphasis"><em>Cookie</em></span> headers on incoming CORS requests with nonwhitelisted <span class="emphasis"><em>Origin</em></span> values to minimize the risk of accidentally sharing user-specific data. To minimize the incidence of mixed-content bugs, consider rejecting HTTPS <span class="emphasis"><em>Origin</em></span> values on any requests received over plain HTTP.<a class="indexterm" id="IDX-CHP-16-0117"/></p><p>Be wary of <span class="emphasis"><em>Access-Control-Allow-Origin: *</em></span>, and if you need to use it, make sure it is only returned for the location you intend to share.</p></li><li class="listitem"><p><span class="bolditalic">XDomainRequest:</span> This is safe to use. As with <span class="emphasis"><em>XMLHttpRequest</em></span>, restricting access to HTTP APIs from HTTPS origins may be a good way to stamp out mixed-content bugs.<a class="indexterm" id="IDX-CHP-16-0118"/></p></li><li class="listitem"><p><span class="strong"><strong>Content Security Policy:</strong></span> This is safe to use as defense in depth. Review the caveats related to the interactions among <span class="emphasis"><em>script-src</em></span>, <span class="emphasis"><em>object-src</em></span>, and so on, and the dangers of permitting <span class="emphasis"><em>data:</em></span> origins. Do not accidentally allow mixed content: Always specify protocols in the rulesets and make sure they match the protocol the requesting page is served over.</p></li><li class="listitem"><p><span class="strong"><strong>Sandboxed frames:</strong></span> This is safe to use as a way to embed gadgets from other origins, but the mechanism will fail dramatically in noncompliant browsers. You should not sandbox same-origin documents.<a class="indexterm" id="IDX-CHP-16-0119"/><a class="indexterm" id="IDX-CHP-16-0120"/></p></li><li class="listitem"><p><span class="strong"><strong>Strict Transport Security:</strong></span> This is safe to use as defense in depth. Be sure to mark all relevant cookies as <span class="emphasis"><em>secure</em></span> and be prepared for the possibility of cookie injection via spoofed, non-STS locations in your domain. Use <span class="emphasis"><em>includeSubDomains</em></span> where feasible to mitigate this risk.<a class="indexterm" id="IDX-CHP-16-0121"/></p></li><li class="listitem"><p><span class="bolditalic">toStaticHTML(...)</span>: This is safe to use where available, but it is difficult to substitute on the client side in noncompliant browsers. Bypass vulnerabilities have an above-average chance of recurring in the API due to the design of the filter.</p></li><li class="listitem"><p><span class="strong"><strong>Private browsing:</strong></span> Do not rely on this mechanism for security purposes.</p></li><li class="listitem"><p><span class="strong"><strong>XSS filtering:</strong></span> Do not rely on this mechanism for security purposes. Always explicitly specify <span class="emphasis"><em>XSS-Protection: 1; mode=block</em></span> or <span class="emphasis"><em>XSS-Protection: 0</em></span> in HTTP responses. The default is fairly unsafe.<a class="indexterm" id="IDX-CHP-16-0122"/><a class="indexterm" id="IDX-CHP-16-0123"/><a class="indexterm" id="IDX-CHP-16-0124"/></p></li></ul></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-16-FN-9" id="ftn.CHP-16-FN-9">85</a>] </sup>Amusingly, the HTML parser in Internet Explorer is apparently so obtuse that even the authors of <span class="emphasis"><em>toStaticHTML(...)</em></span> had some trouble following it. Since its introduction, the API has suffered from a fair number of bypass vulnerabilities, most frequently related to the handling of CSS data.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;17.&#xA0;Other Browser Mechanisms of Note"><div class="titlepage"><div><div><h1 class="title"><a id="other_browser_mechanisms_of_note"/>Chapter 17. Other Browser Mechanisms of Note</h1></div></div></div><p>To conclude the third part of the book, we briefly enumerate some of the recently implemented or simply planned APIs that, although not designed for security purposes, may substantially change the security landscape in the coming years. For example, some change the types of data that web applications have access to or alter the way the browser communicates with the outside world.</p><p>The following list is necessarily incomplete: New, reasonably plausible designs are drafted every week, and old approaches are scrapped at a moment’s notice, often long before shipping in an actual browser. Still, this chapter should serve as an interesting snapshot of what the future may bring.</p><div class="sect1" title="URL- and Protocol-Level Proposals"><div class="titlepage"><div><div><h1 class="title"><a id="url-_and_protocol-level_proposals"/>URL- and Protocol-Level Proposals</h1></div></div></div><p>These features seek to change the processes surrounding the behavior of links, the address bar, and the exchange of data over the wire.<a class="indexterm" id="IDX-CHP-17-0001"/><a class="indexterm" id="IDX-CHP-17-0002"/><a class="indexterm" id="IDX-CHP-17-0003"/><a class="indexterm" id="IDX-CHP-17-0004"/><a class="indexterm" id="IDX-CHP-17-0005"/><a class="indexterm" id="IDX-CHP-17-0006"/><a class="indexterm" id="IDX-CHP-17-0007"/><a class="indexterm" id="IDX-CHP-17-0008"/><a class="indexterm" id="IDX-CHP-17-0009"/><a class="indexterm" id="IDX-CHP-17-0010"/><a class="indexterm" id="IDX-CHP-17-0011"/><a class="indexterm" id="IDX-CHP-17-0012"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Protocol registration</strong></span></span></dt><dd><p>Web applications commonly assume the handling of URL schemes previously reserved for “real” desktop software. One prime example of this may be the <span class="emphasis"><em>mailto:</em></span> protocol, which was originally meant to instantiate a stand-alone mail application but which is often more sensibly routed to webmail interfaces today. To this end, Mozilla proposed and WebKit embraced a simple <span class="emphasis"><em>navigator.registerProtocolHandler(...)</em></span> API.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-1">256</a>]</sup> When this API is invoked, the user is presented with a simple security prompt, and if the action is approved, a URL-based handler is associated with a particular scheme. As of today, the associated prompts are vulnerable to the race conditions outlined in <a class="xref" href="ch14.html" title="Chapter 14. Dealing with Rogue Scripts">Chapter 14</a>, and they seem to be lacking in other ways, as shown in <a class="xref" href="ch17.html#a_seriously_confusing_prompt_in_firefox" title="Figure 17-1. A seriously confusing prompt in Firefox. The prompt shown in the upper area of the browser window was generated by the browser in response to a call to the registerProtocolHandler(...) API, with the protocol name set to “doing really awesome stuff” and application name set to “Firefox (mozilla.org)”. This particular example is harmless, but more sinister abuse is within reach.">Figure 17-1</a>.</p><div class="figure"><a id="a_seriously_confusing_prompt_in_firefox"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e19133"/><img alt="A seriously confusing prompt in Firefox. The prompt shown in the upper area of the browser window was generated by the browser in response to a call to the registerProtocolHandler(...) API, with the protocol name set to “doing really awesome stuff” and application name set to “Firefox (mozilla.org)”. This particular example is harmless, but more sinister abuse is within reach." src="httpatomoreillycomsourcenostarchimages950045.png.jpg"/></div></div><p class="title">Figure 17-1. A seriously confusing prompt in Firefox. The prompt shown in the upper area of the browser window was generated by the browser in response to a call to the <span class="emphasis"><em>registerProtocolHandler(...)</em></span> API, with the protocol name set to “doing really awesome stuff” and application name set to “Firefox (mozilla.org)”. This particular example is harmless, but more sinister abuse is within reach.</p></div></dd><dt><span class="term"><span class="strong"><strong>Address bar manipulation</strong></span></span></dt><dd><p>The newly introduced HTML5 <span class="emphasis"><em>history.pushState(...)</em></span> API,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-2">257</a>]</sup> supported by Firefox, WebKit, and Opera, permits the currently displayed document to change the contents of the address bar to any other same-origin URL, without actually triggering a page transition normally associated with this step. The API offers a superior alternative to the widespread abuse of <span class="emphasis"><em>location.hash</em></span> to store application state. Interestingly, despite its simplicity, it has already led to a fair number of interesting security bugs. For example, some implementations briefly allowed not only the top-level document but also any dodgy third-party frames to change the top-level URL shown in the address bar, and they permitted origins such as <span class="emphasis"><em>about:blank</em></span> to put largely unconstrained gibberish in the URL field.<a class="indexterm" id="IDX-CHP-17-0013"/><a class="indexterm" id="IDX-CHP-17-0014"/><a class="indexterm" id="IDX-CHP-17-0015"/><a class="indexterm" id="IDX-CHP-17-0016"/><a class="indexterm" id="IDX-CHP-17-0017"/><a class="indexterm" id="IDX-CHP-17-0018"/><a class="indexterm" id="IDX-CHP-17-0019"/><a class="indexterm" id="IDX-CHP-17-0020"/></p></dd><dt><span class="term"><span class="strong"><strong>Binary HTTP</strong></span></span></dt><dd><p>SPDY<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-3">258</a>]</sup> (“Speedy”) is a simple, encrypted drop-in replacement for HTTP that preserves the protocol’s key design principles (including the layout and function of most headers). At the same time, it mini- mizes the overhead associated with delivering concurrent requests or with the parsing of text-based requests and response data. The protocol is currently supported only in Chrome, and other than select Google services, it is not commonly encountered on the Web. It may be coming to Firefox soon, too, however.</p></dd><dt><span class="term"><span class="strong"><strong>HTTP-less networking</strong></span></span></dt><dd><p>WebSocket<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-4">259</a>]</sup> is a still-evolving API designed for negotiating largely unconstrained, bidirectional TCP streams for when the transactional nature of TCP gets in the way (e.g., in the case of a low-latency chat application). The protocol is bootstrapped using a keyed challenge-response handshake, which looks sort of like HTTP and which is (quite remarkably) impossible to spoof by merely exploiting a header-splitting flaw in the destination site. Following a successful handshake, raw data may be exchanged bidirectionally within the resulting long-lived TCP connection, with each message enveloped inside a simple protocol frame. The mechanism is supported in WebKit and is probably coming soon to Firefox.</p></dd><dt><span class="term"><span class="strong"><strong>P2P networking</strong></span></span></dt><dd><p>WebRTC<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-5">260</a>]</sup> is a proposed set of APIs and network protocols designed to facilitate the discovery of and communication with other browsers without the need for a centralized server infrastructure. The primary use case for such a protocol is the implementation of IP telephony and video-conferencing features within web apps. No stable browser support is available yet.<a class="indexterm" id="IDX-CHP-17-0021"/></p></dd><dt><span class="term"><span class="strong"><strong>Offline applications</strong></span></span></dt><dd><p>Cache manifests<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-6">261</a>]</sup> are a relatively simple way for a web server to instruct the browser that copies of certain documents should be stored indefinitely and reused whenever the client appears to have no network connectivity. In conjunction with client-side storage mechanisms such as <span class="emphasis"><em>localStorage</em></span> (<a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a>), this allows certain self-sufficient JavaScript applications to be used in offline mode. Offline operation is supported in Firefox, the WebKit browser, and Opera. As with <span class="emphasis"><em>localStorage</em></span>, the persistent nature of this mechanism could exacerbate the long-term consequences of visiting an untrusted network.<a class="indexterm" id="IDX-CHP-17-0022"/></p></dd><dt><span class="term"><span class="strong"><strong>Better cookies</strong></span></span></dt><dd><p><span class="emphasis"><em>Cake</em></span><sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-7">262</a>]</sup> is a now-expired proposal drafted by Adam Barth that aims to create a more lightweight and secure alternative to HTTP cookies: one origin-bound, browser-generated nonce for every destination site. A more current but incomplete proposal appears to flirt with normal but origin-based cookies as an alternative. Neither approach is available in any browser today.<a class="indexterm" id="IDX-CHP-17-0023"/></p></dd></dl></div></div></div>
<div class="sect1" title="Content-Level Features"><div class="titlepage"><div><div><h1 class="title"><a id="content-level_features"/>Content-Level Features</h1></div></div></div><p>The proposals outlined in this section aim to enable new classes of web applications to be built on top of HTML and JavaScript.<a class="indexterm" id="IDX-CHP-17-0024"/><a class="indexterm" id="IDX-CHP-17-0025"/><a class="indexterm" id="IDX-CHP-17-0026"/><a class="indexterm" id="IDX-CHP-17-0027"/><a class="indexterm" id="IDX-CHP-17-0028"/><a class="indexterm" id="IDX-CHP-17-0029"/><a class="indexterm" id="IDX-CHP-17-0030"/><a class="indexterm" id="IDX-CHP-17-0031"/><a class="indexterm" id="IDX-CHP-17-0032"/><a class="indexterm" id="IDX-CHP-17-0033"/><a class="indexterm" id="IDX-CHP-17-0034"/><a class="indexterm" id="IDX-CHP-17-0035"/><a class="indexterm" id="IDX-CHP-17-0036"/><a class="indexterm" id="IDX-CHP-17-0037"/><a class="indexterm" id="IDX-CHP-17-0038"/><a class="indexterm" id="IDX-CHP-17-0039"/><a class="indexterm" id="IDX-CHP-17-0040"/><a class="indexterm" id="IDX-CHP-17-0041"/><a class="indexterm" id="IDX-CHP-17-0042"/><a class="indexterm" id="IDX-CHP-17-0043"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Client-side databases</strong></span></span></dt><dd><p>Several APIs for creating and manipulating locally stored databases have been proposed over the years, including the notorious <span class="emphasis"><em>WebSQL</em></span> API,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-8">263</a>]</sup> which would have brought the famously dangerous SQL syntax to client-side JavaScript. The WebSQL proposal was ditched in favor of a more sensible <span class="emphasis"><em>IndexedDB</em></span> design,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-9">264</a>]</sup> which offers a clean API without serialized queries and has a security model comparable to that of <span class="emphasis"><em>localStorage</em></span>—but not until WebSQL support had shipped in a couple of browsers. Meanwhile, the new API has shipped in Chrome and is expected to appear in Firefox.</p></dd><dt><span class="term"><span class="strong"><strong>Background processes</strong></span></span></dt><dd><p>The <span class="emphasis"><em>Worker</em></span> API,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-10">265</a>]</sup> available in Firefox, WebKit, and Opera, permits the creation of background JavaScript processes to perform computationally expensive tasks without having to worry about blocking the browser UI. Each worker runs in an isolated environment that lacks the usual <span class="emphasis"><em>window</em></span> or <span class="emphasis"><em>document</em></span> DOM and may communicate with its creator asynchronously through the <span class="emphasis"><em>postMessage(...)</em></span> API. <span class="emphasis"><em>Dedicated workers</em></span> are directly reachable only by their creator, while <span class="emphasis"><em>shared workers</em></span> may be “attached” to several different sites at any given time. (<span class="emphasis"><em>Persistent workers</em></span>, which would run independently of any sustained demand for their services, were proposed early on but then dropped.) The concept of worker threads raises some peripheral DoS concerns but otherwise poses no apparent security risks.</p></dd><dt><span class="term"><span class="strong"><strong>Geolocation discovery</strong></span></span></dt><dd><p>The <span class="emphasis"><em>navigator.geolocation.getCurrentPosition(...)</em></span> API<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-11">266</a>]</sup> permits any website to request information about the physical location of the client device, subject to a user’s (largely hijackable) consent. The computed geolocation data may be derived from GPS information on a system with a suitable hardware module, or it may be looked up based on the names of nearby wireless access points, cell towers, and so forth. The API is supported in all major browsers except for Internet Explorer.</p></dd><dt><span class="term"><span class="strong"><strong>Device orientation</strong></span></span></dt><dd><p>A nonrestricted event-driven <span class="emphasis"><em>DeviceOrientation</em></span> API<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-12">267</a>]</sup> allows websites to read back the orientation of the device, based on accelerometer data. This API, which is probably geared toward mobile gaming, is available in Firefox, WebKit, and Opera on systems equipped with the appropriate hardware. Two researchers at the University of California, Davis have recently demonstrated a fatal flaw: On smartphones, minute movements of the device may be used to reliably reconstruct on-screen keyboard input, including passwords entered on unrelated websites.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-13">268</a>]</sup></p></dd><dt><span class="term"><span class="strong"><strong>Page prerendering</strong></span></span></dt><dd><p>This experimental feature in Chrome allows pages to be prefetched in anticipation of the user following a particular link, and it permits the entire HTML document to be prerendered in a hidden tab<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-14">269</a>]</sup> and momentarily revealed once the predicted navigation action takes place. The mechanism has some interesting browser security consequences if the prerendered page turns out to be malicious. The implementation in Chrome is careful to defer any disruptive actions until the tab is revealed, but mistakes will be very easy to make across all browser codebases.<a class="indexterm" id="IDX-CHP-17-0044"/><a class="indexterm" id="IDX-CHP-17-0045"/><a class="indexterm" id="IDX-CHP-17-0046"/><a class="indexterm" id="IDX-CHP-17-0047"/><a class="indexterm" id="IDX-CHP-17-0048"/><a class="indexterm" id="IDX-CHP-17-0049"/><a class="indexterm" id="IDX-CHP-17-0050"/><a class="indexterm" id="IDX-CHP-17-0051"/></p></dd><dt><span class="term"><span class="strong"><strong>Navigation timing</strong></span></span></dt><dd><p>Several complementary APIs, currently available only in Chrome, permit certain types of navigation, including cross-domain page loads, to be very accurately benchmarked from client-side JavaScript.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-15">270</a>]</sup> This interface is designed to allow site owners to identify obvious performance bottlenecks, as experienced by a typical visitor. The API allows some privacy-related information to be collected by profiling the time needed to load certain third-party content, but because the same attack is possible in many other ways (for example with <span class="emphasis"><em>onload</em></span> handlers on subresources), that probably does not matter much.</p></dd></dl></div></div>
<div class="sect1" title="I/O Interfaces"><div class="titlepage"><div><div><h1 class="title"><a id="i_solidus_o_interfaces"/>I/O Interfaces</h1></div></div></div><p>The features listed below offer new input and output capabilities to web-based scripts.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>UI notifications</strong></span></span></dt><dd><p><span class="emphasis"><em>Notification</em></span> and <span class="emphasis"><em>window.notifications</em></span><sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-16">271</a>]</sup> APIs allow the creation of text-only or HTML-based, always-on-top pop-ups in the corner of the screen, allowing select web applications to gently notify users of important developments (such as a new mail message). User consent to receiving notifications is required on a per-site basis, limiting the risk of abuse. Nevertheless, care must be taken to properly communicate the origin of the tiny notification window and any dialogs or prompts it subsequently creates, an aspect that took some time to refine. The API is available only in WebKit today.<a class="indexterm" id="IDX-CHP-17-0052"/></p></dd><dt><span class="term"><span class="strong"><strong>Full-screen mode</strong></span></span></dt><dd><p>Several proposals have been circulated to allow JavaScript to maximize the current browser window and hide all the browser chrome. This functionality is essential to tasks such as viewing presentations or watching movies, but it is obviously very dangerous from the security standpoint: Once in control of the entire screen, any malicious page may draw a fake browser window with a fake address bar. So far, no specific implementation seems to be available for review. An early-stage proposal for mouse cursor locking is being discussed, too.</p></dd><dt><span class="term"><span class="strong"><strong>Media capture</strong></span></span></dt><dd><p>A proposed suite of <span class="emphasis"><em>navigator.device.capture</em></span> APIs<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-17-FT-17">272</a>]</sup> has been postulated for giving websites access to webcam and microphone data. Obvious security and privacy concerns arise around this mechanism, especially around the resilience of any associated security prompts with respect to race condition attacks. The API has no stable browser support today.</p></dd></dl></div></div></body></html>