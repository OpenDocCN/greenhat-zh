<html><head></head><body><section class="chapter" epub:type="chapter" id="securing_your_system" title="Chapter&#xA0;10.&#xA0;Securing Your System"><div class="titlepage"><div><div><h2 class="title">Chapter 10. Securing Your System</h2></div></div></div><div class="epigraph" epub:type="epigraph"><div class="literallayout"><p><span class="emphasis"><em>Hackers at the gates?</em></span><br/>
<span class="emphasis"><em>Puffy the Barbarian</em></span><br/>
<span class="emphasis"><em>defends against fiends.</em></span></p></div></div><p><a class="indexterm" id="idx2063"/><span class="inlinemediaobject"><a id="inline_id00011"/><img alt="" src="httpatomoreillycomsourcenostarchimages1616079.png"/></span> Securing your system means ensuring that your computer’s resources are used only by authorized people and for authorized purposes. Even if a system has no important data, it still has valuable CPU time, memory, storage, and bandwidth. People who think that their systems are too unimportant for anyone to bother breaking into risk finding their equipment hosting pornography or relaying attacks against industrial or military sites. If you’re like me, you would rather not discover that your computers took down a government agency by having law enforcement agents kick in your door.</p><p>Taking over large numbers of remote computers gets easier all the time. Every year, more and more point-and-click toolkits for penetrating servers crop up. When one bright attacker posts an exploit, anyone can use it. Breaking into computers is big business, and if your computer is left unprotected, it <span class="emphasis"><em>will</em></span> be penetrated. The only question is how.</p><p><a class="indexterm" id="idx0192"/><a class="indexterm" id="idx1616"/><a class="indexterm" id="idx2028"/><a class="indexterm" id="idx2064"/>Generally speaking, intruders don’t break into operating systems; they break into server programs running on the operating system. Even the most paranoiac, secure-by-default operating system cannot protect poorly written programs from themselves. OpenBSD features like W^X and address space layout randomization do a lot to protect the operating system from the side effects of buggy programs, but programs themselves still crash and burn. OpenBSD has undergone extensive auditing and testing to eliminate the most common security flaws, but there’s no guarantee that every security flaw has been eradicated. New features appear constantly, and can interact with older functions (and each other) in unexpected ways. For more details on the OpenBSD-specific features, check the papers and presentations collection at <span class="emphasis"><em><a class="ulink" href="http://www.OpenBSD.org/papers/" target="_top">http://www.OpenBSD.org/papers/</a></em></span>.</p><p>No single tool can protect your server against all threats, and no single tool is applicable to all environments. Learning about OpenBSD’s security features helps you to understand not only what the tools do, but when they should be used and when they won’t help your particular situation. The best place to start is by understanding the threat.</p><div class="sect1" title="Who Is the Enemy?"><div class="titlepage"><div><div><h2 class="title" id="who_is_the_enemy" style="clear: both">Who Is the Enemy?</h2></div></div></div><p>Books dedicated to security break attackers down into smaller, more specific groups and include various edge cases, but that’s not what you’re here for. I lump potential attackers into four groups: script kiddies, botnets, disaffected users, and skilled attackers. These categories are easily understood and include 99 percent of all the attackers you’re likely to encounter.</p><div class="sect2" title="Script Kiddies"><div class="titlepage"><div><div><h3 class="title" id="script_kiddies">Script Kiddies</h3></div></div></div><p>The most common type of attackers, script kiddies, are not sysadmins. They are amateurs who download attack scripts and go looking for poorly defended, vulnerable systems.</p><p>Script kiddies are easy to defend against: Keep your software up-to-date and follow good computing practices. Like locusts, script kiddies are easy to squash, but there are just so darned <span class="emphasis"><em>many</em></span> of the little buggers!</p></div><div class="sect2" title="Botnets"><div class="titlepage"><div><div><h3 class="title" id="botnets">Botnets</h3></div></div></div><p>Botnets are composed of machines compromised by worms or viruses and are controlled from a central point. The botnet’s controllers might use the victim machines to search for more vulnerable hosts, to send spam, or to break into secure sites. Most botnets are composed of Windows or Linux machines, but there’s no reason why such a worm couldn’t target OpenBSD. The virus author would need to work hard, but it’s conceivable—if he finds a suitable security flaw.</p><p>Fortunately, botnet defense is much like script kiddie defense. You shouldn’t have much to worry about if you keep your software patched, configure your server software securely, and follow good computing practices.</p></div><div class="sect2" title="Disaffected Users"><div class="titlepage"><div><div><h3 class="title" id="disaffected_users">Disaffected Users</h3></div></div></div><p><a class="indexterm" id="idx0036"/><a class="indexterm" id="idx0071"/><a class="indexterm" id="idx2153"/><a class="indexterm" id="idx2553"/>Security pundits commonly claim that a system’s legitimate users cause the majority of security problems.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id385498" id="id385498">26</a>]</sup> Legitimate users are most likely to know where your security gaps are, to feel that the system rules don’t apply to them, and to have the necessary access and time to experiment with breaking your security. If you tell an employee that company policy forbids him access to a computer resource, and the employee feels that he <span class="emphasis"><em>should</em></span> have access to it, he is likely to search for a way around the restriction. You can patch all of your servers and protect them with an outright hostile firewall, but if someone has physical access and knows the root password, your protections are useless.</p><p>Deal with this problem on two levels. The first is technical: Keep your servers patched and up-to-date. The second is human: Don’t leave projects half finished or half documented. That unsecured modem you installed for emergency incoming access until the VPN is solid? Get rid of it, or put a password on it. Ditto for that telnet server running on a nonstandard port.</p><p>Security by obscurity is feeble at best. When a privileged user leaves the company, immediately disable his account, change all administrative passwords, inform employees of the person’s departure, and remind them not to share confidential information with that person. Implement a computer security policy with real penalties for violations. If you have a Human Resources department, get the staff members to agree to the policy and insist they enforce it.</p><p>What’s the best way to protect yourself against the disaffected user? Don’t be lazy.</p></div><div class="sect2" title="Skilled Attackers"><div class="titlepage"><div><div><h3 class="title" id="skilled_attackers">Skilled Attackers</h3></div></div></div><p>As the most dangerous group, skilled attackers are competent system administrators, security researchers, penetration specialists, and criminals who want access to specific resources. Taking over computers is a lucrative business these days. Sending junk email or launching distributed denial-of-service attacks can bring in large sums of money. These intruders don’t care who they attack, as long as they secure the computing resources they need.</p><p>If your company has valuable secrets, however, you might attract an entirely different type of intruder: someone who wants access to your network in particular. If your employer creates anything—from software to cast-iron tulips for front-wheel-drive vehicles—there’s likely a market for illicit copies of your product. Someone will find it worthwhile to probe every port on every IP address you expose to the Internet. It might take a long time, but that’s okay. Your data has a price tag, and the scan is cheap. This is often called the advanced persistent threat, or APT.</p><p><a class="indexterm" id="idx0934"/><a class="indexterm" id="idx1348"/><a class="indexterm" id="idx1615"/><a class="indexterm" id="idx2068"/><a class="indexterm" id="idx2077"/>Security measures that stop the other types of intruders affect the techniques used by skilled attackers. If you’ve ditched that unsecured inbound access method, the intruder can’t find it. If your servers and programs are up to date and correctly configured, the intruder will need to find a previously unknown exploit to break into your network. If a skilled intruder really wants <span class="emphasis"><em>your</em></span> company’s data, he will need to change tactics. Maybe he will try dumpster diving for old sticky notes, or even show up dressed as a telco repairman and try to install a packet sniffer. If an intruder knows everything about your network and his easiest way to break in is <span class="emphasis"><em>still</em></span> something out of a caper film, your security is pretty good.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note01"/>Note</h3><p>The word hacker has different meanings depending on who is talking. In the technical world, a hacker is someone not only interested in the inner workings of technology but also capable of creating new technology. The media has transformed the word to mean “someone who breaks into computers.” I recommend completely avoiding the word “hacker,” and using terms like “intruder” or “gravy sucking pig-dog” instead. When to use each is up to you, of course.</p></div></div></div><div class="sect1" title="OpenBSD Security Announcements"><div class="titlepage"><div><div><h2 class="title" id="openbsd_security_announcements" style="clear: both">OpenBSD Security Announcements</h2></div></div></div><p>Your best line of defense against all types of intruders is keeping your computer software up to date. This means you need to know when to update your system and what to update. The OpenBSD Project maintains a low-traffic mailing list, <span class="emphasis"><em>security-announce@OpenBSD.org</em></span>, specifically to broadcast new security alerts to users. Subscribe to this list.</p><p>If you don’t feel like subscribing to yet another mailing list, these security alerts are also posted on OpenBSD-specific sites such as <span class="emphasis"><em><a class="ulink" href="http://www.undeadly.org" target="_top">http://www.undeadly.org</a></em></span>.</p><p>Note that this won’t get you security alerts for third-party software running on OpenBSD. You must get updates for those programs separately. Check the software’s website for details on how to get their security announcements. All the time you’ve spent securing your operating system will be wasted if someone hijacks the insecure web application you neglected to update.</p></div><div class="sect1" title="OpenBSD Memory Protection"><div class="titlepage"><div><div><h2 class="title" id="openbsd_memory_protection" style="clear: both">OpenBSD Memory Protection</h2></div></div></div><p>One of the most common intrusion paths is to attack what’s in the computer’s memory. If intruders can access memory that they shouldn’t be able to access, or if they can make a program access memory it shouldn’t, they have any number of ways to get into the system.</p><p>OpenBSD includes a whole bunch of security features for system memory that the sysadmin never actually sees. You don’t need to turn on the nonexecutable stack; it’s just there.</p><p><a class="indexterm" id="idx1887"/><a class="indexterm" id="idx1979"/><a class="indexterm" id="idx2662"/><a class="indexterm" id="idx2666"/>Some of these features appear only in OpenBSD. Some appeared first in OpenBSD, and then spread elsewhere. Some came from research papers. Others build on hardware features.</p><p>The OpenBSD team takes a more proactive attitude about security features than many other projects. As an example, consider the ProPolice deployment several years ago. ProPolice is a compiler feature that prevents certain classes of buffer overflows. When you enabled ProPolice in the early days, a lot of software could not be built. Even more software could be built, but it crashed when used. These failures were not ProPolice problems. ProPolice simply exposed programming errors in the software. But many users and developers said that “enabling ProPolice breaks all kinds of stuff, so don’t turn it on.”</p><p>The OpenBSD team enabled ProPolice by default in a development snapshot. What happened? Stuff—a lot of stuff—broke. Many third-party applications needed by OpenBSD users either could not build or would not run. Third-party application vendors started receiving bug reports from OpenBSD users who were able to say exactly how the software was broken. Software vendors started fixing bugs.</p><p>ProPolice didn’t cause these crashes; it merely exposed bugs. By enabling ProPolice by default, OpenBSD gave the free software world incentive to fix those bugs. Eventually, as the type of bugs revealed by ProPolice became less common, other operating systems also enabled ProPolice. OpenBSD’s willingness to take this step improved computer security as a whole.</p><p>If you closely follow OpenBSD development, expect to see more of this behavior. The OpenBSD team does what it considers most correct, not what is most convenient or easiest.</p><p>The common memory security features you should know about include W^X, .rodata segments, guard pages, randomized memory allocations, ProPolice, and protecting <code class="literal">atexit</code> and <code class="literal">stdio</code>. We’ll cover each in turn.</p><div class="sect2" title="W^X"><div class="titlepage"><div><div><h3 class="title" id="w_x">W^X</h3></div></div></div><p>W^X stands for Write Xor Execute. Once a program is loaded, that program’s pages in memory are either writable or executable, but not both.</p><p>A common exploit technique is to trick a program into writing information to memory, and then executing that piece of memory. An attacker might convince a program to write to a chunk of memory, but the kernel will not allow that memory to be executed.</p><p>Some hardware platforms (such as amd64) have hardware support for W^X. If that support exists, OpenBSD uses it.</p></div><div class="sect2" title=".rodata Segments"><div class="titlepage"><div><div><h3 class="title" id="rodata_segments">.rodata Segments</h3></div></div></div><p>A segment of memory containing program code traditionally had two parts: actual code and read-only data, or <span class="emphasis"><em>.rodata segments</em></span>. In the past, some operating systems allowed programs to modify read-only memory. OpenBSD prevents this by leveraging hardware features when available.</p></div><div class="sect2" title="Guard Pages"><div class="titlepage"><div><div><h3 class="title" id="guard_pages">Guard Pages</h3></div></div></div><p><a class="indexterm" id="idx0029"/><a class="indexterm" id="idx0081"/><a class="indexterm" id="idx0223"/><a class="indexterm" id="idx0933"/><a class="indexterm" id="idx1301"/><a class="indexterm" id="idx1888"/>Many pieces of software used to access memory beyond what they allocated. If a program writes to memory that doesn’t belong to it, it’s writing to memory that belongs to a different program. Intruders use this to exploit programs. A <span class="emphasis"><em>guard page</em></span> is a single page of memory next to the memory allocated by a program. The program cannot write to this memory. If the program tries to write to the guard page, it probably will crash. By enforcing this limit, OpenBSD protects other programs.</p><p>Using guard pages everywhere would use a lot of memory, so OpenBSD enables guard pages only in carefully selected places.</p></div><div class="sect2" title="Address Space Layout Randomization"><div class="titlepage"><div><div><h3 class="title" id="address_space_layout_randomization">Address Space Layout Randomization</h3></div></div></div><p>Traditionally, computers allocate memory consecutively. This can give intruders certain advantages. If they know that program A usually loads after program B, and they know they can make program B write to memory space outside its allocation, they can guess that they can write to program A’s memory space and make program A fail in a predictable manner. Doing so requires a certain degree of skill, but once one person figures out this exploit, innumerable people can use it.</p><p>OpenBSD randomizes where it allocates memory. Two programs started one after the other don’t get consecutive memory blocks. The randomization is done intelligently, to avoid wasting memory. Intruders cannot use one program against another in this manner.</p></div><div class="sect2" title="ProPolice"><div class="titlepage"><div><div><h3 class="title" id="propolice">ProPolice</h3></div></div></div><p>ProPolice protects code against attacks that manipulate the memory stack. When code is compiled, ProPolice adds additional code to keep a program within its own area of memory. If ProPolice determines that specific areas of memory (called <span class="emphasis"><em>canaries</em></span>) have been changed, it immediately aborts the program. Where other memory protection techniques prevent writing to executable memory, ProPolice terminates a process when writable memory that <span class="emphasis"><em>can</em></span> be written to, but specifically <span class="emphasis"><em>should not</em></span>, is changed.</p></div><div class="sect2" title="And More!"><div class="titlepage"><div><div><h3 class="title" id="and_more">And More!</h3></div></div></div><p>OpenBSD includes a whole bunch of small memory guards scattered throughout. Here’s a small sampling:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">malloc()</code> and <code class="literal">atexit()</code> system calls mark memory nonwritable after updating it.</p></li><li class="listitem"><p>File descriptor handling has been carefully audited throughout.</p></li><li class="listitem"><p><code class="literal">snprintf</code> is async-signal-safe when no floats are involved.</p></li></ul></div><p>And the list continues.</p><p><a class="indexterm" id="idx0826"/><a class="indexterm" id="idx1755"/><a class="indexterm" id="idx2013"/><a class="indexterm" id="idx2023"/><a class="indexterm" id="idx2067"/><a class="indexterm" id="idx2354"/><a class="indexterm" id="idx2355"/><a class="indexterm" id="idx2469"/><a class="indexterm" id="idx2543"/>Could any of these be exploited in the real world? Some of them have, and some are just theoretical. But I would rather be protected against theoretical threats than assume no one can break something that has never been broken before.</p></div></div><div class="sect1" title="File Flags"><div class="titlepage"><div><div><h2 class="title" id="file_flags" style="clear: both">File Flags</h2></div></div></div><p>All Unix-like operating systems share a common permissions scheme, but OpenBSD (and most BSD-based operating systems) extends the permissions scheme with <span class="emphasis"><em>file flags</em></span>. File flags work with permissions to change file security. Flags can make a file unchangeable, make it so that existing data cannot be removed and users can only add to the file, and produce several other effects. Some flags have functions unrelated to security, but we’ll pay special attention to the security flags. File flags are listed and documented in <code class="literal">chflags(1)</code>.</p><div class="sect2" title="File Flag Types"><div class="titlepage"><div><div><h3 class="title" id="file_flag_types">File Flag Types</h3></div></div></div><p>Many file flags have different effects depending on the system securelevel, which we’ll cover in the next section. Understanding how securelevels work requires an understanding of file flags, while file flags rely on securelevels. For the moment, just nod and smile when I mention securelevels while discussing file flags. All will become clear, trust me.</p><p>OpenBSD’s UFS and UFS2 filesystems support the following file flags:</p><div class="blockquote" title="sappnd"><blockquote class="blockquote" title="sappnd"><div class="blockquote-title"><span class="strong"><strong><code class="literal">sappnd</code></strong></span></div><p>Files with the system-level append-only flag can be added to but cannot be removed or otherwise edited. The <code class="literal">sappnd</code> flag is particularly useful for log files. For example, a common intruder tactic is to remove <span class="emphasis"><em>.history</em></span> or symlink it to <span class="emphasis"><em>/dev/null</em></span> so that the administrator cannot see what happened. Setting <code class="literal">sappnd</code> on a user’s <span class="emphasis"><em>.history</em></span> file can be interesting if the account is compromised. Using the <code class="literal">sappnd</code> flag ensures that intruders cannot cover their tracks in this manner. Only root can set or remove the <code class="literal">sappnd</code> flag, and it cannot be removed when the system is running at securelevel 1 or higher.</p></blockquote></div><div class="blockquote" title="uappnd"><blockquote class="blockquote" title="uappnd"><div class="blockquote-title"><span class="strong"><strong><code class="literal">uappnd</code></strong></span></div><p>The user-level append-only flag can be set only by the file owner or root. As with <code class="literal">sappnd</code>, a file with the <code class="literal">uappnd</code> flag can be added to but not otherwise edited or removed. This is most useful for personal logs and files; it primarily adds an extra layer of protection against users accidentally deleting their own files. The owner or root can set or remove this flag.</p></blockquote></div><div class="blockquote" title="schg"><blockquote class="blockquote" title="schg"><div class="blockquote-title"><span class="strong"><strong><code class="literal">schg</code></strong></span></div><p>Files with the system-level immutable flag cannot be changed in any way. They cannot be edited, moved, replaced, or overwritten. Basically, the filesystem itself prevents all attempts to alter this file. Only root can set or remove this flag, and it cannot be removed when the system is running at securelevel 1 or higher.</p></blockquote></div><div class="blockquote" title="uchg"><blockquote class="blockquote" title="uchg"><div class="blockquote-title"><span class="strong"><strong><code class="literal">uchg</code></strong></span></div><p><a class="indexterm" id="idx0245"/><a class="indexterm" id="idx1249"/><a class="indexterm" id="idx1548"/><a class="indexterm" id="idx2470"/><a class="indexterm" id="idx2544"/>The user-level immutable flag prevents anyone from changing the file. It’s a user-level flag, so root can override it. This flag helps to prevent a file from being edited or removed by accident, but it’s not a way to secure the system. The owner or root can set or remove this flag at any securelevel.</p></blockquote></div><div class="blockquote" title="nodump"><blockquote class="blockquote" title="nodump"><div class="blockquote-title"><span class="strong"><strong><code class="literal">nodump</code></strong></span></div><p>The no dump flag tells <code class="literal">dump(8)</code> to not back up a file. Set this on files that don’t need to be backed up to tape. Check your backup program’s documentation to see if it honors this flag.</p></blockquote></div></div><div class="sect2" title="Setting, Viewing, and Removing File Flags"><div class="titlepage"><div><div><h3 class="title" id="setting_viewing_and_removing_file_flags">Setting, Viewing, and Removing File Flags</h3></div></div></div><p>Set file flags with <code class="literal">chflags(1)</code>. For example, if you are really worried about someone changing your kernel file, you could mark <span class="emphasis"><em>/bsd</em></span> with the system-level immutable flag.</p><a id="I_programlisting10_id455947"/><pre class="programlisting"># <span class="strong"><strong>chflags schg /bsd</strong></span></pre><p>This would prevent anyone—including you—from changing the kernel, reconfiguring the kernel, or upgrading the system.</p><p>You can also recursively change the file flags on an entire directory tree with the <code class="literal">-R</code> flag. If you wanted to make the entirety of <span class="emphasis"><em>/bin</em></span> immutable, you would run this command:</p><a id="I_programlisting10_id455971"/><pre class="programlisting"># <span class="strong"><strong>chflags -R schg /bin</strong></span></pre><p>And poof, you can no longer upgrade your system.</p><p>To view the flags on a file, use <code class="literal">ls -lo</code>.</p><a id="I_programlisting10_id455991"/><pre class="programlisting">$ <span class="strong"><strong>ls -lo vitallog</strong></span>
-rw-r--r-- 1 root wheel - 20915343 Jul 17 16:56 vitallog</pre><p>This file has no flags set on it. Let’s set the system-level append-only flag.</p><a id="I_programlisting10_id456005"/><pre class="programlisting">$ <span class="strong"><strong>chflags sappnd vitallog</strong></span>
chflags: vitallog: Operation not permitted</pre><p>Oh, right—only root can set system-level flags. Let’s try again:</p><a id="I_programlisting10_id456018"/><pre class="programlisting">$ <span class="strong"><strong>sudo chflags sappnd vitallog</strong></span>
Password:
$ <span class="strong"><strong>ls -lo vitallog</strong></span>
-rw-r--r-- 1 mwlucas mwlucas sappnd 20915343 Jul 17 16:56 vitallog</pre><p><a class="indexterm" id="idx2057"/>This file now has the <code class="literal">sappnd</code> flag. The system can add to it, but cannot otherwise edit or remove it.</p><p>OpenBSD doesn’t flag any files out of the box, so you’ll need to add flags yourself if you want them. Before you go nuts, however, note that adding file flags increases the overhead for system maintenance. If upgrading a system is hard, the sysadmin won’t want to do it. Is it more secure to have all your programs in <span class="emphasis"><em>/bin</em></span> immutable, or is it more secure to simplify upgrades, updates, and application of security patches?</p><p>To remove a flag from a file, use <code class="literal">chflags</code> with a <code class="literal">no</code> before the flag name. For example, to unset the <code class="literal">sappnd</code> flag on the <span class="emphasis"><em>vitallog</em></span> file, try this:</p><a id="I_programlisting10_id456080"/><pre class="programlisting">$ <span class="strong"><strong>sudo chflags noschg vitallog</strong></span>
Password:
chflags: vitallog: Operation not permitted</pre><p>Wait a minute! I’m running under <code class="literal">sudo(8)</code>, and I have root-level privileges. What’s going on?</p><p>By default, OpenBSD runs at securelevel 1. When running at securelevel 1 or higher, you cannot unset system-level file flags, so an attempt to do so failed. You can remove these flags only at securelevel -1 or in single-user mode. Read on to learn about securelevels.</p></div></div><div class="sect1" title="Securelevels"><div class="titlepage"><div><div><h2 class="title" id="securelevels" style="clear: both">Securelevels</h2></div></div></div><p><code class="literal">securelevel(7)</code> is a kernel setting to restrict actions the system can perform. The kernel behaves slightly differently as you raise the securelevel. For example, at low securelevels, the file flags discussed in the previous section can be removed; a file might be marked immutable, but you can remove the marker, delete or edit the file, and restore the flag. When you increase the securelevel, however, you can no longer remove the flag. Similar changes take place in other parts of the system. Taken as a whole, these changes might frustrate or stop an intruder.</p><p>Securelevel settings range from -1 to 2. Though OpenBSD runs at securelevel 1 by default, you can change this setting to fit your environment.</p><p>Higher securelevels make system maintenance difficult. Many actions taken during normal upgrades and administration are also things that intruders might do to cover their tracks. It might make sense for you to run a highly secure, stable server at securelevel 2, and run your experimental machine at -1. On the other hand, the OpenBSD folks don’t encourage changing from the default securelevel. Running your system at -1 may leave you open to attacks, while running at 2 complicates management and maintenance. Which securelevel you choose depends on your environment.</p><p>Despite the name, a securelevel is not an all-purpose general security dial. Arbitrarily increasing the securelevel will do nothing but annoy you and your users. While you can increase the securelevel at any time, you cannot reduce the securelevel without rebooting the system, so don’t experiment blindly.</p><div class="sect2" title="Setting the System Securelevel"><div class="titlepage"><div><div><h3 class="title" id="setting_the_system_securelevel">Setting the System Securelevel</h3></div></div></div><p><a class="indexterm" id="idx0189"/><a class="indexterm" id="idx0726"/><a class="indexterm" id="idx0764"/><a class="indexterm" id="idx1749"/><a class="indexterm" id="idx2299"/><a class="indexterm" id="idx2317"/>Set the boot-time securelevel in <span class="emphasis"><em>/etc/rc.securelevel</em></span>. In that file, you’ll find a line like this:</p><a id="I_programlisting10_id456204"/><pre class="programlisting">securelevel=1</pre><p>Change the <code class="literal">1</code> to your preferred securelevel. On your next reboot, the system will go to this securelevel when it enters multiuser mode. If you need to run a process before the boot process raises the securelevel, put the command to start the process in this file.</p><p>If you want to raise the securelevel without rebooting, adjust the <code class="literal">kern.securelevel sysctl(3)</code> to the desired value.</p><a id="I_programlisting10_id456225"/><pre class="programlisting"># <span class="strong"><strong>sysctl kern.securelevel=2</strong></span>
kern.securelevel: 1 -&gt; 2</pre><p>Remember that you cannot lower the securelevel of a running system. If a sysadmin could lower the securelevel, so could an intruder.</p></div><div class="sect2" title="Securelevel Definitions"><div class="titlepage"><div><div><h3 class="title" id="securelevel_definitions">Securelevel Definitions</h3></div></div></div><p>OpenBSD has four securelevels: -1, 0, 1 and 2. We’ll cover each in turn.</p><div class="sect3" title="Securelevel -1"><div class="titlepage"><div><div><h4 class="title" id="securelevel_-1">Securelevel -1</h4></div></div></div><p>Securelevel -1 is also called permanently insecure mode. The system isn’t necessarily insecure—it’s just that none of the securelevel protections are in place. I use securelevel -1 only to remove file flags that I never should have used in the first place.</p></div><div class="sect3" title="Securelevel 0"><div class="titlepage"><div><div><h4 class="title" id="securelevel_0">Securelevel 0</h4></div></div></div><p>Securelevel 0 is used only when the system is first booting. It offers no special features. When the system reaches multiuser mode, however, the securelevel is automatically raised to 1. Setting <code class="literal">securelevel=0</code> in <span class="emphasis"><em>/etc/rc.securelevel</em></span> is functionally equivalent to setting <code class="literal">securelevel=1</code>.</p></div><div class="sect3" title="Securelevel 1"><div class="titlepage"><div><div><h4 class="title" id="securelevel_1">Securelevel 1</h4></div></div></div><p>At securelevel 1, OpenBSD’s default, things become interesting.</p><p>The securelevel affects certain kernel configuration settings, called sysctls (covered in <a class="xref" href="ch18.html" title="Chapter 18. Kernel Configuration">Chapter 18</a>). Early in the boot process, OpenBSD uses the settings in <span class="emphasis"><em>/etc/sysctl.conf</em></span> to set sysctls. When I say that a particular sysctl cannot be changed, read that as “without altering the configuration and rebooting.”</p><p>Securelevel 1 implements the following limitations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>No one can write to the <span class="emphasis"><em>/dev/mem</em></span> and <span class="emphasis"><em>/dev/kmem</em></span> devices. Many security exploits work by writing to these devices.</p></li><li class="listitem"><p><a class="indexterm" id="idx0995"/><a class="indexterm" id="idx1156"/><a class="indexterm" id="idx1255"/><a class="indexterm" id="idx1258"/><a class="indexterm" id="idx1466"/><a class="indexterm" id="idx1853"/><a class="indexterm" id="idx2014"/><a class="indexterm" id="idx2024"/><a class="indexterm" id="idx2136"/><a class="indexterm" id="idx2202"/>The raw disk devices of all mounted file systems are read-only. (Writing to the raw devices of mounted filesystems would let you change files without regard to permissions.) Programs should access mounted filesystems only through the filesystem anyway, so this won’t change day-to-day operations.</p></li><li class="listitem"><p>The system-level file flags <code class="literal">schg</code> and <code class="literal">sappnd</code> cannot be removed.</p></li><li class="listitem"><p>Kernel modules cannot be loaded or unloaded. OpenBSD supports kernel modules, but the default kernel is monolithic. There’s no legitimate reason to load a kernel module on a running production system.</p></li><li class="listitem"><p>The sysctl <code class="literal">fs.posix.setuid</code> cannot be changed. By default, <code class="literal">chown(1)</code> clears the <code class="literal">setuid</code> and <code class="literal">setgid</code> bits on files when changing file permissions, as per the POSIX standard. You can override this by setting <code class="literal">fs.posix.setuid</code> to 0.</p></li><li class="listitem"><p>The sysctl <code class="literal">hw.allowpowerdown</code> cannot be changed. This controls the power button’s interaction with the system. When it’s set to 1, briefly pressing the power button shuts down the system cleanly. When it’s set to 0, the power button does not shut down the system. (You can still shut down the system by holding down the power button for several seconds, but that’s not a clean shutdown.) Not all platforms support this kind of shutdown or power management.</p></li><li class="listitem"><p>The sysctl <code class="literal">net.inet.ip.sourceroute</code> cannot be changed. Source routing is a technique to permit the sender of a packet to control which route the packet takes across the network. It’s caused many security problems, and its use is generally discouraged. OpenBSD ignores source routing by default. Setting <code class="literal">net.inet.ip.sourceroute</code> to 1 forces OpenBSD to pay attention to source routing.</p></li><li class="listitem"><p>The sysctl <code class="literal">machdep.kbdreset</code> cannot be changed. When set to 1, <code class="literal">machdep.kbdreset</code> allows the system to be cleanly rebooted using <span class="smallcaps">CTRL</span>-<span class="smallcaps">ALT</span>-<span class="smallcaps">DELETE</span>. When this sysctl is set to 0, the system ignores <span class="smallcaps">CTRL</span>-<span class="smallcaps">ALT</span>-<span class="smallcaps">DELETE</span>.</p></li><li class="listitem"><p>The <code class="literal">ddb.console</code> and <code class="literal">ddb.panic</code> sysctls may not be raised. Raising these sysctls enables certain kernel debugging options. Unauthorized users with physical access could gain unlimited system access through the debugger if they could raise these sysctls.</p></li><li class="listitem"><p>The sysctl <code class="literal">machdep.allowaperture</code> cannot be raised. If you want to use the X Window System (discussed in <a class="xref" href="ch17.html" title="Chapter 17. Desktop OpenBSD">Chapter 17</a>), you must allow X access to specific parts of kernel memory by enabling this sysctl early during the boot process. If you’re not running X, no one legitimately needs this access.</p></li><li class="listitem"><p>General-purpose input/output (GPIO) controllers cannot be further configured. GPIO controllers support a wide variety of special-purpose hardware. See <code class="literal">gpio(4)</code> and <code class="literal">gpioctl(8)</code> for details on each.</p></li></ul></div><p>These limitations have little effect on normal day-to-day operations, but they can interfere with debugging. If you’re trying to discover why your GPIO device isn’t working, you probably want to set your securelevel to -1.</p></div><div class="sect3" title="Securelevel 2"><div class="titlepage"><div><div><h4 class="title" id="securelevel_2">Securelevel 2</h4></div></div></div><p><a class="indexterm" id="idx2058"/><a class="indexterm" id="idx2060"/>Securelevel 2 is the highest securelevel in OpenBSD, and it disables a variety of features that you might need during normal maintenance. Use securelevel 2 only on a stable machine that you don’t expect to change much. If you need to change anything restricted by securelevel 2, you must reboot the machine.</p><p>Securelevel 2 includes everything from securelevel 1, plus the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Raw disk devices are always read-only. You cannot format, fdisk, or disklabel disks, even if they’re not in use.</p></li><li class="listitem"><p>The system clock cannot be moved backward, nor close to the overflow point. Make sure your system time is correct before entering multiuser mode!</p></li><li class="listitem"><p>You cannot alter packet-filtering rules (covered in <a class="xref" href="ch21.html" title="Chapter 21. Packet Filtering">Chapter 21</a> and <a class="xref" href="ch22.html" title="Chapter 22. Advanced PF">Chapter 22</a>). Packet filters, network address translation (NAT), traffic queues, and so on are immutable.</p></li><li class="listitem"><p>Kernel debugger sysctl values (those beginning with <code class="literal">ddb</code>) cannot be changed.</p></li></ul></div><p>So, for example, you don’t want your firewall at securelevel 2 unless you understand that packet filtering rules can change only with a reboot.</p></div></div><div class="sect2" title="What Securelevel Do You Need?"><div class="titlepage"><div><div><h3 class="title" id="what_securelevel_do_you_need">What Securelevel Do You Need?</h3></div></div></div><p>The securelevel appropriate for your environment depends entirely on your situation, but the overwhelming majority of the time, the default of securelevel 1 is most suitable.</p><p>If you are debugging and testing features and tools, you might find that you need to use securelevel -1 on a development machine. Once you’ve worked out how to configure your GPIO device or the correct debugger settings for your system, however, use securelevel 1 so that you mirror a production environment.</p><p>If you have a very stable system, you could try securelevel 2. In all my years of running OpenBSD, though, I’ve had only one system for which securelevel 2 was the right choice, and several cases where securelevel 2 created more trouble than it was worth.</p></div><div class="sect2" title="Securelevel Weaknesses"><div class="titlepage"><div><div><h3 class="title" id="securelevel_weaknesses">Securelevel Weaknesses</h3></div></div></div><p>What can’t securelevels do? Consider a case where someone compromises a web application on your server, uses that to bootstrap himself into a shell, and then uses the shell to bootstrap himself into root access. Securelevels don’t do anything to prevent this.</p><p>Unless you’ve made copious use of the <code class="literal">schg</code> flag, the intruder can replace system binaries with ones that send your authentication credentials to a free email account registered in a bogus name. So you decide to run around applying the <code class="literal">schg</code> flag to the contents of critical directories like <span class="emphasis"><em>/bin</em></span> and <span class="emphasis"><em>/usr/lib</em></span>. That will stop the bugger! Well, that will work as long as you make every file immutable, including the system configuration files in <span class="emphasis"><em>/etc</em></span> —you know, the ones that you need to change in order to do your job. If you leave one file unprotected, the intruder could add a command like <code class="literal">chflags -R noschg /</code> to an early part of the system startup, and poof—the next time you reboot your system, you unlock all your files. How often do you exhaustively audit your <span class="emphasis"><em>/etc</em></span> files? And you’ll need to undo this tangled morass every time you patch or upgrade your system!</p><p>This is only one possible path. There are many ways for an intruder to lever himself into the system. Relying on securelevels to protect you is unwise. Use them and consider them a tool in your kit, but don’t think they are a panacea for every problem.</p></div></div><div class="sect1" title="Keeping Secure"><div class="titlepage"><div><div><h2 class="title" id="keeping_secure" style="clear: both">Keeping Secure</h2></div></div></div><p>The tools discussed in this chapter are not OpenBSD’s only security features. The OpenBSD team has put a lot of work into securing every part of the system. But this chapter covers some things that make OpenBSD special and gives you an idea of how those features work.</p><p>What’s the best path to security? Keep your system updated and configure your server daemons securely. It’s boring, but it works.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.id385498"><p><sup>[<a class="para" href="#id385498">26</a>] </sup>I’ve seen too many botnet or script kiddie intrusions go undetected for months to be comfortable blaming legitimate users for the majority of security problems. I would agree that “insider intrusions” are the most commonly identified intrusions, but frequently, that’s because the guilty user can’t keep his mouth shut.</p></div></div></section></body></html>