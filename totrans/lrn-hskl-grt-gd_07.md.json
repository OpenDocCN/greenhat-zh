["```\ndata Bool = False | True\n```", "```\ndata Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647\n```", "```\ndata Shape = Circle Float Float Float | Rectangle Float Float Float Float\n```", "```\nghci> :t Circle\nCircle :: Float -> Float -> Float -> Shape\nghci> :t Rectangle\nRectangle :: Float -> Float -> Float -> Float -> Shape\n```", "```\narea :: Shape -> Float\narea (Circle _ _ r) = pi * r ^ 2\narea (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)\n```", "```\nghci> area $ Circle 10 20 10\n314.15927\nghci> area $ Rectangle 0 0 100 100\n10000.0\n```", "```\ndata Shape = Circle Float Float Float | Rectangle Float Float Float Float\n     deriving (Show)\n```", "```\nghci> Circle 10 20 5\nCircle 10.0 20.0 5.0\nghci> Rectangle 50 230 60 90\nRectangle 50.0 230.0 60.0 90.0\n```", "```\nghci> map (Circle 10 20) [4,5,6,6]\n[Circle 10.0 20.0 4.0,Circle 10.0 20.0 5.0,Circle 10.0 20.0 6.0,Circle 10.0\n20.0 6.0]\n```", "```\ndata Point = Point Float Float deriving (Show)\ndata Shape = Circle Point Float | Rectangle Point Point deriving (Show)\n```", "```\narea :: Shape -> Float\narea (Circle _ r) = pi * r ^ 2\narea (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)\n```", "```\nghci> area (Rectangle (Point 0 0) (Point 100 100))\n10000.0\nghci> area (Circle (Point 0 0) 24)\n1809.5574\n```", "```\nnudge :: Shape -> Float -> Float -> Shape\nnudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r\nnudge (Rectangle (Point x1 y1) (Point x2 y2)) a b\n    = Rectangle (Point (x1+a) (y1+b)) (Point (x2+a) (y2+b))\n```", "```\nghci> nudge (Circle (Point 34 34) 10) 5 10\nCircle (Point 39.0 44.0) 10.0\n```", "```\nbaseCircle :: Float -> Shape\nbaseCircle r = Circle (Point 0 0) r\n```", "```\nbaseRect :: Float -> Float -> Shape\nbaseRect width height = Rectangle (Point 0 0) (Point width height)\n```", "```\nghci> nudge (baseRect 40 100) 60 23\nRectangle (Point 60.0 23.0) (Point 100.0 123.0)\n```", "```\nmodule Shapes\n( Point(..)\n, Shape(..)\n, area\n, nudge\n, baseCircle\n, baseRect\n) where\n```", "```\ndata Person = Person String String Int Float String String deriving (Show)\n```", "```\nghci> let guy = Person \"Buddy\" \"Finklestein\" 43 184.2 \"526-2928\" \"Chocolate\"\nghci> guy\nPerson \"Buddy\" \"Finklestein\" 43 184.2 \"526-2928\" \"Chocolate\"\n```", "```\nfirstName :: Person -> String\nfirstName (Person firstname _ _ _ _ _) = firstname\n\nlastName :: Person -> String\nlastName (Person _ lastname _ _ _ _) = lastname\n\nage :: Person -> Int\nage (Person _ _ age _ _ _) = age\n\nheight :: Person -> Float\nheight (Person _ _ _ height _ _) = height\n\nphoneNumber :: Person -> String\nphoneNumber (Person _ _ _ _ number _) = number\n\nflavor :: Person -> String\nflavor (Person _ _ _ _ _ flavor) = flavor\n```", "```\nghci> let guy = Person \"Buddy\" \"Finklestein\" 43 184.2 \"526-2928\" \"Chocolate\"\nghci> firstName guy\n\"Buddy\"\nghci> height guy\n184.2\nghci> flavor guy\n\"Chocolate\"\n```", "```\ndata Person = Person { firstName :: String\n                     , lastName :: String\n                     , age :: Int\n                     , height :: Float\n                     , phoneNumber :: String\n                     , flavor :: String } deriving (Show)\n```", "```\nghci> :t flavor\nflavor :: Person -> String\nghci> :t firstName\nfirstName :: Person -> String\n```", "```\ndata Car = Car String String Int deriving (Show)\n```", "```\nghci> Car \"Ford\" \"Mustang\" 1967\nCar \"Ford\" \"Mustang\" 1967\n```", "```\ndata Car = Car { company :: String\n               , model :: String\n               , year :: Int\n               } deriving (Show)\n```", "```\nghci> Car {company=\"Ford\", model=\"Mustang\", year=1967}\nCar {company = \"Ford\", model = \"Mustang\", year = 1967}\n```", "```\ndata Maybe a = Nothing | Just a\n```", "```\nghci> Just 3 :: Maybe Int\nJust 3\n```", "```\nghci> Just \"Haha\"\nJust \"Haha\"\nghci> Just 84\nJust 84\nghci> :t Just \"Haha\"\nJust \"Haha\" :: Maybe [Char]\nghci> :t Just 84\nJust 84 :: (Num a) => Maybe a\nghci> :t Nothing\nNothing :: Maybe a\nghci> Just 10 :: Maybe Double\nJust 10.0\n```", "```\ndata IntMaybe = INothing | IJust Int\n\ndata StringMaybe = SNothing | SJust String\n\ndata ShapeMaybe = ShNothing | ShJust Shape\n```", "```\ndata Car = Car { company :: String\n               , model :: String\n               , year :: Int\n               } deriving (Show)\n```", "```\ndata Car a b c = Car { company :: a\n                     , model :: b\n                     , year :: c\n                     } deriving (Show)\n```", "```\ntellCar :: Car -> String\ntellCar (Car {company = c, model = m, year = y}) =\n    \"This \" ++ c ++ \" \" ++ m ++ \" was made in \" ++ show y\n```", "```\nghci> let stang = Car {company=\"Ford\", model=\"Mustang\", year=1967}\nghci> tellCar stang\n\"This Ford Mustang was made in 1967\"\n```", "```\ntellCar :: (Show a) => Car String String a -> String\ntellCar (Car {company = c, model = m, year = y}) =\n    \"This \" ++ c ++ \" \" ++ m ++ \" was made in \" ++ show y\n```", "```\nghci> tellCar (Car \"Ford\" \"Mustang\" 1967)\n\"This Ford Mustang was made in 1967\"\nghci> tellCar (Car \"Ford\" \"Mustang\" \"nineteen sixty seven\")\n\"This Ford Mustang was made in \\\"nineteen sixty seven\\\"\"\nghci> :t Car \"Ford\" \"Mustang\" 1967\nCar \"Ford\" \"Mustang\" 1967 :: (Num t) => Car [Char] [Char] t\nghci> :t Car \"Ford\" \"Mustang\" \"nineteen sixty seven\"\nCar \"Ford\" \"Mustang\" \"nineteen sixty seven\" :: Car [Char] [Char] [Char]\n```", "```\ndata (Ord k) => Map k v = ...\n```", "```\ndata Vector a = Vector a a a deriving (Show)\n\nvplus :: (Num a) => Vector a -> Vector a -> Vector a\n(Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n)\n\ndotProd :: (Num a) => Vector a -> Vector a -> a\n(Vector i j k) `dotProd` (Vector l m n) = i*l + j*m + k*n\n\nvmult :: (Num a) => Vector a -> a -> Vector a\n(Vector i j k) `vmult` m = Vector (i*m) (j*m) (k*m)\n```", "```\nVector a a a -> Vector a a a -> a\n```", "```\nghci> Vector 3 5 8 `vplus` Vector 9 2 8\nVector 12 7 16\nghci> Vector 3 5 8 `vplus` Vector 9 2 8 `vplus` Vector 0 2 3\nVector 12 9 19\nghci> Vector 3 9 7 `vmult` 10\nVector 30 90 70\nghci> Vector 4 9 5 `dotProd` Vector 9.0 2.0 4.0\n74.0\nghci> Vector 2 9 3 `vmult` (Vector 4 9 5 `dotProd` Vector 9 2 4)\nVector 148 666 222\n```", "```\ndata Person = Person { firstName :: String\n                     , lastName :: String\n                     , age :: Int\n                     }\n```", "```\ndata Person = Person { firstName :: String\n                     , lastName :: String\n                     , age :: Int\n                     } deriving (Eq)\n```", "```\nmikeD = Person {firstName = \"Michael\", lastName = \"Diamond\", age = 43}\nadRock = Person {firstName = \"Adam\", lastName = \"Horovitz\", age = 41}\nmca = Person {firstName = \"Adam\", lastName = \"Yauch\", age = 44}\n```", "```\nghci> mca == adRock\nFalse\nghci> mikeD == adRock\nFalse\nghci> mikeD == mikeD\nTrue\nghci> mikeD == Person {firstName = \"Michael\", lastName = \"Diamond\", age = 43}\nTrue\n```", "```\nghci> let beastieBoys = [mca, adRock, mikeD]\nghci> mikeD `elem` beastieBoys\nTrue\n```", "```\ndata Person = Person { firstName :: String\n                     , lastName :: String\n                     , age :: Int\n                     } deriving (Eq, Show, Read)\n```", "```\nghci> mikeD\nPerson {firstName = \"Michael\", lastName = \"Diamond\", age = 43}\nghci> \"mikeD is: \" ++ show mikeD\n\"mikeD is: Person {firstName = \\\"Michael\\\", lastName = \\\"Diamond\\\", age = 43}\"\n```", "```\nmysteryDude = \"Person { firstName =\\\"Michael\\\"\" ++\n                     \", lastName =\\\"Diamond\\\"\" ++\n                     \", age = 43}\"\n```", "```\nghci> read mysteryDude :: Person\nPerson {firstName = \"Michael\", lastName = \"Diamond\", age = 43}\n```", "```\nghci> read mysteryDude == mikeD\nTrue\n```", "```\nghci> read \"Just 3\" :: Maybe a\n```", "```\nghci> read \"Just 3\" :: Maybe Int\nJust 3\n```", "```\ndata Bool = False | True deriving (Ord)\n```", "```\nghci> True `compare` False\nGT\nghci> True > False\nTrue\nghci> True < False\nFalse\n```", "```\nghci> Nothing < Just 100\nTrue\nghci> Nothing > Just (-49999)\nFalse\nghci> Just 3 `compare` Just 2\nGT\nghci> Just 100 > Just 50\nTrue\n```", "```\ndata Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday\n```", "```\ndata Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday\n            deriving (Eq, Ord, Show, Read, Bounded, Enum)\n```", "```\nghci> Wednesday\nWednesday\nghci> show Wednesday\n\"Wednesday\"\nghci> read \"Saturday\" :: Day\nSaturday\n```", "```\nghci> Saturday == Sunday\nFalse\nghci> Saturday == Saturday\nTrue\nghci> Saturday > Friday\nTrue\nghci> Monday `compare` Wednesday\nLT\n```", "```\nghci> minBound :: Day\nMonday\nghci> maxBound :: Day\nSunday\n```", "```\nghci> succ Monday\nTuesday\nghci> pred Saturday\nFriday\nghci> [Thursday .. Sunday]\n[Thursday,Friday,Saturday,Sunday]\nghci> [minBound .. maxBound] :: [Day]\n[Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday]\n```", "```\ntype String = [Char]\n```", "```\ntoUpperString :: [Char] -> [Char]\n```", "```\ntoUpperString :: String -> String.\n```", "```\nphoneBook :: [(String, String)]\nphoneBook =\n    [(\"betty\", \"555-2938\")\n    ,(\"bonnie\", \"452-2928\")\n    ,(\"patsy\", \"493-2928\")\n    ,(\"lucille\", \"205-2928\")\n    ,(\"wendy\", \"939-8282\")\n    ,(\"penny\", \"853-2492\")\n    ]\n```", "```\ntype PhoneBook = [(String,String)]\n```", "```\ntype PhoneNumber = String\ntype Name = String\ntype PhoneBook = [(Name, PhoneNumber)]\n```", "```\ninPhoneBook :: Name -> PhoneNumber -> PhoneBook -> Bool\ninPhoneBook name pnumber pbook = (name, pnumber) `elem` pbook\n```", "```\ninPhoneBook :: String -> String -> [(String, String)] -> Bool\n```", "```\ntype AssocList k v = [(k, v)]\n```", "```\ntype IntMap v = Map Int v\n```", "```\ntype IntMap = Map Int\n```", "```\ntype IntMap = Map.Map Int\n```", "```\ndata Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)\n```", "```\nghci> Right 20\nRight 20\nghci> Left \"w00t\"\nLeft \"w00t\"\nghci> :t Right 'a'\nRight 'a' :: Either a Char\nghci> :t Left True\nLeft True :: Either Bool b\n```", "```\nimport qualified Data.Map as Map\n\ndata LockerState = Taken | Free deriving (Show, Eq)\n\ntype Code = String\n\ntype LockerMap = Map.Map Int (LockerState, Code)\n```", "```\nlockerLookup :: Int -> LockerMap -> Either String Code\nlockerLookup lockerNumber map = case Map.lookup lockerNumber map of\n    Nothing -> Left $ \"Locker \" ++ show lockerNumber ++ \" doesn't exist!\"\n    Just (state, code) -> if state /= Taken\n                            then Right code\n                            else Left $ \"Locker \" ++ show lockerNumber\n                                        ++ \" is already taken!\"\n```", "```\nlockers :: LockerMap\nlockers = Map.fromList\n    [(100,(Taken, \"ZD39I\"))\n    ,(101,(Free, \"JAH3I\"))\n    ,(103,(Free, \"IQSA9\"))\n    ,(105,(Free, \"QOTSA\"))\n    ,(109,(Taken, \"893JJ\"))\n    ,(110,(Taken, \"99292\"))\n    ]\n```", "```\nghci> lockerLookup 101 lockers\nRight \"JAH3I\"\nghci> lockerLookup 100 lockers\nLeft \"Locker 100 is already taken!\"\nghci> lockerLookup 102 lockers\nLeft \"Locker number 102 doesn't exist!\"\nghci> lockerLookup 110 lockers\nLeft \"Locker 110 is already taken!\"\nghci> lockerLookup 105 lockers\nRight \"QOTSA\"\n```", "```\ndata List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)\n```", "```\ndata List a = Empty | Cons { listHead :: a, listTail :: List a}\n    deriving (Show, Read, Eq, Ord)\n```", "```\nghci> Empty\nEmpty\nghci> 5 `Cons` Empty\nCons 5 Empty\nghci> 4 `Cons` (5 `Cons` Empty)\nCons 4 (Cons 5 Empty)\nghci> 3 `Cons` (4 `Cons` (5 `Cons` Empty))\nCons 3 (Cons 4 (Cons 5 Empty))\n```", "```\ninfixr 5 :-:\ndata List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)\n```", "```\nghci> 3 :-: 4 :-: 5 :-: Empty\n3 :-: (4 :-: (5 :-: Empty))\nghci> let a = 3 :-: 4 :-: 5 :-: Empty\nghci> 100 :-: a\n100 :-: (3 :-: (4 :-: (5 :-: Empty)))\n```", "```\ninfixr 5  ++\n(++) :: [a] -> [a] -> [a]\n[]     ++ ys = ys\n(x:xs) ++ ys = x : (xs ++ ys)\n```", "```\ninfixr 5  ^++\n(^++) :: List a -> List a -> List a\nEmpty ^++ ys = ys\n(x :-: xs) ^++ ys = x :-: (xs ^++ ys)\n```", "```\nghci> let a = 3 :-: 4 :-: 5 :-: Empty\nghci> let b = 6 :-: 7 :-: Empty\nghci> a ^++ b\n3 :-: (4 :-: (5 :-: (6 :-: (7 :-: Empty))))\n```", "```\ndata Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show)\n```", "```\nsingleton :: a -> Tree a\nsingleton x = Node x EmptyTree EmptyTree\n\ntreeInsert :: (Ord a) => a -> Tree a -> Tree a\ntreeInsert x EmptyTree = singleton x\ntreeInsert x (Node a left right)\n    | x == a = Node x left right\n    | x < a  = Node a (treeInsert x left) right\n    | x > a  = Node a left (treeInsert x right)\n```", "```\ntreeElem :: (Ord a) => a -> Tree a -> Bool\ntreeElem x EmptyTree = False\ntreeElem x (Node a left right)\n    | x == a = True\n    | x < a  = treeElem x left\n    | x > a  = treeElem x right\n```", "```\nghci> let nums = [8,6,4,1,7,3,5]\nghci> let numsTree = foldr treeInsert EmptyTree nums\nghci> numsTree\nNode 5\n    (Node 3\n        (Node 1 EmptyTree EmptyTree)\n        (Node 4 EmptyTree EmptyTree)\n    )\n    (Node 7\n        (Node 6 EmptyTree EmptyTree)\n        (Node 8 EmptyTree EmptyTree)\n    )\n```", "```\nghci> 8 `treeElem` numsTree\nTrue\nghci> 100 `treeElem` numsTree\nFalse\nghci> 1 `treeElem` numsTree\nTrue\nghci> 10 `treeElem` numsTree\nFalse\n```", "```\nclass Eq a where\n    (==) :: a -> a -> Bool\n    (/=) :: a -> a -> Bool\n    x == y = not (x /= y)\n    x /= y = not (x == y)\n```", "```\ndata TrafficLight = Red | Yellow | Green\n```", "```\ninstance Eq TrafficLight where\n    Red == Red = True\n    Green == Green = True\n    Yellow == Yellow = True\n    _ == _ = False\n```", "```\nclass Eq a where\n    (==) :: a -> a -> Bool\n    (/=) :: a -> a -> Bool\n```", "```\ninstance Show TrafficLight where\n    show Red = \"Red light\"\n    show Yellow = \"Yellow light\"\n    show Green = \"Green light\"\n```", "```\nghci> Red == Red\nTrue\nghci> Red == Yellow\nFalse\nghci> Red `elem` [Red, Yellow, Green]\nTrue\nghci> [Red, Yellow, Green]\n[Red light,Yellow light,Green light]\n```", "```\nclass (Eq a) => Num a where\n   ...\n```", "```\nclass Eq a where\n    (==) :: a -> a -> Bool\n    (/=) :: a -> a -> Bool\n    x == y = not (x /= y)\n    x /= y = not (x == y)\n```", "```\ninstance Eq Maybe where\n    ...\n```", "```\ninstance Eq (Maybe m) where\n    Just x == Just y = x == y\n    Nothing == Nothing = True\n    _ == _ = False\n```", "```\ninstance (Eq m) => Eq (Maybe m) where\n    Just x == Just y = x == y\n    Nothing == Nothing = True\n    _ == _ = False\n```", "```\n(==) :: Maybe -> Maybe -> Bool\n```", "```\n(==) :: (Eq m) => Maybe m -> Maybe m -> Bool\n```", "```\nghci> :info Maybe\ndata Maybe a = Nothing | Just a -- Defined in Data.Maybe\ninstance (Eq a) => Eq (Maybe a) -- Defined in Data.Maybe\ninstance Monad Maybe -- Defined in Data.Maybe\ninstance Functor Maybe -- Defined in Data.Maybe\ninstance (Ord a) => Ord (Maybe a) -- Defined in Data.Maybe\ninstance (Read a) => Read (Maybe a) -- Defined in GHC.Read\ninstance (Show a) => Show (Maybe a) -- Defined in GHC.Show\n```", "```\nif (0) alert(\"YEAH!\") else alert(\"NO!\")\n```", "```\nif (\"\") alert (\"YEAH!\") else alert(\"NO!\")\n```", "```\nif (false) alert(\"YEAH!\") else alert(\"NO!\")\n```", "```\nif (\"WHAT\") alert (\"YEAH!\") else alert(\"NO!\")\n```", "```\nclass YesNo a where\n    yesno :: a -> Bool\n```", "```\ninstance YesNo Int where\n    yesno 0 = False\n    yesno _ = True\n```", "```\ninstance YesNo [a] where\n    yesno [] = False\n    yesno _ = True\n```", "```\ninstance YesNo Bool where\n    yesno = id\n```", "```\ninstance YesNo (Maybe a) where\n    yesno (Just _) = True\n    yesno Nothing = False\n```", "```\ninstance YesNo (Tree a) where\n    yesno EmptyTree = False\n    yesno _ = True\n```", "```\ninstance YesNo TrafficLight where\n    yesno Red = False\n    yesno _ = True\n```", "```\nghci> yesno $ length []\nFalse\nghci> yesno \"haha\"\nTrue\nghci> yesno \"\"\nFalse\nghci> yesno $ Just 0\nTrue\nghci> yesno True\nTrue\nghci> yesno EmptyTree\nFalse\nghci> yesno []\nFalse\nghci> yesno [0,0,0]\nTrue\nghci> :t yesno\nyesno :: (YesNo a) => a -> Bool\n```", "```\nyesnoIf :: (YesNo y) => y -> a -> a -> a\nyesnoIf yesnoVal yesResult noResult =\n    if yesno yesnoVal\n        then yesResult\n        else noResult\n```", "```\nghci> yesnoIf [] \"YEAH!\" \"NO!\"\n\"NO!\"\nghci> yesnoIf [2,3,4] \"YEAH!\" \"NO!\"\n\"YEAH!\"\nghci> yesnoIf True \"YEAH!\" \"NO!\"\n\"YEAH!\"\nghci> yesnoIf (Just 500) \"YEAH!\" \"NO!\"\n\"YEAH!\"\nghci> yesnoIf Nothing \"YEAH!\" \"NO!\"\n\"NO!\"\n```", "```\nclass Functor f where\n    fmap :: (a -> b) -> f a -> f b\n```", "```\nmap :: (a -> b) -> [a] -> [b]\n```", "```\ninstance Functor [] where\n    fmap = map\n```", "```\nfmap :: (a -> b) -> f a -> f b\n```", "```\nghci> fmap (*2) [1..3]\n[2,4,6]\nghci> map (*2) [1..3]\n[2,4,6]\n```", "```\ninstance Functor Maybe where\n    fmap f (Just x) = Just (f x)\n    fmap f Nothing = Nothing\n```", "```\nghci> fmap (++ \" HEY GUYS IM INSIDE THE JUST\") (Just \"Something serious.\")\nJust \"Something serious. HEY GUYS IM INSIDE THE JUST\"\nghci> fmap (++ \" HEY GUYS IM INSIDE THE JUST\") Nothing\nNothing\nghci> fmap (*2) (Just 200)\nJust 400\nghci> fmap (*2) Nothing\nNothing\n```", "```\ninstance Functor Tree where\n    fmap f EmptyTree = EmptyTree\n    fmap f (Node x left right) = Node (f x) (fmap f left) (fmap f right)\n```", "```\nghci> fmap (*2) EmptyTree\nEmptyTree\nghci> fmap (*4) (foldr treeInsert EmptyTree [5,7,3])\nNode 20 (Node 12 EmptyTree EmptyTree) (Node 28 EmptyTree EmptyTree)\n```", "```\ninstance Functor (Either a) where\n    fmap f (Right x) = Right (f x)\n    fmap f (Left x) = Left x\n```", "```\n(b -> c) -> Either a b -> Either a c\n```", "```\n(b -> c) -> (Either a) b -> (Either a) c\n```", "```\ndata Either a b = Left a | Right b\n```", "```\nghci> :k Int\nInt :: *\n```", "```\nghci> :k Maybe\nMaybe :: * -> *\n```", "```\nghci> :k Maybe Int\nMaybe Int :: *\n```", "```\nghci> :k Either\nEither :: * -> * -> *\n```", "```\nghci> :k Either String\nEither String :: * -> *\nghci> :k Either String Int\nEither String Int :: *\n```", "```\nclass Functor f where\n    fmap :: (a -> b) -> f a -> f b\n```"]