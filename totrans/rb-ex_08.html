<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;HTML and XML Tools"><div class="titlepage"><div><div><h1 class="title"><a id="html_and_xml_tools"/>Chapter 8. HTML and XML Tools</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject8_d1e12875"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages686190.png.jpg"/></div></div><p>Text runs the Web. This is especially true of text that is encoded within some sort of markup, such as HyperText Markup Language (<a class="indexterm" id="idx-CHP-8-0804"/>HTML) or <a class="indexterm" id="idx-CHP-8-0805"/>eXtensible Markup Language (XML).</p><p>Even non-programmers know that HTML is the markup generally used by websites, even if they’ve never heard the term markup before. XML is becoming increasingly important for both data transfer and data storage. As I work on the chapters of this book, I save them as a filetype that consists of a compressed collection of XML files. I also used a type of XML called <a class="indexterm" id="idx-CHP-8-0806"/>DocBook (<a class="ulink" href="http://docbook.org">http://docbook.org</a>) for my Doctoral dissertation. The bottom line is, XML-based markup is everywhere. Luckily, Ruby can understand, output, and manipulate XML (and HTML).</p><div class="sect1" title="#30 Cleaning Up HTML (html_tidy.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp30_cleaning_up_html_html_tidyrb"/>#30 Cleaning Up HTML (html_tidy.rb)</h1></div></div></div><p>Let’s start with HTML. This markup language has had several numbered releases, similar to different versions of software, and it’s come a long way since Tim <a class="indexterm" id="idx-CHP-8-0807"/>Berners-Lee made the first web page at CERN in the mid ’90s. Recent versions of <a class="indexterm" id="idx-CHP-8-0808"/>HTML are subsets of XML and are called <a class="indexterm" id="idx-CHP-8-0809"/>XHTML as a result. However, the earlier versions of HTML were not as disciplined; they allowed very liberal interpretations of HTML. Especially when people were first learning how to use HTML, they would often throw together pages that were not very well designed, either aesthetically or technically. But browser manufacturers didn’t want to take the blame for rendering content badly, so they made their browsers very forgiving.<a class="indexterm" id="idx-CHP-8-0810"/><a class="indexterm" id="idx-CHP-8-0811"/></p><p>In the short term, the practice of allowing <a class="indexterm" id="idx-CHP-8-0812"/>non-compliant HTML was great, because it meant that more people could view more content. In the long term, however, that liberality had some negative consequences because it allowed web designers to continue using some uncorrected bad techniques. There’s a lot of sloppy HTML out there, and there’s little reason to add to the mess. We want a tool that helps us make sure that our own HTML is <a class="indexterm" id="idx-CHP-8-0813"/>up to spec.</p><div class="note" title="Note"><h3 class="title"><a id="note-45"/>Note</h3><p><span class="emphasis"><em>I’m assuming that you have a basic familiarity with HTML. If not, there’s a good guide at</em></span> <a class="ulink" href="http://w3schools.com/html/default.asp">http://w3schools.com/html/default.asp</a>. <span class="emphasis"><em>If you’re curious about the various versions of HTML and its relationship to XML, browse to the World Wide Web Consortium (W3C) MarkUp page at</em></span> <a class="ulink" href="http://www.w3.org/MarkUp">http://www.w3.org/MarkUp</a>. <span class="emphasis"><em>This page also has a link to the HTML Tidy program that the</em></span> <em class="replaceable"><code>html_tidy.rb</code></em><a class="indexterm" id="idx-CHP-8-0814"/> <span class="emphasis"><em>script depends on</em></span>.<a class="indexterm" id="idx-CHP-8-0815"/><a class="indexterm" id="idx-CHP-8-0816"/><a class="indexterm" id="idx-CHP-8-0817"/></p></div><p>There’s an excellent program that does most of this clean-up work already. It’s called HTML Tidy, and it was written by Dave <a class="indexterm" id="idx-CHP-8-0818"/>Raggett. It’s available at <a class="ulink" href="http://tidy.sourceforge.net">http://tidy.sourceforge.net</a>, but it also comes prepackaged within many GNU/Linux distributions. Seeing no need to reinvent the wheel, I wrote <code class="literal">html_tidy.rb</code> to use Raggett’s program and add some specific features that I wanted. Let’s take a look at the code.<a class="indexterm" id="idx-CHP-8-0819"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id029"/>The Code</h2></div></div></div><a id="I_programlisting8_d1e12990"/><pre class="programlisting">  #!/usr/bin/env ruby
  # html_tidy.rb
  # cleans up html files

❶ EMPTY_STRING = ''

  SIMPLE_TAG_REPLACEMENTS = {

    #closers
    /\&lt;\/b\&gt;/i             =&gt; '&lt;/strong&gt;',    <em class="lineannotation"><span class="lineannotation"><strong class="userinput"><code>=&gt;</code></strong> Operator</span></em>
    /\&lt;\/i\&gt;/i             =&gt; '&lt;/em&gt;',
    /\&lt;\/strong\&gt;&lt;\/td\&gt;/i =&gt; '&lt;/th&gt;',
    /\&lt;\/u\&gt;/i             =&gt; '&lt;/div&gt;',

    #openers
    /\&lt;b\&gt;/i               =&gt; '&lt;strong&gt;',
    /\&lt;i\&gt;/i               =&gt; '&lt;em&gt;',
    /\&lt;td\&gt;\&lt;strong\&gt;/i    =&gt; '&lt;th&gt;',
    /\&lt;u\&gt;/i               =&gt; '&lt;div style="text-decoration: underline;"&gt;',
    # again, more as appropriate

  }
  TIDY_EXTENSION = '.tidy'

  TIDY_OPTIONS = '-asxml -bc' # possible add -access 3

❷ UNWANTED_REGEXES = [
    /^&lt;meta name=\"GENERATOR\" content=\"Microsoft FrontPage 5.0\"&gt;$/,
    /^ *$/,
    /^\n$/,
    # more as appropriate
  ]

❸ def declare_regexes_and_replacements()
    replacement_of = Hash.new()
    UNWANTED_REGEXES.each do |discard|
      replacement_of[discard] = EMPTY_STRING
    end
    return replacement_of.merge(SIMPLE_TAG_REPLACEMENTS)
  end

  =begin rdoc
  This lacks a ! suffix because it duplicates the argument and
  returns the changes made to that duplicate, rather than overwriting.
  =end
❹ def perform_replacements_on_contents(contents)
    output = contents.dup
    replacement_of = declare_regexes_and_replacements()
❺   replacement_of.keys.sort_by { |r| r.to_s }.each do |regex|
      replace = replacement_of[regex]
❻     output.each { |line| line.gsub!(regex, replace) }
    end
    return output
  end

  =begin rdoc
  This has the ! suffix because it destructively writes
  into the filename argument provided.
  =end
❼ def perform_replacements_on_filename!(filename)
❽   if (system('which tidy &gt; /dev/null'))
      new_filename = filename + TIDY_EXTENSION
      system("tidy #{TIDY_OPTIONS} #{filename} &gt; #{new_filename} 2&gt; /dev/null")    <em class="lineannotation"><span class="lineannotation">Standard Error</span></em>
❾     contents = File.open(new_filename, 'r').readlines()
      new_contents = perform_replacements_on_contents(contents)
      File.open(new_filename, 'w') { |f| f.puts(new_contents) }
    else
      puts "Please install tidy.\n"
    end
  end

❿ ARGV.each do |filename|
    perform_replacements_on_filename!(filename)
  end</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id028"/>How It Works</h2></div></div></div><p>We start by defining some constants at ❶. <code class="literal">EMPTY_STRING</code> should be obvious, and <code class="literal">SIMPLE_TAG_REPLACEMENTS</code> is a Hash whose keys are regular expressions and whose values are whatever the corresponding key should be replaced with. You’ll notice that you need to mark certain characters within a <a class="indexterm" id="idx-CHP-8-0820"/>regular expression with a <a class="indexterm" id="idx-CHP-8-0821"/>backslash (<code class="literal">\</code>)—that’s because some characters have special meanings within regular expressions. You’ve already seen examples of that, where <code class="literal">?</code> means <span class="emphasis"><em>Zero or one of whatever preceded me</em></span> and <code class="literal">*</code> means <span class="emphasis"><em>Zero or more of whatever preceded me</em></span>. Similarly, <code class="literal">\</code> means <span class="emphasis"><em>Treat whatever follows me as a literal character, not a special regex character</em></span>.<a class="indexterm" id="idx-CHP-8-0822"/><a class="indexterm" id="idx-CHP-8-0823"/></p><p>Why do I make these particular replacements? The <code class="literal">&lt;b&gt;</code> and <code class="literal">&lt;i&gt;</code> tags are still commonly used, but they are not compliant with the <a class="indexterm" id="idx-CHP-8-0824"/>Web Accessibility Initiative (<a class="indexterm" id="idx-CHP-8-0825"/>WAI). I’ve set <a class="indexterm" id="idx-CHP-8-0826"/>up this script to replace them with appropriate tags that accomplish the same goal but don’t discriminate against the visually impaired. I also replace <code class="literal">/\&lt;td\&gt;\&lt;\strong\&gt;/</code> with <code class="literal">&lt;th&gt;</code> because I find that people often make “almost” table headers by putting formatting within a table cell, rather than making the cell a real header. Finally, I’ve taken out the <code class="literal">&lt;u&gt;</code> tag because it doesn’t mean anything, even if it creates an underline. It’s just a visual formatting tag with no semantic meaning, which is a no-no. Formatting is what stylesheets are for—the markup itself should just have content. Therefore, I replace <code class="literal">&lt;u&gt;</code> with a <code class="literal">&lt;div&gt;</code> that has an underline style attached to it. I make all these replacements both for the opening tags and the closing tags.</p><div class="note" title="Note"><h3 class="title"><a id="note-46"/>Note</h3><p><span class="emphasis"><em>Web accessibility is important: These fixes help people who are visually impaired surf the Web. The</em></span> <em class="replaceable"><code>html_tidy.rb</code></em><a class="indexterm" id="idx-CHP-8-0827"/> <span class="emphasis"><em>script fixes my mistakes, at least for these particular cases. If you’re curious, read more about accessibility and its importance at the W3C’s Web Accessibility Commission page (</em></span><a class="ulink" href="http://www.w3c.org/WAI">http://www.w3c.org/WAI</a><span class="emphasis"><em>)</em></span>.</p></div><p>We continue with more constants, including some <code class="literal">TIDY_OPTIONS</code>. Execute <code class="literal">man tidy</code> at the command line to see what these do. These options reflect my preferences, but you can certainly make some changes to the constant once you’re comfortable with operating the script. At ❷, we have an Array constant called <code class="literal">UNWANTED_REGEXES</code>. It sounds harsh, but there are some things I just don’t want in my <a class="indexterm" id="idx-CHP-8-0828"/>HTML. One of these is a <code class="literal">&lt;meta&gt;</code> tag, which Microsoft’s FrontPage sometimes adds to files. I also don’t want either lines with only whitespace (which <code class="literal">/^ *$/</code> matches) or completely empty lines (which <code class="literal">/^\n$/</code> matches). As the comment suggests, you can add to this Hash.<a class="indexterm" id="idx-CHP-8-0829"/></p><p>The first method, <code class="literal">declare_regexes_and_replacements</code>, is at ❸. It combines <code class="literal">SIMPLE_TAG_REPLACEMENTS</code> with <code class="literal">UNWANTED_REGEXES</code> by looping through <code class="literal">UNWANTED_REGEXES</code> and making a Hash called <code class="literal">replacement_of</code>, whose keys are the elements of <code class="literal">UNWANTED_REGEXES</code> and whose values are all the <code class="literal">EMPTY_STRING</code>. This makes sense—if a regex is unwanted, we want to replace it with the empty string. The <code class="literal">declare_regexes_and_replacements</code> method then returns the merged Hash, which is made up of both <code class="literal">SIMPLE_TAG_REPLACEMENTS</code>, which was already a Hash in the first place, and our new <code class="literal">replacement_of</code> Hash.<sup>[<a class="footnote" href="#ftn.CHP-8-FNOTE-1" id="CHP-8-FNOTE-1">25</a>]</sup></p><p>On to ❹ and the <code class="literal">perform_replacements_on_contents</code> method. It takes an argument, unsurprisingly called <code class="literal">contents</code>, immediately duplicates it with the <code class="literal">dup</code> method, and calls the result <code class="literal">output</code>. It then calls <code class="literal">declare_regexes_and_replacements</code> (defined at ❸), getting the return value which we already know is a Hash that is called <code class="literal">replacement_of</code>. For simplicity, we’ll keep the same name for that Hash inside <code class="literal">perform_replacements_on_contents</code>. At ❺, we sort the keys of <code class="literal">replacement_of</code> with the <code class="literal">sort_by</code> method, which takes a block. <a class="indexterm" id="idx-CHP-8-0831"/>Strings know how to compare themselves to other Strings for <a class="indexterm" id="idx-CHP-8-0832"/>sorting purposes, whereas regular expressions don’t. Therefore, we convert each of our regular expression keys into a String for sorting purposes.<a class="indexterm" id="idx-CHP-8-0833"/><a class="indexterm" id="idx-CHP-8-0834"/></p><div class="note" title="Note"><h3 class="title"><a id="note-47"/>Note</h3><p><span class="emphasis"><em>Strings know how to compare themselves to other Strings because</em></span> <em class="replaceable"><code>String</code></em> <span class="emphasis"><em>has a</em></span> <em class="replaceable"><code>&lt;=&gt;</code></em><a class="indexterm" id="idx-CHP-8-0835"/> <span class="emphasis"><em>method, and one of</em></span> <em class="replaceable"><code>String</code></em><span class="emphasis"><em>’s ancestors is the Comparable module</em></span>.<sup>[<a class="footnote" href="#ftn.CHP-8-FNOTE-2" id="CHP-8-FNOTE-2">26</a>]</sup> <span class="emphasis"><em>Comparable uses the</em></span> <em class="replaceable"><code>&lt;=&gt;</code></em> <span class="emphasis"><em>method to implement the other comparison operators, such as</em></span> <em class="replaceable"><code>==, &lt;=, &gt;=</code></em>, <span class="emphasis"><em>and so on. If you create a new class and want it to be sortable, give it a method called</em></span> <em class="replaceable"><code>&lt;=&gt;</code></em>, <span class="emphasis"><em>figure out how to implement it in a way that makes sense, and then mix in Comparable. You’ll get lots of sorting value for a minimal amount of effort, and you’ll make your objects more useful</em></span>.</p></div><p>In an earlier version of <code class="literal">html_tidy.rb</code>, I didn’t include the sorting at ❺, and I would occasionally miss replacements described in <code class="literal">SIMPLE_TAG_REPLACEMENTS</code>. The reason was that Hash keys do not have a deterministic order, so sometimes my program would replace <code class="literal">&lt;b&gt;</code> with <code class="literal">&lt;strong&gt;</code> before getting to replacing <code class="literal">&lt;/strong&gt;&lt;/td&gt;</code> with <code class="literal">&lt;/th&gt;</code>, but sometimes it wouldn’t. To make my program more robust, I’d either need to add a Hash pair that replaced <code class="literal">&lt;/b&gt;&lt;/td&gt;</code> with <code class="literal">&lt;/th&gt;</code> or enforce a specific order on how I used <code class="literal">replacement_of</code> at ❺. I chose to enforce order, not just because it makes the program more dependable, and not just because I’m a petty tyrant at heart, but also because it makes the program simpler.<a class="indexterm" id="idx-CHP-8-0837"/></p><p>We sort the keys of <code class="literal">replacement_of</code> and loop through <code class="literal">each</code> of them at ❺, calling them <code class="literal">regex</code> in turn. We also want the replacement value, so we read that out of the Hash as <code class="literal">replace</code>. Then at ❻, we loop through <code class="literal">each</code> <code class="literal">line</code> of the eventual <code class="literal">output</code>, destructively <code class="literal">gsub!</code>ing <code class="literal">regex</code> with <code class="literal">replace</code>. The <code class="literal">output</code> variable is now ready to be <code class="literal">return</code>ed. That’s how we <code class="literal">perform_replacements_on_contents</code>. Where do we get the <code class="literal">contents</code>?</p><p>The <code class="literal">perform_replacements_on_filename!</code> method is at ❼. At ❿, we call it on <code class="literal">each</code> element of the <code class="literal">ARGV</code> Array, which we call <code class="literal">filename</code> as we pass it into <code class="literal">perform_replacements_on_filename!</code> as the single argument. We first attempt a system call of <code class="literal">‘which tidy &gt; /dev/null’</code> (❽). Without getting too deep into Unix black magic, I’ll tell you that when executed, this command determines whether there is a version of <code class="literal">tidy</code> installed on the machine.</p><p>If the test succeeds, we know we can use <code class="literal">tidy</code>. First, we define a <code class="literal">new_filename</code>, which is just the old <code class="literal">filename</code> with the <code class="literal">TIDY_EXTENSION</code> appended to it. We then make a call to <code class="literal">tidy</code> itself, passing it its own <code class="literal">TIDY_OPTIONS</code> (as an interpolated String) and calling it on <code class="literal">filename</code>. We pass its output into the <code class="literal">new_filename</code>, discarding any error messages. The <code class="literal">new_filename</code> file now contains all of the tidying done by <code class="literal">tidy</code> itself but none of our add-on changes.</p><div class="note" title="Note"><h3 class="title"><a id="note-48"/>Note</h3><p><span class="emphasis"><em>The</em></span> <em class="replaceable"><code>&gt;</code></em> <span class="emphasis"><em>character in the Unix shell just means</em></span> Send my output into the following filename, <span class="emphasis"><em>so</em></span> <em class="replaceable"><code>some_command &gt; some_file</code></em> <span class="emphasis"><em>takes the output of</em></span> <em class="replaceable"><code>some_command</code></em> <span class="emphasis"><em>and writes it into a file called</em></span> <em class="replaceable"><code>some_file</code></em>. <span class="emphasis"><em>Putting a</em></span> <em class="replaceable"><code>2</code></em> <span class="emphasis"><em>in front of</em></span> <em class="replaceable"><code>&gt;</code></em> <span class="emphasis"><em>makes it apply to error messages, instead of regular output. Unix calls the output of error messages</em></span> Standard Error. <span class="emphasis"><em>The file called /dev/null just means</em></span> nowhere, <span class="emphasis"><em>so</em></span> <em class="replaceable"><code>some_command &gt; some_file 2&gt; /dev/null</code></em> <span class="emphasis"><em>means</em></span> Send <em class="replaceable"><code>some_command</code></em>’s output into <em class="replaceable"><code>some_file</code></em>, and I don’t care about any error messages.</p></div><p>We then read <code class="literal">new_filename</code>’s <code class="literal">contents</code> using <code class="literal">File.open</code> and the <code class="literal">readlines</code> method at ❾. That <code class="literal">contents</code> variable is ready for <code class="literal">perform_replacements_on_contents</code>, which we call on it, assigning the results into <code class="literal">new_contents</code>. We then open the <code class="literal">new_filename</code> file again, this time for writing, and replace its contents with <code class="literal">new_contents</code>.</p><p>If the <code class="literal">which tidy</code> test fails, we know that our beloved <code class="literal">tidy</code> is not present, so there’s little point in proceeding. We simply ask the user to install <code class="literal">tidy</code>.</p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id021"/>Running the Script</h2></div></div></div><p>I have a sample file at <code class="literal">extras/eh.html</code>, so we can call this script with the command <code class="literal">ruby -w html_tidy.rb extras/eh.html</code>. Here’s the original version, <code class="literal">extras/eh.html</code>:<a class="indexterm" id="idx-CHP-8-0838"/></p><a id="I_programlisting8_d1e13548"/><pre class="programlisting">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;html
    lang="en"
    xml:lang="en"
    &gt;

&lt;head&gt;
&lt;meta http-equiv="refresh" content="10" /&gt;
&lt;title&gt;English Horn for No Clergy&lt;/title&gt;
&lt;style&gt;
@import url('../css/noclergy.css');
h1, h2 { display: none; }
&lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;div id="notation"&gt;
&lt;h1&gt;No Clergy:&lt;/h1&gt;
&lt;p style="text-align:center;"&gt;
&lt;img src="../../png/eh-page1.png" /&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;b&gt;I'm a header, but I don't know it.&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;u&gt;I'm some underlined content.&lt;/u&gt;&lt;/td&gt;
&lt;td&gt;&lt;i&gt;I'm some italicized content.&lt;/i&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;I'm an unclosed paragraph. The horrors.

&lt;/body&gt;
&lt;/html&gt;</pre></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id026"/>The Results</h2></div></div></div><p>And here’s the new version, <code class="literal">extras/eh.html.tidy</code>:</p><a id="I_programlisting8_d1e13558"/><pre class="programlisting">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html lang="en" xml:lang="en" &gt;
&lt;head&gt;
&lt;meta name="generator" content=
"HTML Tidy for Linux/x86 (vers 1 September 2005), see www.w3.org" /&gt;
&lt;meta http-equiv="refresh" content="10" /&gt;
&lt;title&gt;English Horn for No Clergy&lt;/title&gt;

&lt;style type="text/css"&gt;
/*&lt;![CDATA[*/
@import url('../css/noclergy.css');
h1, h2 { display: none; }
/*]]&gt;*/
&lt;/style&gt;

&lt;style type="text/css"&gt;
/*&lt;![CDATA[*/
 p.c1 {text-align:center;}
/*]]&gt;*/
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="notation-id001"&gt;
&lt;h1&gt;No Clergy:&lt;/h1&gt;
&lt;p class="c1"&gt;&lt;img src="../../png/eh-page1.png" /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;I'm a header, but I don't know it.&lt;/th&gt;
&lt;td&gt;&lt;div style="text-decoration: underline;"&gt;I'm some underlined content.
&lt;/div&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;I'm some italicized content.&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;I'm an unclosed paragraph. The horrors.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p>Notice how <code class="literal">tidy</code> added a <code class="literal">&lt;meta&gt;</code> tag for itself and wrapped the style information inside <code class="literal">CDATA</code> markers. It also defined a paragraph class called <code class="literal">c1</code> for our <code class="literal">text-align:center;</code> style that is attached to the free-floating <code class="literal">&lt;p&gt;</code> tag. In addition to everything that <code class="literal">tidy</code> does, our <a class="indexterm" id="idx-CHP-8-0839"/>script does what I’ve described above. It replaced the <a class="indexterm" id="idx-CHP-8-0840"/>tags for our “almost” header with a <code class="literal">&lt;th&gt;</code>, converted the underlining from a bad <code class="literal">&lt;u&gt;</code> tag to a style declaration, and changed the <code class="literal">&lt;i&gt;</code> tag to an <code class="literal">&lt;em&gt;</code> tag, making this content a little friendlier to an audio browser, such as a blind person might use.</p></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id018"/>Hacking the Script</h2></div></div></div><p>Could we use <code class="literal">inject</code>, rather than <code class="literal">each</code>, to modify <code class="literal">declare_regexes_and_replacements</code> at ❸ and make it more functional? Here’s one way:<a class="indexterm" id="idx-CHP-8-0841"/></p><a id="I_programlisting8_d1e13626"/><pre class="programlisting">def declare_regexes_and_replacements()    <em class="lineannotation"><span class="lineannotation">Hashes from Arrays <a class="indexterm" id="idx-CHP-8-0842"/>with inject</span></em>
  return UNWANTED_REGEXES.inject({}) do |h,discard|
    h.merge( { discard =&gt; EMPTY_STRING } )
  end.merge(SIMPLE_TAG_REPLACEMENTS)
end</pre><p>In this variant, <code class="literal">h</code> takes the place of <code class="literal">replacement_of</code>, and it is the memoized Hash that persists from one iteration of <code class="literal">inject</code> to the next. Each time, we merge it with the new pair (consisting of <code class="literal">discard</code> as a key pointing to the <code class="literal">EMPTY_STRING</code>), so we end <a class="indexterm" id="idx-CHP-8-0843"/>up with a Hash of things to replace, all of whose replacements are the <code class="literal">EMPTY_STRING</code>—just like in the original version. This time, however, our temporary variables are confined entirely within the <code class="literal">inject</code> loop.</p><p>Could we have simply altered <code class="literal">contents</code> in place with a <a class="indexterm" id="idx-CHP-8-0844"/>method called <code class="literal">perform_replacements_on_contents!</code>? Of course. I just wanted to show both a destructive method (<code class="literal">perform_replacements_on_filename!</code>) and a regular method (<code class="literal">perform_replacements_on_contents</code>) whose output we would then use for demonstration purposes. Both could have been either destructive or non-destructive. Change the script as you like if you’d prefer these to use the same approach.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FNOTE-1" id="ftn.CHP-8-FNOTE-1">25</a>] </sup>I generally find Perl rather sloppy, but one benefit of its policy of storing Hashes as even-length Arrays is that you can make Hashes out of Arrays very easily. The Perl equivalent of our <code class="literal">UNWANTED_REGEXES.each</code> loop would be something like this: <code class="literal">my %replacement_of = map { $_ =&gt; EMPTY_STRING } @unwanted_regexes;</code>. Of course, it’s more trouble to <code class="literal">merge</code> Hashes in Perl, so I still like Ruby better. Don’t worry about any of this if you don’t know Perl.<a class="indexterm" id="idx-CHP-8-0830"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FNOTE-2" id="ftn.CHP-8-FNOTE-2">26</a>] </sup>Since Comparable is a module, rather than a class, it is an ancestor of String via mixing in, rather than straightforward inheritance. However, <code class="literal">String.ancestors</code> includes Comparable, so I’ve referred to it as an ancestor here.<a class="indexterm" id="idx-CHP-8-0836"/></p></div></div></div>
<div class="sect1" title="#31 Counting Tags (xml_tag_counter.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp31_counting_tags_xml_tag_counterrb"/>#31 Counting Tags (xml_tag_counter.rb)</h1></div></div></div><p>XML is strict about its internal structure. It can only have a single top-level element (called the <span class="emphasis"><em>root element</em></span>), but that root element can have any number of elements within itself, and each of those elements can have any number of other elements within itself, continuing on recursively. We want a script that we can run on an XML file that will output how many times each tag (or element) occurs within that document, no matter how many layers deep it appears—for example, we want to find all <code class="literal">&lt;p&gt;</code> tags regardless of whether or not those tags are immediately within the top-level <code class="literal">&lt;html&gt;</code> element, or within some other element, such as a <code class="literal">&lt;blockquote&gt;</code> or <code class="literal">&lt;div&gt;</code>. Let’s take a look.<a class="indexterm" id="idx-CHP-8-0845"/><a class="indexterm" id="idx-CHP-8-0846"/><a class="indexterm" id="idx-CHP-8-0847"/><a class="indexterm" id="idx-CHP-8-0848"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id030"/>The Code</h2></div></div></div><a id="I_programlisting8_d1e13725"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-8-0849"/>xml_tag_counter.rb

  =begin rdoc
  This script uses the Rexml parser, which is written in Ruby itself.
  Find out more at http://www.germane-software.com/software/rexml.
  =end
❶ require 'rexml/document'    <em class="lineannotation"><span class="lineannotation">REXML</span></em>

  class Hash

❷ =begin rdoc
  Given that &lt;b&gt;self&lt;/b&gt; is a &lt;b&gt;Hash&lt;/b&gt; with keys of
  XML <a class="indexterm" id="idx-CHP-8-0850"/>tags and values of their respective counts in an
  XML source file, sort by the tag count, descending.
  Fall back to an ascending sort of the tag itself,
  weighted half as strongly.
  =end
    def sort_by_tag_count()
      self.sort do |a, b|
❸       ( (b[1] &lt;=&gt; a[1]) * 2 ) + (a[0] &lt;=&gt; b[0])
      end
    end

❹ =begin rdoc
  Merge with another &lt;b&gt;Hash&lt;/b&gt;, but add values rather
  than simply overwriting duplicate keys.
  =end
    def merge_totals(other_hash)    <em class="lineannotation"><span class="lineannotation">Hashes as Histograms</span></em>
      other_hash.keys.each do |key|
        self[key] += other_hash[key]
      end
    end

❺ =begin rdoc
  Your basic pretty formatter, returns a &lt;b&gt;String&lt;/b&gt;.
  =end
    def pretty_report()
      output = ''
      sort_by_tag_count.each do |pair|
        tag, count = pair
        output += "#{tag}: #{count}\n"
      end
      return output
    end

  end # Hash
❻ =begin rdoc
  Returns DOM elements of a given filename.
  =end
  def get_elements_from_filename(filename)
    REXML::Document.new(File.open(filename)).elements()
  end

❼ =begin rdoc
  Returns a &lt;b&gt;Hash&lt;/b&gt; with keys of XML <a class="indexterm" id="idx-CHP-8-0851"/>tags and values
  of those <a class="indexterm" id="idx-CHP-8-0852"/><a class="indexterm" id="idx-CHP-8-0853"/>tags' counts within a given XML document.
  Calls itself recursively on each tag's elements.
  =end
  def tag_count(elements)
❽   count_of = Hash.new(0) # note the default value of 0
    elements.to_a.each do |tag|
      count_of[tag.name()] += 1
❾     count_of.merge_totals(tag_count(tag.elements))
    end
    return count_of
  end

❿ puts tag_count(get_elements_from_file(ARGV[0])).pretty_report()</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id029"/>How It Works</h2></div></div></div><p>Most of the work in this <a class="indexterm" id="idx-CHP-8-0854"/>script comes from adding new methods to the <a class="indexterm" id="idx-CHP-8-0855"/>Hash class. First, at ❶, we <code class="literal">require</code> the <code class="literal">rexml/document</code> library, an XML processing library. Then at ❷, we start the RDoc explaining the <code class="literal">sort_by_tag_count</code> <a class="indexterm" id="idx-CHP-8-0856"/>method. The RDoc explains the method’s goals, but let’s look at each step. First, <code class="literal">self.sort</code> converts a Hash into an Array <a class="indexterm" id="idx-CHP-8-0857"/>of Arrays. Each element of the main Array is another Array with the structure <span class="emphasis"><em>[key, value]</em></span>. Let’s show this in irb:<a class="indexterm" id="idx-CHP-8-0858"/><a class="indexterm" id="idx-CHP-8-0859"/></p><a id="I_programlisting8_d1e13802"/><pre class="programlisting">irb(main):001:0&gt; h = { 0 =&gt; 1, 1 =&gt; 2 }
=&gt; {0=&gt;1, 1=&gt;2}
irb(main):002:0&gt; h.sort
=&gt; [[0, 1], [1, 2]]</pre><p>Since this in the context of a method called <code class="literal">sort</code>, the Array of Arrays is sorted. The <code class="literal">sort</code> method takes a block, which allows us to specify how we’d like it to be sorted. We do this at ❸ with the expression <code class="literal">( (b[1] &lt;=&gt; a[1]) * 2 ) + (a[0] &lt;=&gt; b[0])</code>. What does this expression mean?<a class="indexterm" id="idx-CHP-8-0860"/></p><p>First, we need to talk a bit about <code class="literal">sort</code>ing. You see in the line before ❸ that we identify the variables within the <code class="literal">sort</code> loop as <code class="literal">a</code> and <code class="literal">b</code>. Those names are traditional for <code class="literal">sort</code>s, although Ruby allows you to pick other names if you like. Our expression calls the <code class="literal">&lt;=&gt;</code> method on whatever <code class="literal">b[1]</code> is, with <code class="literal">a[1]</code> as the argument. It then multiplies this by two and adds the result of calling <code class="literal">&lt;=&gt;</code> on <code class="literal">a[0]</code>, with <code class="literal">b[0]</code> as an argument. That should clear everything up, right?</p><p>The <code class="literal">&lt;=&gt;</code> method returns <code class="literal">1</code> when <code class="literal">self</code> is greater then the argument, however it is defined; <code class="literal">-1</code> when <code class="literal">self</code> is less than the argument, hopefully according to the same criteria; and <code class="literal">0</code> when they are equal. Keep this in mind when you create your own classes that implement the <code class="literal">&lt;=&gt;</code> method. Our project specifications from <a class="xref" href="ch08s02.html" title="#31 Counting Tags (xml_tag_counter.rb)">#31 Counting Tags (xml_tag_counter.rb)</a><a class="indexterm" id="idx-CHP-8-0861"/><a class="indexterm" id="idx-CHP-8-0862"/><a class="indexterm" id="idx-CHP-8-0863"/> on page 148 says that the pairs of our Array of Arrays from <code class="literal">sort_by_tag_count</code> will have keys that are the names of XML <a class="indexterm" id="idx-CHP-8-0864"/>tags and values that are the number of times that the tag appears in the document being analyzed. The first part of our expression (the part that is doubled) is just a <code class="literal">sort</code> on the tag count, as the name suggests. We put <code class="literal">b[1]</code> before <code class="literal">a[1]</code> because we want to <code class="literal">sort</code> in descending order, so the most common tags come first.<a class="indexterm" id="idx-CHP-8-0865"/></p><p>What happens when two different tags occur the same number of times in the document? That’s what the second part of the expression is for. When the tag count is tied, we want to then <code class="literal">sort</code> on the name of the tag, which is either <code class="literal">a[0]</code> or <code class="literal">b[0]</code>. We put these in regular order, where <code class="literal">a</code> comes before <code class="literal">b</code>, because we want to <code class="literal">sort</code> in ascending order. Our output is sorted by descending tag count first, and ascending tag name within a given tag count. Why do we double the value of <code class="literal">&lt;=&gt;</code> for the tag counts?</p><p>Since <code class="literal">&lt;=&gt;</code> always returns <code class="literal">-1, 0</code>, or <code class="literal">1</code>, and this is true for either sorting by tag count or tag name, we need to give tag count sorting greater weight somehow. Doubling does this very well, because it increases the magnitude of either <code class="literal">1</code> or <code class="literal">-1</code> for the tag count <code class="literal">sort</code> relative to the tag name <code class="literal">sort</code>, but does nothing for tag count ties, because zero doubled is still zero. Our tag name <code class="literal">sort</code> still counts for something, just less than the <code class="literal">sort_by_tag_count</code>.<sup>[<a class="footnote" href="#ftn.CHP-8-FNOTE-3" id="CHP-8-FNOTE-3">27</a>]</sup></p><p>We now know how to <code class="literal">sort_by_tag_count</code>, but we also want to be able to <code class="literal">merge</code> Hashes together, take another Hash as an argument, add their tag counts together, and have that new pair be the pair in the result. Hashes already have a method called <code class="literal">merge</code>, which takes a Hash argument. That should take care of everything, right? Sadly, no. The preexisting <code class="literal">merge</code> method <span class="emphasis"><em>replaces</em></span> any existing <code class="literal">key =&gt; value</code> pair with whatever is in the hash taken as an argument. We don’t want that—we want to keep the key that they share, but add the values together. How do we do that?<a class="indexterm" id="idx-CHP-8-0866"/></p><p>As is often true in Ruby, the answer is, <span class="emphasis"><em>Write your own method and add it to an existing class</em></span>. The RDoc for <code class="literal">merge_totals</code> starts at ❹ and explains what we want to happen. All we do is loop through <code class="literal">each</code> <code class="literal">key</code> of the <code class="literal">other_hash</code> (the one taken as an argument) and add its value for that <code class="literal">key</code> to <code class="literal">self[key]</code>. Simple. There’s a problem, though. What’s the value of <code class="literal">some_hash[some_key]</code> when <code class="literal">some_key</code> isn’t one of <code class="literal">some_hash</code>’s keys? The value is <code class="literal">nil</code>, and <code class="literal">nil</code> doesn’t like to be added. Let’s see what happens in irb:<a class="indexterm" id="idx-CHP-8-0867"/></p><a id="I_programlisting8_d1e14046"/><pre class="programlisting">irb(main):001:0&gt; h = { 0 =&gt; 1 }
=&gt; {0=&gt;1}
irb(main):002:0&gt; h[1]
=&gt; nil
irb(main):003:0&gt; h[1] + 0
<a class="indexterm" id="idx-CHP-8-0868"/>NoMethodError: undefined method '+' for nil:NilClass
        from (irb):3
        from :0</pre><p>That’s not good. We’ll need to find a way around that problem—but we’ll do that later in the <a class="indexterm" id="idx-CHP-8-0869"/>script. For now, know that <code class="literal">merge_totals</code> will properly add the counts for <a class="indexterm" id="idx-CHP-8-0870"/>tags in Hashes that follow the format <code class="literal">{ tag =&gt; tag_count }</code> when that tag is present.<a class="indexterm" id="idx-CHP-8-0871"/></p><p>We have one more method called <code class="literal">pretty_report</code> to add to all Hashes (❺). This method outputs a String showing each tag and its count within the document. It accomplishes that by sorting through <code class="literal">each</code> <code class="literal">pair</code> in the Array of Arrays returned by <code class="literal">sort_by_tag_count</code> from ❷, and creating an <code class="literal">output</code> String to which it adds a line with the <code class="literal">tag</code>, a colon, a space, the tag <code class="literal">count</code>, and a newline character. Then it <code class="literal">return</code>s that String. That’s it for the new methods in Hash.<a class="indexterm" id="idx-CHP-8-0872"/></p><p>This script also has two functions not attached as methods to the Hash: <code class="literal">get_elements_from_filename</code> (❻) and <code class="literal">tag_count</code> (❼). The <code class="literal">get_elements_from_filename</code> method takes one argument called <code class="literal">filename</code> and instantiates a new <code class="literal">REXML:: Document</code>, which takes an instance of File as its argument. We provide that File via <code class="literal">File.open(filename)</code>. Instances of <code class="literal">REXML::Document</code> have a method called <code class="literal">elements</code>, which does much of our script’s work for us, returning all the XML elements from the File.<a class="indexterm" id="idx-CHP-8-0873"/></p><p>The <code class="literal">tag_count</code> method takes those <code class="literal">elements</code> as an argument, it instantiates a new Hash called <code class="literal">count_of</code> at (❽), and passes <code class="literal">0</code> into the <code class="literal">new</code> method. This <code class="literal">0</code> argument sets the default value for this Hash, which is the value returned by <code class="literal">count_of</code> when it lacks the key it is asked for. This default of <code class="literal">0</code> is how we deal with the problem of adding tag counts that don’t yet exist in the <code class="literal">merge_totals</code> method. The <code class="literal">self</code> Hash has a default of zero, so when a new tag comes in to <code class="literal">merge_totals</code> (which we call at ❾), it is assumed to have a <code class="literal">count_of</code> <code class="literal">0</code> for that tag. Unlike <code class="literal">nil</code>, a <code class="literal">0</code> is happy to have another Integer added to it, so our addition problem is solved. We continue recursively, calling <code class="literal">tag_counts</code> on the <code class="literal">elements</code> found within each <code class="literal">tag</code>, which then calls <code class="literal">tag_counts</code> as needed on its own <code class="literal">elements</code>, if there are any. It all continues, aggregating tag counts with <code class="literal">merge_totals</code>.</p><div class="note" title="Note"><h3 class="title"><a id="note-49"/>Note</h3><p><span class="emphasis"><em>Hashes similar to</em></span> <em class="replaceable"><code>count_of</code></em> <span class="emphasis"><em>often benefit from having default values of either</em></span> <em class="replaceable"><code>0</code></em> <span class="emphasis"><em>or the empty string. Hashes serving as</em></span> <em class="replaceable"><code>histograms</code></em>, <span class="emphasis"><em>like</em></span> <em class="replaceable"><code>count_of</code></em>, <span class="emphasis"><em>count occurrences of something, and should have a default of</em></span> <em class="replaceable"><code>0</code></em>. <span class="emphasis"><em>Other hashes, which accumulate Strings for whatever reason, could have a default of the empty string. Since Strings know to concatenate with other objects, the script could accumulate Strings with</em></span> <em class="replaceable"><code>+=</code></em>, <span class="emphasis"><em>just as in our example, which uses Integers as Hash values</em></span>.<a class="indexterm" id="idx-CHP-8-0874"/></p></div><p>At ❿, we get the output of <code class="literal">tag_count</code>, which expects <code class="literal">elements</code>. We get those <code class="literal">elements</code> by calling <code class="literal">get_elements_from_filename</code> on the first command-line argument. Since <code class="literal">tag_count</code> returns a Hash, that return value has the method <code class="literal">pretty_report</code>, which provides the argument to the <code class="literal">puts</code> method and provides information to the user.</p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id022"/>Running the Script</h2></div></div></div><p>Let’s use the file <code class="literal">extras/eh.html.tidy</code>, the corrected output provided by the <code class="literal">html_tidy.rb</code> script. Let’s try <code class="literal">ruby -w xml_tag_counter.rb extras/eh.html.tidy</code>:<a class="indexterm" id="idx-CHP-8-0875"/></p></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id027"/>The Results</h2></div></div></div><p>Here’s the output:</p><a id="I_programlisting8_d1e14294"/><pre class="programlisting">div: 2
meta: 2
p: 2
style: 2
td: 2
body: 1
em: 1
h1: 1
head: 1
html: 1
img: 1
table: 1
th: 1
title: 1
tr: 1</pre></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id019"/>Hacking the Script</h2></div></div></div><p>What if we wanted <code class="literal">sort_by_tag_count</code> to return a Hash, rather than an Array? We could theoretically make a method like this:</p><a id="I_programlisting8_d1e14304"/><pre class="programlisting">def sorted_by_tag_count()
  # sort_by_tag_count returns an Array of Arrays...
  sort_by_tag_count.inject({}) do |memo,pair|
    tag, count = pair
    memo.merge( { tag =&gt; count } )
  end
  # so we can re-Hash it with inject
end</pre><p>The problem is all Hash pairs are unordered. Our new <code class="literal">sorted_by_tag_count</code> goes to all the trouble of calling <code class="literal">sort_by_tag_count</code> but then rehashes it, losing the ordering.</p><p>What if we wanted to implement <code class="literal">pretty_report</code> with <code class="literal">inject</code>? Here’s one way to do it. Notice how the method becomes a bit shorter, and the <code class="literal">output</code> variable becomes internal to <code class="literal">inject</code>.</p><a id="I_programlisting8_d1e14328"/><pre class="programlisting">def pretty_report()
  sort_by_tag_count.inject('') do |output,pair|
    tag, count = pair
    output += "#{tag}: #{count}\n"
  end
end</pre><p>Finally, instead of calling <code class="literal">get_elements_from_filename</code> only on the first command-line argument, we could have used <code class="literal">ARGV.each</code> to allow the <a class="indexterm" id="idx-CHP-8-0876"/>script to analyze multiple files in succession.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-8-FNOTE-3" id="ftn.CHP-8-FNOTE-3">27</a>] </sup>To paraphrase George Orwell’s <span class="emphasis"><em>Animal Farm</em></span>, “All <code class="literal">sort</code>s are equal, but some are more equal than others.”</p></div></div></div>
<div class="sect1" title="#32 Extracting Text from XML (xml_text_extractor.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp32_extracting_text_from_xml_xml_tex"/>#32 Extracting Text from XML (xml_text_extractor.rb)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-8-0877"/>Counting occurrences of <a class="indexterm" id="idx-CHP-8-0878"/>tags is fine, but XML is designed to hold text wrapped in <a class="indexterm" id="idx-CHP-8-0879"/>tags, providing some organization beyond what’s available simply from the content. That said, though, sometimes having just the text content is handy. When I was preparing a document using DocBook, I found myself wanting to use a <a class="indexterm" id="idx-CHP-8-0880"/>spell checker on it. There are spell checkers that are XML-aware, but another approach would be to run a text extractor on XML and pass that output into a <a class="indexterm" id="idx-CHP-8-0881"/>spell checker that expects plain text. This <code class="literal">xml_text_extractor.rb</code> is just such a script.<a class="indexterm" id="idx-CHP-8-0882"/><a class="indexterm" id="idx-CHP-8-0883"/><a class="indexterm" id="idx-CHP-8-0884"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id031"/>The Code</h2></div></div></div><a id="I_programlisting8_d1e14392"/><pre class="programlisting">  #!/usr/bin/env ruby
  # xml_text_extractor.rb

❶ CHOMP_TAG = lambda { |tag| tag.to_s.chomp }

  =begin rdoc
  This script uses the Rexml parser, which is written in Ruby itself.
  Find out more at http://www.germane-software.com/software/rexml
  =end
❷ require 'rexml/document'

  =begin rdoc
  Returns DOM elements of a given filename.
  =end
❸ def get_elements_from_filename(filename)
    REXML::Document.new(File.open(filename)).elements()
  end

  =begin rdoc
  Returns a &lt;b&gt;String&lt;/b&gt; consisting of the text of a given XML document
  with the tags stripped.
  =end
❹ def strip_tags(elements)
❺   return '' unless (elements.size &gt; 0)
❻   return elements.to_a.map do |tag|
❼     tag.texts.map(&amp;CHOMP_TAG).join('') + strip_tags(tag.elements)    <em class="lineannotation"><span class="lineannotation">Mapping Procs onto Arrays</span></em>
❽   end.join('')
  end

❾ puts strip_tags(get_elements_from_filename(ARGV[0]))</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id030"/>How It Works</h2></div></div></div><p>This <code class="literal">xml_text_extractor.rb</code> script is similar to <code class="literal">xml_tag_counter.rb</code>, although it is simpler—ironic, since its output is arguably more complex. It starts out at ❶ by defining a Proc Constant called <code class="literal">CHOMP_TAG</code>, which accepts a single argument and returns the chomped version of that argument’s rendition as a String. Following that, it requires the <code class="literal">REXML</code> library at ❷, just as in <code class="literal">xml_tag_counter.rb</code>. At ❸, it defines its own version of <code class="literal">get_elements_by_filename</code>, identical to the one in <code class="literal">xml_tag_counter.rb</code>.<a class="indexterm" id="idx-CHP-8-0885"/><a class="indexterm" id="idx-CHP-8-0886"/></p><div class="note" title="Note"><h3 class="title"><a id="note-50"/>Note</h3><p><span class="emphasis"><em>These scripts are designed to demonstrate techniques, rather than to function as production code. For production code, the definition of a method that will be used in multiple places should reside in a single library file that is required by any other file that needs access to that method. Please forgive the duplication in this case for the sake of simplicity</em></span>.<a class="indexterm" id="idx-CHP-8-0887"/></p></div><p>Next, we have <code class="literal">strip_tags</code> at ❹. Contrast the design of this function with <code class="literal">pretty_report</code> in <code class="literal">xml_tag_counter.rb</code>. Rather than a more iterative approach of (for example) defining an output variable looping through an Array with the <code class="literal">each</code> method and appending results onto the output variable), this uses a more functional approach. It maps an action onto each member of <code class="literal">elements</code> (which it calls <code class="literal">tag</code>) at ❻. That action is itself a mapping of the <code class="literal">CHOMP_TAG</code> Proc onto each member of <code class="literal">tag.texts</code> (❼). Then it <code class="literal">join</code>s the resulting Array with an empty String separator between each element, and appends the results of a recursive call to <code class="literal">strip_tags</code> onto the <code class="literal">elements</code> of <code class="literal">tag</code>. The result of a <code class="literal">map</code> is an Array, so it <code class="literal">join</code>s the elements of that Array with a space character before returning (❽). It also has an exit condition, which <code class="literal">return</code>s the empty String if there are no <code class="literal">elements</code> (❺).<a class="indexterm" id="idx-CHP-8-0888"/></p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id023"/>Running the Script</h2></div></div></div><p>Since <code class="literal">strip_tags</code> returns either the elements of a <code class="literal">map</code> joined on a space (which is a String) or the empty String, that String can easily be printed with <code class="literal">puts</code> at ❾. Let’s look at the output returned by <code class="literal">ruby -w xml_text_extracter.rb extras/eh.html.tidy</code>.</p></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id028"/>The Results</h2></div></div></div><a id="I_programlisting8_d1e14515"/><pre class="programlisting">  English Horn for No Clergy
/**/
@import url('../css/noclergy.css');
h1, h2 { display: none; }
/**/
/**/
 p.c1 {text-align:center;}
/**/ No Clergy:  I'm a header, but I don't know it. I'm some underlined
content I'm some italicized content I'm an unclosed paragraph. The horrors.</pre></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id020"/>Hacking the Script</h2></div></div></div><p>As I mentioned, one change that could be done on both <code class="literal">xml_text_extractor.rb</code> and <code class="literal">xml_tag_counter.rb</code> would be to take the common <code class="literal">get_elements_by_filename</code> method and place it in a single <a class="indexterm" id="idx-CHP-8-0889"/>library file that both <code class="literal">xml_text_extractor.rb</code> and <code class="literal">xml_tag_counter.rb</code> access via <code class="literal">require</code>. This operation has a name in the refactoring community: <span class="emphasis"><em>Pull Up Method</em></span>. The <code class="literal">xml_text_extractor.rb</code> script could also massage the output of <code class="literal">strip_tags</code>, stripping out empty lines and/or lines consisting entirely of whitespace, as <code class="literal">html_tidy.rb</code> does with <code class="literal">UNWANTED_REGEXES</code>.<a class="indexterm" id="idx-CHP-8-0890"/></p></div></div>
<div class="sect1" title="#33 Validating XML (xml_well_formedness_checker.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp33_validating_xml_xml_well_formedne"/>#33 Validating XML (xml_well_formedness_checker.rb)</h1></div></div></div><p>All the XML processing in the world won’t do any good if your XML file is not well-formed. Since an XML document either is or is not well-formed, a well-formedness checker that will <code class="literal">return</code> either <code class="literal">true</code> or <code class="literal">false</code> seems like an ideal predicate method. Since XML documents are Files with Strings as their contents, we’ll add a <code class="literal">well_formed_xml?</code> method to both the File class and the String class.<a class="indexterm" id="idx-CHP-8-0891"/><a class="indexterm" id="idx-CHP-8-0892"/><a class="indexterm" id="I_indexterm8_d1e14588"/><a class="indexterm" id="I_indexterm8_d1e14591"/><a class="indexterm" id="I_indexterm8_d1e14596"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id032"/>The Code</h2></div></div></div><a id="I_programlisting8_d1e14604"/><pre class="programlisting">  #!/usr/bin/env ruby
  # xml_well_formedness_checker.rb

  =begin rdoc
  This script uses the xml/dom/builder, written by YoshidaM.
  =end
❶ require 'xml/dom/builder'    <em class="lineannotation"><span class="lineannotation">The DOM</span></em>

  class File

❷   def well_formed_xml?()
      read.well_formed_xml?
    end

  end

  class String

❸   def well_formed_xml?()
      builder = XML::DOM::Builder.new(0)
      builder.setBase("./")    <em class="lineannotation"><span class="lineannotation">Root Element</span></em>

❹     begin
        builder.parse(self, true)
❺     rescue XMLParserError
        return false
      end

❻     return true
    end

  end

❼ def well_formed?(filename)
❽   return unless filename
❾   return File.open(filename, 'r').well_formed_<a class="indexterm" id="idx-CHP-8-0893"/>xml?
  end

❽ puts well_formed?(ARGV[0])</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id031"/>How It Works</h2></div></div></div><p>At ❶, we require the <code class="literal">XML::DOM::Builder</code> library file, which is available as part of Ruby’s standard library. DOM stands for <span class="emphasis"><em>Document Object Model</em></span>, and it’s a way to express an XML document as a object with methods like <code class="literal">elements</code>, which returns the elements found within whatever <code class="literal">self</code> is at the time—it could be the entire document, or it could be a sub-element within the document. We’ve used <code class="literal">elements</code> already in our previous scripts with the <code class="literal">REXML</code> library.<a class="indexterm" id="idx-CHP-8-0894"/></p><div class="note" title="Note"><h3 class="title"><a id="note-51"/>Note</h3><p><span class="emphasis"><em>Programmers that do a lot of Ajax or other JavaScript are intimately familiar with the DOM. Because JavaScript’s most common use is as a client-side scripting language within web browsers, JavaScript programs often find themselves dealing with XML (especially XHTML) data. JavaScript is an excellent language with a terribly misleading name and some poor implementations. It shares a similar fused OO/functional heritage with Ruby</em></span>.<a class="indexterm" id="idx-CHP-8-0895"/></p></div><p>We said that we’d be adding a <code class="literal">well_formed_xml?</code> predicate to File, which is what we do at ❷. The <code class="literal">read</code> method of a File returns the contents of that File as a String. We know that we want to add <code class="literal">well_formed_xml?</code> to all Strings as well as all Files, so we just call <code class="literal">read.well_formed_xml?</code> within File’s <code class="literal">well_formed_xml?</code> method and assume that String will do its job and provide its own version of <code class="literal">well_formed_xml?</code> for us.</p><p>We don’t want to make Strings out to be liars, so we provide String with its own <code class="literal">well_formed_xml?</code> predicate at ❸. This delegates some of its work to the <code class="literal">XML::DOM::Builder</code> library, instantiating a <code class="literal">Builder</code> and setting its base to <code class="literal">‘./’</code>, which stands for the root element of an XML document.<a class="indexterm" id="idx-CHP-8-0896"/></p><div class="note" title="Note"><h3 class="title"><a id="note-52"/>Note</h3><p><span class="emphasis"><em>The</em></span> <em class="replaceable"><code>0</code></em> <span class="emphasis"><em>argument to</em></span> <em class="replaceable"><code>XML::DOM::Builder.new</code></em> <span class="emphasis"><em>tells it to ignore default events, which has no impact our script. You can read more about</em></span> <em class="replaceable"><code>XML::DOM::Builder</code></em> <span class="emphasis"><em>at</em></span> <a class="ulink" href="http://raa.ruby-lang.org/gonzui/markup/xmlparser/lib/xml/dom/builder.rb?q=moduledef:XML">http://raa.ruby-lang.org/gonzui/markup/xmlparser/lib/xml/dom/builder.rb?q=moduledef:XML</a>.</p></div><p>We then start a block at ❹ with the <code class="literal">begin</code> keyword, which indicates a block that may fail so disastrously to do what’s asked of it that it could exit the program entirely. The <code class="literal">begin</code> keyword allows you to trap that error and deal with it in some intelligent way, without causing the program to crash. We ask our <code class="literal">builder</code> instance to <code class="literal">parse</code> the XML content represented by <code class="literal">self</code>, which is of course a String within a String instance.<a class="indexterm" id="idx-CHP-8-0897"/></p><p>This parse operation is the one that might fail. The potentially disastrous error has a type called <code class="literal">XMLParserError</code>, so at ❺ we use the <code class="literal">rescue</code> keyword to trap that particular error type and prevent it from killing the entire program. Since our predicate tests for <a class="indexterm" id="idx-CHP-8-0898"/>XML well-formedness, an <code class="literal">XMLParserError</code> indicates that the document is not well-formed. Therefore, we should <code class="literal">return</code> <code class="literal">false</code> in the event of an <code class="literal">XMLParserError</code>. If we get out of the <code class="literal">begin</code> block without entering the <code class="literal">rescue</code> section, that means there was no error, so we can safely <code class="literal">return</code> <code class="literal">true</code> at ❻.<a class="indexterm" id="idx-CHP-8-0899"/><a class="indexterm" id="idx-CHP-8-0900"/><a class="indexterm" id="idx-CHP-8-0901"/></p><p>We’ll finish the <code class="literal">xml_wellformedness_checker.rb</code> script with a <code class="literal">well_formed?</code> function that accepts a <code class="literal">filename</code> argument, created at ❼. It <code class="literal">return</code>s an implicit <code class="literal">nil</code> for a <code class="literal">nil filename</code> at ❽. We then <code class="literal">return</code> a call to <code class="literal">well_formed_xml?</code> on the File instance created by opening <code class="literal">filename</code> at ❾. Finally, ❿ prints the result of calling <code class="literal">well_formed?</code> to the user via <code class="literal">puts</code>.</p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id024"/>Running the Script</h2></div></div></div><p>We know that we have a well-formed XML file in <code class="literal">extras/eh.html.tidy</code> because we ran <code class="literal">html_tidy.rb</code> on it to fix it. We also know that <code class="literal">extras/eh.html</code> had an unclosed paragraph tag, which would make it not well-formed. Let’s see how <code class="literal">xml_wellformedness_checker.rb</code> performs.</p></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id029"/>The Results</h2></div></div></div><a id="I_programlisting8_d1e14841"/><pre class="programlisting">ruby -w xml_well_formedness_checker.rb extras/eh.html.tidy
true
$ ruby -w xml_well_formedness_checker.rb extras/eh.html
false
$ ruby -w xml_well_formedness_checker.rb xml_well_formedness_checker.rb
false
$ ruby -w xml_well_formedness_checker.rb
nil</pre><p>The <code class="literal">extras/eh.html.tidy</code> file is well-formed XML, so it properly reports <code class="literal">true</code>. The <code class="literal">extras/eh.html</code> and <code class="literal">xml_wellformedness_checker.rb</code> files are either not well-formed XML or not XML at all, so they properly report <code class="literal">false</code>. If we call <code class="literal">xml_wellformedness_checker.rb</code> with no <code class="literal">filename</code>, it returns <code class="literal">nil</code>, as we expect from ❽.<a class="indexterm" id="I_indexterm8_d1e14870"/><a class="indexterm" id="I_indexterm8_d1e14873"/></p></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id021"/>Hacking the Script</h2></div></div></div><p>Calling a separate function called <code class="literal">well_formed?</code> on a <code class="literal">filename</code> argument is really just for demonstration purposes. In production code, a more likely use for this script would be to add another method to String called <code class="literal">well_formed_xml_filename?</code>, implemented as <code class="literal">well_formed?</code>, except that it would use <code class="literal">self</code> in place of <code class="literal">filename</code>. Or, in whatever code opens a given XML file, that file could be checked using File’s <code class="literal">well_formed_xml?</code> method before performing any operations that depend on the file’s contents being well-formed XML.</p></div></div>
<div class="sect1" title="Chapter Recap"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_recap-id006"/>Chapter Recap</h1></div></div></div><p>What was new in this chapter?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Tidying HTML/XML markup</p></li><li class="listitem"><p>Piping output to standard error with <code class="literal">2&gt;</code></p></li><li class="listitem"><p>The Web Accessibility Initiative</p></li><li class="listitem"><p>The <code class="literal">&lt;=&gt;</code> method and the Comparable module</p></li><li class="listitem"><p>Processing XML with <code class="literal">REXML</code> and <code class="literal">XML::DOM::Builder</code></p></li><li class="listitem"><p>Manipulating XML documents with regular expressions</p></li><li class="listitem"><p>Making Hashes out of Arrays with <code class="literal">inject</code></p></li><li class="listitem"><p>Hashes serving as histograms</p></li><li class="listitem"><p>Mapping Procs onto Arrays</p></li><li class="listitem"><p>The Document Object Model</p></li><li class="listitem"><p>The <code class="literal">begin</code> and <code class="literal">rescue</code> keywords</p></li></ul></div><p>That’s it for our XML-processing scripts. I hope these example scripts are not only useful in and of themselves but that they also might give you ideas about how you could modify or extend them to suit new tasks other than those presented here. For now, we’ll proceed to our next chapter, <a class="xref" href="ch09.html" title="Chapter 9. More Complex Utilities and Tricks, Part I">Chapter 9</a>. As the name suggests, its scripts are more detailed, and they will continue to introduce some new functional techniques, as well.</p></div></body></html>