- en: '![](../images/31-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[**MANAGING DAEMONS**](toc.html#chapter2)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/as.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At their core, most appliances have an application or daemon that performs the
    defining function of the appliance, with one or more user interfaces managing
    the core application or daemon. Figure 2-1 shows a typical appliance architecture
    that might already be similar to what you have in mind for your appliance.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way that the defining application is managed by user interfaces
    (UIs), the common services, such as a webserver or system logger, need to be managed
    as well. Because the main application and most common services are implemented
    as daemons, the problem of management comes down to the problem of managing daemons.
    The focus of this chapter is how best to manage daemons.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • Common approaches to managing daemons
  prefs: []
  type: TYPE_NORMAL
- en: • Control and status protocol
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/32-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: Typical user interfaces to an application*'
  prefs: []
  type: TYPE_NORMAL
- en: '[**Common Approaches to Managing Daemons**](toc.html#chapter2.1)'
  prefs: []
  type: TYPE_NORMAL
- en: By *managing* a daemon, we mean configuring the daemon, collecting statistics
    from it, and being able to view its current status. Most Linux daemons use ASCII
    text files for such communication, but there are other options for you to consider
    when building your daemon. The next few sections will describe various daemon-management
    methods and their pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: '[***File-Based Management***](toc.html#chapter2.2)'
  prefs: []
  type: TYPE_NORMAL
- en: Daemons are commonly managed or monitored through a few configuration files
    that control their run-time parameters, status, and logging. For example, the
    DHCP daemon, dhcpd, is controlled by the /etc/dhcpd.conf configuration file; its
    status is displayed in /var/state/dhcp/dhcpd.leases; its start-up script is in
    /etc/rc.d/init.d/dhcpd; and its logs are in /var/log/messages. There is little
    uniformity, however, in how a daemon’s configuration is stored or how its status
    is made available. Status and other state changes are often logged using syslog(),
    but many applications use custom routines for logging and store their log files
    in a non-standard format. Figure 2-2 shows the typical flow of a daemon that uses
    files for configuration and management.
  prefs: []
  type: TYPE_NORMAL
- en: 'A file-based approach has the following limitations for appliances:'
  prefs: []
  type: TYPE_NORMAL
- en: • There is no good way to get status or statistics from most running applications.
    While an application could write status and statistics to files, to do so in real
    time (or anything close to real time) would probably be too heavy a load on the
    CPU and filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: • You need to be able to edit the configuration file, which is not always easy
    on an appliance.
  prefs: []
  type: TYPE_NORMAL
- en: • To apply new settings, you usually have to restart a running daemon, which
    may disrupt service and cause problems for users.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/33-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: The most common way to manage a daemon*'
  prefs: []
  type: TYPE_NORMAL
- en: Despite the limitations of file-based interfaces, many applications use them
    for Unix system administration, and they will probably remain popular. If you
    are building a new application and you’ve chosen to use file-based application
    management, consider using libini or an XML parsing library. Also, applications
    like Webmin can help by offering a web front end that allows you to display and
    edit many configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that very simple applications (including some daemons) may never
    need run-time access to status, statistics, and configuration. There might not
    be any reason to switch from the traditional .conf and .log file approach of Unix.
    It is up to you to decide which approach is best for your particular application.
  prefs: []
  type: TYPE_NORMAL
- en: '[***A Daemon-Based Web Interface***](toc.html#chapter2.3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common approach to daemon management is to offer a web interface directly
    from the daemon. For example, cupsd, the daemon for the print spooler CUPS, provides
    its own web interface on TCP port 631\. This approach is viable for simple daemons,
    but it has two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: • You will need to maintain code in your daemon to support the HTTP implementations
    in many different browsers.
  prefs: []
  type: TYPE_NORMAL
- en: • It can be difficult to add additional interfaces when they are required.
  prefs: []
  type: TYPE_NORMAL
- en: Case in point, we needed run-time access to status and configuration for one
    of our projects, so we added a built-in web interface. What a coding nightmare!
    It seemed to take forever to get all of the details of HTTP right and to make
    the resulting code compatible with all of the major web browsers. If you decide
    to build a web interface directly into your daemon, do yourself a favor and use
    an HTTP library like libhttpd from Hughes Technologies. Because other coders,
    experts in HTTP, keep it up to date regarding the quirks of various browsers,
    your maintenance will be much easier.
  prefs: []
  type: TYPE_NORMAL
- en: This same project also highlights the second problem. Once the web interface
    was working, the customer requested we add an SNMP interface. The fastest way
    to do this was to add SNMP directly to the daemon as we did with the web interface.
    This addition put us well on the path to what we call an “all-in-one” approach,
    which is described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '[***An All-in-One Approach***](toc.html#chapter2.4)'
  prefs: []
  type: TYPE_NORMAL
- en: If you know that your users need to interact with your daemon while it is running,
    and if your running daemon needs more than one type of interface, you might be
    tempted to add the necessary interfaces directly to the daemon. Figure 2-3 shows
    a daemon that is not only trying to perform its real task but is also trying to
    support multiple, simultaneous user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/34-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Adding all the user interfaces directly to the daemon*'
  prefs: []
  type: TYPE_NORMAL
- en: We used a bundling approach like this in one of our early designs, but we found
    that it created a lot of problems. Because only a few developers could work on
    the appliance at a time, development became serial, so developers had to code
    both the main daemon and all of the user interfaces. The tight coupling between
    UI and daemon made it more difficult to isolate changes to one section of code.
    We were afraid that even simple user interface changes might have side effects,
    so we made every change wait for the full regression testing of a major release.
    The whole development and release cycle became much slower.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with the all-in-one approach is performance. If all the user
    interfaces run directly from the daemon, the daemon may spend all of its CPU cycles
    in some possibly unimportant interface request while ignoring the real work it
    needs to do.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Control and Status Protocols**](toc.html#chapter2.5)'
  prefs: []
  type: TYPE_NORMAL
- en: One way to overcome the limitations of the approaches described above is to
    use a protocol for control and status to separate the daemon from the user interfaces.
    Figure 2-4 illustrates a daemon offering a single application programming interface
    (API) to be used by all of the clients and user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/35-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Using one protocol between the daemon and user interfaces*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A control and status protocol has several advantages over the alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduced complexity for multiple user interfaces**'
  prefs: []
  type: TYPE_NORMAL
- en: A control and status protocol simplifies the user interface logic in the daemon,
    since the daemon only needs to implement that protocol. The user interfaces can
    be implemented independently using the languages and tools appropriate to the
    interface. For example, a web interface could be built with Apache and PHP, while
    an SNMP interface could be built with Net-SNMP and C.
  prefs: []
  type: TYPE_NORMAL
- en: '**Access to the daemon while it is running**'
  prefs: []
  type: TYPE_NORMAL
- en: Users want access to an application while it is running in order to get status,
    statistics, and run-time debugging information. A control and status protocol
    can give you a competitive advantage over applications that are limited to configuration
    file access only at startup and SIGHUP. You might note that Microsoft users do
    not configure a daemon by editing a file; they configure the daemon through the
    daemon itself. Therefore, designing your daemon to be configured in this way can
    make it easier for Microsoft users to migrate to your software.
  prefs: []
  type: TYPE_NORMAL
- en: '**Remote network access**'
  prefs: []
  type: TYPE_NORMAL
- en: Remote access can speed development and testing, since you can work on the appliance
    from almost any networked workstation. Remote access is useful to your customers
    who manage a large number of appliances from a central operations management center.
    Furthermore, good remote access will be required by your technical support staff
    to help diagnose problems in the field.
  prefs: []
  type: TYPE_NORMAL
- en: '**Parallel development**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decoupling the management user interfaces from the daemon means that you can
    have two teams working on the project in parallel. Staffing is easier because
    you can hire people with just the skills needed to develop a specific piece of
    the project. Separating user interface developers and daemon developers has another
    advantage: It forces you to think through and define your daemon’s interface early
    in the development, when changes are easiest to make.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easy test scaffolding**'
  prefs: []
  type: TYPE_NORMAL
- en: Because the user interface is separate from the daemon, building a test scaffold
    around each piece of code is a clean and easy process. Once you build a scaffold,
    you can test even if all the pieces aren’t in place.
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved security**'
  prefs: []
  type: TYPE_NORMAL
- en: Using a control and status protocol for your daemon can increase the security
    of your appliance in two ways. First, the user interfaces need not run with the
    same special privileges as the daemon, which means that less code with special
    privileges is running at any given time. Second, using a tightly defined protocol
    lets you focus on securing the protocol and its API. This is much easier than
    securing, say, an all-in-one approach.
  prefs: []
  type: TYPE_NORMAL
- en: A control and status protocol can use a serial connection, a Unix or TCP socket,
    or file reads and writes, or it might be hidden in a library call. These techniques
    are described later in this chapter. As a preview, consider the following examples,
    which set a single bit called *cntl_pt*.
  prefs: []
  type: TYPE_NORMAL
- en: AT commands ATS301=1
  prefs: []
  type: TYPE_NORMAL
- en: XML <rpc><cntrl_pt><value>1</value></cntrl_pt></rpc>
  prefs: []
  type: TYPE_NORMAL
- en: Library call ret = set_cntl_pt(1);
  prefs: []
  type: TYPE_NORMAL
- en: /proc echo 1 > /proc/sys/mydev/cntl_pt
  prefs: []
  type: TYPE_NORMAL
- en: SQL UPDATE my_table SET cntl_pt = 1
  prefs: []
  type: TYPE_NORMAL
- en: '[***Requirements for a Control and Status Protocol***](toc.html#chapter2.6)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you design your own control and status protocol, you should judge your design
    on the following criteria: its data model on client and daemon, its re-use of
    existing protocols and software, the constraints it places on clients and daemons,
    and the ease with which you can discover its system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The data model**'
  prefs: []
  type: TYPE_NORMAL
- en: The control and status protocol should allow the client and daemon to have the
    same data model. That is, if the daemon uses variables, structures, lists, and
    arrays, then the client on the other side of the control and status protocol should
    also support variables, structures, lists, and arrays. Having the same data models
    on both sides of the protocol can make it easier to re-use code, and it helps
    programmers maintain a consistent view of the problem they’re trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use existing standards and code**'
  prefs: []
  type: TYPE_NORMAL
- en: The control and status protocol should use existing software and standards whenever
    possible. You may be able to find developers who already know the protocols and
    software, and existing protocols and software are likely to have good documentation
    for the developers who need to learn them. Using existing code is almost always
    a good idea, since less new code means fewer new bugs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Few constraints on the daemon and clients**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, the protocol would place few constraints on how you design your daemon
    and wouldn’t increase the daemon’s size. You should be able to add the control
    and status protocol to your program with few changes to the main source files.
    When retrofitting old programs with the control and status protocol, you should
    be able to put the bulk of the new code in separate source files, instead of interweaving
    the changes into the main code base. Client binding for your protocol should be
    available for all the major programming languages: at least Java and PHP for web
    interfaces, and C and C++ for compiled code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Discovery mechanism**'
  prefs: []
  type: TYPE_NORMAL
- en: We want to discover the information that is available from the appliance without
    relying on documentation. For example, the ls command discovers which files are
    available in a Unix filesystem; the get-next operator discovers what is in a SNMP
    MIB; and the system tables in a database describe the database itself. In a similar
    way, we want a mechanism whereby a user can discover what can be configured on
    an appliance and what information is available from the appliance.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Common Control and Status Protocols***](toc.html#chapter2.7)'
  prefs: []
  type: TYPE_NORMAL
- en: In our work we have developed several control and status protocols, which we
    will describe in this section. As you’re reading, try to judge them in terms of
    the four criteria presented in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: '**AT Commands**'
  prefs: []
  type: TYPE_NORMAL
- en: In our first control and status protocol, we used a variation of the Hayes AT
    command set. The appliance we were working with was a radio modem, so most of
    our customers were already familiar with that command set, making it a logical
    choice. Our daemon listened for incoming TCP connections and offered an AT command
    interpreter to accepted connections. Using TCP gave us remote access for diagnostics
    and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: We stored the system configuration as a list of AT commands. At system startup
    the daemon would read the configuration file and run it through the AT command
    interpreter. This approach meant that we did not need to add code to process a
    different format for the configuration files. While XML and INI are the standards
    in storing configuration, we did not want to add code and complexity if we could
    easily avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: The AT command protocol had two limitations. First, we could not conveniently
    access data arrays using the standard AT S-register syntax. Second, client-side
    programmers had to write a lot of code to generate the AT commands and parse the
    replies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extensible Markup Language**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We used Extensible Markup Language (XML) as the control and status format in
    a project to manage Juniper routers. Examples of XML protocols include XML-RPC,
    SOAP, and JUNOScript. JUNOScript manages Juniper routers through a telnet or SSH
    connection. It enables you to encode commands in XML, and the router then replies
    with XML responses. For example, a request for the running configuration looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: <rpc>
  prefs: []
  type: TYPE_NORMAL
- en: <get-configuration/>
  prefs: []
  type: TYPE_NORMAL
- en: </rpc>
  prefs: []
  type: TYPE_NORMAL
- en: Prior to the availability of JUNOScript Juniper routers were configured via
    a command-line interface (CLI). The advantages of XML over CLI become apparent
    when you manage routers with a program rather than by hand (especially if you
    have to write that program). It is easier to write code for parsing XML responses
    than for parsing CLI responses. Other advantages of XML include its flexibility
    in representing rich data and the availability of software libraries for processing
    XML formats.
  prefs: []
  type: TYPE_NORMAL
- en: Exchanging XML data between a client and server requires the addition of a transport
    protocol. You could use telnet or SSH, like JUNOScript does, or you could use
    HTTP, as specified by the SOAP and XML-RPC standards.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you would use a library to parse the XML on the server side, and
    then marshal the parsed XML elements into the server’s internal data structures.
    The code to map the XML to the internal data structures can be complex and error
    prone, since the XML structure seldom maps directly onto the data model used in
    the daemon.
  prefs: []
  type: TYPE_NORMAL
- en: If you build your control and status protocol using XML, you should consider
    using the Simple API for XML (SAX). SAX uses an event-driven model for processing
    the XML, and it is a better fit for the kinds of dialogs found in a control and
    status protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Library Calls**'
  prefs: []
  type: TYPE_NORMAL
- en: For another project, we used the popular technique of hiding the protocol from
    the developer by wrapping it in the subroutines of an API. In this case, the daemon
    and client programmers included shared object libraries in their code, and neither
    dealt with the protocol directly. The library routines in the API *became* the
    protocol as far as the developers were concerned. So ubiquitous is this approach
    that many programmers cannot imagine an alternative. They start a project with
    the assumption that they’ll build a daemon and a library, and clients of the daemon
    must include the library in order to talk to the daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Our advice is to let other programmers write libraries and to avoid it yourself.
    Most of the reasons for saying this distill down to minimizing the number of lines
    of code you have to write and maintain. Hiding the protocol in a library API does
    not remove the need to code the protocol and library. You still need to think
    about which IPC to use and the actual protocol to use over that IPC. Perhaps the
    biggest burden is writing and maintaining the client-side libraries for all of
    the programming languages of interest—gone are the days when you could write a
    C library and be done. You’ll want the library available in Java and PHP for web
    interfaces, and in Perl and as a shell command for scripts and testing. Few companies
    have all the experts on staff that are needed to write and document these libraries,
    and fewer still have the time to properly maintain and update the libraries after
    each revision change.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve gone the route of trying to write libraries for our daemons, and one of
    the things we found was that we kept reinventing the wheel. Every library, no
    matter how similar to the previous, was written for the daemon at hand, so we
    had to write a different library for every daemon. While we tried to re-use code,
    this process fell far short of ideal. How nice it would have been to have just
    one library (and one underlying protocol) that we could have used for all of our
    daemons.
  prefs: []
  type: TYPE_NORMAL
- en: Having one library per daemon is particularly problematic for embedded systems,
    in that you may have to give up a lot of system RAM in order to load all the libraries
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Structured Query Language**'
  prefs: []
  type: TYPE_NORMAL
- en: In an attempt to have just one control and status protocol for all of our daemons,
    we tried Structured Query Language (SQL) text commands over TCP and modeled the
    data in our daemon as tables in a database. The daemon accepted a TCP connection
    and presented an SQL command line interpreter to the client. This protocol allowed
    us to represent arrays (and lists) in the control and status protocol, thus solving
    one of the limitations of the AT command protocol. Figure 2-5 illustrates the
    basic idea.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/39-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: SQL as a control and status protocol*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a typical command over the TCP connection might be the string:'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT Column_A FROM Table_A
  prefs: []
  type: TYPE_NORMAL
- en: The command interpreter was then responsible for parsing the SQL string and
    accessing the appropriate “table.” Table is in quotations because the data in
    the daemon could be represented by arbitrary data structures, and it was the responsibility
    of the SQL interpreter to make these arbitrary data structures appear as tables
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the AT control and status protocol, our configuration files were
    stored as text files with SQL commands; this eliminated the need for libraries
    to parse XML or INI files.
  prefs: []
  type: TYPE_NORMAL
- en: The best part of this approach was that the data in the daemon was already stored
    as arrays of structs, so the shift to a “table” paradigm was trivially easy for
    the programmers. The limitation of this protocol was the amount of code that had
    to be developed on the user interface or client side. Because the protocol was
    text based, we had to write client-side code to format and send the request and
    to parse the response. This code had to be rewritten for each programming language
    that the particular client was written in. In our case, there was significant
    effort required because we developed a Windows C++ client, a Java client, a Mac
    OS 9 C client, and a Linux C client.
  prefs: []
  type: TYPE_NORMAL
- en: '**PostgreSQL**'
  prefs: []
  type: TYPE_NORMAL
- en: Our final control and status protocol overcomes the limitations of the previous
    one. It is similar to our SQL protocol in that it models the daemon’s data as
    tables in a database and it uses TCP or Unix sockets between the daemon and the
    client. The difference is that instead of a proprietary text-based protocol, it
    uses the PostgreSQL protocol. Using PostgreSQL means we can use the client-side
    PostgreSQL binding for C, Java, PHP, bash, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: All of the hard work of offering up a daemon’s internal data structures as database
    tables is handled by a library called *Run-Time Access (RTA)*. We link our daemons
    with the RTA library, and after the daemons tell RTA about our tables, it offers
    them up as PostgreSQL database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Although RTA uses PostgreSQL as the control and status protocol, it is *not*
    a database. Rather, it uses a subset of the PostgreSQL protocol and client-side
    bindings as a means of reading and writing memory variables in a running daemon.
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL and RTA have several advantages as a control and status protocol.
    As mentioned, there are a number of PostgreSQL bindings already available in various
    languages, including C, C++, Java, Perl, Tcl, and Python. The availability of
    these bindings means that you will have less code to develop on the UI or client,
    so you are less constrained in how you write your UI clients. PostgreSQL has a
    liberal license and is exceptionally well documented, and the system tables in
    RTA can be used as a way to browse the data offered to the UI programs.
  prefs: []
  type: TYPE_NORMAL
- en: Security can be enhanced by using a Unix socket and setting the ownership and
    read/write permissions carefully. Use SELinux and the Linux Security Module for
    even more precise control over which programs can connect to RTA on the daemon.
    Consider using Stunnel or SSH with port forwarding for secure remote access.
  prefs: []
  type: TYPE_NORMAL
- en: While XML is popular, RTA and PostgreSQL have a few advantages over it. PostgreSQL
    offers both a data exchange format and a transport protocol. With RTA, you don’t
    need to marshal code to map the tree structure of XML into the daemon’s internal
    data structures, so the RTA approach requires less development than XML-based
    approaches. With RTA, the client can look directly at the daemon’s internal memory
    variables, and this functionality requires no additional development.
  prefs: []
  type: TYPE_NORMAL
- en: 'RTA is presented in greater detail in the next chapter, but a simple example
    might show how RTA works as seen from the UI client. Suppose that the daemon has
    an array of the following structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/41-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After telling RTA about the array (with rta_add_table()) you can use any PostgreSQL-enabled
    client to read and write data in the array. If you use psql, a PostgreSQL shell
    program, you can read the Zone table with the following SELECT command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/41-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This example shows a simple way to read variables from a running daemon.
  prefs: []
  type: TYPE_NORMAL
- en: There are some disadvantages to RTA. One is that the RTA library is written
    in C, which means that you can’t use RTA if your server process is written in
    another language—say, Java. Another disadvantage is that if your appliance is
    composed of multiple daemons, you’ll need to develop a management process to manage
    these daemons, while exposing only a *single* management point to the clients.
    To be fair, this last disadvantage is true of all control and status protocols.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Summary**](toc.html#chapter2.8)'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we discussed various ways to manage daemons. Simple daemons
    can use files for all management, but we believe that for Linux appliances with
    multiple user interfaces, a control and status protocol is best. We described
    the reasons to use a control and status protocol and presented some guidelines
    to follow if you decide to build your own.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we’ll show you how to incorporate RTA into a daemon so that
    the client has access to the daemon’s status, configuration, and statistics.
  prefs: []
  type: TYPE_NORMAL
- en: All of the examples used in the remainder of the book use PostgreSQL and the
    RTA library as the management protocol between daemons and user interfaces. Don’t
    be concerned if you choose not to use RTA, though. The book is more about appliance
    *design* than using particular libraries.
  prefs: []
  type: TYPE_NORMAL
