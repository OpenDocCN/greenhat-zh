- en: Chapter 7. SERVERS AND SCRAPERS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![SERVERS AND SCRAPERS](../Images/00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A powerful aspect of Ruby is that you can use it to develop ways to automate
    interactions with resources on the Web. This chapter gives a brief overview of
    how to play with web pages and concludes with a set of client/server scripts that
    can securely pass and execute commands. Interacting with and extracting data from
    the Web is important because there is a wealth of information available—this is
    known as *data mining*. Instead of mining for gold, we will look at different
    ways to mine for significant data and turn it into meaningful information.
  prefs: []
  type: TYPE_NORMAL
- en: Define
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Define
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: define.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This script will query the Web to retrieve the first definition of any user-specified
    word. The website being queried is [http://www.dictionary.com/](http://www.dictionary.com/),
    and like any script that interacts with the Web, there is risk of this script
    breaking if the web designers make any changes. The purpose of the script is to
    retrieve the data you specifically want. Using Dictionary.com is just a means
    to demonstrate that skill, although this is a slick example.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) require "open-uri"   unless ARGV[0]      puts "You
    must supply a word to define."      puts "USAGE: ruby define.rb <word to define>"
         exit  end  ![](../Images/00003.jpg) word = ARGV[0].strip  ![](../Images/00004.jpg) url
    = "http://dictionary.reference.com/search?q=#{word}"   begin ![](../Images/00005.jpg)  
      open(url) do |source|      source.each_line do |x| ![](../Images/00006.jpg)  
          if x =~ /No results found/          puts "\nPlease check spelling, no definition
    was found."          exit      end ![](../Images/00007.jpg)         if x =~ /(1\.)<\/td><td
    valign="top">(.*)<\/td/          puts "\n#{$1} #{$2}"          exit      end  end
    ![](../Images/00008.jpg)     puts "Sorry, unable to find a definition."  end  rescue
    => e      puts "An error occurred, please try again."      puts e  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute this script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby define.rb`** *`word to define`*``'
  prefs: []
  type: TYPE_NORMAL
- en: I chose to define the word *Ruby* in this example. Unfortunately, *the most
    wicked programming language* was not the first result returned!
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script will display the definition of any word supplied. If the definition
    can't be found, the user will be asked to check the spelling—perhaps the word
    doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: '`1.a red variety of corundum, used as a gem.`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again, we encounter the fantastic library open-uri ![](../Images/00002.jpg).
    Whenever a script deals with web interaction, there are a handful of useful libraries;
    I prefer open-uri because it abstracts even more of the network connection details
    than other libraries. After the required library is identified, some error checking
    is performed. I hope you're used to this code block by now. The first variable
    is called `word` and will hold the word that the user wants to define ![](../Images/00003.jpg).
    Next, the Dictionary.com URL is hardcoded into the variable `url` with the addition
    of the user-supplied word ![](../Images/00004.jpg). Thanks to the webmasters at
    Dictionary.com, appending a word to the URL will automatically return the definition.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we start a `begin/rescue` statement due to the volatile nature of web
    requests. HTTP requests are often answered with various error messages; dealing
    with those messages appropriately is the key to success in this script. Now that
    we've deployed our `begin/rescue` safety net, we are ready to ask Dictionary.com
    for the definition. open-uri lets us simply type `open()`, pass the URL to the
    method, and retrieve a web page ![](../Images/00005.jpg). I smile every time I
    use the `open` method because getting a web page is so easy.
  prefs: []
  type: TYPE_NORMAL
- en: The `open` method is followed by a block that manipulates the source code returned
    by the web server. Because we are looking for a particular line (the word's definition),
    we start another block of code that breaks the source code down line by line.
    Dictionary.com will display the message *No results found* if a word cannot be
    defined. If the script finds these words (but no definition) while analyzing the
    source code, it reminds the user to check the spelling of the word as a helpful
    hint, and then exits ![](../Images/00006.jpg). However, if the definition is found,
    the script will begin isolating exactly where the definition resides in the source
    code. A regular expression is used to pinpoint the exact text.
  prefs: []
  type: TYPE_NORMAL
- en: The important part of the regular expression is the `1`. Dictionary.com uses
    this as an annotation for the first definition, which is what we are interested
    in. Using parentheses in the regular expression allows the script to group certain
    areas of any line that match the expression ![](../Images/00007.jpg). The groups
    are stored in the variables `[$1]` through `[$n]`. The line after the regular
    expression outputs the definition. If neither the definition nor *No results found*
    are located in the source code, a different message is displayed, letting the
    user know the definition could not be found ![](../Images/00008.jpg). If any error(s)
    occurred during the definition process, our `rescue` block kicks off and specifies
    what error(s) occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to hack this script is by adding a proxy between the user and the request
    to the web server. If you are using a proxy, you must do this. If you are curious
    about the web traffic from Ruby, the proxy will give you a little insight. See
    the documentation for open-uri; the syntax will look something like `open(url,
    :proxy => "http://127.0.0.1:8080")`. I don't normally have a proxy in place when
    I'm surfing the Web, but when doing web development, I find it helpful to watch
    the traffic in case any errors are encountered.
  prefs: []
  type: TYPE_NORMAL
- en: In this instance, I use the free web proxy Paros ([http://www.parosproxy.org/](http://www.parosproxy.org/)).
    Paros is installed locally on my machine, and I can watch as my web requests are
    made and subsequent responses are received. I have saved many hours of debugging
    by having Paros involved in my development. I am very partial to Paros, but there
    are many other proxies from which to choose, so take a look around.
  prefs: []
  type: TYPE_NORMAL
- en: Automated SMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated SMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: sms.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This script sends an SMS message to whatever mobile phone number you choose.
    I caution you not to abuse the functionality, but you do have to try it. The premise
    is to automate the use of a site that sends SMS messages to people for you. Instead
    of grabbing static web content, this script will actually automate filling out
    and submitting a web form.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require ''win32ole''  ![](../Images/00002.jpg) ie = WIN32OLE.new(''InternetExplorer.Application'')
    ![](../Images/00003.jpg) ie.navigate("http://toolbar.google.com/send/sms/index.php")   ie.visible
    = true ![](../Images/00004.jpg) sleep 1 until ie.readyState() == 4  ![](../Images/00005.jpg) ie.document.all["mobile_user_id"].value
    ="5712013623"  ie.document.all["carrier"].value ="TMOBILE"  ie.document.all["subject"].value
    ="***Ruby Rulez***" ![](../Images/00006.jpg) ie.document.all.tags("textarea").each
    do |i|      i.value = "Thanks for the hard work, Matz!"  end  ![](../Images/00007.jpg) ie.document.all.send_button.click`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute this script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby googleS2P.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script doesn't output anything, but if successful, the phone attached to
    the phone number supplied should notify you of an incoming message. I've used
    fictitious data, but feel free to edit it for your amusement.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you own a computer with Windows and have never played with the library win32ole,
    you need to make time for it, because Windows automation is interesting and fun.
    Not only can you manipulate Internet Explorer (IE), as demonstrated in this script,
    but you can also manipulate any of the Microsoft Office products, as well as other
    Windows applications.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*There are several other libraries available for website automation that are
    extremely helpful for regression and quality assurance testing of web applications.
    One of the more popular examples is Watir (pronounced* Water *). Details for Watir
    can be found at* [http://wtr.rubyforge.org/](http://wtr.rubyforge.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: A new `win32ole` object is created with the IE handle passed as an argument
    ![](../Images/00002.jpg). This lets win32ole know what application will be under
    its control. Using the built-in methods associated with IE, `navigate` obviously
    goes to the specified URL, which is [http://toolbar.google.com/send/sms/index.php/](http://toolbar.google.com/send/sms/index.php/)
    ![](../Images/00003.jpg). The next line specifies an attribute of the IE window.
    If you chose not to watch the script work its magic, you can change this line
    to `false`, and the IE window will disappear into the background. Then you'd only
    be able to see its presence in the task list. Because I like to see the script
    executing, I've set this value to `true`. The Internet Explorer application pops
    up fast, so you have to be ready.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the page load conditional loop. As you know, websites do not load their
    content instantaneously. To prevent the script from submitting its information
    prematurely, this line tells the script to go to sleep for one second and then
    to check back for the correct `readyState` code, which is `4` ![](../Images/00004.jpg).
    Being premature is never a good thing, and it would break the script in this instance.
    Once the IE document has been fully loaded, the script is ready to fill in the
    appropriate fields.
  prefs: []
  type: TYPE_NORMAL
- en: The script knows which fields to look for by the attribute names. If you were
    to look at the source code of the website, you'd see objects called `mobile_user_id`,
    `carrier`, `subject`, and so on. We use this information to specify what input
    goes where ![](../Images/00005.jpg). Most of the HTML used in the website fits
    the standards, but for some reason, the name field of the text area is not put
    in quotation marks. That means we can't use the previous method to access the
    area. Since we saw there was only one text area in the source code, we search
    for it and input our data once it's found. Nothing too fancy, but a little different
    than the norm ![](../Images/00006.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: All that's left to do after the information is in place is to virtually click
    the send button. Google is great for properly naming buttons, so we just grab
    the button name and tell it to use the `click` method. ![](../Images/00007.jpg).
    That's all there is to it—Ruby is so cool!
  prefs: []
  type: TYPE_NORMAL
- en: Link Scrape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Link Scrape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: linkScrape.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scraping links off of web pages has many uses. As with any problem, there are
    many ways to solve it. In [Chapter 2](../Text/dummy_split_073.html#filepos190170)
    we wrote a script to validate links on a website. Because of the need to validate
    the links, the script required far more lines of code than if it had needed to
    simply scrape all of the links. We aren't going to be building a web spider, but
    I'll cover some of the basic components—the first of which is a link scraper.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) require ''mechanize''   unless ARGV[0]      puts
    "You must supply a website."      puts "USAGE: ruby linkScrape.rb <url to scrape>"
         exit  end  ![](../Images/00003.jpg) agent = WWW::Mechanize.new  agent.set_proxy(''localhost'',8080)   begin
    ![](../Images/00004.jpg)     page = agent.get(ARGV[0].strip)       page.links.each
    do |l|          if l.href.split("")[0] ==''/'' ![](../Images/00005.jpg)      
          puts "#{ARGV[0]}#{l.href}"          else              puts l.href       
      end      end  rescue => e      puts "An error occurred."      puts e      retry
     end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute this script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby linkScrape.rb`** *`http://url_to_scrape.com/`*``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script will output a list of all the links found on the page with the specified
    URL. I've scraped [http://www.nostarch.com/main_menu.htm/](http://www.nostarch.com/main_menu.htm/).
  prefs: []
  type: TYPE_NORMAL
- en: '| index.htm | interactive.htm |'
  prefs: []
  type: TYPE_TB
- en: '| catalog.htm | gimp.htm |'
  prefs: []
  type: TYPE_TB
- en: '| wheretobuy.htm | inkscape.htm |'
  prefs: []
  type: TYPE_TB
- en: '| about.htm | js2.htm |'
  prefs: []
  type: TYPE_TB
- en: '| jobs.htm | eblender.htm |'
  prefs: []
  type: TYPE_TB
- en: '| media.htm | oophp.htm |'
  prefs: []
  type: TYPE_TB
- en: '| [http://www.nostarch.com/blog/](http://www.nostarch.com/blog/) | wpdr.htm
    |'
  prefs: []
  type: TYPE_TB
- en: '| [http://ww6.aitsafe.com/cf/review/](http://ww6.aitsafe.com/cf/review/) |
    webbots.htm |'
  prefs: []
  type: TYPE_TB
- en: '| .cfm?userid=8948354 | google.htm |'
  prefs: []
  type: TYPE_TB
- en: '| abs_bsd2.htm | growingsoftware.htm |'
  prefs: []
  type: TYPE_TB
- en: '| openbsd.htm | rootkits.htm |'
  prefs: []
  type: TYPE_TB
- en: '| freebsdserver.htm | hacking2.htm |'
  prefs: []
  type: TYPE_TB
- en: '| debian.htm | voip.htm |'
  prefs: []
  type: TYPE_TB
- en: '| howlinuxworks.htm | firewalls.htm |'
  prefs: []
  type: TYPE_TB
- en: '| appliance.htm | securityvisualization.htm |'
  prefs: []
  type: TYPE_TB
- en: '| lcbk2.htm | silence.htm |'
  prefs: []
  type: TYPE_TB
- en: '| lme.htm | stcb4.htm |'
  prefs: []
  type: TYPE_TB
- en: '| nongeeks.htm | scsi2.htm |'
  prefs: []
  type: TYPE_TB
- en: '| lps.htm | cisco.htm |'
  prefs: []
  type: TYPE_TB
- en: '| mug.htm | cablemodem.htm |'
  prefs: []
  type: TYPE_TB
- en: '| ubuntu_3.htm | xbox.htm |'
  prefs: []
  type: TYPE_TB
- en: '| imap.htm | insidemachine.htm |'
  prefs: []
  type: TYPE_TB
- en: '| pf.htm | nero7.htm |'
  prefs: []
  type: TYPE_TB
- en: '| postfix.htm | wireless.htm |'
  prefs: []
  type: TYPE_TB
- en: '| webmin.htm | creative.htm |'
  prefs: []
  type: TYPE_TB
- en: '| endingspam.htm | ebaypg.htm |'
  prefs: []
  type: TYPE_TB
- en: '| cluster.htm | ebapsg.htm |'
  prefs: []
  type: TYPE_TB
- en: '| nagios.htm | geekgoddess.htm |'
  prefs: []
  type: TYPE_TB
- en: '| nagios_2e.htm | wikipedia.htm |'
  prefs: []
  type: TYPE_TB
- en: '| pgp.htm | indtb.htm |'
  prefs: []
  type: TYPE_TB
- en: '| packet.htm | sayno.htm |'
  prefs: []
  type: TYPE_TB
- en: '| tcpip.htm | networkknowhow.htm |'
  prefs: []
  type: TYPE_TB
- en: '| assembly.htm | sharing.htm |'
  prefs: []
  type: TYPE_TB
- en: '| debugging.htm | apple2.htm |'
  prefs: []
  type: TYPE_TB
- en: '| qt4.htm | newmac.htm |'
  prefs: []
  type: TYPE_TB
- en: '| vb2005.htm | cult_mac.htm |'
  prefs: []
  type: TYPE_TB
- en: '| vsdotnet.htm | ipod.htm |'
  prefs: []
  type: TYPE_TB
- en: '| codecraft.htm | art_of_raw.htm |'
  prefs: []
  type: TYPE_TB
- en: '| hownotc.htm | firstlego.htm |'
  prefs: []
  type: TYPE_TB
- en: '| idapro.htm | flego.htm |'
  prefs: []
  type: TYPE_TB
- en: '| mugperl.htm | legotrains.htm |'
  prefs: []
  type: TYPE_TB
- en: '| gnome.htm | sato.htm |'
  prefs: []
  type: TYPE_TB
- en: '| plg.htm | nxt.htm |'
  prefs: []
  type: TYPE_TB
- en: '| ruby.htm | nxtonekit.htm |'
  prefs: []
  type: TYPE_TB
- en: '| vbexpress.htm | zoo.htm |'
  prefs: []
  type: TYPE_TB
- en: '| wcj.htm | legobuilder.htm |'
  prefs: []
  type: TYPE_TB
- en: '| wcps.htm | nxtig.htm |'
  prefs: []
  type: TYPE_TB
- en: '| wcphp.htm | vlego.htm |'
  prefs: []
  type: TYPE_TB
- en: '| wcruby.htm | mg_databases.htm |'
  prefs: []
  type: TYPE_TB
- en: '| wcss.htm | mg_statistics.htm |'
  prefs: []
  type: TYPE_TB
- en: '| greatcode.htm | eli.htm |'
  prefs: []
  type: TYPE_TB
- en: '| greatcode2.htm | index.htm |'
  prefs: []
  type: TYPE_TB
- en: '| wpc.htm |  |'
  prefs: []
  type: TYPE_TB
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compare the code above with "#10 Web Page Link Validator" on [The Code](../Text/dummy_split_076.html#filepos194055)—quite
    a difference, right? Always think through a problem and remember to solve the
    problem in the simplest way possible. Some of the most elegant solutions are amazingly
    simple. This is a basic website link scraper without regard for validity or anything
    else. The mechanize library is another one commonly used when interacting with
    the Internet ![](../Images/00002.jpg). Aside from the usual error-handling statement,
    a new mechanize object is created which is called `agent` ![](../Images/00003.jpg).
    The object is then customized for future use, so the proxy is set to my local
    Paros proxy. If you don't want to use a proxy, then simply remove this line. Next,
    `agent` uses the method `get` to retrieve the web content ![](../Images/00004.jpg).
    The cool part about mechanize is the way web content is automatically categorized.
    Finding specific elements in the web content using mechanize makes the Ruby coder's
    life that much better.
  prefs: []
  type: TYPE_NORMAL
- en: Within `page`, the array `links` is found. Thanks to mechanize, the links have
    already been parsed. As with any array, we can use the `each` method and iterate
    through each of its elements. Don't forget that `link` not only contains the URL
    of each link but also other attributes defined in the original source code. We
    are only interested in the `href` attribute, so that is what is output to the
    console ![](../Images/00005.jpg). If you are going to be scraping a large website,
    I'd encourage you to save the output to a file, but that's your call. After the
    links have been printed, the script exits cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several other wicked cool web tools, such as Hpricot ([http://code.whytheluckystiff.net/hpricot/](http://code.whytheluckystiff.net/hpricot/))
    and Rubyful Soup ([http://www.crummy.com/software/RubyfulSoup/](http://www.crummy.com/software/RubyfulSoup/)),
    that can accomplish this parsing in a similar fashion. I encourage you to experiment
    with each one to find the tool that suits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Image Scrape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Image Scrape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: imageScrape.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This script will scrape every image from the page at a user-supplied URL. The
    image files will include data residing on the host machine in addition to images
    linked from other web servers.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require "open-uri"  require "pathname"   unless ARGV[0]      puts "You must
    supply a URL to scrape images."      puts "USAGE: ruby imageScrape.rb <url to
    scrape>"      exit  end   url = ARGV[0].strip  begin ![](../Images/00002.jpg)
         open(url, "User-Agent" => "Mozilla/4.0 (compatible; MSIE 5.5; Windows 98)")
     do |source|          source.each_line do |x| ![](../Images/00003.jpg)        
        if x =~ /<img src="(.+.[jpeg|gif])"\s+/                  name = $1.split(''"'').first  ![](../Images/00004.jpg)  
                  name = url + name if Pathname.new(name).absolute? ![](../Images/00005.jpg)  
                  copy = name.split(''/'').last  ![](../Images/00006.jpg)        
            File.open(copy, ''wb'') do |f|                      f.write(open(name).read)
                     end              end          end      end  rescue => e     
    puts "An error occurred, please try again."      puts e`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute this script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby imageScrape.rb`** *`http://url_to_scrape.com/`*``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script will download all the links found within the specified URL. I've
    scraped [http://www.ruby-lang.org/](http://www.ruby-lang.org/), and it grabbed
    two images, *logo.gif* (a Ruby logo) and *download.gif* (an image that links to
    a download of Ruby).
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the task of extracting images from a website, the first step is to retrieve
    the website where the images are located. Using the open-uri method `open`, the
    web page source code is conveniently saved into our variable `source` ![](../Images/00002.jpg).
    As you recall from your HTML coding days, images are embedded into web documents
    using `<img src=`*`foo.jpg`*`>` tags. In the script, we've used a regular expression
    that analyzes each line of the source code and finds this specific tag ![](../Images/00003.jpg).
    From the results of the regular expression, the script can identify the location
    of any images found.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the location of an image, we need to determine if the image was
    linked from another site or if it is located on the host site. Most HTML is coded
    with a slash in front of any images that are on the local web server; this is
    also known as an *absolute path*. The `name` variable holds the image path. If
    the image path is absolute, the script prepends the original URL to the image
    name in order to make the image's complete address. The absolute check happens
    when I create a new `Pathname` object and use the `absolute?` method ![](../Images/00004.jpg).
    Even though the path to the image may have changed, the image's local name will
    be the same stored in `copy` ![](../Images/00005.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: After an appropriate address for the image is created, the script leverages
    the open-uri virtual file handling to read in the contents of the image and output
    it to a file with the name stored in `copy` ![](../Images/00006.jpg). This process
    is repeated for every image found in a web document. The results are stored in
    the same directory from which the script is run.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You could use a pre-built HTML parser like mechanize, Hpricot, or Rubyful Soup.
    These may be even more accurate than the regular expression used above. You could
    also save the images in the same type of directory structure as they were found
    of the web server. There are lots of possibilities, but this script will get you
    started.
  prefs: []
  type: TYPE_NORMAL
- en: Scraper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scraper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: scrape.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scraping, in its most basic form, is the action of pulling data from another
    website through normal HTTP queries. The scraper script is a culmination of the
    previous scripts. It combines the prior techniques discussed in previous scripts
    into one large script with a few more features. This script allows for a one-stop
    shop in basic website scraping. This script is not a bot, because it requires
    user interaction for each scrape; but with a few minor tweaks, this script could
    be completely automated.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require ''rio''  require ''open-uri''  require ''uri''   unless ARGV[0] and
    ARGV[1]      puts "You must specify an operation and URL."      puts "USAGE: scrape.rb
    [page|images|links] <url to scrape>"      exit  end   ![](../Images/00002.jpg) case
    ARGV[0]   when "page" ![](../Images/00003.jpg)     rio(ARGV[1]) > rio("#{URI.parse(ARGV[1].strip).host}.html")
         exit ![](../Images/00004.jpg) when "images"      begin          open(url,
    "User-Agent" => "Mozilla/4.0 (compatible; MSIE 5.5; Windows  98)") do |source|
             source.each_line do |x|              if x =~ /<img src="(.+.[jpeg|gif])"\s+/
                     name = $1.split(''"'').first                   name = url + name
    if Pathname.new(name).absolute?                      copy = name.split(''/'').last
                                      File.open(copy, ''wb'') do |f|             
            f.write(open(name).read)                  end              end       
      end      end      rescue => e          puts "An error occurred, please try again."
             puts e      end      exit  when "links"      links = File.open("links.txt","w+b")
         begin ![](../Images/00005.jpg)         open(ARGV[1], "User-Agent" => "Mozilla/4.0
    (compatible; MSIE 5.5; Windows  98)") do |source| ![](../Images/00006.jpg)    
            links.puts URI.extract(source, [''http'', ''https''])         end     
    rescue => e          puts "An error occurred, please try again."          puts
    e      end      links.close      exit  else      puts "You entered an invalid
    instruction, please try again."      puts "USAGE: scrape.rb [page|images|links]
    <url to scrape>"      exit  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute this script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby scrape.rb [`***`page|images|links`***`]`** *`http://url_to_scrape.com/`*``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script's output will be different for each method chosen. You can see an
    example from the previous script.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script has three options. You can scrape `links`, `images`, or an entire
    web `page`. A `case` statement is used to handle the different options ![](../Images/00002.jpg).
    You could have used an `if/else` statement, but the `case` statement is cleaner.
    If the page is selected, the `rio` command is used to copy the web page source
    code and save it to an HTML file on the local machine ![](../Images/00003.jpg).
    `rio` handles so many of the dirty details that this task can be accomplished
    in just one line!
  prefs: []
  type: TYPE_NORMAL
- en: Next is the image scrape ![](../Images/00004.jpg). This section of the code
    is a copy of "#45 Image Scrape" on [How It Works](../Text/dummy_split_310.html#filepos605751),
    so I won't review the details. If you have any questions, you can refer to the
    previous script.
  prefs: []
  type: TYPE_NORMAL
- en: The final `case` statement is to grab the links. Unlike other methods used,
    I've reinvented the wheel to show another method for extracting URLs. This link-scraping
    method uses the `open` method from open-uri to retrieve the source code ![](../Images/00005.jpg)
    and follows up with the `URI.extract` method, which hunts down HTTP or HTTPS links
    ![](../Images/00006.jpg). The results are saved into a text file called *links.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encrypted Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RSA_client.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Three principles are commonly used when describing information technology and
    security. The three principles are confidentiality, integrity, and availability.
    Each of these security components affects how a user interacts with data. The
    following two scripts will integrate RSA encryption for confidentiality and a
    SHA1 hash for integrity. The data will then be transmitted over a network using
    a TCP connection.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require ''socket''  require ''digest/sha1''   begin      print "Starting
    client..." ![](../Images/00002.jpg)     client = TCPSocket.new(''localhost'',
    8887)       puts "connected!\n\n"  ![](../Images/00003.jpg)     temp = nil   
      5.times do          temp << client.gets      end      puts "Received public
    1024 RSA key!\n\n" ![](../Images/00004.jpg)     public_key = OpenSSL::PKey::RSA.new(temp)    
      msg = ''mpg123*"C:\Program Files\Windows Media Player\mplayer2.exe"*ruby.mp3''
    ![](../Images/00005.jpg)     sha1 = Digest::SHA1.hexdigest(msg)  ![](../Images/00006.jpg)  
      command = public_key.public_encrypt("#{sha1}*#{msg}")      print "Sending the
    command...."  ![](../Images/00007.jpg)     client.send(command,0)       puts "sent!"
     rescue => e      puts "Something terrible happened...."      puts e      retry
     end   client.close`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute this script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby RSA_client.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Below is the output from a successful connection and command issue.
  prefs: []
  type: TYPE_NORMAL
- en: '`Starting client...connected!  Received public 1024 RSA key!  Sending the command...sent!`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client begins by opening a TCP connection to a specified IP address and
    port number ![](../Images/00002.jpg). If the connection is successful, *connected*
    is output to `$stdout`. Next, the client expects to receive a 1024-bit RSA public
    encryption key from the server. The key is stored in a variable called `temp`
    because it is really only a cryptic string object until it is converted into an
    OpenSSL RSA key object ![](../Images/00003.jpg). Once `public_key` is initialized
    and contains the public RSA key, the script confirms the key was received and
    is ready to encrypt data ![](../Images/00004.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: The script will send data that contains a music program, either mpg123 for Linux
    or mplayer2.exe, which is the classic Windows media player. In addition to the
    music program, a music file, *ruby.mp3*, is also sent. The file is already located
    on the server, so this will simply tell the server to play the song. Each portion
    of the command string is delimited by an asterisk (*). You can get as creative
    as you want with this command, or even the data in general, as it will all be
    encrypted and sent to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Data encryption is the next step. The command string described above is stored
    in a variable called `msg` and will be encrypted with the server's public RSA
    key. Before we encrypt the data, the script will run the message through a SHA1
    hash and store the resulting hash in `sha1` ![](../Images/00005.jpg). This hash
    will be used after transmission on the server side. Remember that hash functions
    are one way, so if the data is tampered with during transmission, the before and
    after hash values won't be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the value in `sha1` and `msg` are concatenated with a splat in between.
    The result is encrypted using the RSA key method `public_encrypt` ![](../Images/00006.jpg).
    As you might have guessed, the method encrypts the data using a public RSA key.
    Only the corresponding private RSA key can be used to decrypt the message.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the encrypted message is sent to the server, and the connection is
    closed ![](../Images/00007.jpg). If anything goes wrong during the encryption
    or transmission phases of the script, our trusty `begin/rescue` block is there
    to save the day. If all goes well, the server will pop open an awesome tune about
    Ruby! Can life get any better than listening to songs about Ruby?
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encrypted Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RSA_server.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have seen the client and all of its magic, it's time to analyze
    the server. The server receives the data, checks that the SHA1 hash is valid,
    decrypts the data, and, finally, executes the command string based on the payload
    transmitted.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`` require ''socket''  require ''digest/sha1''  ![](../Images/00002.jpg) priv_key
    = OpenSSL::PKey::RSA.new(1024)  pub_key = priv_key.public_key   host = ARGV[0]
    || ''localhost''  port = (ARGV[1] || 8887).to_i  ![](../Images/00003.jpg) server
    = TCPServer.new(host, port)  ![](../Images/00004.jpg) while session = server.accept
         begin          puts "Connection made...sending public key.\n\n"         
    puts pub_key ![](../Images/00005.jpg)         session.print pub_key          puts
    "Public key sent, waiting on data...\n\n"  ![](../Images/00006.jpg)         temp
    = session.recv(10000)          puts "Received data..."  ![](../Images/00007.jpg)  
          msg = priv_key.private_decrypt(temp)      rescue => e          puts "Something
    terrible happened while receiving and decrypting."          puts e      end  ![](../Images/00008.jpg)  
      command = msg.split("*")       serv_hash = command[0]      nix_app = command[1]
         win_app = command[2]      file = command[3]  ![](../Images/00009.jpg)   
      if Digest::SHA1.hexdigest("#{nix_app}*#{win_app}*#{file}")==serv_hash       
      puts "Message integrity confirmed..." ![](../Images/00011.jpg)         if RUBY_PLATFORM.include?(''mswin32'')
                 puts "Executing windows command: #{win_app} #{file}"             
    `#{win_app} #{file}`              exit ![](../Images/00012.jpg)         else   
              puts "Executing Linux command: #{nix_app} #{file}"              `#{nix_app}
    #{file}`              exit          end      else          puts "The message could
    not be validated!"      end      exit  end``'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute this script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby RSA_server.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Below is the output from a successful connection and command issue.
  prefs: []
  type: TYPE_NORMAL
- en: '`Connection made...sending public key.  -----BEGIN RSA PUBLIC KEY----- MIGJAoGBAMe12IJIyVULS/OLlHeekhZNyh2YhuGfJSwEozw2Z6GfaRjZg7s0cwqb
    B/Z+MMUPIjCmiH38pkKzh5GhA8zcRSWEFtssa8HcyIowA5ftZM27/6diYz9kNueI NO2kvlkqwU5KUOKnLISJnrZAlTbJMqio24dn3PNm27kgae8+KdrHAgMBAAE=
    -----END RSA PUBLIC KEY----- Public key sent, waiting on data...  Received data...
    Message integrity confirmed... Executing windows command: "C:\Program Files\Windows
    Media Player\mplayer2.exe" ruby.mp3`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script first generates a unique, private RSA key ![](../Images/00002.jpg).
    From the private key, a public RSA key is also generated using the RSA key method
    `public_key`. Every time this script is run, a new key pair is created. If someone
    sends data encrypted with an old public key, the script won't be able to decrypt
    the message.
  prefs: []
  type: TYPE_NORMAL
- en: After the RSA keys have been created, a TCP server is initialized ![](../Images/00003.jpg).
    The server can be run with command-line arguments for the host and port, or it
    can use the default values provided. After the server is created, it begins listening
    for incoming connections. A `while` loop is used to regulate the various sessions
    in the script ![](../Images/00004.jpg). Because the script is not multithreaded,
    only one connection at a time is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: When the client is executed, it connects to the server. This connection starts
    a new session, and the first action is to respond with the server's public RSA
    key ![](../Images/00005.jpg). The RSA key is small, so it happens quickly. The
    script then waits for data to be sent by the client. While it waits, the client
    receives the public RSA key and encrypts the message to be sent. The `temp` variable
    captures any data received by the server's TCP connection, up to 10,000 bytes
    ![](../Images/00006.jpg). Only after data is received will the script proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Using the RSA `private_decrypt` method, the value located in `temp` is decrypted
    and stored in `msg` ![](../Images/00007.jpg). If any errors occur during the receipt
    and decryption of the command string, our `rescue` clause will catch the error
    and output some useful information that will help us troubleshoot the issue.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall from "#47 Encrypted Client" on [How It Works](../Text/dummy_split_324.html#filepos624901),
    the command string was delimited by asterisks (*). So, to get the command string
    into the pieces we need, the `split` method is used with a splat as the break
    point in the string `msg` ![](../Images/00008.jpg). The results are saved to `command`,
    which is an array of strings. Since we built the string in the client script,
    we know what the order will be. First is the SHA1 hash; next, the Linux application,
    followed by the windows application; and, finally, the file to be used.
  prefs: []
  type: TYPE_NORMAL
- en: A SHA1 hash is created using the Linux application string, Windows application
    string, and filename ![](../Images/00009.jpg). Asterisks are added in between
    each of the strings to recreate the original hashed string. The results of this
    hash are then compared against `serv_hash`, which contains the SHA1 hash sent
    by the client. If the values are not equal, then something must have happened
    to the data during transmission. The data can no longer be trusted, so the program
    exits. Hopefully, the values will match up so the script can continue.
  prefs: []
  type: TYPE_NORMAL
- en: If the message integrity has been confirmed, then the last decision is to pick
    which application to run. Ruby provides an easy way of determining the platform
    being used. You simply ask it using `RUBY_PLATFORM`. The result for a Windows
    machine is `i386-mswin32`. Using the handy `include?` method, the script checks
    to see if the string returned by `RUBY_PLATFORM` contains `mswin32` ![](../Images/00011.jpg).
    If this statement is `true`, the Windows command is executed. If not, then the
    Linux application is executed ![](../Images/00012.jpg). Either way, if everything
    else works out, the music application should launch and begin playing *ruby.mp3*.
    The script exits after the music application has been terminated. So, that's how
    to covertly communicate while maintaining your data integrity.
  prefs: []
  type: TYPE_NORMAL
