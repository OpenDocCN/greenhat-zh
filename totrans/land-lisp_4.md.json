["```\n> `(sin 0.5)`\n0.47942555\n```", "```\n;the clean, functional part\n (defun add-widget (database widget)\n   (cons widget database))\n\n  ;the dirty, nonfunctional part\n (defparameter *database* nil)\n\n (defun main-loop ()\n   (loop (princ \"Please enter the name of a new widget:\")\n         (setf *database* (add-widget *database* (read)))\n          (format t \"The database contains the following: ˜a˜%\" *database*)))\n```", "```\n> `(main-loop)`\nPlease enter the name of a new widget: `Frombulator`\nThe database contains the following: (FROMBULATOR)\nPlease enter the name of a new widget: `Double-Zingomat`\nThe database contains the following: (DOUBLE-ZINGOMAT FROMBULATOR)\n...\n```", "```\n> `(defparameter *my-list* '(4 7 2 3))`\n*MY-LIST*\n```", "```\n;For demonstration purposes only. A Lisper would not write code like this.\n > `(loop for n below (length *my-list*)`\n         `do (setf (nth n *my-list*) (+ (nth n *my-list*) 2)))`\n  NIL\n  > `*my-list*`\n  (6 9 4 5)\n```", "```\n > `(defun add-two (list)`\n      `(when list`\n        `(cons (+ 2 (car list)) (add-two (cdr list)))))`\n  ADD-TWO\n  > `(add-two '(4 7 2 3))`\n  (6 9 4 5)\n```", "```\n> `(mapcar (lambda (x)`\n             `(+ x 2))`\n           `'(4 7 2 3))`\n(6 9 4 5)\n```", "```\n (defparameter *num-players* 2)\n (defparameter *max-dice* 3)\n (defparameter *board-size* 2)\n (defparameter *board-hexnum* (* *board-size* *board-size*))\n```", "```\n((0 3) (0 3) (1 3) (1 1))\n```", "```\n(defun board-array (lst)\n  (make-array *board-hexnum* :initial-contents lst))\n```", "```\n(defun gen-board ()\n   (board-array (loop for n below *board-hexnum*\n                      collect (list (random *num-players*)\n                                       (1+ (random *max-dice*))))))\n```", "```\n> `(gen-board)`\n#((0 3) (1 2) (1 3) (0 1))\n```", "```\n(defun player-letter (n)\n  (code-char (+ 97 n)))\n```", "```\n> `(player-letter 1)`\n#\\b\n```", "```\n(defun draw-board (board)\n   (loop for y below *board-size*\n          do (progn (fresh-line)\n                   (loop repeat (- *board-size* y)\n                          do (princ \"  \"))\n                   (loop for x below *board-size*\n                         for hex = (aref board (+ x (* *board-size* y)))\n                          do (format t \"˜a-˜a \" (player-letter (first hex))\n                                               (second hex))))))\n```", "```\n> `(draw-board #((0 3) (0 3) (1 3) (1 1)))`\n    a-3 a-3\n  b-3 b-1\n```", "```\n (defun game-tree (board player spare-dice first-move)\n   (list player\n          board\n         (add-passing-move board\n                            player\n                            spare-dice\n                            first-move\n                           (attacking-moves board player spare-dice))))\n```", "```\n (defun add-passing-move (board player spare-dice first-move moves)\n   (if first-move\n       moves\n       (cons (list nil\n                   (game-tree (add-new-dice board player (1- spare-dice))\n                              (mod (1+ player) *num-players*)\n                                     0\n                                     t))\n            moves)))\n```", "```\n(defun attacking-moves (board cur-player spare-dice)\n   (labels ((player (pos)\n               (car (aref board pos)))\n            (dice (pos)\n               (cadr (aref board pos))))\n     (mapcan (lambda (src)\n               (when (eq (player src) cur-player)\n                 (mapcan (lambda (dst)\n                            (when (and (not (eq (player dst) cur-player))\n                                 (> (dice src) (dice dst)))\n                            (list\n      (list (list src dst)\n            (game-tree (board-attack board cur-player src dst (dice src))\n                        cur-player\n                        (+ spare-dice (dice dst))\n                        nil)))))\n                        (neighbors src))))\n              (loop for n below *board-hexnum*\n                    collect n))))\n```", "```\n(defun neighbors (pos)\n    (let ((up (- pos *board-size*))\n          (down (+ pos *board-size*)))\n     (loop for p in (append (list up down)\n                            (unless (zerop (mod pos *board-size*))\n                               (list (1- up) (1- pos)))\n                            (unless (zerop (mod (1+ pos) *board-size*))\n                               (list (1+ pos) (1+ down))))\n                 when (and (>= p 0) (< p *board-hexnum*))\n                  collect p)))\n```", "```\n> `(neighbors 2)`\n(0 3)\n```", "```\n(defun board-attack (board player src dst dice)\n   (board-array (loop for pos\n                      for hex across board\n                      collect (cond ((eq pos src) (list player 1))\n                                    ((eq pos dst) (list player (1- dice)))\n                                    (t hex)))))\n```", "```\n> `(board-attack #((0 3) (0 3) (1 3) (1 1)) 0 1 3 3)`\n#((0 3) (0 1) (1 3) (0 2))\n```", "```\n(defun add-new-dice (board player spare-dice)\n   (labels ((f (lst n)\n              (cond ((null lst) nil)\n                    ((zerop n) lst)\n                 (t (let ((cur-player (caar lst))\n                          (cur-dice (cadar lst)))\n                     (if (and (eq cur-player player) (< cur-dice *max-dice*))\n                          (cons (list cur-player (1+ cur-dice))\n                               (f (cdr lst) (1- n)))\n                         (cons (car lst) (f (cdr lst) n))))))))\n     (board-array (f (coerce board 'list) spare-dice))))\n```", "```\n> `(add-new-dice #((0 1) (1 3) (0 2) (1 1)) 0 2)`\n#((0 2) (1 3) (0 3) (1 1))\n```", "```\n> `(game-tree #((0 1) (1 1) (0 2) (1 1)) 0 0 t)`\n (0\n  #((0 1)(1 1) (0 2) (1 1))\n  (((2 3)(0\n             #((0 1) (1 1) (0 1) (0 1))\n            ((NIL(1\n                     #((0 1) (1 1) (0 1) (0 1))\n                     NIL)))))))\n```", "```\n(defun play-vs-human (tree)\n   (print-info tree)\n   (if (caddr tree)\n       (play-vs-human (handle-human tree))\n     (announce-winner (cadr tree))))\n```", "```\n(defun print-info (tree)\n  (fresh-line)\n   (format t \"current player = ˜a\" (player-letter (car tree)))\n   (draw-board (cadr tree)))\n```", "```\n(defun handle-human (tree)\n    (fresh-line)\n    (princ \"choose your move:\")\n    (let ((moves (caddr tree)))\n     (loop for move in moves\n           for n from 1\n            do (let ((action (car move)))\n                 (fresh-line)\n                (format t \"˜a. \" n)\n                (if action\n                    (format t \"˜a -> ˜a\" (car action) (cadr action))\n                    (princ \"end turn\"))))\n      (fresh-line)\n     (cadr (nth (1- (read)) moves))))\n```", "```\n(defun winners (board)\n   (let* ((tally (loop for hex across board\n                        collect (car hex)))\n           (totals (mapcar (lambda (player)\n                            (cons player (count player tally)))\n                          (remove-duplicates tally)))\n          (best (apply #'max (mapcar #'cdr totals))))\n     (mapcar #'car\n             (remove-if (lambda (x)\n                           (not (eq (cdr x) best)))\n                         totals))))\n```", "```\n(defun announce-winner (board)\n    (fresh-line)\n   (let ((w (winners board)))\n     (if (> (length w) 1)\n       (format t \"The game is a tie between ˜a\" (mapcar #'player-letter w))\n       (format t \"The winner is ˜a\" (player-letter (car w))))))\n```", "```\n> `(play-vs-human (game-tree (gen-board) 0 0 t))`\ncurrent player = a\n    b-2 b-2\n  a-2 b-1\nchoose your move:\n1\\. 2 -> 3\n`1`\ncurrent player = a\n    b-2 b-2\n  a-1 a-1\nchoose your move:\n1\\. end turn\n`1`\ncurrent player = b\n    b-2 b-2\n  a-1 a-1\nchoose your move:\n1\\. 0 -> 2\n2\\. 0 -> 3\n3\\. 1 -> 3\n`1`\ncurrent player = b\n    b-1 b-2\n  b-1 a-1\nchoose your move:\n1\\. end turn\n2\\. 1 -> 3\n`1`\ncurrent player = a\n    b-1 b-2\n  b-1 a-1\nThe winner is b\n```", "```\n(defun rate-position (tree player)\n    (let ((moves (caddr tree)))\n     (if moves\n        (apply (if (eq (car tree) player)\n                #'max\n              #'min)\n              (get-ratings tree player))\n       (let ((w (winners (cadr tree))))\n          (if (member player w)\n             (/ 1 (length w))\n           0)))))\n```", "```\n(defun get-ratings (tree player)\n  (mapcar (lambda (move)\n          (rate-position (cadr move) player))\n        (caddr tree)))\n```", "```\n(defun handle-computer (tree)\n   (let ((ratings (get-ratings tree (car tree))))\n     (cadr (nth (position (apply #'max ratings) ratings) (caddr tree)))))\n```", "```\n(defun play-vs-computer (tree)\n   (print-info tree)\n   (cond ((null (caddr tree)) (announce-winner (cadr tree)))\n       ((zerop (car tree)) (play-vs-computer (handle-human tree)))\n       (t (play-vs-computer (handle-computer tree)))))\n```", "```\n> `(play-vs-computer (game-tree (gen-board) 0 0 t))`\ncurrent player = a\n    a-3 b-3\n  a-2 b-2\nchoose your move:\n1\\. 0 -> 3\n`1`\ncurrent player = a\n    a-1 b-3\n  a-2 a-2\nchoose your move:\n1\\. end turn\n`1`\ncurrent player = b\n    a-2 b-3\n  a-2 a-2\ncurrent player = b\n    b-2 b-1\n  a-2 a-2\ncurrent player = a\n    b-3 b-1\n  a-2 a-2\nchoose your move:\n1\\. 3 -> 1\n`1`\ncurrent player = a\n    b-3 a-1\n  a-2 a-1\nchoose your move:\n1\\. end turn\n`1`\ncurrent player = b\n    b-3 a-1\n  a-2 a-1\ncurrent player = b\n    b-1 a-1\n  b-2 a-1\ncurrent player = b\n    b-1 a-1\n  b-1 b-1\ncurrent player = a\n    b-2 a-1\n  b-2 b-1\nThe winner is b\n```", "```\n(defparameter *board-size* 3)\n(defparameter *board-hexnum* (* *board-size* *board-size*))\n```", "```\n> `(defparameter *foo* (lambda ()`\n `5))`\n  *FOO*\n > `(funcall *FOO*)`\n  5\n```", "```\n > `(defparameter *foo* (let ((x 5))`\n `(lambda ()`\n `x)))`\n  *FOO*\n```", "```\n> `(funcall *foo*)`\n5\n```", "```\n > `(let ((line-number 0))`\n `(defun my-print (x)`\n `(print line-number)`\n   `(print x)`\n `(incf line-number)`\n        `nil))`\n  MY-PRINT\n  > `(my-print \"this\")`\n  0\n  \"this\"\n  nil\n  > `(my-print \"is\")`\n  1\n  \"is\"\n  nil\n  > `(my-print \"a\")`\n  2\n  \"a\"\n  nil\n  > `(my-print \"test\")`\n  3\n  \"test\"\n  nil\n```", "```\n> `(neighbors 0)`\n(3 1 4)\n```", "```\n (let ((old-neighbors (symbol-function 'neighbors))\n       (previous (make-hash-table)))\n   (defun neighbors (pos)\n     (or (gethash pos previous)\n         (setf (gethash pos previous) (funcall old-neighbors pos)))))\n```", "```\n(let ((old-game-tree (symbol-function 'game-tree))\n       (previous (make-hash-table :test #'equalp)))\n    (defun game-tree (&rest rest)\n      (or (gethash rest previous)\n        (setf (gethash rest previous) (apply old-game-tree rest)))))\n```", "```\n(let ((old-rate-position (symbol-function 'rate-position))\n       (previous (make-hash-table)))\n    (defun rate-position (tree player)\n     (let ((tab (gethash player previous)))\n       (unless tab\n         (setf tab (setf (gethash player previous) (make-hash-table))))\n        (or (gethash tree tab)\n           (setf (gethash tree tab)\n                  (funcall old-rate-position tree player))))))\n```", "```\n> `(defun my-length (lst)`\n `(if lst`\n `(1+ (my-length (cdr lst)))`\n `0))`\n  MY-LENGTH\n  > `(my-length '(fie foh fum))`\n  3\n```", "```\n> `(defparameter *biglist* (loop for i below 100000 collect 'x))`\n*BIGLIST*\n> `(my-length *biglist*)`\n\n*** - Program stack overflow. RESET\n```", "```\n> `(defun my-length (lst)`\n `(labels ((f (lst acc)`\n `(if lst`\n `(f (cdr lst) (1+ acc))`\n `acc)))`\n `(f lst 0)))`\n  MY-LENGTH\n  > `(my-length '(fie foh fum))`\n  3\n```", "```\n(compile 'my-length)\n```", "```\n> `(my-length *biglist*)`\n100000\n```", "```\n(defun add-new-dice (board player spare-dice)\n   (labels ((f (lst n acc)\n               (cond ((zerop n) (append (reverse acc) lst))\n                    ((null lst) (reverse acc))\n                     (t (let ((cur-player (caar lst))\n                              (cur-dice (cadar lst)))\n                          (if (and (eq cur-player player)\n                                   (< cur-dice *max-dice*))\n                              (f (cdr lst)\n                                 (1- n)\n                                (cons (list cur-player (1+ cur-dice)) acc))\n                           (f (cdr lst) n (cons (car lst) acc))))))))\n      (board-array (f (coerce board 'list) spare-dice ()))))\n```", "```\n> `(play-vs-computer (game-tree (gen-board) 0 0 t))`\ncurrent player = a\n      b-1 a-2 a-3\n    a-1 b-1 b-2\n  b-2 a-2 b-3\nchoose your move:\n1\\. 1 -> 4\n2\\. 1 -> 0\n3\\. 2 -> 5\n4\\. 7 -> 4\n`3`\ncurrent player = a\n      b-1 a-2 a-1\n    a-1 b-1 a-2\n  b-2 a-2 b-3\nchoose your move:\n1\\. end turn\n2\\. 1 -> 4\n3\\. 1 -> 0\n4\\. 5 -> 4\n5\\. 7 -> 4\n`1`\ncurrent player = b\n      b-1 a-3 a-1\n    a-1 b-1 a-2\n  b-2 a-2 b-3\ncurrent player = b\n      b-1 a-3 a-1\n    b-1 b-1 a-2\n  b-1 a-2 b-3\ncurrent player = a\n      b-1 a-3 a-1\n    b-1 b-1 a-2\n  b-1 a-2 b-3\nchoose your move:\n1\\. 1 -> 4\n2\\. 1 -> 0\n3\\. 5 -> 4\n4\\. 7 -> 4\n5\\. 7 -> 3\n6\\. 7 -> 6\n`1`\ncurrent player = a\n      b-1 a-1 a-1\n    b-1 a-2 a-2\n  b-1 a-2 b-3\nchoose your move:\n1\\. end turn\n2\\. 4 -> 0\n3\\. 4 -> 3\n4\\. 7 -> 3\n5\\. 7 -> 6\n`1`\ncurrent player = b\n      b-1 a-1 a-1\n    b-1 a-2 a-2\n  b-1 a-2 b-3\ncurrent player = b\n      b-1 a-1 a-1\n    b-1 a-2 b-2\n  b-1 a-2 b-1\ncurrent player = a\n      b-2 a-1 a-1\n    b-1 a-2 b-2\n  b-1 a-2 b-1\nchoose your move:\n1\\. 4 -> 3\n2\\. 4 -> 8\n3\\. 7 -> 3\n4\\. 7 -> 6\n5\\. 7 -> 8\n`2`\ncurrent player = a\n      b-2 a-1 a-1\n    b-1 a-1 b-2\n  b-1 a-2 a-1\nchoose your move:\n1\\. end turn\n2\\. 7 -> 3\n3\\. 7 -> 6\n`1`\ncurrent player = b\n      b-2 a-1 a-1\n    b-1 a-1 b-2\n  b-1 a-2 a-1\ncurrent player = b\n      b-1 b-1 a-1\n    b-1 a-1 b-2\n  b-1 a-2 a-1\ncurrent player = a\n      b-1 b-1 a-1\n    b-1 a-1 b-2\n  b-1 a-2 a-1\nchoose your move:\n1\\. 7 -> 3\n2\\. 7 -> 6\n`1`\ncurrent player = a\n      b-1 b-1 a-1\n    a-1 a-1 b-2\n  b-1 a-1 a-1\nchoose your move:\n1\\. end turn\n`1`\ncurrent player = b\n      b-1 b-1 a-1\n    a-1 a-1 b-2\n  b-1 a-1 a-1\ncurrent player = b\n      b-1 b-1 b-1\n    a-1 a-1 b-1\n  b-1 a-1 a-1\ncurrent player = a\n      b-1 b-1 b-1\n    a-1 a-1 b-1\n  b-1 a-1 a-1\nThe winner is b\n```", "```\n(defun add (a b)\n   (let ((x (+ a b)))\n       (format t \"The sum is ˜a\" x)\n       x))\n```", "```\n> `(add 2 3)`\nThe sum is 5\n5\n```", "```\n (defmacro let1 (var val &body body)\n    `(let ((,var ,val))\n       ,@body))\n```", "```\n> `(let ((foo (+ 2 3)))`\n `(* foo foo))`\n25\n> `(let1 foo (+ 2 3)`\n `(* foo foo))`\n25\n```", "```\n (defmacro let1 (var val &body body)\n    `(let ((,var ,val))\n       ,@body))\n```", "```\n(defmacro let1 (var val &body body)\n   `(let ((,var ,val))\n      ,@body))\n```", "```\n> `(let1 foo (+ 2 3)`\n `(princ \"Lisp is awesome!\")`\n `(* foo foo))`\nLisp is awesome!\n25\n```", "```\n(defun add (a b)\n  (let1 x (+ a b)\n     (format t \"The sum is ˜a\" x)\n     x))\n```", "```\n> `(macroexpand '(let1 foo (+ 2 3)`\n   `(* foo foo)))`\n (LET ((FOO (+ 2 3))) (* FOO FOO)) ;\n T\n```", "```\n(defun my-length (lst)\n   (labels ((f (lst acc)\n              (if lst\n                (f (cdr lst) (1+ acc))\n                 acc)))\n      (f lst 0)))\n```", "```\n > `(split '(2 3)`\n `(format t \"This can be split into ˜a and ˜a.\" head tail)`\n   `(format t \"This cannot be split.\"))`\n  This can be split into 2 and (3).\n > `(split '()`\n   `(format t \"This can be split into ˜a and ˜a.\" head tail)`\n `(format t \"This cannot be split.\"))`\n  This cannot be split.\n```", "```\n;Warning! Contains Bugs!\n (defmacro split (val yes no)\n   `(if ,val\n      (let ((head (car ,val))\n            (tail (cdr ,val)))\n        ,yes)\n        ,no))\n```", "```\n(defun my-length (lst)\n    (labels ((f (lst acc)\n               (split lst\n                (f tail (1+ acc))\n                 acc)))\n      (f lst 0)))\n```", "```\n> `(split (progn (princ \"Lisp rocks!\")`\n   `'(2 3))`\n   `(format t \"This can be split into ˜a and ˜a.\" head tail)`\n   `(format t \"This cannot be split.\"))`\n  Lisp rocks!Lisp rocks!Lisp rocks!This can be split into 2 and (3).\n```", "```\n> `(macroexpand '(split (progn (princ \"Lisp rocks!\")`\n   `'(2 3))`\n   `(format t \"This can be split into ˜a and ˜a.\" head tail)`\n   `(format t \"This cannot be split.\")))`\n (IF (PROGN (PRINC \"Lisp rocks!\") '(2 3))\n   (LET\n   ((HEAD (CAR (PROGN (PRINC \"Lisp rocks!\") '(2 3))))\n    (TAIL (CDR (PROGN (PRINC \"Lisp rocks!\") '(2 3)))))\n    (FORMAT T \"This can be split into ˜a and ˜a.\" HEAD TAIL))\n   (FORMAT T \"This cannot be split.\")) ;\n  T\n```", "```\n;Warning! Still contains a bug!\n(defmacro split (val yes no)\n  `(let1 x ,val\n     (if x\n       (let ((head (car x))\n             (tail (cdr x)))\n         ,yes)\n         ,no)))\n```", "```\n> `(split (progn (princ \"Lisp rocks!\")`\n `'(2 3))`\n `(format t \"This can be split into ˜a and ˜a.\" head tail)`\n `(format t \"This cannot be split.\"))`\nLisp rocks!This can be split into 2 and (3).\n```", "```\n> `(let1 × 100`\n `(split '(2 3)`\n `(+ x head)`\n `nil))`\n*** - +: (2 3) is not a number\n```", "```\n> `(macroexpand '(split '(2 3)`\n   `(+ x head)`\n   `nil))`\n (LET ((X '(2 3)))\n     (IF X (LET ((HEAD (CAR X)) (TAIL (CDR X))) (+ X HEAD)) NIL)) ;\n  T\n```", "```\n> `(gensym)`\n#:G8695\n```", "```\n;This function is finally safe to use\n  (defmacro split (val yes no)\n   (let1 g (gensym)\n   `(let1 ,g ,val\n       (if ,g\n         (let ((head (car ,g))\n               (tail (cdr ,g)))\n           ,yes)\n           ,no))))\n```", "```\n> `(macroexpand '(split '(2 3)`\n `(+ x head)`\n `nil))`\n(LET ((#:G8627 '(2 3))) (IF #:G8627 (LET ((HEAD (CAR #:G8627))\n (TAIL (CDR #:G8627))) (+ X HEAD)) NIL)) ;\nT\n> `(macroexpand '(split '(2 3)`\n `(+ x head)`\n `nil))`\n(LET ((#:G8628 '(2 3))) (IF #:G8628 (LET ((HEAD (CAR #:G8628))\n (TAIL (CDR #:G8628))) (+ X HEAD)) NIL)) ;\nT\n```", "```\n(defun my-length (lst)\n  (labels ((f (lst acc)\n             (split lst\n               (f tail (1+ acc))\n               acc)))\n    (f lst 0)))\n```", "```\n > `(recurse (n 9)`\n `(fresh-line)`\n `(if (zerop n)`\n `(princ \"lift-off!\")`\n `(progn (princ n)`\n `(self (1- n)))))`\n  9\n  8\n  7\n  6\n  5\n  4\n  3\n  2\n  1\n  lift-off!\n```", "```\n> `(defun pairs (lst)`\n `(labels ((f (lst acc)`\n `(split lst`\n `(if tail`\n `(f (cdr tail) (cons (cons head (car tail)) acc))`\n `(reverse acc))`\n `(reverse acc))))`\n   `(f lst nil)))`\n  PAIRS\n  > `(pairs '(a b c d e f))`\n  ((A . B) (C . D) (E . F))\n```", "```\n(defmacro recurse (vars &body body)\n   (let1 p (pairs vars)\n     `(labels ((self ,(mapcar #'car p)\n                  ,@body))\n        (self ,@(mapcar #'cdr p)))))\n```", "```\n(defun my-length (lst)\n  (recurse (lst lst\n            acc 0)\n           (split lst\n             (f tail (1+ acc))\n             acc)))\n```", "```\n(defun my-length (lst)\n   (reduce (lambda (x i)\n             (1+ x))\n           lst\n           :initial-value 0))\n```", "```\n<svg >\n  <circle cx=\"50\"\n          cy=\"50\"\n          r=\"50\"\n          style=\"fill:rgb(255,0,0);stroke:rgb(155,0,0)\">\n  </circle>\n  <circle cx=\"100\"\n          cy=\"100\"\n          r=\"50\"\n          style=\"fill:rgb(0,0,255);stroke:rgb(0,0,155)\">\n  </circle>\n</svg>\n```", "```\n <mytag>\n      <inner_tag>\n      </inner_tag>\n </mytag>\n```", "```\n<mytag color=\"BLUE\" height=\"9\"></mytag>\n```", "```\n(defun print-tag (name alst closingp)\n   (princ #\\<)\n   (when closingp\n      (princ #\\/))\n   (princ (string-downcase name))\n   (mapc (lambda (att)\n           (format t \" ˜a=\\\"˜a\\\"\" (string-downcase (car att)) (cdr att)))\n        alst)\n   (princ #\\>))\n```", "```\n> `(print-tag 'mytag '((color . blue) (height . 9)) nil)`\n<mytag color=\"BLUE\" height=\"9\">\n```", "```\n> `(tag mytag (color 'blue height (+ 4 5)))`\n<mytag color=\"BLUE\" height=\"9\"></mytag>\n```", "```\n(defmacro tag (name atts &body body)\n   `(progn (print-tag ',name\n                      (list ,@(mapcar (lambda (x)\n                                        `(cons ',(car x) ,(cdr x)))\n                                      (pairs atts)))\n                       nil)\n           ,@body\n           (print-tag ',name nil t)))\n```", "```\n> `(macroexpand '(tag mytag (color 'blue height (+ 4 5))))`\n  (PROGN (PRINT-TAG 'MYTAG\n                   (LIST (CONS 'COLOR 'BLUE)\n                         (CONS 'HEIGHT (+ 4 5)))\n                    NIL)\n          (PRINT-TAG 'MYTAG NIL T)) ;\n  T\n```", "```\n> `(tag mytag (color 'blue size 'big)`\n   `(tag first_inner_tag ())`\n   `(tag second_inner_tag ()))`\n <mytag color=\"BLUE\" size=\"BIG\">\n    <first_inner_tag></first_inner_tag>\n    <second_inner_tag></second_inner_tag>\n  </mytag>\n```", "```\n> `(tag html ()`\n `(tag body ()`\n `(princ \"Hello World!\")))`\n<html><body>Hello World!</body></html>\n```", "```\n(defmacro html (&body body)\n  `(tag html ()\n        ,@body))\n(defmacro body (&body body)\n  `(tag body ()\n        ,@body))\n```", "```\n> `(html`\n `(body`\n `(princ \"Hello World!\")))`\n<html><body>Hello World!</body></html>\n```", "```\n(defmacro svg (&body body)\n   `(tag svg (xmlns \"http://www.w3.org/2000/svg\"\n              \"xmlns:xlink\" \"http://www.w3.org/1999/xlink\")\n          ,@body))\n```", "```\n(defun brightness (col amt)\n  (mapcar (lambda (x)\n        (min 255 (max 0 (+ x amt))))\n      col))\n```", "```\n> `(brightness '(255 0 0) −100)`\n(155 0 0)\n```", "```\n(defun svg-style (color)\n    (format nil\n           \"˜{fill:rgb(˜a,˜a,˜a);stroke:rgb(˜a,˜a,˜a)˜}\"\n            (append color\n                   (brightness color −100))))\n```", "```\n(defun circle (center radius color)\n   (tag circle (cx (car center)\n                cy (cdr center)\n                r radius\n                style (svg-style color))))\n```", "```\n> `(svg (circle '(50 . 50) 50 '(255 0 0))`\n `(circle '(100 . 100) 50 '(0 0 255)))`\n<svg  xmlns:xlink=\"http://www.w3.org/1999/\nxlink\"><circle cx=\"50\" cy=\"50\" r=\"50\"\nstyle=\"fill:rgb(255,0,0);stroke:rgb(155,0,0)\"></circle><circle cx=\"100\"\ncy=\"100\" r=\"50\" style=\"fill:rgb(0,0,255);stroke:rgb(0,0,155)\"></circle></svg>\n```", "```\n(defun polygon (points color)\n   (tag polygon (points (format nil\n                    \"˜{˜a,˜a ˜}\"\n                    (mapcan (lambda (tp)\n                       (list (car tp) (cdr tp)))\n                         points))\n          style (svg-style color))))\n```", "```\n(defun random-walk (value length)\n    (unless (zerop length)\n      (cons value\n           (random-walk (if (zerop (random 2))\n                             (1- value)\n                           (1+ value))\n                         (1- length)))))\n```", "```\n> `(random-walk 100 10)`\n(100 101 102 101 100 101 102 103 102 103)\n```", "```\n(with-open-file (*standard-output* \"random_walk.svg\"\n                   :direction :output\n                  :if-exists :supersede)\n   (svg (loop repeat 10\n              do (polygon (append '((0 . 200))\n                                   (loop for x\n                                         for y in (random-walk 100 400)\n                                         collect (cons x y))\n                                  '((400 . 200)))\n                            (loop repeat 3\n                                 collect (random 256))))))\n```", "```\n> `(load \"wizards_game.lisp\")`\n;; Loading file wizards_game.lisp ...\n;; Loaded file wizards_game.lisp\nT\n> `(look)`\n(YOU ARE IN THE ATTIC. THERE IS A GIANT WELDING TORCH IN THE CORNER. THERE IS\nA LADDER GOING DOWNSTAIRS FROM HERE.)\n> `(game-repl)`\n`look`\nYou are in the living-room. A wizard is snoring loudly on the couch. There is\na door going west from here. There is a ladder going upstairs\nfrom here. You see a whiskey on the floor. You see a bucket on the floor.\n`quit`\n```", "```\n (defun have (object)\n    (member object (inventory)))\n\n (defparameter *chain-welded* nil)\n\n (defun weld (subject object)\n   (if (and (eq *location* 'attic)\n             (eq subject 'chain)\n             (eq object 'bucket)\n             (have 'chain)\n             (have 'bucket)\n             (not *chain-welded*))\n       (progn (setf *chain-welded* t)\n               '(the chain is now securely welded to the bucket.))\n     '(you cannot weld like that.)))\n```", "```\n> `(weld 'chain 'bucket)`\n(YOU CANNOT WELD LIKE THAT.)\n```", "```\n> `(game-repl)`\n`weld chain bucket`\nI do not know that command.\n`quit`\n```", "```\n> `(pushnew 'weld *allowed-commands*)`\n(WELD LOOK WALK PICKUP INVENTORY)\n> `(game-repl)`\n`weld chain bucket`\nYou cannot weld like that.\n```", "```\n (setf *bucket-filled* nil)\n\n (defun dunk (subject object)\n   (if (and (eq *location* 'garden)\n             (eq subject 'bucket)\n             (eq object 'well)\n             (have 'bucket)\n             *chain-welded*)\n        (progn (setf *bucket-filled* 't)\n               '(the bucket is now full of water))\n      '(you cannot dunk like that.)))\n\n (pushnew 'dunk *allowed-commands*)\n```", "```\n (defmacro game-action (command subj obj place &body body)\n   `(progn (defun ,command (subject object)\n             (if (and (eq *location* ',place)\n                       (eq subject ',subj)\n                       (eq object ',obj)\n                      (have ',subj))\n                 ,@body\n             '(i cant ,command like that.)))\n           (pushnew ',command *allowed-commands*)))\n```", "```\n(defparameter *chain-welded* nil)\n\n(game-action weld chain bucket attic\n             (if (and (have 'bucket) (not *chain-welded*))\n                 (progn (setf *chain-welded* 't)\n                        '(the chain is now securely welded to the bucket.))\n               '(you do not have a bucket.)))\n\n(setf *bucket-filled* nil)\n\n(game-action dunk bucket well garden\n             (if *chain-welded*\n                 (progn (setf *bucket-filled* 't)\n                        '(the bucket is now full of water))\n               '(the water level is too low to reach.)))\n```", "```\n(game-action splash bucket wizard living-room\n   (cond ((not *bucket-filled*) '(the bucket has nothing in it.))\n         ((have 'frog) '(the wizard awakens and sees that you stole his frog.\n                         he is so upset he banishes you to the\n                         netherworlds- you lose! the end.))\n         (t '(the wizard awakens from his slumber and greets you warmly.\n              he hands you the magic low-carb donut- you win! the end.))))\n```", "```\n> `(game-repl)`\n`look`\nYou are in the living-room. There is a wizard  snoring loudly on the couch.\nThere is a door going west from here. There is a ladder going upstairs from\nhere. You see a whiskey on the floor. You see a bucket on the floor.\n`pickup bucket`\nYou are now carrying the bucket\n`pickup whiskey`\nYou are now carrying the whiskey\n`inventory`\nItems- whiskey bucket\n`walk upstairs`\nYou are in the attic. There is a giant welding torch in the corner. There is a\nladder going downstairs from here.\n`walk east`\nYou cannot go that way.\n`walk downstairs`\nYou are in the living-room. A wizard is snoring loudly on the couch. There is\na door going west from here. There is a ladder going upstairs from here.\n`walk west`\nYou are in a beautiful garden. There is a well in front of you. There is a\ndoor going east from here. You see a frog on the floor. You see\na chain on the floor.\n`dunk bucket well`\nThe water level is too low to reach.\n`pickup chain`\nYou are now carrying the chain\n`walk east`\nYou are in the living-room. A wizard is snoring loudly on the couch. There is\na door going west from here. There is a ladder going upstairs\nfrom here.\n`splash bucket wizard`\nThe bucket has nothing in it.\n```", "```\n> `(lazy (+ 1 2))`\n#<FUNCTION ...>\n```", "```\n> `(force (lazy (+ 1 2)))`\n3\n```", "```\n > `(defun add (a b)`\n   `(princ \"I am adding now\")`\n   `(+ a b))`\n  ADD\n > `(defparameter *foo* (lazy (add 1 2)))`\n  *FOO*\n > `(force *foo*)`\n I am adding now\n  3\n```", "```\n (defmacro lazy (&body body)\n   (let ((forced (gensym))\n          (value (gensym)))\n     `(let ((,forced nil)\n        (,value nil))\n        (lambda ()\n          (unless ,forced\n            (setf ,value (progn ,@body))\n            (setf ,forced t))\n          ,value))))\n```", "```\n(defun force (lazy-value)\n  (funcall lazy-value))\n```", "```\n(defmacro lazy-cons (a d)\n  `(lazy (cons ,a ,d)))\n```", "```\n(defun lazy-car (x)\n  (car (force x)))\n\n(defun lazy-cdr (x)\n  (cdr (force x)))\n```", "```\n > `(defparameter *foo* (lazy-cons 4 7))`\n  *FOO*\n > `(lazy-car *foo*)`\n  4\n > `(lazy-cdr *foo*)`\n  7\n```", "```\n(defparameter *integers*\n   (labels ((f (n)\n              (lazy-cons n (f (1+ n)))))\n        (f 1)))\n```", "```\n> `(lazy-car *integers*)`\n1\n> `(lazy-car (lazy-cdr *integers*))`\n2\n> `(lazy-car (lazy-cdr (lazy-cdr *integers*)))`\n3\n```", "```\n(defun lazy-nil ()\n  (lazy nil))\n\n(defun lazy-null (x)\n  (not (force x)))\n```", "```\n(defun make-lazy (lst)\n   (lazy (when lst\n           (cons (car lst) (make-lazy (cdr lst))))))\n```", "```\n (defun take (n lst)\n    (unless (or (zerop n) (lazy-null lst))\n      (cons (lazy-car lst) (take (1- n) (lazy-cdr lst)))))\n\n (defun take-all (lst)\n    (unless (lazy-null lst)\n      (cons (lazy-car lst) (take-all (lazy-cdr lst)))))\n```", "```\n > `(take 10 *integers*)`\n  (1 2 3 4 5 6 7 8 9 10)\n > `(take 10 (make-lazy '(q w e r t y u i o p a s d f)))`\n  (Q W E R T Y U I O P)\n  > `(take-all (make-lazy '(q w e r t y u i o p a s d f)))`\n (Q W E R T Y U I O P A S D F)\n```", "```\n(defun lazy-mapcar (fun lst)\n  (lazy (unless (lazy-null lst)\n          (cons (funcall fun (lazy-car lst))\n                (lazy-mapcar fun (lazy-cdr lst))))))\n\n(defun lazy-mapcan (fun lst)\n  (labels ((f (lst-cur)\n          (if (lazy-null lst-cur)\n                  (force (lazy-mapcan fun (lazy-cdr lst)))\n                (cons (lazy-car lst-cur) (lazy (f (lazy-cdr lst-cur)))))))\n    (lazy (unless (lazy-null lst)\n        (f (funcall fun (lazy-car lst)))))))\n\n(defun lazy-find-if (fun lst)\n  (unless (lazy-null lst)\n    (let ((x (lazy-car lst)))\n      (if (funcall fun x)\n          x\n        (lazy-find-if fun (lazy-cdr lst))))))\n\n(defun lazy-nth (n lst)\n  (if (zerop n)\n      (lazy-car lst)\n    (lazy-nth (1- n) (lazy-cdr lst))))\n```", "```\n > `(take 10 (lazy-mapcar #'sqrt *integers*))`\n  (1 1.4142135 1.7320508 2 2.236068 2.4494898\n   2.6457512 2.828427 3 3.1622777)\n > `(take 10 (lazy-mapcan (lambda (x)`\n   `(if (evenp x)`\n  `(make-lazy (list x))`\n  `(lazy-nil)))`\n   `*integers*))`\n  (2 4 6 8 10 12 14 16 18 20)\n > `(lazy-find-if #'oddp (make-lazy '(2 4 6 7 8 10)))`\n  7\n > `(lazy-nth 4 (make-lazy '(a b c d e f g)))`\n  E\n```", "```\n> `(load \"dice_of_doom_v1.lisp\")`\n> `(load \"lazy.lisp\")`\n```", "```\n> `(defparameter *board-size* 4)`\n> `(defparameter *board-hexnum* (* *board-size* *board-size*))`\n```", "```\n(defun add-passing-move (board player spare-dice first-move moves)\n    (if first-move\n        moves\n       (lazy-cons (list nil\n                         (game-tree (add-new-dice board player\n                                                  (1- spare-dice))\n                                    (mod (1+ player) *num-players*)\n                                    0\n                                    t))\n                   moves)))\n\n  (defun attacking-moves (board cur-player spare-dice)\n    (labels ((player (pos)\n          (car (aref board pos)))\n       (dice (pos)\n           (cadr (aref board pos))))\n     (lazy-mapcan\n       (lambda (src)\n         (if (eq (player src) cur-player)\n            (lazy-mapcan\n              (lambda (dst)\n                (if (and (not (eq (player dst)\n                                  cur-player))\n                         (> (dice src) (dice dst)))\n                   (make-lazy\n                     (list (list (list src dst)\n                                 (game-tree (board-attack board\n                                                          cur-player\n                                                          src\n                                                          dst\n                                                          (dice src))\n                                            cur-player\n                                            (+ spare-dice (dice dst))\n                                            nil))))\n                 (lazy-nil)))\n             (make-lazy (neighbors src)))\n          (lazy-nil)))\n      (make-lazy (loop for n below *board-hexnum*\n                        collect n)))))\n```", "```\n(defun handle-human (tree)\n    (fresh-line)\n    (princ \"choose your move:\")\n    (let ((moves (caddr tree)))\n      (labels ((print-moves (moves n)\n                     (unless (lazy-null moves)\n                       (let* ((move (lazy-car moves))\n                           (action (car move)))\n                          (fresh-line)\n                          (format t \"˜a. \" n)\n                          (if action\n                            (format t \"˜a -> ˜a\" (car action) (cadr action))\n                           (princ \"end turn\")))\n                       (print-moves (lazy-cdr moves) (1+ n)))))\n            (print-moves moves 1))\n      (fresh-line)\n     (cadr (lazy-nth (1- (read)) moves))))\n\n  (defun play-vs-human (tree)\n    (print-info tree)\n   (if (not (lazy-null (caddr tree)))\n        (play-vs-human (handle-human tree))\n      (announce-winner (cadr tree))))\n```", "```\n> `(play-vs-human (game-tree (gen-board) 0 0 t))`\ncurrent player = a\n        a-1 a-3 a-1 b-2\n      b-3 a-3 a-3 a-1\n    a-3 a-3 b-1 a-2\n  b-3 a-3 a-1 a-3\nchoose your move:\n1\\. 5 -> 10\n2\\. 6 -> 10\n3\\. 9 -> 10\n4\\. 11 -> 10\n5\\. 15 -> 10\n```", "```\n (defun limit-tree-depth (tree depth)\n    (list (car tree)\n      (cadr tree)\n     (if (zerop depth)\n         (lazy-nil)\n        (lazy-mapcar (lambda (move)\n                         (list (car move)\n                              (limit-tree-depth (cadr move) (1- depth))))\n                 (caddr tree)))))\n```", "```\n(defparameter *ai-level* 4)\n\n  (defun handle-computer (tree)\n   (let ((ratings (get-ratings (limit-tree-depth tree *ai-level*)\n                                (car tree))))\n      (cadr (lazy-nth (position (apply #'max ratings) ratings)\n                     (caddr tree)))))\n```", "```\n(defun play-vs-computer (tree)\n    (print-info tree)\n   (cond ((lazy-null (caddr tree)) (announce-winner (cadr tree)))\n          ((zerop (car tree)) (play-vs-computer (handle-human tree)))\n          (t (play-vs-computer (handle-computer tree)))))\n```", "```\n(defun score-board (board player)\n   (loop for hex across board\n          for pos from 0\n         sum (if (eq (car hex) player)\n                 (if (threatened pos board)\n                     1\n                   2)\n               −1)))\n```", "```\n(defun threatened (pos board)\n   (let* ((hex (aref board pos))\n           (player (car hex))\n           (dice (cadr hex)))\n     (loop for n in (neighbors pos)\n           do (let* ((nhex (aref board n))\n                      (nplayer (car nhex))\n                      (ndice (cadr nhex)))\n                (when (and (not (eq player nplayer)) (> ndice dice))\n                  (return t))))))\n```", "```\n(defun get-ratings (tree player)\n   (take-all (lazy-mapcar (lambda (move)\n                             (rate-position (cadr move) player))\n                           (caddr tree))))\n\n  (defun rate-position (tree player)\n    (let ((moves (caddr tree)))\n     (if (not (lazy-null moves))\n      (apply (if (eq (car tree) player)\n             #'max\n           #'min)\n             (get-ratings tree player))\n       (score-board (cadr tree) player))))\n```", "```\n> `(play-vs-computer (game-tree (gen-board) 0 0 t))`\ncurrent player = a\n        a-1 b-2 b-1 a-3\n      b-3 a-1 a-3 a-3\n    b-3 b-2 b-2 b-2\n  a-3 a-3 a-2 a-2\nchoose your move:\n1\\. 3 -> 2\n2\\. 6 -> 2\n3\\. 6 -> 10\n4\\. 6 -> 1\n5\\. 6 -> 11\n6\\. 7 -> 11\n7\\. 7 -> 2\n8\\. 13 -> 9\n`3`\ncurrent player = a\n        a-1 b-2 b-1 a-3\n      b-3 a-1 a-1 a-3\n    b-3 b-2 a-2 b-2\n  a-3 a-3 a-2 a-2\nchoose your move:\n1\\. end turn\n2\\. 3 -> 2\n3\\. 7 -> 11\n4\\. 7 -> 2\n5\\. 13 -> 9\n`1`\ncurrent player = b\n        a-2 b-2 b-1 a-3\n      b-3 a-1 a-1 a-3\n    b-3 b-2 a-2 b-2\n  a-3 a-3 a-2 a-2\ncurrent player = b\n        a-2 b-1 b-1 a-3\n      b-3 b-1 a-1 a-3\n    b-3 b-2 a-2 b-2\n  a-3 a-3 a-2 a-2\ncurrent player = b\n        b-2 b-1 b-1 a-3\n      b-1 b-1 a-1 a-3\n    b-3 b-2 a-2 b-2\n  a-3 a-3 a-2 a-2\ncurrent player = b\n        b-2 b-1 b-1 a-3\n      b-1 b-1 b-1 a-3\n    b-3 b-2 a-2 b-1\n  a-3 a-3 a-2 a-2\ncurrent player = a\n        b-3 b-2 b-2 a-3\n      b-1 b-1 b-1 a-3\n    b-3 b-2 a-2 b-1\n  a-3 a-3 a-2 a-2\nchoose your move:\n1\\. 3 -> 2\n2\\. 7 -> 11\n3\\. 7 -> 2\n4\\. 7 -> 6\n5\\. 10 -> 6\n6\\. 10 -> 5\n7\\. 10 -> 11\n8\\. 13 -> 9\n9\\. 15 -> 11\n...\n```", "```\n (defun ab-get-ratings-max (tree player upper-limit lower-limit)\n    (labels ((f (moves lower-limit)\n             (unless (lazy-null moves)\n              (let ((x (ab-rate-position (cadr (lazy-car moves))\n                                          player\n                                          upper-limit\n                                          lower-limit)))\n                (if (>= x upper-limit)\n                    (list x)\n                  (cons x (f (lazy-cdr moves) (max x lower-limit))))))))\n      (f (caddr tree) lower-limit)))\n```", "```\n(defun ab-get-ratings-min (tree player upper-limit lower-limit)\n  (labels ((f (moves upper-limit)\n           (unless (lazy-null moves)\n             (let ((x (ab-rate-position (cadr (lazy-car moves))\n                                        player\n                                        upper-limit\n                                        lower-limit)))\n               (if (<= x lower-limit)\n                   (list x)\n                 (cons x (f (lazy-cdr moves) (min x upper-limit))))))))\n    (f (caddr tree) upper-limit)))\n```", "```\n(defun ab-rate-position (tree player upper-limit lower-limit)\n    (let ((moves (caddr tree)))\n      (if (not (lazy-null moves))\n       (if (eq (car tree) player)\n           (apply #'max (ab-get-ratings-max tree\n                                             player\n                                             upper-limit\n                                             lower-limit))\n           (apply #'min (ab-get-ratings-min tree\n                                             player\n                                             upper-limit\n                                             lower-limit)))\n        (score-board (cadr tree) player))))\n```", "```\n(defun handle-computer (tree)\n   (let ((ratings (ab-get-ratings-max (limit-tree-depth tree *ai-level*)\n                                       (car tree)\n                                      most-positive-fixnum\n                                      most-negative-fixnum)))\n      (cadr (lazy-nth (position (apply #'max ratings) ratings) (caddr tree)))))\n```", "```\n(defparameter *board-size* 5)\n(defparameter *board-hexnum* (* *board-size* *board-size*))\n```", "```\n> `(play-vs-computer (game-tree (gen-board) 0 0 t))`\ncurrent player = a\n          a-2 b-2 a-1 b-2 b-2\n        a-1 b-2 b-3 b-3 a-3\n      a-1 b-2 a-3 b-1 b-2\n    b-1 b-3 a-2 b-2 a-1\n  b-3 b-1 b-1 a-3 b-3\nchoose your move:\n1\\. 9 -> 13\n2\\. 9 -> 4\n3\\. 9 -> 14\n4\\. 12 -> 13\n5\\. 17 -> 22\n6\\. 23 -> 18\n7\\. 23 -> 22\n`3`\ncurrent player = a\n          a-2 b-2 a-1 b-2 b-2\n        a-1 b-2 b-3 b-3 a-1\n      a-1 b-2 a-3 b-1 a-2\n    b-1 b-3 a-2 b-2 a-1\n  b-3 b-1 b-1 a-3 b-3\nchoose your move:\n1\\. end turn\n2\\. 12 -> 13\n3\\. 14 -> 13\n4\\. 14 -> 15\n5\\. 17 -> 22\n6\\. 23 -> 18\n7\\. 23 -> 22\n`1`\ncurrent player = b\n          a-3 b-2 a-1 b-2 b-2\n        a-1 b-2 b-3 b-3 a-1\n      a-1 b-2 a-3 b-1 a-2\n    b-1 b-3 a-2 b-2 a-1\n  b-3 b-1 b-1 a-3 b-3\ncurrent player = b\n          a-3 b-1 a-1 b-2 b-2\n        b-1 b-2 b-3 b-3 a-1\n      a-1 b-2 a-3 b-1 a-2\n    b-1 b-3 a-2 b-2 a-1\n  b-3 b-1 b-1 a-3 b-3\ncurrent player = b\n          a-3 b-1 b-1 b-1 b-2\n        b-1 b-2 b-3 b-3 a-1\n      a-1 b-2 a-3 b-1 a-2\n    b-1 b-3 a-2 b-2 a-1\n  b-3 b-1 b-1 a-3 b-3\ncurrent player = b\n          a-3 b-1 b-1 b-1 b-1\n        b-1 b-2 b-3 b-3 b-1\n      a-1 b-2 a-3 b-1 a-2\n    b-1 b-3 a-2 b-2 a-1\n  b-3 b-1 b-1 a-3 b-3\ncurrent player = b\n          a-3 b-1 b-1 b-1 b-1\n        b-1 b-1 b-3 b-3 b-1\n      b-1 b-2 a-3 b-1 a-2\n    b-1 b-3 a-2 b-2 a-1\n  b-3 b-1 b-1 a-3 b-3\ncurrent player = b\n          a-3 b-1 b-1 b-1 b-1\n        b-1 b-1 b-3 b-3 b-1\n      b-1 b-2 a-3 b-1 a-2\n    b-1 b-1 b-2 b-2 a-1\n  b-3 b-1 b-1 a-3 b-3\ncurrent player = b\n          a-3 b-1 b-1 b-1 b-1\n        b-1 b-1 b-3 b-3 b-1\n      b-1 b-2 a-3 b-1 a-2\n    b-1 b-1 b-2 b-2 b-2\n  b-3 b-1 b-1 a-3 b-1\ncurrent player = a\n          a-3 b-2 b-2 b-2 b-2\n        b-2 b-2 b-3 b-3 b-1\n      b-1 b-2 a-3 b-1 a-2\n    b-1 b-1 b-2 b-2 b-2\n  b-3 b-1 b-1 a-3 b-1\nchoose your move:\n1\\. 0 -> 4\n2\\. 0 -> 1\n3\\. 0 -> 5\n4\\. 12 -> 13\n5\\. 14 -> 10\n6\\. 14 -> 9\n7\\. 14 -> 13\n8\\. 14 -> 15\n9\\. 23 -> 18\n10\\. 23 -> 17\n11\\. 23 -> 22\n12\\. 23 -> 24\n```", "```\n> `(load \"dice_of_doom_v2.lisp\")`\n> `(load \"webserver.lisp\")`\n```", "```\n> `(load \"svg.lisp\")`\n```", "```\n(defparameter *board-width* 900)\n  (defparameter *board-height* 500)\n (defparameter *board-scale* 64)\n (defparameter *top-offset* 3)\n (defparameter *dice-scale* 40)\n (defparameter *dot-size* 0.05)\n```", "```\n (defun draw-die-svg (x y col)\n   (labels ((calc-pt (pt)\n                  (cons (+ x (* *dice-scale* (car pt)))\n                        (+ y (* *dice-scale* (cdr pt)))))\n            (f (pol col)\n                (polygon (mapcar #'calc-pt pol) col)))\n         (f '((0 . −1) (−0.6 . −0.75) (0 . −0.5) (0.6 . −0.75))\n             (brightness col 40))\n          (f '((0 . −0.5) (−0.6 . −0.75) (−0.6 . 0) (0 . 0.25))\n             col)\n          (f '((0 . −0.5) (0.6 . −0.75) (0.6 . 0) (0 . 0.25))\n             (brightness col −40))\n         (mapc (lambda (x y)\n                (polygon (mapcar (lambda (xx yy)\n                                   (calc-pt (cons (+ x (* xx *dot-size*))\n                                                  (+ y (* yy *dot-size*)))))\n                                 '(−1 −1 1 1)\n                                 '(−1 1 1 −1))\n                         '(255 255 255)))\n             '(−0.05 0.125 0.3 −0.3 −0.125 0.05 0.2 0.2 0.45 0.45 −0.45 −0.2)\n              '(−0.875 −0.80 −0.725 −0.775 −0.70 −0.625\n                −0.35 −0.05 −0.45 −0.15 −0.45 −0.05))))\n```", "```\n> `(svg 100 100 (draw-die-svg 50 50 '(255 0 0)))`\n<svg  xmlns\n:xlink=\"http://www.w3.org/1999/xlink\" height=\"100\" width=\"100\"><polygon\n points=\"50,10 26.0,20.0 50,30.0 74.0,20.0 \" style=\"fill:rgb(255,40,40);stroke:rgb\n(155,0,0)\"></polygon><polygon points=\"50,30.0 26.0,20.0 26.0,50 50,60.0\n\" style=\"fill:rgb(255,0,0);stroke:rgb(155,0,0)\"></polygon><polygon points=\"50,\n30.0 74.0,20.0 74.0,50 50,60.0 \" style=\"fill:rgb(215,0,0);\nstroke:rgb(115,0,0)\"></polygon><polygon points=\"46.0,\n13.0 46.0,17.0 50.0,17.0 50.0,13.0 \" style=\"fill:rgb(255,255,255);stroke:rgb(155,155,\n155)\"></polygon><polygon points=\"53.0,16.0 53.0,20.0 57.0,20.0 57.0,16.0\n \" style=\"fill:rgb(255,255,255);stroke:rgb(155,155,155)\"></polygon><polygon\n points=\"60.0,18.999998 60.0,23.0 64.0,23.0 64.0,18.999998 \"\n style=\"fill:rgb(255,255,255);stroke:rgb(155,155,155)\"></polygon><polygon\n points=\"36.0,17.0 36.0,21.000002 40.0,21.000002 40.0,17.0 \" style=\"fill:rgb(255,255,\n255);stroke:rgb(155,155,155)\"></polygon><polygon points=\"43.0,20.0 43.0,\n24.0 47.0,24.0 47.0,20.0 \" style=\"fill:rgb(255,255,255);stroke:rgb(155,155,155)\"><\n/polygon><polygon points=\"50.0,23.0 50.0,27.0 54.0,27.0 54.0,23.0 \"\n style=\"fill:rgb(255,255,255);\nstroke:rgb(155,155,155)\"></polygon><polygon points=\"56.0,34.0 56.0,38.0\n60.0,38.0 60.0,34.0 \" style=\"fill:rgb(255,255,255);stroke:rgb(155,155,155)\"></polygon>\n<polygon points=\"56.0,46.0 56.0,50.0 60.0,50.0 60.0,46.0 \"\n style=\"fill:rgb(255,255,255);stroke:rgb(155,155,155)\">\n</polygon><polygon points=\"66.0,30.0 66.0,34.0 70.0,34.0 70.0,30.0 \" style=\n\"fill:rgb(255,255,255);stroke:rgb(155,155,155)\"></polygon><polygon\n points=\"66.0,42.0 66.0,46.0 70.0,46.0 70.0,42.0 \" style=\"fill:rgb\n(255,255,255);stroke:rgb(155,155,155)\"></polygon><polygon points=\"30.0,30.0\n 30.0,34.0 34.0,34.0 34.0,30.0 \" style=\"fill:rgb(255,255,255);stroke:rgb\n(155,155,155)\"></polygon><polygon points=\"40.0,46.0 40.0,50.0 44.0,\n50.0 44.0,46.0 \" style=\"fill:rgb(255,255,255);stroke:rgb(155,155,155)\"\n></polygon></svg>\n```", "```\n(defun draw-tile-svg (x y pos hex xx yy col chosen-tile)\n   (loop for z below 2\n         do (polygon (mapcar (lambda (pt)\n                                (cons (+ xx (* *board-scale* (car pt)))\n                                      (+ yy (* *board-scale*\n                                               (+ (cdr pt) (* (- 1 z) 0.1))))))\n                             '((−1 . −0.2) (0 . −0.5) (1 . −0.2)\n                                (1 . 0.2) (0 . 0.5) (−1 . 0.2)))\n                     (if (eql pos chosen-tile)\n                          (brightness col 100)\n                        col)))\n   (loop for z below (second hex)\n         do (draw-die-svg (+ xx\n                              (* *dice-scale*\n                                 0.3\n                                (if (oddp (+ x y z))\n                                     −0.3\n                                   0.3)))\n                           (- yy (* *dice-scale* z 0.8)) col)))\n```", "```\n> `(svg 300 300 (draw-tile-svg 0 0 0 '(0 3) 100 150 '(255 0 0) nil))`\n<svg  xmlns:xlink=\"http://www.w3.org/\n1999/xlink\" height=\"300\" width=\"300\"><polygon points=\"36,143.6 100,124.4\n 164,143.6 164,169.2 100,188.4 36,169.2 \" style=\"fill:rgb\n(255,0,0);stroke:rgb(155,0,0)\">\n...\n```", "```\n(defparameter *die-colors* '((255 63 63) (63 63 255)))\n\n (defun draw-board-svg (board chosen-tile legal-tiles)\n   (loop for y below *board-size*\n       do (loop for x below *board-size*\n              for pos = (+ x (* *board-size* y))\n               for hex = (aref board pos)\n               for xx = (* *board-scale* (+ (* 2 x) (- *board-size* y)))\n               for yy = (* *board-scale* (+ (* y 0.7) *top-offset*))\n               for col = (brightness (nth (first hex) *die-colors*)\n                                         (* −15 (- *board-size* y)))\n                  do (if (member pos legal-tiles)\n                          (tag g ()\n                           (tag a (\"xlink:href\" (make-game-link pos))\n                       (draw-tile-svg x y pos hex xx yy col chosen-tile)))\n                        (draw-tile-svg x y pos hex xx yy col chosen-tile)))))\n\n  (defun make-game-link (pos)\n    (format nil \"/game.html?chosen=˜a\" pos))\n```", "```\n> `(svg *board-width* *board-height* (draw-board-svg (gen-board) nil nil))`\n<svg  xmlns:xlink=\"http://www.w3.org/\n1999/xlink\" height=\"500\" width=\"900\"><polygon points=\"256,185.6 320,166.4\n 384,185.6 384,211.2 320,230.4 256,211.2 \"\n...\n```", "```\n(defparameter *cur-game-tree* nil)\n  (defparameter *from-tile* nil)\n\n  (defun dod-request-handler (path header params)\n   (if (equal path \"game.html\")\n       (progn (princ \"<!doctype html>\")\n              (tag center ()\n                    (princ \"Welcome to DICE OF DOOM!\")\n                    (tag br ())\n                   (let ((chosen (assoc 'chosen params)))\n                     (when (or (not *cur-game-tree*) (not chosen))\n                        (setf chosen nil)\n                       (web-initialize))\n                      (cond ((lazy-null (caddr *cur-game-tree*))\n                              (web-announce-winner (cadr *cur-game-tree*)))\n                            ((zerop (car *cur-game-tree*))\n                              (web-handle-human\n                                  (when chosen\n                                        (read-from-string (cdr chosen)))))\n                           (t (web-handle-computer))))\n                    (tag br ())\n                   (draw-dod-page *cur-game-tree* *from-tile*)))\n      (princ \"Sorry... I don't know that page.\")))\n```", "```\n(defun web-initialize ()\n    (setf *from-tile* nil)\n   (setf *cur-game-tree* (game-tree (gen-board) 0 0 t)))\n```", "```\n(defun web-announce-winner (board)\n    (fresh-line)\n    (let ((w (winners board)))\n      (if (> (length w) 1)\n        (format t \"The game is a tie between ˜a\" (mapcar #'player-letter w))\n        (format t \"The winner is ˜a\" (player-letter (car w)))))\n   (tag a (href \"game.html\")\n         (princ \" play again\")))\n```", "```\n(defun web-handle-human (pos)\n   (cond ((not pos) (princ \"Please choose a hex to move from:\"))\n          ((eq pos 'pass) (setf *cur-game-tree*\n                                (cadr (lazy-car (caddr *cur-game-tree*))))\n          (princ \"Your reinforcements have been placed.\")\n           (tag a (href (make-game-link nil))\n                (princ \"continue\")))\n         ((not *from-tile*) (setf *from-tile* pos)\n                             (princ \"Now choose a destination:\"))\n         ((eq pos *from-tile*) (setf *from-tile* nil)\n                                (princ \"Move cancelled.\"))\n         (t (setf *cur-game-tree*\n                   (cadr (lazy-find-if (lambda (move)\n                                         (equal (car move)\n                                                (list *from-tile* pos)))\n                                       (caddr *cur-game-tree*))))\n             (setf *from-tile* nil)\n             (princ \"You may now \")\n            (tag a (href (make-game-link 'pass))\n                  (princ \"pass\"))\n             (princ \" or make another move:\"))))\n```", "```\n(defun web-handle-computer ()\n   (setf *cur-game-tree* (handle-computer *cur-game-tree*))\n   (princ \"The computer has moved. \")\n   (tag script ()\n      (princ\n        \"window.setTimeout('window.location=\\\"game.html?chosen=NIL\\\"',5000)\")))\n```", "```\n(defun draw-dod-page (tree selected-tile)\n    (svg *board-width*\n         *board-height*\n         (draw-board-svg (cadr tree)\n                         selected-tile\n                        (take-all (if selected-tile\n                                       (lazy-mapcar\n                                        (lambda (move)\n                                           (when (eql (caar move)\n                                                     selected-tile)\n                                                (cadar move)))\n                                         (caddr tree))\n                                    (lazy-mapcar #'caar (caddr tree)))))))\n```", "```\n> `(serve #'dod-request-handler)`\n```", "```\n> `(load \"dice_of_doom_v3.lisp\")`\n```", "```\n(defparameter *num-players* 4)\n(defparameter *die-colors* '((255 63 63) (63 63 255) (63 255 63)\n                             (255 63 255)))\n```", "```\n(defparameter *max-dice* 5)\n(defparameter *ai-level* 2)\n```", "```\n(defun attacking-moves (board cur-player spare-dice)\n    (labels ((player (pos)\n                 (car (aref board pos)))\n           (dice (pos)\n               (cadr (aref board pos))))\n      (lazy-mapcan (lambda (src)\n                     (if (eq (player src) cur-player)\n                       (lazy-mapcan\n                         (lambda (dst)\n                           (if (and (not (eq (player dst) cur-player))\n                                    (> (dice src) 1))\n                               (make-lazy (list (list (list src dst)\n        (game-tree (board-attack board cur-player src dst (dice src))\n                   cur-player\n                   (+ spare-dice (dice dst))\n                   nil)\n       (game-tree (board-attack-fail board cur-player src dst (dice src))\n                   cur-player\n                   (+ spare-dice (dice dst))\n                   nil))))\n                                        (lazy-nil)))\n                                    (make-lazy (neighbors src)))\n                       (lazy-nil)))\n                   (make-lazy (loop for n below *board-hexnum*\n                            collect n)))))\n```", "```\n(defun board-attack-fail (board player src dst dice)\n    (board-array (loop for pos from 0\n                       for hex across board\n                       collect (if (eq pos src)\n                                  (list player 1)\n                                hex))))\n```", "```\n(defun roll-dice (dice-num)\n   (let ((total (loop repeat dice-num\n                       sum (1+ (random 6)))))\n      (fresh-line)\n     (format t \"On ˜a dice rolled ˜a. \" dice-num total)\n     total))\n```", "```\n(defun roll-against (src-dice dst-dice)\n  (> (roll-dice src-dice) (roll-dice dst-dice)))\n```", "```\n (defun pick-chance-branch (board move)\n    (labels ((dice (pos)\n                   (cadr (aref board pos))))\n      (let ((path (car move)))\n       (if (or (null path) (roll-against (dice (car path))\n                                          (dice (cadr path))))\n           (cadr move)\n         (caddr move)))))\n```", "```\n(defun handle-human (tree)\n    (fresh-line)\n    (princ \"choose your move:\")\n    (let ((moves (caddr tree)))\n      (labels ((print-moves (moves n)\n                      (unless (lazy-null moves)\n                        (let* ((move (lazy-car moves))\n                             (action (car move)))\n                          (fresh-line)\n                          (format t \"˜a. \" n)\n                          (if action\n                            (format t \"˜a -> ˜a\" (car action) (cadr action))\n                          (princ \"end turn\")))\n                        (print-moves (lazy-cdr moves) (1+ n)))))\n            (print-moves moves 1))\n      (fresh-line)\n     (pick-chance-branch (cadr tree) (lazy-nth (1- (read)) moves))))\n```", "```\n(defun handle-computer (tree)\n    (let ((ratings (get-ratings (limit-tree-depth tree *ai-level*) (car tree))))\n      (pick-chance-branch\n        (cadr tree)\n       (lazy-nth (position (apply #'max ratings) ratings) (caddr tree)))))\n```", "```\n(defparameter *dice-odds* #(#(0.84 0.97 1.0 1.0)\n                            #(0.44 0.78 0.94 0.99)\n                            #(0.15 0.45 0.74 0.91)\n                            #(0.04 0.19 0.46 0.72)\n                            #(0.01 0.06 0.22 0.46)))\n```", "```\n(defun get-ratings (tree player)\n    (let ((board (cadr tree)))\n      (labels ((dice (pos)\n                     (cadr (aref board pos))))\n        (take-all (lazy-mapcar\n                    (lambda (move)\n                      (let ((path (car move)))\n                        (if path\n                            (let* ((src (car path))\n                                   (dst (cadr path))\n                                  (odds (aref (aref *dice-odds*\n                                                     (1- (dice dst)))\n                                               (- (dice src) 2))))\n                             (+ (* odds (rate-position (cadr move) player))\n                                (* (- 1 odds) (rate-position (caddr move)\n                                                              player))))\n                          (rate-position (cadr move) player))))\n                    (caddr tree))))))\n```", "```\n(defun limit-tree-depth (tree depth)\n    (list (car tree)\n          (cadr tree)\n          (if (zerop depth)\n              (lazy-nil)\n            (lazy-mapcar (lambda (move)\n                           (cons (car move)\n                                (mapcar (lambda (x)\n                                           (limit-tree-depth x (1- depth)))\n                                         (cdr move))))\n                         (caddr tree)))))\n```", "```\n(defun get-connected (board player pos)\n   (labels ((check-pos (pos visited)\n               (if (and (eq (car (aref board pos)) player)\n                        (not (member pos visited)))\n                   (check-neighbors (neighbors pos) (cons pos visited))\n                 visited))\n            (check-neighbors (lst visited)\n               (if lst\n                   (check-neighbors (cdr lst) (check-pos (car lst) visited))\n                 visited)))\n     (check-pos pos '())))\n```", "```\n(defun largest-cluster-size (board player)\n   (labels ((f (pos visited best)\n             (if (< pos *board-hexnum*)\n                (if (and (eq (car (aref board pos)) player)\n                        (not (member pos visited)))\n                   (let* ((cluster (get-connected board player pos))\n                         (size (length cluster)))\n                   (if (> size best)\n                       (f (1+ pos) (append cluster visited) size)\n                     (f (1+ pos) (append cluster visited) best)))\n                  (f (1+ pos) visited best))\n              best)))\n          (f 0 '() 0)))\n```", "```\n (defun add-new-dice (board player spare-dice)\n    (labels ((f (lst n)\n              (cond ((zerop n) lst)\n                  ((null lst) nil)\n                  (t (let ((cur-player (caar lst))\n                         (cur-dice (cadar lst)))\n                     (if (and (eq cur-player player) (< cur-dice *max-dice*))\n                         (cons (list cur-player (1+ cur-dice))\n                               (f (cdr lst) (1- n)))\n                       (cons (car lst) (f (cdr lst) n))))))))\n          (board-array (f (coerce board 'list)\n                         (largest-cluster-size board player)))))\n```", "```\n> `(serve #'dod-request-handler)`\n```", "```\n (defun unique-letters (name)\n      (concatenate 'string\n                   \"Hello \"\n                   (coerce (remove-duplicates name) 'string)))\n\n (defun ask-and-respond ()\n      (princ \"What is your name?\")\n      (princ (unique-letters (read-line))))\n```", "```\n(defmacro three-way-if (expr a b &rest c)\n   (let ((val (gensym)))\n       `(let ((,val ,expr))\n          (cond ((and (numberp ,val) (zerop ,val)) ,a)\n                (,val ,@c)\n                (t ,b)))))\n```", "```\n(defun raise-widget-prices (widgets)\n   (when widgets\n        (loop (restart-case (progn (raise-price (car widgets))\n                                   (return))\n                (try-again () (princ \"trying again\"))))\n         (raise-widget-prices (cdr widgets))))\n```", "```\n (defparameter foo (list 1 (make-hash-table) 3))\n (setf (gethash 'my-key (nth foo 1)) 77)\n```", "```\n (html (body (princ \"Hello \")\n             (bold (princ \"World!\"))))\n```", "```\n (defclass widget ()\n      ((color :accessor widget-color\n                :initarg :color)))\n (defmethod describe-widget ((w widget))\n     (format t \"this is a ˜a widget\" (widget-color w)))\n (defmethod describe-widget :before ((w widget))\n    (add-to-log \"Somebody is checking on a widget\"))\n```", "```\n (defmethod describe-widget ((w widget))\n   (add-to-log \"Somebody is checking on a widget\")\n    (format t \"this is a ˜a widget\" (widget-color w)))\n```", "```\n (defclass color () ())\n (defclass red (color) ())\n  (defclass blue (color) ())\n  (defclass yellow (color) ())\n\n (defmethod mix ((c1 color) (c2 color))\n      \"I don't know what color that makes\")\n\n (defmethod mix ((c1 blue) (c2 yellow))\n    \"you made green!\")\n\n (defmethod mix ((c1 yellow) (c2 red))\n    \"you made orange!\")\n```", "```\n> `(mix (make-instance 'red) (make-instance 'blue))`\n\"I don't know what color that makes\"\n> `(mix (make-instance 'yellow) (make-instance 'red))`\n\"you made orange!\"\n```", "```\n(define continuation null)\n\n (define (foo n)\n    (* (call-with-current-continuation\n           (lambda (c)\n             (set! continuation c)\n              (+ n 1)))\n      2))\n```", "```\n (accum a\n   (for n 1 1000\n        (unless (some [is 0 (mod n _)] (range 2 (- n 1)))\n            a.n)))\n```", "```\n (def checking (ref 100))\n  (def savings (ref 200))\n\n (defn transfer-to-savings [n]\n       (dosync (alter checking - n)\n                (alter savings + n)))\n```", "```\n(take 20 (filter even? (iterate inc 0)))\n```"]