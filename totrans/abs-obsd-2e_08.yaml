- en: Chapter 8. Disks and Filesystems
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Oh, my head hurts bad.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*Rings of ones and zeros, ouch!*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '*Filesystems hide them.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) Proper data management
    is perhaps a systems administrator’s most vital duty. You can replace almost every
    computer component, but the data on your disk is irreplaceable. Perhaps that data
    isn’t important or it’s backed up, but losing files will ruin your day. As a sysadmin,
    you must protect important data by carefully managing your disks and filesystems.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We covered the basics of disklabels and MBR partitions in [Chapter 2](ch02.html
    "Chapter 2. Installation Preparations"), but OpenBSD lets you use and abuse disks
    and filesystems in any number of ways. You’ll learn how in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Device Nodes
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *device node* is a file that provides a logical interface to a piece of hardware.
    By reading from a device node, sending data to it, or using a command on it, you’re
    telling the operating system to perform an action on a piece of hardware or, in
    some cases, a logical device.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Different devices behave differently when data is sent to them. For example,
    writing to the console makes text appear on the screen or terminal, while writing
    to a disk device puts data on that disk. (OpenBSD puts device nodes in */dev*
    and disallows device nodes on other filesystems.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Many disk management programs expect to be given a device name as an argument.
    Unfortunately, device node names are frequently cryptic and vary widely among
    operating systems—even on closely related operating systems that run on the same
    hardware. To simplify your life just a bit, [Table 8-1](ch08.html#common_disk_device_node_names
    "Table 8-1. Table 8-1: Common Disk Device Node Names") lists the device node names
    for common OpenBSD disk devices.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-1. Table 8-1: Common Disk Device Node Names'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '| Device Node | Description |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
- en: '| */dev/fd** | Floppy disk (block) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| */dev/rfd** | Floppy disk (raw) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| */dev/wd** | IDE and some SATA disks (block) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| */dev/rwd** | IDE and some SATA disks (raw) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| */dev/sd** | SCSI/SAS/SATA/USB/RAID/non-IDE disk (block) |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| */dev/rsd** | SCSI/SAS/SATA/USB/RAID/non-IDE disk (raw) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| */dev/cd** | CD/DVD drive (block) |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: Device names also have a number that tells you which instance of that device
    it refers to. The numbering starts at 0\. The first IDE hard drive is */dev/wd0*,
    */dev/wd1* is the second, and */dev/cd1* is the second CD drive.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Every partition is assigned a letter. For example, the root partition is *a*,
    the swap area is *b*, the whole disk is *c*, and so on. Each partition also has
    a separate device node, the result of appending the partition letter to your disk
    device name. For example, if you install to a single IDE drive, your root partition
    is */dev/wd0a*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Raw and Block Devices
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Notice in [Table 8-1](ch08.html#common_disk_device_node_names "Table 8-1. Table
    8-1: Common Disk Device Node Names") that devices are listed in either block or
    raw (character) mode. This refers to how the devices are accessed.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在[表8-1](ch08.html#common_disk_device_node_names "表8-1. 表8-1：常见磁盘设备节点名称")中，设备以块或原始（字符）模式列出。这指的是设备是如何被访问的。
- en: Block Devices
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 块设备
- en: Hard disks are usually accessed using a block device node (sometimes called
    a *cooked* device node). When accessing a device as a block, data transmitted
    to or from the device is *buffered*, or collected until there is sufficient data
    to make accessing the device worth the trouble. Block devices are generally considered
    more efficient than raw devices.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘通常使用块设备节点（有时称为*熟*设备节点）进行访问。当以块的形式访问设备时，传输到或从设备的数据会被*缓冲*，或者收集到足够的数据，使得访问设备变得值得麻烦。块设备通常被认为比原始设备更高效。
- en: The device nodes for block devices are named after the device driver; for example,
    */dev/wd3*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 块设备的设备节点以设备驱动程序命名；例如，*/dev/wd3*。
- en: Raw Devices
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原始设备
- en: Raw devices are sometimes called *character* devices, because they access a
    device one character at a time. If you need to control exactly how data appears
    on a disk (for example, when creating a filesystem) use a raw device. Raw device
    nodes have an *r* in front of their name, as in */dev/rwd3*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 原始设备有时被称为*字符*设备，因为它们一次访问一个字符。如果你需要精确控制数据在磁盘上的显示方式（例如，在创建文件系统时）使用原始设备。原始设备节点名称前有一个*r*，例如*/dev/rwd3*。
- en: Raw devices do no buffering. When you tell your system to write to a raw device,
    the data is transmitted immediately. Raw mode works best with software that provides
    its own buffering or that wants to arrange data in a specific way.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 原始设备不进行缓冲。当你告诉系统向原始设备写入数据时，数据会立即传输。原始模式最适合提供自身缓冲或希望以特定方式排列数据的软件。
- en: 'Here’s an easy way to remember the difference between block and raw throughput:
    Say you spill a bottle of aspirin. If you pick up each aspirin individually and
    deposit it directly in the bottle, you’re doing an unbuffered, or raw, transfer.
    If you pick up the aspirin with your right hand and collect them in your left,
    then dump a bunch into the bottle at once (along with all of the dirt from your
    floor), you’re doing a buffered transfer.^([[17](#ftn.id483068)])'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 记住块和原始吞吐量之间的区别有一个简单的方法：假设你洒了一瓶阿司匹林。如果你一个个地捡起阿司匹林并将其直接放入瓶中，你正在进行无缓冲的或原始的传输。如果你用右手拿起阿司匹林，用左手收集它们，然后一次性将一堆阿司匹林（连同地板上的所有灰尘）倒入瓶中，你正在进行缓冲传输.^([[17](#ftn.id483068)])
- en: Choosing Your Mode
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择您的模式
- en: Address disks (and many other devices) as raw or block by choosing the corresponding
    device node. Some programs expect to access raw devices, while others expect block
    devices. If a program opens */dev/sd1a*, it’s accessing partition *a* on disk
    *sd1* as a block device. If it opens */dev/rsd1a*, it’s accessing the exact same
    partition as a character device.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择相应的设备节点，将磁盘（以及许多其他设备）作为原始或块访问。一些程序期望访问原始设备，而另一些程序期望访问块设备。如果一个程序打开*/dev/sd1a*，它是以块设备的形式访问磁盘*sd1*上的分区*a*。如果它打开*/dev/rsd1a*，它是以字符设备的形式访问相同的分区。
- en: Regardless of the mode, the underlying hardware remains the same; the only thing
    that changes is how you exchange information with the device.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无论模式如何，底层硬件保持不变；唯一改变的是你与设备交换信息的方式。
- en: Device Attachment vs. Device Name
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备附加与设备名称对比
- en: Not long ago, most disks were permanently affixed to a single physical location
    on the system. If your computer had two IDE buses, each with two hard drives,
    the operating system knew exactly where to find them, usually at */wd1* and */wd2*.
    A SCSI disk had a SCSI ID and a logical unit number (LUN), and changing them required
    rebooting the computer. Traditionally, you could use the disk’s location in the
    system to identify the disk. For example, a booting i386 computer would find the
    root partition by looking for the hard drive attached to the first port on the
    first IDE controller, finding the *a* partition on that disk, and reading the
    filesystem table from that disk. You could go into the BIOS to tell the computer
    to look for the root partition on a different disk, but the computer still identified
    the disk by where it was physically attached to the computer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不久以前，大多数磁盘都永久固定在系统的一个物理位置上。如果你的计算机有两个IDE总线，每个总线有两个硬盘驱动器，操作系统会确切知道它们的位置，通常在*/wd1*和*/wd2*。SCSI磁盘有一个SCSI
    ID和一个逻辑单元号（LUN），更改它们需要重新启动计算机。传统上，你可以使用磁盘在系统中的位置来识别磁盘。例如，启动的i386计算机会通过查找连接到第一个IDE控制器第一个端口的硬盘来查找根分区，找到该磁盘上的*a*分区，并从该磁盘读取文件系统表。你可以进入BIOS告诉计算机在另一个磁盘上查找根分区，但计算机仍然通过它物理连接到计算机的位置来识别磁盘。
- en: Today, disks can appear and disappear from multiple locations on the system.
    For example, you might attach and remove several flash drives as needed, or hot
    swap Serial Attached SCSI (SAS) or Serial ATA (SATA) drives from bus to bus. Physical
    location is no longer a safe way to identify a disk. While */dev/sd0* is the device
    node for the first SCSI disk, you cannot assume that the disk currently attached
    to the first SCSI port is the same disk that was plugged in there the last time
    the system booted. OpenBSD labels actual disks with unique IDs, as discussed in
    the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，磁盘可以在系统的多个位置出现和消失。例如，你可能需要根据需要连接和断开几个闪存驱动器，或者从总线到总线热插拔串行连接SCSI (SAS) 或串行ATA
    (SATA) 驱动器。物理位置不再是识别磁盘的安全方式。虽然 */dev/sd0* 是第一个SCSI磁盘的设备节点，但你不能假设当前连接到第一个SCSI端口的磁盘就是上次系统启动时插入的那个磁盘。OpenBSD使用唯一ID对实际磁盘进行标记，如下一节所述。
- en: DUIDs and /etc/fstab
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DUIDs和/etc/fstab
- en: All OpenBSD platforms use the disklabel to identify partitions and other information
    about a disk. When you label a disk (as we did in [Chapter 3](ch03.html "Chapter 3. Installation
    Walk-Through") and will do by hand later this chapter), `disklabel` adds a *disklabel
    unique identifier*, or DUID, to the disk label. The DUID is a unique hexadecimal
    number that lets OpenBSD identify a specific disk.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有OpenBSD平台都使用disklabel来识别分区和其他有关磁盘的信息。当你标记一个磁盘（如我们在[第3章](ch03.html "第3章。安装指南")中所述，并在本章稍后手动进行），`disklabel`会将一个*disklabel唯一标识符*，或DUID，添加到磁盘标签中。DUID是一个唯一的十六进制数字，允许OpenBSD识别特定的磁盘。
- en: 'To find a disk’s DUID, pass the device name to `disklabel` and look for the
    `duid` entry:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找磁盘的DUID，将设备名传递给`disklabel`并查找`duid`条目：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The disk currently attached as `sd0` has a DUID of `55128c3700af5491`. Even
    if you physically move the disk so that it becomes `sd9` or `sd18`, OpenBSD can
    use the DUID to uniquely identify this disk.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当前连接为`sd0`的磁盘的DUID为`55128c3700af5491`。即使你物理移动磁盘，使其变为`sd9`或`sd18`，OpenBSD也可以使用DUID来唯一识别此磁盘。
- en: 'OpenBSD uses the filesystem table */etc/fstab* to map filesystems on a disk
    to mount points using either the disk location or the DUID. Each filesystem appears
    on its own line in */etc/fstab*, as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD使用文件系统表 */etc/fstab* 来将磁盘上的文件系统映射到挂载点，使用磁盘位置或DUID。每个文件系统都在 */etc/fstab*
    的单独一行上显示，如下所示：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ll focus on the first entry to explore what’s going on here. The first field,
    `55128c3700af5491.b` **1**, is the location of the partition. Whereas older systems
    used the disk device name and the partition letter (such as */dev/sd0a*), newer
    systems can use the DUID, a period, and the partition letter (as in `55128c3700af5491.a`).
    By using DUIDs in the filesystem table, OpenBSD can always mount the same disk
    at the same location, no matter how it’s attached.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注第一条目来探索这里发生的事情。第一个字段，`55128c3700af5491.b` **1**，是分区的位置。而较老的系统使用磁盘设备名和分区字母（例如*/dev/sd0a*），较新的系统可以使用DUID、一个点号和分区字母（如`55128c3700af5491.a`）。通过在文件系统表中使用DUID，OpenBSD可以始终在相同的位置挂载相同的磁盘，无论其如何连接。
- en: The second field, `none` **2**, lists the *mount point*, which is the directory
    where the filesystem is attached to the directory tree. Every partition you can
    write files to is attached to a mount point (such as */usr*, */var*, and so on),
    with one partition being the root partition (*/*). Swap space uses a mount point
    of `none`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Next, `swap` **3**, is the filesystem type. The standard OpenBSD partition uses
    type `ffs`, the UNIX Fast File System. Other options include, but are not limited
    to, `msdos` (Microsoft-style FAT partitions), `mfs` (Memory File System), and
    `cd9660` (CD).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth field, `sw` **4**, shows the mount options used for this filesystem.
    I’ll cover mount options in more detail in [FFS Mount Options](ch08.html#ffs_mount_options
    "FFS Mount Options"), but here are a few that frequently appear in */etc/fstab*:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '****`ro`****. The filesystem is mounted read-only. Not even root can write
    to it.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`rw`****. The filesystem is mounted read-write.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`nodev`****. Device nodes are not interpreted.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`nosuid`****. `setuid` files are forbidden.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`noauto`****. OpenBSD won’t automatically mount the filesystem at boot
    or when running `mount -a`. This option is useful for removable media drives that
    might not have media in them, such as CD and USB flash drives.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth field indicates whether `dump(8)` should back up this filesystem.
    If this field is 0 (or absent), `dump` doesn’t routinely back up the filesystem.
    Otherwise, the number given is the minimum dump level needed to back up the filesystem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The last field is the *pass number.* It tells `fsck` when to check the filesystem
    during boot. Filesystems with a pass number of 1 are checked first, filesystems
    with a pass number of 2 are checked second, and so on. A pass number of 0 tells
    `fsck` to not check the filesystem during boot. If a filesystem doesn’t have a
    pass number, it’s equivalent to 0.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: I strongly recommend using DUIDs in */etc/fstab* and anywhere else, rather than
    using device node names. While a device node name might change, a DUID will not.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: MBR Partitions and fdisk(8)
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some hardware platforms have specific ideas about disk partitioning that differ
    from what OpenBSD expects. For example, the i386 and amd64 platforms expect to
    find MBR partitions on hard drives, and OpenBSD accommodates this quirk by putting
    its own disklabel partitions inside MBR partitions. We briefly touched on creating
    partitions during the installation process, but if you add hard drives to an existing
    system, you’ll need to edit the MBR partition table by hand using `fdisk(8)`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'My particular test system has two hard drives: *wd0* and *wd1*. I think that
    *wd1* is completely blank but before I can use this drive, I need to verify that
    it is empty, and then create MBR partitions. While `fdisk` has all sorts of commands
    to edit disks, I find the simplest way is to use the interactive disk editor.
    Run `fdisk -e` and give it the device node for the new disk.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The editor is minimal, but lets you view, add, remove, and edit MBR partitions.
    If you forget the commands at any time, entering `help` will print out all the
    commands `fdisk` supports.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Viewing MBR Partitions
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To see the MBR partitions on the current disk, enter **`print`** or **`p`**.
    Here’s an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line shows the disk geometry (as discussed in [Chapter 2](ch02.html
    "Chapter 2. Installation Preparations")). Every value in this disk’s MBR table
    is set to 0, meaning that it has no configured partitions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Adding and Removing Partitions
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Say we want to create an MBR partition on this disk. I habitually use partition
    0, but the OpenBSD installer usually uses partition 3\. The specific number you
    pick doesn’t matter unless you want multiple MBR partitions on the disk.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'To edit a partition, enter **`edit`** or **`e`** followed by the partition
    number. For example, to edit partition 0, enter the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Warning
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conveniently, *`fdisk`* prints the current information on this MBR partition.
    Make sure it’s the partition you think it is before you muck it up.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: First, at **1**, set a partition ID. This is a label indicating what kind of
    filesystem will be on the disk. OpenBSD uses partition ID `a6`, so enter that.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The offset at **2** is the number of sectors from the beginning of the disk
    to the start of the partition. We want to use this entire disk for OpenBSD, so
    set it to `0`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the size at **3** is the number of sectors the MBR partition fills.
    There is no need to copy the number of sectors in the disk here; OpenBSD `fdisk`
    uses `*` to mean “all free space.”
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Now print the MBR table again to check your work.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the entry for partition 0 is type A6 and extends from cylinder 0,
    head 0, sector 1, to cylinder 2088, head 167, sector 63\. It fills 33,554,304
    sectors—the same as the number of sectors in the disk. This MBR partition fills
    the entire disk.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: If you had recycled this disk from another operating system, it would probably
    have a partition already on it. To remove a partition, edit the partition and
    set its partition ID to 0.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Making a Partition Bootable
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to boot from a hard drive, you’ll need to mark a partition as active.
    Use the `flag` command and a partition number to do this.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Include this hard drive in your BIOS boot order, and the computer should try
    to boot from it. Simply marking a partition as active doesn’t mean that the computer
    *can* boot from it; however, you will still need a kernel, boot loader, and all
    the other things that go into bootstrapping a computer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: To mark a partition as no longer active, delete and re-create it. (There is
    no `unflag` command.)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Exiting fdisk
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’re satisfied with your work, enter **`quit`** or **`q`**, and `fdisk`
    should write the new MBR table to disk and exit. If you changed your mind, and
    don’t want to make any changes, enter **`abort`** or **`exit`**, and `fdisk` should
    exit without saving changes to the MBR partition table.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Labeling Disks
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenBSD uses `disklabel` to set up partitions on all hardware platforms. We
    used `disklabel(8)` as part of the installation process, but you need to partition
    new disks before you can use them. (You can also use `disklabel` to back up, restore,
    and duplicate partition tables.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Viewing Labels
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To view the current disklabel, just give the disk name as an argument. Here’s
    how to see the disklabel of the empty disk from the previous section:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This looks much like the disklabel we saw in [Chapter 2](ch02.html "Chapter 2. Installation
    Preparations"), with a few critical differences.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: First, note the device at **1**. The `disklabel` command accesses the raw device,
    but you should use the block device at the command line.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: This label at **2** has no DUID. This is the default empty disklabel. We will
    generate a DUID later.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: At **3**, we see that this disk has only one partition, *c*, which represents
    the entire disk. You could create and use a filesystem on partition *c*, but it’s
    not standard practice to do so.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Creating Disklabel Partitions
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest way to create partitions is to use the same interactive disklabel
    editor that we used to install OpenBSD. Give the disklabel editor the `-E` flag
    and the disk name:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now you can add, remove, and edit partitions, just as in [Chapter 3](ch03.html
    "Chapter 3. Installation Walk-Through").
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the rest of the book, we’ll edit disklabels as needed to change partition
    and filesystem characteristics.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Backing Up and Restoring Disklabels
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before messing with a disk, back up its disklabel so that you can fall back
    to the old label if you screw up. You can back up the disklabel with this command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To apply a saved disklabel to a disk, give `disklabel` the `-R` flag, the disk
    device, and the label file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This writes the saved label to the disk. You can use saved disklabels to duplicate
    partitioning across identical disks.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have partitions, let’s put a filesystem on them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The Fast File System
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenBSD’s filesystem, FFS, is an improved version of the filesystem shipped
    with BSD 4.4\. FFS is sometimes called UFS (for Unix File System), and many system
    utilities still use UFS.^([[18](#ftn.id416360)])
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: FFS is designed to be fast, reliable, and able to handle the most common situations
    effectively while still supporting weird configurations. By default, OpenBSD tunes
    FFS for general use, but you can optimize it to fit your needs—whether you need
    to hold trillions of tiny files or a half dozen 30GB files. You don’t need to
    know much about FFS internals, but you should at least understand blocks, fragments,
    and inodes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: FFS Versions
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The original FFS was written in the 1980s and included hard-coded limits that
    were ample for the day. Filesystems could have up to 231-1 blocks, or just under
    a terabyte (TB). In 1983, a 1TB filesystem was unthinkable. In 2013, 1TB drives
    are cheap.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: For larger file systems, we have FFS version 2\. FFS2 can support filesystems
    up to 8 zettabytes—unthinkable by 2013 standards. (FFS2 is likely to reach other
    limits before hitting the filesystem size limit, mind you.) OpenBSD supports both
    FFS and FFS2.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The i386 and amd64 boot floppies support only FFS, not FFS2\. The installation
    CD, however, supports both. Most machines that need to boot from floppy don’t
    need FFS2, and probably don’t have a BIOS that can support 2TB drives anyway.
    The filesystem creation program `newfs(1)` is smart enough to use FFS2 on filesystems
    large enough to need it, so for most installations, you don’t need to worry about
    the difference between FFS and FFS2.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the exceedingly unlikely event that you actually require FFS2 on a machine
    that must be installed via floppy, be sure to format the critical system partitions
    of root (`/`), `/var`, and `/usr` as FFS, not FFS2\. Use FFS2 only for partitions
    that are not critical to the system. Otherwise, you won’t be able to use the installation
    disk for upgrades or emergency repairs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Blocks, Fragments, and Inodes
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both FFS and FFS2 are managed through blocks, fragments, and inodes. This arrangement
    isn’t unique to FFS and FFS2; filesystems such as NTFS use data blocks and index
    nodes, too. The indexing system used by each filesystem is largely unique, however.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Blocks
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Blocks* are sections of disk that contain data. Files are placed in one or
    more blocks. OpenBSD’s FFS uses a default block size of 16KB, or eight times the
    fragment size, whichever is smaller. Not all files are even multiples of 16KB,
    so leftover bits go in *fragments*. A fragment is one-eighth of the block size,
    or 2KB by default. A 20KB file fills one block and two fragments.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Inodes
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Inodes*, or index nodes, contain basic data about files, such as the file’s
    size, permissions, and the list of blocks that contain the file. Collectively,
    the data in an inode is known as *metadata*, or data about data.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Superblocks
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll also see references to *superblocks*, which are blocks that contain vital
    information about the filesystem’s size and specifications. Superblocks are so
    important that FFS makes many backup copies of them. If you need to meddle with
    superblocks, you’ve probably done something wrong or your filesystem is FUBAR.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Creating FFS Filesystems
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use `newfs(8)` to create FFS and FFS2 filesystems and make sure that the disk
    has a disklabel. The `newfs` command takes one argument: the partition device
    node.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You’ll see details about the filesystem size, how many blocks it includes, and
    so on. The location of each superblock backup is printed as `newfs` proceeds.
    (When computers and disks were much slower, this told the operator that the computer
    was actually doing something and hadn’t seized up.)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The partition size determines which filesystem `newfs` uses. Partitions smaller
    than 1TB are formatted with FFS; larger partitions with FFS2\. If you want to
    specify a particular filesystem format (yes, you can even specify the old-fashioned
    4.3BSD format if you like), use the `-O` flag. It makes no sense to demand an
    FFS filesystem on a large partition, but you might have a reason to use FFS2 on
    a small partition.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you think you need to specify which filesystem format to use on a new filesystem,
    you’re probably wrong.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: FFS Mount Options
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenBSD can handle FFS partitions in several special ways, controlling what
    sorts of changes the filesystem supports and what sorts of files may exist. These
    are called *mount options*. You can specify mount options either when you mount
    partitions on the command line, as we’ll discuss in [Mounting and Unmounting Partitions](ch08.html#mounting_and_unmounting_partitions
    "Mounting and Unmounting Partitions"), or in */etc/fstab*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Mount Options and /etc/fstab
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Specify a filesystem’s mount options in a comma-separated list in the fourth
    field of the filesystem’s */etc/fstab* entry. For example, here’s an */etc/fstab*
    entry for the partition that contains my */home* directory:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I’ve specified the options `rw` (read-write), `nodev` (device nodes forbidden),
    `nosuid` (`setuid` programs forbidden), and `softdep` (soft updates). I’ll cover
    these and other common mount options, and explain why you might want to use them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Read-Only Mounts
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you only want to read the contents of a partition, and never write to it,
    you can mount the partition as *read-only*. In most cases, this is the safest
    way to mount a disk because you cannot alter the data on the disk or write any
    new data. If a filesystem should never change, mounting it read-only might make
    sense.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Read-only mounts are especially valuable when a particular filesystem is damaged.
    While OpenBSD won’t let you perform a standard read-write mount on a damaged or
    dirty filesystem, it can often mount those filesystems read-only. This gives you
    a chance to recover some data from the partition. (Not a large chance, but a chance.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: To mount a filesystem read-only, use the option `rdonly` or `ro`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Read-Write Mounts
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want to both read from and write to the disk, you’ll want to mount the
    partition as *read-write*. By default, OpenBSD mounts all partitions as read-write.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Use the option `rw` to explicitly configure read-write mounts.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: On modern hardware, I recommend using soft updates in conjunction with read-write
    mounts.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous Mounts
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using a synchronous mount is the safest way to mount a filesystem. OpenBSD can
    read data from a synchronous-mounted partition as fast as the hardware permits.
    Whenever you write to the disk, however, the kernel feeds a chunk of data to the
    disk, waits to receive confirmation that the disk has accepted the data and written
    it to disk, and then tells the program that requested the write that the data
    is now on disk.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'You should know that even if you’re using a synchronous mount, most hard drives
    lie about whether they have actually written the data to disk. These drives perform
    *write caching*, where writes are cached in a small flash or RAM buffer on the
    disk itself before the drive actually writes the data. This raises the question:
    Is a synchronous mount really synchronous? Hard drive vendors usually claim that
    in the event of a power failure, these disks retain just enough power to write
    the cache to disk.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Although they provide the greatest data integrity in the case of a crash, synchronous
    mounts are slow. You might use synchronous mounts when data integrity is crucial,
    but in most cases, it’s overkill and you have little ability to verify that the
    mount is truly synchronous.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Activate synchronous mounts with the `sync` keyword.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous Mounts
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To write data quickly, but with a higher risk of data loss, mount partitions
    asynchronously. When using asynchronous mounts, the kernel informs software that
    all disk writes are successful before the disk confirms that the data was written.
    This is fast, but a system failure can leave inconsistent data on your disk.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous mounts are useful when restoring a filesystem from backup, because
    if you get a power failure halfway through the restore procedure, you’ll need
    to start over anyway. Don’t use asynchronous mounts in production if you care
    about your data or would object to re-creating the filesystem.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Activate asynchronous mounts with the `async` keyword.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Soft Update Mounts
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Soft update mounts organize and arrange disk writes so that filesystem metadata
    remains consistent at all times. This gives performance similar to that of an
    asynchronous mount with the reliability of a synchronous mount. While that doesn’t
    mean that all data will be written to disk—a power failure at the wrong moment
    will result in lost data—using soft updates prevents a lot of filesystem integrity
    problems caused by that lost data. It’s not the default because some older, smaller
    hardware doesn’t have enough memory to support it, but if you’re using modern
    i386 and amd64 hardware, I recommend enabling soft updates for all FFS partitions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: To mount a filesystem with soft updates, use the `softdep` option.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: “Don’t Track Access Time” Mounts
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: FFS records the last time a file was read, executed, or otherwise viewed. Updating
    these access times consumes a small but measurable amount of disk I/O and performance.
    You can use the `noatime` mount option to tell OpenBSD to not update the access
    time on any file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Using `noatime` makes sense on laptops, where minimizing power usage is critical.
    If you’re tempted to use this option on your server to squeeze out a little extra
    performance, you should buy a faster disk instead. Some software, such as the
    Mutt mail client, will break if run on filesystems mounted `noatime`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: No Device Nodes Permitted Mount
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By using the `nodev` mount option, you can tell OpenBSD to not interpret any
    device nodes on any given filesystem. Intruders can try to create “rogue” device
    nodes and use them to write files or attack the network, but if the kernel won’t
    recognize those device nodes, it cuts off this whole category of attacks.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: This type of mount is also useful if you have hard drives from multiple operating
    systems on your computer. For example, if you dual-boot OpenBSD and Linux on your
    computer, but you don’t want to accidentally access a Linux device node when using
    OpenBSD, the `nodev` option will prevent you from doing so. (You might think you
    would notice that you had typed */linux/dev/hda* rather than */dev/wd1*, but never
    underestimate your ability to screw up.) In most cases, the partition containing
    */dev* is the only one that should contain device nodes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Execution Forbidden Mounts
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `noexec` mount option prevents any binaries on the partition from being
    executed. Mounting */home* with the `noexec` option helps prevent users from installing
    and running their own programs, but for it to be effective, you’ll need to make
    sure users can’t install binaries in any shared areas, such as */tmp* and */var/tmp*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Note that forbidding execution of binaries doesn’t prevent users from running
    interpreted scripts from that partition. Maybe the users can’t run a compiled
    C program, but if they can run `perl $HOME/rootkit.pl`, then `noexec` won’t slow
    them down very much.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: setuid Forbidden
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `nosuid` option disallows `setuid` behavior from programs on this filesystem.
    Many partitions should not have `setuid` files, and setting this is an easy way
    to disrupt them. OpenBSD sets this on partitions such as */home* and */tmp* by
    default. You must carefully place this option on all user-writable filesystems
    for it to prevent undesired behavior.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Do Not Automatically Mount This Filesystem
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`noauto` isn’t actually a mount option, but rather a way of telling OpenBSD
    to not mount a given partition listed in */etc/fstab* at boot. I frequently make
    */etc/fstab* entries for removable media drives, but the system should not try
    to mount these at boot. The boot will hang if a partition required by */etc/fstab*
    is not available, and I don’t want my computer to refuse to boot just because
    I unplugged a flash drive.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem Integrity
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both versions of FFS go to a great deal of trouble to ensure that the data on
    disk is correct and intact. The blocks that contain a file should be recorded
    in an inode, the inodes should all be referenced by directory entries, and so
    on. When you remove a file, all references to that file should be removed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: After a system failure, however, data might not be consistent. Metadata might
    reference blocks that were previously erased; a file might be in a different location
    than the inode record specifies; and the filesystem might have all kinds of references
    pointing to things that have moved, changed, or disappeared. These inconsistent,
    or *dirty*, filesystems cannot be trusted and must be rationalized, or *cleaned*,
    before you can mount them read-write. If you mount a dirty filesystem read-only,
    it might only panic your system, but if you force OpenBSD to mount a dirty filesystem
    read-write, you will damage the dirty filesystem even more.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: At boot, OpenBSD performs a minimal inspection and cleaning, or *preening*,
    of the filesystems and will automatically correct any minor problems found. If
    preening cannot fully clean the filesystem, the boot will hang until you intervene.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'When confronted with a dirty filesystem, you have a few options: use the filesystem
    checking tool `fsck(8)`, debug the filesystem with `fsdb(8)` and `clri(8)`, or
    throw the filesystem away and run `newfs(8)`. Most of the time, you’ll attempt
    to repair the filesystem with `fsck`. Using `fsdb` successfully requires more
    knowledge about FFS innards than I possess, so I recommend it to only those who
    really want to develop an in-depth knowledge of FFS and have a whole bunch of
    time to devote to it. Rebuilding the filesystem with `newfs` destroys everything
    on the filesystem, but it’s a decent choice for partitions that contain only ephemeral
    data, such as */usr/obj*.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: You can use `dump(8)` to copy the damaged filesystem before trying any of the
    repairs. This gives you the option to fall back to the current state if attempts
    at repairing the disk fail. (If you have to do this, though, you should probably
    reevaluate your backup strategy.)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Running fsck
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you try to mount a dirty filesystem either at boot time or during routine
    operation, you’ll see a message that looks like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `fsck(8)` program is a frontend for several filesystem-specific integrity-checking
    programs. When you run it, `fsck` identifies the type of filesystem and calls
    the correct integrity checker for you. Run `fsck` by giving it the device name
    of the filesystem you want to check:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can use either the raw or cooked device name; `fsck` is smart enough to
    use the raw node even if you give the cooked device name.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Examining the filesystem can take quite a while, so be patient.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'When run on a dirty filesystem, `fsck` will probably find a number of problems:
    blocks that have become disassociated from their inodes, inodes that reference
    empty blocks, and so on. It can often make a good guess as to how everything fits
    together.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: When `fsck` finds a problem that it isn’t absolutely sure about, it will suggest
    a fix and ask if you want to make the change. If you answer `y`, `fsck` makes
    the change. If you answer `n`, `fsck` leaves the filesystem unchanged. If you
    tell `fsck` not to make the change it suggests, the filesystem will still be dirty,
    and you’ll need to fire up `fsdb` or `clri` and make the change you think more
    appropriate.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, `fsck` can’t identify the name or directory of a file recovered from
    a damaged filesystem. These files go into the partition’s *lost+found* directory
    (for example, */usr/lost+found*). You’ll need to use programs such as `grep` and
    `strings` to try to identify these files by their contents.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Blindly Trusting fsck
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Those of us who lack the skills to debug a filesystem find ourselves in a difficult
    situation, where we can either accept that `fsck(8)` knows what’s best or just
    restore from backup. If your filesystem was performing a lot of disk I/O just
    before system failure, `fsck` might need to make dozens or hundreds of changes.
    You could spend an hour sitting at the console pressing `y` repeatedly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to trust `fsck` and hope it’s right, run `fsck -y`. This means
    “answer `y` to every question.” You might wind up with the entire contents of
    the filesystem in the *lost+found* directory, or you might lose every file on
    the filesystem. But unless you’re intimately familiar with the innards of FFS,
    you would need to restore from backup anyway.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: If you run `fsck` and realize partway through that you would like to answer
    `y` to all the questions that follow, enter `F`. That tells `fsck` to answer `y`
    to all remaining questions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the procedure, you’ve either recovered your system or need to
    restore from backup.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: What’s Currently Mounted?
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While performing routine work, inevitably you’ll need to check which disks
    are currently mounted and which are not. To see a list of all mounted filesystems
    and their mount options, run `mount(8)` without any options:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Both FFS and FFS2 partitions show up as `type ffs`. The word `local` means that
    the partition is on a physical drive attached to this machine. We covered the
    various mount options (`nodev`, `nosuid`, and so on) earlier in this chapter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Note that `mount` displays the device node mounted at each partition, not the
    DUID. If you want to see the DUID of a disk, check the disklabel.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Mounting and Unmounting Partitions
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To attach filesystems to your directory tree, or *mount* them, use `mount(8)`.
    If you’ve never manually mounted filesystems before, boot your OpenBSD machine
    into single-user mode (see [Chapter 5](ch05.html "Chapter 5. The Boot Process"))
    and follow along.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'In single-user mode, OpenBSD mounts only one partition: the root partition,
    which it mounts read-only. The root partition contains just enough of the system
    to perform basic setup, establish core services, and find the other filesystems.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Because filesystems other than the root are not mounted, their content is not
    accessible. Look in, say, */usr* on a system in single-user mode, and you’ll find
    that it’s empty. OpenBSD hasn’t lost the files; it just hasn’t mounted the partition
    containing those files.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: To get any real work done in single-user mode, you probably need to mount other
    filesystems.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Mounting Standard Filesystems
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To manually mount a single filesystem listed in */etc/fstab*, give `mount(8)`
    the name of the filesystem you want to mount. Here, we’ll mount our */usr* partition:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This mounts the partition exactly as described in */etc/fstab*, with all the
    options specified therein.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'To mount all of the partitions listed in */etc/fstab*, give `mount` the `-a`
    flag:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All of your filesystems (except those not listed in */etc/fstab* and those with
    the `noauto` option) should now be mounted.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Mounting at Nonstandard Locations
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perhaps you must mount a filesystem at a location not specified in */etc/fstab*.
    I do this most commonly when adding a disk to a machine. To mount a partition
    at a location other than that specified in */etc/fstab*, or to mount a partition
    without an */etc/fstab* entry, give the partition device name and the mount point.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You must use the full path for the device node, not just the brief device node
    name.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the path to the device node, you could use the DUID, a period, and
    the partition letter, but on the command line, that’s more painful than using
    the path to the device node.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Unmounting Partitions
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To disconnect a filesystem from the directory tree, use `umount(8)` on a mount
    point. (Note that there is only one `n` in this command.) Here, we’ll use `umount`
    to unmount our */usr* partition:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You cannot unmount filesystems that are in use by any program. Even a command
    prompt in the mounted directory will prevent you from unmounting the partition.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'To unmount all partitions except the root partition, pass `umount` the `-a`
    flag:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As programs almost certainly have files open on every partition, this probably
    works only in single-user mode. Note that you don’t need to unmount all partitions
    to leave single-user mode.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Mounting with Options
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose you pull a disk from a decommissioned OpenBSD machine and you need to
    retrieve some files from it. You want to mount the disk read-only so that you
    don’t change any of the files on the disk. To manually mount a partition with
    options not specified in */etc/fstab*, use the `-o` flag.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the disk shows up as */dev/sd0* and you want to mount partition
    *a*, run this command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To prevent old software from running on your newer system, it might be a good
    idea to use some of the options we covered earlier, such as `noexec`, `nodev`,
    and `nosuid`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: How Full Is That Partition?
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get an idea how much free space remains on your partitions, use `df(1)`.
    This program displays the total number of filesystem blocks on each partition,
    how many blocks are in use, and how many blocks are free. It also gives you the
    percent in use.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'One annoying thing about `df` is that it offers this information in 512-byte
    blocks by default. This was fine when disks were much smaller, but today, it’s
    like measuring the distance of an airplane flight in yards. Some people have done
    this for so long that they automatically perform block transformations in the
    back of their mind.^([[19](#ftn.id425288)]) For the rest of us, the `-h` flag
    tells `df` to provide human-readable output, such as megabytes or gigabytes, giving
    us something like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You might wonder why the */home* partition in this example has negative free
    space. How is that possible? By default, FFS reserves 5 percent of each partition
    for moving files and reducing fragmentation. When you exceed 100 percent disk
    utilization, you begin tapping into this reserved space.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: FFS performance degrades quickly when the partition is overfull. It’s best to
    keep some free space on your disk so that FFS can defragment itself.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: You can reduce the amount of space FFS reserves, but doing so will impact performance.
    See `tunefs(8)` for instructions on how to shoot yourself in the foot.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: What’s All That Stuff?
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you see a partition is full, the obvious question is “What’s filling up
    my disk?” Every hard drive I’ve ever owned has gradually filled up for no apparent
    reason. You can identify individual large files with `ls -l`, but recursively
    examining every directory in the filesystem is impractical and tedious (not to
    mention annoying).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: To check the number of filesystem blocks used within each directory below the
    current directory, use `du(1)`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When I run `du` in my home directory, I get 700 entries; of those, 563 are related
    to some Mozilla tool. This kind of list intimidates the new sysadmin and makes
    the experienced sysadmin work too hard. Rather than cull through this list manually,
    tell `du` to show only the total for directories in the current directory, and
    then sort the output so that the largest directories appear first.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: I now know why my */home* partition is full.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: You can tell `du` to display human-readable values with the `-h` flag, but doing
    so will show values in a mix of gigabytes, megabytes, and kilobytes, making `sort`
    far less useful.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Setting $BLOCKSIZE
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many disk tools—including, but not limited to, `du(1)` and `df(1)`—display information
    in 512-byte blocks. If you’re accustomed to working in blocks, you probably won’t
    mind seeing them. If you’re not used to working in blocks, however, they’ll probably
    make you want to tear out your hair.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The environment variable `BLOCKSIZE` tells these programs to display information
    using blocks of a different size. If you set `BLOCKSIZE` to `K`, `df` and `du`
    will display totals in kilobytes. If you set it to `M`, these tools will show
    megabytes instead. Check your shell manual page or the dotfiles in your home directory
    for examples of setting environment variables.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Adding New Hard Disks
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OpenBSD installer walks you through formatting and partitioning your initial
    hard disks. If you need to add a disk to an existing system, however, you must
    run these commands yourself. The good news is that if you can install OpenBSD,
    you already know how to use the commands, and the only hard part is learning which
    commands to run.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: I’ll show you how to move */home* to a new disk as an example. You could create
    a new partition on your existing disk if you have some empty space, but that would
    eliminate the need for this example, so I’m going to pretend I never gave you
    that advice. (Also, moving partitions to a separate disk controller channel will
    improve performance.)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before touching anything involving disk partitioning or filesystems, back up
    your system. Verify that backup before starting. You have been warned.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Creating an MBR Partition
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The i386 and amd64 platforms require disks to have MBR partitions as well as
    OpenBSD partitions. A standard new disk needs a single OpenBSD MBR partition covering
    the entire disk. Passing the `-i` argument to `fdisk` does exactly this. Let’s
    create a new MBR partition on `wd1`, our new disk:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once you have an MBR partition on your disk, you can create disklabel partitions.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Disklabel
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All OpenBSD platforms use disklabel partitions. To activate the same disklabel
    editor we used during the install process, give `disklabel` the `-E` flag and
    the disk name:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This should look familiar from earlier in this chapter. Use the interactive
    disklabel editor to create your new partitions. For a single */home* directory,
    we’ll use one large partition, *wd1a*. The new label should look like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When you’ve finished editing partitions, check your work by printing the disklabel.
    This should also give you the DUID of the new disk.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re satisfied with the partitioning, use `newfs` to create a filesystem
    on the new partition:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You’re now ready to add the filesystem to your computer.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Moving Partitions
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Moving data from one disk to another is slightly more complex than adding new
    partitions. You must first mount the new drive in a temporary location, copy files
    to that location, remove them from the old location, and mount the new drive in
    its previous home.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Our new */home* filesystem is on disk partition *wd1a*. The default “temporary
    mount” location is */mnt*, so mount it there. This is strictly temporary, so there’s
    no need to mount it via the DUID or make an */etc/fstab* entry for this.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can then use `tar(1)`, `cpio(1)`, or `dump(8)` and `restore(8)` to copy
    the files to the temporary location. Here, we copy everything in */home* to */mnt*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You could also use `cp(1)` or `mv(1)` for this, but these commands don’t guarantee
    that file permissions and ownership will copy intact. OpenBSD’s versions of these
    programs have never given me errors when I copy or move files, but I’ve learned
    from other Unix-like operating systems that `tar` and `cpio` are both more reliable
    when moving entire file hierarchies. If you’re using file flags for security (see
    [Chapter 10](ch10.html "Chapter 10. Securing Your System")), you must use `dump(8)`
    and `restore(8)` to retain those flags.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Using `tar` or `cpio` does not delete files from their original location. This
    means that if a user changes files in his home directory after you copy them but
    before you change the mount point, he will lose his changes as you shuffle disks
    around.^([[20](#ftn.id369420)])
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Now update */etc/fstab* to reflect your new disk.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Adding New Filesystems
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at the disklabel for the new disk and get the disk’s DUID. This new disk
    has a DUID of `fea9194ee78362d8`. Use the DUID and the partition letter to make
    an */etc/fstab* entry for your new partitions.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You might want to keep the old partition available at a new location, such as
    */oldhome*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not sure about the mount options to use for your new partitions, the
    options `nodev`, `nosuid`, and `softdep` are generally safe. You probably want
    the partition mounted read-write (`rw`) as well.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Now unmount the old and mount the new.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When you unmount a partition, `umount` doesn’t check */etc/fstab*. You tell
    it to unmount a partition, and it unmounts that partition.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Stackable Mounts
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenBSD filesystems are *stackable*, which means that you can mount one partition
    over another. The partition on top hides any files in the filesystem below.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Look at your system in single-user mode. By default, only the root partition
    is mounted. You can go look in the */home* directory, and it will be empty. There’s
    no reason you can’t put files in the */home* directory, even when */home* isn’t
    mounted. Suppose you copy a couple of core files into */home* while in single-user
    mode, and then go into multiuser mode. All the usual partitions are mounted. If
    you then look in */home*, you won’t find your core files.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: What happened? Where did those files go?
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The files are in the directory */home*, but on the root partition. The */home*
    partition is mounted above that directory, so the */home* partition obscures the
    files in the */home* directory on the root partition. To access those hidden files,
    you must unmount the */home* partition. Those hidden files continue to take up
    space on the root partition, however.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: This happens more commonly when splitting a partition. For example, if you find
    that your */var* partition is too small, you might move */var/www* into its own
    partition on a separate disk. To free up space on the original */var*, delete
    the files you copied to */var/www*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况在分区分割时更为常见。例如，如果你发现你的 */var* 分区太小，你可能会将 */var/www* 移动到单独磁盘上的自己的分区中。为了在原始的
    */var* 上释放空间，删除你复制到 */var/www* 的文件。
- en: With the basics of filesystem management under your belt, you’re now ready to
    look at some of OpenBSD’s more interesting filesystem tricks.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握文件系统管理的基本知识后，你现在可以开始了解一些 OpenBSD 更有趣的文件系统技巧。
- en: '* * *'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[17](#id483068)]) If it’s buffered aspirin, then you’re doing buffered buffered
    aspirin transfers. But let’s not go there.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[17](#id483068)]) 如果是缓释型阿司匹林，那么你正在进行缓释型缓释阿司匹林转移。但让我们不要深入那个话题。
- en: ^([[18](#id416360)]) OpenBSD is not the only operating system that still uses
    the BSD 4.4 filesystem or a descendant thereof. If a Unix vendor doesn’t specifically
    tout its “improved and advanced” filesystem, it’s almost certainly running a derivative
    of FFS.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[18](#id416360)]) OpenBSD 并不是唯一仍然使用 BSD 4.4 文件系统或其衍生版本的操作系统。如果一个 Unix 供应商没有特别吹嘘其“改进和先进的”文件系统，那么它几乎肯定运行的是
    FFS 的衍生版本。
- en: ^([[19](#id425288)]) Hi, Henning!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[19](#id425288)]) 嗨，Henning！
- en: ^([[20](#id369420)]) Presumably you warn your users before doing maintenance.
    Or at least *during* maintenance. Or … maybe afterward.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[20](#id369420)]) 假设你在进行维护之前会警告你的用户。或者至少在维护期间。或者……也许是在之后。
