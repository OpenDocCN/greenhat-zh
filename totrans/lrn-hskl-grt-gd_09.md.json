["```\nI'm a lil' teapot\nWhat's with that airplane food, huh?\nIt's so small, tasteless\n```", "```\nimport Control.Monad\nimport Data.Char\n\nmain = forever $ do\n    l <- getLine\n    putStrLn $ map toUpper l\n```", "```\n$ ghc --make capslocker\n[1 of 1] Compiling Main             ( capslocker.hs, capslocker.o )\nLinking capslocker ...\n$ ./capslocker < haiku.txt\nI'M A LIL' TEAPOT\nWHAT'S WITH THAT AIRPLANE FOOD, HUH?\nIT'S SO SMALL, TASTELESS\ncapslocker <stdin>: hGetLine: end of file\n```", "```\nimport Data.Char\n\nmain = do\n    contents <- getContents\n    putStr $ map toUpper contents\n```", "```\n$ ./capslocker < haiku.txt\nI'M A LIL' TEAPOT\nWHAT'S WITH THAT AIRPLANE FOOD, HUH?\nIT'S SO SMALL, TASTELESS\n```", "```\n$ ./capslocker\nhey ho\nHEY HO\nlets go\nLETS GO\n```", "```\nmain = do\n    contents <- getContents\n    putStr (shortLinesOnly contents)\n\nshortLinesOnly :: String -> String\nshortLinesOnly = unlines . filter (\\line -> length line < 10) . lines\n```", "```\ni'm short\nso am i\ni am a loooooooooong line!!!\nyeah i'm long so what hahahaha!!!!!!\nshort line\nloooooooooooooooooooooooooooong\nshort\n```", "```\n$ ghc --make shortlinesonly\n[1 of 1] Compiling Main             ( shortlinesonly.hs, shortlinesonly.o )\nLinking shortlinesonly ...\n```", "```\n$ ./shortlinesonly < shortlines.txt\ni'm short\nso am i\nshort\n```", "```\nmain = interact shortLinesOnly\n\nshortLinesOnly :: String -> String\nshortLinesOnly = unlines . filter (\\line -> length line < 10) . lines\n```", "```\nrespondPalindromes :: String -> String\nrespondPalindromes =\n    unlines .\n    map (\\xs -> if isPal xs then \"palindrome\" else \"not a palindrome\") .\n    lines\n\nisPal :: String -> Bool\nisPal xs = xs == reverse xs\n```", "```\n\"elephant\\nABCBA\\nwhatever\"\n```", "```\n[\"elephant\", \"ABCBA\", \"whatever\"]\n```", "```\n[\"not a palindrome\", \"palindrome\", \"not a palindrome\"]\n```", "```\nmain = interact respondPalindromes\n```", "```\n$ ./palindromes\nhehe\nnot a palindrome\nABCBA\npalindrome\ncookie\nnot a palindrome\n```", "```\ndogaroo\nradar\nrotor\nmadam\n```", "```\n$ ./palindrome < words.txt\nnot a palindrome\npalindrome\npalindrome\npalindrome\n```", "```\nHey! Hey! You! You!\nI don't like your girlfriend!\nNo way! No way!\nI think you need a new one!\n```", "```\nimport System.IO\n\nmain = do\n    handle <- openFile \"girlfriend.txt\" ReadMode\n    contents <- hGetContents handle\n    putStr contents\n    hClose handle\n```", "```\n$ ./girlfriend\nHey! Hey! You! You!\nI don't like your girlfriend!\nNo way! No way!\nI think you need a new one!\n```", "```\nopenFile :: FilePath -> IOMode -> IO Handle\n```", "```\ntype FilePath = String\n```", "```\ndata IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode\n```", "```\nwithFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a\n```", "```\nimport System.IO\n\nmain = do\n    withFile \"girlfriend.txt\" ReadMode (\\handle -> do\n        contents <- hGetContents handle\n        putStr contents)\n```", "```\nbracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c\n```", "```\nwithFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a\nwithFile name mode f = bracket (openFile name mode)\n    (\\handle -> hClose handle)\n    (\\handle -> f handle)\n```", "```\nimport System.IO\n\nmain = do\n    contents <- readFile \"girlfriend.txt\"\n    putStr contents\n```", "```\nimport System.IO\nimport Data.Char\n\nmain = do\n    contents <- readFile \"girlfriend.txt\"\n    writeFile \"girlfriendcaps.txt\" (map toUpper contents)\n```", "```\nimport System.IO\n\nmain = do\n    todoItem <- getLine\n    appendFile \"todo.txt\" (todoItem ++ \"\\n\")\n```", "```\n$ ./appendtodo\nIron the dishes\n$ ./appendtodo\nDust the dog\n$ ./appendtodo\nTake salad out of the oven\n$ cat todo.txt\nIron the dishes\nDust the dog\nTake salad out of the oven\n```", "```\nimport System.IO\nimport System.Directory\nimport Data.List\n\nmain = do\n    contents <- readFile \"todo.txt\"\n    let todoTasks = lines contents\n        numberedTasks = zipWith (\\n line -> show n ++ \" - \" ++ line)\n                                    [0..] todoTasks\n    putStrLn \"These are your TO-DO items:\"\n    mapM_ putStrLn numberedTasks\n    putStrLn \"Which one do you want to delete?\"\n    numberString <- getLine\n    let number = read numberString\n        newTodoItems = unlines $ delete (todoTasks !! number) todoTasks\n    (tempName, tempHandle) <- openTempFile \".\" \"temp\"\n    hPutStr tempHandle newTodoItems\n    hClose tempHandle\n    removeFile \"todo.txt\"\n    renameFile tempName \"todo.txt\"\n```", "```\n[\"Iron the dishes\", \"Dust the dog\", \"Take salad out of the oven\"]\n```", "```\n[\"0 - Iron the dishes\"\n,\"1 - Dust the dog\"\n,\"2 - Take salad out of the oven\"\n]\n```", "```\n$ ./deletetodo\nThese are your TO-DO items:\n0 - Iron the dishes\n1 - Dust the dog\n2 - Take salad out of the oven\nWhich one do you want to delete?\n1\n```", "```\n$ cat todo.txt\nIron the dishes\nTake salad out of the oven\n```", "```\n$ ./deletetodo\nThese are your TO-DO items:\n0 - Iron the dishes\n1 - Take salad out of the oven\nWhich one do you want to delete?\n0\n```", "```\n$ cat todo.txt\nTake salad out of the oven\n```", "```\nimport System.IO\nimport System.Directory\nimport Data.List\nimport Control.Exception\n\nmain = do\n    contents <- readFile \"todo.txt\"\n    let todoTasks = lines contents\n        numberedTasks = zipWith (\\n line -> show n ++ \" - \" ++ line)\n                                    [0..] todoTasks\n    putStrLn \"These are your TO-DO items:\"\n    mapM_ putStrLn numberedTasks\n    putStrLn \"Which one do you want to delete?\"\n    numberString <- getLine\n    let number = read numberString\n        newTodoItems = unlines $ delete (todoTasks !! number) todoTasks\n    bracketOnError (openTempFile \".\" \"temp\")\n        (\\(tempName, tempHandle) -> do\n            hClose tempHandle\n            removeFile tempName)\n        (\\(tempName, tempHandle) -> do\n            hPutStr tempHandle newTodoItems\n            hClose tempHandle\n            removeFile \"todo.txt\"\n            renameFile tempName \"todo.txt\")\n```", "```\nimport System.Environment\nimport Data.List\n\nmain = do\n   args <- getArgs\n   progName <- getProgName\n   putStrLn \"The arguments are:\"\n   mapM putStrLn args\n   putStrLn \"The program name is:\"\n   putStrLn progName\n```", "```\n$ ./arg-test first second w00t \"multi word arg\"\nThe arguments are:\nfirst\nsecond\nw00t\nmulti word arg\nThe program name is:\narg-test\n```", "```\n$ ./todo add todo.txt \"Find the magic sword of power\"\n```", "```\n$ ./todo view todo.txt\n```", "```\n$ ./todo remove todo.txt 2\n```", "```\nimport System.Environment\nimport System.Directory\nimport System.IO\nimport Data.List\n\ndispatch :: String -> [String] -> IO ()\ndispatch \"add\" = add\ndispatch \"view\" = view\ndispatch \"remove\" = remove\n```", "```\nmain = do\n    (command:argList) <- getArgs\n    dispatch command argList\n```", "```\n$ ./todo add todo.txt \"Find the magic sword of power\"\n```", "```\nadd :: [String] -> IO ()\nadd [fileName, todoItem] = appendFile fileName (todoItem ++ \"\\n\")\n```", "```\n./todo add todo.txt \"Find the magic sword of power\"\n```", "```\nview :: [String] -> IO ()\nview [fileName] = do\n    contents <- readFile fileName\n    let todoTasks = lines contents\n        numberedTasks = zipWith (\\n line -> show n ++ \" - \" ++ line)\n                        [0..] todoTasks\n    putStr $ unlines numberedTasks\n```", "```\nremove :: [String] -> IO ()\nremove [fileName, numberString] = do\n    contents <- readFile fileName\n    let todoTasks = lines contents\n        numberedTasks = zipWith (\\n line -> show n ++ \" - \" ++ line)\n                                    [0..] todoTasks\n    putStrLn \"These are your TO-DO items:\"\n    mapM_ putStrLn numberedTasks\n    let number = read numberString\n        newTodoItems = unlines $ delete (todoTasks !! number) todoTasks\n    bracketOnError (openTempFile \".\" \"temp\")\n        (\\(tempName, tempHandle) -> do\n            hClose tempHandle\n            removeFile tempName)\n\n        (\\(tempName, tempHandle) -> do\n            hPutStr tempHandle newTodoItems\n            hClose tempHandle\n            removeFile \"todo.txt\"\n            renameFile tempName \"todo.txt\")\n```", "```\nimport System.Environment\nimport System.Directory\nimport System.IO\nimport Data.List\n\ndispatch :: String -> [String] -> IO ()\ndispatch \"add\" = add\ndispatch \"view\" = view\ndispatch \"remove\" = remove\n\nmain = do\n    (command:argList) <- getArgs\n    dispatch command argList\n\nadd :: [String] -> IO ()\nadd [fileName, todoItem] = appendFile fileName (todoItem ++ \"\\n\")\n\nview :: [String] -> IO ()\nview [fileName] = do\n    contents <- readFile fileName\n    let todoTasks = lines contents\n        numberedTasks = zipWith (\\n line -> show n ++ \" - \" ++ line)\n                        [0..] todoTasks\n    putStr $ unlines numberedTasks\n\nremove :: [String] -> IO ()\nremove [fileName, numberString] = do\n    contents <- readFile fileName\n    let todoTasks = lines contents\n        numberedTasks = zipWith (\\n line -> show n ++ \" - \" ++ line)\n                                    [0..] todoTasks\n    putStrLn \"These are your TO-DO items:\"\n    mapM_ putStrLn numberedTasks\n    let number = read numberString\n        newTodoItems = unlines $ delete (todoTasks !! number) todoTasks\n    bracketOnError (openTempFile \".\" \"temp\")\n        (\\(tempName, tempHandle) -> do\n            hClose tempHandle\n            removeFile tempName)\n        (\\(tempName, tempHandle) -> do\n            hPutStr tempHandle newTodoItems\n            hClose tempHandle\n            removeFile \"todo.txt\"\n            renameFile tempName \"todo.txt\")\n```", "```\n$ ./todo view todo.txt\n0 - Iron the dishes\n1 - Dust the dog\n2 - Take salad out of the oven\n\n$ ./todo add todo.txt \"Pick up children from dry cleaners\"\n\n$ ./todo view todo.txt\n0 - Iron the dishes\n1 - Dust the dog\n2 - Take salad out of the oven\n3 - Pick up children from dry cleaners\n\n$ ./todo remove todo.txt 2\n\n$ ./todo view todo.txt\n0 - Iron the dishes\n1 - Dust the dog\n2 - Pick up children from dry cleaners :\n```", "```\ndispatch :: String -> [String] -> IO ()\ndispatch \"add\" = add\ndispatch \"view\" = view\ndispatch \"remove\" = remove\ndispatch command = doesntExist command\n\ndoesntExist :: String -> [String] -> IO ()\ndoesntExist command _ =\n    putStrLn $ \"The \" ++ command ++ \" command doesn't exist\"\n```", "```\nadd :: [String] -> IO ()\nadd [fileName, todoItem] = appendFile fileName (todoItem ++ \"\\n\")\nadd _ = putStrLn \"The add command takes exactly two arguments\"\n```", "```\n./todo\n```", "```\nrandomNumber :: Int\nrandomNumber = 4\n```", "```\nrandom :: (RandomGen g, Random a) => g -> (a, g)\n```", "```\nghci> random (mkStdGen 100)\n<interactive>:1:0:\n    Ambiguous type variable `a' in the constraint:\n      `Random a' arising from a use of `random' at <interactive>:1:0-20\n    Probable fix: add a type signature that fixes these type variable(s)\n```", "```\nghci> random (mkStdGen 100) :: (Int, StdGen)\n(-1352021624,651872571 1655838864)\n```", "```\nghci> random (mkStdGen 100) :: (Int, StdGen)\n(-1352021624,651872571 1655838864)\n```", "```\nghci> random (mkStdGen 949494) :: (Int, StdGen)\n(539963926,466647808 1655838864)\n```", "```\nghci> random (mkStdGen 949488) :: (Float, StdGen)\n(0.8938442,1597344447 1655838864)\n\nghci> random (mkStdGen 949488) :: (Bool, StdGen)\n(False,1485632275 40692)\nghci> random (mkStdGen 949488) :: (Integer, StdGen)\n(1691547873,1597344447 1655838864)\n```", "```\nthreeCoins :: StdGen -> (Bool, Bool, Bool)\nthreeCoins gen =\n    let (firstCoin, newGen) = random gen\n        (secondCoin, newGen') = random newGen\n        (thirdCoin, newGen'') = random newGen'\n    in  (firstCoin, secondCoin, thirdCoin)\n```", "```\nghci> threeCoins (mkStdGen 21)\n(True,True,True)\nghci> threeCoins (mkStdGen 22)\n(True,False,True)\nghci> threeCoins (mkStdGen 943)\n(True,False,True)\nghci> threeCoins (mkStdGen 944)\n(True,True,True)\n```", "```\nghci> take 5 $ randoms (mkStdGen 11) :: [Int]\n[-1807975507,545074951,-1015194702,-1622477312,-502893664]\nghci> take 5 $ randoms (mkStdGen 11) :: [Bool]\n[True,True,True,True,False]\nghci> take 5 $ randoms (mkStdGen 11) :: [Float]\n[7.904789e-2,0.62691015,0.26363158,0.12223756,0.38291094]\n```", "```\nrandoms' :: (RandomGen g, Random a) => g -> [a]\nrandoms' gen = let (value, newGen) = random gen in value:randoms' newGen\n```", "```\nfiniteRandoms :: (RandomGen g, Random a, Num n) => n -> g -> ([a], g)\nfiniteRandoms 0 gen = ([], gen)\nfiniteRandoms n gen =\n    let (value, newGen) = random gen\n        (restOfList, finalGen) = finiteRandoms (n-1) newGen\n    in  (value:restOfList, finalGen)\n```", "```\nrandomR :: (RandomGen g, Random a) :: (a, a) -> g -> (a, g)\n```", "```\nghci> randomR (1,6) (mkStdGen 359353)\n(6,1494289578 40692)\nghci> randomR (1,6) (mkStdGen 35935335)\n(3,1250031057 40692)\n```", "```\nghci> take 10 $ randomRs ('a','z') (mkStdGen 3) :: [Char]\n\"ndkxbvmomg\"\n```", "```\nimport System.Random\n\nmain = do\n    gen <- getStdGen\n    putStrLn $ take 20 (randomRs ('a','z') gen)\n```", "```\n$ ./random_string\npybphhzzhuepknbykxhe\n$ ./random_string\neiqgcxykivpudlsvvjpg\n$ ./random_string\nnzdceoconysdgcyqjruo\n$ ./random_string\nbakzhnnuzrkgvesqplrx\n```", "```\nimport System.Random\n\nmain = do\n    gen <- getStdGen\n    putStrLn $ take 20 (randomRs ('a','z') gen)\n    gen2 <- getStdGen\n    putStr $ take 20 (randomRs ('a','z') gen2)\n```", "```\nimport System.Random\n\nmain = do\n    gen <- getStdGen\n    putStrLn $ take 20 (randomRs ('a','z') gen)\n    gen' <- newStdGen\n    putStr $ take 20 (randomRs ('a','z') gen')\n```", "```\nimport System.Random\nimport Control.Monad(when)\n\nmain = do\n    gen <- getStdGen\n    askForNumber gen\n\naskForNumber :: StdGen -> IO ()\naskForNumber gen = do\n    let (randNumber, newGen) = randomR (1,10) gen :: (Int, StdGen)\n    putStrLn \"Which number in the range from 1 to 10 am I thinking of? \"\n    numberString <- getLine\n    when (not $ null numberString) $ do\n        let number = read numberString\n\n        if randNumber == number\n            then putStrLn \"You are correct!\"\n            else putStrLn $ \"Sorry, it was \" ++ show randNumber\n        askForNumber newGen\n```", "```\n$ ./guess_the_number\nWhich number in the range from 1 to 10 am I thinking of?\n4\nSorry, it was 3\nWhich number in the range from 1 to 10 am I thinking of?\n10\nYou are correct!\nWhich number in the range from 1 to 10 am I thinking of?\n2\nSorry, it was 4\nWhich number in the range from 1 to 10 am I thinking of?\n5\nSorry, it was 10\nWhich number in the range from 1 to 10 am I thinking of?\n```", "```\nimport System.Random\nimport Control.Monad(when)\n\nmain = do\n    gen <- getStdGen\n    let (randNumber, _) = randomR (1,10) gen :: (Int, StdGen)\n    putStrLn \"Which number in the range from 1 to 10 am I thinking of? \"\n    numberString <- getLine\n    when (not $ null numberString) $ do\n        let number = read numberString\n        if randNumber == number\n            then putStrLn \"You are correct!\"\n            else putStrLn $ \"Sorry, it was \" ++ show randNumber\n        newStdGen\n        main\n```", "```\nimport qualified Data.ByteString.Lazy as B\nimport qualified Data.ByteString as S\n```", "```\nghci> B.pack [99,97,110]\nChunk \"can\" Empty\nghci> B.pack [98..120]\nChunk \"bcdefghijklmnopqrstuvwx\" Empty\n```", "```\nghci> let by = B.pack [98,111,114,116]\nghci> by\nChunk \"bort\" Empty\nghci> B.unpack by\n[98,111,114,116]\n```", "```\nghci> B.fromChunks [S.pack [40,41,42], S.pack [43,44,45], S.pack [46,47,48]]\nChunk \"()*\" (Chunk \"+,-\" (Chunk \"./0\" Empty))\n```", "```\nghci> B.cons 85 $ B.pack [80,81,82,84]\nChunk \"U\" (Chunk \"PQRT\" Empty)\n```", "```\nreadFile :: FilePath -> IO String\n```", "```\nreadFile :: FilePath -> IO ByteString\n```", "```\nimport System.Environment\nimport System.Directory\nimport System.IO\nimport Control.Exception\nimport qualified Data.ByteString.Lazy as B\n\nmain = do\n    (fileName1:fileName2:_) <- getArgs\n    copy fileName1 fileName2\n\ncopy source dest = do\n    contents <- B.readFile source\n    bracketOnError\n        (openTempFile \".\" \"temp\")\n        (\\(tempName, tempHandle) -> do\n            hClose tempHandle\n            removeFile tempName)\n        (\\(tempName, tempHandle) -> do\n            B.hPutStr tempHandle contents\n            hClose tempHandle\n            renameFile tempName dest)\n```", "```\n$ ./bytestringcopy bart.txt bort.txt\n```"]