<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Blocks, Procs, and Lambdas"><div class="titlepage"><div><div><h1 class="title"><a id="blocks_comma_procs_comma_and_lambdas"/>Chapter 10. Blocks, Procs, and Lambdas</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id12"/><div class="mediaobject"><a id="I_mediaobject10_d1e11417"/><img src="httpatomoreillycomsourcenostarchimages860138.png.jpg" alt="image with no caption"/></div></div><p>When programmers talk about blocks, they often mean some arbitrary “chunks” of code. In Ruby, however, a block is special. It is a unit of code that works somewhat like a method but, unlike a method, it has no name.<a id="IDX-CHP-10-0001" class="indexterm"/></p><p>Blocks are very important in Ruby, but they can be difficult to understand. In addition, there are some important differences in the behavior of blocks in Ruby 1.8 and Ruby 1.9. If you fail to appreciate those differences, your programs may behave in unexpected ways when run in different versions of Ruby. This chapter looks at blocks in great detail. Not only does it explain how they work and why they are special, but it also provides guidance on ensuring that they continue to work consistently no matter which version of Ruby you happen to be using.<a id="IDX-CHP-10-0002" class="indexterm"/></p><div class="sect1" title="What Is a Block?"><div class="titlepage"><div><div><h1 class="title"><a id="what_is_a_block_question"/>What Is a Block?</h1></div></div></div><p>Consider this code:<a id="IDX-CHP-10-0003" class="indexterm"/><a id="IDX-CHP-10-0004" class="indexterm"/><a id="IDX-CHP-10-0005" class="indexterm"/></p><p><span class="emphasis"><em>1blocks.rb</em></span></p><a id="I_programlisting10_d1e11453"/><pre class="programlisting">3.times do |i|
    puts( i )
end</pre><p>It’s probably pretty obvious that this code is intended to execute three times. What may be less obvious is the value that <code class="literal">i</code> will have on each successive turn through the loop. In fact, the values of <code class="literal">i</code> in this case will be 0, 1, and 2. The following is an alternative form of the previous code. This time, the block is delimited by curly brackets rather than by <code class="literal">do</code> and <code class="literal">end</code>.<a id="IDX-CHP-10-0006" class="indexterm"/></p><a id="I_programlisting10_d1e11472"/><pre class="programlisting">3.times { |i|
    puts( i )
}</pre><p>According to the Ruby documentation, <code class="literal">times</code> is a method of Integer (let’s call the Integer <code class="literal">int</code>), which iterates a block “<code class="literal">int</code> times, passing in values from 0 to <code class="literal">int</code> −1.” So here, the code within the block is run three times. The first time it is run, the variable <code class="literal">i</code> is given the value 0; each subsequent time, <code class="literal">i</code> is incremented by 1 until the final value, 2 (that is, <code class="literal">int</code>−1), is reached.</p><p>The two code examples shown earlier are functionally identical. A block can be enclosed either by curly brackets or by the <code class="literal">do</code> and <code class="literal">end</code> keywords, and the programmer can use either syntax according to personal preference.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Some Ruby programmers like to delimit blocks with curly brackets when the entire code of the block fits onto a single line and with <code class="literal">do..end</code> when the block spans multiple lines. My personal prejudice is to be consistent, irrespective of code layout, so I generally use curly brackets when delimiting blocks. Usually your choice of delimiters makes no difference to the behavior of the code—but see <a class="xref" href="ch10s13.html" title="Precedence Rules">Precedence Rules</a> in <a class="xref" href="ch10s13.html" title="Precedence Rules">Precedence Rules</a>.<a id="IDX-CHP-10-0007" class="indexterm"/></p></div><p>If you are familiar with a C-like language such as C# or Java, you may, perhaps, assume that Ruby’s curly brackets can be used, as in those languages, simply to group together arbitrary “blocks” of code—for example, a block of code to be executed when a condition evaluates to true. This is not the case. In Ruby, a block is a special construct that can be used only in very specific circumstances.</p></div></div>
<div class="sect1" title="Line Breaks Are Significant"><div class="titlepage"><div><div><h1 class="title"><a id="line_breaks_are_significant"/>Line Breaks Are Significant</h1></div></div></div><p>You must place the opening block delimiter on the same line as the method with which it is associated.</p><p>For example, these are okay:</p><a id="I_programlisting10_d1e11528"/><pre class="programlisting">3.times do |i|
    puts( i )
end

3.times { |i|
    puts( i )
}</pre><p>But these contain syntax errors:</p><a id="I_programlisting10_d1e11532"/><pre class="programlisting">3.times
do |i|
    puts( i )
end

3.times
{ |i|
    puts( i )
}</pre></div>
<div class="sect1" title="Nameless Functions"><div class="titlepage"><div><div><h1 class="title"><a id="nameless_functions"/>Nameless Functions</h1></div></div></div><p>A Ruby block may be regarded as a sort of nameless function or method, and its most frequent use is to provide a means of iterating over items from a list or range of values. If you have never come across nameless functions, this may sound like gobbledygook. With luck, by the end of this chapter, things will have become a little clearer. Let’s look back at the simple example given earlier. I said a block is like a nameless function. Take this block as an example:<a id="IDX-CHP-10-0008" class="indexterm"/><a id="IDX-CHP-10-0009" class="indexterm"/></p><a id="I_programlisting10_d1e11547"/><pre class="programlisting">{ |i|
    puts( i )
}</pre><p>If that were written as a normal Ruby method, it would look something like this:</p><a id="I_programlisting10_d1e11551"/><pre class="programlisting">def aMethod( i )
   puts( i )
end</pre><p>To call that method three times and pass values from 0 to 2, you might write this:</p><a id="I_programlisting10_d1e11555"/><pre class="programlisting">for i in 0..2
   aMethod( i )
end</pre><p>When you create a nameless method (that is, a block), variables declared between upright bars such as <code class="literal">|i|</code> can be treated like the arguments to a named method. I will refer to these variables as <span class="emphasis"><em>block parameters</em></span>.<a id="IDX-CHP-10-0010" class="indexterm"/><a id="IDX-CHP-10-0011" class="indexterm"/></p><p>Look again at my earlier example:<a id="IDX-CHP-10-0012" class="indexterm"/><a id="IDX-CHP-10-0013" class="indexterm"/><a id="IDX-CHP-10-0014" class="indexterm"/></p><a id="I_programlisting10_d1e11584"/><pre class="programlisting">3.times { |i|
    puts( i )
}</pre><p>The <code class="literal">times</code> method of an integer passes values to a block from 0 to the specified integer value minus 1.</p><p>So, this:</p><a id="I_programlisting10_d1e11594"/><pre class="programlisting">3.times{ |i| }</pre><p>is very much like this:</p><a id="I_programlisting10_d1e11598"/><pre class="programlisting">for i in 0..2
    aMethod( i )
end</pre><p>The chief difference is that the second example has to call a named method to process the value of <code class="literal">i</code>, whereas the first example uses the nameless method (the code between curly brackets) to process <code class="literal">i</code>.</p></div>
<div class="sect1" title="Look Familiar?"><div class="titlepage"><div><div><h1 class="title"><a id="look_familiar_question"/>Look Familiar?</h1></div></div></div><p>Now that you know what a block is, you may notice that you’ve seen them before. Many times. For example, you previously used <code class="literal">do..end</code> blocks to iterate over ranges like this:<a id="IDX-CHP-10-0015" class="indexterm"/><a id="IDX-CHP-10-0016" class="indexterm"/></p><a id="I_programlisting10_d1e11624"/><pre class="programlisting">(1..3).each do |i|
    puts(i)
end</pre><p>You have also used <code class="literal">do..end</code> blocks to iterate over arrays (see <span class="emphasis"><em>for_each2.rb</em></span> in <a class="xref" href="ch05.html#for_loops" title="for Loops">for Loops</a>):</p><a id="I_programlisting10_d1e11636"/><pre class="programlisting">arr = ['one','two','three','four']
arr.each do |s|
    puts(s)
end</pre><p>And you have executed a block repeatedly by passing it to the <code class="literal">loop</code> method (see <span class="emphasis"><em>3loops.rb</em></span> in <a class="xref" href="ch05s07.html" title="loop">loop</a>):<a id="IDX-CHP-10-0017" class="indexterm"/></p><a id="I_programlisting10_d1e11651"/><pre class="programlisting">i=0
loop {
    puts(arr[i])
    i+=1
    if (i == arr.length) then
        break
    end
}</pre><p>The previous <code class="literal">loop</code> example is notable for two things: It has no list of items (such as an array or a range of values) to iterate over, and it is pretty darn ugly. These two features are not entirely unrelated! The <code class="literal">loop</code> method is part of the Kernel class, which is “automatically” available to your programs. Because it has no “end value,” it will execute the block forever unless you explicitly break out of it using the <code class="literal">break</code> keyword. Usually there are more elegant ways to perform this kind of iteration—by iterating over a sequence of values with a finite range.<a id="IDX-CHP-10-0018" class="indexterm"/><a id="IDX-CHP-10-0019" class="indexterm"/></p></div>
<div class="sect1" title="Blocks and Arrays"><div class="titlepage"><div><div><h1 class="title"><a id="blocks_and_arrays"/>Blocks and Arrays</h1></div></div></div><p>Blocks are commonly used to iterate over arrays. The Array class, consequently, provides a number of methods to which blocks are passed.</p><p>One useful method is called <code class="literal">collect</code>; this passes each element of the array to a block and creates a new array to contain each of the values returned by the block. Here, for example, a block is passed to each of the integers in an array (each integer is assigned to the variable <code class="literal">x</code>); the block doubles its value and returns it. The <code class="literal">collect</code> method creates a new array containing each of the returned integers in sequence:<a id="IDX-CHP-10-0020" class="indexterm"/><a id="IDX-CHP-10-0021" class="indexterm"/><a id="IDX-CHP-10-0022" class="indexterm"/></p><p><span class="emphasis"><em>2blocks.rb</em></span></p><a id="I_programlisting10_d1e11706"/><pre class="programlisting">b3 = [1,2,3].collect{|x| x*2}</pre><p>The previous example assigns this array to <code class="literal">b3</code>:</p><a id="I_programlisting10_d1e11713"/><pre class="programlisting">[2,4,6]</pre><p>In the next example, the block returns a version of the original strings in which each initial letter is capitalized:</p><a id="I_programlisting10_d1e11717"/><pre class="programlisting">b4 = ["hello","good day","how do you do"].collect{|x| x.capitalize }</pre><p>So, <code class="literal">b4</code> is now as follows:</p><a id="I_programlisting10_d1e11724"/><pre class="programlisting">["Hello", "Good day", "How do you do"]</pre><p>The <code class="literal">each</code> method of the Array class may look rather similar to <code class="literal">collect</code>; it too passes each array element in turn to be processed by the block. However, unlike <code class="literal">collect</code>, the <code class="literal">each</code> method does not create a new array to contain the returned values:</p><a id="I_programlisting10_d1e11741"/><pre class="programlisting">b5 = ["hello","good day","how do you do"].each{|x| x.capitalize }</pre><p>This time, <code class="literal">b5</code> is unchanged:</p><a id="I_programlisting10_d1e11748"/><pre class="programlisting">["hello", "good day", "how do you do"]</pre><p>Recall, however, that some methods—notably those ending with an exclamation mark (<code class="literal">!</code>)—actually alter the original objects rather than yielding new values. If you wanted to use the <code class="literal">each</code> method to capitalize the strings in the original array, you could use the <code class="literal">capitalize!</code> method:<a id="IDX-CHP-10-0023" class="indexterm"/><a id="IDX-CHP-10-0024" class="indexterm"/></p><a id="I_programlisting10_d1e11771"/><pre class="programlisting">b6 = ["hello","good day", "how do you do"].each{|x| x.capitalize! }</pre><p>So, <code class="literal">b6</code> is now as follows:</p><a id="I_programlisting10_d1e11778"/><pre class="programlisting">["Hello", "Good day", "How do you do"]</pre><p>With a bit of thought, you could also use a block to iterate over the characters in a string. First, you need to split off each character from a string. This can be done using the <code class="literal">split</code> method of the String class like this:<a id="IDX-CHP-10-0025" class="indexterm"/></p><a id="I_programlisting10_d1e11790"/><pre class="programlisting">"hello world".split(//)</pre><p>The <code class="literal">split</code> method divides a string into substrings based on a delimiter and returns an array of these substrings. Here <code class="literal">//</code> is a regular expression that defines a zero-length string; this has the effect of returning a single character, so you end up creating an array of all the characters in the string. You can now iterate over this array of characters, returning a <code class="literal">capitalized</code> version of each:</p><a id="I_programlisting10_d1e11804"/><pre class="programlisting">a = "hello world".split(//).each{ |x| newstr &lt;&lt; x.capitalize }</pre><p>At each iteration, a capitalized character is appended to <code class="literal">newstr</code>, and the following is displayed:</p><a id="I_programlisting10_d1e11811"/><pre class="programlisting">H
HE
HEL
HELL
HELLO
HELLO
HELLO W
HELLO WO
HELLO WOR
HELLO WORL
HELLO WORLD</pre><p>Because you are using the <code class="literal">capitalize</code> method here (with no terminating <code class="literal">!</code> character), the characters in the array <code class="literal">a</code> remain as they began, all lowercase, since the <code class="literal">capitalize</code> method does not alter the receiver object (here the receiver objects are the characters passed into the block).</p><p>Be aware, however, that this code would not work if you were to use the <code class="literal">capitalize!</code> method to modify the original characters. This is because <code class="literal">capitalize!</code> returns <code class="literal">nil</code> when no changes are made, so when the space character is encountered, <code class="literal">nil</code> would be returned, and your attempt to append (<code class="literal">&lt;&lt;</code>) a <code class="literal">nil</code> value to the string <code class="literal">newstr</code> would fail.<a id="IDX-CHP-10-0026" class="indexterm"/><a id="IDX-CHP-10-0027" class="indexterm"/><a id="IDX-CHP-10-0028" class="indexterm"/><a id="IDX-CHP-10-0029" class="indexterm"/><a id="IDX-CHP-10-0030" class="indexterm"/><a id="IDX-CHP-10-0031" class="indexterm"/><a id="IDX-CHP-10-0032" class="indexterm"/><a id="IDX-CHP-10-0033" class="indexterm"/></p><p>You could also capitalize a string using the <code class="literal">each_byte</code> method. This iterates through the string characters, passing each byte to the block. These bytes take the form of ASCII codes. So, “hello world” would be passed in the form of these numeric values: <code class="literal">104 101 108 108 111 32 119 111 114 108 100</code>.<a id="IDX-CHP-10-0034" class="indexterm"/></p><p>Obviously, you can’t capitalize an integer, so you need to convert each ASCII value to a character. The <code class="literal">chr</code> method of String does this:<a id="IDX-CHP-10-0035" class="indexterm"/></p><a id="I_programlisting10_d1e11907"/><pre class="programlisting">a = "hello world".each_byte{|x| newstr &lt;&lt; (x.chr).capitalize }</pre></div>
<div class="sect1" title="Procs and Lambdas"><div class="titlepage"><div><div><h1 class="title"><a id="procs_and_lambdas"/>Procs and Lambdas</h1></div></div></div><p>In the examples up to now, blocks have been used in cahoots with methods. This has been a requirement since nameless blocks cannot have an independent existence in Ruby. You cannot, for example, create a stand-alone block like this:</p><a id="I_programlisting10_d1e11914"/><pre class="programlisting">{|x| x = x*10; puts(x)}        # This is not allowed!</pre><p>This is one of the exceptions to the rule that “everything in Ruby is an object.” A block clearly is not an object. Every object is created from a class, and you can find an object’s class by calling its <code class="literal">class</code> method.</p><p>Do this with a hash, for example, and the class name “Hash” will be displayed:</p><a id="I_programlisting10_d1e11923"/><pre class="programlisting">puts({1=&gt;2}.class)</pre><p>Try this with a block, however, and you will only get an error message:</p><a id="I_programlisting10_d1e11927"/><pre class="programlisting">puts({|i| puts(i)}.class) #&lt;= error!</pre></div>
<div class="sect1" title="Block or Hash?"><div class="titlepage"><div><div><h1 class="title"><a id="block_or_hash_question"/>Block or Hash?</h1></div></div></div><p>Ruby uses curly brackets to delimit both blocks and hashes. So, how can you (and Ruby) tell which is which? The answer, basically, is that it’s a hash when it <span class="emphasis"><em>looks</em></span> like a hash, and otherwise it’s a block. A hash looks like a hash when curly brackets contain key-value pairs:</p><a id="I_programlisting10_d1e11937"/><pre class="programlisting">puts( {1=&gt;2}.class )     #&lt;= Hash</pre><p>or when they are empty:<a id="IDX-CHP-10-0036" class="indexterm"/><a id="IDX-CHP-10-0037" class="indexterm"/><a id="IDX-CHP-10-0038" class="indexterm"/><a id="IDX-CHP-10-0039" class="indexterm"/><a id="IDX-CHP-10-0040" class="indexterm"/><a id="IDX-CHP-10-0041" class="indexterm"/></p><p><span class="emphasis"><em>block_or_hash.rb</em></span></p><a id="I_programlisting10_d1e11968"/><pre class="programlisting">puts( {}.class )         #&lt;= Hash</pre><p>However, if you omit the parentheses, there is an ambiguity. Is this an empty hash, or is it a block associated with the <code class="literal">puts</code> method?</p><a id="I_programlisting10_d1e11975"/><pre class="programlisting">puts{}.class</pre><p>Frankly, I have to admit I don’t know the answer to that question, and I can’t get Ruby to tell me. Ruby accepts this as valid syntax but does not, in fact, display anything when the code executes. So, how about this?</p><a id="I_programlisting10_d1e11979"/><pre class="programlisting">print{}.class</pre><p>Once again, this prints nothing at all in Ruby 1.9, but in Ruby 1.8 it displays <code class="literal">nil</code> (not, you will notice, the actual <span class="emphasis"><em>class</em></span> of <code class="literal">nil</code>, which is NilClass, but <code class="literal">nil</code> itself). If you find all this confusing (as I do!), just remember that this can all be clarified by the judicious use of parentheses:</p><a id="I_programlisting10_d1e11996"/><pre class="programlisting">print( {}.class )    #&lt;= Hash</pre></div>
<div class="sect1" title="Creating Objects from Blocks"><div class="titlepage"><div><div><h1 class="title"><a id="creating_objects_from_blocks"/>Creating Objects from Blocks</h1></div></div></div><p>Although blocks may not be objects by default, they can be “turned into” objects. There are three ways of creating objects from blocks and assigning them to variables—here’s how:<a id="IDX-CHP-10-0042" class="indexterm"/></p><p><span class="emphasis"><em>proc_create.rb</em></span><a id="IDX-CHP-10-0043" class="indexterm"/></p><a id="I_programlisting10_d1e12015"/><pre class="programlisting">a = Proc.new{|x| x = x*10; puts(x) }    #=&gt; Proc
b = lambda{|x| x = x*10; puts(x) }      #=&gt; Proc
c = proc{|x| x.capitalize! }            #=&gt; Proc</pre><p>In each of the three cases, you will end up creating an instance of the Proc class—which is the Ruby “object wrapper” for a block.</p><p>Let’s take a look at a simple example of creating and using a Proc object. First, you can create an object calling <code class="literal">Proc.new</code> and passing to it a block as an argument:<a id="IDX-CHP-10-0044" class="indexterm"/><a id="IDX-CHP-10-0045" class="indexterm"/></p><p><span class="emphasis"><em>3blocks.rb</em></span></p><a id="I_programlisting10_d1e12037"/><pre class="programlisting">a = Proc.new{|x| x = x*10; puts(x)}</pre><p>Second, you can execute the code in the block to which <code class="literal">a</code> refers using the Proc class’s <code class="literal">call</code> method with one or more arguments (matching the block parameters) to be passed into the block; in the previous code, you could pass an integer such as 100, and this would be assigned to the block variable <code class="literal">x</code>:</p><a id="I_programlisting10_d1e12050"/><pre class="programlisting">a.call(100)        #=&gt; 1000</pre><p>Finally, you can also create a Proc object by calling the <code class="literal">lambda</code> or <code class="literal">proc</code> methods, which are supplied by the Kernel class. The name <code class="literal">lambda</code> is taken from the Scheme (Lisp) language and is a term used to describe an anonymous method, or <span class="emphasis"><em>closure</em></span>.<a id="IDX-CHP-10-0046" class="indexterm"/></p><a id="I_programlisting10_d1e12070"/><pre class="programlisting">b = lambda{|x| x = x*10; puts(x) }
b.call(100)            #=&gt; 1000

c = proc{|x| x.capitalize! }
c1 = c.call( "hello" )
puts( c1 )             #=&gt; Hello</pre><p>Here is a slightly more complicated example that iterates over an array of strings, capitalizing each string in turn. The array of capitalized strings is then assigned to the <code class="literal">d1</code> variable:</p><a id="I_programlisting10_d1e12077"/><pre class="programlisting">d = lambda{|x| x.capitalize! }
d1 = ["hello","good day","how do you do"].each{ |s| d.call(s)}
puts(d1.inspect)        #=&gt; ["Hello", "Good day", "How do you do"]</pre><p>There is one important difference between creating a Proc object using <code class="literal">Proc.new</code> and creating a Proc object using a <code class="literal">lambda</code> method—<code class="literal">Proc.new</code> does not check that the number of arguments passed to the block matches the number of block parameters. <code class="literal">lambda</code> does. The behavior of the <code class="literal">proc</code> method is different in Ruby 1.8 and 1.9. In Ruby 1.8, <code class="literal">proc</code> is equivalent to <code class="literal">lambda</code>—it checks the number of arguments. In Ruby 1.9, <code class="literal">proc</code> is equivalent to <code class="literal">Proc.new</code>—it does <span class="emphasis"><em>not</em></span> check the number of arguments:<a id="IDX-CHP-10-0047" class="indexterm"/><a id="IDX-CHP-10-0048" class="indexterm"/></p><p><span class="emphasis"><em>proc_lamba.rb</em></span></p><a id="I_programlisting10_d1e12126"/><pre class="programlisting">a = Proc.new{|x,y,z| x = y*z; puts(x) }
a.call(2,5,10,100)        # This is not an error

b = lambda{|x,y,z| x = y*z; puts(x) }
b.call(2,5,10,100)        # This is an error

puts('---Block #2---' )
c = proc{|x,y,z| x = y*z; puts(x) }
c.call(2,5,10,100)        # This is an error in Ruby 1.8
                          # Not an error in Ruby 1.9</pre></div>
<div class="sect1" title="What Is a Closure?"><div class="titlepage"><div><div><h1 class="title"><a id="what_is_a_closure_question"/>What Is a Closure?</h1></div></div></div><p>A <span class="emphasis"><em>closure</em></span> is a function that has the ability to store (that is, to “enclose”) values of local variables within the scope in which the block was created (think of this as the block’s “native scope”). Ruby’s blocks are closures. To understand this, look at this example:<a id="IDX-CHP-10-0049" class="indexterm"/></p><p><span class="emphasis"><em>block_closure.rb</em></span></p><a id="I_programlisting10_d1e12142"/><pre class="programlisting">x = "hello world"

ablock = Proc.new { puts( x ) }

def aMethod( aBlockArg )
    x = "goodbye"
    aBlockArg.call
end

puts( x )
ablock.call
aMethod( ablock )
ablock.call
puts( x )</pre><p>Here, the value of the local variable <code class="literal">x</code> is “hello world” within the scope of <code class="literal">ablock</code>. Inside <code class="literal">aMethod</code>, however, a local variable named <code class="literal">x</code> has the value “goodbye.” In spite of that, when <code class="literal">ablock</code> is passed to <code class="literal">aMethod</code> and called within the scope of <code class="literal">aMethod</code>, it prints “hello world” (that is, the value of <code class="literal">x</code> within the block’s native scope) rather than “goodbye,” which is the value of <code class="literal">x</code> within the scope of <code class="literal">aMethod</code>. The previous code, therefore, only ever prints “hello world.”</p><div class="note" title="Note"><h3 class="title">Note</h3><p>See <a class="xref" href="ch10s14.html#digging_deeper-id9" title="Digging Deeper">Digging Deeper</a> in <a class="xref" href="ch10s14.html#digging_deeper-id9" title="Digging Deeper">Digging Deeper</a> for more on closures.</p></div></div>
<div class="sect1" title="yield"><div class="titlepage"><div><div><h1 class="title"><a id="yield"/>yield</h1></div></div></div><p>Let’s see a few more blocks in use. The <span class="emphasis"><em>4blocks.rb</em></span> program introduces something new, namely, a way of executing a nameless block when it is passed to a method. This is done using the keyword <code class="literal">yield</code>. In the first example, I define this simple method:<a id="IDX-CHP-10-0050" class="indexterm"/></p><p><span class="emphasis"><em>4blocks.rb</em></span></p><a id="I_programlisting10_d1e12201"/><pre class="programlisting">def aMethod
    yield
end</pre><p>It doesn’t really have any code of its own. Instead, it expects to receive a block, and the <code class="literal">yield</code> keyword causes the block to execute. This is how I pass a block to it:</p><a id="I_programlisting10_d1e12208"/><pre class="programlisting">aMethod{ puts( "Good morning" ) }</pre><p>Notice that this time the block is not passed as a named argument. It would be an error to try to pass the block between parentheses, like this:</p><a id="I_programlisting10_d1e12212"/><pre class="programlisting">aMethod(  { puts( "Good morning" ) }  )     # This won't work!</pre><p>Instead, you simply put the block right next to the method to which you are passing it, just as you did in the first example in this chapter. That method receives the block without having to declare a named parameter for it, and it calls the block with <code class="literal">yield</code>.</p><p>Here is a slightly more useful example:<a id="IDX-CHP-10-0051" class="indexterm"/><a id="IDX-CHP-10-0052" class="indexterm"/></p><a id="I_programlisting10_d1e12231"/><pre class="programlisting">def caps( anarg )
    yield( anarg )
end

caps( "a lowercase string" ){ |x| x.capitalize! ; puts( x ) }</pre><p>Here the <code class="literal">caps</code> method receives one argument, <code class="literal">anarg</code>, and passes this argument to a nameless block, which is then executed by <code class="literal">yield</code>. When I call the <code class="literal">caps</code> method, I pass it a string argument (<code class="literal">"a lowercase string"</code>) using the normal parameter-passing syntax. The nameless block is passed <span class="emphasis"><em>after the end</em></span> of the parameter list.</p><p>When the <code class="literal">caps</code> method calls <code class="literal">yield( anarg )</code>, then the string argument is passed into the block; it is assigned to the block variable <code class="literal">x</code>. This capitalizes it and displays it with <code class="literal">puts( s )</code>, which shows that the initial letter has been capitalized: “A lowercase string.”</p></div>
<div class="sect1" title="Blocks Within Blocks"><div class="titlepage"><div><div><h1 class="title"><a id="blocks_within_blocks"/>Blocks Within Blocks</h1></div></div></div><p>You’ve already seen how to use a block to iterate over an array. In the next example (also in <span class="emphasis"><em>4blocks.rb</em></span>), I use one block to iterate over an array of strings, assigning each string in turn to the block variable <code class="literal">s</code>. A second block is then passed to the <code class="literal">caps</code> method in order to capitalize the string:</p><a id="I_programlisting10_d1e12283"/><pre class="programlisting">["hello","good day","how do you do"].each{
    |s|
    caps( s ){ |x| x.capitalize!
        puts( x )
    }
}</pre><p>This results in the following output:</p><a id="I_programlisting10_d1e12287"/><pre class="programlisting">Hello
Good day
How do you do</pre></div>
<div class="sect1" title="Passing Named Proc Arguments"><div class="titlepage"><div><div><h1 class="title"><a id="passing_named_proc_arguments"/>Passing Named Proc Arguments</h1></div></div></div><p>Up to now, you have passed blocks to procedures either anonymously (in which case the block is executed with the <code class="literal">yield</code> keyword) or in the form of a named argument, in which case it is executed using the <code class="literal">call</code> method. There is another way to pass a block. When the last argument in a method’s list of parameters is preceded by an ampersand (<code class="literal">&amp;</code>), it is considered to be a Proc object. This gives you the option of passing an anonymous block to a procedure using the same syntax as when passing a block to an iterator, and yet the procedure itself can receive the block as a named argument. Load <span class="emphasis"><em>5blocks.rb</em></span> to see some examples of this.<a id="IDX-CHP-10-0053" class="indexterm"/><a id="IDX-CHP-10-0054" class="indexterm"/></p><p>First, here is a reminder of the two ways you’ve already seen of passing blocks. This method has three parameters, <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code>:</p><p><span class="emphasis"><em>5blocks.rb</em></span></p><a id="I_programlisting10_d1e12326"/><pre class="programlisting">def abc( a, b, c )
    a.call
    b.call
    c.call
    yield
end</pre><p>You call this method with three named arguments (which here happen to be blocks but could, in principle, be anything) plus an unnamed block:</p><a id="I_programlisting10_d1e12330"/><pre class="programlisting">a = lambda{ puts "one" }
b = lambda{ puts "two" }
c = proc{ puts "three" }
abc(a, b, c ){ puts "four" }</pre><p>The <code class="literal">abc</code> method executes the named block arguments using the <code class="literal">call</code> method and the unnamed block using the <code class="literal">yield</code> keyword. The results are shown in the <code class="literal">#=&gt;</code> comments here:</p><a id="I_programlisting10_d1e12346"/><pre class="programlisting">a.call    #=&gt; one
b.call    #=&gt; two
c.call    #=&gt; three
yield     #=&gt; four</pre><p>The next method, <code class="literal">abc2</code>, takes a single argument, <code class="literal">&amp;d</code>. The ampersand here is significant because it indicates that the <code class="literal">&amp;d</code> parameter is a block. Instead of using the <code class="literal">yield</code> keyword, the <code class="literal">abc2</code> method is able to execute the block using the name of the argument (without the ampersand):</p><a id="I_programlisting10_d1e12365"/><pre class="programlisting">def abc2( &amp;d )
    d.call
end</pre><p>So, a block argument with an ampersand is called in the same way as one without an ampersand. However, there is a difference in the way the object matching that argument is passed to the method. To match an ampersand-argument, an unnamed block is passed by appending it to the method name:</p><a id="I_programlisting10_d1e12370"/><pre class="programlisting">abc2{ puts "four" }</pre><p>You can think of ampersand-arguments as type-checked block parameters. Unlike normal arguments (without an ampersand), the argument cannot match any type; it can match only a block. You cannot pass some other sort of object to <code class="literal">abc2</code>:<a id="IDX-CHP-10-0055" class="indexterm"/><a id="IDX-CHP-10-0056" class="indexterm"/></p><a id="I_programlisting10_d1e12383"/><pre class="programlisting">abc2( 10 )    # This won't work!</pre><p>The <code class="literal">abc3</code> method is essentially the same as the <code class="literal">abc</code> method except it specifies a fourth formal block-typed argument (<code class="literal">&amp;d</code>):</p><a id="I_programlisting10_d1e12396"/><pre class="programlisting">def abc3( a, b, c, &amp;d)</pre><p>The arguments <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code> are called, while the argument <code class="literal">&amp;d</code> may be either called or yielded, as you prefer:</p><a id="I_programlisting10_d1e12412"/><pre class="programlisting">def abc3( a, b, c, &amp;d)
    a.call
    b.call
    c.call
    d.call        # first call block &amp;d
    yield         # then yield block &amp;d
end</pre><p>This means the calling code must pass to this method three formal arguments plus a block, which may be nameless:</p><a id="I_programlisting10_d1e12416"/><pre class="programlisting">abc3(a, b, c){ puts "five" }</pre><p>The previous method call would result in this output (bearing in mind that the final block argument is executed twice since it is both called and yielded):</p><a id="I_programlisting10_d1e12421"/><pre class="programlisting">one
two
three
five
five</pre><p>You can also use a preceding ampersand in order to pass a named block to a method when the receiving method has no matching named argument, like this:</p><a id="I_programlisting10_d1e12425"/><pre class="programlisting">myproc = proc{ puts("my proc") }
abc3(a, b, c, &amp;myproc )</pre><p>An ampersand block variable such as <code class="literal">&amp;myproc</code> in the previous code may be passed to a method even if that method does not declare a matching variable in its argument list. This gives you the choice of passing either an unnamed block or a Proc object:</p><a id="I_programlisting10_d1e12432"/><pre class="programlisting">xyz{ |a,b,c| puts(a+b+c) }
xyz( &amp;myproc )</pre><p>Be careful, however! Notice in one of the previous examples, I have used block parameters (<code class="literal">|a,b,c|</code>) with the same names as the three local variables to which I previously assigned Proc objects: <code class="literal">a</code>, <code class="literal">b</code>, <code class="literal">c</code>:<a id="IDX-CHP-10-0057" class="indexterm"/><a id="IDX-CHP-10-0058" class="indexterm"/><a id="IDX-CHP-10-0059" class="indexterm"/></p><a id="I_programlisting10_d1e12462"/><pre class="programlisting">a = lambda{ puts "one" }
b = lambda{ puts "two" }
c = proc{ puts "three" }
xyz{ |a,b,c| puts(a+b+c) }</pre><p>In principle, block parameters should be visible only within the block itself. However, it turns out that assignment to block parameters has profoundly different effects in Ruby 1.8 and Ruby 1.9. Let’s look first at Ruby 1.8. Here, assignment to block parameters can initialize the values of any local variables with the same name within the block’s native scope (see <a class="xref" href="ch10s09.html" title="What Is a Closure?">What Is a Closure?</a> in <a class="xref" href="ch10s09.html" title="What Is a Closure?">What Is a Closure?</a>).</p><p>Even though the variables in the <code class="literal">xyz</code> method are named <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code>, it turns out that the integer assignments in that method are actually made to the variables <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code> when this block:</p><a id="I_programlisting10_d1e12494"/><pre class="programlisting">{ |a,b,c| puts(a+b+c) }</pre><p>is passed the values of <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code>:</p><a id="I_programlisting10_d1e12508"/><pre class="programlisting">def xyz
    x = 1
    y = 2
    z = 3
    yield( x, y, z )   # 1,2,3 assigned to block parameters a,b,c
end</pre><p>As a consequence, the Proc variables <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code> within the block’s native scope (the main scope of my program) are initialized with the integer values of the block variables <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> once the code in the block has been run. So, <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code>, which began as Proc objects, end up as integers.<a id="IDX-CHP-10-0060" class="indexterm"/></p><p>In Ruby 1.9, on the contrary, the variables inside the block are sealed off from the variables declared outside the block. So, the values of the <code class="literal">xyz</code> method’s <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> variables are not assigned to the block’s <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code> parameters. That means once the block has executed, the values of the <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code> variables declared outside that method are unaffected: They began as Proc objects, and they end up as Proc objects.</p><p>Now let’s suppose you execute the following code, remembering that <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code> are Proc objects at the outset:</p><a id="I_programlisting10_d1e12589"/><pre class="programlisting">xyz{ |a,b,c| puts(a+b+c) }
puts( a, b, c )</pre><p>In Ruby 1.8, the <code class="literal">puts</code> statement shown earlier displays the end values of <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code>, showing that they have been initialized with the integer values that were passed into the block when it was yielded (<code class="literal">yield( x, y, z )</code>) in the <code class="literal">xyz</code> method. As a consequence, they are now integers:</p><a id="I_programlisting10_d1e12612"/><pre class="programlisting">1
2
3</pre><p>But in Ruby 1.9, <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code> are not initialized by the block parameters and remain, as they began, as Proc objects:</p><a id="I_programlisting10_d1e12625"/><pre class="programlisting">#&lt;Proc:0x2b65828@C:/bookofruby/ch10/5blocks.rb:36 (lambda)&gt;
#&lt;Proc:0x2b65810@C:/bookofruby/ch10/5blocks.rb:37 (lambda)&gt;
#&lt;Proc:0x2b657f8@C:/bookofruby/ch10/5blocks.rb:38&gt;</pre><p>This behavior can be difficult to understand, but it is worth taking the time to do so. The use of blocks is commonplace in Ruby, and it is important to know how the execution of a block may (or may not) affect the values of variables declared outside the block. To clarify this, try the simple program in <span class="emphasis"><em>6blocks.rb</em></span>:</p><p><span class="emphasis"><em>6blocks.rb</em></span></p><a id="I_programlisting10_d1e12636"/><pre class="programlisting">a = "hello world"

def foo
    yield 100
end

puts( a )
foo{ |a| puts( a ) }

puts( a )</pre><p>Here <code class="literal">a</code> is a string within the scope of the main program. A different variable with the same name, <code class="literal">a</code>, is declared in the block, which is passed to <code class="literal">foo</code> and yielded. When it is yielded, an integer value, 100, is passed into the block, causing the block’s parameter, <code class="literal">a</code>, to be initialized to 100. The question is, does the initialization of the block argument, <code class="literal">a</code>, also initialize the string variable, <code class="literal">a</code>, in the main scope? And the answer is, <span class="emphasis"><em>yes</em></span> in Ruby 1.8 but <span class="emphasis"><em>no</em></span> in Ruby 1.9.</p><p>Ruby 1.8 displays this:</p><a id="I_programlisting10_d1e12667"/><pre class="programlisting">hello world
100
100</pre><p>Ruby 1.9 displays this:</p><a id="I_programlisting10_d1e12671"/><pre class="programlisting">hello world
100
hello world</pre><p>If you want to make sure that block parameters do not alter the values of variables declared outside the block, no matter which version of Ruby you use, just ensure that the block parameter names do not duplicate names used elsewhere. In the current program, you can do this simply by changing the name of the block argument to ensure that it is unique to the block:<a id="IDX-CHP-10-0061" class="indexterm"/><a id="IDX-CHP-10-0062" class="indexterm"/></p><a id="I_programlisting10_d1e12683"/><pre class="programlisting">foo{ |b| puts( b ) }    # the name 'b' is not used elsewhere</pre><p>This time, when the program is run, Ruby 1.8 and Ruby 1.9 both produce the same results:</p><a id="I_programlisting10_d1e12687"/><pre class="programlisting">hello world
100
hello world</pre><p>This is an example of one of the pitfalls into which it is all too easy to fall in Ruby. As a general rule, when variables share the same scope (for example, a block declared within the scope of the main program here), it is best to make their names unique in order to avoid any unforeseen side effects. For more on scoping, see <a class="xref" href="ch10s14.html#digging_deeper-id9" title="Digging Deeper">Digging Deeper</a> in <a class="xref" href="ch10s14.html#digging_deeper-id9" title="Digging Deeper">Digging Deeper</a>.</p></div>
<div class="sect1" title="Precedence Rules"><div class="titlepage"><div><div><h1 class="title"><a id="precedence_rules"/>Precedence Rules</h1></div></div></div><p>Blocks within curly brackets have stronger precedence than blocks within <code class="literal">do</code> and <code class="literal">end</code>. Let’s see what that means in practice. Consider these two examples:<a id="IDX-CHP-10-0063" class="indexterm"/></p><a id="I_programlisting10_d1e12711"/><pre class="programlisting">foo bar do |s| puts( s ) end
foo bar{ |s| puts(s) }</pre><p>Here, <code class="literal">foo</code> and <code class="literal">bar</code> are both methods, and the code between curly brackets and <code class="literal">do</code> and <code class="literal">end</code> are blocks. So, to which of the two methods is each of these blocks passed? It turns out that the <code class="literal">do..end</code> block would be passed to the leftmost method, <code class="literal">foo</code>, whereas the block in curly brackets would be sent to the rightmost method, <code class="literal">bar</code>. This is because curly brackets are said to have higher precedence than <code class="literal">do</code> and <code class="literal">end</code>.</p><p>Consider this program:</p><p><span class="emphasis"><em>precedence.rb</em></span></p><a id="I_programlisting10_d1e12748"/><pre class="programlisting">def foo( b )
    puts("---in foo---")
    a = 'foo'
    if block_given?
        puts( "(Block passed to foo)" )
        yield( a )
    else
        puts( "(no block passed to foo)" )
    end
    puts( "in foo, arg b = #{b}" )
    return "returned by " &lt;&lt; a
end

def bar
    puts("---in bar---")
    a = 'bar'
    if block_given?
        puts( "(Block passed to bar)" )
        yield( a )
    else
        puts( "(no block passed to bar)" )
    end
    return "returned by " &lt;&lt; a
end

foo bar do |s| puts( s ) end       # 1) do..end block
foo bar{ |s| puts(s) }             # 2) {..} block</pre><p>Here the <code class="literal">do..end</code> block has lower precedence, and the method <code class="literal">foo</code> is given priority. This means both <code class="literal">bar</code> and the <code class="literal">do..end</code> block are passed to <code class="literal">foo</code>. Thus, these two expressions are equivalent:</p><a id="I_programlisting10_d1e12767"/><pre class="programlisting">foo bar do |s| puts( s ) end
foo( bar ) do |s| puts( s ) end</pre><p>A curly bracket block, on the other hand, has stronger precedence, so it tries to execute immediately and is passed to the first possible receiver method (<code class="literal">bar</code>). The result (that is, the value returned by <code class="literal">bar</code>) is then passed as an argument to <code class="literal">foo</code>, but this time, <code class="literal">foo</code> does not receive the block itself. Thus, the two following expressions are equivalent:</p><a id="I_programlisting10_d1e12783"/><pre class="programlisting">foo bar{ |s| puts(s) }
foo( bar{ |s| puts(s) } )</pre><p>If you are confused by all this, take comfort in that you are not alone! The potential ambiguities result from the fact that, in Ruby, the parentheses around argument lists are optional. As you can see from the alternative versions I gave earlier, the ambiguities disappear when you use parentheses.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>A method can test whether it has received a block using the <code class="literal">block_given?</code> method. You can find examples of this in the <span class="emphasis"><em>precedence.rb</em></span> program.<a id="IDX-CHP-10-0064" class="indexterm"/></p></div></div>
<div class="sect1" title="Blocks as Iterators"><div class="titlepage"><div><div><h1 class="title"><a id="blocks_as_iterators"/>Blocks as Iterators</h1></div></div></div><p>As mentioned earlier, one of the primary uses of blocks in Ruby is to provide iterators to which a range or list of items can be passed. Many standard classes such as Integer and Array have methods that can supply items over which a block can iterate. For example:<a id="IDX-CHP-10-0065" class="indexterm"/></p><a id="I_programlisting10_d1e12810"/><pre class="programlisting">3.times{ |i| puts( i ) }
[1,2,3].each{|i| puts(i) }</pre><p>You can, of course, create your own iterator methods to provide a series of values to a block. In the <span class="emphasis"><em>iterate1.rb</em></span> program, I have defined a simple <code class="literal">timesRepeat</code> method that executes a block a specified number of times. This is similar to the <code class="literal">times</code> method of the Integer class except it begins at index 1 rather than at index 0 (here the variable <code class="literal">i</code> is displayed in order to demonstrate this):</p><p><span class="emphasis"><em>iterate1.rb</em></span></p><a id="I_programlisting10_d1e12829"/><pre class="programlisting">def timesRepeat( aNum )
    for i in 1..aNum do
        yield i
    end
end</pre><p>Here is an example of how this method might be called:</p><a id="I_programlisting10_d1e12833"/><pre class="programlisting">timesRepeat( 3 ){  |i| puts("[#{i}] hello world") }</pre><p>This displays the following:</p><a id="I_programlisting10_d1e12837"/><pre class="programlisting">[1] hello world
[2] hello world
[3] hello world</pre><p>I’ve also created a <code class="literal">timesRepeat2</code> method to iterate over an array:</p><a id="I_programlisting10_d1e12845"/><pre class="programlisting">def timesRepeat2( aNum, anArray )
    anArray.each{ |anitem|
        yield( anitem )
    }
end</pre><p>This could be called in this manner:</p><a id="I_programlisting10_d1e12849"/><pre class="programlisting">timesRepeat2( 3, ["hello","good day","how do you do"] ){ |x| puts(x) }</pre><p>This displays the following:</p><a id="I_programlisting10_d1e12853"/><pre class="programlisting">hello
good day
how do you do</pre><p>Of course, it would be better (truer to the spirit of object orientation) if an object itself contained its own iterator method. I’ve implemented this in the next example. Here I have created MyArray, a subclass of Array:</p><a id="I_programlisting10_d1e12857"/><pre class="programlisting">class MyArray &lt; Array</pre><p>It is initialized with an array when a new MyArray object is created:</p><a id="I_programlisting10_d1e12861"/><pre class="programlisting">def initialize( anArray )
    super( anArray )
end</pre><p>It relies upon its own <code class="literal">each</code> method (an object refers to itself as <code class="literal">self</code>), which is provided by its ancestor, Array, to iterate over the items in the array, and it uses the <code class="literal">times</code> method of Integer to do this a certain number of times. This is the complete class definition:</p><p><span class="emphasis"><em>iterate2.rb</em></span></p><a id="I_programlisting10_d1e12878"/><pre class="programlisting">class MyArray &lt; Array
    def initialize( anArray )
        super( anArray )
    end

    def timesRepeat( aNum )
        aNum.times{           # start block 1...
             | num |
             self.each{       # start block 2...
                  | anitem |
                  yield( "[#{num}] :: '#{anitem}'" )
             }                # ...end block 2
        }                     # ...end block 1
    end
end</pre><p>Notice that, because I have used two iterators (<code class="literal">aNum.times</code> and <code class="literal">self.each</code>), the <code class="literal">timesRepeat</code> method comprises two nested blocks. This is an example of how you might use this:</p><a id="I_programlisting10_d1e12891"/><pre class="programlisting">numarr = MyArray.new( [1,2,3] )
numarr.timesRepeat( 2  ){ |x| puts(x) }</pre><p>This would output the following:</p><a id="I_programlisting10_d1e12895"/><pre class="programlisting">[0] :: '1'
[0] :: '2'
[0] :: '3'
[1] :: '1'
[1] :: '2'
[1] :: '3'</pre><p>In <span class="emphasis"><em>iterate3.rb</em></span>, I have set myself the problem of defining an iterator for an array containing an arbitrary number of subarrays, in which each subarray has the same number of items. In other words, it will be like a table or matrix with a fixed number of rows and a fixed number of columns. Here, for example, is a multidimensional array with three “rows” (subarrays) and four “columns” (items):</p><p><span class="emphasis"><em>iterate3.rb</em></span></p><a id="I_programlisting10_d1e12905"/><pre class="programlisting">multiarr =
[ ['one','two','three','four'],
  [1,    2,    3,      4     ],
  [:a,   :b,   :c,    :d     ]
]</pre><p>I’ve tried three alternative versions of this. The first version suffers from the limitation of only working with a predefined number (here 2 at indexes [0] and [1]) of “rows” so it won’t display the symbols in the third row:</p><a id="I_programlisting10_d1e12909"/><pre class="programlisting">multiarr[0].length.times{|i|
    puts(multiarr[0][i], multiarr[1][i])
}</pre><p>The second version gets around this limitation by iterating over each element (or “row”) of <code class="literal">multiarr</code> and then iterating along each item in that row by obtaining the row length and using the Integer’s <code class="literal">times</code> method with that value. As a result, it displays the data from all three rows:</p><a id="I_programlisting10_d1e12920"/><pre class="programlisting">multiarr.each{ |arr|
    multiarr[0].length.times{|i|
        puts(arr[i])
    }
}</pre><p>The third version reverses these operations: The outer block iterates along the length of row 0, and the inner block obtains the item at index <code class="literal">i</code> in each row. Once again, this displays the data from all three rows:</p><a id="I_programlisting10_d1e12927"/><pre class="programlisting">multiarr[0].length.times{|i|
    multiarr.each{ |arr|
        puts(arr[i])
    }
}</pre><p>However, although versions 2 and 3 work in a similar way, you will find that they iterate through the items in a different order. Version 2 iterates through each complete row one at a time. Version 3 iterates down the items in each column. Run the program to verify that. You could try creating your own subclass of Array and adding iterator methods like this—one method to iterate through the rows in sequence and one to iterate through the columns.</p><div class="sidebar"><a id="digging_deeper-id9"/><p class="title">Digging Deeper</p><p>Here we look at important differences between block scoping in Ruby 1.8 and 1.9 and also learn about returning blocks from methods.<a id="IDX-CHP-10-0066" class="indexterm"/><a id="IDX-CHP-10-0067" class="indexterm"/></p><p><span class="bolditalic">Returning Blocks from Methods</span></p><p>Earlier, I explained that blocks in Ruby may act as closures. A closure may be said to enclose the “environment” in which it is declared. Or, to put it another way, it carries the values of local variables from its original scope into a different scope. The example I gave previously showed how the block named <code class="literal">ablock</code> captures the value of the local variable <code class="literal">x</code>:</p><p><span class="emphasis"><em>block_closure.rb</em></span></p><a id="I_programlisting10_d1e12960"/><pre class="programlisting">x = "hello world"
ablock = Proc.new { puts( x ) }</pre><p>It is then able to “carry” that variable into a different scope. Here, for example, <code class="literal">ablock</code> is passed to <code class="literal">aMethod</code>. When <code class="literal">ablock</code> is called inside that method, it runs the code <code class="literal">puts( x )</code>. This displays “hello world” and not “goodbye”:</p><a id="I_programlisting10_d1e12976"/><pre class="programlisting">def aMethod( aBlockArg )
    x = "goodbye"
    aBlockArg.call            #=&gt; "hello world"
end</pre><p>In this particular example, this behavior may seem like a curiosity of no great interest. In fact, block/closures can be used more creatively.</p><p>For example, instead of creating a block and sending it to a method, you could create a block <span class="emphasis"><em>inside a method</em></span> and return that block to the calling code. If the method in which the block is created happens to take an argument, the block could be initialized with that argument.</p><p>This gives you a simple way of creating multiple blocks from the same “block template,” each instance of which is initialized with different data. Here, for example, I have created two blocks and assigned them to the variables <code class="literal">salesTax</code> and <code class="literal">vat</code>, each of which calculates results based on different values (0.10) and (0.175):</p><p><span class="emphasis"><em>block_closure2.rb</em></span></p><a id="I_programlisting10_d1e12997"/><pre class="programlisting">def calcTax( taxRate )
    return lambda{
        |subtotal|
            subtotal * taxRate
    }
end

salesTax = calcTax( 0.10 )
vat = calcTax( 0.175 )

print( "Tax due on book = ")
print( salesTax.call( 10 ) )       #=&gt; 1.0

print( "\nVat due on DVD = ")
print( vat.call( 10 ) )            #=&gt; 1.75</pre><p><span class="bolditalic">Blocks and Instance Variables</span></p><p>One of the less obvious features of blocks is the way in which they use variables. If a block may truly be regarded as a nameless function or method, then, logically, it should be able to contain its own local variables and have access to the instance variables of the object to which the block belongs.<a id="IDX-CHP-10-0068" class="indexterm"/></p><p>Let’s look first at instance variables. Load the <span class="emphasis"><em>closures1.rb</em></span> program. This provides another illustration of a block acting as a closure—by capturing the values of the local variables in the scope in which it was created. Here I have created a block using the <code class="literal">lambda</code> method:</p><p><span class="emphasis"><em>closures1.rb</em></span></p><a id="I_programlisting10_d1e13020"/><pre class="programlisting">aClos = lambda{
    @hello &lt;&lt; " yikes!"
}</pre><p>This block appends the string “ yikes!” to the instance variable <code class="literal">@hello</code>. Notice that at this stage in the proceedings, no value has previously been assigned to <code class="literal">@hello</code>. I have, however, created a separate method, <code class="literal">aFunc</code>, which does assign a value to a variable called <code class="literal">@hello</code>:</p><a id="I_programlisting10_d1e13036"/><pre class="programlisting">def aFunc( aClosure )
    @hello = "hello world"
    aClosure.call
end</pre><p>When I pass my block (the <code class="literal">aClosure</code> argument) to the <code class="literal">aFunc</code> method, the method brings <code class="literal">@hello</code> into being. I can now execute the code inside the block using the <code class="literal">call</code> method. And sure enough, the <code class="literal">@hello</code> variable contains the “hello world” string. The same variable can also be used by calling the block outside of the method. Indeed, now, by repeatedly calling the block, I will end up repeatedly appending the string “ yikes!” to <code class="literal">@hello</code>:</p><a id="I_programlisting10_d1e13059"/><pre class="programlisting">aFunc(aClos)      #&lt;= @hello = "hello world yikes!"
aClos.call        #&lt;= @hello = "hello world yikes! yikes!"
aClos.call        #&lt;= @hello = "hello world yikes! yikes! yikes!"
aClos.call        # ...and so on</pre><p>If you think about it, this is not too surprising. After all, <code class="literal">@hello</code> is an instance variable, so it exists within the scope of an object. When you run a Ruby program, an object called <code class="literal">main</code> is automatically created. So, you should expect any instance variable created within that object (the program) to be available to everything inside it.</p><p>The question now arises: What would happen if you were to send the block to a method of some <span class="emphasis"><em>other</em></span> object? If that object has its own instance variable, <code class="literal">@hello</code>, which variable will the block use—the <code class="literal">@hello</code> from the scope in which the block was created or the <code class="literal">@hello</code> from the scope of the object in which the block is called? Let’s try that. You’ll use the same block as before, except this time it will display a bit of information about the object to which the block belongs and the value of <code class="literal">@hello</code>:<a id="IDX-CHP-10-0069" class="indexterm"/><a id="IDX-CHP-10-0070" class="indexterm"/></p><a id="I_programlisting10_d1e13098"/><pre class="programlisting">aClos = lambda{
    @hello &lt;&lt; " yikes!"
    puts("in #{self} object of class #{self.class}, @hello = #{@hello}")
}</pre><p>Now, create a new object from a new class (X), and give it a method that will receive the block <code class="literal">b</code> and call the block:</p><a id="I_programlisting10_d1e13105"/><pre class="programlisting">class X
    def y( b )
        @hello = "I say, I say, I say!!!"
        puts( "   [In X.y]" )
        puts("in #{self} object of class #{self.class}, @hello = #{@hello}")
        puts( "   [In X.y] when block is called..." )
        b.call
    end
end

x = X.new</pre><p>To test it, just pass the block <code class="literal">aClos</code> to the <code class="literal">y</code> method of <code class="literal">x</code>:</p><a id="I_programlisting10_d1e13118"/><pre class="programlisting">x.y( aClos )</pre><p>And this is what is displayed:</p><a id="I_programlisting10_d1e13122"/><pre class="programlisting">[In X.y]
in #&lt;X:0x32a6e64&gt; object of class X, @hello = I say, I say, I say!!!
    [In X.y] when block is called...
in main object of class Object, @hello = hello world yikes! yikes! yikes!
 yikes! yikes! yikes!</pre><p>So, it is clear that the block executes in the scope of the object in which it was <span class="emphasis"><em>created</em></span> (<code class="literal">main</code>) and retains the instance variable from that object even though the object in whose scope the block is <span class="emphasis"><em>called</em></span> has an instance variable with the same name and a different value.</p><p><span class="bolditalic">Blocks and Local Variables</span></p><p>Now let’s see how a block/closure deals with local variables. In the <span class="emphasis"><em>closures2.rb</em></span> program, I declare a variable, <code class="literal">x</code>, which is local to the context of the program:</p><p><span class="emphasis"><em>closures2.rb</em></span></p><a id="I_programlisting10_d1e13150"/><pre class="programlisting">x = 3000</pre><p>The first block/closure is called <code class="literal">c1</code>. Each time I call this block, it picks up the value of <code class="literal">x</code> defined outside the block (3,000) and returns <code class="literal">x + 100</code>:</p><a id="I_programlisting10_d1e13163"/><pre class="programlisting">c1 = proc{
    x + 100
}</pre><p>Incidentally, even though this returns a value (in ordinary Ruby methods, the default value is the result of the last expression to be evaluated), in Ruby 1.9 you cannot explicitly use the <code class="literal">return</code> statement here like this:</p><a id="I_programlisting10_d1e13170"/><pre class="programlisting">return x + 1</pre><p>If you do this, Ruby 1.9 throws a LocalJumpError exception. Ruby 1.8, on the other hand, does not throw an exception.<a id="IDX-CHP-10-0071" class="indexterm"/></p><p>This block has no block parameters (that is, there are no “block-local” variables between upright bars), so when it is called with a variable, <code class="literal">someval</code>, that variable is discarded, unused. In other words, <code class="literal">c1.call(someval)</code> has the same effect as <code class="literal">c1.call()</code>.</p><p>So, when you call the block <code class="literal">c1</code>, it returns <code class="literal">x+100</code> (that is, 3,100); this value is then assigned to <code class="literal">someval</code>. When you call <code class="literal">c1</code> a second time, the same thing happens all over again, so once again <code class="literal">someval</code> is assigned 3,100:</p><a id="I_programlisting10_d1e13205"/><pre class="programlisting">someval=1000
someval=c1.call(someval); puts(someval)    #&lt;= someval is now 3100
someval=c1.call(someval); puts(someval)    #&lt;= someval is now 3100</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Instead of repeating the call to <code class="literal">c1</code>, as shown earlier, you could place the call inside a block and pass this to the <code class="literal">times</code> method of Integer like this:<a id="IDX-CHP-10-0072" class="indexterm"/></p></div><a id="I_programlisting10_d1e13220"/><pre class="programlisting">2.times{ someval=c1.call(someval); puts(someval) }</pre><p><span class="emphasis"><em>However, because it can be hard enough to work out what just one block is up to (such as the</em></span> <em class="replaceable"><code>c1</code></em> <span class="emphasis"><em>block here), I’ve deliberately avoided using any more blocks than are absolutely necessary in this program!</em></span></p><p>The second block is named <code class="literal">c2</code>. This declares the “block parameter” <code class="literal">z</code>. This too returns a value:</p><a id="I_programlisting10_d1e13239"/><pre class="programlisting">c2 = proc{
    |z|
    z + 100
}</pre><p>However, this time the returned value can be reused since the block parameter acts like an incoming argument to a method—so when the value of <code class="literal">someval</code> is changed after it is assigned the return value of <code class="literal">c2</code>, this changed value is subsequently passed as an argument:</p><a id="I_programlisting10_d1e13249"/><pre class="programlisting">someval=1000
someval=c2.call(someval); puts(someval)      #&lt;= someval is now 1100
someval=c2.call(someval); puts(someval)      #&lt;= someval is now 1200</pre><p>The third block, <code class="literal">c3</code>, looks, at first sight, pretty much the same as the second block, <code class="literal">c2</code>. In fact, the only difference is that its block parameter is called <code class="literal">x</code> instead of <code class="literal">z</code>:</p><a id="I_programlisting10_d1e13265"/><pre class="programlisting">c3 = proc{
    |x|
    x + 100
}</pre><p>The name of the block parameter has no effect on the return value. As before, <code class="literal">someval</code> is first assigned the value 1,100 (that is, its original value, 1,000, plus the 100 added inside the block). Then, when the block is called a second time, <code class="literal">someval</code> is assigned the value 1,200 (its previous value, 1,100, plus 100 assigned inside the block).</p><p>But now look at what happens to the value of the local variable <code class="literal">x</code>. This was assigned 3,000 at the top of the unit. Remember that, in Ruby 1.8, an assignment to a block parameter can change the value of a variable with the same name in its surrounding context. In Ruby 1.8, then the local variable <code class="literal">x</code> changes when the block parameter <code class="literal">x</code> is changed. It now has the value, 1,100—that is, the value that the block parameter, <code class="literal">x</code>, last had when the <code class="literal">c3</code> block was called:</p><a id="I_programlisting10_d1e13293"/><pre class="programlisting">x = 3000
someval=1000
someval=c3.call(someval); puts(someval)    #=&gt; 1100
someval=c3.call(someval); puts(someval)    #=&gt; 1200
puts( x ) # Ruby 1.8, x = 1100. Ruby 1.9, x = 3000</pre><p>Incidentally, even though block-local variables and block parameters can affect similarly named local variables outside the block in Ruby 1.8, the block variables themselves have no “existence” outside the block. You can verify this using the <code class="literal">defined?</code> keyword to attempt to display the type of variable if it is, indeed, defined:<a id="IDX-CHP-10-0073" class="indexterm"/><a id="IDX-CHP-10-0074" class="indexterm"/><a id="IDX-CHP-10-0075" class="indexterm"/><a id="IDX-CHP-10-0076" class="indexterm"/><a id="IDX-CHP-10-0077" class="indexterm"/></p><a id="I_programlisting10_d1e13321"/><pre class="programlisting">print("x=[#{defined?(x)}],z=[#{defined?(z)}]")</pre><p>This demonstrates that only <code class="literal">x</code>, and not the block variable <code class="literal">z</code>, is defined in the main scope:<a id="IDX-CHP-10-0078" class="indexterm"/><a id="IDX-CHP-10-0079" class="indexterm"/><a id="IDX-CHP-10-0080" class="indexterm"/></p><a id="I_programlisting10_d1e13346"/><pre class="programlisting">x=[local-variable], z=[]</pre><p>Matz, the creator of Ruby, has described the scoping of local variables within a block as “regrettable.” Although Ruby 1.9 has addressed some issues, it is worth noting that one other curious feature of block scoping remains: Namely, local variables within a block are invisible to the method containing that block. This may be changed in future versions. For an example of this, look at this code:</p><p><span class="emphasis"><em>local_var_scope.rb</em></span></p><a id="I_programlisting10_d1e13353"/><pre class="programlisting">def foo
    a = 100
    [1,2,3].each do |b|
        c = b
        a = b
        print("a=#{a}, b=#{b}, c=#{c}\n")
    end
    print("Outside block: a=#{a}\n")    # Can't print #{b} and #{c} here!!!
end</pre><p>Here, the block parameter, <code class="literal">b</code>, and the block-local variable, <code class="literal">c</code>, are both visible only when inside the block. The block has access to both these variables and to the variable <code class="literal">a</code> (local to the <code class="literal">foo</code> method). However, outside of the block, <code class="literal">b</code> and <code class="literal">c</code> are inaccessible, and only <code class="literal">a</code> is visible.</p><p>Just to add to the confusion, whereas the block-local variable, <code class="literal">c</code>, and the block parameter, <code class="literal">b</code>, are both inaccessible outside the block in the previous example, they are accessible when you iterate a block with <code class="literal">for</code>, as in the following example:</p><a id="I_programlisting10_d1e13390"/><pre class="programlisting">def foo2
    a = 100
    for b in [1,2,3] do
        c = b
        a = b
        print("a=#{a}, b=#{b}, c=#{c}\n")
    end
    print("Outside block: a=#{a}, b=#{b}, c=#{b}\n")
end</pre></div></div></body></html>