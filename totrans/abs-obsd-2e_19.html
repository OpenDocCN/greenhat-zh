<html><head></head><body><section class="chapter" epub:type="chapter" id="building_custom_kernels" title="Chapter&#xA0;19.&#xA0;Building Custom Kernels"><div class="titlepage"><div><div><h2 class="title">Chapter 19. Building Custom Kernels</h2></div></div></div><div class="epigraph" epub:type="epigraph"><div class="literallayout"><p><span class="emphasis"><em>Rewiring the brain?</em></span><br/>
<span class="emphasis"><em>Knowing where the parts plug in</em></span><br/>
<span class="emphasis"><em>makes it possible.</em></span></p></div></div><p><a class="indexterm" id="idx0322"/><a class="indexterm" id="idx0324"/><span class="inlinemediaobject"><a id="inline_id00020"/><img alt="" src="httpatomoreillycomsourcenostarchimages1616079.png"/></span> The OpenBSD team works very hard to provide a high-quality kernel that requires no tweaking beyond setting the occasional sysctl or perhaps enabling a feature. But if you want to use an experimental feature or add a device driver to the kernel, or you want to squeeze OpenBSD into tiny hardware or embedded systems, you’ll need to build a custom kernel from source code. The OpenBSD people won’t support you if you venture into custom kernels, but they’ll provide you with everything you need to shoot yourself in the foot, as you’ll learn in this chapter.</p><div class="sect1" title="Kernel Cautions"><div class="titlepage"><div><div><h2 class="title" id="kernel_cautions" style="clear: both">Kernel Cautions</h2></div></div></div><p>Before we get into the details of building custom kernels, we’ll look at why that’s usually a bad idea.</p><div class="sect2" title="Don’t Build Custom Kernels"><div class="titlepage"><div><div><h3 class="title" id="dont_build_custom_kernels">Don’t Build Custom Kernels</h3></div></div></div><p><a class="indexterm" id="idx0335"/><a class="indexterm" id="idx0911"/><a class="indexterm" id="idx1152"/>Many open source operating systems encourage sysadmins to build custom kernels. Mailing lists for these operating systems are full of suggestions on rebuilding, tweaking, and modifying the kernel. Those user communities will walk new users through rebuilding the kernel.</p><p>OpenBSD developers take a different approach to rebuilding the kernel. They ship a default kernel, called GENERIC, which you will almost never need to rebuild.</p><p>Building a kernel from source doesn’t prove that you’re an alpha geek, and rebuilding the kernel is never a recommended way to solve a problem. The people who build custom kernels are either kernel developers or ignorant newbies. The OpenBSD Project members feel no particular obligation to help users with customized kernels. If your custom kernel crashes, destroys your filesystem, or starts making threatening calls to the local constabulary, they won’t care. Why? Adding, moving, or changing one kernel option might seem trivial, but each option might represent tens of thousands of lines of source code that you’ve just casually gutted.</p><p>That said, the OpenBSD Project is much friendlier than closed source operating systems, in that it provides the source code for the kernel, and gives you the tools and instructions needed to build it. The territory might be dangerous, with rattlesnakes and bears and the occasional bottomless pit, but they give you a map and a flashlight. If you can carve out some new territory for yourself, good for you! If you get eaten by coyotes, well, that’s pretty much what happens.</p><div class="note" title="Note"><h3 class="title"><a id="ch19note01"/>Note</h3><p>These warnings apply only to custom kernels. The OpenBSD team is extremely interested in problems in a provided kernel, whether that’s the GENERIC kernel, the installer kernel, or any other.</p></div><p>When working with kernels, keep in mind that some platforms have multiple GENERIC kernels. For example, the i386 platform has the standard GENERIC kernel, but it provides GENERIC.MP for multiprocessor machines, and it supports both versions. By the same token, the SGI platform has several GENERIC kernels—one for each supported hardware variety. These kernels are all GENERIC, and all supported.</p></div><div class="sect2" title="Why Build Custom Kernels?"><div class="titlepage"><div><div><h3 class="title" id="why_build_custom_kernels">Why Build Custom Kernels?</h3></div></div></div><p>People build custom kernels for various reasons. For example, if you’re a kernel developer, or aspire to be one, you will need to build customized kernels to test new features and new code.</p><p>Some people who play with kernels are interested in using experimental features. For example, OpenBSD supports the newly developed but not well-tested multipath SCSI, which is not supported by GENERIC. Not many people have the hardware to use multipath SCSI, but those who do have the hardware, along with programming skills, are encouraged to help improve this feature. (When running experimental features, be sure that you understand that <span class="emphasis"><em>experimental</em></span> is the Siamese twin of <span class="emphasis"><em>unstable</em></span>.)</p><p><a class="indexterm" id="idx0333"/><a class="indexterm" id="idx1383"/>Rarely, remediating a security flaw will require a patch to the kernel source code. But rather than build your own, get the patch from OpenBSD’s stable branch or a snapshot (discussed in <a class="xref" href="ch20.html" title="Chapter 20. Upgrading">Chapter 20</a>).</p><p>Finally, some people will build custom kernels to save RAM on a machine with very low memory. Removing features from the kernel reduces its size.</p></div><div class="sect2" title="Problems Building Custom Kernels"><div class="titlepage"><div><div><h3 class="title" id="problems_building_custom_kernels">Problems Building Custom Kernels</h3></div></div></div><p>When building a custom kernel, you are likely to run into trouble. For one, the interdependencies between kernel modules are quite complex and not thoroughly documented. The developers generally assume that people building custom kernels will read kernel source code and man pages. You are expected to read error messages and sort them out yourself.</p><p>OpenBSD’s cross-platform design slightly complicates kernel configuration. Some devices run on some architectures, but they fail to run or behave weirdly on others. If you include the wrong device in your kernel or tell the kernel a card is attached to the wrong bus, you’ll be building a busted kernel. Be sure that you understand how your hardware actually fits together.</p><p>When mucking around in the source tree, you can corrupt the source code in various ways, such as by applying a patch incorrectly, scrambling a file, or forgetting that you edited a file that is now causing you grief. To test your source code, compile GENERIC. If GENERIC won’t compile, you’ve either mucked up the source code or your system has some deeper problem.</p><p>Building a custom kernel usually means including or removing kernel options and features from the configuration file. If you’re trying to use fancy compiler flags, however, stop. Custom compiler options are great for exposing compiler bugs, but the OpenBSD team members make no effort to have their code comply with the demands from these compiler options. Many of these options and higher optimizations break if you’re not running very specific operating systems on very specific architectures. The kernel code assumes that you are using the specified compiler options; if you change them, you’ll get nothing but pain.</p><p>If you’ve checked everything, and you still can’t get your kernel to build, you might don your flameproof suit and ask for help on <span class="emphasis"><em>misc@OpenBSD.org</em></span>. State up front that you’re trying to build a custom kernel, and include the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Your kernel configuration</p></li><li class="listitem"><p>OpenBSD version</p></li><li class="listitem"><p>Unedited boot-time messages from booting a GENERIC kernel on your computer</p></li><li class="listitem"><p>A full description of the problem</p></li></ul></div><p>Someone might take pity and try to help you.</p></div><div class="sect2" title="Problems Running Custom Kernels"><div class="titlepage"><div><div><h3 class="title" id="problems_running_custom_kernels">Problems Running Custom Kernels</h3></div></div></div><p><a class="indexterm" id="idx0106"/><a class="indexterm" id="idx0332"/><a class="indexterm" id="idx0334"/><a class="indexterm" id="idx0912"/><a class="indexterm" id="idx1153"/><a class="indexterm" id="idx2195"/>Custom kernels can have any number of problems, such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Programs might not run as expected.</p></li><li class="listitem"><p>The system might not boot.</p></li><li class="listitem"><p>The system might crash randomly.</p></li><li class="listitem"><p>The kernel might not find all of your hardware.</p></li><li class="listitem"><p>The kernel might eat your hard drives or your motherboard (without mustard or even a shot of malt vinegar).</p></li></ul></div><p>If you have customized your kernel narrowly—say, by adding only the multipath SCSI driver to the GENERIC kernel—the developers working on that feature will probably be interested in your bug reports on that feature.</p><p>If you can reproduce that problem when the same system boots with the GENERIC kernel, the OpenBSD team is definitely interested. Report your problem as occurring on the GENERIC kernel, and include debugging output only from GENERIC, not from your custom kernel. If you manage to identify, debug, and create a patch for a problem with a custom kernel, send your patch and a problem description to the mailing list. Your problem may be due to running on a custom kernel, but you may also have found a bug that could be triggered in GENERIC.</p><p>But most important, if you have a problem running a custom kernel, reboot with GENERIC and get on with your day.</p></div></div><div class="sect1" title="Preparing for Kernel Customization"><div class="titlepage"><div><div><h2 class="title" id="preparing_for_kernel_customization" style="clear: both">Preparing for Kernel Customization</h2></div></div></div><p>Before customizing the kernel, back up the known-good GENERIC kernel on your system by copying <span class="emphasis"><em>/bsd</em></span> to <span class="emphasis"><em>/bsd.GENERIC</em></span>. That way, if your custom kernel doesn’t boot, you can recover by booting the backup kernel.</p><p>You’ll need the kernel source code in order to build a custom kernel. You can just grab <span class="emphasis"><em>sys.tar.gz</em></span> from your OpenBSD installation media. If you installed from an Internet mirror, make sure to get the source code for your version of OpenBSD. The OpenBSD mirror root directory usually contains a snapshot of fairly recent source code, but check the directory for your release for its source code. Expand this directory under <span class="emphasis"><em>/usr/src</em></span>.</p><a id="I_programlisting19_id490839"/><pre class="programlisting"># <span class="strong"><strong>cd /usr/src</strong></span>
# <span class="strong"><strong>tar -xzvpf sys.tar.gz</strong></span></pre><p>Now that you have a backup (you <span class="emphasis"><em>did</em></span> make a backup of your working kernel when I told you to, right?) and the source code, let’s look at kernel configuration.</p></div><div class="sect1" title="Kernel Configuration"><div class="titlepage"><div><div><h2 class="title" id="kernel_configuration-id00001" style="clear: both">Kernel Configuration</h2></div></div></div><p><a class="indexterm" id="idx0325"/><a class="indexterm" id="idx0326"/><a class="indexterm" id="idx0328"/><a class="indexterm" id="idx0425"/><a class="indexterm" id="idx1892"/>You configure the OpenBSD kernel via text files. Like 4.4BSD, OpenBSD doesn’t offer a fancy graphical kernel configuration utility or menu-driven system. Each kernel configuration is on a single line, along with a label indicating the type of entry and a description. Pound signs (<code class="literal">#</code>) mark comments.</p><div class="sect2" title="Configuration Entries"><div class="titlepage"><div><div><h3 class="title" id="configuration_entries">Configuration Entries</h3></div></div></div><p>Kernel configuration entries fall into four general categories: options, device drivers, pseudo-devices, and keywords.</p><div class="sect3" title="Options"><div class="titlepage"><div><div><h4 class="title" id="options">Options</h4></div></div></div><p><span class="emphasis"><em>Options</em></span> are hardware-independent kernel functions. Options handle things like filesystems, networking protocols, and compatibility layers.</p><p>Option entries look like this:</p><a id="I_programlisting19_id490964"/><pre class="programlisting">option     FFS         # UFS
option     INET        # IP + ICMP + TCP + UDP
option     CRYPTO      # Cryptographic framework</pre><p>To learn more about options, read the <code class="literal">options(4)</code> man page.</p></div><div class="sect3" title="Device Drivers"><div class="titlepage"><div><div><h4 class="title" id="device_drivers-id00002">Device Drivers</h4></div></div></div><p>Device drivers give the kernel the necessary software to interact with a piece of hardware. If you want your kernel to support a piece of hardware, it must include the appropriate device driver.</p><p>Device driver kernel configuration entries can be quite long. They might include flags or settings that tell the kernel where to find the device and how to initialize it. (ISA cards usually have a hard-coded IRQ and/or memory address.)</p><p>Device drivers have no common label, but their entry starts with the device name.</p><a id="I_programlisting19_id491000"/><pre class="programlisting">mainbus0 at root
cpu0     at mainbus?
fxp*     at pci?                         # EtherExpress 10/100B ethernet
wd*      at wdc? flags 0x0000
ec0      at isa? port 0x250 iomem 0xd8000 irq 9  # 3C503 ethernet</pre></div><div class="sect3" title="Pseudo-Devices"><div class="titlepage"><div><div><h4 class="title" id="pseudo-devices">Pseudo-Devices</h4></div></div></div><p><span class="emphasis"><em>Pseudo-devices</em></span> behave much like devices, but have no real hardware attached to them. Pseudo-devices are frequently abstractions that can be opened, read from, written to, and closed in the same way as real hardware.</p><p><a class="indexterm" id="idx0327"/><a class="indexterm" id="idx0914"/><a class="indexterm" id="idx1021"/><a class="indexterm" id="idx1171"/><a class="indexterm" id="idx1261"/><a class="indexterm" id="idx1263"/><a class="indexterm" id="idx1298"/><a class="indexterm" id="idx1332"/><a class="indexterm" id="idx2574"/>For example, the loopback interface is a pseudo-device used for network connections to the local machine. (Your computer has no loopback network card, but the loopback interface behaves just like a real network card with an unusual MTU value.)</p><p>Pseudo-devices are labeled with <code class="literal">pseudo-device</code>.</p><a id="I_programlisting19_id491114"/><pre class="programlisting">pseudo-device   loop    # network loopback
pseudo-device   pf      # packet filter
pseudo-device   gre     # GRE encapsulation interface</pre></div><div class="sect3" title="Keywords"><div class="titlepage"><div><div><h4 class="title" id="keywords">Keywords</h4></div></div></div><p>Finally, a handful of other keywords appear only once or rarely. These one-offs change how the kernel runs or how it’s built, and defy easy categorization. The following keywords may appear:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">machine</code> keyword tells the kernel which architecture it should run on.</p></li><li class="listitem"><p>The <code class="literal">makeoptions</code> keyword tells the compiler how to build the kernel.</p></li><li class="listitem"><p>The <code class="literal">include</code> keyword means pull in another configuration file.</p></li><li class="listitem"><p>The <code class="literal">maxusers</code> value sets the size of some in-kernel tables.</p></li></ul></div><p>You’ll find even less common keywords scattered in different kernel configurations.</p><a id="I_programlisting19_id491177"/><pre class="programlisting">machine         amd64
makeoptions     DEBUG="-g"  # compile full symbol table
include         "../../../conf/GENERIC"
maxusers        80          # estimated number of users</pre><p>All of these affect the kernel in wildly different ways. You’ll find several of these keywords in any kernel, even GENERIC.</p></div></div><div class="sect2" title="Configuring GENERIC"><div class="titlepage"><div><div><h3 class="title" id="configuring_generic">Configuring GENERIC</h3></div></div></div><p>Let’s look at an actual kernel configuration. OpenBSD divides kernel configuration into machine-independent and machine-dependent files.</p><div class="sect3" title="Machine-Independent Configuration"><div class="titlepage"><div><div><h4 class="title" id="machine-independent_configuration">Machine-Independent Configuration</h4></div></div></div><p>The machine-independent kernel configuration files are in <span class="emphasis"><em>/usr/src/sys/conf</em></span>. The file <span class="emphasis"><em>/usr/src/sys/conf/GENERIC</em></span> contains the machine-independent kernel configuration, which describes all of the features that OpenBSD supports on all hardware platforms. Every GENERIC kernel contains the configuration in this file. If you change this file, it will affect every kernel built that includes this file.</p><p><a class="indexterm" id="idx0051"/><a class="indexterm" id="idx0913"/><a class="indexterm" id="idx1262"/><a class="indexterm" id="idx2572"/>The machine-independent configuration file doesn’t contain device drivers; instead, devices are tied to particular hardware. This file won’t contain any special building instructions, because they vary from platform to platform. Nor will it include hard-coded system limits, data structure sizes, and so on, as OpenBSD running on a 25-year-old VAX has considerably fewer resources than a brand-new amd64 system. The <span class="emphasis"><em>/usr/src/sys/conf/GENERIC</em></span> file contains mostly options and pseudo-devices. Every OpenBSD kernel must support a filesystem, or it won’t be able to write to disk or anything disk-like.</p><p>A kernel based on this file doesn’t yet know what sort of hardware the filesystem will run on, but it knows how to make a filesystem. It doesn’t know what kind of network card it will have, but once you give it a network card, it can create a TCP data stream and serve your web pages. You’ll need the machine-dependent configuration to make a kernel that can function in the real world.</p></div><div class="sect3" title="Machine-Dependent Configuration"><div class="titlepage"><div><div><h4 class="title" id="machine-dependent_configuration">Machine-Dependent Configuration</h4></div></div></div><p>Each platform has its own machine-dependent kernel directory under <span class="emphasis"><em>/usr/src/sys/arch</em></span>. Here’s where you’ll find a subdirectory for every platform OpenBSD supports, as well as a directory for any platforms under development. Separate directories contain platform-specific code, as well as further <span class="emphasis"><em>conf</em></span> subdirectories for the kernel configuration file.</p><p>I’m using amd64 as an example, so the kernel configuration directory is <span class="emphasis"><em>/usr/src/sys/arch/amd64/conf</em></span>. While we’ll focus on the common i386 and amd64 architectures, the kernel-building process is the same across all hardware platforms.</p><p>A traditional kernel configuration filename is in all capital letters. You’ll see the <span class="emphasis"><em>GENERIC</em></span> configuration, as well as the <span class="emphasis"><em>RAMDISK*</em></span> files used for the installation disks. (The <span class="emphasis"><em>GENERIC.MP</em></span> kernel is the multiprocessor kernel.) We’ll start with the <span class="emphasis"><em>GENERIC</em></span> kernel configuration file:</p><a id="I_programlisting19_id491327"/><pre class="programlisting">machine         amd64
include         "../../../conf/GENERIC"</pre><p>The first entry in this kernel configuration defines the machine.The machine definition tells the kernel configuration parser the kind of hardware you’re running, and defines core hardware characteristics and constraints, such as how many bits are in an integer and how much memory the system can support.</p><p>The second entry pulls in the machine-independent kernel configuration (described in the previous section), defining all of the protocols and tools that make OpenBSD OpenBSD. The amd64 kernel inherits the filesystems and network stacks from this entry.</p><p>Following these two lines you’ll see the devices OpenBSD supports on amd64 hardware. Take a moment and skim the file. It’s the same mix of devices and attachments as described earlier in this chapter.</p></div></div><div class="sect2" title="Your Kernel Configuration"><div class="titlepage"><div><div><h3 class="title" id="your_kernel_configuration">Your Kernel Configuration</h3></div></div></div><p><a class="indexterm" id="idx0329"/><a class="indexterm" id="idx0337"/><a class="indexterm" id="idx1974"/><a class="indexterm" id="idx2035"/>In order to build your own kernel, you’ll need a configuration file. Here, we’ll look at how to create your configuration file. (Do not just edit either GENERIC kernel file.)</p><div class="sect3" title="Minor Changes"><div class="titlepage"><div><div><h4 class="title" id="minor_changes">Minor Changes</h4></div></div></div><p>If your kernel adds only a couple of items to the GENERIC kernel, use the GENERIC configuration as a basis for your new one. For example, here’s the multiprocessor kernel configuration, GENERIC.MP:</p><a id="I_programlisting19_id491410"/><pre class="programlisting"> include  "arch/amd64/conf/GENERIC"
option          MULTIPROCESSOR  # Multiple processor support
cpu*            at mainbus?</pre><p>The multiprocessor kernel builds on GENERIC, adding only one option and one device attachment. You can use this model to define your own kernel configuration.</p><p>For example, suppose you want to enable the experimental SCSI multipathing feature on a kernel. You could create a kernel configuration file in your platform directory, and simply copy the commented-out multipathing entries from the machine-independent GENERIC kernel, like this:</p><a id="I_programlisting19_id491425"/><pre class="programlisting">include    "arch/amd64/conf/GENERIC"
mpath0     at root
scsibus*   at mpath?</pre><p>This creates a custom kernel that closely resembles GENERIC, with these two extra devices.</p></div><div class="sect3" title="Removing Options"><div class="titlepage"><div><div><h4 class="title" id="removing_options">Removing Options</h4></div></div></div><p>To strip options from your kernel, use the <code class="literal">rmoption</code> keyword. For example, to create a minimal kernel based on GENERIC, you could use the <code class="literal">rmoption</code> keyword to remove some kernel options, as in this example:</p><a id="I_programlisting19_id491454"/><pre class="programlisting">include "arch/amd64/conf/GENERIC"
rmoption    NTFS
rmoption    HIBERNATE
…</pre><p>One advantage to creating a configuration by including the default kernel is that when you update your source code, your custom kernel configuration will probably still be valid. However, the more options you remove from the kernel, the greater the chance that the kernel will fail to compile, or if it compiles, that it might not boot. And if it boots, it might eat your hard drive.</p><p><a class="indexterm" id="idx0336"/><a class="indexterm" id="idx0338"/><a class="indexterm" id="idx0432"/>When removing options, keep in mind that some options are more important than you might think. For example, removing the <code class="literal">INET6</code> option (aka IPv6) can create a nonfunctional system. Removing options doesn’t save you much memory, and it might cripple any number of programs.</p></div><div class="sect3" title="Removing Devices"><div class="titlepage"><div><div><h4 class="title" id="removing_devices">Removing Devices</h4></div></div></div><p>If you want to remove a lot of stuff from a machine-dependent kernel configuration, while retaining the options for base OpenBSD functions, copy the machine-dependent GENERIC configuration file to a new text file and make your changes in that file.</p></div><div class="sect3" title="Wholesale Butchery"><div class="titlepage"><div><div><h4 class="title" id="wholesale_butchery">Wholesale Butchery</h4></div></div></div><p>If you want to commit wholesale butchery on the kernel, you’ll want a configuration that includes both the machine-independent and machine-dependent parts. Start by copying the existing GENERIC kernel configurations into one file, in the platform’s kernel configuration. Here, I call my new kernel TREBLE, after the hostname:</p><a id="I_programlisting19_id491532"/><pre class="programlisting"># <span class="strong"><strong>cd /usr/src/sys/arch/amd64/conf</strong></span>
# <span class="strong"><strong>cp ../../../conf/GENERIC TREBLE</strong></span>
# <span class="strong"><strong>cat GENERIC &gt;&gt; TREBLE</strong></span></pre><p>Before making any other changes, remove the line that includes the machine-independent kernel configuration file. Then slice out everything that makes the system functional, and try to build the new kernel. Next, add stuff back in until the kernel builds. (Although removing drivers won’t save much memory, doing so will make booting a tiny bit faster.)</p><div class="note" title="Note"><h3 class="title"><a id="ch19note02"/>Note</h3><p>You might be tempted to use the man pages to create your own kernel configuration from scratch. You’re certainly free to do that, if you’re either a Kernel Lord or an irremediable doofus. Feel free to try it. Every sysadmin can use such a valuable lesson in humility.</p></div></div><div class="sect3" title="Stripping Down the Kernel"><div class="titlepage"><div><div><h4 class="title" id="stripping_down_the_kernel">Stripping Down the Kernel</h4></div></div></div><p>Every device driver and option in the kernel uses memory. If you’re trying to cram OpenBSD onto a tiny computer, or you’re doing any sort of embedded development, you might want to build a custom kernel that includes as few device drivers as possible by editing <span class="emphasis"><em>/var/run/dmesg.boot</em></span>, where every entry matches a line in the kernel configuration.</p><p>The simplest way to trim out unnecessary device drivers is to remove everything that’s not in your computer. The kernel includes dozens of network card drivers, but you need only one or two. If you’re unsure about a device, keep it in the configuration. (The ACPI and BIOS devices in particular are tightly interrelated, and you’ll probably have a really hard time building a bootable custom kernel without the complete set of ACPI and BIOS devices.)</p></div><div class="sect3" title="Gutting the Kernel"><div class="titlepage"><div><div><h4 class="title" id="gutting_the_kernel">Gutting the Kernel</h4></div></div></div><p><a class="indexterm" id="idx0285"/><a class="indexterm" id="idx0339"/><a class="indexterm" id="idx0564"/><a class="indexterm" id="idx1640"/><a class="indexterm" id="idx2407"/>If removing device drivers doesn’t create a sufficiently small kernel for you, try removing machine-independent options. Many of these options are interdependent, however, and removing them can create a kernel you can’t compile. If you can compile the kernel, it might not boot, and if it boots, it might not function correctly.</p></div></div><div class="sect2" title="Testing Your Kernel Configuration with config(8)"><div class="titlepage"><div><div><h3 class="title" id="testing_your_kernel_configuration_with_c">Testing Your Kernel Configuration with config(8)</h3></div></div></div><p>Is your custom kernel configuration internally consistent? To test your kernel and prepare the files needed to compile it, use <code class="literal">config(8)</code>.</p><p>While still in the kernel configuration directory, give <code class="literal">config</code> the kernel configuration filename as an argument, like this:</p><a id="I_programlisting19_id491680"/><pre class="programlisting"># <span class="strong"><strong>config TREBLE</strong></span></pre><p>If you get any error messages, read them. For example, <code class="literal">config</code> might tell you that you need to run <code class="literal">make clean</code> before building your new kernel, or that your kernel configuration is internally inconsistent and will not compile. If there’s a problem, <code class="literal">config</code> will often give a line number where you made an error. Follow any advice <code class="literal">config</code> offers.</p><p>The following are some of the more common types of errors.</p><div class="sect3" title="Orphaned Devices"><div class="titlepage"><div><div><h4 class="title" id="orphaned_devices">Orphaned Devices</h4></div></div></div><p>One common way that <code class="literal">config</code> fails is if you’re missing a device that’s needed by another device. Here’s an example:</p><a id="I_programlisting19_id491731"/><pre class="programlisting"># <span class="strong"><strong>config TREBLE</strong></span>
TREBLE:36: cpu0 at mainbus? is orphaned
 (nothing matching mainbus? declared)
TREBLE:37: bios0 at mainbus0 is orphaned
 (no mainbus0 declared)
TREBLE:38: ioapic* at mainbus? is orphaned
 (nothing matching mainbus? declared)
TREBLE:82: pci* at mainbus0 is orphaned
 (no mainbus0 declared)
*** Stop.</pre><p>Your configuration attaches various devices to <code class="literal">mainbus0</code>, but there’s no <code class="literal">mainbus0</code> entry in your configuration. Kernels that include devices that aren’t attached don’t make sense and cannot compile.</p><p>To address this, examine your hardware again. Figure out how these devices are supposed to attach to the system, and fix your kernel configuration.</p></div><div class="sect3" title="Bogus Hardware"><div class="titlepage"><div><div><h4 class="title" id="bogus_hardware">Bogus Hardware</h4></div></div></div><p>Another common problem is including nonexistent device drivers, which generates the following error.</p><a id="I_programlisting19_id491775"/><pre class="programlisting"># <span class="strong"><strong>config TREBLE</strong></span>
TREBLE:36: cpe0: unknown device `cpe'
*** Stop.</pre><p><a class="indexterm" id="idx0213"/><a class="indexterm" id="idx0214"/><a class="indexterm" id="idx0323"/><a class="indexterm" id="idx2459"/><a class="indexterm" id="idx2573"/><code class="literal">config</code> shows me the error and the line number where it occurs. There is no <code class="literal">cpe</code> device, but there is a <code class="literal">cpu</code> device. My bad.</p><p>The error checking performed by <code class="literal">config</code> does not guarantee that your kernel will compile or run as expected. The only errors it catches are ones where the configuration is either internally inconsistent or flat-out wrong. The first real test comes when you try to actually build your configured kernel.</p></div></div></div><div class="sect1" title="Building a Kernel"><div class="titlepage"><div><div><h2 class="title" id="building_a_kernel" style="clear: both">Building a Kernel</h2></div></div></div><p>If <code class="literal">config</code> ran successfully, you will have a kernel compilation directory including a makefile and a whole slew of header files. The traditional place for the <span class="emphasis"><em>compile</em></span> directory is under the platform directory, which is <span class="emphasis"><em>/usr/src/sys/arch/amd64</em></span> for amd64 hardware.</p><p>The compile directory contains a subdirectory for each kernel configuration processed by <code class="literal">config</code>. My amd64 kernel called TREBLE is in the <span class="emphasis"><em>/usr/src/sys/arch/amd64/compile/TREBLE</em></span> directory, which contains a makefile, as well as all the header files for all included devices and options.</p><a id="I_programlisting19_id491891"/><pre class="programlisting"># <span class="strong"><strong>cd ../compile/TREBLE</strong></span>
# <span class="strong"><strong>make</strong></span></pre><p>Now it’s time to wait. A successful compilation will create a kernel file <span class="emphasis"><em>bsd</em></span> without generating any error messages.</p><div class="sect2" title="Kernel Build Errors"><div class="titlepage"><div><div><h3 class="title" id="kernel_build_errors">Kernel Build Errors</h3></div></div></div><p>If your kernel fails to build, you probably have a perfectly explicable error. First, read the error message given by the compilation. Most of the time, the error message will explain what the kernel is missing. Generally, you will need to change your kernel configuration in some manner because of an error that <code class="literal">config</code> could not catch. A broken kernel compilation will end something like this:</p><a id="I_programlisting19_id491932"/><pre class="programlisting">  ../../../../arch/amd64/pci/pci_machdep.c: In function <span class="strong"><strong>1</strong></span>'pci_intr_map':
  ../../../../arch/amd64/pci/pci_machdep.c:641: error: <span class="strong"><strong>2</strong></span>'PCI_INT_VIA_ISA' <span class="strong"><strong>undeclared</strong></span> (first use in this function)
  ../../../../arch/amd64/pci/pci_machdep.c:641: error: (Each <span class="strong"><strong>undeclared</strong></span> identifier is reported only once
<span class="strong"><strong>3</strong></span> ../../../../arch/amd64/pci/pci_machdep.c:641: error: for each function it
  appears in.)
  *** Error code 1
<span class="strong"><strong>4</strong></span> Stop in /usr/src/sys/arch/amd64/compile/ENVY (line 89 of /usr/share/mk/sys.mk).</pre><p><a class="indexterm" id="idx0330"/><a class="indexterm" id="idx0331"/><a class="indexterm" id="idx1046"/><a class="indexterm" id="idx1154"/><a class="indexterm" id="idx2483"/>This kernel cannot be built because something is missing. When a build fails with statements that something “is undeclared” (as shown in bold), that’s a hint that the kernel is missing a necessary entry.</p><p>The name of where it failed might offer you a hint as to what’s missing. In this case, at <span class="strong"><strong>1</strong></span>, I have a function name where the compilation failed, and then a specific undeclared variable <span class="strong"><strong>2</strong></span> that caused the compilation to fail.</p><p>I would start by figuring out where the <code class="literal">pci_intr_map</code> function comes from and what it’s supposed to do. Search the source code and man pages for references to the missing function. Failing that, try the mailing list archives. Be sure to include the function and variable names in any web search. Generic output that says that “there was an error” <span class="strong"><strong>3</strong></span> or “the compile has stopped” <span class="strong"><strong>4</strong></span> is less unique, and hence it could be useful. If all else fails, fall back to the GENERIC configuration.</p></div></div><div class="sect1" title="Installing Your Kernel"><div class="titlepage"><div><div><h2 class="title" id="installing_your_kernel" style="clear: both">Installing Your Kernel</h2></div></div></div><p>Your completed kernel is the file <span class="emphasis"><em>bsd</em></span> in the compile directory. Before you use your new kernel, verify that you have your current, working, well-behaved kernel backed up to a separate file on the root filesystem, and then copy your new kernel to <span class="emphasis"><em>/bsd</em></span>. That’s it! The next time you reboot, you’ll come up on your new kernel.</p><div class="note" title="Note"><h3 class="title"><a id="ch19note03"/>Note</h3><p>Some people do not like to copy their custom kernel to <span class="emphasis"><em>/bsd</em></span> until they’re certain that the kernel will boot. If you’re one of these people, copy your new kernel to the root directory under a different name, such as <span class="emphasis"><em>/bsd.test</em></span>. Boot into this alternate kernel. Test your system. If everything works, properly install your new kernel.</p></div></div><div class="sect1" title="Identifying the Running Kernel"><div class="titlepage"><div><div><h2 class="title" id="identifying_the_running_kernel" style="clear: both">Identifying the Running Kernel</h2></div></div></div><p>If you build several custom kernels, you might forget which kernel you’re running. The <code class="literal">uname(1)</code> command will tell you the name of the kernel configuration file used to build the running kernel. The <code class="literal">-v</code> flag will tell you the name of your kernel configuration and the number of times you have compiled it.</p><a id="I_programlisting19_id492126"/><pre class="programlisting"># <span class="strong"><strong>uname -v</strong></span>
GENERIC.MP#348</pre><p>This output does not mean that I’ve built a multiprocessor GENERIC kernel 348 times. I use the GENERIC kernel, and I let the OpenBSD release engineers build my kernels for me. They have built 348 official snapshot multiprocessor kernels without wiping the kernel build directory. Remember that building custom kernels is for advanced programmers and ignorant newbies. I’m neither.</p></div></section></body></html>