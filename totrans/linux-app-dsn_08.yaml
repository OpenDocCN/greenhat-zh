- en: '![](../images/129-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[**DESIGNING A WEB INTERFACE**](toc.html#chapter8)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/as.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The web browser has become the user interface of choice for configuring networked
    appliances, particularly home-based routers from companies like Linksys and Netgear.
    The driving force behind the popularity of web interfaces is that they are easy
    to use and don’t require specialized client software. Customers now expect to
    be able to access web interfaces for their devices, and so it is no surprise that
    leading manufacturers of home-based networked appliances provide them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first of several chapters devoted to user interface (UI) design.
    This chapter covers web UIs in general, and the development of Laddie’s web UI
    in particular. In the chapters that follow, we’ll look at Laddie’s other UIs:
    the CLI interface in Chapter 9, the front panel LCD interface in Chapter 10, the
    framebuffer interface in Chapter 11, and the infrared remote control interface
    in Chapter 12\. All of these UIs communicate with the back-end daemons via the
    PostgreSQL protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of web technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing requirements for your appliance’s web interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a webserver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the look and feel of the web interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlights of our implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lessons learned and future improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**Web Basics**](toc.html#chapter8.1)'
  prefs: []
  type: TYPE_NORMAL
- en: Web browsers communicate with webservers using the *HyperText Transfer Protocol
    (HTTP),* a client-server protocol. The communication is initiated from the web
    browser (the client) when it requests a web page via a particular Uniform Resource
    Locator (URL), for example, [http://www.google.com](http://www.google.com/). When
    the webserver receives this request, it checks that the requested page is available,
    and if it is, it sends the page to the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the HTTP protocol is text based, you can use telnet to imitate the
    browser request as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: telnet [www.google.com](http://www.google.com/) 80
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the telnet session has connected, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: GET / HTTP/1.0
  prefs: []
  type: TYPE_NORMAL
- en: Then press enter twice (the empty line created by the second enter causes the
    webserver to respond to the GET request). The page returned is formatted using
    HTML; an example page appears below. (Obviously, this page would look different
    if you opened it in a browser, because the browser would interpret the HTML markup
    and present it in a human-readable way.) Note that the middle portion of the page
    has been replaced by ellipses (. . .) to reduce its size.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/130-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[***DNS and TCP***](toc.html#chapter8.2)'
  prefs: []
  type: TYPE_NORMAL
- en: The network protocols DNS (Domain Name System) and TCP (Transmission Control
    Protocol) make this client-server exchange possible. Given the URL (e.g., [http://www.google.com](http://www.google.com/)),
    the client uses DNS to determine the IP address of the server. HTTP uses TCP for
    error-free data transmission between client and server.
  prefs: []
  type: TYPE_NORMAL
- en: These protocols are defined by the Internet Engineering Task Force (IETF), the
    authoritative Internet standards body. (For more information on IETF standards,
    see [http://www.ietf.org](http://www.ietf.org/); for more information on TCP/IP,
    see *The TCP/IP Guide* by Charles M. Kozierok, No Starch Press, 2005.)
  prefs: []
  type: TYPE_NORMAL
- en: '[***The Webserver***](toc.html#chapter8.3)'
  prefs: []
  type: TYPE_NORMAL
- en: The webserver finds and returns the web page for the given URL. This page may
    reside in the server’s filesystem or in memory, or it may be generated dynamically
    at the time of the request.
  prefs: []
  type: TYPE_NORMAL
- en: '[***CGI***](toc.html#chapter8.4)'
  prefs: []
  type: TYPE_NORMAL
- en: The *Common Gateway Interface (CGI)* emerged as a way for a webserver to communicate
    with a purpose-built program, which would in turn generate the web page on behalf
    of the webserver. In the Unix world, the early CGI programs were written in languages
    like bash, Perl, and C. Today, web-specific scripting languages like PHP are more
    common. Furthermore, modern webservers like Apache can be configured to run PHP
    scripts within the same process as the Apache webserver, thereby avoiding the
    CGI communication mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: '[***JavaScript***](toc.html#chapter8.5)'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has become accepted as the client-side programming language for web
    pages. JavaScript code is embedded in the HTML page, and tags in the web page
    tell the web browser when to execute the JavaScript functions. One of JavaScript’s
    main advantages is that it provides a more responsive user experience. One of
    JavaScript’s main disadvantages is that not all browsers support it, and those
    that do don’t necessarily support it in a standard way.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Evolving Technologies***](toc.html#chapter8.6)'
  prefs: []
  type: TYPE_NORMAL
- en: Coupled with developments on the client side and server side, the HTML protocol
    has undergone many revisions and has expanded to include XHTML, CSS, XSL, and
    XPath.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that web technology is still evolving. This evolution introduces
    challenges for developers striving for interoperability and longevity for their
    web pages. Therefore, as a web developer, it is prudent to plan ahead for changes
    in web technology.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Establishing Requirements**](toc.html#chapter8.7)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before developing a web UI for the Laddie alarm appliance, we established the
    following requirements to guide us with its design:'
  prefs: []
  type: TYPE_NORMAL
- en: The web interface should be easy to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web interface should support a wide variety of browsers, including text-based
    ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web pages should update automatically as the state on the appliance changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web pages should adhere to Internet standards, avoiding proprietary features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation should work with various webservers so that the appliance
    webserver can be replaced should a better one become available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation should be simple so that it can be easily maintained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**Choosing a Webserver**](toc.html#chapter8.8)'
  prefs: []
  type: TYPE_NORMAL
- en: Which webserver should you use when building your appliance? In this section
    we’ll review several webservers suitable for Linux appliances.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Choices***](toc.html#chapter8.9)'
  prefs: []
  type: TYPE_NORMAL
- en: Webservers come in several different flavors. Many support the CGI interface,
    which allows the webserver to spawn an arbitrary process to generate the web page
    content on behalf of the webserver.
  prefs: []
  type: TYPE_NORMAL
- en: The Apache webserver can be compiled with a PHP interpreter so that PHP scripts
    are interpreted within the Apache process. This approach reduces inter-process
    communication and improves response time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lighttpd webserver supports the FastCGI interface. The FastCGI mechanism
    spawns multiple PHP interpreters and load balances requests for PHP web pages
    between them. For more information, see [http://www.fastcgi.com](http://www.fastcgi.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GoAhead webserver allows the webserver and all web pages to be packaged
    into a single executable, which allows the webserver to run without a filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The webserver in the Linksys WRT54G wireless router is written entirely in C
    and includes handcrafted functions for each web page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TUX webserver runs in the Linux kernel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps the first thing to consider when choosing a webserver is the license.
    If you don’t want to release your source code modifications, then you should avoid
    webservers with GPL and Apache licenses. On the other hand, if you do select a
    mature webserver like Apache, it is unlikely that you will have to modify it,
    and consequently, you won’t have to worry about having to release source code.
  prefs: []
  type: TYPE_NORMAL
- en: We suggest that you resist developing your own webserver. It is cheaper to select
    an existing one and to develop the web pages in a server-agnostic way. The advantage
    to this approach is that you don’t have to spend your development resources maintaining
    a webserver, and you can replace the webserver should a better one become available.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Use PHP***](toc.html#chapter8.10)'
  prefs: []
  type: TYPE_NORMAL
- en: We suggest using PHP as the language to generate dynamic web pages. Though you
    can write smaller CGI programs in C, if you use a compiled language and need to
    modify a web page once the appliance has been deployed, you will need a compile
    environment, which would typically not be available on the deployed appliance.
  prefs: []
  type: TYPE_NORMAL
- en: When you use an interpreted language like PHP, you can easily modify and test
    the web pages on the deployed appliance.
  prefs: []
  type: TYPE_NORMAL
- en: PHP is a good language for generating web content because it is popular, mature,
    has an active developer community, and is well integrated into open source webservers
    such as Apache, thttpd, and lighttpd. Even for webservers that don’t support PHP,
    you can still write CGI programs *using PHP.* Thus, you can use PHP with just
    about any webserver. It is for these reasons that we selected PHP to develop the
    Laddie web UI.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Case Study: Linksys WRT54G Wireless Router***](toc.html#chapter8.11)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine the approach taken by the Linksys WRT54G wireless router. The
    webserver in this router is a handcrafted combination of both the micro_httpd
    and mini_httpd webservers, enhanced with specialized C functions that generate
    the dynamic content of the web pages. The code is GPL licensed and is available
    from [http://www.linksys.com](http://www.linksys.com/) under the GPL Code Center.
    (Both micro_httpd and mini_httpd were written by Jef Poskanzer and are available
    at [http://www.acme.com](http://www.acme.com/).)
  prefs: []
  type: TYPE_NORMAL
- en: The specialized C functions are responsible for generating dynamic content for
    the web pages. Because these functions are compiled into the webserver, there
    is no need for a script interpreter like PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the C function dump_route_table() is invoked from a web page by
    placing the function name between a matching pair of tags, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <% dump_route_table(""); %>
  prefs: []
  type: TYPE_NORMAL
- en: This tag mechanism is similar to the approach taken by PHP, except that here,
    the function is implemented in C and compiled into the webserver.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this approach is that it has smaller memory requirements. However,
    as mentioned earlier, the problem with this approach is that the development cycle
    is extended because any change to a specialized C function requires a recompile.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Case Study: The TUX Webserver***](toc.html#chapter8.12)'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike most other webservers, which run in user space, the TUX webserver runs
    in the Linux kernel. Running in kernel space allows TUX to avoid communication
    between kernel space and user space; therefore, TUX offers better server response
    time than other webservers.
  prefs: []
  type: TYPE_NORMAL
- en: TUX supports both static and dynamic web page content, but for it to support
    dynamic content, another webserver must be running in user space. TUX operates
    by responding to requests for static web pages itself and forwarding requests
    for dynamic content to a user space webserver like Apache. As you might imagine,
    TUX doesn’t offer speed advantages when it comes to support for dynamic web pages.
    Thus, for websites that have mostly dynamically generated content, the extra TUX
    configuration might not be worth the trouble.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Comparison of Webservers***](toc.html#chapter8.13)'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we listed a range of webservers from Apache to TUX.
    In this section, we’ll narrow our focus to comparing only webservers that support
    PHP as the scripting language. For space reasons, we’ve limited the set of webservers
    to Apache, Boa, BusyBox’s httpd, Cherokee, GoAhead, lighttpd, and thttpd. These
    webservers have been selected because they are either used in commercial products
    or they are tailored for embedded applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible criteria for comparing webservers include:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory footprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Size of executable file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ongoing maintenance and development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of how you weigh the different criteria, choosing a webserver will
    require a compromise. For example, the memory footprint may be critical for some
    appliances, but not for others.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than advocating one webserver for your appliance, we’ve compiled Table
    8-1, which shows how the various webservers in our limited set compare in each
    area. You can use this table as a starting point when selecting a webserver.
  prefs: []
  type: TYPE_NORMAL
- en: You can use different webservers for different stages of development. For example,
    you could use one webserver that has good debugging support in the development
    phase, and then switch to another one with a small memory footprint during testing
    and deployment. If you choose to use different webservers, plan ahead to ensure
    that you use features supported by all of them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-1:** Comparison of Various Webservers'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/135-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**About the Tabular Data**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at Table 8-1 in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Version tested** This is the software version of the webserver that we tested.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual memory** This is the virtual memory (in kilobytes) that the running
    webserver consumed. The virtual memory was measured using the Unix top command,
    which displays virtual memory under the SIZE column. For webservers that spawn
    multiple processes, we recorded the maximum value. In each case, the virtual memory
    was recorded during the performance test. (See *Response time* on the next page.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Executable size** This is the size (in kilobytes) of the executable file
    after compiling it with mostly default options and then manually stripping it
    with the strip command. This metric is not as good of an indication of required
    memory as virtual memory is because libraries are sometimes linked dynamically
    and sometimes linked statically.'
  prefs: []
  type: TYPE_NORMAL
- en: When programs are linked dynamically, much of the code can be in dynamically
    linked libraries. When you view the size of the executable, the code in these
    libraries will not be factored in. So the size of a dynamically linked executable
    is not a good indication of how much memory will be required when the executable
    is run (when all the libraries are linked-in at load-time). Typically, what’s
    important is how much memory a program requires to run, because memory is the
    precious resource.
  prefs: []
  type: TYPE_NORMAL
- en: '**Response time** This is the average response time (in milliseconds) to access
    Laddie’s status.php page, as recorded by the httperf utility (available at [http://www.hpl.hp.com/research/linux/httperf](http://www.hpl.hp.com/research/linux/httperf)).
    The motivation for this performance test is to measure how quickly the webserver
    responds to requests for the status web page. The following steps were taken for
    each webserver:'
  prefs: []
  type: TYPE_NORMAL
- en: a. The webserver’s software was compiled with default options, except for those
    options necessary to make it work correctly. Detailed instructions on how each
    webserver was configured is available in /Code/src/web/INSTALL_WEB_SERVER.txt
    on this book’s companion CD. We used PHP version 5.0.3.
  prefs: []
  type: TYPE_NORMAL
- en: b. The resulting webserver executable was stripped with the strip command.
  prefs: []
  type: TYPE_NORMAL
- en: c. The back-end Laddie process, ladd, was run.
  prefs: []
  type: TYPE_NORMAL
- en: 'd. The following command was used to measure the response time:'
  prefs: []
  type: TYPE_NORMAL
- en: httperf --hog --server 192.168.1.11 --uri=/cgi-bin/status.php --num-conn 200
    --rate 1
  prefs: []
  type: TYPE_NORMAL
- en: The resultant dynamically generated status.php page was 4546 bytes. The server
    we used for testing consisted of an Intel Celeron 2.4 GHz processor running Linux
    Red Hat 9 with otherwise idle processes. The client consisted of an AMD Duron
    1 GHz processor running Linux Red Hat 9\. The server and client had 10 MHz NICs
    with a Linksys switch/ router between them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Supports CGI** This denotes whether or not the webserver supports the Common
    Gateway Interface (CGI).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Supports FastCGI** This denotes whether or not the webserver supports FastCGI,
    a performance enhancement to CGI. Documentation about FastCGI may be found at
    [http://www.fastcgi.com](http://www.fastcgi.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Supports in-process scripting** This denotes whether the webserver supports
    a built-in PHP interpreter (or some other script interpreter). This functionality
    provides faster performance because it avoids interprocess-communication in the
    CGI interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server API used** This is the Server API interface used during the response
    time performance test. The Server API is the communication mechanism between the
    webserver and the scripts, for example, Apache, CGI, and FastCGI. As you can see
    from the table, some webservers support only one Server API, while others support
    more than one.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Last release** This is the last time the software was released at the time
    of writing. This value is an indication of whether the software is actively maintained.
    In most cases, the version we tested was the last version released. However, there
    is one exception—the last version of thttpd released as of this writing was 2.25b,
    but we tested version 2.21b, because 2.21b was the last version that supported
    in-process scripting.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Debugging** This denotes whether or not you can debug scripts with the webserver.
    In the case of Apache and PHP, there is a commercial development environment called
    Zend Studio that allows you to debug PHP scripts using Internet Explorer. Using
    Zend, you can step though PHP scripts one line at a time and view PHP variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Documentation** This is a rough measure of whether or not the documentation
    specifies clearly which features the webserver supports and whether it provides
    instructions on how to use each feature.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cost** This is the monetary cost of distributing the webserver in an appliance.
    Note that we have not included any webservers for which there is a monetary cost.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security** These are the security features that prevent users from accessing
    files that they shouldn’t be able to access. The most secure webservers are those
    that enforce access through a configuration file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**License** This is the type of software license the webserver has. The Apache,
    BSD, and GPL licenses are well known. The GoAhead license requires that you notify
    GoAhead prior to shipping your product and that you display a GoAhead logo on
    your initial web page.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Considering Memory Requirements**'
  prefs: []
  type: TYPE_NORMAL
- en: If memory is not a factor in your appliance, the Apache webserver would be a
    good choice. The advantage of Apache is its mature feature set, good development
    tools (like Zend Studio), and an active development community.
  prefs: []
  type: TYPE_NORMAL
- en: If memory is at a premium, then the BusyBox webserver might be a good choice;
    it has the smallest virtual memory requirements of the webservers we tested. The
    GoAhead webserver has the next smallest memory requirements; however, the disadvantage
    of GoAhead is that it uses Active Server Pages, a Microsoft technology, rather
    than PHP, an open source technology. (You can still run PHP scripts in GoAhead
    using the CGI mechanism, but it isn’t as seamless as using a webserver with a
    built-in PHP interpreter.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Considering Response Time**'
  prefs: []
  type: TYPE_NORMAL
- en: The top three webservers in terms of response time are thttpd, Apache, and lighttpd.
    Both thttpd and Apache get their speed from running PHP scripts in the same process
    as the webserver itself, which avoids the inter-process communication used by
    the other webservers. The thttpd webserver has the disadvantage that it only services
    one request at a time, so it will block subsequent requests until previous requests
    have been completed. This behavior may be fine for some web pages, but it will
    be a problem if the web page is written to block requests for a certain length
    of time, or to block until a state change. One of the Laddie web pages does block
    for a state change, and so this web page behavior rules out using thttpd webserver
    for the Laddie appliance. (We’ll discuss this particular web page in the section
    “Asynchronous Updates Using Ajax” on page 125.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Our Choice**'
  prefs: []
  type: TYPE_NORMAL
- en: When we were developing Laddie, we used the Apache webserver because of its
    debugging support, while for the production appliance, we selected lighttpd because
    of its smaller memory requirement and its speed. We chose which webserver to use
    in the production appliance rather late in the development cycle. We were able
    to make this decision later because we had written our PHP scripts to work under
    Apache, CGI, and FastCGI.
  prefs: []
  type: TYPE_NORMAL
- en: In his book about embedded Linux, Yaghmour advises against using Apache because
    it is difficult to cross-compile (*Building Embedded Linux Systems*, by Karim
    Yaghmour, O’Reilly, 2003). There was no need to cross-compile for our appliance,
    but if your appliance’s CPU differs from your development machine’s CPU, you should
    keep this in mind.
  prefs: []
  type: TYPE_NORMAL
- en: '[**UI Design**](toc.html#chapter8.14)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll review various approaches to designing the UI look and
    feel, and the trade-offs they require. We will weigh these trade-offs when making
    implementation decisions in the “Implementation” section on page 118.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Menu System***](toc.html#chapter8.15)'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important functions of a menu system is that it allows users
    to quickly grasp the system’s capabilities. A menu with lots of top-level options
    can make it difficult for the user to choose an action, because there are so many
    choices. On the other hand, a menu with lots of nesting, though reducing the crowding
    on the top-level menu, tends to increase the time it takes to find an action.
  prefs: []
  type: TYPE_NORMAL
- en: Menu systems can be divided into those in which the top-level menu runs vertically
    down the left side of the window (see Figure 8-1), and those in which the top-level
    menu runs horizontally, near the top of the window (see Figure 8-2). While the
    vertical menu can be useful, it can quickly become difficult to navigate as the
    number of menu items increases (note the scrollbars in Figure 8-1). The horizontal
    menu is usually superior because it can be more compact because the second-level
    menus share the same real estate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/138-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: A vertical menu*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/139-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: A horizontal menu*'
  prefs: []
  type: TYPE_NORMAL
- en: One disadvantage to the vertical MyFaces menu in Figure 8-2 is that it is not
    visually clear that the second-level menus (e.g., *Tomahawk*, *Documentation*,
    and *Components*) are not selectable; they look like the third-level menus, but
    they behave differently. The MyFaces menu could be improved by making the non-selectable
    menu items more distinct. For example, see the menus shown in Figure 8-3.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/139-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: A menu with distinct non-selectable items*'
  prefs: []
  type: TYPE_NORMAL
- en: '[***Dialog Boxes***](toc.html#chapter8.16)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our advice on dialog boxes is simple: Avoid them. Dialog boxes halt proceedings
    because the user cannot continue until he or she clicks a button to close the
    box. Alan Cooper argues against dialog boxes because they break the flow of the
    user experience and don’t move users closer to their goal *(About Face 2.0: The
    Essentials of User Interaction Design* by Alan Cooper and Robert Reimann, Wiley,
    2003).'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to dialog boxes is to place informational messages into the web
    page itself. We’ll demonstrate this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Error Messages***](toc.html#chapter8.17)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Good error messages can greatly improve the usability of your web UI. Experts
    generally agree on the following guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: If possible, make the program smarter to either avoid the particular error condition
    or recover from it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an unrecoverable error has been detected, provide an explicit error message—that
    is, don’t suppress the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error message should be human readable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error message should be detailed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error message should advise how to fix the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error message should be close to the field with the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fields with errors should be clearly identified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some error conditions are caused by the user (when the user enters a bad value
    in a web form), while others are caused by external events (when the appliance
    disk becomes full). When designing your appliance’s web pages, think about how
    these different errors will be handled.
  prefs: []
  type: TYPE_NORMAL
- en: One way to present error messages is to use dialog boxes (see Figure 8-4), but
    as we mentioned before, we discourage this approach. A second approach is to insert
    the error message into the refreshed web page (see Figure 8-5). The salient feature
    with this approach is that the error message is displayed in the form field, so
    that users can immediately re-enter their data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/140-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: An error dialog box*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/140-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: An in-line error message*'
  prefs: []
  type: TYPE_NORMAL
- en: A third approach is to annotate the labels where an error has occurred, as shown
    in Figure 8-6\. In this example, errors are shown by displaying the labels in
    another color. In this figure, all of the field labels are in black, except for
    *Lan IP* and *Control IP*, which are in red (they’re circled here because they
    appear gray); this tells you that there is a problem with those fields. One problem
    with this approach is that it fails to provide a detailed message. While some
    systems provide a tooltip with a message, such a mechanism is usually not explicit
    enough, and the user must mouse over the label to see more detail, which makes
    the user do unnecessary work.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/141-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: An annotated error message*'
  prefs: []
  type: TYPE_NORMAL
- en: '[***Improving Responsiveness with Ajax***](toc.html#chapter8.18)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ajax (Asynchronous JavaScript and XML)* is a set of technologies that enables
    partial updates of web pages. Because only parts of a web page are refreshed,
    the update occurs more quickly than it would if the entire web page was refreshed.
    Furthermore, the partial update may be triggered by user events like mouse clicks
    and key presses. This behavior makes the UI more responsive than that of a traditional
    web page.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, Gmail, Google’s email service, uses Ajax. When you compose an email
    and start typing the name of a contact, the browser responds to every key, reducing
    the list of matches as you type. The responsiveness is impressive.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8-7 shows an example of how the Ajax communication mechanism works. The
    exchange in this figure is initiated when the user mouses over an active element
    on the web page at event ![](../images/1a.jpg). An onmouseover action is triggered
    and JavaScript code is executed in the web browser at event ![](../images/2a.jpg).
    The JavaScript code creates an XMLHttpRequest object with the URL of the server-side
    script and a JavaScript callback function, and the web browser then sends the
    XMLHttpRequest object to the server at event ![](../images/3a.jpg). On the server
    side, the particular script identified by the URL responds with XML data at event
    ![](../images/4a.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/142-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-7: Typical Ajax sequence.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The format of the XML is known by the client and the server, so that when
    the server sends the XML data, the client understands its format. Typically, the
    XML data will contain the updated information to be displayed on some portion
    of the web page in the browser.*'
  prefs: []
  type: TYPE_NORMAL
- en: Back on the client side, the web browser receives the XML data and invokes the
    JavaScript callback function. This callback function extracts the data from the
    XML message and modifies some portion of the web page using the XML Document Object
    Model (DOM) API at event ![](../images/5a.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Mouse movements are not the only events that are supported by Ajax, but they
    are the most popular, along with mouse button clicks, key presses, text selections,
    and keyboard focuses on editable fields—and more events are made available with
    each browser upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Implementation**](toc.html#chapter8.19)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll discuss the implementation of Laddie’s web UI. We’ll
    show some screenshots of the web UI and discuss how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The web UI supports at least the following web browsers: Internet Explorer
    (version 5.0 and later), Netscape Navigator (version 4.72 and later), Firefox
    (version 1.0 and later), Safari (version 1.0 and later), Opera (version 5.0 and
    later), and Lynx (version 2.8.2 and later). These versions were determined through
    direct testing with archived browsers available from [http://browsers.evolt.org](http://browsers.evolt.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unlike the other graphical browsers, the Lynx browser is text-based.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[***Interfacing with the Daemons***](toc.html#chapter8.20)'
  prefs: []
  type: TYPE_NORMAL
- en: The Laddie web UI presents information from several running daemons. As you
    know, each of these daemons communicates using the PostgreSQL protocol. In this
    section, we’ll discuss how the web UI interacts with ladd, the Laddie alarm daemon.
    Once you understand this interaction, you’ll understand how the web UI interacts
    with the other daemons as well. Figure 8-8 shows a typical sequence where a user
    requests a web page and the web page is generated dynamically, based on the state
    of a daemon.
  prefs: []
  type: TYPE_NORMAL
- en: The figure shows the Linux appliance with the webserver and the ladd alarm daemon
    running on it. For simplicity, we’ve shown the PHP interpreter running in the
    same process as the webserver, as in the case of Apache, but it could be running
    as a different process if you’re using CGI scripts.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, the figure shows a typical request-response sequence for a web
    page. First, the user requests a particular page at event ![](../images/1a.jpg).
    The webserver locates the web page from the filesystem, and because the webserver
    finds PHP tags in the page, it invokes the PHP interpreter, which interprets the
    PHP code. In our case, the particular PHP code includes PHP functions pg_connect()
    and pg_exec(), which are invoked by the PHP interpreter at events ![](../images/2a.jpg)
    and ![](../images/3a.jpg). The PHP code generates the web page at event ![](../images/4a.jpg),
    and this new page is then sent back to the browser at event ![](../images/5a.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/143-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-8: Interfacing with a daemon*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connecting to the Daemon**'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the illustration, before you can read and write to the ladd
    daemon, you must establish a connection using the pg_connect() function, which
    is built into the PHP interpreter when you configure PHP with the --with-pgsql
    option. The pg_connect() function takes a string argument that specifies the hostname
    (or IP address) of the server and the port. In our case, the server is on the
    same machine as the webserver, and the ladd daemon is listening on port 8888\.
    More information on pg_connect() can be found by searching for *PostgreSQL Functions*
    in the PHP manual at http://us2.php.net/pgsql.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code fragment shows how to open a connection to the daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/144-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Reading from the Daemon**'
  prefs: []
  type: TYPE_NORMAL
- en: Once a connection has been established, you can read from and write to the ladd
    daemon. We use the pg_exec() function to do this. This function requests that
    a given statement be executed, in our case a SELECT statement. For more details
    on pg_exec(), see the PostgreSQL Functions at [http://us2.php.net/pgsql](http://us2.php.net/pgsql).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following PHP code fragment shows how to read the alarm status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/144-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the names id, name, enabled, and alarm in the SELECT command
    are the column names in the Zone RTA table in the ladd daemon. Generally, the
    SELECT command will have the same form for different daemons, but the number of
    columns and their names may differ. The value returned by the pg_exec() function
    is an object handle, which is then used to extract the number of rows with pg_NumRows()
    and each row’s contents with pg_result().
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the functions with names that start with pg are part of the PostgreSQL
    PHP library and are not unique to our daemon.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once the information has been read from the daemon, you can use this information
    to generate an HTML page. For example, we would use the results in $id, $name,
    $enabled, and $alarm to generate an HTML table.
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing to the Daemon**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To write to the ladd daemon and set alarm zone 3 into the alarm state, you
    could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/145-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that you use the same pg_exec() function call as when reading information
    from the daemon; the difference is that the SQL command is UPDATE rather than
    SELECT. The SQL command in the preceding code snippet specifies to update the
    alarm column in the Zone table to the value $value, but only in the case where
    the id column matches $id.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet we’ve set the $value and $id variables to arbitrary
    values, but typically the $id and $value variables would be extracted from an
    HTML form.
  prefs: []
  type: TYPE_NORMAL
- en: The interaction between the web UI and the ladd daemon is straightforward enough.
    The web UI can read information from the ladd daemon and it can write information
    to the ladd daemon. The web UI interacts with the other daemons in the same way,
    so there is nothing new to learn about those interactions. (The interaction is
    straightforward because we are using an established protocol, PostgreSQL, and
    the function bindings to this protocol are readily available to PHP programs.)
  prefs: []
  type: TYPE_NORMAL
- en: '[***Alarm Status Page***](toc.html#chapter8.21)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8-9 shows Laddie’s alarm status page. This page allows you to view the
    status of each alarm zone, clear alarm conditions, and set an alarm condition
    (for testing purposes).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/145-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-9: Laddie status page*'
  prefs: []
  type: TYPE_NORMAL
- en: An alarm condition can be shown either as a gray horizontal bar or with the
    label *Alarm* under the *Status* column. If you were to actually use this interface,
    you would probably find that the horizontal bar is much easier to read than the
    label because it offers a quick visual cue. When designing your web interface,
    think about how you might augment your interface with similar visual cues to convey
    information quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike traditional web pages, which require a user to refresh the page to update
    status, this status page automatically updates when an alarm condition changes.
    To observe this automatic update behavior, start two browsers and point them to
    the alarm status page. In one browser, modify the alarm condition by clicking
    the Clear and Set buttons. If JavaScript is enabled in your two browsers, you
    should see a page update on both browsers.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the PHP code that generates this web page on this book’s companion
    CD in the file /opt/laddie/htdocs/web/cgi-bin/status.php.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Alarm Setup Page***](toc.html#chapter8.22)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The alarm setup page, shown in Figure 8-10, allows you to configure the names
    of the alarm zones. When designing this page, we considered two UI design approaches:
    an Update button for each zone and a single Update button for all zones. We chose
    the single button because it reduces the navigation required to configure all
    the zones; you simply modify the parameters of several zones and click Update.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/146-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-10: Laddie alarm setup page*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This web page allows the user to enter the names of each alarm zone. We’ll
    now describe how the web page works and in particular how to work with the tabular
    data shown there. On the browser side, the web page includes an HTML form, which
    is a mechanism for accepting input from a user and sending it to the webserver
    when the user presses a Submit button. If you take a look at the web page’s HTML
    source, you will see the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: <td> <input type=text name=Name_1 value="Garage Door" /> </td>
  prefs: []
  type: TYPE_NORMAL
- en: The input tag tells the browser to display a field for textual input. The name
    tag tells the browser how to name the field, and the value tag tells the browser
    how to populate the initial value for the field. When the user hits the Submit
    button, the names and values of all form fields are sent to the server. When the
    server receives this request, our PHP code will extract the zone names from the
    request and update the Laddie daemon.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP provides a simple mechanism to extract the field values. For example, to
    extract the value for the field with name *Name_1,* you would use the following
    PHP code:'
  prefs: []
  type: TYPE_NORMAL
- en: $name = $_REQUEST["Name_1"];
  prefs: []
  type: TYPE_NORMAL
- en: The _REQUEST variable is a global variable that is populated by the PHP interpreter,
    while the *Name_1* string corresponds to the name of the field in the HMTL form.
    Once this statement is executed on the server, the $name variable will contain
    the text that the user entered in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: For tabular forms we need to be careful about field naming because the HTML
    specification requires that all fields in a form must have a unique name. One
    common approach to naming such form fields in HTML is to append a row number to
    the column name. For example, we append the row number *1* to *Name* (using underscore
    as a separation character) to get *Name_1* for the Name column for Zone 1.
  prefs: []
  type: TYPE_NORMAL
- en: The PHP code to generate this web page can be found on this book’s companion
    CD in the file /opt/laddie/htdocs/web/cgi-bin/setup_alarm.php. Take a look at
    the function displayZoneForm. The PHP code that handles the web form updates is
    in the same file.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Page Layout and Menu System***](toc.html#chapter8.23)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll describe Laddie’s web page layout and menu system. This
    simple scheme is handled by two PHP files. The first file, layout.php, defines
    Laddie’s two-level menu system as a two-dimensional array (see the global variable
    $menu_system on this book’s companion CD in /opt/laddie/ htdocs/web/cgi-bin/layout.php)
    and it defines the function display_page(). This function refreshes the page whenever
    the user navigates the menu. The second file, alarmstyle.css, controls color,
    fonts, and indentation (see /opt/laddie/htdocs/web/alarmstyle.css on the CD).
    Figure 8-11 shows an example web page; the PHP code that generated this web page
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/147-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-11: Laddie’s “Hello, world!” example*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/148-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first two parameters in the call to display_page() are indices into the
    menu structure (defined by the global variable $menu_system in layout.php). The
    first parameter, "Setup" in this example, is the top-level index, while the second
    parameter is the second-level index. The third parameter is an HTML-formatted
    string, which is displayed in the main window. In this example, the main window
    consists of the heading Hello, world! and two lines. It is the main window that
    is different for each web page, and typically this content is generated dynamically,
    depending on the state of the system.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the presentation logic for page layout is encapsulated by the function
    display_page(). For another example of how to use display_page(), see /opt/laddie/htdocs/web/cgi-bin/help_contact_us.php
    on the CD.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Webserver Independence***](toc.html#chapter8.24)'
  prefs: []
  type: TYPE_NORMAL
- en: PHP works with many different webservers, each having a slightly different way
    of interacting with the PHP interpreter. The API with which PHP interacts with
    the webserver is called the Server API. The Server API used by PHP is determined
    when compiling PHP, so as a developer you probably know this before writing the
    PHP scripts. But what if you decided to use another webserver? If you didn’t plan
    ahead, you would have to modify a lot of code to get it to work with the new webserver.
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, PHP provides the function php_sapi_name() to programmati-cally
    determine which API is currently in use. This function returns one of many possible
    strings, three of which are *apache, cgi,* and *cgi-fcgi,* corresponding to Apache,
    CGI, and FastCGI. There’s not too much documentation on the Server API, but try
    searching for it on Google.
  prefs: []
  type: TYPE_NORMAL
- en: 'Early in the design phase, we decided to write our PHP scripts so that they
    would work with these three Server APIs, because the webservers that we investigated
    supported at least one of them. This would mean that our PHP scripts would work
    without modification under any webserver that supported one of these APIs. This
    server-independent approach offers two advantages: It avoids locking you in with
    a particular webserver (should a better one become available) and it allows you
    to develop scripts using a different webserver than the one deployed in your appliance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Script input parameters are defined by name-value strings. For example, an
    input parameter might have the name *disp_id* and a value of 51\. The script’s
    input parameters are provided by the HTTP request that invokes the script; for
    example, the following request will set the input parameter *disp_id* for the
    script wait_for_status.php:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://127.0.0.1/wait_for_status.php?disp_id=51](http://127.0.0.1/wait_for_status.php?disp_id=51)'
  prefs: []
  type: TYPE_NORMAL
- en: The trick to supporting Apache, CGI, and FastCGI lies in handling the script’s
    input parameters the same way, regardless of which environment the script is running
    in. (There is no problem with the output because these three Server APIs handle
    output the same way.)
  prefs: []
  type: TYPE_NORMAL
- en: For CGI scripts, the script’s input parameters are extracted from STDIN, whereas
    for Apache and FastCGI scripts, they are extracted from PHP global variables.
    Actually, the Apache and FastCGI cases are identical, so there are only two cases,
    CGI and Apache. We chose to abstract these two cases with a function called read_params().
    The implementation of read_params() handles the details of both cases, but from
    the caller’s perspective, it provides a uniform way to extract the input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PHP code fragment below shows how the function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/149-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The read_params() function returns an array containing all the script’s input
    parameters. The calling script can then retrieve a particular parameter value
    using the parameter’s name (which is known at design time). Note that the function
    array_key_exists is a PHP built-in function that determines whether or not a given
    index exists in a given array.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the read_params() function can be found in the file /opt/laddie/htdocs/web/cgi-bin/php_params.php
    on the CD. You’ll find another example of its use in /opt/laddie/htdocs/web/cgi-bin/
    setup_snmp.php.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Asynchronous Updates Using Ajax***](toc.html#chapter8.25)'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the status web page shown in Figure 8-9\. How should the web page react
    to changes in the state of an alarm?
  prefs: []
  type: TYPE_NORMAL
- en: 'Preferably, the web page should be updated automatically, rather than requiring
    the user to repeatedly click the browser’s Refresh button. One approach is to
    poll the server at a fixed frequency, for example, using the Refresh HTML meta
    tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <META HTTP-EQUIV="Refresh" CONTENT="5;URL=refreshed-page.html">
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is to use Ajax so that the web page updates only when there
    is a state change on the server. The disadvantage with Ajax is that it requires
    JavaScript to be enabled in the web browser; if the user disables JavaScript,
    the update mechanism breaks. On the other hand, when Ajax is used, the web page
    updates quickly in response to state changes on the server.
  prefs: []
  type: TYPE_NORMAL
- en: In the section “Improving Responsiveness with Ajax” on page 117, we described
    how a typical Ajax exchange works. However, note that this typical exchange is
    initiated by the client, rather than the server. We need a way to modify Ajax
    so that the browser responds to state changes on the server.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that we can modify the Ajax exchange so that the system behaves
    as if the webserver initiates the exchange. The trick is twofold. First, replace
    the onmouseover event with the onload event, so that the XMLHttpRequest is sent
    as soon as the web page is loaded. Second, write the webserver script so that
    it blocks while waiting for an event. By implementing this modified Ajax exchange,
    the web page will update whenever the particular event occurs on the server. The
    experienced Ajax programmer will note that there is another mechanism that achieves
    a similar result, notably the *HTTP Streaming pattern* documented at [http://www.ajaxpatterns.org](http://www.ajaxpatterns.org/)
    (and in the associated book, *Ajax Design Patterns*, by Michael Mahemoff, O’Reilly,
    2006). Both our approach and the HTTP Streaming pattern have the disadvantage
    of using a long-lived TCP connection, which may be a problem for webservers that
    allow only a finite number of concurrent connections. However, for our approach
    we can control how long the request waits for a server event, thereby limiting
    the number of concurrent connections.
  prefs: []
  type: TYPE_NORMAL
- en: Before we describe the details of this modified Ajax exchange, let’s review
    the big picture. Figure 8-12 shows the sequence for a user requesting a new web
    page, with the first full page update and subsequent partial page updates. In
    terms of timing, events ![](../images/1a.jpg) through ![](../images/10a.jpg) occur
    in quick succession after the user requests the particular web page. At this point,
    the web page is loaded with the latest alarm state. When some alarm state changes
    at event ![](../images/11a.jpg), it triggers events ![](../images/12a.jpg) through
    ![](../images/19a.jpg) in quick succession, at which point the web page is refreshed
    with the new alarm state. This latter sequence repeats until the user navigates
    away from the web page.
  prefs: []
  type: TYPE_NORMAL
- en: '**Browser Sends First HTTP Request**'
  prefs: []
  type: TYPE_NORMAL
- en: The sequence from events ![](../images/1a.jpg) through ![](../images/7a.jpg)
    is the standard HTML request response exchange. In step ![](../images/1a.jpg),
    the user requests a web page, the server responds by sending the web page and,
    in step ![](../images/7a.jpg), the browser displays the page. These steps are
    performed for all web requests regardless of whether the web page includes JavaScript.
    The remaining sequence from event ![](../images/8a.jpg) through ![](../images/19a.jpg)
    is more interesting, and it is this sequence that we’ll describe in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/151-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-12: The Ajax sequence for an external event*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Browser Sends Second HTTP Request**'
  prefs: []
  type: TYPE_NORMAL
- en: On the client side, event ![](../images/8a.jpg) is triggered as soon as the
    web page is loaded for the first time at event ![](../images/7a.jpg). In particular,
    the function GetCurrentStatus() is invoked. Take a look at the HTML source for
    the Zone Status web page by booting up this book’s companion CD and using a browser
    to visit 192.168.1.11.
  prefs: []
  type: TYPE_NORMAL
- en: The default IP address of the Laddie alarm appliance is 192.168.1.11 (and the
    default netmask is 255.255.0.0). When you insert this book’s CD into your computer
    and reboot it, you will then be able to connect to the web UI by typing the URL
    [http://192.168.1.11](http://192.168.1.11/) in any web browser on another computer.
    If the default IP address conflicts with an existing node on your network, you
    can change the IP address for Laddie with the following steps. Quit the framebuffer
    interface (press Q for quit), then at the shell prompt, enter **root** for the
    user and press ENTER for the password (there is no password). Then enter **lynx**
    at the command prompt. From lynx you can navigate to the Network Setup page and
    modify the IP address of the network interfaces. Once you have changed the IP
    address with lynx, you can re-type the URL (with your new IP address) in a browser
    on another computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you view the source for this web page, you will see the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: <body onload="GetCurrentStatus()">
  prefs: []
  type: TYPE_NORMAL
- en: 'The GetCurrentStatus() function then makes an XMLHttpRequest with the URL wait_for_status.php
    (at event ![](../images/9a.jpg)). You’ll see the following code in the file /opt/laddie/web/cgi-bin/status.php
    on this book’s companion CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/152-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This code snippet instructs the browser to send a HTTP GET request with the
    URL wait_for_status.php. It also instructs the browser to invoke the callback
    function GotStatus() when a response is received from the server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Server Blocks Waiting for Alarm State Change**'
  prefs: []
  type: TYPE_NORMAL
- en: On the server side, the script wait_for_status.php is invoked. This script does
    a blocking read on port 4444 at event ![](../images/10a.jpg). Whenever there is
    a change in alarm state in the ladd daemon at event ![](../images/11a.jpg), the
    logmuxd daemon writes a message to port 4444 at event ![](../images/13a.jpg).
    The contents of what is written to the port are unimportant; what is important
    is that the message unblocks the PHP thread at event ![](../images/14a.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Notice in the code above that curr_id is sent with the URL. This variable prevents
    the browser from losing log events when the events come too quickly. This variable
    is passed like a token between the server and the browser, and it increases in
    lock-step with the number of log events. If the curr_id value from the browser
    does not match the number of log events on the server, the PHP thread skips blocking
    on port 4444\. This way, if there are new log events during the time interval
    that the PHP thread is not blocking on port 4444, the PHP thread will continue.
  prefs: []
  type: TYPE_NORMAL
- en: '**Server Sends Alarm State as XML**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the blocking read returns, the PHP script reads the alarm status from
    the ladd alarm daemon (at event ![](../images/15a.jpg)), and combines the data
    into an XML document (at event ![](../images/16a.jpg)). The webserver then passes
    this XML document to the browser (at event ![](../images/17a.jpg)). An example
    XML document looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/153-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Browser Updates Portion of Web Page**'
  prefs: []
  type: TYPE_NORMAL
- en: Back on the client side, the browser receives the XML document, and generates
    an HTML fragment from it; it uses this fragment to update the web page (event
    ![](../images/18a.jpg)). The function GotStatus() in status.php has the following
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/154-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first line extracts the zone data from the XML response, the second line
    generates an HTML fragment specifically for the Laddie status page, and the last
    line inserts the HTML fragment into the displayed page.
  prefs: []
  type: TYPE_NORMAL
- en: '**Browser Repeats by Sending Another HTTP Request**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The browser then invokes another XMLHttpRequest and the process repeats (at
    event ![](../images/19a.jpg)). After a small delay, the GotStatus() function invokes
    GetCurrentStatus() with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: setTimeout("GetCurrentStatus()", 2000);
  prefs: []
  type: TYPE_NORMAL
- en: You can see how this behavior works by opening two web browsers to the status
    page at [http://192.168.1.11](http://192.168.1.11/). If you change the state of
    an alarm zone in one of the browsers, you should see this state change on the
    other web browser, as well.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we have shown a technique for using Ajax to update web pages where
    the update is triggered by events on the server rather than by events on the client.
  prefs: []
  type: TYPE_NORMAL
- en: '**Graceful Degradation Without JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: When designing a web-based appliance, you must decide which web browsers you
    will support. Do you support non-graphical browsers like Lynx, or do you only
    support fully featured browsers? By reducing the level of required browser functionality,
    you can support a wide variety of browsers, but it will be at the expense of an
    increased effort in development. At the other extreme, you could dictate that
    a specific browser be used, with the advantage of using proprietary features,
    but with the risk of some customers disliking your browser selection. Customer
    input would be invaluable in helping you to make this decision.
  prefs: []
  type: TYPE_NORMAL
- en: We chose to support a wide variety of browsers, then sought to reduce the developmental
    effort by avoiding browser-specific code. That is, we avoided code that didn’t
    work the same way on all major browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Of particular concern was the ability to support browsers without JavaScript.
    One of the difficulties with JavaScript is that it can be disabled by the user,
    and even worse, the user may not know that it is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: One approach for supporting browsers with and without JavaScript is to structure
    the website as two “universes”—one universe in which JavaScript is used and another
    in which it isn’t. The home page is written to detect whether JavaScript is enabled
    on the browser and to then redirect the browser to the appropriate universe. Unfortunately,
    this solution does not work if the user disables JavaScript and then reloads a
    particular page. The work-around is for the user to turn on JavaScript and then
    revisit the home page.
  prefs: []
  type: TYPE_NORMAL
- en: We took another approach, one which allows the user to enable or disable JavaScript
    and then simply reload the particular page. This means that each web page must
    support a JavaScript version and a non-JavaScript version. In the past, this problem
    might have been tricky to solve because browsers that didn’t support JavaScript
    were confused by JavaScript code. But this problem is easily solved today, because
    the majority of browsers (even those like Lynx that don’t support JavaScript)
    understand the HTML <SCRIPT> tag. When a modern browser has JavaScript disabled,
    it ignores all HTML code between the pair of tags <SCRIPT> and </SCRIPT>.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hiding JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: The following pattern for hiding JavaScript content from browsers is known to
    work for Internet Explorer (version 5.0 and later), Netscape Navigator (version
    4.72 and later), Firefox (version 1.0 and later), Safari (version 1.0 and later),
    Opera (version 5.0 and later), and Lynx (version 2.8.2 and later).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/155-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The HTML comments <!-- and --> are included as a fail-safe mechanism for those
    old browsers that don’t understand the <SCRIPT> tags. Similarly, you can use <NOSCRIPT>
    and </NOSCRIPT> tags to provide alternate content when JavaScript is not enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Using these patterns, each web page can support both JavaScript and non-JavaScript
    versions, and consequently, the user can change the browser’s JavaScript setting
    and reload the page. Because the user doesn’t have to find and reload some site-wide
    redirection page, the user’s experience is greatly simplified.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Improving Our Design**](toc.html#chapter8.26)'
  prefs: []
  type: TYPE_NORMAL
- en: Having implemented the web UI, we are in a better position to review and improve
    our design. What are some areas that could use improvement?
  prefs: []
  type: TYPE_NORMAL
- en: One problem with the current design is that the logic for configuring network
    interfaces is contained in setup_network.php, and unfortunately, this logic is
    not available to other UIs, like the command line interface (CLI). When we first
    implemented the network setup page, we did not foresee how complex this configuration
    logic would be, and so we decided that all UIs would duplicate this “simple” logic.
    In hindsight, we feel that the design would be improved by subsuming the network
    configuration logic into a single manager, notably the networkd daemon. That way,
    the CLI user interface could provide the same functionality as the network setup
    web page, without duplicating much of the logic in setup_network.php.
  prefs: []
  type: TYPE_NORMAL
- en: We could improve the web UI’s usability by clarifying the relationship between
    the second-level and top-level menus. This might be done using different colors
    for the top-level and second-level menus, as shown in Figure 8-2\. Note in this
    figure that it is easy to see that the second-level item *Components* falls under
    the first-level menu *Tomahawk*.
  prefs: []
  type: TYPE_NORMAL
- en: Another improvement would be to add error-checking functionality on the client
    side. This improvement would be achieved by adding JavaScript functions to check
    the validity of form fields, resulting in a more responsive UI.
  prefs: []
  type: TYPE_NORMAL
- en: We could enhance functionality by adding a web page that would provide diagnostics
    functions for network connectivity and hardware health, such as temperature and
    fan speed. This functionality would allow management software to remotely monitor
    the appliance for degrading performance.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Resources**](toc.html#chapter8.27)'
  prefs: []
  type: TYPE_NORMAL
- en: The following resources will be useful for further study of web page design,
    Ajax, debugging, and testing.
  prefs: []
  type: TYPE_NORMAL
- en: '**UI design** The book *About Face 2.0: The Essentials of User Interaction
    Design* by Alan Cooper and Robert Reimann (Wiley, 2003) is a good book about UI
    design.'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript** A good reference book on JavaScript is the *JavaScript Bible,
    5th Edition* by Danny Goodman and Michael Morrison (Wiley, 2004).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ajax** The Wikipedia web page on Ajax programming is a starting point for
    learning about the technique and includes the history of Ajax. See [http://en.wikipedia.org/wiki/Ajax_(programming](http://en.wikipedia.org/wiki/Ajax_(programming)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTML validation** The World Wide Web Consortium (W3C) provides a free HTML
    validation service at [http://validator.w3.org](http://validator.w3.org/). A CSS
    validation service is also available.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web browsers** Older web browsers, useful for testing your web pages, are
    archived at [http://browsers.evolt.org](http://browsers.evolt.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Debuggers** The Zend Studio debugger allows you to debug PHP code using Microsoft’s
    Internet Explorer and the Apache webserver. Using this browser, you can step through
    PHP code that is executing under Apache. It is a commercial software package,
    available at [http://www.zend.com](http://www.zend.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: '[**Summary**](toc.html#chapter8.28)'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have discussed the development of web UIs for Linux-based
    appliances, in particular, the web UI for Laddie. It has not been our goal to
    discuss all of web technology—you will find entire books on that subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter highlighted the pertinent features of Laddie’s web UI:'
  prefs: []
  type: TYPE_NORMAL
- en: The web UI degrades gracefully for browsers that don’t support JavaScript so
    that the web UI functionality is accessible to a wide variety of browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The alarm status page updates automatically whenever there is a change in the
    alarm state on the appliance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an alarm is triggered, each browser viewing the status web page is refreshed
    automatically.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When any browser is used to clear an alarm, the change is reflected on all other
    browsers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After implementing the web UI, we looked back at our design and suggested some
    future improvements. In particular, we suggested that the logic for configuring
    network interfaces should be moved from PHP into the network daemon, networkd.
    This restructuring would have the advantage that other UIs, for example the CLI,
    could configure network interfaces without duplicating the complex logic in PHP.
    Other improvements include restructuring the menu system and adding JavaScript
    error-checking functions.
  prefs: []
  type: TYPE_NORMAL
