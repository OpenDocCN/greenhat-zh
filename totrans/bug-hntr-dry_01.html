<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Bug Hunting"><div class="titlepage"><div><div><h1 class="title"><a id="bug_hunting"/>Chapter 1. Bug Hunting</h1></div></div></div><p><span class="emphasis"><em>Bug hunting</em></span> is the process of finding bugs in software or hardware. In this book, however, the term <span class="emphasis"><em>bug hunting</em></span> will be used specifically to describe the process of finding security-critical software bugs. Security-critical bugs, also called software security vulnerabilities, allow an attacker to remotely compromise systems, escalate local privileges, cross privilege boundaries, or otherwise wreak havoc on a system.<a id="IDX-CHP-1-0001" class="indexterm"/></p><p>About a decade ago, hunting for software security vulnerabilities was mostly done as a hobby or as a way to gain media attention. Bug hunting found its way into the mainstream when people realized that it’s possible to profit from vulnerabilities.<sup>[<a href="ch01s06.html#ftn.CHP-1-FN-1" class="footnoteref">1</a>]</sup></p><p>Software security vulnerabilities, and programs that take advantage of such vulnerabilities (known as <span class="emphasis"><em>exploits</em></span>), get a lot of press coverage. In addition, numerous books and Internet resources describe the process of exploiting these vulnerabilities, and there are perpetual debates over how to disclose bug findings. Despite all this, surprisingly little has been published on the bug-hunting process itself. Although terms like <span class="emphasis"><em>software vulnerability</em></span> or <span class="emphasis"><em>exploit</em></span> are widely used, many people—even many information security professionals—don’t know how bug hunters find security vulnerabilities in software.<a id="IDX-CHP-1-0002" class="indexterm"/></p><p>If you ask 10 different bug hunters how they search through software for security-related bugs, you will most likely get 10 different answers. This is one of the reasons why there is not, and probably will never be, a “cookbook” for bug hunting. Rather than trying and failing to write a book of generalized instructions, I will describe the approaches and techniques that I used to find specific bugs in real-life software. Hopefully this book will help you develop your own style so you can find some interesting security-critical software bugs.</p><div class="sect1" title="1.1 For Fun and Profit"><div class="titlepage"><div><div><h1 class="title"><a id="for_fun_and_profit"/>1.1 For Fun and Profit</h1></div></div></div><p>People who hunt for bugs have a variety of goals and motivations. Some independent bug hunters want to improve software security, while others seek personal gain in the form of fame, media attention, payment, or employment. A company might want to find bugs to use them as fodder for marketing campaigns. Of course, there are always the bad apples who want to find new ways to break into systems or networks. On the other hand, some people simply do it for fun—or to save the world. <span class="inlinemediaobject"><a id="I_inlinemediaobject1_d1e195"/><img src="httpatomoreillycomsourcenostarchimages939227.png" alt=""/></span></p></div></div>
<div class="sect1" title="1.2 Common Techniques"><div class="titlepage"><div><div><h1 class="title"><a id="common_techniques"/>1.2 Common Techniques</h1></div></div></div><p>Although no formal documentation exists that describes the standard bug-hunting process, common techniques do exist. These techniques can be split into two categories: <span class="emphasis"><em>static</em></span> and <span class="emphasis"><em>dynamic</em></span>. In static analysis, also referred to as <span class="emphasis"><em>static code analysis</em></span>, the source code of the software, or the disassembly of a binary, is examined but not executed. Dynamic analysis, on the other hand, involves debugging or fuzzing the target software while it’s executing. Both techniques have pros and cons, and most bug hunters use a combination of static and dynamic techniques.<a id="IDX-CHP-1-0003" class="indexterm"/><a id="IDX-CHP-1-0004" class="indexterm"/><a id="IDX-CHP-1-0005" class="indexterm"/></p><div class="sect2" title="My Preferred Techniques"><div class="titlepage"><div><div><h2 class="title"><a id="my_preferred_techniques"/>My Preferred Techniques</h2></div></div></div><p>Most of the time, I prefer the static analysis approach. I usually read the source code or disassembly of the target software line by line and try to understand it. However, reading all the code from beginning to end is generally not practical. When I’m looking for bugs, I typically start by trying to identify where user-influenced input data enters the software through an interface to the outside world. This could be network data, file data, or data from the execution environment, to name just a few examples.</p><p>Next, I study the different ways that the input data can travel through the software, while looking for any potentially exploitable code that acts on the data. Sometimes I’m able to identify these entry points solely by reading the source code (see <a class="xref" href="ch02.html" title="Chapter 2. Back to the ’90s">Chapter 2</a>) or the disassembly (see <a class="xref" href="ch06.html" title="Chapter 6. One Kernel to Rule Them All">Chapter 6</a>). In other cases, I have to combine static analysis with the results of debugging the target software (see <a class="xref" href="ch05.html" title="Chapter 5. Browse and You’re Owned">Chapter 5</a>) to find the input-handling code. I also tend to combine static and dynamic approaches when developing an exploit.</p><p>After I’ve found a bug, I want to prove if it’s actually exploitable, so I attempt to build an exploit for it. When I build such an exploit, I spend most of my time in the debugger.</p></div><div class="sect2" title="Potentially Vulnerable Code Locations"><div class="titlepage"><div><div><h2 class="title"><a id="potentially_vulnerable_code_locations"/>Potentially Vulnerable Code Locations</h2></div></div></div><p>This is only one approach to bug hunting. Another tactic for finding potentially vulnerable locations in the code is to look at the code near “unsafe” C/C++ library functions, such as <code class="literal">strcpy()</code> and <code class="literal">strcat()</code>, in search of possible buffer overflows. Alternatively, you could search the disassembly for <code class="literal">movsx</code> assembler instructions in order to find sign-extension vulnerabilities. If you find a potentially vulnerable code location, you can then trace backward through the code to see whether these code fragments expose any vulnerabilities accessible from an application entry point. I rarely use this approach, but other bug hunters swear by it.<a id="IDX-CHP-1-0006" class="indexterm"/><a id="IDX-CHP-1-0007" class="indexterm"/><a id="IDX-CHP-1-0008" class="indexterm"/></p></div><div class="sect2" title="Fuzzing"><div class="titlepage"><div><div><h2 class="title"><a id="fuzzing"/>Fuzzing</h2></div></div></div><p>A completely different approach to bug hunting is known as <span class="emphasis"><em>fuzzing</em></span>. Fuzzing is a dynamic-analysis technique that consists of testing an application by providing it with malformed or unexpected input. Though I’m not an expert in fuzzing and fuzzing frameworks—I know bug hunters who have developed their own fuzzing frameworks and find most of their bugs with their fuzzing tools—I do use this approach from time to time to determine where user-influenced input enters the software and sometimes to find bugs (see <a class="xref" href="ch08.html" title="Chapter 8. The Ringtone Massacre">Chapter 8</a>).</p><p>You may be wondering how fuzzing can be used to identify where user-influenced input enters the software. Imagine you have a complex application in the form of a binary that you want to examine for bugs. It isn’t easy to identify the entry points of such complex applications, but complex software often tends to crash while processing malformed input data. This can hold true for software that parses data files, such as office products, media players, or web browsers. Most of these crashes are not security relevant (e.g., a division-by-zero bug in a browser), but they often provide an entry point where I can start looking for user-influenced input data.</p></div><div class="sect2" title="Further Reading"><div class="titlepage"><div><div><h2 class="title"><a id="further_reading"/>Further Reading</h2></div></div></div><p>These are only a few of the available techniques and approaches that can be used to find bugs in software. For more information on finding security vulnerabilities in source code, I recommend Mark Dowd, John McDonald, and Justin Schuh’s <span class="emphasis"><em>The Art of Software Security Assessment: Identifying and Preventing Software Vulnerabilities</em></span> (Addison-Wesley, 2007). If you want more information about fuzzing, see Michael Sutton, Adam Greene, and Pedram Amini’s <span class="emphasis"><em>Fuzzing: Brute Force Vulnerability Discovery</em></span> (Addison-Wesley, 2007).</p></div></div>
<div class="sect1" title="1.3 Memory Errors"><div class="titlepage"><div><div><h1 class="title"><a id="memory_errors"/>1.3 Memory Errors</h1></div></div></div><p>The vulnerabilities described in this book have one thing in common: They all lead to exploitable memory errors. Such memory errors occur when a process, a thread, or the kernel is<a id="IDX-CHP-1-0009" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Using memory it does not own (e.g., NULL pointer dereferences, as described in Section A.2)<a id="IDX-CHP-1-0010" class="indexterm"/></p></li><li class="listitem"><p>Using more memory than has been allocated (e.g., buffer overflows, as described in Section A.1)</p></li><li class="listitem"><p>Using uninitialized memory (e.g., uninitialized variables)<sup>[<a href="ch01s06.html#ftn.CHP-1-FN-2" class="footnoteref">2</a>]</sup><a id="IDX-CHP-1-0011" class="indexterm"/></p></li><li class="listitem"><p>Using faulty heap-memory management (e.g., double frees)<sup>[<a href="ch01s06.html#ftn.CHP-1-FN-3" class="footnoteref">3</a>]</sup><a id="IDX-CHP-1-0012" class="indexterm"/><a id="IDX-CHP-1-0013" class="indexterm"/></p></li></ul></div><p>Memory errors typically happen when powerful C/C++ features like explicit memory management or pointer arithmetic are used incorrectly.</p><p>A subcategory of memory errors, called <span class="emphasis"><em>memory corruption</em></span>, happens when a process, a thread, or the kernel modifies a memory location that it doesn’t own or when the modification corrupts the state of the memory location.<a id="IDX-CHP-1-0014" class="indexterm"/></p><p>If you’re not familiar with such memory errors, I suggest you have a look at Sections A.1, A.2, and A.3. These sections describe the basics of the programming errors and vulnerabilities discussed in this book.</p><p>In addition to exploitable memory errors, dozens of other vulnerability classes exist. These include logical errors and web-specific vulnerabilities like cross-site scripting, cross-site request forgery, and SQL injection, to name just a few. However, these other vulnerability classes are not the subject of this book. All the bugs discussed in this book were the result of exploitable memory errors.</p></div>
<div class="sect1" title="1.4 Tools of the Trade"><div class="titlepage"><div><div><h1 class="title"><a id="tools_of_the_trade"/>1.4 Tools of the Trade</h1></div></div></div><p>When searching for bugs, or building exploits to test them, I need a way to see inside the workings of applications. I most often use debuggers and disassemblers to gain that inside view.<a id="IDX-CHP-1-0015" class="indexterm"/></p><div class="sect2" title="Debuggers"><div class="titlepage"><div><div><h2 class="title"><a id="debuggers"/>Debuggers</h2></div></div></div><p>A debugger normally provides methods to attach to user space processes or the kernel, write and read values to and from registers and memory, and to control program flow using features such as breakpoints or single-stepping. Each operating system typically ships with its own debugger, but several third-party debuggers are available as well. <a class="xref" href="ch01s04.html#debuggers_used_in_this_book" title="Table 1-1. Debuggers Used in This Book">Table 1-1</a> lists the different operating system platforms and the debuggers used in this book.</p><div class="table"><a id="debuggers_used_in_this_book"/><p class="title">Table 1-1. Debuggers Used in This Book</p><div class="table-contents"><table summary="Debuggers Used in This Book" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Operating system<a id="IDX-CHP-1-0016" class="indexterm"/><a id="IDX-CHP-1-0017" class="indexterm"/><a id="IDX-CHP-1-0018" class="indexterm"/><a id="IDX-CHP-1-0019" class="indexterm"/><a id="IDX-CHP-1-0020" class="indexterm"/><a id="IDX-CHP-1-0021" class="indexterm"/><a id="IDX-CHP-1-0022" class="indexterm"/><a id="IDX-CHP-1-0023" class="indexterm"/><a id="IDX-CHP-1-0024" class="indexterm"/><a id="IDX-CHP-1-0025" class="indexterm"/></p></th><th style="text-align: left" valign="bottom"><p>Debugger</p></th><th style="text-align: left" valign="bottom"><p>Kernel debugging<a id="IDX-CHP-1-0026" class="indexterm"/></p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>Microsoft</p></td><td style="text-align: left" valign="top"><p>WinDbg (the official debugger from Microsoft)<a id="IDX-CHP-1-0027" class="indexterm"/><a id="IDX-CHP-1-0028" class="indexterm"/></p></td><td style="text-align: left" valign="top"><p>yes</p></td></tr><tr><td style="text-align: left" valign="top"><p>Windows</p></td><td style="text-align: left" valign="top"><p>OllyDbg and its variant Immunity Debugger<a id="IDX-CHP-1-0029" class="indexterm"/><a id="IDX-CHP-1-0030" class="indexterm"/><a id="IDX-CHP-1-0031" class="indexterm"/></p></td><td style="text-align: left" valign="top"><p>no</p></td></tr><tr><td style="text-align: left" valign="top"><p>Linux</p></td><td style="text-align: left" valign="top"><p>The GNU Debugger (gdb)<a id="IDX-CHP-1-0032" class="indexterm"/></p></td><td style="text-align: left" valign="top"><p>yes</p></td></tr><tr><td style="text-align: left" valign="top"><p>Solaris</p></td><td style="text-align: left" valign="top"><p>The Modular Debugger (mdb)<a id="IDX-CHP-1-0033" class="indexterm"/></p></td><td style="text-align: left" valign="top"><p>yes</p></td></tr><tr><td style="text-align: left" valign="top"><p>Mac OS X<a id="IDX-CHP-1-0034" class="indexterm"/><a id="IDX-CHP-1-0035" class="indexterm"/></p></td><td style="text-align: left" valign="top"><p>The GNU Debugger (gdb)</p></td><td style="text-align: left" valign="top"><p>yes</p></td></tr><tr><td style="text-align: left" valign="top"><p>Apple iOS</p></td><td style="text-align: left" valign="top"><p>The GNU Debugger (gdb)</p></td><td style="text-align: left" valign="top"><p>yes</p></td></tr></tbody></table></div></div><p>These debuggers will be used to identify, analyze and exploit the vulnerabilities that I discovered. See also Sections B.1, B.2, and B.4 for some debugger command cheat sheets.</p></div><div class="sect2" title="Disassemblers"><div class="titlepage"><div><div><h2 class="title"><a id="disassemblers"/>Disassemblers</h2></div></div></div><p>If you want to audit an application and don’t have access to the source code, you can analyze the program binaries by reading the application’s assembly code. Although debuggers have the ability to disassemble the code of a process or the kernel, they usually are not especially easy or intuitive to work with. A program that fills this gap is the Interactive Disassembler Professional, better known as IDA Pro.<sup>[<a href="ch01s06.html#ftn.CHP-1-FN-4" class="footnoteref">4</a>]</sup> IDA Pro supports more than 50 families of processors and provides full interactivity, extensibility, and code graphing. If you want to audit a program binary, IDA Pro is a must-have. For an exhaustive treatment of IDA Pro and all of its features, consult Chris Eagle’s <span class="emphasis"><em>The IDA Pro Book</em></span>, 2nd edition (No Starch Press, 2011).</p></div></div>
<div class="sect1" title="1.5 EIP = 41414141"><div class="titlepage"><div><div><h1 class="title"><a id="eip_equals_41414141"/>1.5 EIP = 41414141</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Instruction pointer/Program counter:</em></span><a id="IDX-CHP-1-0036" class="indexterm"/><a id="IDX-CHP-1-0037" class="indexterm"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>EIP—32-bit instruction pointer (IA-32)</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>RIP—64-bit instruction pointer (Intel 64)</em></span><a id="IDX-CHP-1-0038" class="indexterm"/></p></li><li class="listitem"><p><span class="emphasis"><em>R15 or PC—ARM architecture as used on Apple’s iPhone</em></span></p></li></ul></div></div><p>To illustrate the security implications of the bugs that I found, I will discuss the steps needed to gain control of the execution flow of the vulnerable program by controlling the instruction pointer (IP) of the CPU. The instruction pointer or program counter (PC) register contains the offset in the current code segment for the next instruction to be executed.<sup>[<a href="ch01s06.html#ftn.CHP-1-FN-5" class="footnoteref">5</a>]</sup> If you gain control of this register, you fully control the execution flow of the vulnerable process. To demonstrate instruction pointer control, I will modify the register to values like <code class="literal">0x41414141</code> (hexadecimal representation of ASCII “<code class="literal">AAAA</code>”), <code class="literal">0x41424344</code> (hexadecimal representation of ASCII “<code class="literal">ABCD</code>”), or something similar. So if you see <code class="literal">EIP = 41414141</code> in the following chapters, it means that I’ve gained control of the vulnerable process.<a id="IDX-CHP-1-0039" class="indexterm"/></p><p>Once you achieve control over the instruction pointer, there are many ways to turn it into a fully working, weaponized exploit. For more information on the process of exploit development, you can refer to Jon Erickson’s <span class="emphasis"><em>Hacking: The Art of Exploitation</em></span>, 2nd edition (No Starch Press, 2008), or you can type <span class="emphasis"><em>exploit writing</em></span> into Google and browse through the enormous amount of material available online.</p></div>
<div class="sect1" title="1.6 Final Note"><div class="titlepage"><div><div><h1 class="title"><a id="final_note"/>1.6 Final Note</h1></div></div></div><p>We’ve covered a lot of ground in this chapter, and you might be left with a lot of questions. Don’t worry—that’s a fine place to be. The following seven diary chapters delve into more detail on the topics introduced here and will answer many of your questions. You can also read through the appendixes for background information on various topics discussed throughout this book.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The diary chapters are not in chronological order. They’re arranged according to the subject matter so that the concepts build on one another.</p></div><div class="sect2" title="Notes"><div class="titlepage"><div><div><h2 class="title"><a id="notes"/>Notes</h2></div></div></div><p><sup>[<a id="CHP-1-FN-1" href="#ftn.CHP-1-FN-1" class="footnote">1</a>]</sup></p><p><sup>[<a id="CHP-1-FN-2" href="#ftn.CHP-1-FN-2" class="footnote">2</a>]</sup></p><p><sup>[<a id="CHP-1-FN-3" href="#ftn.CHP-1-FN-3" class="footnote">3</a>]</sup></p><p><sup>[<a id="CHP-1-FN-4" href="#ftn.CHP-1-FN-4" class="footnote">4</a>]</sup></p><p><sup>[<a id="CHP-1-FN-5" href="#ftn.CHP-1-FN-5" class="footnote">5</a>]</sup></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-1-FN-1" href="#CHP-1-FN-1" class="para">1</a>] </sup>See Pedram Amini, “Mostrame la guita! Adventures in Buying Vulnerabilities,” 2009, <a class="ulink" href="http://docs.google.com/present/view?id=dcc6wpsd_20ghbpjxcr">http://docs.google.com/present/view?id=dcc6wpsd_20ghbpjxcr</a>; Charlie Miller, “The Legitimate Vulnerability Market: Inside the Secretive World of 0-day Exploit Sales,” 2007, <a class="ulink" href="http://weis2007.econinfosec.org/papers/29.pdf">http://weis2007.econinfosec.org/papers/29.pdf</a>; iDefense Labs Vulnerability Contribution Program, <a class="ulink" href="https://labs.idefense.com/vcpportal/login.html">https://labs.idefense.com/vcpportal/login.html</a>; TippingPoint’s Zero Day Initiative, <a class="ulink" href="http://www.zerodayinitiative.com/">http://www.zerodayinitiative.com/</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-1-FN-2" href="#CHP-1-FN-2" class="para">2</a>] </sup>See Daniel Hodson, “Uninitialized Variables: Finding, Exploiting, Automating” (presentation, Ruxcon, 2008), <a class="ulink" href="http://felinemenace.org/~mercy/slides/RUXCON2008-UninitializedVariables.pdf">http://felinemenace.org/~mercy/slides/RUXCON2008-UninitializedVariables.pdf</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-1-FN-3" href="#CHP-1-FN-3" class="para">3</a>] </sup>See Common Weakness Enumeration, CWE List, CWE - Individual Dictionary Definition (2.0), CWE-415: Double Free at <a class="ulink" href="http://cwe.mitre.org/data/definitions/415.html">http://cwe.mitre.org/data/definitions/415.html</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-1-FN-4" href="#CHP-1-FN-4" class="para">4</a>] </sup>See <a class="ulink" href="http://www.hex-rays.com/idapro/">http://www.hex-rays.com/idapro/</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-1-FN-5" href="#CHP-1-FN-5" class="para">5</a>] </sup>See <span class="emphasis"><em>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1: Basic Architecture</em></span> at <a class="ulink" href="http://www.intel.com/products/processor/manuals/">http://www.intel.com/products/processor/manuals/</a>.</p></div></div></div></body></html>