<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Solving Problems with Recursion"><div class="titlepage"><div><div><h1 class="title"><a id="solving_problems_with_recursion"/>Chapter 6. Solving Problems with Recursion</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id6"/><div class="mediaobject"><a id="I_mediaobject6_d1e11508"/><img src="httpatomoreillycomsourcenostarchimages1273151.png.jpg" alt="image with no caption"/></div></div><p>This chapter is about <span class="emphasis"><em>recursion</em></span>, which is when a function directly or indirectly calls itself. Recursive programming looks as if it should be simple. Indeed, a good recursive solution often has a simple, almost elegant appearance. However, very often the route to that solution is anything but simple. This is because recursion requires us to think differently than we do with other types of programming. When we process data using loops, we’re thinking about processing in a sequential manner, but when we process data using recursion, our normal sequential thinking process won’t help. Many good, fledgling programmers struggle with recursion because they can’t see a way to apply the problem-solving skills they’ve learned to recursive problems. In this chapter, we’ll discuss how to attack recursive problems systematically. The answer is using what we will call the <span class="emphasis"><em>Big Recursive Idea</em></span>, henceforth referred to as the BRI. It’s an idea that’s so straightforward it will seem like a trick, but it works.<a id="IDX-CHP-6-0001" class="indexterm"/><a id="IDX-CHP-6-0002" class="indexterm"/><a id="IDX-CHP-6-0003" class="indexterm"/></p><div class="sect1" title="Review of Recursion Fundamentals"><div class="titlepage"><div><div><h1 class="title"><a id="review_of_recursion_fundamentals"/>Review of Recursion Fundamentals</h1></div></div></div><p>There is not much to know about the <span class="emphasis"><em>syntax</em></span> of recursion; the difficulty arises when you try to use recursion to solve problems. Recursion occurs any time a function calls itself, so the syntax of recursion is just the syntax of a function call. The most common form is <span class="emphasis"><em>direct recursion</em></span>, when a call to a function occurs in the body of that same function. For example:<a id="IDX-CHP-6-0004" class="indexterm"/><a id="IDX-CHP-6-0005" class="indexterm"/></p><a id="I_programlisting6_d1e11551"/><pre class="programlisting">int factorial(int n) {
  <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>if (n == 1) return 1;
   else return n * <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>factorial(n - 1);
}</pre><p>This function, which is a common but highly inefficient demonstration of recursion, computes the factorial of <span class="emphasis"><em>n</em></span>. For example, if <span class="emphasis"><em>n</em></span> is 5, then the factorial is the product of all the numbers from 5 to 1, or 120. Note that in some cases no recursion occurs. In this function, if the parameter is 1, we simply return a value directly without any recursion <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e11573"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, which is known as a <span class="emphasis"><em>base case</em></span>. Otherwise, we make the recursive call <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e11582"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>.<a id="IDX-CHP-6-0006" class="indexterm"/><a id="IDX-CHP-6-0007" class="indexterm"/></p><p>The other form of recursion is <span class="emphasis"><em>indirect recursion</em></span>—for example, if function A calls function B, which later calls function A. Indirect recursion is rarely used as a problem-solving technique, so we won’t cover it here.<a id="IDX-CHP-6-0008" class="indexterm"/><a id="IDX-CHP-6-0009" class="indexterm"/></p></div><div class="sect1" title="Head and Tail Recursion"><div class="titlepage"><div><div><h1 class="title"><a id="head_and_tail_recursion"/>Head and Tail Recursion</h1></div></div></div><p>Before we discuss the BRI, we need to understand the difference between head recursion and tail recursion. In <span class="emphasis"><em>head recursion</em></span>, the recursive call, when it happens, comes before other processing in the function (think of it happening at the top, or head, of the function). In <span class="emphasis"><em>tail recursion</em></span>, it’s the opposite—the processing occurs before the recursive call. Choosing between the two recursive styles may seem arbitrary, but the choice can make all the difference. To illustrate this difference, let’s look at two problems.<a id="IDX-CHP-6-0010" class="indexterm"/><a id="IDX-CHP-6-0011" class="indexterm"/><a id="IDX-CHP-6-0012" class="indexterm"/><a id="IDX-CHP-6-0013" class="indexterm"/></p><div class="sidebar"><a id="problem_colon_how_many_parrots_question"/><p class="title">Problem: How Many Parrots?</p><p>Passengers on the Tropical Paradise Railway (TPR) look forward to seeing dozens of colorful parrots from the train windows. Because of this, the railway takes a keen interest in the health of the local parrot population and decides to take a tally of the number of parrots in view of each train platform along the main line. Each platform is staffed by a TPR employee (see <a class="xref" href="ch06.html#the_employees_at_the_five_stations_can_c" title="Figure 6-1. The employees at the five stations can communicate only with their immediate neighbors.">Figure 6-1</a>), who is certainly capable of counting parrots. Unfortunately, the job is complicated by the primitive telephone system. Each platform can call only its immediate neighbors. How do we get the parrot total at the main line terminal?</p></div><div class="figure"><a id="the_employees_at_the_five_stations_can_c"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e11647"/><img src="httpatomoreillycomsourcenostarchimages1273251.png.jpg" alt="The employees at the five stations can communicate only with their immediate neighbors."/></div></div><p class="title">Figure 6-1. The employees at the five stations can communicate only with their immediate neighbors.</p></div><p>Let’s suppose that there are 7 parrots by Art at the main terminal, 5 parrots by Belinda, 3 parrots by Cory, 10 parrots by Debbie, and 2 parrots by Evan at the last station. The total number of parrots is thus 27. The question is, how are the employees going to work together to communicate this total to Art? Any solution to this problem is going to require a chain of communications all the way from the main terminal to the end of the line and back. The staff member at each platform will be requested to count parrots and will then report his or her observations. Even so, there are two distinct approaches to this communications chain, and those approaches correspond to the head recursion and tail recursion techniques in programming.<a id="IDX-CHP-6-0014" class="indexterm"/><a id="IDX-CHP-6-0015" class="indexterm"/><a id="IDX-CHP-6-0016" class="indexterm"/></p><div class="sect2" title="Approach 1"><div class="titlepage"><div><div><h2 class="title"><a id="approach_1"/>Approach 1</h2></div></div></div><p>In this approach, we keep a running total of the parrots as we progress through the outbound communications. Each employee, when making the request of the next employee down the line, passes along the number of parrots seen so far. When we get to the end of the line, Evan will be the first to discover the parrot total, which he will pass up to Debbie, who will pass it to Cory, and so on (as shown in <a class="xref" href="ch06.html#numbering_of_steps_taken_in_approach_1_f" title="Figure 6-2. Numbering of steps taken in Approach 1 for the parrot-counting problem">Figure 6-2</a>).</p><div class="figure"><a id="numbering_of_steps_taken_in_approach_1_f"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e11677"/><img src="httpatomoreillycomsourcenostarchimages1273253.png.jpg" alt="Numbering of steps taken in Approach 1 for the parrot-counting problem"/></div></div><p class="title">Figure 6-2. Numbering of steps taken in Approach 1 for the parrot-counting problem</p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>ART begins by counting the parrots around his platform. He counts 7 parrots.</p></li><li class="listitem"><p>ART to BELINDA: “There are 7 parrots here at the main terminal.”</p></li><li class="listitem"><p>BELINDA counts 5 parrots around her platform for a running total of 12.</p></li><li class="listitem"><p>BELINDA to CORY: “There are 12 parrots around the first two stations.”</p></li><li class="listitem"><p>CORY counts 3 parrots.</p></li><li class="listitem"><p>CORY to DEBBIE: “There are 15 parrots around the first three stations.”<a id="IDX-CHP-6-0017" class="indexterm"/><a id="IDX-CHP-6-0018" class="indexterm"/></p></li><li class="listitem"><p>DEBBIE counts 10 parrots.</p></li><li class="listitem"><p>DEBBIE to EVAN: “There are 25 parrots around the first four stations.”</p></li><li class="listitem"><p>EVAN counts 2 parrots and discovers that the total number of parrots is 27.</p></li><li class="listitem"><p>EVAN to DEBBIE: “The total number of parrots is 27.”</p></li><li class="listitem"><p>DEBBIE to CORY: “The total number of parrots is 27.”</p></li><li class="listitem"><p>CORY to BELINDA: “The total number of parrots is 27.”</p></li><li class="listitem"><p>BELINDA to ART: “The total number of parrots is 27.”</p></li></ol></div><p>This approach is analogous to tail recursion. In tail recursion, the recursive call happens after the processing—the recursive call is the last step in the function. In the communications chain above, note that the “work” of the employees—the parrot counting and summation—happens before they signal the next employee down the line. All of the work happens on the outbound communications chain, not the inbound chain. Here are the steps each employee follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Count the parrots visible from the station platform.</p></li><li class="listitem"><p>Add this count to the total given by the previous station.</p></li><li class="listitem"><p>Call the next station to pass along the running sum of parrot counts.</p></li><li class="listitem"><p>Wait for the next station to call with the total parrot count, and then pass this total up to the previous station.</p></li></ol></div></div><div class="sect2" title="Approach 2"><div class="titlepage"><div><div><h2 class="title"><a id="approach_2"/>Approach 2</h2></div></div></div><p>In this approach, we sum the parrot counts from the other end. Each employee, when contacting the next station down the line, requests the total number of parrots from that station onward. The employee then adds the number of parrots at his or her own station and passes this new total up the line (as shown in <a class="xref" href="ch06.html#numbering_of_steps_taken_in_approach_2_f" title="Figure 6-3. Numbering of steps taken in Approach 2 for the parrot-counting problem">Figure 6-3</a>).</p><div class="figure"><a id="numbering_of_steps_taken_in_approach_2_f"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e11756"/><img src="httpatomoreillycomsourcenostarchimages1273255.png.jpg" alt="Numbering of steps taken in Approach 2 for the parrot-counting problem"/></div></div><p class="title">Figure 6-3. Numbering of steps taken in Approach 2 for the parrot-counting problem</p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>ART to BELINDA: “What’s the total number of parrots from your station to the end of the line?”</p></li><li class="listitem"><p>BELINDA to CORY: “What’s the total number of parrots from your station to the end of the line?”</p></li><li class="listitem"><p>CORY to DEBBIE: “What’s the total number of parrots from your station to the end of the line?”</p></li><li class="listitem"><p>DEBBIE to EVAN: “What’s the total number of parrots from your station to the end of the line?”</p></li><li class="listitem"><p>EVAN is the end of the line. He counts 2 parrots.</p></li><li class="listitem"><p>EVAN to DEBBIE: “The total number of parrots here at the end is 2.”</p></li><li class="listitem"><p>DEBBIE counts 10 parrots at her station, so the total from her station to the end is 12.</p></li><li class="listitem"><p>DEBBIE to CORY: “The total number of parrots from here to the end is 12.”</p></li><li class="listitem"><p>CORY counts 3 parrots.</p></li><li class="listitem"><p>CORY to BELINDA: “The total number of parrots from here to the end is 15.”</p></li><li class="listitem"><p>BELINDA counts 5 parrots.</p></li><li class="listitem"><p>BELINDA to ART: “The total number of parrots from here to the end is 20.”</p></li><li class="listitem"><p>ART counts 7 parrots at the main terminal, making a total of 27.</p></li></ol></div><p>This approach is analogous to head recursion. In head recursion, the recursive call happens before the other processing. Here, the call to the next station happens first, before counting the parrots or the summation. The “work” is postponed until after the stations down the line have reported their totals. Here are the steps each employee follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Call the next station.</p></li><li class="listitem"><p>Count the parrots visible from the station platform.</p></li><li class="listitem"><p>Add this count to the total given by the next station.</p></li><li class="listitem"><p>Pass the resulting sum up to the previous station.</p></li></ol></div><p>You may have noticed two practical effects of the different approaches. In the first approach, eventually all of the station employees will learn the overall parrot total. In the second approach, only Art, at the main terminal, learns the full total—but note that Art is the only employee who needs the full total.</p><p>The other practical effect will become more important for our analysis when we transition the discussion to actual programming code. In the first approach, each employee passes along the “running total” to the next station down the line when making the request. In the second approach, the employee simply makes the request for information from the next station, without passing any data down the line. This effect is typical of the head recursion approach. Because the recursive call happens first, before any other processing, there is no new information to give the recursive call. In general, the head recursion approach allows the minimum set of data to be passed to the recursive call. Now let’s look at another problem.</p><div class="sidebar"><a id="problem_colon_whoas_our_best_customer_qu"/><p class="title">Problem: Who’s Our Best Customer?</p><p>The manager of DelegateCorp needs to determine which of eight customers produces the most revenue for his company. Two factors complicate this otherwise simple task. First, determining the total revenue for a customer requires going through that customer’s whole file and tallying numbers on dozens of orders and receipts. Second, the employees of DelegateCorp, as the name suggests, love to delegate, and each employee passes work along to someone at a lower level whenever possible. To keep the situation from getting out of hand, the manager enforces a rule: When you delegate, you must do some portion of the work yourself, and you have to give the delegated employee less work than you were given.</p></div><p><a class="xref" href="ch06.html#delegatecorp_employee_titles_and_rank" title="Table 6-1. DelegateCorp Employee Titles and Rank">Table 6-1</a> and <a class="xref" href="ch06.html#delegatecorp_customers" title="Table 6-2. DelegateCorp Customers">Table 6-2</a> identify the employees and customers of DelegateCorp.</p><div class="table"><a id="delegatecorp_employee_titles_and_rank"/><p class="title">Table 6-1. DelegateCorp Employee Titles and Rank</p><div class="table-contents"><table summary="DelegateCorp Employee Titles and Rank" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Title</p></th><th style="text-align: left" valign="bottom"><p>Rank</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>Manager</p></td><td style="text-align: left" valign="top"><p>1</p></td></tr><tr><td style="text-align: left" valign="top"><p>Vice manager</p></td><td style="text-align: left" valign="top"><p>2</p></td></tr><tr><td style="text-align: left" valign="top"><p>Associate manager</p></td><td style="text-align: left" valign="top"><p>3</p></td></tr><tr><td style="text-align: left" valign="top"><p>Assistant manager</p></td><td style="text-align: left" valign="top"><p>4</p></td></tr><tr><td style="text-align: left" valign="top"><p>Junior manager</p></td><td style="text-align: left" valign="top"><p>5</p></td></tr><tr><td style="text-align: left" valign="top"><p>Intern</p></td><td style="text-align: left" valign="top"><p>6</p></td></tr></tbody></table></div></div><div class="table"><a id="delegatecorp_customers"/><p class="title">Table 6-2. DelegateCorp Customers</p><div class="table-contents"><table summary="DelegateCorp Customers" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Customer Number</p></th><th style="text-align: left" valign="bottom"><p>Revenue</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>#0001</p></td><td style="text-align: left" valign="top"><p>$172,000</p></td></tr><tr><td style="text-align: left" valign="top"><p>#0002</p></td><td style="text-align: left" valign="top"><p>$68,000</p></td></tr><tr><td style="text-align: left" valign="top"><p>#0003</p></td><td style="text-align: left" valign="top"><p>$193,000</p></td></tr><tr><td style="text-align: left" valign="top"><p>#0004</p></td><td style="text-align: left" valign="top"><p>$13,000</p></td></tr><tr><td style="text-align: left" valign="top"><p>#0005</p></td><td style="text-align: left" valign="top"><p>$256,000</p></td></tr><tr><td style="text-align: left" valign="top"><p>#0006</p></td><td style="text-align: left" valign="top"><p>$99,000</p></td></tr></tbody></table></div></div><p>Following the company rule on delegating work, here’s what will happen to the six customer files. The manager will take one file and determine how much revenue that customer has generated for the company. The manager will delegate the other five files to the vice manager. The vice manager will process one file and pass the other four to the associate manager. This process continues until we reach the sixth employee, the intern, who is handed one file and must simply process it, with no further delegation possible.</p><p><a class="xref" href="ch06.html#the_numbering_of_steps_in_approach_1_ope" title="Figure 6-4. The numbering of steps in Approach 1 (a) and Approach 2 (b) for finding the highest-revenue customer">Figure 6-4</a> describes the lines of communication and the division of labor. As with the previous example, though, there are two distinct approaches to the communications chain.</p><div class="figure"><a id="the_numbering_of_steps_in_approach_1_ope"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e11954"/><img src="httpatomoreillycomsourcenostarchimages1273257.png.jpg" alt="The numbering of steps in Approach 1 (a) and Approach 2 (b) for finding the highest-revenue customer"/></div></div><p class="title">Figure 6-4. The numbering of steps in Approach 1 (a) and Approach 2 (b) for finding the highest-revenue customer</p></div></div><div class="sect2" title="Approach 1"><div class="titlepage"><div><div><h2 class="title"><a id="approach_1-id1"/>Approach 1</h2></div></div></div><p>In this approach, when delegating the remaining files, the employee also passes along the highest amount of revenue seen so far. This means that the employee must tally the revenue in one file and compare this to the previous highest amount seen before delegating the remaining files to another employee. Here’s an example of how this would proceed in practice.<a id="IDX-CHP-6-0019" class="indexterm"/><a id="IDX-CHP-6-0020" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>MANAGER tallies the revenue for customer #0001, which is $172,000.</p></li><li class="listitem"><p>MANAGER to VICE MANAGER: “The highest revenue we have seen so far is $172,000, customer #0001. Take these five files and determine the overall highest revenue.”</p></li><li class="listitem"><p>VICE MANAGER tallies the revenue for customer #0002, which is $68,000. The highest revenue seen so far is still $172,000, customer #0001.</p></li><li class="listitem"><p>VICE MANAGER to ASSOCIATE MANAGER: “The highest revenue we have seen so far is $172,000, customer #0001. Take these four files and determine the overall highest revenue.”</p></li><li class="listitem"><p>ASSOCIATE MANAGER tallies the revenue for customer #0003, which is $193,000. The highest revenue seen so far is now $193,000, customer #0003.</p></li><li class="listitem"><p>ASSOCIATE MANAGER to ASSISTANT MANAGER: “The highest revenue we have seen so far is $193,000, customer #0003. Take these three files and determine the overall highest revenue.”</p></li><li class="listitem"><p>ASSISTANT MANAGER tallies the revenue for customer #0004, which is $13,000. The highest revenue seen so far is still $193,000, customer #0003.</p></li><li class="listitem"><p>ASSISTANT MANAGER to JUNIOR MANAGER: “The highest revenue we have seen so far is $193,000, customer #0003. Take these two files and determine the overall highest revenue.”</p></li><li class="listitem"><p>JUNIOR MANAGER tallies the revenue for customer #0005, which is $256,000. The highest revenue seen so far is now $256,000, customer #0005.</p></li><li class="listitem"><p>JUNIOR MANAGER to INTERN: “The highest revenue we have seen so far is $256,000, customer #0005. Take this remaining file and determine the overall highest revenue.”</p></li><li class="listitem"><p>INTERN tallies the revenue for customer #0006, which is $99,000. The highest revenue seen so far is still $256,000, customer #0005.</p></li><li class="listitem"><p>INTERN to JUNIOR MANAGER: “The highest revenue of all customers is $256,000, customer #0005.”</p></li><li class="listitem"><p>JUNIOR MANAGER to ASSISTANT MANAGER: “The highest revenue of all customers is $256,000, customer #0005.”</p></li><li class="listitem"><p>ASSISTANT MANAGER to ASSOCIATE MANAGER: “The highest revenue of all customers is $256,000, customer #0005.”</p></li><li class="listitem"><p>ASSOCIATE MANAGER to VICE MANAGER: “The highest revenue of all customers is $256,000, customer #0005.”</p></li><li class="listitem"><p>VICE MANAGER to MANAGER: “The highest revenue of all customers is $256,000, customer #0005.”</p></li></ol></div><p>This approach, shown in <a class="xref" href="ch06.html#the_numbering_of_steps_in_approach_1_ope" title="Figure 6-4. The numbering of steps in Approach 1 (a) and Approach 2 (b) for finding the highest-revenue customer">Figure 6-4</a> (a), uses the tail recursion technique. Each employee processes one customer file and compares the computed revenue for that customer against the highest revenue seen so far. Then the employee passes the result of that comparison to the subordinate employee. The recursion—the passing off of work—happens after the other processing. Each employee’s process runs like this:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Tally the revenue in one customer file.</p></li><li class="listitem"><p>Compare this total with the highest revenue seen by superiors in other customer files.</p></li><li class="listitem"><p>Pass the remaining customer files to a subordinate employee, along with the highest revenue amount seen so far.</p></li><li class="listitem"><p>When the subordinate employee returns the highest revenue of all the customer files, pass this back to the superior.</p></li></ol></div></div><div class="sect2" title="Approach 2"><div class="titlepage"><div><div><h2 class="title"><a id="approach_2-id1"/>Approach 2</h2></div></div></div><p>In this approach, each employee begins by setting aside one file and then passing the others to the subordinate. In this case, the subordinate isn’t asked to determine the highest revenue of all the files, just of the files the subordinate has been given. As with the first sample problem, this simplifies the requests. Using the same data as the first approach, the conversation would be as follows:<a id="IDX-CHP-6-0021" class="indexterm"/><a id="IDX-CHP-6-0022" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>MANAGER to VICE MANAGER: “Take these five customer files, and tell me the highest revenue.”</p></li><li class="listitem"><p>VICE MANAGER to ASSOCIATE MANAGER: “Take these four customer files, and tell me the highest revenue.”</p></li><li class="listitem"><p>ASSOCIATE MANAGER to ASSISTANT MANAGER: “Take these three customer files, and tell me the highest revenue.”</p></li><li class="listitem"><p>ASSISTANT MANAGER to JUNIOR MANAGER: “Take these two customer files, and tell me the highest revenue.”</p></li><li class="listitem"><p>JUNIOR MANAGER to INTERN: “Take this one customer file, and tell me the highest revenue.”</p></li><li class="listitem"><p>INTERN tallies the revenue for customer #0006, which is $99,000. This is the only file the INTERN has seen, so that’s the highest revenue.</p></li><li class="listitem"><p>INTERN to JUNIOR MANAGER: “The highest revenue in my files is $99,000, customer #0006.”</p></li><li class="listitem"><p>JUNIOR MANAGER tallies the revenue for customer #0005, which is $256,000. The highest revenue this employee knows about is $256,000, customer #0005.</p></li><li class="listitem"><p>JUNIOR MANAGER to ASSISTANT MANAGER: “The highest revenue in my files is $256,000, customer #0005.”</p></li><li class="listitem"><p>ASSISTANT MANAGER tallies the revenue for customer #0004, which is $13,000. The highest revenue this employee knows about is $256,000, customer #0005.</p></li><li class="listitem"><p>ASSISTANT MANAGER to ASSOCIATE MANAGER: “The highest revenue in my files is $256,000, customer #0005.”</p></li><li class="listitem"><p>ASSOCIATE MANAGER tallies the revenue for customer #0003, which is $193,000. The highest revenue this employee knows about is $256,000, customer #0005.</p></li><li class="listitem"><p>ASSOCIATE MANAGER to VICE MANAGER: “The highest revenue in my files is $256,000, customer #0005.”</p></li><li class="listitem"><p>VICE MANAGER tallies the revenue for customer #0002, which is $68,000. The highest revenue this employee knows about is $256,000, customer #0005.</p></li><li class="listitem"><p>VICE MANAGER to MANAGER: “The highest revenue in my files is $256,000, customer #0005.”</p></li><li class="listitem"><p>MANAGER tallies the revenue for customer #0001, which is $172,000. The highest revenue this employee knows about is $256,000, customer #0005.</p></li></ol></div><p>This approach, shown in <a class="xref" href="ch06.html#the_numbering_of_steps_in_approach_1_ope" title="Figure 6-4. The numbering of steps in Approach 1 (a) and Approach 2 (b) for finding the highest-revenue customer">Figure 6-4</a> (b), uses the head recursion technique. Each employee still has to tally the revenue in one customer file, but that action is postponed until after the subordinate employee determines the highest revenue among the remaining files. The process each employee takes is as follows:<a id="IDX-CHP-6-0023" class="indexterm"/><a id="IDX-CHP-6-0024" class="indexterm"/><a id="IDX-CHP-6-0025" class="indexterm"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Pass all customer files except one to a subordinate employee.</p></li><li class="listitem"><p>Get the highest revenue of those files back from the subordinate employee.</p></li><li class="listitem"><p>Tally the revenue in the one customer file.</p></li><li class="listitem"><p>Pass the larger of those two revenues to the superior.</p></li></ol></div><p>As in the “counting parrots” problem, the head recursion technique allows each employee to pass the minimum amount of information to the subordinate.</p></div></div><div class="sect1" title="The Big Recursive Idea"><div class="titlepage"><div><div><h1 class="title"><a id="the_big_recursive_idea"/>The Big Recursive Idea</h1></div></div></div><p>We now arrive at the Big Recursive Idea. In fact, if you’ve read through the steps of the sample problems, you have already seen the BRI in action.</p><p>How so? Both of the sample problems follow the form of a recursive solution. Each person in the communications chain performs the same steps on a smaller and smaller subset of the original data. It’s important to note, however, that <span class="emphasis"><em>the problems involve no recursion at all</em></span>.</p><p>In the first problem, each railway employee makes a request of the next station down the line, and in fulfilling that request, the next employee follows the same steps as the previous employee. But nothing in the wording of the request requires an employee to follow those particular steps. When Art called Belinda using Approach 2, for example, he asked her to count the total number of parrots from her station to the end of the line. He did not dictate a method for discovering this total. If he thought about it, he might have realized that Belinda would have to follow the same steps that he himself was following, but he doesn’t have to consider this. To complete his task, all Art required was for Belinda to provide the correct answer to the question he asked.</p><p>Likewise, in the second problem, each employee in the management chain hands off as much work as possible to a subordinate. The assistant manager, for example, may know the junior manager well and expect the junior manager to hand all of the files but one to the intern. However, the assistant manager has no reason to care whether the junior manager processes all of the remaining files or passes some of them off to a subordinate. The assistant manager cares only that the junior manager returns the right answer. Because the assistant manager is not going to repeat the work of the junior manager, the assistant manager simply assumes that the result returned by the junior manager is correct and uses that data to solve the overall task that the assistant manager received from the associate manager.</p><p>In both problems, when employees make requests of other employees, they are concerned with <span class="emphasis"><em>what</em></span> but not <span class="emphasis"><em>how</em></span>. A question is handed off; an answer is received. This, then, is the Big Recursive Idea: If you follow certain conventions in your coding, <span class="emphasis"><em>you can pretend that no recursion is taking place</em></span>. You can even use a cheap trick (shown below) to move from an iterative implementation to a recursive implementation, without explicitly considering how the recursion is actually solving the problem. Over time, you will develop an intuitive understanding of how recursive solutions work, but before that intuition develops, you can craft recursive implementations and be confident in your code.<a id="IDX-CHP-6-0026" class="indexterm"/><a id="IDX-CHP-6-0027" class="indexterm"/><a id="IDX-CHP-6-0028" class="indexterm"/></p><p>Let’s put the concept into practice through a code example.</p><div class="sidebar"><a id="problem_colon_computing_the_sum_of_an_ar"/><p class="title">Problem: Computing the Sum of an Array of Integers</p><p>Write a recursive function that is given an array of integers and the size of the array as parameters. The function returns the sum of the integers in the array.</p></div><p>Your first thought may have been that this problem would be trivial to solve iteratively. Indeed, let’s start with an iterative solution to this problem:</p><a id="I_programlisting6_d1e12181"/><pre class="programlisting">int iterativeArraySum(int integers[], int size) {
    int sum = 0;
    for (int i = 0; i &lt; size; i++) {
        sum += integers[i];
    }
    return sum;
}</pre><p>You saw code very similar to this in <a class="xref" href="ch03.html" title="Chapter 3. Solving Problems with Arrays">Chapter 3</a>, so the function should be simple to understand. The next step is to write code that is halfway between the iterative solution and the final desired recursive solution. We will keep the iterative function and add a second function we will refer to as a <span class="emphasis"><em>dispatcher</em></span>. The dispatcher will hand off most of the work to the previously written iterative function and use this information to solve the overall problem. To write a dispatcher, we have to follow two rules:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The dispatcher must completely handle the most trivial case, without calling the iterative function.</p></li><li class="listitem"><p>The dispatcher, when calling the iterative function, must pass a smaller version of the problem.</p></li></ol></div><p>In applying the first rule to this problem, we must decide what the most trivial case is. If <code class="literal">size</code> is 0, then the function has conceptually been passed a “null” array, with a sum of 0. One could also make the argument that the most trivial case should be when <code class="literal">size</code> is 1. In that case, there would be only one number in the logical array, and we could return that number as the sum. Either of these interpretations will work, but making the first choice allows the function to handle a special case. Note that the original iterative function will not fail when <code class="literal">size</code> is zero, so it would be preferable to maintain that flexibility.<a id="IDX-CHP-6-0029" class="indexterm"/></p><p>To apply the second rule to this problem, we must figure out a way to pass a smaller version of the problem from the dispatcher to the iterative function. There is no easy way to pass a smaller array, but we can easily pass a smaller value for <code class="literal">size</code>. If the dispatcher is given the value of 10 for <code class="literal">size</code>, the function is being asked to compute the sum of 10 values in the array. If the dispatcher passes 9 as the value of <code class="literal">size</code> to the iterative function, it is requesting the sum of the first 9 values in the array. The dispatcher can then add the value of the one remaining value in the array (the 10th) to compute the sum of all 10 values. Note that reducing size by 1 when calling the iterative function maximizes the work of the iterative function and thereby minimizes the work of the dispatcher. This is always the desired approach—like the managers of DelegateCorp, the dispatcher function avoids as much work as possible.</p><p>Putting these ideas together, here’s a dispatcher function for this problem:</p><a id="I_programlisting6_d1e12225"/><pre class="programlisting">int arraySumDelegate(int integers[], int size) {
  <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>if (size == 0) return 0;
  <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>int lastNumber = integers[size - 1];
    int allButLastSum = <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>iterativeArraySum(integers, size - 1);
  <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>return lastNumber + allButLastSum;
}</pre><p>The first statement enforces the first rule of dispatchers: It checks for a trivial case and handles it completely, in this case, by returning 0 <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12253"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. Otherwise, control passes to the remaining code, which enforces the second rule. The last number in the array is stored in a local variable called <code class="literal">lastNumber</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12262"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, and then the sum of all the other values in the array is computed via a call to the iterative function <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12268"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. This result is stored in another local variable, <code class="literal">allButLastSum</code>, and finally the function returns the sum of the two local variables <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12278"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>.</p><p>If we have correctly created a dispatcher function, we have already effectively created a recursive solution. This is the Big Recursive Idea in action. To convert this iterative solution to a recursive solution requires but one further, simple step: have the delegate function call itself where it was previously calling the iterative function. We can then remove the iterative function altogether.</p><a id="I_programlisting6_d1e12286"/><pre class="programlisting">int <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>arraySumRecursive(int integers[], int size) {
    if (size == 0) return 0;
    int lastNumber = integers[size - 1];
    int allButLastSum = <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>arraySumRecursive(integers, size - 1);
    return lastNumber + allButLastSum;
}</pre><p>Only two changes have been made to the previous code. The name of the function has been changed to better describe its new form <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12302"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, and the function now calls itself where it previously called the iterative function <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12308"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. The logic of the two functions, <code class="literal">arraySumDelegate</code> and <code class="literal">arraySumRecursive</code>, is identical. Each function checks for a trivial case in which the sum is already known—in this case, an array of size 0 that has a sum of 0. Otherwise, each function computes the sum of values in the array by making a function call to compute the sum of all of the values, save the last one. Finally, each function adds that last value to the returned sum for a grand total. The only difference is that the first version of the function calls another function, while the recursive version calls itself. The BRI tells us that if we follow the rules outlined above for writing the dispatcher, we can ignore that distinction.<a id="IDX-CHP-6-0030" class="indexterm"/><a id="IDX-CHP-6-0031" class="indexterm"/><a id="IDX-CHP-6-0032" class="indexterm"/></p><p>You do not need to literally follow all of the steps shown above to follow the BRI. In particular, you usually would not implement an iterative solution to the problem before implementing a recursive solution. Writing an iterative function as a stepping-stone is extra work that will eventually be thrown away. Besides, recursion is best applied to situations in which an iterative solution is difficult, as explained later. However, you can follow the outline of the BRI without actually writing the iterative solution. The key is thinking of a recursive call as a call to another function, without regards to the internals of that function. In this way, you remove the complexities of recursive logic from the recursive solution.</p></div><div class="sect1" title="Common Mistakes"><div class="titlepage"><div><div><h1 class="title"><a id="common_mistakes"/>Common Mistakes</h1></div></div></div><p>As shown above, with the right approach, recursive solutions can often be very easy to write. But it can be just as easy to come up with an incorrect recursive implementation or a recursive solution that “works” but is ungainly. Most problems with recursive implementations stem from two basic faults: overthinking the problem or beginning implementation without a clear plan.</p><p>Overthinking recursive problems is common for new programmers because limited experience and lack of confidence with recursion lead them to think that the problem is more difficult than it really is. Code produced by overthinking can be recognized by its too-careful appearance. For example, a recursive function might have several special cases where it needs only one.</p><p>Beginning implementation too soon can lead to overcomplicated “Rube Goldberg” code, where unforeseen interactions lead to fixes that are bolted onto the original code.</p><p>Let’s look at some specific mistakes and how to avoid them.</p><div class="sect2" title="Too Many Parameters"><div class="titlepage"><div><div><h2 class="title"><a id="too_many_parameters"/>Too Many Parameters</h2></div></div></div><p>As described previously, the head recursion technique can reduce the data passed to the recursive call, while the tail recursion technique can result in passing additional data to recursive calls. Programmers often get stuck in the tail recursion mode because they overthink and start implementation too soon.</p><p>Consider our problem of recursively computing the sum of an array of integers. Writing an iterative solution to this problem, the programmer knows a “running total” variable will be needed (in the iterative solution provided, I called this <code class="literal">sum</code>) and the array will be summed starting from the first element. Considering the recursive solution, the programmer naturally imagines an implementation that most directly mirrors the iterative solution, with a running total variable and the first recursive call handling the first element in the array. This approach, however, requires the recursive function to pass the running total and the location where the next recursive call should begin processing. Such a solution would look like this:</p><a id="I_programlisting6_d1e12357"/><pre class="programlisting">int arraySumRecursiveExtraParams(int integers[], int size, <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>int sum,
 <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>int currentIndex) {
    if (currentIndex == size) return sum;
    sum += integers[currentIndex];
    return arraySumRecursiveExtraParameters(integers, size, sum, currentIndex + 1);
}</pre><p>This code is as short as the other recursive version but considerably more semantically complex because of the additional parameters, <code class="literal">sum</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12376"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> and <code class="literal">currentIndex</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12385"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. From the client code’s point of view, the extra parameters are meaningless and will always have to be zeroes in the call, as shown in this example:</p><a id="I_programlisting6_d1e12391"/><pre class="programlisting">int a[10] = {20, 3, 5, 22, 7, 9, 14, 17, 4, 9};
int total = arraySumRecursiveExtraParameters(a, 10, 0, 0);</pre><p>This problem can be avoided with the use of a <span class="emphasis"><em>wrapper function</em></span>, as described in the next section, but because we can’t eliminate those parameters altogether, that’s not the best solution. The iterative function for this problem and the original recursive function answer the question, what is the sum of this array with this many elements? In contrast, this second recursive function is being asked, what is the sum of this array if it has this many elements, we are starting with this particular element, and this is the sum of all the prior elements?</p><p>The “too many parameters” problem is avoided by choosing your function parameters before thinking about recursion. In other words, force yourself to use the same parameter list you would if the solution were iterative. If you use the full BRI process and actually write the iterative function first, you will avoid this problem automatically. If you skip using the whole process formally, though, you can still use the idea conceptually if you write out the parameter list based on what you would expect for an iterative function.</p></div><div class="sect2" title="Global Variables"><div class="titlepage"><div><div><h2 class="title"><a id="global_variables"/>Global Variables</h2></div></div></div><p>Avoiding too many parameters sometimes leads programmers into making a different mistake: using global variables to pass data from one recursive call to the other. The use of global variables is generally a poor programming practice, although it is sometimes permissible for performance reasons. Global variables should always be avoided in recursive functions when possible. Let’s look at a specific problem to see how programmers talk themselves into this mistake. Suppose we were asked to write a recursive function that counted the number of zeros appearing in an array of integers. This is a simple problem to solve using iteration:</p><a id="I_programlisting6_d1e12405"/><pre class="programlisting">int zeroCountIterative(int numbers[], int size) {
   int sum = 0;
 <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>int count = 0;
   for (int i = 0; i &lt; size; i++) {
      if (numbers[i] == 0) count ++;
   }
   return count;
}</pre><p>The logic of this code is straightforward. We’re just running through the array from the first location to the last, counting up the zeroes as we go and using a local variable, <code class="literal">count</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12418"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, as a tracker. If we have a function like this in our minds when we write our recursive function, though, we may assume that we need a tracker variable in that version as well. We can’t simply declare count as a local variable in the recursive version because then it would be a new variable in each recursive call. So we might be tempted to declare it as a global variable:</p><a id="I_programlisting6_d1e12424"/><pre class="programlisting">int count;
int zeroCountRecursive(int numbers[], int size) {
   if (size == 0) return count;
   if (numbers[size - 1] == 0) count++;
   zeroCountRecursive(numbers, size - 1);
}</pre><p>This code works, but the global variable is entirely unnecessary and causes all the problems global variables typically cause, such as poor readability and more difficult code maintenance. Some programmers might attempt to mitigate the problem by making the variable local, but static:</p><a id="I_programlisting6_d1e12428"/><pre class="programlisting">int zeroCountStatic(int numbers[], int size) {
 <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>static int count <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>= 0;
   if (size == 0) return count;
   if (numbers[size - 1] == 0) count++;
   zeroCountStatic(numbers, size - 1);
}</pre><p>In C++, a local variable declared as <span class="emphasis"><em>static</em></span> retains its value from one function call to the next; thus, the local static variable <code class="literal">count</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12450"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> would act the same as the global variable in the previous version. So what’s the problem? The initialization of the variable to zero <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12456"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> happens only the first time the function is called. This is necessary for the <code class="literal">static</code> declaration to be of any use, but it means that the function will return a correct answer only the first time it is called. If this function were called twice—first with an array that had three zeros, then with an array that had five zeros—the function would return an answer of eight for the second array because <code class="literal">count</code> would be starting where it had left off.<a id="IDX-CHP-6-0033" class="indexterm"/><a id="IDX-CHP-6-0034" class="indexterm"/><a id="IDX-CHP-6-0035" class="indexterm"/><a id="IDX-CHP-6-0036" class="indexterm"/></p><p>The solution to avoiding the global variable in this case is to use the BRI. We can assume that a recursive call with a smaller value for <code class="literal">size</code> will return the correct result and compute the correct value for the overall array from that. This will lead to a head-recursive solution:</p><a id="I_programlisting6_d1e12492"/><pre class="programlisting">int zeroCountRecursive(int numbers[], int size) {
   if (size == 0) return 0;
 <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>int count = zeroCountRecursive(numbers, size - 1);
 <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>if (numbers[size - 1] == 0) count++;
 <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>return count;
}</pre><p>In this function, we still have a local variable, <code class="literal">count</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12517"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, but here no attempt is made to maintain its value from one call to the next. Instead, it stores the return value from our recursive call; we optionally increment the variable <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12523"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> before returning it <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12529"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>.</p></div></div><div class="sect1" title="Applying Recursion to Dynamic Data Structures"><div class="titlepage"><div><div><h1 class="title"><a id="applying_recursion_to_dynamic_data_struc"/>Applying Recursion to Dynamic Data Structures</h1></div></div></div><p>Recursion is often applied to dynamic structures such as linked lists, trees, and graphs. The more complicated the structure, the more the coding can benefit from a recursive solution. Processing complicated structures is often a lot like finding one’s way through a maze, and recursion allows us to backtrack to previous steps in our processing.</p><div class="sect2" title="Recursion and Linked Lists"><div class="titlepage"><div><div><h2 class="title"><a id="recursion_and_linked_lists"/>Recursion and Linked Lists</h2></div></div></div><p>Let’s start, though, with the most basic of dynamic structures, a linked list. For discussions in this section, let’s assume we have the simplest of node structures for our linked list, just a single <code class="literal">int</code> for data. Here are our type declarations:</p><a id="I_programlisting6_d1e12548"/><pre class="programlisting">struct listNnode {
    int data;
    listNode * next;
};
typedef listNode * listPtr;</pre><p>Applying the BRI to a singly linked list follows the same general outline regardless of the specific task. Recursion requires us to divide the problem, to be able to pass a reduced version of the original problem to the recursive call. There is only one practical way to divide a singly linked list: the first node in the list and the rest of the list.</p><p>In <a class="xref" href="ch06.html#a_list_divided_into_a_first_node_and_lth" title="Figure 6-5. A list divided into a first node and “the rest of the list”">Figure 6-5</a>, we see a sample list divided into unequal parts: the first node and all of the other nodes. Conceptually, we can view the “rest of” the original list as its own list, starting with the second node in the original list. It is this view that allows the recursion to work smoothly.</p><div class="figure"><a id="a_list_divided_into_a_first_node_and_lth"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e12559"/><img src="httpatomoreillycomsourcenostarchimages1273259.png" alt="A list divided into a first node and “the rest of the list”"/></div></div><p class="title">Figure 6-5. A list divided into a first node and “the rest of the list”</p></div><p>Again, though, we are not required to picture all the steps of the recursion to make the recursion work. From the point of view of someone writing a recursive function to process a linked list, it can be conceptualized as the first node, which we have to deal with, and the rest of the list, which we don’t and therefore aren’t concerned about. This attitude is shown in <a class="xref" href="ch06.html#the_list_as_a_programmer_using_recursion" title="Figure 6-6. The list as a programmer using recursion should picture it: a first node and the rest of the list as a nebulous shape to be passed off to the recursive call">Figure 6-6</a>.</p><div class="figure"><a id="the_list_as_a_programmer_using_recursion"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e12571"/><img src="httpatomoreillycomsourcenostarchimages1273261.png.jpg" alt="The list as a programmer using recursion should picture it: a first node and the rest of the list as a nebulous shape to be passed off to the recursive call"/></div></div><p class="title">Figure 6-6. The list as a programmer using recursion should picture it: a first node and the rest of the list as a nebulous shape to be passed off to the recursive call</p></div><p>With the division of labor fixed, we can say that recursive processing of singly linked lists will proceed according to the following general plan. Given a linked list L and a question Q:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If L is minimal, we directly assign a default value. Otherwise . . .</p></li><li class="listitem"><p>Use a recursive call to produce an answer to Q for the “rest of” list L (the list starting with the second node of L).</p></li><li class="listitem"><p>Inspect the value in the first node of L.</p></li><li class="listitem"><p>Use the results of the previous two steps to answer Q for the whole of L.</p></li></ol></div><p>As you can see, this is just a straightforward application of the BRI given the practical restrictions on breaking up a linked list. Now let’s apply this blueprint to a specific problem.</p><div class="sidebar"><a id="problem_colon_counting_negative_numbers"/><p class="title">Problem: Counting Negative Numbers in a Singly Linked List</p><p>Write a recursive function that is given a singly linked list where the data type is integer. The function returns the count of negative numbers in the list.</p></div><p>The question, Q, we want to answer is, how many negative numbers are in the list? Therefore, our plan can be stated as:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If the list has no nodes, the count is 0 by default. Otherwise . . .</p></li><li class="listitem"><p>Use a recursive call to count how many negative numbers are in the “rest of” the list.</p></li><li class="listitem"><p>See whether the value in the first node of the list is negative.</p></li><li class="listitem"><p>Use the results of the previous two steps to determine how many negative numbers are in the whole list.<a id="IDX-CHP-6-0037" class="indexterm"/><a id="IDX-CHP-6-0038" class="indexterm"/><a id="IDX-CHP-6-0039" class="indexterm"/><a id="IDX-CHP-6-0040" class="indexterm"/><a id="IDX-CHP-6-0041" class="indexterm"/><a id="IDX-CHP-6-0042" class="indexterm"/><a id="IDX-CHP-6-0043" class="indexterm"/></p></li></ol></div><p>Here’s a function implementation that follows directly from this plan:</p><a id="I_programlisting6_d1e12647"/><pre class="programlisting">int countNegative(listPtr head) {
    if (head == NULL) return 0;
    int listCount = countNegative(head-&gt;next);
    if (head-&gt;data &lt; 0) listCount++;
    return listCount;
}</pre><p>Note how this code follows the same principles as previous examples. It will count the negative numbers “backward,” from the end of the list to the front. Also note that the code employs the head recursion technique; we process the “rest of” the list before we process the first node. As before, this allows us to avoid passing extra data in the recursive call or using global variables.<a id="IDX-CHP-6-0044" class="indexterm"/></p><p>Also notice how linked-list rule 1, “if list L is minimal,” is interpreted in the specific implementation of this problem as “if the list has no nodes.” That’s because it is meaningful to say that a list with no nodes has zero negative values. In some cases, though, there is no meaningful answer for our question Q for a list with no nodes, and the minimal case is a list with one node. Suppose our question was, what’s the largest number in this list? That question cannot be answered for a list with no values. If you don’t see why, pretend you are an elementary school teacher, and your class happens to be all girls. If your school’s principal asked you how many boys in your classroom were members of the boy’s choir, you could simply answer zero because you have no boys. If your principal asked you to name the tallest boy in your class, you could not give a meaningful answer to that question—you would have to have at least one boy to have a tallest boy. In the same way, if the question about a data set requires at least one value to be meaningfully answered, the minimal data set is one item. You may still want to return <span class="emphasis"><em>something</em></span> for the “size zero” case, however, if only for flexibility in the use of the function and to guard against a crash.<a id="IDX-CHP-6-0045" class="indexterm"/><a id="IDX-CHP-6-0046" class="indexterm"/></p></div><div class="sect2" title="Recursion and Binary Trees"><div class="titlepage"><div><div><h2 class="title"><a id="recursion_and_binary_trees"/>Recursion and Binary Trees</h2></div></div></div><p>All of the examples we have explored so far make no more than one recursive call. More complicated structures, however, may require multiple recursive calls. For a taste of how that works, let’s consider the structure known as a <span class="emphasis"><em>binary tree</em></span>, in which each node contains “left” and “right” links to other nodes. Here are the types we’ll use:</p><a id="I_programlisting6_d1e12673"/><pre class="programlisting">struct treeNode {
    int data;
    treeNode * left;
    treeNode * right;
};
typedef treeNode * treePtr;</pre><p>Because each node in the tree points to two other nodes, recursive tree-processing functions require two recursive calls. We conceptualized linked lists as having two parts: a first node and the rest of the list. For applying recursion, we will conceptualize trees as having three parts: the node at the top, known as the <span class="emphasis"><em>root node</em></span>; all of the nodes reached from the left link of the root, known as the <span class="emphasis"><em>left subtree</em></span>; and all of the nodes reached from the right link of the root, known as the <span class="emphasis"><em>right subtree</em></span>. This conceptualization is shown in <a class="xref" href="ch06.html#a_binary_tree_divided_into_a_root_node_a" title="Figure 6-7. A binary tree divided into a root node and left and right subtree">Figure 6-7</a>. As with the linked list and as developers of a recursive solution, we just focus on the existence of the left and right subtrees, without considering their contents. This is shown in <a class="xref" href="ch06.html#a_binary_tree_as_a_programmer_using_recu" title="Figure 6-8. A binary tree as a programmer using recursion should picture it: a root node with left and right subtrees of unknown and unconsidered structure">Figure 6-8</a>.<a id="IDX-CHP-6-0047" class="indexterm"/><a id="IDX-CHP-6-0048" class="indexterm"/><a id="IDX-CHP-6-0049" class="indexterm"/></p><div class="figure"><a id="a_binary_tree_divided_into_a_root_node_a"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e12707"/><img src="httpatomoreillycomsourcenostarchimages1273263.png.jpg" alt="A binary tree divided into a root node and left and right subtree"/></div></div><p class="title">Figure 6-7. A binary tree divided into a root node and left and right subtree</p></div><p>As always, when recursively solving problems involving binary trees, we want to employ the BRI. We will make recursive function calls and assume they return correct results without worrying about how the recursive process solves the overall problem. As with linked lists, we will work with the natural divisions of a binary tree. This produces the following general plan. To answer a question Q for tree T:</p><div class="figure"><a id="a_binary_tree_as_a_programmer_using_recu"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e12717"/><img src="httpatomoreillycomsourcenostarchimages1273265.png" alt="A binary tree as a programmer using recursion should picture it: a root node with left and right subtrees of unknown and unconsidered structure"/></div></div><p class="title">Figure 6-8. A binary tree as a programmer using recursion should picture it: a root node with left and right subtrees of unknown and unconsidered structure</p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If tree T is of minimal size, directly assign a default value. Otherwise . . .</p></li><li class="listitem"><p>Make a recursive call to answer Q for the left subtree of T.</p></li><li class="listitem"><p>Make a recursive call to answer Q for the right subtree of T.</p></li><li class="listitem"><p>Inspect the value in the root node of T.</p></li><li class="listitem"><p>Use the results of the previous three steps to answer Q for all of T.</p></li></ol></div><p>Now let’s apply the general plan to a specific problem.</p><div class="sidebar"><a id="problem_colon_find_the_largest_value_in"/><p class="title">Problem: Find the Largest Value in a Binary Tree</p><p>Write a function that, when given a binary tree where each node holds an integer, returns the largest integer in the tree.<a id="IDX-CHP-6-0050" class="indexterm"/><a id="IDX-CHP-6-0051" class="indexterm"/></p></div><p>Applying the general plan to this specific problem results in the following steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If the root of the tree has no children, return the value in the root. -Otherwise . . .</p></li><li class="listitem"><p>Make a recursive call to find the largest value in the left subtree.</p></li><li class="listitem"><p>Make a recursive call to find the largest value in the right subtree.</p></li><li class="listitem"><p>Inspect the value in the root node.</p></li><li class="listitem"><p>Return the largest of the values in the previous three steps.</p></li></ol></div><p>With those steps in mind, we can directly write the code for the solution:</p><a id="I_programlisting6_d1e12774"/><pre class="programlisting">int maxValue(treePtr root) {
  <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>if (root == NULL) return 0;
  <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>if (root-&gt;right == NULL &amp;&amp; root-&gt;left == NULL)
        return root-&gt;data;
  <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>int leftMax = maxValue(root-&gt;left);
  <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>int rightMax = maxValue(root-&gt;right);
  <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>int maxNum = root-&gt;data;
    if (leftMax &gt; maxNum) maxNum = leftMax;
    if (rightMax &gt; maxNum) maxNum = rightMax;
    return maxNum;
}</pre><p>Notice how the minimal tree for this problem is a single node <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12808"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> (although the empty-tree case is covered for safety <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12814"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>). This is because the question we are asking can only be meaningfully answered with at least one data value. Consider the practical problem if we tried to make the empty tree the base case. What value could we return? If we return zero, we implicitly require some positive values in the tree; if all of the values in the tree are negative, zero will be erroneously returned as the largest value in the tree. We might solve this problem by returning the lowest (most negative) possible integer, but then we would have to be careful adapting the code for other numeric types. By making a single node the base case, we avoid this decision altogether.<a id="IDX-CHP-6-0052" class="indexterm"/></p><p>The rest of the code is straightforward. We use recursion to find the maximum values in the left <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12825"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> and right subtrees <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12831"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. Then we find the largest of the three values (value at root, largest in left subtree, largest in right subtree) using a variant of the “King of the Hill” algorithm we’ve been using throughout this book <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12837"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>.</p></div></div><div class="sect1" title="Wrapper Functions"><div class="titlepage"><div><div><h1 class="title"><a id="wrapper_functions"/>Wrapper Functions</h1></div></div></div><p>In the previous examples in this chapter, we have discussed only the recursive function itself. In some cases, however, the recursive function needs to be “set up” by a second function. Most commonly, this occurs when we write recursive functions inside of class structures. This can cause a mismatch between the parameters required for the recursive function and the parameters needed for a public method of the class. Because classes typically enforce information hiding, the class client code may not have access to the data or types the recursive function requires. This problem and its solution are shown in the next example.<a id="IDX-CHP-6-0053" class="indexterm"/><a id="IDX-CHP-6-0054" class="indexterm"/><a id="IDX-CHP-6-0055" class="indexterm"/><a id="IDX-CHP-6-0056" class="indexterm"/></p><div class="sidebar"><a id="problem_colon_find_the_number_of_leaves"/><p class="title">Problem: Find the Number of Leaves in a Binary Tree</p><p>For a class that implements a binary tree, add a publicly accessible method that returns the number of leaves (nodes without children) in the tree. The counting of leaves should be performed using recursion.<a id="IDX-CHP-6-0057" class="indexterm"/><a id="IDX-CHP-6-0058" class="indexterm"/></p></div><p>Let’s sketch the outline of what this class might look like before we try to implement a solution to this problem. For simplicity, we will include only the relevant parts of the class, ignoring the constructors, the destructor, and even the methods that would allow us to build the tree in order to focus on our recursive method.</p><a id="I_programlisting6_d1e12881"/><pre class="programlisting">class binaryTree {
    public:
      <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>int countLeaves();
    private:
        struct binaryTreeNode {
            int data;
            binaryTreeNode * left;
            binaryTreeNode * right;
        };
        typedef treeNode * treePtr;
        treePtr _root;
};</pre><p>Note that our leaf-counting function takes no parameters <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12891"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>. From an interface point of view, this is exactly correct. Consider a sample call for a previously constructed <code class="literal">binaryTree</code> object <code class="literal">bt</code>:<a id="IDX-CHP-6-0059" class="indexterm"/></p><a id="I_programlisting6_d1e12908"/><pre class="programlisting">int numLeaves = bt.countLeaves();</pre><p>After all, if we are asking the tree how many leaves it has, what information could we possibly provide to the object that it would not already know about itself? As correct as this is for the interface, it’s all wrong for the recursive implementation. If there is no parameter, what changes from one recursive call to the next? Nothing can change in that case, except through global variables, which, as stated earlier, are to be avoided. If nothing changes, there’s no way for the recursion to progress or terminate.</p><p>The way around this problem is to write the recursive function first, conceptualizing it as a function outside of a class. In other words, we’ll write this function to count the leaves in a binary tree in the same style we wrote the function to find the largest value in a binary tree. The one parameter we need to pass is a pointer to our node structure.</p><p>This gives us another opportunity to employ the BRI. What is the question Q in this case? It is, how many leaves are in the tree? Applying the general plan for recursively processing binary trees to this specific problem results in the following:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If the root of the tree has no children, then the tree has one node total. That node is a leaf by definition, so return 1. Otherwise . . .</p></li><li class="listitem"><p>Make a recursive call to count the leaves in the left subtree.</p></li><li class="listitem"><p>Make a recursive call to count the leaves in the right subtree.</p></li><li class="listitem"><p>In this case, there is no need to inspect the root node because if we get to this step, there is no way the root is a leaf. So . . .</p></li><li class="listitem"><p>Return the sum of steps 2 and 3.</p></li></ol></div><p>Translating this plan into code results in this:</p><a id="I_programlisting6_d1e12935"/><pre class="programlisting">struct binaryTreeNode {
    int data;
    treeNode * left;
    treeNode * right;
};
typedef binaryTreeNode * treePtr;
int countLeaves(treePtr rootPtr) {
    if (rootPtr == NULL) return 0;
    if (rootPtr-&gt;right == NULL &amp;&amp; rootPtr-&gt;left == NULL)
        return 1;
    int leftCount = countLeaves(rootPtr-&gt;left);
    int rightCount = countLeaves(rootPtr-&gt;right);
    return leftCount + rightCount;
}</pre><p>As you can see, the code is a direct translation of the plan. The question is, how do we get from this independent function to something we can use in the class? This is where the unwary programmer could easily get into trouble, thinking that we need to use a global variable or make the root pointer public. But we don’t need to do that; we can keep everything inside the class. The trick is to use a <span class="emphasis"><em>wrapper function</em></span>. First, we put the independent function, with the <code class="literal">treePtr</code> parameter, in the private section of our class. Then, we write a public function, the wrapper function, which will “wrap” the private function. Because the public function has access to the private data member <code class="literal">root</code>, it can pass this along to the recursive function and then return the results back to the client like this:<a id="IDX-CHP-6-0060" class="indexterm"/></p><a id="I_programlisting6_d1e12953"/><pre class="programlisting">class binaryTree {
      public:
          int publicCountLeaves();
      private:
          struct binaryTreeNode {
              int data;
              binaryTreeNode * left;
              binaryTreeNode * right;
          };
          typedef binaryTreeNode * treePtr;
          treePtr _root;
          int privateCountLeaves(treePtr rootPtr);
  };
<img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/> int binaryTree::privateCountLeaves(treePtr rootPtr) {
      if (rootPtr == NULL) return 0;
      if (rootPtr-&gt;right == NULL &amp;&amp; rootPtr-&gt;left == NULL)
          return 1;
      int leftCount = privateCountLeaves(rootPtr-&gt;left);
      int rightCount = privateCountLeaves(rootPtr-&gt;right);
      return leftCount + rightCount;
  }
<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/> int binaryTree::publicCountLeaves() {
     <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>return privateCountLeaves(_root);
  }</pre><p>Although C++ would allow both functions to have the same name, for clarity I’ve used different names to distinguish between the public and private “count leaves” functions. The code in <code class="literal">privateCountLeaves</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12978"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> is exactly the same as our previous, independent function <code class="literal">countLeaves</code>. The wrapper function <code class="literal">publicCountLeaves</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e12990"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span> is simple. It calls <code class="literal">privateCountLeaves</code>, passing the private data member root, and returns the result <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13000"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. In essence, it “primes the pump” of the recursive process. Wrapper functions are very helpful when writing recursive functions inside classes, but they can be used anytime a mismatch exists between the parameter list required by a function and the desired parameter list of a caller.</p></div><div class="sect1" title="When to Choose Recursion"><div class="titlepage"><div><div><h1 class="title"><a id="when_to_choose_recursion"/>When to Choose Recursion</h1></div></div></div><p>New programmers often wonder why anyone has to deal with recursion. They may have already learned that any program can be constructed using basic control structures, such as selection (if statements) and iteration (<code class="literal">for</code> and <code class="literal">while</code> loops). If recursion is more difficult to employ than basic control structures and unnecessary, perhaps recursion should just be ignored.</p><p>There are several rebuttals to this. First, programming recursively helps programmers think recursively, and recursive thinking is employed throughout the world of computer science in such areas as compiler design. Second, some languages simply require recursion because they lack some basic control structures. Pure versions of the Lisp language, for example, require recursion in almost every nontrivial function.<a id="IDX-CHP-6-0061" class="indexterm"/><a id="IDX-CHP-6-0062" class="indexterm"/></p><p>The question remains, though: If a programmer has studied recursion enough to “get it” and is using a full-featured language such as C++, Java, or Python, should recursion ever be employed? Does recursion have practical use in such languages, or is it just a mental exercise?</p><div class="sect2" title="Arguments Against Recursion"><div class="titlepage"><div><div><h2 class="title"><a id="arguments_against_recursion"/>Arguments Against Recursion</h2></div></div></div><p>To explore this question, let’s enumerate the bad features of recursion.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Conceptual complexity</strong></span></span></dt><dd><p>For most problems, it’s more difficult for the average programmer to solve a problem using recursion. Even once you understand the Big Recursive Idea, it’s still going to be easier in most cases to write code using loops.</p></dd><dt><span class="term"><span class="strong"><strong>Performance</strong></span></span></dt><dd><p>Function calls incur significant overhead. Recursion involves lots of function calls and, therefore, can be slow.</p></dd><dt><span class="term"><span class="strong"><strong>Space requirements</strong></span></span></dt><dd><p>Recursion doesn’t simply employ many function calls; it also nests them. That is, you can end up with a long chain of function calls waiting for other calls to complete. Each function call that has begun but has yet to end takes additional space on the system stack.</p></dd></dl></div><p>At a glance, this list of features constitutes a strong indictment against recursion as difficult, slow, and wasteful of space. However, these arguments do not hold universally. The most basic rule, then, for deciding between recursion and iteration is, <span class="emphasis"><em>choose recursion when these arguments do not apply</em></span>.</p><p>Consider our function that counts the number of leaves in a binary tree. How would you solve this problem without recursion? It’s possible, but you would need an explicit mechanism for maintaining the “breadcrumb trail” of nodes for which the left children had already been visited but not the right children. These nodes would need to be revisited at some point so we could travel down the right side. You might store these nodes in a dynamic structure, such as a stack. For comparison, here’s an implementation of the function that uses the stack class from the C++ standard template library:<a id="IDX-CHP-6-0063" class="indexterm"/></p><a id="I_programlisting6_d1e13070"/><pre class="programlisting">int binaryTree::stackBasedCountLeaves() {
    if (_root == NULL) return 0;
    int leafCount = 0;
  <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>stack&lt;<img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>binaryTreeNode *&gt; nodes;
  <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>nodes.push(_root);
    while (<img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>!nodes.empty()) {
        treePtr currentNode = <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>nodes.top();
      <img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/>nodes.pop();
        if (currentNode-&gt;left == NULL &amp;&amp; currentNode-&gt;right == NULL)
            leafCount++;
        else {
            if (currentNode-&gt;right != NULL) <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>nodes.push(currentNode-&gt;right);
            if (currentNode-&gt;left != NULL) <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>nodes.push(currentNode-&gt;left);
        }
    }
    return leafCount;
}</pre><p>This code follows the same pattern as the original, but if you’ve never used the stack class before, a few comments are in order. The stack class works like the system stack we discussed in <a class="xref" href="ch03.html" title="Chapter 3. Solving Problems with Arrays">Chapter 3</a>; you can add and remove items only at the top. Note that we could perform our leaf count operation using any data structure that doesn’t have a fixed size. We could have used a vector, for example, but the use of the stack most directly mirrors the original code. When we declare the stack <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13125"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, we specify the type of items we will store there. In this case, we would store pointers to our <code class="literal">binaryTreeNode</code> structure <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13134"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. We make use of four stack class methods in this code. The <code class="literal">push</code> method <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13144"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> places an item (a node pointer, in this case) on the top of the stack. The <code class="literal">empty</code> method <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13153"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span> tells us whether there are any items left on the stack. The <code class="literal">top</code> method <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13162"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span> gives us a copy of the item on top of the stack, and the <code class="literal">pop</code> method <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13172"/><img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/></span> removes the top item from the stack.</p><p>The code solves the problem by placing a pointer to the first node on the stack and then repeatedly removing a pointer to a node from the stack, checking whether it’s a leaf, incrementing our counter if it is, and placing pointers to child nodes, if they exist, on the stack. So the stack keeps track of the nodes we have discovered, but have yet to process, in the same way that the chain of recursive calls in the recursive version keeps track of nodes we must revisit. In comparing this iterative version to the recursive version, we see that none of the standard objections to recursion applies with much vigor in this case. First, this code is longer and more complicated than the recursive version, so there is no argument against the recursive version on the basis of conceptual complexity. Second, look how many function calls <code class="literal">stackBasedCountLeaves</code> makes—for each visit to an interior node (i.e., not a leaf), this function makes four function calls: one each to <code class="literal">empty</code> and <code class="literal">top</code>, and two to <code class="literal">push</code>. The recursive version makes only the two recursive calls for each interior node. (Note that it is possible for us to avoid the function calls to the stack object by incorporating the logic of the stack within the function. This, however, would increase the complexity of the function even further.) Third, while this iterative version doesn’t use additional system stack space, it makes explicit use of a private stack. In fairness, this is less space than the system stack overhead of the recursive calls, but it’s still an expenditure of system memory in proportion to the maximum depth of the binary tree we are traversing.</p><p>Because the objections against recursion are mitigated or minimized in this case, recursion is a good choice for the problem. Put more generally, if a problem is simple to solve iteratively, then iteration should be your first choice. Recursion should be used when iteration would be complicated. Often this involves the necessity of the “breadcrumb trail” mechanism shown here. Traversals of branching structures, such as trees and graphs, are inherently recursive. Processing linear structures, such as arrays and linked lists, usually does not require recursion, but there are exceptions. You will never go wrong making a first stab at a problem using iteration and seeing how far you get. As a last set of examples, consider the following linked-list problems.<a id="IDX-CHP-6-0064" class="indexterm"/><a id="IDX-CHP-6-0065" class="indexterm"/><a id="IDX-CHP-6-0066" class="indexterm"/><a id="IDX-CHP-6-0067" class="indexterm"/></p><div class="sidebar"><a id="problem_colon_display_a_linked_list_in_o"/><p class="title">Problem: Display a Linked List in Order</p><p>Write a function that is passed the head pointer of a singly linked list where the data type of each node is an integer and that displays those integers, one per line, in the order they appear in the list.</p></div><div class="sidebar"><a id="problem_colon_display_a_linked_list_in_r"/><p class="title">Problem: Display a Linked List in Reverse Order</p><p>Write a function that is passed the head pointer of a singly linked list where the data type of each node is an integer and that displays those integers, one per line, in the reverse order they appear in the list.</p></div><p>Because these problems are mirror images of each other, it’s natural to assume that their implementations would likewise be mirror images. That is indeed the case for recursive implementations. Using the <code class="literal">listNode</code> and <code class="literal">listPtr</code> type given previously, here are recursive functions to solve both of these problems:</p><a id="I_programlisting6_d1e13231"/><pre class="programlisting">void displayListForwardsRecursion(listPtr head) {
    if (head != NULL) {
        <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>cout &lt;&lt; head-&gt;data &lt;&lt; "\n";
        <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>displayListForwardsRecursion(head-&gt;next);
    }
}
void displayListBackwardsRecursion(listPtr head) {
    if (head != NULL) {
        <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>displayListBackwardsRecursion(head-&gt;next);
        <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>cout &lt;&lt; head-&gt;data &lt;&lt; "\n";
    }
}</pre><p>As you can see, the code in these functions is identical except for the order of the two statements inside the <code class="literal">if</code> statement. That makes all the difference. In the first case, we display the value in the first node <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13262"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span> before making the recursive call to display the rest of the list <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13268"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>. In the second case, we make the call to display the rest of the list <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13274"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span> before we display the value in the first node <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13280"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>. This results in an overall backward display.</p><p>Because both of these functions are equally succinct, one might assume that recursion is properly used to solve both of these problems, but that’s not the case. To see that, let’s look at iterative implementations of both of these functions.</p><a id="I_programlisting6_d1e13288"/><pre class="programlisting">void displayListForwardsIterative(listPtr head) {
   <img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/>for (listPtr current = head; current != NULL; current = current-&gt;next)
        cout &lt;&lt; current-&gt;data &lt;&lt; "\n";
}
void displayListBackwardsIterative(listPtr head) {
   <img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/>stack&lt;listPtr&gt; nodes;
   <img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/>for (listPtr current = head; current != NULL; current = current-&gt;next)
        nodes.push(current);
   <img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/>while (!nodes.empty()) {
      <img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/>nodePtr current = nodes.top();
      <img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/>nodes.pop();
      <img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/>cout &lt;&lt; current-&gt;data &lt;&lt; "\n";
    }
}</pre><p>The function to display the list in order is nothing more than a straightforward traversal loop <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13335"/><img src="httpatomoreillycomsourcenostarchimages1273182.png" alt=""/></span>, such as those we saw back in <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a>. The function to display the list in reverse order, though, is more complicated. It suffers from the same requirement for a “breadcrumb trail” as our binary tree problems. Displaying the nodes in a linked list in reverse order requires returning to prior nodes by definition. In a singly linked list, there’s no way to do that using the list itself, so a second structure is required. In this case, we need another stack. After declaring the stack <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13343"/><img src="httpatomoreillycomsourcenostarchimages1273191.png" alt=""/></span>, we push all of the nodes in our linked list onto the stack using a <code class="literal">for</code> loop <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13352"/><img src="httpatomoreillycomsourcenostarchimages1273193.png" alt=""/></span>. Because this is a stack, where each item is added on top of previous items, the first item in the linked list will be on the bottom of the stack, and the last item in the linked list will be on the top. We enter a while loop that continues until the stack is empty <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13359"/><img src="httpatomoreillycomsourcenostarchimages1273195.png" alt=""/></span>, repeatedly grabbing a pointer to the top node on the stack <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13365"/><img src="httpatomoreillycomsourcenostarchimages1273197.png" alt=""/></span>, removing that node pointer from the stack <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13371"/><img src="httpatomoreillycomsourcenostarchimages1273199.png" alt=""/></span>, and then displaying the data in the referenced node <span class="inlinemediaobject"><a id="I_inlinemediaobject6_d1e13377"/><img src="httpatomoreillycomsourcenostarchimages1273203.png" alt=""/></span>. Because the data on the top is the last data in the linked list, this has the effect of displaying the data in the linked list in reverse order.</p><p>As with the iterative binary tree function shown earlier, it would be possible to write this function without using a stack (by building a second list within the function that is a reverse of the original). There is no way, however, to make the second function as simple as the first or to avoid effectively traversing two structures instead of one. Comparing the recursive and iterative implementations, it’s easy to see that the iterative “forward” function is so simple that there is no practical advantage in employing recursion, and there are several practical disadvantages. In contrast, the recursive “backward” function is simpler than the iterative version and should be expected to perform approximately as well as the iterative version. Therefore, the “backward” function is a reasonable use of recursion, while the “forward” function, though a good recursive programming exercise, is not a good practical use of recursion.</p></div></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-id6"/>Exercises</h1></div></div></div><p>As always, trying out the ideas presented in the chapter is imperative!</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Write a function to compute the sum of just the positive numbers in an array of integers. First, solve the problem using iteration. Then, using the technique shown in this chapter, convert your iterative function to a recursive function.</p></li><li class="listitem"><p>Consider an array representing a binary string, where every element’s data value is 0 or 1. Write a <code class="literal">bool</code> function to determine whether the binary string has odd parity (an odd number of 1 bits). Hint: Remember that the recursive function is going to return true (odd) or false (even), not the count of 1 bits. Solve the problem first using iteration, then recursion.</p></li><li class="listitem"><p>Write a function that is passed an array of integers and a “target” number and that returns the number of occurrences of the target in the array. Solve the problem first using iteration, then recursion.</p></li><li class="listitem"><p>Design your own: Find a problem processing a one-dimension array that you have already solved or that is trivial for you at your current skill level, and solve the problem (or solve it again) using recursion.</p></li><li class="listitem"><p>Solve exercise 6-1 again, using a linked list instead of an array.</p></li><li class="listitem"><p>Solve exercise 6-2 again, using a linked list instead of an array.</p></li><li class="listitem"><p>Solve exercise 6-3 again, using a linked list instead of an array.</p></li><li class="listitem"><p>Design your own: Try to discover a linked-list processing problem that is difficult to solve using iteration but can be solved directly using recursion.</p></li><li class="listitem"><p>Some words in programming have more than one common meaning. In <a class="xref" href="ch04.html" title="Chapter 4. Solving Problems with Pointers and Dynamic Memory">Chapter 4</a>, we learned about the heap, from which we get memory allocated with <code class="literal">new</code>. The term <span class="emphasis"><em>heap</em></span> also describes a binary tree in which each node value is higher than any in the left or right subtree. Write a recursive function to determine whether a binary tree is a heap.</p></li><li class="listitem"><p>A <span class="emphasis"><em>binary search tree</em></span> is a binary tree in which each node value is greater than any value in that node’s left subtree but less than any value in the node’s right subtree. Write a recursive function to determine whether a binary tree is a binary search tree.</p></li><li class="listitem"><p>Write a recursive function that is passed a binary search tree’s root pointer and a new value to be inserted and that creates a new node with the new value, placing it in the correct location to maintain the binary search tree structure. Hint: Consider making the root pointer parameter a reference parameter.</p></li><li class="listitem"><p>Design your own: Consider basic statistical questions you can ask of a set of numerical values, such as average, median, mode, and so forth. Attempt to write recursive functions to compute those statistics for a binary tree of integers. Some are easier to write than others. Why?</p></li></ol></div></div></div></body></html>