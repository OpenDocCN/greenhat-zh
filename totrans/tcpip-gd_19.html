<html><head></head><body><div class="part" title="Part&#xA0;III-8.&#xA0;TCP/IP WORLD WIDE WEB AND THE HYPERTEXT TRANSFER PROTOCOL (HTTP)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_world_wide_web_and_the_hypertext_t"/>Part III-8. TCP/IP WORLD WIDE WEB AND THE HYPERTEXT TRANSFER PROTOCOL (HTTP)</h1></div></div></div><div class="partintro" id="id3367653" title="TCP/IP WORLD WIDE WEB AND THE HYPERTEXT TRANSFER PROTOCOL (HTTP)"><div/><p><a class="xref" href="ch79.html" title="Chapter 79. WORLD WIDE WEB AND HYPERTEXT OVERVIEW AND CONCEPTS">Chapter 79</a></p><p><a class="xref" href="ch80.html" title="Chapter 80. HTTP GENERAL OPERATION AND CONNECTIONS">Chapter 80</a></p><p><a class="xref" href="ch81.html" title="Chapter 81. HTTP MESSAGES, METHODS, AND STATUS CODES">Chapter 81</a></p><p><a class="xref" href="ch82.html" title="Chapter 82. HTTP MESSAGE HEADERS">Chapter 82</a></p><p><a class="xref" href="ch83.html" title="Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management">Chapter 83</a></p><p><a class="xref" href="ch84.html" title="Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES">Chapter 84</a></p><p>In my overview of file and message transfer protocols in <a class="xref" href="ch71.html" title="Chapter 71. FILE AND MESSAGE TRANSFER OVERVIEW AND APPLICATION CATEGORIES">Chapter 71</a>, I said that the World Wide Web was "almost certainly" the most important TCP/IP application. If anything, I was probably understating the case. The Web is not only quite clearly the most important TCP/IP application today, it is arguably the single most important application in the history of networking, and perhaps even computing as a whole.</p><p>This may sound a little melodramatic, but consider what the Web has done in the decade or so that it has been around. It has transformed not only how internetworks are used, but in many ways, it has also changed society itself. The Web put the Internet on the map, so to speak, moving it from the realm of technicians and academics to the mainstream world.</p><p>This part contains six chapters that describe the World Wide Web and the all-important <span class="emphasis"><em>Hypertext Transfer Protocol (HTTP)</em></span>, the TCP/IP application layer protocol that makes the Web work. The first chapter discusses the Web and the concepts behind hypertext and hypertext documents in general terms. The second chapter provides an overview of HTTP and describes its operation in general terms, focusing on how connections are established and maintained. The third chapter outlines HTTP messages and how they are formatted, and describes HTTP methods (commands) and status codes. The fourth chapter details the many HTTP headers, which are critically important because they are the primary way that information is communicated between HTTP servers and clients. The fifth chapter provides information about how resources, called <span class="emphasis"><em>entities</em></span>, are encoded and transferred in HTTP. The sixth and final chapter explores special features and capabilities of the modern HTTP protocol.</p><p>Like so many TCP/IP protocols, when HTTP was designed, its creators borrowed elements from other application protocols. In this case, HTTP uses certain elements from email, especially the Multipurpose Internet Mail Extensions (MIME). I would recommend familiarity with both the RFC 822 email message format and MIME, especially MIME headers and media types, before reading this part (both topics are covered in <a class="xref" href="ch76.html" title="Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME">Chapter 76</a>). The relationship between HTTP and MIME is covered more fully in <a class="xref" href="ch83.html" title="Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management">Chapter 83</a>, which discusses HTTP entities and media types.</p></div></div>
<div class="chapter" title="Chapter&#xA0;79.&#xA0;WORLD WIDE WEB AND HYPERTEXT OVERVIEW AND CONCEPTS"><div class="titlepage"><div><div><h1 class="title"><a id="world_wide_web_and_hypertext_overview_an"/>Chapter 79. WORLD WIDE WEB AND HYPERTEXT OVERVIEW AND CONCEPTS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e87285"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The World Wide Web (the Web) expands the concepts of messaging beyond the limits of simple text file transfer of electronic mail (email), File Transfer Protocol (FTP), and Usenet. Its power is in its combination of <span class="emphasis"><em>hypertext</em></span>, a system that allows related documents to be linked together, its rich document format that supports not just text but graphics and multimedia, and the special protocol that allows efficient movement of those media. The result is a powerful system that, once introduced, caught on almost immediately among everyone from large company users to individuals. In a few short years, the Web came to dominate all other applications on the Internet.</p><p>In this chapter, I take a high-level, summarized look at the concepts behind the Web. I begin with a short overview and history of the Web and hypertext and a discussion of the components that make up the Web system. I briefly describe the documents and media used on the Web and explain the importance of the Hypertext Markup Language (HTML). I conclude with an overview of how documents are addressed on the Web using Uniform Resource Locators (URLs).</p><div class="sect1" title="World Wide Web and Hypertext Overview and History"><div class="titlepage"><div><div><h1 class="title"><a id="world_wide_web_and_hypertext_overv-id001"/>World Wide Web and Hypertext Overview and History</h1></div></div></div><p>The <a class="indexterm" id="idx-CHP-79-2845"/>World Wide Web is one of the members of the class of Internet messaging applications. But for some reason, it just doesn't seem like a message transfer protocol to me. This led me to wonder, what is so special about the Web that caused it to become popular in a way that no prior messaging applications ever had?</p><p>There is no truly accurate one-word answer to this question. However, if I had to give one anyway, it would be this: <a class="indexterm" id="idx-CHP-79-2846"/><span class="emphasis"><em>hypertext</em></span>. Sure, applications like email and Usenet allow users to send and receive information, and FTP lets a user access a set of files on a server. But what these methods lack is any way of easily representing the <span class="emphasis"><em>relationship</em></span> between documents or providing a way of moving from one to another. Highly simplified, hypertext does exactly that: It allows the creator of a document to include links to related information, either elsewhere in that document or in other documents. With the appropriate software, a user can easily move from one location to another. So why is this a big deal? In fact, this is more important than it may initially seem.</p><p>Without some way of linking documents together, they remain in unconnected islands. In some ways, hypertext-linked documents are to unlinked documents what networked computers are to those that are not networked.</p><div class="sect2" title="History of Hypertext"><div class="titlepage"><div><div><h2 class="title"><a id="history_of_hypertext"/>History of Hypertext</h2></div></div></div><p><a class="indexterm" id="idx-CHP-79-2847"/>The ideas behind hypertext actually go back far beyond the Web and even electronic computers. Vannevar <a class="indexterm" id="idx-CHP-79-2848"/>Bush (1890–1974) is generally credited with introducing the idea in his 1945 description of a theoretical device called the <a class="indexterm" id="idx-CHP-79-2849"/><span class="emphasis"><em>Memex</em></span>, which was intended to be used to store and retrieve documents. He described the concept of a <span class="emphasis"><em>trail</em></span> that would link together related information to make it easier to organize and access the information in the device.</p><p>Bush's ideas were used as the basis of the work of several researchers who followed. One of these was Ted <a class="indexterm" id="idx-CHP-79-2850"/>Nelson, who coined the term <span class="emphasis"><em>hypertext</em></span> and, in 1960, first described a system called <a class="indexterm" id="idx-CHP-79-2851"/><span class="emphasis"><em>Xanadu</em></span>, which is considered one of the original hypertext software models.</p><p>The history of the Web itself goes back to 1989 at <a class="indexterm" id="idx-CHP-79-2852"/><span class="emphasis"><em>CERN</em></span>, the European Organization for Nuclear Research, in Geneva. (The acronym stands for <span class="emphasis"><em>Conseil Européen pour la Recherche Nucléaire</em></span>, the French name of the organization.) Many of the projects undertaken at CERN were large and complex, and they took many years to complete. They also involved many scientists who had to work with and share related documents.</p><p>A researcher at CERN, Tim <a class="indexterm" id="idx-CHP-79-2853"/>Berners-Lee, proposed the idea of creating a "web" of electronically linked documents. The rapidly growing Internet was the obvious conduit for this project. He designed the first (very crude and simple) version of HTTP for TCP/IP in 1990. He was also responsible for developing or co-developing several of the other key concepts and components behind the Web, such as Uniform Resource Identifiers (URIs) and HTML.</p><p>The ability to link documents and files had tremendous appeal, and it took little time before creative individuals found many different uses for this new technology. The early 1990s saw a flurry of development activity. Web server and client software was developed and refined, and the first graphical web browser, <span class="emphasis"><em>Mosaic</em></span>, was created by the National Center for Supercomputer Applications (NCSA) in 1993. (The developer of this program, Marc Andreessen, eventually formed Netscape Communications.)</p><p>Once the Web started to form, it grew very quickly indeed. In fact, to call the growth of the Web anything but <span class="emphasis"><em>explosive</em></span> would not do it justice. In early 1993, only 50 active HTTP web servers existed. By late 1993, more than 1,000 were in service. By late 1995, thousands of new websites were coming online every day, and HTTP requests and responses had overtaken all other TCP/IP application traffic. By the end of the decade, <span class="emphasis"><em>millions</em></span> of websites and more than a billion documents were available on the Web.</p></div><div class="sect2" title="The World Wide Web Today"><div class="titlepage"><div><div><h2 class="title"><a id="the_world_wide_web_today"/>The World Wide Web Today</h2></div></div></div><p>While the rapid growth in the size of the Web is amazing, what is even more fascinating is its growth in <span class="emphasis"><em>scope</em></span>. Since you are reading a book about networking, you are most likely a Web user who is familiar with the incredible array of different types of information you can find on the Web today. Early hypertext systems were based on the use of only text documents; today the Web is a world of many media including pictures, sounds, and movies. The term <span class="emphasis"><em>hypertext</em></span> has in many contexts been replaced with the more generic <a class="indexterm" id="idx-CHP-79-2854"/><span class="emphasis"><em>hypermedia</em></span>—functionally, if not officially.</p><p>The Web has also moved beyond providing simple document retrieval to providing a myriad of services. A website can serve up much more than just documents, allowing users to run thousands of kinds of programs to do everything from shop to play music or games online. Websites are also blurring the lines between different types of applications, offering Web-based email, Web-based Usenet access, bulletin boards, and other interactive forums for discussion.</p><p>The Web has had an impact on both networking and society as a whole that even its most enthusiastic early fans could never have anticipated. In fact, the Web was the ultimate "killer application" for the Internet as a whole. In the early 1990s, big corporations viewed the Web as an amusing curiosity; by the end of the decade, it was for many a business necessity. Millions of individuals and families discovered the wealth of information at their fingertips, and Internet access became for many another necessary utility, like telephone service. In fact, the huge increase in Web traffic volume spawned the spending of billions of dollars on Internet infrastructure.</p><p>The dot-com collapse of the early twenty-first century took some of the wind out of the Web's sails. The incredible growth of the Web could not continue at its original pace and has slowed somewhat. But the Web as a whole continues to expand and mature, and it will likely be the most important information and service resource on the Internet for some time to come.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-477"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The World Wide Web (the Web or WWW) began in 1989 as a project designed to facilitate the representation of relationships between documents and the sharing of information between researchers. The main feature of the Web that makes it so powerful is hypertext, which allows links to be made from one document to another. The many benefits of the Web caused it to grow in only a few short years from a small application to the largest and arguably most important application in the world of networking. It is largely responsible for bringing the Internet into the mainstream of society.</p></div></div></div></div>
<div class="sect1" title="World Wide Web System Concepts and Components"><div class="titlepage"><div><div><h1 class="title"><a id="world_wide_web_system_concepts_and_compo"/>World Wide Web System Concepts and Components</h1></div></div></div><p>Hypertext is the main concept that makes the Web more than just another message transfer system. However, the idea behind hypertext had been around for decades before the Web was born, as had certain software products based on that idea. Obviously, more than just a concept is needed for an idea to be developed into a successful system.</p><p>The Web became a phenomenon because it combined the basic idea of hypertext with several other concepts and technologies to create a rich, comprehensive mechanism for interactive communication. This system today encompasses so many different concepts and software elements, and is so integrated with other technologies, that it's difficult to find any two people who agree on what exactly the Web comprises, and which parts are most critical.</p><p>For example, one of the keys to the success of the Web is undeniably the combination of the TCP/IP internetworking protocol suite and the Internet infrastructure that connects together the computers of the world. Is the Internet then an essential component of the Web? In many ways, it is; and, in fact, due to how popular the Web is today, it is common to hear people refer to the Web as <span class="emphasis"><em>the Internet</em></span>. We know that this is not a precise use of terms, of course, but it shows how important the Web has become and how closely it is tied to the Internet.</p><div class="sect2" title="Major Functional Components of the Web"><div class="titlepage"><div><div><h2 class="title"><a id="major_functional_components_of_the_web"/>Major Functional Components of the Web</h2></div></div></div><p><a class="indexterm" id="idx-CHP-79-2855"/>While the Internet and TCP/IP are obviously important parts of the Web's success, they are generic in nature. When it comes to defining the Web system itself more specifically, three particular components are usually considered most essential (see <a class="xref" href="ch79s02.html#major_functional_components_of_the_world" title="Figure 79-1. Major functional components of the World Wide Web">Figure 79-1</a>):</p><p><span class="strong"><strong>Hypertext Markup Language</strong></span> HTML is a text language used to define hypertext documents. The idea behind HTML was to add simple constructs, called <span class="emphasis"><em>tags</em></span>, to regular text documents, to enable the linking of one document to another, as well as to allow special data formatting and the combining of different types of media. HTML has become the standard language for implementing information in hypertext and has spawned the creation of numerous related languages.</p><p><span class="strong"><strong>Hypertext Transfer Protocol</strong></span> HTTP is the TCP/IP application layer protocol that implements the Web, by enabling the transfer of hypertext documents and other files between a client and server. HTTP began as a very crude protocol for transferring HTML documents between computers, and it has evolved to a full-featured and sophisticated messaging protocol. It supports transfers of many different kinds of documents, streaming of multiple files on a connection, and various advanced features including caching, proxying, and authentication.</p><p><span class="strong"><strong>Uniform Resource Identifiers</strong></span> URIs are used to define labels that identify resources on an internetwork so that they can be easily found and referenced. URIs were originally developed to provide a means by which the users of the Web could locate hypertext documents so they could be retrieved. URIs are actually not specific to the Web, though they are most often associated with the Web and HTTP.</p><div class="figure"><a id="major_functional_components_of_the_world"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e87456"/><img alt="Major functional components of the World Wide Web" src="httpatomoreillycomsourcenostarchimages288305.png.jpg"/></div></div><p class="title">Figure 79-1. Major functional components of the World Wide Web</p></div><div class="note" title="Note"><h3 class="title"><a id="note-171"/>Note</h3><p><a class="indexterm" id="idx-CHP-79-2856"/><span class="emphasis"><em>Uniform Resource Locators (URLs) are actually a subset of Uniform Resource Identifiers (URIs). The terms are often used interchangeably in World Wide Web discussions</em></span><a class="indexterm" id="idx-CHP-79-2857"/>.</p></div><p>All three of these components were created and developed at around the same time, and taken together they represent the key technologies that define the Web. In this chapter, I'll describe HTML and the use of URIs in the context of the Web. HTTP is really the heart of the Web and is covered in the remaining five chapters of this part of the book.</p></div><div class="sect2" title="Web Servers and Web Browsers"><div class="titlepage"><div><div><h2 class="title"><a id="web_servers_and_web_browsers"/>Web Servers and Web Browsers</h2></div></div></div><p><a class="indexterm" id="idx-CHP-79-2858"/><a class="indexterm" id="idx-CHP-79-2859"/>These three main Web components are supplemented by a number of other elements that play supporting roles in rounding out the system as a whole. Chief among these are the hardware and software used to implement client/server communication that makes the Web work, also illustrated in <a class="xref" href="ch79s02.html#major_functional_components_of_the_world" title="Figure 79-1. Major functional components of the World Wide Web">Figure 79-1</a>: <span class="emphasis"><em>web servers</em></span> and <span class="emphasis"><em>web browsers</em></span><a class="indexterm" id="idx-CHP-79-2860"/>.</p><p>Web servers are computers that run special server software that allows them to provide hypertext documents and other files to clients who request them. Millions of such machines around the world now serve as a virtual distributed repository of the enormous wealth of information that the Web represents.</p><p>Web browsers are HTTP client software programs that run on TCP/IP client computers to access web documents on web servers. These browser programs retrieve hypertext documents and display them, and they also implement many of the Web's advanced features, such as caching. Today's browsers support a wide variety of media, allowing the Web to implement many different functions aside from hypertext document transfer. Examples include displaying images, playing sounds, and implementing interactive programs.</p><p>Last, but certainly not least, the <span class="emphasis"><em>users</em></span> of the Web are perhaps its most important component. User involvement has had more of a role in shaping the development of Web technology than any other networking application. The Web began as a simple means of exchanging documents; today, it has grown to encompass thousands of different applications and services, largely as a result of the creativity of its users. Content providers have pushed the boundaries of what the Web can do by creating new ideas for information and services to satisfy the insatiable demands of the end-user community.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-478"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The World Wide Web is a complete system comprising a number of related components, of which three are most essential. Hypertext Markup Language (<a class="indexterm" id="idx-CHP-79-2861"/>HTML) describes how hypertext documents are constructed. HTML allows links between documents to be represented. The Hypertext Transfer Protocol (HTTP) is the application layer protocol that moves hypertext and other documents over the Web. The Uniform Resource Identifier (URI) mechanism provides a consistent means of identifying resources, both on the Web and more generally on the Internet as a whole.</p></div></div></div>
<div class="sect1" title="World Wide Web Media and the Hypertext Markup Language"><div class="titlepage"><div><div><h1 class="title"><a id="world_wide_web_media_and_the_hypertext_m"/>World Wide Web Media and the Hypertext Markup Language</h1></div></div></div><p><a class="indexterm" id="idx-CHP-79-2862"/>I've said the Web is based around the central concept of <span class="emphasis"><em>hypertext</em></span>. The prefix <span class="emphasis"><em>hyper</em></span> usually means above or beyond, and thus <span class="emphasis"><em>hypertext</em></span> is like text but goes beyond it in terms of functionality. Documents written in hypertext are similar to regular text files but include information that implements hypertext functions. These are usually called <span class="emphasis"><em>hypertext documents</em></span> or <span class="emphasis"><em>hypertext files</em></span>.</p><p>The extra information in a hypertext document is used to tell the computer program that displays the file how to format it. This information takes the form of special instructions that are interspersed with the actual text of the document itself, which are written according to the syntax of a defining language. This addition of extra elements to the content of a document is commonly called <span class="emphasis"><em>marking up</em></span> the document.</p><div class="sect2" title="Overview of HTML"><div class="titlepage"><div><div><h2 class="title"><a id="overview_of_html"/>Overview of HTML</h2></div></div></div><p>HTML is one of the three primary system components of the Web and was invented in 1990 by the creator of the Web, Tim Berners-Lee. It was not created in a vacuum; rather, it is a specific application of the general concept of a markup language that is described in ISO standard 8879:1986—the <span class="emphasis"><em>Standard Generalized Markup Language (SGML)</em></span><a class="indexterm" id="idx-CHP-79-2863"/>.</p><p>A markup language defines special items that provide information to the software displaying the document about how it should be presented. For the purposes of hypertext, the most basic type of information in a document is a special instruction that specifies how one document can be linked to another—after all, this linking process is the defining attribute of hypertext.</p><p>However, HTML goes far beyond just this; it defines a full set of text codes used for describing nearly every aspect of how a document is shown to a user. This includes instructions for formatting text (such as defining its color, size, and alignment), interactive forms, methods for displaying tabular data, specifications for how to present images and other media along with the document, and much more. In theory, the language is only supposed to define the document and leave how it should be displayed up to the browser, but in practice, modern HTML documents also usually contain rather specific instructions for how their information should be presented.</p><p>To do justice to HTML, I would need to devote several dozen pages to the subject. I have decided not to do this, because even though HTML is an important part of the Web, it is actually not that important in understanding how the Web works. Knowing HTML is essential if you are writing Web content, and it is also critical if you want to understand how to write Web software. Perhaps ironically, though, to the actual mechanisms that make the Web work, such as HTTP, a document is a document. HTTP is not designed under the assumption that it will transfer HTML, and in most cases, servers do not even look at the contents of an HTML file—they just transfer it.</p><p>That said, a basic understanding of HTML is important, and it just wouldn't seem right not to provide at least an overview of the language, so I will do that here. I encourage you to seek out one of the many good HTML resources if you want to learn more—you'll find dozens of them on the Web (where else?).</p></div><div class="sect2" title="HTML Elements and Tags"><div class="titlepage"><div><div><h2 class="title"><a id="html_elements_and_tags"/>HTML Elements and Tags</h2></div></div></div><p><a class="indexterm" id="idx-CHP-79-2864"/><a class="indexterm" id="idx-CHP-79-2865"/>In simplest terms, an HTML document is a plain ASCII text file, like an email message or other text document. The biggest difference between HTML and regular text is that HTML documents are <span class="emphasis"><em>structured</em></span>; that is, the document is logically organized into a series of <span class="emphasis"><em>elements</em></span> that are arranged according to the rules of the language. Each element defines one part of the document as a whole. The title of a document, a paragraph, a table, and a hyperlink to another document are all examples of elements.</p><p>Each element is described using special text <span class="emphasis"><em>tags</em></span> that follow a particular syntax. Each tag begins with the &lt; symbol, which is then followed by the (case-insensitive) element name, and optionally, additional parameters that describe the element. The tag ends with the &gt; symbol. Here's how a tag looks generally:</p><a id="I_programlisting1_d1e87595"/><pre class="programlisting">&lt;element parameter1="value1" parameter2="value2". . .&gt;</pre><p>Some elements are entirely described by the presence of a tag, and in such cases, that tag is the entire element. More often, tags occur in pairs surrounding the actual content of the element; the <span class="emphasis"><em>start tag</em></span> begins with the name of the element, and the <span class="emphasis"><em>end tag</em></span> begins with a slash symbol followed by the name of the element. For example, the title of a document is an element that can be defined as follows:</p><a id="I_programlisting1_d1e87605"/><pre class="programlisting">&lt;title&gt;This Is A Great Story&lt;/title&gt;</pre><p>The content of each element can contain other elements, which causes tags to be nested within each other. For example, if we wanted to highlight the word <span class="emphasis"><em>Great</em></span> in our title by displaying it in bold letters, we can add the <code class="literal">&lt;b&gt;</code> tag as follows:</p><a id="I_programlisting1_d1e87615"/><pre class="programlisting">&lt;title&gt;This Is A &lt;b&gt;Great&lt;/b&gt; Story&lt;/title&gt;</pre><p>Each whole HTML document is defined as a single element called <code class="literal">html</code>; the whole document is enclosed in <code class="literal">&lt;html&gt;</code> and <code class="literal">&lt;/html&gt;</code> tags. Within this element, the document is divided into two standard subelements that must be present in each document: the <code class="literal">head</code> and the <code class="literal">body</code>. The <code class="literal">head</code> of the document contains information that describes the document and how it is to be processed; it most commonly contains the title of the document. The <code class="literal">body</code> contains the actual content of the document. These three <a class="indexterm" id="idx-CHP-79-2866"/>elements define the basic HTML document structure, as follows:</p><a id="I_programlisting1_d1e87647"/><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
(head elements go here...)
&lt;/head&gt;
&lt;body&gt;
(body elements go here...)
&lt;/body&gt;
&lt;/html&gt;</pre><p>The bulk of the document consists of the body elements that are placed between the <code class="literal">&lt;body&gt;</code> and <code class="literal">&lt;/body&gt;</code> tags. HTML documents can range from very simple bodies containing only elements such as text paragraphs and perhaps a few links, to very sophisticated documents that are computer-generated and contain hundreds or even thousands of nested tags of various sorts.</p></div><div class="sect2" title="Common HTML Elements"><div class="titlepage"><div><div><h2 class="title"><a id="common_html_elements"/>Common HTML Elements</h2></div></div></div><p><a class="xref" href="ch79s03.html#common_html_elements-id001" title="Table 79-1. Common HTML Elements">Table 79-1</a> provides a brief description of some of the more common elements used in the body of an HTML message and the tags that define them, to give you a feel for how the language works.</p><div class="table"><a id="common_html_elements-id001"/><p class="title">Table 79-1. Common HTML Elements</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common HTML Elements"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Element</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Example Element and Tags</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Paragraph</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a id="I_programlisting1_d1e87688"/></p><pre class="programlisting">&lt;p&gt;Jack and Jill went up the hill to
fetch a pail of water...&lt;/p&gt;</pre></td><td style="border-bottom: 0.5pt solid ; "><p>Delineates a paragraph of text. Note that everything between the start and end tags will be considered one paragraph, even if split onto multiple lines as I have done here. Line breaks are not significant in HTML formatting; only tags are recognized.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Line Break</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a id="I_programlisting1_d1e87699"/></p><pre class="programlisting">George W. Bush&lt;br&gt;
The White House&lt;br&gt;
1600 Pennsylvania Ave., NW&lt;br&gt;
Washington, DC 20500</pre></td><td style="border-bottom: 0.5pt solid ; "><p>Forces a line break. Used instead of the paragraph tag to present lines close together, such as addresses.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Heading</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a id="I_programlisting1_d1e87710"/></p><pre class="programlisting">&lt;h1&gt;First Topic&lt;/h1&gt;
&lt;h2&gt;Subtopic&lt;/h2&gt;</pre></td><td style="border-bottom: 0.5pt solid ; "><p>Defines section headings to allow information in a long document to be displayed in hierarchical form. Six sets of tags are defined, from <code class="literal">&lt;h1&gt;</code> and <code class="literal">&lt;/h1&gt;</code> to <code class="literal">&lt;h6&gt;</code> and <code class="literal">&lt;/h6&gt;</code>. Browsers will automatically display the higher-level headings in more prominent ways, by using larger fonts, underlining the text, or similar treatment.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>List</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a id="I_programlisting1_d1e87733"/></p><pre class="programlisting">&lt;p&gt;Shopping list:
&lt;ul&gt;
&lt;li&gt;Milk
&lt;li&gt;Eggs
&lt;li&gt;Sushi
&lt;/ul&gt;
&lt;/p&gt;</pre></td><td style="border-bottom: 0.5pt solid ; "><p>Allows information to be presented as a list. The tag <code class="literal">&lt;ul&gt;</code> means unnumbered list and causes the list items to be shown usually as bullet points. Alternatively, <code class="literal">&lt;ol&gt;</code> (ordered list) can be used to show the items preceded by 1, 2, 3, and so on.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Horizontal Rule</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a id="I_programlisting1_d1e87750"/></p><pre class="programlisting">...end of this part of the story.&lt;/p&gt;
&lt;hr size= "3"&gt;
&lt;p&gt;Start of next part of story...</pre></td><td style="border-bottom: 0.5pt solid ; "><p>Draws a horizontal line across the page; the <code class="literal">size</code> parameter controls its thickness. Used to separate logical sections in a document.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Image</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a id="I_programlisting1_d1e87764"/></p><pre class="programlisting">&lt;img src="companylogo.gif" alt="XYZ
Industries Logo" align="center"&gt;</pre></td><td style="border-bottom: 0.5pt solid ; "><p>Displays an inline image in the appropriate section of the text. The <code class="literal">src</code> parameter is a relative or absolute URL for the image, and numerous other parameters can be included to define the image's alignment, size, alternate text to display if the browser is nongraphical (as shown here with the <code class="literal">alt</code> parameter), and much more.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Link</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a id="I_programlisting1_d1e87781"/></p><pre class="programlisting">&lt;a href="http://
www.PCGuide.com"&gt;Click here to visit
The PC Guide&lt;/a&gt;</pre></td><td style="border-bottom: 0.5pt solid ; "><p>Hyperlinks to another document. The <span class="emphasis"><em>a</em></span> in the tag stands for anchor, which is the formal name for a hyperlink. The <code class="literal">href</code> parameter specifies the URL of the link. Most browsers will underline or otherwise highlight text between the start and end tags to make it clear that the text represents a hyperlink. It is also possible to give a hyperlink to an image by combining the <code class="literal">&lt;img&gt;</code> and <code class="literal">&lt;a&gt;</code> tags.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bookmark</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a id="I_programlisting1_d1e87804"/></p><pre class="programlisting">&lt;a name="Step4"&gt;Step 4: Remove paint
using scrubbing tool.&lt;/a&gt;</pre></td><td style="border-bottom: 0.5pt solid ; "><p>Creates a bookmark that can be used to hyperlink to a particular section in a document. For example, if the bookmark in this example was in a document at URL <a class="ulink" href="http://www.homefixitup.com/repainting.htm">http://www.homefixitup.com/repainting.htm</a>, the URL <a class="ulink" href="http://www.homefixitup.com/repainting.htm#Step4">http://www.homefixitup.com/repainting.htm#Step4</a> refers to this particular place in the document. See the discussion of URLs later in this chapter for more details.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Table</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a id="I_programlisting1_d1e87819"/></p><pre class="programlisting">&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;1st row, 1st column.&lt;/td&gt;
&lt;td&gt;1st row, 2nd column.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2nd row, 1st column.&lt;/td&gt;
&lt;td&gt;2nd row, 2nd column.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;</pre></td><td style="border-bottom: 0.5pt solid ; "><p>Displays information in tabular form. Each <code class="literal">&lt;tr&gt;</code> and <code class="literal">&lt;/tr&gt;</code> tag set defines one row of the table; within each row, each <code class="literal">&lt;td&gt;</code> and <code class="literal">&lt;/td&gt;</code> pair defines one table data element. Many different parameters can be provided for each of these tags to control table size and appearance.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Form</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a id="I_programlisting1_d1e87842"/></p><pre class="programlisting">&lt;form method="POST" action="https://
www.myfavesite.com/order.php"&gt;
&lt;input type="hidden" name="PRODUCT"
value="widget"&gt;
&lt;input type="text" name="QUANTITY"
size="3"&gt;
&lt;input type="submit" value="Click
Here to Proceed to the Secure
Processing Site"&gt;
&lt;/form&gt;</pre></td><td style="border-bottom: 0.5pt solid ; "><p>Defines an HTML form, allowing various sorts of information to be submitted by a client to a program on a website designed to process forms. The form consists of the initial <code class="literal">&lt;form&gt;</code> tag that describes what action to be taken when the submission button is pressed, and other form items such as predefined variables, text-entry fields, and buttons. One example of each of these items is shown here.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Script</p></td><td style="border-right: 0.5pt solid ; "><p><a id="I_programlisting1_d1e87856"/></p><pre class="programlisting">&lt;script language=javascript&gt;
(JavaScript code)
&lt;/script&gt;</pre></td><td style=""><p>Allows instructions in a scripting language to be included in an HTML document. It is most often used for JavaScript.</p></td></tr></tbody></table></div></div></div><div class="sect2" title="Common Text Formatting Tags"><div class="titlepage"><div><div><h2 class="title"><a id="common_text_formatting_tags"/>Common Text Formatting Tags</h2></div></div></div><p>Numerous tags are used to format the appearance of <a class="indexterm" id="idx-CHP-79-2867"/>text within a document; here are some of the more common ones:</p><p><strong class="userinput"><code>&lt;b&gt;text&lt;/b&gt;</code></strong> Present the enclosed text in boldface.</p><p><strong class="userinput"><code>&lt;i&gt;text&lt;/i&gt;</code></strong> Present the enclosed text in italics.</p><p><strong class="userinput"><code>&lt;u&gt;text&lt;/u&gt;</code></strong> Present the enclosed text underlined.</p><p><strong class="userinput"><code>&lt;font (parameters)&gt;text&lt;/font&gt;</code></strong> Present the enclosed text using the indicated font type, size, or color.</p><p>This is just the tip of the iceberg when it comes to HTML. If you are not familiar with HTML, however, knowing these basic tags should help you interpret basic HTML documents and learn how HTTP works.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-479"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The language used by <a class="indexterm" id="idx-CHP-79-2868"/>World Wide Web hypertext documents is called HTML. HTML documents are like ASCII text files, but they are arranged using a special structure of HTML elements that define the different parts of the document and how they should be displayed to the user. Each element is described using special text tags that define it and its characteristics.</p></div></div></div>
<div class="sect1" title="World Wide Web Addressing: HTTP Uniform Resource Locators"><div class="titlepage"><div><div><h1 class="title"><a id="world_wide_web_addressing_http_uniform_r"/>World Wide Web Addressing: HTTP Uniform Resource Locators</h1></div></div></div><p><a class="indexterm" id="idx-CHP-79-2869"/>The main reason that hypertext is so powerful and useful is that it allows related documents to be linked together. In the case of the Web, this is done using a special set of HTML tags that specifies in one document the name of another document that is related in some important way. A user can move from one document to the next using a simple mouse click. The Web has succeeded largely on the basis of this simple and elegant method of referral.</p><p>The notion of hyperlinking has some important implications on how Web documents and other resources are addressed. Even though the Web is at its heart a message transfer protocol similar to FTP, the need to be able to define hyperlinks meant that the traditional FTP model of using a set of commands to specify how to retrieve a resource had to be abandoned. Instead, a system was needed whereby a resource could be uniquely specified using a simple, compact string.</p><p>The result of this need was the definition of one of the three primary elements of the Web: the <span class="emphasis"><em>URI</em></span>. URIs are divided into two categories: <a class="indexterm" id="idx-CHP-79-2870"/><span class="emphasis"><em>Uniform Resource Locators (URLs)</em></span> and <span class="emphasis"><em>Uniform Resource Names (URNs)</em></span>. While URIs, URLs, and URNs grew out of the development of the Web, they have now been generalized to provide an addressing mechanism for a wide assortment of TCP/IP application layer protocols. They are described in detail in <a class="xref" href="ch70.html" title="Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING: UNIFORM RESOURCE IDENTIFIERS, LOCATORS, AND NAMES (URIS, URLS, AND URNS)">Chapter 70</a>. Here, we will look at how they are used specifically for the Web.</p><p>Currently, the Web uses URLs almost exclusively; URNs are still in development. Web URLs specify the use of HTTP for resource retrieval and are thus normally called <span class="emphasis"><em>HTTP URLs</em></span>. These URLs allow a resource such as a document, graphical image, or multimedia file to be uniquely addressed by specifying the host name, directory path, and filename where it is located.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-480"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Uniform Resource Identifiers (URIs) were developed to allow World Wide Web resources to be easily and consistently identified; they are also now used for other protocols and applications. The type of URI currently used on the Web is the Uniform Resource Locator (URL), which identifies the use of HTTP to retrieve a resource, and provides information on where and how it can be found and retrieved.</p></div><div class="sect2" title="HTTP URL Syntax"><div class="titlepage"><div><div><h2 class="title"><a id="http_url_syntax"/>HTTP URL Syntax</h2></div></div></div><p><a class="indexterm" id="idx-CHP-79-2871"/>HTTP URLs may be absolute or relative (see "URL Relative Syntax and Base URLs" in <a class="xref" href="ch70.html" title="Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING: UNIFORM RESOURCE IDENTIFIERS, LOCATORS, AND NAMES (URIS, URLS, AND URNS)">Chapter 70</a> for details on the difference between them). Absolute URLs are usually used for hyperlinks from one website to another or by users requesting a new document without any prior context. Absolute HTTP URLs are based on the following common Internet URL syntax:</p><a id="I_programlisting1_d1e87951"/><pre class="programlisting">&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;urlpath&gt;;&lt;params&gt;?&lt;query&gt;#&lt;fragment&gt;</pre><p>For the Web, the scheme is <code class="literal">http:</code>, and the semantics of the different URL elements are defined to have meanings that are relevant to the Web. The general structure of an HTTP URL looks like this:</p><a id="I_programlisting1_d1e87958"/><pre class="programlisting">http://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt;?&lt;query&gt;#&lt;bookmark&gt;</pre><p>These syntactic elements are specifically defined for HTTP absolute URLs as follows:</p><p><strong class="userinput"><code>&lt;user&gt; and &lt;password&gt;</code></strong> Optional authentication information, for resources located on password-protected servers. This construct is rarely used in practice, so most people don't realize it is an option. It has thus become a target of abuse by con artists who use it to obscure undesirable URLs.</p><p><strong class="userinput"><code>&lt;host&gt;</code></strong> The host name of the web server where the resource is located. This is usually a fully qualified Domain Name System (DNS) domain name, but it may also be an IP address.</p><p><strong class="userinput"><code>&lt;port&gt;</code></strong> The TCP port number to use for connecting to the web server. This defaults to port 80 for HTTP and is usually omitted. In rare cases, you may see some other port number used, sometimes to allow two copies of web server software devoted to different uses on the same IP address. Port 8080 is especially common as an alternative.</p><p><strong class="userinput"><code>&lt;url-path&gt;</code></strong> The path pointing to the specific resource to be retrieved using HTTP. This is usually a full directory path expressing the sequence of directories to be traversed from the root directory to the place where the resource is located, and then the resource's name. It's important to remember that the path is case-sensitive, even though DNS domain names are not.</p><p><strong class="userinput"><code>&lt;query&gt;</code></strong> An optional query or other information to be passed to the web server. This feature is commonly used to implement interactive functions, because the query value can be specified by the user and then be passed from the web browser to the web server. The alternative method is by using the HTTP POST method.</p><p><strong class="userinput"><code>&lt;bookmark&gt;</code></strong> Identifies a particular location within an HTML document. This is commonly used in very large HTML documents to allow a user to click a hyperlink and scroll to a particular place in the document. See the example near the end of <a class="xref" href="ch79s03.html#common_html_elements-id001" title="Table 79-1. Common HTML Elements">Table 79-1</a>.</p><p>Although the URL syntax for the Web is quite rich and potentially complex, most Web URLs are actually quite short. The vast majority of these components are omitted, especially the user, password, port, and bookmark elements. Queries are used only for special purposes. This leaves the more simplified form you will usually encounter for URLs:</p><a id="I_programlisting1_d1e87991"/><pre class="programlisting">http://&lt;<em class="replaceable"><code>host</code></em>&gt;/&lt;<em class="replaceable"><code>url-path</code></em>&gt;</pre></div><div class="sect2" title="Resource Paths and Directory Listings"><div class="titlepage"><div><div><h2 class="title"><a id="resource_paths_and_directory_listings"/>Resource Paths and Directory Listings</h2></div></div></div><p>The <code class="literal">&lt;url-path&gt;</code> used to reference a particular document can also be omitted. This provides a convenient way for a user to see what content is offered on a website without needing to know what particular document to request. For example, a user who wants to see the current headlines on CNN would go to <a class="ulink" href="http://www.cnn.com">http://www.cnn.com</a>. In this case, the request is sent to the web server for the null document (represented by /, which is implied if it is not specified; technically, you are supposed to specify <a class="ulink" href="http://www.cnn.com/">http://www.cnn.com/</a>).</p><p>How a / request is handled depends on the server. Technically, such a request is actually asking the server, "Please show me the contents of the root directory of the server." However, this is both ugly (a listing of filenames is not the best way to make a first impression) and a potential security issue (as anyone can see the name of every file on the server). Instead, most HTTP servers are set up to recognize such requests automatically and return a default document, often named something like index.html or default.html. Many servers will similarly return a default document of some sort if any other directory is specified in a URL; for example, typing <a class="ulink" href="http://www.pcguide.com/ref">http://www.pcguide.com/ref</a> in the URL address bar of a web browser actually returns <a class="ulink" href="http://www.pcguide.com/ref/index.htm">http://www.pcguide.com/ref/index.htm</a>.</p><div class="note" title="Note"><h3 class="title"><a id="note-172"/>Note</h3><p><span class="emphasis"><em>While it is technically incorrect to leave the http:// off an HTTP URL, most web browsers will add it automatically if it's omitted. As a result, many Web users are in the habit of entering URLs that are simply a host name, such as <a class="ulink" href="http://www.tcpipguide.com">www.tcpipguide.com</a></em></span>.</p></div><p>The forms shown here apply to absolute HTTP URLs. URLs may also be relative, which is the norm for links between closely related documents, such as graphics that go with a document, or between documents in a set or project. In this case, usually only a fractional portion of a URL path is specified. This is described fully in <a class="xref" href="ch70.html" title="Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING: UNIFORM RESOURCE IDENTIFIERS, LOCATORS, AND NAMES (URIS, URLS, AND URNS)">Chapter 70</a>.</p></div></div>
<div class="chapter" title="Chapter&#xA0;80.&#xA0;HTTP GENERAL OPERATION AND CONNECTIONS"><div class="titlepage"><div><div><h1 class="title"><a id="http_general_operation_and_connections"/>Chapter 80. HTTP GENERAL OPERATION AND CONNECTIONS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e88033"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The Hypertext Transfer Protocol (HTTP) began as an extremely basic protocol, designed to do just one thing: allow a client to send a simple request for a hypertext file and receive it back from the server. Modern HTTP remains at its heart a straightforward request/reply protocol, but now includes many new features and capabilities to support the growing size of the World Wide Web (the Web) and the ever-increasing variety of ways that people have found to use the Web. Therefore, the best place to start explaining HTTP is by looking at its <a class="indexterm" id="idx-CHP-80-2872"/>operation as a whole and how communication takes place between a web server and a web client.</p><p>In this chapter, I introduce HTTP by describing its operation in general terms. I start with an overview of HTTP, discussing its versions and the standards that define them. I then discuss its operational model, which is important to understanding how HTTP works. I explain the two types of <a class="indexterm" id="idx-CHP-80-2873"/>connections that are supported between HTTP clients and servers, and the method by which requests can be pipelined in the current version of HTTP, HTTP/1.1. I then provide more information about how persistent connections are established, managed, and terminated in HTTP/1.1.</p><div class="sect1" title="HTTP Versions and Standards"><div class="titlepage"><div><div><h1 class="title"><a id="http_versions_and_standards"/>HTTP Versions and Standards</h1></div></div></div><p>The World Wide Web had humble beginnings as a research project at the Swiss research institute, CERN, the European Organization for Nuclear Research. The primary goal of the project was to allow hypertext documents to be electronically linked, so selecting a reference in one document to a second document would cause the reference document to be retrieved. To implement this system, the researchers needed some sort of mechanism to allow a client computer to tell a server to send it a document. To fill this function, the early developers of the Web created a new TCP/IP application layer protocol: the <span class="emphasis"><em>Hypertext Transfer Protocol (HTTP)</em></span>.<a class="indexterm" id="idx-CHP-80-2874"/></p><p>This first version is now known as HTTP/0.9. Subsequent versions are HTTP/1.0 and HTTP/1.1.</p><div class="sect2" title="HTTP/0.9"><div class="titlepage"><div><div><h2 class="title"><a id="http09"/>HTTP/0.9</h2></div></div></div><p>The original version of HTTP was intended only for the transfer of hypertext documents, and it was designed to be very simple to make implementation of the fledgling Web easier. This early HTTP specifies that an HTTP client establishes a connection to an HTTP server using the Transmission Control Protocol (TCP). The client then issues a single GET request specifying a resource to be retrieved. The server responds by sending the file as a stream of text bytes, and the connection is terminated. The entire document defining this version of HTTP is only a couple of pages long!</p><p>This first version of HTTP was functional but extremely limited in its capabilities. It didn't support the transfer of any types of data other than hypertext, and it didn't provide any mechanism for any sort of intelligent communication between the client and server. This early HTTP prototype was not up to the task of providing the basis for data transfer for the future of the Web. It was never made an official RFC standard, and, in fact, never even had a formal version number; it is known today as HTTP version 0.9, or HTTP/0.9, using the HTTP version format. I believe this number has no particular significance, other than being a bit smaller than the number of the first official version of the protocol.</p></div><div class="sect2" title="HTTP/1.0"><div class="titlepage"><div><div><h2 class="title"><a id="http10"/>HTTP/1.0</h2></div></div></div><p>HTTP/0.9's skeleton of functionality formed the basis for a rapid evolution of HTTP in the early 1990s. As the Web grew in size and acceptance, many new ideas and features were incorporated into HTTP. The result of a great deal of development effort was the formalization of the first HTTP standard: version 1.0. The standard for this much enhanced HTTP was published in May 1996 as RFC 1945, "Hypertext Transfer Protocol—HTTP/1.0." It had been in use for several years prior to that formal publication date, however.</p><p>HTTP/1.0 transformed HTTP from a trivial request/response application to a true messaging protocol. It described a complete message format for HTTP, and explained how it should be used for client requests and server responses. One of the most important changes in HTTP/1.0 was the generalization of the protocol to handle many types of different media, as opposed to strictly hypertext documents. To broaden HTTP's scope, its developers borrowed concepts and header constructs from the Multipurpose Internet Mail Extensions (MIME) standard defined for email (discussed in <a class="xref" href="ch76.html" title="Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME">Chapter 76</a>). At the same time that it defined much more capable web servers and web clients, HTTP/1.0 retained backward-compatibility with servers and clients still using HTTP/0.9.</p><p>HTTP/1.0 was the version of HTTP that was widely implemented in the mid-1990s as the Web exploded in popularity. After only a couple of years, HTTP accounted for the majority of the traffic on the burgeoning Internet. The popularity of HTTP was so great that it single-handedly prompted the installation of a lot of new hardware to handle the load of browser requests and web server replies.</p><p>Unfortunately, much of this huge load of traffic was due to some limitations in HTTP itself. These only became apparent due to the tremendous growth in the use of the protocol, which, combined with the normal growing pains of the Internet, led to many frustrated Web users. The inefficiencies of HTTP/1.0 were a result of design limitations, such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The need for each site to be hosted on a different server.</p></li><li class="listitem"><p>The fact that each HTTP session handled only one client request.</p></li><li class="listitem"><p>A general lack of support for necessary performance-enhancing features such as caching, proxying, and partial resource retrieval.</p></li></ul></div></div><div class="sect2" title="HTTP/1.1"><div class="titlepage"><div><div><h2 class="title"><a id="http11"/>HTTP/1.1</h2></div></div></div><p>While impatient pundits coined sarcastic terms such as the "World Wide Wait," the Internet Engineering Task Force (IETF) continued to work to improve HTTP. In January 1997, the first draft version of HTTP/1.1 appeared, in RFC 2068. This document was later revised and published as RFC 2616, "Hypertext Transfer Protocol—HTTP/1.1," in June 1999. HTTP/1.1 retains backward-compatibility with both HTTP/1.0 and HTTP/0.9. It is accompanied by RFC 2617, "HTTP Authentication: Basic and Digest Access Authentication," which deals with security and authentication issues.</p><p>HTTP/1.1 introduces several significant improvements over version 1.0 of the protocol, most of which specifically address the performance problems I just described. Some of the more important improvements in HTTP1/1 include the following:</p><p><span class="strong"><strong>Multiple Host Name Support</strong></span> In HTTP/1.0, there was no way to specify the host name of the server to which the client needed to connect. As a result, the web server at a particular IP address could support only one domain name. This was not only inefficient, but it also was exacerbating the depletion of IP addresses in the 1990s, because each new web server to come online required a new IP address. HTTP/1.1 allows one web server to handle requests for dozens or even hundreds of different virtual hosts.</p><p><span class="strong"><strong>Persistent Connections</strong></span> HTTP/1.1 allows a client to send multiple requests for related documents to a server in a single TCP session. This greatly improves performance over HTTP/1.0, where each request required a new connection to the server.</p><p><span class="strong"><strong>Partial Resource Selection</strong></span> In HTTP/1.1, a client can ask for only part of a resource, rather than needing the get the entire document, which reduces the load on the server and saves transfer bandwidth.</p><p><span class="strong"><strong>Better Caching and Proxying Support</strong></span> HTTP/1.1 includes many provisions to make caching and proxying more efficient and effective than they were in HTTP/1.0. These techniques can improve performance by providing clients with faster replies to their requests while reducing the load on servers, as well as enhancing security and implementing other functionality.</p><p><span class="strong"><strong>Content Negotiation</strong></span> HTTP/1.1 has an additional negotiation feature that allows the client and server to exchange information to help select the best resource or version of a resource when multiple variants are available.</p><p><span class="strong"><strong>Better Security</strong></span> HTTP/1.1 defines authentication methods and is generally more security-aware than HTTP/1.0 was.</p><p>In addition to these notable improvements, many other minor enhancements were made in HTTP/1.1. Several of these take the form of new headers that can be included in client requests to better control under what circumstances resources are retrieved from the server, and headers in server responses to provide additional information to the client.</p></div><div class="sect2" title="Future HTTP Versions"><div class="titlepage"><div><div><h2 class="title"><a id="future_http_versions"/>Future HTTP Versions</h2></div></div></div><p>HTTP/1.1 continues to be the current version of HTTP, even though it is now several years old. This may seem somewhat surprising, given how widely used HTTP is. Then again, it may because so many millions of servers and clients implement HTTP/1.1 that no new version has been created. For a while, there was speculation that version 1.2 of HTTP would be developed, but this has not happened yet.</p><p>In the late 1990s, work began on a method of expanding HTTP through extensions to the existing version 1.1. Development of the <span class="emphasis"><em>HTTP Extension Framework</em></span> proceeded for a number of years, and in 1998, a proposed draft for a new Internet standard was created. However, HTTP/1.1 is so widely deployed and so important that it was very difficult to achieve consensus on any proposal to modify it. As a result, when the HTTP Extension Framework was finally published in February 2000 as RFC 2774, the universal acceptance required for a new standard did not exist. The framework was given experimental status and never became a formal standard.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-481"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The engine of the World Wide Web (the Web) is the application protocol that defines how web servers and clients exchange information: the <span class="emphasis"><em>Hypertext Transfer Protocol (HTTP)</em></span>. The first version of HTTP, HTTP/0.9, was part of the early Web and was a very simple request/response protocol with limited capabilities that could transfer only text files. The first widely used version was HTTP/1.0, which is a more complete protocol that allows the transport of many types of files and resources. The current version is HTTP/1.1, which expands HTTP/1.0's capabilities with several features that improve the efficiency of transfers and address many of the needs of the rapidly growing modern Web.</p></div></div></div></div>
<div class="sect1" title="HTTP Operational Model and Client/Server Communication"><div class="titlepage"><div><div><h1 class="title"><a id="http_operational_model_and_clientserver_"/>HTTP Operational Model and Client/Server Communication</h1></div></div></div><p>While the Web itself has many different facets, HTTP is concerned with only one basic function: the transfer of hypertext documents and other files from web servers to web clients. In terms of actual communication, clients are chiefly concerned with making requests to servers, which respond to those requests.<a class="indexterm" id="idx-CHP-80-2875"/></p><p>Thus, even though HTTP includes a lot of functionality to meet the needs of clients and servers, when you boil it down, you get a very simple, client/server, request/response protocol. In this respect, HTTP more closely resembles a rudimentary protocol like the Boot Protocol (BOOTP) or the Address Resolution Protocol (ARP) than it does other application layer protocols like the File Transfer Protocol (FTP) and the Simple Mail Transfer Protocol (SMTP), which involve multiple communication steps and command/reply sequences.</p><div class="sect2" title="Basic HTTP Client/Server Communication"><div class="titlepage"><div><div><h2 class="title"><a id="basic_http_clientserver_communication"/>Basic HTTP Client/Server Communication</h2></div></div></div><p>In its simplest form, the operation of HTTP involves only an HTTP client, usually a <span class="emphasis"><em>web browser</em></span> on a client machine, and an HTTP server, more commonly known as a <span class="emphasis"><em>web server</em></span>. After a TCP connection is created, the two steps in communication are as follows (see <a class="xref" href="ch80s02.html#http_clientserver_communication_in_its_s" title="Figure 80-1. HTTP client/server communication In its simplest form, HTTP communication consists of an HTTP Request message sent by a client to a server, which replies with an HTTP Response message.">Figure 80-1</a>):</p><p><span class="strong"><strong>Client Request</strong></span> The HTTP client sends a request message formatted according to the rules of the HTTP standard—an <span class="emphasis"><em>HTTP Request</em></span>. This message specifies the resource that the client wishes to retrieve or includes information to be provided to the server.</p><p><span class="strong"><strong>Server Response</strong></span> The server reads and interprets the request. It takes action relevant to the request and creates an <span class="emphasis"><em>HTTP Response</em></span> message, which it sends back to the client. The response message indicates whether the request was successful, and it may also contain the content of the resource that the client requested, if appropriate.</p><div class="figure"><a id="http_clientserver_communication_in_its_s"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e88185"/><img alt="HTTP client/server communication In its simplest form, HTTP communication consists of an HTTP Request message sent by a client to a server, which replies with an HTTP Response message." src="httpatomoreillycomsourcenostarchimages288307.png.jpg"/></div></div><p class="title">Figure 80-1. HTTP client/server communication In its simplest form, HTTP communication consists of an HTTP Request message sent by a client to a server, which replies with an HTTP Response message.</p></div><p>In HTTP/1.0, each TCP connection involves only one such exchange, as shown in <a class="xref" href="ch80s02.html#http_clientserver_communication_in_its_s" title="Figure 80-1. HTTP client/server communication In its simplest form, HTTP communication consists of an HTTP Request message sent by a client to a server, which replies with an HTTP Response message.">Figure 80-1</a>. In HTTP/1.1, multiple exchanges are possible, as you'll see soon. Note also that, in some cases, the server may respond with one or preliminary responses prior to sending the full response. This may occur if the server sends a preliminary response using the 100 Continue status code prior to the actual reply. See the description of HTTP status codes in <a class="xref" href="ch81.html" title="Chapter 81. HTTP MESSAGES, METHODS, AND STATUS CODES">Chapter 81</a> for more information.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-482"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> HTTP is a <a class="indexterm" id="idx-CHP-80-2876"/>client/server-oriented, request/reply protocol. Basic communication consists of an <span class="emphasis"><em>HTTP Request</em></span> message sent by an HTTP client to an HTTP server, which returns an <span class="emphasis"><em>HTTP Response</em></span> message back to the client.</p></div></div><div class="sect2" title="Intermediaries and the HTTP Request/Response Chain"><div class="titlepage"><div><div><h2 class="title"><a id="intermediaries_and_the_http_requestrespo"/>Intermediaries and the HTTP Request/Response Chain</h2></div></div></div><p>The simple request/response pair between a client and server becomes more complex when <span class="emphasis"><em>intermediaries</em></span> are placed in the virtual communication path between the client and server. These are devices such as <span class="emphasis"><em>proxies, gateways</em></span>, or <span class="emphasis"><em>tunnels</em></span> that are used to improve performance, provide security, or perform other necessary functions for particular clients or servers. Proxies are particularly commonly used on the Web, because they can greatly improve response time for groups of related client computers.<a class="indexterm" id="idx-CHP-80-2877"/><a class="indexterm" id="idx-CHP-80-2878"/><a class="indexterm" id="idx-CHP-80-2879"/></p><p>When an intermediary is involved in HTTP communication, it acts as a middleman. Rather than the client speaking directly to the server and vice versa, each talks to the intermediary. This allows the intermediary to perform functions such as caching, translation, aggregation, and encapsulation. For example, consider an exchange through a single intermediary device. The two-step communication process described in the preceding section would become four steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Client Request</strong></span> The HTTP client sends a request message to the intermediary device.</p></li><li class="listitem"><p><span class="strong"><strong>Intermediary Request</strong></span> The intermediary processes the request, making changes to it if necessary. It then forwards the request to the server.</p></li><li class="listitem"><p><span class="strong"><strong>Server Response</strong></span> The server reads and interprets the request, takes appropriate action, and then sends a response. Since it received its request from the intermediary, its reply goes back to the intermediary.</p></li><li class="listitem"><p><span class="strong"><strong>Intermediary Response</strong></span> The intermediary processes the request, again possibly making changes, and then forwards it back to the client.</p></li></ol></div><p>As you can see, the intermediary acts as if it were a server from the client's perspective and as a client from the server's viewpoint. Many <a class="indexterm" id="idx-CHP-80-2880"/>intermediaries are designed to be able to intercept a variety of TCP/IP protocols, by posing as the server to a client and the client to a server. Most protocols are unaware of the existence of intermediaries. HTTP, however, includes special support for certain intermediaries such as proxy servers, providing headers that control how intermediaries handle HTTP requests and replies. (Proxy servers are discussed in <a class="xref" href="ch84.html" title="Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES">Chapter 84</a>.)</p><p>It is possible for two or more intermediaries to be linked together between the client and server. For example, the client might send a request to intermediary 1, which then forwards to intermediary 2, which then talks to the server, as illustrated in <a class="xref" href="ch80s02.html#http_requestresponse_chain_using_interme" title="Figure 80-2. HTTP request/response chain using intermediaries Instead of being connected directly, an HTTP client and server may be linked using one or more intermediary devices such as proxies. In this example, two intermediaries are present. The HTTP Request message sent by the client will actually be transferred three times: from the client to the first intermediary, then to the second, and finally to the server. The HTTP Response message will be created once but transmitted three distinct times. The full set of devices participating in the message exchange is called the request/response chain.">Figure 80-2</a>. The process is reversed for the reply. The HTTP standard uses the phrase <span class="emphasis"><em>request/response chain</em></span> to refer collectively to the entire set of devices involved in an HTTP message exchange.<a class="indexterm" id="idx-CHP-80-2881"/></p><div class="figure"><a id="http_requestresponse_chain_using_interme"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e88280"/><img alt="HTTP request/response chain using intermediaries Instead of being connected directly, an HTTP client and server may be linked using one or more intermediary devices such as proxies. In this example, two intermediaries are present. The HTTP Request message sent by the client will actually be transferred three times: from the client to the first intermediary, then to the second, and finally to the server. The HTTP Response message will be created once but transmitted three distinct times. The full set of devices participating in the message exchange is called the request/response chain." src="httpatomoreillycomsourcenostarchimages288309.png.jpg"/></div></div><p class="title">Figure 80-2. HTTP request/response chain using intermediaries Instead of being connected directly, an HTTP client and server may be linked using one or more intermediary devices such as proxies. In this example, two intermediaries are present. The HTTP Request message sent by the client will actually be transferred three times: from the client to the first intermediary, then to the second, and finally to the server. The HTTP Response message will be created once but transmitted three distinct times. The full set of devices participating in the message exchange is called the request/response chain.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-483"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The simple client/server operational model of HTTP becomes more complicated when <span class="emphasis"><em>intermediary devices</em></span> such as proxies, tunnels, or gateways are inserted in the communication path between the HTTP client and server. HTTP/1.1 is specifically designed with features to support the efficient conveyance of requests and responses through a series of steps from the client through the intermediaries to the server, and back again. The entire set of devices involved in such a communication is called the <span class="emphasis"><em>request/response</em></span> chain.</p></div></div><div class="sect2" title="The Impact of Caching on HTTP Communication"><div class="titlepage"><div><div><h2 class="title"><a id="the_impact_of_caching_on_http_communicat"/>The Impact of Caching on HTTP Communication</h2></div></div></div><p>The normal HTTP communication model is changed through the application of <span class="emphasis"><em>caching</em></span> to client requests. Various devices on the Web employ caching to store recently retrieved resources so they can be quickly supplied in reply to a request. The client itself will cache recently accessed web documents, so that if the user asks for them again, they can be displayed without even making a request to a server. If a request is required, any intermediary device can satisfy a request for a file if the file is in its cache.<a class="indexterm" id="idx-CHP-80-2882"/></p><p>When a cache is used, the device that has the cached resource requested returns it directly, circumventing the normal HTTP communication process. In the example shown in <a class="xref" href="ch80s02.html#http_requestresponse_chain_using_interme" title="Figure 80-2. HTTP request/response chain using intermediaries Instead of being connected directly, an HTTP client and server may be linked using one or more intermediary devices such as proxies. In this example, two intermediaries are present. The HTTP Request message sent by the client will actually be transferred three times: from the client to the first intermediary, then to the second, and finally to the server. The HTTP Response message will be created once but transmitted three distinct times. The full set of devices participating in the message exchange is called the request/response chain.">Figure 80-2</a>, if intermediary 1 has the file the client needs, it will supply it to the client directly, and intermediary 2 and the web server that the client was trying to reach originally will not even be aware that a request was ever made. <a class="xref" href="ch84.html" title="Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES">Chapter 84</a> provides details on HTTP caching.</p><div class="note" title="Note"><h3 class="title"><a id="note-173"/>Note</h3><p><span class="emphasis"><em>Most requests for web resources are made using HTTP URLs based on a Domain Name System (DNS) host name. The first step in satisfying such requests is to resolve the DNS domain name into an IP address, but this process is separate from the HTTP communication itself.</em></span></p></div></div></div>
<div class="sect1" title="HTTP Transitory and Persistent Connections and Pipelining"><div class="titlepage"><div><div><h1 class="title"><a id="http_transitory_and_persistent_connectio"/>HTTP Transitory and Persistent Connections and Pipelining</h1></div></div></div><p>You just learned that the basic HTTP communication process is a simple two-step procedure: A client sends a request to a server, and the server replies back to the client. Since this was all that HTTP was intended to do, the first version of the protocol was designed so that after a TCP connection was established between the client and server, a single request/response exchange was performed. After the request was satisfied, the TCP connection was terminated. These <span class="emphasis"><em>transitory</em></span> connections were the only type supported by the original HTTP/0.9, and the same model was maintained in the more widely deployed HTTP/1.0.</p><p>The advantage of this connection model is its conceptual simplicity. The problem with it is that it is inefficient when the client needs to make many requests to the same server. This is often the case with modern hypertext documents, which usually carry inline references to images and other media. A typical client request for the home page of a website begins with a single request for a Hypertext Markup Language (HTML) file, but then leads to subsequent requests for each of the other related files that go with that document.</p><p>With <a class="indexterm" id="idx-CHP-80-2883"/>transitory connections, each of these requests made by the client requires a new, distinct TCP connection to be set up between the client and server. Every connection takes server resources and network bandwidth, so needing to establish a new one for each file is woefully inefficient. Suppose that you were having a conversation with someone whom you needed to ask a series of questions. Now imagine that after answering each question, the other person hung up the phone, and you had to call her again! You get the picture.</p><p>There are some people who consider the temporary nature of HTTP/0.9 and HTTP/1.0 connections to be a design flaw of these early versions of HTTP, but I don't think that this is fair. In the early days, this model of operation was really not a big issue; it became problematic only when the use of the Web and hypertext evolved. For the first few years of its existence, hypertext was primarily that: <span class="emphasis"><em>text</em></span>. Having an HTTP session last just long enough for one request/response was generally sufficient, since the whole resource was in one file. It was only in the 1990s that hypertext became <span class="emphasis"><em>hypermedia</em></span>, with a heavy emphasis on embedded graphics and other files. When web pages changed from simple text to multimedia marvels sporting dozens or even hundreds of embedded images, the limitations of HTTP/1.0 became obvious.<a class="indexterm" id="idx-CHP-80-2884"/></p><p>The solution to the problem came in HTTP/1.1, which allows an HTTP client and server to set up a <span class="emphasis"><em>persistent connection</em></span>.</p><div class="sect2" title="Persistent Connections"><div class="titlepage"><div><div><h2 class="title"><a id="persistent_connections"/>Persistent Connections</h2></div></div></div><p>With <a class="indexterm" id="idx-CHP-80-2885"/>persistent connections, the basic operation of HTTP is not changed. The main difference is that, by default, the TCP connection is kept open after each request/response set, so that the next request and response can be exchanged immediately. The session is closed only when the client is finished requesting all the documents it needs.</p><p>Keeping the TCP connection between an HTTP client and server alive between requests is probably the single most important way that HTTP/1.1 improves performance over HTTP/1.0. Clients are able to get their files more quickly because they don't need to wait for a TCP connection before each resource is retrieved. Server load is reduced, and memory use in busy servers is conserved. Network congestion is reduced through the elimination of unnecessary TCP handshaking segments.</p></div><div class="sect2" title="Pipelining"><div class="titlepage"><div><div><h2 class="title"><a id="pipelining"/>Pipelining</h2></div></div></div><p><a class="indexterm" id="idx-CHP-80-2886"/>Persistent connections offer another important performance-enhancing option to HTTP clients: the ability to <span class="emphasis"><em>pipeline</em></span> requests. Suppose the client needs to send a request for Files A, B, and C to a server. Since the requests for all of these files will be sent in the same TCP session, there is no need for the client to wait for a response to its request for File A before sending the request for File B. The client can send requests in a rapid-fire fashion, one after the other. This also improves the efficiency of the server, which will be able to fill the requests in the order in which they are received, as soon as it is able, without needing to pause to wait for each new request to be sent.<a class="indexterm" id="idx-CHP-80-2887"/></p><div class="tip" title="Tip"><h3 class="title"><a id="tip-484"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> HTTP/0.9 and HTTP/1.0 supported only <span class="emphasis"><em>transitory connections</em></span> between an HTTP client and server, where just a single request and response could be exchanged on a TCP connection. This is very inefficient for the modern Web, where clients frequently need to make dozens of requests to a server. By default, HTTP/1.1 operates using <span class="emphasis"><em>persistent connections</em></span>. This means that once a TCP connection is established, the client can send many requests to the server and receive replies to each in turn. This allows files to be retrieved more quickly, and conserves server resources and Internet bandwidth. The client can even <span class="emphasis"><em>pipeline</em></span> its requests, sending the second request immediately, without needing to wait for a reply to the first request. HTTP/1.1 still supports transitory connections for backward-compatibility, when needed.</p></div><p>The obvious advantages of persistent connections make them the default for modern HTTP communication, but they do have one drawback: They complicate the process of sending data from the server to the client. With transitory connections, the client knows that all of the data it receives back from the server is in reply to the one request it sent. Once it has all the bytes the server sent and the TCP session ends, the client knows the file is complete.</p><p>With persistent connections, and especially when <a class="indexterm" id="idx-CHP-80-2888"/>pipelining is used, the server will typically be sending one file after the other to the client, which must differentiate them. Remember that TCP sends data as just a series of unstructured bytes; the application must take care of specifying where the dividing points are between files. This means that persistent connections and pipelining lead to data length issues that must be specially addressed in HTTP.</p><p>To provide compatibility with older versions of the software, HTTP/1.1 servers still support transitory connections, and they will automatically close the TCP connection after one response if they receive an HTTP/0.9 or HTTP/1.0 request. HTTP/1.1 clients may also specify in their initial request that they do not want to use persistent connections.</p></div><div class="sect2" title="HTTP Persistent Connection Establishment and Management"><div class="titlepage"><div><div><h2 class="title"><a id="http_persistent_connection_establishment"/>HTTP Persistent Connection Establishment and Management</h2></div></div></div><p>As with most TCP/IP client/server protocols, in establishing a persistent connection, the HTTP server plays the passive role by listening for requests on a particular port number. The default port number for HTTP is well-known TCP port number 80, and is used by web browsers for most HTTP requests, unless a different port number is specified in the Uniform Resource Locator (URL). The client initiates an HTTP connection by opening a TCP connection from itself to the server it wishes to contact.</p><div class="note" title="Note"><h3 class="title"><a id="note-174"/>Note</h3><p><span class="emphasis"><em>A DNS name resolution step may precede the entire HTTP connection, since most URLs contain a host name, while HTTP requires that the client know the server's IP address. This can lead to confusion, because DNS uses the User Datagram Protocol (UDP), but HTTP uses TCP. This causes some people to think that HTTP uses UDP.</em></span></p></div><p>Once the TCP connection is active, the client sends its first request message. The request specifies which version of HTTP the client is using. If this is HTTP/0.9 or HTTP/1.0, the server will automatically work in the transitory connection model, and it will send only one reply and then close the link. If it is HTTP/1.1, the assumption is that a persistent connection is desired. An HTTP/1.1 client can override this by including the special Connection: Close header in its initial request, which tells the server it does not want to keep the session active after the request it is sending has been fulfilled.</p><p>Assuming that a persistent connection is being used, the client may begin pipelining subsequent requests after sending its first request, while waiting for a response from the server to the initial query. As the server starts to respond to requests, the client processes them and takes action, such as displaying the data retrieved to the user. The data received from the server may also prompt the client to request more files on the same connection, as in the case of an HTML document that contains references to images.</p><p>The server will generally buffer a certain number of pipelined requests from the client. In the case where the client sends too many requests too quickly, the server may throttle back the client using the flow-control mechanism built into TCP. In theory, the server could also just decided to terminate the connection with the client, but it is better for it to use TCP's existing features. Closing the connection will cause the client to initiate a new connection, potentially exacerbating any overloading problem.</p><p>The flow of requests and responses continues for as long as the client has requests. The connection can be gracefully terminated by the client by including the Connection: Close header in the last request it needs to send to the server. All requests are filled in order, so the server will satisfy all outstanding requests, and then close the session.</p><p>Since HTTP/1.1 supports pipelining of requests, there is usually no need for a client to establish more than one simultaneous connection to the same server. Clients occasionally do this anyway to allow them to get information from a server more quickly. This is considered by many to be "antisocial," because it can lead to a busy server's resources being monopolized by one client to the exclusion of others that want to access it.</p><p>Under special circumstances, either the client or the server may unexpectedly close an active persistent connection. For example, if the client detects that too much time has elapsed since the server last replied, it may conclude that the server has crashed and terminate the connection. Similarly, the server might receive a shutdown command from its administrator or for other reasons end a session with a client abruptly. Servers normally avoid closing down a link during the middle of sending a response.</p><p>Both clients and servers must be able to handle abrupt session termination. For servers, there is not much to do; if the client terminates the connection, the server simply cleans up any resources associated with the connection, and then goes on to service the next client.</p><p>Clients have more to do when a server prematurely terminates a session, and this is especially the case when requests are pipelined. The client must keep track of all requests sent to the server to ensure that each is filled. If the server closes the session unexpectedly, the client will usually attempt to establish a new connection to retransmit the unfilled requests. Since an abrupt session termination is often a sign of a busy server, the HTTP standard specifies that clients use a binary exponential back-off algorithm to wait a variable but increasing amount of time before resubmitting requests for files (similar in concept to the method used to deal with collisions in Ethernet). This helps prevent clients from piling on requests to a device that is already overwhelmed.</p></div></div>
<div class="chapter" title="Chapter&#xA0;81.&#xA0;HTTP MESSAGES, METHODS, AND STATUS CODES"><div class="titlepage"><div><div><h1 class="title"><a id="http_messages_methods_and_status_codes"/>Chapter 81. HTTP MESSAGES, METHODS, AND STATUS CODES</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e88432"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> As you saw in the previous chapter, the Hypertext Transfer Protocol (HTTP) is entirely oriented around the sending of client requests and server responses. These take the form of <span class="emphasis"><em>HTTP messages</em></span> sent between clients and servers. As with all protocols, HTTP uses a special format that dictates the structure of both client Request messages and server Response messages. Understanding how these messages work is a big part of comprehending HTTP as a whole.</p><p>In this chapter, I describe the messages used by HTTP and the specific commands and responses issued by clients and servers. I begin with a look at the generic HTTP message format and the major components of every HTTP message. I then discuss the specific formats used for both Request and Response messages. I explain the different types of HTTP methods (commands) used in client requests and the HTTP status codes used in server replies.</p><div class="note" title="Note"><h3 class="title"><a id="note-175"/>Note</h3><p><span class="emphasis"><em>Much of the functionality of HTTP is implemented using header fields that appear at the start of each HTTP Request and Response message. Headers are covered in detail in the next chapter</em></span>.</p></div><div class="sect1" title="HTTP Generic Message Format"><div class="titlepage"><div><div><h1 class="title"><a id="http_generic_message_format"/>HTTP Generic Message Format</h1></div></div></div><p><a class="indexterm" id="idx-CHP-81-2889"/>As you learned in the previous chapter, all of the communication between devices using HTTP takes place via HTTP messages, of which there are only two types: <span class="emphasis"><em>Request</em></span> and <span class="emphasis"><em>Response messages</em></span>. Clients usually send requests and receive responses, while servers receive requests and send responses. Intermediate devices such as gateways or proxies may send and receive both types of messages.</p><p>All HTTP messages are created to fit a message structure that the standard calls the <span class="emphasis"><em>generic message format</em></span>. Like most of the other TCP/IP messaging protocols, HTTP does not use a binary message format; rather, the messages are text-based. HTTP messages are based loosely on the electronic mail (email) RFC 822 and 2822 message standards, as well as the Multipurpose Internet Mail Extensions (MIME) standard (described in <a class="xref" href="ch76.html" title="Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME">Chapter 76</a>). I say "loosely" because HTTP messages are similar in construction to email messages but do not strictly follow all of the email or MIME format requirements. One difference is that not all of the RFC 822 and MIME headers are used; there are other differences as well, which we will soon examine.</p><p>The HTTP generic message format is as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>&lt;<span class="emphasis"><em>start-line</em></span>&gt;</td></tr><tr><td>&lt;<span class="emphasis"><em>message-headers</em></span>&gt;</td></tr><tr><td>&lt;<span class="emphasis"><em>empty-line</em></span>&gt;</td></tr><tr><td>[&lt;<span class="emphasis"><em>message-body</em></span>&gt;]</td></tr><tr><td>[&lt;<span class="emphasis"><em>message-trailers</em></span>&gt;]</td></tr></table><p>You can see that this is pretty much the same as the format used for email messages: headers, an empty line, and then a message body. All text lines are terminated with the standard carriage return-line feed (CRLF) control character sequence. The empty line contains just those two characters and nothing else. The headers are always sent as regular text. The body, however, may be either text or 8-bit binary information, depending on the nature of the data to be sent. (This is another way that HTTP does not adhere strictly to the RFC 822 standard; see the discussion of entities and media types in <a class="xref" href="ch83.html" title="Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management">Chapter 83</a> for a full discussion.)</p><p>The generic message format has the following components:</p><p><span class="strong"><strong>Start Line</strong></span> The <span class="emphasis"><em>start line</em></span> is a special text line that conveys the nature of the message. In a request, this line indicates the nature of the request, in the form of a <span class="emphasis"><em>method</em></span>, as well as specifying a Uniform Resource Identifier (URI) to indicate the resource that is the object of the request. Responses use the start line to indicate status information in reply to a request. You can find more details on the use of the start line in the following sections in this chapter that detail HTTP Request messages and Response messages.</p><p><span class="strong"><strong>Message Headers</strong></span> Many dozens of message headers are defined in <a class="indexterm" id="idx-CHP-81-2890"/>HTTP. These headers are organized into groups by function, as described in the following sections in this chapter. Almost all of these headers are optional; the one exception is the Host header, which must be present in each request in HTTP/1.1. Headers may be sent in any order, and they all follow the same header <a class="indexterm" id="idx-CHP-81-2891"/>format used in email messages: &lt;<span class="emphasis"><em>header-name</em></span>&gt;: &lt;<span class="emphasis"><em>header-value</em></span>&gt;.</p><p><span class="strong"><strong>Message Body</strong></span> The message body is optional, because it is needed only for certain types of messages. The body may carry a set of information to be communicated between the client and server, such as a detailed error message in a response. More commonly, it carries a file or other resource, which is formally called an <span class="emphasis"><em>entity</em></span> in the HTTP standard. Entities are most often found in the body of a Response message, since most client requests ask for a server to send a file or other resource. However, they can also be found in certain Request messages. HTTP supports many kinds of entities, as described in detail in <a class="xref" href="ch83.html" title="Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management">Chapter 83</a>.</p><p><span class="strong"><strong>Message Trailers</strong></span> As described in the previous chapter, HTTP/1.1 uses persistent connections by default, so messages are sent in a steady stream from client to server and server to client. This requires some means to mark where one message ends and the next begins, which is usually accomplished in one of two ways. The first is using a special header that indicates the length of the message, so the receiving device knows when the entire message has been received. The second is a method called <span class="emphasis"><em>chunking</em></span>, where a message is broken into pieces for transmission, and the length of each piece is indicated in the message body. When chunking is done, a set of message <span class="emphasis"><em>trailers</em></span> may follow the body of the message. Trailers are actually the same as headers, except for their position in the file, but they may only be used for entity headers. See <a class="xref" href="ch83.html" title="Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management">Chapter 83</a> for more details on trailers and chunked data.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-485"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> All HTTP messages conform to a structure called the <span class="emphasis"><em>generic message format</em></span>. This format is based on the RFC 822 and MIME electronic mail message standards, although HTTP does not follow those formats precisely. Each HTTP message begins with a start line, then contains a number of message headers, followed by an empty line and optionally a message body. The body of the message may contain a resource such as a file to be communicated between client and server, called an <span class="emphasis"><em>entity</em></span>.</p></div></div></div>
<div class="sect1" title="HTTP Request Message Format"><div class="titlepage"><div><div><h1 class="title"><a id="http_request_message_format"/>HTTP Request Message Format</h1></div></div></div><p>The client initiates an HTTP session by opening a TCP connection to the HTTP server with which it wishes to communicate. It then sends <span class="emphasis"><em>HTTP Request messages</em></span> to the server, each of which specifies a particular type of action that the user of the HTTP client would like the server to take. Requests can be generated either by specific user action (such as clicking a hyperlink in a web browser) or indirectly as a result of a prior action (such as a reference to an inline image in an HTML document leading to a request for that image).</p><p><a class="indexterm" id="idx-CHP-81-2892"/>HTTP Request messages use a <a class="indexterm" id="idx-CHP-81-2893"/>format that is based on the generic message format described in the previous section, but specific to the needs of requests. The structure of this format is as follows (see <a class="xref" href="ch81s02.html#http_request_message_format_this_diagram" title="Figure 81-1. HTTP Request message format This diagram shows the structural elements of an HTTP Request message and an example of the sorts of headers a Request message might contain. Like most HTTP requests, this one carries no entity, so there are no entity headers and the message body is empty. See Figure 81-2 for the HTTP Response message format.">Figure 81-1</a>):</p><table border="0" class="simplelist" summary="Simple list"><tr><td>&lt;<span class="emphasis"><em>request-line</em></span>&gt;</td></tr><tr><td>&lt;<span class="emphasis"><em>general-headers</em></span>&gt;</td></tr><tr><td>&lt;<span class="emphasis"><em>request-headers</em></span>&gt;</td></tr><tr><td>&lt;<span class="emphasis"><em>entity-headers</em></span>&gt;</td></tr><tr><td>&lt;<span class="emphasis"><em>empty-line</em></span>&gt;</td></tr><tr><td>[&lt;<span class="emphasis"><em>message-body</em></span>&gt;]</td></tr><tr><td>[&lt;<span class="emphasis"><em>message-trailers</em></span>&gt;]</td></tr></table><div class="figure"><a id="http_request_message_format_this_diagram"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e88638"/><img alt="HTTP Request message format This diagram shows the structural elements of an HTTP Request message and an example of the sorts of headers a Request message might contain. Like most HTTP requests, this one carries no entity, so there are no entity headers and the message body is empty. See for the HTTP Response message format." src="httpatomoreillycomsourcenostarchimages288311.png.jpg"/></div></div><p class="title">Figure 81-1. HTTP Request message format This diagram shows the structural elements of an HTTP Request message and an example of the sorts of headers a Request message might contain. Like most HTTP requests, this one carries no entity, so there are no entity headers and the message body is empty. See <a class="xref" href="ch81s03.html#http_response_message_format_this_figure" title="Figure 81-2. HTTP Response message format This figure illustrates the construction of an HTTP Response message and includes an example of both message headers and body. The status code 200 indicates that this is a successful response to a request; it contains a brief text HTML entity in the message body. See Figure 81-1 for the HTTP Request message format.">Figure 81-2</a> for the HTTP Response message format.</p></div><div class="sect2" title="Request Line"><div class="titlepage"><div><div><h2 class="title"><a id="request_line"/>Request Line</h2></div></div></div><p><a class="indexterm" id="idx-CHP-81-2894"/>The generic <span class="emphasis"><em>start line</em></span> that begins all HTTP messages is called a <span class="emphasis"><em>request line</em></span> in Request messages. Its has three main purposes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>To indicate the command or action that the client wants performed</p></li><li class="listitem"><p>To specify a resource on which the action should be taken</p></li><li class="listitem"><p>To indicate to the server what version of HTTP the client is using</p></li></ul></div><p>The formal syntax for the request line is as follows:</p><p>&lt;<span class="emphasis"><em>METHOD</em></span> &gt; &lt;<span class="emphasis"><em>request-uri</em></span>&gt; &lt;<span class="emphasis"><em>HTTP-VERSION</em></span>&gt;</p><p>Each of the request line components is discussed in the following sections.</p><div class="sect3" title="Method"><div class="titlepage"><div><div><h3 class="title"><a id="method"/>Method</h3></div></div></div><p>The <span class="emphasis"><em>method</em></span> is simply the type of action that the client wants the server to take; it is always specified in uppercase letters. There are eight standard methods defined in HTTP/1.1, of which three are widely used: <span class="emphasis"><em>GET, HEAD</em></span>, and <span class="emphasis"><em>POST</em></span>. They are called <span class="emphasis"><em>methods</em></span>, rather than <span class="emphasis"><em>commands</em></span>, because the HTTP standard uses terminology from object-oriented programming. I explain this and also describe the methods themselves in the "HTTP Methods" section later in this chapter.</p></div><div class="sect3" title="Request URI"><div class="titlepage"><div><div><h3 class="title"><a id="request_uri"/>Request URI</h3></div></div></div><p><a class="indexterm" id="idx-CHP-81-2895"/>The <span class="emphasis"><em>request URI</em></span> is the URI of the resource to which the request applies. While URIs can theoretically refer to either Uniform Resource Locators (URLs) or Uniform Resource Names (URNs), currently, a URI is almost always an HTTP URL that follows the standard syntax rules of Web URLs, as described in <a class="xref" href="ch70.html" title="Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING: UNIFORM RESOURCE IDENTIFIERS, LOCATORS, AND NAMES (URIS, URLS, AND URNS)">Chapter 70</a>.</p><p>Interestingly, the exact form of the URL used in the HTTP request line usually differs from that used in HTML documents or entered by users. This is because some of the information in a full URL is used to control HTTP itself. It is needed as part of the communication between the user and the HTTP client, but not in the request from the client to the server. The standard method of specifying a resource in a request is to include the path and filename in the request line (as well as any optional query information), while specifying the host in the special Host header that must be used in HTTP/1.1 Request messages.</p><p>For example, suppose the user enters a URL such as <code class="literal">http://www.myfavoritewebsite.com:8080/chatware/chatroom.php</code>. We obviously don't need to send the <code class="literal">http</code>: to the server. The client would take the remaining information and split it so the URI was specified as <code class="literal">/chatware/chatroom.php</code> and the Host line would contain <code class="literal">www.myfavoritewebsite.com:8080</code>. Thus, the start of the request would look like this:</p><a id="I_programlisting3_d1e88739"/><pre class="programlisting">GET /chatware/chatroom.php HTTP/1.1
Host: www.myfavoritewebsite.com:8080</pre><p>The exception to this rule is when a request is being made to a proxy server. In that case, the request is made using the full URL in its original form, so that it can be processed by the proxy just as the original client processed it. The request would look like this:</p><a id="I_programlisting3_d1e88743"/><pre class="programlisting">GET http://www.myfavoritewebsite.com:8080/chatware/chatroom.php HTTP/1.1</pre><p>Finally, there is one special case where a single asterisk can be used instead of a real URL. This is for the OPTIONS method, which does not require the specification of a resource. (Nominally, the asterisk means the method refers to the server itself.)</p></div><div class="sect3" title="HTTP Version"><div class="titlepage"><div><div><h3 class="title"><a id="http_version"/>HTTP Version</h3></div></div></div><p>The <span class="emphasis"><em>HTTP version</em></span> element tells the server which version the client is using, so the server knows how to interpret the request, and what to send and not to send the client in its response. For example, a server receiving a request from a client using HTTP/0.9 or HTTP/1.0 will assume that a transitory connection is being used rather than a persistent one (as explained in the previous section), and the server will avoid using <a class="indexterm" id="idx-CHP-81-2896"/>HTTP/1.1 <a class="indexterm" id="idx-CHP-81-2897"/>headers in its reply. The version token is sent in uppercase letters, as HTTP/0.9, HTTP/1.0, or HTTP/1.1—just the way I've been doing throughout my discussion of the protocol.</p></div></div><div class="sect2" title="Headers"><div class="titlepage"><div><div><h2 class="title"><a id="headers"/>Headers</h2></div></div></div><p>After the request line come any of the headers that the client wants to include in the message. In these headers, details are provided to the server about the request. The headers all use the same structure, but are organized into the following categories based on the functions they serve and whether they are specific to one kind of message:</p><p><span class="strong"><strong>General Headers</strong></span> General headers refer mainly to the message itself, as opposed to its contents, and they are used to control its processing or provide the recipient with extra <a class="indexterm" id="idx-CHP-81-2898"/>information. They are not particular to either Request or Response messages, so they can appear in either. Also, they are not specifically relevant to any entity the message may be carrying.</p><p><span class="strong"><strong>Request Headers</strong></span> These headers convey to the server more details about the nature of the client's request, and they give the client more control over how the request is handled. For example, special request headers can be used by the client to specify a conditional request—one that is filled only if certain criteria are met. Others can tell the server which formats or encodings the client is able to process in a Response message.</p><p><span class="strong"><strong>Entity Headers</strong></span> These are headers that describe the entity contained in the body of the request, if any.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-486"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>HTTP Request messages</em></span> are the means by which HTTP clients ask servers to take a particular type of action, such as sending a file or processing user input. Each Request message begins with a <span class="emphasis"><em>request line</em></span>, which contains three critical pieces of information: the <span class="emphasis"><em>method</em></span> (type of action) the client is requesting, the <span class="emphasis"><em>URI</em></span> of the resource on which the client wishes the action to be performed, and the version of HTTP that the client is using. After the request line comes a set of message headers related to the request, followed by a blank line, and then optionally, the message body of the request.</p></div><p>Request headers are obviously used only in Request messages, but both general headers and entity headers can appear in either a Request or a Response message. Since there are so many headers and most are not particular to one message type, I describe them in detail in the next chapter.</p></div></div>
<div class="sect1" title="HTTP Response Message Format"><div class="titlepage"><div><div><h1 class="title"><a id="http_response_message_format"/>HTTP Response Message Format</h1></div></div></div><p>Each Request message sent by an HTTP client to a server prompts the server to send back a <span class="emphasis"><em>Response message</em></span>. Actually, in certain cases, the server may send two responses: a preliminary response, followed by the real one. Usually though, one request yields one response, which indicates the results of the server's processing of the request, and a response often also carries an entity (file or resource) in the message body.</p><p>Like Request messages, Response messages use their own specific <a class="indexterm" id="idx-CHP-81-2899"/>format that is based on the <a class="indexterm" id="idx-CHP-81-2900"/>HTTP generic message format described earlier in this chapter. The format Response message format header is as follows (see <a class="xref" href="ch81s03.html#http_response_message_format_this_figure" title="Figure 81-2. HTTP Response message format This figure illustrates the construction of an HTTP Response message and includes an example of both message headers and body. The status code 200 indicates that this is a successful response to a request; it contains a brief text HTML entity in the message body. See Figure 81-1 for the HTTP Request message format.">Figure 81-2</a>):</p><table border="0" class="simplelist" summary="Simple list"><tr><td>&lt;<span class="emphasis"><em>status-line</em></span>&gt;</td></tr><tr><td>&lt;<span class="emphasis"><em>general-headers</em></span>&gt;</td></tr><tr><td>&lt;<span class="emphasis"><em>response-headers</em></span>&gt;</td></tr><tr><td>&lt;<span class="emphasis"><em>entity-headers</em></span>&gt;</td></tr><tr><td>&lt;<span class="emphasis"><em>empty-line</em></span>&gt;</td></tr><tr><td>[&lt;<span class="emphasis"><em>message-body</em></span>&gt;]</td></tr><tr><td>[&lt;<span class="emphasis"><em>message-trailers</em></span>&gt;]</td></tr></table><div class="figure"><a id="http_response_message_format_this_figure"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e88880"/><img alt="HTTP Response message format This figure illustrates the construction of an HTTP Response message and includes an example of both message headers and body. The status code 200 indicates that this is a successful response to a request; it contains a brief text HTML entity in the message body. See for the HTTP Request message format." src="httpatomoreillycomsourcenostarchimages288313.png.jpg"/></div></div><p class="title">Figure 81-2. HTTP Response message format This figure illustrates the construction of an HTTP Response message and includes an example of both message headers and body. The status code 200 indicates that this is a successful response to a request; it contains a brief text HTML entity in the message body. See <a class="xref" href="ch81s02.html#http_request_message_format_this_diagram" title="Figure 81-1. HTTP Request message format This diagram shows the structural elements of an HTTP Request message and an example of the sorts of headers a Request message might contain. Like most HTTP requests, this one carries no entity, so there are no entity headers and the message body is empty. See Figure 81-2 for the HTTP Response message format.">Figure 81-1</a> for the HTTP Request message format.</p></div><div class="sect2" title="Status Line"><div class="titlepage"><div><div><h2 class="title"><a id="status_line"/>Status Line</h2></div></div></div><p><a class="indexterm" id="idx-CHP-81-2901"/>The <span class="emphasis"><em>status line</em></span> (note that this is not called the <span class="emphasis"><em>response line</em></span>) is the start line used for Response messages. It has two functions: to tell the client what version of the protocol the server is using and to communicate a summary of the results of processing the client's request. The formal syntax for the status line is as follows:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>&lt;<span class="emphasis"><em>HTTP-VERSION</em></span>&gt; &lt;<span class="emphasis"><em>status-code</em></span>&gt; &lt;<span class="emphasis"><em>reason-phrase</em></span>&gt;</td></tr></table><p>Each of the status line components is discussed in the following sections.</p><div class="sect3" title="HTTP Version"><div class="titlepage"><div><div><h3 class="title"><a id="http_version-id001"/>HTTP Version</h3></div></div></div><p>The <span class="emphasis"><em>HTTP-VERSION</em></span> label in the status line serves the same purpose as it does in the request line of a Request message (described in the previous section). Here, it tells the client the version number that the server is using for its response. It uses the same format as in the request line, with the version in uppercase as HTTP/0.9, HTTP/1.0, or HTTP/1.1. The server is required to return an HTTP version number that is no greater than the number the client sent in its request.</p></div><div class="sect3" title="Status Code and Reason Phrase"><div class="titlepage"><div><div><h3 class="title"><a id="status_code_and_reason_phrase"/>Status Code and Reason Phrase</h3></div></div></div><p>The <span class="emphasis"><em>status code</em></span> and <span class="emphasis"><em>reason phrase</em></span> provide information about the results of processing the client's request in two different forms. The status code is a three-digit number that indicates the formal result that the server is communicating to the client. It is intended for the client HTTP implementation to process so the software can take appropriate action. The reason phrase is an additional, descriptive text string, which can be displayed to the human users of the HTTP client so they can see how the server responded. I describe status codes and reason phrases later in this chapter, and also list all of the standard codes.</p></div></div><div class="sect2" title="Headers"><div class="titlepage"><div><div><h2 class="title"><a id="headers-id001"/>Headers</h2></div></div></div><p><a class="indexterm" id="idx-CHP-81-2902"/>The Response message will always include a number of headers that provide extra information about it. Response message headers fall into three categories:</p><p><span class="strong"><strong>General Headers</strong></span> General headers that refer to the message itself and are not specific to Response messages or the entity in the message body. These are the same as the generic headers that can appear in Request messages (though certain headers appear more often in responses, and others are more common in requests).</p><p><span class="strong"><strong>Response Headers</strong></span> These headers provide additional data that expands on the summary result information in the status line. The server may also return extra result information in the body of the message, especially when an error occurs.</p><p><span class="strong"><strong>Entity Headers</strong></span> These are headers that describe the entity contained in the body of the response, if any. These are the same entity headers that can appear in a Request message, but they are seen more often in response messages.</p><p>Most Response messages contain an entity in the message body. In the case of a successful request to retrieve a resource, this is the resource itself. Responses indicating unsuccessful requests usually contain detailed error information, often in the form of an HTML-formatted error message.</p><div class="note" title="Note"><h3 class="title"><a id="note-176"/>Note</h3><p><span class="emphasis"><em>Entity headers may appear in a Response message to describe the resource that is the subject of the request, even if the entity itself is not sent in the message. This occurs when the HEAD method is used to request only the headers associated with an entity</em></span>.</p></div><p>Response headers are used only in Response messages, while the others are general with respect to message type. See <a class="xref" href="ch82.html" title="Chapter 82. HTTP MESSAGE HEADERS">Chapter 82</a> for more details about HTTP headers.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-487"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Each HTTP Request message sent by a client leads to a server returning one or more <span class="emphasis"><em>HTTP Response messages</em></span>. Each Response message starts with a <span class="emphasis"><em>status line</em></span> that contains the server's HTTP version number, and a numeric <span class="emphasis"><em>status code</em></span> and text <span class="emphasis"><em>reason phrase</em></span> that indicate the result of processing the client's request. The message then contains headers related to the response, followed by a blank line, and then the optional message body. Since most HTTP Request messages ask for a server to return a file or other resource, many HTTP Response messages carry an entity in the message body.</p></div></div></div>
<div class="sect1" title="HTTP Methods"><div class="titlepage"><div><div><h1 class="title"><a id="http_methods"/>HTTP Methods</h1></div></div></div><p><a class="indexterm" id="idx-CHP-81-2903"/>An HTTP Request message sent by a client to a server obviously requests that the server do something. All client/server protocols provide a way for the client to prompt the server to take action, generally by having the client give the server a series of commands. HTTP, in contrast, has <span class="emphasis"><em>methods</em></span>, rather than commands. Each client Request message begins with the specification of the method that is the subject of the request.</p><p>What is the difference between a method and a command? In practical terms, nothing; they are the same. So why does HTTP use the term <span class="emphasis"><em>method</em></span> instead of <span class="emphasis"><em>command</em></span>? That's a good question. The answer can be found in the abstract of the standard defining HTTP/1.0, RFC 1945. It states, in part, that HTTP is "a generic, stateless, object-oriented protocol which can be used for many tasks…." In highly simplified terms, <a class="indexterm" id="idx-CHP-81-2904"/>object-oriented programming is a technique in which software modules are described not as sets of procedures, but as <span class="emphasis"><em>objects</em></span> that possess attributes. These modules send messages to each other to communicate and to cause actions to be performed, where the action taken depends on the nature of the object. In object-oriented programming, the procedures each object can perform are called <span class="emphasis"><em>methods</em></span>.</p><p>HTTP is considered to be object-oriented because, in many cases, the action taken by a server depends on the object that is the subject of the request. For example, if you ask a server to retrieve a text document, it will send that document; but if you ask for a directory, the server may instead return a default document for that directory. In contrast, a request that specifies the name of a program will result in the program being executed and its output returned (as opposed to the program's source code being returned).</p><div class="sect2" title="Common Methods"><div class="titlepage"><div><div><h2 class="title"><a id="common_methods"/>Common Methods</h2></div></div></div><p>Each method allows the client to specify a particular type of action to be taken by the server. Method names are always in uppercase letters. There are three methods that are commonly used in HTTP: <a class="indexterm" id="idx-CHP-81-2905"/>GET, HEAD, and POST.</p><div class="sect3" title="GET"><div class="titlepage"><div><div><h3 class="title"><a id="get"/>GET</h3></div></div></div><p><a class="indexterm" id="idx-CHP-81-2906"/>The GET method requests that server retrieve the resource specified by the URL on the HTTP request line and send it in a response back to the client. This is the most basic type of request and the one that accounts for the majority of HTTP traffic. When you enter a conventional URL or click a link to a document or other file, you are usually prompting your web browser to send a GET request.</p><p>The handling of a GET request depends on a number of factors. If the URL is correct and the server can find the resource, it will send back the appropriate response to the client. The exact resource returned depends on the nature of the object requested. If the request cannot be processed properly, an error message may result. Caching (discussed in <a class="xref" href="ch84.html" title="Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES">Chapter 84</a>) also comes into play, as a proxy server or even the client itself might satisfy the request before it gets to the server.</p><p>It's important to remember that the meaning of a GET request may change if certain <a class="indexterm" id="idx-CHP-81-2907"/>headers, such as If-Modified-Since or If-Match, are used. These tell the server to send the resource only if certain conditions are met. A request of this sort is sometimes called a <span class="emphasis"><em>conditional GET</em></span>. Similarly, the client may use the Range <a class="indexterm" id="idx-CHP-81-2908"/>header to request that the server send it only part of a resource; this is usually used for large files. When this header is included, the request may be called a <span class="emphasis"><em>partial GET</em></span>.</p></div><div class="sect3" title="HEAD"><div class="titlepage"><div><div><h3 class="title"><a id="head"/>HEAD</h3></div></div></div><p>The HEAD method is identical to the GET method, but it tells the server not to send the actual body of the message. Thus, the response will contain all of the headers that would have accompanied a reply to the equivalent GET message, including entity headers describing the entity that the server would have sent had the method been GET. The client often uses this method to check the existence, status, or size of a file before deciding whether it wants the server to send the whole file.</p><p>HEAD requests are processed in the same way as GET requests, except that only the headers are returned, not the actual resource.</p></div><div class="sect3" title="POST"><div class="titlepage"><div><div><h3 class="title"><a id="post"/>POST</h3></div></div></div><p><a class="indexterm" id="idx-CHP-81-2909"/>The <a class="indexterm" id="idx-CHP-81-2910"/>POST method allows the client to send an entity containing arbitrary data to the server for processing. It is commonly used to enable a client to submit information such as an interactive HTML form to a program on the server, which then takes action based on that <a class="indexterm" id="idx-CHP-81-2911"/>input and sends a response. This capability is now used for all sorts of online programs. The URL in the request specifies the name of the program on the server that is to accept the data. Contrast this with the <a class="indexterm" id="idx-CHP-81-2912"/>PUT method described in the next section.</p></div></div><div class="sect2" title="Other Methods"><div class="titlepage"><div><div><h2 class="title"><a id="other_methods"/>Other Methods</h2></div></div></div><p>The other methods defined by the HTTP standard are not used as often, but I will describe them briefly, as you may still encounter them. Other HTTP methods include the following:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-81-2913"/>OPTIONS</strong></span> This method allows the client to request that the server send it information about available communication <a class="indexterm" id="idx-CHP-81-2914"/>options. A URI of a resource may be specified to request information relevant to accessing that resource, or an asterisk (*) may be used to indicate that the query is about the server itself. The response includes headers that give the client more details about how the server may be accessed.</p><p><span class="strong"><strong>PUT</strong></span> This method requests that the server store the entity enclosed in the body of the request at the URL specified in the request line. In a PUT, the URI identifies the entity in the request; thus a PUT allows a file to be copied to a server, in the exact complement to how a GET requests that a file be copied to the client. In contrast, with a POST, the URI identifies a program intended to <span class="emphasis"><em>process</em></span> the entity in the request, so it's used for interactive programs. Now, would you like people to be able to store files on your server in the same way that they request them? Neither would I. This is one primary reason why PUT is not often used. It has valid uses, such as uploading content to a website, and it must be used with authentication in this case. However, storing files on a site is more often accomplished using other means, like the File Transfer Protocol (FTP).</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-81-2915"/>DELETE</strong></span> This method requests that the specified resource be <a class="indexterm" id="idx-CHP-81-2916"/>deleted. This has the same issues as PUT and is not often used for similar reasons.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-81-2917"/>TRACE</strong></span> This method allows a client to receive back a copy of the request that it sent to the server, for diagnostic purposes.</p><p>In addition to these, the standard reserves the method name CONNECT for future use. An earlier version of HTTP/1.1, RFC 2068, defined the methods PATCH, LINK, and UNLINK. These were removed in the final version, but you may still see references to them.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-488"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Each HTTP client request specifies a particular type of action that the server should perform; in HTTP, these are called <span class="emphasis"><em>methods</em></span>, rather than commands. The three most common <a class="indexterm" id="idx-CHP-81-2918"/>HTTP methods are <span class="emphasis"><em>GET</em></span>, which prompts a server to return a resource; <span class="emphasis"><em>HEAD</em></span>, which returns just the headers associated with a resource; and <span class="emphasis"><em>POST</em></span>, which allows a client to submit data to a server for processing.</p></div></div><div class="sect2" title="Safe and Idempotent Methods"><div class="titlepage"><div><div><h2 class="title"><a id="safe_and_idempotent_methods"/>Safe and Idempotent Methods</h2></div></div></div><p><a class="indexterm" id="idx-CHP-81-2919"/>As you've seen, methods vary greatly in the type of behavior they cause the server to take. The HTTP standard defines two characteristics that can be used to differentiate methods based on the impact they have on a server:</p><p><span class="strong"><strong>Safe Methods</strong></span> These are methods that an administrator of a server can feel reasonably comfortable permitting a client to send because they are very unlikely to have any negative side effects. The methods usually put into this category are GET, HEAD, OPTIONS, and <a class="indexterm" id="idx-CHP-81-2920"/>TRACE. The methods that cause data to be accepted by the server for processing, or lead to changes on the server, are deemed unsafe: POST, PUT, and DELETE. (The fact that they are considered unsafe doesn't mean a server never allows them—just that they require more care and detail in handling than the others.)</p><p><span class="strong"><strong>Idempotent Methods</strong></span> A method is said to be <span class="emphasis"><em>idempotent</em></span> if repeating the same method request numerous times causes the exact same results, as if the method were issued only once. For example, if you load a web page in your browser, and then type the same URL in again, you get the same result, at least most of the time. In general, all of the methods in HTTP have this property inherently except one: POST.</p><p>The POST method is not idempotent because each instance of a POST request causes the receiving server to process the data in the Request message's body. Submitting a POST request two or more times can often lead to undesirable results. The classic example is clicking the Submit button on a form more than once, which can lead to annoyances such as a duplicate message on an Internet forum or a double order at an online store.</p><p>There are also situations where a method that is normally idempotent may not be. A GET request for a simple document is idempotent, but a GET for a script can change files on the server and therefore is not idempotent. Similarly, a sequence of idempotent methods may not be idempotent. For example, consider a situation where a PUT request is followed by a GET for the same resource. This sequence is not idempotent because the second request depends on the results of the first.</p><p>The significance of nonidempotence is that clients must handle such requests or sequences specially. The client must keep track of them, making sure that they are filled in order and only once. The HTTP standard also specifies that nonidempotent methods should not be pipelined, to avoid problems if an HTTP session is unexpectedly terminated. For example, if two POST requests were pipelined and the server got hung up handling them, the client would need to reissue them but might not know how many of the original requests had been successfully processed.</p></div></div>
<div class="sect1" title="HTTP Status Codes and Reason Phrases"><div class="titlepage"><div><div><h1 class="title"><a id="http_status_codes_and_reason_phrases"/>HTTP Status Codes and Reason Phrases</h1></div></div></div><p><a class="indexterm" id="idx-CHP-81-2921"/>Every request sent by an HTTP client causes one or more responses to be returned by the server that receives it. As you saw earlier in the discussion of the Response message format, the first line of the response is a status line that contains a summary of the results of processing the request. The purpose of this line is to communicate quickly whether or not the request was successful and why.</p><p>HTTP status lines contain both a numeric status code and a text reason phrase. The reason for having both a number and a text string is that computers can more easily understand the results of a request by looking at a number and then can quickly respond accordingly. Humans, on the other hand, find text descriptions easier to comprehend. The idea of using both forms was taken directly from earlier application layer protocols such as FTP, the Simple Mail Transfer Protocol (SMTP), and the Network News Transfer Protocol (NNTP). The explanation of FTP reply codes in <a class="xref" href="ch72.html" title="Chapter 72. FILE TRANSFER PROTOCOL (FTP)">Chapter 72</a> discusses more completely the reasons why numeric reply codes are used in addition to descriptive text.</p><div class="sect2" title="Status Code Format"><div class="titlepage"><div><div><h2 class="title"><a id="status_code_format"/>Status Code Format</h2></div></div></div><p>HTTP status codes are three digits in length and follow a particular format, where the first digit has particular significance. Unlike the reply codes used by FTP and other protocols, the second digit does not stand for a functional grouping; the second and third digits together just make 100 different options for each of the categories indicated by the first digit. Thus, the general form of an HTTP status code is <span class="emphasis"><em>xyy</em></span>, where the first digit, <span class="emphasis"><em>x</em></span>, is specified as shown in <a class="xref" href="ch81s05.html#http_status_code_format_first-digit_inte" title="Table 81-1. HTTP Status Code Format: First-Digit Interpretation">Table 81-1</a>.</p><div class="table"><a id="http_status_code_format_first-digit_inte"/><p class="title">Table 81-1. HTTP Status Code Format: First-Digit Interpretation</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="HTTP Status Code Format: First-Digit Interpretation"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Status Code Format</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Meaning</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1yy</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Informational message</p></td><td style="border-bottom: 0.5pt solid ; "><p>Provides general information; does not indicate success or failure of a request.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2yy</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Success</p></td><td style="border-bottom: 0.5pt solid ; "><p>The method was received, understood, and accepted by the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3yy</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Redirection</p></td><td style="border-bottom: 0.5pt solid ; "><p>The request did not fail outright, but additional action is needed before it can be successfully completed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4yy</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Client error</p></td><td style="border-bottom: 0.5pt solid ; "><p>The request was invalid, contained bad syntax, or could not be completed for some other reason that the server believes was the client's fault.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>5yy</p></td><td style="border-right: 0.5pt solid ; "><p>Server error</p></td><td style=""><p>The request was valid, but the server was unable to complete it due to a problem of its own.</p></td></tr></tbody></table></div></div><p>In each of these five groups, the code where <span class="emphasis"><em>yy</em></span> is 00 is defined as a generic status code for that group, while other two-digit combinations are more specific responses. For example, 404 is the well-known specific error message that means the requested resource was not found by the server, and 400 is the less specific Bad Request error. This system was set up to allow the definition of new status codes that certain clients might not comprehend. If a client receives a strange code, it just treats it as the equivalent of the generic response in the appropriate category. So, if a server response starts with the code 491, and the client has no idea what this is, it treats it as a 400 Bad Request reply.</p></div><div class="sect2" title="Reason Phrases"><div class="titlepage"><div><div><h2 class="title"><a id="reason_phrases"/>Reason Phrases</h2></div></div></div><p><a class="indexterm" id="idx-CHP-81-2922"/>The reason phrase is a text string that provides a more meaningful description of the error for people who are bad at remembering what cryptic codes stand for (which would be most of us!). The HTTP standard includes sample <a class="indexterm" id="idx-CHP-81-2923"/>reason phrases for each status code, but server administrators can customize these phrases if desired. When a server returns a more detailed HTML error message in the body of its Response message, the reason phrase is often used for the title tag in that message body.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-489"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Each HTTP Response message includes both a numeric <span class="emphasis"><em>status code</em></span> and a text <span class="emphasis"><em>reason phrase</em></span>, both of which indicate the disposition of the corresponding client request. The numeric code allows software programs to easily interpret the results of a request, while the text phrase provides more useful information to human users. HTTP status codes are three digits in length, with the first digit indicating the general class of the reply.</p></div><p><a class="xref" href="ch81s05.html#http_status_codes_and_reason_phras-id001" title="Table 81-2. HTTP Status Codes and Reason Phrases">Table 81-2</a> lists in numerical order the status codes defined by the HTTP/1.1 standard, along with the standard reason phrase and a brief description of each.</p><div class="table"><a id="http_status_codes_and_reason_phras-id001"/><p class="title">Table 81-2. HTTP Status Codes and Reason Phrases</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="HTTP Status Codes and Reason Phrases"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-81-2924"/>Status Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-81-2925"/>Reason Phrase</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>100</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Continue</p></td><td style="border-bottom: 0.5pt solid ; "><p>The client should continue sending its request. This is a special status code; see the next section in this chapter for details.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>101</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Switching Protocols</p></td><td style="border-bottom: 0.5pt solid ; "><p>The client has used the Upgrade header to request the use of an alternative protocol and the server has agreed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>200</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>OK</p></td><td style="border-bottom: 0.5pt solid ; "><p>This is the generic successful Request message response, which is the code sent most often when a request is filled normally.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>201</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Created</p></td><td style="border-bottom: 0.5pt solid ; "><p>The request was successful and resulted in a resource being created. This is a typical response to a PUT method.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>202</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Accepted</p></td><td style="border-bottom: 0.5pt solid ; "><p>The request was accepted by the server, but it has not yet been processed. This is an intentionally noncommittal response that does not tell the client whether or not the request will be carried out. The client determines the eventual disposition of the request in some unspecified way. It is used only in special circumstances.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>203</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Non-Authoritative Information</p></td><td style="border-bottom: 0.5pt solid ; "><p>The request was successful, but some of the information returned by the server came from a third party, rather than from the original server associated with the resource.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>204</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No Content</p></td><td style="border-bottom: 0.5pt solid ; "><p>The request was successful, but the server has determined that it does not need to return to the client an entity body.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>205</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reset Content</p></td><td style="border-bottom: 0.5pt solid ; "><p>The request was successful; the server is telling the client that it should reset the document from which the request was generated so that a duplicate request is not sent. This code is intended for use with forms.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>206</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Partial Content</p></td><td style="border-bottom: 0.5pt solid ; "><p>The server has successfully fulfilled a partial GET request. See the section on methods earlier in this chapter for more details on this, as well as the description of the Range header in the next chapter.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>300</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Multiple Choices</p></td><td style="border-bottom: 0.5pt solid ; "><p>The resource is represented in more than one way on the server. The server is returning information describing these representations, so the client can pick the most appropriate one, a process called agent-driven negotiation (discussed in <a class="xref" href="ch83.html" title="Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management">Chapter 83</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>301</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Moved Permanently</p></td><td style="border-bottom: 0.5pt solid ; "><p>The resource requested has been moved to a new URL permanently. Any future requests for this resource should use the new URL. This is the proper method of handling situations where a file on a server is renamed or moved to a new directory. Most people don't bother setting this up, which is why URLs break so often, resulting in 404 errors.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>302</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Found</p></td><td style="border-bottom: 0.5pt solid ; "><p>The resource requested is temporarily using a different URL. The client should continue to use the original URL. See code 307.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>303</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>See Other</p></td><td style="border-bottom: 0.5pt solid ; "><p>The response for the request can be found at a different URL, which the server specifies. The client must do a fresh GET on that URL to see the results of the prior request.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>304</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Not Modified</p></td><td style="border-bottom: 0.5pt solid ; "><p>The client sent a conditional GET request, but the resource has not been modified since the specified date/time, so the server has not sent it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>305</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Use Proxy</p></td><td style="border-bottom: 0.5pt solid ; "><p>To access the requested resource, the client must use a proxy, whose URL is given by the server in its response.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>306</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>(unused)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Defined in an earlier version of HTTP and no longer used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>307</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Temporary Redirect</p></td><td style="border-bottom: 0.5pt solid ; "><p>The resource is temporarily located at a different URL than the one the client specified. Note that 302 and 307 are basically the same status code. Code 307 was created to clear up some confusion related to 302 that occurred in earlier versions of HTTP.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>400</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bad Request</p></td><td style="border-bottom: 0.5pt solid ; "><p>This is a generic response when the request cannot be understood or carried out due to a problem on the client's end.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>401</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unauthorized</p></td><td style="border-bottom: 0.5pt solid ; "><p>The client is not authorized to access the resource. This is often returned if an attempt is made to access a resource protected by a password or some other means without the appropriate credentials.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>402</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Payment Required</p></td><td style="border-bottom: 0.5pt solid ; "><p>This is reserved for future use. Its mere presence in the HTTP standard has caused a lot of people to scratch their chins and go "hmm…."</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>403</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Forbidden</p></td><td style="border-bottom: 0.5pt solid ; "><p>The request has been disallowed by the server. This is a generic "no way" response that is not related to authorization. For example, if the maintainer of website blocks access to it from a particular client, any requests from that client will result in a 403 reply.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>404</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Not Found</p></td><td style="border-bottom: 0.5pt solid ; "><p>The most common HTTP error message, this is returned when the server cannot locate the requested resource. It usually occurs due to the server having moved (or removed) the resource or the client giving an invalid URL (usually due to misspellings).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>405</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Method Not Allowed</p></td><td style="border-bottom: 0.5pt solid ; "><p>The requested method is not allowed for the specified resource. The response includes an Allow header that indicates which methods the server will permit.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>406</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Not Acceptable</p></td><td style="border-bottom: 0.5pt solid ; "><p>The client sent a request that specifies limitations that the server cannot meet for the specified resource. This error may occur if an overly restrictive list of conditions is placed into a request such that the server cannot return any part of the resource.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>407</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Proxy Authentication Required</p></td><td style="border-bottom: 0.5pt solid ; "><p>This is similar to 401, but the client must first authenticate itself with the proxy.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>408</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request Timeout</p></td><td style="border-bottom: 0.5pt solid ; "><p>The server was expecting the client to send a request within a particular time frame and the client didn't send it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>409</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Conflict</p></td><td style="border-bottom: 0.5pt solid ; "><p>The request could not be filled because of a conflict of some sort related to the resource. This most often occurs in response to a PUT method, such as if one user tries to PUT a resource that another user has open for editing.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>410</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Gone</p></td><td style="border-bottom: 0.5pt solid ; "><p>The resource is no longer available at the server, which does not know its new URL. This is a more specific version of the 404 code that is used only if the server knows that the resource was intentionally removed. It is seen rarely (if ever).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>411</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length Required</p></td><td style="border-bottom: 0.5pt solid ; "><p>The request requires a Content-Length header field and one was not included.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>412</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Precondition Failed</p></td><td style="border-bottom: 0.5pt solid ; "><p>This indicates that the client specified a precondition in its request, such as the use of an If-Match header, which evaluated to a false value. This indicates that the condition was not satisfied, so the request is not being filled. This is used by clients in special cases to ensure that they do not accidentally receive the wrong resource.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>413</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request Entity Too Large</p></td><td style="border-bottom: 0.5pt solid ; "><p>The server has refused to fulfill the request because the entity that the client is requesting is too large.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>414</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request-URI Too Long</p></td><td style="border-bottom: 0.5pt solid ; "><p>The server has refused to fulfill the request because the URL specified is longer than the server can process. This rarely occurs with properly formed URLs, but may be seen if clients try to send gibberish to the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>415</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unsupported Media Type</p></td><td style="border-bottom: 0.5pt solid ; "><p>The request cannot be processed because it contains an entity using a media type the server does not support.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>416</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Requested Range Not Satisfiable</p></td><td style="border-bottom: 0.5pt solid ; "><p>The client included a Range header specifying a range of values that is not valid for the resource. An example might be requesting bytes 3000 through 4000 of a 2400-byte file.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>417</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Expectation Failed</p></td><td style="border-bottom: 0.5pt solid ; "><p>The request included an Expect header that could not be satisfied by the server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>500</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Internal Server Error</p></td><td style="border-bottom: 0.5pt solid ; "><p>This is a generic error message indicating that the request could not be fulfilled due to a server problem.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>501</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Not Implemented</p></td><td style="border-bottom: 0.5pt solid ; "><p>The server does not know how to carry out the request, so it cannot satisfy it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>502</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bad Gateway</p></td><td style="border-bottom: 0.5pt solid ; "><p>The server, while acting as a gateway or proxy, received an invalid response from another server it tried to access on the client's behalf.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>503</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Service Unavailable</p></td><td style="border-bottom: 0.5pt solid ; "><p>The server is temporarily unable to fulfill the request for internal reasons. This is often returned when a server is overloaded or down for maintenance.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>504</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Gateway Timeout</p></td><td style="border-bottom: 0.5pt solid ; "><p>The server, while acting as a gateway or proxy, timed out while waiting for a response from another server it tried to access on the client's behalf.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>505</p></td><td style="border-right: 0.5pt solid ; "><p>HTTP Version Not Supported</p></td><td style=""><p>The request used a version of HTTP that the server does not understand.</p></td></tr></tbody></table></div></div></div><div class="sect2" title="The 100 (Continue) Preliminary Reply"><div class="titlepage"><div><div><h2 class="title"><a id="the_100_continue_preliminary_reply"/>The 100 (Continue) Preliminary Reply</h2></div></div></div><p>Now, let's go back to the top of the list in <a class="xref" href="ch81s05.html" title="HTTP Status Codes and Reason Phrases">HTTP Status Codes and Reason Phrases</a> and look at the special status code 100. Normally, a client sends a complete request to the server and waits for a response to it (while optionally pipelining additional requests, as described in the previous chapter). In certain circumstances, however, the client might wish to check in advance if the server is willing to accept the request before it bothers sending the whole message. This is not a common occurrence, because most requests are quite small, so checking first isn't worth the bother. However, in cases where a user wants to submit a very large amount of data to an online program or use PUT to store a large file, for example, checking with the server first can be a useful optimization.</p><p>In this situation, the client sends a request containing the special header Expect: 100-Continue. Assuming that the server supports the feature, it will process the request's headers and immediately send back the 100 Continue preliminary reply. This tells the client to continue sending the rest of the request. The server then processes it and responds normally. If the server doesn't send the 100 response after a certain amount of time, the client will typically just send the rest of the request anyway. Note that in some cases, servers send these preliminary replies even when they are not supposed to, so clients must be prepared to deal with them (they are simply discarded, since they contain no information).</p></div></div>
<div class="chapter" title="Chapter&#xA0;82.&#xA0;HTTP MESSAGE HEADERS"><div class="titlepage"><div><div><h1 class="title"><a id="http_message_headers"/>Chapter 82. HTTP MESSAGE HEADERS</h1></div></div></div><p><span class="inlinemediaobject"><a id="I_inlinemediaobject4_d1e89778"/><img alt="" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></span>As you have seen in the preceding two chapters, Hypertext Transfer Protocol (HTTP) communication takes place through the relatively simple exchange of request and response messages. There are only a small number of methods (commands) supported by the protocol, which might give you the impression that the protocol is quite limited. Looks can be deceiving, however. Much of the functionality in HTTP is actually implemented in the form of <span class="emphasis"><em>message headers</em></span><a class="indexterm" id="idx-CHP-82-2926"/>, which convey important details between clients and servers.</p><p>Some headers can appear in only HTTP requests, some in only HTTP responses, and some in either type of message. Understanding these headers is important to learning how HTTP works. There are literally dozens of them, and many apply to both Request and Response messages.</p><p>In this chapter, I provide a description of each of the many headers used in HTTP Request and Response messages. The chapter is organized by the four basic types of HTTP headers: general headers, request headers, response headers, and entity headers.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-490"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>I assume here that you have already read the preceding chapter describing HTTP message formats</em></span>.</p></div><div class="note" title="Note"><h3 class="title"><a id="note-177"/>Note</h3><p><span class="emphasis"><em>For the purpose of determining how web caches treat HTTP messages, HTTP headers are categorized as either end-to-end or hop-by-hop headers. The former are meaningful only to the ultimate recipient of a message, while the latter are relevant to each device in the chain of devices (such as proxies) connecting a client and server. To avoid unnecessary complication, I have not categorized the headers using these categories; see the full discussion of caching in <a class="xref" href="ch84.html" title="Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES">Chapter 84</a> for more information. In the descriptions of the individual headers, I indicate which headers are hop-by-hop; all others are end-to-end</em></span>.</p></div><div class="sect1" title="HTTP General Headers"><div class="titlepage"><div><div><h1 class="title"><a id="http_general_headers"/>HTTP General Headers</h1></div></div></div><p><a class="indexterm" id="idx-CHP-82-2927"/>HTTP <span class="emphasis"><em>general headers</em></span> are so named because, unlike headers in the other three categories, they are not specific to any particular kind of message or message component (request, response, or message entity). General headers are used primarily to communicate information about the message itself, as opposed to what content it carries. They provide general information and control how a message is processed and handled.</p><p>Despite not being specific to either requests or replies, some general headers are used either mostly or entirely in one or the other type of message. There are also some general headers that can appear in either a Request or a Reply message, but have a somewhat different meaning in each.</p><p>Here, I describe the <a class="indexterm" id="idx-CHP-82-2928"/>Cache-Control and Warning headers and then the other more straightforward headers.</p><div class="sect2" title="Cache-Control Headers"><div class="titlepage"><div><div><h2 class="title"><a id="cache-control_headers"/>Cache-Control Headers</h2></div></div></div><p>A Cache-Control header specifies directives that manage how caching is performed either for an HTTP request or response. These directives affect the handling of a request or response by all devices in the request/response chain from the HTTP client, through any present intermediaries, to the HTTP server (or the other way, from the server, through intermediaries, to the client). They override any default caching behavior performed by a device. See the discussion of caching in <a class="xref" href="ch84.html" title="Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES">Chapter 84</a> for a full exposition of the subject.</p><p>There are a dozen individual directives that can appear in this header, the full details of which can be found in RFC 2616. Even though this is a general header, some directives can appear only in a request or a response. Some also include an additional parameter, such as a number of seconds, that control their interpretation. <a class="xref" href="ch82.html#http_cache-control_directives" title="Table 82-1. HTTP Cache-Control Directives">Table 82-1</a> provides a brief summary of the different Cache-Control options and how they are used.</p><p>Note that only one directive may appear in a Cache-Control header, but more than one such header can appear in a message.</p><div class="table"><a id="http_cache-control_directives"/><p class="title">Table 82-1. HTTP Cache-Control Directives</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="HTTP Cache-Control Directives"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-82-2929"/>Cache-Control Directive</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>HTTP Message Type</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>no-cache</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request or Response</p></td><td style="border-bottom: 0.5pt solid ; "><p>When present, forces a caching device to forward any subsequent requests for the same content to the server for revalidation; that is, the cache must check with the server to ensure that the cached data is still valid. Also see the Pragma header description, for an alternative way of accomplishing the same thing.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>public</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Response</p></td><td style="border-bottom: 0.5pt solid ; "><p>Indicates that the response may be cached by any cache, including a shared one (a cache used by many clients). See <a class="xref" href="ch84.html" title="Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES">Chapter 84</a> for more details on shared caches.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>private</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Response</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies that the response is intended for only a particular user and should not be placed into a shared cache.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>no-store</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request or Response</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies that the entire request or response should not be stored in a cache. This is used sometimes to prevent the storing of sensitive documents in caches where unauthorized people might be able to access them. However, as the HTTP standard points out, this is really a very rudimentary security measure and should not be trusted a great deal (since a malicious cache operator could simply ignore the directive).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>max-age</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request or Response</p></td><td style="border-bottom: 0.5pt solid ; "><p>In a request, indicates that the client is willing to accept a response whose age is no greater than the value specified. In a response, indicates the maximum age of the response before it is considered stale. This is an alternative to the use of the Expires header and takes precedence over it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>s-maxage</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Response</p></td><td style="border-bottom: 0.5pt solid ; "><p>If present, specifies the maximum age for shared caches receiving the response. Private caches (ones that serve only a single client) use the max-age value (see the preceding description).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>min-fresh</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies that the client wants a response that is not only not stale at the time the request is received, but that will remain fresh for the specified number of seconds.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>max-stale</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request</p></td><td style="border-bottom: 0.5pt solid ; "><p>If sent without a parameter, indicates that the client is willing to accept a stale reply (one that has expired). If a numeric parameter is included, it indicates how stale, in seconds, the response may be.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>only-if-cached</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used only in special circumstances, forces the reply to come from a cache only; the content may not come from the actual specified HTTP server.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>must-revalidate</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Response</p></td><td style="border-bottom: 0.5pt solid ; "><p>Instructs a cache to revalidate its cache entry for the given response with the original server after it becomes stale. This is used to prevent problems with certain types of transactions that can occur if stale cache entries are sent to a client (perhaps as a result of the client using the max-stale directive).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>proxy-revalidate</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Response</p></td><td style="border-bottom: 0.5pt solid ; "><p>Similar to must-revalidate, but applies only to proxies that service many users. Private caches, such as those on individual client computers, are not affected.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>no-transform</p></td><td style="border-right: 0.5pt solid ; "><p>Request or Response</p></td><td style=""><p>Some caches will, by default, change the form in which certain cached entries are stored, to save space or improve performance. In cases where this might cause problems, the client or server can use this directive to request that this transformation not be performed.</p></td></tr></tbody></table></div></div></div><div class="sect2" title="Warning"><div class="titlepage"><div><div><h2 class="title"><a id="warning"/>Warning</h2></div></div></div><p><a class="indexterm" id="idx-CHP-82-2930"/>A <a class="indexterm" id="idx-CHP-82-2931"/>Warning header is used when it's needed to provide additional information about the status of a message. Many of the defined warning header types are related to caching. More than one Warning header may appear in a message, and each typically includes a three-digit numeric code as well as a plain text message, following the same basic format used in HTTP response status codes (described in <a class="xref" href="ch81.html" title="Chapter 81. HTTP MESSAGES, METHODS, AND STATUS CODES">Chapter 81</a>). <a class="xref" href="ch82.html#http_warning_header_codes" title="Table 82-2. HTTP Warning Header Codes">Table 82-2</a> briefly lists the <a class="indexterm" id="idx-CHP-82-2932"/>warnings defined in RFC 2616.</p><div class="table"><a id="http_warning_header_codes"/><p class="title">Table 82-2. HTTP Warning Header Codes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="HTTP Warning Header Codes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Warning Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Warning Text</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>110</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Response is stale</p></td><td style="border-bottom: 0.5pt solid ; "><p>Must be included when a response provided by a cache is stale (that is, has passed the expiration time set for it).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>111</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Revalidation failed</p></td><td style="border-bottom: 0.5pt solid ; "><p>A cache attempted to <a class="indexterm" id="idx-CHP-82-2933"/>revalidate a cached entry but was unsuccessful, so it returned its (stale) cached entry.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>112</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Disconnected operation</p></td><td style="border-bottom: 0.5pt solid ; "><p>The cache is disconnected from the rest of the network.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>113</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Heuristic expiration</p></td><td style="border-bottom: 0.5pt solid ; "><p>Included if the cache chose a freshness lifetime of more than 24 hours, and the age of the response is also greater than 24 hours.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>199</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Miscellaneous warning</p></td><td style="border-bottom: 0.5pt solid ; "><p>Catchall code for other, nonspecific warnings.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>214</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Transformation applied</p></td><td style="border-bottom: 0.5pt solid ; "><p>Warns the recipient that an intermediate cache or proxy applied a transformation of some type to change the content coding or media type of the message or message body.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>299</p></td><td style="border-right: 0.5pt solid ; "><p>Miscellaneous persistent warning</p></td><td style=""><p>Similar to code 199, but indicates a persistent warning.</p></td></tr></tbody></table></div></div></div><div class="sect2" title="Other HTTP General Headers"><div class="titlepage"><div><div><h2 class="title"><a id="other_http_general_headers"/>Other HTTP General Headers</h2></div></div></div><p>The following are the other types of HTTP general headers:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2934"/>Connection</strong></span> Contains instructions that pertain only to this particular <a class="indexterm" id="idx-CHP-82-2935"/>connection, and must not be retained by proxies and used for further connections. The most common use of this header is with the <code class="literal">close</code> parameter, as follows: <code class="literal">Connection: close</code>. This overrides the default persistent connection behavior of HTTP/1.1 (described in <a class="xref" href="ch80.html" title="Chapter 80. HTTP GENERAL OPERATION AND CONNECTIONS">Chapter 80</a>), forcing the connection to terminate after the server's response. Connection is a hop-by-hop header.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2936"/>Date</strong></span> Indicates the date and time when the message originated. This is the same as the Date header in the RFC 822 email format (described in <a class="xref" href="ch76.html" title="Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME">Chapter 76</a>). A typical example is <code class="literal">Date: Wed, 17 May 2006 16:43:50 GMT</code>.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2937"/>Pragma</strong></span> Used to enable implementation-specific directives to be applied to all devices in the request/response chain. One common use of this header is to suppress caching by including <a class="indexterm" id="idx-CHP-82-2938"/><code class="literal">Pragma: no-cache</code> in a message. This has the same meaning as a <code class="literal">Cache-Control: no-cache</code> header, and is included in HTTP/1.1 for backward-compatibility with HTTP/1.0 (which supports Pragma but not Cache-Control).</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2939"/>Trailer</strong></span> When chunked transfers are used (as described in <a class="xref" href="ch83.html" title="Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management">Chapter 83</a>), certain headers may be placed as <a class="indexterm" id="idx-CHP-82-2940"/>trailers, after the data being sent. In this case, the Trailer header is included before the data, and it lists the names of the headers that are actually trailers in that message. This warns the recipient to look for them after the data. Trailer is a hop-by-hop header.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2941"/>Transfer-Encoding</strong></span> Indicates what encoding has been used for the body of the message, to ensure that it is able to be transferred properly between devices. This header is most often used with the chunked transfer method. Note that this header describes encoding applied to an entire message, and is thus not the same as the Content-Encoding entity header, which specifically describes the entity carried in a message. See <a class="xref" href="ch83.html" title="Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management">Chapter 83</a> for a full discussion. This header applies only to a single transfer, so it is a hop-by-hop header.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2942"/>Upgrade</strong></span> Allows a client device to specify which additional protocols it supports. If the server also supports one of the protocols the client listed, the server may agree to <a class="indexterm" id="idx-CHP-82-2943"/>upgrade the connection to the alternative protocol. It indicates the protocol to which it is upgrading by including an Upgrade header in a 101 (Switching Protocols) response to the client. This is a hop-by-hop header.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2944"/>Via</strong></span> Included by intermediary devices to indicate to the recipient which gateways, proxies, and/or tunnels were used in conveying a request or response. This header allows easy tracing of the path a message took over a potentially complex chain of devices between a client and server.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-491"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> HTTP <span class="emphasis"><em>general headers</em></span> can appear in either an HTTP Request or HTTP Response message. They are used to communicate information about the message itself, as opposed to its contents. General headers are used for functions such as specifying the date and time of a message, controlling how the message is cached, and indicating its transfer encoding method.</p></div></div></div></div>
<div class="sect1" title="HTTP Request Headers"><div class="titlepage"><div><div><h1 class="title"><a id="http_request_headers"/>HTTP Request Headers</h1></div></div></div><p><a class="indexterm" id="idx-CHP-82-2945"/>HTTP <a class="indexterm" id="idx-CHP-82-2946"/><span class="emphasis"><em>request headers</em></span>, as you might imagine, are used only in HTTP Request messages, where they serve a number of functions. First, they allow the client to provide information about itself to the server. Second, they give additional details about the nature of the request that the client is making. Third, they allow the client to have greater control over how its request is processed and how (or even if) a response is returned by the server or intermediary.</p><p>This is the largest of the four categories of HTTP headers, containing more than a dozen different types, as follows:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2947"/>Accept</strong></span> Allows the client to tell the server which Internet media types it is willing to <a class="indexterm" id="idx-CHP-82-2948"/>accept in a response. The header may list several different Multipurpose Internet Mail Extensions (MIME) media types and subtypes that the client knows how to deal with. Each may be prepended with a quality value (<code class="literal">q</code> parameter) to indicate the client's preference. If this header is not specified, the default is for the server to assume any media type may be sent to the client. See the discussion of entity media types and content negotiation in <a class="xref" href="ch83.html" title="Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management">Chapter 83</a> for more information about how this header is used.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2949"/>Accept-Charset</strong></span> Similar to Accept, but specifies which character sets (charsets) the client is willing to accept in a response, rather than which media types. Again, the listed charsets may use a <code class="literal">q</code> value, and again, the default if the header is omitted is for the client to accept any charset.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2950"/>Accept-Encoding</strong></span> Similar to Accept and <a class="indexterm" id="idx-CHP-82-2951"/>Accept-Charset, but specifies which content encodings the client is willing to accept. This is often used to control whether the server may send content in compressed form. (As you'll learn in <a class="xref" href="ch83.html" title="Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management">Chapter 83</a>, content codings are not the same as transfer encodings.)</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2952"/>Accept-Language</strong></span> Similar to the preceding Accept-type headers, but provides a list of <span class="emphasis"><em>language tags</em></span> that indicates which languages the client supports or <a class="indexterm" id="idx-CHP-82-2953"/>expects the server to use in its response.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2954"/>Authorization</strong></span> Used by the client to present authentication information (called <span class="emphasis"><em>credentials</em></span>) to the server to allow the client to be authenticated. This is required only when the server requests authentication, often by sending a 401 (Unauthorized) response to the client's initial request. This response will contain a WWW-Authenticate header providing the client with details on how to authenticate with the server. See the discussion of security and privacy in <a class="xref" href="ch84.html" title="Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES">Chapter 84</a> for more information.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2955"/>Expect</strong></span> Indicates certain types of actions that the client is expecting the server to perform. Usually, the server will accept the indicated parameters; if not, it will send back a 417 (Expectation Failed) response. The most common use of this field is to control when the server sends a 100 (Continue) response. The client indicates that it wants the server to send this preliminary reply by including the Expect: 100-Continue header in its request. (See the discussion of status codes at the end of <a class="xref" href="ch81.html" title="Chapter 81. HTTP MESSAGES, METHODS, AND STATUS CODES">Chapter 81</a> for details.)</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2956"/>From</strong></span> Contains the email address of the human user making the request. This is optional, and since it is easily spoofed, should be used only for informational purposes, and not for any type of access rights determination or authentication.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2957"/>Host</strong></span> Specifies the Internet <a class="indexterm" id="idx-CHP-82-2958"/>host as a Domain Name System (DNS) domain name and may also contain a port number specification as well (typically, only if a port other than the HTTP default of 80 is to be used). This header is used to allow multiple domains to be served by the same web server on a particular Internet Protocol (IP) host. It has the distinction of being the only mandatory header—it must be present in all HTTP/1.1 requests.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2959"/>If-Match</strong></span> Makes a method conditional by specifying the <span class="emphasis"><em>entity tag</em></span> (or tags) corresponding to the specific entity that the client wishes to access. This is usually used in a GET method, and the server responds with the entity only if it matches the one specified in this header. Otherwise, the server sends a 412 (Precondition Failed) reply.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2960"/>If-Modified-Since</strong></span> Makes a method conditional by telling the server to return the requested entity only if it has been modified since the time specified in this header. Otherwise, the server sends a 304 (Not Modified) response. This is used to check if a resource has changed since it was last accessed, to avoid unnecessary transfers.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2961"/>If-None-Match</strong></span> The opposite of If-Match; it creates a conditional request that is only filled if the specified tag(s) do not match the requested entity.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2962"/>If-Range</strong></span> Used in combination with the <a class="indexterm" id="idx-CHP-82-2963"/>Range header to effectively allow a client to both check for whether an entity has changed and request that a portion of it be sent in a single request. (The alternative is to first issue a conditional request, and if it fails, issue a second request.) When present, <a class="indexterm" id="idx-CHP-82-2964"/>If-Range tells the server to send to the client the part of the entity indicated in the <a class="indexterm" id="idx-CHP-82-2965"/>Range header if the entity has not changed. If the entity has changed, the server sends the entire entity in response.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2966"/>If-Unmodified-Since</strong></span> The logical opposite of the If-Modified-Since header; the request is filled only if the resource has <span class="emphasis"><em>not</em></span> been modified since the specified time. Otherwise, the server sends a 412 reply.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2967"/>Max-Forwards</strong></span> Specifies a limit on the number of times a request can be forwarded to the next device in the request chain. This header is used with the TRACE or OPTIONS methods only, to permit diagnosis of forwarding failures or looping. When present in one of these methods, each time a device forwards the request, the number in this header is decremented. If a device receives a request with a <a class="indexterm" id="idx-CHP-82-2968"/>Max-Forwards value of 0, it must not forward it, but rather it should respond back to the client. (In a way, this is somewhat analogous to how the Time to Live field is used in the IP datagram format, as described in <a class="xref" href="ch21.html" title="Chapter 21. INTERNET PROTOCOL DATAGRAM ENCAPSULATION AND FORMATTING">Chapter 21</a>.)</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2969"/>Proxy-Authorization</strong></span> Like the Authorization header, but used to present credentials to a proxy server for authentication, rather than to the end server. It is created using information sent by a proxy in a response containing a Proxy-Authenticate header. This is a hop-by-hop header, sent only to the first proxy that receives the request. If authentication is required with more than one proxy, multiple <a class="indexterm" id="idx-CHP-82-2970"/>Proxy-Authorization headers may be put in a message, with each proxy consuming one of the headers.</p><p><span class="strong"><strong>Range</strong></span> Allows the client to request that the server send it only a portion of an entity, by specifying a range of bytes in the entity to be retrieved. If the requested range is valid, the server sends only the indicated part of the file, using a 206 (Partial Content) status code; if the range requested cannot be filled, the reply is 416 (Requested Range Not Satisfiable).</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2971"/>Referer</strong></span> Tells the server the Uniform Resource Locator (URL) of the resource from which the URL of the current request was obtained. Typically, when a user clicks a link on one web page to load another, the address of the original web page is put into the <a class="indexterm" id="idx-CHP-82-2972"/>Referer line when the request for the clicked link is sent. This allows tracking and logging of how the server is accessed. If a human user manually enters a Uniform Resource Identifier (URI) into a web browser, this header is not included in the request. Since this header provides information related to how web pages are used, it has certain privacy implications.</p><div class="note" title="Note"><h3 class="title"><a id="note-178"/>Note</h3><p><span class="emphasis"><em>The proper spelling of this word is referrer. It was misspelled years ago in an earlier version of the HTTP standard, and before this was noticed and corrected, this spelling became incorporated into so much software that the Internet Engineering Task Force (IETF) chose not to correct the spelling in HTTP/1.1</em></span><a class="indexterm" id="idx-CHP-82-2973"/>.</p></div><p><a class="indexterm" id="idx-CHP-82-2974"/><a class="indexterm" id="idx-CHP-82-2975"/><span class="strong"><strong>TE</strong></span> Provides information to the server about how the client wishes to deal with transfer encodings for entities sent by the server. If extensions to the standard HTTP transfer encodings are defined, the client can indicate its willingness to accept them in this header. The client can also use the header <code class="literal">TE: trailers</code> to indicate its ability to handle having headers sent as trailers following data when chunking of data is done. This is a hop-by-hop header and applies only to the immediate connection.</p><p><span class="strong"><strong>User-<a class="indexterm" id="idx-CHP-82-2976"/>Agent</strong></span> Provides information about the client software. This is normally the name and version number of the web browser or other program sending the request. It is used for server access statistic logging and also may be used to tailor how the server responds to the needs of different clients. Note that proxies do not modify this field when forwarding a request; rather, they use the Via header.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-492"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> HTTP <span class="emphasis"><em>request headers</em></span> are used only in HTTP Request <a class="indexterm" id="idx-CHP-82-2977"/>messages. They allow a client to provide information about itself to a server, provide more details about a request, and allow control over how the request is carried out.</p></div></div>
<div class="sect1" title="HTTP Response Headers"><div class="titlepage"><div><div><h1 class="title"><a id="http_response_headers"/>HTTP Response Headers</h1></div></div></div><p><a class="indexterm" id="idx-CHP-82-2978"/>The counterpart to request headers, <a class="indexterm" id="idx-CHP-82-2979"/><span class="emphasis"><em>response headers</em></span>, appear only in HTTP responses sent by servers or intermediaries. They provide additional data that expands on the summary information that is present in the status line at the beginning of each server reply. Many of the response headers are sent only in response to the receipt of specific types of requests or even to particular headers within certain requests.</p><p>There are nine response headers defined for HTTP/1.1:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2980"/>Accept-Ranges</strong></span> Tells the client whether the server accepts partial content requests using the Range request header, and if so, what type. For example, include <code class="literal">Accept-Range: bytes</code> indicates the server accepts byte ranges, and <code class="literal">Accept-Range: none</code> indicates range requests are not supported. Note that this is header is different from the other Accept- headers, which are used in HTTP requests to perform content negotiation.</p><p><span class="strong"><strong>Age</strong></span> Tells the client the approximate age of the resource, as calculated by the device sending the response.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2981"/>ETag</strong></span> Specifies the entity tag for the entity included in the response. This value can be used by the client in future requests to uniquely identify an entity, using the If-Match (or similar) request header.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2982"/>Location</strong></span> Indicates a new URL that the server is instructing the client to use in place of the one the client initially requested. This header is normally used when the server redirects a client request to a new <a class="indexterm" id="idx-CHP-82-2983"/>location, using a 301, 302, or 307 reply. It is also used to indicate the location of a created resource in a 201 (Created) response to a PUT request. Note that this is not the same as the Content-Location entity header, which is used to indicate the location of the originally requested resource.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2984"/>Proxy-Authenticate</strong></span> The proxy version of the <a class="indexterm" id="idx-CHP-82-2985"/>WWW-Authenticate header (described next). It is included in a 407 (Proxy Authentication Required) response, to indicate how the proxy is requiring the client to perform authentication. The header specifies an authentication method, as well as any other parameters needed for authentication. The client will use this to generate a new request containing a Proxy-Authorization header. This is a hop-by-hop header.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2986"/>Retry-After</strong></span> Sometimes included in unsuccessful requests—such as those resulting in a 503 (Service Unavailable) response—to tell the client when it should try its request again. It may also be used with a redirection response such as 301, 302, or 307 to indicate how long the client should wait before sending a request for the redirected URL. The <a class="indexterm" id="idx-CHP-82-2987"/>Retry-After header may specify either a time interval to wait (in seconds) or a full date/time when the <a class="indexterm" id="idx-CHP-82-2988"/>server suggests the client try again.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2989"/>Server</strong></span> The server's version of the User-Agent request header. It identifies the type and version of the server software generating the response. Note that proxies do not modify this field when forwarding a response; they put their identification information into a Via header instead.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2990"/>Vary</strong></span> Specifies which request header fields fully determine whether a cache is allowed to use this response to reply to subsequent requests for the same resource without revalidation. A caching device inspects the <a class="indexterm" id="idx-CHP-82-2991"/>Vary header to ascertain which other headers it needs to examine when the client makes its next request for the resource in this reply, to determine whether it can respond with a cached entry. (See <a class="xref" href="ch84.html" title="Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES">Chapter 84</a> for more information about caching, which should make the use of this header easier to understand.)</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2992"/>WWW-Authenticate</strong></span> Included in a 401 (Unauthorized) response to indicate how the server wants the client to authenticate. The header specifies an authentication method as well as any other parameters needed for authentication. The client will use this to generate a new request containing an Authorization header.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-493"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> HTTP <span class="emphasis"><em>response headers</em></span> appear in HTTP Response messages, where they provide additional information about HTTP server capabilities and requirements, and the results of processing a client request.</p></div></div>
<div class="sect1" title="HTTP Entity Headers"><div class="titlepage"><div><div><h1 class="title"><a id="http_entity_headers"/>HTTP Entity Headers</h1></div></div></div><p><a class="indexterm" id="idx-CHP-82-2993"/>Last, but not least, we come to the fourth group of HTTP headers: <span class="emphasis"><em>entity headers</em></span>. These headers provide information about the resource carried in the body of an HTTP message, called an <span class="emphasis"><em>entity</em></span> in the HTTP standards. They serve the overall purpose of conveying to the recipient of a message the information it needs to properly process and display the entity, such as its type and encoding method.</p><p>The most common type of entity is a file or another set of information that has been requested by a client, and for this reason, entity headers most often appear in HTTP Response messages. However, they can also appear in HTTP Request messages, especially those using the PUT and POST methods, which are the ones that transfer data from a client to a server.</p><p>At least one entity header should appear in any <a class="indexterm" id="idx-CHP-82-2994"/>HTTP message that carries an entity. However, they may also be present in certain responses that do not have an actual entity in them. Most notably, a response to a HEAD request will contain all the entity headers associated with the resource specified in the request; these are the same headers that would have been included with the entity had the GET method been used instead of the HEAD method on the same resource. Entity headers may also be present in certain error responses to provide information to help the client make a successful follow-up request.</p><div class="note" title="Note"><h3 class="title"><a id="note-179"/>Note</h3><p><span class="emphasis"><em>Many of the entity headers have the same names as certain MIME headers, but they are often used in different ways. See the topic on HTTP Internet media types in <a class="xref" href="ch83.html" title="Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management">Chapter 83</a> for a full discussion of the relationship between HTTP and MIME</em></span>.</p></div><p>There are ten entity headers defined for HTTP/1.1:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2995"/>Allow</strong></span> Lists all the methods that are supported for a particular resource. This header may be provided in a server response as a guide to the client regarding what methods it may use on the resource in the future. The header must be included when a server returns a 405 (Method Not <a class="indexterm" id="idx-CHP-82-2996"/>Allowed) response to a request containing an unsupported method.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2997"/>Content-Encoding</strong></span> Describes any optional method that may have been used to encode the entity. This header is most often used when transferring entities that have been compressed. It tells the recipient which algorithm has been used so the entity can be uncompressed. Note that this header describes only transformations performed on the entity in a message; the Transfer-Encoding header describes encodings done on the message as a whole. See the discussion of content codings and transfer codings in <a class="xref" href="ch83.html" title="Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management">Chapter 83</a> for more details.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2998"/>Content-Language</strong></span> Specifies the natural (human) language intended for using the entity. This is an optional header, and it may not be appropriate for all resource types. Multiple languages may be specified, if needed. This header is intended to provide guidance so the entity can be presented to the correct audience; thus, the language should be selected based on who would best use the material, which may not necessarily include all of the languages used in the entity. For example, a German analysis of Italian operas would probably be best tagged only with the language <span class="emphasis"><em>de</em></span>.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-2999"/>Content-Length</strong></span> Indicates the size of the entity in octets. This header is important, as it is used by the recipient to determine the end of a message. However, it may be included only in cases where the length of a message can be fully determined prior to transmitting the entity. This is not always possible in the case of dynamically generated content, which complicates message-length calculation; the discussion of data length and chunked transfer encoding in <a class="xref" href="ch83.html" title="Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management">Chapter 83</a> contains a full exploration of this issue.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-82-3000"/>Content-Location</strong></span> Specifies the resource location of the entity, in the form of an absolute or relative URL. This is an optional header, and it is normally included only in cases where the entity has been supplied from a location different from the one specified in the request. This may occur if a particular resource is stored in multiple places.</p><p><span class="strong"><strong>Content-MD5</strong></span> Contains a Message Digest 5 (MD5) digest for the entity, used for checking message integrity.</p><p><span class="strong"><strong>Content-Range</strong></span> Sent when a message contains an entity that is only part of a complete resource—for example, a fragment of a file sent in response to an HTTP GET request containing the Range header. The Content-Range header indicates which portion of the overall file this message contains, as well as the total size of the resource. This information is given as a byte range, with the first byte numbered 0. For example, if the entity contains the first 1200 bytes of a 2000-byte file, this header would have a value of 0-1199/2000.</p><p><span class="strong"><strong>Content-Type</strong></span> Specifies the media type and subtype of the entity, in a manner very similar to how this header is used in MIME. See <a class="xref" href="ch83.html" title="Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management">Chapter 83</a> for a full discussion.</p><p><span class="strong"><strong>Expires</strong></span> Specifies a date and time after which the entity in the message should be considered stale. This may be used to identify certain entities that should be held in HTTP caches for longer or shorter periods of time than usual. This header is ignored if a Cache-Control header containing the max-age directive is present in the message.</p><p><span class="strong"><strong>Last-Modified</strong></span> Indicates the date and time when the server believes the entity was last changed. This header is often used to determine if a resource has been modified since it was last retrieved. For example, suppose a client machine already contains a copy of a very large file that was obtained two months ago, and its user wants to check if an update to the file is available. The client can send a HEAD request for the file, and compare the value of the returned Last-Modified header to the date of the copy of the file it already has. Then it needs to request the entire file only if it has changed.</p><p>Note the use of the word "believes" in the preceding description of the Last-Modified header. The reason for this wording is that the server cannot always be certain of the time that a resource was modified. With files this is fairly simple—it is usually the last-modified time stored for the file by the operating system. For other more complex resources such as database records or virtual objects, however, it may be more difficult to ascertain when the last change occurred to a particular piece of information. In the case of dynamically generated content, the Last-Modified date/time may be the same as that of the message as a whole, as specified in the Date field.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-494"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> HTTP <span class="emphasis"><em>entity headers</em></span> appear in either Request or Response messages that carry an entity in the message body. They describe the nature of the entity, including its type, language, and encoding, to facilitate the proper processing and presentation of the entity by the device receiving it.</p></div></div>
<div class="chapter" title="Chapter&#xA0;83.&#xA0;HTTP Entities, Transfers, Coding Methods, and Content Management"><div class="titlepage"><div><div><h1 class="title"><a id="http_entities_transfers_coding_methods_a"/>Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e90764"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p>Hypertext Transfer Protocol (HTTP) message headers are very important, because they are the mechanism that HTTP uses to allow devices to specify the details of client requests and server responses. These headers, however, are only the means to an end, which is the transfer of resources (such as files, form input, and program output) from one device to another. When a resource is carried in the body of an HTTP message, it is called an <span class="emphasis"><em>entity</em></span>. HTTP defines special rules for how these entities are identified, encoded, and transferred.</p><p>In this chapter, I explain how HTTP handles entities. I begin with a discussion of entities in general terms and a look at how their contents are identified. This includes an examination of the relationship between HTTP and Multipurpose Internet Mail Extensions (MIME). I discuss the issues behind the transfer of entities between clients and servers, and the difference between content encodings and transfer encodings. I describe the special issues associated with identifying the length of entities in HTTP messages, and detail the special chunked transfer coding and message trailers. Finally, I describe the methods by which devices can perform content negotiation and how quality values allow clients to intelligently select different variations of a resource.</p><div class="sect1" title="HTTP Entities and Internet Media Types"><div class="titlepage"><div><div><h1 class="title"><a id="http_entities_and_internet_media_types"/>HTTP Entities and Internet Media Types</h1></div></div></div><p><a class="indexterm" id="idx-CHP-83-3001"/><a class="indexterm" id="idx-CHP-83-3002"/><a class="indexterm" id="idx-CHP-83-3003"/>The presence of the word <span class="emphasis"><em>text</em></span> in the name Hypertext Transfer Protocol is a reminder of the legacy of HTTP. As I explained in <a class="xref" href="ch80.html" title="Chapter 80. HTTP GENERAL OPERATION AND CONNECTIONS">Chapter 80</a>, HTTP was originally created to allow text documents to be linked together. This made sense, because at the time that the Web was being created, most computing was being done with text. Accordingly, the first version of HTTP (HTTP/0.9) supported only one type of message body: a plain ASCII text document.</p><p>In the early 1990s, the rapid increase in computing power and networking performance transformed the world of information technology from text to multimedia. These were also the Web's formative years, and it did not take long before many users wanted to exploit the power of the Web to share not only text files, but also pictures, drawings, sound clips, movies, and much more. Thus, HTTP had to evolve as well. Starting with HTTP/1.0, the protocol's developers made significant changes to allow HTTP to transport and process much more than just text. Today, HTTP really would be better described as dealing with <a class="indexterm" id="idx-CHP-83-3004"/><span class="emphasis"><em>hypermedia</em></span> than <span class="emphasis"><em>hypertext</em></span>.</p><p>One drawback of supporting many types of files in HTTP is added complexity. Previously, every message recipient knew the body contained ASCII text; now any message can contain any of many kinds of data. When HTTP was expanded to support flexible media, it needed a system that would address two specific issues: encoding entities of various types into an HTTP message body and clearly identifying the entity's characteristics for the recipient of the message.</p><p>At the same time that HTTP was being changed to support nontext entities, another important TCP/IP application was also moving away from its decades-long role as a text-messaging medium to one that could transport multimedia: electronic mail (email). This was accomplished using a technology called MIME (introduced in <a class="xref" href="ch76.html" title="Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME">Chapter 76</a>), which define a mechanism for encoding and identifying nontext data—exactly what HTTP needed to do. Since TCP/IP developers wisely reuse technologies that work, the creators of HTTP borrowed many concepts from MIME, including many of the MIME email headers that are used to identify the contents of a MIME message.</p><div class="sect2" title="Media Types and Subtypes"><div class="titlepage"><div><div><h2 class="title"><a id="media_types_and_subtypes"/>Media Types and Subtypes</h2></div></div></div><p><a class="indexterm" id="idx-CHP-83-3005"/>The most important concept that HTTP adopted from MIME was the use of standardized <a class="indexterm" id="idx-CHP-83-3006"/>Internet media types, which describe the contents of an HTTP entity. The formal syntax of an HTTP media type is the same as that used in MIME:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>&lt;<span class="emphasis"><em>type</em></span>&gt;/&lt;<span class="emphasis"><em>subtype</em></span>&gt; [; <span class="emphasis"><em>parameter1</em></span> ; <span class="emphasis"><em>parameter2</em></span> … ; <span class="emphasis"><em>parameterN</em></span> ]</td></tr></table><p>Each media type consists of a top-level media type that defines its general nature and a more specific subtype that indicates its form or structure. For example, text documents use the top-level media type <code class="literal">text</code>, with subtypes such as <code class="literal">plain</code> for regular unformatted text and <code class="literal">html</code> for HTML documents. So, an HTML document of the type commonly transported using HTTP will be identified with a media type of <code class="literal">text/html</code>. Similarly, <code class="literal">image</code> is a top-level media type, with subtypes such as <code class="literal">jpeg</code>, <code class="literal">gif</code>, and <code class="literal">tiff</code>. Photographs usually are identified as <code class="literal">image/jpeg</code>, while line drawings are often seen as <code class="literal">image/gif</code>. Additional parameters may also be supplied to provide more information to help a recipient interpret the entity.</p></div><div class="sect2" title="HTTP's Use of Media Types"><div class="titlepage"><div><div><h2 class="title"><a id="https_use_of_media_types"/>HTTP's Use of Media Types</h2></div></div></div><p>In HTTP, media types are most often seen in a special Content-Type entity header, which is present in any HTTP message that carries an entity. This header uses the same format as the header of the same name in <a class="indexterm" id="idx-CHP-83-3007"/>MIME:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>Content-Type: &lt;<span class="emphasis"><em>type</em></span>&gt;/&lt;<span class="emphasis"><em>subtype</em></span>&gt; [; <span class="emphasis"><em>parameter1</em></span> ; <span class="emphasis"><em>parameter2</em></span> … ; <span class="emphasis"><em>parameterN</em></span> ]</td></tr></table><div class="tip" title="Tip"><h3 class="title"><a id="tip-495"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>I provide a more complete description of both the Content-Type header and Internet media types, including a description of many types and subtypes, in <a class="xref" href="ch76.html" title="Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME">Chapter 76</a>. HTTP can also support composite media types, such as the multipart media type</em></span>.</p></div><p>The other place where media types are used in HTTP is in the Accept request header, which may appear in an HTTP request sent by a client. If present, the purpose of this header is to tell the server what sorts of media types the client can handle, so the server will not send a response that cannot be processed. For example, if a client can process only text documents, it might send a request specifying this in an Accept header. This is part of the overall content negotiation process supported by HTTP, which I describe in the "HTTP Content Negotiation and Quality Values" section later in this chapter.</p><p>When a media type is specified in an Accept header, either the subtype or both the type and subtype can be replaced by the asterisk (*) wildcard to represent any acceptable type. For example, in an Accept header, the specification <code class="literal">text/html</code> refers to an HTML document, while <code class="literal">text/*</code> means any text type. The string <code class="literal">*/*</code> means any type of media; this is usually used in combination with a <code class="literal">q</code> value, as explained in the discussion of the HTTP content negotiation process later in this chapter.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-496"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> While HTTP is most often associated with hypertext, its messages can transport a large variety of different types of files, including images, audio, video, and much more. To indicate the type of entity contained in an HTTP message, its sender must identify its media <span class="emphasis"><em>type</em></span> and <span class="emphasis"><em>subtype</em></span>. This is done using the HTTP Content-Type header, which was borrowed from the Multipurpose Internet Mail Extensions (MIME) specification.</p></div></div><div class="sect2" title="Differences in HTTP and MIME Constructs"><div class="titlepage"><div><div><h2 class="title"><a id="differences_in_http_and_mime_constructs"/>Differences in HTTP and MIME Constructs</h2></div></div></div><p><a class="indexterm" id="idx-CHP-83-3008"/>In addition to media types, HTTP also borrows from MIME in several other ways, such as MIME's notion of content codings and the use of a header to indicate the length of an entity. It's important to recognize, however, that even though HTTP's handling of Internet media is very similar to that of MIME, it is not identical. In fact, there was an early proposal that HTTP use MIME exactly as defined, but HTTP's developers specifically decided not to do this. We will explore a possible reason why HTTP is not strictly MIME-compliant in the next section.</p><p>The bottom line is that HTTP's developers chose to adopt concepts from MIME that made sense and to leave other parts out. As a result, HTTP messages are not MIME-compliant, even though you may see several headers in HTTP messages starting with MIME's Content- prefix. For example, even though HTTP has a Content-Encoding header, its use is quite different from that of MIME's. The fact that HTTP does not use the MIME-Version header that is required in MIME messages confirms the difference between HTTP and MIME.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-497"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Even though HTTP borrows several concepts and header types from MIME, the protocol is not MIME-compliant.</p></div></div></div></div>
<div class="sect1" title="HTTP Content and Transfer Encodings"><div class="titlepage"><div><div><h1 class="title"><a id="http_content_and_transfer_encodings"/>HTTP Content and Transfer Encodings</h1></div></div></div><p><a class="indexterm" id="idx-CHP-83-3009"/>Two specific issues that HTTP must address in order to carry a wide variety of media types in its messages are encoding the data and identifying its type and characteristics. HTTP borrows from MIME the notion of media types and the Content-Type header to handle type identification, as explained in the previous section. It similarly borrows concepts and headers from MIME to deal with the encoding issue. Here, however, we run into some of the important differences between HTTP and MIME.</p><p>Encoding was a significant issue for MIME, because it was created for the specific purpose of sending nontext data using the old RFC 822 email message standard (discussed in <a class="xref" href="ch76.html" title="Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME">Chapter 76</a>). RFC 822 imposes several significant restrictions on the messages it carries, the most important of which is that data must be encoded using 7-bit ASCII. RFC 822 messages are also limited to lines of no more than 1,000 characters that end in a carriage return/line feed (CRLF) sequence.</p><p>These limitations mean that arbitrary binary files, which have no concept of lines and consist of bytes that can each contain a value from 0 to 255, cannot be sent using RFC 822 in their native format. In order for MIME to transfer binary files, they must be encoded using a method such as base64 (described in <a class="xref" href="ch76.html" title="Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME">Chapter 76</a>), which converts three 8-bit characters to a set of four 6-bit characters that can be represented in ASCII. When this sort of transformation is done, the MIME Content-Transfer-Encoding header is included in the message, so the recipient can reverse the encoding to return the data to its normal form. Although this technique works, it is less efficient than sending the data directly in binary, because base64 encoding increases the size of the message by 33 percent (three bytes are encoded using four ASCII characters, each of which takes one byte to transmit).</p><p>HTTP messages are transmitted directly between the client and server over a Transmission Control Protocol (TCP) connection, and they do not use the RFC 822 standard. Thus, binary data can be sent between HTTP clients and servers without the need for base64 encoding or other transformation techniques. Since it is more efficient to send the data unencoded, this may be one reason why HTTP's developers decided not to make the protocol strictly MIME-compliant.</p><div class="sect2" title="HTTP's Two-Level Encoding Scheme"><div class="titlepage"><div><div><h2 class="title"><a id="https_two-level_encoding_scheme"/>HTTP's Two-Level Encoding Scheme</h2></div></div></div><p>So, <a class="indexterm" id="idx-CHP-83-3010"/>encoding would seem to be an area where <a class="indexterm" id="idx-CHP-83-3011"/>HTTP is simpler than MIME. There is no need to encode the entity, and thus no need for the Content-Transfer-<a class="indexterm" id="idx-CHP-83-3012"/>Encoding header, so we have one less thing to worry about. It is true that HTTP could have been designed so that all entities were just sent one byte at a time with no need to specify <a class="indexterm" id="idx-CHP-83-3013"/>encodings, but the developers of the protocol recognized that this would have made the protocol inflexible. There are situations where it might be useful to transform or encode an entity or message for transmission, and then reverse the operation on receipt.</p><p>This effort to make HTTP flexible resulted in a system of representing <a class="indexterm" id="idx-CHP-83-3014"/>encodings that is actually more complicated than MIME's! The key to understanding it is to recognize that HTTP/1.1 actually splits MIME's notion of content transfer encoding into two different encoding levels:</p><p><span class="strong"><strong>Content Encoding</strong></span> This encoding is applied specifically to the entity carried in an HTTP message, to prepare or package it prior to transmission. Content encodings are said to be <span class="emphasis"><em>end-to-end,</em></span> because the encoding of the entity is done once before it sent by the client or server, and decoded only on receipt by the ultimate recipient: server or client. When this type of encoding is done, the method is identified in the special Content-Encoding entity header. A client may also specify which content encodings it can handle, using the Accept-Encoding header, as you will see in the section on content negotiation later in this chapter.</p><p><span class="strong"><strong>Transfer Encoding</strong></span> This encoding is done specifically for the purpose of ensuring that data can be safely transferred between devices. It is applied across an entire HTTP message and not specifically to the entity. This type of encoding is <span class="emphasis"><em>hop-by-hop</em></span>, because a different transfer encoding may be used for each hop of a message that is transmitted through many intermediaries in the request/response chain. The transfer encoding method, if any, is indicated in the Transfer-Encoding general header.</p></div><div class="sect2" title="Use of Content and Transfer Encodings"><div class="titlepage"><div><div><h2 class="title"><a id="use_of_content_and_transfer_encodings"/>Use of Content and Transfer Encodings</h2></div></div></div><p>Since the content and transfer encodings are applied at different levels, it is possible for both to be used at the same time. A content encoding may be applied to an entity and then placed into a message. On some or all of the hops that are used to move the message containing that entity, a transfer encoding may be applied to the entire message (including the entity). The transfer encoding is removed first, and then the content encoding is removed.</p><p>So, what are these types of encodings used for in practice? The answer is not a great deal. The HTTP standard defines a small number of content and transfer encodings, and specifies that additional methods may be registered with the Internet Assigned Numbers Authority (IANA). Currently, only the ones defined in the HTTP/1.1 standard are in use.</p><p>Content encodings are used only to implement compression. This is a good example of an encoding that, while not strictly necessary, can be useful since it improves performance dramatically for some types of data. RFC 2616 defines three different encoding algorithms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">gzip</code>, which is the compression used by the UNIX <code class="literal">gzip</code> program, described in RFC 1952</p></li><li class="listitem"><p><code class="literal">compress</code>, which also represents the compression method used by the UNIX program of that name</p></li><li class="listitem"><p><code class="literal">deflate</code>, which is a method defined in RFCs 1950 and 1951</p></li></ul></div><div class="note" title="Note"><h3 class="title"><a id="note-180"/>Note</h3><p><span class="emphasis"><em>It is also possible to apply compression to an entire HTTP message as a transfer encoding. Obviously, if the entity is already compressed using content encoding, this will result in some duplication of effort. Since the size of HTTP headers is not that large compared to some entities that HTTP messages carry, it is usually simpler just to compress the entity using content encoding</em></span>.</p></div><p>Since transfer encodings are intended to be used to make data safe for transfer, and we've already discussed the fact that HTTP can handle arbitrary binary data, this suggests that transfer encodings are not really necessary. However, there is one situation where safe transport does become an issue: the matter of identifying the end of a message. This issue is the subject of the next section.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-498"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> HTTP supports two levels of codings for data transfer. The first is <span class="emphasis"><em>content encoding</em></span>, which is used in certain circumstances to transform the entity carried in an HTTP message. The second is <span class="emphasis"><em>transfer encoding</em></span>, which is used to encode an entire HTTP message to ensure its safe transport. Content encodings are often employed when entities are compressed to improve communication efficiency. Transfer encoding is used primarily to deal with the problem of identifying the end of a message.</p></div></div></div>
<div class="sect1" title="HTTP Data Length Issues, Chunked Transfers, and Message Trailers"><div class="titlepage"><div><div><h1 class="title"><a id="http_data_length_issues_chunked_transfer"/>HTTP Data Length Issues, Chunked Transfers, and Message Trailers</h1></div></div></div><p><a class="indexterm" id="idx-CHP-83-3015"/>As you've learned, two different levels of encodings are used in HTTP: <span class="emphasis"><em>content encodings</em></span>, which are applied to HTTP entities, and <span class="emphasis"><em>transfer encodings</em></span>, which are used over entire HTTP messages. Content encodings are used for convenience to package entities for transmission. Transfer encodings are hop-specific, and they are intended for use in situations where data needs to be made safe for transfer.</p><p>However, we've already seen that HTTP can transport arbitrary binary data, so unlike the situation where MIME needed to make binary data safe (as defined in RFC 822), this is not an issue with HTTP. Therefore, why are transport encodings needed at all? In theory, they are not, and HTTP/1.0 did not even have a Transfer-Encoding header (though it did use content encodings). The concept of transfer encoding became important in HTTP/1.1 due to another key feature of that version of HTTP: persistent connections (described in <a class="xref" href="ch80.html" title="Chapter 80. HTTP GENERAL OPERATION AND CONNECTIONS">Chapter 80</a>).</p><div class="sect2" title="Dynamic Data Length"><div class="titlepage"><div><div><h2 class="title"><a id="dynamic_data_length"/>Dynamic Data Length</h2></div></div></div><p>Recall that HTTP uses TCP for connections. One of the key characteristics of TCP is that it transmits all data as a stream of unstructured bytes (see <a class="xref" href="ch46.html" title="Chapter 46. TRANSMISSION CONTROL PROTOCOL (TCP) FUNDAMENTALS AND GENERAL OPERATION">Chapter 46</a>). TCP itself does not provide any way of differentiating between the end of one piece of data and the start of the next; this is left up to each application. In HTTP/1.0 (and HTTP/0.9), this was not a problem, because those versions used only transitory connections. Each HTTP session consisted of only one request and one response. Since the client and server each sent only one piece of data, there was no need to worry about differentiating HTTP messages on a connection.</p><p>HTTP/1.1's persistent connections improve performance by letting devices send requests and responses one after the other over a single TCP connection. However, the fact that messages are sent in sequence makes differentiating them a concern. There are two usual approaches to dealing with this sort of data length issue: using an explicit delimiter to mark the end of the message, or including a length header or field to tell the recipient how long each message is. The first approach could not really have been done easily while maintaining compatibility with older versions of the protocol. This left the second approach. Since HTTP already had a Content-Length entity header, the solution was to use this to indicate the length of each message at transmission time.</p><p>Using the Content-Length header works fine in cases where the size of the entity to be transferred is known in advance, such as when transmitting a text document, an image, or an executable program needs. However, there are many types of resources that are generated <a class="indexterm" id="idx-CHP-83-3016"/>dynamically. In those cases, the total size of such a resource is not known until it has been completely processed.</p><p>While not typical in HTTP's early days, dynamic resources account for a large percentage of Web traffic today. Many web pages are often not static Hypertext Markup Language (HTML) files, but instead are created as output from scripts or programs based on user input; discussion forums are a good example. Even modern HTML files are often not static. They usually contain program elements such as <span class="emphasis"><em>server-side includes (SSIs)</em></span> that cause code to be generated on the fly, so their exact size cannot be determined in advance.</p><p>The problem of unknown message length could be resolved by buffering the entire resource before transmission. However, this would be wasteful of server memory and would delay the transmission of the entity unnecessarily, since no part could be sent until the entire entity was ready. Instead, a special transfer encoding method was developed to handle the particular problem of not knowing the length of a file. The method is called <span class="emphasis"><em>chunking</em></span>.</p></div><div class="sect2" title="Chunked Transfers and Message Trailers"><div class="titlepage"><div><div><h2 class="title"><a id="chunked_transfers_and_message_trailers"/>Chunked Transfers and Message Trailers</h2></div></div></div><p><a class="indexterm" id="idx-CHP-83-3017"/><a class="indexterm" id="idx-CHP-83-3018"/>When the chunking technique is used, instead of sending an entity as a raw sequence of bytes, it is broken into, well, chunks. This allows HTTP to send a dynamically generated resource, such as output from a script, a piece at a time as the data becomes available from the software processing it. To indicate that this method has been used, the special header <code class="literal">Transfer-Encoding: chunked</code> is placed in the message. A special format is also used for the body of the HTTP message to delineate the chunks:</p><table border="0" class="simplelist" summary="Simple list"><tr><td>&lt;<span class="emphasis"><em>chunk-1-length</em></span>&gt;</td></tr><tr><td>&lt;<span class="emphasis"><em>chunk-1-data</em></span>&gt;</td></tr><tr><td>&lt;<span class="emphasis"><em>chunk-2-length</em></span>&gt;</td></tr><tr><td>&lt;<span class="emphasis"><em>chunk-2-data</em></span>&gt;</td></tr><tr><td>…</td></tr><tr><td>0</td></tr><tr><td>&lt;<span class="emphasis"><em>message-trailers</em></span>&gt;</td></tr></table><p>Basically, instead of putting the whole entity in the body and indicating its length in a Content-Length header, each chunk is placed in the body sequentially, each preceded by the length of the chunk. The length is specified in hexadecimal and represented using ASCII characters. All chunk lengths and chunk data are terminated with a CRLF sequence. The recipient knows it has received the last chunk when it sees a chunk length of zero.</p><div class="note" title="Note"><h3 class="title"><a id="note-181"/>Note</h3><p><span class="emphasis"><em>An HTTP/1.1 client can specify that it does not want to use persistent connections by including the</em></span> <code class="literal">Connection: close</code> <span class="emphasis"><em>header in its request. In this case, the server does not have to use chunking in its response. Since the server will close the connection after the first response message, the client knows that everything it receives from the server is part of that response. However, some servers may use chunked transfers anyway, even in this situation</em></span>.</p></div><p>When chunked transfer encoding is used, the sender of the message may also choose to specify one or more <span class="emphasis"><em>message trailers</em></span>. These are the same as entity headers, describing the contents of the message body, but appear <span class="emphasis"><em>after</em></span> the entity, rather than <span class="emphasis"><em>before</em></span> it. Message trailers provide flexibility in the same way that chunking itself does: They allow a device to include an HTTP header that may contain information that was not available when the HTTP message transmission began. A good example would be an integrity check field calculated based on the byte values of the entire entity.</p><p>Trailers are optional, and they will not always be needed. When they are used, they are processed just like regular entity headers. To give the recipient of a message a "heads up" that trailers have been used, the special Trailer header is included at the start of the message, which lists the names of each header that appears as a trailer.</p><p>Yes, I really did say that headers can actually be trailers, in which case, a header called Trailer lists each header that is actually a trailer. An example will help clarify matters somewhat. Suppose we have a server that contains a program that, when supplied with a filename, returns a simple HTML response that contains the size and last modification date of the file. This is obviously dynamic content, so the length of the response cannot be determined in advance. If the server were to buffer the entire output of this program (since it is small), it could construct a conventional HTTP response using the Content-Length header, as shown in the sample output of <a class="xref" href="ch83s03.html#example_of_an_http_response_using_a_cont" title="Example 83-1. Example of an HTTP Response using a Content-Length header">Example 83-1</a>.</p><div class="example"><a id="example_of_an_http_response_using_a_cont"/><p class="title">Example 83-1. Example of an HTTP Response using a Content-Length header</p><div class="example-contents"><pre class="programlisting">HTTP/1.1 200 OK
Date: Tue, 22 Mar 2005 11:15:03 GMT
Content-Type: text/html
Content-Length: 129
Expires: Sun, 27 Mar 2005 21:12:00 GMT

&lt;html&gt;&lt;body&gt;&lt;p&gt;The file you requested is 3,400 bytes long and was last modified:
Sun, 20 Mar 2005 21:12:00 GMT.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</pre></div></div><p>Using chunking instead allows the server to send out parts of the response as soon as they become available from the program. The equivalent output of the example shown in <a class="xref" href="ch83s03.html#example_of_an_http_response_using_a_cont" title="Example 83-1. Example of an HTTP Response using a Content-Length header">Example 83-1</a> using chunked transfers is shown in <a class="xref" href="ch83s03.html#example_of_an_http_response_using_chunke" title="Example 83-2. Example of an HTTP Response using chunked transfer encoding">Example 83-2</a>.</p><div class="example"><a id="example_of_an_http_response_using_chunke"/><p class="title">Example 83-2. Example of an HTTP Response using chunked transfer encoding</p><div class="example-contents"><pre class="programlisting">HTTP/1.1 200 OK
Date: Tue, 22 Mar 2005 11:15:03 GMT
Content-Type: text/html
Transfer-Encoding: chunked
Trailer: Expires

29
&lt;html&gt;&lt;body&gt;&lt;p&gt;The file you requested is
5
3,400
23
 bytes long and was last modified:
1d
Sun, 20 Mar 2005 21:12:00 GMT
13
.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
0
Expires: Sun, 27 Mar 2005 21:12:00 GMT</pre></div></div><p>In <a class="xref" href="ch83s03.html#example_of_an_http_response_using_chunke" title="Example 83-2. Example of an HTTP Response using chunked transfer encoding">Example 83-2</a>, notice that the Expires header is now a trailer, so it can be calculated based on the output of the program, and this is indicated by the Trailer: Expires header. Remember that the Content-Length header specifies the length as a decimal number while chunking specifies chunk lengths in hexadecimal; the chunks in this example are 41, 5, 35, 29, and 19 decimal bytes, respectively.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-499"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Since HTTP/1.1 uses persistent connections that allow multiple requests and responses to be sent over a TCP connection, clients and servers need some way to identify where one message ends and the next begins. The easier solution is to use the Content-Length header to indicate the size of a message, but this works only when the length of a message can be determined in advance. For dynamic content or other cases where message length cannot be easily computed before sending the data, the special <span class="emphasis"><em>chunked</em></span> transfer encoding can be used, where the message body is sent as a sequence of chunks, each preceded by the length of the chunk. When chunked transfer encoding is used, the sender of the message may move certain headers from the start of the message to the end, where they are known as <span class="emphasis"><em>trailers</em></span>. Trailers are interpreted in the same way as normal headers by the recipient. The special Trailer header is used in such messages to tell the recipient to look for trailers after the body of the message.</p></div></div></div>
<div class="sect1" title="HTTP Content Negotiation and Quality Values"><div class="titlepage"><div><div><h1 class="title"><a id="http_content_negotiation_and_quality_val"/>HTTP Content Negotiation and Quality Values</h1></div></div></div><p>Many Internet resources have only one representation, meaning a single way in which they are stored or made available. In this situation, a client request to a server is an all-or-nothing proposition. The client may specify conditions under which it would like the server to send the resource, using the If- series of request headers described in the previous chapter. If the condition is met, the resource will be sent in the server's response in the one form in which it exists; if the condition is not met, no entity will be returned.</p><p>Other resources, however, may have multiple representations. The most common example is a document that is available in multiple languages, or one that is stored using more than one character set. Similarly, a graphical image might exist in two different formats: a Tagged Image File Format (TIFF) file, for those who want maximum image <a class="indexterm" id="idx-CHP-83-3019"/>quality despite the large size of TIFF images, and a more compact JPEG file, for those who need to see the image quickly and don't care as much about its quality level.</p><p>To provide flexibility in allowing clients to obtain the best version of resources that exist in multiple forms, HTTP/1.1 defines a set of features that are collectively called <a class="indexterm" id="idx-CHP-83-3020"/><span class="emphasis"><em>content negotiation</em></span>.</p><div class="sect2" title="Content Negotiation Techniques"><div class="titlepage"><div><div><h2 class="title"><a id="content_negotiation_techniques"/>Content Negotiation Techniques</h2></div></div></div><p><a class="indexterm" id="idx-CHP-83-3021"/>The HTTP/1.1 standard defines two basic methods by which this negotiation may be performed.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-83-3022"/>Server-Driven Negotiation</strong></span> In this technique, the client includes headers in its request that provide guidance to the server about its desired representation for the resource. The server uses an algorithm that processes this information and provides the version of the resource that it feels best matches the client's preferences.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-83-3023"/>Agent-Driven Negotiation</strong></span> This method puts the client in charge of the negotiation process. It first sends a preliminary request for the resource to the server. If the resource is available in multiple forms, the server typically sends back a 300 (Multiple Choices) response, which contains a list of the various representations in which the resource is available. The client then sends a second request for the one that it prefers.</p><p>To draw an analogy, suppose a co-worker offers to go out at lunchtime to pick up lunch for the two of you. He is going to a new restaurant, where neither of you have eaten before. You could provide him with some parameters regarding what you like to eat—"I like roast beef sandwiches, fish and chips, and pizza, but not chicken"—and then trust him to pick something you will like. Alternatively, he could go to the restaurant, call you on his cell phone, read the menu to you, and let you make a selection. This former approach is like server-driven negotiation; the latter is like agent-driven negotiation.</p><p>This analogy not only points out the differences between the two methods, but it also highlights the key advantages and disadvantages of each. Trusting your co-worker with your lunch selection is simple and efficient, but not foolproof. It's possible that the restaurant may not have any of the items you specified, or that your friend may get you something containing another ingredient that you don't like but forgot to mention. Similarly, server-based negotiation is a best-guess process that does not guarantee that the client will receive the resource in the format it wants. This is exacerbated by the fact that there are only so many ways for the client to specify its preferences using a handful of request headers.</p><p>Agent-based negotiation, on the other hand, allows the client to select exactly what it wants from the available choices, just as you can choose your favorite dish from the menu of the restaurant. The problem here is that it is inefficient, because two requests and responses are required for each resource access. (Would you really want to read a restaurant's menu over the phone to someone so he could choose his ideal dish?)</p><p>In practice, server-based negotiation is the type that is most commonly used today. The client specifies its preferences using a set of four request headers that indicate what it would prefer in the representation of the resource. The headers each represents one characteristic of a resource: Accept (media type), Accept-Charset (character set), Accept-Encoding (content encoding), and Accept-Language (resource language). Any or all of these may be included in the request. Each Accept- header contains a list of acceptable values that is appropriate to the characteristic that it specifies, separated by a comma. For example, the Accept header lists media types the client considers acceptable, and Accept-Language contains language tags.</p><p>For example, suppose you have a friend who is trilingual in English, French, and Spanish. She can read a particular document in any of these languages, so she might instruct her browser to include the following header in her requests:</p><a id="I_programlisting5_d1e91272"/><pre class="programlisting">Accept-Language: en, fr, sp</pre><div class="tip" title="Tip"><h3 class="title"><a id="tip-500"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> HTTP includes a feature called <span class="emphasis"><em>content negotiation</em></span> that allows the selection of a particular variation of a resource that has more than one representation. There are two negotiation techniques: <span class="emphasis"><em>server-driven</em></span>, where the client includes headers in its request that indicate what it wants and the server does its best to select the most appropriate variant, and <span class="emphasis"><em>agent-driven</em></span>, where the server sends the client a list of the available resource alternatives and the client chooses one.</p></div></div><div class="sect2" title="Quality Values for Preference Weights"><div class="titlepage"><div><div><h2 class="title"><a id="quality_values_for_preference_weights"/>Quality Values for Preference Weights</h2></div></div></div><p>To improve the results of server-driven negotiation, HTTP allows the client to <span class="emphasis"><em>weight</em></span> each of the items in such a list, to indicate which is preferred of the alternatives. The client specifies weights by adding a decimal <span class="emphasis"><em>quality value</em></span> after each parameter using the syntax <code class="literal">q=</code>&lt;<em class="replaceable"><code>value</code></em>&gt;, which represents the relative priority of that parameter relative to others. The highest priority is 1, and the lowest priority is 0. The default if no value is indicated is 1. A value of 0 means that the client will not accept documents with that characteristic.</p><p>For example, suppose your trilingual friend knows English, French, and Spanish, but her French is a bit rusty. Furthermore, she may need to share the document she is requesting with a friend of hers who knows only a little Spanish, so it would be best if she got the document in English. Finally, she knows there is a German version of the resource that she definitely does not want. This could be represented as follows:</p><a id="I_programlisting5_d1e91307"/><pre class="programlisting">Accept-Language: en, fr;q=0.3, sp;q=0.7, de;q=0</pre><p>Translated to English, this means, "I would prefer if you sent me the document in English. If not, Spanish is okay, or French if that is all you have, but definitely don't send it to me in German."</p><p>Incidentally, the name <span class="emphasis"><em>quality value</em></span> is the one used in the HTTP standard, but it is really a poor choice of terminology (a point which, to be fair, is also mentioned in the standard). These values do not have anything to do with quality; for all we know, the German version of this document may be the original and the others could be lousy translations. The <code class="literal">q</code> values specify only the relative preference of the client making the request.</p><p>Finally, the asterisk (*) wildcard can be used in the Accept family of headers to represent any value or everything else. This is often used to tell the server, "If you can't find what I specifically asked for, then here are my preferences for the alternatives." Let's take an example using the Accept header:</p><a id="I_programlisting5_d1e91321"/><pre class="programlisting">Accept: text/html, text/*;q=0.6, */*;q=0.1</pre><p>This header represents the client saying, "My preference (<code class="literal">q=1</code>, the default since no <code class="literal">q</code> value is indicated) is an HTML text document. If not available, I would prefer some other type of text document. Failing that, you may send me any other type of document relevant to the requested resource."</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-501"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Server-driven content negotiation is the type most often used in HTTP. A client sending a request can include up to four different headers that provide information about how the server should fill its request. These may include optional <span class="emphasis"><em>quality</em></span> values that specify the client's relative preference among a set of alternative resource characteristics such as media type, language, character set, and encoding.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;84.&#xA0;HTTP FEATURES, CAPABILITIES, AND ISSUES"><div class="titlepage"><div><div><h1 class="title"><a id="http_features_capabilities_and_issues"/>Chapter 84. HTTP FEATURES, CAPABILITIES, AND ISSUES</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e91344"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p>The previous chapters covered the fundamental concepts and basic operation of the Hypertext Transfer Protocol (HTTP). Modern HTTP, however, goes beyond the simple mechanics by which HTTP requests and responses are exchanged. It includes a number of <a class="indexterm" id="idx-CHP-84-3024"/>features and capabilities that extend the basic protocol to improve performance and meet the various needs of organizations using modern TCP/IP internetworks.</p><p>In this chapter, I complete my description of HTTP by discussing several important matters that are essential to the operation of the modern World Wide Web. I begin with an overview of HTTP caching, which is the single most important feature that promotes efficiency in web transactions. I discuss the different uses of proxies in HTTP and some of the issues associated with them. I briefly examine the issues related to security and privacy in HTTP and conclude with a discussion of the matter of state management and how it is implemented despite HTTP being an inherently stateless protocol.</p><div class="sect1" title="HTTP Caching Features and Issues"><div class="titlepage"><div><div><h1 class="title"><a id="http_caching_features_and_issues"/>HTTP Caching Features and Issues</h1></div></div></div><p>The explosive growth of the Web was a marvel for its users but a nightmare for networking engineers. The biggest problem that the burgeoning Web created was an overloading of the internetworks over which it ran. Many of the features that were added to HTTP/1.1 were designed specifically to improve the efficiency of the protocol and reduce unnecessary bandwidth consumed by HTTP requests and responses. Arguably, the most important of these is a set of features designed to support <span class="emphasis"><em>caching</em></span>.</p><p>The subject of caching comes up again and again in discussions of computers and networking, because of a phenomenon that is widely observed in these technologies: Whenever a user, hardware device, or software process requests a particular piece of data, there is a good chance it will ask for that same data again in the near future. Thus, by storing recently retrieved items in a cache, we can eliminate duplicated effort. This is the reason that caching plays an important role in the efficiency of protocols such as the Address Resolution Protocol (ARP) and the Domain Name System (DNS).</p><div class="sect2" title="Benefits of HTTP Caching"><div class="titlepage"><div><div><h2 class="title"><a id="benefits_of_http_caching"/>Benefits of HTTP Caching</h2></div></div></div><p><a class="indexterm" id="idx-CHP-84-3025"/>Caching is important to HTTP because Web users tend to request the same documents over and over again. For example, in writing this section on HTTP, I made reference to RFC 2616 many, many times. Each time, I loaded it from a particular web server. Since the document never changes, it would have been more efficient to just load it from a local cache rather than needing to retrieve it from the distant web server each time.</p><p>However, caching is even more essential to HTTP than to most other protocols or technologies where it used. The reason is that web documents tend to be structured so that a request for one resource leads to a request for many others. Even if you load a number of <span class="emphasis"><em>different</em></span> documents, they may each refer to common elements that do not change between your requests. Thus, caching can be of benefit in HTTP even if a user never asks for the same document twice, or if a single document changes over time so that caching the document itself would be of little value.</p><p>For example, suppose that each morning, you load CNN's website to see what is going on in the world. Obviously, the headlines will be different every day, so caching of the main CCN.com home page won't be of much value. However, many of the graphical elements on the page (CNN's logo, dividing bars, perhaps a "breaking news" graphic, and so on) will be the same every day, and these can be cached. Another example would be a set of discussion forums on a website. As you load different topics to read, each one is different, but they have common elements (such as icons and other images) that would be wasteful to need to retrieve over and over again.</p><p>Caching in HTTP yields two main benefits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Reduced bandwidth use, by eliminating unneeded transfers of requests and responses</p></li><li class="listitem"><p>Faster response time for the user loading a resource</p></li></ul></div><p>Consider that on many web pages today, the image files are much larger than the HTML page that references them. Caching these graphics will allow the entire page to load far more quickly. <a class="xref" href="ch84.html#impact_of_caching_on_the_http_requestres" title="Figure 84-1. Impact of caching on the HTTP request/response chain This diagram illustrates the impact of caching on the request/response chain of (see Figure 80-2 in Chapter 80). In this example, intermediary 2 is able to satisfy the client's request from its cache. This short-circuits the communication chain after two transfers, which means the client gets its resource more quickly, and the HTTP server is spared the need to process the client's request.">Figure 84-1</a> illustrates how caching reduces bandwidth and speeds up resource retrieval by short-circuiting the request/response chain.</p><div class="figure"><a id="impact_of_caching_on_the_http_requestres"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e91405"/><img alt="Impact of caching on the HTTP request/response chain This diagram illustrates the impact of caching on the request/response chain of (see in ). In this example, intermediary 2 is able to satisfy the client's request from its cache. This short-circuits the communication chain after two transfers, which means the client gets its resource more quickly, and the HTTP server is spared the need to process the client's request." src="httpatomoreillycomsourcenostarchimages288315.png.jpg"/></div></div><p class="title">Figure 84-1. Impact of caching on the HTTP request/response chain This diagram illustrates the impact of caching on the request/response chain of (see <a class="xref" href="ch80s02.html#http_requestresponse_chain_using_interme" title="Figure 80-2. HTTP request/response chain using intermediaries Instead of being connected directly, an HTTP client and server may be linked using one or more intermediary devices such as proxies. In this example, two intermediaries are present. The HTTP Request message sent by the client will actually be transferred three times: from the client to the first intermediary, then to the second, and finally to the server. The HTTP Response message will be created once but transmitted three distinct times. The full set of devices participating in the message exchange is called the request/response chain.">Figure 80-2</a> in <a class="xref" href="ch80.html" title="Chapter 80. HTTP GENERAL OPERATION AND CONNECTIONS">Chapter 80</a>). In this example, intermediary 2 is able to satisfy the client's request from its cache. This short-circuits the communication chain after two transfers, which means the client gets its resource more quickly, and the HTTP server is spared the need to process the client's request.</p></div><p>The obvious advantages of caching have made it a part of the Web since pretty much the beginning. However, it was not until HTTP/1.1 that the importance of caching was really recognized in the protocol itself, and many features were added to support it. Where the HTTP/1.0 standard makes passing mention of caching and some of the issues related to it, HTTP/1.1 devotes 26 full pages to caching (more than 20 percent of the main body of the document!).</p></div><div class="sect2" title="Cache Locations"><div class="titlepage"><div><div><h2 class="title"><a id="cache_locations"/>Cache Locations</h2></div></div></div><p><a class="indexterm" id="idx-CHP-84-3026"/>HTTP caching can be implemented in a variety of places in the request/response chain. The choice of location involves the fundamental trade-off that always occurs in caching: proximity versus universality. Simply put, the closer the cache is to the requester of the information, the more savings that result when data is pulled from the cache, rather than being fetched from the source. However, the further the cache is from the requester (and thus closer to the source), the greater the number of devices that can benefit from the cache. Let's see how this manifests itself in the three classes of devices where caches may be found: the <a class="indexterm" id="idx-CHP-84-3027"/>web client, intermediary, and web server.</p><div class="sect3" title="Caching on the Web Client"><div class="titlepage"><div><div><h3 class="title"><a id="caching_on_the_web_client"/>Caching on the Web Client</h3></div></div></div><p>The cache with which most Internet users are familiar is that found on the local client. It is usually built into the web browser software, and for this reason, it's called a <span class="emphasis"><em>web browser cache</em></span>. This cache stores recent documents and files accessed by a particular user, so that they can be made quickly available if that user requests them again.</p><p>Since the cache is in the user's own machine, a request for an item that the cache contains is filled instantly, resulting in no network transaction and instant gratification for the user. However, that user is the only one who can benefit from the cache, so it's sometimes called a <span class="emphasis"><em>private cache</em></span>.</p></div><div class="sect3" title="Caching on the Intermediary"><div class="titlepage"><div><div><h3 class="title"><a id="caching_on_the_intermediary"/>Caching on the Intermediary</h3></div></div></div><p>Devices such as proxy servers that reside between web clients and servers are also often equipped with a cache. If users want documents that are not in their local client cache, the <a class="indexterm" id="idx-CHP-84-3028"/>intermediary may be able to provide it, as shown in <a class="xref" href="ch84.html#impact_of_caching_on_the_http_requestres" title="Figure 84-1. Impact of caching on the HTTP request/response chain This diagram illustrates the impact of caching on the request/response chain of (see Figure 80-2 in Chapter 80). In this example, intermediary 2 is able to satisfy the client's request from its cache. This short-circuits the communication chain after two transfers, which means the client gets its resource more quickly, and the HTTP server is spared the need to process the client's request.">Figure 84-1</a>. This is not as efficient as retrieving from the local cache, but far better than going back to the <a class="indexterm" id="idx-CHP-84-3029"/>web server.</p><p>An advantage is that all devices using the intermediary can benefit from its cache, which may be termed a <a class="indexterm" id="idx-CHP-84-3030"/><span class="emphasis"><em>public</em></span> or <a class="indexterm" id="idx-CHP-84-3031"/><span class="emphasis"><em>shared cache</em></span>. This can be useful, because members of an organization often access similar documents. For example, in an organization developing a hardware product to be used on Apple computers, many different people might be accessing documents on Apple's website. With a shared cache, a request from User A would often result in items being cached that could be used by User B as well.</p></div><div class="sect3" title="Caching on the Web Server"><div class="titlepage"><div><div><h3 class="title"><a id="caching_on_the_web_server"/>Caching on the Web Server</h3></div></div></div><p>Web servers themselves may also implement a cache. While it may seem a bit strange to have a server maintain a cache of its own documents, this can be of benefit in some circumstances. A resource might require a significant amount of server resources to create. For example, consider a web page that is generated using a complex database query. If this page is retrieved frequently by many clients, there can be a large benefit to creating it periodically and caching it, rather than generating it on the fly for each request.</p><p>Since the web server cache is the farthest from the users, this results in the least savings for a cache hit, as the client request and server response must still travel the full path over the network between the client and server. However, this distance from the client also means that all users of the server can benefit from the cache.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-502"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The most important feature that improves the efficiency of operation of HTTP is <span class="emphasis"><em>caching</em></span>—the storing of recently requested resources in a temporary area. If the same resource is then needed again a short time later, it can be retrieved from the cache rather than requiring a fresh request to the server, resulting in a savings of both time and bandwidth. Caching can be performed by web clients, web servers, and intermediaries. The closer the cache is to the user, the greater the efficiency benefits; the farther from the user, the greater the number of users who can benefit from the cache.</p></div></div></div><div class="sect2" title="Cache Control"><div class="titlepage"><div><div><h2 class="title"><a id="cache_control"/>Cache Control</h2></div></div></div><p><a class="indexterm" id="idx-CHP-84-3032"/>Caching in clients and servers is controlled in the same manner as most other types of control are implemented in HTTP: through the use of special headers. The most important of these is the Cache-Control general header, which has a number of directives that allow the operation of caches to be managed. There are other important caching-related headers, including Expires and Vary. For a great deal of more specific information related to HTTP caching, see RFC 2616, section 13.</p></div><div class="sect2" title="Important Caching Issues"><div class="titlepage"><div><div><h2 class="title"><a id="important_caching_issues"/>Important Caching Issues</h2></div></div></div><p>While the performance advantages of <a class="indexterm" id="idx-CHP-84-3033"/>caching are obvious, caching has one significant drawback: it complicates the operation of HTTP in a number of ways. The following are some of the more important issues that HTTP/1.1 clients, servers, and intermediaries need to address. This list is not exhaustive, but it gives you an idea of what is involved with caching in HTTP.</p><p><span class="strong"><strong>Cache Aging and Staleness</strong></span> When users retrieve a document directly from its original source on the server, they are assured of getting the current version of that resource. When caching is used, that is no longer the case. While many resources change infrequently, almost all will change at some point. For example, at CNN's website, it is probable that the CNN logo won't change very often, but it's possible that the site may be redesigned periodically and the logo modified in some way, such as its size or color. For this reason, a device cannot keep items in an HTTP cache indefinitely. The longer an item is held in a cache—a process called <span class="emphasis"><em>aging</em></span>—the more likely it is that the resource on the server has changed and the cache has become stale. To make matters even more complex, some resources become stale more quickly than others. As a result, much of the caching-related functionality of HTTP involves dealing with this matter of cache aging.</p><p><span class="strong"><strong>Cache Expiration and Validation</strong></span> One of the ways that HTTP deals with the cache aging issue is through <a class="indexterm" id="idx-CHP-84-3034"/>headers and logic that allow caches, clients, and servers to specify how long items should be cached before they expire and must be refreshed. A validation process allows a cache to check with a server at appropriate times to see if an item it has stored has been modified.</p><p><span class="strong"><strong>Communication of Cache Status to the User</strong></span> In most cases, the fact that an item has been retrieved from a cache rather than its source is transparent to users (though they may notice that the resource loads faster than expected). In certain cases, however, the user may need to be informed that a resource came from a cache and not its original source. This is especially true when a cached item may be stale; in which case, the client should warn the user that the information might be out-of-date.</p><p><span class="strong"><strong>Header Caching</strong></span> Caching in HTTP is complicated by the fact that it can occur in multiple places, and some HTTP <a class="indexterm" id="idx-CHP-84-3035"/>headers are treated differently than others. HTTP <a class="indexterm" id="idx-CHP-84-3036"/>headers are divided into two general categories: <span class="emphasis"><em>end-to-end headers</em></span> that are intended to accompany a resource all the way to its ultimate recipient, and <a class="indexterm" id="idx-CHP-84-3037"/><span class="emphasis"><em>hop-by-hop headers</em></span> that are used only for a particular communication between two devices (by the client, server, or intermediary device). End-to-end headers must be stored with a cached resource. Hop-by-hop headers have meaning only for a particular transfer and are not cached.</p><p><span class="strong"><strong>Impact of Resource Updates</strong></span> Some HTTP methods (discussed in <a class="xref" href="ch81.html" title="Chapter 81. HTTP MESSAGES, METHODS, AND STATUS CODES">Chapter 81</a>) will automatically cause cache entries to become invalidated, because they inherently cause a change to the underlying resource. For example, if a user performs a PUT on a resource that was previously retrieved using GET, any cached copies of that resource should be automatically invalidated to prevent the old version from being supplied from the cache.</p><p><span class="strong"><strong>Privacy Concerns</strong></span> In the case of shared caches (such as might exist in a proxy), there are potential privacy issues. In most cases, having User A's cached resource be made available to User B is advantageous, but we must be careful not to cache any items that might be specific to User A, which User B should not see.</p></div></div></div>
<div class="sect1" title="HTTP Proxy Servers and Proxying"><div class="titlepage"><div><div><h1 class="title"><a id="http_proxy_servers_and_proxying"/>HTTP Proxy Servers and Proxying</h1></div></div></div><p><a class="indexterm" id="idx-CHP-84-3038"/>In my overview of the HTTP operational model in <a class="xref" href="ch80.html" title="Chapter 80. HTTP GENERAL OPERATION AND CONNECTIONS">Chapter 80</a>, I described how HTTP was designed to support not just communication between a client and server, but also the inclusion of intermediaries that may sit in the communication path between them. One of the most important types of intermediary is a device called a <span class="emphasis"><em>proxy server</em></span>, or more simply, just a <span class="emphasis"><em>proxy</em></span>.</p><p>A proxy is a middleman that acts as both a client and a server. It accepts requests from a client as if it were a server, then forwards those requests (possibly modifying them) to the real server, which sees the proxy as a client. The server responds back to the proxy, which forwards the reply back to the client. Proxies can be either <span class="emphasis"><em>transparent</em></span>, meaning that they do not modify requests and responses, or <span class="emphasis"><em>nontransparent</em></span>, if they do modify messages in order to provide a particular service.</p><div class="note" title="Note"><h3 class="title"><a id="note-182"/>Note</h3><p><span class="emphasis"><em>The term transparent proxy can also be used to refer to a proxy that is interposed automatically between a client and server—such as an organization-wide firewall—as opposed to one that a user manually configures</em></span>.</p></div><div class="sect2" title="Benefits of Proxies"><div class="titlepage"><div><div><h2 class="title"><a id="benefits_of_proxies"/>Benefits of Proxies</h2></div></div></div><p>Since proxies have the ability to fully process all client requests and server responses, they can be extremely useful in a number of circumstances. They can be used to implement or enhance many important capabilities, such as the following:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-84-3039"/>Security</strong></span> Proxies can be set up to examine both outgoing requests and incoming responses, to address various security concerns. For example, filtering can be set up to prevent users from requesting objectionable content or to screen out harmful replies, such as files containing hidden viruses.</p><p><span class="strong"><strong>Caching</strong></span> As you saw earlier, it can be advantageous to set up a shared cache that is implemented on an intermediary, so resources requested by one client can be made available to another. This can be done within a proxy server.</p><p><span class="strong"><strong>Performance</strong></span> In some circumstances, using a proxy server can significantly improve performance, particularly by reducing latency.</p><p>An excellent example of how a proxy server can improve performance is how proxying is used by my own satellite Internet connection. Due to the distance from the Earth to the satellite, it takes more than 500 milliseconds for a round-trip request/response cycle between my PC and my Internet server provider (ISP). If I loaded a web page containing images, I would need to wait 500+ milliseconds to get the HTML page, and then my browser would need to generate new requests for each graphical element, meaning another 500+ millisecond delay for each. Instead, my ISP has a proxy server to which I send my requests for web pages. The proxy server looks through the HTML of these pages and automatically requests any elements such as graphics for me. It then sends them straight back to my machine, thus drastically reducing the time required to display a full web page.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-503"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> One of the most important types of intermediary devices in HTTP is a <span class="emphasis"><em>proxy server</em></span>, which acts as a middleman between the client and server, handling both requests and responses. A proxy server may transport messages unchanged or may modify them to implement certain features and capabilities. Proxies are often used to increase the security and/or performance of Web access.</p></div></div><div class="sect2" title="Comparing Proxies and Caches"><div class="titlepage"><div><div><h2 class="title"><a id="comparing_proxies_and_caches"/>Comparing Proxies and Caches</h2></div></div></div><p><a class="indexterm" id="idx-CHP-84-3040"/>Proxying and caching are concepts that have a number of similarities, especially in terms of the impact that they have on basic HTTP operation. Like caching, proxying has become more important in recent years, and it also complicates HTTP in a number of ways. The HTTP/1.1 standard includes a number of specific features to support proxies, and it also addresses a number of concerns related to proxying.</p><p>The fact that both proxying and caching represent ways in which basic HTTP client/server communication is changed, combined with the ability of proxies to perform caching, sometimes leads people to think caches and proxies are the same, which is not true. A proxy is a separate element that resides in the HTTP request/response chain. Caches can be implemented within any device in that chain, including a proxy.</p><p>Another key way that caches and proxies differ is that caches are used automatically when they are enabled, but proxies are not. To use a proxy, client software must be told to use the proxy and supplied with its IP address or domain name. The client then sends all requests to the proxy, rather than to the actual server that the user specifies.</p><div class="note" title="Note"><h3 class="title"><a id="note-183"/>Note</h3><p><span class="emphasis"><em>Most of my explanations here have focused on hardware proxy servers, but proxies are also commonly implemented as software in a client device. A software proxy performs the same tasks of processing requests and responses. A software proxy is much cheaper to implement than a hardware proxy, but it cannot be shared by many devices</em></span>.</p></div></div><div class="sect2" title="Important Proxying Issues"><div class="titlepage"><div><div><h2 class="title"><a id="important_proxying_issues"/>Important Proxying Issues</h2></div></div></div><p>As with caching, issues arise when proxies are used in HTTP. The following are some of the more important ones. (For much more information about proxying, refer to RFC 2616).</p><p><span class="strong"><strong>Capability Inconsistencies</strong></span> Issues arise when a client and server don't use the same version of HTTP or don't support the same features. For example, some servers may not support all of the methods that a client may try to use. This becomes more complex when a proxy enters the picture. Of particular concern is the situation where a client and server may agree on a particular feature that the proxy does not. The proxy must make sure that it passes along headers or other elements that it may not comprehend.</p><p><span class="strong"><strong>Authentication Requirements</strong></span> The use of proxy servers often introduces new authentication or security requirements. In addition to authenticating with an end server, the proxy may specify that the client needs to present separate authentication credentials to it as well. This is done using the <a class="indexterm" id="idx-CHP-84-3041"/>HTTP Proxy-Authorization and Proxy-Authenticate headers, as discussed in the next section in this chapter.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-84-3042"/>Caching Interaction</strong></span> Not only do both caching and proxying both complicate <a class="indexterm" id="idx-CHP-84-3043"/>HTTP, they can complicate each other. Many of the issues in handling caching—such as header caching, expiration, and validation—become more complex when proxies are involved. Some of the Cache-Control general header directives are specific to proxying. Another issue is that the use of proxying and caching together can lead to distortions in the apparent number of times that a web resource is accessed. This is important in situations where web pages are supported by advertising, based on the number of times the page is accessed. In some cases, special codes called <span class="emphasis"><em>cache busters</em></span> are placed in URLs to force pages not to be stored in shared caches.</p><p><span class="strong"><strong>Encodings</strong></span> Content encodings (discussed in <a class="xref" href="ch83.html" title="Chapter 83. HTTP Entities, Transfers, Coding Methods, and Content Management">Chapter 83</a>) are applied end-to-end and so should not be affected by proxies. Transfer encoding is done hop-by-hop, so a proxy may use different encodings in handling different transfers of a single request or response.</p><p><span class="strong"><strong>Tracing Proxy Handling</strong></span> It is useful in some circumstances, especially when multiple proxies may be in the request/response chain, to be able to trace which proxies have processed a particular message. To this end, HTTP/1.1 requires that each proxy that handles a message identify itself in the Via header.</p></div></div>
<div class="sect1" title="HTTP Security and Privacy"><div class="titlepage"><div><div><h1 class="title"><a id="http_security_and_privacy"/>HTTP Security and Privacy</h1></div></div></div><p><a class="indexterm" id="idx-CHP-84-3044"/><a class="indexterm" id="idx-CHP-84-3045"/>Many TCP/IP protocols lack security measures, largely because they were developed when security wasn't a big concern. As the Internet has developed, security has become extremely important, however. In the case of the Web, the issue is even more important due to the significance of the changes that have occurred in the content of HTTP messages since the protocol was first developed.</p><p>HTTP has become the vehicle for transporting any and every kind of information, including a large amount of personal data. HTTP was initially designed to carry academic documents such as memos about research projects. Today, an HTTP message is more likely to carry someone's mortgage application, credit card number, or medical details. Thus, not only does HTTP have the usual security issues such as preventing unauthorized access, but it also needs to deal with privacy concerns.</p><div class="sect2" title="HTTP Authentication Methods"><div class="titlepage"><div><div><h2 class="title"><a id="http_authentication_methods"/>HTTP Authentication Methods</h2></div></div></div><p>The main <a class="indexterm" id="idx-CHP-84-3046"/>HTTP/1.1 standard, RFC 2616, does not deal extensively with security matters. These are addressed in detail instead in the companion document, RFC 2617, which explains the two methods of HTTP authentication:</p><p><span class="strong"><strong>Basic Authentication</strong></span> This is a conventional user name/password type of authentication. When a client sends a request to a server that requires authentication to access a resource, the server sends a response to the client's initial request that contains a WWW-Authenticate header. The client then sends a new request containing the Authorization header, which carries a base64-encoded user name and password combination. Basic authentication is not considered strong security because it sends credentials unencrypted, which means that they can be intercepted.</p><p><span class="strong"><strong>Digest Authentication</strong></span> Digest authentication uses the same headers as basic authentication, but employs more sophisticated techniques, including encryption, that protect against a malicious person snooping credentials information. Digest authentication is not considered as strong as public key encryption, but it is a lot better than basic authentication. It's also a lot more complicated. The full details of how it works are in RFC 2617.</p></div><div class="sect2" title="Security and Privacy Concerns and Issues"><div class="titlepage"><div><div><h2 class="title"><a id="security_and_privacy_concerns_and_issues"/>Security and Privacy Concerns and Issues</h2></div></div></div><p>Both RFC 2616 and 2617 address some of the specific security concerns and threats that can potentially affect HTTP clients and servers. These include actions such as spoofing, counterfeit servers, replay attacks, and much more. One concern addressed is the potential for man-in-the-middle attacks, where an attacker interposes between the client and server. Since proxies are inherently middlemen, they represent a security concern in this area. The same <a class="indexterm" id="idx-CHP-84-3047"/>authentication methods used for servers can also be applied to authentication with proxies. In this case, the Proxy-Authenticate and Proxy-Authorization headers are used instead of WWW-Authenticate and Authorization headers.</p><p>The HTTP standards also discuss a number of privacy issues. The following are particularly worthy of examining.</p><p><span class="strong"><strong>Sensitive Information Handling</strong></span> The HTTP protocol can carry any type of information, and it does not inherently protect the privacy of data in HTTP message entities. To ensure the privacy of sensitive information, other techniques must be used (as described in the next section).</p><p><span class="strong"><strong>Information in URLs</strong></span> One issue that sometimes arises in HTTP is that poorly designed websites may inadvertently encode private information into URLs. These URLs may be recorded in web logs, where they could fall into the hands of people who could abuse them. An example of this is a website that submits a user name and password to a server by encoding them as parameters of a GET request such as this: <code class="literal">GET http://www.somesite.com/login?name=xxx&amp;password=yyy</code>. The POST method should be used instead for this sort of functionality, because it transmits its data in the body of the message instead of putting it into the URL.</p><p><span class="strong"><strong>Information in Accept Headers</strong></span> While this may seem strange at first, it is possible that private information about the user could be transmitted through the use of certain Accept headers used for content negotiation. For example, some users might not want others to know what languages they speak, so they may be concerned about who looks at the Accept-Language header.</p><p><span class="strong"><strong>Information in Referer Headers</strong></span> The Referer (yes, that's how it's spelled; see my note in <a class="xref" href="ch82.html" title="Chapter 82. HTTP MESSAGE HEADERS">Chapter 82</a>) request header is a double-edged sword. It can be very useful to those who operate websites because it lets them see the sources of links to their resources. At the same time, it can be abused by those who might employ it to study users' Web-access patterns. There are also potential <a class="indexterm" id="idx-CHP-84-3048"/>privacy issues that the <a class="indexterm" id="idx-CHP-84-3049"/>HTTP standard raises. For example, a user might not want the name of a private document that references a public web page to be transmitted in a Referer header.</p></div><div class="sect2" title="Methods for Ensuring Privacy in HTTP"><div class="titlepage"><div><div><h2 class="title"><a id="methods_for_ensuring_privacy_in_http"/>Methods for Ensuring Privacy in HTTP</h2></div></div></div><p><a class="indexterm" id="idx-CHP-84-3050"/>As mentioned earlier, HTTP does not include any mechanism to protect the privacy of transmitted documents or messages. There are two different methods by which this is normally accomplished:</p><p><span class="strong"><strong>Encryption</strong></span> The simplest way is to encrypt the resource on the server and supply valid decryption keys only to authorized users. Even if the entire message is intercepted, the entity itself will still be secured. The level of protection here depends on the quality of the encryption.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-84-3051"/>Secure Sockets Layer (SSL)</strong></span> Another more common method is to use a protocol designed specifically to ensure the privacy of HTTP transactions. The one often used today is called <span class="emphasis"><em>Secure Sockets Layer (SSL)</em></span><a class="indexterm" id="idx-CHP-84-3052"/>. Servers employ SSL to protect sensitive resources, such as those associated with financial transactions. They are accessed by using the URL scheme <span class="emphasis"><em>https</em></span> rather than <span class="emphasis"><em>http</em></span> in a web browser that supports the protocol. SSL was originally developed by Netscape and is now widely used across the Web.</p></div></div>
<div class="sect1" title="HTTP State Management Using Cookies"><div class="titlepage"><div><div><h1 class="title"><a id="http_state_management_using_cookies"/>HTTP State Management Using Cookies</h1></div></div></div><p><a class="indexterm" id="idx-CHP-84-3053"/>Even though modern HTTP has a lot of capabilities and features, it is still, at its heart, a simple request/reply protocol. One of the unfortunate problems that results from this is that HTTP is entirely <span class="emphasis"><em>stateless</em></span>. This means that each time a server receives a request from a client, it processes the request, sends a response, and then forgets about the request. The next request from the client is treated as independent of any previous ones.</p><div class="note" title="Note"><h3 class="title"><a id="note-184"/>Note</h3><p><span class="emphasis"><em>The persistent connection feature of HTTP/1.1 (described in <a class="xref" href="ch80.html" title="Chapter 80. HTTP GENERAL OPERATION AND CONNECTIONS">Chapter 80</a>) does not change the stateless nature of the protocol. Even though multiple requests and responses can be sent on a single Transmission Control Protocol (TCP) connection, they are still not treated as being related in any way</em></span>.</p></div><p>So why is HTTP being stateless a problem? Isn't this what we would expect of a protocol designed to allow a client to quickly and efficiently retrieve resources from a server? Well, this is, yet again, another place where HTTP's behavior was well suited to its original intended uses but not to how the Web is used today. Sure, if all we want to do is to say, "Hey server, please give me that file over there," then the server doesn't need to care about whether or not it may have previously provided that client with any other files in the past. This is how HTTP was originally intended to be used.</p><p>Today, the Web is much more than a simple resource-retrieval protocol. If you go to an online store, you want to be able to select a number of items to put into a "shopping cart" and have the store's server remember them. You might also want to participate in a discussion forum, which requires you to provide a user name and password in order to post a message. Ideally, the server should let you log in once, and then remember who you are so you can post many messages, without needing to enter your login information each and every time. (I have used forums where the latter is required—it gets old very quickly, believe me.)</p><p>For these and other interactive applications, the stateless nature of HTTP is a serious problem. The solution was the addition of a new technology called <a class="indexterm" id="idx-CHP-84-3054"/><span class="emphasis"><em>state management</em></span>, which allows the state of a client session with a server to be maintained across a series of HTTP transactions. Initially developed by Netscape, this technique was later made a formal Internet standard in RFC 2109, later revised in RFC 2965, "HTTP State Management Mechanism." This feature is actually not part of HTTP; it is an optional element, but one that has been implemented in most web browsers due to its usefulness.</p><p>The idea behind state management is very simple. When a server implements a function that requires state to be maintained across a set of transactions, it sends a small amount of data called a <span class="emphasis"><em>cookie</em></span> to the web client. The cookie contains important information relevant to the particular web application, such as a customer name, items in a shopping cart, or a user name and password. The client stores the information in the cookie, and then uses it in subsequent requests to the server that set the cookie. The server can then update the cookie based on the information in the new request and send it back to the client. In this manner, state information can be maintained indefinitely, allowing the client and server to have a memory that persists over a period of time.</p><div class="note" title="Note"><h3 class="title"><a id="note-185"/>Note</h3><p>Cookie <span class="emphasis"><em>may seem like an odd term, but it is used in a few contexts to refer to a small piece of significant data. Another example is found in the Boot Protocol (BOOTP) and Dynamic Host Configuration Protocol (DHCP) message format. Today, most knowledgeable web users would blink at you if you mentioned the "HTTP state management mechanism," but they usually know what cookies are</em></span><a class="indexterm" id="idx-CHP-84-3055"/>.</p></div><div class="sect2" title="Issues with Cookies"><div class="titlepage"><div><div><h2 class="title"><a id="issues_with_cookies"/>Issues with Cookies</h2></div></div></div><p><a class="indexterm" id="idx-CHP-84-3056"/>Cookies sound like a great idea, right? Cookies are absolutely essential for many of the applications that make the Web the powerhouse it is today. Online shopping and discussion forums are just two of the many interactive applications that benefit from cookies. Most of the time, cookies are used for these sorts of useful and benign purposes. Unfortunately, some people have turned cookies to the "dark side" by finding ways to abuse them. There can even be potential problems with cookies when there is no nefarious intent. For this reason, cookies are rather controversial.</p><p>Here are some of the issues with <a class="indexterm" id="idx-CHP-84-3057"/>cookies:</p><p><span class="strong"><strong>Transmission of Sensitive Information</strong></span> Suppose you use an online banking system. You log in to the server, which then stores your user name and password (which controls access to your account) in a cookie. If the application is not implemented carefully, the message containing that cookie could be intercepted, giving someone access to your account. Even if it is not intercepted, someone knowledgeable who gained access to your computer could retrieve the information from the file where cookies are stored.</p><p><span class="strong"><strong>Undesirable Use of Cookies</strong></span> In theory, cookies should be a help to the user, not a hindrance. However, any server can set a cookie for any reason. In some cases, a server could set a cookie for the purpose of tracking the websites that a user visits, which some people consider a violation of their privacy. Since some web browsers do not inform the user when a cookie is being set, the user may not even be aware that this is happening.</p><p><span class="strong"><strong>Third-Party or <a class="indexterm" id="idx-CHP-84-3058"/>Unintentional Cookies</strong></span> While most people think of cookies as being set in the context of a resource they specifically request, a cookie may be set by any server to which a request is sent, whether the user realizes it or not. Suppose you send a request to <a class="ulink" href="http://www.myfavoritesite.com/index.htm/">http://www.myfavoritesite.com/index.htm/</a>, and that page contains a reference to a tiny image that is on the server <a class="ulink" href="http://www.bigbrotherishere.com/">http://www.bigbrotherishere.com/</a>. The second site can set a cookie on your machine even though you never intended to visit it. This is called a <span class="emphasis"><em>third-party cookie</em></span>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-504"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> HTTP is an inherently <span class="emphasis"><em>stateless</em></span> protocol, because a server treats each request from a client independently, forgetting about all prior requests. This characteristic of HTTP is not an issue for most routine uses of the Web, but is a problem for interactive applications such as online shopping where the server needs to keep track of a user's information over time. To support these applications, most HTTP implementations include an optional feature called <span class="emphasis"><em>state management</em></span>. When enabled, a server sends to a client a small amount of information called a <span class="emphasis"><em>cookie</em></span>, which is stored on the client machine. The data in the cookie is returned to the server with each subsequent request, allowing the server to update it and send it back to the client again. Cookies thus enable servers to remember user data between requests. However, they are controversial, because of certain potential privacy and security concerns related to their use.</p></div></div><div class="sect2" title="Managing Cookie Use"><div class="titlepage"><div><div><h2 class="title"><a id="managing_cookie_use"/>Managing Cookie Use</h2></div></div></div><p>The RFCs describing the cookie state management technique deal extensively with these and other issues, but there is no clear-cut resolution to these concerns. Like most security and privacy matters, the most important determinant of how significant potential cookie abuse may be is your own personal comfort level. Millions of people browse the Web every day letting any and all sites set whatever cookies they want and never have a problem. Others consider cookies an offensive idea and disable all cookies, which eliminates the privacy concerns but can cause problems with useful applications like interactive websites. As usual, the best approach is usually something in the middle, where you choose when and how you will allow cookies to be set.</p><p>The degree to which cookie control is possible depends greatly on the quality and feature set of your web client software. Many browsers do not provide a great deal of control in how and when cookies are set; others are much better in this regard. Some browsers allow cookies to be disabled, but come with them turned on by default. Since many people are not even aware of the issues associated with cookies, they do not realize when cookies are being sent. Most notable in this regard is the popular Microsoft Internet Explorer, which normally comes set by default to accept all cookies without complaint or even comment.</p><p>Internet Explorer does allow you to disable cookies, but you must do it yourself. It also allows you to differentiate between first-party and third-party cookies, but again, you must turn on this feature. Other browsers have more sophisticated settings, which will let you dictate conditions under which cookies may be set and others when they may not. Some browser will even let you allow certain websites to send cookies while prohibiting them from others. Better browsers will also let you visually inspect cookies, and selectively clear the ones you do not want on your machine.</p><p>Third-party cookies can be used by online advertising companies and others to track the sites that a Web user visits. For this reason, they are considered by many people to fall into the general category of undesirable software called <span class="emphasis"><em>spyware</em></span>. There are numerous tools that will allow you to identify and remove tracking cookies from your computer; many are available free on the Web.</p></div></div></body></html>