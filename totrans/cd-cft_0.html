<html><head></head><body><div class="part" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="at_the_codeface"/>Part I. AT THE CODEFACE</h1></div></div></div><div class="partintro" xml:lang="en"><div/><p>Programmers write programs. It doesn't take a genius to figure that one out. But there is a more subtle distinction: Only good programmers habitually write good code. Bad programmers . . . <span class="emphasis"><em>don't</em></span>. They create messes that take more effort to fix than they did to write.</p><p>Which would you rather be?</p><p>Code craft starts at the codeface; it's where we love to be. We programmers are never happier than when immersed in an editor, bashing out line after line of perfectly formed and well-executed source code. We'd be quite happy if the world around us disappeared in a puff of boolean logic. Sadly, the Real World isn't going anywhere—and it doesn't seem willing to keep itself to itself.</p><p>Around your carefully crafted code, the world is in a chaotic state of change. Almo st every software project is characterized by flux: changing requirements, changing budgets, changing deadlines, changing priorities, and changing teams. These all conspire to make writing good code a very difficult job. Welcome to the Real World.</p><p>Good programmers naturally write neat code when left to their own devices. But theyalso have an array of battle tactics to help write robust code <span class="emphasis"><em>on the front line</em></span>. They know how to defend themselves against the harsh realities of the software factory and write code that can survive the whirlwinds of change.</p><p>That's what we're looking at here. This first section delves into the painfully practical, gory details of code construction, the nuts and bolts of writing source code statements. You'll learn strategies to keep yourself afloat on the turbulent software development ocean and will be challenged to improve your code-writing skills.</p><p>These chapters focus on the following issues:</p><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch01.html" title="Chapter 1. ON THE DEFENSIVE">Chapter 1</a></span></dt><dd><p>Defensive programming: How to write robust code when the world is conspiring against you.</p></dd><dt><span class="term"><a class="xref" href="ch02.html" title="Chapter 2. THE BEST LAID PLANS">Chapter 2</a></span></dt><dd><p>Good presentation: why it's important and how to present code well.</p></dd><dt><span class="term"><a class="xref" href="ch03.html" title="Chapter 3. WHAT'S IN A NAME?">Chapter 3</a></span></dt><dd><p>Choosing clear names for the parts of your program.</p></dd><dt><span class="term"><a class="xref" href="ch04.html" title="Chapter 4. THE WRITESTUFF">Chapter 4</a></span></dt><dd><p>Self-documenting code. Practical strategies to explain code when you can't write a whole novel.</p></dd><dt><span class="term"><a class="xref" href="ch05.html" title="Chapter 5. A PASSING COMMENT">Chapter 5</a></span></dt><dd><p>Effective techniques for writing the most appropriate code comments.</p></dd><dt><span class="term"><a class="xref" href="ch06.html" title="Chapter 6. TO ERR IS HUMAN">Chapter 6</a></span></dt><dd><p>Handling errors: How to manage operations that <span class="emphasis"><em>might</em></span> go wrong, and what to do when they do.</p></dd></dl></div><p>These form the path to sound code in an unsound world; they are solid code-writing techniques that should become second nature. If you don't write clear, understandable, defensive, easily testable, easily maintainable software, then you'll be distracted by tedious code-related problems when you should be preparing for what the software factory willthrow at you next.</p></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="on_the_defensive"/>Chapter 1. ON THE DEFENSIVE</h1></div><div><h3 class="subtitle"><i>Defensive Programming Techniques for Robust Code</i></h3></div></div></div><div class="epigraph"><p>We have to distrust each other. It's our only defense against betrayal.</p><div class="attribution"><span>--<span class="attribution">Tennessee Williams</span></span></div></div><p>When my daughter was 10 months old, she liked playing with wooden bricks. Well, she liked playing with wooden bricks and <span class="emphasis"><em>me</em></span>. I'd build a tower as high as I could, and then with a gentle nudge of the bottom brick, she'd topple the whole thing and let out a little whoop of delight. I didn't build these towers for their strength—it would have been pointless if I did. If I had really wanted a sturdy tower, then I'd have built it in a very different way. I'd have shorn up a foundation and started with a wide base, rather than just quickly stacking blocks upon each other and building as high as possible.</p><p>Too many programmers write their code like flimsy towers of bricks; a gentle unexpected prod to the base, and the whole thing falls over. Code builds up in layers, and we need to use techniques that ensure that each layer is sound so that we can build upon it.</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="toward_good_code"/>Toward Good Code</h1></div></div></div><p>There is a huge difference between code that <span class="emphasis"><em>seems</em></span> to work,<span class="emphasis"><em>correct</em></span> code, and <span class="emphasis"><em>good</em></span> code. M.A. Jackson wrote, "The beginning of wisdom for a software engineer is to recognize the difference between getting a program to work, and getting it <span class="emphasis"><em>right</em></span>." ( Jackson 75) There is a difference:<a class="indexterm" id="IDX-CHP-1-0004"/><a class="indexterm" id="IDX-CHP-1-0002"/><a class="indexterm" id="IDX-CHP-1-0003"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>It is easy to write code that <span class="emphasis"><em>works</em></span> most of the time. You feed it the usual set of inputs; it gives the usual set of outputs. But give it something surprising, and it might just fall over.</p></li><li class="listitem"><p><span class="emphasis"><em>Correct</em></span> code won't fall over. For all possible sets of input, the output will be correct. But usually the set of all possible inputs is ridiculously large and hard to test.</p></li><li class="listitem"><p>However, not all correct code is <span class="emphasis"><em>good</em></span> code—the logic may be hard to follow, the code may be contrived, and it may be practically impossible to maintain.</p></li></ul></div><p>By these definitions, good code is what we should aim for. It is robust, efficient enough and, of course, correct. Industrial strength code will not crash or produce incorrect results when given unusual inputs. It will also satisfy all other requirements, including thread safety, timing constraints, and re-entrancy.</p><p>It's one thing to write this good code in the comfort of your own home, a carefully controlled environment. It's an entirely different prospect to do so in the heat of the software factory, where the world is changing around you, the codebase is rapidly evolving, and you're constantly being faced with grotesque <span class="emphasis"><em>legacy code</em></span> —archaic programs written by code monkeys that are now long gone. Try writing good code when the world is conspiring to stop you!<a class="indexterm" id="IDX-CHP-1-0005"/></p><p>In this torturous environment, how do you ensure that your code is industrial strength? <span class="emphasis"><em>Defensive programming</em></span> helps.</p><p>While there are many ways to construct code (object-oriented approaches, component based models, structured design, Extreme Programming, etc.), defensive programming is an approach that can be applied universally. It's not so much a formal methodology as an informal set of basic guidelines. Defensive programming is not a magical cure-all, but a practical way to prevent a pile of potential coding problems.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="assume_the_worst"/>Assume the Worst</h1></div></div></div><p>When you write code, it's all too easy to make a set of assumptions about how it should run, how it will be called, what the valid inputs are, and so on. You won't even realize that you've assumed anything, because it all seems obvious to you. You'll spend months happily crafting code, as these assumptions fade and distort in your mind.<a class="indexterm" id="IDX-CHP-1-0006"/></p><p>Or you might pick up some old code to make a vital last-minute fix when the product's going out the door in 10 minutes. With only enough time for a brief glance at its structure, you'll make assumptions about how the code works. There's no time to perform full literary criticism, and until you get a chance to prove the code is <span class="emphasis"><em>actually</em></span> doing what you think it's doing, assumptions are all you have.</p><p>Assumptions cause us to write flawed software. It's easy to assume:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The function won't <span class="emphasis"><em>ever</em></span> be called like that. I will always be passed valid parameters only.</p></li><li class="listitem"><p>This piece of code will <span class="emphasis"><em>always</em></span> work; it will never generate an error.</p></li><li class="listitem"><p><span class="emphasis"><em>No one</em></span> will ever try to access this variable if I document it <span class="emphasis"><em>For internal use only</em></span>.</p></li></ul></div><p>When we program defensively, we shouldn't make <span class="emphasis"><em>any</em></span> assumptions. We should never assume that <span class="emphasis"><em>it can't happen</em></span>. We should never assume that the world works as we'd expect it to work.</p><p>Experience tells us that the only thing you <span class="emphasis"><em>can</em></span> be certain about is this: Your code <span class="emphasis"><em>will</em></span> somehow, someday, go wrong. Someone <span class="emphasis"><em>will</em></span> do a dumb thing. Murphy's Law puts it this way: "If it can be used incorrectly, it will." Listen to that man—he spoke from experience.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-1" id="CHP-1-FN-1">1</a>]</sup> Defensive programming prevents these accidents by foreseeing them, or at least fore-guessing them—figuring out what might go wrong at each stage in the code, and guarding against it.<a class="indexterm" id="IDX-CHP-1-0008"/><a class="indexterm" id="IDX-CHP-1-0007"/></p><p>Is this paranoid? Perhaps. But it doesn't hurt to be a <span class="emphasis"><em>little</em></span> paranoid. In fact, it makes a lot of sense. As your code evolves, you will forget the original set of assumptions you made (and real code does evolve—see <a class="xref" href="ch15.html" title="Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?">Chapter 15</a>). Other programmers won't have any knowledge of the assumptions in your head, or else they will just make their own invalid assumptions about what your code can do. Software evolution exposes weaknesses, and code growth hides original simple assumptions. A little paranoia at the outset can makecode a lot more robust in the long run.<a class="indexterm" id="IDX-CHP-1-0009"/><a class="indexterm" id="IDX-CHP-1-0010"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Assume nothing. Unwritten assumptions continually cause faults, particularly as code grows</em></span>.</p></dd></dl></div><p>Add to this the fact that things neither you nor your users have any control over can go wrong: Disks fill up, networks fail, and computers crash. Bad things happen. Remember, it's never actually your program that fails—the software always does what you told it to. The actual algorithms, or perhaps the client code, are what introduce faults into the system.</p><p>As you write more code, and as you work through it faster and faster, the likelihood of making mistakes grows and grows. Without adequate time to verify each assumption, you can't write robust code. Unfortunately, on the programming front line, there's rarely any opportunity to slow down, take stock, and linger over a piece of code. The world is just moving too fast, and programmers need to keep up. Therefore, we should grasp every opportunity to reduce errors, and defensive practices are one of our main weapons.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-1" id="ftn.CHP-1-FN-1">1</a>] </sup>Edward Murphy Jr. was a US Air Force engineer. He coined this infamous law after discovering a technician had systematically connected a whole row of devices upside down. Symmetric connectors permitted thisavoidable mistake; afterward, he chose a different connector design.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_is_defensive_programming_question"/>What Is Defensive Programming?</h1></div></div></div><p>As the name suggests, defensive programming is careful, guarded programming. To construct reliable software, we design every component in the system so that it <span class="emphasis"><em>protects</em></span> itself as much as possible. We smash unwritten assumptions by explicitly checking for them in the code. This is an attempt to prevent, or at least observe, when our code is called in a way that will exhibit incorrect behavior.<a class="indexterm" id="IDX-CHP-1-0011"/><a class="indexterm" id="IDX-CHP-1-0012"/><a class="indexterm" id="IDX-CHP-1-0001"/></p><p>Defensive programming enables us to detect minor problems early on, rather than get bitten by them later when they've escalated into major disasters. All too often, you'll see "professional" developers rush out code without thinking. The story goes something like this:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e851"/><img alt="What Is Defensive Programming?" src="tagoreillycom20080909nostarchimages207431.png"/></div></div><p>They are continually tripped up by the incorrect assumptions that they never took the time to validate. Hardly a promotion for modern day software engineering, but it's happening all the time. Defensive programming helps us to write correct software from the start and move away from the <span class="emphasis"><em>code-it</em></span>, <span class="emphasis"><em>try-it</em></span>, <span class="emphasis"><em>code-it</em></span>, <span class="emphasis"><em>try-it</em></span> . . . cycle. With defensive programming, the story looks more like this:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e871"/><img alt="What Is Defensive Programming?" src="tagoreillycom20080909nostarchimages207435.png"/></div></div><p>Okay, defensive programming won't remove program failures altogether. But problems will become less of a hassle and easier to fix. Defensive programmers catch falling snowflakes rather than get buried under an avalanche of errors.</p><p>Defensive programming is a method of prevention, rather than a form of cure. Compare this to debugging—the act of removing bugs <span class="emphasis"><em>after</em></span> they've bitten. Debugging is all about finding a cure.<a class="indexterm" id="IDX-CHP-1-0013"/><a class="indexterm" id="IDX-CHP-1-0014"/></p><div class="sidebar"><a id="what_defensive_programming_isn_apos_t"/><p class="title"><b>WHAT DEFENSIVE PROGRAMMING ISN'T</b></p><p>There are a few common misconceptions about defensive programming. Defensive programming is not:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Error checking</strong></span></span></dt><dd><p>If there are error conditions that might arise in your code, you should be checking for them anyway. This is not defensive code. It's just plain good practice—a part of writing <span class="emphasis"><em>correct</em></span> code.</p></dd><dt><span class="term"><span class="strong"><strong>Testing</strong></span></span></dt><dd><p>Testing your code is not defensive. It's another normal part of our development work. Test harnesses aren't defensive; they can prove the code is correct now, butwon't prove that it will stand up to future modification. Even with the best test suite in the world, anyone can make a change and slip it past untested.</p></dd><dt><span class="term"><span class="strong"><strong>Debugging</strong></span></span></dt><dd><p>You might add some defensive code during a spell of debugging, but debugging is something you do after your program has failed. Defensive programming is somethingyou do to <span class="emphasis"><em>prevent</em></span> your program from failing in the first place (or to detect failures early before they manifest in incomprehensible ways, demanding all-night debugging sessions).</p></dd></dl></div></div><p>Is defensive programming really worth the hassle? There are arguments for and against:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>The case</strong></span> <span class="bolditalic">against</span></span></dt><dd><p>Defensive programming consumes resources, both yours and the computer's.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>It eats into the efficiency of your code; even a little extra code requires a little extra execution. For a single function or class, this might not matter, but when you have a system made up of 100,000 functions, you may have more of a problem.</p></li><li class="listitem"><p>Each defensive practice requires some extra work. Why should you follow any of them? You have enough to do already, right? Just make sure people use your code correctly. If they don't, then any problems are their own fault.</p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>The case</strong></span> <span class="bolditalic">for</span></span></dt><dd><p>The counterargument is compelling.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Defensive programming saves you literally hours of debugging and lets you do more fun stuff instead. Remember Murphy: If your code <span class="emphasis"><em>can</em></span> be used incorrectly, it will be.</p></li><li class="listitem"><p>Working code that runs properly, but ever-so-slightly slower, is <span class="emphasis"><em>far</em></span> superior to code that works most of the time but occasionally collapses in a shower of brightly colored sparks.</p></li><li class="listitem"><p>We can design some defensive code to be physically removed in release builds, circumventing the performance issue. The majority of the items we'll consider here don't have any significant overhead, anyway.</p></li><li class="listitem"><p>Defensive programming avoids a large number of security problems—a serious issue in modern software development. More on this follows.</p></li></ul></div></dd></dl></div><p>As the market demands software that's built faster and cheaper, we need to focus on techniques that deliver results. Don't skip the bit of extra work up front that will prevent a whole world of pain and delay later.<a class="indexterm" id="IDX-CHP-1-0015"/></p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_comma_big_comma_bad_world"/>The Big, Bad World</h1></div></div></div><p>Someone once said, "Never ascribe to malice that which is adequately explained by stupidity."<sup>[<a class="footnote" href="#ftn.CHP-1-FN-2" id="CHP-1-FN-2">2</a>]</sup> Most of the time we are defending against stupidity, against invalid and unchecked assumptions. However there <span class="emphasis"><em>are</em></span> malicious users, and they will try to bend and break your code to suit their vicious purposes.</p><p>Defensive programming helps with program security, guarding against this kind of willful misuse. Crackers and virus writers routinely exploit sloppy code to gain control of an application and then weave whatever wicked schemes they desire. This is a serious threat in the modern world of software development; it has huge implications in terms of the loss of productivity, money, and privacy.</p><p>Software abusers range from the opportunistic user exploiting a small program quirk to the hard-core cracker who spends his time deliberately trying to gain illicit access to your systems. Too many unwitting programmers leave gaping holes for these people to walk through. With the rise of the networked computer, the consequences of sloppiness become more and more significant.</p><p>Many large development corporations are finally waking up to this threat and are beginning to take the problem seriously, investing time and resources into serious defensive code work. In reality, it's hard to graft in defenses <span class="emphasis"><em>after</em></span> an attack. We look at software security in more detail in <a class="xref" href="ch12.html" title="Chapter 12. AN INSECURITY COMPLEX">Chapter 12</a>.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="techniques_for_defensive_programming"/>Techniques for Defensive Programming</h2></div></div></div><p>Enough of the background. What does all this mean to programmers working in the software factory?</p><p>There are a number of common sense rules under the defensive programming umbrella. People usually think of <span class="emphasis"><em>assertions</em></span> when they think of defensive programming, and rightly so. We'll talk about those later. But there's also a pile of simple programming habits that will immeasurably improve the safety of your code.<a class="indexterm" id="IDX-CHP-1-0017"/></p><p>Despite seeming common sense, these rules are often ignored—hence the low standard of most software at large in the world. Tighter security and reliable development can be achieved surprisingly easily, as long as programmers are alert and well informed.</p><p>The next few pages list the rules of defensive programming. We'll start off by painting with broad strokes, looking at high-level defensive techniques, processes, and procedures. As we progress, we'll fill in finer detail, looking more deeply at individual code statements. Some of these defensive techniques are language specific. This is natural—you have to put on bulletproof shoes if your language lets you shoot yourself in the foot.</p><p>As you read this list, evaluate yourself. How many of these rules do you currently follow? Which ones will you now adopt?</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="employ_a_good_coding_style_and_sound_design"/>Employ a Good Coding Style and Sound Design</h2></div></div></div><p>We can prevent most coding mistakes by adopting a good coding style. This naturally dovetails with the other chapters in this section. Simple things like choosing meaningful variable names and using parentheses judiciously can increase clarity and reduce the likelihood of faults slipping past unnoticed.<a class="indexterm" id="IDX-CHP-1-0018"/></p><p>Similarly, considering the larger-scale design before ploughing into the code is key. "The best documentation of a computer program is a clean structure." (Kernighan Plaugher 78) Starting off with a set of clear APIs to implement, a logical system structure, and well-defined component roles and responsibilities will avoid headaches further down the line.<a class="indexterm" id="IDX-CHP-1-0019"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="dont_code_in_a_hurry"/>Don't Code in a Hurry</h2></div></div></div><p>It's all too common to see hit-and-run programming. Programmers quickly hack out a function, shove it through the compiler to check syntax, run it once to see if it works, and then move on to the next task. This approach is fraught with peril.<a class="indexterm" id="IDX-CHP-1-0020"/></p><p>Instead, think about each line as you write it. What errors could arise? Have you considered every logical twist that might occur? Slow, methodical programming seems mundane—but it really does cut down on the number of faults introduced.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>More haste, less speed. Always think carefully about what you're typing as you typeit</em></span>.</p></dd></dl></div><p>A particular C-family gotcha that snares speedy programmers is mistyping <code class="literal">==</code> as just <code class="literal">=</code>. The former is a test for equality; the latter a variable assignment. With an unhelpful compiler (or with warnings switched off) there will be no indication that the program behavior is not what was intended.<a class="indexterm" id="IDX-CHP-1-0021"/><a class="indexterm" id="IDX-CHP-1-0022"/></p><p>Always do <span class="emphasis"><em>all</em></span> of the tasks involved in completing a code section before rushing on. For example, if you decide to write the main flow first and the error checking/handling second, you must be sure you have the discipline to do both. Be very wary of deferring the error checking and moving straight on to the main flow of three more code sections. Your intention to return later may be sincere, but later can easily become much later, by which time you will have forgotten much of the context, making it take longer and be more of a chore. (And of course, by then there will be some artificially urgent deadline.)</p><p>Discipline is a habit that needs to be learned and reinforced. Every time you don't do the right thing now, you become more likely to continue not doing the right thing in the future. Do it now; don't leave it for a rainy day in the Sahara. Doing it later actually requires <span class="emphasis"><em>more</em></span> discipline than doing it now!</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="trust_no_one"/>Trust No One</h2></div></div></div><p>Your mother told you never to talk to strangers. Unfortunately, good software development requires even more cynicism and less faith in human nature. Even well-intentioned code users could cause problems in your program; being defensive means you can't trust anybody.<a class="indexterm" id="IDX-CHP-1-0023"/><a class="indexterm" id="IDX-CHP-1-0024"/><a class="indexterm" id="IDX-CHP-1-0025"/><a class="indexterm" id="IDX-CHP-1-0026"/></p><p>You might suffer problems because of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Genuine users</strong></span> accidentally giving bogus input or operating the program incorrectly.</p></li><li class="listitem"><p><span class="strong"><strong>Malicious users</strong></span> trying to consciously provoke bad program behavior.</p></li><li class="listitem"><p><span class="strong"><strong>Client code</strong></span> calling your function with the wrong parameters or supplying inconsistent input.</p></li><li class="listitem"><p><span class="strong"><strong>The operating environment</strong></span> failing to provide adequate service to the program.</p></li><li class="listitem"><p><span class="strong"><strong>External libraries</strong></span> behaving badly and failing to honor interface contracts that you rely on.</p></li></ul></div><p>You might even make a silly coding mistake in one function or forget how some three-year-old code is supposed to work and then use it badly. Don't assume that all will go well or that all code will operate correctly. Put safety checks in place throughout your work. Constantly watch for weak spots, and guard against them with extra-defensive code.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Trust no one. Absolutely anyone—including yourself—can introduce flaws into your program logic. Treat all inputs and all results with suspicion until you can prove that they are valid</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="write_code_for_clarity_comma_not_brevity"/>Write Code for Clarity, Not Brevity</h2></div></div></div><p>Whenever you can choose between concise (but potentially confusing) code and clear (but potentially tedious) code, use code that <span class="emphasis"><em>reads</em></span> as intended, even if it's less elegant. For example, split complex arithmetic operations into a series of separate statements to make the logic clearer.</p><p>Think about who might read your code. It might require maintenance work by a junior coder, and if he can't understand the logic, then he's bound to make mistakes. Complicated constructs or unusual language tricks might prove your encyclopedic knowledge of operator precedence, but it really butchers code maintainability. <span class="emphasis"><em>Keep it simple</em></span>.</p><p>If it can't be maintained, your code is not safe. In really extreme cases, overly complex expressions can cause the compiler to generate incorrect code—many compiler optimization errors come to light this way.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Simplicity is a virtue. Never make code more complex than necessary</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="dont_let_anyone_tinker_with_stuff_they_shouldnt"/>Don't Let Anyone Tinker with Stuff They Shouldn't</h2></div></div></div><p>Things that are internal should stay on the inside. Things that are private should be kept under lock and key. Don't display your code's dirty laundry in public. No matter how politely you ask, people <span class="emphasis"><em>will</em></span> fiddle with your data when you're not looking if given half a chance, and they <span class="emphasis"><em>will</em></span> try to call "implementation-only" routines for their own reasons. Don't let them.<a class="indexterm" id="IDX-CHP-1-0027"/><a class="indexterm" id="IDX-CHP-1-0028"/><a class="indexterm" id="IDX-CHP-1-0029"/><a class="indexterm" id="IDX-CHP-1-0030"/><a class="indexterm" id="IDX-CHP-1-0031"/><a class="indexterm" id="IDX-CHP-1-0032"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>In object-oriented languages, prevent access to internal class data by making it private. In C++, consider the Cheshire cat (or pimpl) idiom—a common technique for keeping a class's internal structure out of its public header file. (Meyers 97)</p></li><li class="listitem"><p>In procedural languages, you can still employ object-oriented (OO) packaging concepts, by wrapping private data behind opaque types and providing well-defined public operations on them.</p></li><li class="listitem"><p>Keep all variables in the tightest scope necessary; don't declare variables globally when you don't have to. Don't put them at file scope when they can be function-local. Don't place them at function scope when they can be loop-local.<a class="indexterm" id="IDX-CHP-1-0033"/><a class="indexterm" id="IDX-CHP-1-0034"/></p></li></ul></div><div class="sidebar"><a id="say_open_quote_when_close_quote"/><p class="title"><b>SAY "WHEN"</b></p><p><span class="emphasis"><em>When</em></span> do you program defensively? Do you start when things go wrong? Or when you pick up some code you don't understand?</p><p>No, these defensive programming techniques should be used <span class="emphasis"><em>all the time</em></span>. They shouldbe second nature. Mature programmers have learned from experience—they've been bitten enough times that they know to put sensible safeguards in place.</p><p>Defensive strategies are much easier to apply as you start writing code, rather than retrofitting them into existentcode. You can't be thorough and accurate if you try to shoehorn in this stuff late in theday. If you start adding defensive code once something has gone wrong, you are essentially debugging—being reactive, notpreventative and proactive.</p><p>However, during the course of debugging, or even when adding new functionalityyou'll discover conditions that you'd like to verify. It's always a good time to adddefensive code.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="compile_with_all_warnings_switched_on"/>Compile with All Warnings Switched On</h2></div></div></div><p>Most languages' compilers draw on a vast selection of error messages when you hurt their feelings. They will also spit out various <span class="emphasis"><em>warnings</em></span> when they encounter potentially flawed code, like the use of a C or C++ variable before its assignment.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-3" id="CHP-1-FN-3">3</a>]</sup> These warnings can usually be selectively enabled and disabled.</p><p>If your code is full of dangerous constructs, you'll get pages and pages of warnings. Sadly, the common response is to disable compiler warnings or just ignore the messages. Don't do either.</p><p><span class="emphasis"><em>Always</em></span> enable your compiler's warnings. And if your code generates any warnings, fix the code immediately to silence the compiler's screams. Never be satisfied with code that doesn't compile quietly when warnings are enabled. The warnings are there for a reason. Even if there's a particular warning you think doesn't matter, don't leave it in, or one day it will obscure one that <span class="emphasis"><em>does</em></span> matter.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Compiler warnings catch many silly coding errors. Always enable them. Make sure your code compiles silently</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="use_static_analysis_tools"/>Use Static Analysis Tools</h2></div></div></div><p>Compiler warnings are the result of a limited <span class="emphasis"><em>static analysis</em></span> of your code, a code inspection performed <span class="emphasis"><em>before</em></span> the program is run.<a class="indexterm" id="IDX-CHP-1-0041"/><a class="indexterm" id="IDX-CHP-1-0037"/><a class="indexterm" id="IDX-CHP-1-0038"/><a class="indexterm" id="IDX-CHP-1-0039"/><a class="indexterm" id="IDX-CHP-1-0040"/></p><p>There are many separate static analysis tools available, like <code class="literal">lint</code> (and its more modern derivatives) for C and FxCop for .NET assemblies. Your daily programming routine should include use of these tools to check your code. They will pick up many more errors than your compiler alone.<a class="indexterm" id="IDX-CHP-1-0042"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="use_safe_data_structures"/>Use Safe Data Structures</h2></div></div></div><p>Or failing that, use dangerous data structures safely.</p><p>Perhaps the most common security vulnerability results from <span class="emphasis"><em>buffer overrun</em></span>. This is triggered by the careless use of fixed-size data structures. If your code writes into a buffer without checking its size first, then there is always potential for writing past the end of the buffer.<a class="indexterm" id="IDX-CHP-1-0043"/></p><p>It's frighteningly easy to do, as this small snippet of C++ code demonstrates:</p><a id="I_programlisting1_d1e1332"/><pre class="programlisting">
char *unsafe_copy(const char *source)
{
          char *buffer = new char[10];
          strcpy(buffer, source);
          return buffer;
}
</pre><p>If the length of the data in <code class="literal">source</code> is greater than 10 characters, its copy will extend beyond the end of <code class="literal">buffer</code>'s reserved memory. Then anything could happen. In the best case, the result would be data corruption—some other data structure's contents will be overwritten. In the worst case, a malicious user could exploit this simple error to put executable code on the program stack and use it to run his own arbitrary program, effectively hijacking the computer. These kinds of flaw are regularly exploited by system crackers—serious stuff.</p><p>It's easy to avoid being bitten by these vulnerabilities: Don't write such bad code! Use safer data structures that don't allow you to corrupt the program—use a managed buffer like C++'s <code class="literal">string</code> class. Or systematically use safe operations on unsafe data types. The C++ code above can be secured by swapping <code class="literal">strcpy</code> for <code class="literal">strncpy</code>, a size-limited string copy operation:</p><a id="I_programlisting1_d1e1353"/><pre class="programlisting">
char *safer_copy(const char *source)
{
    char *buffer = new char[10];
    <strong class="userinput"><code>strncpy</code></strong>(buffer, source, 10);
   return buffer;
}
</pre></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="check_every_return_value"/>Check Every Return Value</h2></div></div></div><p>If a function returns a value, it does so for a reason. Check that return value. If it is an error code, you <span class="emphasis"><em>must</em></span> inspect it and handle any failure. Don't let errors silently invade your program; swallowing an error can lead to unpredictable behavior.<a class="indexterm" id="IDX-CHP-1-0044"/><a class="indexterm" id="IDX-CHP-1-0045"/><a class="indexterm" id="IDX-CHP-1-0046"/><a class="indexterm" id="IDX-CHP-1-0047"/><a class="indexterm" id="IDX-CHP-1-0048"/><a class="indexterm" id="IDX-CHP-1-0049"/></p><p>This applies to user-defined functions as well as standard library ones. Most of the insidious bugs you'll find arise when a programmer fails to check a return value. Don't forget that some functions may return errors through a different mechanism (i.e., the standard C library's <span class="emphasis"><em>errno</em></span>). Always catch and handle appropriate exceptions at the appropriate level.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="handle_memory_open_parenthesis_and_other_precious"/>Handle Memory (and Other Precious Resources) Carefully</h2></div></div></div><p>Be thorough and release any resource that you acquire during execution. Memory is the example of this cited most often, but it is not the only one. Files and thread locks are other precious resources that we must use carefully. Be a good steward.<a class="indexterm" id="IDX-CHP-1-0050"/></p><p>Don't neglect to close files or release memory because you think that the OS will clean up your program when it exits. You really don't know how long your code will be left running, eating up all file handles or consuming all the memory. You can't even be sure that the OS will cleanly release your resources—some OSes don't.<a class="indexterm" id="IDX-CHP-1-0051"/></p><p>There is a school of thought that says, "Don't worry about freeing memory until you know your program works in the first place; only then add all the relevant releases." Just say no. This is a ludicrously dangerous practice. It will lead to many, many errors in your memory usage; you <span class="emphasis"><em>will</em></span> inevitably forget to free memory in some places.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Treat all scarce resources with respect. Manage their acquisition and release carefully</em></span>.</p></dd></dl></div><p>Java and .NET employ a garbage collector to do all this tedious tidying up for you, so you can just "forget" about freeing resources. Let them drop to the floor, since the run time sweeps up every now and then. It's a nice luxury, but don't be lulled into a false sense of security. You still have to think. You have to explicitly drop references to objects you no longer care about, or they won't be cleaned up; don't accidentally hold on to an object reference. Less advanced garbage collectors are also easily fooled by circular references (e.g., A refers to <span class="emphasis"><em>B</em></span>, and <span class="emphasis"><em>B</em></span> refers to <span class="emphasis"><em>A</em></span>, but no one else cares about them). This could cause objects to never be swept up; a subtle form of memory leak.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="initialize_all_variables_at_their_points_of"/>Initialize All Variables at Their Points of Declaration</h2></div></div></div><p>This is a clarity issue. The intent of each variable is explicit if you initialize it. It's not safe to rely on rules of thumb like <span class="emphasis"><em>If I don't initialize it, I don't care about the initial value</em></span>. The code will evolve. The uninitialized value may turn into a problem further down the line.<a class="indexterm" id="IDX-CHP-1-0052"/><a class="indexterm" id="IDX-CHP-1-0053"/><a class="indexterm" id="IDX-CHP-1-0054"/><a class="indexterm" id="IDX-CHP-1-0055"/></p><p>C and C++ compound this issue. If you accidentally use a variable without having initialized it, you'll get different results each time your program runs, depending on what garbage was in memory at the time. Declaring a variable in one place, assigning it later on, and then using it even later opens up a window for errors. If the assignment is ever skipped, you'll spend ages hunting down random behavior. Close the window by initializing every variable as you declare it; even if the value's wrong, the behavior will at least be predictably wrong.<a class="indexterm" id="IDX-CHP-1-0056"/><a class="indexterm" id="IDX-CHP-1-0057"/></p><p>Safer languages (like Java and C#) sidestep this pitfall by defining an initial value for all variables. It's still good practice to initialize a variable as you declare it, which improves code clarity.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="declare_variables_as_late_as_possible"/>Declare Variables as Late as Possible</h2></div></div></div><p>By doing this, you place the variable as close as possible to its use, preventing it from confusing other parts of the code. It also clarifies the code using the variable. You don't have to hunt around to find the variable's type and initialization; a nearby declaration makes it obvious.<a class="indexterm" id="IDX-CHP-1-0058"/><a class="indexterm" id="IDX-CHP-1-0059"/></p><p>Don't reuse the same temporary variable in a number of places, even if each use is in a logically separate area. It makes later reworking of the code awfully complicated. Create a new variable each time—the compiler will sort out any efficiency concerns.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="use_standard_language_facilities"/>Use Standard Language Facilities</h2></div></div></div><p>C and C++ are nightmares in this respect. They suffer from many different revisions of their specifications, with more obscure cases left as implementation-specific <span class="emphasis"><em>undefined behavior</em></span>. Today there are many compilers, each with subtly different behavior. They are mostly compatible, but there is still plenty of rope to hang yourself with.<a class="indexterm" id="IDX-CHP-1-0060"/></p><p>Clearly define which language version you are using. Unless mandated by your project (and there had better be a good reason), <span class="emphasis"><em>don't</em></span> rely on compiler weirdness or any nonstandard extensions to the language. If there is an area of the language that is undefined, don't rely on the behavior of your particular compiler (e.g., don't rely on your C compiler treating <code class="literal">char</code> as a <code class="literal">signed</code> value—others won't). Doing so leads to very brittle code. What happens when you update the compiler? What happens when a new programmer joins the team who doesn't understand the extensions? Relying on a particular compiler's odd behavior leads to <span class="emphasis"><em>really</em></span> subtle bugs later in life.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="use_a_good_diagnostic_logging_facility"/>Use a Good Diagnostic Logging Facility</h2></div></div></div><p>When you write some new code, you'll often include a lot of diagnostics to check what's going on. Should these really be removed after the event? Leaving them in will make life easier when you have to revisit the code, especially if they can be selectively disabled in the meantime.<a class="indexterm" id="IDX-CHP-1-0061"/><a class="indexterm" id="IDX-CHP-1-0062"/><a class="indexterm" id="IDX-CHP-1-0063"/></p><p>There are a number of diagnostic logging systems available to facilitate this. Many can be used in such a way that diagnostics have no overhead if not needed; they can be conditionally compiled out.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="cast_carefully"/>Cast Carefully</h2></div></div></div><p>Most languages allow you to <span class="emphasis"><em>cast</em></span> (or convert) data from one type to another. This operation is some times more successful than others. If you try to convert a 64-bit integer into a smaller 8-bit data type, what will happen to the other 56 bits? Your execution environment might suddenly throw an exception or silently degrade your data's integrity. Many programmers don't think about this kind of thing, and so their programs behave in unnatural ways.</p><p>If you really want to use a cast, think carefully about it. What you're saying to the compiler is, "Forget your type checking: I know what this variable is, you don't." You're ripping a big hole into the type system and walking straight through it. It's unstable ground; if you make any kind of mistake, the compiler will just sit there quietly and mutter, "I told you so," under its breath. If you're lucky (e.g., using Java or C#) the run time might throw an exception to let you know, but this depends on exactly what you're trying to convert.<a class="indexterm" id="IDX-CHP-1-0064"/></p><p>C and C++ are particularly vague about the precision of data types, so don't make assumptions about data type interchangeability. Don't presume that int and <code class="literal">long</code> are the same size and can be assigned to one another, even if you can get away with it on <span class="emphasis"><em>your</em></span> platform. Code migrates platforms, but bad code migrates badly.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="the_fine_print"/>The Fine Print</h2></div></div></div><p>There are many low-level defensive construction techniques, all part of a sensible coding routine and a healthy distrust of the Real World. Consider:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Providing default behavior</strong></span></span></dt><dd><p>Most languages provide a <code class="literal">switch</code> statement; they document what happens in the <code class="literal">default</code> case. If the default case is erroneous, make that explicit in the code. If nothing happens, make <span class="emphasis"><em>that</em></span> explicit in the code—that way the maintenance programmer will understand.<a class="indexterm" id="IDX-CHP-1-0065"/><a class="indexterm" id="IDX-CHP-1-0066"/></p><p>Similarly, if you write an <code class="literal">if</code> statement without an <code class="literal">else</code> clause, stop for a moment and consider whether you should handle the logical default case.</p></dd><dt><span class="term"><span class="strong"><strong>Following language idioms</strong></span></span></dt><dd><p>This simple piece of advice will ensure that your readers understand all of the code you have written. They'll make fewer bad assumptions.</p></dd><dt><span class="term"><span class="strong"><strong>Checking numeric limits</strong></span></span></dt><dd><p>Even the most basic calculations may cause numeric variables to overflow or underflow. Be on the lookout for this. Language specifications or core libraries provide mechanisms for determining the capacity of standard types—use them. Make sure you know all the available numeric types, and what each is most suitable for.</p><p>Check that each calculation is sound. For example, make sure you can't use values that would cause a <span class="emphasis"><em>divide by zero</em></span> error.<a class="indexterm" id="IDX-CHP-1-0067"/></p></dd><dt><span class="term"><span class="strong"><strong>Beingconst-</strong></span><em class="replaceable"><code>correct</code></em></span></dt><dd><p>C/C++ programmers should be really vigilant about this—it will make life much easier. Make everything as <code class="literal">const</code> as you possibly can. It does two things: <code class="literal">const</code> qualifications act as code documentation, and <code class="literal">const</code> allows the compiler to spot silly mistakes that you make. It prevents you from modifying data that's off-limits.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="constraints"/>Constraints</h2></div></div></div><p>We've thought about the set of assumptions we make as we program. But how can we physically incorporate these assumptions into our software so they're not illusive problems waiting to emerge? Simply write a little extra code to check for each condition. This code acts as the documentation of each assumption, making it explicit rather than implicit.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-4" id="CHP-1-FN-4">4</a>]</sup> In doing so, we're codifying the <span class="emphasis"><em>constraints</em></span> on program functionality and behavior.<a class="indexterm" id="IDX-CHP-1-0068"/></p><p>What do we want the program to do if a constraint is broken? Since this kind of constraint will be more than a simple detectable and correctable run-time error (we should already be checking for and handling those), it must be a flaw in the program logic. There are few possibilities for the program's reaction:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Turn a blind eye to the problem, and hope that nothing will go wrong as a consequence.</p></li><li class="listitem"><p>Give it an on-the-spot fine and allow the program to continue (e.g., print a diagnostic warning or log the error).</p></li><li class="listitem"><p>Go directly to jail; do not pass go (e.g., abort the program immediately, in a controlled or uncontrolled manner).</p></li></ul></div><p>For example, it is invalid to call C's <code class="literal">strlen</code> function with a string pointer set to zero, because the pointer will be immediately dereferenced, so the latter two options are the most plausible candidates. It's probably most appropriate to abort the program immediately, since derefencing a null pointer can lead to all sorts of catastrophes on unprotected operating systems.<a class="indexterm" id="IDX-CHP-1-0072"/></p><p>There are a number of different scenarios in which constraints are used:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Preconditions</strong></span></span></dt><dd><p>These are conditions that must hold true <span class="emphasis"><em>before</em></span> a section of code is entered. If a precondition fails, it's due to a fault in the client code.</p></dd><dt><span class="term"><span class="strong"><strong>Postconditions</strong></span></span></dt><dd><p>These must hold true <span class="emphasis"><em>after</em></span> a code block is left. If a postcondition fails, it's due to a fault in the supplier code.</p></dd><dt><span class="term"><span class="strong"><strong>Invariants</strong></span></span></dt><dd><p>These are conditions that hold true every time the program's execution reaches a particular point: between loop passes, across method calls, and so on. Failure of an invariant implies a fault in the program logic.</p></dd><dt><span class="term"><span class="strong"><strong>Assertions</strong></span></span></dt><dd><p>Any other statement about a program's state at a given point in time.</p></dd></dl></div><p>The first two listed here are frustrating to implement without language support—if a function has multiple exit points,<sup>[<a class="footnote" href="#ftn.CHP-1-FN-5" id="CHP-1-FN-5">5</a>]</sup> then inserting a postcondition gets messy. Eiffel supports pre- and postconditions in the core language and can also ensure that constraint checks don't have any side effects.<a class="indexterm" id="IDX-CHP-1-0073"/><a class="indexterm" id="IDX-CHP-1-0074"/></p><p>However tedious, good constraints expressed in code make your program clearer and more maintainable. This technique is also known as <span class="emphasis"><em>design by contract</em></span>, since constraints form an immutable contract between sections of code.<a class="indexterm" id="IDX-CHP-1-0075"/><a class="indexterm" id="IDX-CHP-1-0076"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="what_to_constrain"/>What to Constrain</h2></div></div></div><p>There are a number of different problems you can guard against with constraints. For example, you can:<a class="indexterm" id="IDX-CHP-1-0077"/><a class="indexterm" id="IDX-CHP-1-0078"/><a class="indexterm" id="IDX-CHP-1-0079"/><a class="indexterm" id="IDX-CHP-1-0080"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Check all array accesses are within bounds.</p></li><li class="listitem"><p>Assert that pointers are not zero before dereferencing them.</p></li><li class="listitem"><p>Ensure that function parameters are valid.</p></li><li class="listitem"><p>Sanity check function results before returning them.</p></li><li class="listitem"><p>Prove that an object's state is consistent before operating on it.</p></li><li class="listitem"><p>Guard any place in the code where you'd write the comment <span class="emphasis"><em>We should never get here</em></span>.</p></li></ul></div><p>The first two of these examples are particularly C/C++ focused. Java and C# have their own ways of avoiding some of these pitfalls in the core language, as do other languages.</p><p>Just how much constraint checking should you do? Placing a check on every other line is a bit extreme. As with many things, the correct balance becomes clear as the programmer gets more mature. Is it better to have too much or too little? It is possible for too many constraint checks to obscure the code's logic. "Readability is the best single criterion of program quality: If a program is easy to read, it is probably a good program; if it is hard to read, it probably isn't good." (Kernighan Plaugher 76)</p><p>Realistically, putting pre- and postconditions in major functions plus invariants in the key loops is sufficient.<a class="indexterm" id="IDX-CHP-1-0081"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="removing_constraints"/>Removing Constraints</h2></div></div></div><p>This kind of constraint checking is usually only required during the development and debugging stages of program construction. Once we have used the constraints to convince ourselves (rightly or wrongly) that the program logic is correct, we would ideally remove them so as not to incur an unnecessary run-time overhead.<a class="indexterm" id="IDX-CHP-1-0082"/><a class="indexterm" id="IDX-CHP-1-0083"/><a class="indexterm" id="IDX-CHP-1-0084"/></p><p>Thanks to the wonders of modern technology, all of this is perfectly possible. The C and C++ standard libraries provide a common mechanism to implement constraints—<code class="literal">assert. assert</code> acts as a procedural firewall, testing the logic of its argument. It is provided as an alarm for the developer to show incorrect program behavior and should not be allowed to trigger in customer-facing code. If the assertion's constraint is satisfied execution continues. Otherwise, the program aborts, producing an error message looking something like this:<a class="indexterm" id="IDX-CHP-1-0085"/></p><a id="I_programlisting1_d1e1820"/><pre class="programlisting">
bugged.cpp:10: int main(): Assertion "1 == 0" failed.
</pre><p><code class="literal">assert</code> is implemented as a preprocessor macro, which means it sits more naturally in C than in C++. There are a number of more C++-sympathetic assertion libraries available.<a class="indexterm" id="IDX-CHP-1-0086"/></p><p>To use <code class="literal">assert</code> you must <code class="literal">#include &lt;assert.h&gt;.</code> You can then write something like <code class="literal">assert(ptr != 0);</code> in your function. Preprocessor magic allows us to strip out assertions in a production build by specifying the <code class="literal">NDEBUG</code> flag to the compiler. All <code class="literal">asserts</code> will be removed, and their arguments will not be evaluated. This means that in production builds <code class="literal">asserts</code> have no overhead at all.<a class="indexterm" id="IDX-CHP-1-0087"/></p><p>Whether or not assertions <span class="emphasis"><em>should</em></span> be completely removed, as opposed to just being made nonfatal, is a debatable issue. There is a school of thought that says after you remove them, you are testing a <span class="emphasis"><em>completely different</em></span> piece of code.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-6" id="CHP-1-FN-6">6</a>]</sup> Others say that the overhead of assertions is not acceptable in a release build, so they must be eliminated. (But how often do people profile execution to prove this?)</p><p>Either way, our assertions must not have any side effects. What would happen, for example, if you mistakenly wrote:</p><a id="I_programlisting1_d1e1868"/><pre class="programlisting">
int i = pullNumberFromThinAir();
assert(i = 6);<span class="strong"><strong>// hmm - should type more carefully!</strong></span>
printf("i is %d\n", i);
</pre><p>The assertion will clearly never trigger in a debug build; its value is 6 (near enough <span class="emphasis"><em>true</em></span> for C). However, in a release build, the <code class="literal">assert</code> line will be removed completely and the <code class="literal">printf</code> will produce different output. This can be the cause of subtle problems late in product development. It's quite hard to guard against bugs in the bug-checking code!</p><p>It's not difficult to envision situations where assertions might have even more subtle side effects. For example, if you <code class="literal">assert</code>(<code class="literal">invariants()</code>);, yet the <code class="literal">invariants()</code> function has a side effect, it's not easy to spot.<a class="indexterm" id="IDX-CHP-1-0088"/><a class="indexterm" id="IDX-CHP-1-0089"/></p><p>Since assertions can be removed in production code, it is vital that only constraint testing is done with <code class="literal">assert</code>. Real error-condition testing, like memory allocation failure or filesystem problems, should be dealt with in ordinary code. You wouldn't want to compile that out of your program! Justifiable run-time errors (no matter how undesirable) should be detected with defensive code that can never be removed.</p><p>Java has a <code class="literal">similar</code> assert mechanism.<sup>[<a class="footnote" href="#ftn.CHP-1-FN-7" id="CHP-1-FN-7">7</a>]</sup> It can be enabled and disabled by controls on the JVM, and throws an exception (<code class="literal">java.lang.AssertionError</code>) instead of causing an instant program abort. .NET provides an assertion mechanism in the framework's <code class="literal">Debug</code> class.</p><div class="sidebar"><a id="offensive_programming_question"/><p class="title"><b>OFFENSIVE PROGRAMMING?</b></p><p><span class="emphasis"><em>The best defense is a good offense</em></span>.</p><p>—<span class="emphasis"><em>Proverb</em></span></p><p>While writing this chapter, I wondered, <span class="emphasis"><em>What's the opposite of defensive programming?</em></span> It's <span class="emphasis"><em>offensive programming</em></span>, of course!<a class="indexterm" id="IDX-CHP-1-0091"/></p><p>There are a number of people I know who you could call offensive programmers. But I think there's more to this than swearing at your computer and never taking baths</p><p>It stands to reason that an offensive programming approach would be actively trying to <span class="emphasis"><em>break</em></span> things in the code, rather than defending against problems. That is, actively attacking the code rather than securing it. I'd call that <span class="emphasis"><em>testing</em></span>. As we'll see later in "<a class="xref" href="ch08s02.html" title="Who, What, When, and Why?">Who, What, When, and Why?</a>" on page 132, testing, when done properly, has an incredibly positive effect on your software construction. It improves code quality greatly and brings stability to the development process.</p><p>We should be all offensive programmers.</p></div><p>When you discover and fix a fault, it is good practice to slip in an assertion where the fault was fixed. Then you can ensure that you won't be bitten twice. If nothing else, this would act as a warning sign to people maintaining the code in the future.</p><p>A common C++/Java technique for writing class constraints is to add a single memberfunction called <code class="literal">bool invariant()</code> to each class. (Naturally this function should have no side effects.) Now an <code class="literal">assert</code> can be put at the beginning and end of each member function calling this invariant. (There should be no assertion at the beginning of a constructor or at the end of the destructor, for obvious reasons.) For example, a <code class="literal">circle</code> class's invariant may check that <code class="literal">radius != 0</code>; that would be invalid object state and could cause later calculations to fail (perhaps with a divide by zero error).<a class="indexterm" id="IDX-CHP-1-0092"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-2" id="ftn.CHP-1-FN-2">2</a>] </sup>Some historians attribute this quote to Napoleon Bonaparte. Now there's a guy who knew something about defense.<a class="indexterm" id="IDX-CHP-1-0016"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-3" id="ftn.CHP-1-FN-3">3</a>] </sup>Many languages (like Java and C#) classify this as an error.<a class="indexterm" id="IDX-CHP-1-0035"/><a class="indexterm" id="IDX-CHP-1-0036"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-4" id="ftn.CHP-1-FN-4">4</a>] </sup>This doesn't replace writing good documentation, though.<a class="indexterm" id="IDX-CHP-1-0069"/><a class="indexterm" id="IDX-CHP-1-0070"/><a class="indexterm" id="IDX-CHP-1-0071"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-5" id="ftn.CHP-1-FN-5">5</a>] </sup>There is a theological debate about whether functions <span class="emphasis"><em>should</em></span> have multiple exit points.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-6" id="ftn.CHP-1-FN-6">6</a>] </sup>In practice, more may change between development and release builds of software—compiler optimization levels and the inclusion of debugging symbols, for example. Both of these can make subtle differences to execution and may obscure the manifestation of other faults. During even the earliest stages of development, testing should be performed equally with development and release builds.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-1-FN-7" id="ftn.CHP-1-FN-7">7</a>] </sup>It was added in JDK 1.4 and is not available in earlier versions.<a class="indexterm" id="IDX-CHP-1-0090"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>Draw water for the siege, strengthen your defenses! Work the clay, tread the mortar, repair the brickwork!</p><div class="attribution"><span>--<span class="attribution">Nahum 3:14</span></span></div></div><p>It is important to craft code that is not just correct but is also good. It needs to document all the assumptions made. This will make it easier to maintain, and it will harbor fewer bugs. Defensive programming is a method of expecting the worst and being prepared for it. It's a technique that prevents simple faults from becoming elusive bugs.</p><p>The use of codified constraints alongside defensive code will make your software far more robust. Like many other good coding practices (<span class="emphasis"><em>unit testing</em></span>, for example—see "<a class="xref" href="ch08s04.html" title="The Types of Test">The Types of Test</a>" on page 138), defensive programming is about spending a little extra time wisely (and early) in order to save much more time, effort, and cost later. Believe me, this <span class="emphasis"><em>can</em></span> save an entire project from ruin.<a class="indexterm" id="IDX-CHP-1-0093"/></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Care that their code is robust</p></li><li class="listitem"><p>Make sure every assumption is explicitly captured in defensive code</p></li><li class="listitem"><p>Want well-defined behavior for garbage input</p></li><li class="listitem"><p>Think carefully about the code they write, as they write it</p></li><li class="listitem"><p>Write code that protects itself from other people's (or their own) stupidity</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Would rather not think about what could go wrong in their code</p></li><li class="listitem"><p>Release code for integration that may fail and hope that someone else will sort it out</p></li><li class="listitem"><p>Leave important information about how their code should be used locked in their heads, ready to be lost</p></li><li class="listitem"><p>Apply little thought to the code they are writing, resulting in unpredictable and unreliable software</p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch08.html" title="Chapter 8. TESTING TIMES">Chapter 8</a></span></dt><dd><p><span class="emphasis"><em>Offensive programming</em></span>—say no more.</p></dd><dt><span class="term"><a class="xref" href="ch09.html" title="Chapter 9. FINDING FAULT">Chapter 9</a></span></dt><dd><p>When faults breach your careful defenses, you'll need a strategy to round them up.</p></dd><dt><span class="term"><a class="xref" href="ch12.html" title="Chapter 12. AN INSECURITY COMPLEX">Chapter 12</a></span></dt><dd><p>Defensive programming is a key technique for writing secure software systems.</p></dd><dt><span class="term"><a class="xref" href="ch19.html" title="Chapter 19. BEING SPECIFIC">Chapter 19</a></span></dt><dd><p>You must document pre- and postconditions; how else will anyone know they exist? If you have any constraints specified, then you can add defensive code to assert them.</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e2083"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207440.png"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id1"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 463.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Can you have <span class="emphasis"><em>too much</em></span> defensive programming?</p></li><li class="listitem"><p>Should you add an assertion to your code for every bug you find and fix?</p></li><li class="listitem"><p>Should assertions conditionally compile away to nothing in production builds? If not, which assertions should remain in release builds?<a class="indexterm" id="IDX-CHP-1-0094"/></p></li><li class="listitem"><p>Are exceptions a better form of defensive barrier than C-style assertions?</p></li><li class="listitem"><p>Should the defensive checking of pre- and postconditions be put <span class="emphasis"><em>inside</em></span> each function, or around each important function <span class="emphasis"><em>call</em></span>?</p></li><li class="listitem"><p>Are constraints a perfect defensive tool? What are their drawbacks?</p></li><li class="listitem"><p>Can you <span class="emphasis"><em>avoid</em></span> defensive programming?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If you designed a <span class="emphasis"><em>better</em></span> language, would defensive programming still be necessary? How could you do this?</p></li><li class="listitem"><p>Does this show that C and C++ are flawed because they have so many areas for problems to manifest?</p></li></ol></div></li><li class="listitem"><p>What sort of code do you not need to worry about writing defensively?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How carefully do you consider each statement that you type? Do you relentlessly check every function return code, even if you're <span class="emphasis"><em>sure</em></span> a function will not return an error?<a class="indexterm" id="IDX-CHP-1-0095"/></p></li><li class="listitem"><p>When you document a function, do you state the pre- and postconditions?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Are they always implicit in the description of what the function does?</p></li><li class="listitem"><p>If there are no pre- or postconditions, do you explicitly document this?</p></li></ol></div></li><li class="listitem"><p>Many companies pay lip service to defensive programming. Does your team recommend it? Take a look at the codebase—do they really? How widely are constraints codified in assertions? How thorough is the error checking in each function?</p></li><li class="listitem"><p>Are you naturally paranoid enough? Do you look both ways before crossing the road? Do you eat your greens? Do you check for every potential error in your code, no matter how unlikely?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How easy is it to do this thoroughly? Do you forget to think about errors?</p></li><li class="listitem"><p>Are there any ways to help yourself write more thorough defensive code?</p></li></ol></div></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_best_laid_plans"/>Chapter 2. THE BEST LAID PLANS</h1></div><div><h3 class="subtitle"><i>The Layout and Presentation of Source Code</i></h3></div></div></div><div class="epigraph"><p>Stop judging by mere appearances, and make a right judgment.</p><div class="attribution"><span>--<span class="attribution">John 7:24</span></span></div></div><p>Coding style has been, is, and will continue to be the subject of holy wars among programmers—professional, amateur, and student—where, unfortunately, intense disagreements degrade into mere name-calling. <span class="emphasis"><em>I'll show you where to stick your stupid brackets</em></span>.</p><p>The first company I ever worked for kick-started a process to define its internal coding standard. The guidelines were supposed to encompass several languages, defining common conventions and best practices. Months later, the group compiling the guidelines was still arguing about where to put brackets in C. I'm not sure if anyone ever followed the standard that was eventually produced.</p><p>Why <span class="emphasis"><em>do</em></span> people get so worked up about this? As we'll see, presentation dramatically affects the readability of code—no one wants to work with code that isn't easy to read. Presentation is also a very subjective and personal thing—<span class="emphasis"><em>you</em></span> may not like the style that turns <span class="emphasis"><em>me</em></span> on. Familiarity breeds comfort, and an alien style puts you on edge.<a class="indexterm" id="IDX-CHP-2-0099"/></p><p>Programmers are passionate about code, so presentation stirs deep emotions.</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="whats_the_big_deal_question"/>What's the Big Deal?</h1></div></div></div><p>The layout and presentation of code is an issue in most modern programming languages. The freedom of formatting that permits individual artistic expression came <span class="emphasis"><em>en vogue</em></span> in the early 1960s with the language Algol; the previously available Fortran versions had been more restricted in format. Since then, very few languages have deviated from that free-form approach.<a class="indexterm" id="IDX-CHP-2-0100"/><a class="indexterm" id="IDX-CHP-2-0101"/><a class="indexterm" id="IDX-CHP-2-0102"/><a class="indexterm" id="IDX-CHP-2-0103"/><a class="indexterm" id="IDX-CHP-2-0104"/><a class="indexterm" id="IDX-CHP-2-0105"/><a class="indexterm" id="IDX-CHP-2-0106"/><a class="indexterm" id="IDX-CHP-2-0107"/><a class="indexterm" id="IDX-CHP-2-0108"/><a class="indexterm" id="IDX-CHP-2-0109"/><a class="indexterm" id="IDX-CHP-2-0110"/><a class="indexterm" id="IDX-CHP-2-0111"/><a class="indexterm" id="IDX-CHP-2-0112"/></p><p>A code presentation style governs a surprisingly large number of things; brace positioning is the most obvious<sup>[<a class="footnote" href="#ftn.CHP-2-FN-1" id="CHP-2-FN-1">1</a>]</sup> and perhaps the most contentious issue. The wider aspects of code style, like conventions for function and variable naming, tie in with other coding concerns such as program structure (e.g.,<span class="emphasis"><em>Don't use</em></span> <em class="replaceable"><code>gotos</code></em>, or <span class="emphasis"><em>Only write Single Entry, Single Exit functions</em></span>) to dictate the style in which you write a program. Altogether, this constitutes your <span class="emphasis"><em>coding standard</em></span>.</p><p>Although there are many individual choices to make when you define a code presentation format, all are aesthetic. By definition, presentation has no syntactic or semantic meaning at all; the compiler ignores it.</p><p>However, presentation makes a real impact on the quality of code. Programmers read meaning into code based on its layout. It can illuminate and support your code's structure, helping the reader understand what's going on. Or it can confuse, mislead, and hide the code's intent. It doesn't matter how well designed your program is; if it looks like a thrown-together mess, it will be unpleasant to work with. But bad formatting not only makes code harder to follow; it may actually <span class="emphasis"><em>hide</em></span> bugs from you. As a simple example of this, consider the following C code:</p><a id="I_programlisting2_d1e2306"/><pre class="programlisting">
int error = doSomeMagicOperation();
if (error)
    fprintf(stderr, "Error: exiting...\n");
    exit(error);
</pre><p>The layout shows what the author meant to happen, but he'll be surprised when the code actually runs.</p><p>Since we're conscientious craftsmen committed to high-quality code, we strive for clear presentation. There are already plenty of stumbling blocks in software development; we shouldn't let basic code presentation become one of them.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-2-FN-1" id="ftn.CHP-2-FN-1">1</a>] </sup><span class="emphasis"><em>Brace</em></span> is a common name for the curly bracket (that is, { and }) so common in C-style programming languages.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="know_your_audience"/>Know Your Audience</h1></div></div></div><p>To write effective source code, it's important to know <span class="emphasis"><em>who</em></span> you're presenting it to. If you're going to confuse someone, you'd better know who deserves the apology. There are, in fact, three audiences for our source code:<a class="indexterm" id="IDX-CHP-2-0113"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Ourselves</strong></span></span></dt><dd><p>My handwriting is so bad that sometimes even <span class="emphasis"><em>I</em></span> can't read it. It's practically useless unless I concentrate on writing clearly. It's the same with code. You have to be able to read what you've written immediately after you write it, but also perhaps years later when you come back to it. Who would have expected to come back to archaic (relatively speaking) COBOL code to fix a Y2K bug?<a class="indexterm" id="IDX-CHP-2-0114"/><a class="indexterm" id="IDX-CHP-2-0115"/></p></dd><dt><span class="term"><span class="strong"><strong>The compiler</strong></span></span></dt><dd><p>The compiler doesn't care what your code looks like, as long as it doesn't have any syntactic errors. The <span class="emphasis"><em>intent</em></span> of the code is completely ignored. You can write detailed comments explaining what you <span class="emphasis"><em>want</em></span> a function to do, but the compiler won't tell you if the instructions don't actually do what your comments say. As long as it's valid code, your development environment will be happy.</p></dd><dt><span class="term"><span class="strong"><strong>Others</strong></span></span></dt><dd><p>This is the most important audience and often the least considered.</p><p>So you're working in a team, but you're the only person who will ever see your bit of code, right? Wrong. It never works that way.</p><p>You're at home writing some code for fun; no one will ever see it. You don't need to worry about making it neat, do you? No, you don't; but how would that benefit you? You aren't developing skills that will make you a professional. This is the perfect opportunity to practice really good discipline on a project with no external pressures. A chance to get into good habits. If you blow it here, is it any wonder you have no discipline on "real" projects?</p><p>Your source code is a document, describing the program you are creating. It needs to read clearly to whoever might come back to it. This will include those auditing (code reviewing) the work you have done and anyone who maintains it later. Be kind to people who have to look after your code—just imagine yourself in their shoes.</p></dd></dl></div><p>We tailor the elements of presentation style with our audiences in mind. How does the audience affect how we lay out code? Surprisingly, we care least of all about the compiler. Its job is to ignore all that unnecessary whitespace and get down to the serious business of interpreting our syntax. Presentation is not about syntactic meaning, and the compiler can cope with whatever freakish layout we throw at it.</p><p>Rather, we use layout to emphasize the <span class="emphasis"><em>logical structure</em></span> of the code to human readers. It's about communication, and the clearer the better.<a class="indexterm" id="IDX-CHP-2-0116"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Understand the real audience for your source code: other programmers. Write for their benefit</em></span>.<a class="indexterm" id="IDX-CHP-2-0117"/></p></dd></dl></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_is_good_presentation_question"/>What Is Good Presentation?</h1></div></div></div><p>As you can see, good presentation means more than just being neat. Tidy code certainly gives an impression of high quality, but code can be both tidy <span class="emphasis"><em>and</em></span> misleading. We strive for <span class="emphasis"><em>clear</em></span> layout; the code structure must be <span class="emphasis"><em>enhanced</em></span> by an indentation strategy, not hidden by it. If a particular flow of control is necessarily complex, the layout should be helping you to read the code. (If you've written a flow of control that is unnecessarily complex, you should change it immediately.)<a class="indexterm" id="IDX-CHP-2-0118"/><a class="indexterm" id="IDX-CHP-2-0119"/><a class="indexterm" id="IDX-CHP-2-0120"/><a class="indexterm" id="IDX-CHP-2-0121"/></p><p>Our code layout must convey meaning, rather than disguise it. I suggest the following as good metrics for the quality of a presentation style.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Consistent</strong></span></span></dt><dd><p>The indentation strategy must be consistent across the project. Don't change styles halfway through a source file. Not only does this look unprofessional, it can confuse and give the impression that your source files are not really related.</p><p>The individual presentation rules should be internally consistent. The positioning of braces, brackets, and so on in different situations should all follow a single convention. The number of spaces of indent should always be the same.<a class="indexterm" id="IDX-CHP-2-0122"/></p><p>Kernighan and Ritchie—the fathers of C—say, after stressing the importance of having good indentation: "The position of braces is less important, although people hold passionate beliefs. We have chosen one of several popular styles. Pick a style that suits you, then use it consistently." (Kernighan Ritchie 88)<a class="indexterm" id="IDX-CHP-2-0123"/></p></dd><dt><span class="term"><span class="strong"><strong>Conventional</strong></span></span></dt><dd><p>It's sensible to adopt one of the major styles currently in use in the industry rather than invent your own indentation rules. You can be sure of it being accessible to others who are reading your code. And you're less likely to make people vomit.</p></dd><dt><span class="term"><span class="strong"><strong>Concise</strong></span></span></dt><dd><p>Can you concisely describe your indentation strategy? Think about it. If you do <span class="emphasis"><em>this</em></span> unless <span class="emphasis"><em>such-and-such</em></span>, in which caseyou do <span class="emphasis"><em>this</em></span> if <span class="emphasis"><em>X</em></span> holds; otherwise you do something else which depends on . . .</p><p>Someone may eventually need to extend the code you've written and should do so in the same style. If it's not easy to pick up, then is it really a useful presentation style?</p></dd></dl></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="brace_yourself"/>Brace Yourself</h1></div></div></div><p>To illustrate the impact presentation has on source code and the trade-offs involved in choosing a particular style, this case study investigates an important C-related layout issue. By looking at the variation in this one simple area, we'll see how important presentation is and what a profound impact it has on your code.</p><p><span class="emphasis"><em>Brace positioning</em></span> is a big concern for the curly bracket languages, although it's really only a fraction of the total code layout problem. As the most immediately visible artifact, it generates about 80 percent of the fuss. Other languages have their own similar layout concerns.</p><p>There are a number of conventional brace positioning styles. Which you pick comes down to your sense of aesthetics, the culture you code in, and what you're used to. Different styles are appropriate in different contexts—consider a magazine article versus a source editor (see "<a class="xref" href="ch02s04.html#well_presented" title="WELL PRESENTED">WELL PRESENTED</a>" on page 28). You may prefer the exdented style, but in a magazine you're forced to use K&amp;R to maximize use of the printed page.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="kr_brace_style"/>K&amp;R Brace Style</h2></div></div></div><p><span class="emphasis"><em>K&amp;R</em></span> style is the oldest flavor, established by the fathers of C Kernighan and Ritchie in their book <span class="emphasis"><em>The C Programming Language</em></span>. (Kernighan Ritchie 88) For this reason, it is often considered the <span class="emphasis"><em>original and best</em></span>. It was driven by the need to display the most information possible on a small screen. It's probably the dominant style for Java code.<a class="indexterm" id="IDX-CHP-2-0124"/><a class="indexterm" id="IDX-CHP-2-0125"/><a class="indexterm" id="IDX-CHP-2-0126"/></p><a id="I_programlisting2_d1e2506"/><pre class="programlisting">
int k_and_r() {
    int a = 0, b = 0;
    while (a != 10) {
        b++;
        a++;
    }
    return b;
}
</pre><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Pros</strong></span></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Takes up little room, so you can get more code on screen at once</p></li><li class="listitem"><p>The closing brace lines up with the statement it matches, so you can scan up to find the construct being terminated</p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Cons</strong></span></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The braces don't line up, so it's hard to visually match them</p></li><li class="listitem"><p>You might not notice if an opening brace goes off the right of the page</p></li><li class="listitem"><p>Code statements appear very densely packed</p></li></ul></div></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="exdented_brace_style"/>Exdented Brace Style</h2></div></div></div><p>A more spacious approach is the so-called <span class="emphasis"><em>exdented</em></span> (or sometimes <span class="emphasis"><em>Allman</em></span>) style. This is my personal favorite.<a class="indexterm" id="IDX-CHP-2-0127"/><a class="indexterm" id="IDX-CHP-2-0128"/><a class="indexterm" id="IDX-CHP-2-0129"/><a class="indexterm" id="IDX-CHP-2-0130"/></p><a id="I_programlisting2_d1e2561"/><pre class="programlisting">
int exdented()
{
    int a = 0, b = 0;
    while (a != 10)
    {
        b++;
        a++;
    }
    return b;
}
</pre><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Pros</strong></span></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A clear and uncluttered format</p></li><li class="listitem"><p>Easier to scan code for opening braces since they're distinct; this makes each code block more obvious</p></li></ul></div></dd><dt><span class="term"><span class="strong"><strong>Cons</strong></span></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Takes up more vertical space</p></li><li class="listitem"><p>Looks wasteful when you have lots of blocks containing only one statement</p></li><li class="listitem"><p>Too much like Pascal for some hackers<a class="indexterm" id="IDX-CHP-2-0131"/></p></li></ul></div></dd></dl></div><div class="sidebar"><a id="well_presented"/><p class="title"><b>WELL PRESENTED</b></p><p>How you present code depends on the context in which it will be read. There are more contexts than you might think. When you're reading some code, it's important to appreciate the forces that drove its presentation. The common code habitats are:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source editor</strong></span></span></dt><dd><p>This is most code's natural habitat. It raises all the presentation concerns programmers automatically think about. The code is read on a computer screen, usually in some dedicated editor or IDE. You scroll or navigate through a file to places of particular interest. It's an interactive world—more often than not, you're reading code to <span class="emphasis"><em>make modifications</em></span>. This means that the code has to be malleable.</p><p>The editor may have horizontal scrollbars for long lines or may limit the page width and wrap them. Usually there's syntax coloring to aid comprehension. As you type, the editor performs some formatting work for you. For example, it intelligently positions the cursor on new lines.</p></dd><dt><span class="term"><span class="strong"><strong>Published code</strong></span></span></dt><dd><p>Unless you live in a lonely, isolated little world, you'll regularly read published code. There are plenty of forums: listings in books and magazines, snippets fromlibrary documentation, or even lines in postings to newsgroups. These are formatted forclarity, but also favor a more compact representation since space is not cheap. Lines arecompressed vertically to get the most code into a short space, and they are compressed horizontally to fit into narrow print margins.<a class="indexterm" id="IDX-CHP-2-0132"/></p><p>This sort of code tends to omit error handling and anything not pertinent to the main idea of the example. It only serves to convey a point, not to be thorough.</p><p>You may never have to write code for this medium, but you'll certainly see plenty of it (you're reading code snippets in this <span class="emphasis"><em>book</em></span>, at least). You need to understand the trade-offs and differences from normal code, so you don't unwittingly pick up any bad habits.</p></dd><dt><span class="term"><span class="strong"><strong>Printouts</strong></span></span></dt><dd><p>When you print out project code you run into new issues. Column widths become a problem. Should you reformat before you print, scale pages down and cope with small fonts, or have haphazard line wrapping? There's no syntax coloring to enhance presentation (unless you're rich enough for a color printer and all that ink), so messy commenting or code disabled by large comment blocks suddenlybecomes less obvious.</p><p>Although you may never print out a page of source, these are valid concerns that you should consider.</p></dd></dl></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="indented_brace_style"/>Indented Brace Style</h2></div></div></div><p>Less common but still used is the <span class="emphasis"><em>indented</em></span> style. Here the braces are indented with the code. It's also known as the <span class="emphasis"><em>Whitesmith</em></span> style, since example code for the early Whitesmith's C compiler used it.<a class="indexterm" id="IDX-CHP-2-0133"/><a class="indexterm" id="IDX-CHP-2-0134"/><a class="indexterm" id="IDX-CHP-2-0135"/><a class="indexterm" id="IDX-CHP-2-0136"/><a class="indexterm" id="IDX-CHP-2-0137"/></p><a id="I_programlisting2_d1e2668"/><pre class="programlisting">
int indented()
    {
    int a = 0, b = 0;
    while (a != 10)
        {
        b++;
        a++;
        }
    return b;
    }
</pre><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Pro</strong></span></span></dt><dd><p>Links code blocks to the braces that contain them</p></dd><dt><span class="term"><span class="strong"><strong>Con</strong></span></span></dt><dd><p>Many people don't like their blocks linked to their braces</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="other_brace_styles"/>Other Brace Styles</h2></div></div></div><p>There are others. For example, the <span class="emphasis"><em>GNU</em></span> style is sandwiched between exdented and indented; braces are placed halfway between each level of indent. There are also hybrids; the Linux kernel coding style is half K&amp;R, half exdented. Most C# programmers also combine layout styles. If you're really perverse, you'll like this:<a class="indexterm" id="IDX-CHP-2-0138"/></p><a id="I_programlisting2_d1e2698"/><pre class="programlisting">
  int my_worst_nightmare()
  {
int a = 0, b = 0;
while (a != 10) {
        b++;
        a++;
        }
return b;
  }
</pre><p>I've seen plenty of surreal code like it, and I'm sure you could concoct something of equally nightmarish proportions if you tried.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Recognize the common code layout styles for your chosen language, and become familiar working with each of them. Appreciate their advantages and disadvantages</em></span>.</p></dd></dl></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="one_style_to_rule_them_all"/>One Style to Rule Them All</h1></div></div></div><p>Having seen seen what constitutes a good coding style, what it governs, and why it's necessary, you must now actually choose one. This is where the fights begin. Disciples of one presentation religion clash with the evangelists of the next, leading to programmer civil war. But the craftsman steps back from these petty squabbles and takes a more balanced view.<a class="indexterm" id="IDX-CHP-2-0139"/><a class="indexterm" id="IDX-CHP-2-0140"/><a class="indexterm" id="IDX-CHP-2-0141"/><a class="indexterm" id="IDX-CHP-2-0142"/></p><p>As long as you write in a style that's good, it doesn't matter what style that is. And there's no point in arguing about it. There is more than one good style; the quality and applicability of each will depend on context and culture.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Pick a single</em></span> good <span class="emphasis"><em>coding style, and stick to it</em></span>.</p></dd></dl></div><p>It could be argued that if your language standard defined the One True Presentation Style, the world would be a better place. After all, all code would look the same. The arguments would cease, and we'd all move on to something more useful instead. You could pick up anyone's code and get to grips with it immediately. Sounds pretty good, doesn't it?</p><p>The counterargument is <span class="emphasis"><em>competition is a Good Thing</em></span>. If we had a single monopoly coding style, who would be able to say that it was the best one? By having more than one coding style, we are encouraged to think and improve the way we apply a style. It encourages style guidelines to improve. The upshot: It makes us write better code.<a class="indexterm" id="IDX-CHP-2-0143"/></p><p>That argument is <span class="emphasis"><em>not</em></span> a license to code in your own particular style, though. Remember that good presentation is <span class="emphasis"><em>conventional</em></span>—a layout that readers expect.</p><div class="sidebar"><a id="common_coding_standards"/><p class="title"><b>COMMON CODING STANDARDS</b></p><p>A number of well-known coding standards are generally used.<a class="indexterm" id="IDX-CHP-2-0144"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Indian Hill</strong></span></span></dt><dd><p>The full title of this famous document is Indian <span class="emphasis"><em>Hill Recommended C Styleand Coding Standards</em></span>. It has nothing to do with Native Americans standing on mounds of earth; instead, it came from the renowned Indian Hill AT&amp;T Bell lab.</p></dd><dt><span class="term"><span class="strong"><strong>GNU</strong></span></span></dt><dd><p><span class="emphasis"><em>The GNU's Coding Standards</em></span> are important since they influence most of the commonly used open source or free software out there. You can find them on the GNU Project's website (<a class="ulink" href="http://www.gnu.org">www.gnu.org</a>).</p></dd><dt><span class="term"><span class="strong"><strong>MISRA</strong></span></span></dt><dd><p>The UK's <span class="emphasis"><em>Motor Industry Software Reliability Association (MISRA)</em></span> has defined a well-known set of standards for writing safety critical embedded software in C. It consists of 127 guidelines, and a number of tools exist to validate your code against them. These guidelines are focused more on language use than code layout.</p></dd><dt><span class="term"><span class="strong"><strong>Project foo</strong></span></span></dt><dd><p>Most every project under the sun defines its own pet coding style. Just go on a hunt, and you'll find literally thousands. The Linux kernel, for example, has its own guidelines, as does the Mozilla project.</p></dd></dl></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="house_styles_open_parenthesis_and_where_to"/>House Styles (and Where to Stick Them)</h1></div></div></div><p>Many software companies have an internal (<span class="emphasis"><em>house</em></span> ) coding stylethat defines, among other things, its code presentation rules. But why bother—code that's been written in any good style is easy to read and maintain. If no one will have ahard time following it, do we really need this extra level of bureaucracy?<a class="indexterm" id="IDX-CHP-2-0145"/><a class="indexterm" id="IDX-CHP-2-0146"/><a class="indexterm" id="IDX-CHP-2-0147"/><a class="indexterm" id="IDX-CHP-2-0148"/></p><p>House styles <span class="emphasis"><em>are</em></span> important and useful for a number of reasons. If everyone sings from the same hymn book (perhaps that should be <span class="emphasis"><em>writes</em></span> on the same hymn book), then all source code will be consistent and homogenized. What value does this bring? It increases the code quality and makes software development safer. Here's how:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Any code released outside the organization will be neatly presented and coherent, appearing to be well thought out. Having many conflicting styles in one project looks careless and unprofessional.</p></li><li class="listitem"><p>The company can be assured that programs are written up to a certain standard, thanks to common idioms and methodologies. This doesn't guarantee good code, but it does help to protect against bad code.</p></li><li class="listitem"><p>It makes up for poor tools; IDEs set in different ways will fight against each other, pulling code apart and generally molesting the layout. A standard provides level ground (and a common enemy for all the programmers).</p></li><li class="listitem"><p>The appeal of being able to instantly recognize the shape of your peers' code and to quickly make appropriate maintenance alterations is clear. It saves reading time and therefore the company's money.<a class="indexterm" id="IDX-CHP-2-0149"/></p></li><li class="listitem"><p>Since the programmers won't be continually reformatting the code to suit their particular aesthetic fetishes, your version control history is very useful. If Fred reformats Bert's code to "his" style, what happens when, a bit later on, you look at a diff? Many diff tools are pretty crude and will now display a plethora of trivial whitespace and brace differences.</p></li></ul></div><p>These house coding standards are a Good Thing. Even if you don't actually agree with the rules they mandate—if, for example, your indentation strategy is much prettier and easier to understand (in your opinion)—it shouldn't matter one iota. The benefits of everyone sharing the same style outweigh the burden on you to have to conform. If you don't agree with the standard, you should still work to it.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>If your team already has a coding standard, then use it. Don't use your own pet style</em></span>.</p></dd></dl></div><p>You may be surprised to find how much of your coding style is bred from familiarity and practice. If you use a house style for a while, it soon becomes second nature and seems perfectly normal.<a class="indexterm" id="IDX-CHP-2-0150"/><a class="indexterm" id="IDX-CHP-2-0151"/></p><p>What happens if you're working on code that originated from outside the company and doesn't conform to your house style? In this case, it makes more sense to write code conforming to the <span class="emphasis"><em>existing</em></span> style of that source file. (This is why writing to a style that's easy to pick up is important.) The only other real alternative is to convert the file (and any others) into your house style. For most Real World projects, this latter course of action isn't feasible, especially if you are continually being fed with external source code updates.<a class="indexterm" id="IDX-CHP-2-0152"/><a class="indexterm" id="IDX-CHP-2-0153"/></p><p>Conform to the style of a given file or project, conform to your house style where this doesn't conflict, and sacrifice your own preferences. Don't surrender your style blindly, though; understand the benefits weighed against the costs. And what if your company doesn't have a house style? Push for one. . . .</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e2910"/><img alt="House Styles (and Where to Stick Them)" src="tagoreillycom20080909nostarchimages207444.png"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="setting_the_standard"/>Setting the Standard</h1></div></div></div><p>You've been tasked to draw up a code presentation style where there currently is none. Good luck! You can be sure that everyone will have an opinion on what the style should contain and that no one will be completely satisfied with the end result. Techies are helpful like that.<a class="indexterm" id="IDX-CHP-2-0154"/></p><p>Creating a coding standard is a delicate task, and it should be approached tactfully but firmly. Why? Dumping edicts upon a group of programmers will neither make you nor your standard popular. But if you don't emphasize how important it is, programmers will not embrace it and will continue coding in their own peculiar ways.</p><p>The difficulty of this task depends on the people in the team:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>How many programmers there are</p></li><li class="listitem"><p>How they code as individuals</p></li><li class="listitem"><p>How similar their coding styles are already</p></li><li class="listitem"><p>Whether they actually <span class="emphasis"><em>want</em></span> a standard or not</p></li><li class="listitem"><p>Whether they are prepared to change their styles at all</p></li></ul></div><p>If their coding styles are all reasonably similar, then the job's a breeze. If they vary wildly, you're in for a bumpy ride. While people seldom agree on the best style, they will generally agree that some styles are better than others. You must aim to provide a sufficiently detailed set of layout directives while trying to satisfy as many programmers as possible—<span class="emphasis"><em>and</em></span> produce something that will help them to work better as a team. Here's a collection of pragmatic advice for this herculean task:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>What's it for?</strong></span></span></dt><dd><p>Start off with a clear idea of the scope of the work—is the coding standard just for your immediate team, the department, or the whole company? This makes a big difference in how you'll develop and implement it.</p><p>Remember: What makes a good personal style is not necessarily the best for a whole team of programmers. You are creating something that shouldn't just serve <span class="emphasis"><em>your</em></span> aesthetic fetishes; it should be a standard that will unite team code and avoid common problems. Keep this goal in mind as your develop the standard.<a class="indexterm" id="IDX-CHP-2-0155"/></p><p>Determine the level of detail you intend to go into. Is this just a code layout document, or will it also touch on language usage concerns? It's best to keep it simple: Write one document for presentation and a different document for language use.</p></dd><dt><span class="term"><span class="strong"><strong>Get buy-in</strong></span></span></dt><dd><p>Involve everyone on the team, so <span class="emphasis"><em>they</em></span> own it. If the programmers feel like they contributed, they'll be more likely to follow the standard.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Get everyone to agree that a standard is needed <span class="emphasis"><em>before</em></span> you start working on it. Make sure the team understands the benefits of code consistency and the perils of ad-hoc code presentation.</p></li><li class="listitem"><p>If you have more than a few programmers, <span class="emphasis"><em>don't</em></span> try to design the standard by committee. Well, not unless you hide all the sharp objects in the office first. Select a small crack team to get the work done.</p></li></ul></div><p>When the standard nears completion, review it with a panel of adopters. Make sure that you have a chairman who can make a final decision though, or everything will stall while 15 programmers sidetrack themselves in religious disputes.</p></dd><dt><span class="term"><span class="strong"><strong>Produce something</strong></span></span></dt><dd><p>The end product should be an accessible document, not just a fuzzy set of agreed conventions. You should be able to refer to the document later, and point newcomers at it. The document contains a list of the rules, perhaps with justification for the more contentious decisions.</p></dd><dt><span class="term"><span class="strong"><strong>Standardize best practice</strong></span></span></dt><dd><p>Make sure the standard embodies the team's current best practices—let them know that they're doing things right. If there's nothing that comes out of the blue, they will be more likely to adopt it. However, if you include random conventions from outside the team's experience, they'll revolt.</p></dd><dt><span class="term"><span class="strong"><strong>Focus on what matters</strong></span></span></dt><dd><p>Concentrate your efforts on the things that really matter and will make the biggest improvements to your team's code. Don't try to create a presentation standard for C, C++, <span class="emphasis"><em>and</em></span> Java if you only ever use C.</p></dd><dt><span class="term"><span class="strong"><strong>Avoid hotspots</strong></span></span></dt><dd><p>Leave rare-but-tedious cases to individual taste if they won't actually make much difference. If people get really worked up over the layout of split lines in an <code class="literal">if</code> statement, give up and let them do what they want.</p><p>Don't be too restrictive; allow the rules to be broken if a violation can genuinely be justified.</p></dd><dt><span class="term"><span class="strong"><strong>Do it in pieces</strong></span></span></dt><dd><p>A sensible approach is to develop your house style <span class="emphasis"><em>a bit at a time</em></span>. Start by agreeing on brace layout and indent size. Just that. It will be difficult enough! Once you have that in place, progress will be <span class="emphasis"><em>much</em></span> easier; any change is just more of the same. At some point, it won't be worth adding new rules, since the code will be sufficiently regular.</p></dd><dt><span class="term"><span class="strong"><strong>Plan for adoption</strong></span></span></dt><dd><p>Have a clear idea how this coding standard will be adopted. Be realistic. People have to be happier <span class="emphasis"><em>with</em></span> it, or they won't use it. Adoption will have to be based on some form of majority rule; if Fred still thinks that <code class="literal">switch</code> statements look better his way when everyone else managed to compromise, <span class="emphasis"><em>too bad, Fred</em></span>. Don't be tempted to make it a democratic process, though. That just won't work.</p><p>Don't threaten people with the standard or induce punishments for not using it. That's not going to go down well. Instead, offer incentives—even if it's just public kudos in a code review.</p><p>Ultimately, the take-up of a standard depends on the authority with which it is introduced. Either the programmers themselves authorize it or the process gets management to back it. Or it's a big waste of time.</p></dd></dl></div><p>Does this sound like trying to persuade a load of school children to get along and play nicely? Funny, isn't it. . . . Still, you'll wade your way through a religious quagmire, emerging on the other side with a house style that will genuinely improve your team's code. Once the wounds heal, it will have been worth it.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="righteous_wars_question"/>Righteous Wars?</h1></div></div></div><div class="epigraph"><p>The quickest way of ending a war is to lose it.<a class="indexterm" id="IDX-CHP-2-0156"/><a class="indexterm" id="IDX-CHP-2-0157"/></p><div class="attribution"><span>--<span class="attribution">George Orwell</span></span></div></div><p>Engaging in holy wars over code layout is unproductive and a waste of time; there are far more important things to focus our attention on. But beware—code layout is not the only hot potato in the programming community. You could extend this to cover editors, compilers, methodologies, the One True Language,<sup>[<a class="footnote" href="#ftn.CHP-2-FN-2" id="CHP-2-FN-2">2</a>]</sup> and beyond.</p><p>These little commotions have been going on for years. They'll continue to go on. And no one will <span class="emphasis"><em>ever</em></span> win. No one will ever manage to establish the <span class="emphasis"><em>right</em></span> answer, because there is no right answer. These arguments are just an opportunity for one person to try to enforce his or her particular (carefully formed) opinion on others, and vice versa. After all, my opinion <span class="emphasis"><em>must</em></span> be right, because it's <span class="emphasis"><em>mine</em></span>. It's like trying to knit spaghetti—amusing for a while, but messy and totally pointless. It's usually only ever immature programmers that get involved. (The old-timers are already argued out.)</p><p>The key point to learn is: Holy wars are a waste of effort. As a professional, you should step back from such petty arguments. Of course, have an educated personal opinion, but don't arrogantly presume that it's correct.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Holy wars</em></span>: Just say no. <span class="emphasis"><em>Don't get involved. Walk away</em></span>.</p></dd></dl></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-2-FN-2" id="ftn.CHP-2-FN-2">2</a>] </sup>This brings to mind a C/C++ programming conference I attended some years ago. A speaker presented his discovery that you get fewer bugs (which are easier to fix) using Pascal rather than C, while the most difficult to fix and numerous bugs occur in C++. The reaction was wonderful—everyone's feathers were ruffled!</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id1"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>Nothing succeeds like the appearance of success.<a class="indexterm" id="IDX-CHP-2-0158"/></p><div class="attribution"><span>--<span class="attribution">Christopher Lasch</span></span></div></div><p>Presentation is one of the key features differentiating good code from bad code. Programmers glean a lot from code's appearance, so it <span class="emphasis"><em>is</em></span> right to worry about layout. It's an important skill to be able to sensitively lay out code for maximum clarity, within the guidelines of any company coding standard that may exist.</p><div class="sidebar"><a id="looking_for_a_fight"/><p class="title"><b>LOOKING FOR A FIGHT</b></p><p>Code layout is not the only excuse for a programmer flame war. There are many religious subjects that you'd best tactfully dodge for the sake of your blood pressure. Watch out for:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>My OS is better than yours</strong></span></span></dt><dd><p>. . . because it scales from a wristwatch to an alien mothership, only requires rebooting once every epoch, and performs most operations with a single two letter command.</p><p>But <span class="emphasis"><em>mine's</em></span> better than yours because you'll never see a single piece of text using it, it's tastefully color coordinated, and it can be operated by a blind squirrel. Anything you can't do with it is illegal in most civilized countries, anyway.</p></dd><dt><span class="term"><span class="strong"><strong>My editor is better than yours</strong></span></span></dt><dd><p>. . . because it recognizes more than a million different syntax schemes, can edit files written in hieroglyphics, and each of its 400 operations are accessible with fewer than 10 simultaneous keystrokes. You can use it on the desktop, from a command line, over a modem, through a rising main, and over 128-bit encrypted smoke signals.</p><p>But <span class="emphasis"><em>mine's</em></span> better than yours because it integrates with my underwear and knows what I want to type before I've even thought of it myself.</p></dd><dt><span class="term"><span class="strong"><strong>My language is better than yours</strong></span></span></dt><dd><p>. . . because it implements the artificial intelligence of most major governmentsand is clever enough to interpret random gesticulations as meaningful sequences instructions.</p><p>But <span class="emphasis"><em>mine's</em></span> better than yours because it allows you to write in haiku and encodes information in combinations of whitespace characters.</p></dd></dl></div></div><p>It's reasonable to assume that code that has been carefully laid out will have been carefully designed. It's even more reasonable to assume that sloppily presented code hasn't been designed with much care. But there's more to this story than formatting source code.<a class="indexterm" id="IDX-CHP-2-0159"/></p><p>Besides presentation skills, there are certain <span class="emphasis"><em>attitudes</em></span> that separate good programmers from bad programmers. The moral is simple: <span class="emphasis"><em>Avoid creating hot air</em></span>. Computers will do that for you (we don't need in-office heating because ours belch out so much heat). Know what you like and be <span class="emphasis"><em>prepared</em></span> to defend it, to put your view across—but don't presume that you have to win or that you have to be right, and don't arrogantly do your own thing anyway.<a class="indexterm" id="IDX-CHP-2-0160"/></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Avoid pointless arguments and are sensitive to others' opinions</p></li><li class="listitem"><p>Are humble enough to know that they're not right all the time</p></li><li class="listitem"><p>Know how code layout impacts readability and strive for the clearest code possible</p></li><li class="listitem"><p>Will adopt a house style even if it contradicts their personal preferences</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Are close-minded and opinionated—<span class="emphasis"><em>My view isthe right one</em></span></p></li><li class="listitem"><p>Argue with anyone over the most trivial things; it's a chance to prove their superiority</p></li><li class="listitem"><p>Have no consistent personal coding style</p></li><li class="listitem"><p>Trample over others' code in their own style</p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id1"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch03.html" title="Chapter 3. WHAT'S IN A NAME?">Chapter 3</a></span></dt><dd><p>A coding standard may mandate how you create names.</p></dd><dt><span class="term"><a class="xref" href="ch04.html" title="Chapter 4. THE WRITESTUFF">Chapter 4</a></span></dt><dd><p>Good presentation is key to writing code that's self-documenting.</p></dd><dt><span class="term"><a class="xref" href="ch05.html" title="Chapter 5. A PASSING COMMENT">Chapter 5</a></span></dt><dd><p>Describes how we write comments; some comment use relates to source code layout.</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e3270"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207448.png.jpg"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id2"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 466.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id1"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Should you alter the layout of legacy code to conform to your latest code style? Is this a valuable use of code reformatting tools?</p></li><li class="listitem"><p>A common layout convention is to split source lines at a set number of columns. What are the pros and cons of this? Is it useful?</p></li><li class="listitem"><p>How detailed should a <span class="emphasis"><em>reasonable</em></span> coding standard be?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How serious are deviations from the style? How many limbs should be amputated for not following it?</p></li><li class="listitem"><p>Can a standard become too detailed and restrictive? What would happen if it did?</p></li></ol></div></li><li class="listitem"><p>When defining a new presentation style, how many items or cases need layout rules? What other presentation rules must be provided? List them.<a class="indexterm" id="IDX-CHP-2-0161"/></p></li><li class="listitem"><p>Which is more important—good code <span class="emphasis"><em>presentation</em></span> or good code <span class="emphasis"><em>design</em></span>? Why?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id1"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Do you write in a consistent style?<a class="indexterm" id="IDX-CHP-2-0162"/><a class="indexterm" id="IDX-CHP-2-0163"/><a class="indexterm" id="IDX-CHP-2-0164"/><a class="indexterm" id="IDX-CHP-2-0165"/><a class="indexterm" id="IDX-CHP-2-0166"/><a class="indexterm" id="IDX-CHP-2-0167"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>When you work with other people's code, which layout style do you adopt—theirs or your own?</p></li><li class="listitem"><p>How much of your coding style is dictated by your editor's auto-formatting? Is this an adequate reason for adopting a particular style?</p></li></ol></div></li><li class="listitem"><p>Tabs: Are they a work of the devil, or the best thing since sliced bread? Explain why.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Do you know if your editor inserts tabs automatically? Do you know what your editor's tab stop is?</p></li><li class="listitem"><p>Some <span class="emphasis"><em>hugely</em></span> popular editors indent with a mixture of tabs and spaces. Does this make the code any less maintainable?</p></li><li class="listitem"><p>How many spaces should a tab correspond to?</p></li></ol></div></li><li class="listitem"><p>Do you have a preferred layout style?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Describe it in a series of simple statements. Be complete. Include, for example, how you format <code class="literal">switch</code> statements and split up long lines.</p></li><li class="listitem"><p>How many statements did it take? Is that what you expected?</p></li><li class="listitem"><p>Does your company have a coding standard?</p></li><li class="listitem"><p>Do you know where it is? Is it advertised? Have you read it?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If yes: Is it any good? Perform an honest critique, and feed your comments back to the document owners.</p></li><li class="listitem"><p>If no: Should it? ( Justify your answer.) Is there a common unwritten code style that everyone adopts? Can you drive the adoption of a standard?</p></li></ol></div></li><li class="listitem"><p>Is there <span class="emphasis"><em>more</em></span> than one standard used, perhaps one per project? If so, how is code shared among projects?</p></li></ol></div></li><li class="listitem"><p>How many different layout styles have you followed?<a class="indexterm" id="IDX-CHP-2-0168"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Which did you feel most comfortable with?</p></li><li class="listitem"><p>Which was the most rigorously defined?</p></li><li class="listitem"><p>Is there a link?</p></li></ol></div></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_apostrophy_s_in_a_name_question"/>Chapter 3. WHAT'S IN A NAME?</h1></div><div><h3 class="subtitle"><i>Giving Meaningful Things Meaningful Names</i></h3></div></div></div><div class="epigraph"><p>When I use a word, Humpty Dumpty said, in a rather scornful tone, it means just what I choose it to mean—neither more nor less.</p><div class="attribution"><span>--<span class="attribution">Lewis Carroll</span></span></div></div><p>Ancient civilizations knew that to name something was to have power over it. This was more than a simple claim to possession. Some believed so strongly in the power of names that they would never give their own names to strangers, for fear the strangers might use it to inflict harm against them.</p><p>Names mean an awful lot. You may not live in fear of them, but don't underestimate the power of a name. A name describes:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Identity</strong></span></span></dt><dd><p>Names are fundamental to our concept of identity. There are examples throughout history—even before 2000 Bc, there are Biblical examples of meaningful place names and children named to reflect circumstances. In most cultures it's still convention for a woman to change her last name when she gets married, although the fact that some women choose not to shows how they attribute significant meaning to their names.<a class="indexterm" id="IDX-CHP-3-0169"/><a class="indexterm" id="IDX-CHP-3-0170"/></p></dd><dt><span class="term"><span class="strong"><strong>Behavior</strong></span></span></dt><dd><p>A name not only promotes identity, but also implies behavior. Obviously, a name doesn't dictate what an object does, but it will influence how you interact with it and how the outside world interprets it. We're never fixed to one name per object. I'm known by different monikers in different contexts: the name my wife calls me,<sup>[<a class="footnote" href="#ftn.CHP-3-FN-1" id="CHP-3-FN-1">1</a>]</sup> the name my daughters know me by, the nickname I use in chat rooms, and so on. These names indicate different relationships and interactions with me and the roles I fulfil.</p></dd><dt><span class="term"><span class="strong"><strong>Recognition</strong></span></span></dt><dd><p>A name marks something as a distinct entity. It elevates it from ethereal concept to well-defined reality. Before someone put a name to electricity, no one would have understood what it was, although they might have some vague idea of its effects by watching lightning or Benjamin Franklin's demonstrations. Once named, it became identifiable as a distinct force and, consequently, easier to reason about. The Basque culture believes that naming something proves its existence: <span class="emphasis"><em>Izena duen guzia omen da</em></span> —That which has a name exists. (Kurlansky 99)</p></dd></dl></div><p>Today the act of naming has become a multimillion-dollar business, used (with varying degrees of success) by small firms, the largest multinational corporations, and everything in between. To launch, rebrand, and publicize products, these organizations need newer, ever more catchy names. These names help to build awareness of products and services.</p><p>Clearly, names are of immense importance.</p><p>As programmers, we wield this enormous power over our constructs when we name them. A badly named entity can be more than just inconvenient; it can be misleading and even downright dangerous. As a very simplistic example, consider the following C++ code:</p><a id="I_programlisting3_d1e3481"/><pre class="programlisting">
void checkForContinue(bool weShouldContinue)
{

    if (weShouldContinue) abort();

}
</pre><p>The parameter name is clearly a lie, or at least its sense is the opposite of what you'd expect. The function will not perform as anticipated and, as a consequence, your program will abort—a reasonably dire result from a single misnamed variable.</p><p><span class="emphasis"><em>Sticks and stones may break my bones, but names will never hurt me</em></span>. Not true.</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="why_should_we_name_well_question"/>Why Should We Name Well?</h1></div></div></div><p>We need to carefully consider the names we give things. Remember that writing source code is all about clear communication. A name creates a channel of understanding, control, and mastery. Appropriate naming means that <span class="emphasis"><em>to know the name is to know the object</em></span>.<a class="indexterm" id="IDX-CHP-3-0171"/></p><p>Good names really matter. The human brain can only hold about seven pieces of information concurrently<sup>[<a class="footnote" href="#ftn.CHP-3-FN-2" id="CHP-3-FN-2">2</a>]</sup> (although I'm sure I have a couple of defective slots, reducing this capacity). It's already hard enough to cram all the information about a program into your head; we should not add complexnaming schemes or require obscure references to make this task even harder.</p><p>Clear naming is one of the hallmarks of well-crafted code. The ability to name things well is an important skill of the code craftsman—he'll work hard to write easy-to-read code.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Learn to name things</em></span> transparently—<span class="emphasis"><em>an object's name should describe it clearly</em></span>.</p></dd></dl></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-1" id="ftn.CHP-3-FN-1">1</a>] </sup>Which depends on whether she's in a good or bad mood at the time!</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-2" id="ftn.CHP-3-FN-2">2</a>] </sup>This is known as the <span class="emphasis"><em>Miller number</em></span>, after George A. Miller's psychological research. (Miller 56)<a class="indexterm" id="IDX-CHP-3-0172"/><a class="indexterm" id="IDX-CHP-3-0173"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_do_we_name_question"/>What Do We Name?</h1></div></div></div><p>In this chapter we'll spend some time thinking, as programmers, about what we name and how we name it. First: <span class="emphasis"><em>What?</em></span> The things we name most often while writing code are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Variables</p></li><li class="listitem"><p>Functions</p></li><li class="listitem"><p>Types (classes, <code class="literal">enum</code>s, <code class="literal">struct</code>s, <code class="literal">typedef</code>s)</p></li><li class="listitem"><p>C++ namespaces and Java packages</p></li><li class="listitem"><p>Macros</p></li><li class="listitem"><p>Source files</p></li></ul></div><p>This list is by no means exhaustive—there are other, higher-level entities we'll give meaningful names to: states of a state machine, parts of messaging protocols, database elements, application executables, and so on. But these six are enough to start with.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="name_games"/>Name Games</h1></div></div></div><p><span class="emphasis"><em>How</em></span> do you name? The naming technique for each of these items will depend on any coding standard you're working to. However, while a standard might mandate certain naming conventions, it won't be specific enough to guide the <span class="emphasis"><em>appropriate</em></span> naming of each and every part of a program.<a class="indexterm" id="IDX-CHP-3-0174"/><a class="indexterm" id="IDX-CHP-3-0175"/></p><p>In order to name well, it's essential to know exactly what you're naming before you think up a name for it. If you don't know what you're naming, how it will be used, and why it actually exists, how can you give it a meaningful name? Bad names are often a sign of poor understanding.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>The key to good naming is to understand exactly what you're naming. Only then can you give a meaningful name. If you can't invent a good name for something, do you really know what it is, or even if it should exist at all?</em></span></p></dd></dl></div><p>Before we look in detail at the specific categories of names we create, it's important to understand the forces that drive our choice of names and exactly what constitutes a good name. The next few sections explain the qualities of a good name.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="descriptive"/>Descriptive</h2></div></div></div><p>Obviously a name must be descriptive. That's what you use it for—to describe something. Yet it's common to see puzzling identifiers that bear little resemblance to the data they describe.</p><p>Even an accurate name can be limiting. People often stick to their initial perceptions of a concept, despite the proverb about judging books by their covers. Therefore, it's important to convey the right first impression through careful naming. Choose names from the perspective of an inexperienced reader, not from your internal, knowledgeable perspective.</p><p>Sometimes finding a good description is difficult. If you can't come up with a good name, then you might need to change your design. It's an indication that something might be wrong.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="technically_correct"/>Technically Correct</h2></div></div></div><p>Modern programming languages impose some rules on how we name things. Most allow case-sensitive names, don't allow <span class="emphasis"><em>whitespace</em></span> (spaces, tabs, newlines), and allow just alphanumeric characters plus certain symbols (like the underscore). These days, there are no appreciable limits on identifier length.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-3" id="CHP-3-FN-3">3</a>]</sup> Although many languages permit use of Unicode identifiers, it's still common to select from the ISO8859-1 (ASCII) character set for simplicity.</p><p>There may be other technical restrictions. The C/C++ standards reserve specific ranges of names: You should not use any global identifier beginning with <code class="literal">str</code> followed by a lowercase letter, or beginning with an underscore, and anything in a namespace called <code class="literal">std</code>. It's important to be aware of these kinds of restrictions so we can write robust, correct code.<a class="indexterm" id="IDX-CHP-3-0177"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="idiomatic"/>Idiomatic</h2></div></div></div><p>Just because a language permits certain combinations of characters doesn't meant they're automatically good names. Clear names follow conventions that the reader expects: the language's <span class="emphasis"><em>idioms</em></span>. Just as fluency in a natural language depends on understanding its idioms, fluency in a programming language requires idiomatic usage.<a class="indexterm" id="IDX-CHP-3-0180"/><a class="indexterm" id="IDX-CHP-3-0178"/><a class="indexterm" id="IDX-CHP-3-0179"/></p><p>Some languages have a single, common naming convention—the vast Java library establishes a prior art that is hard to ignore—while C and C++ have a lesser degree of convergence. There are several cultures, each with their own foibles; the standard libraries use one convention, Windows Win32 APIs another.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Know your language's naming rules. But more importantly, know the language's idiomsw. What are the common naming conventions? Use them</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="appropriate"/>Appropriate</h2></div></div></div><p>An <span class="emphasis"><em>appropriate</em></span> name strikes a good balance in several areas:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Length</strong></span></span></dt><dd><p>To create clear, descriptive names, we must use natural language words. Programmers have a built-in urge to abbreviate and shorten these words, but this leads to confused, messy names. It doesn't matter that a name is long if its meaning is unambiguous. <code class="literal">a</code> is not a realistic replacement for <code class="literal">apple_count</code>.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>When naming, favor clarity over brevity</em></span>.<a class="indexterm" id="IDX-CHP-3-0181"/><a class="indexterm" id="IDX-CHP-3-0182"/></p></dd></dl></div><p>However, there is a case for short (even one letter) variable names: as loop counters. They actually make sense in <span class="emphasis"><em>small</em></span> loops where variable names like <code class="literal">loop_counter</code> are not just overly verbose but can quickly become tedious.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Understand the trade-offs between short and long names—how they depend on the scope of the variable's use</em></span>.</p></dd></dl></div></dd><dt><span class="term"><span class="strong"><strong>Tone</strong></span></span></dt><dd><p>The tone of a name <span class="emphasis"><em>is</em></span> important. Just as a rude joke isn't appropriate at a funeral, an ill-judged name ruins the professionalism of your code. Is this serious? Yes—silly names make the reader doubt the ability of the original author.</p><p>Avoid jokey names like <span class="emphasis"><em>blah</em></span> or <span class="emphasis"><em>wibble</em></span>, or the bigger geek snares <span class="emphasis"><em>foo</em></span> and <span class="emphasis"><em>bar</em></span>. They can easily creep in, and while amusing at first, they just create confusion later on. (Objects given these names are usually quick temporary hacks that outlast their expected lifetime.) And, obviously, being professional means that you don't use expletives when naming.</p></dd></dl></div><div class="sidebar"><a id="food_for_thought"/><p class="title"><b>FOOD FOR THOUGHT</b></p><p>So what's with all this <span class="emphasis"><em>foo</em></span> and <span class="emphasis"><em>bar</em></span> business? These words are a bit of geek humor, utterly meaningless and yet full of purpose. They are usually used as placeholders to represent arbitrary things. You might write: <span class="emphasis"><em>for some variable</em></span> <em class="replaceable"><code>foo</code></em>, <span class="emphasis"><em>increment it by</em></span> <em class="replaceable"><code>++foo</code></em>;.<a class="indexterm" id="IDX-CHP-3-0183"/><a class="indexterm" id="IDX-CHP-3-0184"/></p><p>The words generally come in a series. There are several variant series, but you'll see <span class="emphasis"><em>foo</em></span>, <span class="emphasis"><em>bar</em></span>, and baz <em class="replaceable"><code>quite</code></em> universally. What comes next may be up to the fickle finger of fate or to whatever geek folklore you prefer.</p><p>The etymology of these terms is debatable. Some trace them back to the World War II army slang FUBAR (Mucked Up Beyond All Repair). Needless to say, you should never use these names in production code.<a class="indexterm" id="IDX-CHP-3-0185"/></p></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Name things well the first time, all the time</em></span>.</p></dd></dl></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-3" id="ftn.CHP-3-FN-3">3</a>] </sup>Be aware that older versions of C limited external unique linkage to the first six characters, and case was not <span class="emphasis"><em>necessarily</em></span> significant. You need to understand exactly what the target of your code is when you write it.<a class="indexterm" id="IDX-CHP-3-0176"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_nuts_and_bolts"/>The Nuts and Bolts</h1></div></div></div><p>The following sections investigate how to name each category of item we listed earlier. Even if you've been programming for years, this is a useful review of the broad spectrum of naming conventions.<a class="indexterm" id="IDX-CHP-3-0186"/><a class="indexterm" id="IDX-CHP-3-0187"/><a class="indexterm" id="IDX-CHP-3-0188"/><a class="indexterm" id="IDX-CHP-3-0189"/><a class="indexterm" id="IDX-CHP-3-0190"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="naming_variables"/>Naming Variables</h2></div></div></div><p>If a variable wasn't just an electronic entity, it would be the sort of thing you could hold in your hand, the software equivalent of a physical object. A name that reflects this will usually be a noun. For example, variable names in a GUI application might be <code class="literal">ok_button</code> and <code class="literal">main_window</code>. Even variables that don't correspond to Real World objects can be given noun names; consider <code class="literal">elapsed_time</code> or <code class="literal">exchange_rate</code>.<a class="indexterm" id="IDX-CHP-3-0191"/><a class="indexterm" id="IDX-CHP-3-0192"/></p><p>If not a noun, a variable will usually be a "noun-ized" verb, for example, <code class="literal">count</code>. A numeric variable's name describes the interpretation of the value, as in <code class="literal">widget_length</code>. A boolean variable name is often the name of a conditional statement, which is natural, considering the value will either be true or false.</p><p>There are a number of object-oriented language conventions for adorning member variables to show they are members, not ordinary local variables or (evil) global variables. This is a mild form of <span class="emphasis"><em>Hungarian Notation</em></span>, which some programmers find useful.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-4" id="CHP-3-FN-4">1</a>]</sup> For example, C++ members are commonly prefixed with an underscore, suffixed with an underscore, or prefixed with <code class="literal">m_</code>. The first method is frowned upon because it is somewhat risky and distasteful.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-5" id="CHP-3-FN-5">5</a>]</sup> Besides, a leading or trailing underscore makes the variable pretty unnatural to read.</p><p>Some programmers adorn pointer types with a suffix like <code class="literal">_ptr</code> and reference types with one like <code class="literal">_ref</code>. This is another subtle infiltration of Hungarian Notation, and it is redundant. The fact the variable is a pointer is implicit in its type. If your function is so large that you think this adornment is useful, then it's probably too large!</p><p>Another common variable-naming practice is using acronyms as concise, "meaningful" names. For example, you might declare a variable like this: <code class="literal">SomeTypeWithMeaningfulNaming stwmn(10);</code>. If the scope of use is small, this kind of name may be clearer than a long-winded variant.<a class="indexterm" id="IDX-CHP-3-0194"/><a class="indexterm" id="IDX-CHP-3-0195"/></p><p>Conventions that distinguish type names from variable names are generally best. Type names often have an uppercase initial letter, while variables have a lowercase one. This way, it's not unusual to see variables declared like this: <code class="literal">Window window;</code>.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Employ a helpful naming convention that differentiates variable names from type names</em></span>.</p></dd></dl></div><div class="sidebar"><a id="hungarian_notation"/><p class="title"><b>HUNGARIAN NOTATION</b></p><p>Hungarian Notation is a controversial naming convention that encodes information about a variable or function's type in its name with the belief that it will make the code more readable and maintainable. It originated at Microsoft in the 1980s and is widely used in the company's public Win32 APIs and the MFC library, which is the main reason for its popularity.<a class="indexterm" id="IDX-CHP-3-0196"/><a class="indexterm" id="IDX-CHP-3-0197"/></p><p>It is called Hungarian Notation because it was pioneered by Charles Simonyi, a Hungarian programmer. It's also called that because variable names look like they may as well have been written in Hungarian: Non-Windows programmers get confused by surreal names like <code class="literal">lpszFile</code>, <code class="literal">rdParam</code>, and <code class="literal">hwndItem</code>.</p><p>There are many subtly different and not-quite-compatible dialects of Hungarian Notation, which don't help matters.</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="naming_functions"/>Naming Functions</h2></div></div></div><p>If a variable is like something you could hold in your hand, the <span class="emphasis"><em>function</em></span> is what you do with it—you don't want to hold it forever. Since a function is an action, its name will most logically be (or will at least include) a verb. A function with a noun for a name wouldn't be clear; for example, what does the function <code class="literal">apples()</code> do? Does it return a number of apples, does it convert something into apples, or does it make apples out of thin air?<a class="indexterm" id="IDX-CHP-3-0198"/><a class="indexterm" id="IDX-CHP-3-0199"/><a class="indexterm" id="IDX-CHP-3-0200"/><a class="indexterm" id="IDX-CHP-3-0201"/><a class="indexterm" id="IDX-CHP-3-0202"/></p><p>Meaningful function names avoid the words <span class="emphasis"><em>be</em></span>, <span class="emphasis"><em>do</em></span>, and <span class="emphasis"><em>perform</em></span>. These are classic traps for beginners trying to consciously include verbs (<span class="emphasis"><em>this function</em></span> does <span class="emphasis"><em>XXX</em></span> . . .). They are just noise and don't add any value to the name.</p><p>A function should always be named from the viewpoint of the user, hiding all the internal implementation stuff neatly away. (That's the point of a function—it's a level of compression and abstraction.) Who cares if, behind the scenes, it stores an element in a list, makes calls over a network, or builds a new computer and installs a word processor on it? If the user only sees the function count apples, the function should be called <code class="literal">countApples()</code>.<a class="indexterm" id="IDX-CHP-3-0203"/><a class="indexterm" id="IDX-CHP-3-0204"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Name functions from an external viewpoint, with a doing phrase. Describe the logical operation, not the implementation</em></span>.<a class="indexterm" id="IDX-CHP-3-0205"/></p></dd></dl></div><p>The only time you might choose to break this rule is for simple query functions that request information. For these accessors, you can sensibly name the function after the data being requested. For an example of this, see the answer to question 9 in this chapter's "<a class="xref" href="ch02s11.html#mull_it_over-id1" title="Mull It Over">Mull It Over</a>" section on page 478.</p><p>When you write a function, it should be well documented (either in a specification or using some literate programming method). However, the name should still be a clear statement of what the function does; it is part of the function's contract. What does <code class="literal">void a()</code> do? It could be anything.<a class="indexterm" id="IDX-CHP-3-0206"/><a class="indexterm" id="IDX-CHP-3-0207"/></p><div class="sidebar"><a id="capitalization_conventions"/><p class="title"><b>CAPITALIZATION CONVENTIONS</b></p><p>Most languages prohibit us from using whitespace and punctuation in our identifiers, so we adopt a convention for joining up multiple words. These capitalization conventionscause as many programmer fist fights as the eternal Holy Editor Wars. There are a number of common methods that you'll see in modern code:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>camelCase</strong></span></span></dt><dd><p>camelCase is used extensively by the Java language libraries and also in many C++ codebases. It is so called because the capitalization resembles a camel's humps and was probably first used in Smalltalk in the early 1970s.</p></dd><dt><span class="term"><span class="strong"><strong>ProperCase</strong></span></span></dt><dd><p>This is a close relative of camelCase, its only difference being that the first letter is also capitalized. It is sometimes known as <span class="emphasis"><em>PascalCase</em></span>. Often the two conventions are used together. For example, Java class names are written in ProperCase and members in camelCase. The Windows API and .NET methods use ProperCase.<a class="indexterm" id="IDX-CHP-3-0208"/></p></dd><dt><span class="term"><span class="strong"><strong>using_underscores</strong></span></span></dt><dd><p>Proponents of this style are the implementers of the C++ standard library(look at all the names in the <code class="literal">std</code> namespace) and the GNU foundation.</p><p>There are also many other forms. How many can you think of? You can start by mixing ProperCase with underscores, or by dropping uppercase characters entirely.</p></dd></dl></div></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="naming_types"/>Naming Types</h2></div></div></div><p>Which types you can create depends on the language you're using. C provides <code class="literal">typedef</code>s, which are synonyms for other type names. You use them to provide easier, more convenient names. It stands to reason, then, that a <code class="literal">typedef</code> should be clearly named. Even if it's only a local <code class="literal">typedef</code> in a function body, it should still have a descriptive name.<a class="indexterm" id="IDX-CHP-3-0209"/><a class="indexterm" id="IDX-CHP-3-0210"/><a class="indexterm" id="IDX-CHP-3-0211"/><a class="indexterm" id="IDX-CHP-3-0212"/><a class="indexterm" id="IDX-CHP-3-0213"/><a class="indexterm" id="IDX-CHP-3-0214"/><a class="indexterm" id="IDX-CHP-3-0215"/><a class="indexterm" id="IDX-CHP-3-0216"/><a class="indexterm" id="IDX-CHP-3-0217"/></p><p>Java, C++, and other OO languages are profoundly based on the creation of new types (<span class="emphasis"><em>classes</em></span>). C also allows you to define compound types called <code class="literal">structs</code>. Just as good variable and function names are vital to the readability of the code, good type names are paramount. There aren't too many rigid heuristics for naming classes, though, because different classes serve different purposes.<a class="indexterm" id="IDX-CHP-3-0218"/><a class="indexterm" id="IDX-CHP-3-0219"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A class may describe some stateful data object. In that case, its name will probably be a noun.</p><p>It may be a function object (a <span class="emphasis"><em>functor</em></span>) or a class implementing some virtual callback interface. Here the name will probably be a verb, perhaps including the name of a recognized design pattern. (Gamma et al. 94)<a class="indexterm" id="IDX-CHP-3-0220"/><a class="indexterm" id="IDX-CHP-3-0221"/><a class="indexterm" id="IDX-CHP-3-0222"/></p></li><li class="listitem"><p>If the class is a combination of both, then it's probably hard to name and possibly designed badly.</p><p><span class="emphasis"><em>Interface classes</em></span> (e.g., abstract C++ classes with pure virtual functions or <code class="literal">interface</code>s in Java and .NET) tend to be named according to the interface facility. Names like <code class="literal">Printable</code> and <code class="literal">Serializable</code> are common. .NET adds a Hungarian wart, prefixing all interface names with <code class="literal">I</code>, resulting in names like <code class="literal">IPrintable</code>.</p></li></ul></div><p>Earlier, we discussed words to avoid in function names; there is similar quicksand here. For example, <code class="literal">DataObject</code> is a bad name: The class may very well contain data, and it's obviously going to be used to create an object—this doesn't need to be restated.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Avoid redundant words in names. Specifically, avoid these words in type names</em></span>: class, data, object, <span class="emphasis"><em>and</em></span> type.</p></dd></dl></div><p>Ensure that you describe the <span class="emphasis"><em>class of data</em></span> and not an <span class="emphasis"><em>actual object</em></span>. That's a subtle, but important distinction.</p><div class="sidebar"><a id="a_class_of_bad_names"/><p class="title"><b>A CLASS OF BAD NAMES</b></p><p>A bad class name can serve to really confuse programmers. I once worked on an application that contained a state machine implementation. For some historical reason, the base class of each state was called <code class="literal">Window</code>, rather than something sensible like <code class="literal">State</code>. It was very confusing and threw off several programmers when they first saw it. To add insult to injury, the base class of a command pattern was called <code class="literal">Strategy</code>, when it wasn't actually implementing a strategy design pattern. It was never easy to figure out what was going on. Better naming would have provided a clear route into the code's logic.<a class="indexterm" id="IDX-CHP-3-0223"/></p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="naming_namespaces"/>Naming Namespaces</h2></div></div></div><p>What name do you give something specifically designed to collate names? C++ and C# <code class="literal">namespace</code>s and Java <code class="literal">package</code>s are like bags, acting primarily as grouping mechanisms.<a class="indexterm" id="IDX-CHP-3-0224"/><a class="indexterm" id="IDX-CHP-3-0225"/><a class="indexterm" id="IDX-CHP-3-0226"/><a class="indexterm" id="IDX-CHP-3-0227"/><a class="indexterm" id="IDX-CHP-3-0228"/></p><p>They are also used to prevent <span class="emphasis"><em>name collisions</em></span>. When two programmers create different things with the same name and their code gets glued together, whatwill happen is anyone's guess. At best, the code will fail to link; at worst, all sorts of run-time carnage will ensue. Putting items into different namespaces avoids the danger of polluting the global namespace. This makes them valuable naming tools.<a class="indexterm" id="IDX-CHP-3-0229"/><a class="indexterm" id="IDX-CHP-3-0230"/></p><p>But namespaces on their own do not prevent collisions; your <code class="literal">utils</code> namespace could still clash with someone else's <code class="literal">utils</code>. To remedy this, we employ a <span class="emphasis"><em>naming scheme</em></span>. Java defines a hierarchy of package names, nested like Internet domain names—you'll place code in your own uniquely named package. This neatly avoids the problem of collisions. Without such a convention, namespaces reduce, but do not eliminate, the likelihood of problems.</p><p>When picking a name for your namespace, choose something that describes the relationship of the contents. If they are all part of a library's interface, make it the library name. If the contents are a single section of a larger system, choose a name that describes this section; <code class="literal">UI</code>, <code class="literal">filesystem</code>, or <code class="literal">controls</code> are good names. Don't choose a name that redundantly implies a collection of items—<code class="literal">controls_group</code> is a bad name.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Give namespaces and packages names that reflect the logical relationships of their contents</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="naming_macros"/>Naming Macros</h2></div></div></div><p>Macros are the walnut-cracking sledgehammers of the C/C++ world. They are search-and-replace tools for basic text that don't respect scope or visibility. They're tactless. However, there are some walnuts that just won't crack without them.<a class="indexterm" id="IDX-CHP-3-0231"/><a class="indexterm" id="IDX-CHP-3-0232"/></p><p>Macros have very drastic effects, so there is a well-established tradition for naming macros in a maximally obvious way: using CAPITAL LETTERS. Follow this without fail, and don't make any other name entirely capitalized. This makes macros stand out like sore thumbs, which is basically what they are.<a class="indexterm" id="IDX-CHP-3-0233"/><a class="indexterm" id="IDX-CHP-3-0234"/><a class="indexterm" id="IDX-CHP-3-0235"/><a class="indexterm" id="IDX-CHP-3-0236"/><a class="indexterm" id="IDX-CHP-3-0237"/></p><p>Since they are simple text replacement tools, give macros names that are unique enough to not appear elsewhere in the code. Otherwise, carnage and confusion will ensue.</p><p>A unique file or project name prefix will help here. The macro name <code class="literal">PROJECTFOO_MY_MACRO</code> is much safer than <code class="literal">MY_MACRO</code>.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Macros in C/C++ are always capitalized to make them stand out and carefully named to avoid collisions. Don't capitalize anything else. Ever</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="naming_files"/>Naming Files</h2></div></div></div><p>The names of your source files can have a real impact on the ease of coding. Some languages have strict filename requirements—Java source filenames must correspond to the contained public class name. On the other hand, C and C++ are lax, with no restrictions at all.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-6" id="CHP-3-FN-6">6</a>]</sup></p><p>To make choosing filenames easy and obvious, each file should contain a single conceptual unit. Putting more stuff into one file is asking for trouble in the long run. Split your code into the maximum number of files you can; not only will it make them easier to name, but it will reduce coupling and make the project's structure clearer.</p><p>A C/C++ file that defines the interface for a <span class="emphasis"><em>widget</em></span> should becalled <code class="literal">widget.h</code>, not <code class="literal">widget_interface.h</code>, <code class="literal">widget_decls.h</code>, or any other variation. You should conventionally balance each <code class="literal">widget.h</code> with a matching <code class="literal">widget.cpp</code> or <code class="literal">widget.c</code> (see "<a class="xref" href="ch03s05.html#all_that_ends_well" title="ALL THAT ENDS WELL">ALL THAT ENDS WELL</a>" on page 50) that implements whatever the <code class="literal">widget.h</code> declares. The shared base name ties them together logically. This is both obvious and conventional.</p><p>There are many other subtle, but important issues when naming files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Be aware of capitalization. Some filesystems can't get this right and ignore case when looking up filenames. But when porting to platforms where case <span class="emphasis"><em>is</em></span> important, your code won't compile unless you've observed capitalization carefully. Perhaps the easiest way to avoid being tripped up is to mandate that all filenamesbe lowercase; as they say, <span class="emphasis"><em>If you can't be good, be careful</em></span>. (Of course, that won't work for Java, which uses the PascalCase naming style for its classes and interfaces.)</p></li><li class="listitem"><p>For the same reason, if your filesystem considers the filenames <code class="literal">foo.h</code> and <code class="literal">Foo.h</code> to be different, <span class="emphasis"><em>don't</em></span> exploit it. Make sure that filenames in the same directory differ by more than just case.</p></li><li class="listitem"><p>If you mix languages in a single project, don't create <code class="literal">foo.c</code>, <code class="literal">foo.cpp</code>, and <code class="literal">foo.java</code> in the same directory. It's messy—which file is used to create the object file <code class="literal">foo.o</code>, and which creates the executable called <code class="literal">foo</code>?</p></li><li class="listitem"><p>Try to ensure that all the files you create have a distinct names, even if they're all spread across different directories. This makes it easier to reason about which file is which. It's obvious which header file you mean when you <code class="literal">#include "foo.h"</code>. If there were two files with the same name, then a newcomer to the codebase would be confused. This becomes more of an issue as a system grows.<a class="indexterm" id="IDX-CHP-3-0239"/><a class="indexterm" id="IDX-CHP-3-0240"/></p><p>One valid approach is to add some path information to the logical filename. Arrange your files so that you can include <code class="literal">library_one/version.h</code> and <code class="literal">library_two/version.h</code> without confusion.</p></li></ul></div><p>File naming seriously impacts ease of coding. I once worked on a C++ project where the majority of the filenames matched the class names exactly; the class <code class="literal">Daffodil</code> was defined in <code class="literal">Daffodil.h</code> (names have been changed to protect the guilty). However, a handful of files were named in a <span class="emphasis"><em>slightly</em></span> different manner, usually abbreviated, so <code class="literal">HerbaciousBorder</code> was held in <code class="literal">HerbBdr.h</code>. That made finding the right filename to <code class="literal">#include</code> complex and time consuming. On top of this, not all of the <code class="literal">Daffodil</code> class implementation was necessarily in <code class="literal">Daffodil.cpp</code>—some of it might have been in a shared <code class="literal">FlowerStuff.cpp</code> and perhaps also in <code class="literal">Yogurt.cpp</code>, for no adequately explained reason. As you can imagine, this made finding particular bits of code a nightmare. Source code browsers help in situations like this, but they are no substitute for plain old, well-named code.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-4" id="ftn.CHP-3-FN-4">1</a>] </sup>Of course, this kind of naming convention won't have any impact on a class's public API because all of your member variables are private, aren't they?<a class="indexterm" id="IDX-CHP-3-0193"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-5" id="ftn.CHP-3-FN-5">5</a>] </sup>You can't have global identifiers beginning with an underscore followed by a capital letter. The archaic C naming rules make many such odd demands.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-6" id="ftn.CHP-3-FN-6">6</a>] </sup>Except those imposed by your operating system or filesystem.<a class="indexterm" id="IDX-CHP-3-0238"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="a_rose_by_any_other_name"/>A Rose by Any Other Name</h1></div></div></div><p>There is more to the name game than you'd first think, and there are clearly a lot of considerations for naming bits of code. What are the main principles to pull out?<a class="indexterm" id="IDX-CHP-3-0241"/><a class="indexterm" id="IDX-CHP-3-0242"/><a class="indexterm" id="IDX-CHP-3-0243"/></p><p>To invent a good name, do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Be consistent</p></li><li class="listitem"><p>Exploit content</p></li><li class="listitem"><p>Use names to your advantage</p></li></ul></div><div class="sidebar"><a id="all_that_ends_well"/><p class="title"><b>ALL THAT ENDS WELL</b></p><p>Choosing a suffix is integral to file naming. Java's build system insists that source filenames end in <code class="literal">.java</code>. C and C++ compilers are suffix agnostic, but calling header files something.h is such a universal convention that it would be like sticking pins in your eyes not to do it. We do feel some pain from the lack of rigid definition; there are several conventions for C++ implementation filenames, like the common suffixes <code class="literal">.C</code>, <code class="literal">.cc</code>, <code class="literal">.cpp</code>, <code class="literal">.cxx</code>, and <code class="literal">.c</code>++. Less common, but still seen, are C++ headers files suffixed with <code class="literal">.hpp</code>. Your choice may depend on the compiler, personal preference, and/or a coding standard. Consistency is the key; pick a file suffix scheme and use it consistently.<a class="indexterm" id="IDX-CHP-3-0244"/><a class="indexterm" id="IDX-CHP-3-0245"/><a class="indexterm" id="IDX-CHP-3-0246"/><a class="indexterm" id="IDX-CHP-3-0247"/></p><p>I have even worked on a platform that didn't support filename suffixes. Determiningthe filetype was a complex and messy business.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="be_consistent"/>Be Consistent</h2></div></div></div><p>This is perhaps the most important naming principle. Be <span class="emphasis"><em>consistent</em></span>—not just within your own work, but with respect to company-wide practices. I have no confidence in the quality of a class interface if it looks like this:<a class="indexterm" id="IDX-CHP-3-0248"/><a class="indexterm" id="IDX-CHP-3-0249"/><a class="indexterm" id="IDX-CHP-3-0250"/></p><a id="I_programlisting3_d1e4632"/><pre class="programlisting">
class badly_named : public MyBaseClass
{
public:
    void doTheFirstThing();
    void DoThe2ndThing();
    void do_the_third_thing();
};
</pre><p>When a lot of people work together, it's very easy to end up with code like this—about as internally consistent as a random number generator. It's often a symptom of a more serious problem—perhaps that the programmers aren't respecting the fundamental design of the code they're simultaneously working on. This is where mandated coding standards and central design documents can be a big help.</p><p>Naming consistency goes beyond capitalization and formatting to the way you <span class="emphasis"><em>create</em></span> names. A name establishes an implicit metaphor. Across a program or project, these metaphors should be consistent. Your naming approach should be holistic.<a class="indexterm" id="IDX-CHP-3-0251"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Choose a consistent naming convention—and use it consistently</em></span>.</p></dd></dl></div><p>With consistent naming, we get code that is intuitive and therefore easier to work with, easier to extend, and easier to maintain. In the long run, it's much cheaper to manage.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="exploit_context"/>Exploit Context</h2></div></div></div><p>Every name should make perfect sense when read in context. A name will only ever be read in its context, so you can delete all the superfluous bits that duplicate contextual information. We strive for succinct, descriptive names, without unnecessary baggage.<a class="indexterm" id="IDX-CHP-3-0252"/></p><p>This contextual information may come from:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Scope</strong></span></span></dt><dd><p>Things either live in a top-level, global scope or exist within some namespace, class, or function. Choose a name that makes sense in the context of that scope. The smaller and more specific a scope is, the easier it is to create a name within it and the easier it is for the reader to understand what that name really means. If a function counts the number of apples in a tree and is defined in a class <code class="literal">Tree</code>, then it needn't be called <code class="literal">countApplesInTree()</code>. Its fully qualified name would be an unambiguous description: <code class="literal">Tree::countApples()</code>. Put things in the smallest (and therefore most descriptive) scope you can.</p><p>The French language, like most other Romance languages, has two forms of the word <span class="emphasis"><em>you</em></span>: <span class="emphasis"><em>tu</em></span> and <span class="emphasis"><em>vous</em></span>. Which one you use depends on how familiar you are with the person you're addressing. Similarly, the name you call a variable may depend on the context in which you're using it. You may see a variable named differently in a function's public declaration than in the function implementation.</p></dd><dt><span class="term"><span class="strong"><strong>Type</strong></span></span></dt><dd><p>Everything has a type, and you'll know what that type is. A name doesn't need to restate this type information. (Restating this <span class="emphasis"><em>is</em></span> the purpose of Hungarian Notation and is why it's an often derided convention.)<a class="indexterm" id="IDX-CHP-3-0253"/></p><p>An inexperienced programmer will name his address <code class="literal">string</code> variable <code class="literal">address_string</code>. What good does the <code class="literal">_string</code> suffixdo? Nothing, so get rid of it.</p></dd></dl></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>The detail required in a name depends on its context. Use contextual information to your advantage when naming</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="use_names_to_your_advantage"/>Use Names to Your Advantage</h2></div></div></div><p>There is power in a name—power that allows you to be more expressive than a language's syntax alone might allow. Think about how you can use similar names to group things together, using a common prefix. Or consider how you can imply which of a function's parameters are input or output by including this information in their names.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id2"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>In your name I will hope, for your name is good.<a class="indexterm" id="IDX-CHP-3-0254"/><a class="indexterm" id="IDX-CHP-3-0255"/></p><div class="attribution"><span>--<span class="attribution">Psalms 52:9</span></span></div></div><p>Our ancient ancestors knew it, and good programmers know it: It's crucial to name things well. Good names serve more than just an aesthetic purpose; they convey information about the structure of code. They are an essential tool to aid comprehensibility and maintainability.</p><p>The main reason we write code in high-level languages is to communicate, and that communication is to an audience of code readers—other programmers—rather than to the compiler. Bad names have the potential to mislead. There <span class="emphasis"><em>is</em></span> power in a name, and experienced programmers understand the balance of concerns involved when naming any part of their code.</p><div class="sidebar"><a id="general_dos_and_don_apostrophy_ts"/><p class="title"><b>GENERAL DOS AND DON'TS</b></p><p>We can condense a lot of the advice in this chapter into some general dos and don'ts. <span class="emphasis"><em>Don't</em></span> create names that are:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Cryptic</strong></span></span></dt><dd><p>You can create inexplicable names in a number of ways. Acronyms and abbreviations can appear quite random, and single letter names are far too magical.</p></dd><dt><span class="term"><span class="strong"><strong>Verbose</strong></span></span></dt><dd><p>Avoid terse names, but don't create a variable called <code class="literal">the_number_of_apples_before_I_started_eating</code>, either. It's neither remotely useful nor funny.</p></dd><dt><span class="term"><span class="strong"><strong>Inaccurate or misleading</strong></span></span></dt><dd><p>As obvious as it seems, make your names accurate. Don't call something a <code class="literal">widget_list</code> if it has nothing to do with lists. Don't call something <code class="literal">widget</code> if it's a container of widgets.</p><p>Misspelling opens a minefield of confusion: <span class="emphasis"><em>I thought the variable was called</em></span> <em class="replaceable"><code>ignoramus</code></em>, <span class="emphasis"><em>but I can't find it anywhere</em></span>. <span class="emphasis"><em>Oops, it was misspelled</em></span> <em class="replaceable"><code>ignoramous</code></em>. Sigh.</p></dd><dt><span class="term"><span class="strong"><strong>Ambiguous or vague</strong></span></span></dt><dd><p>Don't use a name that could be interpreted in several ways. Don't use a hopelessly vague name like <code class="literal">data</code> or <code class="literal">value</code> unless it's perfectly clear what it represents. Avoid the vague <code class="literal">temp</code> or <code class="literal">tmp</code> unless you <span class="emphasis"><em>really</em></span> need it.</p><p>Don't differentiate names by capitalization or by changes of a single character. Be wary of names that sound similar.</p><p>Don't gratuitously create local variables with the same name as something in an outer scope.<a class="indexterm" id="IDX-CHP-3-0256"/></p></dd><dt><span class="term"><span class="strong"><strong>Too cute</strong></span></span></dt><dd><p>Sexy little abbreviations, clever shortenings that are hard to remember, and interpretive use of numerals should be avoided. <span class="emphasis"><em>i18n</em></span>, a common abbreviation for <span class="emphasis"><em>internationalization</em></span>, reads like nonsense to the uninitiated.</p><p>On the other hand, <span class="emphasis"><em>do</em></span> create appropriate names that are clear, specific, concise, accurate, and unambiguous. <span class="emphasis"><em>Do</em></span> use common terms and frames of reference. Use words from the problem domain, and draw on descriptive design pattern names.(Gamma et al. 94)</p></dd></dl></div></div><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Realize the importance of names and treat them with respect</p></li><li class="listitem"><p>Think about naming and choose appropriate names for everything they create<a class="indexterm" id="IDX-CHP-3-0257"/></p></li><li class="listitem"><p>Hold many forces in balance: name length, clarity, context, and so on</p></li><li class="listitem"><p>Keep a view of the bigger picture, so their names hold together across a project (or projects)</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Care little for the clarity of their code</p></li><li class="listitem"><p>Produce <span class="emphasis"><em>write-once</em></span> code that is quick to write and poorly thought out</p></li><li class="listitem"><p>Ignore the language's natural idioms</p></li><li class="listitem"><p>Are inconsistent in naming</p></li><li class="listitem"><p>Don't think holistically, failing to consider how their piece of code fits into the whole</p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id2"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch02.html" title="Chapter 2. THE BEST LAID PLANS">Chapter 2</a></span></dt><dd><p>Discusses coding standards, which may guide you in naming things. Also talks about <span class="emphasis"><em>holy wars</em></span>, which Hungarian Notation is definitely a cause of.</p></dd><dt><span class="term"><a class="xref" href="ch04.html" title="Chapter 4. THE WRITESTUFF">Chapter 4</a></span></dt><dd><p>Good names don't replace well-documented code—but they are an integral part of code documentation.</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e4941"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207452.png.jpg"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id3"/>Get Thinking</h1></div></div></div><p>A detailed discussion of the following questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 474.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id2"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Are these good variable names? Answer with either <span class="emphasis"><em>yes</em></span> (explain why, and in what context), <span class="emphasis"><em>no</em></span> (explain why), or <span class="emphasis"><em>can't tell</em></span> (explain why).<a class="indexterm" id="IDX-CHP-3-0258"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><code class="literal">int apple_count</code></p></li><li class="listitem"><p><code class="literal">char foo</code></p></li><li class="listitem"><p><code class="literal">bool apple_count</code></p></li><li class="listitem"><p><code class="literal">char *string</code></p></li><li class="listitem"><p><code class="literal">int loop_counter</code></p></li></ol></div></li><li class="listitem"><p>When would these be appropriate function names? Which return types or parameters might you expect? Which return types would make them nonsensical?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><code class="literal">doIt(...)</code></p></li><li class="listitem"><p><code class="literal">value(...)</code></p></li><li class="listitem"><p><code class="literal">sponge(...)</code></p></li><li class="listitem"><p><code class="literal">isApple(...)</code></p></li></ol></div></li><li class="listitem"><p>Should a naming scheme favor the easy reading or easy writing of code? How would you make either easy?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How many times do you write a single piece of code? (Think about it.) How many times do you read it? Your answers should give some indication as to the relative importances.</p></li><li class="listitem"><p>What do you do when naming conventions collide? Say you're working on camelCase C++ code and need to do STL (using_underscore) library work. What's the best way to handle this situation?</p></li></ol></div></li><li class="listitem"><p>How long should a loop be before you need to give a meaningful loop counter name?</p></li><li class="listitem"><p>In C, if <code class="literal">assert</code> is a macro, why is its name lowercase? Why should we name macros so they stand out?</p></li><li class="listitem"><p>What are the pros and cons of following your language's standard library naming conventions?</p></li><li class="listitem"><p>Can you wear out a name? Is it okay to repeat a local variable name in many different functions? Is it okay to use local names that override (and hide) global names? Why?</p></li><li class="listitem"><p>Describe the mechanics of Hungarian Notation. What are the pros and cons of this naming convention? Does it have a place in modern code design?</p></li><li class="listitem"><p>We see many classes containing member functions acting as <span class="emphasis"><em>getters</em></span> and <span class="emphasis"><em>setters</em></span>; reading and writing the value of certain properties. What are the common naming conventions for these functions, and which is the best?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id2"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How good are you at naming? How many of these heuristics do you follow already? Do you consciously think about your naming and these sorts of rules, or do you just <span class="emphasis"><em>do it</em></span> all naturally? In which areas can you improve?<a class="indexterm" id="IDX-CHP-3-0259"/><a class="indexterm" id="IDX-CHP-3-0260"/><a class="indexterm" id="IDX-CHP-3-0261"/></p></li><li class="listitem"><p>Does your coding standard mention naming at all?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Does it cover all the cases we've looked at here? Is it <span class="emphasis"><em>sufficient</em></span>? Is it useful, or just superficial?</p></li><li class="listitem"><p>How much naming detail <span class="emphasis"><em>is</em></span> appropriate in a coding standard?</p></li></ol></div></li><li class="listitem"><p>What's the worst name you've come across recently? How have names ever misled you? How would you have changed them to avoid future confusion?</p></li><li class="listitem"><p>Do you have to port code between platforms? How has this affected filenames, other names, and the overall code structure?</p></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="the_writestuff"/>Chapter 4. THE WRITESTUFF</h1></div><div><h3 class="subtitle"><i>Techniques for Writing "Self-Documenting" Code</i></h3></div></div></div><div class="epigraph"><p>Real seriousness in regard to writing is one of two absolute necessities. The other, unfortunately, is talent.</p><div class="attribution"><span>--<span class="attribution">Ernest Hemingway</span></span></div></div><p>Modern self-assembly ( <span class="emphasis"><em>flat-pack</em></span>) furniture is remarkable, leaving even the seasoned carpenter in a state of awe and confusion. Generally, it's cleverly designed and will <span class="emphasis"><em>eventually</em></span> build into what you expect it to.</p><p>When assembling it, you have to rely on the supplied instructions—you'll build something more like modern art than furniture without them. The quality of the instructions drastically affects how easy construction is. Bad instructions make you sweat, swear, and continually take apart pieces of wood that should never have been attached in the first place.</p><p>It's a shame they don't make things like they used to.</p><p>Source code suffers from similar problems. It's true, they don't make it like they used to, but no one was ever <span class="emphasis"><em>that</em></span> fond of punched cards or COBOL anyway. More importantly, without good instructions that explain how the code fits together, working with some programs can make you sweat, swear, and continually take apart pieces of code that should never have been attached in the first place.</p><p>Creating good code means creating <span class="emphasis"><em>well-documented</em></span> code. The reason we write code is to communicate clear sets of instructions—not just to the computer, but also to the poor fools who have to fix or extend those instructions later on. Code in the Real World is never written and then forgotten about. It will be modified, extended, and maintained over the life of the software product. To do this we need instructions, a user guide—documentation.</p><p>Common wisdom for documenting code is that you should either write tons of documents <span class="emphasis"><em>about</em></span> the code or write tons of comments <span class="emphasis"><em>in</em></span> the code.</p><p>Both ideas are nonsense. Most programmers have an aversion to word processors and get bored with writing too many comments. Writing code <span class="emphasis"><em>is</em></span> hard work. Documenting it shouldn't be more hard work. In the heat of the software factory, anything that requires extra work tends not to be done. Or if it is, it is done badly.</p><p>I've seen software systems propped up by design specifications, implementation notes, maintenance guides, and style guides. Unsurprisingly, this is the kind of code that's really tedious to work with. The problem with all of this supporting documentation is:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>We don't need extra work to do. Writing documentation takes a lot of time; so does reading it. Programmers would rather spend that time programming.</p></li><li class="listitem"><p>All these separate documents must be kept up to date with any code changes. In a large project, that's an awful lot of work. The common alternative (never updating any documentation) leads to dangerously inaccurate and misleading information.</p></li><li class="listitem"><p>A forest of documentation is hard to manage. It's not easy to find the right document or to locate a particular piece of information that could be in one of several places within a document. Like code, documentation has to be held under revision control, and you must make sure you're reading the corresponding document version for the version of source code you're working on.</p></li><li class="listitem"><p>Important information in separate documents can easily be missed. If it's not beside the code, and there are no helpful pointers, things are overlooked.</p></li></ul></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Don't write code that needs to be propped up by external documentation. It's flimsy. Ensure that your code reads clearly on its own</em></span>.</p></dd></dl></div><p>The common alternative—documenting your code with detailed code comments—can be just as bad, if not worse. Reams of slavishly detailed comments obstruct good code. You'll end up writing poorly formatted documentation rather than a good program.</p><p>How do we avoid this nightmare? We write <span class="emphasis"><em>self-documenting</em></span> code.<a class="indexterm" id="IDX-CHP-4-0262"/></p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="self-documenting_code"/>Self-Documenting Code</h1></div></div></div><p>It sounds like a good idea, doesn't it? But what <span class="emphasis"><em>is</em></span> self-documenting code? This program is self-documenting:<a class="indexterm" id="IDX-CHP-4-0263"/><a class="indexterm" id="IDX-CHP-4-0264"/><a class="indexterm" id="IDX-CHP-4-0265"/><a class="indexterm" id="IDX-CHP-4-0266"/><a class="indexterm" id="IDX-CHP-4-0267"/><a class="indexterm" id="IDX-CHP-4-0268"/><a class="indexterm" id="IDX-CHP-4-0269"/><a class="indexterm" id="IDX-CHP-4-0270"/><a class="indexterm" id="IDX-CHP-4-0271"/></p><a id="I_programlisting4_d1e5224"/><pre class="programlisting">
10 PRINT "I am very small and very pointless"
20 GOTO 10
</pre><p>It's not anything to be proud of, though. A more complicated, more useful self-documenting program requires a great deal of skill. Computer programs tend to be much harder to read than they are to write. Anyone who has used Perl will understand this; it has been described as the ultimate write-once language. Indeed, old Perl code can be truly unfathomable, but you can write opaque code in any language, and it doesn't take much effort.</p><p>The only document that describes your code completely and correctly is the code itself. That doesn't automatically mean it's the best description possible, but more often than not, it's the <span class="emphasis"><em>only</em></span> documentation you'll have available.</p><p>You should, therefore, do everything you can to make it good documentation, the kind of documentation that anyone can read. By necessity, code is something that more people than just the author must be able to understand. Programming languages are our communication medium. Clear communication is vital. With clarity, your code gains quality because you're less likely to make mistakes (since errors are more obvious), and it is cheapter to maintain the code—it takes less time to learn.</p><p>Self-documenting code is easily readable code. It is comprehensible on its own, without relying on external documentation. We can improve the clarity of our code in many ways. Some techniques are very basic and have been drilled into us since we were taught to program. Others are more subtle and come with experience.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Write your code to be read. By humans. Easily. The compiler will be able to cope</em></span>.</p></dd></dl></div><p>Here's an example of a simple function that's about as far from self-documenting as you can get. What do you think it does?</p><a id="I_programlisting4_d1e5249"/><pre class="programlisting">
int fval(int i)
{
     int ret=2;
     for (int n1=1, n2=1, i2=i-3; i2&gt;=0; --i2)
     {
         n1=n2; n2=ret; ret=n2+n1;
     }
     return (i&lt;2) ? 1 : ret;
}
</pre><div class="sidebar"><a id="don_apostrophy_t_judge_a_book_._._."/><p class="title"><b>DON'T JUDGE A BOOK . . .</b></p><p>A file of self-documenting code reads a lot like a good reference book. Such a bookis carefully structured, sectioned, and laid out. It reads naturally from front to back and top to bottom, but you can just as easily dive into it as a reference. That's how our code should work. Let's compare the parts:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Introduction</strong></span></span></dt><dd><p>A book's introduction explains what's inside, sets the tone, and explainshow it fits into the bigger picture. A source file should begin with a code comment header. It explains what's in the file and specifies to which project the source file belongs.</p></dd><dt><span class="term"><span class="strong"><strong>Table of contents</strong></span></span></dt><dd><p>Although some argue that the file header should include a list of all thecontained functions, I strongly advise against this. It will rapidly become out of date. You can, however, list the contents of the file (all types and classes, functions, variables) with most modern editors or IDEs, providing useful directions to specific pieces of code.</p></dd><dt><span class="term"><span class="strong"><strong>Sections</strong></span></span></dt><dd><p>This book is divided into several parts. Source files may also split intomajor sections; perhaps a single file contains several classes or logical groups of functions. This is where breakwater comments help. Extravagant ASCII art is generally a Bad Thing, but these kinds of comments help to logically break up the file for easy navigation.</p><p>Beware, though. Putting too many things in a single source file is not a good idea. A simple one-to-one file/class correspondence is best. Large, multipurpose files are confusing to understand and very hard to navigate. (If this advice leaves you with too many source files, then you need to improve the higher-level code structure.)</p></dd><dt><span class="term"><span class="strong"><strong>Chapters</strong></span></span></dt><dd><p>Each chapter of a book is a self-contained and well-named chunk. Source files typically contain a number of well-named functions.</p></dd><dt><span class="term"><span class="strong"><strong>Paragraphs</strong></span></span></dt><dd><p>Within each function, you'll group code into blocks of statements. The initial variable declarations will be in one logical block, separated from the following code by a blank line (well, at least they will be in older C code). This isn't a syntactic thing, just layout that helps you read the code.</p></dd><dt><span class="term"><span class="strong"><strong>Sentences</strong></span></span></dt><dd><p>Sentences naturally correspond to each single code statement.</p></dd><dt><span class="term"><span class="strong"><strong>Cross-references and index</strong></span></span></dt><dd><p>Again, this isn't a part of your source file markup, but a good editor orIDE will provide cross-referencing capabilities. Learn how to use them.</p><p>This is an interesting analogy, but what difference does it make for writing code?Many good book-writing techniques translate into good code-writing techniques. Learn them to make your code more readable. Split code into sections, chapters, and paragraphs. Use layout to emphasize the code's logical structure. Use simple, short code statements—just like short sentences, they're more readable.</p></dd></dl></div></div><p>That's a realistic example; countless millions of lines in production software look like that, and programmers on the front line suffer because of it. In contrast, the following code <span class="emphasis"><em>is</em></span> self-documenting. You can probably work out what it does by just reading the first line.<a class="indexterm" id="IDX-CHP-4-0272"/></p><a id="I_programlisting4_d1e5323"/><pre class="programlisting">
int fibonacci(int position)
{
    if (position &lt; 2)
    {
        return 1;
    }
    int previousButOne = 1;
    int previous       = 1;

    int answer         = 2;



    for (int n = 2; n &lt; position; ++n)
    {
        previousButOne = previous;
        previous       = answer;
        answer         = previous + previousButOne;
    }
    return answer;
}
</pre><p>There's one thing you should notice about that function—the lack of comments. It's obvious what's going on without any. Comments would just add more stuff to be read. They'd be unnecessary noise and would make the function harder to maintain in the future. That's important—because even the smallest, most beautiful functions <span class="emphasis"><em>will</em></span> need later maintenance.<sup>[<a class="footnote" href="#ftn.CHP-4-FN-1" id="CHP-4-FN-1">1</a>]</sup></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-4-FN-1" id="ftn.CHP-4-FN-1">1</a>] </sup>Did you work out what that first example did? Both functions compute a value in the Fibonacci sequence. Which would you prefer to read?</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="techniques_for_self-documenting_code"/>Techniques for Self-Documenting Code</h1></div></div></div><p>Writing self-documenting code is traditionally thought to involve adding a copious amount of comments. Good commenting certainly is an important technique, but there's muchmore to it than that. In fact, we should actively <span class="emphasis"><em>avoid</em></span> comments bywriting clear code that doesn't need them.<a class="indexterm" id="IDX-CHP-4-0273"/><a class="indexterm" id="IDX-CHP-4-0274"/><a class="indexterm" id="IDX-CHP-4-0275"/><a class="indexterm" id="IDX-CHP-4-0276"/><a class="indexterm" id="IDX-CHP-4-0277"/><a class="indexterm" id="IDX-CHP-4-0278"/><a class="indexterm" id="IDX-CHP-4-0279"/></p><p>The following sections list important self-documenting code techniques. You'll notice that they cover similar ground to the other chapters in this first part of the book. That's not entirely surprising—there are many overlapping characteristics of good code; the benefits of one technique will be seen in several areas of code quality.<a class="indexterm" id="IDX-CHP-4-0280"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="write_simple_code_with_good_presentation"/>Write Simple Code with Good Presentation</h2></div></div></div><p>Presentation has an enormous impact on the clarity of code. Thoughtful layout conveys the structure of the code; it makes functions, loops, and conditional statements clearer.<a class="indexterm" id="IDX-CHP-4-0281"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Make the "normal" path through your code obvious. Error cases should not confuse the normal flow of execution. Your <span class="emphasis"><em>if-then-else</em></span> constructs should be ordered consistently (i.e., always place the "normal" case before the "error" case, or vice versa).</p></li><li class="listitem"><p>Avoid too many nested statements. They lead to complex code that needs lengthy explanation. Common wisdom claims that each function should have one and <span class="emphasis"><em>only</em></span> one exit point; this is known as <span class="emphasis"><em>Single Entry, Single Exit (SESE)</em></span> code. But this is actually too restrictive for readable code and leads to deep levels of nesting. I prefer the <code class="literal">fibonacci</code> example we saw previously to this SESE variant:<a class="indexterm" id="IDX-CHP-4-0282"/><a class="indexterm" id="IDX-CHP-4-0283"/></p><a id="I_programlisting4_d1e5411"/><pre class="programlisting">
int fibonacci(int position)
{
    int answer = 1;
    if (position &gt;= 2)
    {
        int previousButOne = 1;
        int previous = 1;


        for (int n = 2; n &lt; position; ++n)
        {
            previousButOne = previous;
            previous       = answer;
            answer         = previous + previousButOne;
        }
    }
    return answer;
}
</pre><p>For the sake of an extra <code class="literal">return</code> statement, I'd rather avoid that gratuitous nesting—it has made the function much harder to read. <code class="literal">return</code>s deep in the middle of a function's logic <span class="emphasis"><em>are</em></span> questionable, but simple short circuits at the top aid function readability immensely.</p></li><li class="listitem"><p>Be wary of optimizing code so that it's no longer a clear expression of abasic algorithm. <span class="emphasis"><em>Never</em></span> optimize code unless you've proved that it <span class="emphasis"><em>is</em></span> a bottleneck to acceptable program function. Optimize only then, and clearly comment about what's going on.</p></li></ul></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="choose_meaningful_names"/>Choose Meaningful Names</h2></div></div></div><p>All variable, type, file, and function names should be meaningful, not misleading. A name should faithfully describe what it represents. If you can't name something meaningfully, then do you really understand what it's doing? Your naming scheme should be consistent so that there are no nasty surprises. Make sure that a variable is only ever used for what its name implies.<a class="indexterm" id="IDX-CHP-4-0284"/><a class="indexterm" id="IDX-CHP-4-0285"/><a class="indexterm" id="IDX-CHP-4-0286"/></p><p>Good names are probably our best way of avoiding gratuitous comments. They are the nearest thing we have in code to the expressiveness of natural language.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="decompose_into_atomic_functions"/>Decompose into Atomic Functions</h2></div></div></div><p>The way that you split the code into functions and the names you give those functions can either add meaning to code or totally strip it of sense.<a class="indexterm" id="IDX-CHP-4-0287"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>One function, one action</em></span>. Make that your mantra. Don't write complex functions that make coffee, clean shoes, <span class="emphasis"><em>and</em></span> guess the number you first thought of. In one function, do one action. Choose a name that unambiguously explains that action. A good name means that no extra documentation is needed.<a class="indexterm" id="IDX-CHP-4-0288"/></p></li><li class="listitem"><p>Minimize any surprising <span class="emphasis"><em>side effects</em></span>, no matter how benign they appear. They require extra documentation.<a class="indexterm" id="IDX-CHP-4-0289"/></p></li><li class="listitem"><p>Keep it short. Short functions are easy to understand. You can get your head around a complex algorithm if it's broken into small pieces with descriptive names, but you can't if it's a sprawling mess of code on the page.</p></li></ul></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="choose_descriptive_types"/>Choose Descriptive Types</h2></div></div></div><p>As much as possible, describe constraints or behavior with the available language features. For example:<a class="indexterm" id="IDX-CHP-4-0290"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If you are defining a value that will never change, enforce it as a constant type (use <code class="literal">const</code> in C).</p></li><li class="listitem"><p>If a variable should not contain a negative value, use an unsigned type (if your language provides one).</p></li><li class="listitem"><p>Use enumerations to describe a related set of values.</p></li><li class="listitem"><p>Select appropriate types. In C/C++, put sizes in <code class="literal">size_t</code> variables and pointer arithmetic results in <code class="literal">ptrdiff_t</code> variables.</p></li></ul></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="name_constants"/>Name Constants</h2></div></div></div><p>Stumbling over some code that reads <code class="literal">if (counter == 76)</code> will leave you scratching your head. What is the magic significance of the number 76? What is the intent of that test?</p><p>These so-called <span class="emphasis"><em>magic numbers</em></span> are evil. They hide meaning. Writing<a class="indexterm" id="IDX-CHP-4-0291"/></p><a id="I_programlisting4_d1e5533"/><pre class="programlisting">
const size_t bananas_per_cake = 76;
...
if (count == bananas_per_cake)
{
    // make banana cake
}
</pre><p>is much clearer. If you use the constant <code class="literal">76</code> (sorry, <code class="literal">bananas_per_cake</code>) a lot in your code, you gain an additional benefit: When you need to change the banana-to-cake ratio, you only need to make one code change, rather than perform an error-prone search-and-replace for every <code class="literal">76</code> in the project.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Avoid magic numbers. Use well-named constants instead</em></span>.</p></dd></dl></div><p>This holds true for constant strings as well as numbers. Question the use of <span class="emphasis"><em>any</em></span> literal in your code, especially when you use it several times over—can you use a more maintainable named constant instead?</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="emphasize_important_code"/>Emphasize Important Code</h2></div></div></div><p>Make important stuff stand out from mundane stuff. Draw the reader's attention to the right places. There are many coding opportunities to do this.<a class="indexterm" id="IDX-CHP-4-0292"/><a class="indexterm" id="IDX-CHP-4-0293"/><a class="indexterm" id="IDX-CHP-4-0294"/><a class="indexterm" id="IDX-CHP-4-0295"/><a class="indexterm" id="IDX-CHP-4-0296"/></p><p>For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Order the declarations in a class helpfully. Public information should come first, since this is what the class user needs to see. Put the private implementation details at the end, since they are less important to most readers.</p></li><li class="listitem"><p>Wherever possible, hide all nonessential information. Don't clutter the global namespace with unnecessary cruft. In C++ you can use the pimpl idiom to hide class implementation details (Meyers 97).</p></li><li class="listitem"><p>Don't hide important code. Write only one statement per line, and keep each statement simple. You <span class="emphasis"><em>can</em></span> write very clever <code class="literal">for</code> loops, putting all the logic on one line with an assortment of commas, but it's not easy to read. Don't do it.<a class="indexterm" id="IDX-CHP-4-0297"/></p></li><li class="listitem"><p>Limit the number of nested conditional statements. If you don't, the handling of important conditions will become hidden by a nest of <code class="literal">if</code>s and braces.</p></li></ul></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Make sure all important code stands out and is easy to read. Hide anything that the client audience doesn't care about</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="group-related_information"/>Group-Related Information</h2></div></div></div><p>Present all related information in one place. Otherwise, you'll not only make the reader jump through hoops, you'll require him to know via ESP where the hoops are. The API for a single component should be presented in a single file. If there is so much related information that it becomes messy to present it all together, question the code's design.</p><p>Whenever possible, group items by a language construct. In C++ and C# we can group items within a <code class="literal">namespace</code>. Java provides <code class="literal">package</code>s as grouping mechanisms. Related constant values can be defined in an <code class="literal">enum</code>.<a class="indexterm" id="IDX-CHP-4-0298"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Group information together intentionally. Use language features to make this grouping explicit</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="provide_a_file_header"/>Provide a File Header</h2></div></div></div><p>Place a comment block at the top of a file to describe its contents and the project to which it belongs. This takes only a little effort, but it can make a big difference. When someone comes to maintain that file, they'll have a good idea what to expect.</p><p>This header can be important: Most companies mandate that every source file contains a visible copyright notice for legal reasons. File headers commonly look something like the following.</p><a id="I_programlisting4_d1e5659"/><pre class="programlisting">
/*********************************************************
 * File: Foo.java
 * Purpose: Foo class implementation
 * Notice: (c) 1066 Foo industries. All rights reserved.
********************************************************/
</pre></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="handle_errors_appropriately"/>Handle Errors Appropriately</h2></div></div></div><p>Handle any error in the most appropriate context. If there is a disk I/O problem, you should handle it in code that accesses the disk. Perhaps handling this error would mean raising a different error (like a "couldn't load file" exception) to a higher level. This means that at each level in the program, an error is an accurate description of what the problem is <span class="emphasis"><em>in that context</em></span>. Don't handle hard disk corruption in the user interface code—it doesn't make sense.<a class="indexterm" id="IDX-CHP-4-0299"/><a class="indexterm" id="IDX-CHP-4-0300"/></p><p>Self-documenting code helps the reader to understand where an error came from, whatit means, and its implications for the program at that point.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Don't return nonsensical errors. Present the appropriate information in each context</em></span>.<a class="indexterm" id="IDX-CHP-4-0301"/></p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="write_meaningful_comments"/>Write Meaningful Comments</h2></div></div></div><p>As you can see, we've tried to avoid writing comments by using other implicit code documentation techniques. However, once you've written the clearest code you can, you need to comment what remains. Clear code contains an <span class="emphasis"><em>appropriate</em></span> amount of commenting. What is this appropriate amount?<a class="indexterm" id="IDX-CHP-4-0302"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Only add comments if you can't improve the clarity of the code in any other way</em></span>.<a class="indexterm" id="IDX-CHP-4-0303"/></p></dd></dl></div><p>Think about all these other techniques first. Would a name change or a new subordinate function make the code clearer and avoid a comment?</p><div class="sidebar"><a id="self-improvement"/><p class="title"><b>SELF-IMPROVEMENT</b></p><p>How do you get better at writing self-documenting code? Let's head back into bookwriting territory for some clues.<a class="indexterm" id="IDX-CHP-4-0304"/></p><p>There's a simple principle for improving your writing skills: <span class="emphasis"><em>If you read a lot, you become a better writer</em></span>. Critically reading the works of recognized authors teaches you what works and what doesn't. You pick up new techniques and idioms to add to your arsenal.</p><p>Similarly, if you read a lot of code, you'll become a better programmer. If you immerse yourself in <span class="emphasis"><em>good</em></span> code, you'll soon be able to smell bad code a mile away. Customs officials see so many passports each day that a forged one stands out like a sore thumb. Even clever imitations become obvious. Bad code becomes so much more striking when you're sensitive to the warning signs.</p><p>With this experience you'll naturally find yourself using good techniques in yourown code. You'll begin to spot when you write bad code; it will feel uncomfortable.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="practical_self-documentation_methodologies"/>Practical Self-Documentation Methodologies</h1></div></div></div><p>We'll conclude this chapter by comparing two specific code documentation methods. Remember that these methods come <span class="emphasis"><em>after</em></span> the techniques we've just seen. Kernighan and Plaugher said, "Don't document bad code—rewrite it." (Kernighan Plaugher 78)<a class="indexterm" id="IDX-CHP-4-0305"/><a class="indexterm" id="IDX-CHP-4-0306"/><a class="indexterm" id="IDX-CHP-4-0307"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="literate_programming"/>Literate Programming</h2></div></div></div><p><span class="emphasis"><em>Literate programming</em></span> is an extreme self-documenting code technique, conceived by the renowned computer scientist Donald Knuth. He wrote a book by this name that described it. (Knuth 92) It is a radical alternative to the traditional programming model, although some people think the literate programming episode of Knuth's careerwas a large and unfortunate sidetrack. Even if it's not the One True Way to code, there are still things we can learn from it.<a class="indexterm" id="IDX-CHP-4-0308"/></p><p>The idea behind literate programming is simple: You don't write a program, you write a document. The documentation language is bound up tightly with the programming language. Your document is primarily a description of <span class="emphasis"><em>what</em></span> is being programmed, but also happens to compile <span class="emphasis"><em>into</em></span> that program. The source code is the documentation, and vice versa.</p><p>A literate program is written almost as a story; it is easy for the human reader tofollow, perhaps even enjoyable to read. It is not ordered or constrained for a language parser. This is more than just a language with inverted comments; it's an inverted method for programming. Literate programming is a whole different way of thinking.</p><p>Knuth originally mixed TEX (a markup language for document typesetting) and C in a system called <span class="emphasis"><em>WEB</em></span>. A literate programming tool parses the program file and generates either formatted documentation or source code that can be fed into a traditional compiler.<a class="indexterm" id="IDX-CHP-4-0309"/><a class="indexterm" id="IDX-CHP-4-0310"/></p><p>Of course, this is just another programming technique, like structured programming or object-oriented programming. It doesn't <span class="emphasis"><em>guarantee</em></span> quality documentation. That is, as ever, up to the programmer. However, literate programming shifts the emphasis toward writing a description of the program rather than just writing code that implements it.</p><p>Literate programming really comes into its own during a product's maintenance phase. With good quality (and quantity of ) documentation directly on hand, it becomes much easier to maintain the source.<a class="indexterm" id="IDX-CHP-4-0311"/><a class="indexterm" id="IDX-CHP-4-0312"/></p><p>There are many useful qualities of literate programming:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Literate programming places emphasis back on writing documentation.</p></li><li class="listitem"><p>It makes you think about your code in a different way since you write explanations and justifications as you go along.</p></li><li class="listitem"><p>You are more likely to update the documentation when you make changes to the code, since it's situated conveniently nearby.</p></li><li class="listitem"><p>You are guaranteed to only have one document for the whole codebase. You'll always be able to view the correct version for the code you're working on—it <span class="emphasis"><em>is</em></span> the code you're working on.</p></li><li class="listitem"><p>Literate programming encourages the inclusion of items not normally foundin source comments. For example: a description of the algorithms used, proofs of correctness, and the justification of design decisions.</p></li></ul></div><p>However, literate programming isn't a magical cure-all. It has some serious drawbacks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Literate programs are harder to write, because most programmers don't find it natural. We tend not to think of code as a printed document that needs formatting. Rather, we mentally model control flows and interacting objects.</p></li><li class="listitem"><p>Extra compilation steps are required, which make literate programs slowerto work with. There is still no <span class="emphasis"><em>really</em></span> good tool support.</p><p>It's quite difficult to process a literate program, since the compiler needs to extract all the program fragments and reassemble them, in the correct order. Whileit's nice to write the document in any order, C can be quite specific about how it wants to see code; <code class="literal">#includes</code> must come first, for example. This leads to some practical compromises.</p></li><li class="listitem"><p>You might end up documenting some code that doesn't really need it. And the alternative, not documenting swathes of simple code, often happens too. This is no longer a good literate program; you may as well not have bothered.</p><p>When <span class="emphasis"><em>everything</em></span> is being written about, you can miss the few important bits of documentation in all the noise.<a class="indexterm" id="IDX-CHP-4-0313"/></p></li><li class="listitem"><p>Knuth talked about <span class="emphasis"><em>the programmer as essayist</em></span>. Many a programmer couldn't write an essay to save his life, but he can write the most exquisite code. Maybe these guys are exceptions to the rule, but not every good programmer is a capable literate programmer.</p></li><li class="listitem"><p>Tying documentation intimately to code can be problematic. You may have frozen your code for a major release—no changes are allowed—but you still need to work on the documentation. Altering the documentation means altering the source code. Now you have an executable-release version and a documentation-release version of the same codebase that you have to tie together: a management nightmare.</p></li></ul></div><p>A later chapter discusses software specifications; how does literate programming relate to specifications? A literate program will never replace a functional specification describing what work needs to be done. However, it should be possible to develop a literate program from such a specification. The literate program really is more of a combination of traditional code with a design and implementation specification.<a class="indexterm" id="IDX-CHP-4-0314"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="documentation_tools"/>Documentation Tools</h2></div></div></div><p>There is a breed of programming tool that sits halfway between the literate programming approach and writing external specifications. These tools generate documentation from your source code by pulling out blocks of specially formatted comments. This technique has become particularly fashionable since Sun introduced Javadoc as a core component of the Java platform. All ofthe Java API documentation is generated by Javadoc.<a class="indexterm" id="IDX-CHP-4-0315"/><a class="indexterm" id="IDX-CHP-4-0316"/></p><p>To understand exactly how this works, we'll look at an example. The exact comment formats may differ, but to document a <code class="literal">Widget</code> class, you'd write something like:</p><a id="I_programlisting4_d1e5882"/><pre class="programlisting">
<span class="strong"><strong>/**
 * This is the documentation for the Widget class.
 * The tool knows this because the comment started
 * with the special '/**' sequence.
 *
 * @author Author name here
 * @version Version number here
 */</strong></span>
class Widget
{
public:
    <span class="strong"><strong>/**
    * This is the documentation for a method.
     */</strong></span>
   void method();
};
</pre><p>The documentation tool will parse each of your project's files, extract the documentation, build a cross-referenced database of all the information it finds on the way, andspit out a pretty document containing this information.</p><p>You can document pretty much any code you write: classes, types, functions, parameters, flags, variables, namespaces, packages, and so on. There are facilities to capture alot of information, including the ability to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Specify copyright information</p></li><li class="listitem"><p>Document the date of creation</p></li><li class="listitem"><p>Cross-reference information</p></li><li class="listitem"><p>Mark old code as deprecated</p></li><li class="listitem"><p>Provide a short synopsis for quick reference</p></li><li class="listitem"><p>Present a description of each function parameter</p></li></ul></div><p>There are many documentation tools available, both open source and commercial. We've already mentioned Javadoc; other popular tools are C#'s NDoc and the excellent Doxygen (<a class="ulink" href="http://www.doxygen.org">www.doxygen.org</a>).<a class="indexterm" id="IDX-CHP-4-0317"/></p><p>This is an excellent approach to documentation, allowing you to document code at a sensible level of detail without writing a separate specification. You can easily read your documentation in the source files too, which can be very helpful.</p><p>Documentation tools offer many benefits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Like literate programming, this approach encourages you to write documentation and keep it up to date.</p></li><li class="listitem"><p>No separate step is required to get compilable code.</p></li><li class="listitem"><p>It's more natural, not requiring massive adjustments or a steep learning curve. While the code can be used to generate a document, you don't have to artificially make your code look like a book or worry about tedious text layout concerns.</p></li><li class="listitem"><p>The documentation tools support rich searching, cross-referencing, and code-outlining features.</p></li></ul></div><p>However, it is important to understand the consequences of comment-based code documentation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Unlike literate programming, it's really only useful for API documentation, not internal code documentation. You must use regular comments at the statement level.</p></li><li class="listitem"><p>It's hard to glance at a source file and get an overview of the contents, since they are spaced out by reams of documentation comments. You'd have to use the overview output of the tool instead. This may be beautifully formatted, but it's inconvenient to view when you're immersed in the world of the code editor.</p></li></ul></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Use literate documentation tools to automatically generate documentation from your code</em></span>.</p></dd></dl></div><p>Although this is a powerful way to write documentation, you <span class="emphasis"><em>can</em></span> still write bad documentation using it. These are some helpful heuristics for getting it right:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>For each publicly visible item, write a one- or two-sentence description;don't go overboard with reams of text. A slew of prose is slow to read and hard to update. Don't waffle.</p></li><li class="listitem"><p>Document variables or parameters if it's not clear what they're used for, but don't document them if their names make it obvious. You don't need to document every last detail if it doesn't add any value. The tool's output will still include the item, just with no textual explanation.</p></li><li class="listitem"><p>If some of a function's parameters are used for input and some for output, make this clear in their descriptions. Few languages provide a syntactic mechanism to express this, so you must document it explicitly.</p></li><li class="listitem"><p>Document any function pre- or postconditions, what exceptions might be thrown, and any of a function's side effects.</p></li></ul></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id3"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p><span class="emphasis"><em>The skill of writing is to create a context in which other people can think</em></span>.</p><div class="attribution"><span>--<span class="attribution">Edwin Schlossberg</span></span></div></div><p>We write code primarily to communicate. Code without documentation is a perilous thing, hardly communicative. It is a high-maintenance problem. <span class="emphasis"><em>Bad</em></span> documentation is no better, either misleading the reader or resulting in a flimsy program that relies on external explanation.</p><p>Often the only documentation we have for a piece of code <span class="emphasis"><em>is</em></span> that code itself. Making the code self-documenting and clear to read goes some way to remedy this situation. Self-documenting code doesn't happen magically, you have to carefully think about it. The result is code that looks like it <span class="emphasis"><em>was</em></span> easy to write.<a class="indexterm" id="IDX-CHP-4-0318"/><a class="indexterm" id="IDX-CHP-4-0319"/></p><p>Literate programming is one (quite extreme) method of writing self-documenting code. Another less extreme method employs documentation tools. These tools can generate API documentation very easily, but they don't necessarily replace all written specifications.<a class="indexterm" id="IDX-CHP-4-0320"/></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Seek to write clear, self-documenting code</p></li><li class="listitem"><p>Try to write the least amount of documentation necessary</p></li><li class="listitem"><p>Think about the needs of programmers who will maintain their code</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Are proud that they write unfathomable spaghetti</p></li><li class="listitem"><p>Try to avoid writing any documentation</p></li><li class="listitem"><p>Don't care about updating documentation</p></li><li class="listitem"><p>Think, "If it was hard for me to write, it should be hard for anyone else to understand."</p></li></ul></div>
</td></tr></tbody></table></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e6058"/><img alt="In a Nutshell" src="tagoreillycom20080909nostarchimages207456.png.jpg"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id3"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch03.html" title="Chapter 3. WHAT'S IN A NAME?">Chapter 3</a></span></dt><dd><p>Good names are powerful tools when writing self-documenting code.</p></dd><dt><span class="term"><span class="strong"><strong>A Passing Comment</strong></span></span></dt><dd><p>When you do resort to writing comments, this is how to do it correctly.</p></dd><dt><span class="term"><a class="xref" href="ch19.html" title="Chapter 19. BEING SPECIFIC">Chapter 19</a></span></dt><dd><p>Code should document itself, but we still need separate specifications for many reasons.</p></dd></dl></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id4"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 480.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id3"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Grouping related code will make its relationships clear. How can we perform this grouping? Which methods document the relationships most strongly?</p></li><li class="listitem"><p>We should avoid using <span class="emphasis"><em>magic numbers</em></span> in our code. Is zero a magic number? What should you call a constant value representing zero?</p></li><li class="listitem"><p>Self-documenting code makes good use of context to convey information. Show how you do this, and give an example of how a particular name would lead to a different interpretation in different functions?</p></li><li class="listitem"><p>Is it realistic to expect a newcomer to pick up some self-documenting code and understand it totally?</p></li><li class="listitem"><p>If code is truly self-documenting, how much other documentation is required?</p></li><li class="listitem"><p>Why must more people than the original author understand any piece of code?</p></li><li class="listitem"><p>This simple C <span class="emphasis"><em>bubblesort</em></span> function could use some improvement. What specific things are wrong with it? Write an improved, self-documenting version.</p><a id="I_programlisting4_d1e6124"/><pre class="programlisting">
void bsrt(int a[], int n)
{
    for (int i = 0; i &lt; n-1; i++)
        for (int j = n-1; j &gt; i; j--)
            if (a[j-1] &gt; a[j])
            {
                int tmp = a[j-1];
                a[j-1]  = a[j];
                a[j]    = tmp;
            }
}
</pre></li><li class="listitem"><p>Working with code documentation tools brings up some interesting issues. What's your opinion on these?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>When you review the documentation, should you perform a <span class="emphasis"><em>code review</em></span>, looking at the comments in the source files, or a <span class="emphasis"><em>specification review</em></span>, looking at the generated documents?</p></li><li class="listitem"><p>Where do you put documentation of protocols and other non-API issues?</p></li><li class="listitem"><p>Do you document private/internal functions? In C/C++, where do you place this documentation—in the header file or implementation file?</p></li><li class="listitem"><p>In a large system, should you create a single, large API document or several smaller documents, one per area? What are the advantages of each approach?</p></li></ol></div></li><li class="listitem"><p>If you're working on a codebase that isn't literately documented, and you need to alter or add new methods or functions, is it a good idea to give them literate documentation comments, or should you leave them undocumented?</p></li><li class="listitem"><p>Is it possible to write self-documenting assembly code?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id3"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>What do you consider to be the best documented code you've come across? What made it so?<a class="indexterm" id="IDX-CHP-4-0321"/></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Did this code have a large number of external specifications? How many of them did you read? How can you be sure you knew enough about the code without reading them all?</p></li><li class="listitem"><p>How much of this do you think was due to the author's programming style, and how much was because of any house style or guidelines he or she worked to?</p></li></ol></div></li><li class="listitem"><p>If you write in more than one language, how does your documentation strategy differ in each?</p></li><li class="listitem"><p>In the last code you wrote, how did you make the important stuff stand out? Did you hide private information away appropriately?</p></li><li class="listitem"><p>If you're working on a team, how often do others come to you to ask you how something works? Could you avoid this with better-documented code?</p></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="a_passing_comment"/>Chapter 5. A PASSING COMMENT</h1></div><div><h3 class="subtitle"><i>How to Write Code Comments</i></h3></div></div></div><div class="epigraph"><p>Comments are free but facts are sacred.</p><div class="attribution"><span>--<span class="attribution">Charles Prestwich Scott</span></span></div></div><p>Comments are a lot like opinions. You're free to make them, but just because you do doesn't mean they're right. In this chapter, we'll spend a little time thinking about the details of writing these things. There's a lot more to writing comments than you'd think.</p><p>Probably one of the first things you learned when you were taught to program was how to write comments. You were told that comments aid the readability of code, and you were probably encouraged to write lots of them. But in this game, we need to be thinking more about <span class="emphasis"><em>quality</em></span> than <span class="emphasis"><em>quantity</em></span>. Comments are our lifelines, memory jogs, and guides through code. We should treat them with the respect they deserve.</p><p>I set my syntax-highlighting code editor to display comments in green. This way, I get an immediate feeling for the quality of a piece of code and how easy it's going to be to work with as soon as I load up a source file. A nice proportion of green spread through in the right pattern makes me feel good about the world. The opposite makes me stroll to the kitchen for a strong coffee before going any further.</p><p>Comments can make the difference between bad code and good code, between a grossly complex and unfathomable morass of logic and a nice set of clear algorithms. But let's not overstate the case—there are things far more important to get right than comments. When you've written truly good code, your comments are the <span class="emphasis"><em>icing on the cake</em></span>, delicately placed to add aesthetics and value, rather than liberally slapped on to cover up all the cracks and blemishes.</p><p>Good commenting is a strategy to avoid intimidating code. Comments aren't a magic additive to turn sour code sweet.</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_is_a_code_comment_question"/>What Is a Code Comment?</h1></div></div></div><p>Don't skip this section! Admittedly, this is an excruciating place to start. We all know what a code comment is, right? But it is more philosophical than you might think.<a class="indexterm" id="IDX-CHP-5-0324"/></p><p>Syntactically, a comment is a block of source that the compiler will ignore. Put what you like in it, the names of your grandchildren or the color of your favorite shirt; the compiler won't bat an eye as it merrily parses its way through the file.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-1" id="CHP-5-FN-1">1</a>]</sup></p><p>Semantically, a comment is the difference between a dingy dirt track and a well-lit highway. The comment is an annotation of the code it's situated by. You can use it as a highlighter to make a particular problem area stand out or as a documentation medium in your header file. You might use comments to describe the shape of an algorithm, to aid the maintenance programmer (which could be you later on), or to mark the space between each function to help you navigate through a source file more quickly.</p><p>Comments are aimed at the human reader, not the computer. In this sense, comments are the most human-focused brick in the programming wall. They are ornately molded bricks, as opposed to structural breeze blocks. If we want to improve the quality of our comments, we need to look at and address what the human really needs as he reads code.</p><p>Code comments are not the only documentation that you should put in your code. Comments are not specifications. They are not design documents. They are not API references.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-2" id="CHP-5-FN-2">2</a>]</sup> However, they are an invaluable form of documentation that will always be physically attached to the code (unless someone maliciously hits DELETE). Their close proximity means they're more likely to be updated and more likely to be read in context. It's an internal documentation mechanism.</p><p>As responsible programmers, we have a duty to comment well.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-1" id="ftn.CHP-5-FN-1">1</a>] </sup>Of course, the thing that chews up and spits out the comments differs with the kind of language you're using. In C/C++, the monstrous <span class="emphasis"><em>preprocessor</em></span> beast devours comments before the compile stage begins. In other languages, the compiler itself throws away comments as it tokenizes the source. In interpreted languages, your intense commenting may slow down execution, since the interpreter has to jump over the names of all your grandchildren.<a class="indexterm" id="IDX-CHP-5-0325"/><a class="indexterm" id="IDX-CHP-5-0326"/></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-2" id="ftn.CHP-5-FN-2">2</a>] </sup>Well, unless you use a literate programming tool, discussed in "<a class="xref" href="ch04s03.html#literate_programming" title="Literate Programming">Literate Programming</a>" on page 66.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_do_comments_look_like_question"/>What Do Comments Look Like?</h1></div></div></div><p>Well, they're green aren't they? At least they are for me.<a class="indexterm" id="IDX-CHP-5-0327"/><a class="indexterm" id="IDX-CHP-5-0328"/><a class="indexterm" id="IDX-CHP-5-0329"/></p><p>C comments come in blocks between <code class="literal">/*</code> and <code class="literal">*/</code> and can span any number of lines. C++, C99, C#, and Java add the single line comment that follows <code class="literal">//</code>. Other languages provide similar <span class="emphasis"><em>block</em></span> and <span class="emphasis"><em>line</em></span> comment facilities, but with different syntaxes.<a class="indexterm" id="IDX-CHP-5-0330"/><a class="indexterm" id="IDX-CHP-5-0331"/><a class="indexterm" id="IDX-CHP-5-0332"/><a class="indexterm" id="IDX-CHP-5-0333"/><a class="indexterm" id="IDX-CHP-5-0334"/><a class="indexterm" id="IDX-CHP-5-0335"/></p><p>Again, this is elementary subject matter. But the different comment markers are often used in subtly different ways. We'll see examples as we go along. However, any commenting scheme that makes cute use of subtle syntax differentiations should be viewed warily.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="how_many_comments_question"/>How Many Comments?</h1></div></div></div><div class="epigraph"><p>Vigorous writing is concise.</p><div class="attribution"><span>--<span class="attribution">William Strunk Jr.</span></span></div></div><p>We need to focus on comment quality, not quantity, so more important than the amount of comments we write are the contents of those comments. The next section discusses this.</p><p>Student programmers are taught to write comments, and lots of them. But there is such a thing as <span class="emphasis"><em>too much</em></span> commenting—you can obscure important sections of code in a dense forest of words. Code quality suffers when you have to spend more time wading through complex paragraphs of comments than the actual code that you need to read.</p><p>I liken this skill to being a good musician. Playing in a band is not about how much noise you can make at every conceivable opportunity. The more you play your instrument, the more complex the overall sound, and the worse the music. Likewise, too many comments muddle the code. A good musician doesn't have to think, <span class="emphasis"><em>When should I stop playing and let someone else have a chance?</em></span> A good musician only plays when it will really add something. It's about playing the <span class="emphasis"><em>minimum</em></span> you can to create the best sound possible. The beauty is in the space. We should only be writing comments when they really add something.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Learn to write</em></span> enough <span class="emphasis"><em>comments, and no more. Favor quality, not quantity</em></span>.</p></dd></dl></div><p>The people who will read your comments can also read the code, so try to document as much as possible <span class="emphasis"><em>in the code itself</em></span>, rather than in comments. It's what they'll believe, anyway—comments have a nasty tendency to lie. Consider your code statements the first level of comment, and make them self-documenting.<a class="indexterm" id="IDX-CHP-5-0336"/></p><p>Well-written code doesn't actually need comments, because everything should be self-explanatory. Function names like <code class="literal">f()</code> and <code class="literal">g()</code> scream out for comments to describe them, but <code class="literal">someGoodExample()</code> doesn't ask for a comment at all. You can see it's a good example function name.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Spend your time writing code that doesn't need to be propped up by tons of comments</em></span>.</p></dd></dl></div><p>The fewer comments you write, the less chance you have of writing bad comments.</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="what_goes_inside_our_comments_question"/>What Goes Inside Our Comments?</h1></div></div></div><div class="epigraph"><p>Of writing well the source and fountainhead is wise thinking.<a class="indexterm" id="IDX-CHP-5-0337"/><a class="indexterm" id="IDX-CHP-5-0338"/></p><div class="attribution"><span>--<span class="attribution">Horace</span></span></div></div><p>Bad comments are worse than no comments at all—they will misinform and mislead the reader. So what sort of thing should you write in comments? Here are a few basic steps to improve the quality of your comment content:</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="explain_why_comma_not_how"/>Explain Why, Not How</h2></div></div></div><p>This is a key point, so read this paragraph twice. Then eat the page. Your comments should not describe <span class="emphasis"><em>how</em></span> the program works. You can see that by reading the code. After all, the code is the definitive description of how the code works. And it has been written clearly and comprehensibly, hasn't it? You should instead focus on describing <span class="emphasis"><em>why</em></span> something is written the way it is or what the next block of statements ultimately achieves.</p><p>Constantly check whether you're writing <code class="literal">/* update WidgetList structure from GlbWLRegistry */</code> or <code class="literal">/* cache widget information for later */</code>. They might equate to the same thing, but the latter conveys the intent of the code, while the former just tells you what it's doing.</p><p>As you maintain a section of code, the reason <span class="emphasis"><em>why</em></span> it exists will change less often than <span class="emphasis"><em>how</em></span> it achieves that purpose, making this sort of comment's maintenance much easier.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Good comments explain</em></span> why <span class="emphasis"><em>not</em></span> how.</p></dd></dl></div><p>You might also use a comment to explain why you have made a particular implementation choice. If you have two possible implementation strategies and you decide on one over the other, then consider whether it is worth adding a comment explaining this rationale.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="dont_describe_the_code"/>Don't Describe the Code</h2></div></div></div><p>Worthless descriptive comments can be obvious: <code class="literal">++i; // increment i</code>. They can also be more subtle: a lengthy comment description of a complex algorithm, followed by the implementation of the algorithm. There is no need to restate code laboriously in English unless you're documenting a really complex algorithm that's impenetrable without it. And then you should probably worry more about rewriting the algorithm than the comment.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Honor the golden rule</em></span>: One fact—one source. <span class="emphasis"><em>Don't duplicate code in a comment</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="dont_replace_code"/>Don't Replace Code</h2></div></div></div><p>If you see a comment stating something that could be enforced by the language itself (e.g., <code class="literal">// this variable should only be accessed by class foo</code>), then look to express it in concrete syntax.</p><p>If you find yourself writing reams of comments to explain how a complex algorithm works, stop. First pat yourself on the back for trying to document what's going on. But then consider whether you could change the code or the algorithm to make it clearer.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Perhaps you could split the code into several well-named functions to reflect the program logic.</p></li><li class="listitem"><p>Don't write comments to describe the use of a variable; rename the variable. The comment you were going to write will often tell you what the name of the variable should be!</p></li><li class="listitem"><p>If you are documenting a condition that should always hold, perhaps you should be writing an assertion.</p></li><li class="listitem"><p>Remember that you don't need to prematurely optimize (and thus obfuscate) your code.</p></li></ul></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>When you find yourself writing dense comments to explain your code, step back. Is there a bigger problem to solve?</em></span></p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="keep_it_useful"/>Keep It Useful</h2></div></div></div><p>A good comment usually takes several iterations to move up the quality ladder, just like code. Make sure your comments:<a class="indexterm" id="IDX-CHP-5-0339"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Document the unexpected</strong></span></span></dt><dd><p>If any bits of code are unusual, unexpected, or surprising, document them with a comment. You'll thank yourself when you come back later, having forgotten all about the problem. If there are specific work-arounds, say for an operating system issue, then mention this in a comment.</p><p>The flip side of this is that you don't need to document the obvious. Remember: <span class="emphasis"><em>Don't repeat the code!</em></span></p></dd><dt><span class="term"><span class="strong"><strong>Tell the truth</strong></span></span></dt><dd><p>When is a comment not a comment? When it's a lie. Okay, you'll never deliberately write lies, but it's easy to accidentally introduce mistruths, especially when modifying code that has already been commented. Later code changes can easily render a comment inaccurate; "<a class="xref" href="ch05s07.html" title="Working with Comments">Working with Comments</a>" on page 84 describes tactics to cope with this.</p></dd><dt><span class="term"><span class="strong"><strong>Are worthwhile</strong></span></span></dt><dd><p>Little witty cryptic comments may be witty, and they might be little, but <span class="emphasis"><em>don't</em></span> put them in. They get in the way and cause confusion. Avoid expletives, inside jokes that only you understand, and comments that are unnecessarily critical—you never know where your code will end up in a month or year's time, so don't write comments that could cause you embarrassment later.</p></dd><dt><span class="term"><span class="strong"><strong>Are clear</strong></span></span></dt><dd><p>Your comment serves to annotate and explain the code. Don't be ambiguous. Be as specific as you can (without writing a thesis about each line). If someone reads your comment and is left wondering what it means, then you have made the code <span class="emphasis"><em>worse</em></span> and slowed down their comprehension.</p></dd><dt><span class="term"><span class="strong"><strong>Are comprehensible</strong></span></span></dt><dd><p>You don't need to write complete, grammatically correct English sentences inside every comment you write. However, the comment <span class="emphasis"><em>must</em></span> be readable. Cute abbreviations of words usually only serve to confuse the reader—especially if English is not his or her first language.</p></dd></dl></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Think about what you're writing in a comment; don't type without using your brain. Read it back again in the context of the code. Does it contain the</em></span> right <span class="emphasis"><em>information?</em></span></p></dd></dl></div><div class="sidebar"><a id="a_war_story"/><p class="title"><b>A WAR STORY</b></p><p>I once did some consulting work for a company that had a mixture of programmers: some were native English speakers, some native Greek speakers. The Greeks could all speak excellent English, but not one of the English speakers could speak Greek (no surprise there).</p><p>One of the Greek programmers wrote comments in Greek and, when politely asked, refused to change this practice. The English programmers couldn't read these comments because they were, quite literally, <span class="emphasis"><em>all Greek to me</em></span>!</p></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="avoid_distractions"/>Avoid Distractions</h2></div></div></div><p>Comments serve to illuminate the surrounding code, so we must avoid anything that distracts from it. Comments should only <span class="emphasis"><em>add value</em></span>. Avoid comments that include:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>The past</strong></span></span></dt><dd><p>We don't need to keep a record of how we <span class="emphasis"><em>used</em></span> to do something. The revision control system does that. We don't need to see old code reproduced in comments, nor a description of an old algorithm.</p></dd><dt><span class="term"><span class="strong"><strong>Code you don't want</strong></span></span></dt><dd><p>Don't knock out code by enclosing it in comments. It's confusing. Even when debugging <span class="emphasis"><em>commando style</em></span> (no pants, no debugger, and no <code class="literal">printf</code>s), <span class="emphasis"><em>don't</em></span> hide code you need to remove in a comment block. Use C's <code class="literal">#ifdef 0</code> . . . <code class="literal">#endif</code> or some equivalent. These constructs nest and have clearer intent (especially important if you forget to come back later and tidy up).</p></dd><dt><span class="term"><span class="strong"><strong>ASCII art</strong></span></span></dt><dd><p>Avoid ASCII art pictures or anything else that tries to highlight code in clever ways. This, for example, is a bad idea:</p><a id="I_programlisting5_d1e6635"/><pre class="programlisting">
aBadExample(n, foo(wibble));
<strong class="userinput"><code>//             ^^^
//             My favorite
//             function</code></strong>
</pre><p>It won't make sense in editors with variable width display fonts. Comments are not supposed to double maintenance effort!</p></dd><dt><span class="term"><span class="strong"><strong>End of blocks</strong></span></span></dt><dd><p>Some programmers comment the end of every control block, for example putting <code class="literal">// end if (a &lt; 1)</code> after the closing brace of an <code class="literal">if</code> statement. This is a redundant form of comment; it needs to be filtered out before real comprehension can occur. The bottom of a block should be visible on the same page as the top, and the code layout should make its start and end clear. All extra verbiage should be avoided.</p></dd></dl></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_practice"/>In Practice</h1></div></div></div><p>The following example illustrates these commenting principles. Consider the following snippet of C++ code. Idiomatic criticisms aside, it is not at all clear what's going on.<a class="indexterm" id="IDX-CHP-5-0340"/></p><a id="I_programlisting5_d1e6665"/><pre class="programlisting">
for (int i = 0; i &lt; wlst.sz(); ++i)
k(wlst[i]);
</pre><p>Yuck. There's some room for improvement here, so let's improve. The code can be made less cryptic by applying sensible layout rules and adding a few comments:</p><a id="I_programlisting5_d1e6669"/><pre class="programlisting">
<strong class="userinput"><code>// Iterate over all widgets in the widget list</code></strong>
for (int i = 0; i &lt; wlst.sz(); ++i)
{
    <strong class="userinput"><code>// Print out this widget</code></strong>
    k(wlst[i]);
}
</pre><p>Much better! Now it's entirely clear what the code snippet is supposed to be doing. I'm still not entirely happy, though. With appropriate function and variable names, we no longer need any comments at all, since the code describes itself:</p><a id="I_programlisting5_d1e6679"/><pre class="programlisting">
for (int i = 0; i &lt; widgets.size(); ++i)
{
    printWidget(widgets[i]);
}
</pre><p>Note that I didn't rename <code class="literal">i</code> to something more long-winded. It's a loop variable with a very small scope. Calling it <code class="literal">loopCounter</code> would have been overkill and would arguably have made the code <span class="emphasis"><em>harder</em></span> to read.</p><p>It shouldn't be surprising that we ended up with no comments at all. Remember Kernighan and Plaugher's advice: "Don't document bad code—rewrite it." (Kernighan Plaugher 78)</p></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="a_comment_on_aesthetics"/>A Comment on Aesthetics</h1></div></div></div><p>You've no doubt heard people religiously touting about how you should format your comments. I'm not going to prescribe the One True Way to format (there is no such thing), but there are a few important aspects to consider. Interpret these as guidelines, according to your personal taste, rather than as rigid dictates.<a class="indexterm" id="IDX-CHP-5-0341"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="consistency"/>Consistency</h2></div></div></div><p>All commenting should be clear and consistent. Choose a specific way to lay out your comments, and use it throughout. Every programmer has a different sense of aesthetics, so choose what works for you. <span class="emphasis"><em>Do</em></span> use a house style if one exists, or examine (good) existing code and follow the styles you see there.<a class="indexterm" id="IDX-CHP-5-0342"/><a class="indexterm" id="IDX-CHP-5-0343"/></p><p>Small formatting issues in comment writing may seem trivial—for example, should each comment start with a capital letter or not? However, if all your comments are randomly capitalized, it conveys a lack of cohesion in the code, as if the programmer didn't really think all that carefully when he crafted it.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="clear_block_comments"/>Clear Block Comments</h2></div></div></div><p>Syntax highlighting editors are great because they help comments to stand out. But don't rely on them too much. Your code might be read from a monochrome printout or viewed in an editor without syntax coloring. The comment work should still be easily readable.</p><p>A few strategies can help here, especially regarding block comments. Placing the start and end markers (e.g., <code class="literal">/*</code> and <code class="literal">*/</code> in C and C++) on their own lines makes them stand out. Placing a margin character down the left side of a block comment also helps to make it appear as a single item:</p><a id="I_programlisting5_d1e6735"/><pre class="programlisting">
<strong class="userinput"><code>/*
 * This is much more readable
 * as a block comment in the midst
 * of a whole pile of code
 */</code></strong>
</pre><p>This is much better than the alternative:<a class="indexterm" id="IDX-CHP-5-0344"/></p><a id="I_programlisting5_d1e6747"/><pre class="programlisting">
 <strong class="userinput"><code>/*
a comment that might
    span a few lines but without
any margin character.
*/</code></strong>
</pre><p>At the very least, line up the comment text so it's not a jagged mess.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="indenting_comments"/>Indenting Comments</h2></div></div></div><p>A comment shouldn't cut across the code and break up the logical flow. Keep it at the same level of indentation as the code around it. That way, the comment appears to apply to the correct level of the code. I always have to stare hard at code like this:<a class="indexterm" id="IDX-CHP-5-0345"/><a class="indexterm" id="IDX-CHP-5-0346"/></p><a id="I_programlisting5_d1e6767"/><pre class="programlisting">
void strangeCommentStyle()
{
    for (int n = 0; n &lt; JUST_ENOUGH_TIMES; ++n)
    {
<strong class="userinput"><code>// This is a meaningful comment about the next line.</code></strong>
        doSomethingMeaningful(n);
<strong class="userinput"><code>// But frankly, it's confusing the pants off of me.</code></strong>
        anotherUsefulOperation(n);
    }
}
</pre><p>In a loop without braces (which isn't a good idea anyway), <span class="emphasis"><em>don't</em></span> put a comment before the single loop body statement—this can lead to all sorts of distaster. If you want a comment in there, wrap up the whole thing in braces. It's a far safer strategy.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="end-of-line_comments"/>End-of-Line Comments</h2></div></div></div><p>Most comments are written on lines of their own, but sometimes a short single line comment can <span class="emphasis"><em>follow</em></span> a code statement. In this case, it's good practice to space out the comment to mark it as clearly apart from the code. For example:</p><a id="I_programlisting5_d1e6788"/><pre class="programlisting">
class HandyExample
{
public:
    ... some nice public stuff ...
private:
    int appleCount;           <strong class="userinput"><code>// End-of-line comments:</code></strong>
    bool isFatherADustman;    <strong class="userinput"><code>// Make them stand out</code></strong>
    int favoriteNumber;       <strong class="userinput"><code>// from the code</code></strong>
};
</pre><p>This is a good example of using comment layout to improve the appearance of your code. If each end-of-line comment came directly after the variable declaration, they'd look jagged, messy, and require more squinting to read.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="helping_you_to_read_the_code"/>Helping You to Read the Code</h2></div></div></div><p>Comments are usually written <span class="emphasis"><em>above</em></span> the code that they describe, not below it. This way, the source code reads downward, almost like a book. The comment serves to prepare the reader for what is to come.</p><p>Used with whitespace, commenting helps to break the code up into "paragraphs." A comment introduces a few lines, explaining what they intend to achieve; the code immediately follows, then a blank line, then the next block. This is such a convention that a comment with a blank line before it feels like a paragraph start, whereas a comment sandwiched in the middle of two code lines feels more like a statement in brackets or a footnote.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Comments are part of the code narrative. Use them in a way that reads naturally</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="choose_a_low-maintenance_style"/>Choose a Low-Maintenance Style</h2></div></div></div><p>It's sensible to choose a low-maintenance comment style, or you'll waste time fiddling with comments when you should be writing code.<a class="indexterm" id="IDX-CHP-5-0347"/><a class="indexterm" id="IDX-CHP-5-0348"/><a class="indexterm" id="IDX-CHP-5-0349"/></p><p>Some C coders create comment blocks with a column of asterisks in the left margin <span class="emphasis"><em>and</em></span> a column of asterisks as a right margin. Arguably this looks very pretty, but the amount of work required to adjust a paragraph of text within such margins is immense. When you could have moved on to the next task at hand, you have to manually realign all the asterisks on the right. If the programmer used tabs, then things get even nastier: If someone with a different-sized tab stop opens the file, he or she will wonder what the original programmer was up to—all the asterisks will look incredibly ugly and badly lined up.<a class="indexterm" id="IDX-CHP-5-0350"/></p><p>The end-of-line comments we saw above are an example of alignment that requires some effort. How much work you're prepared to spend is up to you. There is always a balance between good-looking source code and maintenance effort. I suppose I prefer a little bit of effort to ugly code.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="breakwaters"/>Breakwaters</h2></div></div></div><p>Comments are often used as <span class="emphasis"><em>breakwaters</em></span> between sections of code. This is where people's artistic sensibilities take over; programmers use different schemes to differentiate major comments (<span class="emphasis"><em>this is a new section of code</em></span>) from minor comments (<span class="emphasis"><em>this describes a few of lines of a function</em></span>). A source file implementing several classes may have something like this between each major section:</p><a id="I_programlisting5_d1e6861"/><pre class="programlisting">
<strong class="userinput"><code>/**************************************************************************
 * class foo implementation
 **************************************************************************/</code></strong>
</pre><p>Some programmers insert large blocks of comment art between each function. Some use a long, single-line comment as a rule-off. I just place a couple of blank lines between functions. If your functions are so large that you need visual clues to see where they start and end, then you need to revise your code.</p><p>Avoid using these large rules to emphasize every comment in sight. Otherwise, nothing gets emphasized. Good indentation and structure, not impressive ASCII art, should group code together.</p><p>All that being said, well-chosen breakwater comments can help you to quickly navigate around a file.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="flags"/>Flags</h2></div></div></div><p>Comments can also be used as inline <span class="emphasis"><em>flags</em></span> in the code. There are a number of common conventions. You'll see <code class="literal">//XXX</code>, <code class="literal">//FIXME</code>, or <code class="literal">//TODO</code> littered though files that are still works in progress. Good syntax-highlighting editors display these comments prominently by default. <code class="literal">XXX</code> is used to mark troublesome code or something that needs to be reworked. <code class="literal">TODO</code> often marks missing pieces of functionality for a later return.<sup>[<a class="footnote" href="#ftn.CHP-5-FN-3" id="CHP-5-FN-3">3</a>]</sup> <code class="literal">FIXME</code> indicates something that's known to be broken.<a class="indexterm" id="IDX-CHP-5-0351"/><a class="indexterm" id="IDX-CHP-5-0352"/><a class="indexterm" id="IDX-CHP-5-0353"/><a class="indexterm" id="IDX-CHP-5-0354"/><a class="indexterm" id="IDX-CHP-5-0355"/><a class="indexterm" id="IDX-CHP-5-0356"/><a class="indexterm" id="IDX-CHP-5-0357"/></p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="file_header_comments"/>File Header Comments</h2></div></div></div><p>Every source file should begin with a comment block that describes its contents. This is just a quick overview, a preface, providing some essential information that you always want displayed as soon as a file is opened. If such a header exists, then any programmer who opens the file will have confidence in the contents; it shows the file was thoughtfully created rather than just hacked up as a dumping ground for some new code.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Give every source file a comment prologue</em></span>.</p></dd></dl></div><p>Some people advocate that this header should provide a list of every function, class, global variable, and so on that is defined in the file. This is a maintenance disaster; such a comment would rapidly become out of date. The kind of information this file header <span class="emphasis"><em>should</em></span> contain is the purpose of the file (e.g., <span class="emphasis"><em>implementation of foo interface</em></span>) and a copyright statement describing ownership and copying rights.</p><p>If a source file is automatically generated during the build process, then you must arrange for this file to receive a comment header that states very clearly (in BIG SCARY CAPITAL LETTERS) where it originated. This will prevent someone from mistakenly editing it, only to have the contents regenerated at the next build.</p><p>The header should <span class="emphasis"><em>not</em></span> contain information that could easily become out of date, like the author(s), modifiers, or the date the file was last modified. This probably wouldn't be updated often, and would become misleading. Version control tells you this anyway. It also needn't contain a source file history describing every modification ever made. That information exists in your source control system and doesn't need to be duplicated here. Moreover, if you have to scroll through 10 pages of modification history to get to the first line of code, then the file becomes tedious to work with. For this reason, some programmers put it at the end of the file instead, but this will still make the file unreasonably large, slow to load, and bothersome to work with.<a class="indexterm" id="IDX-CHP-5-0358"/></p><div class="sidebar"><a id="a_well-placed_comment"/><p class="title"><b>A WELL-PLACED COMMENT</b></p><p>We're focusing on <span class="emphasis"><em>code</em></span> comments in this chapter, what we actually type into source code. But different breeds of comment graze in neighboring pastures:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Check in/out comments</strong></span></span></dt><dd><p>Your revision control system maintains a history of how each file was modified over the life of the project. It associates <span class="emphasis"><em>metadata</em></span> with each revision—at the very least, programmer-supplied <span class="emphasis"><em>check-in comments</em></span>. It may also record <span class="emphasis"><em>checkout comments</em></span> if it keeps tabs on which files are currently in use. You use these comments to describe what you are changing, as a record for posterity.</p><p>Such comments are invaluable, and should be created carefully. They should be:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Short (so you can quickly browse a log of all modifications)</p></li><li class="listitem"><p>Accurate (don't get information wrong, or the history is worthless)</p></li><li class="listitem"><p>Complete (so you can see all that has happened in a file without manually <span class="emphasis"><em>diffing</em></span> revisions)</p></li></ul></div><p>Document <span class="emphasis"><em>what</em></span> has changed and <span class="emphasis"><em>why</em></span>, not <span class="emphasis"><em>how</em></span> it has changed. You can use the file revision differences to work out how you modified the code.</p><p>This is where comments about the past belong. It's also the right place for bugtracking references. Don't be tempted to put information that belongs here into source code comments. Remember: <span class="emphasis"><em>One fact—one source</em></span>.</p></dd><dt><span class="term"><span class="strong"><strong>README files</strong></span></span></dt><dd><p>These are plaintext files that live in the directories alongside source code files. They are useful documentation, falling somewhere between formal specifications and code comments. They often contain practical information, perhaps on what each file does or on the structure of the file hierarchy; they are basically short notes.</p><p>READMEs tend to be either haphazard and poorly thought out or badly maintained and out of date—which is a shame. When you come across a README file, you naturally load it up to see what helpful information it contains. The presence of a README shows someone was thinking when they collected the source files together; there was something worth documenting and something worthwhile to say about it.</p></dd></dl></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-5-FN-3" id="ftn.CHP-5-FN-3">3</a>] </sup>Be careful with <code class="literal">TODO</code> comments. You might be better off throwing a <code class="literal">TODO</code> exception instead, which cannot be missed. That way, if you forget to implement the missing code, your program will fail in a well-defined way.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="working_with_comments"/>Working with Comments</h1></div></div></div><p>Comments are convenient tools to use while you are writing code. But be careful not to abuse them.<a class="indexterm" id="IDX-CHP-5-0359"/></p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="helping_you_to_write_routines"/>Helping You to Write Routines</h2></div></div></div><p>A common routine-writing approach is to fashion its structure in comments first and then fill in the code underneath each comment line. If you work this way, you should ask yourself, once finished, whether the remaining comments are still useful. Evaluate them against the criteria just discussed, and revise or remove them if necessary. Don't just leave them and move on.</p><p>The alternative is to write the new routine freehand, and then add any necessary comments afterward. The danger is that you'll forget to finish the job, or that you might not write the best comments—now knowing almost too well how the code works. The experienced programmer comments <span class="emphasis"><em>as he goes along</em></span>. Practice shows you the right amount of commenting to use.</p><p>Don't be afraid of using the flags we saw earlier, like <code class="literal">TODO</code>, as markers to yourself. It will avoid the embarrassment of forgetting to tie up pesky little loose ends. You can easily search your entire codebase for these comments to find out what still needs to be completed.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="bug-fix_notices"/>Bug-Fix Notices</h2></div></div></div><p>A common, but questionable, comment practice is placing notices where faults have been fixed. You may stumble over a comment like this in the middle of a function:</p><a id="I_programlisting5_d1e7068"/><pre class="programlisting">
<strong class="userinput"><code>// &lt;bug reference&gt; - changed to use blah.foo2()
// method because blah.foo() didn't handle &lt;some
// condition&gt; properly</code></strong>
blah.foo2();
</pre><p>Although written with the best intentions (to help you see what's happened in the course of development), these comments often do more harm than good. To understand the real problem, you'd have to look up the fault in your fault-tracking system and pull out the previous revision of the file to investigate what changed. Few bug fixes require that kind of reading, so the newcomer can probably live in blissful ignorance. These comments proliferate in the later stages of development and during maintenance and litter the source code with sidelines, stale information, and distractions from the main thread of execution.</p><p>There <span class="emphasis"><em>is</em></span> an argument for inserting a comment when you make a non-obvious fix—to prevent someone who is revising the code later from reintroducing the bug. However, in these well-chosen cases, you are actually <span class="emphasis"><em>documenting the unexpected</em></span> rather than placing a bug-fix notice.<a class="indexterm" id="IDX-CHP-5-0360"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Comments should live in the</em></span> present, <span class="emphasis"><em>not the past. Don't describe things that have changed, or tell what something used to do</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="comment_rot"/>Comment Rot</h2></div></div></div><p>Comments rot. Well, all carelessly maintained code tends to rot, acquiring unsightly blemishes and losing the original neat design. However, comments seem to rot much more quickly than any other piece of code. They become out of date with the code they describe. This can be profoundly annoying.<a class="indexterm" id="IDX-CHP-5-0361"/><a class="indexterm" id="IDX-CHP-5-0362"/></p><div class="sidebar"><a id="a_war_story-id1"/><p class="title"><b>A WAR STORY</b></p><p>I once worked on a section of code containing the comment <span class="emphasis"><em>Features A and B not yet implemented</em></span>. I needed both these facilities, so I wrote them. Only after having done so did I discover that feature B <span class="emphasis"><em>had</em></span> already been implemented—I had just wasted effort—and feature A was redundant, since the implementation of B handled it as well. If the programmer who did this had removed the incorrect comment, I would have been spared a <span class="emphasis"><em>lot</em></span> of work.</p></div><p>The simple solution is this: When you fix, add, or modify any code, fix, add, or modify any comments around it. Don't just fiddle with a couple of lines and move on. Make sure that any code changes don't turn comments into lies. The corollary is: We must make comments easy to keep up to date, or they won't be updated. Comments must be clearly related to their section of code, not placed in obscure locations.<a class="indexterm" id="IDX-CHP-5-0363"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>When you alter code, maintain any comments around it</em></span>.</p></dd></dl></div><p>Another bad habit is leaving blocks of code commented out. This will confuse you when you come back in a year's time, or when any other programmer stumbles across them. If you encounter some code in a comment block, you'll wonder why it's there. Was it a fix that was never completed? Is it still a work in progress? Did that code never work? Is the rest of the code functionally complete?</p><p>Either leave a note explaining why you have commented the code out or remove it completely—you can always get it back from the source control system. Even if you think you're only knocking something out temporarily, leave yourself a note; you may forget to finish it off.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="maintenance_and_the_inane_comment"/>Maintenance and the Inane Comment</h2></div></div></div><p>As you wade though an old codebase, it's best not to remove any inane comments you find unless they are downright dangerous. Leave them as a warning for future maintenance programmers—they give a useful insight into the (lack of) quality of the surrounding code. Of course, if you're actually trying to improve that piece of code, then do rework the comments as you go! If you find a comment that <span class="emphasis"><em>is</em></span> factually wrong or misleading, then you should rewrite it as a part of your maintenance of the code.</p><p>Learn the interesting area flags like <code class="literal">XXX</code>, and treat them with respect and caution. Also watch for output statements that have been commented out. These are a sure sign that there has been a problem area here in the past—treat the code with care!</p><p>Be aware of comment rot. Just because a comment says <span class="emphasis"><em>this is defined in foo.c</em></span> doesn't mean that it is anymore. Always have faith in code and doubt comments.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id4"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>Major writing is to say what has been seen, so that it need never be said again.</p><div class="attribution"><span>--<span class="attribution">Delmore Schwartz</span></span></div></div><p>We write a lot of comments. That's because we write a lot of code. Learning to write the right sort of comment is important, or our code may keel over under the weight of inappropriate and outdated commenting.<a class="indexterm" id="IDX-CHP-5-0364"/></p><p>Comments are no more important than the code they annotate—you can't make bad code good using comments. Your aim should be self-documenting code that requires no comments at all.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Try to write a <span class="emphasis"><em>few</em></span> really good comments<a class="indexterm" id="IDX-CHP-5-0365"/></p></li><li class="listitem"><p>Write comments explaining <span class="emphasis"><em>why</em></span></p></li><li class="listitem"><p>Concentrate on writing good code rather than a plethora of comments</p></li><li class="listitem"><p>Write helpful comments that make sense</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Can't tell the difference between good and bad comments</p></li><li class="listitem"><p>Write comments explaining <span class="emphasis"><em>how</em></span></p></li><li class="listitem"><p>Don't mind if comments only make sense to themselves</p></li><li class="listitem"><p>Bolster bad code with many comments</p></li><li class="listitem"><p>Fill their source files with redundant information (revision history, etc.)</p></li></ul></div>
</td></tr></tbody></table></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e7246"/><img alt="In a Nutshell" src="tagoreillycom20080909nostarchimages207458.png.jpg"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id4"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch02.html" title="Chapter 2. THE BEST LAID PLANS">Chapter 2</a></span></dt><dd><p>Code layout and presentation schemes will affect how you lay out your comments.</p></dd><dt><span class="term"><a class="xref" href="ch03.html" title="Chapter 3. WHAT'S IN A NAME?">Chapter 3</a></span></dt><dd><p>Another aspect of self-commenting code: choosing good names.</p></dd><dt><span class="term"><a class="xref" href="ch04.html" title="Chapter 4. THE WRITESTUFF">Chapter 4</a></span></dt><dd><p>Discusses <span class="emphasis"><em>self-documenting code</em></span>, a tactic that makes heavy commenting redundant. Also describes <span class="emphasis"><em>literate programming</em></span> techniques.</p></dd><dt><span class="term"><a class="xref" href="ch18.html" title="Chapter 18. PRACTICING SAFE SOURCE">Chapter 18</a></span></dt><dd><p>Revision control systems hold file history so you don't need to explain it in comments.</p></dd></dl></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id5"/>Get Thinking</h1></div></div></div><p>A detailed discussion of the following questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 485.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id4"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How might the <span class="emphasis"><em>need for</em></span> and the <span class="emphasis"><em>content of</em></span> comments differ in the following types of code:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Low-level assembly language (machine code)</p></li><li class="listitem"><p>Shell scripts</p></li><li class="listitem"><p>A single-file test harness</p></li><li class="listitem"><p>A large C/C++ project</p></li></ol></div></li><li class="listitem"><p>You can run tools to calculate what percentage of your source code lines are comments. How useful are these tools? How accurate a measure is this of comment quality?</p></li><li class="listitem"><p>If you come across some incomprehensible code, which is the better way to factor in some intelligibility: adding comments to document what you think is going on, or renaming variables/functions/types with more descriptive names? Which approach will most likely be easier? Which approach will be safer?</p></li><li class="listitem"><p>When you document a C/C++ API with a code comment block, should it go in the public header file that declares the function or the source file containing the implementation? What are the pros and cons of each location?<a class="indexterm" id="IDX-CHP-5-0366"/><a class="indexterm" id="IDX-CHP-5-0367"/></p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id4"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Look carefully at the source files you've recently worked on. Inspect your commenting. Is it honestly any good? (I bet as you read through the code you'll find yourself making a few changes!)</p></li><li class="listitem"><p>How do you ensure that your comments are genuinely valuable and not just personal ramblings that only you can understand?</p></li><li class="listitem"><p>Do the people you work with all comment to the same standard, in about the same way?</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Who's the best at writing comments? Why do you think that? Who's the worst? How much of a correlation does this bear to these individuals' general quality of coding?</p></li><li class="listitem"><p>Do you think any imposed coding standards could raise the quality of the comments written by your team?</p></li></ol></div></li><li class="listitem"><p>Do you include history logging information in each source file? If yes:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Do you do maintain it manually? Why, if your revision control system will insert this for you automatically? Is the history kept particularly accurate?</p></li><li class="listitem"><p>Is this <span class="emphasis"><em>really</em></span> a sensible practice? How often is this information needed? Why is it better if placed in the source file than in another, separate mechanism?</p></li></ol></div></li><li class="listitem"><p>Do you add your initials to or otherwise mark the comments you make in other people's code? Do you ever date comments? When and why do you do this—is it a useful practice? Has it ever been useful to find someone else's initials and timestamping?</p></li></ol></div></div></div>
<div class="chapter" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="to_err_is_human"/>Chapter 6. TO ERR IS HUMAN</h1></div><div><h3 class="subtitle"><i>Dealing with the Inevitable— Error Conditions in Code</i></h3></div></div></div><div class="epigraph"><p>We know that the only way to avoid error is to detect it, that the only way to detect it is to be free to enquire.</p><div class="attribution"><span>--<span class="attribution">J. Robert Oppenheimer</span></span></div></div><p>At some point in life, everyone has this epiphany: <span class="emphasis"><em>The world doesn't work as you expect it to</em></span>. My one-year-old friend Tom learned this when climbing a chair four times his size. He expected to get to the top. The actual result surprised him: He ended up under a pile of furniture.</p><p>Is the world broken? Is it wrong? No. The world has plodded happily along its way for the last few million years and looks set to continue for the foreseeable future. It's <span class="emphasis"><em>our expectations</em></span> that are wrong and need to be adjusted. As they say: <span class="emphasis"><em>Bad things happen, so deal with it</em></span>. We must write code that deals with the Real World and its unexpected ways.<a class="indexterm" id="IDX-CHP-6-0369"/></p><p>This is particularly difficult because the world <span class="emphasis"><em>mostly</em></span> works as we'd expect it to, constantly lulling us into a false sense of security. The human brain is wired to cope, with built-in fail-safes. If someone bricks up your front door, your brain will process the problem, and you'll stop before walking into an unexpected wall. But programs are not so clever; we have to tell them where the brick walls are and what to do when they hit one.</p><p>Don't presume that everything in your program will always run smoothly. The world doesn't always work as you'd expect it to: You <span class="emphasis"><em>must</em></span> handle all possible error conditions in your code. It sounds simple enough, but that statement leads to a world of pain.</p><div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="from_whence_it_came"/>From Whence It Came</h1></div></div></div><div class="epigraph"><p>To expect the unexpected shows a thoroughly modern intellect.<a class="indexterm" id="IDX-CHP-6-0370"/><a class="indexterm" id="IDX-CHP-6-0371"/></p><div class="attribution"><span>--<span class="attribution">Oscar Wilde</span></span></div></div><p>Errors can and will occur. Undersirable results can arise from almost any operation. They are distinct from bugs in a faulty program because you <span class="emphasis"><em>know</em></span> beforehand that an error can occur. For example, the database file you want to open might have been deleted, a disk could fill up at any time and your next save operation might fail, or the web service you're accessing might not currently be available.</p><p>If you don't write code to handle these error conditions, you will almost certainly end up with a <span class="emphasis"><em>bug</em></span>; your program will not always work as you intend it to. But if the error happens only rarely, it will probably be a very subtle bug! We'll look at bugs in <a class="xref" href="ch09.html" title="Chapter 9. FINDING FAULT">Chapter 9</a>.</p><p>An error may occur for one of a thousand reasons, but it will fall into one of these three categories:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>User error</strong></span></span></dt><dd><p>The stupid user manhandled your lovely program. Perhaps he provided the wrong input or attempted an operation that's absolutely absurd. A good program will point out the mistake and help the user rectify it. It won't insult him or whine in an incomprehensible manner.<a class="indexterm" id="IDX-CHP-6-0372"/></p></dd><dt><span class="term"><span class="strong"><strong>Programmer error</strong></span></span></dt><dd><p>The user pushed all the right buttons, but the code is broken. This is the consequence of a bug elsewhere, a fault the programmer introduced that the user can do nothing about (except to try and avoid it in the future). This kind of error should (ideally) never occur.<a class="indexterm" id="IDX-CHP-6-0373"/></p><p>There's a cycle here: Unhandled errors can cause bugs. And those bugs might result in further error conditions occurring elsewhere in your code. This is why we consider defensive programming an important practice.<a class="indexterm" id="IDX-CHP-6-0374"/></p></dd><dt><span class="term"><span class="bolditalic">Exceptional circumstances</span></span></dt><dd><p>The user pushed all the right buttons, and the programmer didn't mess up. Fate's fickle finger intervened, and we ran into something that couldn't be avoided. Perhaps a network connection failed, we ran out of printer ink, or there's no hard disk space left.</p><p>We need a well-defined strategy to manage each kind of error in our code. An error may be detected and reported to the user in a pop-up message box, or it may be detected by a middle-tier code layer and signaled to the client code programmatically. The same principles apply in both cases: whether a human chooses how to handle the problem or your code makes a decision—<span class="emphasis"><em>someone</em></span> is responsible for acknowledging and acting on errors.<a class="indexterm" id="IDX-CHP-6-0375"/></p></dd></dl></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Take error handling seriously. The stability of your code rests on it</em></span>.</p></dd></dl></div><p>Errors are raised by subordinate components and communicated upward, to be dealt with by the caller. They are reported in a number of ways; we'll look at these in the next section. To take control of program execution, we must be able to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Raise an error when something goes wrong</p></li><li class="listitem"><p>Detect all possible error reports</p></li><li class="listitem"><p>Handle them appropriately</p></li><li class="listitem"><p>Propagate errors we can't handle</p></li></ul></div><p>Errors are hard to deal with. The error you encounter is often not related to what you were doing at the time (most fall under the "exceptional circumstances" category). They are also tedious to deal with—we want to focus on what our program <span class="emphasis"><em>should</em></span> be doing, not on how it may go wrong. However, without good error management, your program will be brittle—built upon sand, not rock. At the first sign of wind or rain, it will collapse.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="error-reporting_mechanisms"/>Error-Reporting Mechanisms</h1></div></div></div><p>There are several common strategies for propagating error information to client code. You'll run into code that uses each of them, so you must know how to speak every dialect. Observe how these error-reporting techniques compare, and notice which situations call for each mechanism.<a class="indexterm" id="IDX-CHP-6-0376"/><a class="indexterm" id="IDX-CHP-6-0377"/></p><p>Each mechanism has different implications for the <span class="emphasis"><em>locality of error</em></span>. An error is local in <span class="emphasis"><em>time</em></span> if it is discovered very soon after it is created. An error is local in <span class="emphasis"><em>space</em></span> if it is identified very close to (or even <span class="emphasis"><em>at</em></span>) the site where it actually manifests. Some approaches specifically aim to reduce the locality of error to make it easier to see what's going on (e.g., error codes). Others aim to extend the locality of error so that normal code doesn't get entwined with error-handling logic (e.g., exceptions).<a class="indexterm" id="IDX-CHP-6-0378"/></p><p>The favored reporting mechanism is often an architectural decision. The architect might consider it important to define a homogeneous hierarchy of exception classes or a central list of shared reason codes to unify error-handling code.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="no_reporting"/>No Reporting</h2></div></div></div><p>The simplest error-reporting mechanism is <span class="emphasis"><em>don't bother</em></span>. This works wonderfully in cases where you want your program to behave in bizarre and unpredictable ways and to crash randomly.</p><p>If you encounter an error and don't know what to do about it, blindly ignoring it is <span class="emphasis"><em>not</em></span> a viable option. You probably can't continue the function's work, but returning without fulfilling your function's contract will leave the world in an undefined and inconsistent state.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Never ignore an error condition. If you don't know how to handle the problem, signal a failure back up to the calling code. Don't sweep an error under the rug and hope for the best</em></span>.</p></dd></dl></div><p>An alternative to ignoring errors is to instantly abort the program upon encountering a problem. It's easier than handling errors throughout the code, but hardly a well-engineered solution!</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="return_values"/>Return Values</h2></div></div></div><p>The next most simple mechanism is to return a success/failure value from your function. A boolean return value provides a simple yes or no answer. A more advanced approach enumerates all the possible exit statuses and returns a corresponding <span class="emphasis"><em>reason code</em></span>. One value means <span class="emphasis"><em>success</em></span>; the rest represent the many and varied abortive cases. This enumeration may be shared across the whole codebase, in which case your function returns a subset of the available values. You should therefore document what the caller can expect.<a class="indexterm" id="IDX-CHP-6-0380"/><a class="indexterm" id="IDX-CHP-6-0379"/></p><p>While this works well for procedures that don't return data, passing error codes back <span class="emphasis"><em>with</em></span> returned data gets messy. If <code class="literal">int count()</code> walks down a linked list and returns the number of elements, how can it signify a list structure corruption? There are three approaches:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Return a compound data type (or <span class="emphasis"><em>tuple</em></span>) containing both the return value and an error code. This is rather clumsy in the popular C-like languages and is seldom seen in them.<a class="indexterm" id="IDX-CHP-6-0381"/></p></li><li class="listitem"><p>Pass the error code back through a function parameter. In C++ or .NET, this parameter would be passed by reference. In C you'd direct the variable access through pointers. This approach is ugly and nonintuitive; there is no syntactic way to distinguish a return value from a parameter.</p></li><li class="listitem"><p>Alternatively, reserve a range of return values to signify failure. The <code class="literal">count</code> example can nominate all negative numbers as error reason codes; they'd be meaningless answers anyway. Negative numbers are a common choice for this. Pointer return values may be given a specific invalid value, which by convention is zero (or <code class="literal">NULL</code>). In Java and C#, you can return a <code class="literal">null</code> object reference.<a class="indexterm" id="IDX-CHP-6-0382"/><a class="indexterm" id="IDX-CHP-6-0383"/><a class="indexterm" id="IDX-CHP-6-0384"/><a class="indexterm" id="IDX-CHP-6-0385"/><a class="indexterm" id="IDX-CHP-6-0386"/></p><p>This technique doesn't always work well. Sometimes it's hard to reserve an error range—all return values are equally meaningful and equally likely. It also has the side effect of reducing the available range of success values; the use of negative values reduces the possible positive values by an order of magnitude.<sup>[<a class="footnote" href="#ftn.CHP-6-FN-1" id="CHP-6-FN-1">1</a>]</sup></p></li></ul></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="error_status_variables"/>Error Status Variables</h2></div></div></div><p>This method attempts to manage the contention between a function's return value and its error status report. Rather than return a reason code, the function sets a shared global error variable. After calling the function, you must then inspect this status variable to find out whether or not it completed successfully.<a class="indexterm" id="IDX-CHP-6-0387"/><a class="indexterm" id="IDX-CHP-6-0388"/></p><p>The shared variable reduces confusion and clutter in the function's signature, and it doesn't restrict the return value's data range at all. However, errors signaled through a separate channel are much easier to miss or willfully ignore. A shared global variable also has nasty thread safety implications.<a class="indexterm" id="IDX-CHP-6-0389"/><a class="indexterm" id="IDX-CHP-6-0390"/></p><p>The C standard library employs this technique with its <code class="literal">errno</code> variable. It has very subtle semantics: Before using any standard library facility, you must manually clear <code class="literal">errno</code>. Nothing ever sets a succeeded value; only failures touch <code class="literal">errno</code>. This is a common source of bugs, and it makes calling each library function tedious. To add insult to injury, not all C standard library functions use <code class="literal">errno</code>, so it is less than consistent.<a class="indexterm" id="IDX-CHP-6-0391"/></p><p>This technique is functionally equivalent to using return values, but it has enough disadvantages to make you avoid it. Don't write your own error reports this way, and use existing implementations with the utmost care.</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="exceptions"/>Exceptions</h2></div></div></div><p>Exceptions are a language facility for managing errors; not all languages support exceptions. Exceptions help to distinguish the normal flow of execution from <span class="emphasis"><em>exceptional</em></span> cases—when a function has failed and cannot honor its contract. When your code encounters a problem that it can't handle, it stops dead and throws up an <span class="emphasis"><em>exception</em></span>—an object representing the error. The language run time then automatically steps back up the call stack until it finds some exception-handling code. The error lands there, for the program to deal with.<a class="indexterm" id="IDX-CHP-6-0392"/><a class="indexterm" id="IDX-CHP-6-0393"/><a class="indexterm" id="IDX-CHP-6-0394"/><a class="indexterm" id="IDX-CHP-6-0395"/></p><p>There are two operational models, distinguished by what happens after an exception is handled:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>The termination model</strong></span></span></dt><dd><p>Execution continues after the handler that caught the exception. This behavior is provided by C++, .NET, and Java.<a class="indexterm" id="IDX-CHP-6-0396"/></p></dd><dt><span class="term"><span class="strong"><strong>The resumption model</strong></span></span></dt><dd><p>Execution resumes where the exception was raised.<a class="indexterm" id="IDX-CHP-6-0397"/></p><p>The former model is easier to reason about, but it doesn't give ultimate control. It only allows <span class="emphasis"><em>error handling</em></span> (you can execute code when you notice an error), not <span class="emphasis"><em>fault rectification</em></span> (a chance to fix the problem and try again).</p></dd></dl></div><p>An exception cannot be ignored. If it isn't caught and handled, it will propagate to the very top of the call stack and will usually stop the program dead in its tracks. The language run time automatically cleans up as it unwinds the call stack. This makes exceptions a tidier and safer alternative to handcrafted error-handling code. However, throwing exceptions through sloppy code can lead to memory leaks and problems with resource cleanup.<sup>[<a class="footnote" href="#ftn.CHP-6-FN-2" id="CHP-6-FN-2">2</a>]</sup> You must take care to write <span class="emphasis"><em>exception-safe</em></span> code. The sidebar explains what this means in more detail.</p><div class="sidebar"><a id="whistle-stop_tour_of_exception_safety"/><p class="title"><b>WHISTLE-STOP TOUR OF EXCEPTION SAFETY</b></p><p>Resilient code must be <span class="emphasis"><em>exception safe</em></span>. It must work correctly (for some definition of <span class="emphasis"><em>correctly</em></span>, which we'll investigate below), no matter what exceptions come its way. This is true regardless of whether or not the code catches any exceptions itself.</p><p><span class="emphasis"><em>Exception-neutral</em></span> code propagates all exceptions up to the caller; it won't consume or change anything. This is an important concept for generic programs like C++ template code—the template types may generate all sorts of exceptions that template implementors don't understand.<a class="indexterm" id="IDX-CHP-6-0398"/></p><p>There are several different levels of exception safety. They are described in terms of guarantees to the calling code. These guarantees are:<a class="indexterm" id="IDX-CHP-6-0399"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Basic guarantee</strong></span></span></dt><dd><p>If exceptions occur in a function (resulting from an operation you perform or the call of another function), it will not leak resources. The code state will be <span class="emphasis"><em>consistent</em></span> (i.e., it can still be used correctly), but it will not necessarily leave in a known state. For example: A member function should add 10 items to a container, but an exception propagates through it. The container is still usable; maybe no objects were inserted, maybe all 10 were, or perhaps every other object was added.</p></dd><dt><span class="term"><span class="strong"><strong>Strong guarantee</strong></span></span></dt><dd><p>This is far more strict than the basic guarantee. If an exception propagates through your code, the program state remains completely unchanged. No object is altered, no global variables changed, nothing. In the example above, nothing was inserted into the container.<a class="indexterm" id="IDX-CHP-6-0400"/><a class="indexterm" id="IDX-CHP-6-0401"/></p></dd><dt><span class="term"><span class="strong"><strong>Nothrow guarantee</strong></span></span></dt><dd><p>The final guarantee is the most restrictive: that an operation can <span class="emphasis"><em>never</em></span> throw an exception. If we are exception neutral, then this implies the function cannot do anything else that might throw an exception.</p><p>Which guarantee you provide is entirely your choice. The more restrictive the guarantee, the more widely (re)usable the code is. In order to implement the strong guarantee, you will generally need a number of functions providing the nothrow guarantee.<a class="indexterm" id="IDX-CHP-6-0402"/><a class="indexterm" id="IDX-CHP-6-0403"/></p><p>Most notably, every destructor you write <span class="emphasis"><em>must</em></span> honor the nothrow guarantee.<sup>[<a class="footnote" href="#ftn.CHP-6-FN-3" id="CHP-6-FN-3">3</a>]</sup> Otherwise, all exception handling bets are off. In the presence of an exception, object destructors are called automatically as the stack is unwound. Raising an exception while handling an exception is not permissible.</p></dd></dl></div></div><p>The code that handles an exception is distinct from the code that raises it, and it may be arbitrarily far away. Exceptions are usually provided by OO languages, where errors are defined by a hierarchy of exception classes. A handler can elect to catch a quite specific class of error (by accepting a leaf class) or a more general category of error (by accepting a base class). Exceptions are particularly useful for signaling errors in a constructor.</p><p>Exceptions don't come for free; the language support incurs a performance penalty. In practice, this isn't significant and only manifests around exception-handling statements—exception handlers reduce the compiler's optimization opportunities. This doesn't mean that exceptions are flawed; their expense is justified compared to the cost of not doing any error handling!</p></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="signals"/>Signals</h2></div></div></div><p>Signals are a more extreme reporting mechanism, largely used for errors sent by the execution environment to the running program. The operating system traps a number of exceptional events, like a <span class="emphasis"><em>floating point exception</em></span> triggered by the maths coprocessor. These well-defined error events are delivered to the application in signals that interrupt the program's normal flow of execution, jumping into a nominated <span class="emphasis"><em>signal handler</em></span> function. Your program could receive a signal at any time, and the code must be able to cope with this. When the signal handler completes, program execution continues at the point it was interrupted.<a class="indexterm" id="IDX-CHP-6-0404"/><a class="indexterm" id="IDX-CHP-6-0405"/><a class="indexterm" id="IDX-CHP-6-0406"/><a class="indexterm" id="IDX-CHP-6-0407"/></p><p>Signals are the software equivalent of a hardware interrupt. They are a Unix concept, now provided on most platforms (a basic version is part of the ISO C standard [ISO99]). The operating system provides sensible default handlers for each signal, some of which do nothing, others of which abort the program with a neat error message. You can override these with your own handler.</p><p>The defined C signal events include program termination, execution suspend/continue requests, and math errors. Some environments extend the basic list with many more events.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-1" id="ftn.CHP-6-FN-1">1</a>] </sup>If you used an <code class="literal">unsigned int</code> then the number of values available would increase by a power of two, reusing the <code class="literal">signed int</code>'s sign bit.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-2" id="ftn.CHP-6-FN-2">2</a>] </sup>For example, you could allocate a block of memory and then exit early as an exception propagates through. The allocated memory would leak. This kind of problem makes writing code in the face of exceptions a complex business.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-3" id="ftn.CHP-6-FN-3">3</a>] </sup>That's the case in C++ and Java, at least. C# stupidly called ~X() a destructor, even though it was a finalizer in disguise. Throwing an exception in a C# destructor has different implications.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="detecting_errors"/>Detecting Errors</h1></div></div></div><p>How you detect an error obviously depends on the mechanism reporting it. In practical terms, this means:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Return values</strong></span></span></dt><dd><p>You determine whether a function failed by looking at its return code. This failure test is bound tightly to the act of calling the function; by making the call, you are implicitly checking its success. Whether or not you do anything with that information is up to you.</p></dd><dt><span class="term"><span class="strong"><strong>Error status variables</strong></span></span></dt><dd><p>After calling a function, you must inspect the error status variable. If it follows C's <code class="literal">errno</code> model of operation, you don't actually need to test for errors after every single function call. First reset <code class="literal">errno</code>, and then call any number of standard library functions back-to-back. Afterward, inspect <code class="literal">errno</code>. If it contains an error value, then one of those functions failed. Of course, you don't know what fell over, but if you don't care, then this is a streamlined error-detection approach.<a class="indexterm" id="IDX-CHP-6-0410"/><a class="indexterm" id="IDX-CHP-6-0408"/><a class="indexterm" id="IDX-CHP-6-0409"/></p></dd><dt><span class="term"><span class="strong"><strong>Exceptions</strong></span></span></dt><dd><p>If an exception propagates out of a subordinate function, you can choose to catch and handle it or to ignore it and let the exception flow up a level. You can only make an informed choice when you know what kinds of exceptions might be thrown. You'll only know this if it has been documented (and if you trust the documentation).<a class="indexterm" id="IDX-CHP-6-0411"/><a class="indexterm" id="IDX-CHP-6-0412"/></p><p>Java's exception implementation places this documentation in the code itself. The programmer has to write an <span class="emphasis"><em>exception specification</em></span> for every method, describing what it can throw; it is a part of the function's signature. Java is the only mainstream language to enforce this approach. You cannot leak an exception that isn't in the list, because the compiler performs static checking to prevent it.<sup>[<a class="footnote" href="#ftn.CHP-6-FN-4" id="CHP-6-FN-4">4</a>]</sup></p></dd><dt><span class="term"><span class="strong"><strong>Signals</strong></span></span></dt><dd><p>There's only one way to detect a signal: Install a hander for it. There's no obligation. You can also choose not to install any signal handlers at all and accept the default behavior.</p><p>As various pieces of code converge in a large system, you will probably need to detect errors in more than one way, even within a single function. Whichever detection mechanism you use, the key point is this:</p></dd></dl></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Never ignore</em></span> any <span class="emphasis"><em>errors that might be reported to you. If an error report channel exists, it's there for a reason</em></span>.</p></dd></dl></div><p>It is good practice to always write error-detection scaffolding—even if an error has no implication for the rest of your code. This makes it clear to a maintenance programmer that you know a function may fail and have consciously chosen to ignore any failures.</p><p>When you let an exception propagate through your code, you are not ignoring it—you <span class="emphasis"><em>can't</em></span> ignore an exception. You are allowing it to be handled by a higher level. The philosophy of exception handling is quite different in this respect. It's less clear what the most appropriate way to document this is—should you write a <code class="literal">try</code>/<code class="literal">catch</code> block that simply re<code class="literal">throw</code>s the exception, should you write a comment claiming that the code <span class="emphasis"><em>is</em></span> exception safe, or should you do nothing? I'd favor documenting the exception behavior.<a class="indexterm" id="IDX-CHP-6-0414"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-4" id="ftn.CHP-6-FN-4">4</a>] </sup>C++ also supports exception specifications, but leaves their use optional. It's idiomatic to avoid them—for performance reasons, among others. Unlike Java, they are enforced at run time.<a class="indexterm" id="IDX-CHP-6-0413"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="handling_errors"/>Handling Errors</h1></div></div></div><div class="epigraph"><p>Love truth, and pardon error.<a class="indexterm" id="IDX-CHP-6-0415"/><a class="indexterm" id="IDX-CHP-6-0416"/></p><div class="attribution"><span>--<span class="attribution">Voltaire</span></span></div></div><p>Errors happen. We've seen how to discover them and when to do so. The question now is: What do you do about them? This is the hard part. The answer largely depends on circumstance and the gravity of an error—whether it's possible to rectify the problem and retry the operation or to carry on regardless. Often there is no such luxury; the error may even herald the beginning of the end. The best you can do is clean up and exit sharply, before anything else goes wrong.</p><p>To make this kind of decision, you must be informed. You need to know a few key pieces of information about the error:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Where it came from</strong></span></span></dt><dd><p>This is quite distinct from where it's going to be handled. Is the source a core system component or a peripheral module? This information may be encoded in the error report; if not, you can figure it out manually.</p></dd><dt><span class="term"><span class="strong"><strong>What you were trying to do</strong></span></span></dt><dd><p>What provoked the error? This may give a clue toward any remedial action. Error reporting seldom contains this kind of information, but you can figure out which function was called from the context.</p></dd><dt><span class="term"><span class="strong"><strong>Why it went wrong</strong></span></span></dt><dd><p>What is the nature of the problem? You need to know exactly what happened, not just a general <span class="emphasis"><em>class</em></span> of error. How much of the erroneous operation completed? <span class="emphasis"><em>All</em></span> or <span class="emphasis"><em>none</em></span> are nice answers, but generally, the program will be in some indeterminate state between the two.</p></dd><dt><span class="term"><span class="strong"><strong>When it happened</strong></span></span></dt><dd><p>This is the locality of the error in time. Has the system only just failed, or is a problem two hours old finally being felt?</p></dd><dt><span class="term"><span class="strong"><strong>The severity of the error</strong></span></span></dt><dd><p>Some problems are more serious than others, but when detected, one error is equivalent to another—you can't continue without understanding and managing the problem. Error severity is usually determined by the caller, based on how easy it will be to recover or work around the error.</p></dd><dt><span class="term"><span class="strong"><strong>How to fix it</strong></span></span></dt><dd><p>This may be obvious (e.g., insert a floppy disk and retry) or not (e.g., you need to modify the function parameters so they are consistent). More often than not, you have to infer this knowledge from the other information you have.</p><p>Given this depth of information, you can formulate a strategy to handle each error. Forgetting to insert a handler for any potential error will lead to a bug, and it might turn out to be a bug that is hard to exercise and hard to track down—so think about every error condition carefully.</p></dd></dl></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="when_to_deal_with_errors"/>When to Deal with Errors</h2></div></div></div><p><span class="emphasis"><em>When</em></span> should you handle each error? This can be separate from when it's detected. There are two schools of thought.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>As soon as possible</strong></span></span></dt><dd><p>Handle each error <span class="emphasis"><em>as</em></span> you detect it. Since the error is handled near to its cause, you retain important contextual information, making the error-handling code clearer. This is a well-known self-documenting code technique. Managing each error near its source means that control passes through less code in an invalid state.</p><p>This is usually the best option for functions that return error codes.</p></dd><dt><span class="term"><span class="strong"><strong>As late as possible</strong></span></span></dt><dd><p>Alternatively, you could defer error handling for as long as possible. This recognizes that code detecting an error rarely knows what to do about it. It often depends on the context in which it is used: A missing file error may be reported to the user when loading a document but silently swallowed when hunting for a preferences file.</p><p>Exceptions are ideal for this; you can pass an exception through each level until you know how to deal with the error. This separation of detection and handling may be clearer, but it can make code more complex. It's not obvious that you are deliberately deferring error handling, and it's not clear where an error came from when you do finally handle it.</p><p>In theory, it's nice to separate "business logic" from error handling. But often you can't, as cleanup is necessarily entwined with that business logic, and it can be more tortuous to write the two separately. However, centralized error-handling code has advantages: You know where to look for it, and you can put the abort/continue policy in one place rather than scatter it through many functions.</p></dd></dl></div><p>Thomas Jefferson once declared, "Delay is preferable to error." There is truth there; the actual <span class="emphasis"><em>existence</em></span> of error handling is far more important than <span class="emphasis"><em>when</em></span> an error is handled. Nevertheless, choose a compromise that's close enough to prevent obscure and out-of-context error handling, while being far enough away to not cloud normal code with roundabout paths and error handling dead ends.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Handle each error in the most appropriate context, as soon as you know enough about it to deal with it correctly</em></span>.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="possible_reactions"/>Possible Reactions</h2></div></div></div><p>You've caught an error. You're poised to handle it. What are you going to do now? Hopefully, whatever is required for correct program operation. While we can't list every recovery technique under the sun, here are the common reactions to consider.<a class="indexterm" id="IDX-CHP-6-0417"/><a class="indexterm" id="IDX-CHP-6-0418"/><a class="indexterm" id="IDX-CHP-6-0419"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Logging</strong></span></span></dt><dd><p>Any reasonably large project should already be employing a logging facility. It allows you to collect important trace information, and is an entry point for the investigation of nasty problems.<a class="indexterm" id="IDX-CHP-6-0420"/><a class="indexterm" id="IDX-CHP-6-0421"/></p><p>The log exists to record interesting events in the life of the program, to allow you to delve into its inner workings and reconstruct paths of execution. For this reason, all errors you encounter should be detailed in the program log; they are some of the most interesting and telling events of all. Aim to capture all pertinent information—as much of the previous list as you can.<a class="indexterm" id="IDX-CHP-6-0422"/></p><p>For really obscure errors that predict catastrophic disaster, it may be a good idea to get the program to "phone home"—to transmit either a snapshot of itself or a copy of the error log to the developers for further investigation.</p><p>What you do <span class="emphasis"><em>after</em></span> logging is another matter.</p></dd><dt><span class="term"><span class="strong"><strong>Reporting</strong></span></span></dt><dd><p>A program should only report an error to the user when there's nothing left to do. The user does not need to be bombarded by a thousand small nuggets of useless information or badgered by a raft of pointless questions. Save the interaction for when it's really vital. Don't report when you encounter a recoverable situation. By all means, log the event, but keep quiet about it. Provide a mechanism that enables users to read the event log if you think one day they might care.</p><p>There <span class="emphasis"><em>are</em></span> some problems that only the user can fix. For these, it is good practice to report the problem immediately, in order to allow the user the best chance to resolve the situation or else decide how to continue.</p><p>Of course, this kind of reporting depends on whether or not the program is interactive. Deeply embedded systems are expected to cope on their own; it's hard to pop up a dialog box on a washing machine.<a class="indexterm" id="IDX-CHP-6-0423"/></p></dd><dt><span class="term"><span class="strong"><strong>Recovery</strong></span></span></dt><dd><p>Sometimes your only course of action is to stop immediately. But not all errors spell doom. If your program saves a file, one day the disk will fill up, and the save operation will fail. The user expects your program to continue happily, so be prepared.</p><p>If your code encounters an error and doesn't know what to do about it, pass the error upward. It's more than likely your caller will have the ability to recover.</p></dd><dt><span class="term"><span class="strong"><strong>Ignore</strong></span></span></dt><dd><p>I only include this for completeness. Hopefully by now you've learned to scorn the very suggestion of ignoring an error. If you choose to forget all about handling it and to just continue with your fingers crossed, <span class="emphasis"><em>good luck</em></span>. This is where most of the bugs in any software package will come from. Ignoring an error whose occurrence may cause the system to misbehave inevitably leads to hours of debugging.</p><p>You can, however, write code that allows you to <span class="emphasis"><em>do nothing</em></span> when an error crops up. Is that a blatant contradiction? No. It is possible to write code that copes with an inconsistent world, that can carry on correctly in the face of an error—but it often gets quite convoluted. If you adopt this approach, you must make it obvious in the code. Don't risk having it misinterpreted as ignorant and incorrect.</p></dd></dl></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Ignoring errors does not save time. You'll spend far longer working out the cause of bad program behavior than you ever would have spent writing the error handler</em></span>.</p></dd></dl></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Propagate</strong></span></span></dt><dd><p>When a subordinate function call fails, you probably can't carry on, but you might not know what else to do. The only option is to clean up and propagate the error report upward. You have options. There are two ways to propagate an error:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Export the same error information you were fed (return the same reason code or propagate exceptions).</p></li><li class="listitem"><p>Reinterpret the information, sending a more meaningful message to the next level up (return a different reason code or catch and wrap up exceptions).</p></li></ul></div><p>Ask yourself this question: Does the error relate to a concept exposed through the module interface? If so, it's okay to propagate that same error. Otherwise, recast it in the appropriate light, choosing an error report that makes sense in the context of your module's interface. This is a good self-documenting code technique.</p></dd></dl></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="code_implications"/>Code Implications</h2></div></div></div><p><span class="emphasis"><em>Show me the code!</em></span> Let's spend some time investigating the implications of error handling in our code. As we'll see, it is not easy to write good error handling that doesn't twist and warp the underlying program logic.<a class="indexterm" id="IDX-CHP-6-0424"/><a class="indexterm" id="IDX-CHP-6-0425"/><a class="indexterm" id="IDX-CHP-6-0426"/><a class="indexterm" id="IDX-CHP-6-0427"/><a class="indexterm" id="IDX-CHP-6-0428"/><a class="indexterm" id="IDX-CHP-6-0429"/><a class="indexterm" id="IDX-CHP-6-0430"/></p><p>The first piece of code we'll look at is a common error handling structure. Yet it isn't a particularly intelligent approach for writing error-tolerant code. The aim is to call three functions sequentially—each of which may fail—and perform some intermediate calculations along the way. Spot the problems with this:</p><a id="I_programlisting6_d1e8293"/><pre class="programlisting">
void nastyErrorHandling()
{
    if (operationOne())
    {
        ... do something ...
        if (operationTwo())
        {
            ... do something else ...
            if (operationThree())
            {
                ... do more ...
            }
        }
    }
}
</pre><p>Syntactically it's fine; the code will work. Practically, it's an unpleasant style to maintain. The more operations you need to perform, the more deeply nested the code gets and the harder it is to read. This kind of error handling quickly leads to a rat's nest of conditional statements. It doesn't reflect the actions of the code very well; each intermediate calculation could be considered the same level of importance, yet they are nested at different levels.</p><div class="sidebar"><a id="crafting_error_messages"/><p class="title"><b>CRAFTING ERROR MESSAGES</b></p><p>Inevitably, your code will encounter errors that the user must sort out. Human intervention may be the only option; your code can't insert a floppy disk or switch on the printer by itself. (If it can, you'll make a fortune!)</p><p>If you're going to whine at the user, there are a few general points to bear in mind:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Users don't think like programmers, so present information the way <span class="emphasis"><em>they'd expect</em></span>. When displaying the free space on a disk, you might report <code class="literal">Disk space: 10K</code>. But if there's no space left, a zero could be misread as OK—and the user will not be able to fathom why he can't save a file when the program says everything's fine.</p></li><li class="listitem"><p>Make sure your messages aren't too cryptic. You might understand them, but can your computer-illiterate granny? (It doesn't matter if your granny won't use this program—someone with a lower intellect almost certainly will.)</p></li><li class="listitem"><p>Don't present meaningless error codes. No user knows what to do when faced with an <code class="literal">Error code 707E</code>. It is, however, valuable to provide such codes as "additional info"—they can be quoted to tech support or looked up more easily on a web search.</p></li><li class="listitem"><p>Distinguish dire errors from mere warnings. Incorporate this information in the message text (perhaps with an <code class="literal">Error</code>: prefix), and emphasize it in message boxes with an accompanying icon.</p></li><li class="listitem"><p>Only ask a question (even a simple one like <span class="emphasis"><em>Continue: Yes/No?</em></span>) if the user fully understands the ramifications of each choice. Explain it if necessary, and make it clear what the consequence of each answer is.</p></li></ul></div><p>What you present to the user will be determined by interface constraints and application or OS style guides. If your company has user interface engineers, then it's their job to make these decisions. Work with them.</p></div><p>Can we avoid these problems? Yes—there are a few alternatives. The first variant flattens the nesting. It is semantically equivalent, but it introduces <span class="emphasis"><em>some</em></span> new complexity, since flow control is now dependent on the value of a new status variable, <code class="literal">ok</code>:</p><a id="I_programlisting6_d1e8345"/><pre class="programlisting">
void flattenedErrorHandling()
{
    bool ok = operationOne();
    if (ok)
    {
        ... do something ...
        ok = operationTwo();
    }
    if (ok)
    {
        ... do something else ...
        ok = operationThree();
    }
    if (ok)
    {
        ... do more ...
    }
    if (!ok)
    {
        ... clean up after errors ...
    }
}
</pre><p>We've also added an opportunity to clean up after any errors. Is that sufficient to mop up all failures? Probably not; the necessary cleanup may depend on how far we got through the function before lightening struck. There are two cleanup approaches:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Perform a little cleanup after each operation that may fail, then return early. This inevitably leads to duplication of cleanup code. The more work you've done, the more you have to clean up, so each exit point will need to do gradually more unpicking.</p><p>If each operation in our example allocates some memory, each early-exit point will have to release all allocations made to date. The further in, the more releases. That will lead to some quite dense and repetitive error-handling code, which makes the function far larger and far harder to understand.</p></li><li class="listitem"><p>Write the cleanup code once, at the end of the function, but write it in such a way as to only clean up what's dirty. This is neater, but if you inadvertently insert an early return in the middle of the function, the cleanup code will be bypassed.</p></li></ul></div><p>If you're not overly concerned about writing <span class="emphasis"><em>Single Entry, Single Exit (SESE)</em></span> functions, this next example removes the reliance on a separate control flow variable.<sup>[<a class="footnote" href="#ftn.CHP-6-FN-5" id="CHP-6-FN-5">5</a>]</sup> We do lose the cleanup code again, though. Simplicity renders this a better description of the actual intent:</p><a id="I_programlisting6_d1e8379"/><pre class="programlisting">
void shortCircuitErrorHandling()
{
    if (!operationOne()) return;
    ... do something ...
    if (!operationTwo()) return;
    ... do something else ...
    if (!operationThree()) return;
    ... do more ...
}
</pre><p>A combination of this short-circuit exit with the requirement for cleanup leads to the following approach, especially seen in low-level systems code. Some people advocate it as the <span class="emphasis"><em>only</em></span> valid use for the maligned <code class="literal">goto</code>. I'm still not convinced.</p><a id="I_programlisting6_d1e8389"/><pre class="programlisting">
void gotoHell()
{
    if (!operationOne()) goto error;
    ... do something ...
    if (!operationTwo()) goto error;
    ... do something else ...
    if (!operationThree()) goto error;
    ... do more ...
    return;
error:
    ... clean up after errors ...
}
</pre><p>You can avoid such monstrous code in C++ using <span class="emphasis"><em>Resource Acquisition Is Initialization (RAII)</em></span> techniques like smart pointers. (Stroustrup 97) This has the bonus of providing exception safety—when an exception terminates your function prematurely, resources are automatically deallocated. These techniques avoid a lot of the problems we've seen above, moving complexity to a separate flow of control.<a class="indexterm" id="IDX-CHP-6-0432"/><a class="indexterm" id="IDX-CHP-6-0433"/><a class="indexterm" id="IDX-CHP-6-0434"/><a class="indexterm" id="IDX-CHP-6-0435"/><a class="indexterm" id="IDX-CHP-6-0436"/></p><p>The same example using exceptions would look like this (in C++, Java, and C#), presuming that all subordinate functions do not return error codes but instead throw exceptions:<a class="indexterm" id="IDX-CHP-6-0437"/></p><a id="I_programlisting6_d1e8418"/><pre class="programlisting">
void exceptionalHandling()
{
    try
    {
        operationOne();
        ... do something ...
        operationTwo();
        ... do something else ...
        operationThree();
        ... do more ...
    }
    catch (...)
    {
        ... clean up after errors ...
    }
}
</pre><p>This is only a basic exception example, but it shows just how neat exceptions can be. A sound code design might not need the <code class="literal">try</code>/<code class="literal">catch</code> block at all if it ensures that no resource is leaked and leaves error handling to a higher level. But alas, writing good code in the face of exceptions requires an understanding of principles beyond the scope of this chapter.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-5" id="ftn.CHP-6-FN-5">5</a>] </sup>Although this clearly isn't SESE, I contend that the previous example isn't, either. There <span class="emphasis"><em>is</em></span> only one exit point, at the end, but the contrived control flow is simulating early exit—it <span class="emphasis"><em>might as well</em></span> have multiple exits. This is a good example of how being bound by a rule like SESE can lead to bad code, unless you think carefully about what you're doing.<a class="indexterm" id="IDX-CHP-6-0431"/></p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="raising_hell"/>Raising Hell</h1></div></div></div><p>We've put up with other people's errors for long enough. It's time to turn the tables and play the bad guy: Let's raise some errors. When writing a function, erroneous things will happen that you'll need to signal to your caller. Make sure you do—don't silently swallow any failure. Even if you're sure that the caller won't know what to do in the face of the problem, it <span class="emphasis"><em>must</em></span> remain informed. Don't write code that lies and pretends to be doing something it's not.<a class="indexterm" id="IDX-CHP-6-0438"/></p><p>Which reporting mechanism should you use? It's largely an architectural choice; obey the project conventions and the common language idioms. In languages with the facility, it is common to favor exceptions, but only use them if the rest of the project does. Java and C# really leave you with no choice; exceptions are buried deep in their execution run times. A C++ architecture may choose to forego this facility to achieve portability with platforms that have no exception support or to interface with older C code.<a class="indexterm" id="IDX-CHP-6-0439"/><a class="indexterm" id="IDX-CHP-6-0440"/><a class="indexterm" id="IDX-CHP-6-0441"/><a class="indexterm" id="IDX-CHP-6-0442"/></p><p>We've already seen strategies for propagating errors from subordinate function calls. Our main concern here is reporting fresh problems encountered during execution. How you determine these errors is your own business, but when reporting them, consider the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Have you cleaned up appropriately first? Reliable code doesn't leak resources or leave the world in an inconsistent state, even when an error occurs, unless it's <span class="emphasis"><em>really</em></span> unavoidable. If you do either of these things, it must be documented carefully. Consider what will happen the next time your code is called if this error has manifested. Ensure it will still work.</p></li><li class="listitem"><p>Don't leak inappropriate information to the outside world in your error reports. Only return useful information that the caller understands and can act on.</p></li><li class="listitem"><p>Use exceptions correctly. Don't throw an exception for unusual return values—the rare but not erroneous cases. Only use exceptions to signal circumstances where a function is not able to meet its contract. Don't use them non-idiomatically (i.e., for flow control).</p></li><li class="listitem"><p>Consider using assertions (see "<a class="xref" href="ch01s04.html#constraints" title="Constraints">Constraints</a>" on page 16) if you're trapping an error that should never happen in the normal course of program execution, a genuine programming error. Exceptions are a valid choice for this too—some assertion mechanisms can be configured to throw exceptions when they trigger.<a class="indexterm" id="IDX-CHP-6-0443"/></p></li><li class="listitem"><p>If you can pull forward any tests to compile time, then do so. The sooner you detect and rectify an error, the less hassle it can cause.</p></li><li class="listitem"><p>Make it hard for people to ignore your errors. Given half a chance, someone <span class="emphasis"><em>will</em></span> use your code badly. Exceptions are good for this—you have to act deliberately to hide an exception.</p></li></ul></div><p>What kind of errors should you be looking out for? This obviously depends on what the function is doing. Here's a checklist of the general kinds of error checks you should make in each function:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Check all function parameters. Ensure you have been given correct and consistent input. Consider using assertions for this, depending on how strictly your contract was written. (Is it an offense to supply bad parameters?)</p></li><li class="listitem"><p>Check that invariants are satisfied at interesting points in execution.<a class="indexterm" id="IDX-CHP-6-0444"/></p></li><li class="listitem"><p>Check all values from external sources for validity before you use them. File contents and interactive input must be sensible, with no missing pieces.</p></li><li class="listitem"><p>Check the return status of all system and other subordinate function calls.</p></li></ul></div><div class="sidebar"><a id="an_exception_to_the_rule"/><p class="title"><b>AN EXCEPTION TO THE RULE</b></p><p>Exceptions are a powerful error reporting mechanism. Used well, they can simplify your code greatly while helping you to write robust software. In the wrong hands, though, they are a deadly weapon.</p><p>I once worked on a project where it was routine for programmers to break a <code class="literal">while</code> loop or end recursion by throwing an exception, using it as a non-local <code class="literal">goto</code>. It's an intersting idea, and kind of cute when you first see it. But this behavior is nothing more than an abuse of exceptions: It isn't what exceptions are idiomatically used for. More than one critical bug was caused by a maintenance programmer not understanding the flow of control through a complex, magically terminated loop.<a class="indexterm" id="IDX-CHP-6-0445"/></p><p>Follow the idioms of your language, and don't write cute code for the sake of it.</p></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="managing_errors"/>Managing Errors</h1></div></div></div><p>The common principle uniting the raising and handling of errors is to have a consistent strategy for dealing with failure, wherever it manifests. These are general considerations for managing the occurrence, detection, and handling of program errors:<a class="indexterm" id="IDX-CHP-6-0446"/><a class="indexterm" id="IDX-CHP-6-0447"/><a class="indexterm" id="IDX-CHP-6-0448"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Avoid things that <span class="emphasis"><em>could</em></span> cause errors. Can you do something that is guaranteed to work, instead? For example, avoid allocation errors by reserving enough resource beforehand. With an assured pool of memory, your routine cannot suffer memory restrictions. Naturally, this will only work when you know how much resource you need up front, but you often do.</p></li><li class="listitem"><p>Define the program or routine's expected behavior under abnormal circumstances. This determines how robust the code needs to be and therefore how thorough your error handling should be. Can a function silently generate bad output, subscribing to the historic <span class="emphasis"><em>GIGO</em></span> principle?<sup>[<a class="footnote" href="#ftn.CHP-6-FN-6" id="CHP-6-FN-6">6</a>]</sup></p></li><li class="listitem"><p>Clearly define which components are responsible for handling which errors. Make it explicit in the module's interface. Ensure that your client knows what will always work and what may one day fail.<a class="indexterm" id="IDX-CHP-6-0449"/></p></li><li class="listitem"><p>Check your programming practice: <span class="emphasis"><em>When</em></span> do you write error-handling code? Don't put it off until later; you'll forget to handle something. Don't wait until your development testing highlights problems before writing handlers—that's not an engineering approach.</p></li></ul></div><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>KEY CONCEPT</strong></span></span></dt><dd><p><span class="emphasis"><em>Write all error detection and handling</em></span> now, <span class="emphasis"><em>as you write the code that may fail. Don't put it off until later. If you must be evil and defer handling, at least write the detection scaffolding now</em></span>.</p></dd></dl></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When trapping an error, have you found a symptom or a cause? Consider whether you've discovered the source of a problem that needs to be rectified here or if you've discovered a symptom of an earlier problem. If it's the latter, then don't write reams of handling code here, put that in a more appropriate (earlier) error handler.</p></li></ul></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-6" id="ftn.CHP-6-FN-6">6</a>] </sup>That is, <span class="emphasis"><em>Garbage In, Garbage Out</em></span>—feed it trash, and it will happily spit out trash.</p></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="in_a_nutshell-id5"/>In a Nutshell</h1></div></div></div><div class="epigraph"><p>To err is human; to repent, divine; to persist, devilish.<a class="indexterm" id="IDX-CHP-6-0450"/></p><div class="attribution"><span>--<span class="attribution">Benjamin Franklin</span></span></div></div><p>To err <span class="emphasis"><em>is</em></span> human (but computers seem quite good at it, too). To handle these errors is divine.</p><p>Every line of code you write must be balanced by appropriate and thorough error checking and handling. A program without rigorous error handling will not be stable. One day an obscure error may occur, and the program will fall over as a result.</p><p>Handling errors and failure cases is hard work. It bogs programming down in the mundane details of the Real World. However, it's absolutely essential. As much as 90 percent of the code you write handles exceptional circumstances. (Bentley 82) That's a surprising statistic, so write code <span class="emphasis"><em>expecting</em></span> to put far more effort into the things that can go wrong than the things that will go right.</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Good programmers . . .</p></th><th style="text-align: left" valign="bottom"><p>Bad programmers . . .</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Combine their good intentions with good coding practices</p></li><li class="listitem"><p>Write the error-handling code <span class="emphasis"><em>as</em></span> they write the main code</p></li><li class="listitem"><p>Are <span class="emphasis"><em>thorough</em></span> in the code they write, covering every error possibility</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Take a haphazard approach to writing code, with neither thought to nor review of what they're doing</p></li><li class="listitem"><p>Ignore the errors that arise as they write code</p></li><li class="listitem"><p>End up conducting lengthy debugging sessions to track down program crashes, because they never considered error conditions in the first place</p></li></ul></div>
</td></tr></tbody></table></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="see_also-id5"/>See Also</h1></div></div></div><div class="variablelist"><dl><dt><span class="term"><a class="xref" href="ch01.html" title="Chapter 1. ON THE DEFENSIVE">Chapter 1</a></span></dt><dd><p>Handing errors in context is one of the many defensive programming techniques.<a class="indexterm" id="IDX-CHP-6-0451"/><a class="indexterm" id="IDX-CHP-6-0452"/></p></dd><dt><span class="term"><a class="xref" href="ch04.html" title="Chapter 4. THE WRITESTUFF">Chapter 4</a></span></dt><dd><p>Self-documenting code ensures that error handling is integral to the code narrative.</p></dd><dt><span class="term"><a class="xref" href="ch09.html" title="Chapter 9. FINDING FAULT">Chapter 9</a></span></dt><dd><p>Unhandled error conditions will manifest as bugs in the code. Here's how to squash them. (It's best to avoid them in the first place, though.)</p></dd></dl></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e8694"/><img alt="See Also" src="tagoreillycom20080909nostarchimages207460.png.jpg"/></div></div></div>
<div class="sect1" xml:lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="get_thinking-id6"/>Get Thinking</h1></div></div></div><p>A detailed discussion of these questions can be found in the "<a class="xref" href="apa.html" title="Appendix A. Answers and Discussion">Appendix A</a>" section on page 487.</p><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="mull_it_over-id5"/>Mull It Over</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Are <span class="emphasis"><em>return values</em></span> and <span class="emphasis"><em>exceptions</em></span> equivalent error reporting mechanisms? Prove it.<a class="indexterm" id="IDX-CHP-6-0453"/><a class="indexterm" id="IDX-CHP-6-0454"/><a class="indexterm" id="IDX-CHP-6-0455"/><a class="indexterm" id="IDX-CHP-6-0456"/></p></li><li class="listitem"><p>What different implementations of <span class="emphasis"><em>tuple</em></span> return types can you think of ? Don't limit yourself to a single programming language. What are the pros and cons of using tuples as a return value?</p></li><li class="listitem"><p>How do exception implementations differ between languages?</p></li><li class="listitem"><p>Signals are an old-school Unix mechanism. Are they still needed now that we have modern techniques like exceptions?</p></li><li class="listitem"><p>What is the best code structure for error handling?</p></li><li class="listitem"><p>How should you handle errors that occur in your error-handling code?</p></li></ol></div></div><div class="sect2" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="getting_personal-id5"/>Getting Personal</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>How thorough is the error handling in your current codebase? How does this contribute to the stability of the program?<a class="indexterm" id="IDX-CHP-6-0457"/><a class="indexterm" id="IDX-CHP-6-0458"/></p></li><li class="listitem"><p>Do you naturally consider error handling as you write code, or do you find it a distraction, preferring to come back to it later?</p></li><li class="listitem"><p>Go to the last (reasonably sized) function you wrote or worked on, and perform a careful review of the code. Find every abnormal occurence and potential error situation. How many of these were actually handled in your code?</p><p>Now get someone else to review it. Don't be shy! Did they find any more? Why? What does this tell you about the code you're working on?</p></li><li class="listitem"><p>Do you find it easier to manage and reason about error conditions using <span class="emphasis"><em>return values</em></span> or <span class="emphasis"><em>exceptions</em></span>? Are you sure you know what is involved in writing exception-safe code?</p></li></ol></div></div></div></body></html>