- en: Chapter 8. DATA FORMATS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Working with maps usually means interacting with a lot of geographic data. Along
    with descriptive information, you need to know where a place is so you can plot
    it on your map. Chances are good that most of the time you'll need to get data
    from someone else. You might also need to share your data with someone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several standard formats have been adopted to make passing around geographic
    data even easier. In this chapter, I''ll go over a few ways to share the basic
    pieces of geography you''d put on a map: points, lines, and shapes.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll also go over a couple formats that are popular on the web for exchanging
    information. More and more, your sources will be websites that make their data
    available with an API. In most cases, the format you'll need is covered in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started and learn some data formats.
  prefs: []
  type: TYPE_NORMAL
- en: '#52: Use XML'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Extensible Markup Language (XML)* is the building block of much of the
    Web's data and of several other formats discussed in this chapter. It looks a
    lot like HTML, because some HTML actually *is* XML. This section will stay away
    from specific flavors of XML, however, as I'll be covering some in their own sections.
    Here, I'll focus on how to recognize and use generic XML.
  prefs: []
  type: TYPE_NORMAL
- en: First, what does it look like? XML is made up of tags, which are words inside
    pointed greater-than and less-than brackets, `<` and `>`. Understanding what the
    words inside the brackets stand for is usually easy, but sometimes they are abbreviations
    or acronyms. Tags can contain other tags, as well as *`key`*`=`*`value`* pairs,
    which are called *attributes*. Tags containing other tags or text end with a matching
    closing tag that includes a `/` before the tag name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this short example XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: XML files usually start off in a similar way, with a processing instruction
    declaring it as XML ❶ and providing version and encoding information. This special
    tag does not have a corresponding end tag. With this header out of the way, we
    get straight to the data.
  prefs: []
  type: TYPE_NORMAL
- en: The root element ❷ can be named anything, but you can only have one. For example,
    HTML only has one `<html>` tag. Within the starting and ending root tags comes
    the real XML content. In this case, the XML has two child elements. Again, the
    tags can be named anything, but I've used names that help describe XML terms in
    this example.
  prefs: []
  type: TYPE_NORMAL
- en: XML is hierarchical, and accessing the data requires understanding its structure.
    The first child element has a single attribute ❸ and a child element ❹ of its
    own. The second child element also has an attribute, but it contains no children.
    When this is the case, we can abbreviate the closing tag ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Now we want to get at this data inside the XML. Reading in the tags and converting
    them to a structure the computer can understand is called *parsing*. Most languages
    have some built-in way to parse XML. Next I'll show two JavaScript examples and
    one using PHP, a server-side programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Parse XML with JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every modern browser comes with a way to read in XML content, which makes sense
    seeing as so much of the Web is built upon the technology. Unfortunately, the
    various browsers have their differences. Also, getting at deeply nested elements
    can be a pain.
  prefs: []
  type: TYPE_NORMAL
- en: Before showing an easier way, we'll give it a go in this section using the XML
    example just described. Rather than loading in an XML file (which I'll get to
    in the next section), we'll use XML that is stored as a string of text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are using JavaScript, the file needs to live inside a web page.
    Everything we''ll be doing will be in the JavaScript portion, so the web page
    will otherwise be blank. Add these lines into a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The bold lines are the ones that get at the data. Everything else is pure setup.
    To be fair, getting the XML text ready ❶ does take seven lines. We could reduce
    this to a single line, but I've expanded it for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the XML requires a multistep approach. First, we need to try the Internet
    Explorer way ❷. This method will fail if we are using another browser. Then, we
    get to the use the more widely adopted method ❸. Hopefully this one works, because
    if it doesn't, we can't parse the XML.
  prefs: []
  type: TYPE_NORMAL
- en: The `x` variable should contain an XML object after those two tries. This variable
    is used by the bold section to extract the names of the children. First, we look
    through the XML for all the child tags ❹. Then, we loop through all of those tags
    ❺. We can tell which step we're on by the `i` variable, which starts at zero and
    counts up each step. Each time through the loop, we add the name of the current
    child to the text we will output ❻.
  prefs: []
  type: TYPE_NORMAL
- en: If you load this file into a web browser, you should see a JavaScript alert
    with the names "first" and "second." You've successfully parsed XML with plain
    ol' JavaScript. Now let's check out how you parse it with the JavaScript library
    jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: Parse XML with jQuery JavaScript Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The single principle behind jQuery is to write less code. The hard work is left
    to the library, which itself is very small (currently less than 20K). When it
    comes to fetching and parsing XML, jQuery keeps things predictably simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the plain JavaScript example, we''ll be parsing the XML in an otherwise
    empty HTML file. However, in this case, we''ll load our XML straight from a file,
    which is a common situation. Make sure you have a file named *example.xml* containing
    the XML from earlier, and then add these lines to a new file in the same directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you'll notice is that we need to load the jQuery JavaScript
    file ❶. You can download it to your own server from [http://jquery.com/](http://jquery.com/)
    or reference a version hosted by Google, as I did in this example. In either case,
    we get access to the library's many features, which include using Ajax to load
    files with JavaScript and parsing XML.
  prefs: []
  type: TYPE_NORMAL
- en: The jQuery library makes use of many techniques to decrease the amount of JavaScript
    you need to write. Among them is the *dollar sign object*, which allows you to
    access much of jQuery's functionality with very simple syntax. For example, loading
    an XML file is accomplished by calling the `$.get` function ❷.
  prefs: []
  type: TYPE_NORMAL
- en: To implement an Ajax call without jQuery requires trying different methods depending
    on the browser, much like our XML parsing example in the previous section. Instead,
    jQuery does the work to ensure we can get at the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading the XML also shows an example of another technique for decreasing code:
    inline, *anonymous functions*. These functions are part of the standard JavaScript
    language but become especially useful with the way jQuery simplifies code. When
    performing an Ajax call, such as the one we use to load our XML file, JavaScript
    needs a callback function. Rather than creating a named function just to receive
    the XML results, we can write one inline ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the anonymous function (so named because it doesn't have a name), we
    use another jQuery shorthand to parse the XML. The parsing happens so fast, you
    might not even realize it's happening. The dollar sign function is passed the
    tag name we want, along with the XML variable that holds the content we got back
    from the Ajax call ❹. Then we chain the jQuery `each` function to the result,
    and we can loop through all the child elements ❺. We don't have to use an explicit
    `for` loop, nor do we need to determine the number of children. That happens within
    jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: What we do each time through the jQuery loop is determined by another anonymous
    function. Again, we just keep everything inline because having a named function
    for one line of code doesn't make sense. Of course, the code is only one line
    because we're using jQuery. The `this` variable holds the current child element,
    and then we use the same `getAttribute` function we used in the non-jQuery example
    to grab the name attribute ❻.
  prefs: []
  type: TYPE_NORMAL
- en: In about half the lines as the previous example, we achieved the same result.
    If you load the file in your web browser, a JavaScript alert will print the names
    of the child tags, "first" and "second." jQuery makes it easy to do the stuff
    you'll do often as you work with APIs and parse data formats, many of which use
    XML.
  prefs: []
  type: TYPE_NORMAL
- en: Parse XML with PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many cases, you'll want to retrieve XML on your server. To do this, you won't
    use JavaScript, because you usually write JavaScript inside a web browser; you'll
    use PHP. PHP is a popular programming language for coding server-side applications.
    For more about PHP and making sure you have it available on your server, be sure
    to read [Chapter 9](ch09.html "Chapter 9. GO SERVER-SIDE").
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s parse the example XML from the previous sections using PHP. Make sure
    you have a file named *example.xml* on your server. Create a new PHP file in the
    same directory and add these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is load our example XML file into the `$xmltxt` variable
    ❶. In many cases, we'll actually be loading the XML from an API. Either way, the
    XML content ends up in a variable, ready to be parsed.
  prefs: []
  type: TYPE_NORMAL
- en: We pass the work of going through the XML to PHP's `SimpleXML` class, which
    is included automatically in PHP 5\. The `simplexml_load_string` function converts
    the textual XML into a useful object ❷ for accessing the data inside the XML.
    A `simplexml_load_file` function is also available, but again, most of the time
    you'll be converting a string that you retrieved from an API.
  prefs: []
  type: TYPE_NORMAL
- en: Once the XML is in object form, we can look for the name attribute within the
    child elements. We need to loop through all the child elements ❸, placing the
    current child inside its own object. Then, we get the attributes ❹ and find the
    one called name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to query the XML will make more sense if you see what the object that
    PHP creates looks like. Use `print_r($xmlobj)` to see a textual representation
    of the hierarchical object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First of all, everything is inside a single `SimpleXMLElement` object, just
    as all the XML is within the root tag. Additional `SimpleXMLElement` objects are
    included as well, which is similar to having tags within tags. The SimpleXML class
    essentially converts XML into a series of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, a numerical array of all the child elements ❶ is created. In this
    case, only two child elements are included, numbered 0 and 1, because, as with
    JavaScript, array indexes in PHP start at zero. Each child has an attributes array
    ❷, which is associative, meaning it ctontains key and value pairs. The key is
    the attribute name, in this case `name`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if tags within the tag exist, they're listed. In this case, the second
    child tag contains a grandchild tag ❸. This tag contains only text, so it's represented
    as a key and value pair, too. If it contained tags or attributes underneath it,
    we'd have yet another `SimpleXMLElement`. Again, the `SimpleXML` class is all
    about finding a way to represent XML inside a PHP object.
  prefs: []
  type: TYPE_NORMAL
- en: Even Simpler XML with XPath
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Traversing the `SimpleXML` object works fine in basic cases where the XML file
    is short and does not include a deep nesting of tags within tags. If you are swamped
    with XML content, you might find querying with XPath simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Like XML, XPath is a web standard. You can use XPath to traverse down through
    the XML to the data you want. All you need to do is call the `xpath` function
    on the `SimpleXML` object and tell it the "path" you want to access.
  prefs: []
  type: TYPE_NORMAL
- en: All three of the following examples find the same element, the grandchild tag,
    which is nested within two levels of hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the full path to the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Or prepend a double slash to get every grandchild tag, regardless of what tags
    surround it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Or mix and match. Here, we grab any grandchild tag that exists below a child
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: XPath can help you quickly access XML in even more ways, such as querying for
    specific values, but I won't cover them here. You can find out more about XPath
    and `SimpleXML`, in general, at [http://php.net/simplexml](http://php.net/simplexml).
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve shown you several methods for accessing XML: JavaScript, the jQuery library,
    and PHP. What you use depends on where you''re getting your XML, how complicated
    the XML is, and what languages you''re already using.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you may grow weary of parsing XML and porting it to your JavaScript
    maps. Many programmers prefer working directly with a format called JSON that
    is closer to true JavaScript. Read on to learn about that format, and see [#57:
    Convert from XML to JSON](ch08s06.html "#57: Convert from XML to JSON") in [#57:
    Convert from XML to JSON](ch08s06.html "#57: Convert from XML to JSON") to learn
    about turning XML into the easier-to-use JSON.'
  prefs: []
  type: TYPE_NORMAL
- en: '#53: Use JSON'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With JavaScript's ever-increasing popularity on the Web, JSON is quickly becoming
    the preferred data format for developers. That's because JSON stands for *JavaScript
    Object Notation* and almost no parsing is necessary to use it in JavaScript. Plus,
    JSON takes fewer characters than XML to express the same data because it has no
    closing tags
  prefs: []
  type: TYPE_NORMAL
- en: You aren't restricted to any one language. You can parse JSON in many server-side
    programming languages. I'll give an example using PHP later. Most modern languages
    have a data structure that makes converting JSON easy. This, along with JavaScript's
    popularity, have made this format widely used for interchanging data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough about JSON''s usefulness: Let''s see an example of what JSON looks like.
    The following shows how the XML in the previous project might be expressed in
    JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This basic example is a bit more complex than it needs to be, but it showcases
    many of the ways data can be organized in JSON. The building blocks are a series
    of key and value pairs inside braces, a structure called an object in JavaScript.
    The fun comes with the definition of a value.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, our main object ❶ has only one key, `child`. The value is an
    array, declared by the brackets. An array can itself contain a list of values.
    In this case, the values are yet more objects.
  prefs: []
  type: TYPE_NORMAL
- en: The first object in the array ❷ contains a single key, `attributes`, and yet
    another object within it. Finally, the new object, which is three levels deep
    now, contains a key `name` and value of `first`. The second object in the array
    ❸ has a similar first key-value pair and then a second key, `grandchild`, which
    has a textual value.
  prefs: []
  type: TYPE_NORMAL
- en: So, a value can be an array, another object, or plain text. It could also be
    a number, a boolean, or a null, though I haven't shown that in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Are you confused by the circular definition of what makes a value? That complication
    is intentional, but it actually ends up being an easy way to express many types
    of data. Because an object can contain arrays, objects, or even arrays of other
    objects, many types of hierarchical data can be expressed with JSON in a very
    small amount of space.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of how JSON looks, let's start using it.
  prefs: []
  type: TYPE_NORMAL
- en: Parse JSON with JavaScript and jQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember what JSON stands for? JavaScript Object Notation. This data format
    was not only made *for* JavaScript but also made *from* it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are hard-coding JSON into JavaScript, you don''t need to do anything
    to use the data inside it. It is ready to go as written. Here, we access the first
    child in the example JSON using JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I added the portion of the code in bold. Otherwise, this code is the exact JSON
    from earlier. All I did was assign it to a variable (`obj`), end the declaration
    with a semicolon (`;`), and then alert a specific value from the object.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, JSON is not likely to be written directly into JavaScript. Instead,
    you'll probably receive it as output from an API. In other words, you might have
    JSON in text form.
  prefs: []
  type: TYPE_NORMAL
- en: If you trust the data, you can use the JavaScript `eval` function to convert
    JSON from text to object. Ensuring you have good data is a smart idea, however,
    because `eval` will execute any JavaScript text, not just text in the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid potentially large security issues, the `parseJSON` function has been
    added in some browsers. But this function is only really useful if it works in
    every browser. You can use a JavaScript file available at [http://json.org/](http://json.org/)
    to fill the gaps while waiting for every browser to support the latest JavaScript
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is use the jQuery JavaScript library, which has an easy way to
    fetch data with Ajax. In fact, you can retrieve and parse JSON within a single
    line of jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these lines to a new HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To access the many useful jQuery functions, we need to include the jQuery JavaScript
    file ❶. Although you can download this file to your server from [http://jquery.com/](http://jquery.com/),
    you can also reference a Google-hosted version, as I've done here.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery does much of the difficult work for you and makes writing very short
    JavaScript that performs advanced functions possible. One of its more apparent
    ways of reducing code is to introduce the dollar sign object. Much of what happens
    in jQuery goes through `$`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we use the `$.getJSON` jQuery function to create an Ajax call to
    download and parse a JSON file. The most important information we need to provide
    is the JSON URL ❷. This URL can be a local file or a call to an external API.
  prefs: []
  type: TYPE_NORMAL
- en: Next, jQuery requires a function reference. In this case, we use an inline,
    anonymous function ❸ to describe what we want to do with the JSON result. Again,
    jQuery is about reducing code, but understanding what is happening here is still
    important. Ajax fetches our JSON, which is then parsed into an object. That object
    is returned to the anonymous function, where we can do whatever we want with it.
    In this case, I create an alert ❹ with the first child's name, just as I did when
    the data was hard-coded.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are calling an external API that returns JSON, for security reasons,
    that API will need to accept a callback function name. To see an example of this
    in action, check out how I retrieve JSON from Yahoo! Pipes in [#69: Create a Weather
    Map](ch10s02.html "#69: Create a Weather Map") in [#69: Create a Weather Map](ch10s02.html
    "#69: Create a Weather Map").'
  prefs: []
  type: TYPE_NORMAL
- en: Building on top of jQuery can save you time and allow you to focus on higher-level
    issues with your mapping projects. You also get an added layer of complexity because
    you have one more piece of JavaScript to include in your HTML. Hopefully its benefits
    make up for this minor cost in loading time.
  prefs: []
  type: TYPE_NORMAL
- en: Parse JSON with PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you just need the data on the server. If the data is in JSON format,
    you won't be able to use JavaScript because it's almost always written inside
    a web browser. Most languages can easily read JSON though, so you'll find it's
    a reasonable format to use on a server, as well as on a client.
  prefs: []
  type: TYPE_NORMAL
- en: I'll use PHP again as an example server-side programming language because of
    its availability on most web hosts. If you're new to PHP, I provide an introduction
    to using PHP for geo projects in [Chapter 9](ch09.html "Chapter 9. GO SERVER-SIDE").
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this project, I said that most languages have a JSON-like
    data structure. The JavaScript object, with its key-value pairs, is represented
    as an associative array in PHP. Similarly, PHP also has standard arrays, in addition
    to strings of text and numbers. In other words, all the pieces are here to represent
    JSON fully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some sample PHP that declares the exact same data I used in the sample
    JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know representing JSON in PHP is possible, how do we go about parsing
    from text to associative array? Beginning with PHP 5, you can parse JSON with
    a single call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example accessing the name of the first child, with the JSON text
    hard-coded. Yours will likely come from an API, or possibly a file, instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Yes, all the work is passed off for the internal PHP function ❶ to perform.
    Instead of using associative arrays, as we did previously, `json_decode` uses
    a PHP object. This object is slightly different but has a similar way of expressing
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The keys, such as `child` ❷, are instance variables of the object and are referenced
    with the `->` arrow. All other types of data, including regular arrays, go through
    as-is. Just as with all other examples, the name of the first child can be found
    three levels down.
  prefs: []
  type: TYPE_NORMAL
- en: The curious reader might be wondering if another function exists to create JSON
    text from PHP data structures. Of course! The opposite of `json_decode` is `json_encode`.
    You could pass the `$obj` variable from the first example or the `$jobj` variable
    from the second example, and the result would be identical to the JSON text stored
    in the `$jtxt` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will likely need to decode JSON more often than encode it. That said, you''ll
    be glad that function exists when you need it. For an example of encoding JSON,
    check out [#71: Search Music Events by Location](ch10s04.html "#71: Search Music
    Events by Location") in [#71: Search Music Events by Location](ch10s04.html "#71:
    Search Music Events by Location").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Though my most recent examples have used PHP, JSON is a rising star of data
    formats because it incorporates so easily with JavaScript—JSON essentially *is*
    JavaScript. Now that you know how to read in JSON data securely, you may find
    yourself on the lookout for APIs that use the format. JSON makes moving on from
    data parsing easy, so you can do what you really want to do: create awesome, data-filled
    web maps.'
  prefs: []
  type: TYPE_NORMAL
- en: '#54: Use GeoRSS'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Location is only one tiny piece of information being pushed around the Web.
    A list of points is much more useful if you include context for what they mean.
    GeoRSS is a way to add location and other geographic information to content feeds,
    creating geo-tagged content.
  prefs: []
  type: TYPE_NORMAL
- en: The content itself is commonly blog posts or photos, though it can be anything.
    Blogs are prime candidates for geo-tagging because most are already syndicated
    with an RSS feed, a way to get the latest posts without visiting the website.
  prefs: []
  type: TYPE_NORMAL
- en: Although named after RSS, GeoRSS can be used inside formats other than RSS.
    For example, the United States Geological Survey publishes an Atom feed of recent
    earthquakes, including the location and depth of each quake. GeoRSS can be added
    to any XML feed to attach geographic data to other content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of GeoRSS inside an RSS feed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '``Most of the text is standard RSS. The bold sections are the GeoRSS hooks
    that add location data to the feed. At the top, you need to include the GeoRSS
    namespace, which allows you to use the `georss:` prefix for tags.``'
  prefs: []
  type: TYPE_NORMAL
- en: '`In this example, we''ve declared a point, which is a geographic coordinate.
    Inside the tag, we put the latitude first, followed by a space, and then the longitude.
    Sometimes you may see a comma between the numbers. Both are permissible.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`GeoRSS has several ways to declare shapes, as well. These shapes are made
    up of multiple points and often represent a route, border, or other boundary.
    GeoRSS refers to them as lines, polygons, and boxes.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Lines and polygons are both declared as a sequence of latitude and longitude
    points:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`As in this example, a line is at least two coordinates, but it can be many
    more. In this way, a line could describe a route.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A polygon is declared similarly, but the final point must be the same as the
    first point. In other words, a polygon is a circular route. It could, for example,
    be used to describe the outside walls of a house or the border of a country.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`A box, on the other hand, will always create a rectangular shape and is declared
    with only two coordinates:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '``If you''re confused, that''s okay. A rectangle has four corners, so shouldn''t
    a box have four coordinates? It''s just like Mapstraction''s `BoundingBox`, covered
    in [#19: Draw a Rectangle to Declare an Area](ch04s04.html "#19: Draw a Rectangle
    to Declare an Area") in [#19: Draw a Rectangle to Declare an Area](ch04s04.html
    "#19: Draw a Rectangle to Declare an Area"). GeoRSS uses only two corners to determine
    the box''s location. The minimum data you need is the southwest and northeast
    corners. From those two points, you can extrapolate the northwest and southeast
    points.``'
  prefs: []
  type: TYPE_NORMAL
- en: '`Now that you are a little familiar with GeoRSS, let''s use it in a different
    type of feed. Here is an example of GeoRSS inside the Atom format:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`` `Atom is an alternative to RSS and is a widely supported format. As you
    can see, for our purposes, it is very similar to RSS. Again, the GeoRSS portions
    are bold.` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `You will see GeoRSS most often in RSS and Atom formats. The examples I''ve
    shown, however, are the simple version of GeoRSS. The format sometimes looks a
    bit different, yet it is still GeoRSS. Read on for some examples of alternate
    GeoRSS encodings.` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `Use Alternate GeoRSS Encodings` ``'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`` `The GeoRSS demonstrated in the previous section is sufficient for most
    needs and is likely the most common encoding you''ll run across. Understanding
    its shortcomings and recognizing other ways of representing location data is important,
    however.` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `*GML* is the *Geography Markup Language* and is a superset of GeoRSS. GML
    was created to express any form of geographic information, including topology
    and coordinate systems other than the latitude/longitude system we''ve been using
    (called WGS84).` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `To make your GeoRSS compatible with GML, you need additional tags. For
    example, the single tag required to declare a point becomes three tags:` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`` `Whenever you write XML that includes tags with a colon in the name, you''ll
    need to make sure the word before the colon (the namespace) is declared at the
    top of your XML. Because this example uses both GeoRSS and GML, we need to include
    both namespaces:` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`` `The two forms of GeoRSS shown so far are the most likely encoding methods
    you''ll run into with new data feeds. An old version is still in somewhat wide
    use, however.` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `The Basic Geo Vocabulary is an encoding developed by the Worldwide Web
    Consortium (W3C), an organization that watches over the development of HTML and
    CSS, among other standards. The development of GeoRSS made the W3C''s geo-tags
    obsolete, but you''ll run into them often enough to need to recognize them.` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`` `Display GeoRSS on a Map` ``'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`` `Mapstraction makes adding GeoRSS to your map easy. Through a single function,
    you can layer the GeoRSS without having to parse the XML yourself.` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `To display GeoRSS, all you need is a publicly accessible feed and a map
    on which to display it. Toss these lines into a new HTML file to see GeoRSS in
    action:` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`` `Load the previous HTML into your browser, and you should see the GeoRSS
    content on your map. If you''re using my example, you''ll see routes across several
    Portland bridges, plus markers that identify landmarks.` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `Now you''re a little more familiar with the GeoRSS format and its trio
    of encodings. In this section, I''ve shown how they can be used in RSS and Atom,
    the two most popular web feed formats. Also, you''ve learned how, in one line
    of Mapstraction code, to layer your GeoRSS feed on your map. To see an example
    of digging into GeoRSS, read [#70: Display Recent Earthquakes Worldwide](ch10s03.html
    "#70: Display Recent Earthquakes Worldwide") in [#70: Display Recent Earthquakes
    Worldwide](ch10s03.html "#70: Display Recent Earthquakes Worldwide").` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
