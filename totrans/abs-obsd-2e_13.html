<html><head></head><body><section class="chapter" epub:type="chapter" id="software_management" title="Chapter&#xA0;13.&#xA0;Software Management"><div class="titlepage"><div><div><h2 class="title">Chapter 13. Software Management</h2></div></div></div><div class="epigraph" epub:type="epigraph"><div class="literallayout"><p><span class="emphasis"><em>Blowfish is solid,</em></span><br/>
<span class="emphasis"><em>but the third-party software?</em></span><br/>
<span class="emphasis"><em>Easy road to ruin.</em></span></p></div></div><p><a class="indexterm" id="idx2184"/><span class="inlinemediaobject"><a id="inline_id00014"/><img alt="" src="httpatomoreillycomsourcenostarchimages1616079.png"/></span> Most people don’t use an operating system; they use software, which runs atop an underlying operating system. No matter how robust an operating system is, it’s useless without applications.</p><p>Many commercial operating systems include hundreds or thousands of small programs: games, desktop toys, and everything from fancy-looking clocks to disk scrubbers and web browsers. Most users never touch most of these programs, but the programs take up disk space (and possibly other resources) just the same. Every program drags along some amount of infrastructure, and all of this software can cause any number of problems.</p><p>Unlike many other operating systems, OpenBSD deliberately includes relatively little software in the default installation. You get exactly what you need to provide the infrastructure for software, and nothing more. While a traditional UNIX or Unix-like system includes compilers, games, and man pages, you don’t even need to install these when installing OpenBSD! Even if you install everything included in OpenBSD, it will have far less software than any commercial operating system. That’s because almost everything is considered an add-on package.</p><p><a class="indexterm" id="idx1293"/><a class="indexterm" id="idx1295"/><a class="indexterm" id="idx1300"/><a class="indexterm" id="idx2183"/><a class="indexterm" id="idx2186"/><a class="indexterm" id="idx2194"/>The advantage to this sparseness is that you know exactly what’s on the system, which simplifies debugging. A random shared library from a program you’ve never used won’t break your programs. The downside is that you need to think a bit to decide exactly what you do want to include, and you’ll need to install those programs. OpenBSD makes installing software as easy as possible through the ports and packages system, which is introduced in this chapter. But first, let’s take a look at building software.</p><div class="sect1" title="Making Software"><div class="titlepage"><div><div><h2 class="title" id="making_software" style="clear: both">Making Software</h2></div></div></div><p>Building software is complicated because source code must be very specifically processed to create a program that works—let alone a program that works well! The <code class="literal">make(1)</code> program makes building software easily reproducible, so that a program can be built exactly as the software author intends. <code class="literal">make</code> takes its instructions from a configuration file, or <span class="emphasis"><em>makefile</em></span>, which tells <code class="literal">make</code> exactly how to build a program from source. You don’t need to know the internals of a makefile, so we’re not going to dissect one here.</p><p>A makefile includes one or more targets and a set of instructions to carry out. For example, typing <code class="literal">make install</code> tells <code class="literal">make</code> to check the makefile for a procedure called <code class="literal">install</code> and, if found, to execute it. A target’s name usually relates to what <code class="literal">make</code> should be doing. The <code class="literal">make install</code> process, for example, usually installs the software built by previous steps. You’ll find targets to install, configure, and uninstall most software, and <code class="literal">make</code> handles a huge variety of functions, some of which far outstrip the creators’ original intentions.</p></div><div class="sect1" title="Source Code and Software"><div class="titlepage"><div><div><h2 class="title" id="source_code_and_software" style="clear: both">Source Code and Software</h2></div></div></div><p>Source code is the human-readable instructions for building the actual machine code that makes up a program. You’ve probably already been exposed to some form of source code; if not, go look at a few files under <span class="emphasis"><em>/usr/src</em></span> (assuming, of course, that you installed the source code as I recommended back in <a class="xref" href="ch03.html" title="Chapter 3. Installation Walk-Through">Chapter 3</a>). While you don’t have to read source code, you should be able to recognize it.</p><p>Once you have a program’s source code, you build (or compile) the program on the type of system on which you want to run it. (Building software for a foreign platform via cross-compiling demands that you know much more about building software, and is not always possible.) If the software was written for an operating system sufficiently similar to what you’re building it on, you’ll create a working program. If the operating system differs too much, either the build fails or the resulting software won’t run. Once you’ve built the software successfully on your system, you can copy the resulting program (or <span class="emphasis"><em>binary</em></span>) to other systems on the same platform, with the same operating system version and supporting software, and expect it to run.</p><p><a class="indexterm" id="idx0061"/><a class="indexterm" id="idx1659"/><a class="indexterm" id="idx1835"/>Some programs are sufficiently well written that you can compile them on many different platforms. A few programs specifically include support for widely divergent platforms. For example, you can compile the Apache web server on Windows, NetWare, and Unix-like platforms by typing <code class="literal">make install</code>. This is quite uncommon, however, and takes considerable effort on the part of the software authors. It also makes the code more complex, and supporting all these operating systems means that it cannot easily support all the features that make those operating systems special. (But note that the ability to <span class="emphasis"><em>build</em></span> software on a variety of platforms doesn’t necessarily mean that it <span class="emphasis"><em>runs</em></span> well on all of those platforms.)</p><p>Generally speaking, if you can build a program from source, it usually runs. A sufficiently experienced sysadmin can use the source code and error messages to learn why a program won’t build, or why it builds but doesn’t run. In many cases, the problem is simple and can be fixed with minimal education.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id453650" id="id453650">34</a>]</sup> This is one reason why access to source code is important.</p><p>Back when every sysadmin was a programmer, debugging software builds absorbed major portions of the sysadmin’s time. Every Unix-like platform was slightly (or wildly) different. To build programs, sysadmins needed to understand their platform, the software’s original platform, and the differences between the two. The duplication of effort to build common programs was truly horrendous. Tools such as <code class="literal">autoconf</code> and <code class="literal">configure</code> were intended to help simplify this problem, but these programs just paper over the underlying problems. Building many software packages requires much more time running <code class="literal">configure</code> scripts than they need to actually compile.</p><p>The OpenBSD ports and packages system removes all this pain.</p></div><div class="sect1" title="The Ports and Packages System"><div class="titlepage"><div><div><h2 class="title" id="the_ports_and_packages_system" style="clear: both">The Ports and Packages System</h2></div></div></div><p><span class="emphasis"><em>Ports</em></span> are a mechanism for reproducibly and consistently building software on OpenBSD. <span class="emphasis"><em>Packages</em></span> are precompiled ports for a specific OpenBSD version and platform. Packages install quickly and easily, and are recommended by the OpenBSD folks. Installing from a port takes more time and effort, but can be customized for your environment or server.</p><p>The basic idea behind the ports system is that if source code must be modified or tweaked to build or run on OpenBSD, the modification process should be automated. If you need other software to build this program from source code or run it, those dependencies should be automatically used. If you record exactly which files the software installs, you can easily uninstall it. And if you have all of these things, you can pick up the software and install it on any similar OpenBSD system.</p><p><a class="indexterm" id="idx1566"/><a class="indexterm" id="idx1660"/><a class="indexterm" id="idx1802"/><a class="indexterm" id="idx1810"/>Packages are the installable files produced by the ports system. You can install packages over the network, either from your own package repository or from an OpenBSD mirror site. But before you can use a package, you must find it.</p></div><div class="sect1" title="Using Packages"><div class="titlepage"><div><div><h2 class="title" id="using_packages" style="clear: both">Using Packages</h2></div></div></div><p>Packages are the preferred method to install OpenBSD software. Packages are built by the OpenBSD Project’s ports team, and are expected to work without any special tweaks from the user. You must configure the software, of course, but the software itself should work as expected. Unless you are planning to make modifications to a specific piece of software, you’ll be a lot happier simply installing the package fetched from a nearby mirror rather than building it from the port (or, worse, installing from the source code without the port).</p><div class="sect2" title="Package Files and $PKG_PATH"><div class="titlepage"><div><div><h3 class="title" id="package_files_and_pkg_path">Package Files and $PKG_PATH</h3></div></div></div><p>Every package is available as a single file named after the port it is found in, a version number, and a <span class="emphasis"><em>.tgz</em></span> extension. For example, version 2.4.2 of the <code class="literal">adsuck</code> software is available in the file <span class="emphasis"><em>adsuck-2.4.2.tgz</em></span>.</p><p>Before you can install packages, you need to find a source for them. Find package files on the official release CDs or on OpenBSD mirror sites.</p><p>The packages are on the FTP and HTTP mirrors in the directory <span class="emphasis"><em>/pub/OpenBSD/</em></span>release<span class="emphasis"><em>/packages/</em></span>platform. For example, the packages for the amd64 platform for OpenBSD 5.3 are in the directory <span class="emphasis"><em>/pub/OpenBSD/5.3/packages/amd64</em></span>. Look at the OpenBSD mirror list. Choose a mirror server near you, and verify that it actually has the <span class="emphasis"><em>packages</em></span> directory for the release and platform you run. My closest mirror is <span class="emphasis"><em><a class="ulink" href="http://ftp10.usa.openbsd.org" target="_top">http://ftp10.usa.openbsd.org</a></em></span>.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id366676" id="id366676">35</a>]</sup> I find the 5.3 amd64 packages at <span class="emphasis"><em><a class="ulink" href="http://ftp10.usa.openbsd.org/pub/OpenBSD/5.3/packages/amd64" target="_top">http://ftp10.usa.openbsd.org/pub/OpenBSD/5.3/packages/amd64</a></em></span>.</p><p>On the official CD, you’ll find packages in <span class="emphasis"><em>/</em></span>release<span class="emphasis"><em>/</em></span>platform<span class="emphasis"><em>/packages</em></span>. (Downloaded installation CDs do not include packages.) If you mounted the 5.3 CD at <span class="emphasis"><em>/mnt</em></span>, you would find the packages at <span class="emphasis"><em>/mnt/5.3/amd64/packages</em></span>.</p><p>Once you’ve chosen a package repository, set the <code class="literal">$PKG_PATH</code> variable in your shell to it. This tells OpenBSD’s package management tools where to get the packages and gives you quick access to a single authoritative source of packages.</p><p>If you set <code class="literal">$PKG_PATH</code> to an invalid location, <code class="literal">pkg_add</code> (the command for installing a package) won’t work. Using a location with packages for a different architecture makes <code class="literal">pkg_add</code> give an error that packages are “not for the right architecture.” If you choose an incorrect release, you’ll see “bad major” or other library version errors. Either of these types of errors mean that your <code class="literal">$PKG_PATH</code> is wrong.</p><p><a class="indexterm" id="idx1065"/><a class="indexterm" id="idx1539"/><a class="indexterm" id="idx1655"/><a class="indexterm" id="idx1656"/><a class="indexterm" id="idx1808"/><a class="indexterm" id="idx1884"/><a class="indexterm" id="idx2043"/><a class="indexterm" id="idx2044"/><a class="indexterm" id="idx2640"/>You can also list multiple package repositories. If the package tools don’t find a desired package in the first repository, they try the next one. This lets you use a local package repository for your custom packages, and then fall back to the official OpenBSD repository if you don’t have a local package. I use this when I must build a custom package for my network and want to use it across multiple machines.</p><p>Installing packages via FTP or HTTP is not quite as secure as installing them from CD. While the OpenBSD release team has verified all the packages on the CD set, an intruder could have tampered with whatever mirror you choose. These intrusions would be caught comparatively quickly, but it’s possible that you could install packages between the time of the intrusion and the time the damage is reversed. If you’re deeply concerned about package integrity, get an official CD set.</p></div><div class="sect2" title="Finding Packages"><div class="titlepage"><div><div><h3 class="title" id="finding_packages">Finding Packages</h3></div></div></div><p>As I write this, the latest OpenBSD/i386 snapshot has 7485 packages on the FTP site. This is a long list to browse through to find the specific package you want. If you have the ports tree installed, you can search it for packages, but if you wanted to use the ports tree, you wouldn’t be using packages, now would you?</p><p>Say you need a piece of software that runs only on Apache 2.2. How can you find this? Find packages on the command line, or use a website.</p><div class="note" title="Note"><h3 class="title"><a id="ch13note01"/>Note</h3><p>Most people don’t need an external web server on OpenBSD; the web servers included with OpenBSD are perfectly fine for average users. I would install Apache 2.2 only if I had a specific application written for Apache 2.2. If you want to run, say, a PHP web application, just use OpenBSD’s included <code class="literal">nginx</code> web server.</p></div><div class="sect3" title="Finding Packages on the Command Line"><div class="titlepage"><div><div><h4 class="title" id="finding_packages_on_the_command_line">Finding Packages on the Command Line</h4></div></div></div><p><code class="literal">pkg_info(1)</code> displays information about packages. While you would normally use <code class="literal">pkg_info</code> to explore the packages you’ve already installed, you can use <code class="literal">-Q</code> to run a case-insensitive search on the packages in your package repository. If you know part of the package name, try the package search.</p><a id="I_programlisting13_id464830"/><pre class="programlisting">$ <span class="strong"><strong>pkg_info -Q apache</strong></span>
apache-ant-1.8.2p3
apache-couchdb-1.0.1p2
apache-httpd-2.2.22
apachetop-0.12.6
modsecurity-apache-1.9.3p5
p5-Apache-ASP-2.61p0
…</pre><p>From the names, you can guess that the package <code class="literal">apache-httpd-2.2.22</code> contains Apache 2.2.</p></div><div class="sect3" title="Finding Packages on the Web"><div class="titlepage"><div><div><h4 class="title" id="finding_packages_on_the_web">Finding Packages on the Web</h4></div></div></div><p><a class="indexterm" id="idx1048"/><a class="indexterm" id="idx1073"/><a class="indexterm" id="idx1625"/><a class="indexterm" id="idx1657"/><a class="indexterm" id="idx1658"/><a class="indexterm" id="idx1662"/><a class="indexterm" id="idx1803"/><a class="indexterm" id="idx2045"/>The easiest way to search packages is to use the unofficial OpenBSD Ports website at <span class="emphasis"><em><a class="ulink" href="http://www.openports.se/" target="_top">http://www.openports.se/</a></em></span>. While this isn’t an official OpenBSD website, it has provided a good interface into the OpenBSD ports tree for several years. If I search for Apache on this site, the third hit is for “www/apache-httpd, apache HTTP server.”</p><p>Once you know the name of the package containing the software you want, you can install it.</p></div></div><div class="sect2" title="Installing Packages"><div class="titlepage"><div><div><h3 class="title" id="installing_packages">Installing Packages</h3></div></div></div><p>Use <code class="literal">pkg_add(1)</code> to install packages. You don’t need the version number—just the package name. Here, I install the Apache package I found earlier:</p><a id="I_programlisting13_id464958"/><pre class="programlisting">  # <span class="strong"><strong>pkg_add apache-httpd</strong></span>
<span class="strong"><strong>1</strong></span> apache-httpd-2.2.22:libiconv-1.14: ok
  apache-httpd-2.2.22:pcre-8.30: ok
  …
<span class="strong"><strong>2</strong></span> apache-httpd-2.2.22: ok
<span class="strong"><strong>3</strong></span> The following new rcscripts were installed: /etc/rc.d/httpd2
  See rc.d(8) for details.
<span class="strong"><strong>4</strong></span> --- +apache-httpd-2.2.22 -------------------
  This is the official httpd distributed by the Apache Server Project,
  provided as a port for those who, for various reasons, need to run
  version 2.
  OpenBSD provides a custom Apache server, httpd(8), in the base system
  which has been audited for security and may run in a chroot(2)
  environment. Users are STRONGLY encouraged to use the system httpd
  rather than this port.</pre><p>A great deal of software requires other software to run, and OpenBSD’s package tools track these <span class="emphasis"><em>dependencies</em></span>. <code class="literal">pkg_add</code> starts my Apache installation by installing the various dependencies of the chosen package, as shown at <span class="strong"><strong>1</strong></span>. Apache 2.2.22 requires <code class="literal">libiconv</code> and <code class="literal">pcre</code>, among several other packages. As each package installs, you’ll see a progress bar scroll across the screen. If a dependency cannot be installed, the package installation terminates.</p><p>After installing all the dependencies, <code class="literal">pkg_add</code> installs the actual Apache 2.2 package, as shown at <span class="strong"><strong>2</strong></span>. At the end of package installation, you’ll see notices for startup scripts added by the package, as shown at <span class="strong"><strong>3</strong></span>, and then any notes from the OpenBSD team about the packages, like those at <span class="strong"><strong>4</strong></span>.</p><div class="sect3" title="Which Files Are Installed?"><div class="titlepage"><div><div><h4 class="title" id="which_files_are_installed">Which Files Are Installed?</h4></div></div></div><p>Use the <code class="literal">-L</code> option to <code class="literal">pkg_info</code> to see which files a package installs.</p><a id="I_programlisting13_id465071"/><pre class="programlisting">$ <span class="strong"><strong>pkg_info -L apache-httpd</strong></span>
Information for inst:apache-httpd-2.2.22
Files:
/usr/local/include/apache2/ap_compat.h
/usr/local/include/apache2/ap_config.h
/usr/local/include/apache2/ap_config_auto.h
/usr/local/include/apache2/ap_config_layout.h
/usr/local/include/apache2/ap_listen.h
…</pre><p><a class="indexterm" id="idx1650"/><a class="indexterm" id="idx1806"/><a class="indexterm" id="idx2558"/><a class="indexterm" id="idx2592"/>As you can see, all of these files are installed under <span class="emphasis"><em>/usr/local</em></span>. OpenBSD installs all packages under <span class="emphasis"><em>/usr/local</em></span>.</p></div><div class="sect3" title="Verbose Installation"><div class="titlepage"><div><div><h4 class="title" id="verbose_installation">Verbose Installation</h4></div></div></div><p>If you’re interested in the details of how <code class="literal">pkg_add</code> works, use the <code class="literal">-v</code> flag to trigger verbose mode. You can specify multiple <code class="literal">-v</code> flags for added detail. I recommend trying verbose mode a few times, in varying levels of detail, to get a deeper understanding of what <code class="literal">pkg_add</code> actually does.</p></div><div class="sect3" title="Ambiguous Packages"><div class="titlepage"><div><div><h4 class="title" id="ambiguous_packages">Ambiguous Packages</h4></div></div></div><p>Sometimes <code class="literal">pkg_add</code> needs an extra hint about what you want to install. For example, everything in my production network is tied together with LDAP, and I need to run an OpenLDAP mirror in each datacenter. (I could use OpenBSD’s integrated LDAP daemon instead, but the master servers run OpenLDAP, and I don’t want to mix LDAP servers.) The following is my attempt to install OpenLDAP.</p><a id="I_programlisting13_id465184"/><pre class="programlisting">  # <span class="strong"><strong>pkg_add openldap-server</strong></span>
<span class="strong"><strong>1</strong></span> Ambiguous: choose package for openldap-server
  a       0: &lt;None&gt;
          1: openldap-server-2.3.43p10
          2: openldap-server-2.4.31p0
  Your choice: <span class="strong"><strong>2</strong></span>
<span class="strong"><strong>2</strong></span> Ambiguous: choose dependency for openldap-server-2.4.31p0:
  a       0: cyrus-sasl-2.1.25p3
          1: cyrus-sasl-2.1.25p3-db4
          2: cyrus-sasl-2.1.25p3-ldap
          3: cyrus-sasl-2.1.25p3-mysql
          4: cyrus-sasl-2.1.25p3-pgsql
          5: cyrus-sasl-2.1.25p3-sqlite3
  Your choice: <span class="strong"><strong>2</strong></span>
<span class="strong"><strong>3</strong></span> Detected loop, merging sets ok
  | cyrus-sasl-2.1.25p3-ldap
  | openldap-client-2.4.31
  openldap-server-2.4.31p0:cyrus-sasl-2.1.25p3-ldap+openldap-client-2.4.31: ok
  openldap-server-2.4.31p0:db-4.6.21v0: ok
  openldap-server-2.4.31p0:icu4c-49.1.2p1: ok
  openldap-server-2.4.31p0: ok
  The following new rcscripts were installed: /etc/rc.d/saslauthd /etc/rc.d/slapd
  See rc.d(8) for details.</pre><p><a class="indexterm" id="idx0404"/><a class="indexterm" id="idx0834"/><a class="indexterm" id="idx1651"/><a class="indexterm" id="idx2584"/>As you can see at <span class="strong"><strong>1</strong></span>, OpenBSD has two OpenLDAP server packages: recent releases of version 2.3 and version 2.4. I want version 2.4. The OpenBSD OpenLDAP package is compiled with Cyrus SASL (Simple Authentication and Security Layer), which in turn comes in six different flavors, as you can see at <span class="strong"><strong>2</strong></span>—one for each supported database. I choose the version that uses LDAP as its backend. (I don’t need this particular SASL; any SASL will suffice.)</p><p><code class="literal">pkg_add</code> realizes that this is something of a chicken-and-egg problem. LDAP is compiled using Cyrus, but Cyrus is compiled using LDAP. Fortunately, as you can see at <span class="strong"><strong>3</strong></span>, it knows that this is a permissible configuration. The dependencies are installed, and then the OpenLDAP server that I want is added.</p></div></div><div class="sect2" title="Identifying Where Files Originate"><div class="titlepage"><div><div><h3 class="title" id="identifying_where_files_originate">Identifying Where Files Originate</h3></div></div></div><p>As you’ve seen in earlier examples, many packages install other packages as dependencies. Once you’ve installed a few complicated software packages, <span class="emphasis"><em>/usr/local</em></span> starts to fill up with weird-looking files and programs. Eventually, you’ll wonder which packages are needed or where a package was installed from.</p><p>OpenBSD maintains records for every installed package in <span class="emphasis"><em>/var/db/pkg</em></span>, including files installed and dependency information, but wading through these files resembles effort, and I won’t do it. Also, many package names are obscure, opaque, obfuscated, or otherwise obtuse. (It’s not that the OpenBSD packages team tries to make package names incomprehensible, but there’s only so much it can do when the software has a name like <code class="literal">icu4c</code>.)</p><p>Thankfully, <code class="literal">pkg_info(1)</code> can easily answer most questions about your installed software. Start by getting a complete list of all software packages on the machine with the <code class="literal">-a</code> argument.</p><a id="I_programlisting13_id465347"/><pre class="programlisting">$ <span class="strong"><strong>pkg_info -a</strong></span>
cyrus-sasl-2.1.25p3-ldap RFC 2222 SASL (Simple Authentication and Security Layer)
db-4.6.21v0         Berkeley DB package, revision 4
icu4c-49.1.2p1      International Components for Unicode
openldap-client-2.4.31 Open source LDAP software (client)
openldap-server-2.4.31p0 Open source LDAP software (server)
quirks-1.73         exceptions to pkg_add rules
tcsh-6.18.01        extended C-shell with many useful features</pre><p>Hang on a minute! I’ve installed <code class="literal">tcsh</code>, of course, as my aged brain isn’t up to learning a new shell. I installed OpenLDAP, and chose to add <code class="literal">cyrus-SASL</code> as a dependency. Did <code class="literal">pkg_add</code> really install all of these other packages as dependencies? Or has one of my junior admins installed extra cruft? Do I really <span class="emphasis"><em>need</em></span> all of these packages, or do I just need to smack a minion?</p><p>OpenBSD records which software packages you’ve installed, versus those installed as dependencies. Use the <code class="literal">-m</code> flag to see only those packages you manually installed.</p><a id="I_programlisting13_id465389"/><pre class="programlisting"># <span class="strong"><strong>pkg_info -m</strong></span>
openldap-server-2.4.31p0 Open source LDAP software (server)
quirks-1.73         exceptions to pkg_add rules
tcsh-6.18.01        extended C-shell with many useful features</pre><p><a class="indexterm" id="idx1654"/><a class="indexterm" id="idx1809"/>This looks more familiar. Apparently everything else really is a dependency.</p><p>Now let’s look at some options. For longer descriptions of each package, add the <code class="literal">-d</code> flag or use the <code class="literal">-a</code> flag to show information for all packages. If you want to run <code class="literal">pkg_info</code> for a single package, use the package name as an argument. For example, <code class="literal">-L</code> shows the list of files a package installs. With the <code class="literal">-a</code> flag, it will show all files included in all installed packages, but that’s probably more than you want. To show all files installed by a package, use the <code class="literal">-L</code> flag and the package name.</p><a id="I_programlisting13_id465446"/><pre class="programlisting">$ <span class="strong"><strong>pkg_info -L tcsh</strong></span>
Information for inst:tcsh-6.18.01
Files:
/usr/local/bin/tcsh
/usr/local/man/man1/tcsh.1
/usr/local/share/nls/C/tcsh.cat
/usr/local/share/nls/de_AT.ISO_8859-1/tcsh.cat
/usr/local/share/nls/de_CH.ISO_8859-1/tcsh.cat
/usr/local/share/nls/de_DE.ISO_8859-1/tcsh.cat
…</pre><p>As you can see, the <code class="literal">tcsh(1)</code> package includes the actual <code class="literal">tcsh</code> binary, the man page, and a whole bunch of National Language Support (NLS) files. Given a package name, you can identify which files are part of the package.</p><p>Going the other way, sometimes you want to know where a particular file originated. For example, I occasionally browse my server filesystems looking for weird stuff. I define “weird stuff” as “things I don’t recognize.” If I see an unfamiliar program or file, I’ll check to see which package installed it.</p><a id="I_programlisting13_id465477"/><pre class="programlisting">$ <span class="strong"><strong>pkg_info -E /usr/local/sbin/pluginviewer</strong></span>
/usr/local/sbin/pluginviewer: cyrus-sasl-2.1.25p3-ldap
cyrus-sasl-2.1.25p3-ldap RFC 2222 SASL (Simple Authentication and Security Layer)</pre><p>The only <code class="literal">pluginviewer</code> I had previously encountered was one designed to help Unix web browsers run third-party software when a website demanded a plug-in. I don’t know what this <code class="literal">pluginviewer</code> does, but apparently it’s a legitimate part of <code class="literal">cyrus-SASL</code>. To find something to worry about, I need to keep looking.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id485212" id="id485212">36</a>]</sup> If you do many file searches like this, you can get faster results by using <code class="literal">pkglocatedb</code> (<span class="emphasis"><em>/usr/ports/databases/pkglocatedb</em></span>).</p><p><a class="indexterm" id="idx0405"/><a class="indexterm" id="idx1357"/><a class="indexterm" id="idx1652"/><a class="indexterm" id="idx1665"/><a class="indexterm" id="idx1807"/><a class="indexterm" id="idx2489"/><a class="indexterm" id="idx2501"/>After installation, many packages show a message, which I frequently read and promptly forget. To display this information again, use <code class="literal">pkg_info</code> with the <code class="literal">-M</code> flag.</p><a id="I_programlisting13_id465588"/><pre class="programlisting">$ <span class="strong"><strong>pkg_info -M apache-httpd</strong></span>
Information for inst:apache-httpd-2.2.22
Install notice:
This is the official httpd distributed by the Apache Server Project,
…</pre><p>If you don’t remember which package had the message you wanted, use the <code class="literal">-a</code> flag instead of a package name to display the messages for all packages that have one. To show all packages that are not required by other packages, use the <code class="literal">-t</code> flag, which you might think matches all packages you chose to install. If you didn’t request a package, it could only be installed as a dependency to something you requested, right?</p><a id="I_programlisting13_id465612"/><pre class="programlisting">$ <span class="strong"><strong>pkg_info -t</strong></span>
apache-httpd-2.2.22 apache HTTP server
icu4c-49.1.2p1      International Components for Unicode
quirks-1.73         exceptions to pkg_add rules
tcsh-6.18.01        extended C-shell with many useful features</pre><p>I know that I did not choose to install <code class="literal">icu4c</code>. I have no moral objections to the software, mind you, but it’s nothing I requested. How did a piece of software that I didn’t choose to install, and isn’t required by anything else, get on this system?</p><p>It’s there because I uninstalled something that required it.</p></div><div class="sect2" title="Uninstalling Packages"><div class="titlepage"><div><div><h3 class="title" id="uninstalling_packages">Uninstalling Packages</h3></div></div></div><p>To remove a previously installed package, use <code class="literal">pkg_delete(1)</code>.</p><a id="I_programlisting13_id465650"/><pre class="programlisting"># <span class="strong"><strong>pkg_delete openldap-server</strong></span>
openldap-server-2.4.31p0: ok
Read shared items: ok
--- -openldap-server-2.4.31p0 -------------------
You should also run /usr/sbin/userdel _openldap
You should also run /usr/sbin/groupdel _openldap</pre><p><code class="literal">pkg_delete</code> does not request confirmation. It doesn’t ask if you are sure. It just blasts the software off the disk and gets on with its day. It also doesn’t remove the unprivileged users and groups created for the software, as you might still have files owned by them.</p><p>Remember that many packages require other packages. By default, <code class="literal">pkg_delete</code> doesn’t remove dependencies of packages you remove. For example, earlier we saw that <code class="literal">icu4c</code> had been installed automatically as a leftover dependency from a removed OpenLDAP server package. To automatically remove unneeded dependencies, use the <code class="literal">-a</code> flag. For example, to completely eradicate the <code class="literal">openldap-server</code> package and its infrastructure from the machine, run <code class="literal">pkg_delete</code> twice.</p><a id="I_programlisting13_id465695"/><pre class="programlisting"># <span class="strong"><strong>pkg_delete openldap-server</strong></span>
# <span class="strong"><strong>pkg_delete -a</strong></span></pre><p><a class="indexterm" id="idx1661"/><a class="indexterm" id="idx1836"/>This should clean your system of all packages installed as dependencies.</p></div><div class="sect2" title="Package Limitations"><div class="titlepage"><div><div><h3 class="title" id="package_limitations">Package Limitations</h3></div></div></div><p>The package system is fast, efficient, reliable, and the OpenBSD Project’s preferred way for users to install software. But the system does have a few limitations that you should be aware of, including lags in the software-porting process and the support for newer packages on older versions of OpenBSD.</p><p>Each OpenBSD release supports only packages built for that release, and new packages are not built for old releases. The packages issued with the release are all you’ll get. (There are slight exceptions to this if you’re running <code class="literal">-stable</code>; see <a class="xref" href="ch20.html" title="Chapter 20. Upgrading">Chapter 20</a>.) If you’re running OpenBSD 5.3 and try to install packages from OpenBSD 5.4, they won’t work.</p><p>Most packages include software produced by third parties. OpenBSD provides the packaging, but the software itself is released on a schedule completely independent of OpenBSD’s. After the software developers release their newest software, the OpenBSD package is updated, but there’s a gap between the software’s release date and the release of the OpenBSD package. A popular package might be updated in hours, while larger, less frequently used, or unpopular packages can languish at an older version for days or weeks. These packages are not officially available until the next OpenBSD release, so you might run software that’s a point or two behind the latest for a few months. Usually, this is not a problem (if it is, investigate OpenBSD’s <code class="literal">-stable</code> branch, discussed in <a class="xref" href="ch20.html" title="Chapter 20. Upgrading">Chapter 20</a>.)</p><div class="note" title="Note"><h3 class="title"><a id="ch13note02"/>Note</h3><p>If packages won’t work for you, investigate building third-party software through ports. You won’t get newer versions of the software, but you can get slightly different versions.</p></div></div></div><div class="sect1" title="Using Ports"><div class="titlepage"><div><div><h2 class="title" id="using_ports" style="clear: both">Using Ports</h2></div></div></div><p>The ports collection is the toolkit to build OpenBSD packages. Installing software from ports takes longer than installing via packages, is more error-prone, and requires a deeper understanding of the system and the add-on software than packages demand. You can’t get packages for every possible situation, however (one particularly annoying example is when the license for a particular piece of software makes it illegal for the OpenBSD project to create and distribute packages), and sometimes ports are the only way to get third-party software on your OpenBSD system short of compiling it yourself.</p><p><a class="indexterm" id="idx0095"/><a class="indexterm" id="idx1024"/><a class="indexterm" id="idx1296"/><a class="indexterm" id="idx1838"/><a class="indexterm" id="idx1844"/><a class="indexterm" id="idx1848"/><a class="indexterm" id="idx2564"/>What makes ports interesting is their level of automation. With one command, a port can find the source code for a program, download it, verify its integrity, apply any patches needed to make it run on OpenBSD, toggle any flags needed for any custom features of your system, build the code into actual binaries, produce a package, and install it. If you have compiled software on other platforms, you’ll quickly realize how ports simplify building software.</p><p>Like packages, ports work only on the version of OpenBSD for which they are released. That means that you must use the OpenBSD 5.4 ports collection on OpenBSD 5.4; the 5.5 ports collection won’t work. Oh, it might look like it works sometimes, but the software will fail unpredictably, and no one will have sympathy for you (sympathy for your coworkers, perhaps, but not for you).</p><p>When you upgrade OpenBSD, the expectation is that you will upgrade your ports collection and all installed packages to the precise matching version. You might be able to use older packages on a newer OpenBSD, as long as you don’t delete the older shared libraries required by the software.</p><div class="sect2" title="The Ports Tree"><div class="titlepage"><div><div><h3 class="title" id="the_ports_tree">The Ports Tree</h3></div></div></div><p>The ports tree is usually installed in <span class="emphasis"><em>/usr/ports</em></span>. If you want the ports tree, you must manually fetch the <span class="emphasis"><em>ports.tar.gz</em></span> file from your OpenBSD release and extract it under <span class="emphasis"><em>/usr</em></span>.</p><div class="note" title="Note"><h3 class="title"><a id="ch13note03"/>Note</h3><p>I suggested this way back in <a class="xref" href="ch04.html" title="Chapter 4. Post-Install Setup">Chapter 4</a>, but you can also get the ports tree and keep the files up to date using <code class="literal">cvs(1)</code>, as covered in <a class="xref" href="ch20.html" title="Chapter 20. Upgrading">Chapter 20</a>. Look in this directory, and you’ll find a whole bunch of directories and files.</p></div><p>The <span class="emphasis"><em>INDEX</em></span> file contains a list of every port in the system, in alphabetical order but machine-readable format. You can search this file for ports, but I recommend using one of the tools discussed later to do so.</p><p>The <span class="emphasis"><em>Makefile</em></span> contains the basic machine instructions for making the ports system work. While it’s intended for use by <code class="literal">make(1)</code>, you can learn a lot by reading the makefile for any port. Most of the really complicated ports code is in the <span class="emphasis"><em>ports/infrastructure</em></span> directory, and all of the makefiles in the ports system build on that infrastructure.</p><p>The remaining directories are software categories. Each category contains a further layer of directories, and each directory under a category is a port of a specific piece of software. OpenBSD has more than 7600 ports as of this writing, so this hierarchical organization is vital to keeping them in some sort of manageable order.</p><p>For example, the following is a listing of the contents of the <span class="emphasis"><em>news</em></span> directory, which contains programs for using and managing Usenet news. This is one of the smaller categories. Some categories have hundreds of entries, but they’re arranged in much the same way.</p><a id="I_programlisting13_id465981"/><pre class="programlisting">CVS               leafnode          p5-News-Article   py-yenc           tin
Makefile          newsfetch         p5-News-Newsrc    sabnzbd           trn
aub               nn                pan               sickbeard         ubh
hellanzb          p5-Gateway        plor              slrn              yencode</pre><p><a class="indexterm" id="idx0342"/><a class="indexterm" id="idx1841"/><a class="indexterm" id="idx2049"/><a class="indexterm" id="idx2393"/>Like the <span class="emphasis"><em>CVS</em></span> directory in the main ports tree, the category’s <span class="emphasis"><em>CVS</em></span> directory contains CVS version control information that doesn’t matter for day-to-day operation. The <span class="emphasis"><em>Makefile</em></span> contains a list of valid ports within the category. You can build all of the ports in this category using this makefile, although that’s mostly useful only when building packages en masse. (When the OpenBSD Project team builds everything in the ports tree, it uses <span class="emphasis"><em>/usr/ports/infrastructure/bin/dpb</em></span>.)</p><p>Let’s go down another level. Here’s the port for <code class="literal">tcsh</code>, one of my nonnegotiable requirements as a sysadmin:</p><a id="I_programlisting13_id466052"/><pre class="programlisting">$ <span class="strong"><strong>ls /usr/ports/shells/tcsh</strong></span>
CVS      Makefile distinfo patches  pkg</pre><p>The <span class="emphasis"><em>CVS</em></span> directory contains version control information, as in every <span class="emphasis"><em>CVS</em></span> directory.</p><p>The <span class="emphasis"><em>Makefile</em></span> gives specific instructions for building <code class="literal">tcsh</code> on OpenBSD, including where to get the software and any patches, how to extract it, where the package can be distributed from, and any supported customizations.</p><p>The <span class="emphasis"><em>distinfo</em></span> file contains several different cryptographic hashes for the source code to be downloaded, to avoid building software from compromised source code, and the size of the source file. Newer ports contain only SHA-256 hashes.</p><div class="note" title="Note"><h3 class="title"><a id="ch13note04"/>Note</h3><p>While it’s possible (difficult, but possible) to have a compromised file match a specific hash, it’s extremely unlikely that an altered source code file could match hashes computed with several different algorithms and have the same size as the uncompromised code. Even if people figure out how to break a particular hash, use of multiple hashes and the file size make compromising a source file nearly impossible.</p></div><p>The <span class="emphasis"><em>patches</em></span> directory contains code alterations needed to make this software run on OpenBSD. Some ports have no patches; others have dozens.</p><p>Finally, the <span class="emphasis"><em>pkg</em></span> directory describes the package and lists the files that the complete package must include.</p></div><div class="sect2" title="Secondary Ports"><div class="titlepage"><div><div><h3 class="title" id="secondary_ports">Secondary Ports</h3></div></div></div><p>Some ports include other ports. Here are the contents of the <span class="emphasis"><em>emulators/fedora</em></span> port.</p><a id="I_programlisting13_id466139"/><pre class="programlisting">CVS    Makefile   Makefile.inc  base       cups       motif      sdl</pre><p><a class="indexterm" id="idx0211"/><a class="indexterm" id="idx0661"/><a class="indexterm" id="idx1297"/><a class="indexterm" id="idx1845"/><a class="indexterm" id="idx1931"/><a class="indexterm" id="idx2591"/>The file <span class="emphasis"><em>Makefile.inc</em></span> is new, as are the subdirectories <span class="emphasis"><em>base</em></span>, <span class="emphasis"><em>cups</em></span>, <span class="emphasis"><em>motif</em></span>, and <span class="emphasis"><em>sdl</em></span>. The subdirectories are independent ports. These four ports are often installed together, and as a whole, support OpenBSD’s Linux emulation (documented in <code class="literal">compat_linux(8)</code>). All four ports call in the common instructions in <span class="emphasis"><em>Makefile.inc</em></span>. (The ports tree doesn’t include many of these, but don’t be shocked when you find one.)</p></div><div class="sect2" title="Read-Only Ports Tree"><div class="titlepage"><div><div><h3 class="title" id="read-only_ports_tree">Read-Only Ports Tree</h3></div></div></div><p>The process of building a port creates an installable package and uses a whole bunch of temporary files, source files, and status files. By default, all of these files are placed inside the ports tree itself. While this works, I encourage you to treat <span class="emphasis"><em>/usr/ports</em></span> as a read-only OpenBSD directory tree, just like <span class="emphasis"><em>/usr/bin</em></span>, <span class="emphasis"><em>/usr/lib</em></span>, and so on. Doing so simplifies upgrading and identifying local changes, helps identify what you’ve built from ports, and saves space on the <span class="emphasis"><em>/usr</em></span> partition.</p><div class="note" title="Note"><h3 class="title"><a id="ch13note05"/>Note</h3><p>Build files for ports can range from a few kilobytes to several gigabytes, so it’s best to build ports on a large scratch partition. If you have unpartitioned disk space, create a partition just for building ports. Or use any partition with space, or even an NFS partition.</p></div><p>Configure the ports collection by setting variables in <span class="emphasis"><em>/etc/mk.conf</em></span>. To use a read-only ports tree, set the variables in these directories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><p title="WRKOBJDIR"><span class="title"><strong><span class="strong"><strong><code class="literal">WRKOBJDIR</code></strong></span></strong></span>. Directory where the software is extracted from source and compiled. These can be deleted and re-created as needed.</p></li><li class="listitem" style="list-style-type: none"><p title="PACKAGE_REPOSITORY"><span class="title"><strong><span class="strong"><strong><code class="literal">PACKAGE_REPOSITORY</code></strong></span></strong></span>. Directory where completed packages are stored. The ports collection builds packages, which you can then install.</p></li><li class="listitem" style="list-style-type: none"><p title="PLIST_DB"><span class="title"><strong><span class="strong"><strong><code class="literal">PLIST_DB</code></strong></span></strong></span>. Directory where package packing lists are stored.</p></li><li class="listitem" style="list-style-type: none"><p title="BULK_COOKIES_DIR"><span class="title"><strong><span class="strong"><strong><code class="literal">BULK_COOKIES_DIR</code></strong></span></strong></span>. Directory for storing status cookies during mass builds of packages.</p></li><li class="listitem" style="list-style-type: none"><p title="UPDATE_COOKIES_DIR"><span class="title"><strong><span class="strong"><strong><code class="literal">UPDATE_COOKIES_DIR</code></strong></span></strong></span>. Directory for storing status cookies during mass updates of packages.</p></li><li class="listitem" style="list-style-type: none"><p title="DISTDIR"><span class="title"><strong><span class="strong"><strong><code class="literal">DISTDIR</code></strong></span></strong></span>. Directory where vendor source code is kept. Source code is usually retained for reuse.</p></li></ul></div><p>If these directories are owned by your regular user account, you can do a large part of package building without being root.</p><p>On one particular test system, I have hundreds of gigabytes free in <span class="emphasis"><em>/home</em></span>, so I chose to put my package directories there. Here’s my <span class="emphasis"><em>/etc/mk.conf</em></span>:</p><a id="I_programlisting13_id466376"/><pre class="programlisting">WRKOBJDIR=/home/ports/wrkobjdir
DISTDIR=/home/ports/distdir
PLIST_DB=/home/ports/plist
BULK_COOKIES_DIR=/home/ports/bulk_cookies
UPDATE_COOKIES_DIR=/home/ports/update_cookies
PACKAGE_REPOSITORY=/home/ports/pkgrepo</pre><p><a class="indexterm" id="idx1291"/><a class="indexterm" id="idx1840"/><a class="indexterm" id="idx1842"/><a class="indexterm" id="idx2567"/>The ports system will build everything in <span class="emphasis"><em>/home/ports/wrkobjdir</em></span>. Original source code files go in <span class="emphasis"><em>/home/ports/distdir</em></span>. The ports system maintains various records in <span class="emphasis"><em>/home/ports/update_cookies</em></span> and <span class="emphasis"><em>/home/ports/bulk_cookies</em></span>. Completed packages go into <span class="emphasis"><em>/home/ports/pkgrepo</em></span>.</p><div class="note" title="Note"><h3 class="title"><a id="ch13note06"/>Note</h3><p>If you have a dedicated port-building machine, consider per-release package repositories. For example, I might have three versions of OpenBSD running at any given time. The package-building machine always runs the latest release, but I don’t want to throw away my old packages, so I use a package repository directory like <span class="emphasis"><em>/home/ports/pkgrepo/5.4</em></span> for packages built on a 5.4 system.</p></div></div><div class="sect2" title="Finding Software"><div class="titlepage"><div><div><h3 class="title" id="finding_software">Finding Software</h3></div></div></div><p>As with packages, the first problem with ports is finding software you want. (To randomly poke around the ports tree in a pretty interface, see the <span class="emphasis"><em><a class="ulink" href="http://www.openports.se" target="_top">http://www.openports.se</a></em></span> website.) OpenBSD has several ways to search the ports collection, including the ports index, keywords, and via SQL.</p><div class="sect3" title="The Ports Index"><div class="titlepage"><div><div><h4 class="title" id="the_ports_index">The Ports Index</h4></div></div></div><p>The file <span class="emphasis"><em>/usr/ports/INDEX</em></span> lists all software in the ports tree, sorted by category and then alphabetically. If you have a good idea what your port is called, you can search the file for your preferred software. The index describes each port in a single pipe-delimited line, much like this:</p><a id="I_programlisting13_id466493"/><pre class="programlisting">gcpio-2.11|archivers/gcpio||GNU copy-in/out (cpio)|archivers/gcpio/pkg/DESCR|The OpenBSD ports mailing-list &lt;ports@openbsd.org&gt;|archivers|
STEM-&gt;=0.10.38:devel/gettext converters/libiconv|STEM-&gt;=0.10.38:devel/gettext|STEM-&gt;=0.10.38:devel/gettext|any|y|y|y|y</pre><p>While the ports tree itself finds this a convenient format, it’s not particularly human-readable. To translate this to a human-friendly format, go into <span class="emphasis"><em>/usr/ports</em></span> and run <span class="strong"><strong><code class="literal">make print-index</code></strong></span>. (This process goes on for tens of thousands of lines, so feed it to a pager.) Here’s the same port in the human-readable format:</p><a id="I_programlisting13_id466516"/><pre class="programlisting">$ <span class="strong"><strong>cd /usr/ports</strong></span>
$ <span class="strong"><strong>make print-index | less</strong></span>
…
Port:   gcpio-2.11
Path:   archivers/gcpio
Info:   GNU copy-in/out (cpio)
Maint:  The OpenBSD ports mailing-list &lt;ports@openbsd.org&gt;
Index:  archivers
L-deps: STEM-&gt;=0.10.38:devel/gettext converters/libiconv
B-deps: STEM-&gt;=0.10.38:devel/gettext
R-deps: STEM-&gt;=0.10.38:devel/gettext
…</pre><p><a class="indexterm" id="idx1025"/><a class="indexterm" id="idx1276"/><a class="indexterm" id="idx2046"/><a class="indexterm" id="idx2047"/><a class="indexterm" id="idx2205"/>The <code class="literal">Port</code> statement gives the official name of the port and the version of the ported software. This software is called <code class="literal">gcpio</code>, and it’s at version 2.11. The <code class="literal">Path</code> gives the ports tree category and directory where the port can be found—in this case, <span class="emphasis"><em>archivers/gcpio</em></span>. The <code class="literal">Info</code> line gives a very brief description of the software. This is the GNU version of <code class="literal">cpio(1)</code>. The <code class="literal">Maint</code>, or maintainer, is the person or group responsible for maintaining this software in the ports tree. The OpenBSD ports team supports the <code class="literal">gcpio</code> port. The best-maintained ports usually have an individual as a maintainer, rather than the mailing list.</p><p>The final three entries describe other software required by this software. The <code class="literal">L-deps</code> line lists shared libraries, <code class="literal">B-deps</code> lists software needed to build this port, and <code class="literal">R-deps</code> lists the port’s runtime dependencies.</p><p>What good does this do? Suppose you’re still hung up on an Apache 2 web server. You can search <span class="emphasis"><em>INDEX</em></span> for ports beginning with “apache.”</p><a id="I_programlisting13_id466641"/><pre class="programlisting">$ <span class="strong"><strong>grep -i ^apache INDEX</strong></span>
…
apache-httpd-2.2.20p1|www/apache-httpd||apache HTTP server|www/apache-httpd/pkg/DESCR|The OpenBSD ports mailing-list &lt;ports@openbsd.org&gt;|www net|
apr-util-*-!ldap:devel/apr-util converters/libiconv devel/pcre|STEM-&gt;=1.21:
textproc/groff|converters/libiconv|any|y|y|y|y</pre><p>The first three (omitted) entries are ports related to Apache, but they are not the web server software. The fourth line is our port.</p><p>Gathering this information from the index is rather limited, however. If you don’t know the name of the software, or how OpenBSD packages the software, you can’t easily find the port. In that case, try one of the other methods discussed next.</p></div><div class="sect3" title="Finding by Keyword"><div class="titlepage"><div><div><h4 class="title" id="finding_by_keyword">Finding by Keyword</h4></div></div></div><p>If you don’t know a package’s exact name, try the ports collection’s search feature: <code class="literal">make search</code> and a key scans the index for a specific word. To search for Apache-related software, try this:</p><a id="I_programlisting13_id466680"/><pre class="programlisting">$ <span class="strong"><strong>make search key=apache</strong></span></pre><p>On my system, this returns 62 results. You’ll need to scroll through several pages of possibilities, but you’ll find what you want.</p><p>You might need to try several possible keywords for a particular package, as some keywords have no hits and others generate too many.</p></div><div class="sect3" title="Finding via SQL"><div class="titlepage"><div><div><h4 class="title" id="finding_via_sql">Finding via SQL</h4></div></div></div><p>The <code class="literal">sqlports</code> package lets you build a database of the <span class="emphasis"><em>INDEX</em></span> file, permitting you to search for ports based on highly arbitrary criteria via SQL. For example, say you want to know all ports that depend on <code class="literal">libiconv</code> and <code class="literal">expat</code>. In this case, <code class="literal">sqlports</code> is your friend. Install it from ports or packages, and it will automatically build a database in <span class="emphasis"><em>/usr/local/share/sqlports</em></span> from <span class="emphasis"><em>INDEX</em></span>, and then use OpenBSD’s <code class="literal">sqlite3</code> to query the database.</p><p><a class="indexterm" id="idx0407"/><a class="indexterm" id="idx1286"/><a class="indexterm" id="idx1839"/><a class="indexterm" id="idx2198"/>I won’t teach SQL<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id431051" id="id431051">37</a>]</sup> here, but just as an example, here’s how to search for ports whose name includes the string “apache” using <code class="literal">sqlports</code> (which can build much more complex queries than this one):</p><a id="I_programlisting13_id466794"/><pre class="programlisting">$ <span class="strong"><strong>sqlite3 /usr/local/share/sqlports</strong></span>
sqlite&gt; <span class="strong"><strong>select fullpkgname from ports where fullpkgname like '%apache%';</strong></span>
apache-couchdb-1.0.1p2
apache-ant-1.8.2p3
apachetop-0.12.6
apache-httpd-2.2.22
modsecurity-apache-1.9.3p5
p5-Apache-ASP-2.61p0
p5-Apache-DB-0.14p3
…</pre><p>The Apache <code class="literal">httpd</code> server is the fourth hit, but there are another dozen or so ports. Every name that begins with <code class="literal">p5-</code> is a Perl module.</p></div></div></div><div class="sect1" title="Building Ports"><div class="titlepage"><div><div><h2 class="title" id="building_ports" style="clear: both">Building Ports</h2></div></div></div><p>You’ve decided to ignore the OpenBSD team’s recommendations to use packages, downloaded and extracted the ports tree, found software you need to install from ports, and designated an area for building ports. Now what?</p><p>The port directories don’t contain actual source code. When you build a package from a port, the system does the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Automatically downloads the appropriate source code from an approved Internet site</p></li><li class="listitem"><p>Checks the downloaded code for integrity errors</p></li><li class="listitem"><p>Extracts the code to the build area</p></li><li class="listitem"><p>Patches the code</p></li><li class="listitem"><p>Compiles the code</p></li><li class="listitem"><p>Creates the package</p></li><li class="listitem"><p>Installs the package (optional)</p></li></ul></div><p>Additionally, if the port you’re adding has unmet dependencies, the system also handles installing those dependencies.</p><p>To make all this happen, just go to the <span class="emphasis"><em>port</em></span> directory and enter this command:</p><a id="I_programlisting13_id466895"/><pre class="programlisting"># <span class="strong"><strong>make install</strong></span></pre><p>You should see the port build the software, create the package, and install the package on your system.</p><div class="sect2" title="What a Port Installation Does"><div class="titlepage"><div><div><h3 class="title" id="what_a_port_installation_does">What a Port Installation Does</h3></div></div></div><p><a class="indexterm" id="idx1827"/><a class="indexterm" id="idx2029"/><a class="indexterm" id="idx2461"/><a class="indexterm" id="idx2464"/>It’s time to dissect a port build and installation. Here’s how to install <code class="literal">tcsh</code> from a port:</p><a id="I_programlisting13_id466960"/><pre class="programlisting"># <span class="strong"><strong>cd /usr/ports/shells/tcsh</strong></span>
# <span class="strong"><strong>make install</strong></span>
===&gt;  Verifying specs: c termlib c termlib
===&gt;  found c.65.0 termlib.12.1
===&gt;  Checking files for tcsh-6.18.01
&gt;&gt; Fetch ftp://ftp.astron.com/pub/tcsh/tcsh-6.18.01.tar.gz
tcsh-6.18.01.tar.gz 100% |****************************************************
|   905 KB    00:00
&gt;&gt; (SHA256) tcsh-6.18.01.tar.gz: OK</pre><p>The port first checks to see if the software’s required libraries are in place. Building <code class="literal">tcsh</code> requires the <code class="literal">termlib</code> and <code class="literal">c</code> libraries. The port finds <code class="literal">termlib</code> but not a file containing the <code class="literal">tcsh</code> source code on the local system, so the port fetches the code. (When building a port, you should see the system downloading the appropriate source code.) The port then verifies the checksum of the downloaded code. If the port can’t get all of the code, or the checksums don’t match, the build process stops.</p><p>Once all necessary source code is downloaded and verified, the build continues with something like this:</p><a id="I_programlisting13_id467009"/><pre class="programlisting">…
===&gt;  Extracting for tcsh-6.18.01
===&gt;  Patching for tcsh-6.18.01
===&gt;  Configuring for tcsh-6.18.01
Using /usr/ports/pobj/tcsh-6.18.01/config.site (generated)
configure: WARNING: unrecognized options: --disable-silent-rules
configure: loading site script /usr/ports/pobj/tcsh-6.18.01/config.site
checking for a BSD-compatible install… /usr/bin/install -c -o root -g bin
checking build system type… i386-unknown-openbsd5.2
checking host system type… i386-unknown-openbsd5.2
…</pre><p>The port extracts the source code from the compressed file(s), applies any OpenBSD-specific patches, and starts the build process. (Many of you know that <code class="literal">configure</code> is not the same as building software, but not all software requires a <code class="literal">configure</code> step. The port knows what to do.)</p><p>The build process will go on for many lines. Building something like OpenOffice can take days and generate hundreds of thousands of lines of output.</p><div class="note" title="Note"><h3 class="title"><a id="ch13note07"/>Note</h3><p>If you need to debug a port build failure, those messages that scroll off the top of your screen or terminal window contain all the clues you get. For that reason, I often build ports in a <code class="literal">script(1)</code> session. If you like the idea of keeping build messages around, see the <code class="literal">script</code> man page for details.</p></div><p>Eventually, you should see a message that the build has finished and the port is installing the software.</p><a id="I_programlisting13_id467058"/><pre class="programlisting">…
===&gt;  Faking installation for tcsh-6.18.01
install -c -s -o root -g bin -m 555 /home/ports/wrkobjdir/tcsh-6.18.01/tcsh-6.18.01/tcsh /home/ports/wrkobjdir/tcsh-6.18.01/fake-i386/usr/local/bin/tcsh
install -c -o root -g bin -m 444 /home/ports/wrkobjdir/tcsh-6.18.01/tcsh-6.18.01/tcsh.man /home/ports/wrkobjdir/tcsh-6.18.01/fake-i386/usr/local/man/man1/tcsh.1
install -c -o root -g bin -m 444 /home/ports/wrkobjdir/tcsh-6.18.01/tcsh-6.18.01/nls/C.cat /home/ports/wrkobjdir/tcsh-6.18.01/fake-i386/usr/local/share/nls/C/tcsh.cat
…</pre><p><a class="indexterm" id="idx1817"/>The port installs the software in a temporary location in the port building directory, but that’s not where we want the software installed! Remember that the ports system builds packages, and then installs from the package. This “fake” installation is for building the package.</p><a id="I_programlisting13_id467080"/><pre class="programlisting">…
===&gt;  Building package for tcsh-6.18.01
Create /home/ports/pkgrepo/i386/all/tcsh-6.18.01.tgz
…</pre><p>There’s the package, retained in the package repository specified earlier. You might want to grab this file to install on your other machines, or perhaps even share the package repository via NFS.</p><p>Now, because we specified <code class="literal">make install</code> on the command line, the port installs the created package.</p><a id="I_programlisting13_id467097"/><pre class="programlisting">…
===&gt;  Verifying specs: c termlib
===&gt;  found c.65.0 termlib.12.1
===&gt;  Installing tcsh-6.18.01 from /home/ports/pkgrepo/i386/all/
…
tcsh-6.18.01: ok
#</pre><p>Installing the package requires making some of the same checks as building the package. Yes, the port could not have built the package without those libraries, but the ports system doesn’t assume that the package was built on the local system.</p></div><div class="sect2" title="Port Build Stages"><div class="titlepage"><div><div><h3 class="title" id="port_build_stages">Port Build Stages</h3></div></div></div><p>The package build process actually includes several stages, or smaller chunks of build procedure. Each stage performs all the stages before it. The final stage, <code class="literal">make install</code>, calls all of them, which provides several points where you can intervene in the port build process. If you want to make custom changes to a package, you can do it here.</p><p>Let’s look at each of the stages called for every port build.</p><div class="sect3" title="The make fetch Stage"><div class="titlepage"><div><div><h4 class="title" id="the_make_fetch_stage">The make fetch Stage</h4></div></div></div><p><a class="indexterm" id="idx0497"/><a class="indexterm" id="idx0499"/><a class="indexterm" id="idx1280"/><a class="indexterm" id="idx1285"/>The <code class="literal">make fetch</code> stage gets the source code, or <span class="emphasis"><em>distfiles</em></span>, for the port. First, it looks in any directories specified by the <span class="emphasis"><em>mk.conf</em></span> variable <code class="literal">$DISTDIR</code>. If this variable isn’t set, it looks in the directory specified by the shell environment variable <code class="literal">$DISTDIR</code>. If neither variable is set, it looks in <span class="emphasis"><em>/usr/ports/distfiles</em></span>. If <code class="literal">make fetch</code> finds the distribution files and thinks that they’re the correct version, it hands control to the next requested stage, and the build continues.</p><p>If the source code is not on the local machine, <code class="literal">make fetch</code> tries to download it from an Internet site specified in the port’s makefile as <code class="literal">MASTER_SITES</code>. (You can customize download locations, as discussed in <a class="xref" href="ch13.html#customizing_ports" title="Customizing Ports">Customizing Ports</a>.)</p><p>You’ll find the <code class="literal">make fetch</code> command very useful when there are certain times in your day when you can download more easily than other times. For example, I have a T1 to my house,<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id370871" id="id370871">38</a>]</sup> but my employer’s office has roughly 66 times as much bandwidth as I have at home. I can run <code class="literal">make fetch</code> on my laptop while visiting my employer, go home, and build the port in peace. (And the boss thinks I come in because he buys lunch.)</p></div><div class="sect3" title="The make checksum Stage"><div class="titlepage"><div><div><h4 class="title" id="the_make_checksum_stage">The make checksum Stage</h4></div></div></div><p>The <code class="literal">make checksum</code> stage verifies that distfiles have not been corrupted, either by the download process or maliciously. OpenBSD includes several different checksums for each distfile, but only checks that the SHA-256 checksum matches the distfile. If the checksum matches, the build proceeds to the next stage. If the checksums do not match, the build immediately aborts. The build will not continue until you find a distfile that matches the checksum.</p><p>Not all software developers are conscientious about updating the names of their distfiles when they update their software. For these software packages, the <span class="emphasis"><em>foo-1.0.tgz</em></span> file the port developer downloaded in the morning might differ from the <span class="emphasis"><em>foo-1.0.tgz</em></span> file you download later that same day. Perhaps the original software author thought that no one would notice, but the OpenBSD folks would, if only via the logic built into the ports tools. After all, the ports system can’t tell the difference between a source file quietly modified by the software author and a source file quietly modified by an intruder. If you get a distfile that doesn’t match the recorded checksum, try to fetch a matching file by setting the <code class="literal">REFETCH</code> variable to <code class="literal">true</code>.</p><a id="I_programlisting13_id467288"/><pre class="programlisting"># <span class="strong"><strong>make checksum REFETCH=true</strong></span></pre><p>Now <code class="literal">make</code> will walk through all the distfile sources listed in the port, downloading them successively in an effort to find a distfile that matches that used by the port developer.</p><p>If you are absolutely certain that the file you downloaded is the correct, untampered-with one, but it still doesn’t pass <code class="literal">make checksum</code>, you’re wrong. If you know that you’re wrong, but you really do want to install compromised or damaged software, set the environment variable <code class="literal">NO_CHECKSUM=yes</code> to skip the <code class="literal">make checksum</code> stage.</p><div class="warning" epub:type="warning" title="Warning"><h3 class="title"><a id="ch13note08"/>Warning</h3><p>Skipping the <code class="literal">make checksum</code> stage might be valid for debugging, but it certainly isn’t the way to create a stable, useful, or secure package. You also might invalidate the rest of the port. Perhaps the OpenBSD patches will no longer apply cleanly, the software just won’t run, or you could even be installing a backdoor, inviting scumbags to stash problematic content on your machine. You are utterly on your own if you insist on ignoring a checksum mismatch.</p></div></div><div class="sect3" title="The make prepare Stage"><div class="titlepage"><div><div><h4 class="title" id="the_make_prepare_stage">The make prepare Stage</h4></div></div></div><p><a class="indexterm" id="idx1282"/><a class="indexterm" id="idx1283"/><a class="indexterm" id="idx1289"/><a class="indexterm" id="idx1290"/>At this point, the ports system gets into recursion. At <code class="literal">make prepare</code>, the port checks for any software needed to build or run the software you’re trying to build. If the port lists any of these dependencies, it checks to see if they are installed. If the dependencies are not installed, this stage kicks off <code class="literal">make install</code> for those required ports. Once all of the required dependencies are installed, this stage ends.</p></div><div class="sect3" title="The make extract Stage"><div class="titlepage"><div><div><h4 class="title" id="the_make_extract_stage">The make extract Stage</h4></div></div></div><p>The ports system must extract the source code from the distfile before building the software. Source code is extracted into the directory defined by <code class="literal">$WRKOBJDIR</code>, or in a directory under <span class="emphasis"><em>/usr/ports/pobj/</em></span> named after the port. By default, my <code class="literal">tcsh</code> port would extract under <span class="emphasis"><em>/usr/ports/pobj/tcsh</em></span>, but because I defined a separate location for building software, it’s built under <span class="emphasis"><em>/home/ports/wrkobjdir/tcsh</em></span>.</p></div><div class="sect3" title="The make patch Stage"><div class="titlepage"><div><div><h4 class="title" id="the_make_patch_stage">The make patch Stage</h4></div></div></div><p>Any patches included in the port’s patches directory are applied in the <code class="literal">make patch</code> stage. If the patches all apply correctly, this stage ends. If the patches do not apply correctly, the port fails.</p><p>To apply your own patches to the port, or to review the code before compiling it, run <code class="literal">make patch</code> first. Your patches might conflict with the port patches if you apply them first, cause compilation failures, or bring up any number of other problems. By running <code class="literal">make patch</code> first, you get to see the code as OpenBSD can compile it. Anything you break after that is definitely your fault.</p></div><div class="sect3" title="The make configure Stage"><div class="titlepage"><div><div><h4 class="title" id="the_make_configure_stage">The make configure Stage</h4></div></div></div><p>Many software packages use a <code class="literal">configure</code> script to prepare themselves for compilation on a specific platform. The <code class="literal">make configure</code> command runs that script. If you want to edit the <code class="literal">configure</code> script, do so before running this stage! If there is no <code class="literal">configure</code> script, the port silently skips this stage.</p></div><div class="sect3" title="The make build Stage"><div class="titlepage"><div><div><h4 class="title" id="the_make_build_stage">The make build Stage</h4></div></div></div><p><a class="indexterm" id="idx1205"/><a class="indexterm" id="idx1279"/><a class="indexterm" id="idx1281"/><a class="indexterm" id="idx1284"/><a class="indexterm" id="idx1287"/><a class="indexterm" id="idx1288"/><a class="indexterm" id="idx1376"/><a class="indexterm" id="idx1804"/><a class="indexterm" id="idx1819"/><a class="indexterm" id="idx1820"/>The <code class="literal">make build</code> stage compiles the fetched, extracted, patched, and configured software. If you type <code class="literal">make</code> in a port directory, the port calls <code class="literal">make build</code>. This stage doesn’t assemble a package; it just performs the compilation and creates the actual program binaries in the port’s work directory.</p></div><div class="sect3" title="The make fake Stage"><div class="titlepage"><div><div><h4 class="title" id="the_make_fake_stage">The make fake Stage</h4></div></div></div><p>The <code class="literal">make fake</code> stage installs the software in a subdirectory, laid out exactly as it would be under the <span class="emphasis"><em>root</em></span> directory. This fake root directory is in the work directory, named <span class="emphasis"><em>fake-</em></span> with the architecture appended, such as <span class="emphasis"><em>fake-amd64</em></span>. Everything that will be in the package is installed under this directory, with the same ownership and permissions that it will include in the package.</p></div><div class="sect3" title="The make package Stage"><div class="titlepage"><div><div><h4 class="title" id="the_make_package_stage">The make package Stage</h4></div></div></div><p>The <code class="literal">make package</code> stage bundles up the port’s fake installation directory, adds in packaging and installation instructions, and ties it all up in a package exactly like those available on the FTP site. The package will be stored under the <span class="emphasis"><em>PKGREPO</em></span> directory you defined earlier (or in <span class="emphasis"><em>/usr/ports/packages</em></span> if you didn’t define one), in a subdirectory organized by architecture, and in further subdirectories organized by available distribution locations.</p><p><code class="literal">make package</code> means that you can build this port on one machine without installing it. You must install the build dependencies to build the port, however.</p></div><div class="sect3" title="The make install Stage"><div class="titlepage"><div><div><h4 class="title" id="the_make_install_stage">The make install Stage</h4></div></div></div><p>The <code class="literal">make install</code> stage runs <code class="literal">pkg_add(1)</code> to install the package you compiled.</p></div><div class="sect3" title="The make clean Stage"><div class="titlepage"><div><div><h4 class="title" id="the_make_clean_stage">The make clean Stage</h4></div></div></div><p>Some packages require a lot of disk space. The <code class="literal">make clean</code> stage removes all of the build files except the distfile and the completed package.</p></div></div></div><div class="sect1" title="Customizing Ports"><div class="titlepage"><div><div><h2 class="title" id="customizing_ports" style="clear: both">Customizing Ports</h2></div></div></div><p>OpenBSD includes a variety of hooks to let you easily customize how you get and build ports. If possible, you should use the OpenBSD-provided infrastructure, but there may be cases where that’s not possible. Here, we’ll look at some of the more commonly used customization settings.</p><div class="sect2" title="Local Distfile Mirrors"><div class="titlepage"><div><div><h3 class="title" id="local_distfile_mirrors">Local Distfile Mirrors</h3></div></div></div><p>While ports provide several places to get source code, you might want to override those sites. Perhaps you share a network with a major mirror site, or you don’t have unfettered Internet access. OpenBSD lets you set your own preferred mirror sites.</p><div class="sect3" title="Preferred Collection Mirrors"><div class="titlepage"><div><div><h4 class="title" id="preferred_collection_mirrors">Preferred Collection Mirrors</h4></div></div></div><p><a class="indexterm" id="idx0120"/><a class="indexterm" id="idx0922"/><a class="indexterm" id="idx0923"/><a class="indexterm" id="idx1326"/><a class="indexterm" id="idx1378"/><a class="indexterm" id="idx1511"/><a class="indexterm" id="idx1821"/><a class="indexterm" id="idx1860"/>Many software sources can be grouped into <span class="emphasis"><em>collections</em></span>, which tend to be mirrored together. An example is the official GNU software collection. A GNU mirror site probably has everything in the official GNU collection. The Gnu C Compiler Project has its own set of software and mirrors. There are older software collections, such as SunSITE, and newer ones, such as SourceForge.</p><p>Each collection is available from a list of mirror sites. OpenBSD maintains lists of these mirror sites in <span class="emphasis"><em>/usr/ports/infrastructure/templates/network.conf.template</em></span>. Never edit this file; it’s a core ports file, and upgrading changes it.</p><p>For example, here’s a list of mirrors for a smaller project, BerliOS:</p><a id="I_programlisting13_id467828"/><pre class="programlisting">…
MASTER_SITE_BERLIOS+=   \
        http://download.berlios.de/ \
        http://download2.berlios.de/ \
        http://spacehopper.org/mirrors/berlios/
…</pre><p>Several ports want to fetch BerliOS-related software from the main BerliOS download site. The OpenBSD port developers have identified three desirable mirrors, as listed in the variable <code class="literal">MASTER_SITE_BERLIOS</code>.</p><p>But suppose you have a BerliOS mirror much closer to you. Perhaps it’s not an official mirror, or you’ve managed to finagle access to a nonpublic mirror. It’s closer, it’s faster, and you would prefer to use it. OpenBSD looks at <span class="emphasis"><em>/usr/ports/infrastructure/db/network.conf</em></span> before the default mirror list. You could copy the default mirror list to this file and edit it, but then you would need to manually synchronize changes during upgrades. That’s work, and therefore morally questionable. Instead, add entries only in <span class="emphasis"><em>network.conf</em></span>, and include the default <span class="emphasis"><em>network.conf.template</em></span>.</p><p>Suppose you have a private BerliOS mirror at <span class="emphasis"><em><a class="ulink" href="http://www.blackhelicopters.org/berlios/" target="_top">http://www.blackhelicopters.org/berlios/</a></em></span>. You would create a <span class="emphasis"><em>network.conf</em></span> file like this:</p><a id="I_programlisting13_id467875"/><pre class="programlisting">MASTER_SITE_BERLIOS+=   \
        http://www.blackhelicopters.org/berlios/
.include "../templates/network.conf.template"</pre><p>The <code class="literal">+=</code> used in both <span class="emphasis"><em>network.conf</em></span> and <span class="emphasis"><em>network.conf.template</em></span> means “Add this value to variable such-and-such.” More desirable mirrors appear first in the list. This <span class="emphasis"><em>network.conf</em></span> entry adds the private mirror to the variable <code class="literal">MASTER_SITE_BERLIOS</code>, and then calls in <span class="emphasis"><em>network.conf.default</em></span>, which appends all of the other mirrors. The end result is that the BerliOS mirror list will contain four mirrors: your preferred mirror first and the default OpenBSD-approved mirrors later. If a file does not exist on a mirror, the port will try the other mirrors in order.</p><p><a class="indexterm" id="idx0809"/><a class="indexterm" id="idx1375"/><a class="indexterm" id="idx1512"/><a class="indexterm" id="idx2179"/>I used BerliOS as an example because it has a small mirror list, but the same applies to any other software collection that OpenBSD recognizes. Other collections available at this time are shown in <a class="xref" href="ch13.html#some_software_collections" title="Table 13-1. Table 13-1: Some Software Collections">Table 13-1</a>.</p><div class="table"><a id="some_software_collections"/><div class="table-title">Table 13-1. Table 13-1: Some Software Collections</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Collection</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Description</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_GNU</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Software from the GNU project</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_GCC</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Software from the GCC project</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_XCONTRIB</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Contributions to the X Window System</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_R5CONTRIB</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Older X Window System contributions</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_SUNSITE</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>A collection of Sun software</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_SOURCEFORGE</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Software hosted by SourceForge</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_SOURCEFORGE_JP</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Japanese SourceForge mirrors</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_GNOME</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Software from the Gnome project</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_PERL_CPAN</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>The biggest Perl module collection</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_TEX_CTAN</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Software for TeX typesetting</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_KDE</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Software related to KDE</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_SAVANNAH</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Software development hosted by the FSF</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_AFTERSTEP</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Software related to the AfterStep window manager</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_WINDOWMAKER</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Software related to the Window Maker window manager</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_FREEBSD_LOCAL</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Software distributed by the FreeBSD Project, but not included in FreeBSD</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_PACKETSTORM</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Security software part of the Packet Storm collection</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_APACHE</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Apache Foundation software</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_BERLIOS</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Parts of the BerliOS Linux project</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_MYSQL</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Software from the MySQL project (Oracle)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_PYPI</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Python software</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_RUBYGEMS</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Modules for Ruby</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_NPM</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>JavaScript packages</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><code class="literal">MASTER_SITE_ISC</code></p></td><td style="vertical-align: top; "><p>Software from the Internet Software Consortium</p></td></tr></tbody></table></div></div><p>If you have a Debian mirror in your university datacenter, list it in <span class="emphasis"><em>network.conf</em></span>. If it appears a second time, later in the list, because it’s listed in <span class="emphasis"><em>network.conf.template</em></span>, so what? Either the distfile is there, in which case you save time and bandwidth, or the <span class="emphasis"><em>distfile</em></span> isn’t there, in which case you waste 50 milliseconds checking the local mirror a second time.</p></div><div class="sect3" title="Fallback Mirrors"><div class="titlepage"><div><div><h4 class="title" id="fallback_mirrors">Fallback Mirrors</h4></div></div></div><p>OpenBSD supports two fallback mirrors. If all other distfile sources fail, you can check either the OpenBSD or FreeBSD mirrors for the file. Both OpenBSD and FreeBSD tend to mirror distfiles for active ports. This isn’t preferred, because if everyone did this, it would use bandwidth that the projects need for distributing their own software. But if you’re desperate, set <code class="literal">MASTER_SITE_OPENBSD</code> and/or <code class="literal">MASTER_SITE_FREEBSD</code> to <code class="literal">YES</code> in <span class="emphasis"><em>network.conf</em></span>.</p></div><div class="sect3" title="Primary Mirror"><div class="titlepage"><div><div><h4 class="title" id="primary_mirror">Primary Mirror</h4></div></div></div><p><a class="indexterm" id="idx1327"/><a class="indexterm" id="idx1379"/><a class="indexterm" id="idx1513"/><a class="indexterm" id="idx1822"/><a class="indexterm" id="idx1861"/>You can have the ports system check a particular site first for all distfiles, regardless of the download site listed in the port. Perhaps you have a local mirror where you’ve stuck a whole bunch of distfiles, or you automatically load distfiles from your ports-building machines to a central location. Define this site with the variable <code class="literal">MASTER_SITE_OVERRIDE</code> in <span class="emphasis"><em>network.conf</em></span>.</p><a id="I_programlisting13_id468558"/><pre class="programlisting">MASTER_SITE_OVERRIDE=ftp://ftp.mycompany.com/distfiles</pre><div class="note" title="Note"><h3 class="title"><a id="ch13note09"/>Note</h3><p>I’ve built local distfile mirrors many times, usually when starting a new job. I manage to update the mirror for about six months before some other task supersedes it and the mirror becomes obsolete, so I don’t generally recommend this practice. But if maintaining a local distfile mirror reduces your workload instead of increasing it, enjoy.</p></div></div></div><div class="sect2" title="Flavors"><div class="titlepage"><div><div><h3 class="title" id="flavors">Flavors</h3></div></div></div><p>Some ports can create multiple but slightly different packages through <span class="emphasis"><em>flavors</em></span>. The Apache 2.2 web server I keep dragging out as an example can be built with or without LDAP support, as can programs with optional X support. Shells can be built in dynamic or static versions. OpenBSD’s official packages are built with the most common choices, but these alternatives are reasonable and occasionally necessary.</p><p>To identify the flavors that a port supports, go to the port directory and run <span class="strong"><strong><code class="literal">make show=FLAVORS</code></strong></span>. Here’s how to check the flavors of the popular text editor Vim:</p><a id="I_programlisting13_id468609"/><pre class="programlisting"># <span class="strong"><strong>cd /usr/ports/editors/vim</strong></span>
# <span class="strong"><strong>make show=FLAVORS</strong></span>
huge gtk2 athena motif no_x11 perl python ruby</pre><p>You can guess what some of these eight flavors do, but how can you learn about the others? You can check the package’s description file for brief descriptions of each flavor. Here are the descriptions for the Vim flavors, from <span class="emphasis"><em>editors/vim/pkg/DESCR-main</em></span>:</p><a id="I_programlisting13_id468634"/><pre class="programlisting">…
Flavors:
        gtk2       - build using the Gtk+2 toolkit (default);
        motif      - build using the Motif toolkit;        athena     - build
using the Athena toolkit;
…</pre><p><a class="indexterm" id="idx0408"/><a class="indexterm" id="idx0871"/><a class="indexterm" id="idx1823"/>Motif? I remember Motif. And now I’m going to try really hard to forget it again. But if you want Motif support in your Vim version, go for it.</p><p>To fall back to my ongoing example, here are the flavors for Apache 2:</p><a id="I_programlisting13_id468674"/><pre class="programlisting"># <span class="strong"><strong>cd /usr/ports/www/apache-httpd</strong></span>
# <span class="strong"><strong>make show=FLAVORS</strong></span>
ldap</pre><p>I use LDAP to attach websites to my central authentication system. If I can get LDAP authentication on my web server, I want it.</p><div class="sect3" title="Building a Flavored Port"><div class="titlepage"><div><div><h4 class="title" id="building_a_flavored_port">Building a Flavored Port</h4></div></div></div><p>Define any desired flavors with the <code class="literal">$FLAVOR</code> environment variable, but not in your <span class="emphasis"><em>.profile</em></span> or <span class="emphasis"><em>.cshrc</em></span> file, as a port will not build if you request an unrecognized flavor. Define it when you build the port. For example, while still in the <span class="emphasis"><em>apache-httpd</em></span> directory, I run this command:</p><a id="I_programlisting13_id468724"/><pre class="programlisting"># <span class="strong"><strong>env FLAVOR="ldap" make package</strong></span>
===&gt;  Checking files for apache-httpd-2.2.20p1-ldap
&gt;&gt; Fetch http://www.reverse.net/pub/apache/httpd/httpd-2.2.20.tar.gz
…
===&gt; apache-httpd-2.2.20p1-ldap depends on: openldap-client-* - not found
===&gt;  Verifying install for openldap-client-* in databases/openldap
…</pre><p>By your defining the flavor on the command line, the port knows to check for the OpenLDAP client needed to build Apache. When the build finishes, you should get a package file with the flavor appended—in this case, <span class="emphasis"><em>apache-httpd-2.2.20p1-ldap.tgz</em></span>.</p></div><div class="sect3" title="Flavors and Dependencies"><div class="titlepage"><div><div><h4 class="title" id="flavors_and_dependencies">Flavors and Dependencies</h4></div></div></div><p>When you build a <span class="emphasis"><em>flavored port</em></span>, the flavor does not propagate to dependencies. You need to check the flavored port’s dependencies to see if they need flavoring as well. For example, my flavored Apache package calls in the OpenLDAP client, which has no flavors, but OpenLDAP calls in <code class="literal">cyrus-SASL</code>, and if I check that port, I see this:</p><a id="I_programlisting13_id468771"/><pre class="programlisting"># <span class="strong"><strong>cd /usr/ports/security/cyrus-sasl2</strong></span>
# <span class="strong"><strong>make show=FLAVORS</strong></span>
db4 ldap mysql pgsql sqlite3</pre><p>Cyrus SASL comes in LDAP flavor, but defining that I want Apache built in LDAP flavor doesn’t mean that <code class="literal">cyrus-SASL</code> will also be built with LDAP support. If I need LDAP support in this dependency, I must build it separately. I don’t need it for my environment, so I won’t bother, but check for potential issues like these when building your packages.</p><p><a class="indexterm" id="idx1824"/><a class="indexterm" id="idx1826"/><a class="indexterm" id="idx2262"/><a class="indexterm" id="idx2488"/>If you decide to rebuild a dependent port with a flavor, be sure to rebuild all the ports that depend on that port afterward. Be sure that your packages have correct dependencies using the targets <code class="literal">print-build-depends</code> and <code class="literal">print-run-depends</code>. Here, I see which ports I’ll need to build for my flavored Apache 2:</p><a id="I_programlisting13_id468841"/><pre class="programlisting"># <span class="strong"><strong>env FLAVOR="ldap" make print-build-depends</strong></span>
This port requires package(s) "metaauto-1.0 gperf-3.0.4 libiconv-1.14 gettext-0.18.1p1 gmake-3.82p1 groff-1.21p8 pcre-8.30 help2man-1.29p0 autoconf-2.65 autoconf-2.68 cyrus-sasl-2.1.25p3 icu4c-4.8.1.1p0 db-4.6.21v0 openldap-client-2.4.31 apr-1.4.6 apr-util-1.4.1-ldap" to build.</pre><p>I can check the flavors of each of these ports.</p></div><div class="sect3" title="Building Multiple Flavors"><div class="titlepage"><div><div><h4 class="title" id="building_multiple_flavors">Building Multiple Flavors</h4></div></div></div><p>You can build multiple flavors of one port on the same system. Each package filename includes the flavor, so you can have packages for both the Motif and GTK2 versions of Vim. Carefully inspect the dependencies to verify that each is built with the correct flavoring. For packages with flavored dependencies, I recommend removing every flavored dependency and rebuilding them all again, so that everything gets the correct flavor.</p></div><div class="sect3" title="Uninstalling and Reinstalling Flavored Ports"><div class="titlepage"><div><div><h4 class="title" id="uninstalling_and_reinstalling_flavored_p">Uninstalling and Reinstalling Flavored Ports</h4></div></div></div><p>Flavoring a package changes its name. I can’t run <code class="literal">pkg_delete apache-httpd</code> because it’s not installed. Query the system for the packages you’ve manually installed, and you’ll see this:</p><a id="I_programlisting13_id468893"/><pre class="programlisting"># <span class="strong"><strong>pkg_info -m</strong></span>
apache-httpd-2.2.20p1-ldap apache HTTP server
…</pre><p>When working with this package, you must specify the flavor.</p><a id="I_programlisting13_id468907"/><pre class="programlisting"># <span class="strong"><strong>pkg_delete apache-httpd-2.2.20p1-ldap</strong></span>
apache-httpd-2.2.20p1-ldap: ok
…</pre><p>Similarly, to reinstall a flavored package, specify the flavored package file.</p></div></div></div><div class="sect1" title="Subpackages"><div class="titlepage"><div><div><h2 class="title" id="subpackages" style="clear: both">Subpackages</h2></div></div></div><p>Some ports contain multiple wildly different packages. This isn’t like adding LDAP support to Apache or Motif support to Vim—those are changes to the existing package, not wildly different. Some ports create two completely different packages, such as a database client and the associated database server. I’ve drawn in OpenLDAP through this chapter’s examples, and both the OpenLDAP server and client come from the same port: <span class="emphasis"><em>databases/openldap</em></span>. Other applications might have plug-ins for accessing several different database engines. These are called <span class="emphasis"><em>subpackages</em></span> or <span class="emphasis"><em>multipackages</em></span>.</p><p><a class="indexterm" id="idx1416"/><a class="indexterm" id="idx1664"/><a class="indexterm" id="idx2232"/>Unlike flavors, OpenBSD provides all subpackages of a port. You can install both the server and client versions of OpenLDAP from official packages. When the port is built, all the subpackages are built. The package is split into subpackages at the package-bundling stage.</p><p>To see all the subpackages supported by a port, run the following command:</p><a id="I_programlisting13_id468988"/><pre class="programlisting"># <span class="strong"><strong>cd /usr/ports/databases/openldap</strong></span>
# <span class="strong"><strong>make show=MULTI_PACKAGES</strong></span>
-main -server</pre><p>This port has two subpackages: <code class="literal">openldap-main</code> and <code class="literal">openldap-server</code>.</p><p>How can you learn what each subpackage includes? As with flavors, you can check its description file, which is <span class="emphasis"><em>pkg/DESCR</em></span>. OpenLDAP includes <span class="emphasis"><em>pkg/DESCR-server</em></span> and <span class="emphasis"><em>pkg/DESCR-main</em></span>. Reading these shows that the <code class="literal">main</code> package is the client, as you would expect.</p><p>If you run <code class="literal">make install</code> in the port directory, you get the main version of the port—in this case, the OpenLDAP client. OpenLDAP clients outnumber the servers, so that’s also what you would expect. To build a different subpackage, set <code class="literal">SUBPACKAGE</code> in the environment on the command line, as you did for flavors.</p><a id="I_programlisting13_id469047"/><pre class="programlisting"># <span class="strong"><strong>env SUBPACKAGE="-server" make package</strong></span></pre><p>This builds the <code class="literal">-server</code> version. Be sure to include the leading dash, as specifying a nonexistent subpackage makes the build fail.</p></div><div class="sect1" title="Packages and rc.d Scripts"><div class="titlepage"><div><div><h2 class="title" id="packages_and_rc_d_scripts" style="clear: both">Packages and rc.d Scripts</h2></div></div></div><p><a class="xref" href="ch05.html" title="Chapter 5. The Boot Process">Chapter 5</a> covered how to have OpenBSD start packaged software, but let’s review it quickly. When you install a package that can be started at boot time, the package also installs a startup script in <span class="emphasis"><em>/etc/rc.d</em></span>. If I install the OpenLDAP server, the package installation will report:</p><a id="I_programlisting13_id469087"/><pre class="programlisting">…
The following new rcscripts were installed: /etc/rc.d/slapd</pre><p>To start the <code class="literal">slapd(8)</code> OpenLDAP server at boot, add the script name to the <code class="literal">pkg_scripts</code> variable in <span class="emphasis"><em>/etc/rc.conf.local</em></span>.</p><a id="I_programlisting13_id469106"/><pre class="programlisting">pkg_scripts="slapd"</pre><p>OpenBSD runs these scripts in order at boot, and in reverse order at shutdown.</p><p>To change a package’s command-line arguments from the default, add a <span class="emphasis"><em><code class="literal">command</code></em></span><code class="literal">_flags</code> variable to <span class="emphasis"><em>rc.conf.local</em></span>. Do not edit the startup script.</p><a id="I_programlisting13_id469130"/><pre class="programlisting">slapd_flags="-u _openldap -6 -l local0"</pre><p>You can now manage your add-on software in any way you need.</p><p>Now let’s move on to configuring OpenBSD’s integrated software, through the files in <span class="emphasis"><em>/etc</em></span>.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.id453650"><p><sup>[<a class="para" href="#id453650">34</a>] </sup>In the IT industry, “minimal education” means a willingness to dig in and figure it out, plus a few years of college or professional experience; access to programming textbooks or other educational materials; or a whole lot of youth, stubbornness, and motivation.</p></div><div class="footnote" epub:type="footnote" id="ftn.id366676"><p><sup>[<a class="para" href="#id366676">35</a>] </sup>No, it’s not. There is no <span class="emphasis"><em>ftp10.usa.openbsd.org</em></span>. Follow the instructions. Look at the mirror list and pick a mirror that actually exists and is close to you. Never blindly copy my examples!</p></div><div class="footnote" epub:type="footnote" id="ftn.id485212"><p><sup>[<a class="para" href="#id485212">36</a>] </sup>If you don’t see anything to worry about on any given server, you aren’t looking hard enough.</p></div><div class="footnote" epub:type="footnote" id="ftn.id431051"><p><sup>[<a class="para" href="#id431051">37</a>] </sup>This example exhausts my understanding of SQL. As long as I maintain my database ignorance, people won’t expect my help fixing their databases.</p></div><div class="footnote" epub:type="footnote" id="ftn.id370871"><p><sup>[<a class="para" href="#id370871">38</a>] </sup>Don’t laugh. It’s paid for.</p></div></div></section></body></html>