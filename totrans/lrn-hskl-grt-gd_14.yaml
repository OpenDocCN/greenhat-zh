- en: Chapter 14. For a Few Monads More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve seen how monads can be used to take values with contexts and apply them
    to functions, and how using `>>=` or `do` notation allows you to focus on the
    values themselves, while Haskell handles the context for you.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve met the `Maybe` monad and seen how it adds a context of possible failure
    to values. You’ve learned about the list monad and seen how it lets us easily
    introduce nondeterminism into our programs. You’ve also learned how to work in
    the `IO` monad, even before you knew what a monad was!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll cover a few other monads. You’ll see how they can make
    your programs clearer by letting you treat all sorts of values as monadic ones.
    Further exploration of monads will also solidify your intuition for recognizing
    and working with monads.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802698.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The monads that we’ll be exploring are all part of the `mtl` package.(A Haskell
    *package* is a collection of modules.) The `mtl` package comes with the Haskell
    Platform, so you probably already have it. To check if you do, type **`ghc-pkg
    list`** from the command line. This will show which Haskell packages you have
    installed, and one of them should be `mtl`, followed by a version number.
  prefs: []
  type: TYPE_NORMAL
- en: Writer? I Hardly Knew Her!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve loaded our gun with the `Maybe` monad, the list monad, and the `IO` monad.
    Now let’s put the `Writer` monad in the chamber and see what happens when we fire
    it!
  prefs: []
  type: TYPE_NORMAL
- en: Whereas the `Maybe` monad is for values with an added context of failure, and
    the list monad is for nondeterministic values, the `Writer` monad is for values
    that have another value attached that acts as a sort of log value. `Writer` allows
    us to do computations while making sure that all the log values are combined into
    one log value, which then is attached to the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we might want to equip our values with strings that explain what’s
    going on, probably for debugging purposes. Consider a function that takes a number
    of bandits in a gang and tells us if that’s a big gang. It’s a very simple function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what if instead of just giving us a `True` or `False` value, we want the
    function to also return a log string that says what it did? Well, we just make
    that string and return it alongside our `Bool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, instead of just returning a `Bool`, we return a tuple, where the first
    component of the tuple is the actual value and the second component is the string
    that accompanies that value. There’s some added context to our value now. Let’s
    give this a go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. `isBigGang` takes a normal value and returns a value with
    a context. As you’ve just seen, feeding it a normal value is not a problem. Now
    what if we already have a value that has a log string attached to it, such as
    `(3, "Smallish gang.")`, and we want to feed it to `isBigGang`? It seems like
    once again, we’re faced with this question: If we have a function that takes a
    normal value and returns a value with a context, how do we take a value with a
    context and feed it to the function?'
  prefs: []
  type: TYPE_NORMAL
- en: When we were exploring the `Maybe` monad in the previous chapter, we made a
    function `applyMaybe`. This function takes a `Maybe a` value and a function of
    type `a -> Maybe b`. We feed that `Maybe a` value into the function, even though
    the function takes a normal `a` instead of a `Maybe a`. It does this by minding
    the context that comes with `Maybe a` values, which is that they are values with
    possible failure. But inside the `a -> Maybe b` function, we can treat that value
    as just a normal value, because `applyMaybe` (which later becomes `>>=`) takes
    care of checking if it is a `Nothing` or a `Just` value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802700.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the same vein, let’s make a function that takes a value with an attached
    log—that is, an `(a, String)` value—and a function of type `a -> (b, String)`,
    and feeds that value into the function. We’ll call it `applyLog`. But an `(a,
    String)` value doesn’t carry with it a context of possible failure, but rather
    a context of an additional log value. So, `applyLog` will make sure that the log
    of the original value isn’t lost, but is joined together with the log of the value
    that results from the function. Here’s the implementation of `applyLog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When we have a value with a context that we want to feed to a function, we usually
    try to separate the actual value from the context, apply the function to the value,
    and then see whether the context is handled. In the `Maybe` monad, we checked
    if the value was a `Just x`, and if it was, we took that `x` and applied the function
    to it. In this case, it’s very easy to find the actual value, because we’re dealing
    with a pair where one component is the value and the other a log. So, first, we
    just take the value, which is `x`, and we apply the function `f` to it. We get
    a pair of `(y, newLog)`, where `y` is the new result and `newLog` is the new log.
    But if we returned that as the result, the old log value wouldn’t be included
    in the result, so we return a pair of `(y, log ++ newLog)`. We use `++` to append
    the new log to the old one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s `applyLog` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The results are similar to before, except that now the number of people in the
    gang has its accompanying log, which is included in the result log.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few more examples of using `applyLog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See how inside the lambda, `x` is just a normal string and not a tuple, and
    how `applyLog` takes care of appending the logs?
  prefs: []
  type: TYPE_NORMAL
- en: Monoids to the Rescue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right now, `applyLog` takes values of type `(a, String)`, but is there a reason
    that the log must be a `String`? It uses `++` to append the logs, so wouldn’t
    this work on any kind of list, not just a list of characters? Sure, it would.
    We can change its type to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now the log is a list. The type of values contained in the list must be the
    same for the original list as well as for the list that the function returns.
    Otherwise, we wouldn’t be able to use `++` to stick them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Would this work for bytestrings? There’s no reason it shouldn’t. However, the
    type we have now works only for lists. It seems as though we would need to make
    a separate `applyLog` for bytestrings. But wait! Both lists and bytestrings are
    monoids. As such, they are both instances of the `Monoid` type class, which means
    that they implement the `mappend` function. And for both lists and bytestrings,
    `mappend` is for appending. Watch it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool! Now our `applyLog` can work for any monoid. We need to change the type
    to reflect this, as well as the implementation, because we need to change `++`
    to `mappend`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the accompanying value can now be any monoid value, we no longer need
    to think of the tuple as a value and a log; now we can think of it as a value
    with an accompanying monoid value. For instance, we can have a tuple that has
    an item name and an item price as the monoid value. We just use the `Sum newtype`
    to make sure that the prices are added as we operate with the items. Here’s a
    function that adds drink to some cowboy food order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We use strings to represent foods and an `Int` in a `Sum newtype` wrapper to
    keep track of how many cents something costs. As a reminder, doing `mappend` with
    `Sum` results in the wrapped values being added together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addDrink` function is pretty simple. If we’re eating beans, it returns
    `"milk"` along with `Sum 25`, so 25 cents wrapped in `Sum`. If we’re eating jerky,
    we drink whiskey. And if we’re eating anything else, we drink beer. Just normally
    applying this function to a food wouldn’t be terribly interesting right now. But
    using `applyLog` to feed a food that comes with a price itself into this function
    is worth a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Milk costs 25 cents, but if we have it with beans that cost 25 cents, we’ll
    end up paying 35 cents.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s clear how the attached value doesn’t always need to be a log. It can
    be any monoid value, and how two such values are combined depends on the monoid.
    When we were doing logs, they were appended, but now, the numbers are being added
    up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the value that `addDrink` returns is a tuple of type `(Food, Price)`,
    we can feed that result to `addDrink` again, so that it tells us what we should
    drink along with our meal and how much that will cost us. Let’s give it a shot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Adding a drink to some dog meat results in a beer and an additional 30 cents,
    so `("beer", Sum 35)`. And if we use `applyLog` to feed that to `addDrink`, we
    get another beer, and the result is `("beer", Sum 65)`.
  prefs: []
  type: TYPE_NORMAL
- en: The Writer Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve seen how a value with an attached monoid acts like a monadic
    value, let’s examine the `Monad` instance for types of such values. The `Control.Monad.Writer`
    module exports the `Writer w a` type along with its `Monad` instance and some
    useful functions for dealing with values of this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To attach a monoid to a value, we just need to put them together in a tuple.
    The `Writer w a` type is just a `newtype` wrapper for this. Its definition is
    very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It’s wrapped in a `newtype` so that it can be made an instance of `Monad` and
    so that its type is separate from a normal tuple. The `a` type parameter represents
    the type of the value, and the `w` type parameter represents the type of the attached
    monoid value.
  prefs: []
  type: TYPE_NORMAL
- en: The `Control.Monad.Writer` module reserves the right to change the way it internally
    implements the `Writer w a` type, so it doesn’t export the `Writer` value constructor.
    However, it does export the `writer` function, which does the same thing that
    the `Writer` constructor would do. Use it when you want to take a tuple and make
    a `Writer` value from it.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `Writer` value constructor is not exported, you also can’t pattern
    match against it. Instead, you need to use the `runWriter` function, which takes
    a tuple that’s wrapped in a `Writer newtype` and unwraps it, returning a simple
    tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its `Monad` instance is defined like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, let’s examine `>>=`. Its implementation is essentially the same as `applyLog`,
    only now that our tuple is wrapped in the `Writer newtype`, we need to unwrap
    it when pattern matching. We take the value `x` and apply the function `f` to
    it. This gives us gives us a `Writer w a` value, and we use a `let` expression
    to pattern match on it. We present `y` as the new result and use `mappend` to
    combine the old monoid value with the new one. We pack that up with the result
    value in a tuple and then wrap that with the `Writer` constructor so that our
    result is a `Writer` value, instead of just an unwrapped tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802702.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, what about `return`? It must take a value and put it in a default minimal
    context that still presents that value as the result. What would such a context
    be for `Writer` values? If we want the accompanying monoid value to affect other
    monoid values as little as possible, it makes sense to use `mempty`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mempty` is used to present identity monoid values, such as `""` and `Sum 0`
    and empty bytestrings. Whenever we use `mappend` between `mempty` and some other
    monoid value, the result is that other monoid value. So, if we use `return` to
    make a `Writer` value and then use `>>=` to feed that value to a function, the
    resulting monoid value will be only what the function returns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use `return` on the number `3` a bunch of times, pairing it with a different
    monoid each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Because `Writer` doesn’t have a `Show` instance, we used `runWriter` to convert
    our `Writer` values to normal tuples that can be shown. For `String`, the monoid
    value is the empty string. With `Sum`, it’s `0`, because if we add 0 to something,
    that something stays the same. For `Product`, the identity is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Writer` instance doesn’t feature an implementation for `fail`, so if a
    pattern match fails in `do` notation, `error` is called.
  prefs: []
  type: TYPE_NORMAL
- en: Using do Notation with Writer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a `Monad` instance, we’re free to use `do` notation for `Writer`
    values. It’s handy when we have several `Writer` values and want to do stuff with
    them. As with other monads, we can treat them as normal values, and the context
    gets taken care of for us. In this case, all the monoid values that come attached
    are `mappend`ed, and so are reflected in the final result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example of using `do` notation with `Writer` to multiply two
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`logNumber` takes a number and makes a `Writer` value out of it. Notice how
    we used the `writer` function to construct a `Writer` value, instead of directly
    using the `Writer` value constructor. For the monoid, we use a list of strings,
    and we equip the number with a singleton list that just says that we have that
    number. `multWithLog` is a `Writer` value that multiplies `3` and `5` and makes
    sure that their attached logs are included in the final log. We use `return` to
    present `a*b` as the result. Because `return` just takes something and puts it
    in a minimal context, we can be sure that it won’t add anything to the log.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we see if we run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, we just want some monoid value to be included at some particular
    point. For this, the `tell` function is useful. It’s part of the `MonadWriter`
    type class. In the case of `Writer`, it takes a monoid value, like `["This is
    going on"]`, and creates a `Writer` value that presents the dummy value `()` as
    its result, but has the desired monoid value attached. When we have a monadic
    value that has `()` as its result, we don’t bind it to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s `multWithLog` with some extra reporting included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s important that `return (a*b)` is the last line, because the result of
    the last line in a `do` expression is the result of the whole `do` expression.
    Had we put `tell` as the last line, the result of this `do` expression would be
    `()`. We would lose the result of the multiplication. However, the log would be
    the same. Here’s this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Adding Logging to Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Euclid’s algorithm takes two numbers and computes their greatest common divisor—that
    is, the biggest number that still divides both of them. Haskell already features
    the `gcd` function, which does exactly this, but let’s implement our own function
    and then equip it with logging capabilities. Here’s the normal algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm is very simple. First, it checks if the second number is 0\. If
    it is, then the result is the first number. If it isn’t, then the result is the
    greatest common divisor of the second number and the remainder of dividing the
    first number with the second one.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we want to know what the greatest common divisor of 8 and
    3 is, we just follow this algorithm. Because 3 isn’t 0, we need to find the greatest
    common divisor of 3 and 2 (if we divide 8 by 3, the remainder is 2). Next, we
    find the greatest common divisor of 3 and 2\. 2 still isn’t 0, so now we have
    have 2 and 1\. The second number isn’t 0, so we run the algorithm again for 1
    and 0, as dividing 2 by 1 gives us a remainder of 0\. And finally, because the
    second number is now 0, the final result is 1\. Let’s see if our code agrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It does. Very good! Now, we want to equip our result with a context, and the
    context will be a monoid value that acts as a log. As before, we’ll use a list
    of strings as our monoid. So, this should be the type of our new `gcd''` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'All that’s left now is to equip our function with log values. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes two normal `Int` values and returns a `Writer [String]
    Int`—that is, an `Int` that has a log context. In the case where `b` is `0`, instead
    of just giving `a` as the result, we use a `do` expression to put together a `Writer`
    value as a result. First, we use `tell` to report that we’re finished, and then
    we use `return` to present `a` as the result of the `do` expression. Instead of
    this `do` expression, we could have also written this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: However, I think the `do` expression is easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the case when `b` isn’t `0`. In this case, we log that we’re using
    `mod` to figure out the remainder of dividing `a` and `b`. Then the second line
    of the `do` expression just recursively calls `gcd'`. Remember that `gcd'` now
    ultimately returns a `Writer` value, so it’s perfectly valid that ``gcd' b (a
    `mod` b)`` is a line in a `do` expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out our new `gcd''`. Its result is a `Writer [String] Int` value,
    and if we unwrap that from its `newtype`, we get a tuple. The first part of the
    tuple is the result. Let’s see if it’s okay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Good! Now what about the log? Because the log is a list of strings, let’s use
    `mapM_ putStrLn` to print those strings on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: I think it’s awesome how we were able to change our ordinary algorithm to one
    that reports what it does as it goes along. And we did this just by changing normal
    values to monadic values. We let the implementation of `>>=` for `Writer` take
    care of the logs for us.
  prefs: []
  type: TYPE_NORMAL
- en: You can add a logging mechanism to pretty much any function. You just replace
    normal values with `Writer` values where you want and change normal function application
    to `>>=` (or `do` expressions if it increases readability).
  prefs: []
  type: TYPE_NORMAL
- en: Inefficient List Construction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using the `Writer` monad, you need to be careful which monoid to use, because
    using lists can sometimes turn out to be very slow. Lists use `++` for `mappend`,
    and using `++` to add something to the end of a list is slow if that list is really
    long.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `gcd''` function, the logging is fast because the list appending ends
    up looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A list is a data structure that’s constructed from left to right. This is efficient,
    because we first fully construct the left part of a list and only then add a longer
    list on the right. But if we’re not careful, using the `Writer` monad can produce
    list appending that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802704.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This associates to the left instead of to the right. It’s inefficient because
    every time it wants to add the right part to the left part, it must construct
    the left part all the way from the beginning!
  prefs: []
  type: TYPE_NORMAL
- en: The following function works like `gcd'`, but it logs stuff in reverse. First,
    it produces the log for the rest of the procedure, and then it adds the current
    step to the end of the log.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It does the recursion first and binds its resulting value to `result`. Then
    it adds the current step to the log, but the current step goes at the end of the
    log that was produced by the recursion. At the end, it presents the result of
    the recursion as the final result. Here it is in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This function is inefficient because it ends up associating the use of `++`
    to the left instead of to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Because lists can sometimes be inefficient when repeatedly appended in this
    manner, it’s best to use a data structure that always supports efficient appending.
    One such data structure is the difference list.
  prefs: []
  type: TYPE_NORMAL
- en: Using Difference Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While similar to a normal list, a *difference list* is actually a function that
    takes a list and prepends another list to it. For example, the difference list
    equivalent of a list like `[1,2,3]` is the function `\xs -> [1,2,3] ++ xs`. A
    normal empty list is `[]`, whereas an empty difference list is the function `\xs
    -> [] ++ xs`.
  prefs: []
  type: TYPE_NORMAL
- en: Difference lists support efficient appending. When we append two normal lists
    with `++`, the code must walk all the way to the end of the list on the left of
    `++`, and then stick the other one there. But what if we take the difference list
    approach and represent our lists as functions?
  prefs: []
  type: TYPE_NORMAL
- en: 'Appending two difference lists can be done like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that `f` and `g` are functions that take lists and prepend something
    to them. For instance, if `f` is the function `("dog"++)` (just another way of
    writing `\xs -> "dog" ++ xs`) and `g` is the function `("meat"++)`, then ``f `append`
    g`` makes a new function that’s equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We’ve appended two difference lists just by making a new function that first
    applies one difference list to some list and then to the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make a `newtype` wrapper for difference lists so that we can easily give
    them monoid instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The type that we wrap is `[a] -> [a]`, because a difference list is just a
    function that takes a list and returns another list. Converting normal lists to
    difference lists and vice versa is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To make a normal list into a difference list, we just do what we did before
    and make it a function that prepends it to another list. Because a difference
    list is a function that prepends something to another list, if we just want that
    something, we apply the function to an empty list!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the `Monoid` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how for lists, `mempty` is just the `id` function, and `mappend` is
    actually just function composition. Let’s see if this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Tip-top! Now we can increase the efficiency of our `gcdReverse` function by
    making it use difference lists instead of normal lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We just needed to change the type of the monoid from `[String]` to `DiffList
    String` and then when using `tell`, convert our normal lists into difference lists
    with `toDiffList`. Let’s see if the log gets assembled properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We do `gcdReverse 110 34`, then use `runWriter` to unwrap it from the `newtype`,
    then apply `snd` to that to just get the log, then apply `fromDiffList` to convert
    it to a normal list, and, finally, print its entries to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get a feel for just how much difference lists may improve your performance,
    consider the following function. It just counts down from some number to zero
    but produces its log in reverse, like `gcdReverse`, so that the numbers in the
    log will actually be counted up.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If we give it `0`, it just logs that value. For any other number, it first counts
    down its predecessor to `0`, and then appends that number to the log. So, if we
    apply `finalCountDown` to `100`, the string `"100"` will come last in the log.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you load this function in GHCi and apply it to a big number, like `500000`,
    you’ll see that it quickly starts counting from `0` onward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you change it to use normal lists instead of difference lists,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'and then tell GHCi to start counting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: you’ll see that the counting is really slow.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is not the proper and scientific way to test the speed of your
    programs. However, we were able to see that, in this case, using difference lists
    starts producing results immediately, whereas normal lists take forever.
  prefs: []
  type: TYPE_NORMAL
- en: Oh, by the way, the song “Final Countdown” by Europe is now stuck in your head.
    Enjoy!
  prefs: []
  type: TYPE_NORMAL
- en: Reader? Ugh, Not This Joke Again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 11](ch11.html "Chapter 11. Applicative Functors"), you saw that
    the function type `(->) r` is an instance of `Functor`. Mapping a function `f`
    over a function `g` will make a function that takes the same thing as `g`, applies
    `g` to it, and then applies `f` to that result. So basically, we’re making a new
    function that’s like `g`, but before returning its result, `f` is applied to that
    result as well. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802706.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ve also seen that functions are applicative functors. They allow us to
    operate on the eventual results of functions as if we already had their results.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The expression `(+) <$> (*2) <*> (+10)` makes a function that takes a number,
    gives that number to `(*2)` and `(+10)`, and then adds together the results. For
    instance, if we apply this function to `3`, it applies both `(*2)` and `(+10)`
    to `3`, giving `6` and `13`. Then it calls `(+)` with `6` and `13`, and the result
    is `19`.
  prefs: []
  type: TYPE_NORMAL
- en: Functions As Monads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not only is the function type `(->) r` a functor and an applicative functor,
    but it’s also a monad. Just like other monadic values that you’ve met so far,
    a function can also be considered a value with a context. The context for functions
    is that that value is not present yet and that we need to apply that function
    to something in order to get its result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because you’re already acquainted with how functions work as functors and applicative
    functors, let’s dive right in and see what their `Monad` instance looks like.
    It’s located in `Control.Monad.Instances`, and it goes a little something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You’ve seen how `pure` is implemented for functions, and `return` is pretty
    much the same thing as `pure`. It takes a value and puts it in a minimal context
    that always has that value as its result. And the only way to make a function
    that always has a certain value as its result is to make it completely ignore
    its parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation for `>>=` may seem a bit cryptic, but it’s really not all
    that complicated. When we use `>>=` to feed a monadic value to a function, the
    result is always a monadic value. So, in this case, when we feed a function to
    another function, the result is a function as well. That’s why the result starts
    off as a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: All of the implementations of `>>=` so far somehow isolated the result from
    the monadic value and then applied the function `f` to that result. The same thing
    happens here. To get the result from a function, we need to apply it to something,
    which is why we use `(h w)` here, and then we apply `f` to that. `f` returns a
    monadic value, which is a function in our case, so we apply it to `w` as well.
  prefs: []
  type: TYPE_NORMAL
- en: The Reader Monad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you don’t get how `>>=` works at this point, don’t worry. After a few examples,
    you’ll see that this is a really simple monad. Here’s a `do` expression that utilizes
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same thing as the applicative expression that we wrote earlier,
    but now it relies on functions being monads. A `do` expression always results
    in a monadic value, and this one is no different. The result of this monadic value
    is a function. It takes a number, then `(*2)` is applied to that number, and the
    result becomes `a`. `(+10)` is applied to the same number that `(*2)` was applied
    to, and the result becomes `b`. `return`, as in other monads, doesn’t have any
    effect but to make a monadic value that presents some result. This presents `a+b`
    as the result of this function. If we test it, we get the same result as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `(*2)` and `(+10)` are applied to the number `3` in this case. `return
    (a+b)` does as well, but it ignores that value and always presents `a+b` as the
    result. For this reason, the function monad is also called the *reader monad*.
    All the functions read from a common source. To make this even clearer, we can
    rewrite `addStuff` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You see that the reader monad allows us to treat functions as values with a
    context. We can act as if we already know what the functions will return. It does
    this by gluing functions together into one function and then giving that function’s
    parameter to all of the functions that compose it. So, if we have a lot of functions
    that are all just missing one parameter, and they will eventually be applied to
    the same thing, we can use the reader monad to sort of extract their future results,
    and the `>>=` implementation will make sure that it all works out.
  prefs: []
  type: TYPE_NORMAL
- en: Tasteful Stateful Computations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Haskell is a pure language, and because of that, our programs are made of functions
    that can’t change any global state or variables; they can only do some computations
    and return the results. This restriction actually makes it easier to think about
    our programs, as it frees us from worrying what every variable’s value is at some
    point in time.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802708.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, some problems are inherently stateful, in that they rely on some state
    that changes over time. While this isn’t a problem for Haskell, these computations
    can be a bit tedious to model. That’s why Haskell features the `State` monad,
    which makes dealing with stateful problems a breeze, while still keeping everything
    nice and pure.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we were looking at random numbers back in [Chapter 9](ch09.html "Chapter 9. More
    Input and More Output"), we dealt with functions that took a random generator
    as a parameter and returned a random number and a new random generator. If we
    wanted to generate several random numbers, we always needed to use the random
    generator that a previous function returned along with its result. For example,
    to create a function that takes a `StdGen` and tosses a coin three times based
    on that generator, we did this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This function takes a generator `gen`, and then `random gen` returns a `Bool`
    value along with a new generator. To throw the second coin, we use the new generator,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In most other languages, we wouldn’t need to return a new generator along with
    a random number. We could just modify the existing one! But since Haskell is pure,
    we can’t do that, so we need to take some state, make a result from it and a new
    state, and then use that new state to generate new results.
  prefs: []
  type: TYPE_NORMAL
- en: You would think that to avoid manually dealing with stateful computations in
    this way, we would need to give up the purity of Haskell. Well, we don’t have
    to, since there’s a special little monad called the `State` monad that handles
    all this state business for us, without impacting any of the purity that makes
    Haskell programming so cool.
  prefs: []
  type: TYPE_NORMAL
- en: Stateful Computations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To help demonstrate stateful computations, let’s go ahead and give them a type.
    We’ll say that a stateful computation is a function that takes some state and
    returns a value along with some new state. That function has the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`s` is the type of the state, and `a` is the result of the stateful computations.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assignment in most other languages could be thought of as a stateful computation.
    For instance, when we do `x = 5` in an imperative language, it will usually assign
    the value `5` to the variable `x`, and it will also have the value `5` as an expression.
    If you look at that functionally, it’s like a function that takes a state (that
    is, all the variables that have been assigned previously) and returns a result
    (in this case, `5`) and a new state, which would be all the previous variable
    mappings plus the newly assigned variable.
  prefs: []
  type: TYPE_NORMAL
- en: This stateful computation—a function that takes a state and returns a result
    and a new state—can be thought of as a value with a context as well. The actual
    value is the result, whereas the context is that we must provide some initial
    state to actually get that result, and that apart from getting a result, we also
    get a new state.
  prefs: []
  type: TYPE_NORMAL
- en: Stacks and Stones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Say we want to model a stack. A *stack* is a data structure that contains a
    bunch of elements and supports exactly two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pushing* an element to the stack, which adds an element onto the top of the
    stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Popping* an element off the stack, which removes the topmost element from
    the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll use a list to represent our stack, with the head of the list acting as
    the top of the stack. To help us with our task, we’ll make two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pop` will take a stack, pop one item, and return that item as the result.
    It will also return a new stack, without the popped item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push` will take an item and a stack and then push that item onto the stack.
    It will return `()` as its result, along with a new stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the functions in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We used `()` as the result when pushing to the stack because pushing an item
    onto the stack doesn’t have any important result value—its main job is to change
    the stack. If we apply only the first parameter of `push`, we get a stateful computation.
    `pop` is already a stateful computation because of its type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a small piece of code to simulate a stack using these functions.
    We’ll take a stack, push `3` to it, and then pop two items, just for kicks. Here
    it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We take a `stack`, and then we do `push 1 stack`, which results in a tuple.
    The first part of the tuple is a `()`, and the second is a new stack, which we
    call `newStack1`. Then we pop a number from `newStack1`, which results in a number
    `a` (which is the `3`) that we pushed and a new stack, which we call `newStack2`.
    Then we pop a number off `newStack2`, and we get a number that’s `b` and a `newStack3`.
    We return a tuple with that number and that stack. Let’s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The result is `5`, and the new stack is `[8,2,1]`. Notice how `stackManip` is
    itself a stateful computation. We’ve taken a bunch of stateful computations and
    sort of glued them together. Hmm, sounds familiar.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code for `stackManip` is kind of tedious, since we’re manually
    giving the state to every stateful computation and storing it and then giving
    it to the next one. Wouldn’t it be cooler if, instead of giving the stack manually
    to each function, we could write something like the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Well, using the `State` monad will allow us to do exactly that. With it, we
    will be able to take stateful computations like these and use them without needing
    to manage the state manually.
  prefs: []
  type: TYPE_NORMAL
- en: The State Monad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Control.Monad.State` module provides a `newtype` that wraps stateful computations.
    Here’s its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: A `State s a` is a stateful computation that manipulates a state of type `s`
    and has a result of type `a`.
  prefs: []
  type: TYPE_NORMAL
- en: Much like `Control.Monad.Writer`, `Control.Monad.State` doesn’t export its value
    constructor. If you want to take a stateful computation and wrap it in the `State
    newtype`, use the `state` function, which does the same thing that the `State`
    constructor would do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve seen what stateful computations are about and how they can
    even be thought of as values with contexts, let’s check out their `Monad` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Our aim with `return` is to take a value and make a stateful computation that
    always has that value as its result. That’s why we just make a lambda `\s -> (x,
    s)`. We always present `x` as the result of the stateful computation, and the
    state is kept unchanged, because `return` must put a value in a minimal context.
    So `return` will make a stateful computation that presents a certain value as
    the result and keeps the state unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802710.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What about `>>=`? Well, the result of feeding a stateful computation to a function
    with `>>=` must be a stateful computation, right? So, we start of with the `State
    newtype` wrapper, and then we type out a lambda. This lambda will be our new stateful
    computation. But what goes on in it? Well, we need to somehow extract the result
    value from the first stateful computation. Because we’re in a stateful computation
    right now, we can give the stateful computation `h` our current state `s`, which
    results in a pair of the result and a new state: `(a, newState)`.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, every time we implemented `>>=`, once we had extracted just the result
    from the monadic value, we applied the function `f` to it to get the new monadic
    value. In `Writer`, after doing that and getting the new monadic value, we still
    need to make sure that the context is taken care of by `mappend`ing the old monoid
    value with the new one. Here, we do `f a`, and we get a new stateful computation
    `g`. Now that we have a new stateful computation and a new state (which goes by
    the name of `newState`), we just apply that stateful computation `g` to the `newState`.
    The result is a tuple of the final result and final state!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, with `>>=`, we kind of glue two stateful computations together. The second
    computation is hidden inside a function that takes the previous computation’s
    result. Because `pop` and `push` are already stateful computations, it’s easy
    to wrap them into a `State` wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we used the `state` function to wrap a function into the `State newtype`
    instead of using the `State` value constructor directly.
  prefs: []
  type: TYPE_NORMAL
- en: '`pop` is already a stateful computation, and `push` takes an `Int` and returns
    a stateful computation. Now we can rewrite our previous example of pushing `3`
    onto the stack and then popping two numbers off, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'See how we’ve glued a push and two pops into one stateful computation? When
    we unwrap it from its `newtype` wrapper, we get a function to which we can provide
    some initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We didn’t need to bind the second `pop` to `a`, because we didn’t use that
    `a` at all. So, we could have written it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty cool. But what if we want to do something a little more complicated?
    Let’s say we want to pop one number off the stack, and if that number is `5`,
    we’ll just push it back on the stack and stop. But if the number *isn’t* `5`,
    we’ll push `3` and `8` back on instead. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite straightforward. Let’s run it with an initial stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that `do` expressions result in monadic values, and with the `State`
    monad, a single `do` expression is also a stateful function. Because `stackManip`
    and `stackStuff` are ordinary stateful computations, we can glue them together
    to produce further stateful computations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If the result of `stackManip` on the current stack is `100`, we run `stackStuff`;
    otherwise, we do nothing. `return ()` just keeps the state as it is and does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting and Setting State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Control.Monad.State` module provides a type class called `MonadState`,
    which features two pretty useful functions: `get` and `put`. For `State`, the
    `get` function is implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: It just takes the current state and presents it as the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `put` function takes some state and makes a stateful function that replaces
    the current state with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'So, with these, we can see what the current stack is or we can replace it with
    a whole other stack, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use `get` and `put` to implement `pop` and `push`. Here’s `pop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We use `get` to get the whole stack, and then we use `put` to make everything
    but the top element the new state. Then we use `return` to present `x` as the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s `push` implemented with `get` and `put`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We just use `get` to get the current stack and use `put` to make the set the
    new state as our stack, with the element `x` on top.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth examining what the type of `>>=` would be if it worked only for
    `State` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'See how the type of the state `s` stays the same, but the type of the result
    can change from `a` to `b`? This means that we can glue together several stateful
    computations whose results are of different types, but the type of the state must
    stay the same. Now why is that? Well, for instance, for `Maybe`, `>>=` has this
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: It makes sense that the monad itself, `Maybe`, doesn’t change. It wouldn’t make
    sense to use `>>=` between two different monads. Well, for the `State` monad,
    the monad is actually `State s`, so if that `s` were different, we would be using
    `>>=` between two different monads.
  prefs: []
  type: TYPE_NORMAL
- en: Randomness and the State Monad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of this section, we talked about how generating random numbers
    can sometimes be awkward. Every random function takes a generator and returns
    a random number along with a new generator, which must then be used instead of
    the old one if we want to generate another random number. The `State` monad makes
    dealing with this a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `random` function from `System.Random` has the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This means it takes a random generator and produces a random number along with
    a new generator. We can see that it’s a stateful computation, so we can wrap it
    in the `State newtype` constructor by using the `state` function, and then use
    it as a monadic value so that passing the state is handled for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now if we want to throw three coins (`True` is tails, and `False` is heads),
    we just do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '`threeCoins` is now a stateful computation, and after taking an initial random
    generator, it passes that generator to the first `randomSt`, which produces a
    number and a new generator, which is passed to the next one, and so on. We use
    `return (a, b, c)` to present `(a, b, c)` as the result without changing the most
    recent generator. Let’s give this a go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Now doing things that require some state to be saved in between steps just became
    much less of a hassle!
  prefs: []
  type: TYPE_NORMAL
- en: Error Error on the Wall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You know by now that `Maybe` is used to add a context of possible failure to
    values. A value can be a `Just something` or a `Nothing`. However useful it may
    be, when we have a `Nothing`, all we know is that there was some sort of failure—there’s
    no way to cram more information in there telling us what kind of failure it was.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Either e a` type also allows us to incorporate a context of possible failure
    into our values. It also lets us attach values to the failure, so they can describe
    what went wrong or provide other useful information regarding the failure. An
    `Either e a` value can either be a `Right` value, signifying the right answer
    and a success, or it can be a `Left` value, signifying failure. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty much just an enhanced `Maybe`, so it makes sense for it to be
    a monad. It can also be viewed as a value with an added context of possible failure,
    but now there’s a value attached when there’s an error as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its `Monad` instance is similar to that of `Maybe`, and it can be found in
    `Control.Monad.Error`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '`return`, as always, takes a value and puts it in a default minimal context.
    It wraps our value in the `Right` constructor because we’re using `Right` to represent
    a successful computation where a result is present. This is a lot like `return`
    for `Maybe`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `>>=` examines two possible cases: a `Left` and a `Right`. In the case
    of a `Right`, the function `f` is applied to the value inside it, similar to the
    case of a `Just` where the function is just applied to its contents. In the case
    of an error, the `Left` value is kept, along with its contents, which describe
    the failure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Monad` instance for `Either e` has an additional requirement. The type
    of the value contained in a `Left`—the one that’s indexed by the `e` type parameter—must
    be an instance of the `Error` type class. The `Error` type class is for types
    whose values can act like error messages. It defines the `strMsg` function, which
    takes an error in the form of a string and returns such a value. A good example
    of an `Error` instance is the `String` type! In the case of `String`, the `strMsg`
    function just returns the string that it got:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: But since we usually use `String` to describe the error when using `Either`,
    we don’t need to worry about this too much. When a pattern match fails in `do`
    notation, a `Left` value is used to signify this failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: When we use `>>=` to feed a `Left` value to a function, the function is ignored
    and an identical `Left` value is returned. When we feed a `Right` value to a function,
    the function is applied to what’s on the inside, but in this case, that function
    produced a `Left` value anyway!
  prefs: []
  type: TYPE_NORMAL
- en: When we try to feed a `Right` value to a function that also succeeds, we’re
    tripped up by a peculiar type error. Hmmm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Haskell says that it doesn’t know which type to choose for the `e` part of
    our `Either e a`-typed value, even though we’re just printing the `Right` part.
    This is due to the `Error e` constraint on the `Monad` instance. So, if you get
    type errors like this one when using `Either` as a monad, just add an explicit
    type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: And now it works!
  prefs: []
  type: TYPE_NORMAL
- en: Other than this little hang-up, using the error monad is very similar to using
    `Maybe` as a monad.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapter, we used the monadic aspects of `Maybe` to simulate
    birds landing on the balancing pole of a tightrope walker. As an exercise, you
    can rewrite that with the error monad so that when the tightrope walker slips
    and falls, you remember how many birds were on each side of the pole when he fell.
  prefs: []
  type: TYPE_NORMAL
- en: Some Useful Monadic Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’re going to explore a few functions that operate on monadic
    values or return monadic values as their results (or both!). Such functions are
    usually referred to as *monadic functions*. While some of them will be brand new,
    others will be monadic counterparts of functions that you already know, like `filter`
    and `foldl`. Here, we’ll look at `liftM`, `join`, `filterM`, and `foldM`.
  prefs: []
  type: TYPE_NORMAL
- en: liftM and Friends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we started our journey to the top of Monad Mountain, we first looked at
    *functors*, which are for things that can be mapped over. Then we covered improved
    functors called *applicative functors*, which allow us to apply normal functions
    between several applicative values as well as to take a normal value and put it
    in some default context. Finally, we introduced *monads* as improved applicative
    functors, which add the ability for these values with context to somehow be fed
    into normal functions.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802712.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, every monad is an applicative functor, and every applicative functor is
    a functor. The `Applicative` type class has a class constraint such that our type
    must be an instance of `Functor` before we can make it an instance of `Applicative`.
    `Monad` should have the same constraint for `Applicative`, as every monad is an
    applicative functor, but it doesn’t, because the `Monad` type class was introduced
    to Haskell long before `Applicative`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But even though every monad is a functor, we don’t need to rely on it having
    a `Functor` instance because of the `liftM` function. `liftM` takes a function
    and a monadic value and maps the function over the monadic value. So it’s pretty
    much the same thing as `fmap`! This is `liftM`’s type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the type of `fmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `Functor` and `Monad` instances for a type obey the functor and monad
    laws, these two amount to the same thing (and all the monads that we’ve met so
    far obey both). This is kind of like `pure` and `return` do the same thing, but
    one has an `Applicative` class constraint, whereas the other has a `Monad` constraint.
    Let’s try out `liftM`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: You already know quite well how `fmap` works with `Maybe` values. And `liftM`
    does the same thing. For `Writer` values, the function is mapped over the first
    component of the tuple, which is the result. Running `fmap` or `liftM` over a
    stateful computation results in another stateful computation, but its eventual
    result is modified by the supplied function. Had we not mapped `(+100)` over `pop`
    before running it, it would have returned `(1, [2,3,4])`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how `liftM` is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with `do` notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We feed the monadic value `m` into the function, and then we apply the function
    `f` to its result before putting it back into a default context. Because of the
    monad laws, this is guaranteed not to change the context; it changes only the
    result that the monadic value presents.
  prefs: []
  type: TYPE_NORMAL
- en: You see that `liftM` is implemented without referencing the `Functor` type class
    at all. This means that we can implement `fmap` (or `liftM`—whatever you want
    to call it) just by using the goodies that monads offer us. Because of this, we
    can conclude that monads are at least as strong as functors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Applicative` type class allows us to apply functions between values with
    contexts as if they were normal values, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this applicative style makes things pretty easy. `<$>` is just `fmap`,
    and `<*>` is a function from the `Applicative` type class that has the following
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: So it’s kind of like `fmap`, but the function itself is in a context. We need
    to somehow extract it from the context and map it over the `f a` value, and then
    reassemble the context. Because all functions are curried in Haskell by default,
    we can use the combination of `<$>` and `<*>` to apply functions that take several
    parameters between applicative values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, it turns out that just like `fmap`, `<*>` can also be implemented by
    using only what the `Monad` type class gives us. The `ap` function is basically
    `<*>`, but with a `Monad` constraint instead of an `Applicative` one. Here’s its
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '`mf` is a monadic value whose result is a function. Because the function as
    well as the value is in a context, we get the function from the context and call
    it `f`, then get the value and call that `x`, and, finally, apply the function
    to the value and present that as a result. Here’s a quick demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Now we can see that monads are at least as strong as applicatives as well, because
    we can use the functions from `Monad` to implement the ones for `Applicative`.
    In fact, many times, when a type is found to be a monad, people first write up
    a `Monad` instance, and then make an `Applicative` instance by just saying that
    `pure` is `return` and `<*>` is `ap`. Similarly, if you already have a `Monad`
    instance for something, you can give it a `Functor` instance just by saying that
    `fmap` is `liftM`.
  prefs: []
  type: TYPE_NORMAL
- en: '`liftA2` is a convenience function for applying a function between two applicative
    values. It’s defined like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `liftM2` function does the same thing, but with a `Monad` constraint. There
    are also `liftM3`, `liftM4`, and `liftM5` functions.
  prefs: []
  type: TYPE_NORMAL
- en: You saw how monads are at least as strong as applicatives and functors and how
    even though all monads are functors and applicative functors, they don’t necessarily
    have `Functor` and `Applicative` instances. We examined the monadic equivalents
    of the functions that functors and applicative functors use.
  prefs: []
  type: TYPE_NORMAL
- en: The join Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s some food for thought: If the result of one monadic value is another
    monadic value (one monadic value is nested inside the other), can you flatten
    them to just a single, normal monadic value? For instance, if we have `Just (Just
    9)`, can we make that into `Just 9`? It turns out that any nested monadic value
    can be flattened and that this is actually a property unique to monads. For this,
    we have the `join` function. Its type is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `join` takes a monadic value within a monadic value and gives us just a
    monadic value—it flattens it, in other words. Here it is with some `Maybe` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The first line has a successful computation as a result of a successful computation,
    so they are both just joined into one big successful computation. The second line
    features a `Nothing` as a result of a `Just` value. Whenever we were dealing with
    `Maybe` values before and we wanted to combine several of them into one—be it
    with `<*>` or `>>=`—they all needed to be `Just` values for the result to be a
    `Just` value. If there was any failure along the way, the result was a failure,
    and the same thing happens here. In the third line, we try to flatten what is
    from the onset a failure, so the result is a failure as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flattening lists is pretty intuitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, for lists, `join` is just `concat`. To flatten a `Writer` value
    whose result is a `Writer` value itself, we need to `mappend` the monoid value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The outer monoid value `"bbb"` comes first, and then `"aaa"` is appended to
    it. Intuitively speaking, when you want to examine the result of a `Writer` value,
    you need to write its monoid value to the log first, and only then can you look
    at what it has inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flattening `Either` values is very similar to flattening `Maybe` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'If we apply `join` to a stateful computation whose result is a stateful computation,
    the result is a stateful computation that first runs the outer stateful computation
    and then the resulting one. Watch it at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The lambda here takes a state, puts `2` and `1` onto the stack, and presents
    `push 10` as its result. So, when this whole thing is flattened with `join` and
    then run, it first puts `2` and `1` onto the stack, and then `push 10` is carried
    out, pushing a `10` onto the top.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation for `join` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the result of `mm` is a monadic value, we get that result and then
    just put it on a line of its own because it’s a monadic value. The trick here
    is that when we call `m <- mm`, the context of the monad that we are in is taken
    care of. That’s why, for instance, `Maybe` values result in `Just` values only
    if the outer and inner values are both `Just` values. Here’s what this would look
    like if the `mm` value were set in advance to `Just (Just 8)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Perhaps the most interesting thing about `join` is that for every monad, feeding
    a monadic value to a function with `>>=` is the same thing as just mapping that
    function over the value and then using `join` to flatten the resulting nested
    monadic value! In other words, `m >>= f` is always the same thing as `join (fmap
    f m)`. It makes sense when you think about it.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802714.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With `>>=`, we’re always thinking about how to feed a monadic value to a function
    that takes a normal value but returns a monadic value. If we just map that function
    over the monadic value, we have a monadic value inside a monadic value. For instance,
    say we have `Just 9` and the function `\x -> Just (x+1)`. If we map this function
    over `Just 9`, we’re left with `Just (Just 10)`.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that `m >>= f` always equals `join (fmap f m)` is very useful if we’re
    making our own `Monad` instance for some type. This is because it’s often easier
    to figure out how we would flatten a nested monadic value than to figure out how
    to implement `>>=`.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting thing is that `join` cannot be implemented by just using
    the functions that functors and applicatives provide. This leads us to conclude
    that not only are monads as strong as functors and applicatives, but they are
    in fact stronger, because we can do more stuff with them than we can with just
    functors and applicatives.
  prefs: []
  type: TYPE_NORMAL
- en: filterM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `filter` function is pretty much the bread of Haskell programming (`map`
    being the butter). It takes a predicate and a list to filter and then returns
    a new list where only the elements that satisfy the predicate are kept. Its type
    is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The predicate takes an element of the list and returns a `Bool` value. Now,
    what if the `Bool` value that it returned was actually a monadic value? What if
    it came with a context? For instance, what if every `True` or `False` value that
    the predicate produced also had an accompanying monoid value, like `["Accepted
    the number 5"]` or `["3 is too small"]`? If that were the case, we would expect
    the resulting list to also come with a log of all the log values that were produced
    along the way. So, if the `Bool` that the predicate returned came with a context,
    we would expect the final resulting list to have some context attached as well.
    Otherwise, the context that each `Bool` came with would be lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `filterM` function from `Control.Monad` does just what we want! Its type
    is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The predicate returns a monadic value whose result is a `Bool`, but because
    it’s a monadic value, its context can be anything from a possible failure to nondeterminism
    and more! To ensure that the context is reflected in the final result, the result
    is also a monadic value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a list and keep only those values that are smaller than 4\. To start,
    we’ll just use the regular `filter` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s pretty easy. Now, let’s make a predicate that, aside from presenting
    a `True` or `False` result, also provides a log of what it did. Of course, we’ll
    be using the `Writer` monad for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Instead of just returning a `Bool`, this function returns a `Writer [String]
    Bool`. It’s a monadic predicate. Sounds fancy, doesn’t it? If the number is smaller
    than `4`, we report that we’re keeping it, and then `return True`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s give it to `filterM` along with a list. Because the predicate returns
    a `Writer` value, the resulting list will also be a `Writer` value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Examining the result of the resulting `Writer` value, we see that everything
    is in order. Now, let’s print the log and see what we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: So, just by providing a monadic predicate to `filterM`, we were able to filter
    a list while taking advantage of the monadic context that we used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very cool Haskell trick is using `filterM` to get the powerset of a list
    (if we think of them as sets for now). The *powerset* of some set is a set of
    all subsets of that set. So if we have a set like `[1,2,3]`, its powerset includes
    the following sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: In other words, getting a powerset is like getting all the combinations of keeping
    and throwing out elements from a set. For example, `[2,3]` is the original set
    with the number `1` excluded, `[1,2]` is the original set with `3` excluded, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a function that returns a powerset of some list, we’re going to rely
    on nondeterminism. We take the list `[1,2,3]` and then look at the first element,
    which is `1`, and we ask ourselves, “Should we keep it or drop it?” Well, we would
    like to do both actually. So, we are going to filter a list, and we’ll use a predicate
    that nondeterministically both keeps and drops every element from the list. Here’s
    our `powerset` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait, that’s it? Yup. We choose to drop and keep every element, regardless
    of what that element is. We have a nondeterministic predicate, so the resulting
    list will also be a nondeterministic value and will thus be a list of lists. Let’s
    give this a go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: This takes a bit of thinking to wrap your head around. Just consider lists as
    nondeterministic values that don’t know what to be, so they decide to be everything
    at once, and the concept is a bit easier to grasp.
  prefs: []
  type: TYPE_NORMAL
- en: foldM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The monadic counterpart to `foldl` is `foldM`. If you remember your folds from
    [Chapter 5](ch05.html "Chapter 5. Higher-Order Functions"), you know that `foldl`
    takes a binary function, a starting accumulator, and a list to fold up and then
    folds it from the left into a single value by using the binary function. `foldM`
    does the same thing, except it takes a binary function that produces a monadic
    value and folds the list up with that. Unsurprisingly, the resulting value is
    also monadic. The type of `foldl` is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas `foldM` has the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The value that the binary function returns is monadic, so the result of the
    whole fold is monadic as well. Let’s sum a list of numbers with a fold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The starting accumulator is `0`, and then `2` is added to the accumulator, resulting
    in a new accumulator that has a value of `2`. `8` is added to this accumulator,
    resulting in an accumulator of `10`, and so on. When we reach the end, the final
    accumulator is the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what if we wanted to sum a list of numbers but with the added condition
    that if any number in the list is greater than `9`, the whole thing fails? It
    would make sense to use a binary function that checks if the current number is
    greater than `9`. If it is, the function fails; if it isn’t, the function continues
    on its merry way. Because of this added possibility of failure, let’s make our
    binary function return a `Maybe` accumulator instead of a normal one. Here’s the
    binary function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Because our binary function is now a monadic function, we can’t use it with
    the normal `foldl`; we must use `foldM`. Here goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! Because one number in the list was greater than `9`, the whole thing
    resulted in a `Nothing`. Folding with a binary function that returns a `Writer`
    value is cool as well, because then you log whatever you want as your fold goes
    along its way.
  prefs: []
  type: TYPE_NORMAL
- en: Making a Safe RPN Calculator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we were solving the problem of implementing an RPN calculator in [Chapter 10](ch10.html
    "Chapter 10. Functionally Solving Problems"), we noted that it worked fine as
    long as the input that it got made sense. But if something went wrong, it caused
    our whole program to crash. Now that we know how to make already existing code
    monadic, let’s take our RPN calculator and add error handling to it by taking
    advantage of the `Maybe` monad.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802716.png)'
  prefs: []
  type: TYPE_IMG
- en: We implemented our RPN calculator by taking a string like `"1 3 + 2 *"`, breaking
    it up into words to get something like `["1","3","+","2","*"]`. Then we folded
    over that list by starting out with an empty stack and using a binary folding
    function that adds numbers to the stack or manipulates numbers on the top of the
    stack to add them together and divide them and such.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was the main body of our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'We made the expression into a list of strings, and folded over it with our
    folding function. Then, when we were left with just one item in the stack, we
    returned that item as the answer. This was the folding function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The accumulator of the fold was a stack, which we represented with a list of
    `Double` values. As the folding function went over the RPN expression, if the
    current item was an operator, it took two items off the top of the stack, applied
    the operator between them, and then put the result back on the stack. If the current
    item was a string that represented a number, it converted that string into an
    actual number and returned a new stack that was like the old one, except with
    that number pushed to the top.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first make our folding function capable of graceful failure. Its type
    is going to change from what it is now to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: So, it will either return `Just` a new stack or it will fail with `Nothing`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reads` function is like `read`, except that it returns a list with a single
    element in case of a successful read. If it fails to read something, it returns
    an empty list. Apart from returning the value that it read, it also returns the
    part of the string that it didn’t consume. We’re going to say that it always must
    consume the full input to work, and make it into a `readMaybe` function for convenience.
    Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, it seems to work. So, let’s make our folding function into a monadic
    function that can fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The first three cases are like the old ones, except the new stack is wrapped
    in a `Just` (we used `return` here to do this, but we could just as well have
    written `Just`). In the last case, we use `readMaybe numberString`, and then we
    map `(:xs)` over it. So, if the stack `xs` is `[1.0,2.0]`, and `readMaybe numberString`
    results in a `Just 3.0`, the result is `Just [3.0,1.0,2.0]`. If `readMaybe numberString`
    results in a `Nothing`, the result is `Nothing`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try out the folding function by itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: It looks like it’s working! And now it’s time for the new and improved `solveRPN`.
    Here it is ladies and gents!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Just as in the previous version, we take the string and make it into a list
    of words. Then we do a fold, starting with the empty stack, but instead of doing
    a normal `foldl`, we do a `foldM`. The result of that `foldM` should be a `Maybe`
    value that contains a list (that’s our final stack), and that list should have
    only one value. We use a `do` expression to get that value, and we call it `result`.
    In case the `foldM` returns a `Nothing`, the whole thing will be a `Nothing`,
    because that’s how `Maybe` works. Also notice that we pattern match in the `do`
    expression, so if the list has more than one value or none at all, the pattern
    match fails, and a `Nothing` is produced. In the last line, we just call `return
    result` to present the result of the RPN calculation as the result of the final
    `Maybe` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give it a shot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: The first failure happens because the final stack isn’t a list with one element
    in it, so the pattern matching in the `do` expression fails. The second failure
    happens because `readMaybe` returns a `Nothing`.
  prefs: []
  type: TYPE_NORMAL
- en: Composing Monadic Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we were talking about the monad laws in [Chapter 13](ch13.html "Chapter 13. A
    Fistful of Monads"), you learned that the `<=<` function is just like composition,
    but instead of working for normal functions like `a -> b`, it works for monadic
    functions like `a -> m b`. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first composed two normal functions, applied the resulting
    function to `4`, and then composed two monadic functions and fed `Just 4` to the
    resulting function with `>>=`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a bunch of functions in a list, you can compose them all into one
    big function just by using `id` as the starting accumulator and the `.` function
    as the binary function. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The function `f` takes a number and then adds `1` to it, multiplies the result
    by `100`, and then adds `1` to that.
  prefs: []
  type: TYPE_NORMAL
- en: We can compose monadic functions in the same way, but instead of normal composition,
    we use `<=<`, and instead of `id`, we use `return`. We don’t need to use a `foldM`
    over a `foldr` or anything like that, because the `<=<` function makes sure that
    composition happens in a monadic fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you were introduced to the list monad in [Chapter 13](ch13.html "Chapter 13. A
    Fistful of Monads"), we used it to figure out if a knight can go from one position
    on a chessboard to another in exactly three moves. We created a function called
    `moveKnight`, which takes the knight’s position on the board and returns all the
    possible moves that he can make next. Then, to generate all the possible positions
    that he can have after taking three moves, we made the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'And to check if he can go from `start` to `end` in three moves, we did the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Using monadic function composition, we can make a function like `in3`, except
    instead of generating all the positions that the knight can have after making
    three moves, we can do it for an arbitrary number of moves. If you look at `in3`,
    you’ll see that we used our `moveKnight` three times, and each time, we used `>>=`
    to feed it all the possible previous positions. So now, let’s make it more general.
    Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: First, we use `replicate` to make a list that contains `x` copies of the function
    `moveKnight`. Then we monadically compose all those functions into one, which
    gives us a function that takes a starting position and nondeterministically moves
    the knight `x` times. Then we just make the starting position into a singleton
    list with `return` and feed it to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can change our `canReachIn3` function to be more general as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Making Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’re going to look at an example of how a type gets made,
    identified as a monad, and then given the appropriate `Monad` instance. We don’t
    usually set out to make a monad with the sole purpose of making a monad. Rather,
    we make a type whose purpose is to model an aspect of some problem, and then later
    on, if we see that the type represents a value with a context and can act like
    a monad, we give it a `Monad` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802718.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you’ve seen, lists are used to represent nondeterministic values. A list
    like `[3,5,9]` can be viewed as a single nondeterministic value that just can’t
    decide what it’s going to be. When we feed a list into a function with `>>=`,
    it just makes all the possible choices of taking an element from the list and
    applying the function to it and then presents those results in a list as well.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the list `[3,5,9]` as the numbers `3`, `5`, and `9` occurring
    at once, we might notice that there’s no information regarding the probability
    that each of those numbers occurs. What if we wanted to model a nondeterministic
    value like `[3,5,9]`, but we wanted to express that `3` has a 50 percent chance
    of happening and `5` and `9` both have a 25 percent chance of happening? Let’s
    try to make this work!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that every item in the list comes with another value: a probability
    of it happening. It might make sense to present that value like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'In mathemathics, probabilities aren’t usually expressed in percentages, but
    rather in real numbers between a 0 and 1\. A 0 means that there’s no chance in
    hell for something to happen, and a 1 means that it’s happening for sure. Floating-point
    numbers can get messy fast because they tend to lose precision, but Haskell offers
    a data type for rational numbers. It’s called `Rational`, and it lives in `Data.Ratio`.
    To make a `Rational`, we write it as if it were a fraction. The numerator and
    the denominator are separated by a `%`. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line is just one-quarter. In the second line, we add two halves to
    get a whole. In the third line, we add one-third with five-quarters and get nineteen-twelfths.
    So, let’s throw out our floating points and use `Rational` for our probabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so `3` has a one-out-of-two chance of happening, while `5` and `9` will
    happen one time out of four. Pretty neat.
  prefs: []
  type: TYPE_NORMAL
- en: We took lists and we added some extra context to them, so this represents values
    with contexts as well. Before we go any further, let’s wrap this into a `newtype`,
    because something tells me we’ll be making some instances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Is this a functor? Well, the list is a functor, so this should probably be
    a functor, too, because we just added some stuff to the list. When we map a function
    over a list, we apply it to each element. Here, we’ll apply it to each element
    as well, but we’ll leave the probabilities as they are. Let’s make an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'We unwrap it from the `newtype` with pattern matching, apply the function `f`
    to the values while keeping the probabilities as they are, and then wrap it back
    up. Let’s see if it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Note that the probabilities should always add up to `1`. If those are all the
    things that can happen, it doesn’t make sense for the sum of their probabilities
    to be anything other than `1`. A coin that lands tails 75 percent of the time
    and heads 50 percent of the time seems like it could work only in some other strange
    universe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the big question: Is this a monad? Given how the list is a monad, this
    looks like it should be a monad as well. First, let’s think about `return`. How
    does it work for lists? It takes a value and puts it in a singleton list. What
    about here? Well, since it’s supposed to be a default minimal context, it should
    also make a singleton list. What about the probability? Well, `return x` is supposed
    to make a monadic value that always presents `x` as its result, so it doesn’t
    make sense for the probability to be `0`. If it always must present this value
    as its result, the probability should be `1`!'
  prefs: []
  type: TYPE_NORMAL
- en: 'What about `>>=`? Seems kind of tricky, so let’s make use of the fact that
    `m >>= f` always equals `join (fmap f m)` for monads and think about how we would
    flatten a probability list of probability lists. As an example, let’s consider
    this list where there’s a 25 percent chance that exactly one of `''a''` or `''b''`
    will happen. Both `''a''` and `''b''` are equally likely to occur. Also, there’s
    a 75 percent chance that exactly one of `''c''` or `''d''` will happen. `''c''`
    and `''d''` are also equally likely to happen. Here’s a picture of a probability
    list that models this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802720.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What are the chances for each of these letters to occur? If we were to draw
    this as just four boxes, each with a probability, what would those probabilites
    be? To find out, all we need to do is multiply each probability with all of the
    probabilities that it contains. `'a'` would occur one time out of eight, as would
    `'b'`, because if we multiply one-half by one-quarter, we get one-eighth. `'c'`
    would happen three times out of eight, because three-quarters multiplied by one-half
    is three-eighths. `'d'` would also happen three times out of eight. If we sum
    all the probabilities, they still add up to one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s this situation expressed as a probability list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that its type is `Prob (Prob Char)`. So now that we’ve figured out how
    to flatten a nested probability list, all we need to do is write the code for
    this. Then we can write `>>=` simply as `join (fmap f m)`, and we have ourselves
    a monad! So here’s `flatten`, which we’ll use because the name `join` is already
    taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: The function `multAll` takes a tuple of probability list and a probability `p`
    that comes with it and then multiplies every inner probability with `p`, returning
    a list of pairs of items and probabilities. We map `multAll` over each pair in
    our nested probability list, and then we just flatten the resulting nested list.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have all that we need. We can write a `Monad` instance!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Because we already did all the hard work, the instance is very simple. We also
    defined the `fail` function, which is the same as it is for lists, so if there’s
    a pattern-match failure in a `do` expression, a failure occurs within the context
    of a probability list.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also important to check if the monad laws hold for the monad that we just
    made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802722.png)'
  prefs: []
  type: TYPE_IMG
- en: The first law says that `return x >>= f` should be equal to `f x`. A rigorous
    proof would be rather tedious, but we can see that if we put a value in a default
    context with `return`, then `fmap` a function over that, and then flatten the
    resulting probability list, every probability that results from the function would
    be multiplied by the `1%1` probability that we made with `return`, so it wouldn’t
    affect the context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second law states that `m >>= return` is no different than `m`. For our
    example, the reasoning for `m >>= return` being equal to just `m` is similar to
    that for the first law.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third law states that `f <=< (g <=< h)` should be the same as `(f <=< g)
    <=< h`. This one is true as well, because it holds for the list monad that forms
    the basis of the probability monad and because multiplication is associative.
    `1%2 * (1%3 * 1%5)` is equal to `(1%2 * 1%3) * 1%5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have a monad, what can we do with it? Well, it can help us do calculations
    with probabilities. We can treat probabilistic events as values with contexts,
    and the probability monad will make sure that those probabilities are reflected
    in the probabilities of the final result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have two normal coins and one loaded coin that lands tails an astounding
    nine times out of ten and heads only one time out of ten. If we throw all the
    coins at once, what are the odds of all of them landing tails? First, let’s make
    probability values for a normal coin flip and for a loaded one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the coin-throwing action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Giving it a go, we see that the odds of all three landing tails are not that
    good, despite cheating with our loaded coin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: All three of them will land tails 9 times out of 40, which is less than 25 percent.
    We see that our monad doesn’t know how to join all of the `False` outcomes where
    all coins don’t land tails into one outcome. That’s not a big problem, since writing
    a function to put all the same outcomes into one outcome is pretty easy (and left
    as an exercise to you, the reader).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we went from having a question (what if lists also carried
    information about probability?) to making a type, recognizing a monad, and finally
    making an instance and doing something with it. I think that’s quite fetching!
    By now, you should have a pretty good grasp of monads and what they’re about.
  prefs: []
  type: TYPE_NORMAL
