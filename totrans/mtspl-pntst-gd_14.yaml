- en: Chapter 14. Creating Your Own Exploits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a penetration tester, you will frequently encounter applications for which
    no Metasploit modules are available. In such situations, you can attempt to uncover
    vulnerabilities in the application and develop your own exploits for them.
  prefs: []
  type: TYPE_NORMAL
- en: One of the easiest ways to discover a vulnerability is to fuzz the application.
    *Fuzz testing* is the act of sending invalid, unexpected, or malformed random
    data to an application and monitoring it for exceptions such as crashes. If a
    vulnerability is found, you can work to develop an exploit for it. Fuzzing is
    a vast topic and entire books have been written on the subject. We will only briefly
    scratch the surface of fuzzing prior to moving on and developing a working exploit
    module.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll walk you though the process of identifying a vulnerability
    via fuzzing and exploit development, using the known vulnerability in NetWin SurgeMail
    3.8k4-4, discovered by Matteo Memelli (ryujin) and available at [http://www.exploit-db.com/exploits/5259/](http://www.exploit-db.com/exploits/5259/).
    This application had a vulnerability that made it improperly handle overly long
    `LIST` commands, resulting in a stack overflow that let an attacker execute code
    remotely.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter assumes that you are familiar with exploit development and comfortable
    with the concept of buffer overflows and the use of a debugger. If you need a
    bit of a refresher, you’ll find some excellent tutorials by *corelanc0d3r* on
    the Exploit Database site, [http://www.exploit-db.com/](http://www.exploit-db.com/).
    At a minimum, consider reading “Exploit Writing Tutorial Part 1: Stack Based Overflows”([http://www.exploit-db.com/download_pdf/13535/](http://www.exploit-db.com/download_pdf/13535/))
    and “Exploit Writing Tutorial Part 3: SEH” ([http://www.exploit-db.com/download_pdf/13537/](http://www.exploit-db.com/download_pdf/13537/)).'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The Art of Fuzzing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you develop any exploit, you need to determine whether a vulnerability
    exists in the application. This is where fuzzing comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: The following listing shows the code for a simple Internet Message Access Protocol
    (IMAP) fuzzer. Save this to your */root/.msf3/modules/auxiliary/fuzzers/* directory,
    but be sure to keep your testing modules in a folder separate from the main Metasploit
    trunk.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The fuzzer module begins by importing the IMAP ![](../images/00002.gif) and
    denial-of-service ![](../images/00004.gif) mixins. Including IMAP gives you the
    required login functionality, and since the goal of the fuzzer is to crash the
    server, this module results in a denial of service.
  prefs: []
  type: TYPE_NORMAL
- en: At ![](../images/00005.gif) the *fuzz string* (the malformed data we want to
    send) is set as a randomized string of alphanumeric characters with a maximum
    length of 1024 bytes. The fuzzer connects and logs into the remote service at
    ![](../images/00006.gif), and if it fails to connect and the loop breaks, you
    have something worth investigating. The lack of response by the server might mean
    that you’ve successfully caused an exception in the remote service.
  prefs: []
  type: TYPE_NORMAL
- en: At ![](../images/00007.gif) the variable `fuzzed` is set to the random string
    generated by the Framework, and the malicious request ![](../images/00026.gif)
    is built according to the published exploit code by appending the malicious data
    to the vulnerable `LIST` command. If the fuzzer doesn’t receive a response from
    the server, it prints the message `"Server crashed, no response"` and quits.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your new fuzzer, start up *msfconsole*, load the module, and set its
    options as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The fuzzer should now be ready to go. Make sure that your debugger of choice
    (we’re using the Immunity Debugger in our examples) is attached to the *surgemail.exe*
    process, and start the fuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this listing, the fuzzer connects and logs into the remote service at ![](../images/00002.gif)
    and generates a random string of text at ![](../images/00004.gif). At ![](../images/00005.gif)
    the malicious request is sent to the server, and the reply is received and displayed
    at ![](../images/00006.gif). If the server receives no reply, you receive the
    notification at ![](../images/00007.gif) that the server has crashed, which is
    your cue to check your debugger.
  prefs: []
  type: TYPE_NORMAL
- en: If you now check your debugger on the Windows target, you should see that it
    has paused at the point of the crash, as shown in [Figure 14-1](part0018.html#the_debugger_pauses_at_the_point_of_the).
    Looking at the crash, we can see that no memory addresses are overwritten and
    that, unfortunately, there’s nothing really exploitable at first glance. After
    further tinkering with increasing buffer lengths, you will find that by sending
    an even longer string of 11,000 bytes, you can overwrite the Structured Exception
    Handler (SEH). Controlling the SEH makes the exploit more reliable, because it
    makes it more versatile. Similarly, the use of an application DLL for a return
    address makes the exploit portable across different operating system versions.
  prefs: []
  type: TYPE_NORMAL
- en: '![The debugger pauses at the point of the crash.](../images/00048.jpeg)Figure 14-1. The
    debugger pauses at the point of the crash.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To send the 11,000-byte string, we make a small change in the fuzzer code,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Rather than using the random string of characters, this code modification sends
    a string of 11,000 *A*s as part of the malicious request.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the Structured Exception Handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you restart the *surgemail* service, reattach the debugger to the process,
    and rerun the module, you should see the crash that fuzzing found in your debugger.
    If you’re using the Immunity Debugger, you should be able to see the contents
    of the SEH chain by selecting **View**▸**SEH chain**. Right-click the value, which
    should be *41414141*, and select **Follow address in stack** to display the stack
    contents leading to the SEH overwrite in the lower-right pane shown in [Figure 14-2](part0018.html#the_overwritten_seh_entry).
  prefs: []
  type: TYPE_NORMAL
- en: '![The overwritten SEH entry](../images/00049.jpeg)Figure 14-2. The overwritten
    SEH entry'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know that you can control the SEH chain on the vulnerable *surgemail*
    process with an overly long buffer, it’s time to determine the exact length required
    to overwrite it on the target. As you will recall from our discussions of stand-alone
    exploit development, before you can use a return address, you first need to find
    out where, exactly, the overwrite occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can modify our fuzzer code to create a nonrepeating, random string of characters
    of a specific length, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this listing, we use `Rex::Text.pattern_create` to generate the nonrepeating
    random string of characters with our fuzzer. Rerunning the fuzzer module now shows
    that SEH was overwritten on the target with *684E3368*, as shown in [Figure 14-3](part0018.html#the_seh_overwritten_with_random_characte).
  prefs: []
  type: TYPE_NORMAL
- en: '![The SEH overwritten with random characters](../images/00050.jpeg)Figure 14-3. The
    SEH overwritten with random characters'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the SEH overwritten with our random set of characters, we can use *pattern_offset.rb*
    in */opt/metasploit3/msf3/tools/* to determine exactly where the overwrite occurs
    by passing the characters of interest (*684E3368*) followed by the length of the
    string that was sent to the target (*11000*), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The value *10360* means that the four bytes that overwrite SEH are 10361, 10362,
    10363, and 10364\. We can now change the fuzzer code one last time to verify our
    findings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As shown, the fuzzer will build the malicious request beginning with 10,360
    *A*s (hexadecimal *41*), followed by four *B*s (hexadecimal *42*) to overwrite
    the SEH, and then 636 *C*s (hexadecimal *43*) as filler to keep the string length
    constant at 11,000 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Running the fuzzer against the target again shows that the entire SEH chain
    is under your complete control, as shown in [Figure 14-4](part0018.html#seh_fully_controlled).
  prefs: []
  type: TYPE_NORMAL
- en: '![SEH fully controlled](../images/00051.jpeg)Figure 14-4. SEH fully controlled'
  prefs: []
  type: TYPE_NORMAL
- en: Hopping Around SEH Restrictions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following the SEH overwrite, there’s very little space for shellcode before
    the end of the stack. Normally, a *POP-POP-RETN* set of instructions would be
    used to reach the Next SEH (NSEH), followed by a short jump forward into the shellcode.
    We’ll overcome this limited space restriction by developing an exploit to use
    as much space as possible for our final payload. At this point, we are done with
    the fuzzing process and we’ll move into developing an exploit for the vulnerability
    that we found.
  prefs: []
  type: TYPE_NORMAL
- en: 'This exploit would be a good candidate for an *egg hunter*, which is a small
    segment of shellcode that searches memory for the main payload; however, we’ll
    use a different tactic and overwrite SEH with the *POP-POP-RETN* instruction pointer.
    Once that’s overwritten we’ll make a short jump backward that requires very few
    instructions (rather than jumping forward). Next, we’ll use the space gained in
    the short jump to execute the larger near jump farther back into a NOP slide and
    shellcode. Although it’s not required, a NOP slide is always a good addition to
    an exploit, because it gives you a little room for error should the buffer position
    change in memory. NOPs will have no adverse impact on the exploit code and will
    act as filler. Conceptually, the attack will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To ensure portability of the exploit across different versions of Windows, use
    a return address from an application DLL or executable. In this case, only the
    application executable itself is available, so you can try to accomplish a three-byte
    overwrite of SEH using a *POP-POP-RETN* sequence of instructions from the *surgemail.exe*
    file. If this can be done successfully, the exploit will be universal across versions
    of Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to creating the actual exploit for the SurgeMail vulnerability.
    Following is our initial skeleton exploit module to be saved in */root/.msf3/modules/exploits/windows/imap/*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `''Space''` declaration at ![](../images/00002.gif) refers to the space
    available for shellcode. This declaration is very important in an exploit module
    because it determines which payloads Metasploit will allow you to use when running
    your exploit. Some payloads require much more space than others, so try not to
    overstate this value. Payload sizes vary greatly and encoding increases their
    sizes. To see the size of an unencoded payload, you would use the `info` command
    followed by the name of the payload and look for the `Total size` value, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The return address at ![](../images/00004.gif) in the `'Targets'` section is
    currently occupied by a placeholder value, which we’ll change later in the exploit
    development process.
  prefs: []
  type: TYPE_NORMAL
- en: As with the fuzzer module discussed earlier, this exploit connects and logs
    into the target at ![](../images/00005.gif), uses a string of *A*s at ![](../images/00006.gif)
    as the initial buffer, and appends four *C*s at ![](../images/00007.gif) to overwrite
    the SEH. The entire exploit string is generated at ![](../images/00026.gif) and
    then sent to the target at ![](../images/00027.gif).
  prefs: []
  type: TYPE_NORMAL
- en: Getting a Return Address
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to locate a *POP-POP-RETN* sequence in *surgemail.exe*. To
    do so, copy the executable to a location on your Back|Track machine, and then
    use the `-p` switch with `msfpescan` to locate a suitable candidate, as in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When `msfpescan` is run against the target executable, it reads through the
    machine code looking for assembly instructions that match the target (a *POP-POP-RETN*
    sequence in this case) and displays the memory address where these instructions
    occur. As you can see in the listing, multiple addresses are found. We’ll use
    the address at the end of the output, *0x0078517e*, to overwrite SEH in the exploit.
    Having made our selection, we edit the `'Targets'` section of the exploit module
    to include this address and edit the `exploit` section to include it as part of
    the buffer to be sent, as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To perform a three-byte overwrite of the SEH, we set the three bytes to be added
    to the buffer in the `'Targets'` block at ![](../images/00002.gif), in little-endian
    order, as shown in boldface type in the listing. (Endian-ness is determined by
    the target CPU’s architecture, and Intel-compatible processors use little-endian
    byte ordering.)
  prefs: []
  type: TYPE_NORMAL
- en: At ![](../images/00004.gif) we replace the three *C*s in the `evil` string with
    `[target.ret].pack("A3")`, which will send the return address exactly as it is
    declared in the `'Targets'` block. When modifying many exploits that use a three-byte
    overwrite, you can declare the target address literally (*0x0078517e* in this
    case) and Metasploit will automatically order the bytes correctly when you use
    `[target.ret].pack('V')`. This scenario requires more granular control, because
    if we were to send the null (00) byte, it would represent the end of a string
    and could prevent the exploit from functioning properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now is a good time to run the exploit to make sure that it works properly.
    If you jump too far ahead when developing an exploit, you run the risk of making
    an error somewhere and having to do a lot of backtracking to find out what went
    wrong. Here’s the exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The payload that we use at ![](../images/00002.gif), `generic/debug_trap`, won’t
    actually send a payload. Instead, it sends multiple `\xCC`s, or breakpoints, to
    debug the execution flow of the exploit. This is useful for confirming that your
    shellcode is inserted at the right places in your exploit.
  prefs: []
  type: TYPE_NORMAL
- en: After running the exploit, open the Immunity Debugger, as shown in [Figure 14-5](part0018.html#landing_in_the_pop-pop-retn_instructions),
    and at the crash select **View** ▸ **SEH chain**. Set a breakpoint by pressing
    F2, and then press shift-F9 to pass the exception to the application and step
    into the *POP-POP-RETN* sequence of instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, still in the debugger, press F7 to single-step through the instructions
    until you land in the *41414141* contained in NSEH.
  prefs: []
  type: TYPE_NORMAL
- en: '![Landing in the POP-POP-RETN instructions](../images/00052.jpeg)Figure 14-5. Landing
    in the *POP-POP-RETN* instructions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, edit the exploit to include the instructions for the short jump backward,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When editing your exploit, be sure to adjust the initial buffer length at ![](../images/00002.gif)
    as you make changes, or your alignment will be off. In this case, NSEH is being
    overwritten with the instructions to make a short five-byte jump backward (`\xeb\xf9\x90\x90`)
    ![](../images/00004.gif), where `eb` is the operation code for a short jump. The
    new lead buffer length is adjusted to 10,356 bytes, because these five new bytes
    come before the SEH overwrite.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the exploit again and step through the instructions in the debugger,
    you should land in the *41*s (hexadecimal *A*s) before the exception handler values.
    The five `INC ECX` instructions should be replaced with the code to jump farther
    back into the initial buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll change the exploit to include the “near jump” (*\xe9\xdd\xd7\xff\xff*)
    sequence of instructions, to jump backward to a location near the beginning of
    the buffer. Looking at the buffer ([Figure 14-6](part0018.html#lots_of_room_for_shellcode)),
    you can see that the entire string of *A*s is completely intact, leaving more
    than 10,000 bytes available for shellcode. Since the average space required for
    functional shellcode is less than 500 bytes, this leaves you ample room.
  prefs: []
  type: TYPE_NORMAL
- en: '![Lots of room for shellcode](../images/00053.jpeg)Figure 14-6. Lots of room
    for shellcode'
  prefs: []
  type: TYPE_NORMAL
- en: Now all you have to do is replace the buffer of *41*s with NOPs (`\x90`) to
    give yourself a nice NOP slide to land in, and then you can sit back and let Metasploit
    take care of the shellcode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in this listing, the initial string of *A*s we used earlier is
    replaced by NOPs minus the length of the shellcode that Metasploit generates at
    ![](../images/00002.gif). Notice that the buffer length, initially 10,356 bytes,
    has been decreased by five bytes to 10,351 to account for the near jump instructions
    at ![](../images/00004.gif). Finally, the malicious string is built using all
    of the exploit’s components at ![](../images/00005.gif).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can select a real payload and execute the module to see what happens.
    Surprisingly, the exploit completes but no session is created. The exploit module
    connects and sends its payload, but no shell is returned to us, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Bad Characters and Remote Code Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Well, that certainly wasn’t expected: The exploit completes but no session
    is created. If you check your debugger, you’ll see that the application didn’t
    even crash — so what happened? Welcome to the sometimes challenging and nearly
    always frustrating world of *bad characters*. Some characters, when sent as part
    of an exploit buffer, get mangled while being read by the application. The unfortunate
    result is that bad characters render your shellcode, and sometimes the entire
    exploit, unusable.'
  prefs: []
  type: TYPE_NORMAL
- en: When writing a Metasploit module, you should always be sure to identify all
    the bad characters, because the shellcode that Metasploit generates differs each
    time an exploit is launched, and any rogue bad characters will greatly reduce
    a module’s reliability. In many cases, if you fail to find all the bad characters,
    the application will crash without running the shellcode. In the preceding example,
    SurgeMail didn’t even crash. The exploit appears to succeed, but we don’t get
    a session.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to identify bad characters, including replacing the dynamically
    created shellcode with a string of sequential characters (`\x00\x01\x02`...),
    and checking the debugger to see where the first character gets mangled and marking
    that character as bad. One of the fastest methods, however, is to find the bad
    characters in the source code of similar exploits. For example, a search of the
    IMAP exploits as of this writing finds `\x00\x09\x0a\x0b\x0c\x0d\x20\x2c\x3a\x40\x7b`
    listed as bad characters, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When you declare `'BadChars'` in an exploit module, Metasploit will automatically
    exclude them from shellcode and from any automatically generated strings of text
    or NOPs.
  prefs: []
  type: TYPE_NORMAL
- en: When we run the exploit again, as shown next, after declaring bad characters,
    we finally get a session on the third try. The exploit still isn’t reliable, but
    it works because Metasploit dynamically changes the shellcode each time the exploit
    is run. As a result, the characters that are causing the module to fail may not
    always be present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Determining the remaining bad characters is an exercise left for the reader.
    An excellent, albeit tedious, way to eliminate all bad characters is to follow
    the technique described at [http://en.wikibooks.org/wiki/Metasploit/WritingWindowsExploit#Dealing_with_badchars](http://en.wikibooks.org/wiki/Metasploit/WritingWindowsExploit#Dealing_with_badchars).
  prefs: []
  type: TYPE_NORMAL
- en: 'The current exploit code, including all of the pieces we’ve added, is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although we haven’t uncovered a new vulnerability in this chapter, we have covered
    the entire process from developing and running a fuzzer to developing a functioning
    exploit. The exploit that we built in this chapter is complicated and unusual,
    and it therefore offers an excellent opportunity to think beyond the basics and
    explore creative avenues to obtain code execution.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best ways to dig deeper into Metasploit is to read through the Metasploit
    source files and other exploit modules to get a better idea of what is possible
    within the Metasploit Framework. The techniques in this chapter have given you
    the basic tools you’ll need to begin discovering vulnerabilities and developing
    Metasploit exploit modules that will take advantage of them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will begin to dive into porting exploits into the Framework
    that will build upon the knowledge you learned in this chapter. We’ll show you
    how to convert publicly available exploits into a working Metasploit exploit by
    rewriting the exploit and debugging it to see what it’s doing.
  prefs: []
  type: TYPE_NORMAL
