- en: Appendix A. JAVASCRIPT QUICK START
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. JAVASCRIPT 快速入门
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
- en: All the mapping APIs covered in this book are based on JavaScript. To use them,
    you need to program JavaScript from your web page to interact with the maps. However,
    as you'll see in this appendix, it's a programming language that is easy to learn.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖的所有映射 API 都基于 JavaScript。要使用它们，您需要从您的网页中编写 JavaScript 代码以与地图交互。然而，正如您在本附录中将会看到的，它是一种易于学习的编程语言。
- en: I'll cover a very basic approach to JavaScript—enough not to be confused by
    the examples elsewhere in the book. If you're looking to learn the complete ins
    and outs, pick up *The Book of JavaScript* (thau!, No Starch Press, 2000).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将介绍一种非常基础的 JavaScript 方法——足以不被书中其他示例所困惑。如果您想学习完整的细节，请拿起 *JavaScript 权威指南*（thau!,
    No Starch Press, 2000）。
- en: Where JavaScript Goes
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 的去向
- en: JavaScript is added to HTML pages via the `<script>` tag. Sometimes code is
    placed between this tag and its closing tag. Other times, the tag calls to an
    external file from the attributes. I'll show both versions in this section.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 通过 `<script>` 标签添加到 HTML 页面中。有时代码会放置在这个标签及其结束标签之间。其他时候，这个标签会通过属性调用外部文件。在这个部分，我将展示这两种版本。
- en: Technically, you can put your `<script>` tag anywhere within an HTML document.
    For analytics services the bottom of a page may be optimal. JavaScript for widgets
    may need to be placed at the exact location where you want the widgets to appear.
    With the JavaScript you write, however, including it in the `<head>` of your document
    whenever possible makes sense from a standards compliance and best practice point
    of view.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，您可以将 `<script>` 标签放置在 HTML 文档的任何位置。对于分析服务，页面底部可能是最佳位置。对于小部件的 JavaScript，可能需要放置在您希望小部件出现的确切位置。然而，从标准合规性和最佳实践的角度来看，尽可能在文档的
    `<head>` 中包含您编写的 JavaScript 是有意义的。
- en: 'Here''s an example of some very basic JavaScript on an even more basic web
    page:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在更基础的网页上一些非常基础的 JavaScript 的例子：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: JavaScript code goes between the `<script>` tags. Here I've used `alert`, a
    JavaScript function that will create a message window in your web browser using
    the text inside the parentheses. Using an alert is a handy way to show simple
    examples and to debug, but moving beyond it is best for more complex scripts and
    for public-facing web pages.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 代码位于 `<script>` 标签之间。这里我使用了 `alert`，这是一个 JavaScript 函数，它将在您的网络浏览器中使用括号内的文本创建一个消息窗口。使用
    alert 是展示简单示例和调试的好方法，但对于更复杂的脚本和面向公众的网页来说，超越它才是最佳选择。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Want to send a special message to browsers without JavaScript? Include `<noscript>`
    tags and the browser will display any content within.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 想要向没有 JavaScript 的浏览器发送特殊消息吗？包含 `<noscript>` 标签，浏览器将显示其中的任何内容。
- en: 'A `<script>` tag can include as many lines of JavaScript as you want, though
    too much can start to weigh down your HTML file, so most scripts that are more
    than a few lines are stored in external files. Consider the following, slightly
    altered example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`<script>` 标签可以包含任意多的 JavaScript 代码行，尽管过多的代码可能会开始拖累您的 HTML 文件，所以大多数超过几行的脚本都存储在外部文件中。考虑以下略微修改的例子：'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, I've loaded the JavaScript via the `src` attribute of the `<script>` tag,
    which is similar to the way images are referenced in HTML. By convention, the
    file has a *.js* extension. Also, to keep things organized, most developers keep
    JavaScript files in a directory off the web root. In this example, I have used
    a directory named `js`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我通过 `<script>` 标签的 `src` 属性加载了 JavaScript，这与在 HTML 中引用图像的方式类似。按照惯例，文件具有
    *.js* 扩展名。此外，为了保持组织有序，大多数开发者将 JavaScript 文件存储在离网站根目录的目录中。在这个例子中，我使用了名为 `js` 的目录。
- en: 'The contents of the file are the same as when you include the JavaScript directly
    on the page. But you do not need the `<script>` tags. Continuing the previous
    example, *test.js* would contain only a single line:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的内容与您直接在页面上包含 JavaScript 时相同。但您不需要 `<script>` 标签。继续上一个例子，*test.js* 将只包含一行：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using this method has the distinct advantage that the script file is cached
    separately by the user's browser. If you use the same script on many pages, as
    the user navigates around your site, the script will only have been downloaded
    once.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法具有明显的优势，即脚本文件由用户的浏览器单独缓存。如果您在许多页面上使用相同的脚本，当用户在您的网站上导航时，脚本只会下载一次。
- en: As in the first example, this code runs as soon as it is loaded. To run code
    at different times, you'll need to use functions, described later in this appendix.
    But first, let's get a feel for other pieces of JavaScript syntax, such as variables,
    conditionals, and loops.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如第一个例子所示，此代码在加载时立即运行。要在不同时间运行代码，你需要使用函数，这些函数将在本附录的后面描述。但首先，让我们感受一下JavaScript语法的其他部分，如变量、条件语句和循环。
- en: Variables
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: Variables store values that can be changed or accessed later. You can hold numbers,
    text, and more inside variables. In this section, I'll show some simple values,
    as well as more complex structures like arrays and objects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 变量存储可以更改或稍后访问的值。你可以在变量中保存数字、文本等。在本节中，我将展示一些简单的值，以及更复杂的结构，如数组和对象。
- en: 'First, you need to be able to identify variables. They look like ordinary words.
    Sometimes variables are more than one word, though they can''t include spaces.
    Often the first time a variable is used it will be set to a value, for example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要能够识别变量。它们看起来像普通单词。有时变量可能由多个单词组成，但它们不能包含空格。通常，变量第一次使用时将被设置为值，例如：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here I have created a new variable using JavaScript's `var` keyword. This variable
    is called `age`, but you can use just about any name you want, as long as it isn't
    one of the words reserved by the language. Like most lines of JavaScript code,
    this one ends with a semicolon.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用JavaScript的`var`关键字创建了一个新变量。这个变量被称为`age`，但你几乎可以使用任何你想要的名称，只要它不是语言保留的单词之一。像大多数JavaScript代码行一样，这一行以分号结束。
- en: The equals sign declares that the variable on the left side will now be set
    to the value on the right side. In this case, I've used a literal number. You
    could also use text, another variable, or even a combination of other variables
    and literal values.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 等号声明左侧的变量现在将被设置为右侧的值。在这种情况下，我使用了一个字面量数字。你也可以使用文本、另一个变量，甚至其他变量和字面量的组合。
- en: 'Here is an example using multiple variables, one dependent on the others:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用多个变量的例子，其中一个变量依赖于其他变量：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `var` keyword should only be used the first time you reference a variable.
    In fact, you do not even need to use it at all, though if you don''t, the variable
    is then assumed to be *global*. [Variable Scope](apas05.html#variable_scope "Variable
    Scope") in [Variable Scope](apas05.html#variable_scope "Variable Scope") will
    explain what this means and why it''s a good idea to declare your variables explicitly.
    You can even do so without creating a value:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`关键字应该只在你第一次引用变量时使用。实际上，你甚至不需要使用它，尽管如此，如果没有使用，变量将被假定为*全局的*。[变量作用域](apas05.html#variable_scope
    "变量作用域")在[变量作用域](apas05.html#variable_scope "变量作用域")中将解释这意味着什么以及为什么明确声明变量是一个好主意。你甚至可以在不创建值的情况下这样做：'
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When setting variables that hold text, you need to use quotes on each end of
    the value, for example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置包含文本的变量时，需要在值的每端使用引号，例如：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can use either single (`'`) or double (`"`) quotes to define your text literals,
    but you can't mix them. If you want to include the quote within your string, you
    need to escape it with a backslash.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用单引号(`'`)或双引号(`"`)来定义文本字面量，但不能混合使用。如果你想在你字符串中包含引号，你需要用反斜杠转义它。
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Another idiosyncrasy about text variables is covered in the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关于文本变量的另一个特性将在下一节中介绍。
- en: Arithmetic
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术
- en: In the previous section, I showed an example that calculated the `total_cost`
    by multiplying one variable times another, using an asterisk (`*`) character.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我展示了使用乘号(`*`)字符将一个变量乘以另一个变量来计算`total_cost`的例子。
- en: The `+`, `−`, `*`, `/`, and `=` signs are your tools when it comes to changing
    variable values. We've already seen that `=` sets a variable as *equal* to a value.
    Addition uses the plus sign, `+`. Subtraction uses the minus, `-`. Multiplication
    and division are accomplished by the asterisk, `*`, and slash, `/`, respectively.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`、`−`、`*`、`/`和`=`符号是改变变量值时的工具。我们已经看到`=`将变量设置为与值*相等*。加法使用加号`+`。减法使用减号`-`。乘法和除法分别通过星号`*`和斜杠`/`完成。'
- en: 'Here''s a more complex example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更复杂的例子：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The *mathematical order of operations* is followed, which means multiplication
    and division is performed first and everything is calculated left to right. You
    can force ordering by enclosing some operations within parentheses:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循**数学运算顺序**，这意味着先执行乘法和除法，然后从左到右进行计算。你可以通过将某些操作放在括号内来强制排序：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To save you some typing, a few shorthand arithmetic conventions are shown in
    Table A-1\. Use these when you need to alter a variable's value by some amount
    relative to its current value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省您的时间，表A-1中展示了几个简写算术约定。当您需要通过相对于当前值的某个量来更改变量的值时，请使用这些约定。
- en: Table A-1. Arithmetic Shorthand
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表A-1. 算术简写
- en: '| Shorthand | Long Version |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 简写 | 长版本 |'
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `num += 3;` | `num = num + 3;` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `num += 3;` | `num = num + 3;` |'
- en: '| `num++;` | `num = num + 1;` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `num++;` | `num = num + 1;` |'
- en: '| `num -= anothernum;` | `num = num − anothernum;` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `num -= anothernum;` | `num = num − anothernum;` |'
- en: '| `num--;` | `num = num − 1;` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `num--;` | `num = num − 1;` |'
- en: '| `num *= 2;` | `num = num * 2;` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `num *= 2;` | `num = num * 2;` |'
- en: '| `num /= 4;` | `num = num / 4;` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `num /= 4;` | `num = num / 4;` |'
- en: 'The plus sign, `+`, can also be used to *concatenate*—add together—text strings,
    for example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 加号`+`也可以用来*连接*——合并——文本字符串，例如：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Three separate strings are all combined here. The first and last are the `him`
    and `her` variables. The middle one is a literal string, which begins and ends
    with a space. If you were to `alert` the `together` variable, it would read *Adam
    and Eve*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将三个单独的字符串全部合并在一起。第一个和最后一个分别是`him`和`her`变量。中间的一个是字面字符串，它以空格开始和结束。如果您要`alert`（弹窗显示）`together`变量，它将显示为*亚当和夏娃*。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can also use the `+=` shorthand to concatenate strings. For example: `name
    += '' Smith''` will add the string to the end of the text in the `name` variable.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`+=`简写来连接字符串。例如：`name += ' Smith'`将字符串添加到`name`变量中的文本末尾。
- en: Arrays
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: So far I've covered two types of variables—numbers and text. Here I'll introduce
    a special kind of variable that holds multiple values. Or, put another way, it
    can contain an *array* of values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经介绍了两种类型的变量——数字和文本。在这里，我将介绍一种特殊的变量，它可以存储多个值。或者，换句话说，它可以包含一个*数组*的值。
- en: 'The values can be numbers, text, or a combination. You can also include other
    arrays or even objects (covered in the next section) within an array. Here is
    an example of an array declaration:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以是数字、文本或它们的组合。您还可以在数组中包含其他数组，甚至对象（下一节将介绍）。以下是一个数组声明的示例：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The values are separated by commas. The list is surrounded by square brackets,
    `[` and `]`. The same brackets are used to access the individual values according
    to where they appear in the list. For example, to pull `Rosemary` from the `herbs`
    variable, you use the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 值之间用逗号分隔。列表被方括号`[`和`]`包围。相同的括号用于根据它们在列表中的位置访问单个值。例如，要从`herbs`变量中提取`Rosemary`，您可以使用以下代码：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In JavaScript, as in most programming languages, array indexes begin at zero.
    Therefore, even though `Rosemary` is the third item in the list, you access it
    with number `2`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，就像在大多数编程语言中一样，数组索引从零开始。因此，尽管`Rosemary`是列表中的第三个项目，但您使用数字`2`来访问它。
- en: 'To determine how many items are in a list, you use the `length` attribute:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定列表中有多少项，您使用`length`属性：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In [Loops](apas04.html "Loops") in [Loops](apas04.html "Loops"), I'll show how
    to access each item in the array.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在[循环](apas04.html "循环")中，我将展示如何访问数组中的每个项目。
- en: Objects
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: Like arrays, objects hold multiple values. The difference is that you can express
    more structured data than a simple list. To do this, objects contain key and value
    pairs. Keys are word-like labels, but values can be numbers, text, arrays, or
    other objects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，对象可以存储多个值。区别在于，您可以表达比简单列表更结构化的数据。为此，对象包含键和值对。键是类似单词的标签，但值可以是数字、文本、数组或其他对象。
- en: 'Here''s a simple example representing a car:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个表示汽车的简单示例：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To access the values within the object, you use dot notation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问对象内的值，您使用点符号：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that you have seen the different ways of expressing data in JavaScript,
    let's do something with it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了在JavaScript中表示数据的不同方式，让我们来做些实际操作。
- en: Conditionals
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句
- en: Conditionals help you compare variables to other values (including other variables).
    This comparison happens in a *conditional statement*. Using conditionals is the
    basis of much programming, because they contain the logic that helps a computer
    "make decisions."
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句帮助您比较变量与其他值（包括其他变量）。这种比较发生在*条件语句*中。使用条件语句是许多编程的基础，因为它们包含帮助计算机“做出决定”的逻辑。
- en: 'The most common conditional is an `if` statement. You use it to provide code
    that is only used in a situation where the condition is true, for example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的条件语句是`if`语句。您使用它来提供仅在条件为真时才使用的代码，例如：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code inside the `{` and `}` braces will only run if the `num` variable is
    exactly `5`. The `==` operator is used to provide the *equals* comparison—in contrast
    to the single equals, which is used to *assign* a value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`{`和`}`大括号内的代码只有在`num`变量正好是`5`时才会运行。`==`操作符用于提供*等于*比较——与用于*赋值*的单个等号相反。
- en: You can use other comparison operators, as shown in Table A-2, for cases where
    you don't want the values to be exactly equal.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用其他比较操作符，如表A-2所示，在你不希望值完全相等的情况下使用。
- en: Table A-2. Conditional Operators
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 表A-2. 条件操作符
- en: '| Operator | Description |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `==` | Equal |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 等于 |'
- en: '| `!=` | Not equal |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 不等于 |'
- en: '| `>` | Greater than |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 大于 |'
- en: '| `<` | Less than |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 小于 |'
- en: '| `>=` | Greater than or equal |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 大于或等于 |'
- en: '| `<=` | Less than or equal |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 小于或等于 |'
- en: 'If you want to do something else if the condition is false, you can include
    an `else` statement immediately after an `if`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件为假时你想做其他事情，你可以在`if`语句之后立即包含一个`else`语句：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code within the `{` and `}` after the `else` statement only runs if the
    condition in the `if` statement is not true. In this example, the `else` code
    runs when `num` is zero or less. The `if` code runs in the other case (where `num`
    is greater than zero). You won't encounter an occasion where both `if` and `else`
    code runs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`else`语句之后的`{`和`}`大括号内的代码只有在`if`语句中的条件不成立时才会运行。在这个例子中，当`num`为零或更少时，`else`代码会运行。在其他情况下（`num`大于零），会运行`if`代码。你不会遇到同时运行`if`和`else`代码的情况。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An `else` statement cannot exist without an accompanying `if` statement. You
    can, however, have `if` statements without `else` statements.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`else`语句不能没有伴随的`if`语句。然而，你可以有没有`else`语句的`if`语句。
- en: 'You can also have an `if` statement without any operator. In those cases, the
    variable within the statement is called a *boolean*, which is either `true` or
    `false`. Here''s an example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以有一个没有任何操作符的`if`语句。在这些情况下，语句中的变量被称为*布尔值*，它可以是`true`或`false`。以下是一个示例：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `if (is_cool)` code is shorthand for the much longer `if (is_cool == true)`.
    You can also compare a variable to false in shorthand, using an exclamation point
    to mean "not," as in this example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (is_cool)`代码是较长的`if (is_cool == true)`的简写。你还可以使用感叹号表示“不是”来简写比较变量为假，如下例所示：'
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Sometimes a non-boolean variable can be a conditional, too. In that case, *empty*
    values are considered false. Empty values are `0` for numbers, `""` (empty string)
    for text, and `null` for objects. Also, any undefined variable is false.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个非布尔变量也可以作为条件。在这种情况下，*空值*被认为是假的。空值对于数字是`0`，对于文本是`""`（空字符串），对于对象是`null`。此外，任何未定义的变量也是假的。
- en: Loops
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'Loops are like special conditionals that run the code over and over until the
    condition is no longer true. I will cover two types of loops in this section:
    `for` loops and `while` loops.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 循环就像特殊的条件语句，它会反复运行代码，直到条件不再为真。在本节中，我将介绍两种类型的循环：`for`循环和`while`循环。
- en: 'In most cases, a loop has a number to count how many times you have used the
    loop. Here''s an example that runs 10 times:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，循环有一个数字来计数你使用了多少次循环。以下是一个运行10次的示例：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Three pieces are included inside the parentheses of the `for` statement. The
    initial value ❶, the condition under which the loop continues ❷, and the increment
    portion ❸. The first time through the loop, `i` is 0\. Then 1 and so on, as long
    as `i` is *less than* 10\. When `i` equals 10, the loop stops. But since we started
    at 0, the loop will have run 10 times.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句的括号内包含三个部分。初始值❶、循环继续的条件❷和增量部分❸。第一次通过循环时，`i`是0。然后是1，以此类推，只要`i`小于10。当`i`等于10时，循环停止。但由于我们从0开始，循环将运行10次。'
- en: 'The same can be achieved with a `while` loop using the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码使用`while`循环实现相同的效果：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In fact, if you look at the segments of the code in bold, you'll notice they
    match with the three pieces of a `for` statement. This `while` loop is logically
    equivalent.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你查看粗体代码段，你会注意到它们与`for`语句的三个部分相匹配。这个`while`循环在逻辑上是等价的。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you know how many times a loop will run, using `for` is probably easiest.
    When you don't know in advance the number of iterations needed (such as when you're
    searching for a value), use `while`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道循环将运行多少次时，使用`for`可能最简单。当你事先不知道所需的迭代次数（例如，当你正在搜索一个值时），使用`while`。
- en: 'Remember the `herbs` variable from the array section? To refresh your memory,
    we declared it like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 记得数组部分中的 `herbs` 变量吗？为了刷新你的记忆，我们这样声明它：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now let''s use a loop to do something with each value in the array. Because
    we know the total number of *iterations* (the length of the array), we''ll use
    a `for` loop. Here''s the code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用一个循环来对数组中的每个值进行一些操作。因为我们知道迭代的总次数（数组的长度），所以我们将使用 `for` 循环。以下是代码：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each time through the loop, we tack the current herb (the one in the index
    determined by the number `i`) to the end of the `allherbs` string. At the end
    of the loop, this is what is stored in that variable:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的每次迭代中，我们将当前草药（由数字 `i` 确定的索引处的那个）附加到 `allherbs` 字符串的末尾。循环结束时，这就是该变量中存储的内容：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've used a loop to concatenate the four values held in our array. This concept
    is used throughout the book, only not usually for adding strings together; instead,
    we use it to create hundreds of map markers in just a few lines or output all
    the results of a search.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用循环来连接数组中持有的四个值。这个概念在整本书中都有使用，只是通常不是用于添加字符串；相反，我们用它来在几行代码中创建数百个地图标记或输出搜索的所有结果。
- en: Loops are an important tool in limiting the code you need to write. But functions
    are perhaps the best tool to achieve simple, reusable code. Read on to see what
    I mean.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是限制你需要编写的代码的重要工具。但函数可能是实现简单、可重用代码的最好工具。继续阅读以了解我的意思。
- en: Functions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: If you're ready to upgrade your JavaScript programming abilities, writing functions
    is a good place to start. A function is a packaged-up piece of code for performing
    a particular operation. They can accept one or more variables and return a value
    if necessary. With functions, you can make your code more reusable and break your
    application into smaller pieces.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你准备好提升你的 JavaScript 编程能力，编写函数是一个好的开始。函数是一段打包的代码，用于执行特定的操作。它们可以接受一个或多个变量，并在必要时返回一个值。使用函数，你可以使你的代码更具可重用性，并将应用程序分解成更小的部分。
- en: 'For a basic example, we''ll create a function that outputs the greater of two
    numbers. This function already exists as `Math.max` (which can accept many values
    to compare), but it''s still a good example. Here''s the entire code for the function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一个基本的例子，我们将创建一个输出两个数中较大数的函数。这个函数已经以 `Math.max` 的形式存在（可以接受多个值进行比较），但它仍然是一个很好的例子。以下是该函数的完整代码：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Every function begins with the `function` declaration, followed by the name
    of the function. Then, within parentheses, you declare the parameters—variables—that
    your function will accept. In this case, we have two that I've named `num` and
    `another`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都以 `function` 声明开始，后跟函数名。然后，在括号内，你声明函数将接受的参数——变量。在这种情况下，我们有两个，我分别命名为 `num`
    和 `another`。
- en: The rest of the function, which resides inside `{` and `}` braces, should look
    familiar; it's just ordinary JavaScript code. When the function is called, you
    pass two variables, and the code runs based on that input. When you're ready to
    send a value back, you use the `return` statement to immediately exit the function
    and make its output equal to the variable (or literal value) you put after `return`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分，位于 `{` 和 `}` 大括号内，应该看起来很熟悉；它只是普通的 JavaScript 代码。当函数被调用时，你传递两个变量，代码根据输入运行。当你准备好发送一个值返回时，你使用
    `return` 语句立即退出函数，并使其输出等于 `return` 后面的变量（或字面量值）。
- en: 'I can probably explain it best with an example. Here''s how you might call
    the new `biggest` function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能最好用一个例子来解释它。这是调用新的 `biggest` 函数的方法：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: I've passed a variable (`somenum`) and a literal number to the function. I can
    use any combination of literal or variable values. And the names of my variables
    don't need to match those used within the function. They have different *scope*,
    as I'll explain in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我传递了一个变量（`somenum`）和一个字面量数字到函数中。我可以使用任何字面量或变量值的组合。我的变量名不需要与函数内部使用的变量名匹配。它们有不同的
    *作用域*，我将在下一节中解释。
- en: For normal boolean, number, and text variables, JavaScript makes a copy of the
    value and sends it to the function. That means if you make any changes to the
    values within the function, the original variables outside are unaffected. The
    same is not true of objects and arrays; in these cases you will be modifying the
    value of the original variable—even if the variable is not in the return.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通的布尔型、数字型和文本型变量，JavaScript 会复制其值并将其发送到函数中。这意味着如果你在函数内部对值进行任何修改，原始变量外部将不受影响。对于对象和数组来说，情况并非如此；在这些情况下，你将修改原始变量的值——即使变量不在返回值中。
- en: 'At the very beginning of this section, I mentioned that a function does not
    need to take parameters. In these instances, the function needs empty parentheses.
    Here''s a mapping-related example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开始，我提到一个函数不需要接受参数。在这些情况下，函数需要空括号。以下是一个与映射相关的示例：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This function would be used to set the map to a stored center point, as long
    as you have the variable in memory. I used a similar approach in [#34: Return
    to the Center When the Message Box Is Closed](ch05s09.html "#34: Return to the
    Center When the Message Box Is Closed") in [#34: Return to the Center When the
    Message Box Is Closed](ch05s09.html "#34: Return to the Center When the Message
    Box Is Closed"). The only way for it to work as shown is if `stored_center` is
    a global variable, visible from any JavaScript on the page.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '此函数将用于将地图设置为存储的中心点，只要你将变量保存在内存中。我在 [#34: 当消息框关闭时返回中心](ch05s09.html "#34: 当消息框关闭时返回中心")
    中使用了类似的方法。要使其按所示工作，唯一的方法是 `stored_center` 是一个全局变量，可以从页面上的任何 JavaScript 中访问。'
- en: Variable Scope
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量作用域
- en: In the previous sections, I demonstrated how to create variables. I also explained
    that the `var` keyword, although optional, is recommended. The reason behind this
    advice has to do with a variable's visibility—or its scope.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我演示了如何创建变量。我还解释了 `var` 关键字虽然不是必需的，但建议使用。这些建议背后的原因与变量的可见性——或者说其作用域有关。
- en: If you use a variable without including the `var` statement, the variable will
    automatically be considered *global*, as opposed to *local*. Global variables
    can be seen from any JavaScript on the page, including other functions. You can
    also explicitly make a variable global by declaring it outside a function, usually
    at the beginning of your JavaScript section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用一个没有包含 `var` 语句的变量，该变量将自动被认为是 *全局的*，而不是 *局部的*。全局变量可以从页面上的任何 JavaScript
    中看到，包括其他函数。你还可以通过在函数外部声明变量来显式地将变量设置为全局，通常在 JavaScript 部分的开头。
- en: 'Consider this example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What will the values of the three variables be when the JavaScript `alert` shows
    them? Let's walk through the code. When the page loads, we create a global variable
    ❶ and then we call the `call_first` function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JavaScript 的 `alert` 弹出时，三个变量的值将会是什么？让我们逐步分析代码。当页面加载时，我们创建一个全局变量❶，然后调用 `call_first`
    函数。
- en: Within the first function, we set a variable's value without using the `var`
    keyword ❷, making the variable, implicitly, a global variable. The third variable
    ❸ we create is a local variable because the `var` keyword is used within a function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个函数内部，我们设置了一个变量的值而没有使用 `var` 关键字❷，这使得该变量隐式地成为全局变量。我们创建的第三个变量❸是一个局部变量，因为我们在函数内部使用了
    `var` 关键字。
- en: With these three variables created in different ways, we then call our second
    function from within the first function. In this new function, we reset a global
    variable ❹, create a new local variable ❺, and create a new global variable ❻.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三种不同方式创建的三个变量后，我们然后在第一个函数内部调用我们的第二个函数。在这个新的函数中，我们重置一个全局变量❹，创建一个新的局部变量❺，并创建一个新的全局变量❻。
- en: When we return to our spot in the first function, the only variable that has
    changed for this scope is `firstvar`. The `secondvar` variable within the `then_me`
    function is local, so it does not alter the global `secondvar`. And even though
    `then_me`'s `thirdvar` is global, that does not alter a local variable with the
    same name inside the `call_first` function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们返回到第一个函数中的位置时，在这个作用域中唯一改变的变量是 `firstvar`。`then_me` 函数中的 `secondvar` 变量是局部的，因此它不会改变全局的
    `secondvar`。尽管 `then_me` 的 `thirdvar` 是全局的，但这不会改变 `call_first` 函数内部具有相同名称的局部变量。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To make things easier on yourself, be clear and always use the `var` keyword
    to declare variables explicitly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让自己更容易理解，要明确并始终使用 `var` 关键字显式声明变量。
- en: It's okay if it seems confusing. The good news is the process is logical, if
    you can follow it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能看起来有些复杂，但好消息是这个过程是逻辑的，只要你能够理解它。
- en: Anonymous Functions
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: A special kind of function gets used often in modern JavaScript, especially
    when reading in data (as you often do with maps). This function is called an anonymous
    function because it has no name. These functions are often passed as parameters
    to other functions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 JavaScript 中，经常使用一种特殊类型的函数，尤其是在读取数据时（就像你经常使用地图那样）。这个函数被称为匿名函数，因为它没有名字。这些函数通常作为参数传递给其他函数。
- en: 'Here''s a very basic example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常基础的示例：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The portion in bold is the anonymous function. It looks exactly like any other
    function, except a name is missing. Another strange thing is that here the function
    is slapped inside the parentheses of a call to another function, `call_another`.
    In that second function, we have one variable ❶, which holds the *reference* to
    our anonymous function. Then we can call it with the name of the reference variable
    ❷.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体部分是匿名函数。它看起来就像任何其他函数一样，只是缺少一个名字。另一件奇怪的事情是，这里函数被放在了另一个函数调用 `call_another` 的括号内。在那个第二个函数中，我们有一个变量
    ❶，它持有匿名函数的 *引用*。然后我们可以通过引用变量的名字 ❷ 来调用它。
- en: Sure enough, if you load that up and call the `start_here` function, you'll
    see an alert message from your anonymous function—via the second function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 确实如此，如果你加载它并调用 `start_here` 函数，你会看到来自你的匿名函数的警告消息——通过第二个函数。
- en: 'Here''s an example of a more common use for an anonymous function, reading
    JSON in from a web service using jQuery:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个匿名函数更常见用途的例子，使用 jQuery 从网络服务中读取 JSON：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We''re passing two values to jQuery''s `getJSON` function. The first is the
    URL of the JSON we want to retrieve. The second is our anonymous function—this
    time with a variable being passed to it. When evaluating the JSON data (see [#53:
    Use JSON](ch08s02.html "#53: Use JSON") in [#53: Use JSON](ch08s02.html "#53:
    Use JSON")), jQuery puts it into a JavaScript object, which is then passed to
    our anonymous function.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '我们向 jQuery 的 `getJSON` 函数传递了两个值。第一个是我们想要检索的 JSON 的 URL。第二个是我们匿名函数——这次传递了一个变量给它。当评估
    JSON 数据时（参见[第 53 节：使用 JSON](ch08s02.html "#53: Use JSON")），jQuery 会将其放入一个 JavaScript
    对象中，然后将其传递给我们的匿名函数。'
- en: 'Using anonymous functions is, in a way, shorthand. Here''s a longer version
    of this jQuery example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用匿名函数在某种程度上是一种简写。这是这个 jQuery 示例的更长版本：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Sure, you don't save *that much* time typing, but your code is often more readable.
    Littering your JavaScript with single-purpose functions isn't very clean. But
    perhaps the best reason to understand anonymous functions is that you'll probably
    see many of them in other people's code—including in this book.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你打字的时间并没有节省多少，但你的代码通常更易于阅读。在 JavaScript 中使用单用途函数会使代码变得杂乱无章。但了解匿名函数的最好理由可能是你可能会在其他人的代码中看到很多匿名函数——包括在这本书中。
- en: 'Anonymous functions should only be used in the situations where they''re most
    useful, however. If you find yourself writing a lot of code in an anonymous function,
    you might make it a named function. Also, watch out for creating anonymous functions
    inside a long loop. You''re essentially creating new functions every time through
    the loop, which is inefficient. And doing this is also counter to the purpose
    of functions: to write code once and run it many times.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，匿名函数只应该在它们最有用的场合下使用。如果你发现自己正在匿名函数中编写大量代码，你可能应该将其改为命名函数。此外，注意在长循环中创建匿名函数。你实际上在每次循环中创建新的函数，这是低效的。而且这样做也与函数的目的相悖：编写一次代码，多次运行。
- en: Using jQuery
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 jQuery
- en: In several places in this book, I make use of the JavaScript framework, jQuery.
    jQuery simplifies common tasks and provides a single interface to actions that
    are implemented inconsistently in different browsers. Perhaps the most common
    use of jQuery, especially in this book, is reading in files or other data from
    web services. This section is meant to give a quick introduction to using jQuery.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的几个地方，我使用了 JavaScript 框架 jQuery。jQuery 简化了常见任务，并为在不同浏览器中实现不一致的操作提供了一个统一的接口。jQuery
    在这本书中最常见的用途，尤其是本节，是从网络服务中读取文件或其他数据。本节旨在快速介绍使用 jQuery。
- en: 'Before you can use jQuery, you need to include it in your web page. You can
    do so by downloading the latest version at [http://jquery.com/](http://jquery.com/)
    or by grabbing a Google-hosted version by adding the following to the `<head>`
    section of your HTML file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够使用 jQuery 之前，你需要将其包含在你的网页中。你可以通过在 [http://jquery.com/](http://jquery.com/)
    下载最新版本，或者通过在你的 HTML 文件的 `<head>` 部分添加以下内容来获取 Google 托管的版本：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: One advantage to using the Google-hosted version is that many other sites do
    as well. That means when people come to your site, they may already have jQuery
    stored in their browser's cache. Even if they don't, they can download it quickly—currently
    the file is under 20KB.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Google 托管的版本的一个优点是，许多其他网站也是如此。这意味着当人们访问你的网站时，他们可能已经在浏览器缓存中存储了 jQuery。即使他们没有，他们也可以快速下载它——目前文件大小不到
    20KB。
- en: 'Once you have included jQuery in your document, you can use its functions via
    two global variables: `jQuery` and its shorthand, `$`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在文档中包含了jQuery，你就可以通过两个全局变量来使用它的函数：`jQuery`及其缩写`$`。
- en: Query Document Objects
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询文档对象
- en: Among its many uses, jQuery is very good at quickly and easily extracting elements
    from your HTML page into JavaScript code. You can query by `id`, tag name, CSS
    class, or combinations of these factors. jQuery makes this task easier, so you
    can focus on what you want to do with those elements.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在其众多用途中，jQuery非常擅长快速轻松地从你的HTML页面中提取元素到JavaScript代码中。你可以通过`id`、标签名、CSS类或这些因素的组合来进行查询。jQuery使这项任务变得更容易，这样你就可以专注于你想对这些元素做什么。
- en: 'To grab a single piece of the page, such as the map `<div>`, you call it by
    its `id`. Much of jQuery''s syntax is borrowed from CSS, which may look familiar.
    Here is how you would call an object with an `id` of `mymap`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取页面上的单个元素，例如地图`<div>`，你可以通过它的`id`来调用它。jQuery的大部分语法都借鉴了CSS，这可能会让你感到熟悉。以下是如何调用一个`id`为`mymap`的对象：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice I'm using the dollar-sign shorthand. Then I add parentheses because `$`
    is a variable and a function (jQuery stretches the bounds of JavaScript in ways
    that you and I probably won't). Inside the function, we pass a string with the
    CSS we'd use to style the map div, `#mymap`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我正在使用美元符号缩写。然后我添加括号，因为`$`是一个变量和一个函数（jQuery在JavaScript的边界上进行了扩展，你和我可能都不会这样做）。在函数内部，我们传递一个字符串，其中包含我们用来样式化地图`div`的CSS，`#mymap`。
- en: You've now used your first jQuery function to query for a specific element.
    You can achieve the same result with JavaScript's standard `document.getElementById`
    function, but jQuery's method is faster to type. Plus, the result using `$` allows
    you to chain other jQuery functions, such as visual effects.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经使用了第一个jQuery函数来查询特定元素。你可以用JavaScript的标准`document.getElementById`函数达到相同的效果，但jQuery的方法输入更快。此外，使用`$`的结果允许你链式调用其他jQuery函数，例如视觉效果。
- en: 'jQuery can also do more than just query individual elements; it can gather
    multiple elements in a single call. Here are a few examples:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery不仅可以查询单个元素，还可以在一次调用中收集多个元素。以下是一些示例：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Each of these examples shows a different type of querying—and many more are
    possible. You can learn about what jQuery calls *selectors* at [http://api.jquery.com/category/selectors/](http://api.jquery.com/category/selectors/).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了不同类型的查询——还有更多可能。你可以在[http://api.jquery.com/category/selectors/](http://api.jquery.com/category/selectors/)了解jQuery所称为的*选择器*。
- en: Insert and Hide Content
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入和隐藏内容
- en: Once you have one or more elements from the page using jQuery, you'll want to
    do something to them. In this section, I'll show you a way to add or replace the
    content inside a page element. And I'll also demonstrate an effect that will hide
    the content, so later, you can make it reappear.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用jQuery从页面上获取了一个或多个元素，你将想要对它们做些什么。在本节中，我将向你展示如何在页面元素内部添加或替换内容的方法。我还会演示一个效果，这样你就可以稍后使其重新出现。
- en: 'Let''s say you want an element on your page where you can show the results
    of some calculation. You can add the element with HTML using something like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要在页面上添加一个元素，你可以显示一些计算的结果。你可以使用类似以下方式使用HTML添加该元素：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When you''re ready to add the results, you can use jQuery to find the element
    and then display the results. If you want to display the content of a variable
    called `total`, you could use this single line of jQuery:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好添加结果时，你可以使用jQuery找到元素并显示结果。如果你想显示一个名为`total`的变量的内容，你可以使用以下单行jQuery：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This line will find the element on the page with the `id` of `results` and
    then replace its inner HTML with the value in the `total` variable. If you just
    want to add additional content to the element, use this line instead:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将找到页面上`id`为`results`的元素，并将其内部HTML替换为`total`变量的值。如果你只想向元素添加附加内容，请使用此行代码代替：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now the results section will look something like this (if the `total` variable
    is `42`):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在结果部分看起来可能像这样（如果`total`变量是`42`）：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You''ve seen how to insert content, but what about making that same content
    disappear? For example, before adding the results, a page with just `Results:`
    without anything after it looks a bit funny. So when the page loads (you''ll learn
    how in the next section), run the following code to hide the results element:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何插入内容，但关于使相同内容消失呢？例如，在添加结果之前，一个只有`Results:`而没有其他内容的页面看起来有点奇怪。所以当页面加载时（你将在下一节中学习如何做到这一点），运行以下代码来隐藏结果元素：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And when you''re ready to display the results to the user, include this code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好向用户显示结果时，包括以下代码：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: These two functions are simple (and very useful) examples of jQuery effects.
    Many more effects are listed on the jQuery website at [http://api.jquery.com/category/effects/](http://api.jquery.com/category/effects/).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数是 jQuery 效果的简单（且非常有用）示例。更多效果可以在 jQuery 网站上找到，地址为 [http://api.jquery.com/category/effects/](http://api.jquery.com/category/effects/)。
- en: Use Browser Events
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用浏览器事件
- en: Earlier in this book, I spent an entire chapter on events that happen on maps,
    such as clicking or dragging. You can also react to events anywhere in the browser,
    and jQuery makes reacting a simple process.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期，我花了一整章来介绍在地图上发生的事件，例如点击或拖动。你还可以在浏览器中的任何位置响应事件，jQuery 使响应过程变得简单。
- en: To respond to an event, you first need to be listening for it. When your page
    first loads, you register your intention to react to an event. You can do this
    by adding a JavaScript function to the `onload` attribute of your `<body>` tag.
    Or you can do this with a special jQuery event.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要响应事件，你首先需要监听它。当你的页面首次加载时，你注册你的意图来响应事件。你可以通过将 JavaScript 函数添加到 `<body>` 标签的
    `onload` 属性来实现，或者你可以使用特殊的 jQuery 事件来完成。
- en: 'Although creating an event to register other events may seem counterintuitive,
    it works. Here''s an example that waits until the page is ready:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建一个事件来注册其他事件可能看起来有些反直觉，但它确实有效。以下是一个等待页面准备好的示例：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Notice that the element we''re querying for is a little different than in the
    past. Instead of a string inside the parentheses, we''ve inserted a standard JavaScript
    object, `document`. When enough of the page has loaded that the browser knows
    all the objects it contains, we call the `register_events` function. That function
    doesn''t exist, however, so we need to write it. Or, instead, we could react to
    the same event with an anonymous function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们要查询的元素与过去略有不同。我们不再在括号内插入字符串，而是插入了一个标准的 JavaScript 对象，`document`。当页面加载足够多，浏览器知道它包含的所有对象时，我们调用
    `register_events` 函数。然而，该函数不存在，因此我们需要编写它。或者，我们可以用匿名函数来响应相同的事件：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As with most anonymous functions, you usually want to keep it to just a few
    lines. If you have many events to register, you are probably best served with
    a named function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数匿名函数一样，你通常希望将其保持为只有几行。如果你有很多事件需要注册，使用一个命名函数可能更适合你。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A big difference exists between using your browser's `onload` attribute and
    jQuery's `ready` event. With `onload`, you wait until the entire page is loaded,
    including images and other external files. With `$(document).ready`, you can run
    code, such as registering events and hiding objects, the moment the browser is
    ready. Using jQuery here often translates to a better user experience.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器 `onload` 属性和 jQuery 的 `ready` 事件之间存在很大差异。使用 `onload`，你等待整个页面加载完成，包括图像和其他外部文件。使用
    `$(document).ready`，你可以在浏览器准备好时立即运行代码，例如注册事件和隐藏对象。在这里使用 jQuery 通常意味着更好的用户体验。
- en: 'Now that you''ve waited for the browser to be ready to register other events,
    let''s register them. Here''s the basic pattern for jQuery events:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经等待浏览器准备好注册其他事件，让我们来注册它们。以下是 jQuery 事件的基模式：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The *`element`* portion is usually a selector, such as an element's `id` (though
    it can also be any browser object, as shown in the `ready` example). The *`event`*
    piece is the name of the function, as declared by jQuery. Finally, *`function`*
    is the function reference, either an anonymous function or the name of the function
    to call.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*`element`* 部分通常是选择器，例如元素的 `id`（尽管它也可以是任何浏览器对象，如 `ready` 示例所示）。*`event`* 部分是函数的名称，由
    jQuery 声明。最后，*`function`* 是函数引用，可以是匿名函数或要调用的函数名称。'
- en: 'Here''s how you''d listen for a particular element to be clicked:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何监听特定元素被点击的示例：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you're familiar with JavaScript events included in HTML, you might be wondering
    where the `on`, as in `onClick`, went. In jQuery, events are referenced with only
    the action.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 HTML 中包含的 JavaScript 事件，你可能想知道 `on`，如 `onClick` 去哪里了。在 jQuery 中，事件仅通过动作来引用。
- en: 'You can also get additional information about the event. The information available
    may be a little different depending on the event. Here''s how you find out where
    the user has double-clicked on a page:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以获取有关事件的额外信息。可用的信息可能因事件而异。以下是如何找出用户在页面上双击的位置：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Instead of a `click` event, I used a `dblclick` event. Because we want more
    information about the event, I included an optional parameter ❶ to the anonymous
    function. Within the function, I can use that variable to get information, such
    as where the user clicked. This data comes in two pieces: the number of pixels
    from the left side of the page ❷ and the number from the top of the page ❸.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有使用`click`事件，而是使用了`dblclick`事件。因为我们想要更多关于事件的详细信息，我在匿名函数中包含了一个可选参数❶。在函数内部，我可以使用这个变量来获取信息，例如用户点击的位置。这些数据分为两部分：从页面左侧的像素数❷和从页面顶部的像素数❸。
- en: You can see a sampling of available events in Table A-3, along with the additional
    information that is passed in the optional parameter to each event.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在表A-3中看到可用事件的样本，以及每个事件可选参数中传递的附加信息。
- en: Table A-3. Some Useful jQuery Events
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 表A-3. 一些有用的jQuery事件
- en: '| Event Name | Objects Available | Additional Information |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 事件名称 | 可用对象 | 其他信息 |'
- en: '| --- | --- | --- |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `click` | Any | Page location: `pageX`, `pageY` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `click` | 任意 | 页面位置：`pageX`，`pageY` |'
- en: '| `dblclick` | Any | Page location: `pageX`, `pageY` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `dblclick` | 任意 | 页面位置：`pageX`，`pageY` |'
- en: '| `mousemove` | Any | Page location: `pageX`, `pageY` |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `mousemove` | 任意 | 页面位置：`pageX`，`pageY` |'
- en: '| `keydown` | `document`, `window` | Key code: `which` |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `keydown` | `document`，`window` | 键码：`which` |'
- en: '| `focus` | Form elements |   |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `focus` | 表单元素 |  |'
- en: Events will make your web pages much more interactive, whether or not they contain
    maps. For a full list of events (and additional event information available),
    see jQuery's documentation at [http://api.jquery.com/category/events/](http://api.jquery.com/category/events/).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 事件会使你的网页更加互动，无论它们是否包含地图。有关事件的全列表（以及可用的附加事件信息），请参阅jQuery的文档[http://api.jquery.com/category/events/](http://api.jquery.com/category/events/)。
- en: Load Files and Data
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载文件和数据
- en: If you want to interact with data outside of your current HTML file, jQuery
    has some excellent tools for doing these sorts of Ajax calls. Though Ajax is short
    for *Asynchronous JavaScript And XML*, you can access any type of data with Ajax.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要与当前HTML文件外的数据进行交互，jQuery提供了一些出色的工具来进行这类Ajax调用。尽管Ajax代表的是*异步JavaScript和XML*，但你可以使用Ajax访问任何类型的数据。
- en: 'To load a file with jQuery, you use the `get` function. `get` needs at least
    two parameters: the URL you want to load and the function to which you want jQuery
    to send the results. Here''s a simple example for loading a text file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用jQuery加载文件，你使用`get`函数。`get`至少需要两个参数：你想要加载的URL以及jQuery想要发送结果的函数。以下是一个加载文本文件的简单示例：
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The URL ❶ I provided is just the name of a file. In this case, the file is
    text, but it could be a bit of HTML code or another type of content. In [#52:
    Use XML](ch08.html#number_symble_52_colon_use_xml "#52: Use XML") in [#52: Use
    XML](ch08.html#number_symble_52_colon_use_xml "#52: Use XML"), I show how to parse
    XML results with the `get` function.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '我提供的URL只是一个文件的名称。在这种情况下，文件是文本，但它也可能是HTML代码或其他类型的内容。在[第52节：使用XML](ch08.html#number_symble_52_colon_use_xml
    "#52: Use XML")中，我展示了如何使用`get`函数解析XML结果。'
- en: 'You aren''t restricted to only loading simple files. You could include directory
    names or even a full URL. Whatever you load needs to be on the same domain that
    you are making the call on. For security reasons, browsers will not let you retrieve
    data from someone else''s site, even if that data is meant to be public. You can
    get around this by loading the file server-side (as shown in [#61: Retrieve a
    Web Page](ch09s03.html "#61: Retrieve a Web Page") in [#61: Retrieve a Web Page](ch09s03.html
    "#61: Retrieve a Web Page")) and then accessing the local copy.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '你不仅限于只加载简单的文件。你可以包括目录名，甚至完整的URL。无论你加载什么，都需要在同一个域名上。出于安全原因，浏览器不会让你从其他网站检索数据，即使这些数据是公开的。你可以通过在服务器端加载文件（如[第61节：检索网页](ch09s03.html
    "#61: Retrieve a Web Page")中所示）然后访问本地副本来解决这个问题。'
- en: 'A special case exists that allows you to load data from another site. If the
    site provides JSON data and it allows you to specify a callback function in the
    URL, then you can load the data remotely using jQuery''s `getJSON` function. Here''s
    the basic structure:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个特殊情况，允许你从另一个网站加载数据。如果该网站提供JSON数据，并且它允许你在URL中指定回调函数，那么你可以使用jQuery的`getJSON`函数远程加载数据。以下是基本结构：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The URL you send to the `getJSON` function ❷ needs to contain a question mark
    in place of the name of a function. Then jQuery will create a function and call
    your anonymous function (or named function, if you choose) from its new function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你发送给 `getJSON` 函数的 URL ❷ 需要包含一个问号来代替函数名称。然后 jQuery 将创建一个函数，并从其新函数中调用你的匿名函数（或者如果你选择，命名函数）。
- en: Another way `getJSON` is different from `get` is in the type of data passed
    in the parameters to your callback function. Rather than the plain text returned
    to the URL, jQuery passes you parsed JSON in the form of a JavaScript object.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`getJSON` 与 `get` 另一个不同之处在于传递给回调函数的参数类型。而不是返回给 URL 的纯文本，jQuery 会以 JavaScript
    对象的形式将解析后的 JSON 传递给你。'
- en: 'You''ll find a more complete example of `getJSON` in [#53: Use JSON](ch08s02.html
    "#53: Use JSON") in [#53: Use JSON](ch08s02.html "#53: Use JSON"). Also, you can
    see examples of the function used in a real project in several of the mashups
    in [Chapter 10](ch10.html "Chapter 10. MASHUP PROJECTS").'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以在 [第53节：使用 JSON](ch08s02.html "#53: Use JSON") 中找到 `getJSON` 的一个更完整的示例。此外，你还可以在
    [第10章](ch10.html "第10章。MASHUP 项目") 中几个 mashup 示例中看到该函数在实际项目中的应用。'
