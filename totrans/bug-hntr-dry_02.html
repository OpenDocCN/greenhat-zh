<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Back to the &#x2019;90s"><div class="titlepage"><div><div><h1 class="title"><a id="back_to_the_a90s"/>Chapter 2. Back to the ’90s</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Sunday, October 12, 2008</em></span><a id="IDX-CHP-2-0001" class="indexterm"/></p><p><span class="emphasis"><em>Dear Diary</em></span>,</p></div><p>I had a look at the source code of VideoLAN’s popular VLC media player today. I like VLC because it supports all different kinds of media files and runs on all my favorite operating system platforms. But supporting all those different media file formats has downsides. VLC does a lot of parsing, and that often means a lot of bugs just waiting to be discovered.<a id="IDX-CHP-2-0002" class="indexterm"/><a id="IDX-CHP-2-0003" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>According to <span class="emphasis"><em>Parsing Techniques: A Practical Guide</em></span> by Dick Grune and Ceriel J.H. Jacobs,<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-1" class="footnoteref">6</a>]</sup> “Parsing is the process of structuring a linear representation in accordance with a given grammar.” A parser is software that breaks apart a raw string of bytes into individual words and statements. Depending on the data format, parsing can be a very complex and error-prone task.<a id="IDX-CHP-2-0004" class="indexterm"/></p></div><p>After I became familiar with the inner workings of VLC, finding the first vulnerability took me only about half a day. It was a classic stack buffer overflow (see Section A.1). This one occurred while parsing a media file format called TiVo, the proprietary format native to TiVo digital recording devices. Before finding this bug, I had never heard of this file format, but that didn’t stop me from exploiting it.<a id="IDX-CHP-2-0005" class="indexterm"/></p><div class="sect1" title="2.1 Vulnerability Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_discovery"/>2.1 Vulnerability Discovery</h1></div></div></div><p>Here is how I found the vulnerability:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: Generate a list of the demuxers of VLC.<a id="IDX-CHP-2-0006" class="indexterm"/></p></li><li class="listitem"><p>Step 2: Identify the input data.</p></li><li class="listitem"><p>Step 3: Trace the input data.</p></li></ul></div><p>I’ll explain this process in detail in the following sections.</p><div class="sect2" title="Step 1: Generate a List of the Demuxers of VLC"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_generate_a_list_of_the_demu"/>Step 1: Generate a List of the Demuxers of VLC</h2></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>I used VLC 0.9.4 on the Microsoft Windows Vista SP1 (32-bit) platform for all the following steps</em></span>.<a id="IDX-CHP-2-0007" class="indexterm"/></p></div><p>After downloading and unpacking the source code of VLC,<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-2" class="footnoteref">7</a>]</sup> I generated a list of the available demuxers of the media player.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In digital video, <span class="emphasis"><em>demuxing</em></span> or <span class="emphasis"><em>demultiplexing</em></span> refers to the process of separating audio and video as well as other data from a video stream or container in order to play the file. A demuxer is software that extracts the components of such a stream or container.</p></div><p>Generating a list of demuxers wasn’t too hard, as VLC separates most of them in different C files in the directory <span class="emphasis"><em>vlc-0.9.4\modules\demux\</em></span> (see <a class="xref" href="ch02.html#vlc_demuxer_list" title="Figure 2-1. VLC demuxer list">Figure 2-1</a>).</p><div class="figure"><a id="vlc_demuxer_list"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e717"/><img src="httpatomoreillycomsourcenostarchimages939229.png.jpg" alt="VLC demuxer list"/></div></div><p class="title">Figure 2-1. VLC demuxer list</p></div></div><div class="sect2" title="Step 2: Identify the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_identify_the_input_data"/>Step 2: Identify the Input Data</h2></div></div></div><p>Next, I tried to identify the input data processed by the demuxers. After reading some C code, I stumbled upon the following structure, which is declared in a header file included in every demuxer.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>vlc-0.9.4\include\vlc_demux.h</em></span></p></dd></dl></div><a id="I_programlisting2_d1e736"/><pre class="programlisting">[..]
<strong class="userinput"><code>41    struct demux_t</code></strong>
42    {
43       VLC_COMMON_MEMBERS
44
45       /* Module properties */
46       module_t    *p_module;
47
48       /* eg informative but needed (we can have access+demux) */
49       char        *psz_access;
50       char        *psz_demux;
51       char        *psz_path;
52
<strong class="userinput"><code>53       /* input stream */</code></strong>
<strong class="userinput"><code>54       stream_t    *s;     /* NULL in case of a access+demux in one */</code></strong>
[..]</pre><p>In line 54, the structure element <code class="literal">s</code> is declared and described as <code class="literal">input stream</code>. This was exactly what I was searching for: a reference to the input data that is processed by the demuxers.</p></div><div class="sect2" title="Step 3: Trace the Input Data"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_trace_the_input_data"/>Step 3: Trace the Input Data</h2></div></div></div><p>After I discovered the <code class="literal">demux_t</code> structure and its input stream element, I searched the demuxer files for references to it. The input data was usually referenced by <code class="literal">p_demux-&gt;s</code>, as shown in lines 1623 and 1641 below. When I found such a reference, I traced the input data while looking for coding errors. Using this approach, I found the following vulnerability.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Source code file</strong></span></span></dt><dd><p><span class="emphasis"><em>vlc-0.9.4\modules\demux\Ty.c</em></span></p></dd><dt><span class="term"><span class="strong"><strong>Function</strong></span></span></dt><dd><p><code class="literal">parse_master()</code></p></dd></dl></div><a id="I_programlisting2_d1e783"/><pre class="programlisting">[..]
1623    static void parse_master(<strong class="userinput"><code>demux_t *p_demux</code></strong>)
1624    {
1625        demux_sys_t *p_sys = p_demux-&gt;p_sys;
<strong class="userinput"><code>1626        uint8_t mst_buf[32];</code></strong>
<strong class="userinput"><code>1627        int i, i_map_size;</code></strong>
1628        int64_t i_save_pos = stream_Tell(p_demux-&gt;s);
1629        int64_t i_pts_secs;
1630
1631        /* Note that the entries in the SEQ table in the stream may have
1632           different sizes depending on the bits per entry.  We store them
1633           all in the same size structure, so we have to parse them out one
1634           by one.  If we had a dynamic structure, we could simply read the
1635           entire table directly from the stream into memory in place. */
1636
1637        /* clear the SEQ table */
1638        free(p_sys-&gt;seq_table);
1639
1640        /* parse header info */
<strong class="userinput"><code>1641        stream_Read(p_demux-&gt;s, mst_buf, 32);</code></strong>
<strong class="userinput"><code>1642        i_map_size = U32_AT(&amp;mst_buf[20]);  /* size of bitmask, in bytes */</code></strong>
1643        p_sys-&gt;i_bits_per_seq_entry = i_map_size * 8;
1644        i = U32_AT(&amp;mst_buf[28]);   /* size of SEQ table, in bytes */
1645        p_sys-&gt;i_seq_table_size = i / (8 + i_map_size);
1646
1647        /* parse all the entries */
1648        p_sys-&gt;seq_table = malloc(p_sys-&gt;i_
seq_table_size * sizeof(ty_seq_table_t));
1649        for (i=0; i&lt;p_sys-&gt;i_seq_table_size; i++) {
<strong class="userinput"><code>1650             stream_Read(p_demux-&gt;s, mst_buf, 8 + i_map_size);</code></strong>
[..]</pre><p>The <code class="literal">stream_Read()</code> function in line 1641 reads 32 bytes of user-controlled data from a TiVo media file (referenced by <code class="literal">p_demux-&gt;s</code>) and stores them in the stack buffer <code class="literal">mst_buf</code>, declared in line 1626. The <code class="literal">U32_AT</code> macro in line 1642 then extracts a user-controlled value from <code class="literal">mst_buf</code> and stores it in the signed int variable <code class="literal">i_map_size</code>. In line 1650, the <code class="literal">stream_Read()</code> function stores user-controlled data from the media file in the stack buffer <code class="literal">mst_buf</code> again. But this time, <code class="literal">stream_Read()</code> uses the user-controlled value of <code class="literal">i_map_size</code> to calculate the size of the data that gets copied into <code class="literal">mst_buf</code>. This leads to a straight stack buffer overflow (see Section A.1) that can be easily exploited.</p><p>Here is the anatomy of the bug, as illustrated in <a class="xref" href="ch02s02.html#overview_of_the_vulnerability_from_input" title="Figure 2-2. Overview of the vulnerability from input to stack buffer overflow">Figure 2-2</a>:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>32 bytes of user-controlled TiVo media file data are copied into the stack buffer <code class="literal">mst_buf</code>. The destination buffer has a size of 32 bytes.</p></li><li class="listitem"><p>4 bytes of user-controlled data are extracted from the buffer and stored in <code class="literal">i_map_size</code>.</p></li><li class="listitem"><p>User-controlled TiVo media-file data is copied into <code class="literal">mst_buf</code> once again. This time, the size of the copied data is calculated using <code class="literal">i_map_size</code>. If <code class="literal">i_map_size</code> has a value greater than 24, a stack buffer overflow will occur (see Section A.1).</p></li></ol></div></div></div></div>
<div class="sect1" title="2.2 Exploitation"><div class="titlepage"><div><div><h1 class="title"><a id="exploitation"/>2.2 Exploitation</h1></div></div></div><p>To exploit the vulnerability, I performed the following steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Step 1: Find a sample TiVo movie file.</p></li><li class="listitem"><p>Step 2: Find a code path to reach the vulnerable code.</p></li><li class="listitem"><p>Step 3: Manipulate the TiVo movie file to crash VLC.</p></li><li class="listitem"><p>Step 4: Manipulate the TiVo movie file to gain control of <code class="literal">EIP</code>.</p></li></ul></div><div class="figure"><a id="overview_of_the_vulnerability_from_input"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e893"/><img src="httpatomoreillycomsourcenostarchimages939231.png.jpg" alt="Overview of the vulnerability from input to stack buffer overflow"/></div></div><p class="title">Figure 2-2. Overview of the vulnerability from input to stack buffer overflow</p></div><p>There’s more than one way to exploit a file-format bug. You can create a file with the right format from scratch, or you can manipulate a valid preexisting file. I chose the latter in this example.</p><div class="sect2" title="Step 1: Find a Sample TiVo Movie File"><div class="titlepage"><div><div><h2 class="title"><a id="step_1_colon_find_a_sample_tivo_movie_fi"/>Step 1: Find a Sample TiVo Movie File</h2></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>The website</em></span> <a class="ulink" href="http://samples.mplayerhq.hu/">http://samples.mplayerhq.hu/</a> <span class="emphasis"><em>is a good starting point to search for all kinds of multimedia file-format samples</em></span></p></div><p>First I downloaded the following TiVo sample file from <a class="ulink" href="http://samples.mplayerhq.hu/">http://samples.mplayerhq.hu/</a>:</p><a id="I_programlisting2_d1e916"/><pre class="programlisting"><strong class="userinput"><code>$ wget http://samples.mplayerhq.hu/TiVo/test-dtivo-junkskip.ty%2b</code></strong>
--2008-10-12 21:12:25--  http://samples.mplayerhq.hu/TiVo/test-dtivo-junkskip.ty%2b
Resolving samples.mplayerhq.hu... 213.144.138.186
Connecting to samples.mplayerhq.hu|213.144.138.186|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 5242880 (5.0M) [text/plain]
Saving to: `test-dtivo-junkskip.ty+'

100%[=========================&gt;] 5,242,880    240K/s   in 22s

2008-10-12 21:12:48 (232 KB/s) - `test-dtivo-junkskip.ty+' saved [5242880/5242880]</pre></div><div class="sect2" title="Step 2: Find a Code Path to Reach the Vulnerable Code"><div class="titlepage"><div><div><h2 class="title"><a id="step_2_colon_find_a_code_path_to_reach_t"/>Step 2: Find a Code Path to Reach the Vulnerable Code</h2></div></div></div><p>I couldn’t find documentation on the specifications of the TiVo file format, so I read the source code in order to find a path to reach the vulnerable code in <code class="literal">parse_master()</code>.</p><p>If a TiVo file is loaded by VLC, the following execution flow is taken (all source code references are from <span class="emphasis"><em>vlc-0.9.4\modules\demux\Ty.c</em></span> of VLC). The first relevant function that’s called is <code class="literal">Demux()</code>:</p><a id="I_programlisting2_d1e936"/><pre class="programlisting">[..]
<strong class="userinput"><code>386    static int Demux( demux_t *p_demux )</code></strong>
387    {
388        demux_sys_t  *p_sys = p_demux-&gt;p_sys;
389        ty_rec_hdr_t *p_rec;
390        block_t      *p_block_in = NULL;
391
392        /*msg_Dbg(p_demux, "ty demux processing" );*/
393
394        /* did we hit EOF earlier? */
395        if( p_sys-&gt;eof )
396            return 0;
397
398        /*
399         * what we do (1 record now.. maybe more later):
400         * - use stream_Read() to read the chunk header &amp; record headers
401         * - discard entire chunk if it is a PART header chunk
402         * - parse all the headers into record header array
403         * - keep a pointer of which record we're on
404         * - use stream_Block() to fetch each record
405         * - parse out PTS from PES headers
406         * - set PTS for data packets
407         * - pass the data on to the proper codec via es_out_Send()
408
409         * if this is the first time or
410         * if we're at the end of this chunk, start a new one
411         */
412        /* parse the next chunk's record headers */
413        if( p_sys-&gt;b_first_chunk || p_sys-&gt;i_cur_rec &gt;= p_sys-&gt;i_num_recs )
414        {
<strong class="userinput"><code>415               if( get_chunk_header(p_demux) == 0 )</code></strong>
[..]</pre><p>After some sanity checks in lines 395 and 413, the function <code class="literal">get_chunk_header()</code> is called in line 415.</p><a id="I_programlisting2_d1e949"/><pre class="programlisting">[..]
 <strong class="userinput"><code>112    #define TIVO_PES_FILEID   ( 0xf5467abd )</code></strong>
[..]
1839    static int get_chunk_header(demux_t *p_demux)
1840    {
1841        int i_readSize, i_num_recs;
1842        uint8_t *p_hdr_buf;
1843        const uint8_t *p_peek;
1844        demux_sys_t *p_sys = p_demux-&gt;p_sys;
1845        int i_payload_size;                /* sum of all records' sizes */
1846
1847        msg_Dbg(p_demux, "parsing ty chunk #%d", p_sys-&gt;i_cur_chunk );
1848
1849        /* if we have left-over filler space from the last chunk, get that */
1850        if (p_sys-&gt;i_stuff_cnt &gt; 0) {
1851            stream_Read( p_demux-&gt;s, NULL, p_sys-&gt;i_stuff_cnt);
1852            p_sys-&gt;i_stuff_cnt = 0;
1853        }
1854
1855        /* read the TY packet header */
<strong class="userinput"><code>1856        i_readSize = stream_Peek( p_demux-&gt;s, &amp;p_peek, 4 );</code></strong>
1857        p_sys-&gt;i_cur_chunk++;
1858
1859        if ( (i_readSize &lt; 4) || ( U32_AT(&amp;p_peek[ 0 ] ) == 0 ))
1860        {
1861            /* EOF */
1862            p_sys-&gt;eof = 1;
1863            return 0;
1864        }
1865
1866        /* check if it's a PART Header */
<strong class="userinput"><code>1867        if( U32_AT( &amp;p_peek[ 0 ] ) == TIVO_PES_FILEID )</code></strong>
1868        {
1869            /* parse master chunk */
<strong class="userinput"><code>1870            parse_master(p_demux);</code></strong>
1871            return get_chunk_header(p_demux);
1872        }
[..]</pre><p>In line 1856 of <code class="literal">get_chunk_header()</code>, the user-controlled data from the TiVo file is assigned to the pointer <code class="literal">p_peek</code>. Then, in line 1867, the process checks whether the file data pointed to by <code class="literal">p_peek</code> equals <code class="literal">TIVO_PES_FILEID</code> (which is defined as <code class="literal">0xf5467abd</code> in line 112). If so, the vulnerable function <code class="literal">parse_master()</code> gets called (see line 1870).</p><p>To reach the vulnerable function using this code path, the TiVo sample file had to contain the value of <code class="literal">TIVO_PES_FILEID</code>. I searched the TiVo sample file for the <code class="literal">TIVO_PES_FILEID</code> pattern and found it at file offset <code class="literal">0x00300000</code> (see <a class="xref" href="ch02s02.html#tivo_underscore_pes_underscore_fileid_pa" title="Figure 2-3. TIVO_PES_FILEID pattern in TiVo sample file">Figure 2-3</a>).</p><div class="figure"><a id="tivo_underscore_pes_underscore_fileid_pa"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1002"/><img src="httpatomoreillycomsourcenostarchimages939233.png.jpg" alt="TIVO_PES_FILEID pattern in TiVo sample file"/></div></div><p class="title">Figure 2-3. <code class="literal">TIVO_PES_FILEID</code> pattern in TiVo sample file</p></div><p>Based on the information from the <code class="literal">parse_master()</code> function (see the following source code snippet) the value of <code class="literal">i_map_size</code> should be found at offset 20 (<code class="literal">0x14</code>) relative to the <code class="literal">TIVO_PES_FILEID</code> pattern found at file offset <code class="literal">0x00300000</code>.</p><a id="I_programlisting2_d1e1024"/><pre class="programlisting">[..]
1641     stream_Read(p_demux-&gt;s, mst_buf, 32);
1642     i_map_size = U32_AT(&amp;mst_buf[<strong class="userinput"><code>20</code></strong>]);  /* size of bitmask, in bytes */
[..]</pre><p>At this point, I had discovered that the TiVo sample file I downloaded already triggers the vulnerable <code class="literal">parse_master()</code> function, so it wouldn’t be necessary to adjust the sample file. Great!</p></div><div class="sect2" title="Step 3: Manipulate the TiVo Movie File to Crash VLC"><div class="titlepage"><div><div><h2 class="title"><a id="step_3_colon_manipulate_the_tivo_movie_f"/>Step 3: Manipulate the TiVo Movie File to Crash VLC</h2></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Get the vulnerable Windows version of VLC from</em></span> <a class="ulink" href="http://download.videolan.org/pub/videolan/vlc/0.9.4/win32/">http://download.videolan.org/pub/videolan/vlc/0.9.4/win32/</a>.</p></div><p>Next, I tried to manipulate the TiVo sample file in order to crash VLC. To achieve this, all I had to do was change the 4-byte value at the sample file offset of <code class="literal">i_map_size</code> (which was <code class="literal">0x00300014</code> in this example).</p><p>As illustrated in <a class="xref" href="ch02s02.html#new_value_for_i_underscore_map_underscor" title="Figure 2-4. New value for i_map_size in TiVo sample file">Figure 2-4</a>, I changed the 32-bit value at file offset <code class="literal">0x00300014</code> from <code class="literal">0x00000002</code> to <code class="literal">0x000000ff</code>. The new value of 255 bytes (<code class="literal">0xff</code>) should be enough to overflow the 32-byte stack buffer and to overwrite the return address stored after the buffer on the stack (see Section A.1). Next, I opened the altered sample file with VLC while debugging the media player with Immunity Debugger.<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-3" class="footnoteref">8</a>]</sup> The movie file was played as before, but after a few seconds—as soon as the altered file data was processed—the VLC player crashed, with the result shown in <a class="xref" href="ch02s02.html#vlc_access_violation_in_immunity_debugge" title="Figure 2-5. VLC access violation in Immunity Debugger">Figure 2-5</a>.<a id="IDX-CHP-2-0008" class="indexterm"/><a id="IDX-CHP-2-0009" class="indexterm"/></p><div class="figure"><a id="new_value_for_i_underscore_map_underscor"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1088"/><img src="httpatomoreillycomsourcenostarchimages939235.png.jpg" alt="New value for i_map_size in TiVo sample file"/></div></div><p class="title">Figure 2-4. New value for <code class="literal">i_map_size</code> in TiVo sample file</p></div><div class="figure"><a id="vlc_access_violation_in_immunity_debugge"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1096"/><img src="httpatomoreillycomsourcenostarchimages939237.png.jpg" alt="VLC access violation in Immunity Debugger"/></div></div><p class="title">Figure 2-5. VLC access violation in Immunity Debugger</p></div><p>As expected, VLC crashed while parsing the malformed TiVo file. The crash was very promising, since the instruction pointer (<code class="literal">EIP</code> register) was pointing to an invalid memory location (indicated by the message <code class="literal">Access violation when executing [20030000]</code> in the status bar of the debugger). This might mean that I could easily gain control of the instruction pointer.</p></div><div class="sect2" title="Step 4: Manipulate the TiVo Movie File to Gain Control of EIP"><div class="titlepage"><div><div><h2 class="title"><a id="step_4_colon_manipulate_the_tivo_movie_f"/>Step 4: Manipulate the TiVo Movie File to Gain Control of EIP</h2></div></div></div><p>My next step was to determine which bytes of the sample file actually overwrote the return address of the current stack frame so that I could take control of <code class="literal">EIP</code>. The debugger stated that <code class="literal">EIP</code> had a value of <code class="literal">0x20030000</code> at the time of the crash. To determine which offset this value is found at, I could try to calculate the exact file offset, or I could simply search the file for the byte pattern. I chose the latter approach and started from file offset <code class="literal">0x00300000</code>. I found the desired byte sequence at file offset <code class="literal">0x0030005c</code>, represented in little-endian notation, and I changed the 4 bytes to the value <code class="literal">0x41414141</code> (as illustrated in <a class="xref" href="ch02s02.html#new_value_for_eip_in_tivo_sample_file" title="Figure 2-6. New value for EIP in TiVo sample file">Figure 2-6</a>).<a id="IDX-CHP-2-0010" class="indexterm"/></p><div class="figure"><a id="new_value_for_eip_in_tivo_sample_file"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1144"/><img src="httpatomoreillycomsourcenostarchimages939239.png.jpg" alt="New value for EIP in TiVo sample file"/></div></div><p class="title">Figure 2-6. New value for <code class="literal">EIP</code> in TiVo sample file</p></div><p>I then restarted VLC in the debugger and opened the new file (see <a class="xref" href="ch02s02.html#eip_control_of_vlc_media_player" title="Figure 2-7. EIP control of VLC media player">Figure 2-7</a>).</p><div class="figure"><a id="eip_control_of_vlc_media_player"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1158"/><img src="httpatomoreillycomsourcenostarchimages939241.png.jpg" alt="EIP control of VLC media player"/></div></div><p class="title">Figure 2-7. <code class="literal">EIP</code> control of VLC media player</p></div><p><code class="literal">EIP = 41414141</code> . . . Mission <code class="literal">EIP</code> control accomplished! I was able to build a working exploit, intended to achieve arbitrary code execution, using the well-known <code class="literal">jmp reg</code> technique, as described in “Variations in Exploit Methods Between Linux and Windows” by David Litchfield.<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-4" class="footnoteref">9</a>]</sup><a id="IDX-CHP-2-0011" class="indexterm"/><a id="IDX-CHP-2-0012" class="indexterm"/><a id="IDX-CHP-2-0013" class="indexterm"/><a id="IDX-CHP-2-0014" class="indexterm"/><a id="IDX-CHP-2-0015" class="indexterm"/><a id="IDX-CHP-2-0016" class="indexterm"/><a id="IDX-CHP-2-0017" class="indexterm"/><a id="IDX-CHP-2-0018" class="indexterm"/><a id="IDX-CHP-2-0019" class="indexterm"/></p><p>Since Germany has strict laws against it, I will not provide you with a full working exploit, but if you’re interested, you can watch a short video I recorded that shows the exploit in action.<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-5" class="footnoteref">10</a>]</sup></p></div></div>
<div class="sect1" title="2.3 Vulnerability Remediation"><div class="titlepage"><div><div><h1 class="title"><a id="vulnerability_remediation"/>2.3 Vulnerability Remediation</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Saturday, October 18, 2008</em></span></p></div><p>Now that I’ve discovered a security vulnerability, I could disclose it in several ways. I could contact the software developer and “responsibly” tell him what I’ve found and help him to create a patch. This process is referred to as <span class="emphasis"><em>responsible disclosure</em></span>. Since this term implies that other means of disclosure are irresponsible, which isn’t necessarily true, it is slowly being replaced by <span class="emphasis"><em>coordinated disclosure</em></span>.<a id="IDX-CHP-2-0020" class="indexterm"/><a id="IDX-CHP-2-0021" class="indexterm"/></p><p>On the other hand, I could sell my findings to a <span class="emphasis"><em>vulnerability broker</em></span> and let him tell the software developer. Today, the two primary players in the commercial vulnerability market are Verisign’s iDefense Labs, with its Vulnerability Contribution Program (VCP), and Tipping Point’s Zero Day Initiative (ZDI). Both VCP and ZDI follow coordinated-disclosure practices and work with the affected vendor.<a id="IDX-CHP-2-0022" class="indexterm"/></p><p>Another option is <span class="emphasis"><em>full disclosure</em></span>. If I chose full disclosure, I would release the vulnerability information to the public without notifying the vendor. There are other disclosure options, but the motivation behind them usually doesn’t involve fixing the bug (for example, selling the findings in underground markets).<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-6" class="footnoteref">11</a>]</sup><a id="IDX-CHP-2-0023" class="indexterm"/></p><p>In the case of the VLC vulnerability described in this chapter, I chose coordinated disclosure. In other words, I notified the VLC maintainers, provided them with the necessary information, and coordinated with them on the timing of public disclosure.</p><p>After I informed the VLC maintainers about the bug, they developed the following patch to address the vulnerability:<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-7" class="footnoteref">12</a>]</sup></p><a id="I_programlisting2_d1e1254"/><pre class="programlisting">--- a/modules/demux/ty.c
+++ b/modules/demux/ty.c
@@ −1639,12 +1639,14 @@ static void parse_master(demux_t *p_demux)
     /* parse all the entries */
     p_sys-&gt;seq_table = malloc(p_sys-&gt;i_seq_table_size * sizeof(ty_seq_table_t));
     for (i=0; i&lt;p_sys-&gt;i_seq_table_size; i++) {
<strong class="userinput"><code>-        stream_Read(p_demux-&gt;s, mst_buf, 8 + i_map_size);</code></strong>
<strong class="userinput"><code>+        stream_Read(p_demux-&gt;s, mst_buf, 8);</code></strong>
         p_sys-&gt;seq_table[i].l_timestamp = U64_AT(&amp;mst_buf[0]);
         if (i_map_size &gt; 8) {
             msg_Err(p_demux, "Unsupported SEQ bitmap size in master chunk");
<strong class="userinput"><code>+            stream_Read(p_demux-&gt;s, NULL, i_map_size);</code></strong>
             memset(p_sys-&gt;seq_table[i].chunk_bitmask, i_map_size, 0);
         } else {
<strong class="userinput"><code>+            stream_Read(p_demux-&gt;s, mst_buf + 8, i_map_size);</code></strong>
             memcpy(p_sys-&gt;seq_table[i].chunk_bitmask, &amp;mst_buf[8], i_map_size);
         }
     }</pre><p>The changes are quite straightforward. The formerly vulnerable call to <code class="literal">stream_Read()</code> now uses a fixed size value, and the user-controlled value of <code class="literal">i_map_size</code> is used only as a size value for <code class="literal">stream_Read()</code> if it is less than or equal to 8. An easy fix for an obvious bug.<a id="IDX-CHP-2-0024" class="indexterm"/><a id="IDX-CHP-2-0025" class="indexterm"/><a id="IDX-CHP-2-0026" class="indexterm"/><a id="IDX-CHP-2-0027" class="indexterm"/><a id="IDX-CHP-2-0028" class="indexterm"/></p><p>But wait—is the vulnerability really gone? The variable <code class="literal">i_map_size</code> is still of the type signed int. If a value greater than or equal to <code class="literal">0x80000000</code> is supplied for <code class="literal">i_map_size</code>, it’s interpreted as negative, and the overflow will still occur in the <code class="literal">stream_Read()</code> and <code class="literal">memcpy()</code> functions of the <code class="literal">else</code> branch of the patch (see Section A.3 for a description of unsigned int and signed int ranges). I also reported this problem to the VLC maintainers, resulting in another patch:<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-8" class="footnoteref">13</a>]</sup></p><a id="I_programlisting2_d1e1317"/><pre class="programlisting">[..]
@@ −1616,7 +1618,7 @@ static void parse_master(demux_t *p_demux)

 {
     demux_sys_t *p_sys = p_demux-&gt;p_sys;
     uint8_t mst_buf[32];
<strong class="userinput"><code>-    int i, i_map_size;</code></strong>
<strong class="userinput"><code>+    uint32_t i, i_map_size;</code></strong>
     int64_t i_save_pos = stream_Tell(p_demux-&gt;s);
     int64_t i_pts_secs;
[..]</pre><p>Now that <code class="literal">i_map_size</code> is of the type unsigned int, this bug is fixed. Perhaps you’ve already noticed that the <code class="literal">parse_master()</code> function contains another buffer overflow vulnerability. I also reported that bug to the VLC maintainers. If you can’t spot it, then take a closer look at the second patch provided by the VLC maintainers, which fixed this bug as well.</p><p>One thing that surprised me was the fact that none of the lauded exploit mitigation techniques of Windows Vista were able to stop me from taking control of <code class="literal">EIP</code> and executing arbitrary code from the stack using the <code class="literal">jmp reg</code> technique. The security cookie or /GS feature should have prevented the manipulation of the return address. Furthermore, ASLR or NX/DEP should have prevented arbitrary code execution. (See Section C.1 for a detailed description of all of these mitigation techniques.)<a id="IDX-CHP-2-0029" class="indexterm"/><a id="IDX-CHP-2-0030" class="indexterm"/><a id="IDX-CHP-2-0031" class="indexterm"/></p><p>To solve this mystery, I downloaded Process Explorer<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-9" class="footnoteref">14</a>]</sup> and configured it to show the processes’ DEP and ASLR status.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>To configure Process Explorer to show the processes’ DEP and ASLR status, I added the following columns to the view: <span class="strong"><strong>View</strong></span> ▸ <span class="strong"><strong>Select Columns</strong></span> ▸ <span class="strong"><strong>DEP Status</strong></span> and <span class="strong"><strong>View</strong></span> ▸ <span class="strong"><strong>Select Columns</strong></span> ▸ <span class="strong"><strong>ASLR Enabled</strong></span>. Additionally, I set the lower pane to view DLLs for a process and added the “ASLR Enabled” column.</p></div><p>The output of Process Explorer, illustrated in <a class="xref" href="ch02s03.html#vlc_in_process_explorer" title="Figure 2-8. VLC in Process Explorer">Figure 2-8</a>, shows that VLC and its modules use neither DEP nor ASLR (this is denoted by an empty value in the DEP and ASLR columns). I investigated further to determine why the VLC process does not use these mitigation techniques.</p><div class="figure"><a id="vlc_in_process_explorer"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1384"/><img src="httpatomoreillycomsourcenostarchimages939243.png.jpg" alt="VLC in Process Explorer"/></div></div><p class="title">Figure 2-8. VLC in Process Explorer</p></div><p>DEP can be controlled by system policy through special APIs and compile-time options (see Microsoft’s Security Research and Defense blog<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-10" class="footnoteref">15</a>]</sup> for more information on DEP). The default system-wide DEP policy for client operating systems such as Windows Vista is called OptIn. In this mode of operation, DEP is enabled only for processes that explicitly opt in to DEP. Because I used a default installation of Windows Vista 32-bit, the system-wide DEP policy should be set to OptIn. To verify this, I used the <code class="literal">bcdedit.exe</code> console application from an elevated command prompt:</p><a id="I_programlisting2_d1e1396"/><pre class="programlisting">C:\Windows\system32&gt;<strong class="userinput"><code>bcdedit /enum | findstr nx</code></strong>
nx                      OptIn</pre><p>The output of the command shows that the system was indeed configured to use the OptIn operation mode of DEP, which explains why VLC doesn’t use this mitigation technique: The process simply doesn’t opt in to DEP.</p><p>There are different ways to opt a process in to DEP. For example, you could use the appropriate linker switch (/NXCOMPAT) at compile time, or you could use the <code class="literal">SetProcessDEPPolicy</code> API to allow an application to opt in to DEP programmatically.<a id="IDX-CHP-2-0032" class="indexterm"/><a id="IDX-CHP-2-0033" class="indexterm"/></p><p>To get an overview of the security-relevant compile-time options used by VLC, I scanned the executable files of the media player with LookingGlass (see <a class="xref" href="ch02s03.html#lookingglass_scan_result_of_vlc" title="Figure 2-9. LookingGlass scan result of VLC">Figure 2-9</a>).<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-11" class="footnoteref">16</a>]</sup><a id="IDX-CHP-2-0034" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In 2009, Microsoft released a tool called BinScope Binary Analyzer, which analyzes binaries for a wide variety of security protections with a very straightforward and easy-to-use interface.<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-12" class="footnoteref">17</a>]</sup></p></div><p>LookingGlass showed that the linker switch for neither ASLR nor DEP was used to compile VLC.<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-13" class="footnoteref">18</a>]</sup> The Windows releases of VLC media player are built using the Cygwin<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-14" class="footnoteref">19</a>]</sup> environment, a set of utilities designed to provide the look and feel of Linux within the Windows operating system. Since the linker switches that I mentioned are supported only by Microsoft’s Visual C++ 2005 SP1 and later (and thus are not supported by Cygwin), it isn’t a big surprise that they aren’t supported by VLC.</p><p><span class="emphasis"><em>Exploit mitigation techniques of Microsoft’s Visual C++ 2005 SP1 and later</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>/GS for stack cookies/canaries</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>/DYNAMICBASE for ASLR</em></span>.</p></li><li class="listitem"><p><span class="emphasis"><em>/NXCOMPAT for DEP/NX</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>/SAFESEH for exception handler protection</em></span></p></li></ul></div><div class="figure"><a id="lookingglass_scan_result_of_vlc"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1458"/><img src="httpatomoreillycomsourcenostarchimages939245.png.jpg" alt="LookingGlass scan result of VLC"/></div></div><p class="title">Figure 2-9. LookingGlass scan result of VLC</p></div><p>See the following excerpt from the VLC build instructions:<a id="IDX-CHP-2-0035" class="indexterm"/></p><a id="I_programlisting2_d1e1468"/><pre class="programlisting">[..]
Building VLC from the source code
=================================
[..]
- natively on Windows, using cygwin (www.cygwin.com) with or
 without the POSIX emulation layer. This is the preferred way to compile
 vlc if you want to do it on Windows.
[..]
UNSUPPORTED METHODS
-------------------
[..]
- natively on Windows, using Microsoft Visual Studio. This will not work.
[..]</pre><p>At the time of this writing, VLC didn’t make use of any of the exploit mitigation techniques provided by Windows Vista or later releases. As a result, every bug in VLC under Windows is as easily exploited today as 20 years ago, when none of these security features were widely deployed or supported.</p></div>
<div class="sect1" title="2.4 Lessons Learned"><div class="titlepage"><div><div><h1 class="title"><a id="lessons_learned"/>2.4 Lessons Learned</h1></div></div></div><p>As a programmer:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Never trust user input (this includes file data, network data, etc.).</p></li><li class="listitem"><p>Never use unvalidated length or size values.</p></li><li class="listitem"><p>Always make use of the exploit mitigation techniques offered by modern operating systems wherever possible. Under Windows, software has to be compiled with Microsoft’s Visual C++ 2005 SP1 or later, and the appropriate compiler and linker options have to be used. In addition, Microsoft has released the <span class="emphasis"><em>Enhanced Mitigation Experience Toolkit</em></span>,<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-15" class="footnoteref">20</a>]</sup> which allows specific mitigation techniques to be applied without recompilation.</p></li></ul></div><p>As a user of media players:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Don’t ever trust media file extensions (see Section 2.5 below).</p></li></ul></div></div>
<div class="sect1" title="2.5 Addendum"><div class="titlepage"><div><div><h1 class="title"><a id="addendum"/>2.5 Addendum</h1></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Monday, October 20, 2008</em></span></p></div><p>Since the vulnerability was fixed and a new version of VLC is now available, I released a detailed security advisory on my website (<a class="xref" href="ch02s05.html#timeline_of_the_vulnerability" title="Figure 2-10. Timeline of the vulnerability">Figure 2-10</a> shows the timeline).<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-16" class="footnoteref">21</a>]</sup> The bug was assigned CVE-2008-4654.<a id="IDX-CHP-2-0036" class="indexterm"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>According to the documentation provided by MITRE,<sup>[<a href="ch02s05.html#ftn.CHP-2-FN-17" class="footnoteref">22</a>]</sup> <span class="emphasis"><em>Common Vulnerabilities and Exposures Identifiers</em></span> (also called <span class="emphasis"><em>CVE names</em></span>, <span class="emphasis"><em>CVE numbers</em></span>, <span class="emphasis"><em>CVE-IDs</em></span>, and <span class="emphasis"><em>CVEs</em></span>) are “unique, common identifiers for publicly known information security vulnerabilities.”<a id="IDX-CHP-2-0037" class="indexterm"/></p></div><div class="figure"><a id="timeline_of_the_vulnerability"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e1543"/><img src="httpatomoreillycomsourcenostarchimages939247.png.jpg" alt="Timeline of the vulnerability"/></div></div><p class="title">Figure 2-10. Timeline of the vulnerability</p></div><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Monday, January 5, 2009</em></span></p></div><p>In reaction to the bug and my detailed advisory, I got a lot of mail with various questions from worried VLC users. There were two questions that I saw over and over:</p><div class="blockquote"><blockquote class="blockquote"><p>I have never heard of the TiVo media format before. Why would I ever open such an obscure media file?</p><p>Am I secure if I don’t open TiVo media files in VLC anymore?</p></blockquote></div><p>These are valid questions, so I asked myself how I would normally learn about the format of a media file I downloaded via the Internet with no more information than the file extension. I could fire up a hex editor and have a look at the file header, but to be honest, I don’t think ordinary people would go to the trouble. But are file extensions trustworthy? No, they aren’t. The regular file extension for TiVo files is <span class="emphasis"><em>.ty</em></span>. But what stops an attacker from changing the filename from <span class="emphasis"><em>fun.ty</em></span> to <span class="emphasis"><em>fun.avi</em></span>, <span class="emphasis"><em>fun.mov</em></span>, <span class="emphasis"><em>fun.mkv</em></span>, or whatever she likes? The file will still be opened and processed as a TiVo file by the media player, since VLC, like almost all media players, does not use file extensions to recognize the media format.</p><div class="sect2" title="Notes"><div class="titlepage"><div><div><h2 class="title"><a id="notes-id1"/>Notes</h2></div></div></div><p><sup>[<a id="CHP-2-FN-1" href="#ftn.CHP-2-FN-1" class="footnote">6</a>]</sup></p><p><sup>[<a id="CHP-2-FN-2" href="#ftn.CHP-2-FN-2" class="footnote">7</a>]</sup></p><p><sup>[<a id="CHP-2-FN-3" href="#ftn.CHP-2-FN-3" class="footnote">8</a>]</sup></p><p><sup>[<a id="CHP-2-FN-4" href="#ftn.CHP-2-FN-4" class="footnote">9</a>]</sup></p><p><sup>[<a id="CHP-2-FN-5" href="#ftn.CHP-2-FN-5" class="footnote">10</a>]</sup></p><p><sup>[<a id="CHP-2-FN-6" href="#ftn.CHP-2-FN-6" class="footnote">11</a>]</sup></p><p><sup>[<a id="CHP-2-FN-7" href="#ftn.CHP-2-FN-7" class="footnote">12</a>]</sup></p><p><sup>[<a id="CHP-2-FN-8" href="#ftn.CHP-2-FN-8" class="footnote">13</a>]</sup></p><p><sup>[<a id="CHP-2-FN-9" href="#ftn.CHP-2-FN-9" class="footnote">14</a>]</sup></p><p><sup>[<a id="CHP-2-FN-10" href="#ftn.CHP-2-FN-10" class="footnote">15</a>]</sup></p><p><sup>[<a id="CHP-2-FN-11" href="#ftn.CHP-2-FN-11" class="footnote">16</a>]</sup></p><p><sup>[<a id="CHP-2-FN-12" href="#ftn.CHP-2-FN-12" class="footnote">17</a>]</sup></p><p><sup>[<a id="CHP-2-FN-13" href="#ftn.CHP-2-FN-13" class="footnote">18</a>]</sup></p><p><sup>[<a id="CHP-2-FN-14" href="#ftn.CHP-2-FN-14" class="footnote">19</a>]</sup></p><p><sup>[<a id="CHP-2-FN-15" href="#ftn.CHP-2-FN-15" class="footnote">20</a>]</sup></p><p><sup>[<a id="CHP-2-FN-16" href="#ftn.CHP-2-FN-16" class="footnote">21</a>]</sup><a id="IDX-CHP-2-0038" class="indexterm"/></p><p><sup>[<a id="CHP-2-FN-17" href="#ftn.CHP-2-FN-17" class="footnote">22</a>]</sup></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-1" href="#CHP-2-FN-1" class="para">6</a>] </sup>See Dick Grune and Ceriel J.H. Jacobs, <span class="emphasis"><em>Parsing Techniques: A Practical Guide</em></span>, 2nd ed. (New York: Springer Science+Business Media, 2008), 1.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-2" href="#CHP-2-FN-2" class="para">7</a>] </sup>The vulnerable source code version of VLC can be downloaded at <a class="ulink" href="http://download.videolan.org/pub/videolan/vlc/0.9.4/vlc-0.9.4.tar.bz2">http://download.videolan.org/pub/videolan/vlc/0.9.4/vlc-0.9.4.tar.bz2</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-3" href="#CHP-2-FN-3" class="para">8</a>] </sup>Immunity Debugger is a great Windows debugger based on OllyDbg. It comes with a nice GUI and a lot of extra features and plug-ins to support bug hunting and exploit development. It can be found at <a class="ulink" href="http://www.immunityinc.com/products-immdbg.shtml">http://www.immunityinc.com/products-immdbg.shtml</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-4" href="#CHP-2-FN-4" class="para">9</a>] </sup>See David Litchfield, “Variations in Exploit Methods Between Linux and Windows,” 2003, <a class="ulink" href="http://www.nccgroup.com/Libraries/Document_Downloads/Variations_in_Exploit_methods_between_Linux_and_Windows.sflb.ashx">http://www.nccgroup.com/Libraries/Document_Downloads/Variations_in_Exploit_methods_between_Linux_and_Windows.sflb.ashx</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-5" href="#CHP-2-FN-5" class="para">10</a>] </sup>See <a class="ulink" href="http://www.trapkit.de/books/bhd/">http://www.trapkit.de/books/bhd/</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-6" href="#CHP-2-FN-6" class="para">11</a>] </sup>For more information on responsible, coordinated, and full disclosure as well as the commercial vulnerability market, consult Stefan Frei, Dominik Schatzmann, Bernhard Plattner, and Brian Trammel, “Modelling the Security Ecosystem—The Dynamics of (In)Security,” 2009, <a class="ulink" href="http://www.techzoom.net/publications/security-ecosystem/">http://www.techzoom.net/publications/security-ecosystem/</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-7" href="#CHP-2-FN-7" class="para">12</a>] </sup>The Git repository of VLC can be found at <a class="ulink" href="http://git.videolan.org/">http://git.videolan.org/</a>. The first fix issued for this bug can be downloaded from <a class="ulink" href="http://git.videolan.org/?p=vlc.git;a=commitdiff;h=26d92b87bba99b5ea2e17b7eaa39c462d65e9133">http://git.videolan.org/?p=vlc.git;a=commitdiff;h=26d92b87bba99b5ea2e17b7eaa39c462d65e9133</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-8" href="#CHP-2-FN-8" class="para">13</a>] </sup>The fix for the subsequent VLC bug that I found can be downloaded from <a class="ulink" href="http://git.videolan.org/?p=vlc.git;a=commitdiff;h=d859e6b9537af2d7326276f70de25a840f554dc3">http://git.videolan.org/?p=vlc.git;a=commitdiff;h=d859e6b9537af2d7326276f70de25a840f554dc3</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-9" href="#CHP-2-FN-9" class="para">14</a>] </sup>To download Process Explorer, visit <a class="ulink" href="http://technet.microsoft.com/en-en/sysinternals/bb896653/">http://technet.microsoft.com/en-en/sysinternals/bb896653/</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-10" href="#CHP-2-FN-10" class="para">15</a>] </sup>See <a class="ulink" href="http://blogs.technet.com/b/srd/archive/2009/06/12/understanding-dep-as-a-mitigation-technology-part-1.aspx">http://blogs.technet.com/b/srd/archive/2009/06/12/understanding-dep-as-a-mitigation-technology-part-1.aspx</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-11" href="#CHP-2-FN-11" class="para">16</a>] </sup>LookingGlass is a handy tool to scan a directory structure or the running processes to report which binaries do not make use of ASLR and NX. It can be found at <a class="ulink" href="http://www.erratasec.com/lookingglass.html">http://www.erratasec.com/lookingglass.html</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-12" href="#CHP-2-FN-12" class="para">17</a>] </sup>To download BinScope Binary analyzer, visit <a class="ulink" href="http://go.microsoft.com/?linkid=9678113">http://go.microsoft.com/?linkid=9678113</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-13" href="#CHP-2-FN-13" class="para">18</a>] </sup>A good article on the exploit mitigation techniques introduced by Microsoft Visual C++ 2005 SP1 and later: Michael Howard, “Protecting Your Code with Visual C++ Defenses,” <span class="emphasis"><em>MSDN Magazine</em></span>, March 2008, <a class="ulink" href="http://msdn.microsoft.com/en-us/magazine/cc337897.aspx">http://msdn.microsoft.com/en-us/magazine/cc337897.aspx</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-14" href="#CHP-2-FN-14" class="para">19</a>] </sup>See <a class="ulink" href="http://www.cygwin.com/">http://www.cygwin.com/</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-15" href="#CHP-2-FN-15" class="para">20</a>] </sup>The Enhanced Mitigation Experience Toolkit is available at <a class="ulink" href="http://blogs.technet.com/srd/archive/2010/09/02/enhanced-mitigation-experience-toolkit-emet-v2-0-0.aspx">http://blogs.technet.com/srd/archive/2010/09/02/enhanced-mitigation-experience-toolkit-emet-v2-0-0.aspx</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-16" href="#CHP-2-FN-16" class="para">21</a>] </sup>My security advisory that describes the details of the VLC vulnerability can be found at <a class="ulink" href="http://www.trapkit.de/advisories/TKADV2008-010.txt">http://www.trapkit.de/advisories/TKADV2008-010.txt</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-2-FN-17" href="#CHP-2-FN-17" class="para">22</a>] </sup>See <a class="ulink" href="http://cve.mitre.org/cve/identifiers/index.html">http://cve.mitre.org/cve/identifiers/index.html</a>.</p></div></div></div></body></html>