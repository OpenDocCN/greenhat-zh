["```\n  #!/usr/bin/env ruby\n  # html_tidy.rb\n  # cleans up html files\n\n❶ EMPTY_STRING = ''\n\n  SIMPLE_TAG_REPLACEMENTS = {\n\n    #closers\n    /\\<\\/b\\>/i             => '</strong>',    ***`=>`** Operator*\n    /\\<\\/i\\>/i             => '</em>',\n    /\\<\\/strong\\><\\/td\\>/i => '</th>',\n    /\\<\\/u\\>/i             => '</div>',\n\n    #openers\n    /\\<b\\>/i               => '<strong>',\n    /\\<i\\>/i               => '<em>',\n    /\\<td\\>\\<strong\\>/i    => '<th>',\n    /\\<u\\>/i               => '<div style=\"text-decoration: underline;\">',\n    # again, more as appropriate\n\n  }\n  TIDY_EXTENSION = '.tidy'\n\n  TIDY_OPTIONS = '-asxml -bc' # possible add -access 3\n\n❷ UNWANTED_REGEXES = [\n    /^<meta name=\\\"GENERATOR\\\" content=\\\"Microsoft FrontPage 5.0\\\">$/,\n    /^ *$/,\n    /^\\n$/,\n    # more as appropriate\n  ]\n\n❸ def declare_regexes_and_replacements()\n    replacement_of = Hash.new()\n    UNWANTED_REGEXES.each do |discard|\n      replacement_of[discard] = EMPTY_STRING\n    end\n    return replacement_of.merge(SIMPLE_TAG_REPLACEMENTS)\n  end\n\n  =begin rdoc\n  This lacks a ! suffix because it duplicates the argument and\n  returns the changes made to that duplicate, rather than overwriting.\n  =end\n❹ def perform_replacements_on_contents(contents)\n    output = contents.dup\n    replacement_of = declare_regexes_and_replacements()\n❺   replacement_of.keys.sort_by { |r| r.to_s }.each do |regex|\n      replace = replacement_of[regex]\n❻     output.each { |line| line.gsub!(regex, replace) }\n    end\n    return output\n  end\n\n  =begin rdoc\n  This has the ! suffix because it destructively writes\n  into the filename argument provided.\n  =end\n❼ def perform_replacements_on_filename!(filename)\n❽   if (system('which tidy > /dev/null'))\n      new_filename = filename + TIDY_EXTENSION\n      system(\"tidy #{TIDY_OPTIONS} #{filename} > #{new_filename} 2> /dev/null\")    *Standard Error*\n❾     contents = File.open(new_filename, 'r').readlines()\n      new_contents = perform_replacements_on_contents(contents)\n      File.open(new_filename, 'w') { |f| f.puts(new_contents) }\n    else\n      puts \"Please install tidy.\\n\"\n    end\n  end\n\n❿ ARGV.each do |filename|\n    perform_replacements_on_filename!(filename)\n  end\n```", "```\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n<html\n    lang=\"en\"\n    xml:lang=\"en\"\n    >\n\n<head>\n<meta http-equiv=\"refresh\" content=\"10\" />\n<title>English Horn for No Clergy</title>\n<style>\n@import url('../css/noclergy.css');\nh1, h2 { display: none; }\n</style>\n</head>\n\n<body>\n\n<div id=\"notation\">\n<h1>No Clergy:</h1>\n<p style=\"text-align:center;\">\n<img src=\"../../png/eh-page1.png\" />\n</p>\n</div>\n\n<table>\n<tr>\n<td><b>I'm a header, but I don't know it.</b></td>\n<td><u>I'm some underlined content.</u></td>\n<td><i>I'm some italicized content.</i></td>\n</tr>\n</table>\n\n<p>I'm an unclosed paragraph. The horrors.\n\n</body>\n</html>\n```", "```\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n    \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html lang=\"en\" xml:lang=\"en\" >\n<head>\n<meta name=\"generator\" content=\n\"HTML Tidy for Linux/x86 (vers 1 September 2005), see www.w3.org\" />\n<meta http-equiv=\"refresh\" content=\"10\" />\n<title>English Horn for No Clergy</title>\n\n<style type=\"text/css\">\n/*<![CDATA[*/\n@import url('../css/noclergy.css');\nh1, h2 { display: none; }\n/*]]>*/\n</style>\n\n<style type=\"text/css\">\n/*<![CDATA[*/\n p.c1 {text-align:center;}\n/*]]>*/\n</style>\n</head>\n<body>\n<div id=\"notation-id001\">\n<h1>No Clergy:</h1>\n<p class=\"c1\"><img src=\"../../png/eh-page1.png\" /></p>\n</div>\n<table>\n<tr>\n<th>I'm a header, but I don't know it.</th>\n<td><div style=\"text-decoration: underline;\">I'm some underlined content.\n</div></td>\n<td><em>I'm some italicized content.</em></td>\n</tr>\n</table>\n<p>I'm an unclosed paragraph. The horrors.</p>\n</body>\n</html>\n```", "```\ndef declare_regexes_and_replacements()    *Hashes from Arrays with inject*\n  return UNWANTED_REGEXES.inject({}) do |h,discard|\n    h.merge( { discard => EMPTY_STRING } )\n  end.merge(SIMPLE_TAG_REPLACEMENTS)\nend\n```", "```\n  #!/usr/bin/env ruby\n  # xml_tag_counter.rb\n\n  =begin rdoc\n  This script uses the Rexml parser, which is written in Ruby itself.\n  Find out more at http://www.germane-software.com/software/rexml.\n  =end\n❶ require 'rexml/document'    *REXML*\n\n  class Hash\n\n❷ =begin rdoc\n  Given that <b>self</b> is a <b>Hash</b> with keys of\n  XML tags and values of their respective counts in an\n  XML source file, sort by the tag count, descending.\n  Fall back to an ascending sort of the tag itself,\n  weighted half as strongly.\n  =end\n    def sort_by_tag_count()\n      self.sort do |a, b|\n❸       ( (b[1] <=> a[1]) * 2 ) + (a[0] <=> b[0])\n      end\n    end\n\n❹ =begin rdoc\n  Merge with another <b>Hash</b>, but add values rather\n  than simply overwriting duplicate keys.\n  =end\n    def merge_totals(other_hash)    *Hashes as Histograms*\n      other_hash.keys.each do |key|\n        self[key] += other_hash[key]\n      end\n    end\n\n❺ =begin rdoc\n  Your basic pretty formatter, returns a <b>String</b>.\n  =end\n    def pretty_report()\n      output = ''\n      sort_by_tag_count.each do |pair|\n        tag, count = pair\n        output += \"#{tag}: #{count}\\n\"\n      end\n      return output\n    end\n\n  end # Hash\n❻ =begin rdoc\n  Returns DOM elements of a given filename.\n  =end\n  def get_elements_from_filename(filename)\n    REXML::Document.new(File.open(filename)).elements()\n  end\n\n❼ =begin rdoc\n  Returns a <b>Hash</b> with keys of XML tags and values\n  of those tags' counts within a given XML document.\n  Calls itself recursively on each tag's elements.\n  =end\n  def tag_count(elements)\n❽   count_of = Hash.new(0) # note the default value of 0\n    elements.to_a.each do |tag|\n      count_of[tag.name()] += 1\n❾     count_of.merge_totals(tag_count(tag.elements))\n    end\n    return count_of\n  end\n\n❿ puts tag_count(get_elements_from_file(ARGV[0])).pretty_report()\n```", "```\nirb(main):001:0> h = { 0 => 1, 1 => 2 }\n=> {0=>1, 1=>2}\nirb(main):002:0> h.sort\n=> [[0, 1], [1, 2]]\n```", "```\nirb(main):001:0> h = { 0 => 1 }\n=> {0=>1}\nirb(main):002:0> h[1]\n=> nil\nirb(main):003:0> h[1] + 0\nNoMethodError: undefined method '+' for nil:NilClass\n        from (irb):3\n        from :0\n```", "```\ndiv: 2\nmeta: 2\np: 2\nstyle: 2\ntd: 2\nbody: 1\nem: 1\nh1: 1\nhead: 1\nhtml: 1\nimg: 1\ntable: 1\nth: 1\ntitle: 1\ntr: 1\n```", "```\ndef sorted_by_tag_count()\n  # sort_by_tag_count returns an Array of Arrays...\n  sort_by_tag_count.inject({}) do |memo,pair|\n    tag, count = pair\n    memo.merge( { tag => count } )\n  end\n  # so we can re-Hash it with inject\nend\n```", "```\ndef pretty_report()\n  sort_by_tag_count.inject('') do |output,pair|\n    tag, count = pair\n    output += \"#{tag}: #{count}\\n\"\n  end\nend\n```", "```\n  #!/usr/bin/env ruby\n  # xml_text_extractor.rb\n\n❶ CHOMP_TAG = lambda { |tag| tag.to_s.chomp }\n\n  =begin rdoc\n  This script uses the Rexml parser, which is written in Ruby itself.\n  Find out more at http://www.germane-software.com/software/rexml\n  =end\n❷ require 'rexml/document'\n\n  =begin rdoc\n  Returns DOM elements of a given filename.\n  =end\n❸ def get_elements_from_filename(filename)\n    REXML::Document.new(File.open(filename)).elements()\n  end\n\n  =begin rdoc\n  Returns a <b>String</b> consisting of the text of a given XML document\n  with the tags stripped.\n  =end\n❹ def strip_tags(elements)\n❺   return '' unless (elements.size > 0)\n❻   return elements.to_a.map do |tag|\n❼     tag.texts.map(&CHOMP_TAG).join('') + strip_tags(tag.elements)    *Mapping Procs onto Arrays*\n❽   end.join('')\n  end\n\n❾ puts strip_tags(get_elements_from_filename(ARGV[0]))\n```", "```\n  English Horn for No Clergy\n/**/\n@import url('../css/noclergy.css');\nh1, h2 { display: none; }\n/**/\n/**/\n p.c1 {text-align:center;}\n/**/ No Clergy:  I'm a header, but I don't know it. I'm some underlined\ncontent I'm some italicized content I'm an unclosed paragraph. The horrors.\n```", "```\n  #!/usr/bin/env ruby\n  # xml_well_formedness_checker.rb\n\n  =begin rdoc\n  This script uses the xml/dom/builder, written by YoshidaM.\n  =end\n❶ require 'xml/dom/builder'    *The DOM*\n\n  class File\n\n❷   def well_formed_xml?()\n      read.well_formed_xml?\n    end\n\n  end\n\n  class String\n\n❸   def well_formed_xml?()\n      builder = XML::DOM::Builder.new(0)\n      builder.setBase(\"./\")    *Root Element*\n\n❹     begin\n        builder.parse(self, true)\n❺     rescue XMLParserError\n        return false\n      end\n\n❻     return true\n    end\n\n  end\n\n❼ def well_formed?(filename)\n❽   return unless filename\n❾   return File.open(filename, 'r').well_formed_xml?\n  end\n\n❽ puts well_formed?(ARGV[0])\n```", "```\nruby -w xml_well_formedness_checker.rb extras/eh.html.tidy\ntrue\n$ ruby -w xml_well_formedness_checker.rb extras/eh.html\nfalse\n$ ruby -w xml_well_formedness_checker.rb xml_well_formedness_checker.rb\nfalse\n$ ruby -w xml_well_formedness_checker.rb\nnil\n```"]