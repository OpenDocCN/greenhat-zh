<html><head></head><body><section class="chapter" epub:type="chapter" id="advanced_pf" title="Chapter&#xA0;22.&#xA0;Advanced PF"><div class="titlepage"><div><div><h2 class="title">Chapter 22. Advanced PF</h2></div></div></div><div class="epigraph" epub:type="epigraph"><div class="literallayout"><p><span class="emphasis"><em>Office net seems slow</em></span><br/>
<span class="emphasis"><em>thanks to bootleg film swapping.</em></span><br/>
<span class="emphasis"><em>Let’s stop that right quick!</em></span></p></div></div><p><a class="indexterm" id="idx1778"/><span class="inlinemediaobject"><a id="inline_id00023"/><img alt="" src="httpatomoreillycomsourcenostarchimages1616079.png"/></span> The previous chapter covered the basics of the OpenBSD packet filter <code class="literal">pf(4)</code>. But, as I mentioned, PF can manipulate packets in all kinds of ways beyond just permitting or denying them, including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You can dynamically change the list of addresses to pass or block through outside software, such as <code class="literal">dhcpd(8)</code> or <code class="literal">spamd(8)</code>.</p></li><li class="listitem"><p>You can dynamically create sub-rulesets that let you set up very specific rules for troublesome protocols without allowing more access than necessary.</p></li><li class="listitem"><p>PF can provide NAT, letting you offer an entire network Internet access without public IP addresses.</p></li><li class="listitem"><p>You can redirect incoming traffic arbitrarily, and control how much bandwidth you will let a service use.</p></li><li class="listitem"><p>You can use PF logging.</p></li></ul></div><p>This chapter covers each of these topics.</p><div class="sect1" title="Packet Filtering with Tables"><div class="titlepage"><div><div><h2 class="title" id="packet_filtering_with_tables" style="clear: both">Packet Filtering with Tables</h2></div></div></div><p><a class="indexterm" id="idx0150"/><a class="indexterm" id="idx0291"/><a class="indexterm" id="idx0692"/><a class="indexterm" id="idx1756"/><a class="indexterm" id="idx1779"/><a class="indexterm" id="idx2359"/><a class="indexterm" id="idx2362"/>A <span class="emphasis"><em>table</em></span> is a list of IPv4 and/or IPv6 addresses, much like a list. A table is faster than a list, however, and uses less memory. If you have only a few addresses, using a list is fine, but once you have more than a few, use a table.</p><p>Interestingly, you can edit tables without reloading the filter rules, and several programs use this feature to dynamically change how a server behaves. Some people load lists of malware-laden computers into a table to block those hosts, or use external programs to generate such lists. (“You’ve tried to send us four invalid emails in a row? Good-bye!”) Tables can be kept permanently in external files, or you can treat them as ephemera. It’s your choice.</p><div class="sect2" title="Defining Tables"><div class="titlepage"><div><div><h3 class="title" id="defining_tables">Defining Tables</h3></div></div></div><p>You can create and manipulate tables entirely with <code class="literal">pfctl</code>, but that’s not as common as defining the table within <span class="emphasis"><em>pf.conf</em></span>. Give the table name in angle brackets, and provide the initial members delimited by commas inside braces.</p><a id="I_programlisting22_id501375"/><pre class="programlisting">table &lt;management&gt; {192.0.2.5, 192.0.2.8, 192.0.2.81}</pre><p>In this case, the <code class="literal">management</code> table contains three IP addresses.</p><p>If you want to define a table that <code class="literal">pfctl</code> cannot change, use the <code class="literal">const</code> keyword. The following example defines a table for private (RFC 1918) address space. This address space has been well defined for many years, so no one should alter it.</p><a id="I_programlisting22_id501400"/><pre class="programlisting">table &lt;private&gt; const {10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16}</pre><p>If no rules reference a table, PF drops it. This makes sense for static rules, but if you’re using anchors (discussed later this chapter), you might want to retain the table for when rules reappear. Use the <code class="literal">persist</code> keyword to make a table stick around even if it’s not used in a rule.</p><a id="I_programlisting22_id501413"/><pre class="programlisting">table &lt;scumbags&gt; persist</pre><p>Some tables contain enough addresses that you wouldn’t want to list them in your configuration. For convenience, you can populate a table from a file, like this:</p><a id="I_programlisting22_id501421"/><pre class="programlisting">table &lt;fullbogons&gt; persist file "/etc/fullbogons.txt"</pre><p>I have a script that updates the <span class="emphasis"><em>fullbogons.txt</em></span> file every day. (<span class="emphasis"><em>Bogons</em></span> are addresses that should never appear in the global Internet routing table.)</p><p>The bogons list includes private address space, addresses reserved for experimentation or documentation, addresses not assigned to any network, and addresses assigned to other exotic purposes. Several organizations produce and update full bogon lists. I use the bogons list at my border to weed out obvious garbage. The file looks like this:</p><a id="I_programlisting22_id501443"/><pre class="programlisting"># last updated 1352220481 (Tue Nov  6 16:48:01 2012 GMT)
0.0.0.0/8
10.0.0.0/8
14.1.96.0/19
…</pre><p><a class="indexterm" id="idx1788"/><a class="indexterm" id="idx2364"/><a class="indexterm" id="idx2365"/>You can include individual addresses, but not dotted-quad netmasks. You can use hostnames, but before <code class="literal">pfctl</code> feeds the rules to the kernel, it checks the IP address or addresses of the host. This means that if a host changes its IP address after you load the rules, PF will not know about the new IP address.</p></div><div class="sect2" title="Using Tables"><div class="titlepage"><div><div><h3 class="title" id="using_tables">Using Tables</h3></div></div></div><p>Use the table in your firewall rules exactly as you would use an address or list.</p><a id="I_programlisting22_id501496"/><pre class="programlisting">block in on egress from &lt;fullbogons&gt; to any</pre><p>You can put multiple tables in a list.</p><a id="I_programlisting22_id501504"/><pre class="programlisting">block in on egress from {&lt;fullbogons&gt;, &lt;scumbags&gt;} to any</pre><p>Yes, a list is slower than a table. But if you maintain two different tables in different ways, you probably want those tables separated. And if a list of two items triggers firewall exhaustion, you really need more hardware.</p></div><div class="sect2" title="Viewing Tables"><div class="titlepage"><div><div><h3 class="title" id="viewing_tables">Viewing Tables</h3></div></div></div><p>Tables have their own subset of <code class="literal">pfctl</code> commands. To see which tables are in the kernel, use <code class="literal">pfctl -s Tables</code>. (Note that <code class="literal">Tables</code> begins with a capital <code class="literal">T</code>.)</p><a id="I_programlisting22_id501542"/><pre class="programlisting"># <span class="strong"><strong>pfctl -s Tables</strong></span>
fullbogons
scumbags</pre><p>Why would you need to ask the kernel what tables it has? Because dynamic rules can add and remove tables, as discussed in <a class="xref" href="ch22.html#anchors" title="Anchors">Anchors</a>.</p><p>If you already know the table name, and you want to view the addresses within the table, use the <code class="literal">-t</code> argument to specify a table name. The <code class="literal">-T</code> argument has several subcommands, much like <code class="literal">-s</code>, but is for table operations. Here’s how to examine the contents of the <code class="literal">scumbags</code> table:</p><a id="I_programlisting22_id501581"/><pre class="programlisting"># <span class="strong"><strong>pfctl -t scumbags -T show</strong></span>
   157.166.248.10
   157.166.248.11
   157.166.249.10
   157.166.249.11</pre><p><a class="indexterm" id="idx2048"/><a class="indexterm" id="idx2361"/><a class="indexterm" id="idx2363"/>For many table operations (<code class="literal">add</code>, <code class="literal">delete</code>, <code class="literal">replace</code>, and <code class="literal">test</code> as of right now), you can add one or two <code class="literal">-v</code> options before the <code class="literal">-T</code> to increase verbosity. If you work on multiple addresses simultaneously, adding verbosity shows details of what the command did.</p></div><div class="sect2" title="Searching Tables"><div class="titlepage"><div><div><h3 class="title" id="searching_tables">Searching Tables</h3></div></div></div><p>You can eyeball a table with four entries pretty easily, but if a table has thousands of entries, you won’t want to page through it searching for an address. You could use <code class="literal">grep(1)</code>, but that can fail because an address might be part of a network that looks completely different. (I’m sure I <span class="emphasis"><em>could</em></span> write a <code class="literal">grep</code> expression that matches 10.0.0.0/8 if I enter 10.99.61.4, but I don’t want to try it.) You can test an address to see if it’s in a table.</p><a id="I_programlisting22_id501672"/><pre class="programlisting"># <span class="strong"><strong>pfctl -t fullbogons -T test 192.0.2.88</strong></span>
1/1 addresses match.</pre><p>This address appears in the <code class="literal">fullbogons</code> table.</p><p>If you test multiple addresses in one command, use <code class="literal">-v</code> or <code class="literal">-vv</code> before <code class="literal">-T</code> to see which addresses match and which don’t.</p><a id="I_programlisting22_id501705"/><pre class="programlisting"># <span class="strong"><strong>pfctl -t scumbags -vvT test 192.0.2.88 198.51.100.90</strong></span>
1/2 addresses match.
M  192.0.2.88    192.0.0.0/22
198.51.100.90    nomatch</pre><p>Using a single <code class="literal">-v</code> shows only matching addresses.</p></div><div class="sect2" title="Changing Tables"><div class="titlepage"><div><div><h3 class="title" id="changing_tables">Changing Tables</h3></div></div></div><p>One important feature of tables is that you can dynamically alter them without reloading the firewall rules. If you must add an address to a table, use <code class="literal">-T</code>’s <code class="literal">add</code> command.</p><a id="I_programlisting22_id501746"/><pre class="programlisting"># <span class="strong"><strong>pfctl -t scumbags -T add 192.0.2.88</strong></span>
1/1 addresses added.</pre><p>Add networks by specifying a netmask and multiple addresses in a single command.</p><a id="I_programlisting22_id501760"/><pre class="programlisting"># <span class="strong"><strong>pfctl -t scumbags -T add 198.51.100.0/24 2001:db8::/32</strong></span>
2/2 addresses added.</pre><p>If you add addresses to a nonexistent table, PF automatically creates the table (so now you know where that <code class="literal">scumbags</code> table came from).</p><p><a class="indexterm" id="idx0094"/><a class="indexterm" id="idx0399"/><a class="indexterm" id="idx0878"/><a class="indexterm" id="idx1173"/><a class="indexterm" id="idx2360"/>Add all the addresses in a file to a table with the <code class="literal">-f</code> argument.</p><a id="I_programlisting22_id501840"/><pre class="programlisting"># <span class="strong"><strong>pfctl -t scumbags -T add -f scumbags.txt</strong></span>
1/1 addresses added.</pre><p>To remove addresses, use the <code class="literal">delete</code> command.</p><a id="I_programlisting22_id501857"/><pre class="programlisting"># <span class="strong"><strong>pfctl -t scumbags -T delete  198.51.100.0/24</strong></span>
1/1 addresses deleted.</pre><p>To completely remove all entries from a table, use <code class="literal">flush</code>.</p><a id="I_programlisting22_id501875"/><pre class="programlisting"># <span class="strong"><strong>pfctl -t scumbags -T flush</strong></span>
6 addresses deleted.</pre><p>If emptying the table is not enough, and you want to completely remove it from the rules, use <code class="literal">kill</code>.</p><a id="I_programlisting22_id501893"/><pre class="programlisting"># <span class="strong"><strong>pfctl -t scumbags -T kill</strong></span>
1 table deleted.</pre></div><div class="sect2" title="Tables and Automation"><div class="titlepage"><div><div><h3 class="title" id="tables_and_automation">Tables and Automation</h3></div></div></div><p>OpenBSD includes software that can adjust tables algorithmically. In <a class="xref" href="ch16.html" title="Chapter 16. Network Servers">Chapter 16</a>, I mentioned the DHCP server’s ability to assign leased, abandoned, and changed addresses to tables. You can use PF to assign different rules to each group of addresses.</p><p>Assume you have <code class="literal">dhcpd(8)</code> add all leased IP addresses to the <code class="literal">leased</code> table, abandoned addresses to the <code class="literal">abandoned</code> table, and changed addresses to the <code class="literal">changed</code> table. Hosts with properly leased addresses can access the network, but hosts with abandoned and changed addresses cannot. Here, interfaces in the office group face the local network:</p><a id="I_programlisting22_id501942"/><pre class="programlisting">table &lt;leased&gt; persist
table &lt;abandoned&gt; persist
table &lt;changed&gt; persist
pass in on lan from &lt;leased&gt; to any
block in on lan from {&lt;abandoned&gt;, &lt;changed&gt;} to any</pre><p>If someone decides to configure an address from the DHCP server as a static address for their computer, they automatically lose access to the rest of the network—problem solved. Other OpenBSD software, such as <code class="literal">spamd(8)</code>, has similar features.</p><p>At first glance, it might seem like this feature is ready for integration with other programs. It’s fairly simple to write a script that parses a log, grabs the IP addresses, and feeds those addresses to a table. Several years ago, I wrote a script to take alerts from the Snort intrusion detection system and automatically block attackers from the network. Without careful and skilled attention though, Snort generates many false positives. My autoblocking script very effectively created a denial-of-service attack against my own development team.</p><p><a class="indexterm" id="idx0865"/><a class="indexterm" id="idx1090"/><a class="indexterm" id="idx1118"/><a class="indexterm" id="idx1445"/><a class="indexterm" id="idx1681"/><a class="indexterm" id="idx1874"/><a class="indexterm" id="idx1969"/><a class="indexterm" id="idx1970"/>Be careful with automatically feeding PF tables to block traffic. It’s very easy to harm desirable connectivity.</p></div></div><div class="sect1" title="Using NAT"><div class="titlepage"><div><div><h2 class="title" id="using_nat" style="clear: both">Using NAT</h2></div></div></div><p>One of the critical functions of a firewall is NAT. Use NAT to provide IPv4 network access to multiple machines but show only one public IPv4 address. Some companies provide Internet access to thousands and thousands of machines via NAT.</p><p>NAT is like making soup out of a bone—it stretches what you have so that it covers more. Some protocols won’t work well with NAT. It really confuses anyone who is trying to restrict access by IP address. And it can cause nightmares for network forensics and troubleshooters. But NAT is the chosen solution for the IPv4 address shortage.</p><p>NAT is <span class="emphasis"><em>not</em></span> intended as a security mechanism. There are minor security benefits, but they are inadequate against today’s network threats. Relying on NAT for security is chasing 10 boilermakers with a cup of black coffee before staggering out of the pub to drive home. You might get away with it, but only by luck.</p><p>IPv6 was designed without NAT, but it was shoehorned in several years later by popular demand. (IPv4 was originally designed without NAT as well, so IPv6 is just following tradition.) Note that an IPv6 address—even a globally unique IPv6 address—does not mean or even imply “reachable from the world.” You can have solid network separation without NAT. Avoiding NAT means using your packet filter to protect your machines, with additional application proxies as needed.</p><div class="sect2" title="Private NAT Addresses"><div class="titlepage"><div><div><h3 class="title" id="private_nat_addresses">Private NAT Addresses</h3></div></div></div><p>In theory, you can use any addresses behind your NAT device. If you use some random IP addresses, though, you cannot exchange packets with whoever uses those IP addresses out in the real world. It’s highly advisable to use some of the IP addresses reserved for private use, generally referred to as “RFC 1918 addresses.” These include the following IP addresses:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>10.0.0.0/8 (10.0.0.0-10.255.255.255)</p></li><li class="listitem"><p>172.16.0.0/12 (172.16.0.0-172.31.255.255)</p></li><li class="listitem"><p>192.168.0.0/16 (192.168.0.0-192.168.255.255)</p></li></ul></div><p>You can subnet and rearrange those addresses any way you like, as long as you don’t try to route them on the public Internet.</p><p>You can use other IP addresses behind your NAT if you have a really good reason for doing so. For example, RFC 5737 defines IPv4 addresses for use in documentation. Like RFC 1918 addresses, RFC 5737 addresses should never appear on the public Internet. I write documentation, so I use those addresses on my home and test networks. It saves me from doing search and replace as I write books.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id330960" id="id330960">48</a>]</sup> There’s still no chance of those addresses appearing on other networks.</p></div><div class="sect2" title="Configuring NAT"><div class="titlepage"><div><div><h3 class="title" id="configuring_nat">Configuring NAT</h3></div></div></div><p><a class="indexterm" id="idx1441"/><a class="indexterm" id="idx1442"/><a class="indexterm" id="idx1448"/>Perhaps the most common form of NAT is for use in hiding a small network behind a single IP address. You’ll find this in many homes and small businesses. Very few home offices have internal routing and multiple subnets. For this example, I have two interface groups: the Internet-facing <code class="literal">egress</code> group and the <code class="literal">lan</code> group attached to my office.</p><a id="I_programlisting22_id502174"/><pre class="programlisting">pass out on egress from <span class="strong"><strong>1</strong></span>lan:network to any <span class="strong"><strong>2</strong></span>nat-to egress</pre><p>The first part of this rule looks just like any other firewall rule permitting the addresses on the <code class="literal">lan</code> interface access to everywhere, but the last two words additionally configure NAT. The <code class="literal">nat-to</code> keyword tells PF to translate addresses <span class="strong"><strong>2</strong></span>. The <code class="literal">egress</code> that follows tells PF to hide the internal addresses behind the addresses of the <code class="literal">egress</code> interfaces <span class="strong"><strong>1</strong></span>. You could use an interface name or a specific IP address here, but if you do, you must change your filter rules when you change your server.</p><p>In order to have PF recognize IP address changes from DHCP, put the interface group name in parentheses.</p><a id="I_programlisting22_id502228"/><pre class="programlisting">pass out on egress from lan:network to any nat-to (egress)</pre><p>Now load your firewall rules, enable IP forwarding, and suddenly, hosts on your LAN will have access to the Internet through the firewall’s public address.</p></div><div class="sect2" title="How NAT Works"><div class="titlepage"><div><div><h3 class="title" id="how_nat_works">How NAT Works</h3></div></div></div><p>The easiest way to understand how address translation works is to look at the state table (discussed in the previous chapter) after PF passes translated packets back and forth. On the office network from machine 192.0.2.2, I ran this command:</p><a id="I_programlisting22_id502254"/><pre class="programlisting">$ <span class="strong"><strong>ping www.michaelwlucas.com</strong></span></pre><p>Several pings later, I checked the state table and found entries like this:</p><a id="I_programlisting22_id502266"/><pre class="programlisting"># <span class="strong"><strong>pfctl -ss | grep 192.0.2.2</strong></span>
all udp <span class="strong"><strong>1</strong></span>203.0.113.5:55797 <span class="strong"><strong>2</strong></span>(192.0.2.2:10853) -&gt; <span class="strong"><strong>3</strong></span>203.0.113.15:53    MULTIPLE:SINGLE
all icmp 203.0.113.5:8813 (192.0.2.2:41584) -&gt; 198.22.63.8:8       0:0</pre><p><a class="indexterm" id="idx1444"/>The first state represents a UDP connection from the firewall’s public address <span class="strong"><strong>1</strong></span> to the local DNS server <span class="strong"><strong>3</strong></span>. This state entry includes the client’s private IP address <span class="strong"><strong>2</strong></span>, as well as the actual ports used by the client, the firewall, and the DNS server.</p><p>The client initiated this state by sending a request from port 10853 on its IP address to port 53 on the DNS server. When the packet passed through PF, OpenBSD rewrote the packet so that it appeared to come from the address 203.0.113.5 on port 55797 and sent it on to the DNS server. The DNS server sent its response to the firewall’s public IP on port 55797. When the reply arrived, the firewall checked the state table, and found that UDP packets on port 55797 were part of the state for the client. PF rewrote the packet’s destination address and forwarded it to the client.</p><p>The second state represents an ICMP connection. The state table encodes the various ICMP codes used for a ping request as port numbers, and forwards responses back to the client based on that information. Otherwise, it’s very similar to the DNS example above it.</p><p>In other words, NAT works by lying. PF lies to the client, telling it that it has direct access to the public Internet. It lies to the external servers, giving a false source address and port for client connections. PF uses the state table to track its lies and keep everything consistent. These lies are convenient for IPv4 address conservation, but they’re exactly why address translation complicates troubleshooting and intrusion forensics.</p><p>Now that you understand the basics of NAT, let’s tell the network even more complicated and interesting lies.</p></div><div class="sect2" title="Multiple or Specific Public Addresses"><div class="titlepage"><div><div><h3 class="title" id="multiple_or_specific_public_addresses">Multiple or Specific Public Addresses</h3></div></div></div><p>You can use several public IP addresses for address translation. If you use an interface group for the external address in your NAT rule, any addresses in that interface group can become the public address of any connection. If you want to be specific, list particular addresses.</p><a id="I_programlisting22_id502367"/><pre class="programlisting">pass out on egress from lan:network to any <span class="strong"><strong>1</strong></span>nat-to 203.0.113.5</pre><p>I use this configuration when my firewall’s external interface has multiple IP addresses and I want to conceal my desktop clients behind a single address (although I probably would define and use a macro for the external address <span class="strong"><strong>1</strong></span>).</p><p>But how many public addresses do you need? The answer depends on your clients.</p><p>Port numbers range from 0 to 65535. The bottom 1024 ports are generally used for services on the localhost. Not all of those ports will be used on the localhost, but a packet filter generally won’t use those ports for translated connections. I’m lazy, so I’ll round off to 64,000 free ports.</p><p>Even the most heavily loaded desktop client rarely can use as many as 100 outbound connections simultaneously. Most will use far fewer, but again, I’m lazy, and I want a worst-case scenario, so I’ll call it 100.</p><p><a class="indexterm" id="idx0125"/><a class="indexterm" id="idx0133"/><a class="indexterm" id="idx1437"/><a class="indexterm" id="idx1572"/><a class="indexterm" id="idx2247"/>One IP address can support 64,000 / 100 = 640 machines being pathological simultaneously. Realistically, each client might have 10 simultaneous outbound connections, so a public address could support 6,400 simultaneous clients. How many of your users browse the Internet at the same time? The answer probably is not many. And if you have thousands of users, you would probably benefit from implementing a caching proxy, which would greatly reduce the number of connections.</p><p>If you’re concerned about overflowing the number of client machines for one address, watch your state table. Until you have multiple tens of thousands of states for one public IP address, don’t worry.</p><p>Specifying individual addresses in a NAT rule is most useful for bidirectional NAT.</p></div><div class="sect2" title="Bidirectional NAT"><div class="titlepage"><div><div><h3 class="title" id="bidirectional_nat">Bidirectional NAT</h3></div></div></div><p>Some applications work better if you dedicate a public IP address as the NAT address for a specific private IP address. For example, if you have a server that offers several different services on different ports, and you want to put it behind your firewall, you might want to dedicate a single address to it. This is called <span class="emphasis"><em>bidirectional</em></span>, <span class="emphasis"><em>one-to-one</em></span>, or <span class="emphasis"><em>static</em></span> NAT. OpenBSD docs use “bidirectional,” but the terms all mean the same thing.</p><p>Configure bidirectional NAT with the <code class="literal">binat-to</code> keyword.</p><a id="I_programlisting22_id502491"/><pre class="programlisting">pass on lan from 192.0.2.65 to any binat-to 203.0.113.6</pre><p>PF dedicates the public IP address 203.0.113.6 for NAT services for the private IP address 192.0.2.65.</p><p>If you use bidirectional NAT, be sure to specify a specific IP address for your general NAT and consider using the following NAT rules:</p><a id="I_programlisting22_id502504"/><pre class="programlisting">pass out log on egress from lan:network to any nat-to egress
pass on lan from 192.0.2.2 to any binat-to 203.0.113.6</pre><p>The IP addresses on this LAN are hidden behind the IP addresses on the <code class="literal">egress</code> interface. If 203.0.113.6 is an address on an <code class="literal">egress</code> interface, outbound packets from the LAN might use it as a source address.</p><p>When I need bidirectional NAT, I usually write my NAT rules like this:</p><a id="I_programlisting22_id502524"/><pre class="programlisting">mainnat="203.0.113.5"
servernat="203.0.113.6"
pass out log on egress from lan:network to any nat-to $mainnat
pass on lan from 192.0.2.2 to any binat-to $servernat</pre><p>In this way, packets leaving my network are unambiguously translated. Only the one specific server uses the IP address 203.0.113.6; all other hosts on my local network use 203.0.113.5. If I change IP addresses, I must reconfigure <span class="emphasis"><em>pf.conf</em></span>, but that’s a minor annoyance compared to troubleshooting network ambiguity.</p><div class="sect3" title="Bidirectional NAT and Security"><div class="titlepage"><div><div><h4 class="title" id="bidirectional_nat_and_security">Bidirectional NAT and Security</h4></div></div></div><p><a class="indexterm" id="idx0126"/><a class="indexterm" id="idx0128"/><a class="indexterm" id="idx1439"/><a class="indexterm" id="idx1440"/><a class="indexterm" id="idx2065"/>The use of bidirectional NAT, and allowing the redirection of connections, lets you give people outside your network access to servers behind your firewall, and every one of these gaps is a potential security hole. If you allow the world access to your web servers, and an intruder compromises one of your servers, you have a compromised machine inside your firewall. The firewall doesn’t really secure the web servers; it just controls who can try to break into them and limits the available attack vectors.</p></div><div class="sect3" title="Packet Filtering, Bidirectional NAT, and Rule Order"><div class="titlepage"><div><div><h4 class="title" id="packet_filtering_bidirectional_nat_and_r">Packet Filtering, Bidirectional NAT, and Rule Order</h4></div></div></div><p>When writing packet-filtering rules for bidirectional NAT, the order in which you list rules is important. Consider the following rules:</p><a id="I_programlisting22_id502623"/><pre class="programlisting">pass on lan from 192.0.2.2 to any binat-to 203.0.113.6
pass in on egress proto tcp from any to 192.0.2.2 port 80</pre><p>The first rule establishes static NAT for the host 192.0.2.2 on the LAN, hiding it behind the public IP address 203.0.113.6. All is well and good. The second line permits connections to port 80 on the same host, or does it? Packets meant for this server that arrive on the firewall’s <code class="literal">egress</code> interface won’t be addressed to 192.0.2.2; they’ll be addressed to the public NAT address, or 203.0.113.6. They won’t match this rule, so they are discarded.</p><p>In order to permit connections from the world to the web server behind this firewall, permit packets sent to the proper port on the public address.</p><a id="I_programlisting22_id502643"/><pre class="programlisting">pass on lan from 192.0.2.2 to any binat-to 203.0.113.6
pass in on egress proto tcp from any to 203.0.113.6 port 80</pre><p>This translates 192.0.2.2 to the public address 203.0.113.6, and then allows packets with a destination of port 80 on 203.0.113.6 to pass. You’ll see this in the state table, like this:</p><a id="I_programlisting22_id502653"/><pre class="programlisting">all tcp 203.0.113.6:80 &lt;- 198.22.63.8:64791       ESTABLISHED:ESTABLISHED</pre><p>The host 198.22.63.8 has connected to the server’s public IP address on port 80.</p><p>Why doesn’t this state entry have the hidden IP address in it? Because this is a bidirectional NAT. PF can send port numbers through unaltered, so it can track a little less information in the state table.</p><p>The tricky thing here is that the rule order impacts how you filter, and you must read your filtering rules carefully to see how address translation interacts with packet filtering. I <span class="emphasis"><em>always</em></span> write my rules so that I do address translation before I filter. I consistently use the public IP address in the filter rules, but sometimes that’s not practical. PF lets you write arbitrarily complex rules mainly because the real world is arbitrarily complex. If you have trouble passing traffic through NAT, read your rules very carefully.</p><p><a class="indexterm" id="idx0127"/><a class="indexterm" id="idx1438"/>To see a bidirectional NAT, look at the loaded rules.</p><a id="I_programlisting22_id502700"/><pre class="programlisting"># <span class="strong"><strong>pfctl -sr</strong></span>
…
pass out on lan inet from 192.0.2.2 to any flags S/SA nat-to 203.0.113.6 static-port
pass in on lan inet from any to 203.0.113.6 flags S/SA <span class="strong"><strong>rdr-to</strong></span> 192.0.2.2
pass on egress inet proto tcp from any to 203.0.113.6 port = 80 flags S/SA</pre><p>The first rule gives the private IP address access to the public Internet, translated to the specific IP address. The third rule passes traffic to the translated address.</p><p>But what about the second rule, with that <code class="literal">rdr-to</code> stuff? That’s a redirection, which is how PF implements static NAT.</p></div></div><div class="sect2" title="Redirection"><div class="titlepage"><div><div><h3 class="title" id="redirection">Redirection</h3></div></div></div><p>Bidirectional NAT is actually a combination of address translation and <span class="emphasis"><em>redirection</em></span>; in other words, it twists a connection intended for one IP or port to another. In bidirectional NAT, all connections to the designated public IP address are redirected to a different IP address. Sometimes you don’t want to twist all traffic for an IP address—only a few ports. Sometimes you want to redirect one port one way, but a different port elsewhere. Do this with redirection rules.</p><p>Suppose you have one public IP address: 203.0.113.5. You want port 80 on that IP address routed to your web server at 192.0.2.2, ports 25 and 110 to your mail server at 192.0.2.3, and port 443 to your e-commerce server at 192.0.2.4. PF lets you choose where to send each port via redirection by using a standard packet-filtering rule and adding the <code class="literal">rdr-to</code> redirection keyword.</p><a id="I_programlisting22_id502757"/><pre class="programlisting">pass in on egress proto tcp from any to egress port 80 rdr-to 192.0.2.2
pass in on egress proto tcp from any to egress port {25, 110} rdr-to 192.0.2.3
pass in on egress proto tcp from any to egress port 443 rdr-to 192.0.2.4</pre><p>These rules declare that any connection coming to the <code class="literal">egress</code> interface group (the interface facing the public Internet, with a default route going over it) can be redirected in three different ways. The first rule directs port 80 requests to one internal server. The second rule directs requests for ports 25 and 110 to the second server. The last rule redirects requests for port 443 to the third server. One public IP address is now providing services to the world from three different servers.</p><p>All port redirection rules must include a protocol, because specifying a TCP/IP port works only if you’re forwarding a protocol that includes port numbers, such as TCP or UDP. If you want to forward both TCP and UDP ports, you must specify both protocols. For example, DNS uses port 53 on both TCP and UDP. Here’s a rule that forwards both of these protocols’ port 53 to the internal server 192.0.2.5:</p><a id="I_programlisting22_id502781"/><pre class="programlisting">pass in on egress proto {tcp, udp} from any to egress port 53 rdr-to 192.0.2.5</pre><p><a class="indexterm" id="idx1443"/><a class="indexterm" id="idx1446"/>Pick a port, say where you want it to go, and PF will redirect it as you please.</p><div class="note" title="Note"><h3 class="title"><a id="ch22note01"/>Note</h3><p>You’ve learned how bidirectional NAT combines redirection and address translation. The in-kernel PF engine doesn’t actually know anything about this beastie called “bidirectional NAT.” <code class="literal">pfctl(8)</code> translates the <code class="literal">binat</code> rule into two separate rules: one for translation and one for redirection.</p></div></div><div class="sect2" title="Multiple Addresses and Interface Groups"><div class="titlepage"><div><div><h3 class="title" id="multiple_addresses_and_interface_groups">Multiple Addresses and Interface Groups</h3></div></div></div><p>All of the preceding discussion makes sense when you have only one public IP address. But what happens when you have multiple addresses?</p><p>Remember that using an interface group in <span class="emphasis"><em>pf.conf</em></span> tells <code class="literal">pfctl</code> to create a matching rule for every IP address in the interface group. Suppose you have three IP addresses on your <code class="literal">egress</code> interface:  203.0.113.5, 203.0.113.6, and 203.0.113.7. You write this <span class="emphasis"><em>pf.conf</em></span> rule:</p><a id="I_programlisting22_id502860"/><pre class="programlisting">pass in on egress proto tcp from any to egress port 80 rdr-to 192.0.2.2</pre><p>Load this rule into the kernel with <code class="literal">pfctl</code>, and what do you get?</p><a id="I_programlisting22_id502872"/><pre class="programlisting"># <span class="strong"><strong>pfctl -sr</strong></span>
…
pass in on egress inet proto tcp from any to 203.0.113.5 port = 80 flags S/SA rdr-to 192.0.2.2
pass in on egress inet proto tcp from any to 203.0.113.6 port = 80 flags S/SA rdr-to 192.0.2.2
pass in on egress inet proto tcp from any to 203.0.113.7 port = 80 flags S/SA rdr-to 192.0.2.2</pre><p>Any connection to port 80 on any of these IP addresses is directed to port 80 on the same server. This might be useful in some environments, but that’s not what most of us want. If you have multiple IP addresses, and you want to redirect a port on only one IP address, you must specify the interface name and the public IP address.</p><a id="I_programlisting22_id502891"/><pre class="programlisting">pass in on em0 proto tcp from any to 203.0.113.5 port 80 rdr-to 192.0.2.2</pre><p>This doesn’t expand; it doesn’t have any interface groups, lists of addresses, variables, or macros. When <code class="literal">pfctl</code> parses this, it loads only one PF rule into the kernel.</p></div><div class="sect2" title="Port Manipulation and Ranges"><div class="titlepage"><div><div><h3 class="title" id="port_manipulation_and_ranges">Port Manipulation and Ranges</h3></div></div></div><p>As you redirect ports from one machine to another, you can change the port. The following example takes requests to TCP port 2222 on the firewall and redirects them to port 22 on a machine inside the firewall.</p><a id="I_programlisting22_id502920"/><pre class="programlisting">pass in on egress proto tcp from any to egress port 2222 rdr-to 192.0.2.2 port 22</pre><p><a class="indexterm" id="idx0500"/><a class="indexterm" id="idx1447"/><a class="indexterm" id="idx1920"/><a class="indexterm" id="idx2454"/>This is a reasonable way to offer SSH services to several machines inside the firewall on only one IP address, and to give each machine its own port.</p><p>If you have specific source addresses that you want to abuse, you can give them special port redirections by source IP address.</p><a id="I_programlisting22_id502968"/><pre class="programlisting">pass in on egress proto tcp from 198.51.100.0/24 to egress port 80 rdr-to 192.0.2.2
pass in on egress proto tcp from ! 198.51.100.0/24 to egress port 80 rdr-to 192.0.2.3</pre><p>Every HTTP connection from the IP addresses in 198.51.100.0/24 will be redirected to one server, while every other connection will be directed elsewhere. (To redirect connections for many source addresses, use a table for the source address.)</p><p>PF can also redirect entire ranges of ports using the same logical operators used for filtering ports. One obvious thing to do is to redirect a range of ports to a single machine. NFS is a prime example, as it requires TCP port 111, as well as all TCP and UDP ports from 1024 to 65535.</p><a id="I_programlisting22_id502984"/><pre class="programlisting">pass in on egress proto {tcp, udp} from any to egress port {111, 1024:65535} rdr-to 192.0.2.15</pre><p>Recall from <a class="xref" href="ch21.html" title="Chapter 21. Packet Filtering">Chapter 21</a> that a colon between port numbers indicates a range of ports. This rule passes ports 1024 through 65535, inclusive. Admittedly, certain NFS implementations can be restricted to use either TCP or UDP, and that’s a great big gaping hole in your packet filter. But NFS uses random high-numbered ports that come and go very quickly, and cannot be effectively filtered or restricted at the packet level.</p><p>You can also funnel an entire range of ports to one port on one machine.</p><a id="I_programlisting22_id503004"/><pre class="programlisting">pass in on egress proto tcp from any to egress port {1024:65535} rdr-to 192.0.2.15 port 80</pre><p>I’ve used this to point random traffic at a web page that says “Go away. You cannot use this service.”</p></div><div class="sect2" title="Transparent Interception"><div class="titlepage"><div><div><h3 class="title" id="transparent_interception">Transparent Interception</h3></div></div></div><p>Traffic interception is similar to redirection in that PF intercepts traffic bound for one port and steers it to a port on the local machine. Traffic interception is one way to implement a transparent proxy. Use the <code class="literal">divert-to</code> keyword to tell PF to steer any matching packets to a local server.</p><a id="I_programlisting22_id503029"/><pre class="programlisting">pass in inet proto tcp from lan:network to any port 80 <span class="strong"><strong>divert-to</strong></span> 127.0.0.1 port 3129</pre><p>Any traffic from the local LAN to port 80 will be diverted to port 3129 on the firewall. Port 3129 is usually used by the Squid caching proxy (<span class="emphasis"><em>/usr/ports/www/squid</em></span>). If you choose to implement a caching proxy like Squid, you’ll probably want to redirect several ports to the cache. (We’ll take a closer look at diverting connections in <a class="xref" href="ch22.html#ftp_and_pf" title="FTP and PF">FTP and PF</a>.)</p></div></div><div class="sect1" title="Anchors"><div class="titlepage"><div><div><h2 class="title" id="anchors" style="clear: both">Anchors</h2></div></div></div><p><a class="indexterm" id="idx0052"/><a class="indexterm" id="idx0054"/><a class="indexterm" id="idx0092"/><a class="indexterm" id="idx0905"/><a class="indexterm" id="idx1761"/><a class="indexterm" id="idx1762"/><a class="indexterm" id="idx1942"/>In PF, an <span class="emphasis"><em>anchor</em></span> is a sub-ruleset at a specific point in the filter rules that you can change without reloading the rules. It’s a spot marked “insert rules here,” letting you dynamically add and remove filter rules, tables, and other PF configurations.</p><p>The most common users of anchors are software programs. Human beings or sysadmins should probably just edit <span class="emphasis"><em>pf.conf</em></span> and reload the rules.</p><p>OpenBSD includes several programs that take advantage of anchors, however, including the FTP proxy <code class="literal">ftp-proxy(8)</code>, the authenticated firewall access system <code class="literal">authpf(8)</code>, and the load balancer <code class="literal">relayd(8)</code>. You could also use anchors to trigger conditional evaluation of rules.</p><p>A ruleset with an anchor might look something like the following, where the interface group <code class="literal">egress</code> faces the Internet, and the interface group <code class="literal">lan</code> faces a small office with the addresses 192.0.2.0/24.</p><a id="I_programlisting22_id503176"/><pre class="programlisting">block
pass in on egress from any to 192.0.2.45 port {25, 80}
anchor "antivirus/*"
pass in on lan from 192.0.2.0/27 to any</pre><p>These rules block all traffic by default. Incoming traffic is allowed to a specific address on ports 25 and 80 because those are the mail and web servers. There’s an anchor in the middle of the rules. I don’t yet know what’s in the <code class="literal">antivirus</code> anchor, but any rules in it are processed next. Finally, a small subnet of the addresses is allowed out.</p><p>Now let’s add some rules to the anchor.</p><div class="sect2" title="Adding Rules to Anchors"><div class="titlepage"><div><div><h3 class="title" id="adding_rules_to_anchors">Adding Rules to Anchors</h3></div></div></div><p>You can insert rules into anchors from a file, within <span class="emphasis"><em>pf.conf</em></span> itself, or via <code class="literal">pfctl</code>.</p><div class="sect3" title="Anchor Rules from Files"><div class="titlepage"><div><div><h4 class="title" id="anchor_rules_from_files">Anchor Rules from Files</h4></div></div></div><p>Adding rules to an anchor from a file is a good way to initialize your anchor when first starting the packet filter. You can set base rules here that you can expand later. Give the filename in <span class="emphasis"><em>pf.conf</em></span>.</p><a id="I_programlisting22_id503235"/><pre class="programlisting">anchor dhcp
load anchor dhcp from "/etc/pf/dhcp-anchor.conf"</pre><p>I created an <span class="emphasis"><em>/etc/pf/</em></span> directory because I didn’t want to have a whole bunch of PF configuration files scattered throughout <span class="emphasis"><em>/etc</em></span>. I’m easily confused, after all. This file contains PF rules like this:</p><a id="I_programlisting22_id503252"/><pre class="programlisting">block from 192.0.2.192/26 to any</pre><p>This is one way to load basic rules into an anchor when you start PF.</p><p><a class="indexterm" id="idx0693"/><a class="indexterm" id="idx1787"/>If you were paying attention, you probably noticed that my first example anchor had a <code class="literal">/*</code> after its name. This example doesn’t. I’ll explain why in <a class="xref" href="ch22.html#nested_anchors" title="Nested Anchors: /*">Nested Anchors: /*</a>.</p></div><div class="sect3" title="Anchor Rules in pf.conf"><div class="titlepage"><div><div><h4 class="title" id="anchor_rules_in_pf_conf">Anchor Rules in pf.conf</h4></div></div></div><p>You can place anchor rules directly inside <span class="emphasis"><em>pf.conf</em></span>. If you don’t intend to dynamically alter the rules, you don’t even need to name the anchor. Just use curly braces to define the beginning and end of the anchor.</p><a id="I_programlisting22_id503312"/><pre class="programlisting">anchor "smtp" on egress {
    pass proto tcp from 192.0.2.12 to any port 25
    }</pre><p>This is just slightly more complicated than the anchors in the default <span class="emphasis"><em>pf.conf</em></span>.</p><p>Why would you want to do this? Read <a class="xref" href="ch22.html#conditional_filtering" title="Conditional Filtering">Conditional Filtering</a>.</p></div><div class="sect3" title="Anchor Rules via pfctl"><div class="titlepage"><div><div><h4 class="title" id="anchor_rules_via_pfctl">Anchor Rules via pfctl</h4></div></div></div><p>To dynamically alter anchor rules with <code class="literal">pfctl</code>, you need the name of the anchor and the rule you want to put in its place. For example, suppose I want to add a rule to the <code class="literal">antivirus</code> anchor in the first anchor example.</p><a id="I_programlisting22_id503354"/><pre class="programlisting"># <span class="strong"><strong>1</strong></span><span class="strong"><strong>echo "block in from 203.0.113.8 to any"</strong></span> <span class="strong"><strong>2</strong></span><span class="strong"><strong>| pfctl</strong></span> <span class="strong"><strong>3</strong></span><span class="strong"><strong>-a antivirus</strong></span> <span class="strong"><strong>4</strong></span><span class="strong"><strong>-f -</strong></span></pre><p>Let’s look at this command slightly backwards. The <code class="literal">-a</code> argument to <code class="literal">pfctl</code> specifies an anchor name—in this case, the <code class="literal">antivirus</code> anchor <span class="strong"><strong>3</strong></span>. The <code class="literal">-f</code> argument normally gives a filename that contains the new anchor rule, much like <code class="literal">-f</code> when loading a PF ruleset, but rather than a path to a file, I use a single dash that tells <code class="literal">pfctl</code> to read the new rule from standard input, or the command line <span class="strong"><strong>4</strong></span>. I start everything by echoing the rule to be added <span class="strong"><strong>1</strong></span>, and then piping that into <code class="literal">pfctl</code> <span class="strong"><strong>2</strong></span>.</p><p>Taken as a whole, this adds the rule <code class="literal">block in from 203.0.113.8 to any</code> to the anchor <code class="literal">antivirus</code>.</p><p>You could also write the new rule to a file, and tell <code class="literal">pfctl</code> to load the rules from that file into the anchor.</p><a id="I_programlisting22_id503475"/><pre class="programlisting"># <span class="strong"><strong>pfctl -a antivirus -f newrule.conf</strong></span></pre><p>If you’re writing rules to a file to load them into an anchor, however, chances are you’re better off editing <span class="emphasis"><em>pf.conf</em></span>.</p><div class="note" title="Note"><h3 class="title"><a id="ch22note02"/>Note</h3><p>Adding a rule to an anchor erases any rules already in the anchor. If you have a software package that updates anchor rules, your software needs to handle this behavior. If your desired behavior can be accomplished using a list of IP addresses, consider using a table instead of an anchor.</p></div></div></div><div class="sect2" title="Viewing and Flushing Anchors"><div class="titlepage"><div><div><h3 class="title" id="viewing_and_flushing_anchors">Viewing and Flushing Anchors</h3></div></div></div><p><a class="indexterm" id="idx0055"/><a class="indexterm" id="idx0056"/><a class="indexterm" id="idx0057"/><a class="indexterm" id="idx0279"/><a class="indexterm" id="idx1458"/><a class="indexterm" id="idx1790"/>Use the <code class="literal">pfctl</code> view (<code class="literal">-s</code>), flush (<code class="literal">-F</code>), and load (<code class="literal">-f</code>) commands on anchors by specifying the anchor name with <code class="literal">-a</code>.</p><a id="I_programlisting22_id503582"/><pre class="programlisting"># <span class="strong"><strong>pfctl -a antivirus -s rules</strong></span>
block drop in inet from 203.0.113.8 to any</pre><p>To erase the rules from an anchor, flush the rules in the anchor.</p><a id="I_programlisting22_id503596"/><pre class="programlisting"># <span class="strong"><strong>pfctl -a antivirus -F rules</strong></span>
rules cleared</pre><p>Your anchor is now empty.</p><p>Rulesets within anchors are completely separate from each other, and also from the main ruleset. Flushing all the rules in a specific anchor does not affect the rules in any other anchor, or the rules in the main ruleset. For that matter, flushing the rules in the main ruleset does not impact the rules in the anchor. To destroy an anchor, you must remove everything in the anchor, including any child anchors.</p><p>“Child anchors?” I hear you cry. “What are you babbling about <span class="emphasis"><em>now</em></span>, dude?”</p></div><div class="sect2" title="Conditional Filtering"><div class="titlepage"><div><div><h3 class="title" id="conditional_filtering">Conditional Filtering</h3></div></div></div><p>Consider the following <span class="emphasis"><em>pf.conf</em></span> snippet:</p><a id="I_programlisting22_id503642"/><pre class="programlisting">…
anchor "office/*" in from lan to any {
    pass out proto tcp from any to {80, 443}
    }
…</pre><p>The <code class="literal">office/*</code> anchor has a filter condition after it, and only traffic that matches the filter condition will pass through the anchor. In this case, only packets that come from the <code class="literal">lan</code> interface group will pass through the rules within the anchor. Your rules within the anchor might be easier to write, simply because everything in the anchor is already known to be originating from the <code class="literal">lan</code> interfaces.</p><p>If your packet filter is very heavily loaded, you might be able to reduce the amount of time it spends processing packets by careful conditional filtering.</p></div><div class="sect2" title="Nested Anchors: /*"><div class="titlepage"><div><div><h3 class="title" id="nested_anchors">Nested Anchors: /*</h3></div></div></div><p>Anchors can contain other anchors.</p><a id="I_programlisting22_id503683"/><pre class="programlisting">anchor "office" in from lan to any{
    …
    anchor "ftp-proxy/*"
    pass in quick inet proto tcp to port ftp divert-to 127.0.0.1 port 8021
}
…</pre><p><a class="indexterm" id="idx0024"/><a class="indexterm" id="idx0099"/><a class="indexterm" id="idx0365"/><a class="indexterm" id="idx0831"/><a class="indexterm" id="idx0898"/><a class="indexterm" id="idx1723"/><a class="indexterm" id="idx1767"/>Only traffic that passes into the <code class="literal">office</code> anchor can pass through the <code class="literal">ftp-proxy</code> anchor. The FTP proxy can have its own sub-anchors as well. In fact, you might have several layers of anchors to support a complicated protocol, such as FTP.</p><p>This is where the <code class="literal">/*</code> after some anchor names comes in. An anchor name without this is executed all by itself. By adding the <code class="literal">/*</code>, you tell PF to evaluate all sub-anchors within this anchor, in alphabetical order.</p><p>Anchors and sub-anchors deliberately resemble a filesystem. You can have a file <span class="emphasis"><em>/office</em></span> or a directory <span class="emphasis"><em>/office/</em></span> containing more files. If you list the files in a directory, they appear in alphabetical order. Anchors work much the same way.</p><p>All of this anchor stuff is very theoretical. How about a practical example? Read on to see how PF uses anchors to handle that most annoying of network protocols: FTP.</p></div></div><div class="sect1" title="FTP and PF"><div class="titlepage"><div><div><h2 class="title" id="ftp_and_pf" style="clear: both">FTP and PF</h2></div></div></div><p>Most modern application protocols run over a single network connection. If you make a web request, your browser opens a connection to the server on port 80, requests information, and receives the answer, all on the same connection. SSH opens a single connection on port 22 and exchanges all information over that port, even if you tunnel a hundred other protocols inside it. Experience and experiments with older protocols taught the wisdom of this approach. FTP is an older protocol, and it provides a wealth of experience on how not to do things.</p><p>The original version of FTP (today called <span class="emphasis"><em>active FTP</em></span>) required the client to connect to the server on port 21. The server would then open a connection back to the client, from port 20 to some random high-numbered port on the client for sending information. The connection from server to client is called the <span class="emphasis"><em>data connection</em></span>, or the <span class="emphasis"><em>back channel</em></span>. The FTP client and server agree on the ports to be used and how the second connection will be used. On a network protocol level, however, no connection exists between the client’s connection to port 21 and the server’s connection from port 20, so there’s no way for a firewall to use stateful inspection to sort out if such a connection is allowed. Worse, if the client is behind a NAT device, there’s no way to determine to which private IP address the firewall should route an incoming FTP data request.</p><p><span class="emphasis"><em>Passive FTP</em></span> is an updated version of the FTP protocol where the client initiates both TCP connections. All modern clients and servers support passive FTP. The differences between active and passive FTP spark endless rounds of user education and increased help-desk load, especially if you’re trying to use FTP through a web browser. (And if anyone is going to break my help desk staff, it’s going to be me!) Active FTP simplified firewall rules, because the firewall didn’t need to allow the back channel. Unfortunately, the creators of passive FTP called the modified protocol FTP. Clients don’t care about active or passive, they just want “this FTP thing” to work, regardless of the actual protocol underlying it.</p><p><a class="indexterm" id="idx0695"/><a class="indexterm" id="idx0720"/><a class="indexterm" id="idx0899"/><a class="indexterm" id="idx0904"/><a class="indexterm" id="idx1765"/>To complicate things, some FTP servers and clients implement something between active and passive FTP. The FTP protocol has been around for decades (it predates TCP/IP), and people have tweaked and “improved” it for years. Getting a random combination of FTP server and client through a random NAT device and a packet filter can cause nightmares, or at least require opening a wide range of TCP ports.</p><p>OpenBSD and PF get around this problem by including an FTP application proxy, <code class="literal">ftp-proxy(8)</code>. When a client makes an FTP request, PF intercepts the request and reroutes it to the application proxy. The proxy tracks the FTP protocol transactions, uses anchors to insert the appropriate rules into the firewall, and removes the rules when the transfer finishes. Strictly speaking, <code class="literal">ftp-proxy</code> isn’t a traditional proxy. Data doesn’t actually go through <code class="literal">ftp-proxy</code>; the “proxy” adjusts the firewall rules so that traffic can pass. The proxy requires two parts: a running <code class="literal">ftp-proxy</code> instance and the redirect rules.</p><div class="sect2" title="Configuring ftp-proxy(8)"><div class="titlepage"><div><div><h3 class="title" id="configuring_ftp-proxy8">Configuring ftp-proxy(8)</h3></div></div></div><p>Like any other OpenBSD daemon, <code class="literal">ftp-proxy</code> is enabled in <span class="emphasis"><em>/etc/rc.conf.local</em></span>. There’s no configuration file—only command-line arguments. By default, <code class="literal">ftp-proxy</code> automatically listens on port 8021 on the loopback interface. It’s very rare for me to add any command-line arguments for <code class="literal">ftp-proxy</code> for routine use.</p><a id="I_programlisting22_id503942"/><pre class="programlisting">ftpproxy_flags=""</pre><p>If I’m debugging a problem, however, I might run <code class="literal">ftp-proxy</code> in the foreground, in debugging mode. Doing this shows me all FTP transactions as they occur.</p><a id="I_programlisting22_id503954"/><pre class="programlisting"># ftp-proxy -dD7</pre><p>This displays everything that passes through the FTP proxy, including the ports used for the data channel back to the client. Press <span class="smallcaps">CTRL</span>-C to stop <code class="literal">ftp-proxy</code>.</p><p>The most common problem I have with <code class="literal">ftp-proxy</code> is that nothing appears in the debugging terminal. That means that the firewall isn’t diverting any traffic to the proxy. Check your <span class="emphasis"><em>pf.conf</em></span> file to verify that you have the necessary rules to support the FTP proxy.</p></div><div class="sect2" title="PF Configuration and the FTP Proxy"><div class="titlepage"><div><div><h3 class="title" id="pf_configuration_and_the_ftp_proxy">PF Configuration and the FTP Proxy</h3></div></div></div><p>PF must know to send FTP requests to <code class="literal">ftp-proxy</code>. There’s a good example configuration in the default <span class="emphasis"><em>pf.conf</em></span> file:</p><a id="I_programlisting22_id504007"/><pre class="programlisting">anchor "ftp-proxy/*"
pass in quick inet proto tcp to port ftp divert-to 127.0.0.1 port 8021
pass out inet proto tcp from (self) to any port ftp</pre><p><a class="indexterm" id="idx0044"/><a class="indexterm" id="idx0053"/><a class="indexterm" id="idx0109"/><a class="indexterm" id="idx1763"/>Here’s where we use anchors. The <code class="literal">ftp-proxy/*</code> anchor can contain sub-rulesets. The <code class="literal">ftp-proxy</code> daemon modifies these anchors on the fly to configure the necessary traffic or data connections. The second rule declares that PF will divert any traffic addressed to the FTP port (21 as per <span class="emphasis"><em>/etc/services</em></span>) to port 8021 on the localhost. The third rule says that the firewall host can send TCP port 21 traffic to any other host. This rule contains a new term, <code class="literal">(self)</code>, which is PF shorthand for “all IP addresses on the localhost.”</p><p>How can you be sure this works? First, find an FTP server that supports active FTP. Open your FTP client and log in to the server, going through the firewall. Once you log in, use the <code class="literal">pasv</code> command at the FTP prompt. This command turns passive mode on and off. If the server doesn’t recognize <code class="literal">pasv</code>, it supports only passive FTP. Find another FTP server for this test. Once the FTP server reports that “passive mode is off,” list the contents of a directory. Directory listings, like data files, come over the data channel.</p><p>During the data transfer of an active FTP connection, you should see rules in the <code class="literal">ftp-proxy/*</code> anchor.</p><a id="I_programlisting22_id504085"/><pre class="programlisting"># <span class="strong"><strong>pfctl -a "ftp-proxy/*" -sr</strong></span>
anchor "6837.2" all {
  pass in log (all) quick on rdomain 0 inet proto tcp from 129.128.5.191 to 139.171.202.34 port = 62323 flags S/SA keep state (max 1) rtable 0 rdr-to 192.0.2.2 port 64280
  pass out log (all) quick on rdomain 0 inet proto tcp from 129.128.5.191 to 192.0.2.2 port = 64280 flags S/SA keep state (max 1) nat-to 129.128.5.191
}</pre><p>The rules created by <code class="literal">ftp-proxy</code> are very specific. They permit only one connection, from a particular server to a particular client, with address translation rules to make each side think it’s actually talking to the proper client or server.</p><div class="note" title="Note"><h3 class="title"><a id="ch22note03"/>Note</h3><p>To learn how to restrict your clients to using only anonymous FTP, or how to use <code class="literal">ftp-proxy</code> to permit inbound FTP access to a server inside your firewall, read the <code class="literal">ftp-proxy(8)</code> man page.</p></div></div></div><div class="sect1" title="Bandwidth Management"><div class="titlepage"><div><div><h2 class="title" id="bandwidth_management" style="clear: both">Bandwidth Management</h2></div></div></div><p>One common task for a network perimeter device is bandwidth management. Network managers must control how much bandwidth is used for certain tasks, and must also reserve bandwidth for vital functions. If one of your minions loads the latest blockbuster comic book movie on the web server, you must be able to make an SSH connection to the server, find out why your server is overloaded, and fix the problem. PF includes the ALTQ bandwidth management system.</p><p>The most important thing to remember about bandwidth management is that you cannot control how much traffic other people send you. You can stop traffic at the point it enters your network. You can send hints that the bandwidth is saturated. You can arbitrarily restrict bandwidth <span class="emphasis"><em>from</em></span> your servers. But nothing you do can stop 10,000 people a second from clicking a link to that server. You cannot prevent a distributed denial-of-service attack from saturating your inbound bandwidth. The best you can do is control how you respond to those requests.</p><p><a class="indexterm" id="idx0228"/><a class="indexterm" id="idx0253"/><a class="indexterm" id="idx0292"/><a class="indexterm" id="idx0825"/><a class="indexterm" id="idx0868"/><a class="indexterm" id="idx1764"/><a class="indexterm" id="idx1870"/><a class="indexterm" id="idx1872"/><a class="indexterm" id="idx1901"/>When I run content farms, I usually put dedicated bandwidth control machines in front of my servers. This setup controls how much traffic actually reaches my server network, reduces load on the servers in case of a sudden spike, and prevents one overly busy customer from taking down other customers on the same server.</p><div class="sect2" title="Queues for Bandwidth Management"><div class="titlepage"><div><div><h3 class="title" id="queues_for_bandwidth_management">Queues for Bandwidth Management</h3></div></div></div><p>ALTQ manages bandwidth by <span class="emphasis"><em>queues</em></span>. A queue is a list of packets waiting to be processed.</p><p>By dividing your bandwidth into separate queues, and processing those queues as you configure, you can manage server bandwidth. Queues are somewhat like the checkout lines at the grocery store; some lines are for 10 packets or less and get you out quickly, and others are for people who shop once a month and fill up three carts. You can define just about any characteristics for queues, as if you could create a “meats only” or “white wine with fish” register.</p><p>Engineers have defined many different queuing algorithms, and the most proper queue method for a given situation is a topic that sparks heated discussions. TCP/IP quality-of-service queue handling is one of those topics that make angelic children cry. By default, all BSD-based systems use first-in, first-out (FIFO) queuing, where packets are processed in the order in which they are received. Newer packets wait in a queue until older packets move on.</p><p>OpenBSD also supports priority queuing (PRIQ or prio), where the kernel considers packets of certain types to have “priority” and processes them first. This means that if you assign web packets highest priority, all web packets jump to the head of the queue. Packets of lower priority might never be processed at all under this scheme. These days, just about everything supports priority queuing, especially switches. The goal of priority queuing is to reduce latency for specific traffic, such as voice or video, paying for that reduced latency by increasing the latency of less urgent traffic.</p><p>However, in most operational settings where you must regulate bandwidth, class-based queuing (CBQ) is appropriate. CBQ allows the network administrator to allocate a certain amount of bandwidth to different types of traffic through hierarchical classes. Each class has its own queue, with its own bandwidth characteristics. You can assign different sorts of traffic to different classes: SSH to one class, HTTP and HTTPS to another, and so on. One of the nice features of CBQ is that its hierarchical nature allows lower classes to borrow available bandwidth from classes above them.</p><p><a class="indexterm" id="idx0112"/><a class="indexterm" id="idx1691"/><a class="indexterm" id="idx1906"/><a class="indexterm" id="idx2421"/><a class="indexterm" id="idx2447"/>As I find CBQ appropriate for most environments, I focus on it here. Once you master CBQ, if you need PRIQ, you’ll find it easy to understand.</p></div><div class="sect2" title="Parent Queue Definitions"><div class="titlepage"><div><div><h3 class="title" id="parent_queue_definitions">Parent Queue Definitions</h3></div></div></div><p>Queuing starts with defining the parent queue. All other queues are children of the parent queue. The parent queue is attached to a network interface, most commonly the Internet-facing interface. Place your queue definitions in <span class="emphasis"><em>pf.conf</em></span>. I put queues at the top of the file, before any packet-filtering rules.</p><p>Here’s how you define a parent queue on an interface:</p><a id="I_programlisting22_id504339"/><pre class="programlisting"><span class="strong"><strong>1</strong></span>altq on <span class="strong"><strong>2</strong></span><span class="emphasis"><em>interface</em></span> <span class="strong"><strong>3</strong></span>cbq bandwidth <span class="strong"><strong>4</strong></span><span class="emphasis"><em>bw</em></span> qlimit <span class="strong"><strong>5</strong></span><span class="emphasis"><em>qlim</em></span> tbrsize <span class="strong"><strong>6</strong></span><span class="emphasis"><em>size</em></span> <span class="strong"><strong>7</strong></span>queue { <span class="strong"><strong>8</strong></span><span class="emphasis"><em>queue1</em></span>, <span class="strong"><strong>9</strong></span><span class="emphasis"><em>queue2</em></span>}</pre><p>Start all ALTQ parent queue definitions with the <code class="literal">altq</code> keyword <span class="strong"><strong>1</strong></span>, and then give the interface to which this queue is attached <span class="strong"><strong>2</strong></span>. (Each interface can have no more than one parent queue.) Then give the queue type you’re using <span class="strong"><strong>3</strong></span>. For CBQ queuing, the queue type is always <code class="literal">cbq</code>.</p><p>Now define the total amount of bandwidth in the parent queue <span class="strong"><strong>4</strong></span>. This is not the same as the amount of bandwidth the interface can pass, but the amount of bandwidth you reasonably expect to pass upstream. If your OpenBSD machine has a gigabit network card, but you have only 10 megabits of bandwidth to the Internet, use <code class="literal">10Mb</code> as your bandwidth (or fiddle with the bandwidth value until you hit your actually usable allocation). You can use the following case-sensitive abbreviations for bandwidth:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><p title="b"><span class="title"><strong><span class="strong"><strong><code class="literal">b</code></strong></span></strong></span>. bits per second</p></li><li class="listitem" style="list-style-type: none"><p title="Kb"><span class="title"><strong><span class="strong"><strong><code class="literal">Kb</code></strong></span></strong></span>. kilobits per second</p></li><li class="listitem" style="list-style-type: none"><p title="Mb"><span class="title"><strong><span class="strong"><strong><code class="literal">Mb</code></strong></span></strong></span>. megabits per second</p></li><li class="listitem" style="list-style-type: none"><p title="Gb"><span class="title"><strong><span class="strong"><strong><code class="literal">Gb</code></strong></span></strong></span>. gigabits per second</p></li></ul></div><p>The optional <code class="literal">qlimit</code> parameter gives the number of packets the queue can hold <span class="strong"><strong>5</strong></span>. The default value is <code class="literal">50</code>, which suffices for almost all cases. I recommend not setting <code class="literal">qlimit</code> unless specific debugging shows that you need a larger queue size.</p><p>This example includes the token bucket regulator size configuration because <code class="literal">tbrsize</code> lets you dictate how quickly packets can be transmitted <span class="strong"><strong>6</strong></span>. ALTQ defaults to transmitting packets as fast as the wire permits. As with <code class="literal">qlimit</code>, I recommend not setting <code class="literal">tbrsize</code> unless you encounter a problem.</p><p>Next, identify this as a parent queue <span class="strong"><strong>7</strong></span>, and define child queues <code class="literal">queue1</code> <span class="strong"><strong>8</strong></span> and <code class="literal">queue2</code> <span class="strong"><strong>9</strong></span>.</p><p>Here’s how to configure a parent queue with a 50-megabit uplink, with the child queues <code class="literal">ssh</code>, <code class="literal">web</code>, and <code class="literal">mgmt</code>:</p><a id="I_programlisting22_id504605"/><pre class="programlisting">altq on em0 bandwidth 50Mb queue {ssh, web, mgmt}</pre><p>The <code class="literal">tbrsize</code> and <code class="literal">qlim</code> keywords are not set, so they’re at their defaults.</p></div><div class="sect2" title="Child Queue Definitions"><div class="titlepage"><div><div><h3 class="title" id="child_queue_definitions">Child Queue Definitions</h3></div></div></div><p><a class="indexterm" id="idx0111"/><a class="indexterm" id="idx0113"/><a class="indexterm" id="idx0246"/><a class="indexterm" id="idx1869"/><a class="indexterm" id="idx1903"/><a class="indexterm" id="idx1905"/><a class="indexterm" id="idx1907"/>Once you have a parent queue, you can define child queues. Define CBQ queues with the following syntax:</p><a id="I_programlisting22_id504690"/><pre class="programlisting">queue <span class="strong"><strong>1</strong></span><span class="emphasis"><em>name</em></span> on <span class="strong"><strong>2</strong></span><span class="emphasis"><em>interface</em></span> bandwidth <span class="strong"><strong>3</strong></span><span class="emphasis"><em>bw</em></span> [priority <span class="strong"><strong>4</strong></span>pri] [qlimit <span class="strong"><strong>5</strong></span><span class="emphasis"><em>qlim</em></span>] cbq <span class="strong"><strong>6</strong></span>(options) <span class="strong"><strong>7</strong></span>{child_queues}</pre><p>Each queue needs a name <span class="strong"><strong>1</strong></span>, defined in the parent queue definition, of 15 characters or less. The names don’t need to be unique—you could use a queue of the same name on a different interface—but I recommend that you use unique names.</p><p>The interface is the specific interface to which this queue is applied <span class="strong"><strong>2</strong></span>. If you don’t define an interface, traffic that passes through any interface can be assigned to this queue.</p><p>The <code class="literal">bandwidth</code> term uses the same bandwidth labels that the parent queue uses, but the total bandwidth assigned to all child queues cannot exceed the total amount of bandwidth available on the parent queue <span class="strong"><strong>3</strong></span>. You can also use a percentage value for bandwidth, indicating the percentage of the parent queue that this queue can consume. Bandwidth and queue are the only mandatory terms in a child queue description.</p><p>The following defines the <code class="literal">ssh</code> child queue and gives it a bandwidth of 2 megabits:</p><a id="I_programlisting22_id504791"/><pre class="programlisting">queue ssh bandwidth 2Mb</pre><p>Here’s a child queue called <code class="literal">web</code>, which is allowed to use three-quarters of the parent queue bandwidth:</p><a id="I_programlisting22_id504802"/><pre class="programlisting">queue web bandwidth 75%</pre><p>You can assign a priority to a queue <span class="strong"><strong>4</strong></span>. CBQ priorities run from <code class="literal">0</code> to <code class="literal">7</code>, with <code class="literal">7</code> being the highest. The default priority is <code class="literal">1</code>. A CBQ queue with a higher priority does not run to the exclusion of other queues, but PF processes it more quickly than other queues.</p><p>As with a parent queue, you can assign a <code class="literal">qlimit</code> to a child queue <span class="strong"><strong>5</strong></span>, but don’t do this unless you have a specific problem that can be solved with this value.</p><p>You can assign options to a CBQ child queue <span class="strong"><strong>6</strong></span>. We’ll look at these options in the next section.</p><p>Finally, child queues can have their own children. Define a queue’s children in the queue <span class="strong"><strong>7</strong></span>. You’ll see an example of this in <a class="xref" href="ch22.html#a_cbq_ruleset" title="A CBQ Ruleset">A CBQ Ruleset</a>.</p></div><div class="sect2" title="Queue Options"><div class="titlepage"><div><div><h3 class="title" id="queue_options">Queue Options</h3></div></div></div><p>Modify how a child queue processes packets by assigning options to a queue. Options let you decide how the queue should respond to a variety of network conditions and bandwidth availability.</p><div class="sect3" title="Default"><div class="titlepage"><div><div><h4 class="title" id="default">Default</h4></div></div></div><p><a class="indexterm" id="idx0229"/><a class="indexterm" id="idx0230"/><a class="indexterm" id="idx0254"/><a class="indexterm" id="idx0255"/><a class="indexterm" id="idx0537"/><a class="indexterm" id="idx0803"/><a class="indexterm" id="idx1919"/>Every parent queue must have one and only one default child. If a packet crossing a queued interface is assigned to no other queue, it is assigned to the default queue.</p></div><div class="sect3" title="Random Early Detection"><div class="titlepage"><div><div><h4 class="title" id="random_early_detection">Random Early Detection</h4></div></div></div><p>Random early detection (RED) is a method for handling packet loss when a queue starts to fill up. As the queue fills up, more and more packets are dropped. RED randomly chooses packets to drop. The net effect is that short transfers, such as HTTP requests and interactive SSH sessions, respond more quickly, while large data transfers become slower.</p><p>TCP clients and servers react to dropped packets by reducing their throughput. UDP, ICMP, and other protocols don’t have any built-in reaction to packet loss. Using RED on queues expected to carry TCP is sensible, but not on queues for other protocols.</p></div><div class="sect3" title="Explicit Congestion Notification"><div class="titlepage"><div><div><h4 class="title" id="explicit_congestion_notification">Explicit Congestion Notification</h4></div></div></div><p>Explicit Congestion Notification (ECN) is a modification to RED that sets flags in the packet rather than dropping the packet. If a device recognizes the ECN flag, it will reduce transmission rates.</p><p>Not all platforms understand ECN, however, and many that can recognize ECN disable it by default. Microsoft’s Windows Vista and newer, Apple OS X, FreeBSD, and OpenBSD can support ECN, but disable it by default. Newer Linux versions support ECN if the other host requests it. I have successfully used ECN, in corporate environments where I could make the support guys enable ECN on the desktops.</p><p>Unless you know the operating systems in use and can control their settings, stick with standard RED.</p></div><div class="sect3" title="borrow"><div class="titlepage"><div><div><h4 class="title" id="borrow">borrow</h4></div></div></div><p>The <code class="literal">borrow</code> option is available only in CBQ. A queue with borrow set may borrow bandwidth from its parent queue, if the bandwidth is available. For example, you might have a queue that reserves 20 percent of your bandwidth for VoIP. If you don’t have that much VoIP traffic at any particular moment, the parent will have excess bandwidth. Other queues could borrow bandwidth from that allocation. When your VoIP traffic spikes, however, PF revokes the bandwidth loan, and the VoIP traffic gets what’s reserved for it.</p><p>Use the <code class="literal">borrow</code> option on the queues that you want to permit to borrow bandwidth, not on the queues whose bandwidth might be borrowed.</p></div></div><div class="sect2" title="A CBQ Ruleset"><div class="titlepage"><div><div><h3 class="title" id="a_cbq_ruleset">A CBQ Ruleset</h3></div></div></div><p>Before configuring queues, figure out how you want to divide your bandwidth. While you could use bits per second to manage bandwidth, for most of us, percentages are easier to deal with. Here’s how you might divide Internet bandwidth for a company with a 10-megabit link. Start by making a list of your desired bandwidth reservations, and then assign a name to each category, like this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="indexterm" id="idx0110"/><a class="indexterm" id="idx1329"/><a class="indexterm" id="idx1902"/><a class="indexterm" id="idx1904"/>5 percent for SSH (<code class="literal">ssh</code>)</p></li><li class="listitem"><p>50 percent for inbound traffic to our e-commerce server, with RED (<code class="literal">web</code>)</p></li><li class="listitem"><p>5 percent for inbound VoIP, high priority (<code class="literal">voip</code>)</p></li><li class="listitem"><p>40 percent for other traffic, including DNS, SMTP, and so on</p></li></ul></div><p>All of these queues can borrow from the parent queue.</p><p>Start by defining the parent queue.</p><a id="I_programlisting22_id505133"/><pre class="programlisting">altq on em0 cbq bandwidth 10Mb queue {ssh, web, voip, other}</pre><p>This parent queue is attached to interface <code class="literal">em0</code>, and has 10 megabits of bandwidth and four child queues. Leave all the other options alone.</p><p>Now define the first child queue.</p><a id="I_programlisting22_id505150"/><pre class="programlisting">queue ssh bandwidth 5% cbq (borrow)</pre><p>Start with the queue name and the bandwidth percentage you’ve chosen. This percentage is calculated from the parent of this particular queue, so it’s about 5 percent of 10 megabits, or 500 kilobits per second. That should be plenty to log in remotely and fix any problems. Adding the <code class="literal">borrow</code> option lets you use more bandwidth for SSH if it’s available.</p><p>Building from this example, you can define the other child queues.</p><a id="I_programlisting22_id505167"/><pre class="programlisting">queue web bandwidth 50% cbq (borrow, red)
queue voip bandwidth 5% cbq (borrow)
queue other bandwidth 5% cbq (borrow, default)</pre><p>The other queue is your default. Any traffic that isn’t assigned its own queue is assigned to this queue.</p></div><div class="sect2" title="Assigning Traffic to Queues"><div class="titlepage"><div><div><h3 class="title" id="assigning_traffic_to_queues">Assigning Traffic to Queues</h3></div></div></div><p>Assign traffic to a queue with the <code class="literal">queue</code> keyword at the end of a packet-filtering rule. To allow all SSH (port 22) traffic into the network and assign it to the queue named <code class="literal">ssh</code>, use a rule like this:</p><a id="I_programlisting22_id505196"/><pre class="programlisting">pass in on egress proto tcp from any to lan:network port 22 queue ssh</pre></div><div class="sect2" title="Using the match Keyword"><div class="titlepage"><div><div><h3 class="title" id="using_the_match_keyword">Using the match Keyword</h3></div></div></div><p>Sometimes you must classify traffic without filtering it. The previous example let you assign inbound SSH traffic to the <code class="literal">ssh</code> queue, but what if you want to capture outbound SSH as well? Consider the following rule snippet:</p><a id="I_programlisting22_id505221"/><pre class="programlisting">pass in on egress proto tcp from &lt;customers&gt; to &lt;sshservers&gt; port 22
pass out on egress from lan:network to any</pre><p><a class="indexterm" id="idx1022"/><a class="indexterm" id="idx1319"/><a class="indexterm" id="idx1768"/><a class="indexterm" id="idx1786"/><a class="indexterm" id="idx1908"/>This allows hosts in the <code class="literal">customers</code> table to connect to hosts in the <code class="literal">sshservers</code> table on port 22. The second rule allows the local network to send any traffic, or any protocol. Some of that outbound traffic will be SSH traffic. Should you write a separate rule just for queuing traffic?</p><p>This is where the <code class="literal">match</code> keyword comes in. Using <code class="literal">match</code>, you can change how PF classifies traffic without changing how it filters traffic. Here’s how to send all TCP port 22 traffic to the <code class="literal">ssh</code> queue, without changing any filtering characteristics:</p><a id="I_programlisting22_id505302"/><pre class="programlisting">match proto tcp from any to any port 22 queue ssh
pass in on egress proto tcp from &lt;customers&gt; to &lt;sshservers&gt; port 22
pass out on egress from lan:network to any</pre><p>The first rule matches all traffic on TCP port 22 and assigns it to the <code class="literal">ssh</code> queue. The rules that follow control who can send and receive SSH connections.</p></div><div class="sect2" title="Viewing Queues"><div class="titlepage"><div><div><h3 class="title" id="viewing_queues">Viewing Queues</h3></div></div></div><p>To view the queues currently in the packet filter, run <code class="literal">pfctl -s queues</code>.</p><a id="I_programlisting22_id505330"/><pre class="programlisting"># <span class="strong"><strong>pfctl -sq</strong></span>
queue root_em0 on em0 bandwidth 10Mb priority 0 cbq( wrr root ) {ssh, web, voip, other}
queue  ssh on em0 bandwidth 500Kb cbq( borrow )
queue  web on em0 bandwidth 5Mb cbq( red borrow )
queue  voip on em0 bandwidth 500Kb priority 7 cbq( borrow )
queue  other on em0 bandwidth 500Kb cbq( borrow default )</pre><p>Adding <code class="literal">-v</code> gives you a brief snapshot of the state of each queue. For a constantly updating view of all queues, including how much traffic is borrowed from each, what gets dropped, and so on, use <code class="literal">-vvsq</code> or <code class="literal">systat queues</code> instead.</p></div></div><div class="sect1" title="PF Edges"><div class="titlepage"><div><div><h2 class="title" id="pf_edges" style="clear: both">PF Edges</h2></div></div></div><p>This section covers a couple tidbits of PF configuration that don’t quite fit anywhere else: include files and the <code class="literal">quick</code> keyword.</p><div class="sect2" title="Using Include Files"><div class="titlepage"><div><div><h3 class="title" id="using_include_files">Using Include Files</h3></div></div></div><p>Sometimes splitting a configuration file into multiple pieces simplifies your work. Do this with an <code class="literal">include</code> statement in <span class="emphasis"><em>pf.conf</em></span>.</p><a id="I_programlisting22_id505395"/><pre class="programlisting">include "/etc/pf/management-addresses"</pre><p>I do this when I need to manage several PF machines with unique configurations, but certain pieces are identical. The <span class="emphasis"><em>management-addresses</em></span> file defines a table listing all hosts and networks that can connect via SSH, make SNMP queries, as so on. When one of those addresses change, I copy this file to all of my PF hosts and reload the packet-filtering rules.</p></div><div class="sect2" title="Skipping Matches with quick"><div class="titlepage"><div><div><h3 class="title" id="skipping_matches_with_quick">Skipping Matches with quick</h3></div></div></div><p><a class="indexterm" id="idx1217"/><a class="indexterm" id="idx1769"/><a class="indexterm" id="idx1780"/><a class="indexterm" id="idx1793"/>PF processes packet-filtering rules in order, and the last matching rule wins, which can complicate designing a ruleset that supports exactly the access you desire. If you find yourself stuck, use the <code class="literal">quick</code> keyword to abort processing the rest of the rules for matching packets. Here’s an example:</p><a id="I_programlisting22_id505469"/><pre class="programlisting">…
pass in <span class="strong"><strong>quick</strong></span> proto tcp from any to $sshserver port 22
…
block in proto tcp from any to any port 22
…</pre><p>The first rule permits traffic to the host(s) in the macro <code class="literal">$sshserver</code> on port 22. The second rule drops all TCP port 22 traffic. The <code class="literal">quick</code> keyword in the first rule says, “When a packet matches this rule, follow this rule and do not process any more rules.” In this case, the SSH connection will be permitted.</p><p>The <code class="literal">quick</code> keyword is especially useful in anchors, where rules added for a special purpose by an automated process like <code class="literal">ftp-proxy(8)</code> might be overridden by later rules meant for unrelated purposes.</p><p>The purist in me wants to insist that all static rulesets be written without using <code class="literal">quick</code>. While strictly speaking that’s true, sometimes avoiding <code class="literal">quick</code> creates rulesets that are difficult to interpret. A ruleset you can easily understand is more secure than something baroque but syntactically pure.</p></div></div><div class="sect1" title="Logging PF"><div class="titlepage"><div><div><h2 class="title" id="logging_pf" style="clear: both">Logging PF</h2></div></div></div><p>Tell PF to log packets with the <code class="literal">log</code> keyword in a rule.</p><a id="I_programlisting22_id505537"/><pre class="programlisting">pass out <span class="strong"><strong>log</strong></span> on egress from lan:network to any</pre><p>Without additional setup, however, those logs just go to the PF log device <code class="literal">pflog0</code>. To successfully log PF messages, you must run the packet filter logger <code class="literal">pflogd(8)</code>. If you start PF at boot, <code class="literal">pflogd</code> is automatically started with it. Otherwise, you must start it on the command line.</p><p>One thing to remember is that if you’re using stateful inspection, only the first packet that triggers a rule is logged. Other packets that are part of the same state are not logged. To log all packets in a stateful connection, give the <code class="literal">all</code> modifier to the <code class="literal">log</code> keyword, but beware because this can generate very large logs.</p><a id="I_programlisting22_id505575"/><pre class="programlisting">pass out log <span class="strong"><strong>(all)</strong></span> on egress from lan:network to any</pre><p>Logging is especially useful when troubleshooting connection problems. If packets are being blocked when you think they should be passed, add logging to your <code class="literal">block</code> statements to see which rule is stopping the traffic.</p><p>I don’t recommend logging everything, especially because logs can grow quite large. Log selectively. For example, perhaps you don’t care which websites your local users visit, but do want to know about incoming traffic. And be sure to exclude your firewall logging traffic from your packet filter logs, or you’ll quickly find that PF is logging the transmission of the logs of the log transmissions, which are logs of transmitting the logs, from when you transmitted the logs … yadda yadda yadda.</p><div class="sect2" title="Reading PF Logs"><div class="titlepage"><div><div><h3 class="title" id="reading_pf_logs">Reading PF Logs</h3></div></div></div><p><a class="indexterm" id="idx0858"/><a class="indexterm" id="idx1218"/><a class="indexterm" id="idx1833"/><a class="indexterm" id="idx2377"/><a class="indexterm" id="idx2378"/><a class="indexterm" id="idx2586"/>PF logs in the <code class="literal">tcpdump(8)</code> binary format. Use <code class="literal">tcpdump</code> to examine the data. To just dump everything in the log, tell <code class="literal">tcpdump</code> to read the log file.</p><a id="I_programlisting22_id505685"/><pre class="programlisting"># <span class="strong"><strong>tcpdump -r /var/log/pflog</strong></span></pre><p>This can generate a huge amount of output. See <a class="xref" href="ch22.html#filtering_tcpdump" title="Filtering tcpdump">Filtering tcpdump</a> for some hints.</p></div><div class="sect2" title="Real-Time Log Access"><div class="titlepage"><div><div><h3 class="title" id="real-time_log_access">Real-Time Log Access</h3></div></div></div><p>The entries in <span class="emphasis"><em>/var/log/pflog</em></span> are not added in real time; <code class="literal">pflogd(8)</code> buffers its records until writing a log message is worthwhile. To see PF logs in real time, attach <code class="literal">tcpdump</code> to the <code class="literal">pflog0</code> interface with the <code class="literal">-i</code> flag.</p><a id="I_programlisting22_id505736"/><pre class="programlisting"># <span class="strong"><strong>tcpdump -i pflog0</strong></span></pre><p>Depending on how much traffic you’re logging, this might also produce an overwhelming amount of information. You must filter <code class="literal">tcpdump</code> to make it useful. Or if you pretend you missed my earlier warning about log sizes, you can devise a one-liner that uses <code class="literal">logger</code> to send your PF logs as text to <code class="literal">syslog</code>.</p></div><div class="sect2" title="Filtering tcpdump"><div class="titlepage"><div><div><h3 class="title" id="filtering_tcpdump">Filtering tcpdump</h3></div></div></div><p>Every system administrator should know how to use <code class="literal">tcpdump</code>. Here’s your motivation for doing so.</p><p>When troubleshooting a problem with a particular connection, you probably don’t care about every packet passing through the filter. You care about traffic to or from a particular host. Specify an IP address with the <code class="literal">ip</code> or <code class="literal">ip6</code> expression.</p><a id="I_programlisting22_id505794"/><pre class="programlisting"># <span class="strong"><strong>tcpdump -i pflog0 ip host 192.0.2.2</strong></span></pre><p>This will display only traffic to and from this particular host.</p><p>To narrow things further and see only the traffic between two hosts, combine the hosts with the <code class="literal">and</code> keyword.</p><a id="I_programlisting22_id505815"/><pre class="programlisting"># <span class="strong"><strong>tcpdump -i pflog0 ip host 192.0.2.2 and ip host 203.0.113.88</strong></span></pre><p>Maybe you’re interested in only a specific port, on a specific address. Use the <code class="literal">tcp</code> or <code class="literal">udp</code> keyword and the port number to filter on that.</p><a id="I_programlisting22_id505835"/><pre class="programlisting"># <span class="strong"><strong>tcpdump -i pflog0 ip host 139.171.199.254 and tcp port 80</strong></span></pre><p><a class="indexterm" id="idx0154"/><a class="indexterm" id="idx0938"/><a class="indexterm" id="idx1781"/><a class="indexterm" id="idx1794"/><a class="indexterm" id="idx2452"/>Read the <code class="literal">tcpdump(8)</code> man page for an exhaustive list of innumerable other filtering options.</p><p>If using <code class="literal">tcpdump</code> doesn’t appeal to you, consider the <code class="literal">pflow(4)</code> NetFlow exporter. Network flow is a complicated topic, but the book <span class="emphasis"><em>Network Flow Analysis</em></span> (No Starch Press, 2010) might help you.</p></div><div class="sect2" title="Ruleset Tracing"><div class="titlepage"><div><div><h3 class="title" id="ruleset_tracing">Ruleset Tracing</h3></div></div></div><p>Sometimes, knowing whether a packet passed or failed isn’t enough. You know that a packet was blocked, but not why. You want to watch the packet pass through the rules and see which rules affect it.</p><p>Suppose an internal host 192.0.2.226 cannot connect to the external host 203.0.113.34. The log would show that the packet is blocked, but not why. You can specifically have PF log matching rules. Add a line like this to the top of your <span class="emphasis"><em>pf.conf</em></span> file:</p><a id="I_programlisting22_id505936"/><pre class="programlisting">match log (matches) from 192.0.2.226 to 203.0.113.34</pre><p>This is a standard packet-filtering rule. You could use an individual IP address, a port number, or any other legal packet filter terms. Reload your packet-filtering rules.</p><p>Turn on <code class="literal">tcpdump</code>, and filter based on one of the IP addresses in your <code class="literal">match</code> statement. If you’re using NAT, filter on the IP address that doesn’t change.</p><a id="I_programlisting22_id505957"/><pre class="programlisting"># <span class="strong"><strong>tcpdump -n -e -ttt -i pflog0 ip host 203.0.113.34</strong></span>
Dec 17 18:05:07.773703 <span class="strong"><strong>rule 0/(match) match out on fxp0</strong></span>: 192.0.2.226.24916
&gt; 203.0.113.34.22: S 1730871963:1730871963(0) win 16384 &lt;mss 1460,nop,nop,
sackOK,nop,wscale 3,nop,nop,timestamp 597858150[|tcp]&gt; (DF)
Dec 17 18:05:07.773708 <span class="strong"><strong>rule 2/(match) block out on fxp0</strong></span>: 192.0.2.226.24916
&gt; 203.0.113.34.22: S 1730871963:1730871963(0) win 16384 &lt;mss 1460,nop,nop,
sackOK,nop,wscale 3,nop,nop,timestamp 597858150[|tcp]&gt; (DF)
Dec 17 18:05:07.773712 <span class="strong"><strong>rule 5/(match) pass out on fxp0</strong></span>: 192.0.2.226.24916
&gt; 203.0.113.34.22: S 1730871963:1730871963(0) win 16384 &lt;mss 1460,nop,nop,
sackOK,nop,wscale 3,nop,nop,timestamp 597858150[|tcp]&gt; (DF)</pre><p>While I won’t go through all the annoying details of reading <code class="literal">tcpdump</code> output, you can see that PF logs the rule numbers that this data connection matches, and whether the rule passes or blocks the connection. If the connection involves NAT, you’ll see the actual and translated IP addresses.</p><p>At this point, you know enough about PF to protect a small network. If you need more, definitely check out <span class="emphasis"><em>The Book of PF, 2nd edition</em></span> (No Starch Press, 2010).</p><p>Now let’s look at some of the more exotic edges of OpenBSD.</p></div></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.id330960"><p><sup>[<a class="para" href="#id330960">48</a>] </sup>Can Lucas configure a highly available firewall cluster in a day? Yep. Can he search and replace IP addresses in a text file without screwing everything up? Nope.</p></div></div></section></body></html>