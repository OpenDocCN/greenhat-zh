<html><head></head><body><section class="chapter" epub:type="chapter" id="root_and_how_to_avoid_it" title="Chapter&#xA0;7.&#xA0;Root, and How to Avoid It"><div class="titlepage"><div><div><h2 class="title">Chapter 7. Root, and How to Avoid It</h2></div></div></div><div class="epigraph" epub:type="epigraph"><div class="literallayout"><p><span class="emphasis"><em>The root of all evil</em></span><br/>
<span class="emphasis"><em>is never far from your touch.</em></span><br/>
<span class="emphasis"><em>sudo saves your life.</em></span></p></div></div><p><a class="indexterm" id="idx1989"/><span class="inlinemediaobject"><a id="inline_id00008"/><img alt="" src="httpatomoreillycomsourcenostarchimages1616079.png"/></span> The security of most Unix-like operating systems has long been considered coarsely grained. One superuser, root, can do anything. Other users are lowly sharecroppers who endure the shackles root places upon them. The problem is that root doesn’t have many shackles and it can’t individualize the ones that it has very well. Some operating systems use POSIX access control lists (ACLs) to provide more fine-grained access controls, but these are difficult to configure correctly.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id411230" id="id411230">15</a>]</sup></p><p>While it’s true that Unix-like operating systems don’t have detailed access controls, the fact is that most people don’t bother using the controls that <span class="emphasis"><em>do</em></span> exist. Fortunately, you can combine groups and permissions to handle almost any problem securely.</p><div class="sect1" title="The Root Password"><div class="titlepage"><div><div><h2 class="title" id="the_root_password" style="clear: both">The Root Password</h2></div></div></div><p><a class="indexterm" id="idx0927"/><a class="indexterm" id="idx1985"/><a class="indexterm" id="idx2258"/><a class="indexterm" id="idx2263"/><a class="indexterm" id="idx2650"/>The root user owns the system and has absolute power over every piece of hardware as well as certain actions that require absolute control, such as manipulating the kernel and changing authentication sources. You need root permissions to perform these tasks. You can log in as root, use <code class="literal">su(1)</code> to become root, or use <code class="literal">sudo(8)</code> (discussed later this chapter) to get certain root-level privileges without actually using the root account.</p><p>To use the root password, you can either log in as root at a console login prompt or, if you belong to the group <code class="literal">wheel</code>, log in as yourself and use the switch user command <code class="literal">su(1)</code>. Of the two, I recommend using <code class="literal">su</code>; it logs who uses it and can be used when you are logged in from a remote system. To use <code class="literal">su</code>, run the following:</p><a id="I_programlisting7_id443034"/><pre class="programlisting">$ <span class="strong"><strong>su</strong></span>
Password:
#</pre><p>When prompted, enter the root password. Now check your current user ID with <code class="literal">id(1)</code>.</p><a id="I_programlisting7_id443051"/><pre class="programlisting"># <span class="strong"><strong>id</strong></span>
uid=0(root) gid=0(wheel) groups=0(wheel), 2(kmem), 3(sys), 4(tty), 5(operator), 20(staff), 31(guest)</pre><p>As you can see, the UID is 0, which means that you now own the system, and I do mean <span class="emphasis"><em>own</em></span> it. Consider every keystroke carefully. Carelessness could return your hard drive to its primordial, unformatted state.</p><p>Only users in the group <code class="literal">wheel</code> can use the root password to become root via <code class="literal">su</code>. If you give the root password to users without physical console access and who are in the <code class="literal">wheel</code> group, they can enter <code class="literal">su</code> and the root password as many times as they want, and it won’t work. (But anyone can use the root account and password at the system console, so don’t make a habit of blabbing the root password all around the office.)</p><p>Requiring group membership to use the root password leads to the question, “Who needs root access?” Root is required to configure many parts of OpenBSD, but once the system is running properly, you can greatly decrease or discontinue your use of root. For any remaining tasks that absolutely require root, use <code class="literal">sudo</code>.</p></div><div class="sect1" title="Using Groups"><div class="titlepage"><div><div><h2 class="title" id="using_groups" style="clear: both">Using Groups</h2></div></div></div><p>One of the simplest ways to reduce the need for root is with groups. Unix-like operating systems classify users into groups, which consist of accounts of users who perform similar administrative functions. You can, for example, define a group named <code class="literal">dnsadmins</code> and add the accounts of every user who edits DNS zone files to that group. Then, by setting the permissions of the zone files and their directory appropriately, members of that group can edit zone files and reload the name server without the root password. The good news is that you could create such a group for almost any system function, and thereby avoid giving those users root access. Using groups in this manner is a powerful and often neglected system administration tool. I use groups for administering my own servers—just because I <span class="emphasis"><em>can</em></span> use root doesn’t mean that I <span class="emphasis"><em>want</em></span> to use root. Users can identify the groups they belong to by using <code class="literal">id(1)</code>.</p><a id="I_programlisting7_id443136"/><pre class="programlisting"># <span class="strong"><strong>id</strong></span>
uid=1000(mwlucas) gid=1000(mwlucas) groups=1000(mwlucas), 0(wheel), 2005(dnsadmin)</pre><p><a class="indexterm" id="idx0613"/><a class="indexterm" id="idx0918"/><a class="indexterm" id="idx0926"/><a class="indexterm" id="idx0928"/><a class="indexterm" id="idx1006"/><a class="indexterm" id="idx1431"/><a class="indexterm" id="idx1731"/><a class="indexterm" id="idx2519"/>My UID is 1000, and my username is <code class="literal">mwlucas</code>. My GID, the primary group ID, is also 1000 and is also named <code class="literal">mwlucas</code>. I’m also in the <code class="literal">wheel</code> and <code class="literal">dnsadmin</code> groups.</p><div class="sect2" title="The /etc/group File"><div class="titlepage"><div><div><h3 class="title" id="the_etc_group_file">The /etc/group File</h3></div></div></div><p>The file <span class="emphasis"><em>/etc/group</em></span> contains all group information. Each line contains four colon-delimited fields: the group name, password, ID number, and list of members.</p><a id="I_programlisting7_id443245"/><pre class="programlisting">wheel:*:0:root,mwlucas,pkdick</pre><p>The <span class="emphasis"><em>group name</em></span> is a human-friendly name for the group. This group is named <code class="literal">wheel</code>. Group names are completely arbitrary and you could call a group <code class="literal">lickspittles</code> if you want, but you should choose a name that gives an idea of the group’s purpose. While you might remember that <code class="literal">lickspittles</code> can edit the company web page, will that group name make any sense to your coworkers? If it does, you probably need better coworkers.</p><p>The second field, the group password, was a great theory that became an appalling practice once exposed to the real world. Modern Unix-like systems don’t do anything with the group password, but the field remains because old programs expect to find something here. The asterisk is just a placeholder to placate such software. (While OpenBSD could eliminate this field, some enterprises share <span class="emphasis"><em>/etc/group</em></span> across operating systems.)</p><p>The third field gives the group’s unique numeric GID. Many programs use the GID rather than the name to identify a group. The <code class="literal">wheel</code> group has a GID of 0. The maximum GID is 232, or 4,294,967,296.</p><p>Last is a comma-separated list of all users in the group. As you can see, the users <code class="literal">root</code>, <code class="literal">mwlucas</code>, and <code class="literal">pkdick</code> are all members of the <code class="literal">wheel</code> group. To add users to a group, add their username to this list, but remember that no <span class="emphasis"><em>/etc/group</em></span> entry can contain more than 200 users or be longer than 1024 characters.</p></div><div class="sect2" title="Creating Groups"><div class="titlepage"><div><div><h3 class="title" id="creating_groups">Creating Groups</h3></div></div></div><p>In order to create a new group, you need a name and GID number. OpenBSD usually assigns the next free GID to a newly created group with GIDs below 1000 reserved for OpenBSD. Programs included in OpenBSD that need a dedicated group ID use one below 1000. Software installed via the OpenBSD package system or ports (discussed in <a class="xref" href="ch13.html" title="Chapter 13. Software Management">Chapter 13</a>) assigns dedicated GIDs in the 500 to 1000 range. GIDs for user accounts start at 1000 and go up. If you create groups for special roles, start at a high GID so that these administrative groups will be obviously different from user accounts.</p></div><div class="sect2" title="Groups, Unprivileged Users, and Group Permissions"><div class="titlepage"><div><div><h3 class="title" id="groups_unprivileged_users_and_group_perm">Groups, Unprivileged Users, and Group Permissions</h3></div></div></div><p><a class="indexterm" id="idx0832"/><a class="indexterm" id="idx0929"/><a class="indexterm" id="idx1248"/><a class="indexterm" id="idx1754"/>The simplest way to create a new group is to use <code class="literal">adduser</code> to create an unprivileged user for the role, and use that user’s group to assign file permissions. As with any other unprivileged user, give this account the home directory <span class="emphasis"><em>/var/empty</em></span> and a shell of <code class="literal">nologin</code>. Do not add this user to any other groups (especially not <code class="literal">wheel</code>). Lastly, let <code class="literal">adduser</code> disable the account. Sure, the shell will prevent logins, but an extra layer of defense won’t hurt.</p><p>Now that you have an administrative user and a group, you can assign file ownership. A user and a group own every file. To view the permissions on existing files, including hidden ones, use <code class="literal">ls -la</code>. (If you’ve forgotten how file ownership and permissions work, read <code class="literal">ls(1)</code> and <code class="literal">chmod(1)</code>.) Many system administrators focus on file ownership and owner permissions, invest somewhat less time on worldwide permissions, and gloss over group permissions as if they don’t exist. Look closely at the sample DNS files that follow.</p><a id="I_programlisting7_id443427"/><pre class="programlisting"># <span class="strong"><strong>ls -la</strong></span>
total 22
drwxr-xr-x  2 mwlucas  wheel     512 Apr 16 22:02 .
drwxrwxrwt  8 root     wheel     512 Apr 16 22:00 ..
-rw-rw-r--  1 mwlucas  mwlucas 14595 Apr 16 22:02 michaelwlucas.com.db
-rw-r-----  1 mwlucas  wheel     198 Apr 16 22:02 rndc.key</pre><p>This directory contains two files. The file <span class="emphasis"><em>rndc.key</em></span> can be read and written by the user <code class="literal">mwlucas</code>; anyone in the <code class="literal">wheel</code> group can read <span class="emphasis"><em>rndc.key</em></span>; and no one else can even read it. The file <span class="emphasis"><em>michaelwlucas.com.db</em></span> can be read or written by the user <code class="literal">mwlucas</code> or anyone in the group <code class="literal">wheel</code>, but others can only read it. If you’re in the group <code class="literal">mwlucas</code>, you can edit this file.</p><p>Say I want my junior DNS administrators to be able to edit zone files but not be able to edit the <code class="literal">rndc(8)</code> configuration. The file permissions are correct, but I need the files to be owned by my DNS administrative user, <code class="literal">dnsadmin</code>. I also want my DNS admins to be able to create new zone files, so they need write permissions on the directory. Here’s how I would do that:</p><a id="I_programlisting7_id443486"/><pre class="programlisting"># <span class="strong"><strong>chown dnsadmin:dnsadmin michaelwlucas.com.db</strong></span>
# <span class="strong"><strong>chgrp dnsadmin rndc.key</strong></span>
# <span class="strong"><strong>chown dnsadmin:dnsadmin .</strong></span>
# <span class="strong"><strong>chmod 775 .</strong></span>
# <span class="strong"><strong>ls -la</strong></span>
total 22
drwxrwxr-x  2 dnsadmin  dnsadmin    512 Apr 16 22:02 .
drwxrwxrwt  8 root      wheel       512 Apr 16 22:08 ..
-rw-rw-r--  1 dnsadmin  dnsadmin  14595 Apr 16 22:02 michaelwlucas.com
-rw-r--r--  1 root      dnsadmin    198 Apr 16 22:02 rndc.key</pre><p><a class="indexterm" id="idx0309"/><a class="indexterm" id="idx1977"/><a class="indexterm" id="idx1993"/><a class="indexterm" id="idx2264"/><a class="indexterm" id="idx2267"/><a class="indexterm" id="idx2274"/>As you can see, these files are now owned by the user <code class="literal">dnsadmin</code> and the group <code class="literal">dnsadmin</code>. Anyone in the group <code class="literal">dnsadmin</code> should be able to edit <span class="emphasis"><em>michaelwlucas.com.db</em></span> without using the root password. The user <code class="literal">named</code>—the unprivileged user for the DNS server—should be able to read both files. Add your DNS administrators to the <code class="literal">dnsadmin</code> group in <span class="emphasis"><em>/etc/group</em></span>, and they should no longer need the root password to do their jobs.</p><p>This model has limitations, however. While your junior admins can’t accidentally edit <span class="emphasis"><em>rndc.conf</em></span>, they can delete and replace it. It would be better to put that file in a directory they can read but not edit. And while our DNS administrators might think that they need the root password to restart the name server, they’re wrong. Use <code class="literal">rndc(8)</code> to manage the DNS server; other tasks can be managed via <code class="literal">cron(8)</code> or through <code class="literal">sudo</code>.</p></div></div><div class="sect1" title="Hiding Root with sudo"><div class="titlepage"><div><div><h2 class="title" id="hiding_root_with_sudo" style="clear: both">Hiding Root with sudo</h2></div></div></div><p>While the proper use of groups can almost eliminate the need for root access to edit files, that won’t help with commands that can be run only by root. You could set up a cron job to reload the name server each day at midnight, but every piece of software occasionally needs a manual restart. Because root is an all-or-nothing affair, people who have one minor task to perform have traditionally needed the root password.</p><p>OpenBSD includes <code class="literal">sudo(8)</code> and its associated tools, which implement fine-grained access control for commands that can be run only by particular users. When configured properly, <code class="literal">sudo</code> lets normal users run specific programs as other users, including root. Configured improperly, <code class="literal">sudo</code> permits full root access. I’ll explain a basic <code class="literal">sudo</code> setup that covers almost all uses, but remember that many more combinations are possible. And don’t be afraid to read <code class="literal">sudo(8)</code>, <code class="literal">sudoers(5)</code>, and the documentation at the <code class="literal">sudo</code> home page (<span class="emphasis"><em><a class="ulink" href="http://www.gratisoft.us/sudo/" target="_top">http://www.gratisoft.us/sudo/</a></em></span>).</p><div class="sect2" title="Why Use sudo?"><div class="titlepage"><div><div><h3 class="title" id="why_use_sudo">Why Use sudo?</h3></div></div></div><p>The <code class="literal">sudo</code> tool provides benefits beyond fine-grained privilege control. Every command run via <code class="literal">sudo</code> is logged, making it very easy to track who did what. The senior sysadmin can change the root password and not give it out, even to people who have root-level access.</p><p>The <code class="literal">sudo</code> configuration file is designed to be shared across multiple systems, so one <code class="literal">sudo</code> policy can cover your entire network and every operating system. Admittedly, you’ll have trouble using a single <code class="literal">sudo</code> configuration on operating systems with wildly unique directory layouts, such as Mac OS X, but you can easily share one configuration among OpenBSD, other BSDs, Linux, and even OpenSolaris or AIX.</p></div><div class="sect2" title="sudo Disadvantages"><div class="titlepage"><div><div><h3 class="title" id="sudo_disadvantages">sudo Disadvantages</h3></div></div></div><p>The most common problem with <code class="literal">sudo</code> is getting your users to accept it. People who have historically had access to the root account think they “lose something” by working through <code class="literal">sudo</code>.</p><p><a class="indexterm" id="idx0538"/><a class="indexterm" id="idx0756"/><a class="indexterm" id="idx2066"/><a class="indexterm" id="idx2108"/><a class="indexterm" id="idx2272"/><a class="indexterm" id="idx2276"/><a class="indexterm" id="idx2623"/>The key to overcoming this is to give users access only to what’s required to perform the tasks for which they’re responsible. A junior administrator who complains about insufficient privileges has either overreached his responsibilities or needs more privileges. One sure way to discover what people actually do is to implement a minimal <code class="literal">sudo</code> permissions scheme and wait for complaints. If no one complains, they’re not working very hard.</p><p>The configuration syntax for <code class="literal">sudo</code> can be confusing because its configuration doesn’t closely resemble any other configuration file, and getting everything right can be difficult at first. The configuration file is actually well suited to its purpose, however. Once you understand it, adjusting privileges is quick and easy.</p><div class="note" title="Note"><h3 class="title"><a id="ch07note01"/>Note</h3><p>More seriously, a faulty <code class="literal">sudo</code> setup can create the appearance of security while leaving gaps for a user to become root. Be sure to test <code class="literal">sudo</code> every time you make a change, and avoid the common configuration mistakes I document here.</p></div><p>Some users will do their best to push the limits of their access, for no other reason than to see if they can outsmart you. These users are best managed with a combination of careful configuration, administrative policy, and a cricket bat.</p></div><div class="sect2" title="An Overview of the sudo Software"><div class="titlepage"><div><div><h3 class="title" id="an_overview_of_the_sudo_software">An Overview of the sudo Software</h3></div></div></div><p>The <code class="literal">sudo</code> program is a <code class="literal">setuid</code> root wrapper that can run commands as any other user. Use <code class="literal">sudo</code> by giving it the command you want to run.</p><a id="I_programlisting7_id443876"/><pre class="programlisting">$ <span class="strong"><strong>sudo /etc/rc.d/named restart</strong></span></pre><p>The <code class="literal">sudo</code> software compares the desired command (in this case, <code class="literal">/etc/rc.d/named restart</code>) to its internal list of permissions and privileges. If the configuration file allows that particular user to run that command as root, <code class="literal">sudo</code> runs it as root. And, because root can run any command as any user, <code class="literal">sudo</code> can also run commands as any arbitrary system user. You can use this fact to grant any user the ability to run specific commands as chosen users; for example, administrators of certain database servers must frequently run commands as the database user.</p><p>The <code class="literal">sudo</code> software is a suite with four pieces. The first piece is the actual <code class="literal">sudo(8)</code> command, the <code class="literal">setuid</code> root wrapper. The second is the configuration file <span class="emphasis"><em>/etc/sudoers</em></span>, which describes who may run which commands as what user. (<span class="emphasis"><em>/etc/sudoers</em></span> is fully documented in <code class="literal">sudoers(5)</code>.) Third is the <code class="literal">visudo(8)</code> command that opens <span class="emphasis"><em>/etc/sudoers</em></span> in an editor and checks the configuration file syntax before exiting. Finally, the <code class="literal">sudoedit(8)</code> program is specifically for editing files as another user.</p></div><div class="sect2" title="The visudo(8) Command"><div class="titlepage"><div><div><h3 class="title" id="the_visudo8_command">The visudo(8) Command</h3></div></div></div><p>If <span class="emphasis"><em>/etc/sudoers</em></span> contains incorrect syntax, <code class="literal">sudo</code> will not run. If you rely on <code class="literal">sudo</code> to provide root-level access to the system and you break your <span class="emphasis"><em>sudoers</em></span> file, you’ll lock yourself out of the root account and lose the ability to correct your error. That is bad.</p><p><a class="indexterm" id="idx0757"/>Fortunately, the <code class="literal">visudo(8)</code> program provides some protection against this sort of error by locking <span class="emphasis"><em>/etc/sudoers</em></span> so that only one person can edit the configuration at a time. It then opens <span class="emphasis"><em>/etc/sudoers</em></span> in a text editor (vi by default, but it respects the <code class="literal">$EDITOR</code> environment variable). Make your changes and save your work. When you exit the editor, <code class="literal">visudo</code> should parse the file for syntactic correctness.</p><p>If <code class="literal">visudo</code> detects an error, it prints out the offending line number and asks what you want to do.</p><a id="I_programlisting7_id444018"/><pre class="programlisting">&gt;&gt;&gt; /etc/sudoers: syntax error near line 34 &lt;&lt;&lt;
What now?</pre><p>Here, I’ve made an error near line 34. I can reedit the file to fix the error, quit without saving any changes, or force <code class="literal">visudo</code> to accept this file.</p><p>Press the E key, and <code class="literal">visudo</code> should return you to the editor. Go to the offending line, fix your error, save the file, and exit the editor again.</p><p>Enter the X key, and <code class="literal">visudo</code> should quit and revert the configuration file to its original state. Your changes will be lost, but that might be acceptable. It’s better to have an old, working configuration than a new, broken one.</p><p>Pressing Q forces <code class="literal">visudo</code> to accept the file, busted syntax and all. If <code class="literal">sudo</code> can’t parse <span class="emphasis"><em>/etc/sudoers</em></span>, it will immediately exit. Essentially, you’re telling <code class="literal">visudo</code> to break <code class="literal">sudo</code> until you log in as root to fix the problem. If you think you understand <span class="emphasis"><em>/etc/sudoers</em></span> better than <code class="literal">visudo</code> does, you’re probably wrong. Even if you’re right, you’re wrong.</p><p>The <code class="literal">visudo</code> program doesn’t guarantee that the configuration will do what you desire, only that the configuration parses and is valid. A properly formatted configuration that declares “No one may do anything via <code class="literal">sudo</code>” is perfectly acceptable to <code class="literal">visudo</code>.</p></div><div class="sect2" title="The /etc/sudoers File"><div class="titlepage"><div><div><h3 class="title" id="the_etc_sudoers_file">The /etc/sudoers File</h3></div></div></div><p>The <span class="emphasis"><em>/etc/sudoers</em></span> file determines who may run which commands as which users. Never edit <span class="emphasis"><em>/etc/sudoers</em></span> directly, even if you think you know exactly what change you want to make. Always use <code class="literal">visudo</code> to change <span class="emphasis"><em>/etc/sudoers</em></span>.</p><p>The various <span class="emphasis"><em>sudoers</em></span> sample configurations you’ll find are usually very complicated, as they demonstrate all the nifty things <code class="literal">sudo</code> can do. At this point, however, you want to do only simple, boring things, like giving particular users access to run specific commands. And the bare syntax is very simple. Every <span class="emphasis"><em>sudoers</em></span> rule follows this format:</p><a id="I_programlisting7_id444143"/><pre class="programlisting"><span class="emphasis"><em>Username    host</em></span>=<span class="emphasis"><em>command</em></span></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <span class="emphasis"><em><code class="literal">username</code></em></span> is the username of the user who may execute the command, an alias for usernames, or a system group.</p></li><li class="listitem"><p>The <span class="emphasis"><em><code class="literal">host</code></em></span> is the hostname of the system this rule applies to. You can share <span class="emphasis"><em>/etc/sudoers</em></span> across multiple systems. This entry permits per-host rules.</p></li><li class="listitem"><p>The <span class="emphasis"><em><code class="literal">command</code></em></span> space lists the commands this rule applies to. You must list the full path to each command, or <code class="literal">sudo</code> will not recognize it. If this weren’t a requirement, some untrustworthy soul could just adjust his <code class="literal">$PATH</code> to access renamed versions of commands.</p></li></ul></div><p><a class="indexterm" id="idx0761"/>For example, suppose I trust user <code class="literal">sbaxter</code> to run any command, on any system, as root. I use the keyword <code class="literal">ALL</code> to match all possible options for host and command:</p><a id="I_programlisting7_id444222"/><pre class="programlisting">sbaxter    ALL=ALL</pre><p>As the lead sysadmin, I should know which duties I have assigned <code class="literal">sbaxter</code>, and exactly which commands he needs. Suppose <code class="literal">sbaxter</code> is my DNS minion. I control the actual editing of zone files with group permissions, but there are many legitimate occasions for him to stop, restart, or otherwise slap around the name server program. I want him to use the system script <span class="emphasis"><em>/etc/rc.d/named</em></span> for this task, and this <span class="emphasis"><em>sudoers</em></span> entry gives him permission to use the script on all machines.</p><a id="I_programlisting7_id444247"/><pre class="programlisting">sbaxter    ALL=/etc/rc.d/named</pre><p>If I share this file across several machines, it’s likely that many of those machines don’t even run a name server. To restrict my minion’s access to only the DNS server, I’ll change the host field.</p><a id="I_programlisting7_id444257"/><pre class="programlisting">sbaxter    dns1=/etc/rc.d/named</pre><p>Then again, <code class="literal">sbaxter</code> is the administrator of the email server <code class="literal">mail1</code>. This server is his responsibility, so he needs to run any command. I can set entirely different privileges for him on the mail server and still use the same <span class="emphasis"><em>sudoers</em></span> file on all the systems.</p><a id="I_programlisting7_id444277"/><pre class="programlisting">sbaxter    dns1=/etc/rc.d/named
sbaxter    mail1=ALL</pre><p>Yes, <code class="literal">sbaxter</code> can use <code class="literal">visudo</code> on <code class="literal">mail1</code>, but he already has full privileges on that machine. I’m comfortable with this, as he knows I’ll hold him responsible for any downtime.</p><div class="sect3" title="Multiple Entries in a sudoers Field"><div class="titlepage"><div><div><h4 class="title" id="multiple_entries_in_a_sudoers_field">Multiple Entries in a sudoers Field</h4></div></div></div><p>Separate multiple entries in a single field with commas. For example, after a while, I get tired of <code class="literal">sbaxter</code> asking me to mount NFS shares on the DNS server, so I add <code class="literal">mount_nfs</code> to his privileges.</p><a id="I_programlisting7_id444318"/><pre class="programlisting">sbaxter    dns1=/etc/rc.d/named,/sbin/mount_nfs</pre><p>He can now mount his own blasted NFS shares and leave me alone.</p></div><div class="sect3" title="Running Commands As Non-root Users"><div class="titlepage"><div><div><h4 class="title" id="running_commands_as_non-root_users">Running Commands As Non-root Users</h4></div></div></div><p><a class="indexterm" id="idx0004"/><a class="indexterm" id="idx0040"/><a class="indexterm" id="idx0102"/><a class="indexterm" id="idx0760"/><a class="indexterm" id="idx0762"/>Specify a username in parentheses before a command to say that the user can use <code class="literal">sudo</code> to run commands as a particular user. For example, my user <code class="literal">dwsmith</code> is a database administrator and needs to run any command as the user <code class="literal">_postgresql</code> on the database server <code class="literal">db1</code>.</p><a id="I_programlisting7_id444401"/><pre class="programlisting">dwsmith    db1 = (_postgresql) ALL</pre><p>The <code class="literal">_postgresql</code> user can’t successfully run critical system programs like <code class="literal">fdisk</code> and <code class="literal">newfs</code>, but it can restart the database, back it up, and perform other database-administration tasks. By choosing a specific user, a specific machine, and a specific command, you can define arbitrarily complex <span class="emphasis"><em>sudoers</em></span> policies.</p></div><div class="sect3" title="Long Lines"><div class="titlepage"><div><div><h4 class="title" id="long_lines">Long Lines</h4></div></div></div><p>If you have several commands, usernames, or hosts on a line, that line might become uncomfortably long. Use a backslash (<code class="literal">\</code>) to indicate that a rule continues on the next line.</p><a id="I_programlisting7_id444444"/><pre class="programlisting">sbaxter    dns1=/etc/rc.d/named,/sbin/mount_nfs, \
        /sbin/reboot, /sbin/dump</pre><p>Use as many lines as you like to make your <span class="emphasis"><em>sudoers</em></span> file easier to manage.</p></div></div><div class="sect2" title="/etc/sudoers Aliases"><div class="titlepage"><div><div><h3 class="title" id="etc_sudoers_aliases">/etc/sudoers Aliases</h3></div></div></div><p>Take several machines with different roles, add multiple sysadmins with differing privilege levels, and your <span class="emphasis"><em>/etc/sudoers</em></span> file will quickly become complicated. When you have a few users with identical privileges and long lists of commands that you would like them to access, maintaining consistency in each user’s privilege list becomes tedious. <span class="emphasis"><em>Aliases</em></span> simplify these tasks and make <span class="emphasis"><em>/etc/sudoers</em></span> much more comprehensible, which makes your life easier.</p><p>An alias is a group of users, hosts, or commands. You can use aliases anywhere you would normally use users, hosts, or commands. You might, for example, create an alias called <code class="literal">DATABASE_COMMANDS</code> that contains all of the commands your database administrators need to run using <code class="literal">sudo</code>.</p><p>Let’s take database administrator <code class="literal">dwsmith</code> and use an alias to specify his commands.</p><a id="I_programlisting7_id444504"/><pre class="programlisting">dwsmith    db1 = (_postgresql) DATABASE_COMMANDS</pre><p>This alias might not seem to save us much, but suppose we have several database administrators. We could create an alias called <code class="literal">DBAs</code> that includes all of them.</p><a id="I_programlisting7_id444516"/><pre class="programlisting">DBAs    db1 = (_postgresql) DATABASE_COMMANDS</pre><p>Suddenly, this one line represents multiple rules. All of the database admins have identical <code class="literal">sudo</code> privileges, and when you discover that you need to give them access to an additional command, add the command to the alias, and it immediately becomes available to every database admin. There’s no tedious and error-prone copying of entries between users.</p><p><a class="indexterm" id="idx0011"/><a class="indexterm" id="idx0930"/><a class="indexterm" id="idx1747"/><a class="indexterm" id="idx2008"/><a class="indexterm" id="idx2320"/><a class="indexterm" id="idx2529"/><a class="indexterm" id="idx2651"/>You must define an alias before you can use it, so aliases normally appear at the top of the file. Each alias is made up of a label identifying its type, a name, and a list of its items. Alias types include user aliases, run as aliases, host aliases, and command aliases.</p><div class="sect3" title="User Aliases"><div class="titlepage"><div><div><h4 class="title" id="user_aliases">User Aliases</h4></div></div></div><p>A <span class="emphasis"><em>user alias</em></span> is a group of users, and it is labeled with the string <code class="literal">User_Alias</code>. Put only usernames in this alias.</p><a id="I_programlisting7_id444617"/><pre class="programlisting">User_Alias    DBAs = dwsmith, kkrusch</pre><p>Here, the user alias <code class="literal">DBAs</code> contains the users <code class="literal">dwsmith</code> and <code class="literal">kkrusch</code>. By using the alias in my <span class="emphasis"><em>sudoers</em></span> rules instead of the usernames, I ensure that these users receive exactly the same <code class="literal">sudo</code> privileges.</p><p>You can use system groups in user aliases by prefacing them with a percent sign (<code class="literal">%</code>). I might create a group in <span class="emphasis"><em>/etc/groups</em></span> called <code class="literal">databaseteam</code>, and make <code class="literal">dwsmith</code> and <code class="literal">kkrusch</code> part of that team.</p><a id="I_programlisting7_id444666"/><pre class="programlisting">%databaseteam db1 = (_postgresql) DATABASE_COMMANDS</pre><p>Perhaps the most common usage of this is giving the <code class="literal">wheel</code> group unlimited <code class="literal">sudo</code> access.</p><a id="I_programlisting7_id444681"/><pre class="programlisting">%wheel ALL = ALL</pre><p>This rule permits the <code class="literal">wheel</code> group to run any command as root through <code class="literal">sudo</code>. It doesn’t change the group members’ privileges, but gives them access via <code class="literal">sudo</code>. This is convenient for running single commands.</p></div><div class="sect3" title="Run as Aliases"><div class="titlepage"><div><div><h4 class="title" id="run_as_aliases">Run as Aliases</h4></div></div></div><p>A <span class="emphasis"><em>run as</em></span> alias is a list of users that other users can run commands as. For example, on certain application servers, the database admins need to run commands both as the database owner <code class="literal">_postgresql</code> and as the web server owner <code class="literal">www</code>. If the user must run commands as multiple users, however, you would need a separate <span class="emphasis"><em>sudoers</em></span> entry for each target user.</p><p>A run as alias lets you group these accounts:</p><a id="I_programlisting7_id444736"/><pre class="programlisting">Runas_Alias    APPOWNER = _postgresql, www</pre><p>You can now write a single rule allowing users to run commands as either <code class="literal">_postgresql</code> or <code class="literal">www</code>.</p></div><div class="sect3" title="Host Aliases"><div class="titlepage"><div><div><h4 class="title" id="host_aliases">Host Aliases</h4></div></div></div><p><a class="indexterm" id="idx0266"/><a class="indexterm" id="idx0509"/><a class="indexterm" id="idx0758"/><a class="indexterm" id="idx0979"/><a class="indexterm" id="idx2652"/>A <span class="emphasis"><em>host alias</em></span> is a list of hosts, defined as hostnames, IP addresses, or network blocks. Label host aliases with the string <code class="literal">Host_Alias</code>. Here are examples of all host alias types:</p><a id="I_programlisting7_id444806"/><pre class="programlisting">Host_Alias    DB = db1, db2, db3
Host_Alias    DMZ = 192.0.2.0/24
Host_Alias    FIREWALL = 192.0.2.1, 192.0.2.2, 192.0.2.3</pre><div class="note" title="Note"><h3 class="title"><a id="ch07note02"/>Note</h3><p>I warn elsewhere in this book about how security rules based on a hostname are vulnerable to DNS spoofing attacks. An intruder can’t spoof the machine’s local hostname, however, so you can safely use the hostname from <span class="emphasis"><em>/etc/myname</em></span> in <span class="emphasis"><em>sudoers</em></span>.</p></div></div><div class="sect3" title="Command Aliases"><div class="titlepage"><div><div><h4 class="title" id="command_aliases">Command Aliases</h4></div></div></div><p>A <span class="emphasis"><em>command alias</em></span> is a list of commands. For example, you might have a command alias that includes all of the commands needed to back up the system or restore from a backup. They’re labeled with the string <code class="literal">Cmnd_Alias</code>.</p><a id="I_programlisting7_id444853"/><pre class="programlisting">Cmnd_Alias    BACKUPS = /bin/mt, /sbin/restore, /sbin/dump</pre><p>You can tell a command alias to include everything in a particular directory by using a wildcard.</p><a id="I_programlisting7_id444862"/><pre class="programlisting">Cmnd_Alias	APPCOMMANDS = /home/appuser/bin/*</pre><p>You can also list partial command names. For example, most of PostgreSQL’s commands begin with the <code class="literal">pg_</code> prefix. To give a user access to these commands, use a wildcard like so:</p><a id="I_programlisting7_id444874"/><pre class="programlisting">Cmnd_Alias    APPCOMMANDS = /home/appuser/bin/*,/usr/local/bin/pg_*</pre><p>If you find yourself writing command aliases that include paths like <span class="emphasis"><em>/sbin/*</em></span>, stop and reconsider, because you’re essentially giving the user unlimited root access.</p></div><div class="sect3" title="Using Aliases in /etc/sudoers"><div class="titlepage"><div><div><h4 class="title" id="using_aliases_in_etc_sudoers">Using Aliases in /etc/sudoers</h4></div></div></div><p>Use an alias exactly as you would normally list the user, command, or hostname. In the previous examples, I defined the user alias <code class="literal">DBAs</code>, the run as alias <code class="literal">APPOWNER</code>, the host alias <code class="literal">DB</code>, and the command alias <code class="literal">APPCOMMANDS</code>. Here’s how they might be used:</p><a id="I_programlisting7_id444917"/><pre class="programlisting">DBAs    DB = ALL</pre><p><a class="indexterm" id="idx0042"/><a class="indexterm" id="idx1459"/>Here, the user group <code class="literal">DBAs</code> can run any command on any server in the <code class="literal">DB</code> group, as any user. The members of the group own the servers, and if they screw them up, it’s not my problem.</p><p>Well, this attitude sounds good, but the truth is that when they destroy the server, I must get involved. Even if it’s not my fault that they drove the database server into the ditch, it <span class="emphasis"><em>is</em></span> my problem. I must lock down the commands that they can run, restricting them to only the commands in the <code class="literal">APPCOMMANDS</code> alias. So, the <code class="literal">DBAs</code> group can now run any command in <code class="literal">APPCOMMANDS</code> on the <code class="literal">DB</code> servers.</p><a id="I_programlisting7_id444972"/><pre class="programlisting">DBAs    DB = APPCOMMANDS</pre><p>Then I discover that my database admins are either cleverer or dafter than I thought. They run certain database commands as root, creating log files owned by root. The unprivileged database user <code class="literal">_postgresql</code> cannot write to these log files, and so the application server crashes. Fixing this requires changing the permissions on those log files, but the database admins do not have permission to run <code class="literal">chown</code>. If I give them the ability to change the permissions on arbitrary files, I might as well just give them root access.</p><p>To keep this from happening again, I restrict their privileges so they can run their commands only as the application unprivileged users.</p><a id="I_programlisting7_id444996"/><pre class="programlisting">DBAs    DB = (APPOWNER) APPCOMMANDS</pre><p>Everyone in the <code class="literal">DBAs</code> group can run any command in <code class="literal">APPCOMMANDS</code>, as any user in <code class="literal">APPOWNER</code>, on any server in <code class="literal">DB</code>. I can change their access by adding entries to the various aliases.</p><p>Without aliases, what would this rule look like?</p><a id="I_programlisting7_id445022"/><pre class="programlisting">dwsmith,kkrusch    db1,db2,db3 = (_postgresql,www) \
     /home/appowner/bin/*,/usr/local/bin/pg_*</pre><p>That’s ugly, and it does exactly the same thing.</p><p>If you name your aliases well, you’ll find rules easier to understand. While these example aliases are fairly short, I’ve used aliases with up to 20 members. The resulting rules are appalling without aliases.</p><div class="note" title="Note"><h3 class="title"><a id="ch07note03"/>Note</h3><p>Some of the permissions granted by <code class="literal">sudo</code> in this case are unnecessary. For example, the unprivileged web server user doesn’t need to run the various PostgreSQL utilities, and if <code class="literal">www</code> did try to run the database, nothing much would happen. If you don’t like this, make two separate rules. Either way, it’s tighter security than giving database administrators the root password.</p></div></div><div class="sect3" title="Nesting Aliases"><div class="titlepage"><div><div><h4 class="title" id="nesting_aliases">Nesting Aliases</h4></div></div></div><p>You can include aliases in aliases. Here, I combine two user aliases into a single alias for my application administrators:</p><a id="I_programlisting7_id445068"/><pre class="programlisting">User_Alias    APPADMINS = DBAs, WEBMASTERS</pre></div><div class="sect3" title="Alias Naming Conventions"><div class="titlepage"><div><div><h4 class="title" id="alias_naming_conventions">Alias Naming Conventions</h4></div></div></div><p><a class="indexterm" id="idx0007"/><a class="indexterm" id="idx0041"/><a class="indexterm" id="idx0398"/><a class="indexterm" id="idx0794"/><a class="indexterm" id="idx1428"/><a class="indexterm" id="idx1453"/><a class="indexterm" id="idx2265"/>It’s traditional, but not mandatory, to give aliases names in all capital letters to help differentiate them from users, hosts, and so on. And though it’s valid syntax, it’s best to avoid naming aliases after users or hosts. Here’s an example:</p><a id="I_programlisting7_id445155"/><pre class="programlisting">User_Alias    MWLUCAS    = mwlucas,pkdick,sbaxter,dwsmith</pre><p>This would quickly drive me batty.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id365199" id="id365199">16</a>]</sup></p><p>You can also reuse alias names if they are for different types of aliases. For example, the following is perfectly legal, but perfectly offensive.</p><a id="I_programlisting7_id445172"/><pre class="programlisting">User_Alias    DB = dwsmith,kkrusch
Runas_Alias    DB = _postgresql,www
Host_Alias    DB = db1, db2, db3
Cmnd_Alias    DB = /usr/local/bin/pg_*, /home/appowner/bin/*
DB    DB = (DB) DB</pre><p>If you do this, anyone who must debug your <code class="literal">sudo</code> configuration will curse your name. Even if you consider being cursed a job perk, this naming scheme makes your phone ring at inconvenient times.</p></div></div><div class="sect2" title="Changing sudo’s Default Behavior"><div class="titlepage"><div><div><h3 class="title" id="changing_sudos_default_behavior">Changing sudo’s Default Behavior</h3></div></div></div><p>You can customize <code class="literal">sudo</code>’s behavior, or its behavior for certain users, hosts, or aliases, with the <code class="literal">Defaults</code> field. For example, one feature of <code class="literal">sudo</code> is that if you enter the wrong password, it insults you.</p><a id="I_programlisting7_id445209"/><pre class="programlisting">$ <span class="strong"><strong>sudo -l</strong></span>
Password:
My pet rat can type better than you!
Password:</pre><p>I typed my password incorrectly. <code class="literal">sudo</code> insulted me and offered me a chance to enter my password again. If I enter the wrong password three times, <code class="literal">sudo</code> exits.</p><p>Insulting the user is just fine in an open source environment, but if you’re in a company, someone will complain to management. You can either go to sensitivity training or proactively disable insults by adding the following line to <span class="emphasis"><em>sudoers</em></span>:</p><a id="I_programlisting7_id445241"/><pre class="programlisting">Defaults !insults</pre><p>The <code class="literal">Defaults</code> statement indicates that the following item affects one or more <code class="literal">sudo</code> defaults. The <code class="literal">insults</code> option controls insulting the user. The exclamation point (<code class="literal">!</code>) is a negation symbol. By putting an exclamation point in front of the option, you turn off the feature. The system will no longer insult users when they demonstrate that they cannot type as well as my pet rat.</p><a id="I_programlisting7_id445266"/><pre class="programlisting">$ <span class="strong"><strong>sudo -l</strong></span>
Password:
Sorry, try again.
Password:</pre><p><a class="indexterm" id="idx1748"/><a class="indexterm" id="idx1757"/>You can override defaults globally or on a per-alias basis.</p><div class="sect3" title="Overriding Defaults per Host"><div class="titlepage"><div><div><h4 class="title" id="overriding_defaults_per_host">Overriding Defaults per Host</h4></div></div></div><p>To override the defaults on a per-host basis, use an <code class="literal">@</code> symbol after <code class="literal">Defaults</code> and give either a host or a host alias. Here, I want to insult users who can’t type their password on <code class="literal">caddis</code> or on a machine in the alias <code class="literal">APPSERVERS</code>, while leaving insults disabled for all other servers:</p><a id="I_programlisting7_id445337"/><pre class="programlisting">Defaults !insults
Defaults@caddis insults
Defaults@APPSERVERS insults</pre><p>This lets me enable or disable functions for any combination of servers.</p></div><div class="sect3" title="Overriding Defaults per User"><div class="titlepage"><div><div><h4 class="title" id="overriding_defaults_per_user">Overriding Defaults per User</h4></div></div></div><p>To change <code class="literal">sudo</code> defaults on a per-user basis, use a <code class="literal">%</code> and the user or user alias.</p><a id="I_programlisting7_id445366"/><pre class="programlisting">Defaults !insults
Defaults%lasnyder insults
Defaults%DBAs insults</pre><p>It doesn’t matter where <code class="literal">lasnyder</code> logs in—I’m going to insult him, as well as the users in the <code class="literal">DBAs</code> alias. But database administrators are used to poor treatment by their software, and to not insult them would confuse and disappoint them.</p></div><div class="sect3" title="Overriding Defaults per Command"><div class="titlepage"><div><div><h4 class="title" id="overriding_defaults_per_command">Overriding Defaults per Command</h4></div></div></div><p>You can also change how <code class="literal">sudo</code> behaves on a command-by-command basis by putting an exclamation point between <code class="literal">Defaults</code> and the command list.</p><a id="I_programlisting7_id445404"/><pre class="programlisting">Defaults !insults
Defaults!/sbin/newfs,/sbin/fsck insults
Defaults%APPCOMMANDS insults</pre><p>Anyone who tries to use <code class="literal">newfs(8)</code> or <code class="literal">fsck(8)</code> (discussed in <a class="xref" href="ch08.html" title="Chapter 8. Disks and Filesystems">Chapter 8</a>) and cannot type their password needs insulting. The application administration commands might not merit insults, but I can always claim it was an oversight.</p></div><div class="sect3" title="Overriding Defaults per Run As"><div class="titlepage"><div><div><h4 class="title" id="overriding_defaults_per_run_as">Overriding Defaults per Run As</h4></div></div></div><p><a class="indexterm" id="idx0558"/><a class="indexterm" id="idx1187"/><a class="indexterm" id="idx2009"/><a class="indexterm" id="idx2268"/>Lastly, you can change the defaults based on who the command is being run as. Use a right angle bracket (<code class="literal">&lt;</code>) to indicate changing behavior for a run as alias.</p><a id="I_programlisting7_id445487"/><pre class="programlisting">Defaults !insults
Defaults&lt;_postgresql insults
Defaults&lt;APPOWNER insults</pre><p>If a user runs a command as <code class="literal">_postgresql</code>, or as any user in the <code class="literal">APPOWNER</code> run as alias, and types his password incorrectly, he gets insulted.</p><div class="note" title="Note"><h3 class="title"><a id="ch07note04"/>Note</h3><p>In the rest of this chapter, we’ll use <code class="literal">Default</code> widely. Please assume that each section includes the text “Restrict this as necessary by user, host, command, or run as.”</p></div></div></div><div class="sect2" title="sudo and the Environment"><div class="titlepage"><div><div><h3 class="title" id="sudo_and_the_environment">sudo and the Environment</h3></div></div></div><p>Certain environment variables can cause problems. For example, <code class="literal">$HOME</code> is an obvious one—a user cannot create files in another user’s home directory. Others, such as <code class="literal">LD_LIBRARY_PATH</code>, can cause endless annoyance as well as security issues, as applications try to link against the wrong libraries. The <code class="literal">sudo</code> program can remove suspicious environment variables, completely reset the user’s environment, or be configured to preserve the original user’s environment.</p><p>The <code class="literal">env_reset</code> <span class="emphasis"><em>sudoers</em></span> option is set by default. It purges all environment variables except <code class="literal">LOGNAME</code>, <code class="literal">SHELL</code>, <code class="literal">USER</code>, <code class="literal">USERNAME</code>, and anything beginning with <code class="literal">SUDO_</code>. You can change this behavior by disabling <code class="literal">env_reset</code>, but I strongly recommend against disabling environment purging.</p><p>Instead of letting users blindly carry all the random garbage in their environment along with them, create a list of necessary and safe environment variables that they can retain. You’ll see examples in OpenBSD’s default <span class="emphasis"><em>sudoers</em></span> file using the <code class="literal">env_keep</code> option.</p><a id="I_programlisting7_id445591"/><pre class="programlisting">Defaults env_keep +="DESTDIR DISTDIR EDITOR FETCH_CMD FLAVOR FTPMODE GROUP MAKE"
Defaults env_keep +="MAKECONF MULTI_PACKAGES NOMAN OKAY_FILES OWNER PKG_CACHE"
Defaults env_keep +="PKG_DBDIR PKG_DESTDIR PKG_PATH PKG_TMPDIR PORTSDIR"
Defaults env_keep +="RELEASEDIR SHARED_ONLY SSH_AUTH_SOCK SUBPACKAGE VISUAL"
Defaults env_keep +="WRKOBJDIR"</pre><p>The OpenBSD team deems these environment variables safe to pass into a new user account. The <code class="literal">+=</code> means “add these to the existing list of items to keep.” The environment variables themselves are in quotation marks.</p><p>If you need to pass your SSH environment around your servers, you can use <code class="literal">scp(1)</code> and <code class="literal">sftp(1)</code> to move files to other servers. Read the documentation, create a list of approved environment variables, and add an entry.</p><a id="I_programlisting7_id445618"/><pre class="programlisting">Defaults env_keep += "SSH_CLIENT SSH_CONNECTION SSH_TTY SSH_AUTH_SOCK"</pre><div class="note" title="Note"><h3 class="title"><a id="ch07note05"/>Note</h3><p><a class="indexterm" id="idx1734"/><a class="indexterm" id="idx2273"/><a class="indexterm" id="idx2434"/>The ability to copy files to other servers probably should be restricted to people in a certain group. Sysadmins might need to copy files to other servers, but many other users don’t need this access.</p></div></div></div><div class="sect1" title="Using sudo"><div class="titlepage"><div><div><h2 class="title" id="using_sudo" style="clear: both">Using sudo</h2></div></div></div><p>Now that you know how to set <code class="literal">sudo</code> permissions, let’s see how to actually use it. First, let’s tell <code class="literal">sudo</code> that your account has permission to run any command. (You should have root access on your test machine, at least, so this won’t be a security issue.)</p><p>The easy way to accomplish this is to uncomment the <span class="emphasis"><em>sudoers</em></span> entry allowing <code class="literal">wheel</code> members access to all commands.</p><a id="I_programlisting7_id445702"/><pre class="programlisting">%wheel ALL=(ALL) SETENV: ALL</pre><p>As a user in <code class="literal">wheel</code>, check your <code class="literal">sudo</code> permissions.</p><a id="I_programlisting7_id445716"/><pre class="programlisting">$ <span class="strong"><strong>sudo -l</strong></span>
Password:
Matching Defaults entries for mwlucas on this host:
    env_keep+="DESTDIR DISTDIR EDITOR FETCH_CMD FLAVOR FTPMODE GROUP MAKE",
    env_keep+="MAKECONF MULTI_PACKAGES NOMAN OKAY_FILES OWNER PKG_CACHE",
    env_keep+="PKG_DBDIR PKG_DESTDIR PKG_PATH PKG_TMPDIR PORTSDIR",
    env_keep+="RELEASEDIR SHARED_ONLY SSH_AUTH_SOCK SUBPACKAGE VISUAL",
    env_keep+=WRKOBJDIR
User mwlucas may run the following commands on this host:
    (ALL) SETENV: ALL</pre><p>When <code class="literal">sudo</code> asks for a password, enter your own password, not the root password.</p><p>The <code class="literal">-l</code> flag tells <code class="literal">sudo</code> to show you which privileges and settings you have. In response, <code class="literal">sudo</code> parses <span class="emphasis"><em>/etc/sudoers</em></span> and spits out all of the settings that apply to your account on this system. Any host-specific limitations are already evaluated and do not appear.</p><div class="sect2" title="sudo Password Caching"><div class="titlepage"><div><div><h3 class="title" id="sudo_password_caching">sudo Password Caching</h3></div></div></div><p>When you enter your password correctly, <code class="literal">sudo</code> records the time, and for the next five minutes, it remembers that you’ve recently entered your password and will work without requiring you to enter it again. After five minutes, you must reauthenticate. This simplifies work when entering a series of <code class="literal">sudo</code> commands, but it times out reasonably quickly.</p><p>You can tell <code class="literal">sudo</code> to forget your cached password by running <code class="literal">sudo -k</code>. You can control the number of minutes before <code class="literal">sudo</code> asks for the password again with the <code class="literal">timestamp_timeout</code> option in <span class="emphasis"><em>sudoers</em></span>. Here, we tell <code class="literal">sudo</code> to not time out the password for 10 minutes:</p><a id="I_programlisting7_id445809"/><pre class="programlisting">Defaults timestamp_timeout 10</pre><p><a class="indexterm" id="idx0672"/><a class="indexterm" id="idx2275"/><a class="indexterm" id="idx2277"/>If you set the timeout to 0, <code class="literal">sudo</code> always asks for a password. If you set it to a negative value, <code class="literal">sudo</code> caches the password throughout this login session. You must run <code class="literal">sudo -k</code> to make <code class="literal">sudo</code> forget that you entered your password.</p></div><div class="sect2" title="Running Commands Under sudo"><div class="titlepage"><div><div><h3 class="title" id="running_commands_under_sudo">Running Commands Under sudo</h3></div></div></div><p>To run commands via <code class="literal">sudo</code>, just put the command name after the <code class="literal">sudo</code> command. For example, here’s how you would run <code class="literal">tcpdump</code> via <code class="literal">sudo</code>:</p><a id="I_programlisting7_id445885"/><pre class="programlisting">$ <span class="strong"><strong>sudo tcpdump</strong></span></pre><p>The <code class="literal">sudo</code> command should prompt for your password. Enter it correctly, and <code class="literal">tcpdump</code> should run as root.</p><p>You can also run commands that include arguments under <code class="literal">sudo</code>. For example, I use <code class="literal">tail -f</code> to view the end of a log file and show new entries as they appear. But some log files are accessible only to root, such as the authentication log and the log that contains detailed <code class="literal">sudo</code> logs. You can view these logs without becoming root by using <code class="literal">sudo</code>.</p><a id="I_programlisting7_id445926"/><pre class="programlisting">$ <span class="strong"><strong>sudo tail -f /var/log/authlog</strong></span></pre><p>You can configure <span class="emphasis"><em>sudoers</em></span> to permit any combination of commands and arguments.</p></div><div class="sect2" title="Running Commands as Other Users"><div class="titlepage"><div><div><h3 class="title" id="running_commands_as_other_users">Running Commands as Other Users</h3></div></div></div><p>Earlier, you saw how to give some users permission to run commands as users other than root. Specify the user with the <code class="literal">-u</code> flag.</p><a id="I_programlisting7_id445959"/><pre class="programlisting">$ <span class="strong"><strong>sudo -u _postgresql pg_dump</strong></span></pre><p>If you don’t have permission to run that command as that user, you’ll get an error.</p></div></div><div class="sect1" title="sudoedit"><div class="titlepage"><div><div><h2 class="title" id="sudoedit" style="clear: both">sudoedit</h2></div></div></div><p>My flunky <code class="literal">sbaxter</code> needs to edit the <span class="emphasis"><em>named</em></span> configuration file, <span class="emphasis"><em>/etc/named.conf</em></span>. Consider this <code class="literal">sudo</code> configuration:</p><a id="I_programlisting7_id446001"/><pre class="programlisting">sbaxter    dns1=/etc/rc.d/named,/sbin/mount_nfs,/usr/bin/vi /etc/named.conf</pre><p>Looks good, right?</p><p>Uh, no.</p><p>The first problem is that I’m requiring <code class="literal">sbaxter</code> to use a specific editor. Minimal competence in vi is required for system administrators, but I don’t want to force him to use a specific editor to do his day-to-day job. Also, many editors offer shell escapes. While most people are aware of escaping to a shell in vi, emacs has a shell escape as well. If my flunky can escape to a shell while running an editor as root, he gains root access. This is exactly what I want to avoid.</p><p><a class="indexterm" id="idx0539"/><a class="indexterm" id="idx2269"/><a class="indexterm" id="idx2278"/><a class="indexterm" id="idx2537"/><a class="indexterm" id="idx2622"/>The <code class="literal">sudoedit</code> feature lets users edit specific files with their preferred editor, or a default chosen by the sysadmin, without working as root.</p><a id="I_programlisting7_id446075"/><pre class="programlisting">sbaxter    dns1=/etc/rc.d/named,/sbin/mount_nfs, \
        <span class="strong"><strong>sudoedit</strong></span> /etc/named.conf, /etc/rndc.key</pre><p>The keyword <code class="literal">sudoedit</code> is followed by a list of the files that the user can edit, thereby permitting the user to change those files without root privileges.</p><p>The user edits the file by passing a filename to <code class="literal">sudoedit</code>.</p><a id="I_programlisting7_id446101"/><pre class="programlisting">$ <span class="strong"><strong>sudoedit /etc/named.conf</strong></span></pre><p>Technically, the user doesn’t edit the actual file; instead, <code class="literal">sudoedit</code> copies the file to a temporary file owned by the user, and when the user closes the editor, it copies the temporary file to the original location. The user never runs the editor as root.</p><p>The <code class="literal">sudoedit</code> keyword uses the editor given by the environment variable <code class="literal">$SUDO_EDITOR</code>, <code class="literal">$VISUAL</code>, or <code class="literal">$EDITOR</code>. Users can set that variable in their shell if they don’t like what the system offers them.</p></div><div class="sect1" title="The Biggest sudo Mistake: Exclusions"><div class="titlepage"><div><div><h2 class="title" id="the_biggest_sudo_mistake_exclusions" style="clear: both">The Biggest sudo Mistake: Exclusions</h2></div></div></div><p>Now that you know the basics of <code class="literal">sudo</code>, let’s consider a configuration that trips up even experienced system administrators. Sometimes you want to prevent users from executing specific commands but give them access to every other command. The <span class="emphasis"><em>sudoers</em></span> documentation says that you can do this using the exclamation point (<code class="literal">!</code>) as a negation character, but that’s not entirely effective. Because this is a popular method, however, I’ll discuss how it works, and then demonstrate how your users automatically get root if you use it.</p><p>Start by defining command aliases that contain the forbidden commands. One popular exclusion is <code class="literal">su</code>. Another common exclusion is user shells, because if you execute a shell as a user, you become that user.</p><a id="I_programlisting7_id446177"/><pre class="programlisting">Cmnd_Alias    SHELLS = /bin/sh,/bin/csh,/usr/local/bin/tcsh
Cmnd_Alias    SU = /usr/bin/su</pre><p>Now configure a command alias that excludes those commands.</p><a id="I_programlisting7_id446184"/><pre class="programlisting">pkdick	ALL = ALL, !SHELLS,!SU</pre><p>Looks sensible, doesn’t it? And it seems to work.</p><a id="I_programlisting7_id446193"/><pre class="programlisting">$ <span class="strong"><strong>sudo sh</strong></span>
Password:
Sorry, user pkdick is not allowed to execute '/usr/bin/su' as root.</pre><p><a class="indexterm" id="idx2270"/><a class="indexterm" id="idx2587"/>Here’s the catch: Commands are defined by full paths. You’re allowing the user to run any command except for a few specified by full path. All this user needs to do is copy the command to another location and run it.</p><a id="I_programlisting7_id446226"/><pre class="programlisting">$ <span class="strong"><strong>cp /bin/sh /tmp/sh</strong></span>
$ <span class="strong"><strong>sudo /tmp/sh</strong></span>
#</pre><p>Welcome to root!</p><p>Negating commands can be bypassed by anyone who understands even the basics of <code class="literal">sudo</code>, as you’ll find well documented in the <code class="literal">sudo</code> manual and other literature. People <span class="emphasis"><em>still</em></span> insist on using it to protect production systems. Don’t be one of those people.</p></div><div class="sect1" title="sudo Logs"><div class="titlepage"><div><div><h2 class="title" id="sudo_logs" style="clear: both">sudo Logs</h2></div></div></div><p>Every <code class="literal">sudo</code> command is logged to <span class="emphasis"><em>/var/log/secure</em></span> by <code class="literal">syslogd</code>. Each log message contains a timestamp, a username, a terminal, the directory where the command was run, the user the command was run as, and the command used.</p><a id="I_programlisting7_id446285"/><pre class="programlisting">Apr 30 14:16:50 treble sudo:  mwlucas : TTY=ttyp8 ; PWD=/home/mwlucas ; USER=root ; COMMAND=/usr/bin/su -m</pre><p>By checking the file <span class="emphasis"><em>secure</em></span>, you can track exactly who did what and when. (Send your <span class="emphasis"><em>syslog</em></span> messages to a logging server that your users cannot access to prevent those who screw up from deleting the logs of their screwup.)</p><a id="I_programlisting7_id446302"/><pre class="programlisting">May 15 09:14:55 treble sudo:  lasnyder : TTY=ttyp4 ; PWD=/etc ; USER=root ; COMMAND=/bin/rm pf.conf</pre><p>I know exactly who broke this system and when. The log entry transforms what’s about to happen from “homicide” to “justifiable manslaughter.” That alone makes <code class="literal">sudo</code> worth using properly.</p><p>This chapter has given you some tips on how to avoid screwing up your system accidentally. Now let’s look at ways to really mess up your system, by mucking with disks and filesystems.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.id411230"><p><sup>[<a class="para" href="#id411230">15</a>] </sup>I could just say that “I have never seen POSIX ACLs configured correctly,” but personal anecdotal evidence is not proof. Even the dozens of horrifying personal anecdotes I’ve gathered over decades in this business are not proof. Feel free to prove me wrong, but please, do it on <span class="emphasis"><em>your</em></span> server.</p></div><div class="footnote" epub:type="footnote" id="ftn.id365199"><p><sup>[<a class="para" href="#id365199">16</a>] </sup>Oh, all right—battier. Happy?</p></div></div></section></body></html>