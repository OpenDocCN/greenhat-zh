["```\nmodule MyModule\n    REWARD = 100\n\n    def prize\n        return \"You've won #{REWARD} credits\"\n    end\n\nend\n```", "```\ndef MyModule.lose\n    return \"Sorry, you didn't win\"\nend\n```", "```\nMyModule.lose   #=> \"Sorry, you didn't win\"\n```", "```\nputs( prize )           # Error: undefined local variable or method\nputs( MyModule.prize )  # Error: undefined method 'prize'\n```", "```\nmodule MyModule\n    GOODMOOD = \"happy\"\n    BADMOOD = \"grumpy\"\n\n    def greet\n        return \"I'm #{GOODMOOD}. How are you?\"\n    end\n\n    def MyModule.greet\n        return \"I'm #{BADMOOD}. How are you?\"\n    end\nend\n```", "```\nputs(MyModule::GOODMOOD)    #=> happy\n```", "```\ninclude MyModule\n```", "```\nputs( greet )            #=> I'm happy. How are you?\nputs( MyModule.greet )   #=> I'm grumpy. How are you?\n```", "```\nclass MyClass\n    include MyModule\n\n    def sayHi\n        puts( greet )\n    end\n\nend\n```", "```\nob = MyClass.new\nob.sayHi          #=> I'm happy. How are you?\nputs(ob.greet)    #=> I'm happy. How are you?\n```", "```\nmodule MagicThing\n    attr_accessor :power\nend\n\nmodule Treasure\n    attr_accessor :value\n    attr_accessor :owner\nend\n\nclass Weapon\n    attr_accessor :deadliness\nend\n\nclass Sword < Weapon        # descend from Weapon\n    include Treasure        # mix in Treasure\n    include MagicThing      # mix in MagicThing\n    attr_accessor :name\nend\n```", "```\ns = Sword.new\ns.name = \"Excalibur\"\ns.deadliness = \"fatal\"\ns.value = 1000\ns.owner = \"Gribbit The Dragon\"\ns.power = \"Glows when Orcs appear\"\nputs(s.name)            #=> Excalibur\nputs(s.deadliness)      #=> fatal\nputs(s.value)           #=> 1000\nputs(s.owner)           #=> Gribbit The Dragon\nputs(s.power)           #=> Glows when Orcs appear\n```", "```\nx = 1             # local to this program\n\nmodule Foo\n    x = 50        # local to module Foo\n\n                  # this can be mixed in but the variable x won't be visible\n    def no_bar\n        return x\n    end\n\n    def bar\n         @x = 1000\n         return  @x\n    end\n    puts( \"In Foo: x = #{x}\" )   # this can access the module-local x\nend\n\ninclude Foo                      # mix in the Foo module\n```", "```\nIn Foo: x = 50\n```", "```\nputs(x)           #=> 1\n```", "```\nputs( no_bar )    # Error: undefined local variable or method 'x'\n```", "```\nputs(bar)         #=> 1000\n```", "```\nmodule X\n    @instvar = \"X's @instvar\"\n\n    def self.aaa\n        puts(@instvar)\n    end\nend\n\nX.aaa #=> X's @instvar\n```", "```\nmodule X\n    @instvar = \"X's @instvar\"\n    @anotherinstvar = \"X's 2nd @instvar\"\n\n        def amethod\n             @instvar = 10       # creates @instvar in current scope\n             puts(@instvar)\n        end\nend\n\ninclude X\np( @instvar )                    #=> nil\namethod                          #=> 10\nputs( @instvar )                 #=> 10\n@instvar = \"hello world\"\nputs( @instvar )                 #=> \"hello world\"\n```", "```\nmodule X\n    @@classvar = \"X's @@classvar\"\nend\n\ninclude X\n\nputs( @@classvar )         #=> X's @classvar\n@@classvar = \"bye bye\"\nputs( @@classvar )         #=> \"bye bye\"\n```", "```\np( X.instance_variables )      #=> [:@instvar, @anotherinstvar]\np( self.instance_variables )   #=> [:@instvar]\n```", "```\nmodule Happy\n    def Happy.mood        # module method\n        return \"happy\"\n    end\n\n    def expression        # instance method\n        return \"smiling\"\n    end\nend\nmodule Sad\n    def Sad.mood          # module method\n        return \"sad\"\n    end\n\n    def expression        # instance method\n        return \"frowning\"\n    end\nend\n```", "```\nclass Person\n    include Happy\n    include Sad\n    attr_accessor :mood\n\n    def initialize\n        @mood = Happy.mood\n    end\nend\n```", "```\np1 = Person.new\nputs(p1.expression)\n```", "```\nalias  happyexpression expression\n```", "```\nmodule Happy\n    def Happy.mood\n        return \"happy\"\n    end\n\n    def expression\n        return \"smiling\"\n    end\n    alias happyexpression expression\nend\n\nmodule Sad\n    def Sad.mood\n        return \"sad\"\n    end\n\n    def expression\n        return \"frowning\"\n    end\n    alias sadexpression expression\nend\n\nclass Person\n    include Happy\n    include Sad\n    attr_accessor :mood\n    def initialize\n        @mood = Happy.mood\n    end\nend\n\np2 = Person.new\nputs(p2.mood)                 #=> happy\nputs(p2.expression)           #=> frowning\nputs(p2.happyexpression)      #=> smiling\nputs(p2.sadexpression)        #=> frowning\n```", "```\n# This is an example of how NOT to use modules!\nmodule MagicThing                           # module\n    class MagicClass                        # class inside module\n    end\nend\n\nmodule Treasure                             # module\nend\n\nmodule MetalThing\n    include MagicThing                      # mixin\n    class Attributes < MagicClass           # subclasses class from mixin\n    end\nend\n\ninclude MetalThing                          # mixin\nclass Weapon < MagicClass                   # subclass class from mixin\n    class WeaponAttributes < Attributes     # subclass\n    end\nend\n\nclass Sword < Weapon                        # subclass\n    include Treasure                        # mixin\n    include MagicThing                      # mixin\nend\n```", "```\nrequire( \"./testmod.rb\" )\n```", "```\nrequire( \"./testmod\" )  # this works too\n```", "```\n$: << \"C:/mydir\"\n```", "```\nputs( $: )\n```", "```\nrequire_relative( \"testmod.rb\" )    # Ruby 1.9 only\n```", "```\n$: << \".\"              # add current directory to array of search paths\nrequire( \"testmod.rb\" )\n```", "```\nputs(require( \"testmod.rb\" )) #=> true, false or LoadError\n```", "```\ndef sing\n    puts( \"Tra-la-la-la-la....\")\nend\n\nputs( \"module loaded\")\nsing\n```", "```\nmodule loaded\nTra-la-la-la-la....\n```", "```\nrequire_module2.rb\nrequire( \"testmod.rb\")\ninclude MyModule       #mix in MyModule declared in testmod.rb\n```", "```\nload( \"testmod.rb\", true)\n```", "```\nload( \"testmod.rb\", true)\n\nputs( MyModule.greet )   #=>Error:uninitialized constant Object::MyModule\nputs(MyModule::GOODMOOD) #=>Error:uninitialized constant Object::MyModule\ninclude MyModule         #=>Error:uninitialized constant Object::MyModule\nputs( greet )            #=>Error:undefined local variable or method 'greet'\n```", "```\nload( \"testmod.rb\", false)\n\nputs( MyModule.greet )   #=> I'm grumpy. How are you?\nputs(MyModule::GOODMOOD) #=> happy\ninclude MyModule         #=> [success]\nputs( greet )            #=> I'm happy. How are you?\n```", "```\nMyConst = 1\nif @a == nil then\n    @a = 1\nelse\n    @a += MyConst\nend\n\nputs @a\n```", "```\nrequire \"./test\"\nrequire \"./test\"\nrequire \"./test\"\n```", "```\n1\n```", "```\nload \"test.rb\"\nload \"test.rb\"\nload \"test.rb\"\n```", "```\n1\n./test.rb:1: warning: already initialized constant MyConst\n2\n./test.rb:1: warning: already initialized constant MyConst\n3\n```", "```\nmodule MyMod\nend\n\nputs( MyMod.class )            #=> Module\n```", "```\nmodule MyMod\nend\n\nmodule MyOtherMod < MyMod      # You can't do this!\nend\n```", "```\nclass X < Module               # But you can do this\nend\n```", "```\nClass\nModule            #=> is the superclass of Class\nObject            #=> is the superclass of Module\nBasicObject       #=> (in Ruby 1.9) is the superclass of Module\n```", "```\nputs( Math.sqrt(144) )  #=> 12.0\nputs( Math::PI )        #=> 3.141592653589793\n```", "```\nclass Being\n       include Comparable\n\n       BEINGS = ['hobbit','dwarf','elf','orc','giant','oliphant','dragon']\n\n       attr_accessor :name\n\n       def <=> (anOtherName)\n               BEINGS.index(@name)<=>BEINGS.index(anOtherName.name)\n       end\n\n       def initialize( aName )\n               @name = aName\n       end\n\nend\n\nelf =  Being.new('elf')\norc = Being.new('orc')\ngiant = Being.new('giant')\n\nputs( elf < orc )     #=> true\nputs( elf > giant )   #=> false\n```", "```\nmodule OuterMod\n    moduleInnerMod\n        class Class1\n        end\n    end\nend\n```", "```\nOuterMod::InnerMod::Class1\n```", "```\nScope1::Scope2::Scope3        #...etc\n```", "```\n::ACONST                      # refers to ACONST at top-level scope\n```", "```\nACONST = \"hello\"                         # This is a top-level constant\n\nmodule OuterMod\n   module InnerMod\n      ACONST=10                          # OuterMod::InnerMod::ACONST\n      class Class1\n         class Class2\n            module XYZ\n               class ABC\n                  ACONST=100             # Deeply nested ACONST\n                  def xyz\n                     puts( ::ACONST )    # <= This refers to top-level ACONST\n                  end\n               end\n            end\n         end\n      end\n   end\nend\n\nputs(OuterMod::InnerMod::ACONST)                             #=> 10\nputs(OuterMod::InnerMod::Class1::Class2::XYZ::ABC::ACONST)   #=> 100\nob = OuterMod::InnerMod::Class1::Class2::XYZ::ABC.new\nob.xyz                                                       #=> hello\n```", "```\nmodule MyModule\n    def sayHi\n        return \"hi!\"\n    end\n\n    def sayGoodbye\n        return \"Goodbye\"\n  end\n\n    module_function :sayHi\nend\n```", "```\nclass MyClass\n    include MyModule\n        def speak\n            puts(sayHi)\n            puts(sayGoodbye)\n        end\nend\n```", "```\nob = MyClass.new\nob.speak                   #=> hi!\\nGoodbye\nputs(MyModule.sayHi)       #=> hi!\n```", "```\nputs(MyModule.sayGoodbye)  #=> Error: undefined method\n```", "```\nmodule A\n    def method_a\n        puts( 'hello from a' )\n    end\nend\n\nclass MyClass\n    def mymethod\n        puts( 'hello from mymethod of class MyClass' )\n    end\nend\n\nob = MyClass.new\nob.mymethod       #=> hello from mymethod of class MyClass\nob.extend(A)\n```", "```\nob.method_a      #=> hello from a\n```", "```\nmodule B\n    def method_b\n        puts( 'hello from b' )\n    end\nend\n\nmodule C\n    def mymethod\n        puts( 'hello from mymethod of module C' )\n    end\nend\n\nob.extend(B, C)\nob.method_b       #=> hello from b\nob.mymethod       #=> hello from mymethod of module C\n```", "```\nob.freeze\n```", "```\nmodule D\n    def method_d\n        puts( 'hello from d' )\n    end\nend\nob.extend( D ) #=> Error: can't modify frozen object (RuntimeError)\n```", "```\nif !(ob.frozen?)\n    ob.extend( D )\n    ob.method_d\nelse\n    puts( \"Can't extend a frozen object\" )\nend\n```"]