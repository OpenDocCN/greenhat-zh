<html><head></head><body><div class="part" title="Part&#xA0;II.&#xA0;Safe Harbor"><div class="titlepage"><div><div><h1 class="title"><a id="safe_harbor"/>Part II. Safe Harbor</h1></div></div></div><div class="partintro" title="Safe Harbor" id="id2719316"><div/><div class="epigraph"><p><span class="emphasis"><em>On the threats that lurk in between the computer and the Internet</em></span></p><div class="attribution"><span>—<span class="attribution"/></span></div></div></div></div>
<div class="chapter" title="Chapter&#xA0;5.&#xA0;Blinkenlights"><div class="titlepage"><div><div><h1 class="title"><a id="blinkenlights"/>Chapter 5. Blinkenlights</h1></div></div></div><div class="epigraph"><p><span class="emphasis"><em>Where we conclude that pretty can also be deadly, and we learn to read from LEDs</em></span></p><div class="attribution"><span>—<span class="attribution"/></span></div></div><p>The first part of this book focused on various problems related to the design of the data entry point system. Those problems were limited to deducing input by observing seemingly unrelated behavioral patterns by a user with local access to a system. But as information moves farther down its path to the addressee and leaves this system, its exposure broadens, and problems become more tangible.</p><p>The second part of this book focuses on some of the problems that occur while the data remains within reach, but just after it leaves the originating system-—moments before it enters the Internet. The exposure discussed here is limited to roughly the physical footprint of a local area network with its direct surroundings. An attack at this level requires an observation point that is local to the origin, but it does not require system-level access.</p><p>The specific problem discussed in this chapter is somewhat different from those discussed previously: the exposure now manifests at the hardware level, much like in TEMPEST, but is different. The beauty of this phenomenon, and the ease of observing it with no specialized equipment, more than justify giving it a closer look.</p><div class="sect1" title="The Art of Transmitting Data"><div class="titlepage"><div><div><h1 class="title"><a id="the_art_of_transmitting_data"/>The Art of Transmitting Data</h1></div></div></div><p>The need for computers to communicate with other electronic devices has been apparent since the beginning of practical computing, as has the difficulty of achieving this task reliably and on a budget. We can control the machine’s internal communication by providing generous and custom-fit interfaces among all major components with a desired capacity, maintaining precise signal characteristics, and using a common reference clock for all operations, so that the recipient always knows when to listen, and the sender always knows when to transmit data. But communication over longer distances or to devices equipped with nonspecialized, cheap interfaces is a different challenge: the computer is forced to communicate over a medium that usually does not allow for the degree of freedom we have grown accustomed to working with on the insides of a single machine.<a id="IDX-CHP-5-0217" class="indexterm"/><a id="IDX-CHP-5-0218" class="indexterm"/><a id="IDX-CHP-5-0219" class="indexterm"/><a id="IDX-CHP-5-0220" class="indexterm"/><a id="IDX-CHP-5-0221" class="indexterm"/><a id="IDX-CHP-5-0222" class="indexterm"/><a id="IDX-CHP-5-0223" class="indexterm"/></p><p>In fact, the situation is quite the opposite. The customer expects simple, convenient, practical, and cheap solutions, and requiring computers to be connected through a $100, 3-inch, 100-wire cable didn’t seem like a winning solution. Simplicity is a necessity. The core of any external communication channel almost always relies on the serial transmission of subsequent bits that only when reassembled and grouped together produce numeric values, text strings, or other pieces of data native to the machine environment of the sender or recipient. In the most seemingly trivial and obvious scenario, when two machines or devices connected only by a pair of wires need to exchange information, they do so by setting one of the wires to high or low voltage in relation to the other (reference) line—or by using any other differing signals or states, for that matter. They do so in order to send subsequent bits of data at a given frequency—a frequency that must be kept reasonably close and in sync on both devices.</p><p>Even in such a trivial design, a number of problems immediately arise. First, the devices do not share a reference clock. Although both have internal quartz-based clocks, no two affordable clocks are ever accurate enough to maintain reliable and fast communications over an extended period of time due to slight manufacturing imperfections, interference, and other physical conditions. And serial communications demand precise synchronization. The straightforward bit-encoding scheme, usually referred to as Non-Return to Zero (NRZ), simply outputs one signal (voltage) for 0 and another signal for 1. In such a system, it is easy to keep both endpoints synchronized when values change on a regular basis—the system simply needs to detect a falling or rising edge, use it as a rough reference, and adjust its own clock accordingly. But given a longer sequence of 1s or 0s, it becomes difficult for the receiving side to accurately determine how many bits are being sent. In fact, even a small clock drift can cause problems, and there is no way to compensate for this during the exchange of a constant sequence of bits.</p><p>The obvious solution, to simply interleave the data with a separate, distinguishable timing signal, is not always the most convenient and efficient method; increased complexity and reduced throughput is often perceived as a nuisance.</p><p>To effectively address this problem, many systems use a scheme called <span class="emphasis"><em>Manchester encoding</em></span>, also known as <span class="emphasis"><em>biphase code</em></span>. The algorithm for Manchester coding, shown along with NRZ in <a class="xref" href="ch05.html#serial_line_transmission_encodingsmnrz_a" title="Figure 5-1. Serial line transmission encodings—NRZ and biphase (Manchester)">Figure 5-1</a>, encodes data using signal edges, as opposed to signal levels. The original, aforementioned NRZ encoding uses an internal clock to measure voltage levels at a constant pace, interpreting low voltage as binary 0 and high voltage as 1. Manchester encoding, on the other hand, carries data in transitions from low to high voltage or vice versa. In such a design, the signal is switched to high to denote binary 1 and to low to indicate 0.<sup>[<a id="CHP-5-FN-1" href="#ftn.CHP-5-FN-1" class="footnote">11</a>]</sup><a id="IDX-CHP-5-0225" class="indexterm"/><a id="IDX-CHP-5-0224" class="indexterm"/></p><p>Although such encoding does not require the clocks to be kept synchronized, it is also not quite enough as it is: there is no way to encode two binary 0s or 1s, because it is not possible to go from low to high voltage twice without returning to low halfway down the road (and vice versa). To allow this type of information to be encoded, transitions that occur shortly after a falling or rising signal edge are ignored, thus allowing the system to encode multiple occurrences of 0 and 1 by returning to the same voltage midcycle. To manage the “blackout” period after a transition, a simple one-shot interval clock is necessary.</p><div class="figure"><a id="serial_line_transmission_encodingsmnrz_a"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3335"/><img src="httpatomoreillycomsourcenostarchimages1138020.png.jpg" alt="Serial line transmission encodings—NRZ and biphase (Manchester)"/></div></div><p class="title">Figure 5-1. Serial line transmission encodings—NRZ and biphase (Manchester)</p></div><p>The design of a serial line based on the self-synchronizing scheme discussed above is often extended to provide full-duplex communications in which both parties can talk at once, either by using two separate lines (transmit and receive, Tx and Rx for short) or by using advanced echo detection and cancellation tricks to differentiate between its own signal and the data sent from the other side. Some mediums require or allow for more sophisticated signaling schemes, for example sending more than just one bit in every cycle; yet the principle of communications remains essentially the same, and Manchester encoding over the lowest possible number of wires—often two—is prevalent across the entire domain.</p><p>Equipped with a knowledge of the basics of “wire pair” serial communications, let’s take a peak at two prominent examples of serial communications in the world of networking, see how they exchange data internally, and look at how this information can leak to third parties without the user noticing.</p><div class="sect2" title="From Your Email to Loud Noises . . . Back and Forth"><div class="titlepage"><div><div><h2 class="title"><a id="from_your_email_to_loud_noises_._._._bac"/>From Your Email to Loud Noises . . . Back and Forth</h2></div></div></div><p>The most popular long-distance computer communications device is, hands down, a modem. Initially introduced in the 1950s for the maintenance and control of certain types of military equipment at remote locations, the modem brought the Internet to the masses. Although today often considered some-what obsolete, the modem has given birth to many advanced technologies, such as affordable high-speed DSL (Digital Subscriber Line) systems or cable modems. These devices all use clever variations of the same set of techniques to communicate over phone lines or other nondedicated analog media using either audible or inaudible signals. The research invested in improving modems also contributed to our understanding of numerous large-scale design problems in electronics in general and computer and network design in particular. Thus, an understanding of how modems work is key to exploring other, perhaps more up-to-date, methods of long-distance data transmission.<a id="IDX-CHP-5-0226" class="indexterm"/><a id="IDX-CHP-5-0227" class="indexterm"/><a id="IDX-CHP-5-0228" class="indexterm"/><a id="IDX-CHP-5-0229" class="indexterm"/><a id="IDX-CHP-5-0230" class="indexterm"/><a id="IDX-CHP-5-0231" class="indexterm"/><a id="IDX-CHP-5-0232" class="indexterm"/><a id="IDX-CHP-5-0233" class="indexterm"/><a id="IDX-CHP-5-0234" class="indexterm"/><a id="IDX-CHP-5-0235" class="indexterm"/><a id="IDX-CHP-5-0236" class="indexterm"/><a id="IDX-CHP-5-0237" class="indexterm"/><a id="IDX-CHP-5-0238" class="indexterm"/></p><p>The universality of the telephone line makes it a natural medium for computers to use for communication. Phone lines can be found almost anywhere, and phone systems provide excellent call-routing capabilities, making it possible to reach just about any location with little if any effort. There is a tiny caveat, though: phone lines were meant to carry the human voice, transmitted as a waveform, within narrow-frequency response range (usually not exceeding several kHz). Because these frequencies were recorded as voltage changes over a pair of wires and relayed through a number of analog repeaters and amplifiers, the standard of quality for the transmission wasn’t particularly high. It had to be just good enough for people to hear and understand each other, and because the human brain is a superb signal filtering and processing system, occasional noise or sound-level fluctuations were not much of a concern—not until much later on, when customers grew a bit picky.</p><p>Computers, on the other hand, are generally engineered to exchange binary information, which is encoded using fairly precise voltage levels over well-designed, short lines with good signal characteristics and low capacitance—an exact opposite of long-distance, poorly shielded telephone lines with inadequate signal characteristics. Computers also need to talk much faster and much more than humans usually do. As such, modem designers had (huge understatement here) a difficult challenge to solve: They had to determine a way to encode bits of data not only in a manner that could be efficiently transmitted to a remote system over the wire (something that Manchester encoding made a bit easier), but also as audible signals that could be accurately distinguished at the other end of the line regardless of often entirely unpredictable voltage changes and other transmission artifacts. They had to employ robust error-correction algorithms and variable transmission speeds to compensate for poor line quality, occasional cross talk, trucks going over a buried phone line, birds building a nest on a pole, and so forth. The designers nodded, scratched their heads, and after perhaps just 40 years brought us an affordable and fairly fast method for computer-to-computer communication. Let’s take an abbreviated look at how this developed and how the technology matured—yet essentially stayed the same—over the decades that followed.<a id="IDX-CHP-5-0239" class="indexterm"/></p><p>The history of commercial modem development and standardization began in the 1960s when two standards, Bell 103/113 and V.21, were conceived. Both standards provided an amazing (for the time) 300-baud (bits per second) full-duplex connectivity using a technique called <span class="emphasis"><em>frequency shift keying</em></span> (FSK). FSK is a mysterious-sounding term that happens to stand for a rather trivial signal-encoding scheme: it uses two different tones to denote different values, one frequency for “low,” and another frequency for “high.” The advantage of using audible frequencies over other types of signaling is rather significant: this is the only type of signal that can be relayed through the phone system fairly well—after all, this is what the system was designed for. All other signals are more or less destined to be trashed beyond recognition before reaching the other end of the wire, in the best-case scenario, or being immediately filtered out by bandpass filters somewhere down the line in the worst case.</p><p>In addition to FSK encoding, the aforementioned Bell 103/113 and V.21 standards split the frequency range that could be transmitted over phone lines in two: one of the modems, the caller, used a frequency of 980 Hz to encode low and 1,180 Hz to encode high. The other end, the answerer, used the higher part of the spectrum: 1,650 Hz and 1,850 Hz, respectively. Why split the frequency in this way? Because a phone line is essentially just a pair of wires, which can be used for transmission by two devices simultaneously (full duplex), but only if they are capable of dealing with the fact that their respective transmissions would superimpose on each other. In full-duplex communication, each device must be able to distinguish its own signal from the data it’s receiving and filter it out. If it cannot do so successfully, each device would have to pause while the other end is talking (simplex mode), severely impairing the already sort of unimpressive throughput. By splitting the frequency, the phone line is essentially made to carry what it sees as two different “voices,” thus ensuring that simultaneous communication can occur with no collisions.</p><p>It took 25 more years for modems to take another step in the right direction. The next major set of standards, Bell 212A and V.22, took a big leap forward and dropped frequency shift keying in favor of <span class="emphasis"><em>differential phase shift keying</em></span> (DPSK). Rather than change the frequency of a wave, DPSK shifts its phase to signal different values.<a id="IDX-CHP-5-0240" class="indexterm"/></p><p>The phase shift technique essentially introduces a minimal time shift, or delay, that causes the output audio signal to be slightly out of sync with the original reference wave, while maintaining exactly the same shape (see <a class="xref" href="ch05.html#frequency_shift_versus_phase_shift" title="Figure 5-2. Frequency shift versus phase shift">Figure 5-2</a>).</p><div class="figure"><a id="frequency_shift_versus_phase_shift"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3420"/><img src="httpatomoreillycomsourcenostarchimages1138022.png.jpg" alt="Frequency shift versus phase shift"/></div></div><p class="title">Figure 5-2. Frequency shift versus phase shift</p></div><p>The value of the phase shift, also called the <span class="emphasis"><em>shift value</em></span>, is expressed in degrees (a reference to its effect on trigonometric functions: y = sin(x) shifted by 90° is exactly the same as y = sin(90° + x). A shift value of 360° denotes a shift by the entire wavelength, which simply puts the waves right back in sync and has no effect on the waveform. The correspondence of various phase shifts is shown in <a class="xref" href="ch05.html#phase_shifted_signals_open_parenthesis_l" title="Figure 5-3. Phase shifted signals (left) and a result of subtracting a reference waveform to more easily distinguish between phases (right)">Figure 5-3</a>, on the left.</p><p>Once both parties are synchronized and have a way to compare the signal received over the cable with the expected waveform, the actual encoded data can be easily retrieved. A differential circuit can compare two signals, subtract them, and easily determine the exact phase shift of the signal, by comparing it to a reference signal, as shown in <a class="xref" href="ch05.html#phase_shifted_signals_open_parenthesis_l" title="Figure 5-3. Phase shifted signals (left) and a result of subtracting a reference waveform to more easily distinguish between phases (right)">Figure 5-3</a>, on the right.</p><p>The new standard also took advantage of a more advanced data-encoding method. Instead of simply using two alternating signals to transmit 0s and 1s, as was the case previously, V.22 encodes whole <span class="emphasis"><em>dibits</em></span>—slang for pairs of bits. Encoding two bits at once can be achieved using four phase shift values, with the amount of shift used to denote each of the possible values chosen so that values are uniformly and possibly farthest spaced through the entire 360° spectrum—and thus easily distinguishable from each other (see <a class="xref" href="ch05.html#using_phase_shifts_to_encode_two_bits_of" title="Table 5-1. Using phase shifts to encode two bits of data (dibit)">Table 5-1</a>).<a id="IDX-CHP-5-0241" class="indexterm"/></p><div class="figure"><a id="phase_shifted_signals_open_parenthesis_l"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3450"/><img src="httpatomoreillycomsourcenostarchimages1138024.png.jpg" alt="Phase shifted signals (left) and a result of subtracting a reference waveform to more easily distinguish between phases (right)"/></div></div><p class="title">Figure 5-3. Phase shifted signals (left) and a result of subtracting a reference waveform to more easily distinguish between phases (right)</p></div><p>The use of dibits allowed for significantly faster transfer speed (1,200 baud) without the need to increase the physical rate with which the actual signal was modulated. Twice as much information—twice as many bits—was carried within every single beep.</p><div class="table"><a id="using_phase_shifts_to_encode_two_bits_of"/><p class="title">Table 5-1. Using phase shifts to encode two bits of data (dibit)</p><div class="table-contents"><table summary="Using phase shifts to encode two bits of data (dibit)" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Dibit</p></th><th style="text-align: left" valign="bottom"><p>Phase Shift</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">00</code></p></td><td style="text-align: left" valign="top"><p>90°</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">01</code></p></td><td style="text-align: left" valign="top"><p>0°</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">10</code></p></td><td style="text-align: left" valign="top"><p>180°</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">11</code></p></td><td style="text-align: left" valign="top"><p>270°</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Although it is theoretically possible to use such an extended alphabet—that is, composite signal units similar to dibits (that have more than two states and thus encode more than one bit at once)—with FSK encoding as well, it is a bit more problematic to do so. FSK signals must avoid subharmonics and other frequencies that are particularly prone to distortion when sent through phone systems, thus severely limiting the set of possible states. The advantage of DPSK over FSK is that it uses a fixed frequency that is known to cause the fewest transmission problems and, hence, can be used more reliably at higher transmission rates.</p></div><p>In the next few years, the pace of research accelerated a bit, and a number of new standards surfaced. The V.22bis standard took the concept of wide alphabet signaling a bit further, combining DPSK with signal amplitude (loudness) modulation to build a two-dimensional set of 16 possible values. The transition from a measured signal to binary values was expressed using a two-dimensional table. The value to which a signal corresponds is obtained by first looking up the column, based on the measured phase-shift value, and then the row is looked up based on the amplitude measurement. A simplified but analogous two-by-four example is shown in <a class="xref" href="ch05.html#two-dimensional_encoding_of_three_bits" title="Table 5-2. Two-dimensional encoding of three bits using two distinct signal parameters">Table 5-2</a>.<a id="IDX-CHP-5-0242" class="indexterm"/></p><div class="table"><a id="two-dimensional_encoding_of_three_bits"/><p class="title">Table 5-2. Two-dimensional encoding of three bits using two distinct signal parameters</p><div class="table-contents"><table summary="Two-dimensional encoding of three bits using two distinct signal parameters" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </th><th style="text-align: left" valign="bottom"><p>Phase 0°</p></th><th style="text-align: left" valign="bottom"><p>Phase 90°</p></th><th style="text-align: left" valign="bottom"><p>Phase 180°</p></th><th style="text-align: left" valign="bottom"><p>Phase 270°</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Low amplitude</strong></span></p></td><td style="text-align: left" valign="top"><p>000 (0)</p></td><td style="text-align: left" valign="top"><p>001 (1)</p></td><td style="text-align: left" valign="top"><p>010 (2)</p></td><td style="text-align: left" valign="top"><p>011 (3)</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>High amplitude</strong></span></p></td><td style="text-align: left" valign="top"><p>100 (4)</p></td><td style="text-align: left" valign="top"><p>101 (5)</p></td><td style="text-align: left" valign="top"><p>110 (6)</p></td><td style="text-align: left" valign="top"><p>111 (7)</p></td></tr></tbody></table></div></div><p>To add to the confusion, this new approach was called <span class="emphasis"><em>quadrature amplitude modulation</em></span> (QAM). QAM once again made it possible to go from 1,200 to 2,400 bps without actually improving signal modulation speed, but by extending the number of meanings a single atom of signal can have.</p><p>The next major evolutionary step was V.32. V.32 was the first design to introduce a novel concept: instead of splitting frequencies, it used advanced echo cancellation circuitry<sup>[<a id="CHP-5-FN-2" href="#ftn.CHP-5-FN-2" class="footnote">12</a>]</sup> to detect and subtract the signal transmitted by the device itself from the data received over the wire. This technique allowed both devices (sender and receiver) to use the entire frequency spectrum, instead of just half of it, while still doing full-duplex.</p><p>Development continued, and the V.34 protocol soon appeared. Although the rate at which the signal could safely alternate before introducing excessive distortion did not noticeably change over the years, the standard was considerably faster than its predecessors. V.34 achieves a throughput of 28,800 baud, sometimes pushed a bit further by manufacturers to a unofficial speed of 33,600 baud (33.6 Kbps) by sending only about 2,500 to 3,500 signal samples (alphabet symbols) per second; however, it combines four different encoding schemes to build a four-dimensional structure with 1,664 possible states, making it possible to send as many as 41 bits at once. As it turns out, it’s not about raw speed but how you use what you’ve got.</p><p>It is widely believed that the V.34 standard and its derivatives approach the theoretical limit for transmission of data via the voice-oriented telephone system. Although this may seem an odd statement given the prevalence of 56 Kbps modems, there is a catch: 56 Kbps devices achieve this transmission rate in a wholly different way than in analog solutions. Given that most phone systems have migrated from analog to digital since modems were first developed, and because most dial-up providers can now interface their systems directly with digital telecommunication systems, service providers can return to the most obvious but, until recently, impossible solution: changing line voltages instead of shifting frequencies when sending data to a subscriber. Because the signal is carried as digital data from the beginning—and can travel over buried copper lines only till the nearest telco facility—there are virtually no signal quality problems, and the only limit is the voice-carrying capacity designed into the phone system hardware. Working at 8,000 symbols per second, but operating with a considerably smaller alphabet (usually about 128 symbols, or voltage levels), it is possible to send data to a subscriber who is connected to a digital phone system with high-quality wire using a 56 Kbps modem at a higher speed than usual. The upstream transfer is still implemented the old-fashioned way, though, and is considerably slower; as such, the modem is only partly 56 Kbps, and only when conditions permit.<a id="IDX-CHP-5-0244" class="indexterm"/></p></div><div class="sect2" title="The Day Today"><div class="titlepage"><div><div><h2 class="title"><a id="the_day_today"/>The Day Today</h2></div></div></div><p>Not much has changed since the conception of modem technology. As transmission protocols advanced, so did the error-correction and fallback mechanisms needed to ensure reliable transmission when your favorite quadruped decides to chew the phone cable. A jungle of standards were spawned: V.42 provided a basic CRC (cyclic redundancy check) implementation, MNP-1 to MNP-4 provided proprietary error-correction algorithms, V.42bis and MNP-5 provided integrity checking combined with compression, and so on. But the real revolution is yet to come.<a id="IDX-CHP-5-0246" class="indexterm"/><a id="IDX-CHP-5-0245" class="indexterm"/></p><p>Or is it? You might argue that DSL and cable modems are a revolutionary technology that has changed the world. I am willing to argue: in fact, they are quite similar to their older cousins, modems. The only significant difference between the two is that the other endpoint—the server that handles all connections—has moved from a distant city where the service provider is located to the nearest local telco facility, and the connection to it can be made directly using the copper wire coming from the customer’s residence or business. Because that direct connection again does not go through any other equipment, these devices can use high, inaudible frequencies and subtler signals that would otherwise be distorted or not relayed at all over the telephone network. In contrast, the good old modem was strictly limited to a narrow range of audible frequencies and signals that the phone system was intended to carry and that it could carry well. In many ways, DSL devices have it much easier than the old modem.<a id="IDX-CHP-5-0247" class="indexterm"/><a id="IDX-CHP-5-0248" class="indexterm"/><a id="IDX-CHP-5-0249" class="indexterm"/></p><p>As we see, designing a modem is actually quite a complex and difficult task; that’s why it took us decades to advance from bulky and expensive 300-baud devices to where we are now.<sup>[<a href="apb.html#ftn.CHP-5-BIB-1" class="footnoteref">60</a>]</sup> Surprisingly, all these devices can talk to one another, even to devices ten years older, even at the lowest speeds we long forgot about. Too, all are usually aware of the standards known to date, including the dozens of alternatives and forks of each. Doesn’t that make modems even more a marvel of computer engineering?</p><p>But who pulls the strings?</p></div><div class="sect2" title="Sometimes, a Modem Is Just a Modem"><div class="titlepage"><div><div><h2 class="title"><a id="sometimes_comma_a_modem_is_just_a_modem"/>Sometimes, a Modem Is Just a Modem</h2></div></div></div><p>Modem-to-modem communications is, of course, not where the story starts or ends. The modem is just a piece of fairly inert middleware that’s hardly even a good paperweight. For a modem to be of any use, it must be able to communicate with a computer to receive commands and exchange data, even when it’s only being used for something as feeble as random web browsing. Internal modems have it easy: ISA (Integrated Systems Architecture), PCI (Peripheral Component Interconnect), PCMCIA (PC Memory Card International Association), and some other dedicated buses provide high-speed and fairly generous parallel interfaces that make the communication process almost trivial.<a id="IDX-CHP-5-0251" class="indexterm"/><a id="IDX-CHP-5-0252" class="indexterm"/><a id="IDX-CHP-5-0250" class="indexterm"/></p><p>External modems (of the analog or DSL kind), however, have to do things the hard way, with a serial link. Most analog modems use the well-known serial protocol RS-232 (renamed in the ’90s to the much more descriptive EIA/TIA-232-E<sup>[<a href="apb.html#ftn.CHP-5-BIB-2" class="footnoteref">61</a>]</sup>); many newer ones use USB (Universal Serial Bus). As we get close to the information disclosure scenarios in those devices, we want to get a glimpse of what happens to the data on its way between the modem and the computer, too, because that plays a crucial role in the attack.<a id="IDX-CHP-5-0253" class="indexterm"/></p><p>Although external modems have to use inhumane means of communicating not only with a remote system, but also with the local machine itself, thanks to the proximity to the computer and the fact that interfaces such as RS-232 are digital and were designed for use by computers to start with, this stage is still much simpler than the phone line modulation and demodulation for which bit modems became famous.</p><p>RS-232 uses a fairly straightforward implementation of bipolar encoding for the data exchanged over two separate lines and backs this with a set of NRZ control lines. To make life a bit more interesting, RS-232 comes with a multitude of link or protocol features that make it fairly difficult to implement from scratch: its asynchronous nature, a wide array of possible settings and speeds, and unusual voltage levels. But with all this, RS-232 still does not even come close to a real challenge for an implementator who had dealt with signal modulation over phone lines.<a id="IDX-CHP-5-0254" class="indexterm"/></p><p>USB, on the other hand, attempts to standardize and unify the serial interface. Although USB requires higher-end circuitry than RS-232 in order to interface a computer with a device (because of, among other things, a higher level of abstraction and higher supported transmission speeds), the USB is universal (hence its name) and has fewer oddities and legacy features.</p><p>Last but not least, a common method of communicating with local devices is the use of Ethernet, a mechanism somewhat similar to, but predating, USB. Let us look at Ethernet for a while now, and I am sure all those communication protocols will eventually meet in one place.</p></div><div class="sect2" title="Collisions Under Control"><div class="titlepage"><div><div><h2 class="title"><a id="collisions_under_control"/>Collisions Under Control</h2></div></div></div><p>Ethernet networks are, in essence, an advanced type of a multiparty serial link.<sup>[<a href="apb.html#ftn.CHP-5-BIB-3" class="footnoteref">62</a>]</sup> An Ethernet network is composed of a number of computers connected by a shared medium—nothing particularly complex, in its most basic form, just a pair of fairly regular wires. When a device on the network uses the medium, it applies a specific voltage to the wire, and all other connected systems can interpret the data by measuring the voltages. A set of checks ensures that devices do not try to use the link at the same time and that recovery is smooth if an accident happens. Still, even considering this possibility, the basic design is unbelievably trivial, compared with modems.<a id="IDX-CHP-5-0257" class="indexterm"/><a id="IDX-CHP-5-0258" class="indexterm"/><a id="IDX-CHP-5-0255" class="indexterm"/><a id="IDX-CHP-5-0256" class="indexterm"/></p><p>To work around the problem of two parties talking at once, a standard named Carrier Sense Multiple Access with Collision Detection (CSMA/CD) is used as the core mechanism controlling all communication via Ethernet. Before sending any data, every device connected to Ethernet follows a CSMA procedure to see if another device is using the cable by checking the modem’s electrical properties. If no other transmission is occurring, the device enters the transmission phase and beams its data out to the masses.<a id="IDX-CHP-5-0259" class="indexterm"/></p><p>In this phase, the data is sent on the wire as a sequence of bits using <span class="emphasis"><em>bipolar encoding</em></span>; the traffic contains a header with all the necessary sender and recipient information and a proper checksum intended to protect the integrity of the data in case of external or internal interference, quadruped or not. A network interface that considers itself to be acting on behalf of a recipient, presumably by comparing the observed destination address provided in the packet with its unique MAC (hardware) address stored on the card, should accept this traffic and verify the checksum. At the same time, all other parties should ignore this frame; naturally, if they do not (and almost every card can be instructed not to), the user can view or react to traffic addressed to others. (You can see how Ethernet was designed in the spirit of far-fetched trust and altruism—a noble but risky approach.)</p><p>It is possible (and not very unlikely) for two devices on an Ethernet network to start sending at exactly the same moment, even though both checked just microseconds or nanoseconds ago for another party transmitting. And, if they do transmit at exactly the same moment, a disaster is bound to happen. Two transmissions are mixed up and mangled, and the sent data should fail the checksum test at the destination . . . or should it?</p><p>Although the use of a checksum implemented within the Ethernet frame specification is typically sufficient to verify data transmission accuracy, it may not be particularly effective if the link is saturated and hundreds or thousands of collisions occur in a short period of time; it is just small enough to accidentally come out correct from time to time. The law of probabilities tells us that some damaged packets will—just by chance—have the same check-sum as an original packet. Furthermore, even if we ignore the problem of checksum deficiencies, we still want to stop collisions as soon as possible—by just letting collisions run rampant, you might find that you are no longer able to ensure the timely retransmissions of mangled and dropped frames in your network. After all, the sender sent it with no indication of a problem, and the recipient did not receive anything even remotely resembling a useful packet.</p><p>The solution comes with the latter part of the standard: collision detection (CD). The specification calls for the sender to monitor the network link while explaining their business to others. If another party is caught trying to talk at the same time, that should be detected (again, with a simple measurement of the electrical properties of the line), and the transmission should be immediately aborted. The device should also send a special jam code to ensure that both frames (the one being sent and the one that interfered with it) will be unconditionally dropped, without even getting to the checksum verification; the recipient should be able to spot the jam code and stop the reception of data being processed. The device then idles for a gradually increasing and preferably (initially) random period of time after every attempt (called retransmission backoff), to minimize the likelihood of a subsequent collision.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>A fun fact: The jam code mechanism imposes an unusual requirement on the protocol. All frames must have a minimum (!) length, with the value calculated such that it allows the jam code to be generated and propagated to all machines before the transmission is completed. With very short frames, there may not be enough time to achieve this. Hence, the sender is required to artificially pad all their outgoing transmissions.</p></div><p><a class="xref" href="ch05.html#the_stages_of_a_typical_ethernet_convers" title="Figure 5-4. The stages of a typical Ethernet conversation">Figure 5-4</a> shows the exact sequence of events in a typical collision scenario. As you can see, Sender A hopes to send data to the recipient but notices another transmission occurring, at which point they decide to wait until that transmission stops. Sender A then prepares to send the data but, unfortunately, Sender B does the same, and both conclude that it is safe to send data at nearly the same time.</p><p>Both attempt to transmit, data gets mangled, and at that point both detect the other transmission and quickly send a jam code to instruct the recipient to disregard this frame. Finally, both senders back off for a random amount of time and hopefully manage not to start simultaneously the next time around.</p></div><div class="sect2" title="Behind the Scenes: Wiring Soup and How We Dealt with It"><div class="titlepage"><div><div><h2 class="title"><a id="behind_the_scenes_colon_wiring_soup_and"/>Behind the Scenes: Wiring Soup and How We Dealt with It</h2></div></div></div><p>Although not an example of a particularly scalable or elegant design, the Ethernet protocol is amazingly powerful and easy to deploy; it enabled the building of cheap peer-structure networks using coaxial cables just about anywhere. As such, it has become a de facto standard, replacing many other (and sometimes superior, but more expensive or proprietary) networking architectures.<a id="IDX-CHP-5-0261" class="indexterm"/><a id="IDX-CHP-5-0262" class="indexterm"/><a id="IDX-CHP-5-0263" class="indexterm"/><a id="IDX-CHP-5-0260" class="indexterm"/></p><div class="figure"><a id="the_stages_of_a_typical_ethernet_convers"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3732"/><img src="httpatomoreillycomsourcenostarchimages1138026.png.jpg" alt="The stages of a typical Ethernet conversation"/></div></div><p class="title">Figure 5-4. The stages of a typical Ethernet conversation</p></div><p>Naturally, simple Ethernet over coaxial cable had its limits and disadvantages; it was essentially based on a long piece of wire with devices hooked up to it at various locations, and with resistors on both ends, not something you'd want to be responsible for maintaining in a large office. A simple and difficult-to-debug mishap, such as a shorted terminal, could bring the entire infrastructure down. A more advanced—but only marginally more expensive—replacement was warmly welcomed.</p><p>Electronic multiport repeaters (hubs) made it possible to run wiring without much effort using twisted pair wiring (Cat-3 and Cat-5 cables with RJ-45 connectors). To use them, you simply plugged a piece of wire from your machine into a black box, and all other devices connected to this black box could communicate with it without much consideration of electrical problems or the risk that a single cable failure would bring down the entire network.<a id="IDX-CHP-5-0264" class="indexterm"/></p><p><span class="emphasis"><em>Hubs</em></span> are, in essence, simple repeaters that broadcast all traffic received on one port to all other ports. They make it possible to build easily reconfigurable and more reliable star-type networks, but they do little else. As the network grows, the cost of broadcasting every bit of information to all locations, and the fact that only one party can talk at once across the entire network, makes it all too evident that the simplicity of this design is its major weakness.</p><p><span class="emphasis"><em>Switches</em></span> turned out to be the solution. Switches are the next generation of hubs. Equipped with a decent processor and some memory, they’re a more expensive alternative to hubs that provide, under normal circumstances, additional high-level analysis of Ethernet frames. This analysis associates hardware addresses with specific ports and optimizes frame routing by delivering certain packets directly to the appropriate port (in unicast mode), instead of broadcasting them to all parties (see <a class="xref" href="ch05.html#hubs_versus_switches_in_local_networks" title="Figure 5-5. Hubs versus switches in local networks">Figure 5-5</a>). This greatly improves performance in more extensive networks.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Another fun fact: Real hubs are almost extinct nowadays. Almost all 10/100 Mb devices marketed as hubs actually use basic switch chipsets; it is simply cheaper to repackage the chip than to develop and maintain several variants.</p></div><div class="figure"><a id="hubs_versus_switches_in_local_networks"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3760"/><img src="httpatomoreillycomsourcenostarchimages1138028.png.jpg" alt="Hubs versus switches in local networks"/></div></div><p class="title">Figure 5-5. Hubs versus switches in local networks</p></div><p>I’m guessing that at this point you’re asking yourself, Where the heck are you going with all this? What do modems have to do with information disclosure? What significance do serial links have in this context? How do Ethernet networks fit in? And what the heck are blinkenlights?<a id="IDX-CHP-5-0265" class="indexterm"/></p><p>Glad you asked. I am about to get there—to the last question, that is.</p></div><div class="sect2" title="Blinkenlights in Communications"><div class="titlepage"><div><div><h2 class="title"><a id="blinkenlights_in_communications"/>Blinkenlights in Communications</h2></div></div></div><p>Historically, almost all refrigerator-sized computers were equipped with numerous prominently exposed diagnostic interfaces. These included arrays of tiny lights that displayed, among other things, certain arcane properties of the internal state of a machine, such as internal registers or flags of the core processing unit or an indication of whether the cat living underneath had been fed today. As computers became more reliable and compact, and an average user no longer had to understand the machine’s internals in order to use it efficiently, the lights started to disappear from many devices. Ever-increasing clock speeds also contributed to the decline—most of the time it was no longer possible for humans to get any meaningful information from such a visual signal that would change thousands or millions of times every second.<a id="IDX-CHP-5-0267" class="indexterm"/><a id="IDX-CHP-5-0268" class="indexterm"/><a id="IDX-CHP-5-0269" class="indexterm"/><a id="IDX-CHP-5-0266" class="indexterm"/></p><p>Yet, the lights prevailed in some applications; for example, almost all networking devices feature light-emitting diodes (LEDs) on their front or back panel. These provide link diagnostics, such as an indication of whether a particular module or socket is functioning properly, a party is connected, data is being transferred, and so on. The lights are not merely a diagnostic tool either; their hypnotic patterns have strange appeal, and their mystery plants seeds of uncertainty, fear, and respect in the hearts of lay people who enter the realm of the server room.</p><p>The term <span class="emphasis"><em>blinkenlights</em></span> or <span class="emphasis"><em>blinkenlichten</em></span> has been used to describe the much-adored institution of diagnostic LEDs on computer equipment ever since the dark ages of computing, bathing the computer geek in the soothing green light during those long, lonely nights spent at the terminal. It came from an amusing prank note in mock German (itself a spoof of another, noncomputer joke from WWII), displayed some time in the 1950s at IBM laboratories. The note later propagated into a majority of server rooms and computer science laboratories across the world and went like this (as quoted from Eric S. Raymond’s <span class="emphasis"><em>Hacker’s Dictionary</em></span>):</p><div class="informalfigure"><a id="image_no_caption"/><div class="mediaobject"><a id="I_mediaobject1_d1e3803"/><img src="httpatomoreillycomsourcenostarchimages1138030.png" alt="image with no caption"/></div></div><p>Communications equipment is one of the last domains in which blinken-lights prevail and prosper. But that’s not all. Almost all these devices use serial lines for communications. And, for the sake of simplicity and aesthetics, “activity” LEDs are sometimes wired almost directly, through a simple driver circuit, to the transmit or receive line of the device. Curtain falls.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-1" href="#CHP-5-FN-1" class="para">11</a>] </sup>Or the other way around, depending on the transmitter design.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-2" href="#CHP-5-FN-2" class="para">12</a>] </sup>Echo cancellation circuits attempt to distinguish signals being sent by the device itself from those coming from the other party, and to eliminate or significantly reduce the former. Various types of such devices are commonly used not only in digital data transfer, but also to improve phone call quality, eliminate microphone feedback during public events, and solve many other everyday problems.<a id="IDX-CHP-5-0243" class="indexterm"/></p></div></div></div>
<div class="sect1" title="The Implications of Aesthetics"><div class="titlepage"><div><div><h1 class="title"><a id="the_implications_of_aesthetics"/>The Implications of Aesthetics</h1></div></div></div><p>It took decades for the problem to be discovered, and once it happened (in 2002), it struck us all as so obvious and trivial we wanted to bang our heads on the keyboard a couple of times.<a id="IDX-CHP-5-0270" class="indexterm"/><a id="IDX-CHP-5-0271" class="indexterm"/><a id="IDX-CHP-5-0272" class="indexterm"/><a id="IDX-CHP-5-0273" class="indexterm"/><a id="IDX-CHP-5-0274" class="indexterm"/><a id="IDX-CHP-5-0275" class="indexterm"/></p><p>Joe Lughry and David A. Umphress, in a research paper titled “Information Leakage from Optical Emanations,”<sup>[<a href="apb.html#ftn.CHP-5-BIB-4" class="footnoteref">63</a>]</sup> discovered a new type of signal-disclosure scenario in certain types of network equipment, most often modems. They concluded that someone observing these lights could go beyond simply watching the magic lights with the naked eye.</p><p>LEDs, unlike incandescent bulbs, usually have short rise and fall times, meaning that they turn on and off almost instantly. That’s not surprising; after all, high-end LEDs are used to control fiber-optic links and some other optoelectronic communication channels. As such, the blinking of an LED hooked up to a serial data transmission line can actually often mirror single bits of the transmission as it occurs on the wire. Given a way to record this activity at a sufficient speed, it should be possible to retrieve this information, from at least as far as you can see the tiny blinking light on a device with the naked eye (or with a telephoto lens).</p><p>This research caused some stir in the industry; it was eventually also both downplayed and overhyped, and hence a great deal of confusion ensued, and very little has changed. The paper resulted in many conflicting reports, but its basic premise is simple and truly beautiful. The beauty of this technique is that it is trivial to devise such a device to receive the signal: the equally cheap and popular counterparts of LEDs—photodiodes and phototransistors—are easy to acquire and equally easy to interface with the computer. And the exposure zone, unlike most of the TEMPEST activity we discussed in <a class="xref" href="ch03.html" title="Chapter 3. Ten Heads of the Hydra">Chapter 3</a>, is not merely the subject of urban legends and pure laboratory results, but can be directly observed and measured.</p><p>In the course of their research, the authors performed a set of experiments to verify that the signal could be successfully acquired from as far away as 20 meters (just under 100 feet) without the need for additional digital signal conditioning. And common sense suggests that this might actually be an understatement, especially when good optics are used. (The authors used a 100 mm focal length, f/2.0 lens for the test, but a much better telephoto lens is commonly available to many midrange SLR (single lens reflex) photography amateurs. Those who are willing to part with their money can buy a superb-quality lens with a focal length of as much as 1,200 mm.)</p><p>The paper takes a defensive stance in several cases, and a careful reader might be tempted to conclude that some of the devices classified are not vulnerable to the problem. In particular, some of the Ethernet devices may exhibit a more subtle variant of the vulnerability, as you’ll see in the prevention section later in this chapter. But first let’s peek at the problem with our own (computerized) eyes, shall we?</p></div>
<div class="sect1" title="Building Your Own Spy Gear . . ."><div class="titlepage"><div><div><h1 class="title"><a id="building_your_own_spy_gear"/>Building Your Own Spy Gear . . .</h1></div></div></div><p>The simplicity of building a snooping device makes it quite tempting to do so. This section contains several suggestions and rough schematics on how to build and connect such a device to an ordinary computer. Although the circuit is not particularly complex and does not require a master’s degree in soldering and a printed board circuit design software, a minimum level of proficiency in electronics is desirable, as is a dose of common sense. Although external interfaces of today’s computers are fairly robust and foolproof, there is always the risk of damaging equipment when attaching home-brew devices in a really innovative way, in a brief moment of insanity. It’s happened to the best of us.<a id="IDX-CHP-5-0276" class="indexterm"/><a id="IDX-CHP-5-0277" class="indexterm"/><a id="IDX-CHP-5-0278" class="indexterm"/><a id="IDX-CHP-5-0279" class="indexterm"/><a id="IDX-CHP-5-0280" class="indexterm"/><a id="IDX-CHP-5-0281" class="indexterm"/><a id="IDX-CHP-5-0282" class="indexterm"/><a id="IDX-CHP-5-0283" class="indexterm"/></p><p>The baseline design is extremely trivial. It calls for a single phototransistor (a component consisting of a transistor driven by a built-in photodiode), a regular low-power NPN (Negative-Positive-Negative) transistor to amplify the signal a bit further (not always necessary), and a set of potentiometers (perhaps in the range of 10 kΩ just to have enough flexibility) to experimentally pull down the voltage and control the circuit’s sensitivity and threshold points. There are no particular requirements for the components, although your mileage will vary depending on which ones you use. Be sure to select a phototransistor that has a decent response in the visible light range, though all cheap ones should work. (For reference, a green LED emits a wavelength of approximately 520 nm.)</p><p>A sample circuit design is shown in <a class="xref" href="ch05s03.html#a_simple_receiver_circuit" title="Figure 5-6. A simple receiver circuit">Figure 5-6</a>.</p><div class="figure"><a id="a_simple_receiver_circuit"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e3903"/><img src="httpatomoreillycomsourcenostarchimages1138032.png.jpg" alt="A simple receiver circuit"/></div></div><p class="title">Figure 5-6. A simple receiver circuit</p></div><p>The circuit has an optimal running voltage of approximately 5V and a low maximum current: a power supply capable of delivering perhaps 10 to 50 mA is more than enough. A word of warning: If you use a supply capable of delivering a higher voltage, you will risk damaging the port or the computer; likewise, if you use a more powerful supply and do not prevent higher current from flowing through the circuit.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Setting Rvar1 or Rvar2 to a very low resistance may short the circuit. If you want to fiddle with the knobs mindlessly, it might be a good idea to add a fixed resistor to limit the current drain.</p></div><p>You must shield the phototransistor from external light sources—for example, by enclosing it in an opaque tube. Because the phototransistor has no focusing mechanism, it is not likely to pick up more distant signals (other than ambient light). Thus, for initial tests, it is a good idea to cover it entirely to simulate darkness and then put it by an LED to excite the circuit. You can also connect another LED temporarily between the GND and the output line to test the circuit. The test LED should light up when the sensor is directed at a light source, but otherwise be fairly dark.</p></div>
<div class="sect1" title=". . . And Using It with a Computer"><div class="titlepage"><div><div><h1 class="title"><a id="and_using_it_with_a_computer"/>. . . And Using It with a Computer</h1></div></div></div><p>If the circuit with a test LED hookup works so far, well done; you have built a fancy TV remote tester. Because generic, cheap phototransistors are eager to pick up infrared light, your creation should “translate” IR (infrared) into visible light, but that’s about all the fun stuff it will do. To make it a bit more useful, you need to interface the circuit with the computer. A good way to do so is through a line printer interface, LPT, if your computer has one. Unfortunately, this wonderful hardware hacker’s tool is being dropped from some of the more compact and fancy designs.<a id="IDX-CHP-5-0284" class="indexterm"/></p><p>Although initially designed to be unidirectional (for output only), the LPT interface provides a number of status feedback lines, such as “paper out,” “busy,” and “acknowledgment,” that were intended to provide a means for the printer to complain about problems. You can easily read the data that issues through this interface by accessing port 0x379 (the LPT1 status register) on a PC-compatible system. By hooking the circuit to a parallel port, you can easily transmit information back to the computer. Although you might want to connect the circuit to a different interface, LPT is much faster than, say, RS-232, and you won’t have to cope with any mundane protocols, signaling schemes, or unusual voltage levels. Too, unlike USB and some other current solutions, you do not need special controllers to implement a fairly complex protocol to even be able to talk to your PC.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Although LPT also offers bi-directional operation modes (ECP or EPP), it is usually pointless to attempt to use this functionality for such a simple task. In the unidirectional mode, four bits are available for input, more than enough for this application; switching to bi-directional modes such as EPP or ESP provides an extra four bits.</p></div><p>It is up to you to choose the status line to use. <a class="xref" href="ch05s04.html#lpt_pinout" title="Table 5-3. LPT pinout">Table 5-3</a> shows a pin layout of the DB25 connector used for a printer port. The rows shaded gray can be used for input.</p><p>To interface the circuit with this port, you can simply connect the ground reference point on the connector with the one used in your circuit and then hook up the output line to any of the five pins. (Remember to disconnect the LED used for diagnostics first.) Next, monitor the status port as you first expose it to light and then cover the sensor. In either case, the value read depends on how you hooked up the circuit; the exact value does not matter, as long as the two values are different.</p><div class="table"><a id="lpt_pinout"/><p class="title">Table 5-3. LPT pinout</p><div class="table-contents"><table summary="LPT pinout" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" colspan="3" valign="bottom"><p>LPT Port: DB25 Pinout (Standard Mode)</p></th></tr><tr><th style="text-align: left" valign="bottom"><p>Pin</p></th><th style="text-align: left" valign="bottom"><p>Name</p></th><th style="text-align: left" valign="bottom"><p>Function</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>1</p></td><td style="text-align: left" valign="top"><p>Strobe</p></td><td style="text-align: left" valign="top"><p>Control output bit 0</p></td></tr><tr><td style="text-align: left" valign="top"><p>2</p></td><td style="text-align: left" valign="top"><p>D0</p></td><td style="text-align: left" valign="top"><p>Data output bit 0</p></td></tr><tr><td style="text-align: left" valign="top"><p>3</p></td><td style="text-align: left" valign="top"><p>D1</p></td><td style="text-align: left" valign="top"><p>Data output bit 1</p></td></tr><tr><td style="text-align: left" valign="top"><p>4</p></td><td style="text-align: left" valign="top"><p>D2</p></td><td style="text-align: left" valign="top"><p>Data output bit 2</p></td></tr><tr><td style="text-align: left" valign="top"><p>5</p></td><td style="text-align: left" valign="top"><p>D3</p></td><td style="text-align: left" valign="top"><p>Data output bit 3</p></td></tr><tr><td style="text-align: left" valign="top"><p>6</p></td><td style="text-align: left" valign="top"><p>D4</p></td><td style="text-align: left" valign="top"><p>Data output bit 4</p></td></tr><tr><td style="text-align: left" valign="top"><p>7</p></td><td style="text-align: left" valign="top"><p>D5</p></td><td style="text-align: left" valign="top"><p>Data output bit 5</p></td></tr><tr><td style="text-align: left" valign="top"><p>8</p></td><td style="text-align: left" valign="top"><p>D6</p></td><td style="text-align: left" valign="top"><p>Data output bit 6</p></td></tr><tr><td style="text-align: left" valign="top"><p>9</p></td><td style="text-align: left" valign="top"><p><span class="underline">D7</span></p></td><td style="text-align: left" valign="top"><p>Data output bit 7</p></td></tr><tr><td style="text-align: left" valign="top"><p>10</p></td><td style="text-align: left" valign="top"><p>ACK</p></td><td style="text-align: left" valign="top"><p>Status input bit 2</p></td></tr><tr><td style="text-align: left" valign="top"><p>11</p></td><td style="text-align: left" valign="top"><p>Busy</p></td><td style="text-align: left" valign="top"><p>Status input bit 3</p></td></tr><tr><td style="text-align: left" valign="top"><p>12</p></td><td style="text-align: left" valign="top"><p>Paper Out</p></td><td style="text-align: left" valign="top"><p>Status input bit 1</p></td></tr><tr><td style="text-align: left" valign="top"><p>13</p></td><td style="text-align: left" valign="top"><p><span class="underline">Select In</span></p></td><td style="text-align: left" valign="top"><p>Status input bit 0</p></td></tr><tr><td style="text-align: left" valign="top"><p>14</p></td><td style="text-align: left" valign="top"><p><span class="underline">Autofeed</span></p></td><td style="text-align: left" valign="top"><p>Control output bit 1</p></td></tr><tr><td style="text-align: left" valign="top"><p>15</p></td><td style="text-align: left" valign="top"><p><span class="underline">Error</span></p></td><td style="text-align: left" valign="top"><p>Status input (unused)</p></td></tr><tr><td style="text-align: left" valign="top"><p>16</p></td><td style="text-align: left" valign="top"><p><span class="underline">Init</span></p></td><td style="text-align: left" valign="top"><p>Control output bit 2</p></td></tr><tr><td style="text-align: left" valign="top"><p>17</p></td><td style="text-align: left" valign="top"><p>Select</p></td><td style="text-align: left" valign="top"><p>Control output bit 3</p></td></tr><tr><td style="text-align: left" valign="top"><p>18</p></td><td style="text-align: left" valign="top"><p>GND</p></td><td style="text-align: left" valign="top"><p>Ground (0V)</p></td></tr><tr><td style="text-align: left" valign="top"><p>19</p></td><td style="text-align: left" valign="top"><p>GND</p></td><td style="text-align: left" valign="top"><p>Ground (0V)</p></td></tr><tr><td style="text-align: left" valign="top"><p>20</p></td><td style="text-align: left" valign="top"><p>GND</p></td><td style="text-align: left" valign="top"><p>Ground (0V)</p></td></tr><tr><td style="text-align: left" valign="top"><p>21</p></td><td style="text-align: left" valign="top"><p>GND</p></td><td style="text-align: left" valign="top"><p>Ground (0V)</p></td></tr><tr><td style="text-align: left" valign="top"><p>22</p></td><td style="text-align: left" valign="top"><p>GND</p></td><td style="text-align: left" valign="top"><p>Ground (0V)</p></td></tr><tr><td style="text-align: left" valign="top"><p>23</p></td><td style="text-align: left" valign="top"><p>GND</p></td><td style="text-align: left" valign="top"><p>Ground (0V)</p></td></tr><tr><td style="text-align: left" valign="top"><p>24</p></td><td style="text-align: left" valign="top"><p>GND</p></td><td style="text-align: left" valign="top"><p>Ground (0V)</p></td></tr><tr><td style="text-align: left" valign="top"><p>25</p></td><td style="text-align: left" valign="top"><p>GND</p></td><td style="text-align: left" valign="top"><p>Ground (0V)</p></td></tr></tbody></table></div></div><p>Because chip logic requires somewhat different input levels than your test LED diode, you might have to tweak the <code class="literal">Rvar2</code> until you get distinct readings from the port when you cover the sensor, and when you expose it to light. To accomplish this, it is best to be able to monitor the port in real time on the computer itself.</p><p>The way you can monitor the state of the port will depend on the operating system and the programming language you are using. If you’re using C, the function used to read the value off a port is <code class="literal">inb(port)</code>, so in this particular case you would issue <code class="literal">inb(0x379)</code> and check the return value. In other languages, it is likely to have a similar name. (Try looking for <code class="literal">in</code>, <code class="literal">inport</code>, <code class="literal">readport</code>, and so forth.) Also, Windows users may find the built-in “debug” utility and its “i” (port read) function quite handy.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>On some systems, such as Linux, you might need to request that the system give you permission to access a specific port first. Consult the documentation for <code class="literal">iopl(3)</code> or a similar call for more information.</p></div><p>At this point, you are ready to go. You can choose to point your probe at any LED on a device, adjust the sensor based on its brightness, and start reading alternating patterns of light and dark signals, as you discover how they correspond to the exchanged information, if at all.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>If you’re curious, you might try to examine the brightness of the indicator diode, not only a binary representation of its state. It might turn out that even though a specific LED is not intended to directly map a signal on the serial line to its blink patterns, there is some analog cross talk between circuits, and the serial line signal will have some influence on the brightness. A cheap analog-to-digital converter such as TLV571 from Texas Instruments is just asking to be used this way.</p></div><p>You can use this approach to sample the frequency of less than 1 million bits per second, which should suffice for capturing transmission on many interfaces, but not necessarily on Ethernet ports (which transmit at least 10 million bits per second). Past this capture capacity, your LPT port will likely reach its physical throughput limits, but do not despair: as long as the sensor (phototransistor) can switch at the rate sufficient to capture communications in question, you still have an option. Remember that LPT is a parallel port. To reach faster capture speeds, such as the one needed for Ethernet, combine a trivial clock, a counter circuit, and a set of sample-and-hold latches (such as 74LS377) to sequentially store data between the port read attempts on the computer side. You can accumulate this information for a short period of time and then, by using more than just one status pin (or by switching the port to bi-directional mode), easily send several bits—samples—to the computer, in a single burst, in one read cycle, thus improving the read rate four- or eightfold.</p><p>I’ll spare you a further, perhaps needless, excursion into the world of electronics. If you want to toy with the idea of high-speed or analog sampling, or perhaps just get your kicks from soldiering stuff together and hooking it to a computer, you might want to take a look at my fairly comprehensive introductory tutorial under the thin disguise of a computer-controlled robot design project. You should be able to find it at <a class="ulink" href="http://lcamtuf.coredump.cx/robot.txt">http://lcamtuf.coredump.cx/robot.txt</a>.</p><p>And now, for those with interests that lean more toward practical security: a brief discussion of how to address the issue, short of covering all LEDs in the office with duct tape.</p></div>
<div class="sect1" title="Preventing Blinkenlights Data Disclosure&#x2014;and Why It Will Fail"><div class="titlepage"><div><div><h1 class="title"><a id="preventing_blinkenlights_data_disclosure"/>Preventing Blinkenlights Data Disclosure—and Why It Will Fail</h1></div></div></div><p>The easiest solution to the problem, and one suggested by the original research, is <span class="emphasis"><em>pulse stretching</em></span>—a practice intended to distort the blinks on an indicator by prolonging some of them, thus making any practical data recovery seemingly not feasible. <span class="emphasis"><em>Pulse stretching circuits</em></span> are a group of fairly trivial devices that extend the duration of an encountered “high” input signal for an additional period of time. Most basic pulse stretcher design relies on a capacitor that charges in the presence of an input signal and then discharges slowly. This capacitor is connected to a <span class="emphasis"><em>binary discriminator</em></span>, which is not a nickname for a vicious wrestling champion, but rather a device that converts analog data into binary output by applying a particular threshold (outputting a voltage for logical 1 for all input voltages above <span class="emphasis"><em>n</em></span>, and 0 for all input voltages below). In this case, it uses a certain capacitor charge level as the discrimination point.<a id="IDX-CHP-5-0285" class="indexterm"/><a id="IDX-CHP-5-0286" class="indexterm"/><a id="IDX-CHP-5-0287" class="indexterm"/><a id="IDX-CHP-5-0288" class="indexterm"/><a id="IDX-CHP-5-0289" class="indexterm"/><a id="IDX-CHP-5-0290" class="indexterm"/></p><p>More advanced and reliable designs, including purely digital circuitry, are also common, and all can be used in hubs and switches to make LEDs nice to look at. Without them, the high-speed blinking at way more than 50 cycles per second (considered the limit on our ability to perceive flicker), would usually result in our seeing the lights as dim but seemingly constant. A discriminator causes the LED to be driven by 1 more often than by 0 by extending the duration of each 1 pulse. This makes the LED light brighter and blink less often. <a class="xref" href="ch05s05.html#pulse_stretcher_behavior_comma_3x" title="Figure 5-7. Pulse stretcher behavior, 3x">Figure 5-7</a> shows the behavior of such a pulse stretcher: a single spike (single 1) is stretched to last three times as long, whereas all 0s are left as they are.</p><div class="figure"><a id="pulse_stretcher_behavior_comma_3x"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e4307"/><img src="httpatomoreillycomsourcenostarchimages1138034.png.jpg" alt="Pulse stretcher behavior, 3x"/></div></div><p class="title">Figure 5-7. Pulse stretcher behavior, 3x</p></div><p>While their primary purpose is aesthetic, as I have mentioned, this also seems to be a good way to solve the problem of light emissions information disclosure, by letting the attacker deduce only certain general properties of the traffic. Thus, at best, the attacker can figure out only general properties of the traffic, such as when something is being sent and when it is not.<sup>[<a id="CHP-5-FN-3" href="#ftn.CHP-5-FN-3" class="footnote">13</a>]</sup></p><p>What seems to be a good solution, however, is not always. Consider the following sample data and the corresponding serial line signal:</p><div class="informalfigure"><a id="image_no_caption-id1"/><div class="mediaobject"><a id="I_mediaobject1_d1e4322"/><img src="httpatomoreillycomsourcenostarchimages1138036.png" alt="image with no caption"/></div></div><p>Assume the signal is processed using a 5x pulse stretcher that makes every 1 last for five additional cycles. (The original paper suggests a safe limit of 2x, but we’ll exaggerate to make a point.)</p><div class="informalfigure"><a id="image_no_caption-id2"/><div class="mediaobject"><a id="I_mediaobject1_d1e4330"/><img src="httpatomoreillycomsourcenostarchimages1138038.png.jpg" alt="image with no caption"/></div></div><p>Although it might appear that almost all important information has been lost when compared with the input signal we want to intercept, it is possible to recover much of it by making four important observations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Obviously, all areas where the stretcher output is zero must have been zero in the original signal.</p></li><li class="listitem"><p>Each stretched run of 1s must have been triggered by 1 at the starting location in the original stream.</p></li><li class="listitem"><p>Each run of L 1s must have originally contained at least one 1 for every <span class="emphasis"><em>N</em></span> cycles, where <span class="emphasis"><em>N</em></span> is the stretch factor for this circuit; otherwise, there would be gaps in the run. The count of 1s in a block of data represented under a single stretch of 1s in output is greater than or equal to L/<span class="emphasis"><em>N</em></span> rounded up.</p></li><li class="listitem"><p>Every run ends after exactly <span class="emphasis"><em>N</em></span>−1 zeros in the original stream. We know that these zeros must have been preceded with 1; otherwise the run would have ended sooner.</p></li></ul></div><p>By applying this knowledge to the previous example, we can reconstruct most of the original data, as follows:</p><div class="informalfigure"><a id="image_no_caption-id3"/><div class="mediaobject"><a id="I_mediaobject1_d1e4366"/><img src="httpatomoreillycomsourcenostarchimages1138040.png.jpg" alt="image with no caption"/></div></div><p>In the previous fairly realistic example, fewer than 9 out of 32 bits of data were lost due to pulse stretching and cannot be conclusively reconstructed (marked with question marks in the graphic). Thus, we recovered 99.999988% of the potential search space. We must guess at the remaining data, which (especially if the data snooped is regular English text, such as email) is rather trivial to reconstruct compared to the starting point. The authors of the research suggest that even N = 1.5 or N = 2 “on” time pulse stretching is sufficient to obfuscate the data, but this is not necessarily so.</p><p>The previous reconstruction scheme works with stretches of 0s or 1s. Some links use return-to-zero (RZ) encodings (such as the Manchester scheme mentioned earlier), and because the signal is constantly alternating there, the 2x stretching might indeed be sufficient to obfuscate all data. However, this is only true if the LED is driven by a signal prior to initial internal decoding to NRZ—which, in most situations, is not the case. In fact, applying pulse stretching to RZ-encoded signal is often a silly idea in that the LED would be on all the time; hence there seems to be no point in doing that in the first place.</p><p>As noted previously, an additional problem stems from the quality of the pulse stretcher and its susceptibility to interference from other internal circuits: LED voltage fluctuations that result in slight brightness changes during a “stretch” period might disclose some information. Capacitor-based solutions, in particular, can fall into this category.</p><p>Thus, some systems, particularly Ethernet devices known to deploy pulse stretching, can be partly vulnerable to attack, even though the original paper discussed earlier concluded that there is no direct correlation between the transmitted data and the behavior of an LED, based on the observation of a recorded blinking pattern using an oscilloscope.</p><p>The optimal solution, particularly with other types of encoding, or when pulse stretching is not desirable for some other reason (for example, if the designer wants to avoid making the LED light appear constantly for the time of a transmission) is to sample the line at a fairly low frequency (for example, 20 Hz) and latch it to a register that holds it until the next sample and that also controls the LED.</p><p>And, now, back to plain English.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-5-FN-3" href="#CHP-5-FN-3" class="para">13</a>] </sup>This, technically speaking, is still an attack venue, per the discussion in <a class="xref" href="ch01.html" title="Chapter 1. I Can Hear You Typing">Chapter 1</a>, yet it is considerably less effective and practical, for we only get a rough idea of what is going on, not a copy of the data.</p></div></div></div>
<div class="sect1" title="Food for Thought"><div class="titlepage"><div><div><h1 class="title"><a id="food_for_thought-id2"/>Food for Thought</h1></div></div></div><p>Other than network device LEDs, plenty of other, equally interesting light emissions leak scenarios can be found, although the amount of information disclosed can be significantly lower. For example, consider disk activity LEDs. Of course, disk communication is not using serial signaling; instead, portions of data, ranging from bytes to 32-bit words, are sent simultaneously using a set of signal lines. And, although the LED is usually attached to indicate only a state of a specific control line, it is still possible to deduce many aspects of system activity by measuring seek times or the amount of data stored and read. (Depending on what the LED is actually attached to, it may be possible to measure either or both.) Although it’s unlikely that this information would give an attacker any immediate advantage, certain induced I/O activities can be combined with hard-disk drive LED observation to draw interesting conclusions, although I am unaware of any research in this area.<a id="IDX-CHP-5-0291" class="indexterm"/><a id="IDX-CHP-5-0292" class="indexterm"/><a id="IDX-CHP-5-0293" class="indexterm"/><a id="IDX-CHP-5-0294" class="indexterm"/></p><p>Other potential attack venues involve many USB devices and other proprietary interfaces. As mentioned earlier, USB is a serial bus, and some USB appliances do have activity indicators.</p><p>Various other unusual and arcane information-disclosure venues have also been proposed, partly researched or at least toyed with. These include measuring the acoustic effects of recharging capacitors as the CPU consumes various levels of power depending on the executed instruction<sup>[<a href="apb.html#ftn.CHP-5-BIB-5" class="footnoteref">64</a>]</sup> or measuring a black box device by analyzing its power consumption with the help of statistical analysis.<sup>[<a href="apb.html#ftn.CHP-5-BIB-6" class="footnoteref">65</a>]</sup> Once again, no truly comprehensive research has been done in the area of disclosure channels other than classic EMF (electromagnetic field) emanations—and it appears to be a good idea to investigate. Best of luck. :-)</p></div>
<div class="chapter" title="Chapter&#xA0;6.&#xA0;Echoes of the Past"><div class="titlepage"><div><div><h1 class="title"><a id="echoes_of_the_past"/>Chapter 6. Echoes of the Past</h1></div></div></div><div class="epigraph"><p><span class="emphasis"><em>Where, on the example of a curious Ethernet flaw, we learn that it is good to speak precisely</em></span></p><div class="attribution"><span>—<span class="attribution"/></span></div></div><p>The previous chapter tackled the basics of Ethernet communications. This seemingly foolproof and amazingly trivial mechanism appears to be incapable of causing serious security issues, except for the possible abuse of the trust relationship caused by the regular broadcasting of data to all parties on the network. This is a well-known and well-understood property of Ethernet networks, for which good remedies include switches, bridges, and network segmentation, to name just a few.</p><p>Nonetheless, this issue manifests itself in ways wholly unforeseen, due largely to an unfortunate choice of words, or lack thereof, in the official implementation requirements for Ethernet drivers. A widespread implementation problem is the result, and it has reached a scale that has earned it a place as this chapter. It provides an interesting case study for this class of nobody-at-fault problems.</p><div class="sect1" title="Building the Tower of Babel"><div class="titlepage"><div><div><h1 class="title"><a id="building_the_tower_of_babel"/>Building the Tower of Babel</h1></div></div></div><p>The Ethernet protocol provides the basic means to distribute bytes over a piece of wire: a low-level data-encoding scheme, and a data format to contain a portion of the information. The Ethernet frame contains the information about the local disposition of the data it carries (that is, who is sending it and who should be the recipient) and a brief description of the type of information encapsulated. Additional methods for error detection are also provided, and then the entire frame is pushed out to a potential recipient and all other systems. In terms of functionality, Ethernet is similar to data portion encapsulation schemes used over different mediums or in different applications, such as frame relay, Asynchronous Transfer Mode (ATM), Point-to-Point Protocol (PPP), and so forth.</p><p>The question is, “What data should be carried by such an Ethernet frame?” Computers use hundreds of formats and application protocols and can run applications ranging from scientific simulations to network games and chat clients. As such, although it is possible to simply encapsulate the data for a remote recipient within an Ethernet frame as is, it is usually a bad idea because the recipient won’t know how to handle it. Is it incoming email? A web picture? Or perhaps configuration data? You can’t tell. Too, because a typical computer runs a variety of programs almost simultaneously, the distinction is even further blurred.</p><p>Ethernet poses yet another problem on a larger scale; specifically, how to reach the other end. Broadcasting data to all parties on a local network is easy; but what if the other system, the party one of the local users hopes to reach, is not local? What if it has to be reached over a wide area network (WAN) and uses a wholly different link-layer protocol? Even if a way can be found to route traffic to that remote destination, a more fundamental issue remains: how to address the package.</p><p>Ethernet uses its own unique, specialized addressing scheme. It calls hosts by their theoretically unique hardware card identification numbers (Media Access Control addresses, or MAC addresses) embedded by the manufacturer on every Ethernet adapter. These numbers are meaningful only to Ethernet; they are meaningless to any other type of network and are nearly impossible to use to track down a piece of hardware if you are not on the local setup. This raises a trust issue. For example, who bought a card with the address of 00:0D:56:E3:FB:E4, and where are they now? Can you trust them to really be the original purchaser and not an impostor?</p><p>Low-level host-addressing schemes, such as this one, usually are no help in relaying data to its destination unless the hardware with a particular MAC address is attached directly to the sender’s physical network. There is no way to directly map a physical device identifier to a particular location on the globe and determine which path should be used to send it information.</p><div class="sect2" title="The OSI Model"><div class="titlepage"><div><div><h2 class="title"><a id="the_osi_model"/>The OSI Model</h2></div></div></div><p>The link-level protocols were designed to support communication between local nodes or, in some extreme cases, between two fixed endpoints on a shared link. To make internetworking possible and some more practical uses of the networks feasible, a hierarchical structure of network protocols called Open System Interconnection (OSI) was devised.<a id="IDX-CHP-6-0295" class="indexterm"/><a id="IDX-CHP-6-0296" class="indexterm"/></p><p>The OSI model (see <a class="xref" href="ch06.html#the_physical_data_layout_in_the_osi_mode" title="Figure 6-1. The physical data layout in the OSI model, an example">Figure 6-1</a>) defines the physical connection level as the first layer and builds higher-level features on top of it. Link-level protocols constitute the second layer (data link layer) and are, as expected, defined as a way to communicate with other local nodes that use the same physical link. These protocols carry higher-level, link-independent protocol data, defined as the third layer (network layer) of the model. The Internet Protocol, IP for short, is the most prominent example of such a protocol.<a id="IDX-CHP-6-0297" class="indexterm"/></p><div class="figure"><a id="the_physical_data_layout_in_the_osi_mode"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e4458"/><img src="httpatomoreillycomsourcenostarchimages1138042.png.jpg" alt="The physical data layout in the OSI model, an example"/></div></div><p class="title">Figure 6-1. The physical data layout in the OSI model, an example</p></div><p>The third layer is designed to provide information about the general disposition of the traffic as well as universal identification of both the origin and final destination of data using network-specific addressing, thus making it easier to route the packet. Unlike the second-layer protocols, the third layer is not discarded or modified en route and is devoid of any link-specific features such as MAC addresses, CSMA/CD (Carrier Sense Multiple Access with Collision Detection) overhead, and so forth.</p><p>The fourth layer provides the means for establishing specific communication channels between endpoints starting and terminating on a given machine. This provides a way for simultaneous communication of multiple types and channels. None of the fourth-level protocols needs to be understood by intermediate systems to properly deliver the traffic to the destination. The packets are interpreted only by the final recipient to determine which application should be receiving the data and how this piece of information relates to adjacent packets.</p><p>The subsequent layers of the OSI model are perhaps less interesting and have a tendency to blend together. The fifth level is supposed to provide reliability features that are often incorporated either in fourth-level protocols, such as TCP/IP (Transmission Control Protocol/Internet Protocol), or on the application level. In some cases, they are not even implemented at all if there is no need to achieve reliable communications. The sixth level provides “library” functions, such as decompression and decoding of the data and, as with the fifth level, is usually perceived in terms of application-level functionality. Finally, the seventh layer is the application layer, the place where data is transferred in a specific format.</p><p>Notice that the higher layers in the OSI model are independent of the lower layers as they apply to the carried data. When the time is right, the lower layers can gradually be disposed of without losing the data or the ability to further process it. The second layer is discarded at every intermediate system; the third layer can be discarded once the data is delivered to its destination system. The fourth layer is dropped before delivering the data to the client application.</p><p>The third layer usually remains completely independent of the underlying link-level protocol by providing complete sender and addressee information, an integrity protection mechanism (checksumming), and information about the size of the carried payload. This is precisely what IP does.</p><p>One important consequence of this design is that any superfluous information appended to the packet on layer 2 while in transit will not affect the way the IP information is interpreted by the addressee.</p></div></div></div>
<div class="sect1" title="The Missing Sentence"><div class="titlepage"><div><div><h1 class="title"><a id="the_missing_sentence"/>The Missing Sentence</h1></div></div></div><p>In the previous chapter’s discussion of the design of the Ethernet, I mentioned an interesting requirement that arises out of a need to provide reliable jam code propagation for the purpose of collision notification: the <span class="emphasis"><em>minimum</em></span> size limit for an Ethernet frame.<a id="IDX-CHP-6-0298" class="indexterm"/><a id="IDX-CHP-6-0299" class="indexterm"/><a id="IDX-CHP-6-0300" class="indexterm"/><a id="IDX-CHP-6-0301" class="indexterm"/><a id="IDX-CHP-6-0302" class="indexterm"/><a id="IDX-CHP-6-0303" class="indexterm"/><a id="IDX-CHP-6-0304" class="indexterm"/></p><p>This requirement was carried over to the official IP-over-Ethernet encapsulation specifications, such as RFC 1042, “A Standard for the Transit of Internet Protocol Datagrams Over IEEE 802 Networks,”<sup>[<a href="apb.html#ftn.CHP-6-BIB-1" class="footnoteref">66</a>]</sup> by requiring frames that were shorter than this minimum length to be padded. The padding can be carried out at will and has no effect on the carried data on the IP layer, as the packet length specified in the IP headers does not change. Thus, the padding will not be interpreted by the recipient as a part of higher-level OSI model traffic.<a id="IDX-CHP-6-0305" class="indexterm"/></p><p>There is, however, a slight problem. Although the RFC requires the padding to be initialized to zero, it does not specify who should provide and prepare the padding and at what software stage the padding should occur. The need for the padding to be of a particular value is also a requirement that in its nature is fairly arbitrary; hence, no attention is paid to it—setting it any other way would not impact how the protocol works, because the extraneous data is simply discarded upon receipt.</p><p>To add to the confusion, many network interface cards provide an autopadding feature if a packet the operating system sent to the hardware is too short—but, naturally, not to ensure the specific contents of a padding if frame size has been already taken care of in software. This led to wide-spread confusion among some developers who chose to obey the size requirement and extend the size of a packet in software by simply increasing its declared length. They often did not realize that the data between the end of the IP packet and the end of the padded frame was not prepared (initialized to zeros) by the driver, the operating system, or the hardware.</p><p>The problem went largely unnoticed for years, although it caused an awkward issue that regularly drove some network hackers insane. The packets they received from local systems often contained some extra garbage at the end—such as fragments of website contents or even chat conversations that were clearly irrelevant. They blamed the recipient (faulty equipment, the network traffic analysis application, libraries) but ultimately gave up looking for a cause because the issue was of marginal relevance. The issue never got the attention it deserved.</p><p>That is, not until Ofir Arkin and Josh Anderson of @Stake decided to give it a closer look in 2003. Their paper “EtherLeak—Ethernet Frame Padding Information Leaks”<sup>[<a href="apb.html#ftn.CHP-6-BIB-2" class="footnoteref">67</a>]</sup> examined the problem in more detail. The authors realized that a large number of mainstream systems, such as Linux, NetBSD, Microsoft Windows, and other platforms, fail to initialize the memory at the end of the newly prepared Ethernet frame after modifying its length. Some implementations even fail to change the size of a frame properly or to send a proper number of bytes to the hardware layer.</p><p>As a result, the IP packet is padded with data that happens to be stored in the portion of memory the system used previously for other purposes. The memory could contain part of a previously sent packet or some other kernel memory fragment, depending on the design of the driver or the operating system. This, of course, creates a fascinating information disclosure scenario: An attacker sends inconspicuous and legitimate traffic to the victim and, with some luck, obtains potentially sensitive information. The amount of information disclosed is typically sufficient to justify concern.</p><p>The exposure is limited to a single Ethernet network and, as such, is fairly localized and noncritical in a typical LAN environment. Still, it definitely remains a problem of some significance, and even though any local network is partly vulnerable to snooping, this particular problem suggests some conclusions that extend beyond the most obvious:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>On systems that use dynamic buffers for outgoing Ethernet frames (Linux, for example), the padding can expose not only the previous frame, but other memory contents, such as edited or viewed documents, URLs, passwords, or other sensitive resources. In this case, a careful observer might be able to gain access to information they could not otherwise intercept on the network.</p></li><li class="listitem"><p>On systems that use static buffers only to prepare Ethernet frames, the problem can be exploited to defeat systems that protect against traffic sniffing, such as switches, enabling the attacker to intercept data from a different connection.</p></li><li class="listitem"><p>In certain static buffer designs, information from another segment on a multihoned machine, with one network interface connected to a general LAN and the other interface hooked up to a restricted network, can be exposed, thus relaying portions of presumably secret data to the public infrastructure.</p></li></ul></div><p>The authors of the paper extensively reviewed several open-source implementations and concluded that a variety of approaches and buffer layouts are commonly used and that there is no predominant buffer allocation and usage scheme. Their conclusion? A typical diverse network environment is likely to be affected by all three types of issues at some point.</p></div>
<div class="sect1" title="Food for Thought"><div class="titlepage"><div><div><h1 class="title"><a id="food_for_thought-id3"/>Food for Thought</h1></div></div></div><p>The issue discussed here is not unique to Ethernet or network design. These problems almost always arise when an otherwise detailed implementation guideline omits or only vaguely discusses a single necessary step, causing numerous developers to simply overlook the problem while implementing the standard. Had they been given more vague overall instructions, developers would probably be forced to think through the problem. Instead, they implement step-by-step instructions and are far more vulnerable to committing errors. “Foolproof” instructions that tell how to perform certain tasks, as opposed to what to achieve, often backfire.<a id="IDX-CHP-6-0306" class="indexterm"/><a id="IDX-CHP-6-0307" class="indexterm"/></p><p>We will return to the problems of protocol leak scenarios, albeit in a slightly different context, in <a class="xref" href="pt03.html" title="Part III. Out in the Wild">Part III</a> of this book.</p></div>
<div class="chapter" title="Chapter&#xA0;7.&#xA0;Secure in Switched Networks"><div class="titlepage"><div><div><h1 class="title"><a id="secure_in_switched_networks"/>Chapter 7. Secure in Switched Networks</h1></div></div></div><div class="epigraph"><p><span class="emphasis"><em>Or, why Ethernet LANs cannot be quite fixed, no matter how hard we try</em></span></p><div class="attribution"><span>—<span class="attribution"/></span></div></div><p>Ethernet networks do not provide a universal and easy way to ensure the integrity or confidentiality of the data they transmit, nor are they engineered to with-stand malicious, intentionally injected traffic. Ethernet is merely a means for interfacing a number of local, presumably trusted systems.</p><p>Assuming this level of trust is convenient at the design stage and is theoretically sufficient for peer systems on the same network and often at roughly the same physical location. But, as the old saying goes, only in theory is there no difference between theory and practice. In practice, there is a difference.</p><p>As it turns out, local networks are difficult to fully control and must be protected from their own users as well as from external threats. Any expanding local network is bound to encounter a rogue user, whether from within the organization or from outside, exploiting a flaw in one of the systems. The occurrence of such an exploit is only a matter of time, as almost all network administrators learn at some point.</p><p>Practical network security is the art of detecting incidents, minimizing exposure, and assessing and understanding the risk on all levels, not only an exercise in building perimeter defenses. The problem? A bare-bones Ethernet infrastructure is prone to all types of data interception, hijacking, and impersonation scenarios; once an intruder or a malicious but legitimate user controls a single system on the network—breaking through a single line of defense—this person can wreak havoc on the infrastructure and gain access or take over certain resources and services with minimal effort.</p><div class="sect1" title="Some Theory"><div class="titlepage"><div><div><h1 class="title"><a id="some_theory"/>Some Theory</h1></div></div></div><p>Ethernet switches, a class of smart devices designed to route unicast traffic on the second OSI layer to the appropriate port instead of broadcasting it to all nodes (as is the case with hubs or direct connections), may appear to solve this problem. They are often thought to solve the security problems associated with the ability for one system to observe or hijack third-party traffic, but this is not so. The solution is not that simple, and the confusion caused by this presumption sometimes causes more harm than the switches could do good in the first place. But first things first. To understand the exposure, let’s look at how Ethernet switches really work.<a id="IDX-CHP-7-0308" class="indexterm"/><a id="IDX-CHP-7-0309" class="indexterm"/><a id="IDX-CHP-7-0310" class="indexterm"/><a id="IDX-CHP-7-0311" class="indexterm"/><a id="IDX-CHP-7-0312" class="indexterm"/><a id="IDX-CHP-7-0313" class="indexterm"/><a id="IDX-CHP-7-0314" class="indexterm"/></p><div class="sect2" title="Address Resolution and Switching"><div class="titlepage"><div><div><h2 class="title"><a id="address_resolution_and_switching"/>Address Resolution and Switching</h2></div></div></div><p>All communication within a local network is based on the addressing scheme discussed in <a class="xref" href="ch05.html" title="Chapter 5. Blinkenlights">Chapter 5</a>. Unique identifiers assigned by the hardware manufacturer to a specific endpoint device are used to address systems and deliver data frames. However, the Internet and most of today’s private networks are built around a more flexible and universal suite of protocols and use an addressing scheme on the third OSI layer, commonly known as Internet Protocol (IP) addresses. The IP address is first used to direct the traffic across the world to an appropriate local network using a hierarchy of routing tables on middle systems all over the globe; not until the packet reaches the perimeter of the destination network must the final recipient be located the old-fashioned way, by a hardware address lookup.</p><p>Whenever a system on the local network decides to locate another local party with a specific IP address, it uses a special address resolution protocol (ARP) to determine the association between a physical card address—the basis for addressing systems on a local network—and the IP address, a universal internetworking system identifier.<sup>[<a href="apb.html#ftn.CHP-7-BIB-1" class="footnoteref">68</a>]</sup> The sender distributes an ARP query to a special broadcast address on the local network. This reserved address is guaranteed to be received and processed by all systems on the network, regardless of the actual hardware address assigned to specific nodes. In this scenario, the system that considers itself to have the right to use the IP address specified in the query is expected to send a response to the sender, thus disclosing its hardware address in answer to the query; all other folks are supposed to silently ignore the broadcast ARP packet. After this exchange, both parties now know each other’s IP and media access control (MAC) addresses. They should cache the finding in a special buffer to eliminate the need to perform additional lookups every time a portion of data is exchanged and then proceed with the actual communications—but other than that, they are ready to swap some packets based on IP addressing. This design is a charming and delightful example of an old-time trust and courtesy. But what can be done to contain the exposure caused by a malicious bystander on the same network, who pretends to be someone else, and what can be done to prevent the more curious users or evil foes from reaching too far? Manufacturers of the Ethernet hardware most certainly did not help network administrators by making it possible and trivial to change MAC addresses on most of today’s devices—presumably allowing the user to reprogram then in order not to end up in trouble should one day a batch of cards turn out to have duplicate addresses.</p><p>Again, switches appear to solve the problem. The basic design concept behind a smart switching device relies on duplicating the MAC address cache on the level of an interim network device. A switching device is equipped with numerous Ethernet ports, each of which connects to a single system (or, less often, a set of systems). But instead of serving as dumb repeaters, sending all traffic received on one port to all others (as Ethernet hubs do), switches attempt to memorize MAC addresses associated with a machine connected to each port, effectively creating MAC-to-port associations, as opposed to the MAC-to-IP mappings created by endpoint systems.</p><p>The data, stored in content addressable memory<sup>[<a id="CHP-7-FN-1" href="#ftn.CHP-7-FN-1" class="footnote">14</a>]</sup> (CAM), determines where to deliver incoming packets. Whenever a portion of traffic arrives, the switch attempts to determine which port the addressee is on. If this information is available, the packet is delivered directly (and only) to this particular port, keeping the information away from others and improving network performance.</p></div><div class="sect2" title="Virtual Networks and Traffic Management"><div class="titlepage"><div><div><h2 class="title"><a id="virtual_networks_and_traffic_management"/>Virtual Networks and Traffic Management</h2></div></div></div><p>Some more advanced switch solutions provide additional features intended to make it easier to manage extensive networks and to lower deployment times and expenses. These features also appear to help with network security and may include the following:<a id="IDX-CHP-7-0315" class="indexterm"/><a id="IDX-CHP-7-0316" class="indexterm"/><a id="IDX-CHP-7-0317" class="indexterm"/><a id="IDX-CHP-7-0318" class="indexterm"/><a id="IDX-CHP-7-0319" class="indexterm"/><a id="IDX-CHP-7-0320" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Virtual LAN (VLAN)</strong></span></span></dt><dd><p>A general name for a set of methods used to divide a pool of ports on a physical device into a set of separate logical networks, thus separating traffic on a group of ports from others and preventing any kind of traffic from crossing between those groups on the switch level. (This scheme is most commonly implemented using the IEEE 802.1Q standard, discussed in the next item in detail.) Implementing a VLAN is like splitting a single switch into several fully independent devices, except that the VLAN solution is far more flexible and cost-effective, because it is possible to reshape your network and reallocate physical resources at will. VLANs were met with a warm welcome by network staff everywhere because they promised to offer a simple yet powerful way to build a set of separate networks on a single device or, for example, separate servers from workstations, without the need to buy a dedicated switch for each group.</p></dd><dt><span class="term"><span class="strong"><strong>Trunking</strong></span></span></dt><dd><p>A natural extension of the baseline VLAN design. Trunks use the IEEE 802.1Q frame-tagging scheme to tunnel multiple VLAN traffic over a single link, instead of forcing the user to run separate wire for every VLAN to be populated to another device, as shown in <a class="xref" href="ch07.html#vlan_trunking_in_action._vlans_propagate" title="Figure 7-1. VLAN trunking in action. VLANs propagated across two devices. Devices on all instances of both VLAN #1 and VLAN #2 can talk with each other, but cross talk between VLAN #1 and VLAN #2 is not possible.">Figure 7-1</a>. Packets from all or some VLANs on the source switch are tagged with enough information to determine their originating VLAN within the Ethernet frame header, tunneled to the other endpoint over a traditional link, decoded, and then pushed out into appropriate VLANs at the destination. Although this option usually results in lower performance than running a separate cable for every subnet, it is much more practical. Trunked systems often also feature DTP (Dynamic Trunking Protocol), a trunk autoconfiguration protocol that enables devices to automatically discover and exchange encapsulated frames other trunk-enabled devices with no special administrative actions required.<a id="IDX-CHP-7-0321" class="indexterm"/></p><div class="figure"><a id="vlan_trunking_in_action._vlans_propagate"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e4679"/><img src="httpatomoreillycomsourcenostarchimages1138044.png.jpg" alt="VLAN trunking in action. VLANs propagated across two devices. Devices on all instances of both VLAN #1 and VLAN #2 can talk with each other, but cross talk between VLAN #1 and VLAN #2 is not possible."/></div></div><p class="title">Figure 7-1. VLAN trunking in action. VLANs propagated across two devices. Devices on all instances of both VLAN #1 and VLAN #2 can talk with each other, but cross talk between VLAN #1 and VLAN #2 is not possible.</p></div></dd><dt><span class="term"><span class="strong"><strong>Spanning tree protocol (STP)</strong></span></span></dt><dd><p>Lets you build redundant network structures in which switches are interconnected in more than one location, in order to maintain fault tolerance. Traditionally, such a design could cause broadcast traffic and some other packets to loop forever while also causing network performance to deteriorate significantly, because the data received on one interface and forwarded to another in effect bounces back to the originator (see <a class="xref" href="ch07.html#packet_storm_problem_and_stp_election_sc" title="Figure 7-2. Packet storm problem and STP election scheme; left side shows a fault-tolerant network with no STP, where some packets are bound to loop (almost) forever between switches; right side is the same network where one of the devices was automatically elected a master node using STP, and for which the logical topology was adjusted to eliminate loops. When one of the links fails, the network would be reconfigured to ensure proper operations.">Figure 7-2</a>, left).<a id="IDX-CHP-7-0322" class="indexterm"/></p></dd></dl></div><p>When designing a network, it is often difficult to avoid accidental broadcast loops. It is also sometimes desirable to design architectures with potential loops (in which one switch connects to two or more switches), because this type of design is much more fault tolerant and a single device or single link can be taken out without dividing the entire network into two separate islands.</p><p>To make it possible to build loops and other nontrivial architectures without causing serious performance problems, STP implements an election mechanism to select a “root” node switch. Based on the result of this election, a treelike traffic distribution hierarchy is built from this node down, and links that could cause a reverse propagation of broadcast traffic are temporarily disabled (see <a class="xref" href="ch07.html#packet_storm_problem_and_stp_election_sc" title="Figure 7-2. Packet storm problem and STP election scheme; left side shows a fault-tolerant network with no STP, where some packets are bound to loop (almost) forever between switches; right side is the same network where one of the devices was automatically elected a master node using STP, and for which the logical topology was adjusted to eliminate loops. When one of the links fails, the network would be reconfigured to ensure proper operations.">Figure 7-2</a>, right). You can quickly change this simple self-organizing hierarchy when one of the nodes drops off and reactivate a link previously deemed unnecessary.</p><div class="figure"><a id="packet_storm_problem_and_stp_election_sc"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e4707"/><img src="httpatomoreillycomsourcenostarchimages1138046.png.jpg" alt="Packet storm problem and STP election scheme; left side shows a fault-tolerant network with no STP, where some packets are bound to loop (almost) forever between switches; right side is the same network where one of the devices was automatically elected a master node using STP, and for which the logical topology was adjusted to eliminate loops. When one of the links fails, the network would be reconfigured to ensure proper operations."/></div></div><p class="title">Figure 7-2. Packet storm problem and STP election scheme; left side shows a fault-tolerant network with no STP, where some packets are bound to loop (almost) forever between switches; right side is the same network where one of the devices was automatically elected a master node using STP, and for which the logical topology was adjusted to eliminate loops. When one of the links fails, the network would be reconfigured to ensure proper operations.</p></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.CHP-7-FN-1" href="#CHP-7-FN-1" class="para">14</a>] </sup>As its name suggests, this type of memory can be directly addressed by the parameter for which you are trying to determine the value, which saves time that would normally have to be spent on searching for the parameter. A library catalog is a trivial example of CAM—you do not need to go through all the books in the library just to find one; you determine where to look based on what you are looking for (a piece of information about the “content”).</p></div></div></div>
<div class="sect1" title="Attacking the Architecture"><div class="titlepage"><div><div><h1 class="title"><a id="attacking_the_architecture"/>Attacking the Architecture</h1></div></div></div><p>The mechanisms discussed so far were engineered to improve the bottom line while providing high performance, on top of a network design that provides no security features whatsoever.<sup>[<a href="apb.html#ftn.CHP-7-BIB-2" class="footnoteref">69</a>]</sup> Although certain common, well-understood, and easy-to-prevent attacks, such as <span class="emphasis"><em>MAC spoofing</em></span> (the ability for any person to spoof an ARP message and impersonate a device with a particular IP) are widely recognized as a pitfall of local area networking and are easy to prevent with properly configured switches, some other serious design flaws are not so trivial and, in fact, not prevented so easily. It is not always obvious that solutions commonly perceived as designed to improve security in fact do nothing to help it.<a id="IDX-CHP-7-0323" class="indexterm"/><a id="IDX-CHP-7-0324" class="indexterm"/><a id="IDX-CHP-7-0325" class="indexterm"/><a id="IDX-CHP-7-0326" class="indexterm"/><a id="IDX-CHP-7-0327" class="indexterm"/><a id="IDX-CHP-7-0328" class="indexterm"/><a id="IDX-CHP-7-0329" class="indexterm"/></p><div class="sect2" title="CAM and Traffic Interception"><div class="titlepage"><div><div><h2 class="title"><a id="cam_and_traffic_interception"/>CAM and Traffic Interception</h2></div></div></div><p>One of the more spectacular reasons not to consider switches as a security feature is the <span class="emphasis"><em>CAM overflow</em></span> scenario. The CAM that stores MAC-to-port associations has a fixed and limited size and is generally constructed in a nondiscriminatory manner. Whenever a system cannot be located in CAM, the switch has but one way to deliver the packet—it must fall back to the hub mode, broadcasting the packet to all systems, hoping the recipient will recognize this traffic as addressed to himself and that other systems will be nice enough to disregard it altogether. Thus, a careful attacker can employ a tactic to generate a large number of bogus ARP requests and responses, or some other packets, impersonating a vast number of separate network devices, just to fill up the switch’s CAM. Once the CAM is full, the attack has effectively degraded the network security by disabling smart frame routing on the switch and forcing it to fall back to broadcasting all data. This, in turn, allows the attacker to snoop on all communications, as if the network was not switched at all. The attacker can do all this without impersonating the recipient or visibly affecting the operations of the network, so the victim might well remain completely unaware of this problem. This is a design issue; it is not a flaw in the intended purpose of these devices, but a serious misconception in the popular understanding of how switches work. And, rest assured, it is nearly impossible to fully address this problem in a typical environment. Some switches do implement port and time limits to prevent such attacks, but these are never 100 percent effective.<a id="IDX-CHP-7-0331" class="indexterm"/><a id="IDX-CHP-7-0332" class="indexterm"/><a id="IDX-CHP-7-0333" class="indexterm"/><a id="IDX-CHP-7-0334" class="indexterm"/><a id="IDX-CHP-7-0335" class="indexterm"/><a id="IDX-CHP-7-0336" class="indexterm"/><a id="IDX-CHP-7-0330" class="indexterm"/></p></div><div class="sect2" title="Other Attack Scenarios: DTP, STP, Trunks"><div class="titlepage"><div><div><h2 class="title"><a id="other_attack_scenarios_colon_dtp_comma_s"/>Other Attack Scenarios: DTP, STP, Trunks</h2></div></div></div><p>Other problems are usually easier to prevent and remain more evident (can be often detected by the victim), but still illustrate Ethernet-level security issues. For example, an attack on the aforementioned DTP mechanism is one interesting possibility. DTP autonegotiation is often enabled for all ports on a device in order to provide easier setup. The problem is that a clever attacker can hence pretend to be a trunk-enabled switch, rather than a mere end-user workstation or a humble server; once recognized by the switch it is connected to as a friendly device, he would start receiving 802.1Q tagged frames, including traffic in other virtual LANs served by the switch it is connected to, being able to intercept or inject malicious traffic to networks with which he is not supposed to be able to communicate. In many networks where the same switch handles both protected, “demilitarized” networks and common corporate LAN infrastructure, such an attack may be yield very useful data by enabling members of one of the networks to snoop on or interact with the other.</p><p>You can resolve this DTP problem on some devices by changing the default configuration and clearly defining a set of dedicated trunk-enabled ports on the switch. However, the problem does not end here—our other friend, STP, can be abused in a similar manner, allowing an attacker to choose self as the “root” switch and receive a cut of the network traffic. Disabling STP discovery might be even more difficult in a typical corporate environment.</p><p>Still another problem arises when any trunk originates or terminates at a nondedicated VLAN. (That is, the port used for trunking is placed in a VLAN also used by workstations.) By injecting already tagged frames, it is possible to inject traffic to a trunk. This is arguably a configuration flaw, and the problem is often overlooked, since many engineers assume the method for implementing trunks is far more advanced and magical than it really is.</p></div></div>
<div class="sect1" title="Prevention of Attacks"><div class="titlepage"><div><div><h1 class="title"><a id="prevention_of_attacks"/>Prevention of Attacks</h1></div></div></div><p>These problems are often difficult to solve, particularly in a network that was not firmly and closely supervised through all phases of its development and expansion. Although certain high-end devices provide extended security features to counter potential attack vectors and mitigate or eliminate some of the risks, Ethernet networks were not designed to provide security, nor were many of the smart devices created to manage these networks. The attacker can easily render some or all of their features useless and downgrade the network security model to the least desirable option.<a id="IDX-CHP-7-0337" class="indexterm"/></p><p>Although there are methods and rigid practices to follow in order to secure a local Ethernet network, the complexity of this process and the additional financial cost and performance impact that doing so often carries, let alone the number of vectors to be addressed, all make it obvious that the technology was not engineered with any level of practical security in mind.</p></div>
<div class="sect1" title="Food for Thought"><div class="titlepage"><div><div><h1 class="title"><a id="food_for_thought-id4"/>Food for Thought</h1></div></div></div><p>When Ethernet was developed, it seemed reasonable to disregard any security considerations in the design decisions and to leave the burden of securing the network to higher-level architecture, encryption, and so on. Over time, however, this initial decision has begun to contribute to the overall maintenance costs of Ethernet networks and the difficulty of keeping them reasonably hack proof without sacrificing functionality in some ways.</p><p>The problem is hardly limited to the Ethernet, either. Many networks designed to be trusted based on physical-access or equipment-access criteria—including, for example, most of the world’s phone systems—are inherently and uncontrollably exposed to internal threats with little or no way to efficiently contain the exposure and control the collateral damage resulting from a single-system compromise within the grid. As the size of the network grows, and the number of interchanges increases, the probability of one of the systems being operated by a malicious user or insufficiently protected either on physical or remote access steadily approaches 1. Although traditionally, access to the backbone, rather than access to an end-user station, would be required to compromise the system—thus making the situation somewhat different from Ethernet—nowadays, Voice-over-IP (VoIP) systems quickly make up for this inconvenience, frequently allowing easy spoofing and other trickery by putting too much trust on the user endpoint side.</p></div>
<div class="chapter" title="Chapter&#xA0;8.&#xA0;Us versus Them"><div class="titlepage"><div><div><h1 class="title"><a id="us_versus_them"/>Chapter 8. Us versus Them</h1></div></div></div><div class="epigraph"><p><span class="emphasis"><em>What else can happen in the local perimeter of “our” network? Quite a bit!</em></span></p><div class="attribution"><span>—<span class="attribution"/></span></div></div><p>Local network designs, such as the Token Ring or now predominant Ethernet, were engineered under the assumption that there was no need to assure security on the level (or layer) of the technology used to transmit the data itself. When computers were first developed, users sharing a network were expected to play nice.</p><p>Although for this reason alone one might assume that the designers of Ethernet would have seen no need to incorporate full-fledged security functionality into their design, they are to be blamed for the unwarranted optimism and not foreseeing the inevitable. Ethernet simply did not leave space to easily implement integrity, confidentiality, and sender-verification mechanisms at higher-order OSI layers, devices, and applications. Subsequent protocols and communication schemes attempted to implement partial privacy and a level of undeniability of communications—but only to reach a point where we realized it is not possible to implement adequate security there without going back and reworking the link layer. The only other possibility we were left with was building computationally expensive and complex cryptographic hacks on top of the system, of which the sheer complexity contributes to a number of security problems discovered year after year.</p><p>This unfortunate and later quite intentional trend had effectively created a set of networking mechanisms that, although they perform well and are affordable, are not suitable for handling even moderately sensitive data in the presence of a hostile party (and almost all user-related data flow on a local network is sensitive). Solutions that try to address these problems—such as virtual private network (VPN) applications, encrypted encapsulation for the lucky few of the most popular web protocols, advanced switches, and so forth—are usually far more expensive and sophisticated than they could have been had security been a key factor when devising the initial concept for an Ethernet communications scheme.</p><p>Before we arrived there, we lived in partial denial for quite a while. When security became a real-world concern (with the expansion of the Internet and a sudden proliferation of system compromises), the first defenses to appear focused on the external world, while ignoring threats that could come from within the “trusted” network. But it wasn’t too long before a couple of corporate and institutional entities learned some painful lessons. With time, it became obvious that external defenses such as firewalls and intrusion detection systems alone were not enough, even when properly configured across the enterprise. The network layer was still vulnerable, allowing an insider to compromise data exchanges without exploiting the security vulnerabilities of any single system in the company.</p><p>Although you can argue that the network could be secured by deploying appropriate encryption and cryptographic identity and integrity verification mechanisms on all interfaces, that is often impractical or impossible, particularly without impacting the performance and reliability of the network and incurring significant costs (not to mention the issues of compatibility with various operating systems and applications). Besides, as I have mentioned, cryptography is not always the answer: not only is it much easier to successfully attack when the data can be seen and intercepted (replay or timing attacks, for example), but certain types of information—such as the Ethernet frame-padding flaw discussed previously—can thwart all efforts to protect the user.</p><p>In <a class="xref" href="pt02.html" title="Part II. Safe Harbor">Part II</a> of this book, we are addressing some of the threats inherent in local networks that expose information without a traditional attack ever occurring. All these problems will remain with us as long as networks use the old and tested design that is rather ill-suited for networking today.</p><p>We are now ready to move forward, but before we dive into the wild and fascinating world beyond the local perimeter, let’s glance at some other interesting (and more specific) exposure scenarios.</p><div class="sect1" title="Logical Blinkenlights and Their Unusual Application"><div class="titlepage"><div><div><h1 class="title"><a id="logical_blinkenlights_and_their_unusual"/>Logical Blinkenlights and Their Unusual Application</h1></div></div></div><p>One such example relates to the abuse of logical indicators—that is, counters, flags, and other gizmos that have no physical representation but, rather, are maintained by a computer and made available in software, commonly implemented in local networks. Logical indicators are a helpful feature that, once again, assume that the local network is to be trusted.<a id="IDX-CHP-8-0338" class="indexterm"/><a id="IDX-CHP-8-0339" class="indexterm"/></p><p>The Simple Network Management Protocol<sup>[<a href="apb.html#ftn.CHP-8-BIB-1" class="footnoteref">70</a>]</sup> (SNMP) is the most popular method for monitoring and sometimes administrating network devices. SNMP is often implemented on endpoint systems (servers and workstations) as well as network devices, such as switches, routers, and printers.</p><p>SNMP provides a means for reading (or modifying) an abstract representation of many system and application internals, operational and configuration parameters, and statistics. Using SNMP, you can query a network printer about the number of network cards it has or its uptime and then use exactly the same method to query a mainframe for the same information, even though the information needs to be obtained internally by the device in a wholly different way on each system. Hence, SNMP makes it easy to monitor and manage heterogeneous environments without implementing a multitude of native access protocols and check procedures.</p><p>Naturally, SNMP itself has plenty of implementation and deployment security issues, but that is not my point here. Even when properly implemented, this functionality can lead to a security information disclosure, such as providing read-only access to the seemingly irrelevant statistics of a network interface. (This hole is eliminated if the protocol is carefully restricted, but that is often impossible on certain types of network equipment.) A careful attacker can observe frame or packet counters on a system running SNMP and use that information to derive profiling information needed for timing attacks, which can recover interactive session information or other interesting characteristics, in a manner similar to the approach discussed in <a class="xref" href="ch01.html" title="Chapter 1. I Can Hear You Typing">Chapter 1</a>.</p><p>Whoops. But really, can this much bad happen because of this?</p><div class="sect2" title="Show Me Your Typing, and I Will Tell You Who You Are"><div class="titlepage"><div><div><h2 class="title"><a id="show_me_your_typing_comma_and_i_will_tel"/>Show Me Your Typing, and I Will Tell You Who You Are</h2></div></div></div><p>Although I’ve mentioned this class of problems several times already, and they may seem abstract, their consequences are real, even when the keystroke reconstruction vector, on which I focused in <a class="xref" href="ch01.html" title="Chapter 1. I Can Hear You Typing">Chapter 1</a>, is disregarded. For example, in a fascinating development, a group of German researchers from Institut für Bankinnovation have created a commercial product, PSYLock, that provides typing-pattern-based biometrics<sup>[<a href="apb.html#ftn.CHP-8-BIB-2" class="footnoteref">71</a>]</sup>: Using PSYLock they have been able to uniquely identify (and hence possibly track) users by examining how they use the keyboard.<a id="IDX-CHP-8-0341" class="indexterm"/><a id="IDX-CHP-8-0342" class="indexterm"/><a id="IDX-CHP-8-0343" class="indexterm"/><a id="IDX-CHP-8-0344" class="indexterm"/><a id="IDX-CHP-8-0345" class="indexterm"/><a id="IDX-CHP-8-0346" class="indexterm"/><a id="IDX-CHP-8-0340" class="indexterm"/></p><p>PSYLock relies primarily on measurements of interkeystroke timing, a trick I discussed previously. Given the ability to observe packet counters for a specific machine and calculate when, in an interactive session, a key is pressed by the user, you can identify a person regardless of which terminal they use. Some interesting applications, both malicious and supervisory in nature, can be suggested based on the application of this concept to the network layer. If the attacker knows that there is an interactive session of some remote access protocol between a station for which they can monitor SNMP switch port statistics, they can, by repeatedly polling the counter, determine when keys are pressed and, hence, draw conclusions as to what is being typed or who is typing.</p><p>A more lightweight variant of the attack, not requiring any of the advanced modeling that we had to cope with before, is also feasible. In their Bugtraq posting titled “Passive Analysis of SSH (Secure Shell) Traffic,”<sup>[<a href="apb.html#ftn.CHP-8-BIB-3" class="footnoteref">72</a>]</sup> Solar Designer and Dug Song, among other things suggest yet another possible attack, this time using the SSH protocol, a common method for connecting to a remote system. Although SSH is encrypted, in versions released prior to their research it is possible to measure the length of a password by carefully analyzing the size of an observed packet during login (the password is sent in a single chunk of data once entered by the user).</p><p>This technique could well be successfully applied to other cryptographic protocols that do not take active measures to hide the length of a password by padding it before sending. And, no suprise, the attack can be carried out simply by observing an SNMP byte counter, rather than by directly monitoring traffic.</p></div></div></div>
<div class="sect1" title="The Unexpected Bits: Personal Data All Around"><div class="titlepage"><div><div><h1 class="title"><a id="the_unexpected_bits_colon_personal_data"/>The Unexpected Bits: Personal Data All Around</h1></div></div></div><p>Yet another reason we should not be thrilled by the prospect of a hostile party peeking at our network (regardless of whether we believe the data they can see is sensitive) is that plenty of software violates the principle of least astonishment. The principle of least astonishment is a fundamental rule of software design that basically says that a program should respond to the user in ways that surprise them least—in a consistent, intuitive, predictable, or otherwise expected manner. As it turns out, many programs from several software publishers send an amazing amount of valuable information, far beyond what we might expect, often putting users in a situation they did not bargain for. As always, Microsoft Windows leads the pack of these astonishing programs and does a great job of releasing information in intentional, but often overlooked and nonobvious ways, but the friendly software giant is not alone.<a id="IDX-CHP-8-0347" class="indexterm"/><a id="IDX-CHP-8-0348" class="indexterm"/><a id="IDX-CHP-8-0349" class="indexterm"/><a id="IDX-CHP-8-0350" class="indexterm"/><a id="IDX-CHP-8-0351" class="indexterm"/><a id="IDX-CHP-8-0352" class="indexterm"/></p><p>Although few users know it, when Windows is working in a domain and is configured to use roaming profiles to enable the user to log in from a different workstation and access their personal data, large portions of the user’s registry are sent to the domain controller each time they log in or out. Although the information contained in the profile may seem quite worthless at first, it includes various personal settings and history information that can be quite interesting, including last-executed commands, last-visited web pages, and last-opened documents.<a id="IDX-CHP-8-0353" class="indexterm"/></p><p>Similarly, and perhaps even more astonishing, if a user’s home directory within the domain resides on a network drive, Windows looks up all commands entered by the user in the Run box first on the remote server and then locally. Thus, the information about all commands issued by the user is disclosed via the Server Message Block (SMB) protocol to a careful observer.<a id="IDX-CHP-8-0354" class="indexterm"/></p><p>These and many other examples make it painfully obvious that almost all network data should be assumed to be sensitive. As such, local networks at large are not particularly well suited to transport any commonly occurring data, except for specific, limited, or additionally protected setups. And we have no good way to protect this information without rolling out heavy artillery, such as cryptographic IP tunnels or similar software or by redesigning every aspect of networking from scratch.</p></div>
<div class="sect1" title="Wi-Fi Vulnerabilities"><div class="titlepage"><div><div><h1 class="title"><a id="wi-fi_vulnerabilities"/>Wi-Fi Vulnerabilities</h1></div></div></div><p>It would be unfair to close this chapter and ignore the problems with the wireless replacement to Ethernet: wi-fi.<a id="IDX-CHP-8-0358" class="indexterm"/><a id="IDX-CHP-8-0359" class="indexterm"/><a id="IDX-CHP-8-0360" class="indexterm"/><a id="IDX-CHP-8-0355" class="indexterm"/><a id="IDX-CHP-8-0356" class="indexterm"/><a id="IDX-CHP-8-0357" class="indexterm"/></p><p>Wireless networks based on the IEEE 802.11 protocol are gaining momentum in the corporate world, as well as among ordinary home users. Unfortunately, even long before gaining widespread acceptance, and even though they were designed with the intent to maintain a level of additional security over wired hookups, wi-fi proved fairly difficult to deploy properly, perhaps because it attempted to follow in the footsteps of its older brother a bit too closely.</p><p>The 802.11 standard is, in its operating principles, not that much different from Ethernet. It uses a traditional “one can talk, others listen” media access control scheme, the only difference being that instead of a pair of wires, the carrier of the signal is now just a designated radio frequency. Which brings us to 802.11’s first problem.</p><p>In May 2004, the Queensland University of Technology’s Information Security Research Centre (ISRC) announced its findings that any 802.11 network in any enterprise could be brought to a grinding halt in a matter of seconds simply by transmitting a signal that inhibits other parties from trying to talk. Naturally, the same is true for Ethernet, except that you must be able to connect to a network plug first, which of course makes the attacker much easier to track and the problem easier to solve. You can simply check the switch then follow the cable. This attack is not exactly a surprise, but it’s not what business adopters expected either.</p><p>That’s not where the problems end. Where the 802.11 standard attempted to thwart carrier-level attacks, it actually failed miserably. The Wired Equivalent Privacy (WEP) mechanism was designed for wi-fi networks to provide a level of protection against eavesdropping on network sessions by external parties, thus providing security roughly comparable to traditional LANs. However, a number of design flaws in the WEP scheme were found in 2001 by researchers from the University of California and Zero Knowledge Systems, which proved the scheme grossly inappropriate. Regrettably, even by that time wi-fi had been deployed widely enough to make necessary modifications difficult to implement.<sup>[<a href="apb.html#ftn.CHP-8-BIB-4" class="footnoteref">73</a>]</sup><a id="IDX-CHP-8-0361" class="indexterm"/></p><p>To add insult to injury, use of WEP is optional, and most wireless network devices have WEP turned off; they’re ready to accept and relay any traffic they receive. Although this is generally acceptable with wired networks, where an additional layer of security is provided on the physical level, wireless networks are open to any random person within range.</p><div class="figure"><a id="tracy_reedas_warflying_adventure_open_pa"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e4990"/><img src="httpatomoreillycomsourcenostarchimages1138048.png.jpg" alt="Tracy Reed’s warflying adventure (courtesy of Tracy Reed of Copilot Consulting at treed@copilotconsulting.com)"/></div></div><p class="title">Figure 8-1. Tracy Reed’s warflying adventure (courtesy of Tracy Reed of Copilot Consulting at <span class="email"><a class="email" href="mailto:treed@copilotconsulting.com">treed@copilotconsulting.com</a></span>)</p></div><p>The practice of wardriving—equipping a car with a wi-fi–capable laptop and going on urban network-finding expeditions—became extremely popular once it was discovered that a majority of large businesses—particularly in large shopping malls and commercial districts in every city—have partly or fully open wireless networks. The abuse is often quite trivial, ranging from networking for free to sending spam or conducting remote attacks through the victim’s network, but the risk of a network being penetrated from inside by a skilled attacker is real.</p><p>What is the true scale of the problem? Suffice it to say that at some point wardriving became passé with the birth of warflying (wardriving, but with a plane rather than a ground vehicle). In 2002, Tracy Reed of Copilot Consulting decided to fly around and vicinity with a wireless scanner. Cruising at 1,500 feet, he managed to find nearly 400 access points with default configurations and likely free network access to the Internet or internal corporate networks for any person nearby (see <a class="xref" href="ch08s03.html#tracy_reedas_warflying_adventure_open_pa" title="Figure 8-1. Tracy Reed’s warflying adventure (courtesy of Tracy Reed of Copilot Consulting at treed@copilotconsulting.com)">Figure 8-1</a> and <a class="xref" href="ch08s03.html#silicon_valley_warflying" title="Figure 8-2. Silicon Valley warflying">Figure 8-2</a>). Only 23 percent of the devices scanned were protected by WEP (which is, in general, easy to crack anyway) or better mechanisms.</p><p>Go figure.</p><div class="figure"><a id="silicon_valley_warflying"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e5009"/><img src="httpatomoreillycomsourcenostarchimages1138050.png.jpg" alt="Silicon Valley warflying"/></div></div><p class="title">Figure 8-2. Silicon Valley warflying</p></div></div></body></html>