["```\nauto addr, reg, val;   // legal, multiple variables declared with no initializers\nauto count = 0;        // declaration with initialization\n```", "```\nextern outsideGlobal;\n\nstatic main() {\n   extern insideGlobal;\n   outsideGlobal = \"Global\";\n   insideGlobal = 1;\n}\n```", "```\nresult = (x >> 1) & 0x7fffffff;  //set most significant bit to zero\n```", "```\nauto str = \"String to slice\";\nauto s1, s2, s3, s4;\ns1 = str[7:9];     // \"to\"\ns2 = str[:6];      // \"String\", omitting start index starts at 0\ns3 = str[10:];     // \"slice\", omitting end index goes to end of string\ns4 = str[5];       // \"g\", single element slice, similar to array element access\n```", "```\nauto i;\nfor (i = 0; i < 10; i += 2) {}     // illegal, += is not supported\nfor (i = 0; i < 10; i = i + 2) {}  // legal\n```", "```\nif (1) {    //always true\n   auto x;\n   x = 10;\n}\nelse {      //never executes\n   auto y;\n   y = 3;\n}\nMessage(\"x = %d\\n\", x);   // x remains accessible after its block terminates\nMessage(\"y = %d\\n\", y);   // IDC allows this even though the else did not execute\n```", "```\nstatic my_func(x, y, z) {\n   //declare any local variables first\n   auto a, b, c;\n   //add statements to define the function's behavior\n   // ...\n}\n```", "```\nauto q = 0, r = 1, s = 2;\nmy_func(q, r, s);   //all three arguments passed using call-by-value\n                    //upon return, q, r, and s hold 0, 1, and 2 respectively\nmy_func(q, &r, s);  //q and s passed call-by-value, r is passed call-by-reference\n                    //upon return, q, and s hold 0 and 2 respectively, but r may have\n                    //changed. In this second case, any changes\n that my_func makes to its\n                    //formal parameter y will be reflected in the\n caller as changes to r\n```", "```\nstatic getFunc() {\n   return Message;  //return the built-in Message function as a result\n}\n\nstatic useFunc(func, arg) {  //func here is expected to be a function reference\n   func(arg);\n}\n\nstatic main() {\n   auto f = getFunc();\n   f(\"Hello World\\n\");       //invoke the returned function f\n   useFunc(f, \"Print me\\n\"); //no need for & operator,\n functions always call-by-reference\n}\n```", "```\nclass ExampleClass {\n   ExampleClass(x, y) {   //constructor\n      this.a = x;         //all ExampleClass objects have data member a\n      this.b = y;         //all ExampleClass objects have data member b\n   }\n   ~ExampleClass() {      //destructor\n   }\n   foo(x) {\n      this.a = this.a + x;\n   }\n   //...   other member functions as desired\n};\n\nstatic main() {\n   ExampleClass ex;            //DON'T DO THIS!! This is not\n a valid variable declaration\n   auto ex = ExampleClass(1, 2);   //reference variables are initialized by assigning\n                                   //the result of calling the class constructor\n   ex.foo(10);                 //dot notation is used to access members\n   ex.z = \"string\";            //object ex now has a member z, BUT the class does not\n}\n```", "```\n#include <idc.idc>    // useful include directive\n//declare additional functions as required\nstatic main() {\n   //do something fun here\n}\n```", "```\n#include <idc.idc>\n#include <my_amazing_script.idc>\nstatic main() {\n   AddHotkey(\"z\", \"MyAmazingFunc\");  //Now 'z' invokes MyAmazingFunc\n}\n```", "```\n#include <idc.idc>\nstatic main() {\n   auto addr, end, args, locals, frame, firstArg, name, ret;\n   addr = 0;\n   for (addr = NextFunction(addr); addr != BADADDR; addr = NextFunction(addr)) {\n      name = Name(addr);\n      end = GetFunctionAttr(addr, FUNCATTR_END);\n      locals = GetFunctionAttr(addr, FUNCATTR_FRSIZE);\n      frame = GetFrame(addr);     // retrieve a handle to the function's stack frame\n      ret = GetMemberOffset(frame, \" r\");  // \" r\" is the name of the return address\n      if (ret == −1) continue;\n      firstArg = ret + 4;\n      args = GetStrucSize(frame) - firstArg;\n      Message(\"Function: %s, starts at %x, ends at %x\\n\", name, addr, end);\n      Message(\"   Local variable area is %d bytes\\n\", locals);\n      Message(\"   Arguments occupy %d bytes (%d args)\\n\", args, args / 4);\n   }\n}\n```", "```\n#include <idc.idc>\n  static main() {\n     auto func, end, count, inst;\n    func = GetFunctionAttr(ScreenEA(), FUNCATTR_START);\n     if (func != −1) {\n       end = GetFunctionAttr(func, FUNCATTR_END);\n        count = 0;\n        inst = func;\n        while (inst < end) {\n             count++;\n          inst = FindCode(inst, SEARCH_DOWN | SEARCH_NEXT);\n        }\n        Warning(\"%s contains %d instructions\\n\", Name(func), count);\n     }\n     else {\n        Warning(\"No function found at location %x\", ScreenEA());\n     }\n  }\n```", "```\n#include <idc.idc>\nstatic main() {\n  auto func, end, target, inst, name, flags, xref;\n  flags = SEARCH_DOWN | SEARCH_NEXT;\n  func = GetFunctionAttr(ScreenEA(), FUNCATTR_START);\n  if (func != −1) {\n    name = Name(func);\n    end = GetFunctionAttr(func, FUNCATTR_END);\n    for (inst = func; inst < end; inst = FindCode(inst, flags)) {\n      for (target = Rfirst(inst); target != BADADDR; target = Rnext(inst, target)) {\n        xref = XrefType();\n        if (xref == fl_CN || xref == fl_CF) {\n          Message(\"%s calls %s from 0x%x\\n\", name, Name(target), inst);\n        }\n      }\n    }\n  }\n  else {\n    Warning(\"No function found at location %x\", ScreenEA());\n  }\n}\n```", "```\nchar *strcpy(char *dest, const char *source);\n```", "```\n#include <idc.idc>\n  static list_callers(bad_func) {\n     auto func, addr, xref, source;\n    func = LocByName(bad_func);\n     if (func == BADADDR) {\n        Warning(\"Sorry, %s not found in database\", bad_func);\n     }\n     else {\n       for (addr\n = RfirstB(func); addr != BADADDR; addr = RnextB(func, addr)) {\n         xref = XrefType();\n         if (xref == fl_CN || xref == fl_CF) {\n             source = GetFunctionName(addr);\n             Message\n(\"%s is called from 0x%x in %s\\n\", bad_func, addr, source);\n           }\n        }\n     }\n  }\n  static main() {\n     list_callers(\"_strcpy\");\n     list_callers(\"_sprintf\");\n  }\n```", "```\n#include <idc.idc>\nstatic main() {\n   auto entryPoints, i, ord, addr, name, purged, file, fd;\n   file = AskFile(1, \"*.idt\", \"Select IDT save file\");\n   fd = fopen(file, \"w\");\n   entryPoints = GetEntryPointQty();\n   fprintf(fd, \"ALIGNMENT 4\\n\");\n   fprintf(fd, \"0 Name=%s\\n\", GetInputFile());\n   for (i = 0; i < entryPoints; i++) {\n      ord = GetEntryOrdinal(i);\n      if (ord == 0) continue;\n      addr = GetEntryPoint(ord);\n      if (ord == addr) {\n         continue; //entry point has no ordinal\n      }\n      name = Name(addr);\n      fprintf(fd, \"%d Name=%s\", ord, name);\n      purged = GetFunctionAttr(addr, FUNCATTR_ARGSIZE);\n      if (purged > 0) {\n         fprintf(fd, \" Pascal=%d\", purged);\n      }\n      fprintf(fd, \"\\n\");\n   }\n}\n```", "```\n.text:08048894                 push    0               ; protocol\n.text:08048896                 push    1               ; type\n.text:08048898                 push    2               ; domain\n.text:0804889A                 call    _socket\n```", "```\n.text:080487AD                 mov     [esp+8], 0\n.text:080487B5                 mov     [esp+4], 1\n.text:080487BD                 mov     [esp], 2\n.text:080487C4                 call    _socket\n```", "```\n#include <idc.idc>\nstatic main() {\n  auto addr, op, end, idx;\n  auto func_flags, type, val, search;\n  search = SEARCH_DOWN | SEARCH_NEXT;\n  addr = GetFunctionAttr(ScreenEA(), FUNCATTR_START);\n  func_flags = GetFunctionFlags(addr);\n  if (func_flags & FUNC_FRAME) {  //Is this an ebp-based frame?\n    end = GetFunctionAttr(addr, FUNCATTR_END);\n    for (; addr < end && addr != BADADDR; addr = FindCode(addr, search)) {\n      type = GetOpType(addr, 0);\n      if (type == 3) {  //Is this a register indirect operand?\n        if (GetOperandValue(addr, 0) == 4) {   //Is the register esp?\n          MakeComm(addr, \"arg_0\");  //[esp] equates to arg_0\n        }\n      }\n      else if (type == 4) {  //Is this a register + displacement operand?\n        idx = strstr(GetOpnd(addr, 0), \"[esp\"); //Is the register esp?\n        if (idx != −1) {\n          val = GetOperandValue(addr, 0);   //get the displacement\n          MakeComm(addr, form(\"arg_%d\", val));  //add a comment\n        }\n      }\n    }\n  }\n}\n```", "```\n.text:080487AD                 mov     [esp+8], 0   ; arg_8\n.text:080487B5                 mov     [esp+4], 1   ; arg_4\n.text:080487BD                 mov     [esp], 2    ; arg_0\n.text:080487C4                 call    _socket\n```", "```\n.text:080487AD                 mov     [esp+8], 0   ;  int protocol\n.text:080487B5                 mov     [esp+4], 1   ;  int type\n.text:080487BD                 mov     [esp], 2    ;  int domain\n.text:080487C4                 call    _socket\n```", "```\n.text:08049EDE                 mov     [ebp+var_4], 0\n.text:08049EE5\n.text:08049EE5 loc_8049EE5:\n.text:08049EE5                 cmp     [ebp+var_4], 3C1h\n.text:08049EEC                 ja      short locret_8049F0D\n.text:08049EEE                 mov     edx, [ebp+var_4]\n.text:08049EF1                 add     edx, 804B880h\n.text:08049EF7                 mov     eax, [ebp+var_4]\n.text:08049EFA                 add     eax, 804B880h\n.text:08049EFF                 mov     al, [eax]\n.text:08049F01                 xor     eax, 4Bh\n.text:08049F04                 mov     [edx], al\n.text:08049F06                 lea     eax, [ebp+var_4]\n.text:08049F09                 inc     dword ptr [eax]\n.text:08049F0B                 jmp     short loc_8049EE5\n```", "```\nauto var_4, edx, eax, al;\nvar_4 = 0;\nwhile (var_4 <= 0x3C1) {\n   edx = var_4;\n   edx = edx + 0x804B880;\n   eax = var_4;\n   eax = eax + 0x804B880;\n   al = Byte(eax);\n   al = al ^ 0x4B;\n   PatchByte(edx, al);\n   var_4++;\n}\n```", "```\nauto var_4, addr;\nfor (var_4 = 0; var_4 <= 0x3C1; var_4++) {\n   addr = 0x804B880 + var_4;\n   PatchByte(addr, Byte(addr) ^ 0x4B);\n}\n```", "```\n# ln -s /usr/lib/libpython2.7.so.1.0 /usr/lib/libpython2.6.so.1\n```", "```\nfuncs = Functions()\nfor f in funcs:\n   name = Name(f)\n   end = GetFunctionAttr(f, FUNCATTR_END)\n   locals = GetFunctionAttr(f, FUNCATTR_FRSIZE)\n   frame = GetFrame(f)     # retrieve a handle to the function's stack frame\n   if frame is None: continue\n   ret = GetMemberOffset(frame, \" r\")  # \" r\" is the name of the return address\n   if ret == −1: continue\n   firstArg = ret + 4\n   args = GetStrucSize(frame) - firstArg\n   Message(\"Function: %s, starts at %x, ends at %x\\n\" % (name, f, end))\n   Message(\"   Local variable area is %d bytes\\n\" % locals)\n   Message(\"   Arguments occupy %d bytes (%d args)\\n\" % (args, args / 4))\n```", "```\nfrom idaapi import *\nfunc = get_func(here())  # here() is synonymous with ScreenEA()\nif not func is None:\n   fname = Name(func.startEA)\n   count = 0\n   for i in FuncItems(func.startEA): count = count + 1\n   Warning(\"%s contains %d instructions\\n\" % (fname,count))\nelse:\n   Warning(\"No function found at location %x\" % here())\n```", "```\nfrom idaapi import *\nfunc = get_func(here())\nif not func is None:\n   fname = Name(func.startEA)\n   items = FuncItems(func.startEA)\n   for i in items:\n      for xref in XrefsFrom(i, 0):\n         if xref.type == fl_CN or xref.type == fl_CF:\n            Message(\"%s calls %s from 0x%x\\n\" % (fname, Name(xref.to), i))\nelse:\n   Warning(\"No function found at location %x\" % here())\n```", "```\nfile = AskFile(1, \"*.idt\", \"Select IDT save file\")\nwith open(file, 'w') as fd:\n   fd.write(\"ALIGNMENT 4\\n\")\n   fd.write(\"0 Name=%s\\n\" % GetInputFile())\n   for i in range(GetEntryPointQty()):\n      ord = GetEntryOrdinal(i)\n      if ord == 0: continue\n      addr = GetEntryPoint(ord)\n      if ord == addr: continue   #entry point has no ordinal\n      fd.write(\"%d Name=%s\" % (ord, Name(addr)))\n      purged = GetFunctionAttr(addr, FUNCATTR_ARGSIZE)\n      if purged > 0:\n         fd.write(\" Pascal=%d\" % purged)\n      fd.write(\"\\n\")\n```", "```\n#define USE_DANGEROUS_FUNCTIONS\n#include <ida.hpp>\n```", "```\n#ifdef __EA64__\n  typedef ulonglong nodeidx_t;\n  #else\n  typedef ulong nodeidx_t;\n  #endif\n  class netnode {\n    netnode();\n    netnode(nodeidx_t num);\n    netnode(const char *name, size_t namlen=0, bool do_create=false);\n    bool create(const char *name, size_t namlen=0);\n    bool create();\n     //... remainder of netnode class follows\n  };\n  netnode n0;                       //uses\n  netnode n1(0x00401110);           //uses\n  netnode n2(\"$ node 2\");           //uses\n  netnode n3(\"$ node 3\", 0, true);  //uses\n```", "```\nif (BADNODE == (nodeidx_t)n2) {\n   n2.create(\"$ node 2\");\n}\n```", "```\nn0.create();  //assign an internally generated netnodenumber to n0\n```", "```\nnetnode n(\"$ idabook\", 0, true);  //create the netnode if it doesn't exist\nsval_t index = 1000;  //sval_t is a 32 bit type, this example uses 32-bit indexes\nulong value = 0x12345678;\nn.altset(index, value);   //store value into the 'A' array at index\nvalue = n.altval(index);  //retrieve value from the 'A' array at index\nn.altset(index, value, (char)3);  //store into array 3\nvalue = n.altval(index, (char)3); //read from array 3\n```", "```\nnetnode n(\"$ idabook\", 0, true);\nuchar index = 80;      //this example uses 8-bit index values\nulong value = 0x87654321;\nn.altset_idx8(index, value, 'A');  //store, no default tags with xxx_idx8 functions\nvalue = n.altval_idx8(index, 'A'); //retrieve value from the 'A' array at index\nn.altset_idx8(index, value, (char)3);  //store into array 3\nvalue = n.altval_idx8(index, (char)3); //read from array 3\n```", "```\nnetnode n(\"$ idabook\", 0, true);  //create the netnode if it doesn't exist\n\nchar *string_data = \"example supval string data\";\nchar binary_data[] = {0xfe, 0xdc, 0x4e, 0xc7, 0x90, 0x00, 0x13, 0x8a,\n                      0x33, 0x19, 0x21, 0xe5, 0xaa, 0x3d, 0xa1, 0x95};\n\n//store binary_data into the 'S' array at index 1000, we must supply a\n//pointer to data and the size of the data\nn.supset(1000, binary_data, sizeof(binary_data));\n\n//store string_data into the 'S' array at index 1001\\.  If no size is supplied,\n//or size is zero, the data size is computed as: strlen(data) + 1\nn.supset(1001, string_data);\n//store into an array other than 'S' (200 in this case) at index 500\nn.supset(500, binary_data, sizeof(binary_data), (char)200);\n```", "```\n//determine size of element 1000 in 'S' array.  The NULL pointer indicates\n//that we are not supplying an output buffer\nint len = n.supval(1000, NULL, 0);\n\nchar *outbuf = new char[len];  //allocate a buffer of sufficient size\nn.supval(1000, outbuf, len);   //extract data from the supval\n\n//determine size of element 1001 in 'S' array.  The NULL pointer indicates\n//that we are not supplying an output buffer.\nlen = n.supstr(1001, NULL, 0);\n\nchar *outstr = new char[len];  //allocate a buffer of sufficient size\nn.supval(1001, outstr, len);   //extract data from the supval\n\n//retrieve a supval from array 200, index 500\nchar buf[1024];\nlen = n.supval(500, buf, sizeof(buf), (char)200);\n```", "```\nbool altset(sval_t alt, nodeidx_t value, char tag=atag) {\n   return supset(alt, &value, sizeof(value), tag);\n}\n```", "```\nnetnode n(\"$ idabook\", 0, true);\n//Iterate altvals first to last\nfor (nodeidx_t idx = n.alt1st(); idx != BADNODE; idx = n.altnxt(idx)) {\n   ulong val = n.altval(idx);\n   msg(\"Found altval['A'][%d] = %d\\n\", idx, val);\n}\n\n//Iterate altvals last to first\nfor (nodeidx_t idx = n.altlast(); idx != BADNODE; idx = n.altprev(idx)) {\n   ulong val = n.altval(idx);\n   msg(\"Found altval['A'][%d] = %d\\n\", idx, val);\n}\n```", "```\nnetnode n(\"$ idabook\", 0, true);\nn.kill();                        //entire contents of n are deleted\n```", "```\nnetnode n(\"$ idabook\", 0, true);\n n.altdel(100);       //delete item 100 from the default altval array ('A')\n  n.altdel(100, (char)3); //delete item 100 from altval array 3\n n.altdel();          //delete the entire contents of the default altval array\n  n.altdel_all('A');      //alternative to delete default altval array contents\n  n.altdel_all((char)3);  //delete the entire contents of altval array 3;\n```", "```\nfor (func_t *f = get_next_func(0); f != NULL; f = get_next_func(f->startEA)) {\n   char fname[1024];\n   get_func_name(f->startEA, fname, sizeof(fname));\n   msg(\"%08x: %s\\n\", f->startEA, fname);\n}\n```", "```\nfor (int idx = 0; idx < get_func_qty(); idx++) {\n   char fname[1024];\n   func_t *f = getn_func(idx);\n   get_func_name(f->startEA, fname, sizeof(fname));\n   msg(\"%08x: %s\\n\", f->startEA, fname);\n}\n```", "```\n int a = funcs.get_next_area(0);\n  while (a != −1) {\n     char fname[1024];\n    func_t *f = (func_t*)funcs.getn_area(a);  // getn_area returns an area_t\n     get_func_name(f->startEA, fname, sizeof(fname));\n     msg(\"%08x: %s\\n\", f->startEA, fname);\n    a = funcs.get_next_area(f->startEA);\n  }\n```", "```\nfunc_t *func = get_func(get_screen_ea());  //get function at cursor location\nmsg(\"Local variable size is %d\\n\", func->frsize);\nmsg(\"Saved regs size is %d\\n\", func->frregs);\nstruc_t *frame = get_frame(func);          //get pointer to stack frame\nif (frame) {\n   size_t ret_addr = func->frsize + func->frregs;  //offset to return address\n   for (size_t m = 0; m < frame->memqty; m++) {    //loop through members\n      char fname[1024];\n      get_member_name(frame->members[m].id, fname, sizeof(fname));\n      if (frame->members[m].soff < func->frsize) {\n         msg(\"Local variable \");\n      }\n      else if (frame->members[m].soff > ret_addr) {\n         msg(\"Parameter \");\n      }\n      msg(\"%s is at frame offset %x\\n\", fname, frame->members[m].soff);\n      if (frame->members[m].soff == ret_addr) {\n         msg(\"%s is the saved return address\\n\", fname);\n      }\n   }\n}\n```", "```\nvoid list_callers(char *bad_func) {\n   char name_buf[MAXNAMELEN];\n   ea_t func = get_name_ea(BADADDR, bad_func);\n   if (func == BADADDR) {\n      warning(\"Sorry, %s not found in database\", bad_func);\n   }\n   else {\n      for (ea_t addr = get_first_cref_to(func); addr != BADADDR;\n           addr = get_next_cref_to(func, addr)) {\n         char *name = get_func_name(addr, name_buf, sizeof(name_buf));\n         if (name) {\n            msg(\"%s is called from 0x%x in %s\\n\", bad_func, addr, name);\n         }\n         else {\n            msg(\"%s is called from 0x%x\\n\", bad_func, addr);\n         }\n      }\n   }\n}\n```", "```\nstruct xrefblk_t {\n    ea_t from;     // the referencing address - filled by first_to(),next_to()\n    ea_t to;       // the referenced address - filled by first_from(), next_from()\n    uchar iscode;  // 1-is code reference; 0-is data reference\n    uchar type;    // type of the last returned reference\n    uchar user;    // 1-is user defined xref, 0-defined by ida\n\n    //fill the \"to\" field with the first address to which \"from\" refers.\n   bool first_from(ea_t from, int flags);\n\n    //fill the \"to\" field with the next address to which \"from\" refers.\n    //This function assumes a previous call to first_from.\n   bool next_from(void);\n\n    //fill the \"from\" field with the first address that refers to \"to\".\n   bool first_to(ea_t to,int flags);\n\n    //fill the \"from\" field with the next address that refers to \"to\".\n    //This function assumes a previous call to first_to.\n   bool next_to(void);\n  };\n```", "```\n#define XREF_ALL        0x00            // return all references\n#define XREF_FAR        0x01            // don't return ordinary flow xrefs\n#define XREF_DATA       0x02            // return data references only\n```", "```\nvoid list_callers(char *bad_func) {\n     char name_buf[MAXNAMELEN];\n     ea_t func = get_name_ea(BADADDR, bad_func);\n     if (func == BADADDR) {\n        warning(\"Sorry, %s not found in database\", bad_func);\n     }\n     else {\n        xrefblk_t xr;\n        for (bool ok = xr.first_to(func, XREF_ALL); ok; ok = xr.next_to()) {\n          if (xr.type != fl_CN && xr.type != fl_CF) continue;\n           char *name = get_func_name(xr.from, name_buf, sizeof(name_buf));\n           if (name) {\n              msg(\"%s is called from 0x%x in %s\\n\", bad_func, xr.from, name);\n           }\n           else {\n              msg(\"%s is called from 0x%x\\n\", bad_func, xr.from);\n           }\n        }\n     }\n  }\n```", "```\nclass plugin_t {\npublic:\n  int version;          // Should be equal to IDP_INTERFACE_VERSION\n  int flags;            // Features of the plugin\n  int (idaapi* init)(void); // Initialize plugin\n  void (idaapi* term)(void);   // Terminate plugin. This function will be called\n                            // when the plugin is unloaded. May be NULL.\n  void (idaapi* run)(int arg); // Invoke plugin\n  char *comment;               // Long comment about the plugin\n  char *help;           // Multiline help about the plugin\n  char *wanted_name;    // The preferred short name of the plugin\n  char *wanted_hotkey;  // The preferred hotkey to run the plugin\n};\n```", "```\nint idaapi idaboook_plugin_init(void);\nvoid idaapi idaboook_plugin_term(void);\nvoid idaapi idaboook_plugin_run(int arg);\n\nchar idabook_comment[] = \"This is an example of a plugin\";\nchar idabook_name[] = \"Idabook\";\nchar idabook_hotkey = \"Alt-F9\";\n\nplugin_t PLUGIN = {\n   IDP_INTERFACE_VERSION, 0, idaboook_plugin_init, idaboook_plugin_term,\n    idaboook_plugin_run, idabook_comment, NULL, idabook_name, idabook_hotkey\n};\n```", "```\nint idaapi mips_init() {\n   if (ph.id != PLFM_MIPS) return PLUGIN_SKIP;\n   else return PLUGIN_OK;  //or, alternatively PLUGIN_KEEP\n}\n```", "```\n//typedef for event hooking callback functions (from loader.hpp)\ntypedef int idaapi hook_cb_t(void *user_data, int notification_code, va_list va);\n//prototype for  hook_to_notification_point (from loader.hpp)\nbool hook_to_notification_point(hook_type_t hook_type,\n                                hook_cb_t *callback,\n                                void *user_data);\nint idaapi idabook_plugin_init() {\n   //Example call to  hook_to_notification_point\n   hook_to_notification_point(HT_IDB, idabook_database_cb, NULL);\n}\n```", "```\nint idabook_database_cb(void *user_data, int notification_code, va_list va) {\n     ea_t addr;\n     ulong original, current;\n     switch (notification_code) {\n        case idb_event::byte_patched:\n         addr = va_arg(va, ea_t);\n           current = get_byte(addr);\n           original = get_original_byte(addr);\n           msg(\"%x was patched to %x.  Original value was %x\\n\",\n                addr, current, original);\n           break;\n     }\n     return 0;\n  }\n```", "```\nvoid idaapi idabook_plugin_term() {\n   unhook_from_notification_point(HT_IDB, idabook_database_cb, NULL);\n}\n```", "```\nvoid idaapi idabook_plugin_run(int arg) {\n   msg(\"idabook plugin activated!\\n\");\n}\n```", "```\nvoid idaapi extended_plugin_run(int arg) {\n   func_t *func = get_func(get_screen_ea());  //get function at cursor location\n   msg(\"Local variable size is %d\\n\", func->frsize);\n   msg(\"Saved regs size is %d\\n\", func->frregs);\n   struc_t *frame = get_frame(func);          //get pointer to stack frame\n   if (frame) {\n      size_t ret_addr = func->frsize + func->frregs;  //offset to return address\n      for (size_t m = 0; m < frame->memqty; m++) {    //loop through members\n         char fname[1024];\n         get_member_name(frame->members[m].id, fname, sizeof(fname));\n         if (frame->members[m].soff < func->frsize) {\n            msg(\"Local variable \");\n         }\n         else if (frame->members[m].soff > ret_addr) {\n            msg(\"Parameter \");\n         }\n         msg(\"%s is at frame offset %x\\n\", fname, frame->members[m].soff);\n         if (frame->members[m].soff == ret_addr) {\n            msg(\"%s is the saved return address\\n\", fname);\n         }\n      }\n   }\n}\n```", "```\n#Set this variable to point to your SDK directory\nIDA_SDK=../../\n\nPLATFORM=$(shell uname | cut -f 1 -d _)\n\nifneq \"$(PLATFORM)\" \"MINGW32\"\nIDA=$(HOME)/ida\nendif\n\n#Set this variable to the desired name of your compiled plugin\nPROC=idabook_plugin\n\nifeq \"$(PLATFORM)\" \"MINGW32\"\nPLATFORM_CFLAGS=-D__NT__ -D__IDP__ -DWIN32 -Os -fno-rtti\nPLATFORM_LDFLAGS=-shared -s\nLIBDIR=$(shell find ../../ -type d | grep -E \"(lib|lib/)gcc.w32\")\nifeq ($(strip $(LIBDIR)),)\nLIBDIR=../../lib/x86_win_gcc_32\nendif\nIDALIB=$(LIBDIR)/ida.a\nPLUGIN_EXT=.plw\n\nelse ifeq \"$(PLATFORM)\" \"Linux\"\nPLATFORM_CFLAGS=-D__LINUX__\nPLATFORM_LDFLAGS=-shared -s\nIDALIB=-lida\nIDADIR=-L$(IDA)\nPLUGIN_EXT=.plx\n\nelse ifeq \"$(PLATFORM)\" \"Darwin\"\nPLATFORM_CFLAGS=-D__MAC__\nPLATFORM_LDFLAGS=-dynamiclib\nIDALIB=-lida\nIDADIR=-L$(IDA)/idaq.app/Contents/MacOs\nPLUGIN_EXT=.pmc\nendif\n\n#Platform specific compiler flags\nCFLAGS=-Wextra -Os $(PLATFORM_CFLAGS)\n\n#Platform specific ld flags\nLDFLAGS=$(PLATFORM_LDFLAGS)\n\n#specify any additional libraries that you may need\nEXTRALIBS=\n\n# Destination directory for compiled plugins\nOUTDIR=$(IDA_SDK)bin/plugins/\n\n#list out the object files in your project here\nOBJS=idabook_plugin.o\n\nBINARY=$(OUTDIR)$(PROC)$(PLUGIN_EXT)\n\nall: $(OUTDIR) $(BINARY)\n\nclean:\n    -@rm *.o\n    -@rm $(BINARY)\n\n$(OUTDIR):\n    -@mkdir -p $(OUTDIR)\n\nCC=g++\nINC=-I$(IDA_SDK)include/\n\n%.o: %.cpp\n    $(CC) -c $(CFLAGS) $(INC) $< -o $@\n\nLD=g++\n\n$(BINARY): $(OBJS)\n    $(LD) $(LDFLAGS) -o $@ $(OBJS) $(IDADIR) $(IDALIB) $(EXTRALIBS)\n\n#change idabook_plugin below to the name of your plugin, make sure to add any\n#additional files that your plugin is dependent on\nidabook_plugin.o: idabook_plugin.cpp\n```", "```\n; Semicolons introduce comments.  A plugin configuration line consists\n; of three required components and two optional components\n;  plugin_name  plugin_file  hotkey  [integer run arg]  [DEBUG]\nThe_IdaBook_Plugin   idabook_plugin   Alt-F2  1\nIdaBook_Plugin_Alt   idabook_plugin   Alt-F3  2\n```", "```\ntypedef error_t (idaapi *idc_func_t)(idc_value_t *argv, idc_value_t *res);\nbool set_idc_func_ex(const char *idc_name, idc_func_t idc_impl,\n                     const char *args, int extfunc_flags);\n```", "```\nint idaapi init(void) {\n    static const char idc_str_args[] = { VT_STR2, 0 };\n    set_idc_func_ex(\"CreateNetnode\", idc_create_netnode, idc_str_args, 0);\n      return PLUGIN_KEEP;\n  }\n```", "```\n/*\n   * native implementation of CreateNetnode.  Returns the id of the new netnode\n   * this id can be used with all of the existing IDC Array functions.\n   */\n  static error_t idaapi idc_create_netnode(idc_value_t *argv, idc_value_t *res) {\n   res->vtype = VT_LONG;           //result type is a netnode index\n   if (argv[0].vtype == VT_STR2) {  //verify we have the proper input type\n      netnode n(argv[0].c_str(), 0, true);  //create the netnode\n      res->num = (nodeidx_t)n;          //set the result value\n     }\n     else {\n      res->num = −1;         //If the user supplies a bad argument we fail\n     }\n     return eOk;\n  }\n```", "```\nvoid idaapi term(void) {}   //nothing to do on termination\n  void idaapi run(int arg) {} //nothing to do and no way to activate\n\n  plugin_t PLUGIN = {\n    IDP_INTERFACE_VERSION,\n    //this plugin loads at IDA startup, does not get listed on the Edit>Plugins menu\n    //and modifies the database\n   PLUGIN_FIX | PLUGIN_HIDE | PLUGIN_MOD,  // plugin flags\n    init,                 // initialize\n    term,                 // terminate. this pointer may be NULL.\n    run,                  // invoke plugin\n    \"\",                   // long comment about the plugin\n    \"\",                   // multiline help about the plugin\n    \"\",                   // the preferred short name of the plugin\n    \"\"                    // the preferred hotkey to run the plugin\n  };\n```", "```\nauto n, val;\nn = CreateNetnode(\"$ imports\");       //no $ idc_array prefix will be added\nval = GetArrayElement(AR_STR, n, 0);  //get element zero\n```", "```\nulong choose(void *obj,\n             int width,\n             ulong (idaapi *sizer)(void *obj),\n             char *(idaapi *getline)(void *obj, ulong n, char *buf),\n             const char *title);\n```", "```\n#include <kernwin.hpp>\n\n//The sample data to be displayed\nint data[] = {0xdeafbeef, 0xcafebabe, 0xfeedface, 0};\n\n//this example expects obj to point to a zero\n//terminated array of non-zero integers.\nulong idaapi idabook_sizer(void *obj) {\n   int *p = (int*)obj;\n   int count = 0;\n   while (*p++) count++;\n   return count;\n}\n\n/*\n * obj In this example obj is expected to point to an array of integers\n * n indicates which line (1..n) of the display is being formatted.\n *   if n is zero, the header line is being requested.\n * buf is a pointer to the output buffer for the formatted data. IDA will\n *     call this with a buffer of size MAXSTR (1024).\n */\nchar * idaapi idabook_getline(void *obj, ulong n, char *buf) {\n   int *p = (int*)obj;\n   if (n == 0) { //This is the header case\n      qstrncpy(buf, \"Value\", strlen(\"Value\") + 1);\n   }\n   else { //This is the data case\n      qsnprintf(buf, 32, \"0x%08.8x\", p[n - 1]);\n   }\n   return buf;\n}\n\nvoid idaapi run(int arg) {\n   int choice = choose(data, 16, idabook_sizer, idabook_getline,\n                      \"Idabook Choose\");\n   msg(\"The user's choice was %d\\n\", choice);\n}\n```", "```\nulong choose2(void *obj,\n              int ncol,\n              const int *widths,\n              ulong (idaapi *sizer)(void *obj),\n              void (idaapi *getline)(void *obj, ulong n, char* const *cells),\n              const char *title);\n```", "```\n#include <kernwin.hpp>\n\n//The sample data to be displayed\nint data[] = {0xdeafbeef, 0xcafebabe, 0xfeedface, 0};\n//The width of each column\nint widths[] = {16, 16, 16};\n//The headers for each column\nchar *headers[] = {\"Decimal\", \"Hexadecimal\", \"Octal\"};\n//The format strings for each column\nchar *formats[] = {\"%d\", \"0x%x\", \"0%o\"};\n\n//this function expects obj to point to a zero terminated array\n//of non-zero integers.\nulong idaapi idabook_sizer(void *obj) {\n   int *p = (int*)obj;\n   int count = 0;\n   while (*p++) count++;\n   return count;\n}\n\n/*\n * obj In this function obj is expected to point to an array of integers\n * n indicates which line (1..n) of the display is being formatted.\n *   if n is zero, the header line is being requested.\n * cells is a pointer to an array of character pointers. This array\n *       contains one pointer for each column in the chooser.  The output\n *       for each column should not exceed MAXSTR (1024) characters.*/\nvoid idaapi idabook_getline_2(void *obj, ulong n, char* const *cells) {\n   int *p = (int*)obj;\n   if (n == 0) {\n      for (int i = 0; i < 3; i++) {\n         qstrncpy(cells[i], headers[i], widths[i]);\n      }\n   }\n   else {\n      for (int i = 0; i < 3; i++) {\n         qsnprintf(cells[i], widths[i], formats[i], p[n - 1]);\n      }\n   }\n}\n\nvoid run(int arg) {\n   int choice = choose2(data, 3, widths, idabook_sizer, idabook_getline_2,\n                        \"Idabook Choose2\");\n   msg(\"The choice was %d\\n\", choice);\n}\n```", "```\nint AskUsingForm_c(const char *form,...);\n```", "```\n<#hint text#label:type:width:swidth:@hlp[]>\n```", "```\nInput field types                       va_list parameter\n  -----------------                       -----------------\n\n  A - ascii string                        char* at least MAXSTR size\n  S - segment                             sel_t*\n  N - hex number, C notation              uval_t*\n  n - signed hex number, C notation       sval_t*\n  L - default base (usually hex) number,  ulonglong*\n      C notation\n  l - default base (usually hex) number,  longlong*\n      signed C notation\n  M - hex number, no \"0x\" prefix          uval_t*\n  D - decimal number                      sval_t*\n  O - octal number, C notation            sval_t*\n  Y - binary number, \"0b\" prefix          sval_t*\n  H - char value, C notation              sval_t*\n  $ - address                             ea_t*\n  I - ident                               char* at least MAXNAMELEN size\n  B - button                              formcb_t button callback function\n  K - color button                        bgcolor_t*\n  C - checkbox                            ushort* bit mask of checked boxes\n  R - radiobutton                         ushort* number of selected radiobutton\n```", "```\n// callback for buttons\ntypedef void (idaapi *formcb_t)(TView *fields[],int code);\n```", "```\n<#item hint#label:type>\n```", "```\n<#item hint#label:type>>\n```", "```\n<#item hint#title#box hint#label:type>\n```", "```\n<##title##label:type>\n```", "```\nchar *dialog =\n \"STARTITEM 0\\n\"          //The first item gets the input focus\n \"This is the title\\n\\n\"  //followed by 2 new lines\n \"This is static text\\n\"\n \"<String:A:32:32::>\\n\"   //An ASCII input field, need char[MAXSTR]\n \"<Decimal:D:10:10::>\\n\"  //A decimal input field, sval_t*\n \"<#No leading 0x#Hex:M:8:10::>\\n\"  //A Hex input field with hint, uval_t*\n \"<Button:B::::>\\n\"                 //A button field with no code, formcb_t\n \"<##Radio Buttons##Radio 1:R>\\n\"   //A radio button with box title\n \"<Radio 2:R>>\\n\"                   //Last radio button in group\n                                    //ushort* number of selected radio\n \"<##Check Boxes##Check 1:C>\\n\"     //A checkbox field with a box title\n \"<Check 2:C>>\\n\";                  //Last checkbox in group\n                                    //ushort* bitmask of checks\n```", "```\nvoid idaapi button_func(TView *fields[], int code) {\n   msg(\"The button was pressed!\\n\");\n}\n\nvoid idaapi run(int arg) {\n   char input[MAXSTR];\n   sval_t dec = 0;\n   uval_t hex = 0xdeadbeef;\n   ushort radio = 1;      //select button 1 initially\n   ushort checkmask = 3;  //select both checkboxes initially\n   qstrncpy(input, \"initial value\", sizeof(input));\n   if (AskUsingForm_c(dialog, input, &dec, &hex,\n                      button_func, &radio, &checkmask) == 1) {\n      msg(\"The input string was: %s\\n\", input);\n      msg(\"Decimal: %d, Hex %x\\n\", dec, hex);\n      msg(\"Radio button %d is selected\\n\", radio);\n      for (int n = 0; checkmask; n++) {\n         if (checkmask & 1) {\n            msg(\"Checkbox %d is checked\\n\", n);\n         }\n         checkmask >>= 1;\n      }\n   }\n}\n```", "```\nHWND mainWindow = (HWND)callui(ui_get_hwnd).vptr;\n```", "```\n*`ftp://ftp.qt.nokia.com/qt/source/qt-win-opensource-4.7.2-vs2008.exe`*\n```", "```\n*`ftp://ftp.qt.nokia.com/qt/source/qt-everywhere-opensource-src-4.7.2.tar.gz`*\n```", "```\n-qtnamespace QT\n```", "```\nQT_NAMESPACE = QT\n```", "```\nunsigned int len = ::qstrlen(myString);\n```", "```\nQWidget *mainWindow = QApplication::activeWindow();\n```", "```\nfrom idaapi import *\n\nclass idabook_plugin_t(plugin_t):\n   flags = 0\n   wanted_name = \"IdaBook Python Plugin\"\n   wanted_hotkey = \"Alt-8\"\n   comment = \"IdaBook Python Plugin\"\n   help = \"Something helpful\"\n\n   def init(self):\n      msg(\"IdaBook plugin init called.\\n\")\n      return PLUGIN_OK\n\n   def term(self):\n      msg(\"IdaBook plugin term called.\\n\")\n\n   def run(self, arg):\n      warning(\"IdaBook plugin run(%d) called.\\n\" % arg)\n\n   def PLUGIN_ENTRY():\n      return idabook_plugin_t()\n```", "```\n#include <idc.idc>\n\nclass idabook_plugin_t {\n\n   idabook_plugin_t() {\n      this.flags = 0;\n      this.wanted_name = \"IdaBook IDC Plugin\";\n      this.wanted_hotkey = \"Alt-9\";\n      this.comment = \"IdaBook IDC Plugin\";\n      this.help = \"Something helpful\";\n   }\n\n   init() {\n      Message(\"IdaBook plugin init called.\\n\");\n      return PLUGIN_OK;\n   }\n\n   term() {\n      Message(\"IdaBook plugin term called.\\n\");\n   }\n\n   run(arg) {\n      Warning(\"IdaBook plugin run(%d) called.\\n\", arg);\n   }\n}\n\nstatic PLUGIN_ENTRY() {\n   return idabook_plugin_t();\n}\n```", "```\nseg000:00000000                 db  4Dh ; M\nseg000:00000001                 db  5Ah ; Z\nseg000:00000002                 db  90h ; É\nseg000:00000003                 db    0\nseg000:00000004                 db    3\nseg000:00000005                 db    0\nseg000:00000006                 db    0\nseg000:00000007                 db    0\n```", "```\nseg000:00000000                 dw 5A4Dh                ; e_magic\nseg000:00000000                 dw 90h                  ; e_cblp\nseg000:00000000                 dw 3                    ; e_cp\nseg000:00000000                 dw 0                    ; e_crlc\nseg000:00000000                 dw 4                    ; e_cparhdr\nseg000:00000000                 dw 0                    ; e_minalloc\nseg000:00000000                 dw 0FFFFh               ; e_maxalloc\nseg000:00000000                 dw 0                    ; e_ss\nseg000:00000000                 dw 0B8h                 ; e_sp\nseg000:00000000                 dw 0                    ; e_csum\nseg000:00000000                 dw 0                    ; e_ip\nseg000:00000000                 dw 0                    ; e_cs\nseg000:00000000                 dw 40h                  ; e_lfarlc\nseg000:00000000                 dw 0                    ; e_ovno\nseg000:00000000                 dw 4 dup(0)             ; e_res\nseg000:00000000                 dw 0                    ; e_oemid\nseg000:00000000                 dw 0                    ; e_oeminfo\nseg000:00000000                 dw 0Ah dup(0)           ; e_res2\nseg000:00000000                 dd 80h                ; e_lfanew\n```", "```\nseg000:00000080        dd 4550h        ; Signature\nseg000:00000080        dw 14Ch       ; FileHeader.Machine\nseg000:00000080        dw 4          ; FileHeader.NumberOfSections\nseg000:00000080        dd 47826AB4h    ; FileHeader.TimeDateStamp\nseg000:00000080        dd 0E00h        ; FileHeader.PointerToSymbolTable\nseg000:00000080        dd 0FBh         ; FileHeader.NumberOfSymbols\nseg000:00000080        dw 0E0h         ; FileHeader.SizeOfOptionalHeader\nseg000:00000080        dw 307h         ; FileHeader.Characteristics\nseg000:00000080        dw 10Bh         ; OptionalHeader.Magic\nseg000:00000080        db 2            ; OptionalHeader.MajorLinkerVersion\nseg000:00000080        db 38h          ; OptionalHeader.MinorLinkerVersion\nseg000:00000080        dd 600h         ; OptionalHeader.SizeOfCode\nseg000:00000080        dd 400h         ; OptionalHeader.SizeOfInitializedData\nseg000:00000080        dd 200h         ; OptionalHeader.SizeOfUninitializedData\nseg000:00000080        dd 1000h      ; OptionalHeader.AddressOfEntryPoint\nseg000:00000080        dd 1000h        ; OptionalHeader.BaseOfCode\nseg000:00000080        dd 0            ; OptionalHeader.BaseOfData\nseg000:00000080        dd 400000h    ; OptionalHeader.ImageBase\nseg000:00000080        dd 1000h      ; OptionalHeader.SectionAlignment\nseg000:00000080        dd 200h       ; OptionalHeader.FileAlignment\n```", "```\nseg000:00400178                 db '.text',0,0,0      ; Name\nseg000:00400178                 dd 440h                 ; VirtualSize\nseg000:00400178                 dd 1000h              ; VirtualAddress\nseg000:00400178                 dd 600h               ; SizeOfRawData\nseg000:00400178                 dd 400h               ; PointerToRawData\nseg000:00400178                 dd 0                    ; PointerToRelocations\nseg000:00400178                 dd 0                    ; PointerToLinenumbers\nseg000:00400178                 dw 0                    ; NumberOfRelocations\nseg000:00400178                 dw 0                    ; NumberOfLinenumbers\nseg000:00400178                 dd 60000020h            ; Characteristics\n```", "```\n.headers:004003FF                 db    0\n.headers:004003FF _headers        ends\n.headers:004003FF\nseg001:00400400 ; ===========================================================\nseg001:00400400\nseg001:00400400 ; Segment type: Pure code\nseg001:00400400 seg001          segment byte public 'CODE' use32\nseg001:00400400                 assume cs:seg001\nseg001:00400400                 ;org 400400h\nseg001:00400400                 assume es:_headers, ss:_headers, ds:_headers\nseg001:00400400                 db  55h ; U\n```", "```\n.headers:004001A0                 db '.rdata',0,0         ; Name\n.headers:004001A0                 dd 60h                  ; VirtualSize\n.headers:004001A0                 dd 2000h                ; VirtualAddress\n.headers:004001A0                 dd 200h                 ; SizeOfRawData\n.headers:004001A0                 dd 0A00h                ; PointerToRawData\n.headers:004001A0                 dd 0                    ; PointerToRelocations\n.headers:004001A0                 dd 0                    ; PointerToLinenumbers\n.headers:004001A0                 dw 0                    ; NumberOfRelocations\n.headers:004001A0                 dw 0                    ; NumberOfLinenumbers\n.headers:004001A0                 dd 40000040h            ; Characteristics\n```", "```\n.headers:004001C8                 db '.bss',0,0,0      ; Name\n.headers:004001C8                 dd 40h             ; VirtualSize\n.headers:004001C8                 dd 3000h             ; VirtualAddress\n.headers:004001C8                 dd 0               ; SizeOfRawData\n.headers:004001C8                 dd 0                 ; PointerToRawData\n.headers:004001C8                 dd 0                 ; PointerToRelocations\n.headers:004001C8                 dd 0                 ; PointerToLinenumbers\n.headers:004001C8                 dw 0                 ; NumberOfRelocations\n.headers:004001C8                 dw 0                 ; NumberOfLinenumbers\n.headers:004001C8                 dd 0C0000080h        ; Characteristics\n```", "```\nName     Start    End      R W X D L Align Base Type   Class\n.headers 00400000 00400400 ? ? ? . . byte  0000 public DATA   ...\n.text    00401000 00401600 ? ? ? . . byte  0000 public CODE   ...\n.rdata   00402000 00402200 ? ? ? . . byte  0000 public DATA   ...\n.bss     00403000 00403040 ? ? ? . . byte  0000 public BSS    ...\n.idata   00404000 00404200 ? ? ? . . byte  0000 public IMPORT ...\nseg005   00404200 004058DE ? ? ? . L byte  0001 public CODE   ...\n```", "```\nSetSegmentAttr(0x401000, SEGATTR_PERM, 1);\n```", "```\nAddEntryPoint(0x401000, 0x401000, 'start', 1);\n```", "```\nstruct loader_t {\n  ulong version;        // api version, should be IDP_INTERFACE_VERSION\n  ulong flags;          // loader flags\n\n//check input file format. if recognized,\n  int (idaapi *accept_file)(linput_t *li,\n                            char fileformatname[MAX_FILE_FORMAT_NAME],\n                            int n);\n//load file into the database.\n  void (idaapi *load_file)(linput_t *li, ushort neflags,\n                           const char *fileformatname);\n\n//create output file from the database, this function may be absent.\n  int (idaapi *save_file)(FILE *fp, const char *fileformatname);\n\n//take care of a moved segment (fix up relocations, for example)\n//this function may be absent.\n  int (idaapi *move_segm)(ea_t from, ea_t to, asize_t size,\n                          const char *fileformatname);\n\n//initialize user configurable options based on the input file.\n//Called only when loading is done via File->New, not File->Open\n//this function may be absent.\n  bool (idaapi *init_loader_options)(linput_t *li);\n};\n```", "```\nstruct simpleton {\n   uint32_t magic; //simpleton magic number: 0x1DAB00C\n   uint32_t size;  //size of the code array\n   uint32_t base;  //base virtual address and entry point\n   uint8_t code[size]; //the actual program code\n};\n```", "```\n0000000: 0cb0 da01 4900 0000 0040 0000 31c0 5050  ....I....@..1.PP\n0000010: 89e7 6a10 5457 50b0 f350 cd91 5859 4151  ..j.TWP..P..XYAQ\n0000020: 50cd 9166 817f 0213 8875 f16a 3e6a 025b  P..f.....u.j>j.[\n0000030: 5853 6a09 516a 3ecd 914b 79f4 5068 6e2f  XSj.Qj>..Ky.Ph//\n0000040: 7368 682f 2f62 6989 e350 5389 e150 5153  shh/bin..PS..PQS\n0000050: b03b 50cd 91                             .;P..\n```", "```\n#include \"../idaldr.h\"\n#define SIMPLETON_MAGIC 0x1DAB00C\n\nstruct simpleton {\n   uint32_t magic; //simpleton magic number: 0x1DAB00C\n   uint32_t size;  //size of the code array\n   uint32_t base;  //base virtual address and entry point\n};\n```", "```\nint idaapi accept_simpleton_file(linput_t *, char[MAX_FILE_FORMAT_NAME], int);\nvoid idaapi load_simpleton_file(linput_t *, ushort, const char *);\nint idaapi save_simpleton_file(FILE *, const char *);\n\nloader_t LDSC = {\n  IDP_INTERFACE_VERSION,\n  0,                      // loader flags\n  accept_simpleton_file,  // test simpleton format.\n  load_simpleton_file,    // load file into the database.\n  save_simpleton_file,    // simpleton is an easy format to save\n  NULL,                   // no special handling for moved segments\n  NULL,                   // no special handling for File->New\n};\n```", "```\nint idaapi accept_simpleton_file(linput_t *li,\n                              char fileformatname[MAX_FILE_FORMAT_NAME], int n) {\n   uint32 magic;\n   if (n || lread4bytes(li, &magic, false)) return 0;\n   if (magic != SIMPLETON_MAGIC) return 0;   //bad magic number found\n   qsnprintf(fileformatname, MAX_FILE_FORMAT_NAME, \"Simpleton Executable\");\n   return 1;  //simpleton format recognized\n}\n```", "```\nvoid idaapi load_simpleton_file(linput_t *li, ushort neflags, const char *) {\n   simpleton hdr;\n   //read the program header from the input file\n   lread(li, &hdr, sizeof(simpleton));\n   //load file content into the database\n   file2base(li, sizeof(simpleton), hdr.base, hdr.base + hdr.size,\n             FILEREG_PATCHABLE);\n   //create a segment around the file's code section\n   if (!add_segm(0, hdr.base, hdr.base + hdr.size, NAME_CODE, CLASS_CODE)) {\n      loader_failure();\n   }\n   //retrieve a handle to the new segment\n   segment_t *s = getseg(hdr.base);\n   //so that we can set 32 bit addressing mode on (x86 has 16 or 32 bit modes)\n   set_segm_addressing(s, 1);  //set 32 bit addressing\n   //tell IDA to create the file header comment for us.  Do this\n   //only once. This comment contains license, MD5,\n   // and original input file name information.\n   create_filename_cmt();\n   //Add an entry point so that the processor module knows at least one\n   //address that contains code.  This is the root of the recursive descent\n   //disassembly process\n   add_entry(hdr.base, hdr.base, \"_start\", true);\n}\n```", "```\nint ida_export file2base(linput_t *li, long pos, ea_t ea1, ea_t ea2, int patchable);\n```", "```\nbool ida_export add_entry(uval_t ord, ea_t ea, const char *name, bool makecode);\n```", "```\nint idaapi save_simpleton_file(FILE *fp, const char *fileformatname) {\n   uint32 magic = SIMPLETON_MAGIC;\n   if (fp == NULL) return 1;   //special case, success means we can save files\n   segment_t *s = getnseg(0);  //get segment zero, the one and only segment\n   if (s) {\n      uint32 sz = s->endEA - s->startEA;    //compute the segment size\n      qfwrite(fp, &magic, sizeof(uint32));  //write the magic value\n      qfwrite(fp, &sz, sizeof(uint32));     //write the segment size\n      qfwrite(fp, &s->startEA, sizeof(uint32));  //write the base address\n      base2file(fp, sizeof(simpleton), s->startEA, s->endEA); //dump the segment\n      return 1;  //return success\n   }\nelse {\n      return 0;  //return failure\n   }\n}\n```", "```\npcap_file: pcap_file_header (pcap_packet)*\npcap_packet: pcap_packet_header pcap_content\npcap_content: (byte)+\n```", "```\nvoid add_types() {\n#ifdef ADDTIL_DEFAULT\n   add_til2(\"gnuunx.til\", ADDTIL_SILENT);\n#else\n   add_til(\"gnuunx.til\");\n#endif\n   pcap_hdr_struct = til2idb(-1, \"pcap_file_header\");\n   pkthdr_struct = til2idb(-1, \"pcap_pkthdr\");\n   ether_struct = til2idb(-1, \"ether_header\");\n   ip_struct = til2idb(-1, \"iphdr\");\n   tcp_struct = til2idb(-1, \"tcphdr\");\n   udp_struct = til2idb(-1, \"udphdr\");\n}\n```", "```\nvoid add_types() {\n   til_t *t = new_til(\"pcap.til\", \"pcap header types\"); //empty type library\n   parse_decls(t, pcap_types, NULL, HTI_PAK1); //parse C declarations into library\n   sort_til(t);                                //required after til is modified\n   pcap_hdr_struct = import_type(t, −1, \"pcap_file_header\");\n   pkthdr_struct = import_type(t, −1, \"pcap_pkthdr\");\n   ether_struct = import_type(t, −1, \"ether_header\");\n   ip_struct = import_type(t, −1, \"iphdr\");\n   tcp_struct = import_type(t, −1, \"tcphdr\");\n   udp_struct = import_type(t, −1, \"udphdr\");\n   free_til(t);                                  //free the temporary library\n}\n```", "```\nchar *pcap_types =\n   \"struct pcap_file_header {\\n\"\n        \"int magic;\\n\"\n        \"short version_major;\\n\"\n        \"short version_minor;\\n\"\n        \"int thiszone;\\n\"\n        \"int sigfigs;\\n\"\n        \"int snaplen;\\n\"\n        \"int linktype;\\n\"\n   \"};\\n\"\n   ...\n```", "```\nvoid idaapi load_pcap_file(linput_t *li, ushort, const char *) {\n   ssize_t len;\n   pcap_pkthdr pkt;\n\n   add_types();              //add structure templates to database\n   create_filename_cmt();    //create the main file header comment\n   //load the pcap file header from the database into the file\n   file2base(li, 0, 0, sizeof(pcap_file_header), FILEREG_PATCHABLE);\n   //try to add a new data segment to contain the file header bytes\n   if (!add_segm(0, 0, sizeof(pcap_file_header), \".file_header\", CLASS_DATA)) {\n      loader_failure();\n   }\n   //convert the file header bytes into a pcap_file_header\n   doStruct(0, sizeof(pcap_file_header), pcap_hdr_struct);\n   //... continues\n```", "```\n//...continuation of load_pcap_file\n   uint32 pos = sizeof(pcap_file_header);    //file position tracker\n   while ((len = qlread(li, &pkt, sizeof(pkt))) == sizeof(pkt)) {\n      mem2base(&pkt, pos, pos + sizeof(pkt), pos);  //transfer header to database\n      pos += sizeof(pkt);       //update position pointer point to packet content\n      //now read packet content based on number of bytes of packet that are\n      //present\n      file2base(li, pos, pos, pos + pkt.caplen, FILEREG_PATCHABLE);\n      pos += pkt.caplen;        //update position pointer to point to next header\n   }\n   //create a new section around the packet content.  This section begins where\n   //the pcap file header ended.\n   if (!add_segm(0, sizeof(pcap_file_header), pos, \".packets\", CLASS_DATA)) {\n      loader_failure();\n   }\n   //retrieve a handle to the new segment\n   segment_t *s = getseg(sizeof(pcap_file_header));\n   //so that we can set 32 bit addressing mode on\n   set_segm_addressing(s, 1);  //set 32 bit addressing\n   //...continues\n```", "```\n//...continuation of load_pcap_file\n   //apply headers structs for each packet in the database\n   for (uint32 ea = s->startEA; ea < pos;) {\n      uint32 pcap = ea;       //start of packet\n      //apply pcap packet header struct\n      doStruct(pcap, sizeof(pcap_pkthdr), pkthdr_struct);\n      uint32 eth = pcap + sizeof(pcap_pkthdr);\n      //apply Ethernet header struct\n      doStruct(eth, sizeof(ether_header), ether_struct);\n      //Test Ethernet type field\n      uint16 etype = get_word(eth + 12);\n      etype = (etype >> 8) | (etype << 8);  //htons\n\n      if (etype == ETHER_TYPE_IP) {\n         uint32 ip = eth + sizeof(ether_header);\n         //Apply IP header struct\n         doStruct(ip, sizeof(iphdr), ip_struct);\n         //Test IP protocol\n         uint8 proto = get_byte(ip + 9);\n         //compute IP header length\n         uint32 iphl = (get_byte(ip) & 0xF) * 4;\n         if (proto == IP_PROTO_TCP) {\n            doStruct(ip + iphl, sizeof(tcphdr), tcp_struct);\n         }\n         else if (proto == IP_PROTO_UDP) {\n            doStruct(ip + iphl, sizeof(udphdr), udp_struct);\n         }\n      }\n      //point to start of next pcak_pkthdr\n      ea += get_long(pcap + 8) + sizeof(pcap_pkthdr);\n   }\n}\n```", "```\n.file_header:0000 _file_header    segment byte public 'DATA' use16\n.file_header:0000         assume cs:_file_header\n.file_header:0000         pcap_file_header <0A1B2C3D4h, 2, 4, 0, 0, 0FFFFh, 1>\n.file_header:0000 _file_header    ends\n.file_header:0000\n.packets:00000018 ; =========================================================\n.packets:00000018\n.packets:00000018 ; Segment type: Pure data\n.packets:00000018 _packets  segment byte public 'DATA' use32\n.packets:00000018            assume cs:_packets\n.packets:00000018            ;org 18h\n.packets:00000018            pcap_pkthdr <<47DF275Fh, 1218Ah>, 19Ch, 19Ch>\n.packets:00000028            db 0, 18h, 0E7h, 1, 32h, 0F5h; ether_dhost\n.packets:00000028            db 0, 50h, 0BAh, 0B8h, 8Bh, 0BDh; ether_shost\n.packets:00000028            dw 8                    ; ether_type\n.packets:00000036            iphdr <45h, 0, 8E01h, 0EE4h, 40h, 80h, 6, 9E93h,\n                                    200A8C0h, 6A00A8C0h>\n.packets:0000004A            tcphdr <901Fh, 2505h, 0C201E522h, 6CE04CCBh, 50h,\n                                     18h, 0E01Ah, 3D83h, 0>\n.packets:0000005E            db  48h ; H\n.packets:0000005F            db  54h ; T\n.packets:00000060            db  54h ; T\n.packets:00000061            db  50h ; P\n.packets:00000062            db  2Fh ; /\n.packets:00000063            db  31h ; 1\n.packets:00000064            db  2Eh ; .\n.packets:00000065            db  30h ; 0\n```", "```\nstatic void load_file(linput_t *li, ushort neflag, const char *) {\n  if (ph.id != PLFM_JAVA) {\n    set_processor_type(\"java\", SETPROC_ALL | SETPROC_FATAL);\n  }\n  if (ph.notify(ph.loader, li, (bool)(neflag & NEF_LOPT))) {\n    error(\"Internal error in loader<->module link\");\n  }\n}\n```", "```\n#include <idc.idc>\n\n#define SIMPLETON_MAGIC 0x1DAB00C\n\n//Verify the input file format\n//   li - loader_input_t object. See IDA help file for more information\n//   n  - How many times we have been called\n//Returns:\n//   0 - file unrecognized\n//   Name of file type - if file is recognized\nstatic accept_file(li, n) {\n   auto magic;\n   if (n) return 0;\n   li.readbytes(&magic, 4, 0);\n   if (magic != SIMPLETON_MAGIC) {\n      return 0;\n   }\n   return \"IDC Simpleton Loader\";\n}\n\n//Load the file\n//   li - loader_input_t object\n//   neflags - refer to loader.hpp for valid flags\n//   format  - The file format selected nby the user\n//Returns:\n//   1 - success\n//   0 - failure\nstatic load_file(li, neflags, format) {\n   auto magic, size, base;\n   li.seek(0, 0);\n   li.readbytes(&magic, 4, 0);\n   li.readbytes(&size, 4, 0);\n   li.readbytes(&base, 4, 0);\n   // copy bytes to the database\n   loadfile(li, 12, base, size);\n   // create a segment\n   AddSeg(base, base + size, 0, 1, saRelPara, scPub);\n   // add the initial entry point\n   AddEntryPoint(base, base, \"_start\", 1);\n   return 1;\n}\n```", "```\n#Verify the input file format\n#   li - loader_input_t object. See IDA help file for more information\n#   n  - How many times we have been called\n#Returns:\n#   0 - file unrecognized\n#   Name of file type - if file is recognized\ndef accept_file(li, n):\n   if (n):\n      return 0\n   li.seek(0)\n   magic = struct.unpack(\"<I\", li.read(4))[0]\n   if magic != 0x1DAB00C:\n      return 0\n   return \"Python Simpleton Loader\"\n\n#Load the file\n#   li - loader_input_t object\n#   neflags - refer to loader.hpp for valid flags\n#   format  - The file format selected nby the user\n#Returns:\n#   1 - success\n#   0 - failure\ndef load_file(li, neflags, format):\n   li.seek(0)\n   (magic, size, base) = struct.unpack(\"<III\", li.read(12))\n   # copy bytes to the database\n   li.file2base(12, base, base + size, 1)\n   # create a segment\n   add_segm(0, base, base + size, \".text\", \"CODE\")\n   # add the initial entry point\n   add_entry(base, base, \"_start\", 1)\n   return 1;\n```", "```\nstruct instruc_t {\n  const char *name;  //instruction mnemonic\n  ulong feature;     //bitwise OR of CF_xxx flags defined in idp.hpp\n};\n```", "```\ninstruc_t Instructions[] = {\n     {\"STOP_CODE\", CF_STOP},   /* 0 */\n     {\"POP_TOP\", 0},           /* 1 */\n     {\"ROT_TWO\", 0},           /* 2 */\n     {\"ROT_THREE\", 0},         /* 3 */\n     {\"DUP_TOP\", 0},           /* 4 */\n     {\"ROT_FOUR\", 0},          /* 5 */\n    {NULL, 0},                /* 6 */\n     ...\n     {\"CALL_FUNCTION_VAR_KW\", CF_CALL}, /* 142 */\n     {\"SETUP_WITH\", 0},                 /* 143 */\n     {\"EXTENDED_ARG\", 0},               /* 145 */\n     {\"SET_ADD\", 0},                    /* 146 */\n     {\"MAP_ADD\", 0}                     /* 147 */\n  };\n```", "```\nenum python_opcodes {\n   STOP_CODE = 0,\n   POP_TOP = 1,    //remove top item on stack\n   ROT_TWO = 2,    //exchange top two items on stack\n   ROT_THREE = 3,  //move top item below the 2nd and 3rd items\n   DUP_TOP = 4,    //duplicate the top item on the stack\n   ROT_FOUR = 5,   //move top item below the 2nd, 3rd, and 4th items\n   NOP = 9,        //no operation\n   ...\n   CALL_FUNCTION_VAR_KW = 142,\n   SETUP_WITH = 143,\n   EXTENDED_ARG = 145,\n   SET_ADD = 146,\n   MAP_ADD = 147,\n   PYTHON_LAST = 148\n};\n```", "```\nint instruc_start;   // integer code of the first instruction\n  int instruc_end;     // integer code of the last instruction + 1\n  instruc_t *instruc;  // array of instructions\n```", "```\nstatic char *RegNames[] = {\n   \"eax\", \"ebx\", \"ecx\", \"edx\", \"edi\", \"esi\", \"ebp\", \"esp\",\n   \"ax\", \"bx\", \"cx\", \"dx\", \"di\", \"si\", \"bp\", \"sp\",\n   \"al\", \"ah\", \"bl\", \"bh\",  \"cl\", \"ch\", \"dl\", \"dh\",\n   \"cs\", \"ds\", \"es\", \"fs\", \"gs\"\n};\n```", "```\nenum x86_regs {\n   r_eax, r_ebx, r_ecx, r_edx, r_edi, r_esi, r_ebp, r_esp,\n   r_ax, r_bx, r_cx, r_dx, r_di, r_si, r_bp, r_sp,\n   r_al, r_ah, r_bl, r_bh,  r_cl, r_ch, r_dl, r_dh,\n   r_cs, r_ds, r_es, r_fs, r_gs\n};\n```", "```\nint   regsNum;            // total number of registers\n  char  **regNames;         // array of register names\n```", "```\n // Segment register information (use virtual CS and DS registers if\n  // your processor doesn't have segment registers):\n    int   regFirstSreg;        // number of first segment register\n    int   regLastSreg;         // number of last segment register\n    int   segreg_size;         // size of a segment register in bytes\n\n // If your processor does not use segment registers, You should define\n  // 2 virtual segment registers for CS and DS.\n  // Let's call them rVcs and rVds.\n    int   regCodeSreg;         // number of CS register\n    int   regDataSreg;         // number of DS register\n```", "```\nr_cs, r_gs, 2, r_cs, r_ds\n```", "```\n//in reg.cpp\nstatic char *RegNames = { \"cs\", \"ds\" };\n\n//in python.hpp\nenum py_registers { rVcs, rVds };\n```", "```\nrVcs, rVds, 0, rVcs, rVds\n```", "```\nint version; // should be IDP_INTERFACE_VERSION\nint id;     // IDP id, a PLFM_xxx value or self assigned > 0x8000\nulong flag; // Processor features, bitwise OR of PR_xxx values\nint cnbits; // Number of bits in a byte for code segments (usually 8)\nint dnbits; // Number of bits in a byte for data segments (usually 8)\n```", "```\nint idaapi ana(void); //analyze one instruction and return the instruction length\n```", "```\nclass insn_t {\n  public:\n    ea_t cs; // Current segment base paragraph. Set by kernel\n    ea_t ip; // Virtual address of instruction (within segment). Set by kernel\n    ea_t ea; // Linear address of the instruction. Set by kernel\n   uint16\n itype; // instruction enum value (not opcode!). Proc sets this in ana\n   uint16 size;  // Size of instruction in bytes. Proc sets this in ana\n    union {       // processor dependent field. Proc may set this\n      uint16 auxpref;\n      struct {\n        uchar low;\n          uchar high;\n      } auxpref_chars;\n    };\n    char segpref;     // processor dependent field.  Proc may set this\n    char insnpref;    // processor dependent field.  Proc may set this\n   op_t Operands[6]; // instruction operand info.  Proc sets this in ana\n    char flags;       // instruction flags.  Proc may set this\n  };\n```", "```\n//read one byte from current instruction location\nuchar ua_next_byte(void);\n//read two bytes from current instruction location\nushort ua_next_word(void);\n//read four bytes from current instruction location\nulong ua_next_long(void);\n//read eight bytes from current instruction location\nulonglong ua_next_qword(void);\n```", "```\nclass op_t {\npublic:\n  char n;  // number of operand (0,1,2).  Kernel sets this do not change!\n  optype_t type; // type of operand.  Set in ana, See ua.hpp for values\n\n  // offset of operand relative to instruction start\n  char offb;  //Proc sets this in ana, set to 0 if unknown\n  // offset to second part of operand (if present) relative to instruction start\n\n  char offo;  //Proc sets this in ana, set to 0 if unknown\n  uchar flags; //Proc sets this in ana.  See ua.hpp for possible values\n\n  char dtyp; // Specifies operand datatype. Set in ana. See ua.hpp for values\n\n  // The following unions keep other information about the operand\n  union {\n    uint16 reg;    // number of register for type o_reg\n    uint16 phrase; // number of register phrase for types o_phrase and o_displ\n                   // define numbers of phrases as you like\n  };\n\n  union {          // value of operand for type o_imm or\n    uval_t value;  // outer displacement (o_displ+OF_OUTER_DISP)\n    struct {       // Convenience access to halves of value\n        uint16 low;\n        uint16 high;\n    } value_shorts;\n  };\n\n  union {   // virtual address pointed or used by the operand\n    ea_t addr;  // for types (o_mem,o_displ,o_far,o_near)\n    struct {    // Convenience access to halves of addr\n        uint16 low;\n        uint16 high;\n    } addr_shorts;\n  };\n\n  //Processor dependent fields, use them as you like.  Set in ana\n  union {\n    ea_t specval;\n    struct {\n        uint16 low;\n        uint16 high;\n    } specval_shorts;\n  };\n  char specflag1, specflag2, specflag3, specflag4;\n};\n```", "```\nmov  eax, 0x31337          ; o_reg(dt_dword), o_imm(dt_dword)\npush word ptr [ebp - 12]   ; o_displ(dt_word)\nmov [0x08049130], bl       ; o_mem(dt_byte), o_reg(dt_byte)\nmovzx eax, ax              ; o_reg(dt_dword), o_reg(dt_word)\nret                        ; o_void(dt_void)\n```", "```\n#define HAVE_ARGUMENT 90\nint idaapi py_ana(void) {\n   cmd.itype = ua_next_byte();    //opcodes ARE itypes for us (updates cmd.size)\n   if (cmd.itype >= PYTHON_LAST) return 0;             //invalid instruction\n   if (Instructions[cmd.itype].name == NULL) return 0; //invalid instruction\n   if (cmd.itype < HAVE_ARGUMENT) { //no operands\n      cmd.Op1.type = o_void;      //Op1 is a macro for Operand[0] (see ua.hpp)\n      cmd.Op1.dtyp = dt_void;\n   }\n   else {   //instruction must have two bytes worth of operand data\n      if (flags[cmd.itype] & (HAS_JREL | HAS_JABS)) {\n         cmd.Op1.type = o_near;  //operand refers to a code location\n      }\n      else {\n         cmd.Op1.type = o_mem;   //operand refers to memory (sort of)\n      }\n      cmd.Op1.offb = 1;          //operand offset is 1 byte into instruction\n      cmd.Op1.dtyp = dt_dword;   //No sizes in python so we just pick something\n\n      cmd.Op1.value = ua_next_word(); //fetch the operand word (updates cmd.size)\n      cmd.auxpref = flags[cmd.itype]; //save flags for later stages\n\n      if (flags[cmd.itype] & HAS_JREL) {\n         //compute relative jump target\n         cmd.Op1.addr = cmd.ea + cmd.size + cmd.Op1.value;\n      }\n      else if (flags[cmd.itype] & HAS_JABS) {\n         cmd.Op1.addr = cmd.Op1.value;  //save absolute address\n      }\n      else if (flags[cmd.itype] & HAS_CALL) {\n         //target of call is on the stack in Python, the operand indicates\n         //how many arguments are on the stack, save these for later stages\n         cmd.Op1.specflag1 = cmd.Op1.value & 0xFF;         //positional parms\n         cmd.Op1.specflag2 = (cmd.Op1.value >> 8) & 0xFF;  //keyword parms\n      }\n   }\n   return cmd.size;\n}\n```", "```\nint idaapi emu(void); //emulate one instruction\n```", "```\nvoid TouchArg(op_t &op, int isRead);  //Processor author writes this\n\nint idaapi emu() {\n   ulong feature = cmd.get_canon_feature(); //get the instruction's CF_xxx flags\n\n   if (feature & CF_USE1) TouchArg(cmd.Op1, 1);\n   if (feature & CF_USE2) TouchArg(cmd.Op2, 1);\n\n   if (feature & CF_CHG1) TouchArg(cmd.Op1, 0);\n   if (feature & CF_CHG2) TouchArg(cmd.Op2, 0);\n\n   if ((feature & CF_STOP) == 0) { //instruction doesn't stop\n      //add code cross ref to next sequential instruction\n      ua_add_cref(0, cmd.ea + cmd.size, fl_F);\n   }\n   return 1;\n}\n```", "```\nbool add_auto_stkpnt2(func_t *pfn, ea_t ea, sval_t delta);\n```", "```\nif (cmd.itype == X86_push) {\n   add_auto_stkpnt2(NULL, cmd.ea + cmd.size, −4);\n}\n```", "```\n//handle cases such as:  sub  esp, 48h\nif (cmd.itype == X86_sub && cmd.Op1.type == o_reg\n    && cmd.Op1.reg == r_esp && cmd.Op2.type == o_imm) {\n   add_auto_stkpnt2(NULL, cmd.ea + cmd.size, -cmd.Op2.value);\n}\n```", "```\nint idaapi py_emu(void) {\n   //We can only resolve target addresses for relative jumps\n   if (cmd.auxpref & HAS_JREL) { //test the flags set by the analyzer\n      ua_add_cref(cmd.Op1.offb, cmd.Op1.addr, fl_JN);\n   }\n   //Add the sequential flow as long as CF_STOP is not set\n   if((cmd.get_canon_feature() & CF_STOP) == 0) {\n      //cmd.ea + cmd.size computes the address of the next instruction\n      ua_add_cref(0, cmd.ea + cmd.size, fl_F);\n   }\n   return 1;\n}\n```", "```\nvoid idaapi out(void); //output a single disassembled instruction\n```", "```\n//--------------------------------------------------------------------------\n//      I D P   H E L P E R   F U N C T I O N S  -  O U T P U T\n//--------------------------------------------------------------------------\n```", "```\n//with the following we can do things like: OutReg(op.reg);\nvoid OutReg(int regnum) {\n   out_register(ph.regNames[regnum]);  //use regnum to index register names array\n}\n```", "```\nbool MakeLine(const char *contents, int indent = −1);\n```", "```\nvoid py_out(void) {\n   char str[MAXSTR];  //MAXSTR is an IDA define from pro.h\n   init_output_buffer(str, sizeof(str));\n   OutMnem(12);       //first we output the mnemonic\n   if(cmd.Op1.type != o_void) {  //then there is an argument to print\n      out_one_operand(0);\n   }\n   term_output_buffer();\n   gl_comm = 1;      //we want comments!\n   MakeLine(str);    //output the line with default indentation\n}\n```", "```\nchar *compare_ops[] = {\n    \"<\", \"<=\", \"==\", \"!=\", \">\", \">=\",\n    \"in\", \"not in\", \"is\", \"is not\", \"exception match\"\n};\n\nbool idaapi py_outop(op_t& x) {\n   if (cmd.itype == COMPARE_OP) {\n      //For comparisons, the argument indicates the type of comparison to be\n      //performed.  Print a symbolic representation of the comparison rather\n      //than a number.\n      if (x.value < qnumber(compare_ops)) {\n         OutLine(compare_ops[x.value]);\n      }\n      else {\n         OutLine(\"BAD OPERAND\");\n      }\n   }\n   else if (cmd.auxpref & HAS_JREL) {\n      //we don't test for x.type == o_near here because we need to distinguish\n      //between relative jumps and absolute jumps.  In our case, HAS_JREL\n      //implies o_near\n      out_name_expr(x, x.addr, x.addr);\n   }\n   else {  //otherwise just print the operand value\n      OutValue(x);\n   }\n   return true;\n}\n```", "```\nvoid idaapi d_out(ea_t ea);   //format data at the specified address\n```", "```\nvoid idaapi python_data(ea_t ea) {\n   char obuf[256];\n   init_output_buffer(obuf, sizeof(obuf));\n   flags_t flags = get_flags_novalue(ea);  //get the flags for address ea\n   if (isWord(flags)) {  //output a word declaration\n      out_snprintf(\"%s %xh\", ash.a_word ? ash.a_word : \"\", get_word(ea));\n   }\n   else if (isDwrd(flags)) {  //output a dword declaration\n      out_snprintf(\"%s %xh\", ash.a_dword ? ash.a_dword : \"\", get_long(ea));\n   }\n   else { //we default to byte declarations in all other cases\n      int val = get_byte(ea);\n      char ch = ' ';\n      if (val >= 0x20 && val <= 0x7E) {\n         ch = val;\n      }\n      out_snprintf(\"%s %02xh   ; %c\", ash.a_byte ? ash.a_byte : \"\", val, ch);\n   }\n   term_output_buffer();\n   gl_comm = 1;\n   MakeLine(obuf);\n}\n```", "```\nint idaapi notify(idp_notify msgid, ...);  //notify processor with a given msg\n```", "```\n// A well-behaving processor module should call invoke_callbacks()\n// in its notify() function. If invoke_callbacks function returns 0,\n// then the processor module should process the notification itself.\n// Otherwise the code should be returned to the caller.\n```", "```\nstatic int idaapi notify(processor_t::idp_notify msgid, ...) {\n   va_list va;\n   va_start(va, msgid);   //setup args list\n   int result = invoke_callbacks(HT_IDP, msgid, va);\n   if (result == 0) {\n      result = 1;             //default success\n      switch(msgid) {\n         case processor_t::init:\n            inf.mf = 0;       //ensure little endian!\n            break;\n         case processor_t::make_data: {\n            ea_t ea = va_arg(va, ea_t);\n            flags_t flags = va_arg(va, flags_t);\n            tid_t tid = va_arg(va, tid_t);\n            asize_t len = va_arg(va, asize_t);\n            if (len > 4) { //our d_out can only handle byte, word, dword\n               result = 0; //disallow big data\n            }\n            break;\n         }\n      }\n   }\n   va_end(va);\n   return result;\n}\n```", "```\nROM:00156                 LOAD_CONST 12\nROM:00159                 COMPARE_OP ==\nROM:00162                 JUMP_IF_FALSE loc_182\nROM:00165                 POP_TOP\nROM:00166                 LOAD_NAME 4\nROM:00169                 LOAD_ATTR 10\nROM:00172                 LOAD_NAME 5\nROM:00175                 CALL_FUNCTION 1\nROM:00178                 POP_TOP\nROM:00179                 JUMP_FORWARD loc_183\nROM:00182 # ----------------------------------------------------------\nROM:00182 loc_182:                           # CODE XREF: ROM:00162j\nROM:00182                 POP_TOP\nROM:00183\nROM:00183 loc_183:                           # CODE XREF: ROM:00179j\nROM:00183                 LOAD_CONST 0\nROM:00186                 RETURN_VALUE\n```", "```\n$ mkidp *`module description`*\n```", "```\nLong module name:short module name\n```", "```\n$ ./mkidp procs/python.w32 \"Python Bytecode:python\"\n```", "```\nmkidp: too long processor description\n```", "```\n#Set this variable to point to your SDK directory\n  IDA_SDK=../../\n\n  PLATFORM=$(shell uname | cut -f 1 -d _)\n\n  ifneq \"$(PLATFORM)\" \"MINGW32\"\n  IDA=$(HOME)/ida\n  endif\n\n  #Set this variable to the desired name of your compiled processor\n  PROC=python\n\n  #Specify a description string for your processor, this is required\n  #The syntax is <long name>:<short name>\n DESCRIPTION=Python Bytecode:python\n\n  ifeq \"$(PLATFORM)\" \"MINGW32\"\n  PLATFORM_CFLAGS=-D__NT__ -D__IDP__ -DWIN32 -Os -fno-rtti\n  PLATFORM_LDFLAGS=-shared -s\n  LIBDIR=$(shell find ../../ -type d | grep -E \"(lib|lib/)gcc.w32\")\n  ifeq ($(strip $(LIBDIR)),)\n  LIBDIR=../../lib/x86_win_gcc_32\n  endif\n  IDALIB=$(LIBDIR)/ida.a\n  PROC_EXT=.w32\n\n  else ifeq \"$(PLATFORM)\" \"Linux\"\n  PLATFORM_CFLAGS=-D__LINUX__\n  PLATFORM_LDFLAGS=-shared -s\n  IDALIB=-lida\n  IDADIR=-L$(IDA)\n  PROC_EXT=.ilx\n\n    else ifeq \"$(PLATFORM)\" \"Darwin\"\n  PLATFORM_CFLAGS=-D__MAC__\n  PLATFORM_LDFLAGS=-dynamiclib\n  IDALIB=-lida\n  IDADIR=-L$(IDA)/idaq.app/Contents/MacOs\n  PROC_EXT=.imc\n  endif\n\n  #Platform specific compiler flags\n  CFLAGS=-Wextra $(PLATFORM_CFLAGS)\n\n  #Platform specific ld flags\n  LDFLAGS=$(PLATFORM_LDFLAGS)\n\n  #specify any additional libraries that you may need\n  EXTRALIBS=\n\n  # Destination directory for compiled plugins\n  OUTDIR=$(IDA_SDK)bin/procs/\n\n  # Postprocessing tool to add processor comment\n MKIDP=$(IDA_SDK)bin/fix_proc\n  #MKIDP=$(IDA)bin/mkidp\n\n  #list out the object files in your project here\n  OBJS=     ana.o emu.o ins.o out.o reg.o\n\n  BINARY=$(OUTDIR)$(PROC)$(PROC_EXT)\n\n  all: $(OUTDIR) $(BINARY)\n\n  clean:\n          -@rm *.o\n          -@rm $(BINARY)\n\n  $(OUTDIR):\n          -@mkdir -p $(OUTDIR)\n\n  CC=g++\n  INC=-I$(IDA_SDK)include/\n\n  %.o: %.cpp\n          $(CC) -c $(CFLAGS) $(INC) $< -o $@\n\n  LD=g++\n    ifeq \"$(PLATFORM)\" \"MINGW32\"\n  #Windows processor's require post processing\n  $(BINARY): $(OBJS)\n          $(LD) $(LDFLAGS) -o $@ $(OBJS) $(IDALIB) $(EXTRALIBS)\n       $(MKIDP) $(BINARY) \"$(DESCRIPTION)\"\n  else\n  $(BINARY): $(OBJS)\n         $(LD) $(LDFLAGS) -o $@ $(OBJS) $(IDALIB) $(EXTRALIBS)\n  endif\n\n  #change python below to the name of your processor, make sure to add any\n  #additional files that your processor is dependent on\n  python.o: python.cpp\n  ana.o: ana.cpp\n  emu.o: emu.cpp\n  ins.o: ins.cpp\n  out.o: out.cpp\n  reg.o: reg.cpp\n```", "```\nint idaapi init(void) {\n    if (ph.id != PLFM_386) return PLUGIN_SKIP;\n    hook_to_notification_point(HT_IDP, hook, NULL);\n     return PLUGIN_KEEP;\n  }\n\n  int idaapi hook(void *user_data, int notification_code, va_list va) {\n     switch (notification_code) {\n        case processor_t::custom_out: {\n         if (cmd.itype == NN_leave) {  //intercept the leave instruction\n            MakeLine(SCOLOR_ON SCOLOR_INSN \"cya\" SCOLOR_OFF);\n              return 2;\n           }\n           else if (cmd.Op2.type != o_void) {\n              //intercept 2 operand instructions\n              op_t op1 = cmd.Op1;\n              op_t op2 = cmd.Op2;\n              cmd.Op1 = op2;\n              cmd.Op2 = op1;\n               (*ph.u_out)();\n              cmd.Op1 = op1;\n              cmd.Op2 = op2;\n              return 2;\n           }\n        }\n     }\n     return 0;\n  }\n    plugin_t PLUGIN = {\n    IDP_INTERFACE_VERSION,\n   PLUGIN_PROC | PLUGIN_HIDE | PLUGIN_MOD,  // plugin flags\n    init,                 // initialize\n    term,                 // terminate. this pointer may be NULL.\n    run,                  // invoke plugin\n    comment,              // long comment about the plugin\n    help,                 // multiline help about the plugin\n    wanted_name,          // the preferred short name of the plugin\n    wanted_hotkey         // the preferred hotkey to run the plugin\n  };\n```", "```\n.text:00401350            push    ebp\n .text:00401351            mov     400000h, edx\n  .text:00401356            mov     esp, ebp\n .text:00401358            mov     offset unk_402060, eax\n .text:0040135D            sub     0Ch, esp\n  .text:00401360            mov     edx, [esp+8]\n  .text:00401364            mov     eax, [esp+4]\n .text:00401368            mov     offset unk_402060, [esp]\n  .text:0040136F            call    sub_401320\n .text:00401374            cya\n  .text:00401375            retn\n```", "```\nvoid idaapi load_file(linput_t *li, ushort neflag, const char *) {\n   if (ph.id != PLFM_PYTHON) {  //shared processor ID\n      set_processor_type(\"python\", SETPROC_ALL|SETPROC_FATAL);\n   }\n   //tell the python processor module to do the loading for us\n   //by sending the processor_t::loader notification message\n   if (ph.notify(processor_t::loader, li, neflag)) {\n      error(\"Python processor/loader failed\");\n   }\n}\n```", "```\nfrom idaapi import *\n\nclass demo_processor_t(idaapi.processor_t):\n   # Initialize required processor data fields including id and\n   # assembler and many others. The assembler field is a dictionary\n   # containing keys for all of the fields of an asm_t. A list of\n   # instructions named *`instruc`* is also required. Each item in the list\n   # is a two-element dictionary containing *`name`* and *`feature`* keys.\n\n   # Also define functions required by processor_t such as those below.\n\n   def ana(self):\n      # analyzer behavior\n\n   def emu(self):\n      # emulator behavior\n\n   def out(self):\n      # outputter behavior\n\n   def outop(self):\n      # outop behavior\n\n# define the processor entry point function which instantiates\n# and returns an instance of processor_t\ndef PROCESSOR_ENTRY():\n    return demo_processor_t()\n```"]