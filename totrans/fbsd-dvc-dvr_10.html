<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Managing and Using Resources"><div class="titlepage"><div><div><h1 class="title"><a id="managing_and_using_resources"/>Chapter 10. Managing and Using Resources</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id10"/><div class="mediaobject"><a id="I_mediaobject10_d1e18649"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1137497.png.jpg"/></div></div><p>In <a class="xref" href="ch07.html" title="Chapter 7. Newbus and Resource Allocation">Chapter 7</a> we discussed how to allocate IRQs, I/O ports, and I/O memory. <a class="xref" href="ch08.html" title="Chapter 8. Interrupt Handling">Chapter 8</a> focused on using IRQs for interrupt handling. This chapter details how to use I/O ports for port-mapped I/O (PMIO) and I/O memory for memory-mapped I/O (MMIO). Before I describe PMIO and MMIO, some background on I/O ports and I/O memory is needed.</p><div class="sect1" title="I/O Ports and I/O Memory"><div class="titlepage"><div><div><h1 class="title"><a id="i_solidus_o_ports_and_i_solidus_o_memory"/>I/O Ports and I/O Memory</h1></div></div></div><p>Every peripheral device is controlled by reading from and writing to its registers (Corbet et al., 2005), which are mapped to either I/O ports or I/O memory. The use of I/O ports or I/O memory is device and architecture dependent. For example, on the <span class="emphasis"><em>i386</em></span>, most ISA devices will map their registers to I/O ports; however, PCI devices tend to map their registers to I/O memory. As you may have guessed, reading and writing to a device’s registers, which are mapped to either I/O ports or I/O memory, is called PMIO or MMIO.<a class="indexterm" id="IDX-CHP-10-0001"/><a class="indexterm" id="IDX-CHP-10-0002"/><a class="indexterm" id="IDX-CHP-10-0003"/><a class="indexterm" id="IDX-CHP-10-0004"/><a class="indexterm" id="IDX-CHP-10-0005"/><a class="indexterm" id="IDX-CHP-10-0006"/></p><div class="sect2" title="Reading from I/O Ports and I/O Memory"><div class="titlepage"><div><div><h2 class="title"><a id="reading_from_i_solidus_o_ports_and_i_sol"/>Reading from I/O Ports and I/O Memory</h2></div></div></div><p>After a driver has called <code class="literal">bus_alloc_resource</code> to allocate the range of I/O ports or I/O memory it needs, it can read from those I/O regions using one of the following functions:</p><a id="I_programlisting10_d1e18702"/><pre class="programlisting">#include &lt;sys/bus.h&gt;
#include &lt;machine/bus.h&gt;

u_int8_t
bus_read_1(struct resource *r, bus_size_t offset);

u_int16_t
bus_read_2(struct resource *r, bus_size_t offset);

u_int32_t
bus_read_4(struct resource *r, bus_size_t offset);

u_int64_t
bus_read_8(struct resource *r, bus_size_t offset);


void
bus_read_multi_1(struct resource *r, bus_size_t offset,
    u_int8_t *datap, bus_size_t count);

void
bus_read_multi_2(struct resource *r, bus_size_t offset,
    u_int16_t *datap, bus_size_t count);

void
bus_read_multi_4(struct resource *r, bus_size_t offset,
    u_int32_t *datap, bus_size_t count);

void
bus_read_multi_8(struct resource *r, bus_size_t offset,
    u_int64_t *datap, bus_size_t count);


void
bus_read_region_1(struct resource *r, bus_size_t offset,
    u_int8_t *datap, bus_size_t count);

void
bus_read_region_2(struct resource *r, bus_size_t offset,
    u_int16_t *datap, bus_size_t count);

void
bus_read_region_4(struct resource *r, bus_size_t offset,
    u_int32_t *datap, bus_size_t count);

void
bus_read_region_8(struct resource *r, bus_size_t offset,
    u_int64_t *datap, bus_size_t count);</pre><p>The <code class="literal">bus_read_N</code> functions (where <code class="literal">N</code> is <code class="literal">1</code>, <code class="literal">2</code>, <code class="literal">4</code>, or <code class="literal">8</code>) read <em class="replaceable"><code>N</code></em> bytes from an <code class="literal">offset</code> in <code class="literal">r</code> (where <code class="literal">r</code> is the return value from a successful <code class="literal">bus_alloc_resource</code> call that allocated an I/O region).<a class="indexterm" id="IDX-CHP-10-0007"/><a class="indexterm" id="IDX-CHP-10-0008"/><a class="indexterm" id="IDX-CHP-10-0009"/><a class="indexterm" id="IDX-CHP-10-0010"/><a class="indexterm" id="IDX-CHP-10-0011"/><a class="indexterm" id="IDX-CHP-10-0012"/></p><p>The <code class="literal">bus_read_multi_</code><em class="replaceable"><code>N</code></em> functions read <em class="replaceable"><code>N</code></em> bytes from an <code class="literal">offset</code> in <code class="literal">r</code>, <code class="literal">count</code> times, and store the reads into <code class="literal">datap</code>. In short, <code class="literal">bus_read_multi_</code><em class="replaceable"><code>N</code></em> reads from the same location multiple times.</p><p>The <code class="literal">bus_read_region_</code><em class="replaceable"><code>N</code></em> functions read <code class="literal">count</code> <em class="replaceable"><code>N</code></em>-byte values starting from an <code class="literal">offset</code> in <code class="literal">r</code>, and store the reads into <code class="literal">datap</code>. In other words, <code class="literal">bus_read_region_</code><em class="replaceable"><code>N</code></em> reads consecutive <em class="replaceable"><code>N</code></em>-byte values from an I/O region (that is, an array).</p></div><div class="sect2" title="Writing to I/O Ports and I/O Memory"><div class="titlepage"><div><div><h2 class="title"><a id="writing_to_i_solidus_o_ports_and_i_solid"/>Writing to I/O Ports and I/O Memory</h2></div></div></div><p>A driver writes to an I/O region using one of the following functions:</p><a id="I_programlisting10_d1e18831"/><pre class="programlisting">#include &lt;sys/bus.h&gt;
#include &lt;machine/bus.h&gt;

void
bus_write_1(struct resource *r, bus_size_t offset,
    u_int8_t value);

void
bus_write_2(struct resource *r, bus_size_t offset,
    u_int16_t value);

void
bus_write_4(struct resource *r, bus_size_t offset,
    u_int32_t value);

void
bus_write_8(struct resource *r, bus_size_t offset,
    u_int64_t value);


void
bus_write_multi_1(struct resource *r, bus_size_t offset,
    u_int8_t *datap, bus_size_t count);

void
bus_write_multi_2(struct resource *r, bus_size_t offset,
    u_int16_t *datap, bus_size_t count);

void
bus_write_multi_4(struct resource *r, bus_size_t offset,
    u_int32_t *datap, bus_size_t count);

void
bus_write_multi_8(struct resource *r, bus_size_t offset,
    u_int64_t *datap, bus_size_t count);


void
bus_write_region_1(struct resource *r, bus_size_t offset,
    u_int8_t *datap, bus_size_t count);

void
bus_write_region_2(struct resource *r, bus_size_t offset,
    u_int16_t *datap, bus_size_t count);

void
bus_write_region_4(struct resource *r, bus_size_t offset,
    u_int32_t *datap, bus_size_t count);

void
bus_write_region_8(struct resource *r, bus_size_t offset,
    u_int64_t *datap, bus_size_t count);


void
bus_set_multi_1(struct resource *r, bus_size_t offset,
    u_int8_t value, bus_size_t count);

void
bus_set_multi_2(struct resource *r, bus_size_t offset,
    u_int16_t value, bus_size_t count);

void
bus_set_multi_4(struct resource *r, bus_size_t offset,
    u_int32_t value, bus_size_t count);

void
bus_set_multi_8(struct resource *r, bus_size_t offset,
    u_int64_t value, bus_size_t count);


void
bus_set_region_1(struct resource *r, bus_size_t offset,
    u_int8_t value, bus_size_t count);

void
bus_set_region_2(struct resource *r, bus_size_t offset,
    u_int16_t value, bus_size_t count);

void
bus_set_region_4(struct resource *r, bus_size_t offset,
    u_int32_t value, bus_size_t count);

void
bus_set_region_8(struct resource *r, bus_size_t offset,
    u_int64_t value, bus_size_t count);</pre><p>The <code class="literal">bus_write_</code><em class="replaceable"><code>N</code></em> functions (where <em class="replaceable"><code>N</code></em> is <code class="literal">1</code>, <code class="literal">2</code>, <code class="literal">4</code>, or <code class="literal">8</code>) write an <em class="replaceable"><code>N</code></em>-byte <code class="literal">value</code> to an <code class="literal">offset</code> in <code class="literal">r</code> (where <code class="literal">r</code> is the return value from a <code class="literal">bus_alloc_resource</code> call that allocated an I/O region).<a class="indexterm" id="IDX-CHP-10-0013"/><a class="indexterm" id="IDX-CHP-10-0014"/><a class="indexterm" id="IDX-CHP-10-0015"/><a class="indexterm" id="IDX-CHP-10-0016"/><a class="indexterm" id="IDX-CHP-10-0017"/><a class="indexterm" id="IDX-CHP-10-0018"/></p><p>The <code class="literal">bus_write_multi_</code><em class="replaceable"><code>N</code></em> functions take <code class="literal">count</code> <em class="replaceable"><code>N</code></em>-byte values from <code class="literal">datap</code> and write them to an <code class="literal">offset</code> in <code class="literal">r</code>. In short, <code class="literal">bus_write_multi_</code><em class="replaceable"><code>N</code></em> writes multiple values to the same location.</p><p>The <code class="literal">bus_write_region_</code><em class="replaceable"><code>N</code></em> functions take <code class="literal">count</code> <em class="replaceable"><code>N</code></em>-byte values from <code class="literal">datap</code> and write them to a region in <code class="literal">r</code>, starting at <code class="literal">offset</code>. Each successive value is written at an offset of <em class="replaceable"><code>N</code></em> bytes after the previous value. In short, <code class="literal">bus_write_region_</code><em class="replaceable"><code>N</code></em> writes consecutive <em class="replaceable"><code>N</code></em>-byte values to an I/O region (that is, an array).</p><p>The <code class="literal">bus_set_multi_</code><em class="replaceable"><code>N</code></em> functions write an <em class="replaceable"><code>N</code></em>-byte <code class="literal">value</code> to an <code class="literal">offset</code> in <code class="literal">r</code>, <code class="literal">count</code> times. That is, <code class="literal">bus_set_multi_</code><em class="replaceable"><code>N</code></em> writes the same value to the same location multiple times.</p><p>The <code class="literal">bus_set_region_</code><em class="replaceable"><code>N</code></em> functions write an <em class="replaceable"><code>N</code></em>-byte <code class="literal">value</code>, <code class="literal">count</code> times, throughout a region in <code class="literal">r</code>, starting at <code class="literal">offset</code>. In other words, <code class="literal">bus_set_region_</code><em class="replaceable"><code>N</code></em> writes the same value consecutively to an I/O region (that is, an array).</p></div><div class="sect2" title="Stream Operations"><div class="titlepage"><div><div><h2 class="title"><a id="stream_operations"/>Stream Operations</h2></div></div></div><p>All of the preceding functions handle converting to and from host byte order and bus byte order. In some cases, however, you may need to avoid this conversion. Fortunately, FreeBSD provides the following functions for such an occasion:</p><a id="I_programlisting10_d1e19020"/><pre class="programlisting">#include &lt;sys/bus.h&gt;
#include &lt;machine/bus.h&gt;

u_int8_t
bus_read_stream_1(struct resource *r, bus_size_t offset);

u_int16_t
bus_read_stream_2(struct resource *r, bus_size_t offset);

u_int32_t
bus_read_stream_4(struct resource *r, bus_size_t offset);

u_int64_t
bus_read_stream_8(struct resource *r, bus_size_t offset);


void
bus_read_multi_stream_1(struct resource *r, bus_size_t offset,
    u_int8_t *datap, bus_size_t count);

void
bus_read_multi_stream_2(struct resource *r, bus_size_t offset,
    u_int16_t *datap, bus_size_t count);

void
bus_read_multi_stream_4(struct resource *r, bus_size_t offset,
    u_int32_t *datap, bus_size_t count);

void
bus_read_multi_stream_8(struct resource *r, bus_size_t offset,
    u_int64_t *datap, bus_size_t count);


void
bus_read_region_stream_1(struct resource *r, bus_size_t offset,
    u_int8_t *datap, bus_size_t count);

void
bus_read_region_stream_2(struct resource *r, bus_size_t offset,
    u_int16_t *datap, bus_size_t count);

void
bus_read_region_stream_4(struct resource *r, bus_size_t offset,
    u_int32_t *datap, bus_size_t count);

void
bus_read_region_stream_8(struct resource *r, bus_size_t offset,
    u_int64_t *datap, bus_size_t count);


void
bus_write_stream_1(struct resource *r, bus_size_t offset,
    u_int8_t value);

void
bus_write_stream_2(struct resource *r, bus_size_t offset,
    u_int16_t value);

void
bus_write_stream_4(struct resource *r, bus_size_t offset,
    u_int32_t value);

void
bus_write_stream_8(struct resource *r, bus_size_t offset,
    u_int64_t value);


void
bus_write_multi_stream_1(struct resource *r, bus_size_t offset,
    u_int8_t *datap, bus_size_t count);

void
bus_write_multi_stream_2(struct resource *r, bus_size_t offset,
    u_int16_t *datap, bus_size_t count);

void
bus_write_multi_stream_4(struct resource *r, bus_size_t offset,
    u_int32_t *datap, bus_size_t count);

void
bus_write_multi_stream_8(struct resource *r, bus_size_t offset,
    u_int64_t *datap, bus_size_t count);


void
bus_write_region_stream_1(struct resource *r, bus_size_t offset,
    u_int8_t *datap, bus_size_t count);

void
bus_write_region_stream_2(struct resource *r, bus_size_t offset,
    u_int16_t *datap, bus_size_t count);

void
bus_write_region_stream_4(struct resource *r, bus_size_t offset,
    u_int32_t *datap, bus_size_t count);

void
bus_write_region_stream_8(struct resource *r, bus_size_t offset,
    u_int64_t *datap, bus_size_t count);


void
bus_set_multi_stream_1(struct resource *r, bus_size_t offset,
    u_int8_t value, bus_size_t count);

void
bus_set_multi_stream_2(struct resource *r, bus_size_t offset,
    u_int16_t value, bus_size_t count);

void
bus_set_multi_stream_4(struct resource *r, bus_size_t offset,
    u_int32_t value, bus_size_t count);

void
bus_set_multi_stream_8(struct resource *r, bus_size_t offset,
    u_int64_t value, bus_size_t count);


void
bus_set_region_stream_1(struct resource *r, bus_size_t offset,
    u_int8_t value, bus_size_t count);

void
bus_set_region_stream_2(struct resource *r, bus_size_t offset,
    u_int16_t value, bus_size_t count);

void
bus_set_region_stream_4(struct resource *r, bus_size_t offset,
    u_int32_t value, bus_size_t count);

void
bus_set_region_stream_8(struct resource *r, bus_size_t offset,
    u_int64_t value, bus_size_t count);</pre><p>These functions are identical to their nonstream counterparts, except that they don’t perform any byte order conversions.</p></div></div></div>
<div class="sect1" title="Memory Barriers"><div class="titlepage"><div><div><h1 class="title"><a id="memory_barriers"/>Memory Barriers</h1></div></div></div><p>Sequences of read and write instructions can often be executed more quickly if run in an order that’s different from the program text (Corbet et al., 2005). As a result, modern processors customarily reorder read and write instructions. However, this optimization can foul up drivers performing PMIO and MMIO. To prevent instruction reordering, memory barriers are employed. <span class="emphasis"><em>Memory barriers</em></span> ensure that all instructions before the barrier conclude before any instruction after the barrier. For PMIO and MMIO operations, the <code class="literal">bus_barrier</code> function provides this ability:<a class="indexterm" id="IDX-CHP-10-0019"/><a class="indexterm" id="IDX-CHP-10-0020"/><a class="indexterm" id="IDX-CHP-10-0021"/><a class="indexterm" id="IDX-CHP-10-0022"/><a class="indexterm" id="IDX-CHP-10-0023"/><a class="indexterm" id="IDX-CHP-10-0024"/><a class="indexterm" id="IDX-CHP-10-0025"/></p><a id="I_programlisting10_d1e19061"/><pre class="programlisting">#include &lt;sys/bus.h&gt;
#include &lt;machine/bus.h&gt;

void
bus_barrier(struct resource *r, bus_size_t offset, bus_size_t length,
    int flags);</pre><p>The <code class="literal">bus_barrier</code> function inserts a memory barrier that enforces the ordering of read or write operations on a region in <code class="literal">r</code>, which is described by the <code class="literal">offset</code> and <code class="literal">length</code> arguments. The <code class="literal">flags</code> argument specifies the type of operation to be ordered. Valid values for this argument are shown in <a class="xref" href="ch10s02.html#bus_underscore_barrier_symbolic_constant" title="Table 10-1. bus_barrier Symbolic Constants">Table 10-1</a>.</p><div class="table"><a id="bus_underscore_barrier_symbolic_constant"/><p class="title">Table 10-1. bus_barrier Symbolic Constants</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="bus_barrier Symbolic Constants"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Constant</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">BUS_SPACE_BARRIER_READ</code></p></td><td style="text-align: left" valign="top"><p>Synchronizes read operations</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">BUS_SPACE_BARRIER_WRITE</code></p></td><td style="text-align: left" valign="top"><p>Synchronizes write operations</p></td></tr></tbody></table></div></div><p>Note that these flags can be ORed to enforce ordering on both read and write operations. An exemplary use of <code class="literal">bus_barrier</code> looks something like this:</p><a id="I_programlisting10_d1e19119"/><pre class="programlisting">bus_write_1(r, 0, data0);
bus_barrier(r, 0, 1, BUS_SPACE_BARRIER_WRITE);
bus_write_1(r, 0, data1);
bus_barrier(r, 0, 2, BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
data2 = bus_read_1(r, 1);
bus_barrier(r, 1, 1, BUS_SPACE_BARRIER_READ);
data3 = bus_read_1(r, 1);</pre><p>Here, the calls to <code class="literal">bus_barrier</code> guarantee that the writes and reads conclude in the order written.</p></div>
<div class="sect1" title="Tying Everything Together"><div class="titlepage"><div><div><h1 class="title"><a id="tying_everything_together-id2"/>Tying Everything Together</h1></div></div></div><p><a class="xref" href="ch10s03.html#led.c" title="Example 10-1. led.c">Example 10-1</a> is a simple driver for an i-Opener’s LEDs (based on code written by Warner Losh). An i-Opener includes two LEDs that are controlled by bits 0 and 1 of the register located at 0x404c. Hopefully, this example will clarify any misunderstandings you may have about PMIO (and MMIO).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Take a quick look at this code and try to discern some of its structure. If you don’t understand all of it, don’t worry; an explanation follows.</p></div><div class="example"><a id="led.c"/><p class="title">Example 10-1. led.c</p><div class="example-contents"><pre class="programlisting">#include &lt;sys/param.h&gt;
  #include &lt;sys/module.h&gt;
  #include &lt;sys/kernel.h&gt;
  #include &lt;sys/systm.h&gt;

  #include &lt;sys/bus.h&gt;
  #include &lt;sys/conf.h&gt;
  #include &lt;sys/uio.h&gt;
  #include &lt;sys/lock.h&gt;
  #include &lt;sys/mutex.h&gt;

  #include &lt;machine/bus.h&gt;
  #include &lt;sys/rman.h&gt;
  #include &lt;machine/resource.h&gt;

<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/> #define LED_IO_ADDR             0x404c
<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/> #define LED_NUM                 2

  struct led_softc {
          int                     sc_io_rid;
          struct resource        *sc_io_resource;
          struct cdev            *sc_cdev0;
          struct cdev            *sc_cdev1;
          u_int32_t               sc_open_mask;
          u_int32_t               sc_read_mask;
          struct mtx              sc_mutex;
  };

  static devclass_t led_devclass;

  static d_open_t                 led_open;
  static d_close_t                led_close;
  static d_read_t                 led_read;
  static d_write_t                led_write;

  static struct cdevsw led_cdevsw = {
          .d_version =            D_VERSION,
          .d_open =               led_open,
          .d_close =              led_close,
          .d_read =               led_read,
          .d_write =              led_write,
          .d_name =               "led"
  };

  static int
  led_open(struct cdev *dev, int oflags, int devtype, struct thread *td)
  {
          int led = dev2unit(dev) &amp; 0xff;
          struct led_softc *sc = dev-&gt;si_drv1;

          if (led &gt;= LED_NUM)
                  return (ENXIO);

          mtx_lock(&amp;sc-&gt;sc_mutex);
          if (sc-&gt;sc_open_mask &amp; (1 &lt;&lt; led)) {
                  mtx_unlock(&amp;sc-&gt;sc_mutex);
                  return (EBUSY);
          }
          sc-&gt;sc_open_mask |= 1 &lt;&lt; led;
          sc-&gt;sc_read_mask |= 1 &lt;&lt; led;
          mtx_unlock(&amp;sc-&gt;sc_mutex);

          return (0);
  }

  static int
  led_close(struct cdev *dev, int fflag, int devtype, struct thread *td)
  {
          int led = dev2unit(dev) &amp; 0xff;
          struct led_softc *sc = dev-&gt;si_drv1;

          if (led &gt;= LED_NUM)
                  return (ENXIO);

          mtx_lock(&amp;sc-&gt;sc_mutex);
          sc-&gt;sc_open_mask &amp;= ˜(1 &lt;&lt; led);
          mtx_unlock(&amp;sc-&gt;sc_mutex);

          return (0);
  }

  static int
  led_read(struct cdev *dev, struct uio *uio, int ioflag)
  {
          int led = dev2unit(dev) &amp; 0xff;
          struct led_softc *sc = dev-&gt;si_drv1;
          u_int8_t ch;
          int error;

          if (led &gt;= LED_NUM)
                  return (ENXIO);

          mtx_lock(&amp;sc-&gt;sc_mutex);
          /* No error EOF condition. */
          if (!(sc-&gt;sc_read_mask &amp; (1 &lt;&lt; led))) {
                  mtx_unlock(&amp;sc-&gt;sc_mutex);
                  return (0);
          }
          sc-&gt;sc_read_mask &amp;= ˜(1 &lt;&lt; led);
          mtx_unlock(&amp;sc-&gt;sc_mutex);

          ch = bus_read_1(sc-&gt;sc_io_resource, 0);
          if (ch &amp; (1 &lt;&lt; led))
                  ch = '1';
          else
                  ch = '0';

          error = uiomove(&amp;ch, 1, uio);
          return (error);
  }

  static int
  led_write(struct cdev *dev, struct uio *uio, int ioflag)
  {
          int led = dev2unit(dev) &amp; 0xff;
          struct led_softc *sc = dev-&gt;si_drv1;
          u_int8_t ch;
          u_int8_t old;
          int error;

          if (led &gt;= LED_NUM)
                  return (ENXIO);

          error = uiomove(&amp;ch, 1, uio);
          if (error)
                  return (error);

          old = bus_read_1(sc-&gt;sc_io_resource, 0);
          if (ch &amp; 1)
                  old |= (1 &lt;&lt; led);
          else
                  old &amp;= ˜(1 &lt;&lt; led);

          bus_write_1(sc-&gt;sc_io_resource, 0, old);

          return (error);
  }

  static void
  led_identify(driver_t *driver, device_t parent)
  {
          device_t child;

          child = device_find_child(parent, "led", −1);
          if (!child) {
                  child = BUS_ADD_CHILD(parent, 0, "led", −1);
                  bus_set_resource(child, SYS_RES_IOPORT, 0, LED_IO_ADDR, 1);
          }
  }

  static int
  led_probe(device_t dev)
  {
          if (!bus_get_resource_start(dev, SYS_RES_IOPORT, 0))
                  return (ENXIO);

          device_set_desc(dev, "I/O Port Example");
          return (BUS_PROBE_SPECIFIC);
  }

  static int
  led_attach(device_t dev)
  {
          struct led_softc *sc = device_get_softc(dev);

          sc-&gt;sc_io_rid = 0;
          sc-&gt;sc_io_resource = bus_alloc_resource_any(dev, SYS_RES_IOPORT,
              &amp;sc-&gt;sc_io_rid, RF_ACTIVE);
          if (!sc-&gt;sc_io_resource) {
                  device_printf(dev, "unable to allocate resource\n");
                  return (ENXIO);
          }

          sc-&gt;sc_open_mask = 0;
          sc-&gt;sc_read_mask = 0;
          mtx_init(&amp;sc-&gt;sc_mutex, "led", NULL, MTX_DEF);

          sc-&gt;sc_cdev0 = make_dev(&amp;led_cdevsw, 0, UID_ROOT, GID_WHEEL, 0644,
              "led0");
          sc-&gt;sc_cdev1 = make_dev(&amp;led_cdevsw, 1, UID_ROOT, GID_WHEEL, 0644,
              "led1");
          sc-&gt;sc_cdev0-&gt;si_drv1 = sc;
          sc-&gt;sc_cdev1-&gt;si_drv1 = sc;

          return (0);
  }

  static int
  led_detach(device_t dev)
  {
          struct led_softc *sc = device_get_softc(dev);

          destroy_dev(sc-&gt;sc_cdev0);
          destroy_dev(sc-&gt;sc_cdev1);

          mtx_destroy(&amp;sc-&gt;sc_mutex);

          bus_release_resource(dev, SYS_RES_IOPORT, sc-&gt;sc_io_rid,
              sc-&gt;sc_io_resource);

          return (0);
  }

  static device_method_t led_methods[] = {
          /* Device interface. */
          DEVMETHOD(device_identify,      led_identify),
          DEVMETHOD(device_probe,         led_probe),
          DEVMETHOD(device_attach,        led_attach),
          DEVMETHOD(device_detach,        led_detach),
          { 0, 0 }
  };

  static driver_t led_driver = {
          "led",
          led_methods,
          sizeof(struct led_softc)
  };

  DRIVER_MODULE(led, isa, led_driver, led_devclass, 0, 0);</pre></div></div><p>Before I describe the functions defined in <a class="xref" href="ch10s03.html#led.c" title="Example 10-1. led.c">Example 10-1</a>, note that the constant <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19156"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">LED_IO_ADDR</code> is defined as <code class="literal">0x404c</code> and that the constant <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19168"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">LED_NUM</code> is defined as <code class="literal">2</code>.<a class="indexterm" id="IDX-CHP-10-0026"/><a class="indexterm" id="IDX-CHP-10-0027"/><a class="indexterm" id="IDX-CHP-10-0028"/><a class="indexterm" id="IDX-CHP-10-0029"/><a class="indexterm" id="IDX-CHP-10-0030"/><a class="indexterm" id="IDX-CHP-10-0031"/></p><p>The following sections describe the functions defined in <a class="xref" href="ch10s03.html#led.c" title="Example 10-1. led.c">Example 10-1</a> in the order they would roughly execute.</p><div class="sect2" title="led_identify Function"><div class="titlepage"><div><div><h2 class="title"><a id="led_underscore_identify_function"/>led_identify Function</h2></div></div></div><p>The <code class="literal">led_identify</code> function is the <code class="literal">device_identify</code> implementation for this driver. This function is required because the ISA bus cannot identify its children unaided. Here is the function definition for <code class="literal">led_identify</code> (again):</p><a id="I_programlisting10_d1e19233"/><pre class="programlisting">static void
led_identify(driver_t *driver, device_t parent)
{
        device_t child;

        child = <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>device_find_child(parent, <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>"led", −1);
        if (!child) {
                child = <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>BUS_ADD_CHILD(parent, 0, "led", −1);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>bus_set_resource(child, SYS_RES_IOPORT, 0, LED_IO_ADDR, 1);
        }
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19261"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> determines if the ISA bus has identified a child device named <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19267"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">"led"</code>. If it has not, then <code class="literal">"led"</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19279"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> appended to the ISA bus’s catalog of identified children. Afterward, <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19286"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">bus_set_resource</code> is called to specify that I/O port access for <code class="literal">"led"</code> starts at <code class="literal">LED_IO_ADDR</code>.</p></div><div class="sect2" title="led_probe Function"><div class="titlepage"><div><div><h2 class="title"><a id="led_underscore_probe_function"/>led_probe Function</h2></div></div></div><p>The <code class="literal">led_probe</code> function is the <code class="literal">device_probe</code> implementation for this driver. Here is its function definition (again):</p><a id="I_programlisting10_d1e19312"/><pre class="programlisting">static int
led_probe(device_t dev)
{
        <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (!bus_get_resource_start(dev, SYS_RES_IOPORT, 0))
                return (ENXIO);

        <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>device_set_desc(dev, "I/O Port Example");
        <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>return (BUS_PROBE_SPECIFIC);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19334"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> checks if <code class="literal">"led"</code> can acquire I/O port access. Afterward, the verbose description of <code class="literal">"led"</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19346"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> set and the success code <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19352"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">BUS_PROBE_SPECIFIC</code> is returned.<a class="indexterm" id="IDX-CHP-10-0032"/><a class="indexterm" id="IDX-CHP-10-0033"/><a class="indexterm" id="IDX-CHP-10-0034"/><a class="indexterm" id="IDX-CHP-10-0035"/><a class="indexterm" id="IDX-CHP-10-0036"/><a class="indexterm" id="IDX-CHP-10-0037"/><a class="indexterm" id="IDX-CHP-10-0038"/><a class="indexterm" id="IDX-CHP-10-0039"/><a class="indexterm" id="IDX-CHP-10-0040"/><a class="indexterm" id="IDX-CHP-10-0041"/><a class="indexterm" id="IDX-CHP-10-0042"/><a class="indexterm" id="IDX-CHP-10-0043"/></p></div><div class="sect2" title="led_attach Function"><div class="titlepage"><div><div><h2 class="title"><a id="led_underscore_attach_function"/>led_attach Function</h2></div></div></div><p>The <code class="literal">led_attach</code> function is the <code class="literal">device_attach</code> implementation for this driver. Here is its function definition (again):</p><a id="I_programlisting10_d1e19428"/><pre class="programlisting">static int
led_attach(device_t dev)
{
        struct led_softc *sc = device_get_softc(dev);

        sc-&gt;sc_io_rid = 0;
        sc-&gt;sc_io_resource = <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>bus_alloc_resource_any(dev, SYS_RES_IOPORT,
            &amp;sc-&gt;sc_io_rid, RF_ACTIVE);
        if (!sc-&gt;sc_io_resource) {
                device_printf(dev, "unable to allocate resource\n");
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>return (ENXIO);
        }

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>sc-&gt;sc_open_mask = 0;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>sc-&gt;sc_read_mask = 0;
        mtx_init(<img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>&amp;sc-&gt;sc_mutex, "led", NULL, MTX_DEF);

        sc-&gt;sc_cdev0 = <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>make_dev(&amp;led_cdevsw, 0, UID_ROOT, GID_WHEEL, 0644,
            "led0");
        sc-&gt;sc_cdev1 = <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>make_dev(&amp;led_cdevsw, 1, UID_ROOT, GID_WHEEL, 0644,
            "led1");
        sc-&gt;sc_cdev0-&gt;si_drv1 = sc;
        sc-&gt;sc_cdev1-&gt;si_drv1 = sc;

        return (0);
}</pre><p>This function begins by <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19475"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> acquiring an I/O port. If unsuccessful, the error code <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19481"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">ENXIO</code> is returned. Then the member variables <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19490"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">sc_open_mask</code> and <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19500"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">sc_read_mask</code> are zeroed; in the <code class="literal">d_foo</code> functions, these variables will be protected by <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19512"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">sc_mutex</code>. Finally, <code class="literal">led_attach</code> creates a <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19525"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19531"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> character device node for each LED.</p></div><div class="sect2" title="led_detach Function"><div class="titlepage"><div><div><h2 class="title"><a id="led_underscore_detach_function"/>led_detach Function</h2></div></div></div><p>The <code class="literal">led_detach</code> function is the <code class="literal">device_detach</code> implementation for this driver. Here is its function definition (again):</p><a id="I_programlisting10_d1e19548"/><pre class="programlisting">static int
led_detach(device_t dev)
{
        struct led_softc *sc = device_get_softc(dev);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>destroy_dev(sc-&gt;sc_cdev0);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>destroy_dev(sc-&gt;sc_cdev1);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>mtx_destroy(&amp;sc-&gt;sc_mutex);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>bus_release_resource(dev, SYS_RES_IOPORT, sc-&gt;sc_io_rid,
            sc-&gt;sc_io_resource);

        return (0);
}</pre><p>This function begins by <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19576"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19582"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> destroying its device nodes. Once this is done, it <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19588"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> destroys its mutex and <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19594"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> releases its I/O port.<a class="indexterm" id="IDX-CHP-10-0044"/><a class="indexterm" id="IDX-CHP-10-0045"/><a class="indexterm" id="IDX-CHP-10-0046"/><a class="indexterm" id="IDX-CHP-10-0047"/></p></div><div class="sect2" title="led_open Function"><div class="titlepage"><div><div><h2 class="title"><a id="led_underscore_open_function"/>led_open Function</h2></div></div></div><p>The <code class="literal">led_open</code> function is defined in <code class="literal">led_cdevsw</code> (that is, the character device switch table) as the <code class="literal">d_open</code> operation. Here is its function definition (again):</p><a id="I_programlisting10_d1e19635"/><pre class="programlisting">static int
led_open(struct cdev *dev, int oflags, int devtype, struct thread *td)
{
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>int led = dev2unit(dev) &amp; 0xff;
        struct led_softc *sc = dev-&gt;si_drv1;

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>if (led &gt;= LED_NUM)
                <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>return (ENXIO);

        mtx_lock(&amp;sc-&gt;sc_mutex);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>if (sc-&gt;sc_open_mask &amp; (1 &lt;&lt; led)) {
                mtx_unlock(&amp;sc-&gt;sc_mutex);
                <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>return (EBUSY);
        }
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>sc-&gt;sc_open_mask |= 1 &lt;&lt; led;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>sc-&gt;sc_read_mask |= 1 &lt;&lt; led;
        mtx_unlock(&amp;sc-&gt;sc_mutex);

        return (0);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19682"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> stores in <code class="literal">led</code> the unit number of the device node being opened. If <code class="literal">led</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19694"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> greater than or equal to <code class="literal">LED_NUM</code>, then <code class="literal">ENXIO</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19707"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> returned. Next, the value of <code class="literal">sc_open_mask</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19716"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> examined. If its <code class="literal">led</code> bit does not equal <code class="literal">0</code>, which indicates that another process has opened the device, then <code class="literal">EBUSY</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19732"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> returned. Otherwise, <code class="literal">sc_open_mask</code> and <code class="literal">sc_read_mask</code> are <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19744"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19750"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> set to include <code class="literal">1 &lt;&lt; led</code>. That is, their <code class="literal">led</code> bit will be changed to <code class="literal">1</code>.</p></div><div class="sect2" title="led_close Function"><div class="titlepage"><div><div><h2 class="title"><a id="led_underscore_close_function"/>led_close Function</h2></div></div></div><p>The <code class="literal">led_close</code> function is defined in <code class="literal">led_cdevsw</code> as the <code class="literal">d_close</code> operation. Here is its function definition (again):<a class="indexterm" id="IDX-CHP-10-0048"/><a class="indexterm" id="IDX-CHP-10-0049"/><a class="indexterm" id="IDX-CHP-10-0050"/><a class="indexterm" id="IDX-CHP-10-0051"/><a class="indexterm" id="IDX-CHP-10-0052"/><a class="indexterm" id="IDX-CHP-10-0053"/></p><a id="I_programlisting10_d1e19816"/><pre class="programlisting">static int
led_close(struct cdev *dev, int fflag, int devtype, struct thread *td)
{
        int led = dev2unit(dev) &amp; 0xff;
        struct led_softc *sc = dev-&gt;si_drv1;

        if (led &gt;= LED_NUM)
                return (ENXIO);

        mtx_lock(&amp;sc-&gt;sc_mutex);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>sc-&gt;sc_open_mask &amp;= ˜(1 &lt;&lt; led);
        mtx_unlock(&amp;sc-&gt;sc_mutex);

        return (0);
}</pre><p>As you can see, this function simply <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19826"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> clears <code class="literal">sc_open_mask</code>’s <code class="literal">led</code> bit (which allows another process to open this device).</p></div><div class="sect2" title="led_read Function"><div class="titlepage"><div><div><h2 class="title"><a id="led_underscore_read_function"/>led_read Function</h2></div></div></div><p>The <code class="literal">led_read</code> function is defined in <code class="literal">led_cdevsw</code> as the <code class="literal">d_read</code> operation. This function returns one character indicating whether the LED is on (<code class="literal">1</code>) or off (<code class="literal">0</code>). Here is its function definition (again):<a class="indexterm" id="IDX-CHP-10-0054"/><a class="indexterm" id="IDX-CHP-10-0055"/><a class="indexterm" id="IDX-CHP-10-0056"/></p><a id="I_programlisting10_d1e19876"/><pre class="programlisting">static int
led_read(struct cdev *dev, struct uio *uio, int ioflag)
{
        int led = dev2unit(dev) &amp; 0xff;
        struct led_softc *sc = dev-&gt;si_drv1;
        u_int8_t ch;
        int error;

        if (led &gt;= LED_NUM)
                return (ENXIO);

        mtx_lock(&amp;sc-&gt;sc_mutex);
        /* No error EOF condition. */
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (!(sc-&gt;sc_read_mask &amp; (1 &lt;&lt; led))) {
                mtx_unlock(&amp;sc-&gt;sc_mutex);
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>return (0);
        }
        sc-&gt;sc_read_mask &amp;= ˜(1 &lt;&lt; led);
        mtx_unlock(&amp;sc-&gt;sc_mutex);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>ch = bus_read_1(sc-&gt;sc_io_resource, 0);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>if (ch &amp; (1 &lt;&lt; led))
                ch = '1';
        else
                ch = '0';

        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>uiomove(&amp;ch, 1, uio);
        return (error);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19910"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> checks that <code class="literal">sc_read_mask</code>’s <code class="literal">led</code> bit is set; otherwise, it <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19922"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> exits. Next, 1 byte from the LED’s control register is <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19928"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> read into <code class="literal">ch</code>. Then <code class="literal">ch</code>’s <code class="literal">led</code> bit is <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19944"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> isolated and its value is <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e19950"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> returned to user space.</p></div><div class="sect2" title="led_write Function"><div class="titlepage"><div><div><h2 class="title"><a id="led_underscore_write_function"/>led_write Function</h2></div></div></div><p>The <code class="literal">led_write</code> function is defined in <code class="literal">led_cdevsw</code> as the <code class="literal">d_write</code> operation. This function takes in one character to turn on (<code class="literal">1</code>) or off (<code class="literal">0</code>) the LED. Here is its function definition (again):</p><a id="I_programlisting10_d1e19976"/><pre class="programlisting">static int
led_write(struct cdev *dev, struct uio *uio, int ioflag)
{
        int led = dev2unit(dev) &amp; 0xff;
        struct led_softc *sc = dev-&gt;si_drv1;
        u_int8_t ch;
        u_int8_t old;
        int error;

        if (led &gt;= LED_NUM)
                return (ENXIO);

        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>uiomove(&amp;ch, 1, uio);
        if (error)
                return (error);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>old = bus_read_1(sc-&gt;sc_io_resource, 0);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>if (ch &amp; 1)
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>old |= (1 &lt;&lt; led);
        else
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>old &amp;= ˜(1 &lt;&lt; led);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>bus_write_1(sc-&gt;sc_io_resource, 0, old);

        return (error);
}</pre><p>This function first <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e20017"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> copies one character from user space to <code class="literal">ch</code>. Next, 1 byte from the LED’s control register is <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e20026"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> read into <code class="literal">old</code>. Then, based on the <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e20035"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> value from user space, <code class="literal">old</code>’s <code class="literal">led</code> bit is turned <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e20048"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> on or <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e20054"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> off. Afterward, <code class="literal">old</code> is <span class="inlinemediaobject"><a id="I_inlinemediaobject10_d1e20063"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> written back to the LED’s control register.</p></div></div>
<div class="sect1" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="conclusion-id9"/>Conclusion</h1></div></div></div><p>This chapter described all of the functions provided by FreeBSD for performing PMIO and MMIO (that is, for accessing a device’s registers). The next chapter discusses using PMIO and MMIO with PCI devices, which are more involved than what’s been shown here.</p></div></body></html>