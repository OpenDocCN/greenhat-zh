- en: Chapter 0x400. NETWORKING
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communication and language have greatly enhanced the abilities of the human
    race. By using a common language, humans are able to transfer knowledge, coordinate
    actions, and share experiences. Similarly, programs can become much more powerful
    when they have the ability to communicate with other programs via a network. The
    real utility of a web browser isn't in the program itself, but in its ability
    to communicate with webservers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Networking is so prevalent that it is sometimes taken for granted. Many applications
    such as email, the Web, and instant messaging rely on networking. Each of these
    applications relies on a particular network protocol, but each protocol uses the
    same general network transport methods.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Many people don't realize that there are vulnerabilities in the networking protocols
    themselves. In this chapter you will learn how to network your applications using
    sockets and how to deal with common network vulnerabilities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: OSI Model
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When two computers talk to each other, they need to speak the same language.
    The structure of this language is described in layers by the OSI model. The OSI
    model provides standards that allow hardware, such as routers and firewalls, to
    focus on one particular aspect of communication that applies to them and ignore
    others. The OSI model is broken down into conceptual layers of communication.
    This way, routing and firewall hardware can focus on passing data at the lower
    layers, ignoring the higher layers of data encapsulation used by running applications.
    The seven OSI layers are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '| **Physical layer** This layer deals with the physical connection between
    two points. This is the lowest layer, whose primary role is communicating raw
    bit streams. This layer is also responsible for activating, maintaining, and deactivating
    these bit-stream communications. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
- en: '| **Data-link layer** This layer deals with actually transferring data between
    two points. In contrast with the physical layer, which takes care of sending the
    raw bits, this layer provides high-level functions, such as error correction and
    flow control. This layer also provides procedures for activating, maintaining,
    and deactivating data-link connections. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
- en: '| **Network layer** This layer works as a middle ground; its primary role is
    to pass information between the lower and the higher layers. It provides addressing
    and routing. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
- en: '| **Transport layer** This layer provides transparent transfer of data between
    systems. By providing reliable data communication, this layer allows the higher
    layers to never worry about reliability or cost-effectiveness of data transmission.
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
- en: '| **Session layer** This layer is responsible for establishing and maintaining
    connections between network applications. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
- en: '| **Presentation layer** This layer is responsible for presenting the data
    to applications in a syntax or language they understand. This allows for things
    like encryption and data compression. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
- en: '| **Application layer** This layer is concerned with keeping track of the requirements
    of the application. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **应用层** 这一层关注跟踪应用程序的需求。 |'
- en: When data is communicated through these protocol layers, it's sent in small
    pieces called packets. Each packet contains implementations of these protocol
    layers. Starting from the application layer, the packet wraps the pre-sentation
    layer around that data, which wraps the session layer, which wraps the transport
    layer, and so forth. This process is called encapsulation. Each wrapped layer
    contains a header and a body. The header contains the protocol information needed
    for that layer, while the body contains the data for that layer. The body of one
    layer contains the entire package of previously encapsulated layers, like the
    skin of an onion or the functional contexts found on a program's stack.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据通过这些协议层进行通信时，它被分成小块，称为数据包。每个数据包包含这些协议层的实现。从应用层开始，数据包将表示层包裹在数据周围，然后是会话层，再然后是传输层，以此类推。这个过程称为封装。每个封装层包含一个头部和一个主体。头部包含该层所需的协议信息，而主体包含该层的数据。一个层的主体包含之前封装的所有层的整个包，就像洋葱的皮或程序堆栈上找到的功能上下文一样。
- en: For example, whenever you browse the Web, the Ethernet cable and card make up
    the physical layer, taking care of the transmission of raw bits from one end of
    the cable to the other. The next later is the data link layer. In the web browser
    example, Ethernet makes up this layer, which provides the low-level communications
    between Ethernet ports on the LAN. This protocol allows for communication between
    Ethernet ports, but these ports don't yet have IP addresses. The concept of IP
    addresses doesn't exist until the next layer, the network layer. In addition to
    addressing, this layer is responsible for moving data from one address to another.
    These three lower layers together are able to send packets of data from one IP
    address to another. The next layer is the transport layer, which for web traffic
    is TCP; it provides a seamless bidirectional socket connection. The term *TCP/IP*describes
    the use of TCP on the transport layer and IP on the network layer. Other addressing
    schemes exist at this layer; however, your web traffic probably uses IP version
    4 (IPv4). IPv4 addresses follow a familiar form of *XX.XX.XX.XX.*. IP version
    6 (IPv6) also exists on this layer, with a totally different addressing scheme.
    Since IPv4 is most common, *IP* will always refer to IPv4 in this book.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，每次你浏览网页时，以太网电缆和卡组成物理层，负责将原始比特从电缆一端传输到另一端。下一层是数据链路层。在网页浏览器的例子中，以太网构成了这一层，它提供了局域网中以太网端口之间的低级通信。这个协议允许以太网端口之间的通信，但这些端口还没有IP地址。IP地址的概念直到下一层，即网络层才存在。除了寻址之外，这一层还负责将数据从一个地址移动到另一个地址。这三个较低层共同能够将数据包从一个IP地址发送到另一个IP地址。下一层是传输层，对于网络流量来说是TCP；它提供了一个无缝的双向套接字连接。术语*TCP/IP*描述了在传输层使用TCP和在网络层使用IP。在这一层存在其他寻址方案；然而，你的网络流量可能使用IP版本4（IPv4）。IP版本6（IPv6）也存在于这一层，具有完全不同的寻址方案。由于IPv4最常见，本书中的*IP*始终指IPv4。
- en: The web traffic itself uses HTTP (Hypertext Transfer Protocol) to communicate,
    which is in the top layer of the OSI model. When you browse the Web, the web browser
    on your network is communicating across the Internet with the webserver located
    on a different private network. When this happens, the data packets are encapsulated
    down to the physical layer where they are passed to a router. Since the router
    isn't concerned with what's actually in the packets, it only needs to implement
    protocols up to the network layer. The router sends the packets out to the Internet,
    where they reach the other network's router. This router then encapsulates this
    packet with the lowerlayer protocol headers needed for the packet to reach its
    final destination. This process is shown in the following illustration.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 网络流量本身使用HTTP（超文本传输协议）进行通信，这是OSI模型的顶层。当你浏览网页时，你网络上的网络浏览器正通过互联网与位于不同私有网络上的web服务器进行通信。当这种情况发生时，数据包被封装到物理层，然后传递给路由器。由于路由器不关心数据包中实际的内容，它只需要实现到网络层的协议。路由器将数据包发送到互联网，在那里它们到达另一个网络的路由器。然后，这个路由器将这个数据包封装成需要到达最终目的地的低层协议头部。这个过程在下面的插图中有展示。
- en: '![](httpatomoreillycomsourcenostarchimages254249.png.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](httpatomoreillycomsourcenostarchimages254249.png.jpg)'
- en: Figure 0x400-1.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0x400-1。
- en: All of this packet encapsulation makes up a complex language that hosts on the
    Internet (and other types of networks) use to communicate with each other. These
    protocols are programmed into routers, firewalls, and your computer's operating
    system so they can communicate. Programs that use networking, such as web browsers
    and email clients, need to interface with the operating system which handles the
    network communications. Since the operating system takes care of the details of
    network encapsulation, writing network programs is just a matter of using the
    network interface of the OS.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数据包封装构成了一个复杂的语言，互联网（以及其他类型的网络）上的主机使用它来相互通信。这些协议被编程到路由器、防火墙以及您的计算机操作系统中，以便它们可以通信。使用网络的应用程序，如网页浏览器和电子邮件客户端，需要与操作系统接口，该操作系统处理网络通信。由于操作系统负责网络封装的细节，编写网络程序只是使用操作系统的网络接口的问题。
- en: Sockets
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字
- en: A socket is a standard way to perform network communication through the OS.
    A socket can be thought of as an endpoint to a connection, like a socket on an
    operator's switchboard. But these sockets are just a programmer's abstraction
    that takes care of all the nitty-gritty details of the OSI model described above.
    To the programmer, a socket can be used to send or receive data over a network.
    This data is transmitted at the session layer (5), above the lower layers (handled
    by the operating system), which take care of routing. There are several different
    types of sockets that determine the structure of the transport layer (4). The
    most common types are stream sockets and datagram sockets.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 网络套接字是通过操作系统执行网络通信的标准方式。套接字可以被视为连接的端点，就像操作员交换机上的一孔。但这些套接字只是程序员对上述OSI模型中所有繁琐细节的抽象处理。对于程序员来说，套接字可以用来在网络中发送或接收数据。这些数据在会话层（5）传输，位于下层（由操作系统处理）之上，下层负责路由。存在几种不同类型的套接字，它们决定了传输层（4）的结构。最常见的是流套接字和数据报套接字。
- en: Stream sockets provide reliable two-way communication similar to when you call
    someone on the phone. One side initiates the connection to the other, and after
    the connection is established, either side can communicate to the other. In addition,
    there is immediate confirmation that what you said actually reached its destination.
    Stream sockets use a standard communication protocol called Transmission Control
    Protocol (TCP), which exists on the transport layer (4) of the OSI model. On computer
    networks, data is usually transmitted in chunks called packets. TCP is designed
    so that the packets of data will arrive without errors and in sequence, like words
    arriving at the other end in the order they were spoken when you are talking on
    the telephone. Webservers, mail servers, and their respective client applications
    all use TCP and stream sockets to communicate.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 流套接字提供类似于打电话时的可靠双向通信。一方发起与另一方的连接，连接建立后，任何一方都可以与另一方通信。此外，还有即时的确认，表明您所说的话确实到达了目的地。流套接字使用一种称为传输控制协议（TCP）的标准通信协议，该协议存在于OSI模型的传输层（4）上。在计算机网络中，数据通常以称为数据包的块的形式传输。TCP被设计成数据包将无错误且按顺序到达，就像您在电话中说话时，另一端接收到的单词顺序与您说话的顺序相同。Web服务器、邮件服务器及其相应的客户端应用程序都使用TCP和流套接字进行通信。
- en: Another common type of socket is a datagram socket. Communicating with a datagram
    socket is more like mailing a letter than making a phone call. The connection
    is one-way only and unreliable. If you mail several letters, you can't be sure
    that they arrived in the same order, or even that they reached their destination
    at all. The postal service is pretty reliable; the Internet, however, is not.
    Datagram sockets use another standard protocol called UDP instead of TCP on the
    transport layer (4). UDP stands for User Datagram Protocol, implying that it can
    be used to create custom protocols. This protocol is very basic and lightweight,
    with few safeguards built into it. It's not a real connection, just a basic method
    for sending data from one point to another. With datagram sockets, there is very
    little overhead in the protocol, but the protocol doesn't do much. If your program
    needs to confirm that a packet was received by the other side, the other side
    must be coded to send back an acknowledgment packet. In some cases packet loss
    is acceptable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Datagram sockets and UDP are commonly used in networked games and streaming
    media, since developers can tailor their communications exactly as needed without
    the built-in overhead of TCP.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Socket Functions
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C, sockets behave a lot like files since they use file descriptors to identify
    themselves. Sockets behave so much like files that you can actually use the `read()`
    and `write()` functions to receive and send data using socket file descriptors.
    However, there are several functions specifically designed for dealing with sockets.
    These functions have their prototypes defined in /usr/include/sys/sockets.h.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '**`socket(int domain, int type, int protocol)`**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Used to create a new socket, returns a file descriptor for the socket or `-1`
    on error.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**`connect(int fd, struct sockaddr *remote_host, socklen_t addr_length)`**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Connects a socket (described by file descriptor `fd`) to a remote host. Returns
    `0` on success and `-1` on error.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '**`bind(int fd, struct sockaddr *local_addr, socklen_t addr_length)`**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Binds a socket to a local address so it can listen for incoming connections.
    Returns `0` on success and `-1` on error.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '**`listen(int fd, int backlog_queue_size)`**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Listens for incoming connections and queues connection requests up to `backlog_queue_size`.
    Returns `0` on success and `-1` on error.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**`accept(int fd, sockaddr *remote_host, socklen_t *addr_length)`**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Accepts an incoming connection on a bound socket. The address information from
    the remote host is written into the `remote_host` structure and the actual size
    of the address structure is written into `*addr_length`. This function returns
    a new socket file descriptor to identify the connected socket or `-1` on error.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '**``send(int fd, void *buffer, size_t *`n`*, int flags)``**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Sends *`n`* bytes from `*buffer` to socket `fd`; returns the number of bytes
    sent or `-1` on error.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**``recv(int fd, void *buffer, size_t *`n`*, int flags)``**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Receives *`n`* bytes from socket `fd` into `*buffer`; returns the number of
    bytes received or `-1` on error.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: When a socket is created with the `socket()` function, the domain, type, and
    protocol of the socket must be specified. The domain refers to the protocol family
    of the socket. A socket can be used to communicate using a variety of protocols,
    from the standard Internet protocol used when you browse the Web to amateur radio
    protocols such as AX.25 (when you are being a gigantic nerd). These protocol families
    are defined in bits/socket.h, which is automatically included from sys/socket.h.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: From /usr/include/bits/socket.h
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As mentioned before, there are several types of sockets, although stream sockets
    and datagram sockets are the most commonly used. The types of sockets are also
    defined in bits/socket.h. (The `/* comments */` in the code above are just another
    style that comments out everything between the asterisks.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: From /usr/include/bits/socket.h
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The final argument for the `socket()` function is the protocol, which should
    almost always be `0`. The specification allows for multiple protocols within a
    protocol family, so this argument is used to select one of the protocols from
    the family. In practice, however, most protocol families only have one protocol,
    which means this should usually be set for `0`; the first and only protocol in
    the enumeration of the family. This is the case for everything we will do with
    sockets in this book, so this argument will always be `0` in our examples.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Socket Addresses
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of the socket functions reference a `sockaddr` structure to pass address
    information that defines a host. This structure is also defined in bits/socket.h,
    as shown on the following page.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: From /usr/include/bits/socket.h
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The macro for `SOCKADDR_COMMON` is defined in the included bits/sockaddr.h file,
    which basically translates to an unsigned short int. This value defines the address
    family of the address, and the rest of the structure is saved for address data.
    Since sockets can communicate using a variety of protocol families, each with
    their own way of defining endpoint addresses, the definition of an address must
    also be variable, depending on the address family. The possible address families
    are also defined in bits/socket.h; they usually translate directly to the corresponding
    protocol families.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: From /usr/include/bits/socket.h
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since an address can contain different types of information, depending on the
    address family, there are several other address structures that contain, in the
    address data section, common elements from the `sockaddr` structure as well as
    information specific to the address family. These structures are also the same
    size, so they can be typecast to and from each other. This means that a `socket()`
    function will simply accept a pointer to a `sockaddr` structure, which can in
    fact point to an address structure for IPv4, IPv6, or X.25\. This allows the socket
    functions to operate on a variety of protocols.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: In this book we are going to deal with Internet Protocol version 4, which is
    the protocol family `PF_INET`, using the address family `AF_INET`. The parallel
    socket address structure for `AF_INET` is defined in the netinet/in.h file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: From /usr/include/netinet/in.h
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `SOCKADDR_COMMON` part at the top of the structure is simply the unsigned
    short int mentioned above, which is used to define the address family. Since a
    socket endpoint address consists of an Internet address and a port number, these
    are the next two values in the structure. The port number is a 16-bit short, while
    the `in_addr` structure used for the Internet address contains a 32-bit number.
    The rest of the structure is just 8 bytes of padding to fill out the rest of the
    `sockaddr` structure. This space isn''t used for anything, but must be saved so
    the structures can be interchangeably typecast. In the end, the socket address
    structures end up looking like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages254410.png.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: Figure 0x400-2.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Network Byte Order
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The port number and IP address used in the `AF_INET` socket address structure
    are expected to follow the network byte ordering, which is big-endian. This is
    the opposite of *x*86''s little-endian byte ordering, so these values must be
    converted. There are several functions specifically for these conversions, whose
    prototypes are defined in the netinet/in.h and arpa/inet.h include files. Here
    is a summary of these common byte order conversion functions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '**`htonl`***`(long value)`* **Host-to-Network Long**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Converts a 32-bit integer from the host's byte order to network byte order
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '**`htons`***`(short value)`* **Host-to-Network Short**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Converts a 16-bit integer from the host's byte order to network byte order
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '**`ntohl`***`(long value)`* **Network-to-Host Long**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Converts a 32-bit integer from network byte order to the host's byte order
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '**`ntohs`***`(long value)`* **Network-to-Host Short**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Converts a 16-bit integer from network byte order to the host's byte order
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: For compatibility with all architectures, these conversion functions should
    still be used even if the host is using a processor with big-endian byte ordering.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Internet Address Conversion
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you see 12.110.110.204, you probably recognize this as an Internet address
    (IP version 4). This familiar dotted-number notation is a common way to specify
    Internet addresses, and there are functions to convert this notation to and from
    a 32-bit integer in network byte order. These functions are defined in the arpa/inet.h
    include file, and the two most useful conversion functions are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**ASCII to Network**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: This function converts an ASCII string containing an IP address in dottednumber
    format into an `in_addr` structure, which, as you remember, only contains a 32-bit
    integer representing the IP address in network byte order.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Network to ASCII**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: This function converts the other way. It is passed a pointer to an `in_addr`
    structure containing an IP address, and the function returns a character pointer
    to an ASCII string containing the IP address in dotted-number format. This string
    is held in a statically allocated memory buffer in the function, so it can be
    accessed until the next call to `inet_ntoa()`, when the string will be overwritten.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Server Example
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to show how these functions are used is by example. The following
    server code listens for TCP connections on port 7890\. When a client connects,
    it sends the message *Hello, world!* and then receives data until the connection
    is closed. This is done using socket functions and structures from the include
    files mentioned earlier, so these files are included at the beginning of the program.
    A useful memory dump function has been added to hacking.h, which is shown on the
    following page.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Added to hacking.h
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function is used to display packet data by the server program. However,
    since it is also useful in other places, it has been put into hacking.h, instead.
    The rest of the server program will be explained as you read the source code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: simple_server.c
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So far, the program sets up a socket using the `socket()` function. We want
    a TCP/IP socket, so the protocol family is `PF_INET` for IPv4 and the socket type
    is `SOCK_STREAM` for a stream socket. The final protocol argument is `0`, since
    there is only one protocol in the `PF_INET` protocol family. This function returns
    a socket file descriptor which is stored in `sockfd`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The `setsockopt()` function is simply used to set socket options. This function
    call sets the `SO_REUSEADDR` socket option to `true`, which will allow it to reuse
    a given address for binding. Without this option set, when the program tries to
    bind to a given port, it will fail if that port is already in use. If a socket
    isn't closed properly, it may appear to be in use, so this option lets a socket
    bind to a port (and take over control of it), even if it seems to be in use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to this function is the socket (referenced by a file descriptor),
    the second specifies the level of the option, and the third specifies the option
    itself. Since `SO_REUSEADDR` is a socket-level option, the level is set to `SOL_SOCKET`.
    There are many different socket options defined in /usr/include/ asm/socket.h.
    The final two arguments are a pointer to the data that the option should be set
    to and the length of that data. A pointer to data and the length of that data
    are two arguments that are often used with socket functions. This allows the functions
    to handle all sorts of data, from single bytes to large data structures. The `SO_REUSEADDR`
    options uses a 32-bit integer for its value, so to set this option to `true`,
    the final two arguments must be a pointer to the integer value of `1` and the
    size of an integer (which is 4 bytes).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These next few lines set up the `host_addr` structure for use in the bind call.
    The address family is `AF_INET`, since we are using IPv4 and the `sockaddr_in`structure.
    The port is set to `PORT`, which is defined as `7890`. This short integer value
    must be converted into network byte order, so the `htons()` function is used.
    The address is set to `0`, which means it will automatically be filled with the
    host's current IP address. Since the value `0` is the same regardless of byte
    order, no conversion is necessary.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行设置了 `host_addr` 结构，用于在 `bind` 调用中使用。地址族是 `AF_INET`，因为我们使用 IPv4 和 `sockaddr_in`
    结构。端口号设置为 `PORT`，它定义为 `7890`。这个短整数值必须转换为网络字节顺序，因此使用 `htons()` 函数。地址设置为 `0`，这意味着它将自动填充为主机的当前
    IP 地址。由于 `0` 的值与字节顺序无关，因此不需要转换。
- en: The `bind()` call passes the socket file descriptor, the address structure,
    and the length of the address structure. This call will bind the socket to the
    current IP address on port 7890.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()` 调用传递套接字文件描述符、地址结构和地址结构长度。此调用将套接字绑定到当前 IP 地址的 7890 端口。'
- en: The `listen()` call tells the socket to listen for incoming connections, and
    a subsequent `accept()` call actually accepts an incoming connection. The `listen()`
    function places all incoming connections into a backlog queue until an `accept()`
    call accepts the connections. The last argument to the `listen()` call sets the
    maximum size for the backlog queue.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`listen()` 调用告诉套接字监听传入的连接，并且随后的 `accept()` 调用实际上接受了一个传入的连接。`listen()` 函数将所有传入的连接放入一个后备队列中，直到
    `accept()` 调用接受连接。`listen()` 调用的最后一个参数设置了后备队列的最大大小。'
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next is a loop that accepts incoming connections. The `accept()` function's
    first two arguments should make sense immediately; the final argument is a pointer
    to the size of the address structure. This is because the `accept()` function
    will write the connecting client's address information into the address structure
    and the size of that structure into `sin_size`. For our purposes, the size never
    changes, but to use the function we must obey the calling convention. The `accept()`
    function returns a new socket file descriptor for the accepted connection. This
    way, the original socket file descriptor can continue to be used for accepting
    new connections, while the new socket file descriptor is used for communicating
    with the connected client.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个接受传入连接的循环。`accept()` 函数的前两个参数应该立即有意义；最后一个参数是指向地址结构大小的指针。这是因为 `accept()`
    函数会将连接客户端的地址信息写入地址结构，并将该结构的大小写入 `sin_size`。对于我们的目的，大小永远不会改变，但为了使用该函数，我们必须遵守调用约定。`accept()`
    函数返回已接受连接的新套接字文件描述符。这样，原始套接字文件描述符可以继续用于接受新的连接，而新的套接字文件描述符用于与已连接的客户端通信。
- en: After getting a connection, the program prints out a connection message, using
    `inet_ntoa()` to convert the `sin_addr` address structure to a dotted-number IP
    string and `ntohs()` to convert the byte order of the `sin_port` number.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立连接后，程序会打印出一个连接消息，使用 `inet_ntoa()` 将 `sin_addr` 地址结构转换为点分十进制 IP 字符串，并使用 `ntohs()`
    将 `sin_port` 数字字节的顺序转换为网络字节顺序。
- en: The `send()` function sends the 13 bytes of the string `Hello, world!\n` to
    the new socket that describes the new connection. The final argument for the `send()`
    and `recv()` functions are flags, that for our purposes, will always be `0`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()` 函数将字符串 `Hello, world!\n` 的 13 个字节发送到描述新连接的新套接字。`send()` 和 `recv()`
    函数的最后一个参数是标志，对于我们的目的，将始终是 `0`。'
- en: Next is a loop that receives data from the connection and prints it out. The
    `recv()` function is given a pointer to a buffer and a maximum length to read
    from the socket. The function writes the data into the buffer passed to it and
    returns the number of bytes it actually wrote. The loop will continue as long
    as the `recv()` call continues to receive data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个循环，它从连接接收数据并将其打印出来。`recv()` 函数提供了一个指向缓冲区的指针和一个从套接字读取的最大长度。该函数将数据写入传递给它的缓冲区，并返回实际写入的字节数。只要
    `recv()` 调用继续接收数据，循环就会继续。
- en: 'When compiled and run, the program binds to port 7890 of the host and waits
    for incoming connections:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译并运行时，程序将绑定到主机的 7890 端口并等待传入的连接：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A telnet client basically works like a generic TCP connection client, so it
    can be used to connect to the simple server by specifying the target IP address
    and port.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet 客户端基本上就像一个通用的 TCP 连接客户端，因此可以通过指定目标 IP 地址和端口来连接到简单服务器。
- en: From a Remote Machine
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自远程机器
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Upon connection, the server sends the string `Hello, world!`, and the rest is
    the local character echo of me typing `this is a test` and a line of keyboard
    mashing. Since telnet is line-buffered, each of these two lines is sent back to
    the server when `ENTER` is pressed. Back on the server side, the output shows
    the connection and the packets of data that are sent back.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 连接后，服务器发送字符串`Hello, world!`，其余的是我输入`this is a test`的本地字符回显和一行键盘敲击。由于telnet是按行缓冲的，所以这两行在按下`ENTER`键时都会发送回服务器。在服务器端，输出显示了连接和数据包，这些数据包被发送回。
- en: On a Local Machine
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在本地机器上
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A Web Client Example
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个Web客户端示例
- en: The telnet program works well as a client for our server, so there really isn't
    much reason to write a specialized client. However, there are thousands of different
    types of servers that accept standard TCP/IP connections. Every time you use a
    web browser, it makes a connection to a webserver somewhere. This connection transmits
    the web page over the connection using HTTP, which defines a certain way to request
    and send information. By default, webservers run on port 80, which is listed along
    with many other default ports in /etc/services.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: telnet程序作为我们的服务器客户端工作得很好，所以实际上没有太多理由去编写一个专门的客户端。然而，有成千上万种不同类型的服务器接受标准的TCP/IP连接。每次你使用网络浏览器时，它都会连接到某个地方的web服务器。这个连接通过HTTP在连接上传输网页，HTTP定义了请求和发送信息的一种特定方式。默认情况下，web服务器运行在端口80上，这个端口在/etc/services中列出了许多其他默认端口。
- en: From /etc/services
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自/etc/services
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: HTTP exists in the application layer—the top layer—of the OSI model. At this
    layer, all of the networking details have already been taken care of by the lower
    layers, so HTTP uses plaintext for its structure. Many other application layer
    protocols also use plaintext, such as POP3, SMTP, IMAP, and FTP's control channel.
    Since these are standard protocols, they are all well documented and easily researched.
    Once you know the syntax of these various protocols, you can manually talk to
    other programs that speak the same language. There's no need to be fluent, but
    knowing a few important phrases will help you when traveling to foreign servers.
    In the language of HTTP, requests are made using the command `GET`, followed by
    the resource path and the HTTP protocol version. For example, `GET / HTTP/1.0`
    will request the root document from the webserver using HTTP version 1.0\. The
    request is actually for the root directory of /, but most webservers will automatically
    search for a default HTML document in that directory of index.html. If the server
    finds the resource, it will respond using HTTP by sending several headers before
    sending the content. If the command `HEAD` is used instead of `GET`, it will only
    return the HTTP headers without the content. These headers are plaintext and can
    usually provide information about the server. These headers can be retrieved manually
    using telnet by connecting to port 80 of a known website, then typing `HEAD /
    HTTP/1.0` and pressing ENTER twice. In the output below, telnet is used to open
    a TCP-IP connection to the webserver at [http://www.internic.net](http://www.internic.net).
    Then the HTTP application layer is manually spoken to request the headers for
    the main index page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP存在于OSI模型的网络层——最顶层。在这一层，所有网络细节都已经被下层处理完毕，因此HTTP使用明文作为其结构。许多其他应用层协议也使用明文，例如POP3、SMTP、IMAP以及FTP的控制通道。由于这些是标准协议，它们都有很好的文档记录，并且易于研究。一旦你了解了这些各种协议的语法，你就可以手动与其他使用相同语言的程序进行交流。不需要流利，但了解一些重要短语将有助于你在访问国外服务器时。在HTTP的语言中，使用命令`GET`发起请求，后跟资源路径和HTTP协议版本。例如，`GET
    / HTTP/1.0`将使用HTTP 1.0版本从web服务器请求根文档。实际上，请求的是`/`的根目录，但大多数web服务器会自动在该目录中搜索默认的HTML文档index.html。如果服务器找到资源，它将通过发送几个头部信息来使用HTTP响应，然后再发送内容。如果使用的是命令`HEAD`而不是`GET`，它将只返回HTTP头部信息而不包含内容。这些头部信息是明文的，通常可以提供关于服务器的信息。这些头部信息可以通过telnet手动获取，通过连接到已知网站的80端口，然后输入`HEAD
    / HTTP/1.0`并按两次ENTER。在下面的输出中，telnet用于打开到[http://www.internic.net](http://www.internic.net)的web服务器的TCP-IP连接。然后手动与HTTP应用层进行交流，请求主索引页的头部信息。
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This reveals that the webserver is Apache version 2.0.52 and even that the host
    runs CentOS. This can be useful for profiling, so let's write a program that automates
    this manual process.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这揭示了web服务器是Apache版本2.0.52，甚至可以知道主机运行的是CentOS。这对于配置文件分析可能很有用，所以让我们编写一个程序来自动化这个手动过程。
- en: The next few programs will be sending and receiving a lot of data. Since the
    standard socket functions aren't very friendly, let's write some functions to
    send and receive data. These functions, called `send_string()` and `recv_line()`,
    will be added to a new include file called hacking-network.h.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个程序将发送和接收大量数据。由于标准套接字函数不是很友好，让我们编写一些发送和接收数据的函数。这些函数被称为 `send_string()`
    和 `recv_line()`，并将添加到一个名为 hacking-network.h 的新头文件中。
- en: The normal `send()` function returns the number of bytes written, which isn't
    always equal to the number of bytes you tried to send. The `send_string()` function
    accepts a socket and a string pointer as arguments and makes sure the entire string
    is sent out over the socket. It uses `strlen()` to figure out the total length
    of the string passed to it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的 `send()` 函数返回写入的字节数，这并不总是等于你尝试发送的字节数。`send_string()` 函数接受一个套接字和一个字符串指针作为参数，并确保整个字符串通过套接字发送出去。它使用
    `strlen()` 来确定传递给它的字符串的总长度。
- en: You may have noticed that every packet the simple server received ended with
    the bytes `0x0D` and `0x0A`. This is how telnet terminates the lines—it sends
    a carriage return and a newline character. The HTTP protocol also expects lines
    to be terminated with these two bytes. A quick look at an ASCII table shows that
    `0x0D` is a carriage return (`'\r'`) and `0x0A` is the newline character (`'\n'`).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，简单服务器接收到的每个数据包都以字节 `0x0D` 和 `0x0A` 结尾。这就是 telnet 终止行的方式——它发送一个回车符和一个换行符。HTTP
    协议也期望行以这两个字节结束。快速查看 ASCII 表可以看出，`0x0D` 是回车符 (`'\r'`)，而 `0x0A` 是换行符 (`'\n'`)。
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `recv_line()` function reads entire lines of data. It reads from the socket
    passed as the first argument into the a buffer that the second argument points
    to. It continues receiving from the socket until it encounters the last two linetermination
    bytes in sequence. Then it terminates the string and exits the function. These
    new functions ensure that all bytes are sent and receive data as lines terminated
    by `'\r\n'`. They are listed below in a new include file called hacking-network.h.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`recv_line()` 函数读取整个数据行。它从作为第一个参数传递的套接字读取数据到第二个参数指向的缓冲区。它继续从套接字接收数据，直到遇到连续的最后一个两个行终止字节。然后它终止字符串并退出函数。这些新函数确保所有字节都发送和接收以
    `''\r\n''` 结尾的数据行。它们列在下面，在一个名为 hacking-network.h 的新头文件中。'
- en: hacking-network.h
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: hacking-network.h
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Making a socket connection to a numerical IP address is pretty simple but named
    addresses are commonly used for convenience. In the manual `HTTP HEAD` request,
    the telnet program automatically does a DNS (Domain Name Service) lookup to determine
    that [www.internic.net](http://www.internic.net) translates to the IP address
    192.0.34.161\. DNS is a protocol that allows an IP address to be looked up by
    a named address, similar to how a phone number can be looked up in a phone book
    if you know the name. Naturally, there are socket-related functions and structures
    specifically for hostname lookups via DNS. These functions and structures are
    defined in netdb.h. A function called `gethostbyname()` takes a pointer to a string
    containing a named address and returns a pointer to a `hostent`structure, or `NULL`
    pointer on error. The `hostent` structure is filled with information from the
    lookup, including the numerical IP address as a 32-bit integer in network byte
    order. Similar to the `inet_ntoa()` function, the memory for this structure is
    statically allocated in the function. This structure is shown below, as listed
    in netdb.h.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将套接字连接到数值 IP 地址相当简单，但命名地址通常用于方便。在手册 `HTTP HEAD` 请求中，telnet 程序自动执行 DNS（域名服务）查找以确定
    [www.internic.net](http://www.internic.net) 对应于 IP 地址 192.0.34.161。DNS 是一种协议，允许通过命名地址查找
    IP 地址，类似于如果你知道名字，可以在电话簿中查找电话号码。自然，有一些与套接字相关的函数和结构专门用于通过 DNS 进行主机名查找。这些函数和结构在 netdb.h
    中定义。一个名为 `gethostbyname()` 的函数接受一个包含命名地址的字符串指针，并在成功时返回一个指向 `hostent` 结构的指针，或者在出错时返回
    `NULL` 指针。`hostent` 结构包含查找信息，包括作为网络字节顺序的 32 位整数的数值 IP 地址。类似于 `inet_ntoa()` 函数，这个结构的内存是在函数中静态分配的。这个结构如下所示，列在
    netdb.h 中。
- en: From /usr/include/netdb.h
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 /usr/include/netdb.h
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The following code demonstrates the use of the `gethostbyname()` function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了 `gethostbyname()` 函数的使用。
- en: host_lookup.c
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: host_lookup.c
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This program accepts a hostname as its only argument and prints out the IP address.
    The `gethostbyname()` function returns a pointer to a `hostent` structure, which
    contains the IP address in element `h_addr`. A pointer to this element is typecast
    into an `in_addr` pointer, which is later dereferenced for the call to `inet_ntoa()`,
    which expects a `in_addr` structure as its argument. Sample program output is
    shown on the following page.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序接受一个主机名作为其唯一参数，并打印出IP地址。`gethostbyname()`函数返回一个指向`hostent`结构的指针，该结构包含在元素`h_addr`中的IP地址。将此元素的指针转换为`in_addr`指针，稍后用于调用`inet_ntoa()`，该函数期望一个`in_addr`结构作为其参数。以下页面展示了示例程序输出。
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using socket functions to build on this, creating a webserver identification
    program isn't that difficult.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用套接字函数构建在此之上，创建一个网络服务器识别程序并不困难。
- en: webserver_id.c
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: webserver_id.c
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Most of this code should make sense to you now. The `target_addr` structure's
    `sin_addr` element is filled using the address from the `host_info` structure
    by typecasting and then dereferencing as before (but this time it's done in a
    single line). The `connect()` function is called to connect to port 80 of the
    target host, the command string is sent, and the program loops reading each line
    into buffer. The `strncasecmp()` function is a string comparison function from
    strings.h. This function compares the first *n* bytes of two strings, ignoring
    capitalization. The first two arguments are pointers to the strings, and the third
    argument is *n*, the number of bytes to compare. The function will return `0`
    if the strings match, so the `if` statement is searching for the line that starts
    with `"Server:"`. When it finds it, it removes the first eight bytes and prints
    the webserver version information. The following listing shows compilation and
    execution of the program.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大部分代码应该对你来说都是有意义的。`target_addr`结构的`sin_addr`元素使用之前的方法通过类型转换和间接引用填充了`host_info`结构中的地址。调用`connect()`函数连接到目标主机的80端口，发送命令字符串，程序循环读取每一行到缓冲区。`strncasecmp()`函数是strings.h中的字符串比较函数。此函数比较两个字符串的前*n*个字节，忽略大小写。前两个参数是字符串的指针，第三个参数是*n*，要比较的字节数。如果字符串匹配，函数将返回`0`，因此`if`语句正在寻找以`"Server:"`开头的行。当找到它时，它将删除前八个字节并打印出网络服务器的版本信息。以下列表显示了程序的编译和执行。
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A Tinyweb Server
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个Tinyweb服务器
- en: A webserver doesn't have to be much more complex than the simple server we created
    in the previous section. After accepting a TCP-IP connection, the webserver needs
    to implement further layers of communication using the HTTP protocol.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器不必比我们在上一节中创建的简单服务器复杂得多。在接收TCP-IP连接后，网络服务器需要使用HTTP协议实现进一步的通信层。
- en: The server code listed below is nearly identical to the simple server, except
    that connection handling code is separated into its own function. This function
    handles HTTP `GET` and `HEAD` requests that would come from a web browser. The
    program will look for the requested resource in the local directory called webroot
    and send it to the browser. If the file can't be found, the server will respond
    with a 404 HTTP response. You may already be familiar with this response, which
    means *File Not Found*. The complete source code listing follows.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下面列出的服务器代码几乎与简单服务器相同，除了连接处理代码被分离到自己的函数中。此函数处理来自网络浏览器的HTTP `GET`和`HEAD`请求。程序将在名为webroot的本地目录中查找请求的资源并将其发送到浏览器。如果找不到文件，服务器将返回404
    HTTP响应。你可能已经熟悉这个响应，这意味着*文件未找到*。完整的源代码列表如下。
- en: tinyweb.c
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tinyweb.c
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `handle_connection` function uses the `strstr()` function to look for the
    substring `HTTP/` in the request buffer. The `strstr()` function returns a pointer
    to the substring, which will be right at the end of the request. The string is
    terminated here, and the requests `HEAD` and `GET` are recognized as processable
    requests. A `HEAD` request will just return the headers, while a `GET` request
    will also return the requested resource (if it can be found).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_connection`函数使用`strstr()`函数在请求缓冲区中查找子字符串`HTTP/`。`strstr()`函数返回指向子字符串的指针，该指针将位于请求的末尾。字符串在这里被终止，`HEAD`和`GET`请求被识别为可处理请求。`HEAD`请求将仅返回头部信息，而`GET`请求将返回请求的资源（如果可以找到）。'
- en: 'The files index.html and image.jpg have been put into the directory webroot,
    as shown in the output below, and then the tinyweb program is compiled. Root privileges
    are needed to bind to any port below 1024, so the program is setuid root and executed.
    The server''s debugging output shows the results of a web browser''s request of
    http://127.0.0.1:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 文件index.html和image.jpg已经被放入webroot目录中，如下面的输出所示，然后编译了tinyweb程序。绑定任何小于1024的端口需要root权限，因此程序被设置为root用户执行。服务器的调试输出显示了浏览器对http://127.0.0.1的请求结果。
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The address 127.0.0.1 is a special loopback address that routes to the local
    machine. The initial request gets index.html from the webserver, which in turn
    requests image.jpg. In addition, the browser automatically requests favicon.ico
    in an attempt to retrieve an icon for the web page. The screenshot below shows
    the results of this request in a browser.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 地址127.0.0.1是一个特殊的回环地址，它指向本地机器。初始请求从web服务器获取index.html，然后web服务器又请求image.jpg。此外，浏览器还会自动请求favicon.ico，试图获取网页的图标。下面的截图显示了浏览器中这个请求的结果。
- en: '![](httpatomoreillycomsourcenostarchimages254301.png.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![截图](httpatomoreillycomsourcenostarchimages254301.png.jpg)'
- en: Figure 0x400-3.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图0x400-3。
- en: Peeling Back the Lower Layers
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 撕开底层
- en: When you use a web browser, all seven OSI layers are taken care of for you,
    allowing you to focus on browsing and not protocols. At the upper layers of OSI,
    many protocols can be plaintext since all the other details of the connection
    are already taken care of by the lower layers. Sockets exist on the session layer
    (5), providing an interface to send data from one host to another. TCP on the
    transport layer (4) provides reliability and transport control, while IP on the
    network layer (3) provides addressing and packet-level communication. Ethernet
    on the data-link layer (2) provides addressing between Ethernet ports, suitable
    for basic LAN (Local Area Network) communications. At the bottom, the physical
    layer (1) is simply the wire and the protocol used to send bits from one device
    to another. A single HTTP message will be wrapped in multiple layers as it is
    passed through different aspects of communication.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用网页浏览器时，所有七层OSI模型都会为你处理，让你可以专注于浏览而不是协议。在OSI模型的较高层，许多协议可以是明文，因为所有其他连接的细节已经被较低层处理好了。套接字存在于会话层（5），它提供了一个接口，用于从一个主机向另一个主机发送数据。传输层的TCP（4）提供可靠性和传输控制，而网络层的IP（3）提供寻址和包级通信。数据链路层的以太网（2）提供以太网端口之间的寻址，适用于基本的局域网（Local
    Area Network）通信。在最底层，物理层（1）仅仅是电线和用于将比特从一台设备发送到另一台设备的协议。一个单独的HTTP消息会在通过通信的不同方面时被包裹在多个层中。
- en: This process can be thought of as an intricate interoffice bureaucracy, reminiscent
    of the movie *Brazil*. At each layer, there is a highly specialized receptionist
    who only understands the language and protocol of that layer. As data packets
    are transmitted, each receptionist performs the necessary duties of her particular
    layer, puts the packet in an interoffice envelope, writes the header on the outside,
    and passes it on to the receptionist at the next layer below. That receptionist,
    in turn, performs the necessary duties of his layer, puts the entire envelope
    in another envelope, writes the header on the outside, and passes it on. Network
    traffic is a chattering bureaucracy of servers, clients, and peer-to-peer connections.
    At the higher layers, the traffic could be financial data, email, or basically
    anything. Regardless of what the packets contain, the protocols used at the lower
    layers to move the data from point A to point B are usually the same. Once you
    understand the office bureaucracy of these common lower layer protocols, you can
    peek inside envelopes in transit, and even falsify documents to manipulate the
    system.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可以想象成一个复杂的内部办公室官僚机构，让人联想到电影*巴西*。在每一层，都有一个高度专业化的接待员，他们只理解该层的语言和协议。当数据包传输时，每个接待员都会执行她特定层的必要职责，将数据包放入一个内部办公室的信封中，在外部写上标题，并将其传递给下一层的接待员。那个接待员接着执行他层的必要职责，将整个信封放入另一个信封中，在外部写上标题，然后传递出去。网络流量是服务器、客户端和对等连接的嘈杂官僚机构。在较高层，流量可能是财务数据、电子邮件或基本上任何东西。无论数据包包含什么，用于将数据从A点移动到B点的较低层使用的协议通常都是相同的。一旦你理解了这些常见底层协议的办公室官僚机构，你就可以查看传输中的信封，甚至伪造文件来操纵系统。
- en: Data-Link Layer
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据链路层
- en: The lowest visible layer is the data-link layer. Returning to the receptionist
    and bureaucracy analogy, if the physical layer below is thought of as interoffice
    mail carts and the network layer above as a worldwide postal system, the data-link
    layer is the system of interoffice mail. This layer provides a way to address
    and send messages to anyone else in the office, as well as to figure out who's
    in the office.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最低的可视层是数据链路层。回到接待员和官僚主义的类比，如果将下面的物理层视为办公室邮件车，将上面的网络层视为全球邮政系统，那么数据链路层就是办公室邮件系统。这一层提供了一种向办公室内的任何人发送消息并确定谁在办公室的方法。
- en: Ethernet exists on this layer, providing a standard addressing system for all
    Ethernet devices. These addresses are known as Media Access Control (MAC) addresses.
    Every Ethernet device is assigned a globally unique address consisting of six
    bytes, usually written in hexadecimal in the form `xx:xx:xx:xx:xx:xx`. These addresses
    are also sometimes referred to as hardware addresses, since each address is unique
    to a piece of hardware and is stored in the device's integrated circuit memory.
    MAC addresses can be thought of as Social Security numbers for hardware, since
    each piece of hardware is supposed to have a unique MAC address.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网存在于这一层，为所有以太网设备提供标准地址系统。这些地址被称为媒体访问控制（MAC）地址。每个以太网设备都被分配一个全球唯一的地址，由六个字节组成，通常以十六进制形式书写，形式为`xx:xx:xx:xx:xx:xx`。这些地址有时也被称为硬件地址，因为每个地址都是独一无二的，存储在设备的集成电路内存中。可以将MAC地址视为硬件的社保号码，因为每块硬件都应该有一个唯一的MAC地址。
- en: An Ethernet header is 14 bytes in size and contains the source and destination
    MAC addresses for this Ethernet packet. Ethernet addressing also provides a special
    broadcast address, consisting of all binary 1's (`ff:ff:ff:ff:ff:ff`). Any Ethernet
    packet sent to this address will be sent to all the connected devices.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网头部大小为14字节，包含此以太网数据包的源MAC地址和目的MAC地址。以太网地址还提供了一个特殊的广播地址，由所有二进制1组成（`ff:ff:ff:ff:ff:ff`）。任何发送到该地址的以太网数据包都将发送到所有连接的设备。
- en: The MAC address of a network device isn't meant to change, but its IP address
    may change regularly. The concept of IP addresses doesn't exist at this level,
    only hardware addresses do, so a method is needed to correlate the two addressing
    schemes. In the office, post office mail sent to an employee at the office's address
    goes to the appropriate desk. In Ethernet, the method is known as Address Resolution
    Protocol (ARP).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 网络设备的MAC地址不应该改变，但它的IP地址可能会定期改变。在这一层，IP地址的概念不存在，只有硬件地址，因此需要一种方法来关联这两种地址方案。在办公室里，寄给办公室地址的员工邮件会送到相应的办公桌。在以太网中，这种方法被称为地址解析协议（ARP）。
- en: This protocol allows "seating charts" to be made to associate an IP address
    with a piece of hardware. There are four different types of ARP messages, but
    the two most important types are *ARP request messages* and *ARP reply messages*.
    Any packet's Ethernet header includes a type value that describes the packet.
    This type is used to specify whether the packet is an ARP-type message or an IP
    packet.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议允许创建“座位图”，将一个IP地址与一块硬件关联起来。ARP消息有四种不同类型，但最重要的两种类型是*ARP请求消息*和*ARP回复消息*。任何数据包的以太网头部都包含一个类型值，用于描述该数据包。此类型用于指定数据包是ARP类型消息还是IP数据包。
- en: An ARP request is a message, sent to the broadcast address, that contains the
    sender's IP address and MAC address and basically says, "Hey, who has this IP?
    If it's you, please respond and tell me your MAC address." An ARP reply is the
    corresponding response that is sent to the requester's MAC address (and IP address)
    saying, "This is my MAC address, and I have this IP address." Most implementations
    will temporarily cache the MAC/IP address pairs received in ARP replies, so that
    ARP requests and replies aren't needed for every single packet. These caches are
    like the interoffice seating chart.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ARP请求是一条发送到广播地址的消息，其中包含发送者的IP地址和MAC地址，基本上是这么说的：“嘿，谁有这个IP？如果是你，请回复并告诉我你的MAC地址。”ARP回复是对请求者的MAC地址（以及IP地址）的相应回复，表示：“这是我的MAC地址，我拥有这个IP地址。”大多数实现都会暂时缓存ARP回复中接收到的MAC/IP地址对，这样就不需要为每个数据包都进行ARP请求和回复。这些缓存就像办公室的座位图。
- en: For example, if one system has the IP address 10.10.10.20 and MAC address `00:00:00:aa:aa:aa`,
    and another system on the same network has the IP address 10.10.10.50 and MAC
    address `00:00:00:bb:bb:bb`, neither system can communicate with the other until
    they know each other's MAC addresses.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages254445.png.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: Figure 0x400-4.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: If the first system wants to establish a TCP connection over IP to the second
    device's IP address of 10.10.10.50, the first system will first check its ARP
    cache to see if an entry exists for 10.10.10.50\. Since this is the first time
    these two systems are trying to communicate, there will be no such entry, and
    an ARP request will be sent out to the broadcast address, saying, "If you are
    10.10.10.50, please respond to me at `00:00:00:aa:aa:aa`." Since this request
    uses the broadcast address, every system on the network sees the request, but
    only the system with the corresponding IP address is meant to respond. In this
    case, the second system responds with an ARP reply that is sent directly back
    to `00:00:00:aa:aa:aa` saying, "I am 10.10.10.50 and I'm at `00:00:00:bb:bb:bb`."
    The first system receives this reply, caches the IP and MAC address pair in its
    ARP cache, and uses the hardware address to communicate.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Network Layer
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The network layer is like a worldwide postal service providing an addressing
    and delivery method used to send things everywhere. The protocol used at this
    layer for Internet addressing and delivery is, appropriately, called Internet
    Protocol (IP); the majority of the Internet uses IP version 4.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Every system on the Internet has an IP address, consisting of a familiar four-byte
    arrangement in the form of `xx.xx.xx.xx`. The IP header for packets in this layer
    is 20 bytes in size and consists of various fields and bitflags as defined in
    RFC 791.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: From RFC 791
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This surprisingly descriptive ASCII diagram shows these fields and their positions
    in the header. Standard protocols have awesome documentation. Similar to the Ethernet
    header, the IP header also has a protocol field to describe the type of data in
    the packet and the source and destination addresses for routing. In addition,
    the header carries a checksum, to help detect transmission errors, and fields
    to deal with packet fragmentation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The Internet Protocol is mostly used to transmit packets wrapped in higher layers.
    However, Internet Control Message Protocol (ICMP) packets also exist on this layer.
    ICMP packets are used for messaging and diagnostics. IP is less reliable than
    the post office—there's no guarantee that an IP packet will actually reach its
    final destination. If there's a problem, an ICMP packet is sent back to notify
    the sender of the problem.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: ICMP is also commonly used to test for connectivity. ICMP Echo Request and Echo
    Reply messages are used by a utility called ping. If one host wants to test whether
    it can route traffic to another host, it pings the remote host by sending an ICMP
    Echo Request. Upon receipt of the ICMP Echo Request, the remote host sends back
    an ICMP Echo Reply. These messages can be used to determine the connection latency
    between the two hosts. However, it is important to remember that ICMP and IP are
    both connectionless; all this protocol layer really cares about is getting the
    packet to its destination address.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a network link will have a limitation on packet size, disallowing
    the transfer of large packets. IP can deal with this situation by fragmenting
    packets, as shown here.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages254201.png.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: Figure 0x400-5.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The packet is broken up into smaller packet fragments that can pass through
    the network link, IP headers are put on each fragment, and they're sent off. Each
    fragment has a different fragment offset value, which is stored in the header.
    When the destination receives these fragments, the offset values are used to reassemble
    the original IP packet.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Provisions such as fragmentation aid in the delivery of IP packets, but this
    does nothing to maintain connections or ensure delivery. This is the job of the
    protocols at the transport layer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Transport Layer
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The transport layer can be thought of as the first line of office receptionists,
    picking up the mail from the network layer. If a customer wants to return a defective
    piece of merchandise, they send a message requesting a Return Material Authorization
    (RMA) number. Then the receptionist would follow the return protocol by asking
    for a receipt and eventually issuing an RMA number so the customer can mail the
    product in. The post office is only concerned with sending these messages (and
    packages) back and forth, not with what's in them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'The two major protocols at this layer are the Transmission Control Protocol
    (TCP) and User Datagram Protocol (UDP). TCP is the most commonly used protocol
    for services on the Internet: telnet, HTTP (web traffic), SMTP (email traffic),
    and FTP (file transfers) all use TCP. One of the reasons for TCP''s popularity
    is that it provides a transparent, yet reliable and bidirectional, connection
    between two IP addresses. Stream sockets use TCP/IP connections. A bidirectional
    connection with TCP is similar to using a telephone—after dialing a number, a
    connection is made through which both parties can communicate. Reliability simply
    means that TCP will ensure that all the data will reach its destination in the
    proper order. If the packets of a connection get jumbled up and arrive out of
    order, TCP will make sure they''re put back in order before handing the data up
    to the next layer. If some packets in the middle of a connection are lost, the
    destination will hold on to the packets it has while the source retransmits the
    missing packets.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this functionality is made possible by a set of flags, called *TCP flags*,
    and by tracking values called *sequence numbers*. The TCP flags are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能都是通过一组标志实现的，这些标志被称为*TCP标志*，以及通过跟踪值称为*序列号*。TCP标志如下：
- en: '| TCP flag | Meaning | Purpose |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| TCP标志 | 含义 | 目的 |'
- en: '| --- | --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| URG | Urgent | Identifies important data |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| URG | 紧急 | 标识重要数据 |'
- en: '| ACK | Acknowledgment | Acknowledges a packet; it is turned on for the majority
    of the connection |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| ACK | 确认 | 确认一个数据包；在大多数连接中都是开启的 |'
- en: '| PSH | Push | Tells the receiver to push the data through instead of buffering
    it |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| PSH | 推送 | 告诉接收方直接推送数据而不是缓冲它 |'
- en: '| RST | Reset | Resets a connection |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| RST | 重置 | 重置一个连接 |'
- en: '| SYN | Synchronize | Synchronizes sequence numbers at the beginning of a connection
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| SYN | 同步 | 在连接开始时同步序列号 |'
- en: '| FIN | Finish | Gracefully closes a connection when both sides say goodbye
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| FIN | 结束 | 当双方都告别时，优雅地关闭连接 |'
- en: These flags are stored in the TCP header along with the source and destination
    ports. The TCP header is specified in RFC 793.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志存储在TCP头部，与源端口和目标端口一起。TCP头部在RFC 793中指定。
- en: From RFC 793
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自RFC 793
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The sequence number and acknowledgment number are used to maintain state. The
    SYN and ACK flags are used together to open connections in a three-step handshaking
    process. When a client wants to open a connection with a server, a packet with
    the SYN flag on, but the ACK flag off, is sent to the server. The server then
    responds with a packet that has both the SYN and ACK flags turned on. To complete
    the connection, the client sends back a packet with the SYN flag off but the ACK
    flag on. After that, every packet in the connection will have the ACK flag turned
    on and the SYN flag turned off. Only the first two packets of the connection have
    the SYN flag on, since those packets are used to synchronize sequence numbers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 序列号和确认号用于维护状态。SYN和ACK标志一起用于在三个步骤的握手过程中打开连接。当客户端想要与服务器建立连接时，会发送一个带有SYN标志但ACK标志关闭的数据包到服务器。然后服务器响应一个同时带有SYN和ACK标志的数据包。为了完成连接，客户端发送一个带有SYN标志关闭但ACK标志开启的数据包。之后，连接中的每个数据包都将开启ACK标志并关闭SYN标志。只有连接的前两个数据包带有SYN标志，因为那些数据包用于同步序列号。
- en: '![](httpatomoreillycomsourcenostarchimages254295.png.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](httpatomoreillycomsourcenostarchimages254295.png.jpg)'
- en: Figure 0x400-6.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0x400-6.
- en: Sequence numbers allow TCP to put unordered packets back into order, to determine
    whether packets are missing, and to prevent mixing up packets from other connections.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 序列号允许TCP将无序的数据包重新排序，确定数据包是否缺失，并防止混淆来自其他连接的数据包。
- en: When a connection is initiated, each side generates an initial sequence number.
    This number is communicated to the other side in the first two SYN packets of
    the connection handshake. Then, with each packet that is sent, the sequence number
    is incremented by the number of bytes found in the data portion of the packet.
    This sequence number is included in the TCP packet header. In addition, each TCP
    header has an acknowledgment number, which is simply the other side's sequence
    number plus one.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个连接被发起时，每一方都会生成一个初始序列号。这个数字在连接握手的前两个SYN数据包中传达给对方。然后，随着每个数据包的发送，序列号会根据数据包数据部分的字节数增加。这个序列号包含在TCP数据包头部中。此外，每个TCP头部都有一个确认号，它简单地是另一方的序列号加一。
- en: TCP is great for applications where reliability and bidirectional communication
    are needed. However, the cost of this functionality is paid in communication overhead.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: TCP非常适合需要可靠性和双向通信的应用程序。然而，这种功能的代价是通信开销。
- en: 'UDP has much less overhead and built-in functionality than TCP. This lack of
    functionality makes it behave much like the IP protocol: It is connectionless
    and unreliable. Without built-in functionality to create connections and maintain
    reliability, UDP is an alternative that expects the application to deal with these
    issues. Sometimes connections aren''t needed, and the lightweight UDP is a much
    better protocol for these situations. The UDP header, defined in RFC 768, is relatively
    tiny. It only contains four 16-bit values in this order: source port, destination
    port, length, and checksum.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: UDP比TCP有更少的开销和内置功能。这种缺乏功能使得它表现得非常像IP协议：它是无连接和不可靠的。没有内置的功能来创建连接并保持可靠性，UDP是一种期望应用程序处理这些问题的替代方案。有时不需要连接，轻量级的UDP对于这些情况来说是一个更好的协议。UDP头，在RFC
    768中定义，相对较小。它只包含以下顺序的四个16位值：源端口、目的端口、长度和校验和。
- en: Network Sniffing
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络嗅探
- en: On the data-link layer lies the distinction between switched and unswitched
    networks. On an *unswitched network*, Ethernet packets pass through every device
    on the network, expecting each system device to only look at the packets sent
    to its destination address. However, it's fairly trivial to set a device to *promiscuous
    mode*, which causes it to look at all packets, regardless of the destination address.
    Most packet-capturing programs, such as tcpdump, drop the device they are listening
    to into promiscuous mode by default. Promiscuous mode can be set using `ifconfig`,
    as seen in the following output.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据链路层，存在交换网络和非交换网络之间的区别。在*非交换网络*上，以太网数据包通过网络上的每个设备，期望每个系统设备只查看发送到其目的地址的数据包。然而，将设备设置为*混杂模式*相对简单，这会导致它查看所有数据包，无论目的地址如何。大多数数据包捕获程序，如tcpdump，默认将它们监听的设备置于混杂模式。混杂模式可以使用`ifconfig`设置，如下面的输出所示。
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The act of capturing packets that aren't necessarily meant for public viewing
    is called *sniffing*. Sniffing packets in promiscuous mode on an unswitched network
    can turn up all sorts of useful information, as the following output shows.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获并非一定供公众查看的数据包的行为被称为*嗅探*。在非交换网络上以混杂模式嗅探数据包可以揭示各种有用的信息，如下面的输出所示。
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Data transmitted over the network by services such as telnet, FTP, and POP3
    is unencrypted. In the preceding example, the user `leech` is seen logging into
    an FTP server using the password `l8@nite`. Since the authentication process during
    login is also unencrypted, usernames and passwords are simply contained in the
    data portions of the transmitted packets.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过telnet、FTP和POP3等服务在网络中传输的数据是不加密的。在先前的例子中，可以看到用户`leech`正在使用密码`l8@nite`登录FTP服务器。由于登录过程中的认证过程也是不加密的，因此用户名和密码只是包含在传输数据包的数据部分中。
- en: '`tcpdump` is a wonderful, general-purpose packet sniffer, but there are specialized
    sniffing tools designed specifically to search for usernames and passwords. One
    notable example is Dug Song''s program, `dsniff`, which is smart enough to parse
    out data that looks important.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcpdump`是一个功能强大的通用数据包嗅探器，但也有一些专门设计的嗅探工具，旨在搜索用户名和密码。一个值得注意的例子是Dug Song的程序`dsniff`，它足够智能，可以解析出看起来重要的数据。'
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Raw Socket Sniffer
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始套接字嗅探器
- en: So far in our code examples, we have been using stream sockets. When sending
    and receiving using stream sockets, the data is neatly wrapped in a TCP/IP connection.
    Accessing the OSI model of the session (5) layer, the operating system takes care
    of all of the lower-level details of transmission, correction, and routing. It
    is possible to access the network at lower layers using raw sockets. At this lower
    layer, all the details are exposed and must be handled explicitly by the programmer.
    Raw sockets are specified by using `SOCK_RAW` as the type. In this case, the protocol
    matters since there are multiple options. The protocol can be `IPPROTO_TCP, IPPROTO_UDP`,
    or `IPPROTO_ICMP`. The following example is a TCP sniffing program using raw sockets.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的代码示例中，我们一直在使用流套接字。当使用流套接字发送和接收时，数据被整洁地封装在TCP/IP连接中。访问会话（5）层的OSI模型，操作系统负责所有低级传输、纠正和路由的细节。可以使用原始套接字在网络较低层进行访问。在这一层，所有细节都暴露出来，必须由程序员显式处理。原始套接字通过使用`SOCK_RAW`作为类型来指定。在这种情况下，协议很重要，因为有多种选项。协议可以是`IPPROTO_TCP,
    IPPROTO_UDP`或`IPPROTO_ICMP`。以下是一个使用原始套接字的TCP嗅探程序的示例。
- en: raw_tcpsniff.c
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: raw_tcpsniff.c
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This program opens a raw TCP socket and listens for three packets, printing
    the raw data of each one with the `dump()` function. Notice that buffer is declared
    as a `u_char` variable. This is just a convenience type definition from sys/socket.h
    that expands to "unsigned char." This is for convenience, since unsigned variables
    are used a lot in network programming and typing `unsigned` every time is a pain.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序打开一个原始TCP套接字并监听三个数据包，使用`dump()`函数打印每个数据包的原始数据。请注意，缓冲区被声明为一个`u_char`变量。这只是一个来自sys/socket.h的便利类型定义，展开为"unsigned
    char"。这是为了方便，因为在网络编程中经常使用无符号变量，每次都输入`unsigned`是很麻烦的。
- en: When compiled, the program needs to be run as root, because the use of raw sockets
    requires root access. The following output shows the program sniffing the network
    while we're sending sample text to our simple_server.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，程序需要以root用户身份运行，因为使用原始套接字需要root权限。以下输出显示了程序在发送示例文本到我们的简单服务器时嗅探网络。
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: While this program will capture packets, it isn't reliable and will miss some
    packets, especially when there is a lot of traffic. Also, it only captures TCP
    packets—to capture UDP or ICMP packets, additional raw sockets need to be opened
    for each. Another big problem with raw sockets is that they are notoriously inconsistent
    between systems. Raw socket code for Linux most likely won't work on BSD or Solaris.
    This makes multiplatform programming with raw sockets nearly impossible.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个程序可以捕获数据包，但它并不可靠，可能会错过一些数据包，尤其是在流量很大的时候。此外，它只捕获TCP数据包——要捕获UDP或ICMP数据包，需要为每个数据包打开额外的原始套接字。原始套接字的一个大问题是它们在系统之间非常不一致。Linux的原始套接字代码很可能在BSD或Solaris上无法工作。这使得使用原始套接字进行多平台编程几乎不可能。
- en: libpcap Sniffer
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: libpcap嗅探器
- en: A standardized programming library called libpcap can be used to smooth out
    the inconsistencies of raw sockets. The functions in this library still use raw
    sockets to do their magic, but the library knows how to correctly work with raw
    sockets on multiple architectures. Both tcpdump and dsniff use libpcap, which
    allows them to compile with relative ease on any platform. Let's rewrite the raw
    packet sniffer program using the libpcap's functions instead of our own. These
    functions are quite intuitive, so we will discuss them using the following code
    listing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一个标准化的编程库libpcap来平滑原始套接字的不一致性。这个库中的函数仍然使用原始套接字来完成它们的魔法，但这个库知道如何在多个架构上正确地与原始套接字一起工作。tcpdump和dsniff都使用libpcap，这使得它们可以在任何平台上相对容易地编译。让我们用libpcap的函数重写原始数据包嗅探程序，而不是使用我们自己的。这些函数非常直观，所以我们将使用以下代码列表来讨论它们。
- en: pcap_sniff.c
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pcap_sniff.c
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First, pcap.h is included providing various structures and defines used by the
    pcap functions. Also, I've written a `pcap_fatal()` function for displaying fatal
    errors. The pcap functions use a error buffer to return error and status messages,
    so this function is designed to display this buffer to the user.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，包含pcap.h提供由pcap函数使用的各种结构和定义。我还编写了一个`pcap_fatal()`函数来显示致命错误。pcap函数使用错误缓冲区来返回错误和状态消息，因此这个函数被设计为向用户显示这个缓冲区。
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `errbuf` variable is the aforementioned error buffer, its size coming from
    a define in pcap.h set to `256`. The header variable is a `pcap_pkthdr` structure
    containing extra capture information about the packet, such as when it was captured
    and its length. The `pcap_handle` pointer works similarly to a file descriptor,
    but is used to reference a packet-capturing object.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`errbuf`变量是前面提到的错误缓冲区，其大小来自pcap.h中的一个定义，设置为`256`。头变量是一个`pcap_pkthdr`结构，包含有关数据包的额外捕获信息，例如捕获时间和长度。`pcap_handle`指针的工作方式类似于文件描述符，但用于引用一个数据包捕获对象。'
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `pcap_lookupdev()` function looks for a suitable device to sniff on. This
    device is returned as a string pointer referencing static function memory. For
    our system this will always be `/dev/eth0`, although it will be different on a
    BSD system. If the function can't find a suitable interface, it will return `NULL`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`pcap_lookupdev()`函数寻找一个合适的设备进行嗅探。该设备作为字符串指针返回，引用静态函数内存。对于我们的系统，这始终是`/dev/eth0`，尽管在BSD系统上可能不同。如果函数找不到合适的接口，它将返回`NULL`。'
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Similar to the socket function and file open function, the `pcap_open_live()`
    function opens a packet-capturing device, returning a handle to it. The arguments
    for this function are the device to sniff, the maximum packet size, a promiscuous
    flag, a timeout value, and a pointer to the error buffer. Since we want to capture
    in promiscuous mode, the promiscuous flag is set to `1`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与套接字函数和文件打开函数类似，`pcap_open_live()` 函数打开一个数据包捕获设备，并返回对该设备的句柄。此函数的参数包括要嗅探的设备、最大数据包大小、混杂标志、超时值以及错误缓冲区的指针。由于我们想要以混杂模式进行捕获，所以混杂标志被设置为
    `1`。
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Finally, the packet capture loop uses `pcap_next()` to grab the next packet.
    This function is passed the `pcap_handle` and a pointer to a `pcap_pkthdr` structure
    so it can fill it with details of the capture. The function returns a pointer
    to the packet and then prints the packet, getting the length from the capture
    header. Then `pcap_close()` closes the capture interface.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，数据包捕获循环使用 `pcap_next()` 来获取下一个数据包。此函数接收 `pcap_handle` 和一个指向 `pcap_pkthdr`
    结构的指针，以便填充捕获的详细信息。函数返回数据包的指针，然后打印数据包，从捕获头中获取长度。然后 `pcap_close()` 关闭捕获接口。
- en: When this program is compiled, the pcap libraries must be linked. This can be
    done using the `-l` flag with GCC, as shown in the output below. The pcap library
    has been installed on this system, so the library and include files are already
    in standard locations the compiler knows about.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个程序编译时，必须链接 pcap 库。这可以通过 GCC 的 `-l` 标志来完成，如下面的输出所示。在这个系统上已经安装了 pcap 库，因此库和包含文件已经位于编译器已知的标准位置。
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice that there are many bytes preceding the sample text in the packet and
    many of these bytes are similar. Since these are raw packet captures, most of
    these bytes are layers of header information for Ethernet, IP, and TCP.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到数据包中样本文本之前有许多字节，其中许多字节是相似的。由于这些是原始数据包捕获，其中大部分字节是用于以太网、IP 和 TCP 的头部信息层。
- en: Decoding the Layers
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解码层结构
- en: In our packet captures, the outermost layer is Ethernet, which is also the lowest
    visible layer. This layer is used to send data between Ethernet endpoints with
    MAC addresses. The header for this layer contains the source MAC address, the
    destination MAC address, and a 16-bit value that describes the type of Ethernet
    packet. On Linux, the structure for this header is defined in /usr/include/linux/if_ethernet.h
    and the structures for the IP header and TCP header are located in /usr/include/netinet/ip.h
    and /usr/include/ netinet/tcp.h, respectively. The source code for tcpdump also
    has structures for these headers, or we could just create our own header structures
    based on the RFCs. A better understanding can be gained from writing our own structures,
    so let's use the structure definitions as guidance to create our own packet header
    structures to include in hacking-network.h.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据包捕获中，最外层是以太网，这也是最低的可视层。这一层用于在具有 MAC 地址的以太网端点之间发送数据。这一层的头部包含源 MAC 地址、目的
    MAC 地址以及一个描述以太网数据包类型的 16 位值。在 Linux 上，此头部的结构定义在 /usr/include/linux/if_ethernet.h
    中，IP 头部的结构位于 /usr/include/netinet/ip.h 中，TCP 头部的结构位于 /usr/include/netinet/tcp.h
    中。tcpdump 的源代码也有这些头部的结构，或者我们可以根据 RFCs 创建自己的头部结构。通过编写自己的结构可以获得更好的理解，因此让我们使用结构定义作为指导来创建自己的数据包头部结构，并将其包含在
    hacking-network.h 中。
- en: First, let's look at the existing definition of the Ethernet header.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看以太网头部的现有定义。
- en: From /usr/include/if_ether.h
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 /usr/include/if_ether.h
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This structure contains the three elements of an Ethernet header. The variable
    declaration of `__be16` turns out to be a type definition for a 16-bit unsigned
    short integer. This can be determined by recursively grepping for the type definition
    in the include files.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构包含以太网头部的三个元素。`__be16` 变量的声明实际上是一个 16 位无符号短整数的类型定义。这可以通过在包含文件中递归地搜索类型定义来确定。
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The include file also defines the Ethernet header length in `ETH_HLEN` as 14
    bytes. This adds up, since the source and destination MAC addresses use 6 bytes
    each, and the packet type field is a 16-bit short integer that takes up 2 bytes.
    However, many compilers will pad structures along 4-byte boundaries for alignment,
    which means that `sizeof(struct ethhdr)` would return an incorrect size. To avoid
    this, `ETH_HLEN` or a fixed value of 14 bytes should be used for the Ethernet
    header length.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 包含文件还定义了以太网头部长度为 `ETH_HLEN`，为 14 字节。这是合理的，因为源地址和目标 MAC 地址各占用 6 字节，而数据包类型字段是一个
    16 位短整数，占用 2 字节。然而，许多编译器会为了对齐而在 4 字节边界上填充结构，这意味着 `sizeof(struct ethhdr)` 会返回错误的大小。为了避免这种情况，应该使用
    `ETH_HLEN` 或 14 字节的固定值作为以太网头部长度。
- en: By including `<linux/if_ether.h>`, these other include files containing the
    required `__be16` type definition are also included. Since we want to make our
    own structures for hacking-network.h, we should strip out references to unknown
    type definitions. While we're at it, let's give these fields better names.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含 `<linux/if_ether.h>`，这些包含所需 `__be16` 类型定义的其他包含文件也被包含进来了。由于我们想要为 hacking-network.h
    创建自己的结构，我们应该去除对未知类型定义的引用。在此过程中，让我们也给这些字段起更好的名字。
- en: Added to hacking-network.h
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加到 hacking-network.h
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can do the same thing with the IP and TCP structures, using the corresponding
    structures and RFC diagrams as a reference.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用相同的方法处理 IP 和 TCP 结构，使用相应的结构和 RFC 图作为参考。
- en: From /usr/include/netinet/ip.h
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 `/usr/include/netinet/ip.h`
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: From RFC 791
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 RFC 791
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Each element in the structure corresponds to the fields shown in the RFC header
    diagram. Since the first two fields, Version and IHL (Internet Header Length)
    are only four bits in size and there aren't any 4-bit variable types in C, the
    Linux header definition splits the byte differently depending on the byte order
    of the host. These fields are in the network byte order, so, if the host is little-endian,
    the IHL should come before Version since the byte order is reversed. For our purposes,
    we won't really be using either of these fields, so we don't even need to split
    up the byte.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 结构中的每个元素都对应于 RFC 头部图示中的字段。由于前两个字段，版本和 IHL（互联网头部长度）只有四位大小，而在 C 中没有 4 位变量类型，Linux
    头部定义根据主机的字节序不同而将字节分割成不同的部分。这些字段以网络字节序排列，因此，如果主机是小端字节序，IHL 应该在版本之前，因为字节序是相反的。就我们的目的而言，我们实际上不会使用这两个字段中的任何一个，所以我们甚至不需要分割字节。
- en: Added to hacking-network.h
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加到 hacking-network.h
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The compiler padding, as mentioned earlier, will align this structure on a 4-byte
    boundary by padding the rest of the structure. IP headers are always 20 bytes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，编译器填充会将此结构对齐到 4 字节边界，通过填充结构的其余部分。IP 头部总是 20 字节。
- en: For the TCP packet header, we reference /usr/include/netinet/tcp.h for the structure
    and RFC 793 for the header diagram.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 TCP 数据包头部，我们参考 `/usr/include/netinet/tcp.h` 中的结构以及 RFC 793 中的头部图示。
- en: From /usr/include/netinet/tcp.h
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 `/usr/include/netinet/tcp.h`
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: From RFC 793
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 RFC 793
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Linux's `tcphdr` structure also switches the ordering of the 4-bit data offset
    field and the 4-bit section of the reserved field depending on the host's byte
    order. The data offset field is important, since it tells the size of the variablelength
    TCP header. You might have noticed that Linux's `tcphdr` structure doesn't save
    any space for TCP options. This is because the RFC defines this field as optional.
    The size of the TCP header will always be 32-bit-aligned, and the data offset
    tells us how many 32-bit words are in the header. So the TCP header size in bytes
    equals the data offset field from the header times four. Since the data offset
    field is required to calculate the header size, we'll split the byte containing
    it, assuming little-endian host byte ordering.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的 `tcphdr` 结构也会根据主机的字节序切换 4 位数据偏移字段和保留字段的 4 位部分。数据偏移字段很重要，因为它告诉我们可变长度
    TCP 头部的大小。你可能已经注意到 Linux 的 `tcphdr` 结构没有为 TCP 选项保留任何空间。这是因为 RFC 将此字段定义为可选的。TCP
    头部的大小总是 32 位对齐的，数据偏移告诉我们头部中有多少个 32 位字。因此，TCP 头部的大小（以字节为单位）等于头部中的数据偏移字段乘以四。由于数据偏移字段是计算头部大小所必需的，我们将包含它的字节分割，假设主机是小端字节序。
- en: The `th_flags` field of Linux's `tcphdr` structure is defined as an 8-bit unsigned
    character. The values defined below this field are the bitmasks that correspond
    to the six possible flags.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的 `tcphdr` 结构中的 `th_flags` 字段定义为 8 位无符号字符。在此字段以下定义的值是对应于六个可能标志的位掩码。
- en: Added to hacking-network.h
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加到 hacking-network.h
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now that the headers are defined as structures, we can write a program to decode
    the layered headers of each packet. But before we do, let''s talk about libpcap
    for a moment. This library has a function called `pcap_loop()`, which is a better
    way to capture packets than just looping on a `pcap_next()`call. Very few programs
    actually use `pcap_next()`, because it''s clumsy and inefficient. The `pcap_loop()`
    function uses a callback function. This means the `pcap_loop()` function is passed
    a function pointer, which is called every time a packet is captured. The prototype
    for `pcap_loop()` is as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The first argument is the pcap''s handle, the next one is a count of how many
    packets to capture, and the third is a function pointer to the callback function.
    If the count argument is set to `-1`, it will loop until the program breaks out
    of it. The final argument is an optional pointer that will get passed to the callback
    function. Naturally, the callback function needs to follow a certain prototype,
    since `pcap_loop()` must call this function. The callback function can be named
    whatever you like, but the arguments must be as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The first argument is just the optional argument pointer from the last argument
    to `pcap_loop()`. It can be used to pass additional information to the callback
    function, but we aren''t going to be using this. The next two arguments should
    be familiar from `pcap_next()`: a pointer to the capture header and a pointer
    to the packet itself.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The following example code uses `pcap_loop()` with a callback function to capture
    packets and our header structures to decode them. This program will be explained
    as the code is listed.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: decode_sniff.c
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: At the beginning of this program, the prototype for the callback function, called
    `caught_packet()`, is declared along with several decoding functions. Everything
    else in `main()` is basically the same, except that the for loop has been replaced
    with a single call to `pcap_loop()`. This function is passed the `pcap_handle`,
    told to capture three packets, and pointed to the callback function, `caught_packet()`.
    The final argument is `NULL`, since we don't have any additional data to pass
    along to `caught_packet()`. Also, notice that the `decode_tcp()`function returns
    a u_int. Since the TCP header length is variable, this function returns the length
    of the TCP header.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `caught_packet()` function gets called whenever `pcap_loop()` captures a
    packet. This function uses the header lengths to split the packet up by layers
    and the decoding functions to print out details of each layer's header.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The decoding functions are passed a pointer to the start of the header, which
    is typecast to the appropriate structure. This allows accessing various fields
    of the header, but it's important to remember these values will be in network
    byte order. This data is straight from the wire, so the byte order needs to be
    converted for use on an *x*86 processor.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With the headers decoded and separated into layers, the TCP/IP connection is
    much easier to understand. Notice which IP addresses are associated with which
    MAC address. Also, notice how the sequence number in the two packets from 192.168.42.1
    (the first and last packet) increases by nine, since the first packet contained
    nine bytes of actual data: 2887045283 – 2887045274 = 9\. This is used by the TCP
    protocol to make sure all of the data arrives in order, since packets could be
    delayed for various reasons.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 解码头部并将它们分离成层后，TCP/IP连接就更容易理解了。注意哪些IP地址与哪些MAC地址相关联。还要注意，从192.168.42.1（第一个和最后一个数据包）的两个数据包中的序列号增加了九，因为第一个数据包包含九个字节的实际数据：2887045283
    – 2887045274 = 9。这是TCP协议用来确保所有数据按顺序到达的，因为数据包可能会因为各种原因而延迟。
- en: Despite all of the mechanisms built into the packet headers, the packets are
    still visible to anyone on the same network segment. Protocols such as FTP, POP3,
    and telnet transmit data without encryption. Even without the assistance of a
    tool like dsniff, it's fairly trivial for an attacker sniffing the network to
    find the usernames and passwords in these packets and use them to compromise other
    systems. From a security perspective, this isn't too good, so more intelligent
    switches provide switched network environments.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数据包头部内置了所有这些机制，但数据包仍然对同一网络段上的任何人可见。FTP、POP3和telnet等协议在传输数据时不进行加密。即使没有dsniff等工具的帮助，攻击者也很容易在网络嗅探中找到这些数据包中的用户名和密码，并利用它们来破坏其他系统。从安全角度来看，这并不太好，因此更智能的交换机提供了交换网络环境。
- en: Active Sniffing
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 激活嗅探
- en: In a *switched network environment*, packets are only sent to the port they
    are destined for, according to their destination MAC addresses. This requires
    more intelligent hardware that can create and maintain a table associating MAC
    addresses with certain ports, depending on which device is connected to each port,
    as illustrated here.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个*交换网络环境*中，数据包只会发送到它们的目的端口，根据它们的MAC地址。这需要更智能的硬件来创建和维护一个将MAC地址与特定端口关联的表格，具体取决于连接到每个端口的设备，如图所示。
- en: The advantage of a switched environment is that devices are only sent packets
    that are meant for them, so that promiscuous devices aren't able to sniff any
    additional packets. But even in a switched environment, there are clever ways
    to sniff other devices' packets; they just tend to be a bit more complex. In order
    to find hacks like these, the details of the protocols must be examined and then
    combined.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 交换环境的优势在于，设备只会接收到为其发送的数据包，因此混杂设备无法嗅探任何额外的数据包。但在交换环境中，也有巧妙的方法来嗅探其他设备的数据包；它们只是稍微复杂一些。为了找到这些黑客技巧，必须检查协议的细节，并将它们结合起来。
- en: One important aspect of network communications that can be manipulated for interesting
    effects is the source address. There's no provision in these protocols to ensure
    that the source address in a packet really is the address of the source machine.
    The act of forging a source address in a packet is known as *spoofing*. The addition
    of spoofing to your bag of tricks greatly increases the number of possible hacks,
    since most systems expect the source address to be valid.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 网络通信的一个重要方面是可以用来产生有趣效果的源地址。这些协议中没有规定确保数据包中的源地址确实是源机器的地址。在数据包中伪造源地址的行为被称为*欺骗*。将欺骗添加到你的技巧包中大大增加了可能的黑客攻击数量，因为大多数系统都期望源地址是有效的。
- en: '![](httpatomoreillycomsourcenostarchimages254195.png.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图片](httpatomoreillycomsourcenostarchimages254195.png.jpg)'
- en: Figure 0x400-7.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0x400-7。
- en: Spoofing is the first step in sniffing packets on a switched network. The other
    two interesting details are found in ARP. First, when an ARP reply comes in with
    an IP address that already exists in the ARP cache, the receiving system will
    overwrite the prior MAC address information with the new information found in
    the reply (unless that entry in the ARP cache was explicitly marked as permanent).
    Second, no state information about the ARP traffic is kept, since this would require
    additional memory and would complicate a protocol that is meant to be simple.
    This means systems will accept an ARP reply even if they didn't send out an ARP
    request.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 欺骗是交换网络中嗅探数据包的第一步。其他两个有趣的细节可以在ARP中找到。首先，当一个带有已存在于ARP缓存中的IP地址的ARP回复到来时，接收系统将用回复中找到的新信息覆盖先前的MAC地址信息（除非该ARP缓存条目被明确标记为永久）。其次，不保留ARP流量的状态信息，因为这需要额外的内存，并且会复杂化一个旨在简单的协议。这意味着系统会接受ARP回复，即使它们没有发送ARP请求。
- en: These three details, when exploited properly, allow an attacker to sniff network
    traffic on a switched network using a technique known as *ARP redirection*. The
    attacker sends spoofed ARP replies to certain devices that cause the ARP cache
    entries to be overwritten with the attacker's data. This technique is called *ARP
    cache poisoning*. In order to sniff network traffic between two points, *A* and
    *B*, the attacker needs to poison the ARP cache of *A* to cause *A* to believe
    that *B*'s IP address is at the attacker's MAC address, and also poison the ARP
    cache of *B* to cause *B* to believe that *A*'s IP address is also at the attacker's
    MAC address. Then the attacker's machine simply needs to forward these packets
    to their appropriate final destinations. After that, all of the traffic between
    *A* and *B* still gets delivered, but it all flows through the attacker's machine,
    as shown here.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages254508.png.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: Figure 0x400-8.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Since *A* and *B* are wrapping their own Ethernet headers on their packets based
    on their respective ARP caches, *A*'s IP traffic meant for *B* is actually sent
    to the attacker's MAC address, and vice versa. The switch only filters traffic
    based on MAC address, so the switch will work as it's designed to, sending *A*'s
    and *B*'s IP traffic, destined for the attacker's MAC address, to the attacker's
    port. Then the attacker rewraps the IP packets with the proper Ethernet headers
    and sends them back to the switch, where they are finally routed to their proper
    destination. The switch works properly; it's the victim machines that are tricked
    into redirecting their traffic through the attacker's machine.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Due to timeout values, the victim machines will periodically send out real ARP
    requests and receive real ARP replies in response. In order to maintain the redirection
    attack, the attacker must keep the victim machine's ARP caches poisoned. A simple
    way to accomplish this is to send spoofed ARP replies to both A and B at a constant
    interval—for example, every 10 seconds.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: A *gateway* is a system that routes all the traffic from a local network out
    to the Internet. ARP redirection is particularly interesting when one of the victim
    machines is the default gateway, since the traffic between the default gateway
    and another system is that system's Internet traffic. For example, if a machine
    at 192.168.0.118 is communicating with the gateway at 192.168.0.1 over a switch,
    the traffic will be restricted by MAC address. This means that this traffic cannot
    normally be sniffed, even in promiscuous mode. In order to sniff this traffic,
    it must be redirected.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: To redirect the traffic, first the MAC addresses of 192.168.0.118 and 192.168.0.1
    need to be determined. This can be done by pinging these hosts, since any IP connection
    attempt will use ARP. If you run a sniffer, you can see the ARP communications,
    but the OS will cache the resulting IP/MAC address associations.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: After pinging, the MAC addresses for both 192.168.0.118 and 192.168.0.1 are
    in the attacker's ARP cache. This way, packets can reach their final destinations
    after being redirected to the attacker's machine. Assuming IP forwarding capabilities
    are compiled into the kernel, all we need to do is send some spoofed ARP replies
    at regular intervals. 192.168.0.118 needs to be told that 192.168.0.1 is at `00:00:AD:D1:C7:ED`,
    and 192.168.0.1 needs to be told that 192.168.0.118 is also at `00:00:AD:D1:C7:ED`.
    These spoofed ARP packets can be injected using a command-line packet injection
    tool called Nemesis. Nemesis was originally a suite of tools written by Mark Grimes,
    but in the most recent version 1.4, all functionality has been rolled up into
    a single utility by the new maintainer and developer, Jeff Nathan. The source
    code for Nemesis is on the LiveCD at /usr/src/nemesis-1.4/, and it has already
    been built and installed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ping 之后，192.168.0.118 和 192.168.0.1 的 MAC 地址都出现在攻击者的 ARP 缓存中。这样，数据包在被重定向到攻击者机器后可以到达最终目的地。假设
    IP 转发功能已编译到内核中，我们只需要定期发送一些欺骗的 ARP 响应。192.168.0.118 需要知道 192.168.0.1 在 `00:00:AD:D1:C7:ED`，而
    192.168.0.1 需要知道 192.168.0.118 也在 `00:00:AD:D1:C7:ED`。这些欺骗的 ARP 数据包可以使用名为 Nemesis
    的命令行数据包注入工具注入。Nemesis 最初是由 Mark Grimes 编写的工具套件，但在最新版本 1.4 中，所有功能都被新的维护者和开发者 Jeff
    Nathan 合并到一个单一的工具中。Nemesis 的源代码位于 LiveCD 的 /usr/src/nemesis-1.4/ 目录下，并且已经编译并安装。
- en: '[PRE54]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: These two commands spoof ARP replies from 192.168.0.1 to 192.168.0.118 and vice
    versa, both claiming that their MAC address is at the attacker's MAC address of
    `00:00:AD:D1:C7:ED`. If these commands are repeated every 10 seconds, these bogus
    ARP replies will continue to keep the ARP caches poisoned and the traffic redirected.
    The standard BASH shell allows commands to be scripted, using familiar control
    flow statements. A simple BASH shell while loop is used below to loop forever,
    sending our two poisoning ARP replies every 10 seconds.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令从 192.168.0.1 到 192.168.0.118 以及相反方向欺骗 ARP 响应，都声称它们的 MAC 地址是攻击者的 MAC 地址
    `00:00:AD:D1:C7:ED`。如果这些命令每 10 秒重复一次，这些虚假的 ARP 响应将继续使 ARP 缓存中毒并重定向流量。标准的 BASH
    shell 允许使用熟悉的控制流语句进行命令脚本化。下面使用了一个简单的 BASH shell while 循环来无限循环，每 10 秒发送我们的两个中毒
    ARP 响应。
- en: '[PRE55]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can see how something as simple as Nemesis and the standard BASH shell can
    be used to quickly hack together a network exploit. Nemesis uses a C library called
    libnet to craft spoofed packets and inject them. Similar to libpcap, this library
    uses raw sockets and evens out the inconsistencies between platforms with a standardized
    interface. libnet also provides several convenient functions for dealing with
    network packets, such as checksum generation.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，像 Nemesis 和标准的 BASH shell 这样简单的东西可以用来快速组合网络攻击。Nemesis 使用一个名为 libnet 的
    C 库来制作欺骗数据包并将其注入。类似于 libpcap，这个库使用原始套接字，并通过标准接口平衡不同平台之间的不一致性。libnet 还提供了一些方便的网络数据包处理函数，例如生成校验和。
- en: The libnet library provides a simple and uniform API to craft and inject network
    packets. It's well documented and the functions have descriptive names. A high-level
    glance at the source code for Nemesis shows how easy it is to craft ARP packets
    using libnet. The source file nemesis-arp.c contains several functions for crafting
    and injecting ARP packets, using statically defined data structures for the packet
    header information. The `nemesis_arp()` function shown below is called in nemesis.c
    to build and inject an ARP packet.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: libnet 库提供了一个简单且统一的 API 来制作和注入网络数据包。它有很好的文档记录，函数名具有描述性。从 Nemesis 的源代码中可以高屋建瓴地看到，使用
    libnet 制作 ARP 数据包是多么容易。下面的 `nemesis_arp()` 函数在 nemesis.c 中被调用，用于构建和注入一个 ARP 数据包。
- en: From nemesis-arp.c
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 nemesis-arp.c
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The structures `ETHERhdr` and `ARPhdr` are defined in the file nemesis.h (shown
    below) as aliases for existing libnet data structures. In C, `typedef` is used
    to alias a data type with a symbol.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 结构 `ETHERhdr` 和 `ARPhdr` 在文件 nemesis.h 中（如下所示）被定义为现有 libnet 数据结构的别名。在 C 语言中，`typedef`
    用于用符号别名一个数据类型。
- en: From nemesis.h
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 nemesis.h
- en: '[PRE57]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `nemesis_arp()` function calls a series of other functions from this file:
    `arp_initdata(), arp_cmdline(), arp_validatedata()`, and `arp_verbose()`. You
    can probably guess that these functions initialize data, process command-line
    arguments, validate data, and do some sort of verbose reporting. The `arp_initdata()`
    function does exactly this, initializing values in statically declared data structures.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The `arp_initdata()` function, shown below, sets various elements of the header
    structures to the appropriate values for an ARP packet.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: From nemesis-arp.c
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Finally, the `nemesis_arp()` function calls the function `buildarp()` with pointers
    to the header data structures. Judging from the way the return value from `buildarp()`
    is handled here, `buildarp()` builds the packet and injects it. This function
    is found in yet another source file, nemesis-proto_arp.c.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: From nemesis-proto_arp.c
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: At a high level, this function should be readable to you. Using libnet functions,
    it opens a link interface and initializes memory for a packet. Then, it builds
    the Ethernet layer using elements from the Ethernet header data structure and
    then does the same for the ARP layer. Next, it writes the packet to the device
    to inject it, and finally cleans up by destroying the packet and closing the interface.
    The documentation for these functions from the libnet man page is shown below
    for clarity.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: From the libnet Man Page
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: With a basic understanding of C, API documentation, and common sense, you can
    teach yourself just by examining open source projects. For example, Dug Song provides
    a program called arpspoof, included with dsniff, that performs the ARP redirection
    attack.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: From the arpspoof Man Page
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The magic of this program comes from its `arp_send()` function, which also uses
    libnet to spoof packets. The source code for this function should be readable
    to you, since many of the previously explained libnet functions are used (shown
    in bold below). The use of structures and an error buffer should also be familiar.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: arpspoof.c
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The remaining libnet functions get hardware addresses, get the IP address, and
    look up hosts. These functions have descriptive names and are explained in detail
    on the libnet man page.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: From the libnet Man Page
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Once you've learned how to read C code, existing programs can teach you a lot
    by example. Programming libraries like libnet and libpcap have plenty of documentation
    that explains all the details you may not be able to divine from the source alone.
    The goal here is to teach you how to learn from source code, as opposed to just
    teaching how to use a few libraries. After all, there are many other libraries
    and a lot of existing source code that uses them.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Denial of Service
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the simplest forms of network attack is a Denial of Service (DoS) attack.
    Instead of trying to steal information, a DoS attack simply prevents access to
    a service or resource. There are two general forms of DoS attacks: those that
    crash services and those that flood services.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Denial of Service attacks that crash services are actually more similar to program
    exploits than network-based exploits. Often, these attacks are dependent on a
    poor implementation by a specific vendor. A buffer overflow exploit gone wrong
    will usually just crash the target program instead of directing the execution
    flow to the injected shellcode. If this program happens to be on a server, then
    no one else can access that server after it has crashed. Crashing DoS attacks
    like this are closely tied to a certain program and a certain version. Since the
    operating system handles the network stack, crashes in this code will take down
    the kernel, denying service to the entire machine. Many of these vulnerabilities
    have long since been patched on modern operating systems, but it's still useful
    to think about how these techniques might be applied to different situations.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 导致服务崩溃的拒绝服务攻击实际上与程序漏洞利用比基于网络的漏洞利用更相似。通常，这些攻击依赖于特定供应商的糟糕实现。一个错误的缓冲区溢出漏洞利用通常只会使目标程序崩溃，而不是将执行流程导向注入的
    shellcode。如果这个程序恰好在服务器上运行，那么在它崩溃后，其他人将无法访问该服务器。这种崩溃的 DoS 攻击与某个特定程序和版本紧密相关。由于操作系统处理网络堆栈，这段代码的崩溃将使内核崩溃，导致整个机器的服务被拒绝。许多这些漏洞在现代操作系统上早已被修补，但思考这些技术如何应用于不同情况仍然是有用的。
- en: SYN Flooding
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SYN 洪水
- en: A SYN flood tries to exhaust states in the TCP/IP stack. Since TCP maintains
    "reliable" connections, each connection needs to be tracked somewhere. The TCP/IP
    stack in the kernel handles this, but it has a finite table that can only track
    so many incoming connections. A SYN flood uses spoofing to take advantage of this
    limitation.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: SYN 洪水试图耗尽 TCP/IP 堆栈中的状态。由于 TCP 维护“可靠”的连接，每个连接都需要在某个地方进行跟踪。内核中的 TCP/IP 堆栈处理这项工作，但它有一个有限的表，只能跟踪这么多传入的连接。SYN
    洪水利用了这一限制。
- en: The attacker floods the victim's system with many SYN packets, using a spoofed
    nonexistent source address. Since a SYN packet is used to initiate a TCP connection,
    the victim's machine will send a SYN/ACK packet to the spoofed address in response
    and wait for the expected ACK response. Each of these waiting, half-open connections
    goes into a backlog queue that has limited space. Since the spoofed source addresses
    don't actually exist, the ACK responses needed to remove these entries from the
    queue and complete the connections never come. Instead, each half-open connection
    must time out, which takes a relatively long time.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者使用伪造的不存在的源地址向受害者的系统发送大量的 SYN 数据包。由于 SYN 数据包用于初始化 TCP 连接，受害者的机器将向伪造的地址发送一个
    SYN/ACK 数据包作为响应，并等待预期的 ACK 响应。每个这些等待的半开连接都会进入一个有限空间的回退队列。由于伪造的源地址实际上并不存在，因此从队列中删除这些条目并完成连接所需的
    ACK 响应永远不会到来。相反，每个半开连接必须超时，这需要相对较长的时间。
- en: As long as the attacker continues to flood the victim's system with spoofed
    SYN packets, the victim's backlog queue will remain full, making it nearly impossible
    for real SYN packets to get to the system and initiate valid TCP/IP connections.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 只要攻击者继续向受害者的系统发送伪造的 SYN 数据包，受害者的回退队列就会保持满载，这使得真正的 SYN 数据包几乎无法到达系统并初始化有效的 TCP/IP
    连接。
- en: Using the Nemesis and arpspoof source code as reference, you should be able
    to write a program that performs this attack. The example program below uses libnet
    functions pulled from the source code and socket functions previously explained.
    The Nemesis source code uses the function `libnet_get_prand()` to obtain pseudo-random
    numbers for various IP fields. The function `libnet_seed_prand()` is used to seed
    the randomizer. These functions are similarly used below.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以 Nemesis 和 arpspoof 的源代码为参考，你应该能够编写一个执行这种攻击的程序。下面的示例程序使用了从源代码中提取的 libnet 函数和之前解释过的套接字函数。Nemesis
    源代码使用 `libnet_get_prand()` 函数来获取用于各种 IP 字段的伪随机数。`libnet_seed_prand()` 函数用于初始化随机数生成器。以下类似地使用了这些函数。
- en: synflood.c
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: synflood.c
- en: '[PRE64]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This program uses a `print_ip()` function to handle converting the u_long type,
    used by libnet to store IP addresses, to the struct type expected by `inet_ntoa()`.
    The value doesn't change—the typecasting just appeases the compiler.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序使用一个 `print_ip()` 函数来处理将 libnet 存储 IP 地址所用的 u_long 类型转换为 `inet_ntoa()` 所期望的
    struct 类型。值本身并没有改变——类型转换只是为了让编译器满意。
- en: The current release of libnet is version 1.1, which is incompatible with libnet
    1.0\. However, Nemesis and arpspoof still rely on the 1.0 version of libnet, so
    this version is included in the LiveCD and this is also what we will use in our
    synflood program. Similar to compiling with libpcap, when compiling with libnet,
    the flag `-lnet` is used. However, this isn't quite enough information for the
    compiler, as the output below shows.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: libnet 的当前版本是 1.1，与 libnet 1.0 不兼容。然而，Nemesis 和 arpspoof 仍然依赖于 libnet 的 1.0
    版本，因此这个版本包含在 LiveCD 中，这也是我们将在我们的 synflood 程序中使用的版本。与使用 libpcap 编译类似，使用 libnet
    编译时，使用标志 `-lnet`。然而，这并不是足够的信息供编译器使用，如下面的输出所示。
- en: '[PRE65]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The compiler still fails because several mandatory define flags need to be set
    for libnet. Included with libnet, a program called libnet-config will output these
    flags.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器仍然失败，因为需要为 libnet 设置几个强制性的定义标志。与 libnet 一起，有一个名为 libnet-config 的程序会输出这些标志。
- en: '[PRE66]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Using the BASH shell's command substitution in both, these defines can be dynamically
    inserted into the compile command.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个中，使用 BASH shell 的命令替换功能，这些定义可以动态地插入到编译命令中。
- en: '[PRE67]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the example above, the host 192.168.42.88 is a Windows XP machine running
    an openssh server on port 22 via cygwin. The tcpdump output below shows the spoofed
    SYN packets flooding the host from apparently random IPs. While the program is
    running, legitimate connections cannot be made to this port.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，主机 192.168.42.88 是一台运行在 cygwin 上、端口 22 的 openssh 服务器的 Windows XP 机器。下面的
    tcpdump 输出显示了从看似随机的IP地址向主机发送的伪造 SYN 数据包洪水。当程序运行时，无法建立到该端口的合法连接。
- en: '[PRE68]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Some operating systems (for example, Linux) use a technique called syncookies
    to try to prevent SYN flood attacks. The TCP stack using syncookies adjusts the
    initial acknowledgment number for the responding SYN/ACK packet using a value
    based on host details and time (to prevent replay attacks).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作系统（例如，Linux）使用一种称为 syncookies 的技术来尝试防止 SYN 洪水攻击。使用 syncookies 的 TCP 栈使用基于主机细节和时间（以防止重放攻击）的值调整响应
    SYN/ACK 包的初始确认号。
- en: The TCP connections don't actually become active until the final ACK packet
    for the TCP handshake is checked. If the sequence number doesn't match or the
    ACK never arrives, a connection is never created. This helps prevent spoofed connection
    attempts, since the ACK packet requires information to be sent to the source address
    of the initial SYN packet.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 连接实际上只有在检查 TCP 握手的最终 ACK 包时才会变得活跃。如果序列号不匹配或 ACK 永远没有到达，就不会创建连接。这有助于防止伪造的连接尝试，因为
    ACK 包需要将信息发送到初始 SYN 包的源地址。
- en: The Ping of Death
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死亡之ping
- en: According to the specification for ICMP, ICMP echo messages can only have 2^(16),
    or 65,536, bytes of data in the data part of the packet. The data portion of ICMP
    packets is commonly overlooked, since the important information is in the header.
    Several operating systems crashed if they were sent ICMP echo messages that exceeded
    the size specified. An ICMP echo message of this gargantuan size became affectionately
    known as "The Ping of Death." It was a very simple hack exploiting a vulnerability
    that existed because no one ever considered this possibility. It should be easy
    for you to write a program using libnet that can perform this attack; however,
    it won't be that useful in the real world. Modern systems are all patched against
    this vulnerability.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 根据ICMP的规范，ICMP回显消息的数据部分只能有 2^(16)，即 65,536 字节的数据。ICMP数据包的数据部分通常被忽视，因为重要的信息在头部。如果发送的ICMP回显消息超过了指定的尺寸，几个操作系统会崩溃。这种巨大的尺寸的ICMP回显消息亲切地被称为“死亡之ping”。这是一个非常简单的黑客攻击，利用了由于没有人考虑这种可能性而存在的漏洞。你应该很容易编写一个使用
    libnet 执行这种攻击的程序；然而，在现实世界中它并不那么有用。现代系统都修补了这个漏洞。
- en: However, history tends to repeat itself. Even though oversized ICMP packets
    won't crash computers anymore, new technologies sometimes suffer from similar
    problems. The Bluetooth protocol, commonly used with phones, has a similar ping
    packet on the L2CAP layer, which is also used to measure the communication time
    on established links. Many implementations of Bluetooth suffer from the same oversized
    ping packet problem. Adam Laurie, Marcel Holtmann, and Martin Herfurt have dubbed
    this attack *Bluesmack* and have released source code by the same name that performs
    this attack.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，历史往往有惊人的相似之处。尽管过大的ICMP数据包不再会导致计算机崩溃，但新技术有时也会出现类似的问题。蓝牙协议，常用于手机，在L2CAP层也有类似的ping数据包，该数据包也用于测量已建立链路上的通信时间。许多蓝牙实现都存在同样的问题。Adam
    Laurie、Marcel Holtmann和Martin Herfurt将这种攻击称为*Bluesmack*，并发布了同名的源代码，该代码执行这种攻击。
- en: Teardrop
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 液滴攻击
- en: Another crashing DoS attack that came about for the same reason was called teardrop.
    Teardrop exploited another weakness in several vendors' implementations of IP
    fragmentation reassembly. Usually, when a packet is fragmented, the offsets stored
    in the header will line up to reconstruct the original packet with no overlap.
    The teardrop attack sent packet fragments with overlapping offsets, which caused
    implementations that didn't check for this irregular condition to inevitably crash.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种由于相同原因出现的崩溃式拒绝服务攻击被称为液滴攻击。液滴攻击利用了几个厂商在IP分片重组实现中的另一个弱点。通常，当一个数据包被分片时，存储在头部中的偏移量将排列整齐，以便无重叠地重新构造原始数据包。液滴攻击发送具有重叠偏移量的数据包片段，导致未检查这种不规则条件的实现不可避免地崩溃。
- en: Although this specific attack doesn't work anymore, understanding the concept
    can reveal problems in other areas. Although not limited to a Denial of Service,
    a recent remote exploit in the OpenBSD kernel (which prides itself on security)
    had to do with fragmented IPv6 packets. IP version 6 uses more complicated headers
    and even a different IP address format than the IPv4 most people are familiar
    with. Often, the same mistakes made in the past are repeated by early implementations
    of new products.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种特定的攻击已经不再有效，但理解这个概念可以揭示其他领域的问题。尽管不限于拒绝服务，但最近OpenBSD内核（以其安全性而自豪）的一个远程利用问题就与分片IPv6数据包有关。IPv6使用比人们熟悉的IPv4更复杂的头部信息，甚至使用不同的IP地址格式。通常，新产品的早期实现会重复过去犯过的同样错误。
- en: Ping Flooding
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ping 洪水攻击
- en: Flooding DoS attacks don't try to necessarily crash a service or resource, but
    instead try to overload it so it can't respond. Similar attacks can tie up other
    resources, such as CPU cycles and system processes, but a flooding attack specifically
    tries to tie up a network resource.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 洪水式拒绝服务攻击并不试图必然使服务或资源崩溃，而是试图使其过载，使其无法响应。类似的攻击可能会占用其他资源，如CPU周期和系统进程，但洪水攻击专门试图占用网络资源。
- en: The simplest form of flooding is just a ping flood. The goal is to use up the
    victim's bandwidth so that legitimate traffic can't get through. The attacker
    sends many large ping packets to the victim, which eat away at the bandwidth of
    the victim's network connection.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 洪水的最简单形式就是ping洪水攻击。目标是耗尽受害者的带宽，使合法流量无法通过。攻击者向受害者发送许多大型ping数据包，这些数据包会消耗受害者网络连接的带宽。
- en: There's nothing really clever about this attack—it's just a battle of bandwidth.
    An attacker with greater bandwidth than a victim can send more data than the victim
    can receive and therefore deny other legitimate traffic from getting to the victim.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击并没有什么真正高明的地方——它只是一场带宽的较量。攻击者如果拥有比受害者更大的带宽，就能发送比受害者能接收更多的数据，从而阻止其他合法流量到达受害者。
- en: Amplification Attacks
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 放大攻击
- en: There are actually some clever ways to perform a ping flood without using massive
    amounts of bandwidth. An amplification attack uses spoofing and broadcast addressing
    to amplify a single stream of packets by a hundred-fold. First, a target amplification
    system must be found. This is a network that allows communication to the broadcast
    address and has a relatively high number of active hosts. Then the attacker sends
    large ICMP echo request packets to the broadcast address of the amplification
    network, with a spoofed source address of the victim's system. The amplifier will
    broadcast these packets to all the hosts on the amplification network, which will
    then send corresponding ICMP echo reply packets to the spoofed source address
    (i.e., to the victim's machine).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有一些巧妙的方法可以在不使用大量带宽的情况下执行ping洪水攻击。放大攻击利用欺骗和广播地址来将单个数据包流放大一百倍。首先，必须找到一个目标放大系统。这是一个允许向广播地址进行通信并且具有相对较高活跃主机数量的网络。然后，攻击者向放大网络的广播地址发送大量ICMP回显请求数据包，并使用受害者的系统作为欺骗的源地址。放大器将这些数据包广播到放大网络上的所有主机，然后这些主机将向欺骗的源地址（即受害者的机器）发送相应的ICMP回显回复数据包。
- en: This amplification of traffic allows the attacker to send a relatively small
    stream of ICMP echo request packets out, while the victim gets swamped with up
    to a couple hundred times as many ICMP echo reply packets. This attack can be
    done with both ICMP packets and UDP echo packets. These techniques are known as
    *smurf* and *fraggle* attacks, respectively.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这种流量放大允许攻击者发送相对较小的ICMP回显请求数据包流，而受害者则被多达几百倍的ICMP回显回复数据包淹没。这种攻击可以使用ICMP数据包和UDP回显数据包进行。这些技术分别被称为*smurf*和*fraggle*攻击。
- en: '![](httpatomoreillycomsourcenostarchimages254478.png.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图片](http://atomoreilly.com/source/nostarch/images/254478.png.jpg)'
- en: Figure 0x400-9.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0x400-9。
- en: Distributed DoS Flooding
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式DoS洪水
- en: A *distributed DoS (DDoS) attack* is a distributed version of a flooding DoS
    attack. Since bandwidth consumption is the goal of a flooding DoS attack, the
    more bandwidth the attacker is able to work with, the more damage they can do.
    In a DDoS attack, the attacker first compromises a number of other hosts and installs
    daemons on them. Systems installed with such software are commonly referred to
    as bots and make up what is known as a botnet. These bots wait patiently until
    the attacker picks a victim and decides to attack. The attacker uses some sort
    of a controlling program, and all of the bots simultaneously attack the victim
    with some form of flooding DoS attack. Not only does the great number of distributed
    hosts multiply the effect of the flooding, this also makes tracing the attack
    source much more difficult.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '*分布式DoS（DDoS）攻击*是洪水DoS攻击的分布式版本。由于带宽消耗是洪水DoS攻击的目标，攻击者能够使用的带宽越多，他们能够造成的损害就越大。在DDoS攻击中，攻击者首先入侵多个其他主机并在它们上安装守护进程。安装了此类软件的系统通常被称为僵尸程序，构成了所谓的僵尸网络。这些僵尸程序耐心等待，直到攻击者选择一个受害者并决定发起攻击。攻击者使用某种控制程序，所有的僵尸程序同时以某种形式的洪水DoS攻击攻击受害者。不仅大量分布的主机增加了洪水的影响，这也使得追踪攻击源变得更加困难。'
- en: TCP/IP Hijacking
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP劫持
- en: '*TCP/IP hijacking* is a clever technique that uses spoofed packets to take
    over a connection between a victim and a host machine. This technique is exceptionally
    useful when the victim uses a one-time password to connect to the host machine.
    A one-time password can be used to authenticate once and only once, which means
    that sniffing the authentication is useless for the attacker.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*TCP/IP劫持*是一种使用欺骗数据包来接管受害者和主机机器之间连接的巧妙技术。当受害者使用一次性密码连接到主机机器时，这种技术特别有用。一次性密码只能用于认证一次，这意味着对于攻击者来说，嗅探认证是毫无用处的。'
- en: To carry out a TCP/IP hijacking attack, the attacker must be on the same network
    as the victim. By sniffing the local network segment, all of the details of open
    TCP connections can be pulled from the headers. As we have seen, each TCP packet
    contains a sequence number in its header. This sequence number is incremented
    with each packet sent to ensure that packets are received in the correct order.
    While sniffing, the attacker has access to the sequence numbers for a connection
    between a victim (system A in the following illustration) and a host machine (system
    B). Then the attacker sends a spoofed packet from the victim's IP address to the
    host machine, using the sniffed sequence number to provide the proper acknowledgment
    number, as shown here.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages254502.png.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
- en: Figure 0x400-10.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: The host machine will receive the spoofed packet with the correct acknowledgment
    number and will have no reason to believe it didn't come from the victim machine.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: RST Hijacking
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very simple form of TCP/IP hijacking involves injecting an authentic-looking
    reset (RST) packet. If the source is spoofed and the acknowledgment number is
    correct, the receiving side will believe that the source actually sent the reset
    packet, and the connection will be reset.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a program to perform this attack on a target IP. At a high level, it
    would sniff using libpcap, then inject RST packets using libnet. Such a program
    doesn't need to look at every packet but only at established TCP connections to
    the target IP. Many other programs that use libpcap also don't need to look at
    every single packet, so libpcap provides a way to tell the kernel to only send
    certain packets that match a filter. This filter, known as a Berkeley Packet Filter
    (BPF), is very similar to a program. For example, the filter rule to filter for
    a destination IP of 192.168.42.88 is `"dst host 192.168.42.88"`. Like a program,
    this rule consists of keyword and must be compiled before it's actually sent to
    the kernel. The tcpdump program uses BPFs to filter what it captures; it also
    provides a mode to dump the filter program.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'After the filter rule is compiled, it can be passed to the kernel for filtering.
    Filtering for established connections is a bit more complicated. All established
    connections will have the ACK flag set, so this is what we should look for. The
    TCP flags are found in the 13th octet of the TCP header. The flags are found in
    the following order, from left to right: URG, ACK, PSH, RST, SYN, and FIN. This
    means that if the ACK flag is turned on, the 13th octet would be `00010000` in
    binary, which is 16 in decimal. If both SYN and ACK are turned on, the 13th octet
    would be `00010010` in binary, which is 18 in decimal.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a filter that matches when the ACK flag is turned on without
    caring about any of the other bits, the bitwise AND operator is used. ANDing `00010010`
    with `00010000` will produce `00010000`, since the ACK bit is the only bit where
    both bits are `1`. This means that a filter of `tcp[13] & 16 == 16` will match
    the packets where the ACK flag is turned on, regardless of the state of the remaining
    flags.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个在ACK标志被打开时匹配的过滤器，而不关心其他任何位，我们使用了按位与运算符。将`00010010`与`00010000`进行与操作将产生`00010000`，因为ACK位是唯一一个两个位都是`1`的位。这意味着`tcp[13]
    & 16 == 16`的过滤器将匹配ACK标志被打开的数据包，而不管其他标志的状态如何。
- en: This filter rule can be rewritten using named values and inverted logic as `tcp[tcpflags]
    & tcp-ack != 0`. This is easier to read but still provides the same result. This
    rule can be combined with the previous destination IP rule using and logic; the
    full rule is shown below.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过滤器规则可以使用命名值和逆逻辑重写为`tcp[tcpflags] & tcp-ack != 0`。这更容易阅读，但仍然提供相同的结果。这个规则可以使用与逻辑与先前的目标IP规则组合；完整的规则如下所示。
- en: '[PRE70]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: A similar rule is used in the following program to filter the packets libpcap
    sniffs. When the program gets a packet, the header information is used to spoof
    a RST packet. This program will be explained as it's listed.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下程序中，使用类似的规则来过滤libpcap嗅探到的数据包。当程序接收到数据包时，使用头部信息来模拟一个RST数据包。这个程序将按其列出顺序进行解释。
- en: rst_hijack.c
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rst_hijack.c
- en: '[PRE71]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The majority of this program should make sense to you. In the beginning, a `data_pass`
    structure is defined, which is used to pass data through the libpcap callback.
    libnet is used to open a raw socket interface and to allocate packet memory. The
    file descriptor for the raw socket and a pointer to the packet memory will be
    needed in the callback function, so this critical libnet data is stored in its
    own structure. The final argument to the `pcap_loop()` call is user pointer, which
    is passed directly to the callback function. By passing a pointer to the `critical_libnet_data`
    structure, the callback function will have access to everything in this structure.
    Also, the snap length value used in `pcap_open_live()` has been reduced from `4096`
    to `128`, since the information needed from the packet is just in the headers.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这段程序的大部分内容应该对你来说是有意义的。一开始，定义了一个`data_pass`结构，该结构用于通过libpcap回调传递数据。libnet用于打开原始套接字接口并分配数据包内存。在回调函数中需要原始套接字文件描述符和数据包内存指针，因此这些关键的libnet数据存储在其自己的结构中。`pcap_loop()`调用中的最后一个参数是用户指针，它直接传递到回调函数。通过传递`critical_libnet_data`结构体的指针，回调函数将能够访问该结构体中的所有内容。此外，`pcap_open_live()`中使用的snap长度值已从`4096`减少到`128`，因为所需的信息仅限于数据包的头部。
- en: '[PRE72]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The next function compiles and sets the BPF to only accept packets from established
    connections to the target IP. The `sprintf()` function is just a `printf()` that
    prints to a string.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数编译并设置BPF，以便只接受目标IP的已建立连接的数据包。`sprintf()`函数只是一个将输出打印到字符串的`printf()`。
- en: '[PRE73]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The callback function spoofs the RST packets. First, the critical libnet data
    is retrieved, and pointers to the IP and TCP headers are set using the structures
    included with libnet. We could use our own structures from hacking-network.h,
    but the libnet structures are already there and compensate for the host's byte
    ordering. The spoofed RST packet uses the sniffed source address as the destination,
    and vice versa. The sniffed sequence number is used as the spoofed packet's acknowledgment
    number, since that is what is expected.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数模拟RST数据包。首先，获取关键的libnet数据，并使用libnet提供的结构设置IP和TCP头指针。我们可以使用自己从hacking-network.h中定义的结构，但libnet的结构已经存在，并且可以补偿主机的字节序。模拟的RST数据包使用嗅探到的源地址作为目标地址，反之亦然。嗅探到的序列号被用作模拟数据包的确认号，因为这是预期的。
- en: '[PRE74]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Continued Hijacking
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续劫持
- en: The spoofed packet doesn't need to be an RST packet. This attack becomes more
    interesting when the spoof packet contains data. The host machine receives the
    spoofed packet, increments the sequence number, and responds to the victim's IP.
    Since the victim's machine doesn't know about the spoofed packet, the host machine's
    response has an incorrect sequence number, so the victim ignores that response
    packet. And since the victim's machine ignored the host machine's response packet,
    the victim's sequence number count is off. Therefore, any packet the victim tries
    to send to the host machine will have an incorrect sequence number as well, causing
    the host machine to ignore it. In this case, both legitimate sides of the connection
    have incorrect sequence numbers, resulting in a desynchronized state. And since
    the attacker sent out the first spoofed packet that caused all this chaos, it
    can keep track of sequence numbers and continue spoofing packets from the victim's
    IP address to the host machine. This lets the attacker continue communicating
    with the host machine while the victim's connection hangs.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 欺骗的数据包不需要是RST数据包。当欺骗的数据包包含数据时，这种攻击变得更加有趣。主机机器接收到欺骗的数据包，增加序列号，并回应受害者的IP。由于受害者机器不知道欺骗的数据包，主机机器的响应具有错误的序列号，因此受害者忽略该响应数据包。而且，由于受害者机器忽略了主机机器的响应数据包，受害者的序列号计数就偏移了。因此，受害者尝试发送给主机机器的任何数据包都将具有错误的序列号，导致主机机器忽略它。在这种情况下，连接的双方都有错误的序列号，导致不同步的状态。而且，由于攻击者发送了第一个导致所有这些混乱的欺骗数据包，它可以跟踪序列号并继续从受害者的IP地址向主机机器发送欺骗数据包。这使得攻击者可以在受害者的连接挂起的同时继续与主机机器通信。
- en: Port Scanning
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端口扫描
- en: Port scanning is a way of figuring out which ports are listening and accepting
    connections. Since most services run on standard, documented ports, this information
    can be used to determine which services are running. The simplest form of port
    scanning involves trying to open TCP connections to every possible port on the
    target system. While this is effective, it's also noisy and detectable. Also,
    when connections are established, services will normally log the IP address. To
    avoid this, several clever techniques have been invented.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 端口扫描是一种确定哪些端口正在监听并接受连接的方法。由于大多数服务都在标准、已记录的端口上运行，因此这些信息可以用来确定正在运行的服务。端口扫描的最简单形式是尝试在目标系统上的每个可能的端口上打开TCP连接。虽然这种方法有效，但它也很嘈杂且容易被检测到。此外，当建立连接时，服务通常会记录IP地址。为了避免这种情况，已经发明了几种巧妙的技术。
- en: A port scanning tool called nmap, written by Fyodor, implements all of the following
    port-scanning techniques. This tool has become one of the most popular open source
    port-scanning tools.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 由Fyodor编写的端口扫描工具nmap实现了以下所有端口扫描技术。这个工具已经成为最受欢迎的开源端口扫描工具之一。
- en: Stealth SYN Scan
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 潜行SYN扫描
- en: 'A SYN scan is also sometimes called a *half-open* scan. This is because it
    doesn''t actually open a full TCP connection. Recall the TCP/IP handshake: When
    a full connection is made, first a SYN packet is sent, then a SYN/ACK packet is
    sent back, and finally an ACK packet is returned to complete the handshake and
    open the connection. A SYN scan doesn''t complete the handshake, so a full connection
    is never opened. Instead, only the initial SYN packet is sent, and the response
    is examined. If a SYN/ACK packet is received in response, that port must be accepting
    connections. This is recorded, and an RST packet is sent to tear down the connection
    to prevent the service from accidentally being DoSed.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: SYN扫描有时也称为*半开*扫描。这是因为它实际上并没有打开完整的TCP连接。回想一下TCP/IP握手：当建立完整连接时，首先发送一个SYN数据包，然后发送一个SYN/ACK数据包作为回应，最后发送一个ACK数据包来完成握手并打开连接。SYN扫描不会完成握手，因此永远不会打开完整的连接。相反，只发送初始的SYN数据包，并检查响应。如果收到SYN/ACK数据包作为回应，那么该端口必须正在接受连接。这将被记录下来，并发送一个RST数据包来断开连接，以防止服务意外地被DoS攻击。
- en: Using nmap, a SYN scan can be performed using the command-line option `-sS`.
    The program must be run as root, since the program isn't using standard sockets
    and needs raw network access.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nmap，可以使用命令行选项`-sS`执行SYN扫描。程序必须以root权限运行，因为程序不使用标准套接字，需要原始网络访问。
- en: '[PRE75]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: FIN, X-mas, and Null Scans
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FIN, X-mas, and Null Scans
- en: 'In response to SYN scanning, new tools to detect and log half-open connections
    were created. So yet another collection of techniques for stealth port scanning
    evolved: FIN, X-mas, and Null scans. These all involve sending a nonsensical packet
    to every port on the target system. If a port is listening, these packets just
    get ignored. However, if the port is closed and the implementation follows protocol
    (RFC 793), an RST packet will be sent. This difference can be used to detect which
    ports are accepting connections, without actually opening any connections.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对 SYN 扫描，创建了新的工具来检测和记录半开连接。因此，又出现了一组用于隐蔽端口扫描的技术：FIN、X-mas 和 Null 扫描。这些技术都涉及向目标系统上的每个端口发送无意义的数据包。如果端口正在监听，这些数据包就会被忽略。然而，如果端口关闭并且实现遵循协议（RFC
    793），则会发送一个 RST 数据包。这种差异可以用来检测哪些端口正在接受连接，而实际上并不需要打开任何连接。
- en: The FIN scan sends a FIN packet, the X-mas scan sends a packet with FIN, URG,
    and PUSH turned on (so named because the flags are lit up like a Christmas tree),
    and the Null scan sends a packet with no TCP flags set. While these types of scans
    are stealthier, they can also be unreliable. For instance, Microsoft's implementation
    of TCP doesn't send RST packets like it should, making this form of scanning ineffective.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: FIN 扫描发送一个 FIN 数据包，X-mas 扫描发送一个同时开启 FIN、URG 和 PUSH 标志的数据包（之所以这样命名是因为标志亮起就像圣诞树一样），而
    Null 扫描发送一个没有设置 TCP 标志的数据包。虽然这些扫描类型更隐蔽，但它们也可能不可靠。例如，微软对 TCP 的实现并没有像预期的那样发送 RST
    数据包，这使得这种扫描方式无效。
- en: Using nmap, FIN, X-mas, and NULL scans can be performed using the command-line
    options `-sF, -sX`, and `-sN`, respectively. Their output looks basically the
    same as the previous scan.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 nmap，可以通过命令行选项 `-sF`、`-sX` 和 `-sN` 分别执行 FIN、X-mas 和 NULL 扫描。它们的输出基本上与之前的扫描相同。
- en: Spoofing Decoys
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪造诱饵
- en: Another way to avoid detection is to hide among several decoys. This technique
    simply spoofs connections from various decoy IP addresses in between each real
    port-scanning connection. The responses from the spoofed connections aren't needed,
    since they are simply misleads. However, the spoofed decoy addresses must use
    real IP addresses of live hosts; otherwise, the target may be accidentally SYN
    flooded.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种避免检测的方法是隐藏在几个诱饵之中。这种技术简单地在每个真实端口扫描连接之间伪造来自不同诱饵 IP 地址的连接。伪造连接的响应并不需要，因为它们只是误导。然而，伪造的诱饵地址必须使用活动主机的真实
    IP 地址；否则，目标可能会意外地被 SYN 洪水攻击。
- en: Decoys can be specified in nmap with the `-D` command-line option. The sample
    nmap command shown below scans the IP 192.168.42.72, using 192.168.42.10 and 192.168.42.11
    as decoys.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 nmap 的 `-D` 命令行选项指定诱饵。下面显示的示例 nmap 命令扫描 IP 192.168.42.72，使用 192.168.42.10
    和 192.168.42.11 作为诱饵。
- en: '[PRE76]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Idle Scanning
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空闲扫描
- en: Idle scanning is a way to scan a target using spoofed packets from an idle host,
    by observing changes in the idle host. The attacker needs to find a usable idle
    host that is not sending or receiving any other network traffic and that has a
    TCP implementation that produces predictable IP IDs that change by a known increment
    with each packet. IP IDs are meant to be unique per packet per session, and they
    are commonly incremented by a fixed amount. Predictable IP IDs have never really
    been considered a security risk, and idle scanning takes advantage of this misconception.
    Newer operating systems, such as the recent Linux kernel, OpenBSD, and Windows
    Vista, randomize the IP ID, but older operating systems and hardware (such as
    printers) typically do not.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 空闲扫描是一种使用空闲主机伪造的数据包扫描目标的方法，通过观察空闲主机的变化来实现。攻击者需要找到一个可用的空闲主机，该主机没有发送或接收任何其他网络流量，并且具有产生可预测
    IP ID 的 TCP 实现，这些 IP ID 随每个数据包以已知增量变化。IP ID 的目的是在每个会话中为每个数据包提供唯一性，并且通常以固定数量递增。可预测的
    IP ID 从未真正被视为安全风险，而空闲扫描正是利用了这种误解。较新的操作系统，如最近的 Linux 内核、OpenBSD 和 Windows Vista，会随机化
    IP ID，但较旧的操作系统和硬件（如打印机）通常不会。
- en: First, the attacker gets the current IP ID of the idle host by contacting it
    with a SYN packet or an unsolicited SYN/ACK packet and observing the IP ID of
    the response. By repeating this process a few more times, the increment applied
    to the IP ID with each packet can be determined.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，攻击者通过发送一个 SYN 数据包或未经请求的 SYN/ACK 数据包与空闲主机联系，并观察响应的 IP ID 来获取空闲主机的当前 IP ID。通过重复这个过程几次，可以确定每次数据包应用到的
    IP ID 的增量。
- en: 'Then, the attacker sends a spoofed SYN packet with the idle host''s IP address
    to a port on the target machine. One of two things will happen, depending on whether
    that port on the victim machine is listening:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: If that port is listening, a SYN/ACK packet will be sent back to the idle host.
    But since the idle host didn't actually send out the initial SYN packet, this
    response appears to be unsolicited to the idle host, and it responds by sending
    back an RST packet.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If that port isn't listening, the target machine doesn't send a SYN/ACK packet
    back to the idle host, so the idle host doesn't respond.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, the attacker contacts the idle host again to determine how much
    the IP ID has incremented. If it has only incremented by one interval, no other
    packets were sent out by the idle host between the two checks. This implies that
    the port on the target machine is closed. If the IP ID has incremented by two
    intervals, one packet, presumably an RST packet, was sent out by the idle machine
    between the checks. This implies that the port on the target machine is open.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: The steps are illustrated on the next page for both possible outcomes.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if the idle host isn't truly idle, the results will be skewed. If
    there is light traffic on the idle host, multiple packets can be sent for each
    port. If 20 packets are sent, then a change of 20 incremental steps should be
    an indication of an open port, and none, of a closed port. Even if there is light
    traffic, such as one or two non–scan-related packets sent by the idle host, this
    difference is large enough that it can still be detected.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: If this technique is used properly on an idle host that doesn't have any logging
    capabilities, the attacker can scan any target without ever revealing his or her
    IP address.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'After finding a suitable idle host, this type of scanning can be done with
    nmap using the `-sI` command-line option followed by the idle host''s address:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![](httpatomoreillycomsourcenostarchimages254496.png.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
- en: Figure 0x400-11.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Proactive Defense (shroud)
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Port scans are often used to profile systems before they are attacked. Knowing
    what ports are open allows an attacker to determine which services can be attacked.
    Many IDSs offer methods to detect port scans, but by then the information has
    already been leaked. While writing this chapter, I wondered if it is possible
    to prevent port scans before they actually happen. Hacking, really, is all about
    coming up with new ideas, so a newly developed method for proactive port-scanning
    defense will be presented here.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the FIN, Null, and X-mas scans can be prevented by a simple kernel
    modification. If the kernel never sends reset packets, these scans will turn up
    nothing. The following output uses `grep` to find the kernel code responsible
    for sending reset packets.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: By adding the `return` command (shown above in bold), the `tcp_v4_send_reset()`
    kernel function will simply return instead of doing anything. After the kernel
    is recompiled, the resulting kernel won't send out reset packets, avoiding information
    leakage.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`return`命令（如上所示加粗），`tcp_v4_send_reset()`内核函数将简单地返回而不是执行任何操作。在内核重新编译后，生成的内核不会发送重置数据包，从而避免信息泄露。
- en: FIN Scan Before the Kernel Modification
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心修改前的FIN扫描
- en: '[PRE79]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: FIN Scan After the Kernel Modification
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心修改后的FIN扫描
- en: '[PRE80]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This works fine for scans that rely on RST packets, but preventing information
    leakage with SYN scans and full-connect scans is a bit more difficult. In order
    to maintain functionality, open ports have to respond with SYN/ACK packets—there
    is no way around that. But if all of the closed ports also responded with SYN/ACK
    packets, the amount of useful information an attacker could retrieve from port
    scans would be minimized. Simply opening every port would cause a major performance
    hit, though, which isn't desirable. Ideally, this should all be done without using
    a TCP stack. The following program does exactly that. It's a modification of the
    rst_hijack.c program, using a more complex BPF string to filter only SYN packets
    destined for closed ports. The callback function spoofs a legitimate looking SYN/ACK
    response to any SYN packet that makes it through the BPF. This will flood port
    scanners with a sea of false positives, which will hide legitimate ports.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于依赖于RST数据包的扫描来说效果很好，但防止SYN扫描和全连接扫描的信息泄露则要困难一些。为了保持功能，开放端口必须以SYN/ACK数据包响应——这是无法绕过的。但如果所有关闭的端口也以SYN/ACK数据包响应，攻击者从端口扫描中能获取的有用信息量将会最小化。然而，简单地打开所有端口会导致性能大幅下降，这并不是所希望的。理想情况下，这一切都应该在不使用TCP栈的情况下完成。以下程序正是如此。它是rst_hijack.c程序的修改版，使用更复杂的BPF字符串来过滤仅针对关闭端口的SYN数据包。回调函数对通过BPF的任何SYN数据包伪造一个看起来合法的SYN/ACK响应。这将向端口扫描器发送大量的假阳性，从而隐藏合法端口。
- en: shroud.c
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: shroud.c
- en: '[PRE81]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: There are a few tricky parts in the code above, but you should be able to follow
    all of it. When the program is compiled and executed, it will shroud the IP address
    given as the first argument, with the exception of a list of existing ports provided
    as the remaining arguments.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中有几个棘手的部分，但你应该能够理解所有内容。当程序编译并执行时，它将隐藏作为第一个参数给出的IP地址，除了作为剩余参数提供的现有端口列表之外。
- en: '[PRE82]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: While shroud is running, any port scanning attempts will show every port to
    be open.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 当shroud运行时，任何端口扫描尝试都会显示所有端口都是开放的。
- en: '[PRE83]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The only service that is actually running is ssh on port 22, but it is hidden
    in a sea of false positives. A dedicated attacker could simply telnet to every
    port to check the banners, but this technique could easily be expanded to spoof
    banners also.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上运行的服务只有一个，即22号端口上的ssh，但它隐藏在假阳性之中。一个专门的攻击者可以简单地telnet到每个端口来检查标语，但这种技术可以很容易地扩展到伪造标语。
- en: Reach Out and Hack Someone
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伸出援手，黑客他人
- en: Network programming tends to move many chunks of memory around and is heavy
    in typecasting. You've seen for yourself how crazy some of the typecasts can get.
    Mistakes thrive in this type of chaos. And since many network programs need to
    run as root, these little mistakes can become critical vulnerabilities. One such
    vulnerability exists in the code from this chapter. Did you notice it?
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 网络编程倾向于移动许多内存块，并且类型转换很重。你自己已经看到了一些类型转换是多么疯狂。在这种混乱中，错误会蓬勃发展。而且由于许多网络程序需要以root身份运行，这些小错误可能会成为关键漏洞。本章代码中存在这样一个漏洞。你注意到它了吗？
- en: Reach Out and Hack Someone
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伸出援手，黑客他人
- en: From hacking-network.h
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自hacking-network.h
- en: '[PRE84]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `recv_line()` function in hacking-network.h has a small mistake of omission—there
    is no code to limit the length. This means received bytes can overflow if they
    exceed the `dest_buffer` size. The tinyweb server program and any other programs
    that use this function are vulnerable to attack.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在hacking-network.h中的`recv_line()`函数有一个小的遗漏错误——没有限制长度的代码。这意味着如果接收的字节超过`dest_buffer`的大小，就会溢出。tinyweb服务器程序以及使用此函数的任何其他程序都容易受到攻击。
- en: Analysis with GDB
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GDB分析
- en: To exploit the vulnerability in the tinyweb.c program, we just need to send
    packets that will strategically overwrite the return address. First, we need to
    know the offset from the start of a buffer we control to the stored return address.
    Using GDB, we can analyze the compiled program to find this; however, there are
    some subtle details that can cause tricky problems. For example, the program requires
    root privileges, so the debugger must be run as root. But using `sudo` or running
    with root's environment will change the stack, meaning the addresses seen in the
    debugger's run of the binary won't match the addresses when it's running normally.
    There are other slight differences that can shift memory around in the debugger
    like this, creating inconsistencies that can be maddening to track down. According
    to the debugger, everything will look like it should work; however, the exploit
    fails when run outside the debugger, since the addresses are different.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用 tinyweb.c 程序中的漏洞，我们只需要发送会策略性地覆盖返回地址的数据包。首先，我们需要知道从我们控制的缓冲区开始到存储的返回地址的偏移量。使用
    GDB，我们可以分析编译后的程序以找到这个偏移量；然而，有一些细微的细节可能会导致复杂的问题。例如，程序需要 root 权限，因此调试器必须以 root 身份运行。但是使用
    `sudo` 或以 root 的环境运行会改变堆栈，这意味着在调试器运行二进制文件时看到的地址与正常运行时的地址不匹配。还有其他一些细微的差异可能会在调试器中像这样移动内存，造成不一致，难以追踪。根据调试器的显示，一切看起来都应该是正常的；然而，当在调试器外运行时，由于地址不同，攻击会失败。
- en: One elegant solution to this problem is to attach to the process after it's
    already running. In the output below, GDB is used to attach to an already-running
    tinyweb process that was started in another terminal. The source is recompiled
    using the `-g` option to include debugging symbols that GDB can apply to the running
    process.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的优雅方法是连接到已经运行的进程。在下面的输出中，GDB 用于连接到另一个终端中启动的已经运行的 tinyweb 进程。使用 `-g` 选项重新编译源代码以包含
    GDB 可以应用于运行进程的调试符号。
- en: '[PRE85]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: After attaching to the running process, a stack backtrace shows the program
    is currenty in `main()`, waiting for a connection. After setting a breakpoint
    at the first `recv_line()` call on line 62 (![](httpatomoreillycomsourcenostarchimages254488.png)),
    the program is allowed to continue. At this point, the program's execution must
    be advanced by making a web request using `wget` in another terminal or a browser.
    Then the breakpoint in `handle_connection()` will be hit.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到正在运行的进程后，堆栈跟踪显示程序当前在 `main()` 中，等待连接。在 62 行的第一次 `recv_line()` 调用处设置断点 (![](httpatomoreillycomsourcenostarchimages254488.png))
    后，程序被允许继续执行。此时，必须通过在另一个终端中使用 `wget` 或浏览器发起网络请求来推进程序的执行。然后 `handle_connection()`
    中的断点将被触发。
- en: '[PRE86]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: At the breakpoint, the request buffer begins at `0xbfffff5c0`. The `bt` command's
    stack backtrace shows that the return address from `handle_connection()` is `0x08048cf6`.
    Since we know how the local variables are generally laid out on the stack, we
    know the request buffer is near the end of the frame. This means that the stored
    return address should be on the stack somewhere near the end of this 500-byte
    buffer. Since we already know the general area to look, a quick inspection shows
    the stored return address is at `0xbffff7dc` (![](httpatomoreillycomsourcenostarchimages254530.png)).
    A little math shows the stored return address is 540 bytes from the start of the
    request buffer. However, there are a few bytes near the beginning of the buffer
    that might be mangled by the rest of the function. Remember, we don't gain control
    of the program until the function returns. To account for this, it's best to just
    avoid the beginning of the buffer. Skipping the first 200 bytes should be safe,
    while leaving plenty of space for shellcode in the remaining 300 bytes. This means
    `0xbffff688` is the target return address.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在断点处，请求缓冲区从 `0xbfffff5c0` 开始。`bt` 命令的堆栈跟踪显示从 `handle_connection()` 返回的地址是 `0x08048cf6`。由于我们知道局部变量通常在堆栈上的布局，我们知道请求缓冲区位于帧的末尾附近。这意味着存储的返回地址应该在堆栈的末尾附近这个
    500 字节缓冲区的某个位置。既然我们已经知道了要查找的大致区域，快速检查显示存储的返回地址在 `0xbffff7dc` (![](httpatomoreillycomsourcenostarchimages254530.png))。一点数学计算表明存储的返回地址距离请求缓冲区的开始有
    540 字节。然而，缓冲区开头附近的一些字节可能会被函数的其余部分破坏。记住，我们只有在函数返回后才能控制程序。为了解决这个问题，最好只避免缓冲区的开头。跳过前
    200 字节应该是安全的，同时为剩余的 300 字节留出足够的空间用于 shellcode。这意味着 `0xbffff688` 是目标返回地址。
- en: Almost Only Counts with Hand Grenades
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几乎只有手榴弹才有效
- en: The following exploit for the tinyweb program uses the offset and return address
    overwrite values calculated with GDB. It fills the exploit buffer with null bytes,
    so anything written into it will automatically be null-terminated. Then it fills
    the first 540 bytes with NOP instructions. This builds the NOP sled and fills
    the buffer up to the return address overwrite location. Then the entire string
    is terminated with the `'\r\n'` line terminator.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: tinyweb_exploit.c
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'When this program is compiled, it can remotely exploit hosts running the tinyweb
    program, tricking them into running the shellcode. The exploit also dumps out
    the bytes of the exploit buffer before it sends it. In the output below, the tinyweb
    program is run in a different terminal, and the exploit is tested against it.
    Here''s the output from the attacker''s terminal:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Back on the terminal running the tinyweb program, the output shows the exploit
    buffer was received and the shellcode is executed. This will provide a rootshell,
    but only for the console running the server. Unfortunately, we aren''t at the
    console, so this won''t do us any good. At the server console, we see the following:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The vulnerability certainly exists, but the shellcode doesn't do what we want
    in this case. Since we're not at the console, shellcode is just a selfcontained
    program, designed to take over another program to open a shell. Once control of
    the program's execution pointer is taken, the injected shellcode can do anything.
    There are many different types of shellcode that can be used in different situations
    (or payloads). Even though not all shellcode actually spawns a shell, it's still
    commonly called shellcode.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Port-Binding Shellcode
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When exploiting a remote program, spawning a shell locally is pointless. Port-binding
    shellcode listens for a TCP connection on a certain port and serves up the shell
    remotely. Assuming you already have port-binding shellcode ready, using it is
    simply a matter of replacing the shellcode bytes defined in the exploit. Port-binding
    shellcode is included in the LiveCD that will bind to port 31337\. These shellcode
    bytes are shown in the output below.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: After some quick formatting, these bytes are swapped into the shellcode bytes
    of the tinyweb_exploit.c program, resulting in tinyweb_exploit2.c. The new shellcode
    line is shown below.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: New Line from tinyweb_exploit2.c
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: When this exploit is compiled and run against a host running tinyweb server,
    the shellcode listens on port 31337 for a TCP connection. In the output below,
    a program called nc is used to connect to the shell. This program is netcat (*nc*
    for short), which works like that cat program but over the network. We can't just
    use telnet to connect since it automatically terminates all outgoing lines with
    `'\r\n'`. The output of this exploit is shown below. The `-vv` command-line option
    passed to netcat is just to make it more verbose.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Even though the remote shell doesn't display a prompt, it still accepts commands
    and returns the output over the network.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 即使远程shell不会显示提示符，它仍然接受命令并通过网络返回输出。
- en: A program like netcat can be used for many other things. It's designed to work
    like a console program, allowing standard input and output to be piped and redirected.
    Using netcat and the port-binding shellcode in a file, the same exploit can be
    carried out on the command line.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 netcat 这样的程序可以用于许多其他事情。它被设计成像控制台程序一样工作，允许标准输入和输出通过管道和重定向。使用 netcat 和文件中的端口绑定shellcode，相同的攻击可以在命令行上执行。
- en: '[PRE93]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In the output above, first the length of the port-binding shellcode is shown
    to be 92 bytes. The return address is found 540 bytes from the start of the buffer,
    so with a 300-byte NOP sled and 92 bytes of shellcode, there are 152 bytes to
    the return address overwrite. This means that if the target return address is
    repeated 38 times at the end of the buffer, the last one should do the overwrite.
    Finally, the buffer is terminated with `'\r\n'`. The commands that build the buffer
    are grouped with parentheses to pipe the buffer into netcat. netcat connects to
    the tinyweb program and sends the buffer. After the shellcode runs, netcat needs
    to be broken out of by pressing CTRL-C, since the original socket connection is
    still open. Then, netcat is used again to connect to the shell bound on port 31337.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的输出中，首先显示了端口绑定shellcode的长度为92字节。返回地址位于缓冲区开始处的540字节处，因此，使用300字节的NOP sled和92字节的shellcode，到返回地址覆盖处有152字节。这意味着如果目标返回地址在缓冲区末尾重复38次，最后一个应该完成覆盖。最后，缓冲区以`'\r\n'`结束。构建缓冲区的命令用括号分组，以便将缓冲区管道输入到netcat。netcat连接到tinyweb程序并发送缓冲区。shellcode运行后，需要通过按CTRL-C来退出netcat，因为原始的套接字连接仍然打开。然后，再次使用netcat连接到绑定在端口31337上的shell。
