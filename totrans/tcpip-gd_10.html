<html><head></head><body><div class="part" title="Part&#xA0;II-7.&#xA0;TCP/IP ROUTING PROTOCOLS (GATEWAY PROTOCOLS)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_routing_protocols_gateway_protocol"/>Part II-7. TCP/IP ROUTING PROTOCOLS (GATEWAY PROTOCOLS)</h1></div></div></div><div class="partintro" id="id3262439" title="TCP/IP ROUTING PROTOCOLS (GATEWAY PROTOCOLS)"><div/><p><a class="xref" href="ch37.html" title="Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS">Chapter 37</a></p><p><a class="xref" href="ch38.html" title="Chapter 38. ROUTING INFORMATION PROTOCOL (RIP, RIP-2, AND RIPNG)">Chapter 38</a></p><p><a class="xref" href="ch39.html" title="Chapter 39. OPEN SHORTEST PATH FIRST (OSPF)">Chapter 39</a></p><p><a class="xref" href="ch40.html" title="Chapter 40. BORDER GATEWAY PROTOCOL (BGP/BGP-4)">Chapter 40</a></p><p><a class="xref" href="ch41.html" title="Chapter 41. OTHER ROUTING PROTOCOLS">Chapter 41</a></p><p>Routing is not just one of the most important activities that take place at the network layer; it is also the function that really <span class="emphasis"><em>defines</em></span> layer 3 of the OSI Reference Model. Routing is what enables small local networks to be linked together to form potentially huge internetworks that can span cities, countries, or even the entire globe. The job of routing is done by special devices called <span class="emphasis"><em>routers</em></span>, which forward datagrams from network to network, allowing any device to send to any other device, even if the source has no idea where the destination is.</p><p>Strictly speaking, an argument could be made that some routing protocols don't belong in layer 3. For example, many of these protocols send messages using the Transmission Control Protocol (TCP) or User Datagram Protocol (UDP) at layer 4. Despite this, routing is inherently a layer 3 activity, and for this reason, it is traditional to consider routing protocols part of layer 3.</p><p>Routing is a complicated subject. The short summary of the process is that routers decide how to forward a datagram based on its destination address, which is compared to information the router keeps in special routing tables. These tables contain entries for each of the networks the router knows about, telling the router which adjacent router the datagram should be sent to in order for it to reach its eventual destination.</p><p>As you can imagine, routing tables are critically important to the routing process. It is possible for these tables to be manually maintained by network administrators, but this is tedious and time-consuming and doesn't allow routers to deal with changes or problems in the internetwork. Instead, most modern routers are designed with functionality that lets them share route information with other routers, so they can keep their routing tables up-to-date automatically. This information exchange is accomplished through the use of <span class="emphasis"><em>routing protocols</em></span>.</p><p>This part contains five chapters that provide a description of the most common routing (or <span class="emphasis"><em>gateway</em></span>) protocols used in TCP/IP. The first chapter provides an overview of various concepts that are important to know in order to understand how routing protocols work, including an explanation of the difference between interior and exterior routing protocols. This sets the stage for the chapters that follow.</p><p>In the second and third chapters, I thoroughly explain the two most commonly used interior routing protocols in TCP/IP: the Routing Information Protocol (RIP) and the Open Shortest Path First (OSPF) protocol. In the fourth chapter, I describe the Border Gateway Protocol (BGP), which is the exterior routing protocol used today on the Internet. The fifth chapter briefly discussing five historical, proprietary, or less commonly used routing protocols.</p><p>You may notice that the title of this part refers to both <span class="emphasis"><em>routing protocols</em></span> and <span class="emphasis"><em>gateway protocols</em></span>. These terms are interchangeable, and the word <span class="emphasis"><em>gateway</em></span> appears in the name of several of the protocols. This is an artifact of the historical use of the term <span class="emphasis"><em>gateway</em></span> in early TCP/IP standards to refer to the devices we now call routers. Today, the term <span class="emphasis"><em>gateway</em></span> normally refers not to a router, but to a different type of network interconnection device, so this can be particularly confusing. The term <span class="emphasis"><em>routing protocol</em></span> is now preferred, and it is the one I use.</p><p>Like all topics related to routing, routing protocols are generally quite complex. I cover the major ones here in more detail than most general networking references, but even so, I am only scratching the surface, especially of the more complicated ones like OSPF. You can check out the referenced Internet standards (RFCs) for more details if you desire. Also note that there are some routing protocols in use on IP networks that I do not cover here, such as IS-IS (which is actually an OSI protocol and not formally part of TCP/IP).</p></div></div>
<div class="chapter" title="Chapter&#xA0;37.&#xA0;OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS"><div class="titlepage"><div><div><h1 class="title"><a id="overview_of_key_routing_protocol_concept"/>Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e39982"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> <a class="indexterm" id="idx-CHP-37-1375"/>Routing protocols play an important part in the overall process of routing in an internetwork. It is therefore easiest to understand them in the scope of an overall discussion of routing. It's difficult to describe the individual TCP/IP routing protocols without some background information on how routing protocols work. For this reason, I feel it is worth taking a brief look at key routing protocol concepts so that you will have more luck making sense of the routing protocols described in the next few chapters.</p><p>In this chapter, I will provide an overview of the routing protocol <a class="indexterm" id="idx-CHP-37-1376"/>architectures, protocol types, algorithms, and metrics.</p><div class="sect1" title="Routing Protocol Architectures"><div class="titlepage"><div><div><h1 class="title"><a id="routing_protocol_architectures"/>Routing Protocol Architectures</h1></div></div></div><p>Let's start with a look at routing protocol architectures. In this context, the word <span class="emphasis"><em>architecture</em></span> refers to the way that an internetwork is structured. Once you have some networks and routers that you wish to connect together, there are any number of ways that you can do this. The architecture you choose is based on the way that routers are <a class="indexterm" id="idx-CHP-37-1377"/>linked, and this has an impact on the way that routing is done and how routing protocols operate.</p><div class="sect2" title="Core Architecture"><div class="titlepage"><div><div><h2 class="title"><a id="core_architecture"/>Core Architecture</h2></div></div></div><p>TCP/IP and the Internet were developed simultaneously, so TCP/IP routing protocols evolved as the Internet itself did. Early architecture of the Internet consisted of a small number of <span class="emphasis"><em>core</em></span> routers that contained comprehensive information about the internetwork. When the Internet was very small, adding more routers to this core expanded it. However, each time the core was expanded, the amount of routing information that needed to be maintained grew.<a class="indexterm" id="idx-CHP-37-1378"/></p><p>Eventually, the core became too large, so a two-level hierarchy was formed to allow further expansion. <span class="emphasis"><em>Noncore</em></span> routers were located on the periphery of the core and contained only partial routing information; they relied on the <a class="indexterm" id="idx-CHP-37-1379"/>core routers for transmissions that went across the internetwork. A special routing protocol called the <span class="emphasis"><em>Gateway-to-Gateway Protocol (GGP)</em></span> was used within the core of the internetwork, while another protocol called the <span class="emphasis"><em>Exterior Gateway Protocol (EGP)</em></span> was used between noncore and core routers. The <a class="indexterm" id="idx-CHP-37-1380"/>noncore routers were sometimes single, stand-alone routers that connected a single network to the core, or they could be sets of routers for an organization.<a class="indexterm" id="idx-CHP-37-1381"/><a class="indexterm" id="idx-CHP-37-1382"/></p><p>This architecture served for a while, but it did not scale very well as the Internet grew. The problem was mainly due to the fact that there was only a single level to the architecture: Every router in the core had to communicate with every other router. Even with peripheral routers being kept outside the core, the amount of traffic in the core kept growing.</p></div><div class="sect2" title="Autonomous System (AS) Architecture"><div class="titlepage"><div><div><h2 class="title"><a id="autonomous_system_as_architecture"/>Autonomous System (AS) Architecture</h2></div></div></div><p>To resolve the scaling problem, a new architecture was created that moved away from the centralized concept of a core toward an architecture that was better suited to a larger and growing internetwork. This decentralized architecture treats the internetwork as a set of independent groups, with each group called an <span class="emphasis"><em>autonomous system (AS)</em></span>. An AS consists of a set of routers and networks controlled by a particular organization or administrative entity, which uses a single consistent policy for internal routing.<a class="indexterm" id="idx-CHP-37-1383"/></p><p>The power of this system is that routing on the internetwork as a whole occurs between ASes and not individual routers. Information is shared between one and maybe a couple of routers in each AS, not every router in each AS. The details of routing within an AS are also hidden from the rest of the internetwork. This provides both flexibility for each AS to do routing as it sees fit (thus the name <span class="emphasis"><em>autonomous</em></span>) and efficiency for the overall internetwork. Each AS has its own number, and the numbers are globally managed to make sure that they are unique across an internetwork (such as the Internet).</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-206"/>Tip</h3><p><a class="indexterm" id="idx-CHP-37-1384"/><span class="strong"><strong>KEY CONCEPT</strong></span> Large, modern TCP/IP internetworks can contain thousands of <a class="indexterm" id="idx-CHP-37-1385"/>routers. To better manage routing in such an environment, routers are grouped into constructs called <span class="emphasis"><em>autonomous systems (ASes)</em></span>, each of which consists of a group of routers managed independently by a particular organization or entity.</p></div></div><div class="sect2" title="Modern Protocol Types: Interior and Exterior Routing Protocols"><div class="titlepage"><div><div><h2 class="title"><a id="modern_protocol_types_interior_and_exter"/>Modern Protocol Types: Interior and Exterior Routing Protocols</h2></div></div></div><p>The different nature of routing within an AS and between ASes can be seen in the fact that the following distinct sets of TCP/IP <a class="indexterm" id="idx-CHP-37-1386"/>routing protocols are used for each type:<a class="indexterm" id="idx-CHP-37-1387"/></p><p><span class="strong"><strong>Interior Routing Protocols</strong></span> These protocols are used to exchange routing information between routers within an AS. Interior routing protocols are not used between ASes.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-37-1388"/>Exterior Routing Protocols</strong></span> These protocols are used to exchange routing information between ASes. They may in some cases be used between routers within an AS, but they primarily deal with exchanging information between ASes.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-207"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Interior routing protocols are used to share routing information within an autonomous system; each AS may use a different interior routing protocol because the system is, as the name says, autonomous. Exterior routing protocols convey routing data between ASes; each AS must use the same exterior protocol to ensure that it can communicate.</p></div><p>Since ASes are just sets of routers, you connect ASes by linking a router in one AS to a router in another AS. Architecturally, an AS consists of a set of routers with two different types of connectivity:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-37-1389"/>Internal Routers</strong></span> Some routers in an AS connect only to other routers in the same AS. These run interior routing protocols.</p><p><span class="strong"><strong>Border Routers</strong></span> Some routers in an AS connect both to routers within the AS and to routers in one or more other ASes. These devices are responsible for passing traffic between the AS and the rest of the internetwork. They run both interior and exterior routing protocols.</p><p>Due to its advantages, the AS architecture, an example of which can be seen in <a class="xref" href="ch37.html#tcpip_autonomous_system_as_routing_archi" title="Figure 37-1. TCP/IP autonomous system (AS) routing architecture This diagram shows a simplified Internet organized into three ASes, each of which is managed independently from the others. Communication within each AS is done using an interior routing protocol chosen by that AS's administrators (thin links). Communication between ASes must be done using a common exterior routing protocol (thick links). Internal routers are shown in lighter text, and border routers are shown in black text.">Figure 37-1</a>, has become the standard for TCP/IP networks, most notably the Internet. The division of routing protocols into the interior and exterior classifications has thus also become standard, and all modern TCP/IP routing protocols are first subdivided by type in this manner.</p><div class="figure"><a id="tcpip_autonomous_system_as_routing_archi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e40150"/><img alt="TCP/IP autonomous system (AS) routing architecture This diagram shows a simplified Internet organized into three ASes, each of which is managed independently from the others. Communication within each AS is done using an interior routing protocol chosen by that AS's administrators (thin links). Communication between ASes must be done using a common exterior routing protocol (thick links). Internal routers are shown in lighter text, and border routers are shown in black text." src="httpatomoreillycomsourcenostarchimages288027.png.jpg"/></div></div><p class="title">Figure 37-1. TCP/IP autonomous system (AS) routing architecture This diagram shows a simplified Internet organized into three ASes, each of which is managed independently from the others. Communication within each AS is done using an interior routing protocol chosen by that AS's administrators (thin links). Communication between ASes must be done using a common exterior routing protocol (thick links). Internal routers are shown in lighter text, and border routers are shown in black text.</p></div></div></div></div>
<div class="sect1" title="Routing Protocol Algorithms and Metrics"><div class="titlepage"><div><div><h1 class="title"><a id="routing_protocol_algorithms_and_metrics"/>Routing Protocol Algorithms and Metrics</h1></div></div></div><p>Another key differentiation of <a class="indexterm" id="idx-CHP-37-1390"/>routing protocols is on the basis of the <span class="emphasis"><em>algorithms</em></span> and <span class="emphasis"><em>metrics</em></span> they use. An algorithm refers to a method that the protocol uses for determining the best route between any pair of networks, and for sharing routing information between routers. A metric is a measure of "cost" that is used to assess the efficiency of a particular route. Since internetworks can be quite complex, the <a class="indexterm" id="idx-CHP-37-1391"/>algorithms and metrics of a protocol are very important, and they can be the determining factor in deciding that one protocol is superior to another.</p><p>There are two routing <a class="indexterm" id="idx-CHP-37-1392"/>protocol algorithms that are most commonly encountered: distance vector and link state. There are also protocols that use a combination of these methods or other methods.</p><div class="sect2" title="Distance-Vector (Bellman-Ford) Routing Protocol Algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="distance-vector_bellman-ford_routing_pro"/>Distance-Vector (Bellman-Ford) Routing Protocol Algorithm</h2></div></div></div><p>A <span class="emphasis"><em>distance-vector</em></span> routing algorithm, also called a <span class="emphasis"><em>Bellman-Ford</em></span> algorithm after two of its inventors, is one where routes are selected based on the distance between networks. The distance metric is something simple—usually the number of <span class="emphasis"><em>hops</em></span>, or routers, between them.<a class="indexterm" id="idx-CHP-37-1393"/><a class="indexterm" id="idx-CHP-37-1394"/></p><p>Routers using this type of protocol maintain information about the distance to all known networks in a table. They regularly send that table to each router they immediately connect with (their <span class="emphasis"><em>neighbors</em></span> or <span class="emphasis"><em>peers</em></span>). These routers then update their tables and send those tables to their neighbors. This causes distance information to propagate across the internetwork, so that eventually, each router obtains distance information about all networks on the internetwork.</p><p>Distance-vector routing protocols are somewhat limited in their ability to choose the best route. They also are subject to certain problems in their operation that must be worked around through the addition of special heuristics and features. Their chief advantages are simplicity and history (they have been used for a long time).</p></div><div class="sect2" title="Link-State (Shortest-Path First) Routing Protocol Algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="link-state_shortest-path_first_routing_p"/>Link-State (Shortest-Path First) Routing Protocol Algorithm</h2></div></div></div><p>A <span class="emphasis"><em>link-state</em></span> algorithm selects routes based on a dynamic assessment of the shortest path between any two networks. For that reason, it's also called a <span class="emphasis"><em>shortest-path first</em></span> method.</p><p>Using this method, each router maintains a map describing the current topology of the internetwork. This map is updated regularly by testing reachability of different parts of the Internet, and by exchanging link-state information with other routers. The determination of the best route (or shortest path) can be made based on a variety of metrics that indicate the true cost of sending a datagram over a particular route.</p><p>Link-state algorithms are much more powerful than distance-vector algorithms. They adapt dynamically to changing internetwork conditions, and they also allow routes to be selected based on more realistic metrics of cost than simply the number of hops between networks. However, they are more complicated to set up and use more computer processing resources than distance-vector algorithms, and they aren't as well established.</p></div><div class="sect2" title="Hybrid Routing Protocol Algorithms"><div class="titlepage"><div><div><h2 class="title"><a id="hybrid_routing_protocol_algorithms"/>Hybrid Routing Protocol Algorithms</h2></div></div></div><p>There are also hybrid protocols that combine features from both types of algorithms, and other protocols that use completely different algorithms. For example, the <span class="emphasis"><em>Border Gateway Protocol (BGP)</em></span> is a path-vector algorithm, which is somewhat similar to the distance-vector algorithm, but communicates much more detailed route information. It includes some of the attributes of distance-vector and link-state protocols, but is more than just a combination of the two.</p></div></div>
<div class="sect1" title="Static and Dynamic Routing Protocols"><div class="titlepage"><div><div><h1 class="title"><a id="static_and_dynamic_routing_protocols"/>Static and Dynamic Routing Protocols</h1></div></div></div><p>Finally, you may also occasionally see routing protocols categorized by type as <span class="emphasis"><em>static</em></span> and <span class="emphasis"><em>dynamic</em></span>. This terminology is somewhat misleading.</p><p>The term <span class="emphasis"><em>static routing</em></span> simply refers to a situation where the routing tables are manually set up so that they remain static. In contrast, <span class="emphasis"><em>dynamic routing</em></span> is the use of routing protocols to dynamically update routing tables. Thus, all routing protocols are dynamic. There is no such thing as a static routing protocol (unless you consider a network administrator who is editing a routing table a protocol).</p></div>
<div class="chapter" title="Chapter&#xA0;38.&#xA0;ROUTING INFORMATION PROTOCOL (RIP, RIP-2, AND RIPNG)"><div class="titlepage"><div><div><h1 class="title"><a id="routing_information_protocol_rip_rip_2_a"/>Chapter 38. ROUTING INFORMATION PROTOCOL (RIP, RIP-2, AND RIPNG)</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e40261"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The most popular of the TCP/IP interior routing protocols is the <span class="emphasis"><em>Routing Information Protocol (RIP)</em></span>. The simplicity of the name matches the simplicity of the protocol. Of all the routing protocols, RIP is one of the easiest to configure and least demanding of resources. Its popularity is due both to this simplicity and its long history. In fact, support for RIP has been built into operating systems for as long as TCP/IP itself has existed.</p><p>There are three versions of RIP: RIP versions 1 and 2 for IP version 4 (IPv4) and RIPng for IP version 6 (IPv6). The basic operation of the protocol is mostly the same for all three versions, but there are also some notable differences between them, especially in terms of the format of messages sent.</p><p>RIP was one of the first interior routing protocols used in TCP/IP. More than 20 years later, it continues to be widely used. Even though RIP has important limitations, it continues to have an important place in TCP/IP routing to this day. Evidence that RIP has a future can be seen in the creation of an IPv6 version of the protocol: RIPng.</p><p>I will open the examination of <a class="indexterm" id="idx-CHP-38-1395"/>RIP with an overall description of its characteristics and how it works in general terms. I start with an overview and history of the protocol, including a brief discussion of its different versions and the standards that define them. I describe the method that RIP uses to determine routes and the metric used to assess route cost. I describe the general operation of the protocol including message types and when they are sent. I then describe the most important limitations and issues with RIP, and the special features that have been added to the protocol to resolve several problems with the basic RIP algorithm. Finally, I take a closer look at each version, showing the message format used for each and discussing version-specific features as well.</p><div class="sect1" title="RIP Overview"><div class="titlepage"><div><div><h1 class="title"><a id="rip_overview"/>RIP Overview</h1></div></div></div><p>RIP has been the most popular interior routing protocol in the TCP/IP protocol suite for many years. The history of the protocol and how it came to achieve prominence is a rather interesting one. Unlike many of the other important protocols in the TCP/IP suite, RIP was not first developed formally using the RFC <a class="indexterm" id="idx-CHP-38-1396"/>standardization process (see <a class="xref" href="ch03.html" title="Chapter 3. NETWORK STANDARDS AND STANDARDS ORGANIZATIONS">Chapter 3</a>). Rather, it evolved as a de facto industry standard and became an Internet standard later.</p><p>The history of RIP has something in common with another networking heavyweight: Ethernet. Like that formidable local area network (LAN) technology, RIP's roots go back to that computing pioneer, Xerox's <a class="indexterm" id="idx-CHP-38-1397"/>Palo Alto Research Center (PARC). At the same time that Ethernet was being developed for tying together LANs, <a class="indexterm" id="idx-CHP-38-1398"/>PARC created a higher-layer protocol to run on Ethernet called the Xerox <a class="indexterm" id="idx-CHP-38-1399"/>PARC Universal Protocol (PUP). <a class="indexterm" id="idx-CHP-38-1400"/>PUP required a routing protocol, so Xerox created a protocol called the <a class="indexterm" id="idx-CHP-38-1401"/>Gateway Information Protocol (GWINFO). This was later renamed the Routing Information Protocol and used as part of the <a class="indexterm" id="idx-CHP-38-1402"/>Xerox Network System (XNS) protocol suite.</p><p>RIP entered the mainstream when developers at the University of California at Berkeley adapted it for use in the Berkeley Standard Distribution (BSD) of the UNIX operating system. RIP first appeared in BSD version 4.2 in 1982, where it was implemented as the UNIX program <a class="indexterm" id="idx-CHP-38-1403"/><span class="emphasis"><em>routed</em></span> (pronounced "route-dee," not "rout-ed"—the "d" stands for "daemon," a common UNIX term for a server process).</p><p>BSD was (and still is) a very popular operating system, especially for machines connected to the early Internet. As a result, RIP was widely deployed and became the industry standard for internal routing protocols. It was used both for TCP/IP and other protocol suites. In fact, a number of other routing protocols, such as the RTP protocol in the AppleTalk suite, were based on this early version of RIP.</p><div class="sect2" title="RIP Standardization"><div class="titlepage"><div><div><h2 class="title"><a id="rip_standardization"/>RIP Standardization</h2></div></div></div><p>For a while, the BSD implementation of routed was actually considered the standard for the protocol itself. However, this was not a formally defined standard, and this meant that there was no formal definition of exactly how it functioned. This led to slight differences in various implementations of the protocol over time. To resolve potential interoperability issues between implementations, the Internet Engineering Task Force (IETF) formally specified RIP in the Internet standard RFC 1058, "Routing Information Protocol," which was published in June 1988. This RFC was based directly on the BSD routed program. This original version of RIP is now also sometimes called RIP version 1 or RIP-1 to differentiate it from later versions.</p><p>RIP's popularity was due in large part to its inclusion in BSD, and it was included in BSD because of the relative simplicity of the protocol.</p></div><div class="sect2" title="RIP Operational Overview, Advantages, and Limitations"><div class="titlepage"><div><div><h2 class="title"><a id="rip_operational_overview_advantages_and_"/>RIP Operational Overview, Advantages, and Limitations</h2></div></div></div><p>RIP uses the distance-vector algorithm to determine routes, as described in <a class="xref" href="ch37.html" title="Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS">Chapter 37</a>. Each router maintains a routing table containing entries for various networks or hosts in the internetwork. Each entry contains two primary pieces of information: the address of the network or host and the distance to it, measured in hops, which is simply the number of routers that a datagram must pass through to get to its destination.</p><p>On a regular basis, each router in the internetwork sends out its routing table in a special message on each of the networks to which it is connected, using the User Datagram Protocol (UDP). Other routers receive these tables and use them to update their own tables. This is done by taking each of the routes they receive and adding an extra hop. For example, if Router A receives an indication from Router B that Network N1 is four hops away, since Router A and Router B are adjacent, the distance from Router A to Network N1 is five. After a router updates its tables, it sends out this information to other routers on its local networks. Over time, routing distance information for all networks propagates over the entire internetwork.</p><p>RIP is straightforward in operation, easy to implement, and undemanding of router processing power, which makes it especially attractive in smaller autonomous systems (ASes). There are, however, some important limitations that arise due to the simplicity of the protocol. For starters, hops are often not the best metric to use in selecting routes. There are also a number of problems that arise with the algorithm itself. These include slow convergence (delays in having all routers agree on the same routing information) and problems dealing with network link failures. RIP includes several special features to resolve some of these issues, but others are inherent limitations of the protocol. For example, RIP supports a maximum of only 15 hops between destinations, making it unsuitable for very large ASes, and this cannot be changed.</p><p>More than two decades after it was first created, RIP continues to be a popular interior routing protocol. Its limitations have led to many internetworking experts hoping that the protocol would eventually be replaced by newer protocols such as Open Shortest Path First (OSPF) that are superior on a strictly technical basis. Some have gone so far as to sarcastically suggest that maybe it would be best if RIP would R. I. P. Once a protocol becomes popular, however, it's hard to resist momentum, and RIP is likely to continue to be used for many years to come.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-208"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <span class="emphasis"><em>Routing Information Protocol (RIP)</em></span> is one of the oldest and most popular interior routing protocols. With each router, it uses a distance-vector algorithm that maintains a table, which indicates how to reach various networks in the AS and the distance to it in hops. RIP is popular because it is well established and simple, but it has a number of important limitations.</p></div></div><div class="sect2" title="Development of RIP Version 2 (RIP-2) and RIPng for IPv6"><div class="titlepage"><div><div><h2 class="title"><a id="development_of_rip_version_2_rip-2_and_r"/>Development of RIP Version 2 (RIP-2) and RIPng for IPv6</h2></div></div></div><p>Some other issues with <a class="indexterm" id="idx-CHP-38-1404"/>RIP came about as a result <a class="indexterm" id="idx-CHP-38-1405"/>of the protocol having been developed in the early 1980s, when TCP/IP was still in its infancy. Over time, as the use of TCP/IP protocols changed, RIP became outdated. In response, <span class="emphasis"><em>RIP version 2</em></span>, or <span class="emphasis"><em>RIP-2</em></span> was created in the early 1990s.</p><p>RIP-2 defines a new message format for RIP and includes a number of new features, including support for classless addressing, authentication, and the use of multicasting instead of broadcasting, which improves network performance. It was first defined in RFC 1388, "RIP Version 2 Carrying Additional Information," published in January 1993. This RFC was revised in RFC 1723 and finalized in RFC 2453, "RIP Version 2," published in November 1998.</p><p>In order to ensure that RIP can work with TCP/IP in the future, it was necessary to define a version that would work with the IPv6. In 1997, RFC 2080 was published, titled "RIPng for IPv6." The <span class="emphasis"><em>ng</em></span> stands for <span class="emphasis"><em>next generation</em></span>; you'll recall that IPv6 is also sometimes called <span class="emphasis"><em>IPng</em></span>.</p><p><span class="emphasis"><em>RIPng</em></span> is not just a new version of RIP, like RIP-2, but is defined as a new stand-alone protocol. It is, however, based closely on the original RIP and RIP-2 standards. A distinct protocol (as opposed to a revision of the original) was needed due to the changes made between IPv4 and IPv6, though RIP and RIPng work in the same basic way. RIPng is sometimes also called <span class="emphasis"><em>RIPv6</em></span>.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-209"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The original version of RIP has the fewest features and is now called <span class="emphasis"><em>RIP-1</em></span>. <span class="emphasis"><em>RIP-2</em></span> was created to add support for classless addressing and other capabilities. <span class="emphasis"><em>RIPng</em></span> is the version created for compatibility with IPv6.</p></div></div></div></div>
<div class="sect1" title="RIP Route Determination Algorithm and Metric"><div class="titlepage"><div><div><h1 class="title"><a id="rip_route_determination_algorithm_and_me"/>RIP Route Determination Algorithm and Metric</h1></div></div></div><p>As I mentioned in the previous chapter, one of the defining characteristics of any routing protocol is the algorithm it uses for determining routes. RIP falls into the class of protocols that use a distance-vector, or Bellman-Ford, routing algorithm. To help you understand exactly how RIP determines routes, this section presents the specific implementation of the algorithm for RIP and provides an example.</p><p>Note that the description presented here is the basic algorithm used by RIP. This is modified in certain ways to address some of the problems that can occur in special circumstances due to how the algorithm works. Later in this chapter, we will explore these problems and the special features RIP includes to address them.</p><div class="sect2" title="RIP Routing Information and Route Distance Metric"><div class="titlepage"><div><div><h2 class="title"><a id="rip_routing_information_and_route_distan"/>RIP Routing Information and Route Distance Metric</h2></div></div></div><p><a class="indexterm" id="idx-CHP-38-1406"/>The job of RIP, like any routing protocol, is to provide a mechanism for exchanging information about routes so routers can keep their routing tables up-to-date. Each router in an RIP internetwork keeps track in its routing table of all networks (and possibly individual hosts) in the internetwork. For each network or host, the device includes a variety of information, of which the following is the most important:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The address of the network or host</p></li><li class="listitem"><p>The distance from that router to the network or host</p></li><li class="listitem"><p>The first hop for the route: the device to which datagrams must first be sent to eventually get to the network or host</p></li></ul></div><p>In theory, the distance metric can be any assessment of cost, but <a class="indexterm" id="idx-CHP-38-1407"/>in RIP, distance is measured in hops. As you probably already know, in TCP/IP vernacular, a datagram makes a <span class="emphasis"><em>hop</em></span> when it passes through a router. Thus, the <a class="indexterm" id="idx-CHP-38-1408"/>RIP distance between a router and a network measures the number of routers that the datagram must pass through to get to the network. If a router connects to a network directly, then the distance is 1 hop. If it goes through a single router, the distance is 2 hops, and so on. In RIP, a maximum of 15 hops are allowed for any network or host. The value 16 is defined as infinity, so an entry with 16 in it means "this network or host is not reachable."</p></div><div class="sect2" title="RIP Route Determination Algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="rip_route_determination_algorithm"/>RIP Route Determination Algorithm</h2></div></div></div><p>On a regular basis, each router running RIP will send out its routing table entries to provide information to other routers about the networks and hosts it knows how to reach. Any routers on the same network as the one sending out this information will be able to update their own tables based on the information they receive.</p><p>Any router that receives a message from another router on the same network saying it can reach Network X at a cost of <span class="emphasis"><em>N</em></span> knows it can reach Network X at a cost of <span class="emphasis"><em>N</em></span>+1 by sending to the router it received the message from.</p></div><div class="sect2" title="RIP Route Determination and Information Propagation"><div class="titlepage"><div><div><h2 class="title"><a id="rip_route_determination_and_information_"/>RIP Route Determination and Information Propagation</h2></div></div></div><p><a class="indexterm" id="idx-CHP-38-1409"/>Let's take a specific example to help you understand how routes are determined and how route information is propagated using RIP. Consider a relatively simple internetwork with four individual networks, connected as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Router RA connects Network N1 to Network N2.</p></li><li class="listitem"><p>Router RB and Router RC connect Network N2 to Network N3.</p></li><li class="listitem"><p>Router RD connects Network N3 to Network N4.</p></li></ul></div><p>This sample AS is illustrated in <a class="xref" href="ch38s02.html#sample_rip_as_this_is_an_example_of_a_si" title="Figure 38-1. Sample RIP AS This is an example of a simple AS that contains four physical networks and four routers.">Figure 38-1</a>.</p><div class="figure"><a id="sample_rip_as_this_is_an_example_of_a_si"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e40499"/><img alt="Sample RIP AS This is an example of a simple AS that contains four physical networks and four routers." src="httpatomoreillycomsourcenostarchimages288029.png.jpg"/></div></div><p class="title">Figure 38-1. Sample RIP AS This is an example of a simple AS that contains four physical networks and four routers.</p></div><p>Now let's suppose that we just turned on Router RA. It sees that it is directly connected to Network N1 and Network N2, so it will have an entry in its routing table indicating that it can reach Network N1 at a cost of 1, which we can represent as {N1,1}. Information about Network N1 will propagate from Router RA across the internetwork in the following sequence of steps (which are illustrated in <a class="xref" href="ch38s02.html#propagation_of_network_routing_informati" title="Figure 38-2. Propagation of network routing information using RIP This composite diagram illustrates the five steps in propagating route information about Network N1 from Router RA to the rest of the AS. In step 1, the information is sent from Router RA to both of its connected networks. In step 2, it reaches Routers RB and RC, which then know they can reach Network N1 through Router RA at a cost of one additional hop. In step 3, these two routers send this information on their networks, and in step 4, it reaches Router RD. In step 5, Router RD sends out the information, but no other routers are around to receive it.">Figure 38-2</a>):</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Router RA sends out an RIP message containing the entry {N1,1} on each of the networks to which it is connected. There are no other routers on Network N1, so nothing happens there. But Routers RB and RC are on Network N2, so they receive the information.</p></li><li class="listitem"><p>Routers RB and RC will look in their routing tables to see if they already have entries for Network N1. Assuming neither does, they will each create a routing table entry {N1,2} for Router RA. This means, "I can reach Network N1 at a cost of 2 hops by sending to Router RA."</p></li><li class="listitem"><p>Routers RB and RC will each send their own routing tables out over the networks to which they are connected: Networks N2 and N3. This will contain the entry {N1,2}. Router RA will receive that message on Network N2 but will ignore it, since it knows it can reach Network N1 directly (cost of 1, which is less than 2). But Router RD will receive the message on Network N3.</p></li><li class="listitem"><p>Router RD will examine its routing table, and seeing no entry for Network N1, it will add the entry {N1,3} for Routers RB or RC. Either one will work, so whichever is chosen depends entirely on whether Router RD received information about Network N1 first from Router RB or Router RC.</p></li><li class="listitem"><p>Router RD will send the entry {N1,3} on Network N4, but there are no other routers there to hear it.</p></li></ol></div><p>Note that RIP is designed so that a routing entry is replaced only if information is received about a <span class="emphasis"><em>shorter</em></span> route; ties go to the incumbent, if you will. This means that once Router RD creates an entry for Network N1 with a cost of 3 going through Router RB, if it receives information that it can reach Network N1 at the same cost of 3 through Router RC, it will ignore it. Similarly, if it gets Router RC's information first, it will ignore the information from Router RB.</p><p>Naturally, this same propagation scheme will occur for all the other networks as well. I have shown only how information about Network N1 moves from router to router. For example, Router RA will eventually install an entry for Network N4 saying that it is reachable at a cost of 3 going through either Router RB or RC; this will be either {N4,RB,3} or {N4,RC,3}.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-210"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Routing information is propagated between routers in RIP using a simple algorithm. On a regular basis, each router sends out RIP messages that specify which networks it can reach and how many hops it takes to reach them. Other routers directly connected to that one know that they can then reach those networks through that router at a cost of one additional hop. So if Router A sends a message saying it can reach Network X for a cost of <span class="emphasis"><em>N</em></span> hops, every other router that connects directly to Router A can reach Network X for a cost of <span class="emphasis"><em>N</em></span>+1 hops. It will put that information into its routing table, unless it knows of an alternate route through another router that has a lower cost.</p></div><div class="figure"><a id="propagation_of_network_routing_informati"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e40545"/><img alt="Propagation of network routing information using RIP This composite diagram illustrates the five steps in propagating route information about Network N1 from Router RA to the rest of the AS. In step 1, the information is sent from Router RA to both of its connected networks. In step 2, it reaches Routers RB and RC, which then know they can reach Network N1 through Router RA at a cost of one additional hop. In step 3, these two routers send this information on their networks, and in step 4, it reaches Router RD. In step 5, Router RD sends out the information, but no other routers are around to receive it." src="httpatomoreillycomsourcenostarchimages288031.png.jpg"/></div></div><p class="title">Figure 38-2. Propagation of network routing information using RIP This composite diagram illustrates the five steps in propagating route information about Network N1 from Router RA to the rest of the AS. In step 1, the information is sent from Router RA to both of its connected networks. In step 2, it reaches Routers RB and RC, which then know they can reach Network N1 through Router RA at a cost of one additional hop. In step 3, these two routers send this information on their networks, and in step 4, it reaches Router RD. In step 5, Router RD sends out the information, but no other routers are around to receive it.</p></div><p>This <a class="indexterm" id="idx-CHP-38-1410"/>propagation of network routing information occurs on a regular basis, and also when the structure of the network changes (due to intentional changes in topography or failure of links or <a class="indexterm" id="idx-CHP-38-1411"/>routers). When this happens, the change information will move through the internetwork so that all routers are eventually updated. For example, suppose a connection were added from Router RC to Network N1. If Router RD previously had the entry {N1,RB,3}, it would eventually change this to {N1,RC,2}, since it could now reach Network N1 more quickly by going through Router RC.</p></div><div class="sect2" title="Default Routes"><div class="titlepage"><div><div><h2 class="title"><a id="default_routes"/>Default Routes</h2></div></div></div><p>In some cases, it is not convenient for every network or host in a large internetwork to be fully specified with its own routing entry. Then it may be advantageous to specify a <a class="indexterm" id="idx-CHP-38-1412"/>default route for the network to use in reaching hosts or networks for which they have no information. The most common example of this is when an AS connects to the public Internet through a single router. Except for that router, the rest of the local network doesn't need to know how to access the Internet.</p><p>In <a class="indexterm" id="idx-CHP-38-1413"/>RIP, information about a default route is communicated by having routers that are intended to handle such traffic send information about a "dummy" network with the address 0.0.0.0. This is treated as if it were a regular network when information about routes is propagated on the internetwork using <a class="indexterm" id="idx-CHP-38-1414"/>RIP messages, but other devices recognize this special address and understand that it means a default route.</p></div></div>
<div class="sect1" title="RIP General Operation, Messaging, and Timers"><div class="titlepage"><div><div><h1 class="title"><a id="rip_general_operation_messaging_and_time"/>RIP General Operation, Messaging, and Timers</h1></div></div></div><p><a class="indexterm" id="idx-CHP-38-1415"/>RIP is a protocol for exchanging routing information, so its operation can best be described in terms of the messages used to exchange this information and the rules for when messages are sent. The RIP software in each router sends messages and takes other actions both in reaction to certain events and in response to triggers set off by timers. Timers are also used to determine when routing information should be discarded if it is not updated.</p><div class="sect2" title="RIP Messages and Basic Message Types"><div class="titlepage"><div><div><h2 class="title"><a id="rip_messages_and_basic_message_types"/>RIP Messages and Basic Message Types</h2></div></div></div><p><a class="indexterm" id="idx-CHP-38-1416"/>Communication between RIP software elements in routers on an internetwork is accomplished through the use of <span class="emphasis"><em>RIP messages</em></span>. These messages are sent using the UDP, with the UDP port number 520 reserved for RIP-1 and RIP-2, and 521 for RIPng. Thus, even though RIP is considered part of layer 3 like other routing protocols, it behaves more like an application in terms of how it sends messages. The exact format of the message is version-dependent, and all three formats (RIP, RIP-2, and RIPng) are described in detail later in this chapter. RIP messages can be either sent to a specific device or sent out for multiple devices to receive. If directed to one device, they are sent unicast; otherwise, they are either broadcast (in RIP) or multicast (RIP-2 and RIPng).</p><p>There are only two basic message types for all three versions of RIP:</p><p><span class="strong"><strong>RIP Request</strong></span> A message sent by a router to another router asking it to send back all or part of its routing table.</p><p><span class="strong"><strong>RIP Response</strong></span> A message sent by a router containing all or part of its routing table. Note that despite the name, this message is <span class="emphasis"><em>not</em></span> sent just in response to an RIP Request message, as you will see.</p><div class="note" title="Note"><h3 class="title"><a id="note-107"/>Note</h3><p><span class="emphasis"><em>The original RIP also defined a few other message types: Traceon, Traceoff, and a special message type reserved for use by Sun Microsystems. These are obsolete and no longer used. They were removed from the RIP-2 and RIPng standards</em></span>.</p></div></div><div class="sect2" title="RIP Update Messaging and the 30-Second Timer"><div class="titlepage"><div><div><h2 class="title"><a id="rip_update_messaging_and_the_30-second_t"/>RIP Update Messaging and the 30-Second Timer</h2></div></div></div><p>RIP Request messages are sent under special circumstances when a router requires that it be provided with immediate routing information. The most common example of this is when a router is first powered on. After initializing, the router will typically send an RIP Request message on its attached networks to ask for the latest information about routes from any neighboring routers. It is also possible for RIP Request messages to be used for diagnostic purposes.</p><p>A router receiving an RIP Request message will process it and send an RIP Response message containing either all of its routing table or just the entries the Request message asked for, as appropriate. Under normal circumstances, however, routers do not usually send RIP Request messages asking specifically for routing information. Instead, each RIP router has a special timer that goes off every 30 seconds. (This timer is not given a specific name in the RIP standards; it is just the <a class="indexterm" id="idx-CHP-38-1417"/>30-second timer.)</p><p>Each time the timer expires, an unsolicited (unrequested) broadcast or multicast is made of an RIP Response message containing the router's entire routing table. The timer is then reset, and 30 seconds later, it goes off again, causing another routine RIP Response message to be sent. This process ensures that route information is regularly sent around the Internet, so routers are always kept up-to-date about routes.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-211"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> RIP uses two basic message types: the RIP Request and RIP Response. Both are sent using the User Datagram Protocol (UDP). RIP Response messages, despite their name, are used both for routine periodic routing table <a class="indexterm" id="idx-CHP-38-1418"/>updates as well as to reply to RIP Request messages. Requests are sent only in special circumstances, such as when a router first joins a network.</p></div></div><div class="sect2" title="Preventing Stale Information: The Timeout Timer"><div class="titlepage"><div><div><h2 class="title"><a id="preventing_stale_information_the_timeout"/>Preventing Stale Information: The Timeout Timer</h2></div></div></div><p><a class="indexterm" id="idx-CHP-38-1419"/>When a router receives routing information and enters it into its routing table, that information cannot be considerd valid indefinitely. In the example presented earlier in the "RIP Route Determination and Information Propagation" section, suppose that after Router RB installs a route to Network N1 through Router RA, the link between Router RA and Network N2 fails. Once this happens, Network N1 is no longer reachable from Router RB, but Router RB has a route indicating that it can reach Network N1.</p><p>To prevent this problem, routes are kept in the routing table for only a limited amount of time. A special Timeout timer is started whenever a route is installed in the routing table. Whenever the router receives another RIP Response message with information about that route, the route is considered refreshed, and its Timeout timer is reset. As long as the route continues to be refreshed, the timer will never expire.</p><p>If, however, RIP Response messages containing that route stop arriving, the timer will eventually expire. When this happens, the route is marked for deletion by setting the distance for the route to 16 (which you may recall is RIP infinity and indicates an unreachable network). The default value for the Timeout timer is usually 180 seconds. This allows several periodic updates of a route to be missed before a router will conclude that the route is no longer reachable.</p></div><div class="sect2" title="Removing Stale Information: The Garbage-Collection Timer"><div class="titlepage"><div><div><h2 class="title"><a id="removing_stale_information_the_garbage-c"/>Removing Stale Information: The Garbage-Collection Timer</h2></div></div></div><p><a class="indexterm" id="idx-CHP-38-1420"/>When a route is marked for deletion, a new <a class="indexterm" id="idx-CHP-38-1421"/>Garbage-Collection timer is also started. <span class="emphasis"><em>Garbage collection</em></span> is a computer-industry phrase for a task that looks for deleted or invalid information and cleans it up. Thus, this is a timer that counts a number of seconds before the newly invalid route will be actually removed from the table. The default value for this timer is 120 seconds.</p><p>The reason for using this two-stage removal method is to give the router that declared the route that's no longer reachable a chance to propagate this information to other routers. Until the Garbage-Collection timer expires, the router will include that route, with the unreachable metric of 16 hops, in its own RIP Response messages, so that the problem with that route is conveyed to the other routers. When the timer expires, the route is deleted. If during the garbage collection period a new RIP Response message for the route is received, then the deletion process is aborted. In this case, the Garbage-Collection timer is cleared, the route is marked as valid again, and a new Timeout timer starts.</p></div><div class="sect2" title="Triggered Updates"><div class="titlepage"><div><div><h2 class="title"><a id="triggered_updates"/>Triggered Updates</h2></div></div></div><p><a class="indexterm" id="idx-CHP-38-1422"/>In addition to the two situations already described where an RIP Response is sent—in reply to an RIP Request message and on expiration of the 30-second timer—an RIP Response message is also sent out when a route changes.</p><p>This action, an enhancement to a basic RIP operation, called a <span class="emphasis"><em>triggered update</em></span>, is intended to ensure that information about route changes is propagated as fast as possible across the internetwork. This will help reduce the slow convergence problem in RIP. For example, in the case of a route timing out and the Garbage-Collection timer starting, a triggered update would be sent out about the now-invalid route immediately. This is described in more detail later in the chapter, in the "RIP Special Features for Resolving RIP Algorithm <a class="indexterm" id="idx-CHP-38-1423"/>Problems" section.</p></div></div>
<div class="sect1" title="RIP Problems and Some Resolutions"><div class="titlepage"><div><div><h1 class="title"><a id="rip_problems_and_some_resolutions"/>RIP Problems and Some Resolutions</h1></div></div></div><p>The simplicity of RIP is often given as the main reason for its popularity. Simplicity is great most of the time, but an unfortunate price of simplicity in too many cases is that problems crop up, usually in unusual cases or special situations, and so it is with RIP. The straightforward distance-vector algorithm and operation mechanism work well most of the time, but they have some important weaknesses. We need to examine these problems to understand both the limitations of RIP and some of the complexities that have been added to the protocol to resolve them.</p><div class="sect2" title="Issues with RIP's Algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="issues_with_rips_algorithm"/>Issues with RIP's Algorithm</h2></div></div></div><p>The most important area where we find serious issues with RIP is with the basic function of the distance-vector <a class="indexterm" id="idx-CHP-38-1424"/>algorithm described earlier in this section and the way that messages are used to implement it, as described in the following sections.</p><div class="sect3" title="Slow Convergence"><div class="titlepage"><div><div><h3 class="title"><a id="slow_convergence"/>Slow Convergence</h3></div></div></div><p><a class="indexterm" id="idx-CHP-38-1425"/>The distance-vector algorithm is designed so that all <a class="indexterm" id="idx-CHP-38-1426"/>routers share all their routing information regularly. Over time, all routers eventually end up with the same information about the location of networks and which are the best routes to use to reach them. This is called <span class="emphasis"><em>convergence</em></span>. Unfortunately, the basic RIP algorithm is rather slow to achieve convergence. It takes a long time for all routers to get the same information, and in particular, it takes a long time for information about topology changes to propagate.</p><p>Consider the worst-case situation of two networks separated by 15 routers. Since routers normally send RIP Response messages only every 30 seconds, a change to one of this pair of networks might not be seen by the router nearest to the other one until many minutes have elapsed—an eternity in networking terms.</p><p>The <a class="indexterm" id="idx-CHP-38-1427"/>slow convergence problem is even more pronounced when it comes to the propagation of route failures. Failure of a route is detected only through the expiration of the 180-second Timeout timer, so that adds up to three minutes more delay before convergence can even begin.</p></div><div class="sect3" title="Routing Loops"><div class="titlepage"><div><div><h3 class="title"><a id="routing_loops"/>Routing Loops</h3></div></div></div><p><a class="indexterm" id="idx-CHP-38-1428"/>A routing loop occurs when Router A has an entry telling it to send datagrams for Network 1 to Router B, and Router B has an entry saying that datagrams for Network 1 should be sent to Router A. Larger loops can also exist: Router A says to send to B, which says to send to Router C, which says to send to Router A. Under normal circumstances, these loops should not occur, but they can happen in special situations.</p><p>RIP does not include any specific mechanism to detect or prevent <a class="indexterm" id="idx-CHP-38-1429"/>routing loops. The best it can do is try to avoid them.</p></div><div class="sect3" title="Counting to Infinity"><div class="titlepage"><div><div><h3 class="title"><a id="counting_to_infinity"/>Counting to Infinity</h3></div></div></div><p><a class="indexterm" id="idx-CHP-38-1430"/>A special case of slow convergence can lead to a routing loop situation where one router passes bad information to another router, which sends more bad information to another router, and so on. This causes a situation where the protocol is sometimes described as unstable. The problem is called <a class="indexterm" id="idx-CHP-38-1431"/><span class="emphasis"><em>counting to infinity</em></span>, for reasons you will soon see.</p><p>To understand how this happens, let's modify the example presented earlier in the "RIP Route Determination and Information Propagation" section, as shown in <a class="xref" href="ch38s04.html#the_rip_counting_to_infinity_problem_thi" title="Figure 38-3. The RIP counting to infinity problem This composite diagram shows part of the AS illustrated previously in Figure 38-1. The top panel (1) shows the normal state of the network, with Router RB able to reach Network N1 through Router RA at a cost of 2. In panel 2, the link between Router RA and Network N1 is broken. Router RA changes its cost to reach Network N1 to 16 (RIP infinity). In panel 3, before Router RA can send out this update to Router RB, it receives a routine RIP message from Router RB indicating that Network N1 can be reached for a cost of 2. Router RA is then fooled into thinking that it can use Router RB as an alternate route to Network N1, even though Router RB's information originally came from Router RA in the first place. In panel 4, Router RA then sends this bogus information out, which is received by Router RB in panel 5. Router RB then increases its cost to 4, and on its next cycle will send this to Router RA, which will increase its cost to 5, and so on. This cycle will continue, with both routers &quot;counting to infinity&quot; (cost of 16).">Figure 38-3</a>. Suppose that the internetwork is operating properly for a while. Router RB has an entry indicating it can reach Network N1 through Router RA at a cost of 2. But let's say the link from Network N1 to Router RA fails. After the Timeout timer for Network N1 expires on Router RA, that router will change the metric for Network N1 to 16 to indicate that it is unreachable. In the absence of any mechanism to force Router RA to immediately inform other routers of this failure, those routers will not know about the change. Router RB will continue to think it can reach Network N1 through Router RA.</p><div class="figure"><a id="the_rip_counting_to_infinity_problem_thi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e40793"/><img alt="The RIP counting to infinity problem This composite diagram shows part of the AS illustrated previously in . The top panel (1) shows the normal state of the network, with Router RB able to reach Network N1 through Router RA at a cost of 2. In panel 2, the link between Router RA and Network N1 is broken. Router RA changes its cost to reach Network N1 to 16 (RIP infinity). In panel 3, before Router RA can send out this update to Router RB, it receives a routine RIP message from Router RB indicating that Network N1 can be reached for a cost of 2. Router RA is then fooled into thinking that it can use Router RB as an alternate route to Network N1, even though Router RB's information originally came from Router RA in the first place. In panel 4, Router RA then sends this bogus information out, which is received by Router RB in panel 5. Router RB then increases its cost to 4, and on its next cycle will send this to Router RA, which will increase its cost to 5, and so on. This cycle will continue, with both routers &quot;counting to infinity&quot; (cost of 16)." src="httpatomoreillycomsourcenostarchimages288033.png.jpg"/></div></div><p class="title">Figure 38-3. The RIP counting to infinity problem This composite diagram shows part of the AS illustrated previously in <a class="xref" href="ch38s02.html#sample_rip_as_this_is_an_example_of_a_si" title="Figure 38-1. Sample RIP AS This is an example of a simple AS that contains four physical networks and four routers.">Figure 38-1</a>. The top panel (1) shows the normal state of the network, with Router RB able to reach Network N1 through Router RA at a cost of 2. In panel 2, the link between Router RA and Network N1 is broken. Router RA changes its cost to reach Network N1 to 16 (RIP infinity). In panel 3, before Router RA can send out this update to Router RB, it receives a routine RIP message from Router RB indicating that Network N1 can be reached for a cost of 2. Router RA is then fooled into thinking that it can use Router RB as an alternate route to Network N1, even though Router RB's information originally came from Router RA in the first place. In panel 4, Router RA then sends this bogus information out, which is received by Router RB in panel 5. Router RB then increases its cost to 4, and on its next cycle will send this to Router RA, which will increase its cost to 5, and so on. This cycle will continue, with both routers "counting to infinity" (cost of 16).</p></div><p><a class="indexterm" id="idx-CHP-38-1432"/><a class="indexterm" id="idx-CHP-38-1433"/>Now suppose Router RB's regular 30-second timer goes off before Router RA's next broadcast. Router RB will send its normal routing table, <span class="emphasis"><em>which contains a route to Network N1 at a cost of 2</em></span>. Router RA will see this and say, "Hey look, Router RB has a route to Network N1 with a cost of 2! That means I can get there with a cost of 3, which sure beats my current cost of 16. Let's use that!" So Router RA installs this route and cancels its Timeout timer. Of course, this is bogus information—Router RA doesn't realize that Router RB's claim of being able to reach Network N1 was based on old information from Router RA itself!</p><p>It only gets worse from there. When it is time for Router RA's regular routing table update, it will broadcast a route to Network N1 with a cost of 3. Now Router RB will see this and say, "Well, my route to Network N1 is through Router RA. Router RA was saying before that its cost was 1; but now it says the cost is 3. That means I have to change my cost to 4."</p><p>Router RB will later send back to Router RA, and back and forth they will go, each incrementing the cost two at a time. This won't stop until the value of infinity cost of 16 is hit—thus the name counting to infinity. At this point, both routers will finally agree that Network N1 is unreachable, but as you can see, it takes a long time for it to happen.</p></div><div class="sect3" title="Small Infinity"><div class="titlepage"><div><div><h3 class="title"><a id="small_infinity"/>Small Infinity</h3></div></div></div><p><a class="indexterm" id="idx-CHP-38-1434"/>The use of a relatively small value for the infinity cost limits the slow convergence problem. Even in a situation where we count to infinity, the total amount of time elapsed is at least manageable. (Imagine if infinity were defined as say, 1,000!) Unfortunately, the drawback of this is that it limits the size of the internetwork that can be used for RIP.</p><p>Many people balk at the limit of a span of 15 routers in RIP, but to be honest I think it is much ado about, well, if not nothing, then nothing much. The 15 value is not a limit on the total number of routers you can use, but rather a limit on the number of routers between any two networks. Consider that most internetworks are set up hierarchically. Even if you have a rather complex four-level hierarchy, you wouldn't be close to the 15-router limit. In fact, you could create a huge AS with thousands of routers, without having more than 15 routers between any two devices. So this is a limitation for only the very largest of ASes.</p><p>On the other hand, RIP's need to send out its entire routing table many times each hour makes it a potentially poor choice for a large internetwork regardless of the infinity=16 issue. In an internetwork with many routers, the amount of traffic RIP generates can become excessive.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-212"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> One of the most important problems with the operation of RIP is slow convergence, which describes the fact that it can take a long time for information about changes to a network to propagate between routers. One specific instance of this problem is the counting to infinity problem, in which out-of-date information causes many bogus RIP messages to be exchanged between routers about an unreachable network.</p></div><p>To be fair, these problems are mostly general to distance-vector routing algorithms and not RIP in particular. Some of them are corrected through the implementation of specific changes to the algorithm or the rules under which RIP messages are sent, as described in the next section. According to RFC 2453, there was actually a proposal to increase RIP's infinity cost to a number larger than 16, but this would have caused compatibility problems with older devices (which would view any route with a <a class="indexterm" id="idx-CHP-38-1435"/>metric of 16 or higher as unreachable), so it was rejected.</p></div></div><div class="sect2" title="Issues with RIP's Metric"><div class="titlepage"><div><div><h2 class="title"><a id="issues_with_rips_metric"/>Issues with RIP's Metric</h2></div></div></div><p>In addition to these concerns with the algorithm itself, RIP is also often criticized because of its choice of metric. The first issue here is RIP's use of hop count as a distance metric. Simply put, hop count is a poor metric of the cost of sending a datagram between two networks. I believe the use of hop count as the metric in RIP is partially due to the desire for simplicity (it's easy to make the protocol work when hop count is all the routers need to consider). But the use of hop count is also partially an artifact of RIP being around for more than 20 years.</p><p>Decades ago, computers were slow, so each time a datagram passed through a router there was probably a significant delay. Hop count was not a perfect metric even then, but I think it had more correspondence with how long it took to move a datagram across an internetwork than it does today.</p><p>Modern routers are lightning fast, making hop count a flawed way of measuring network distance. The number of hops taken often has no correlation with the actual amount of time it takes to move data across a route. To take an extreme case, consider two networks that are connected by a direct dial-up telephone networking link using 56K modems. Let's say they are also connected by a sequence of three routers using high-speed DS-3 lines. RIP would consider the 56K link a better route because it has fewer hops, even though it clearly is much slower.</p><p>Another issue is RIP's lack of support for dynamic (real-time) metrics. Even if RIP were to use a more meaningful metric than hop count, the algorithm requires that the metric should be fixed for each link. There is no way to have RIP calculate the best route based on real-time data about various links the way protocols like OSPF do (see <a class="xref" href="ch39.html" title="Chapter 39. OPEN SHORTEST PATH FIRST (OSPF)">Chapter 39</a>).</p><p>Most of these problems are built into RIP and cannot be resolved. Interestingly, some RIP implementations apparently do let administrators "fudge" certain routes to compensate for the limitations of the hop count metric. For example, the routers on either end of the 56K link mentioned earlier could be configured so that they considered the 56K link to have a hop count of ten instead of one. This would cause any routes using the link to be more expensive than the DS-3 path. This is clever, but hardly an elegant or general solution.</p><p>Note that in addition to the rather long list of problems that I've mentioned, there were also some specific issues with the first version of RIP. Some of the more important of these include lack of support for Classless Inter-Domain Routing (CIDR), lack of authentication, and a performance reduction caused by the use of broadcasts for messaging. These were mostly addressed through extensions in RIP-2.</p></div><div class="sect2" title="RIP Special Features for Resolving RIP Algorithm Problems"><div class="titlepage"><div><div><h2 class="title"><a id="rip_special_features_for_resolving_rip_a"/>RIP Special Features for Resolving RIP Algorithm Problems</h2></div></div></div><p><a class="indexterm" id="idx-CHP-38-1436"/>The simplicity of RIP is its most attractive quality, but as you just saw, this leads to certain problems with how it operates. Most of these limitations are related to the basic algorithm used for determining routes, and the method of message passing that's being used to implement the algorithm. In order for RIP to be a useful protocol, some of these issues needed to be addressed, in the form of changes to the basic RIP algorithm and operational scheme we explored earlier in this section.</p><p>The solution to problems that arise due to RIP being too simple is to add complexity in the form of features that add more intelligence to the way that RIP operates. In the following sections, we'll take a look at four of these: <a class="indexterm" id="idx-CHP-38-1437"/><span class="emphasis"><em>split horizon</em></span>, <a class="indexterm" id="idx-CHP-38-1438"/><span class="emphasis"><em>split horizon with poisoned reverse</em></span>, <span class="emphasis"><em>triggered updates</em></span>, and <span class="emphasis"><em>hold down</em></span>.</p><p>Note that while I describe these as "features," at least some of them are really necessary to ensure the proper RIP functionality. Therefore, they are generally considered standard parts of RIP, and most were described even in the earliest RIP documents. However, sometimes performance or stability issues may arise when these techniques are used, especially in combination. For this reason different RIP implementations may omit some features. For example, hold down slows down route recovery and may not be needed when other features such as split horizon are used. As always, care must be taken to ensure that all routers are using the same features, or even greater problems may arise.</p><p>Also, see the upcoming section on RIP-2's specific features, later in this chapter, for a description of the Next Hop feature, which helps reduce convergence and routing problems when RIP is used.</p><div class="sect3" title="Split Horizon"><div class="titlepage"><div><div><h3 class="title"><a id="split_horizon"/>Split Horizon</h3></div></div></div><p>The counting to infinity problem is one of the most serious issues with the basic RIP algorithm. In the example in the previous section, the cause of the problem is immediately obvious: After Network N1 fails and Router RA notices it go down, Router RB "tricks" Router RA into thinking it has an alternate path to Network N1 by sending Router RA a route advertisement to Network N1.</p><p>If you think about it, it doesn't really make sense under <span class="emphasis"><em>any</em></span> circumstances to have Router RB send an advertisement to Router RA about a network that Router RB can access only through Router RA in the first place. In the case where the route fails, it causes this problem, which is obviously a good reason not do it. But even when the route is operational, what is the point of Router RB telling Router RA about it? Router RA already has a shorter connection to the network and will therefore never send traffic intended for Network N1 to Router RB anyway.</p><p>Clearly, the best solution is simply to have Router RB not include any mention of the route to Network N1 in any RIP Response messages it sends to Router RA. We can generalize this by adding a new rule to RIP operation: When a router sends out an RIP Response message on any of the networks to which it is connected, it omits any route information that it originally learned from that network. This feature is called <span class="emphasis"><em>split horizon</em></span>, because the router effectively splits its view of the internetwork, sending different information on certain links than on others.</p><p>With this new rule, let's consider the behavior of Router RB. It has an interface on Network N2, which it shares with Router RA. It will therefore not include any information on routes it originally obtained from Router RA when sending on Network N2. This will prevent the counting to infinity loop you saw in the previous section. Similarly, because Router RD is on Network N3, Router RB will not send any information about routes it got from Router RD when sending on Network N3.</p><p>Note, however, that split horizon may not always solve the counting to infinity problem, especially in the case where multiple routers are connected indirectly. The classic example would be three routers configured in a triangle. In this situation, problems may still result due to data that is propagated in two directions between any two routers. In this case, the hold down feature, described shortly, may be of assistance.</p></div><div class="sect3" title="Split Horizon with Poisoned Reverse"><div class="titlepage"><div><div><h3 class="title"><a id="split_horizon_with_poisoned_reverse"/>Split Horizon with Poisoned Reverse</h3></div></div></div><p><a class="indexterm" id="idx-CHP-38-1439"/>Adding "poisoned reverse" provides an enhancement of the basic split horizon feature. Instead of omitting routes learned from a particular interface when sending RIP Response messages on that interface, we include those routes but set their metric to RIP infinity, or 16. So in the previous example, Router RB <span class="emphasis"><em>would</em></span> include the route to Network N1 in its transmissions on Network N2, but it would say the cost to reach Network N1 was 16 instead of its real cost (which is 2).</p><p>The <span class="emphasis"><em>poisoned reverse</em></span> refers to the fact that we are poisoning the routes that we want to make sure routers on that interface don't use. Router RA will see Router RB advertise Network N1 but with a cost of 16, which serves as an explicit message to Router RA: "There is absolutely no way for you to get to Network N1 through Router RB." This provides more insurance than the regular split horizon feature, because if the link from Router RA to Network N1 is broken, Router RA will know for certain that it can't try to get a new route through Router RB. <a class="xref" href="ch38s04.html#rip_problem_solving_using_split_horizon_" title="Figure 38-4. RIP problem solving using split horizon with poisoned reverse The top panel in this diagram (1) shows the same example as in Figure 38-3. In panel 2, as before, the link between Router RA and Network N1 is broken, just as Router RB is ready to send out its routine update. However, the split horizon with poisoned reverse feature means it sends different messages on its two links. On the network that connects it to Router RA, it sends a route advertisement with a cost of 16. In panel 3, Router RA receives this, which it will discard, ensuring no counting to infinity problem occurs. On Router RA's next cycle, it will update Router RB to tell it that Network N1 is no longer reachable.">Figure 38-4</a> shows how <a class="indexterm" id="idx-CHP-38-1440"/>split horizon with poisoned reverse works.</p><p>This technique also works in normal circumstances (meaning when there is no issue such as a broken link to a network). In that case, Router RA will receive updates from Router RB with a cost of 16 on a periodic basis, but Router RA will never try to reach Network N1 through Router RB anyway, since it is directly connected to Network N1 (cost of 1).</p></div><div class="sect3" title="Triggered Updates"><div class="titlepage"><div><div><h3 class="title"><a id="triggered_updates-id001"/>Triggered Updates</h3></div></div></div><p><a class="indexterm" id="idx-CHP-38-1441"/>The routing loop problem we looked at earlier in this chapter occurred because Router RB advertised Router RA's route back to Router RA. There's another aspect of the problem that is also significant: After Router RA discovered that the link to Network N1 failed, it had to wait up to 30 seconds until its next scheduled transmission time to tell other routers about the failure.</p><p>For RIP to work well, when something significant happens, we want to tell other routers on the internetwork immediately. For this reason, a new rule should be added to the basic RIP router operation: Whenever a router changes the metric for a route it is required to (almost) immediately send out an RIP Response message to tell its immediate neighbor routers about the change. If these routers, seeing this change, update their routing information, they are in turn required to send out updates. Thus, the change of any network route information causes cascading updates to be sent throughout the internetwork, significantly reducing the slow convergence problem. Note that this includes the removal of a route due to expiration of its Timeout timer, since the first step in route removal is setting the route's metric to 16, which triggers an update.</p><div class="figure"><a id="rip_problem_solving_using_split_horizon_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e40959"/><img alt="RIP problem solving using split horizon with poisoned reverse The top panel in this diagram (1) shows the same example as in . In panel 2, as before, the link between Router RA and Network N1 is broken, just as Router RB is ready to send out its routine update. However, the split horizon with poisoned reverse feature means it sends different messages on its two links. On the network that connects it to Router RA, it sends a route advertisement with a cost of 16. In panel 3, Router RA receives this, which it will discard, ensuring no counting to infinity problem occurs. On Router RA's next cycle, it will update Router RB to tell it that Network N1 is no longer reachable." src="httpatomoreillycomsourcenostarchimages288035.png.jpg"/></div></div><p class="title">Figure 38-4. RIP problem solving using split horizon with poisoned reverse The top panel in this diagram (1) shows the same example as in <a class="xref" href="ch38s04.html#the_rip_counting_to_infinity_problem_thi" title="Figure 38-3. The RIP counting to infinity problem This composite diagram shows part of the AS illustrated previously in Figure 38-1. The top panel (1) shows the normal state of the network, with Router RB able to reach Network N1 through Router RA at a cost of 2. In panel 2, the link between Router RA and Network N1 is broken. Router RA changes its cost to reach Network N1 to 16 (RIP infinity). In panel 3, before Router RA can send out this update to Router RB, it receives a routine RIP message from Router RB indicating that Network N1 can be reached for a cost of 2. Router RA is then fooled into thinking that it can use Router RB as an alternate route to Network N1, even though Router RB's information originally came from Router RA in the first place. In panel 4, Router RA then sends this bogus information out, which is received by Router RB in panel 5. Router RB then increases its cost to 4, and on its next cycle will send this to Router RA, which will increase its cost to 5, and so on. This cycle will continue, with both routers &quot;counting to infinity&quot; (cost of 16).">Figure 38-3</a>. In panel 2, as before, the link between Router RA and Network N1 is broken, just as Router RB is ready to send out its routine update. However, the split horizon with poisoned reverse feature means it sends different messages on its two links. On the network that connects it to Router RA, it sends a route advertisement with a cost of 16. In panel 3, Router RA receives this, which it will discard, ensuring no counting to infinity problem occurs. On Router RA's next cycle, it will update Router RB to tell it that Network N1 is no longer reachable.</p></div><p><a class="indexterm" id="idx-CHP-38-1442"/>You probably noticed that I said that triggered updates were sent "almost" immediately. In fact, before sending a triggered update a route waits a random amount of time, from 1 to 5 seconds. This is done to reduce the load on the internetwork that would result from many routers sending update messages nearly simultaneously.</p></div><div class="sect3" title="Hold Down"><div class="titlepage"><div><div><h3 class="title"><a id="hold_down"/>Hold Down</h3></div></div></div><p><a class="indexterm" id="idx-CHP-38-1443"/><a class="indexterm" id="idx-CHP-38-1444"/>Split horizon tries to solve the counting to infinity problem by suppressing the transmission of invalid information about routes that fail. For extra insurance, we can implement a feature that changes how devices receiving route information process it in the case of a failed route. The <span class="emphasis"><em>hold down</em></span> feature works by having each router start a timer when it first receives information about a network that is unreachable. Until the timer expires, the router will discard any subsequent route messages that indicate that the route is in fact reachable. A typical Hold Down timer runs for 60 or 120 seconds.</p><p>The main advantage of this technique is that a router won't be confused by receiving spurious information about a route being accessible when it was just recently told that the route was no longer valid. It provides a period of time for out-of-date information to be flushed from the system, which is valuable especially on complex internetworks. Adding hold down to split horizon can also help in situations where split horizon alone is insufficient for preventing counting to infinity, such as when a trio of routers are linked in a triangle, as discussed earlier.</p><p>The main disadvantage of hold down is that it forces a delay in a router responding to a route once it is fixed. Suppose that a route went down for just five seconds for some reason. After the network is up again, routers will want to again know about this. However, the Hold Down timer must expire before the router will try to use that network again. This makes internetworks using hold down relatively slow to respond to corrected routes, and it could lead to delays in accessing networks that fail intermittently.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-213"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Four special features represent changes to RIP operation that ameliorate or eliminate the problems with the operation of the basic protocol. <span class="emphasis"><em>Split horizon</em></span> and <span class="emphasis"><em>split horizon with poisoned reverse</em></span> prevent a router from sending invalid route information back to the router from which it originally learned the route. <span class="emphasis"><em>Triggered updates</em></span> reduce the slow convergence problem by causing the immediate propagation of changed route information. Finally, the <span class="emphasis"><em>hold down</em></span> feature may be used to provide robustness when information about a failed route is received.</p></div></div></div></div>
<div class="sect1" title="RIP Version-Specific Message Formats and Features"><div class="titlepage"><div><div><h1 class="title"><a id="rip_version-specific_message_formats_and"/>RIP Version-Specific Message Formats and Features</h1></div></div></div><p><a class="indexterm" id="idx-CHP-38-1445"/>As I've noted, RIP has been in widespread use for more than two decades. During that time, internetworks and internetworking technologies have changed. To keep up with the times, RIP has also evolved and today has three different versions. The basic operation of all three is fairly similar, and it was described in the previous sections of this chapter. As you might expect, there are also some differences between the versions. One of the more important of these is the format used for RIP messages in each version, and the meaning and use of the fields within that format.</p><p>It's now time to take a look at the message format used by each of the three versions of RIP as well as certain specific features not common to all versions. I begin with the original RIP, now also known as <span class="emphasis"><em>RIP version 1</em></span>. I then describe the updated version of RIP called <span class="emphasis"><em>RIP version 2</em></span> or <span class="emphasis"><em>RIP-2</em></span>. Finally, I discuss <span class="emphasis"><em>RIPng</em></span>, also sometimes called <span class="emphasis"><em>RIPv6</em></span>; it's the version of RIP used for IPv6. (Note that this is not technically a new version of the original RIP but a new protocol closely based on the earlier RIP versions.)</p><div class="sect2" title="RIP Version 1 (RIP-1) Message Format and Features"><div class="titlepage"><div><div><h2 class="title"><a id="rip_version_1_rip-1_message_format_and_f"/>RIP Version 1 (RIP-1) Message Format and Features</h2></div></div></div><p><a class="indexterm" id="idx-CHP-38-1446"/>RIP evolved as an industry standard and was <a class="indexterm" id="idx-CHP-38-1447"/>popularized by its inclusion in the Berkeley Standard Distribution of UNIX (BSD UNIX). This first version of RIP (now sometimes called RIP-1 to differentiate it from later versions) was eventually standardized in RFC 1058. As part of this standard, the original RIP-1 message format was defined, which of course serves <span class="emphasis"><em>RIP-1</em></span> itself, and is also the basis for the format used in later versions.</p><div class="sect3" title="RIP-1 Messaging"><div class="titlepage"><div><div><h3 class="title"><a id="rip-1_messaging"/>RIP-1 Messaging</h3></div></div></div><p>As explained in the general discussion on RIP operation in the previous sections, route information is exchanged in RIP through the sending of two different types of RIP messages: RIP Request and the RIP Response. These are transmitted as regular TCP/IP messages using UDP, which uses the UDP reserved port number 520. This port number is used as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>RIP Request messages are sent to UDP destination port 520. They may have a source port of 520 or may use an ephemeral port number (see <a class="xref" href="ch43.html" title="Chapter 43. TCP AND UDP ADDRESSING: PORTS AND SOCKETS">Chapter 43</a> for an explanation of ephemeral ports).</p></li><li class="listitem"><p>RIP Response messages sent in reply to an RIP Request are sent with a source port of 520 and a destination port equal to whatever source port the RIP Request used.</p></li><li class="listitem"><p>Unsolicited RIP Response messages (sent on a routine basis and not in response to a request) are sent with both the source and destination ports, which are set to 520.</p></li></ul></div></div><div class="sect3" title="RIP-1 Message Format"><div class="titlepage"><div><div><h3 class="title"><a id="rip-1_message_format"/>RIP-1 Message Format</h3></div></div></div><p>The basic message format for RIP-1 is described in <a class="xref" href="ch38s05.html#rip-_message_format" title="Table 38-1. RIP-1 Message Format">Table 38-1</a> and illustrated <a class="xref" href="ch38s05.html#rip-1_message_format_the_rip-1_message_f" title="Figure 38-5. RIP-1 message format The RIP-1 message format can contain up to 25 RIP entries. Here, RIP entry 1 is shown with each of its constituent subfields.">Figure 38-5</a>.</p><div class="table"><a id="rip-_message_format"/><p class="title">Table 38-1. RIP-1 Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="RIP-1 Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Command Type: Identifies the type of RIP message being sent. A value of 1 indicates an RIP Request, while 2 means an RIP Response. Originally, three other values and commands were also defined: 3 and 4 for the Traceon and Traceoff commands, and 5, which was reserved for use by Sun Microsystems. These are obsolete and no longer used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Version</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Version Number: Set to 1 for RIP version 1.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Must Be Zero</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Field reserved; value must be set to all zeros.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>RIP Entries</p></td><td style="border-right: 0.5pt solid ; "><p>20 to 500, in increments of 20</p></td><td style=""><p>The body of an RIP message consists of 1 to 25 sets of RIP entries. These entries contain the actual route information that the message is conveying. Each entry is 20 bytes long and has the subfields shown in <a class="xref" href="ch38s05.html#rip-_rip_entries" title="Table 38-2. RIP-1 RIP Entries">Table 38-2</a>.</p></td></tr></tbody></table></div></div><div class="table"><a id="rip-_rip_entries"/><p class="title">Table 38-2. RIP-1 RIP Entries</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="RIP-1 RIP Entries"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Address Family Identifier</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A fancy name for a field that identifies the type of address in the entry. The routers are using IP addresses, for which this field value is 2.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Must Be Zero</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Field reserved; value must be set to all zeros.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IP Address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The address of the route the routers are sending information about. No distinction is made between addresses of different types of devices in RIP, so the address can be for a network, a subnet, or a single host. It is also possible to send an address of all zeros, which is interpreted as the default route for other devices on the network to use for reaching routes with no specified routing entries. This is commonly used to allow a network to access the Internet.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Must Be Zero</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Field reserved; value must be set to all zeros.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Must Be Zero</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Field reserved; value must be set to all zeros. (Yes, two of them in a row.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Metric</p></td><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style=""><p>The distance for the network indicated by the IP address in the IP Address field. Values of 1 to 15 indicate the number of hops to reach the network, while a value of 16 represents infinity (an unreachable destination). See the general discussion of the RIP algorithm earlier in this chapter for more information about the use of metrics.</p></td></tr></tbody></table></div></div><div class="figure"><a id="rip-1_message_format_the_rip-1_message_f"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e41227"/><img alt="RIP-1 message format The RIP-1 message format can contain up to 25 RIP entries. Here, RIP entry 1 is shown with each of its constituent subfields." src="httpatomoreillycomsourcenostarchimages288037.png"/></div></div><p class="title">Figure 38-5. RIP-1 message format The RIP-1 message format can contain up to 25 RIP entries. Here, RIP entry 1 is shown with each of its constituent subfields.</p></div><p>If you're like me, the first thing that comes to mind after looking at this message format is this: What's with all the extra space? I mean, we have four different fields that are reserved (must be zero), and even most of the other fields are larger than they need to be (a metric of 1 to 16 needs only 4 bits, not 32). The command type and version number could also easily have been made only 4 bits each, if not less. And why bother having a 2-byte field to identify the address type when we are only going to deal with IP addresses anyway?</p><p>This seeming wastefulness is actually an artifact of the generality of the original RIP design. The protocol was intended to be able to support routing for a variety of different internetworking protocols, not just Internet Protocol (IP). Remember that it wasn't even originally developed with IP in mind. So, the Address Family Identifier was included to specify address type, and RIP entries were made large enough to handle large addresses. IP requires only 4 bytes per address, so some of the space is not used.</p></div><div class="sect3" title="RIP-1 Version-Specific Features"><div class="titlepage"><div><div><h3 class="title"><a id="rip-1_version-specific_features"/>RIP-1 Version-Specific Features</h3></div></div></div><p>Since RIP-1 was the first version of the protocol, its features formed the basis for future RIP versions; it doesn't really have any <a class="indexterm" id="idx-CHP-38-1448"/>version-specific features. What RIP-1 has is a number of limitations, such as a lack of support for specifying classless addresses and no means for authentication. <a class="indexterm" id="idx-CHP-38-1449"/>RIP-2 was created to address some of RIP-1 shortcomings. As you will see in the next section, RIP-2's features put to good use those "Must Be Zero" bytes in the RIP-1 format!</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-214"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> RIP-1 was the first version of RIP and is the simplest in terms of operation and features. The bulk of an RIP-1 message consists of sets of RIP entries that specify route addresses and the distance to the route in hops.</p></div></div></div><div class="sect2" title="RIP Version 2 (RIP-2) Message Format and Features"><div class="titlepage"><div><div><h2 class="title"><a id="rip_version_2_rip-2_message_format_and_f"/>RIP Version 2 (RIP-2) Message Format and Features</h2></div></div></div><p>The original RIP (RIP-1) has a number of problems and limitations. As the TCP/IP protocol suite evolved and changed, RIP-1's problems were compounded by it becoming somewhat out of date. It was unable to handle newer IP features. There were some who felt that the existence of newer and better interior routing protocols meant that it would be best to just give up on RIP entirely and move over to something like OSPF.</p><p>However, RIP's appeal was never its technical superiority, but its simplicity and ubiquity in the industry. By the early 1990s, RIP was already in use in many thousands of networks. For those who liked RIP, it made more sense to migrate to a newer version that addressed some of RIP-1's shortcomings than to go to an entirely different protocol. To this end, a new version of the protocol, RIP-2 was developed. It was initially published in RFC 1388 in 1993. It is now defined in RFC 2453, "RIP Version 2," which was published in November 1998.</p><div class="sect3" title="RIP-2 Version-Specific Features"><div class="titlepage"><div><div><h3 class="title"><a id="rip-2_version-specific_features"/>RIP-2 Version-Specific Features</h3></div></div></div><p><a class="indexterm" id="idx-CHP-38-1450"/>RIP-2 represents a very modest change to the basic RIP. RIP-2 works in the same basic way as RIP-1. In fact, the new features introduced in RIP-2 are described as <span class="emphasis"><em>extensions</em></span> to the basic protocol, thereby conveying the fact that they are layered upon regular RIP-1 functionality. The five key RIP-2 extensions are as follows:</p><p><span class="strong"><strong>Classless Addressing Support and Subnet Mask Specification</strong></span> When RIP-1 was developed, the use of subnets in IP (as described in RFC 950) had not yet been formally defined. It was still possible to use RIP-1 with subnets through the use of a heuristic to determine if the destination is a network, subnet, or host. However, there was no way to clearly specify the subnet mask for an address using RIP-1 messages. RIP-2 adds explicit support for subnets by allowing a subnet mask within the route entry for each network address. It also provides support for Variable Length Subnet Masking (VLSM; see <a class="xref" href="ch18.html" title="Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS">Chapter 18</a>) and CIDR.</p><p><span class="strong"><strong>Next Hop Specification</strong></span> In RIP-2, each RIP entry includes a space where an explicit IP address can be entered as the next-hop router for datagrams that are intended for the network in that entry. This feature can help improve efficiency of routing by eliminating unnecessary extra hops for datagrams sent to certain destinations. One common use of this field is when the most efficient route to a network is through a router that is not running RIP. Such a router will not exchange RIP messages and would therefore not normally be selected by RIP routers as a next hop for any network. The explicit Next Hop field allows the router to be selected as the next hop, regardless of this situation.</p><p><span class="strong"><strong>Authentication</strong></span> RIP-1 included no authentication mechanism, which is a problem because it could potentially allow a malicious host to attack an internetwork by sending bogus RIP messages. <a class="indexterm" id="idx-CHP-38-1451"/>RIP-2 provides a basic authentication scheme that allows routers to ascertain the identity of a router before it will accept RIP messages from it.</p><p><span class="strong"><strong>Route Tag</strong></span> Each RIP-2 entry includes a Route Tag field where additional information about a route can be stored. This information is propagated along with other data about the route as RIP entries are sent around the internetwork. A common use of this field is when a route is learned from a different AS in order to identify the AS from which the route was obtained.</p><p><span class="strong"><strong>Use of Multicasting</strong></span> To help reduce network load, RIP-2 allows routers to be configured to use multicasts instead of broadcasts for sending out unsolicited RIP Response messages. These datagrams are sent out using the special reserved multicast address 224.0.0.9. All routers on an internetwork must use multicast if this is to work properly.</p><p>As you can see, many of these extensions require more information to be included with each advertised route. This is where all that extra space in the message format of RIP-1 routing entries comes in handy, as you will see shortly.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-215"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> RIP-2 is the most recent version of RIP used in IPv4. It includes a number of enhancements over the original RIP-1, including support for subnet masks and classless addressing, explicit next-hop specification, route tagging, authentication, and multicast. For compatibility, it uses the same basic message format as RIP-1, putting the extra information required for its new features into some of the unused fields of the RIP-1 message format.</p></div></div><div class="sect3" title="RIP-2 Messaging"><div class="titlepage"><div><div><h3 class="title"><a id="rip-2_messaging"/>RIP-2 Messaging</h3></div></div></div><p><a class="indexterm" id="idx-CHP-38-1452"/>RIP-2 messages are exchanged using the same basic mechanism as RIP-1 messages. Two different message types exist: RIP Request and RIP Response. They are sent using UDP, which uses the reserved port number 520. The semantics for the use of this port are the same as for RIP-1. For convenience, I'll repeat the description here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>RIP Request messages are sent to UDP destination port 520. They may have a source port of 520 or may use an ephemeral port number.</p></li><li class="listitem"><p>RIP Response messages sent in reply to an RIP Request message are sent with a source port of 520 and a destination port equal to whatever source port the RIP Request message used.</p></li><li class="listitem"><p>Unsolicited RIP Response messages (sent on a routine basis and not in response to a request) are sent with both the source and destination ports set to 520.</p></li></ul></div></div><div class="sect3" title="RIP-2 Message Format"><div class="titlepage"><div><div><h3 class="title"><a id="rip-2_message_format"/>RIP-2 Message Format</h3></div></div></div><p>The basic message format for RIP-2 is also pretty much the same as it was for RIP-1, with the Version field set to 2 in order to clearly identify the message as being RIP-2. <a class="xref" href="ch38s05.html#rip-_message_format-id001" title="Table 38-3. RIP-2 Message Format">Table 38-3</a> and <a class="xref" href="ch38s05.html#rip-2_message_format_the_rip_entries_of_" title="Figure 38-6. RIP-2 message format The RIP entries of RIP-1 are called Route Table Entries (RTEs) in RIP-2; the message format can contain up to 25. The format of RTE 1 is shown here with each of its subfields (the others are summarized to save space).">Figure 38-6</a> illustrate the RIP-2 message format. The real differences are in the individual RIP entries, as you can see in <a class="xref" href="ch38s05.html#rip-_route_table_entries_rtes" title="Table 38-4. RIP-2 Route Table Entries (RTEs)">Table 38-4</a>.</p><div class="table"><a id="rip-_message_format-id001"/><p class="title">Table 38-3. RIP-2 Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="RIP-2 Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Command Type: Identifies the type of RIP message being sent. A value of 1 indicates an RIP Request, while 2 means an RIP Response.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Version</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Version Number: Set to 2 for RIP version 2.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Must Be Zero</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Field reserved; value must be set to all zeros.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Route Table Entries (RTEs)</p></td><td style="border-right: 0.5pt solid ; "><p>20 to 500, in increments of 20</p></td><td style=""><p>As with RIP-1, the body of an RIP-2 message consists of 1 to 25 sets of route information. In RIP-2 these are labeled Route Table Entries, or RTEs. Each RTE is 20 bytes long and has the subfields shown in <a class="xref" href="ch38s05.html#rip-_route_table_entries_rtes" title="Table 38-4. RIP-2 Route Table Entries (RTEs)">Table 38-4</a>.</p></td></tr></tbody></table></div></div><div class="table"><a id="rip-_route_table_entries_rtes"/><p class="title">Table 38-4. RIP-2 Route Table Entries (RTEs)</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="RIP-2 Route Table Entries (RTEs)"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Address Family Identifier</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Same meaning as for RIP-1; value is 2 to identify IP addresses.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Route Tag</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Additional information to be carried with this route.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IP Address</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Same as in RIP-1: the address of the route the router is sending information about. No distinction is made between the address of different types of devices in RIP, so the address can be for a network, a subnet, or a single host. It is also possible to send an address of all zeros, which is interpreted as the default route, as in RIP-1.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subnet Mask</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The subnet mask associated with this address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Next Hop</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Address of the device to use as the next hop for the network advertised in this entry.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Metric</p></td><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style=""><p>The distance for the network indicated by the IP address, as in RIP-1. Values of 1 to 15 indicate the number of hops to reach the network (as described in the discussion of the RIP algorithm earlier in this chapter), while a value of 16 represents infinity (an unreachable destination).</p></td></tr></tbody></table></div></div><p>As you can see, the unused fields allow the new RIP-2 features to be implemented without changing the basic structure of the RIP entry format. This allows RIP-1 and RIP-2 messages and devices to coexist in the same network. An RIP-2 device can handle both RIP-1 and RIP-2 messages, and will look at the version number to see which version the message is. An RIP-1 device should handle both RIP-2 and RIP-1 messages the same way, simply ignoring the extra RIP-2 fields it doesn't understand.</p><div class="note" title="Note"><h3 class="title"><a id="note-108"/>Note</h3><p><span class="emphasis"><em>If authentication is used, one of the RTEs contains authentication information, thus limiting the message to 24 "real" RTEs</em></span>.</p></div><div class="figure"><a id="rip-2_message_format_the_rip_entries_of_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e41500"/><img alt="RIP-2 message format The RIP entries of RIP-1 are called Route Table Entries (RTEs) in RIP-2; the message format can contain up to 25. The format of RTE 1 is shown here with each of its subfields (the others are summarized to save space)." src="httpatomoreillycomsourcenostarchimages288039.png"/></div></div><p class="title">Figure 38-6. RIP-2 message format The RIP entries of RIP-1 are called Route Table Entries (RTEs) in RIP-2; the message format can contain up to 25. The format of RTE 1 is shown here with each of its subfields (the others are summarized to save space).</p></div></div></div><div class="sect2" title="RIPng (RIPv6) Message Format and Features"><div class="titlepage"><div><div><h2 class="title"><a id="ripng_ripv6_message_format_and_features"/>RIPng (RIPv6) Message Format and Features</h2></div></div></div><p>The future of TCP/IP is IPv6, which makes some very important changes to IP, especially with regard to addressing. Since IPv6 addresses are different than IPv4 addresses, everything that works with IP addresses must change to function under IPv6. This includes routing protocols, which exchange addressing information.</p><p>To ensure a future for the RIP, a new IPv6-compatible version had to be developed. This new version was published in 1997 in RFC 2080, <a class="indexterm" id="idx-CHP-38-1453"/><span class="emphasis"><em>RIPng for IPv6</em></span>, where the <span class="emphasis"><em>ng</em></span> stands for next generation (IPv6 is also sometimes called <span class="emphasis"><em>IP next generation</em></span>).</p><p>RIPng, which is also occasionally seen as RIPv6 for obvious reasons, was designed to be as similar as possible to the current version of RIP for IPv4, which is RIP-2. In fact, RFC 2080 describes RIPng as the minimum change possible to RIP to allow it to work on IPv6. Despite this effort, it was not possible to define RIPng as just a new version of the older RIP, as RIP-2 was defined. RIPng is a new protocol, which was necessary because of the significance of the changes between IPv4 and IPv6—especially the change from 32-bit to 128-bit addresses in IPv6, which necessitated a new message format.</p><div class="sect3" title="RIPng Version-Specific Features"><div class="titlepage"><div><div><h3 class="title"><a id="ripng_version-specific_features"/>RIPng Version-Specific Features</h3></div></div></div><p><a class="indexterm" id="idx-CHP-38-1454"/>Even though RIPng is a new protocol, a specific effort was made to make RIPng like its predecessors. Its basic operation is almost entirely the same, and it uses the same overall algorithm and operation, as you saw earlier in this chapter. RIPng also does not introduce any specific new features compared to RIP-2, except those needed to implement RIP on IPv6.</p><p><a class="indexterm" id="idx-CHP-38-1455"/>RIPng maintains most of the enhancements introduced in RIP-2; some are implemented as they were in RIP-2, while others appear in a modified form. Here's specifically how the five extensions in RIP-2 are implemented in RIPng:</p><p><span class="strong"><strong>Classless Addressing Support and Subnet Mask Specification</strong></span> In IPv6 all, addresses are classless and specified using an address and a prefix length, instead of a subnet mask. Thus, a field for the prefix length is provided for each entry instead of a subnet mask field.</p><p><span class="strong"><strong>Next Hop Specification</strong></span> This feature is maintained in RIPng, but implemented differently. Due to the large size of IPv6 addresses, if you include a Next Hop field in the format of RIPng, the RTEs would almost double the size of every entry. Since Next Hop is an optional feature, this would be wasteful. Instead, when a Next Hop is needed, it is specified in a separate routing entry.</p><p><span class="strong"><strong>Authentication</strong></span> RIPng does not include its own authentication mechanism. It is assumed that if authentication and/or encryption are needed, they will be provided using the standard IPsec features, which are defined for IPv6 at the IP layer. This is more efficient than having individual protocols like RIPng perform authentication.</p><p><span class="strong"><strong>Route Tag</strong></span> This field is implemented in the same way as it is in RIP-2.</p><p><span class="strong"><strong>Use of Multicasting</strong></span> RIPng uses multicasts for transmissions, specifically the reserved IPv6 multicast address FF02::9.</p></div><div class="sect3" title="RIPng Messaging"><div class="titlepage"><div><div><h3 class="title"><a id="ripng_messaging"/>RIPng Messaging</h3></div></div></div><p><a class="indexterm" id="idx-CHP-38-1456"/>There are two basic RIPng message types, RIP Request and RIP Response, which are exchanged using the UDP as with RIP-1 and RIP-2. Since RIPng is a new protocol, it cannot use the same UDP reserved port number 520, which is used for RIP-1/RIP-2. Instead, RIPng uses well-known port number 521. The semantics for the use of this port are the same as those used for port 520 in RIP-1 and RIP-2. For convenience, here are the rules again:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>RIP Request messages are sent to UDP destination port 521. They may have a source port of 521 or may use an ephemeral port number.</p></li><li class="listitem"><p>RIP Response messages sent in reply to an RIP Request message are sent with a source port of 521 and a destination port equal to whatever source port the RIP Request message used.</p></li><li class="listitem"><p>Unsolicited RIP Response messages (sent on a routine basis and not in response to a request) are sent with both the source and destination ports set to 521.</p></li></ul></div></div><div class="sect3" title="RIPng Message Format"><div class="titlepage"><div><div><h3 class="title"><a id="ripng_message_format"/>RIPng Message Format</h3></div></div></div><p>The message format for RIPng is similar to that of RIP-1 and RIP-2, except for the format of the RTEs. It is shown in <a class="xref" href="ch38s05.html#ripng_message_format-id001" title="Table 38-5. RIPng Message Format">Table 38-5</a> and illustrated in <a class="xref" href="ch38s05.html#ripng_message_format_ripng_retains_the_u" title="Figure 38-7. RIPng message format RIPng retains the use of RTEs from RIP-2, but their format has been changed to accommodate the much larger IPv6 address size. The limit of 25 entries per message has also been eliminated.">Figure 38-7</a>.</p><div class="table"><a id="ripng_message_format-id001"/><p class="title">Table 38-5. RIPng Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="RIPng Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Command</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Command Type: Identifies the type of RIPng message being sent. A value of 1 indicates an RIPng Request, while 2 means an RIPng Response.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Version</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Version Number: Set to 1 (not 6, since this is the first version of the new protocol RIPng).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Must Be Zero</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Field reserved; value must be set to all zeros.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Route Table Entries (RTEs)</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>The body of an RIPng message consists of a variable number of Route Table Entries (RTEs) that contain information about routes. Each entry is 20 bytes long and has the subfields shown in <a class="xref" href="ch38s05.html#ripng_rtes" title="Table 38-6. RIPng RTEs">Table 38-6</a>.</p></td></tr></tbody></table></div></div><div class="table"><a id="ripng_rtes"/><p class="title">Table 38-6. RIPng RTEs</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="RIPng RTEs"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>IPv6 Prefix</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>The 128-bit IPv6 address of the network whose information is contained in this RTE.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Route Tag</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Additional information to be carried with this route, as defined in RIP-2.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Prefix Len</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>The number of bits of the IPv6 address that is the network portion (the remainder being the host portion). This is the number that normally would appear after the slash when specifying an IPv6 network address. It is analogous to an IPv4 subnet mask. See the description of IPv6 prefix notation in <a class="xref" href="ch25.html" title="Chapter 25. IPV6 ADDRESSING">Chapter 25</a> for more details.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Metric</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style=""><p>The distance for the network indicated by the IP address, as in RIP-1. Values of 1 to 15 indicate the number of hops to reach the network (as described in the general discussion of the RIP algorithm earlier in this chapter) while a value of 16 represents infinity (an unreachable destination).</p></td></tr></tbody></table></div></div><div class="figure"><a id="ripng_message_format_ripng_retains_the_u"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e41723"/><img alt="RIPng message format RIPng retains the use of RTEs from RIP-2, but their format has been changed to accommodate the much larger IPv6 address size. The limit of 25 entries per message has also been eliminated." src="httpatomoreillycomsourcenostarchimages288041.png"/></div></div><p class="title">Figure 38-7. RIPng message format RIPng retains the use of RTEs from RIP-2, but their format has been changed to accommodate the much larger IPv6 address size. The limit of 25 entries per message has also been eliminated.</p></div><p>The maximum number of RTEs in RIPng is not restricted to 25 as it is in RIP-1 and RIP-2. It is limited only by the maximum transmission unit (MTU) of the network over which the message is being sent.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-216"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> RIPng is the version of RIP that was developed for use on IPv6 internetworks. It is technically a distinct protocol from RIP-1 and RIP-2, but is very similar to both. It retains the enhancements to RIP made in RIP-2, making changes to these features and to the RIP message format wherever needed for compatibility with IPv6.</p></div><p>When a Next Hop field needs to be specified, a special RTE is included, as I mentioned earlier. This RTE is included before all the RTEs to which it applies. It has the same basic structure as shown for regular RTEs in <a class="xref" href="ch38s05.html#ripng_rtes" title="Table 38-6. RIPng RTEs">Table 38-6</a>, with the IPv6 Prefix subfield containing the next hop address, the Route Tag and Prefix Len fields set to 0, and the Metric field set to 255 (0xFF).</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;39.&#xA0;OPEN SHORTEST PATH FIRST (OSPF)"><div class="titlepage"><div><div><h1 class="title"><a id="open_shortest_path_first_ospf"/>Chapter 39. OPEN SHORTEST PATH FIRST (OSPF)</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e41744"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> Interior routing protocols using a distance-vector routing algorithm, such as the Routing Information Protocol (RIP) we explored last chapter, have a long history and work well in a small group of routers. However, they also have some serious limitations in both scalability and performance that make them poorly suited to larger autonomous systems (ASes) or those with specific performance issues. Many organizations that start out using RIP quickly find that its restrictions and issues make it less than ideal.</p><p>To solve this problem, a new routing protocol was developed in the late 1980s. This protocol, called <span class="emphasis"><em>Open Shortest Path First (OSPF)</em></span><a class="indexterm" id="idx-CHP-39-1457"/>, uses the more capable (and more complex) link-state or <span class="emphasis"><em>shortest-path first</em></span> routing algorithm. It fixes many of the issues with RIP and allows routes to be selected dynamically based on the current state of the network, not just a static picture of how routers are connected. It also has numerous advanced features, including support for a hierarchical topology and automatic load sharing among routes. On the downside, it is a complicated protocol, which means it is often not used unless it is really needed. This makes it the complement of RIP and is the reason they both have a place in the spectrum of TCP/IP routing protocols.</p><p>In this chapter, I provide a condensed explanation of the concepts and operation behind <a class="indexterm" id="idx-CHP-39-1458"/>OSPF. As usual, I begin with an overview of the protocol, discussing how it was developed, its versions, and the standards that define them. I describe the concepts behind <a class="indexterm" id="idx-CHP-39-1459"/>OSPF, including basic topology and the link-state database. I then discuss the more complex optional hierarchical topology of routers and the roles routers play when this topology is used. I briefly explain the method used for determining routes in OSPF, and the general operation and messaging used in the protocol, including a description of the five OSPF message types. I conclude with descriptions of the formats used for OSPF messages.</p><div class="note" title="Note"><h3 class="title"><a id="note-109"/>Note</h3><p><span class="emphasis"><em>The difficult thing about networking is that so many protocols and technologies are so involved that each deserves its own book. This is certainly the case with OSPF itself, which is sufficiently complex that the RFC defining OSPF version 2 is more than 240 pages long! Thus, this chapter, despite being fairly comprehensive, is only a high-level description of OSPF</em></span>.</p></div><div class="sect1" title="OSPF Overview"><div class="titlepage"><div><div><h1 class="title"><a id="ospf_overview"/>OSPF Overview</h1></div></div></div><p>In the early days of TCP/IP, RIP became the standard protocol for routing within an autonomous system (AS), almost by default. RIP had two big things going for it: It was simple and easy to use, and it was included in the popular Berkeley Standard Distribution (BSD) of UNIX starting in 1982. Most organizations using TCP/IP started out with relatively small networks and were able to use RIP with some degree of success.</p><p>However, as I discussed in <a class="xref" href="ch38.html" title="Chapter 38. ROUTING INFORMATION PROTOCOL (RIP, RIP-2, AND RIPNG)">Chapter 38</a>, that protocol has some serious technical issues, and they are exacerbated when RIP is used on a larger AS. Many of RIP's problems are due to it being a distance-vector protocol, because the algorithm itself simply limits the ability of RIP to choose the best route and adapt to changing network conditions. Other problems with RIP were based on its implementation, such as the selection of a cost value of 16 for infinity, which makes it impossible to use RIP in a situation where more than 15 hops might occur between devices. Problems such as the lack of classless addressing support were addressed in version 2 of RIP, but the basic difficulties with the protocol as a whole persist.</p><div class="sect2" title="Development and Standardization of OSPF"><div class="titlepage"><div><div><h2 class="title"><a id="development_and_standardization_of_ospf"/>Development and Standardization of OSPF</h2></div></div></div><p><a class="indexterm" id="idx-CHP-39-1460"/>The Internet Engineering Task Force (IETF) recognized that RIP by itself simply would not meet the needs of all ASes on the Internet. It formed a working group in 1988 to develop a new routing protocol based on the more capable link-state algorithm, also called shortest path first (SPF). Research into this type of protocol had already begun as early as the 1970s, with some of it conducted on the ARPAnet, the predecessor of the Internet, upon which much of TCP/IP was developed.</p><p>This new protocol's name conveys two of its most important characteristics. The first word refers to the fact that the protocol, like all TCP/IP standards, was developed using the open and public RFC process, so it is not proprietary, and no license is required to use it. The SPF portion of the name refers to the type of algorithm it uses, which is designed to allow routers to dynamically determine the shortest path between any two networks.</p><p>The first version of OSPF was described in RFC 1131, which was published in October 1989. This was quickly replaced by OSPF version 2 in July 1991, which is described in RFC 1247. Since then, there have been several revisions to the OSPF version 2 standard, in RFCs 1583, 2178, and 2328, with the last of these now the current standard. OSPF version 2 is the only version in use today, so it is usually what is meant when people (including myself) refer to OSPF.</p></div><div class="sect2" title="Overview of OSPF Operation"><div class="titlepage"><div><div><h2 class="title"><a id="overview_of_ospf_operation"/>Overview of OSPF Operation</h2></div></div></div><p>The fundamental concept behind OSPF is a data structure called the <span class="emphasis"><em>link-state database (LSDB)</em></span>. Each router in an AS maintains a copy of this database, which contains information in the form of a directed graph that describes the current state of the AS. Each link to a network or another router is represented by an entry in the database, and each has an associated cost (or metric). The metric can be made to include many different aspects of route performance, not just a simple hop count, as is used in RIP.</p><p>Information about the AS moves around the AS in the form of <span class="emphasis"><em>link-state advertisements (LSAs)</em></span>, which are messages that let each router tell the others what it currently knows about the state of the AS. Over time, the information that each router has about the AS converges with that of the others, and they all have the same data. When changes occur to the internetwork, routers send updates to ensure that all the routers are kept up-to-date.</p><p>To determine actual routes, each router uses its LSDB to construct a shortest-path tree. This tree shows the links from the router to each other router and network and allows the lowest-cost route to any location to be determined. As new information about the state of the internetwork arrives, this tree can be recalculated, so the best route is dynamically adjusted based on network conditions. When more than one route with an equal cost exists, traffic can be shared among the routes.</p></div><div class="sect2" title="OSPF Features and Drawbacks"><div class="titlepage"><div><div><h2 class="title"><a id="ospf_features_and_drawbacks"/>OSPF Features and Drawbacks</h2></div></div></div><p><a class="indexterm" id="idx-CHP-39-1461"/>In addition to the obvious benefits of the link-state algorithm, OSPF includes several other features of value, especially to larger organizations. It supports authentication for security and all three major types of IP addressing (classful, subnetted classful, and classless). For very large ASes, OSPF also allows routers to be grouped and arranged into a hierarchical topology. This allows for better organization and improved performance through reduced LSA traffic.</p><p>Naturally, the superior functionality and many features of OSPF do not come without a cost. In this case, the primary cost is that of complexity. Where RIP is a simple and easy-to-use protocol, OSPF requires more work and more expertise to properly configure and maintain. This means that even though OSPF is widely considered better than RIP, technically, it's not for everyone. The obvious role for OSPF is as a routing protocol for larger or higher-performance ASes, leaving RIP to cover the smaller and simpler internetworks.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-217"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> <span class="emphasis"><em>Open Shortest Path First (OSPF)</em></span> was developed in the late 1980s to provide a more capable interior routing protocol for larger or more complex ASes that were not being served well by RIP. It uses the dynamic shortest path first, or link-state, routing algorithm, with each router maintaining a database containing information about the state and <a class="indexterm" id="idx-CHP-39-1462"/>topology of the internetwork. As changes to the internetwork occur, routers send out updated state information, which allows each router to dynamically calculate the best route to any network at any point in time. OSPF is a complement to RIP in that RIP is simple but limited, whereas OSPF is more capable but more complicated.</p></div></div></div></div>
<div class="sect1" title="OSPF Basic Topology and the Link-State Database (LSDB)"><div class="titlepage"><div><div><h1 class="title"><a id="ospf_basic_topology_and_the_link-state_d"/>OSPF Basic Topology and the Link-State Database (LSDB)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-39-1463"/><a class="indexterm" id="idx-CHP-39-1464"/>OSPF is designed to facilitate routing in both smaller and larger ASes. To this end, the protocol supports two topologies. When there is only a small number of routers, the entire AS is managed as a single entity. This doesn't have a specific name, but I call it <span class="emphasis"><em>OSPF basic topology</em></span> to convey the simple nature of the topology and to contrast it with the hierarchical topology you will explore in the next section.</p><p>When OSPF basic topology is used, all the routers in the AS function as peers. Each router communicates routing information with each other one, and each maintains a copy of the key OSPF data structure: the LSDB, which is essentially a computerized representation of the topology of the AS. It is the method by which routers see the state of the links in the AS—thus the name <span class="emphasis"><em>link-state database</em></span> (and for that matter, the name of the entire class of link-state algorithms of which OSPF is a part).</p><p>The LSDB is a bit hard to visualize, but is best viewed as a set of data that is equivalent to a graphical picture that shows the topology of an AS. In such a diagram, we typically show routers and networks as nodes, and connections between routers and networks as lines that connect them. The OSPF LSDB takes that information and puts it into a table to allow a router to maintain a virtual picture of all the connections between routers and networks in the AS.</p><p>The LSDB therefore indicates which routers can directly reach which other routers and which networks each router can reach. Furthermore, it stores for each of these links a <span class="emphasis"><em>cost</em></span> to reach the network. This cost is an arbitrary metric that can be set up based on any criteria important to the administrator. OSPF is not restricted to the overly simple hop-count metric used in RIP.</p><div class="sect2" title="OSPF Basic Topology"><div class="titlepage"><div><div><h2 class="title"><a id="ospf_basic_topology"/>OSPF Basic Topology</h2></div></div></div><p>For example, let's consider the same AS that you looked at in the examination of the RIP route determination algorithm in <a class="xref" href="ch38.html" title="Chapter 38. ROUTING INFORMATION PROTOCOL (RIP, RIP-2, AND RIPNG)">Chapter 38</a>. This internetwork has four individual networks, connected as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Router RA connects Network N1 to Network N2.</p></li><li class="listitem"><p>Routers RB and RC connect Network N2 to Network N3.</p></li><li class="listitem"><p>Router RD connects Network N3 to Network N4.</p></li></ul></div><p>To make this example more interesting, I added a direct link between Routers RB and RC.</p><p>The resulting <a class="indexterm" id="idx-CHP-39-1465"/>AS is shown in <a class="xref" href="ch39s02.html#sample_ospf_as_this_is_the_same_as_that_" title="Figure 39-1. Sample OSPF AS This is the same AS that you looked at in RIP (as shown in Figure 38-1 in Chapter 38), but with the addition of a link between the two Routers RB and RC.">Figure 39-1</a>. <a class="xref" href="ch39s02.html#sample_ospf_link-state_database_lsdb" title="Table 39-1. Sample OSPF Link-State Database (LSDB)">Table 39-1</a> shows what the LSDB for this AS might look like.</p><div class="figure"><a id="sample_ospf_as_this_is_the_same_as_that_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e41906"/><img alt="Sample OSPF AS This is the same AS that you looked at in RIP (as shown in in ), but with the addition of a link between the two Routers RB and RC." src="httpatomoreillycomsourcenostarchimages288043.png.jpg"/></div></div><p class="title">Figure 39-1. Sample OSPF AS This is the same AS that you looked at in RIP (as shown in <a class="xref" href="ch38s02.html#sample_rip_as_this_is_an_example_of_a_si" title="Figure 38-1. Sample RIP AS This is an example of a simple AS that contains four physical networks and four routers.">Figure 38-1</a> in <a class="xref" href="ch38.html" title="Chapter 38. ROUTING INFORMATION PROTOCOL (RIP, RIP-2, AND RIPNG)">Chapter 38</a>), but with the addition of a link between the two Routers RB and RC.</p></div><div class="table"><a id="sample_ospf_link-state_database_lsdb"/><p class="title">Table 39-1. Sample OSPF Link-State Database (LSDB)</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Sample OSPF Link-State Database (LSDB)"><colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-39-1466"/><a class="indexterm" id="idx-CHP-39-1467"/>To Router/Network</p></th><th colspan="4" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">From Router</th><th colspan="4" style="border-bottom: 0.5pt solid ; ">From Network</th></tr><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RA</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RB</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RC</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RD</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>N1</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>N2</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>N3</p></th><th style="border-bottom: 0.5pt solid ; "><p>N4</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>RA</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>RB</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>•</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>RC</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>•</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>RD</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>N1</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>•</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>N2</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>•</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>•</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>•</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>N3</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>•</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>•</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>•</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>N4</strong></span></p></td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "><p>•</p></td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style=""> </td></tr></tbody></table></div></div><p>In practice, each of the bullets (•) in <a class="xref" href="ch39s02.html#sample_ospf_link-state_database_lsdb" title="Table 39-1. Sample OSPF Link-State Database (LSDB)">Table 39-1</a> would be replaced by a metric value indicating the cost to send a datagram from the particular router to another router or network. Note that the chart is symmetric, because if Router RB can reach Router RC, Router RC can reach Router RB. However, the <span class="emphasis"><em>costs</em></span> do not have to be symmetric. It is possible for Router RB to have a metric that is higher for it to send to Router RC than for Router RC to send to Router RB.</p><p>Note too that there is no cost to reach a router <span class="emphasis"><em>from</em></span> a network. This ensures that only one cost is applied for a router to send to another router over a network. The cost is to reach the network from the router. This makes sense, since each router is a member of the network on which it is connected.</p></div><div class="sect2" title="LSDB Information Storage and Propagation"><div class="titlepage"><div><div><h2 class="title"><a id="lsdb_information_storage_and_propagation"/>LSDB Information Storage and Propagation</h2></div></div></div><p>An important thing to remember about the LSDB is that even though each router maintains it, the database isn't constructed from the perspective of the individual router. A router's LSDB represents the topology of the entire AS, including links between routers that may be rather distant from it. So, for example, Router RA would keep the entire database in its storage area, including information about Router RC and Router RD, to which it does not connect directly.</p><p>Since in the basic topology, all the routers are peers and maintain information for the entire AS, in theory, they should have the exact same LSDB contents. When a router is first turned on, it may have different LSDB information than its neighbors, but this will be corrected through the exchange of update messages containing LSAs. Eventually, all routers should converge to the same information. You will see how this works in the section about OSPF messaging later in this chapter.</p><p>OSPF, as an interior routing protocol, is used only within the AS. In most cases, the AS will be connected to other ASes through one or more of its routers. The routers that connect the AS to other ASes are often called <span class="emphasis"><em>boundary routers</em></span>. These devices will use OSPF to communicate within the AS, and an exterior routing protocol (typically BGP) to talk to routers outside the AS. The word <span class="emphasis"><em>boundary</em></span> in its name refers to the fact that these devices are usually located on the periphery of the AS.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-218"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In basic OSPF topology, each of the routers running OSPF is considered a peer of the others. Each maintains a <span class="emphasis"><em>link-state database (LSDB)</em></span> that contains information about the topology of the entire AS. Each link between a router and network or between two routers is represented by an entry in the LSDB that indicates the cost to send data over the link. The LSDB is updated regularly through the exchange of OSPF <span class="emphasis"><em>link-state advertisements (LSAs)</em></span>.</p></div></div></div>
<div class="sect1" title="OSPF Hierarchical Topology"><div class="titlepage"><div><div><h1 class="title"><a id="ospf_hierarchical_topology"/>OSPF Hierarchical Topology</h1></div></div></div><p><a class="indexterm" id="idx-CHP-39-1468"/>When the number of routers in an AS is relatively small, using the previously described basic topology works well. Each router maintains a common picture of the network topology in the form of an identical LSDB. The routers communicate as peers using LSAs. While changes in the AS may cause a router to temporarily have different information than its peers, routine exchanges of data will keep all the LSDBs synchronized and up-to-date, and not that much information needs to be sent around because the AS is small.</p><p>This simpler topology does scale reasonably well, and it can support many smaller and even moderate-sized ASes. However, as the number of routers increases, the amount of communication required to update LSDBs increases as well. In a very large internetwork with dozens or even hundreds of routers, having all the routers be OSPF peers using the basic topology can result in performance degradation. This problem occurs due to the amount of routing information that needs to be passed around and to the need for each router to maintain a large LSDB containing every router and network in the entire AS.</p><div class="sect2" title="OSPF Areas"><div class="titlepage"><div><div><h2 class="title"><a id="ospf_areas"/>OSPF Areas</h2></div></div></div><p><a class="indexterm" id="idx-CHP-39-1469"/>To provide better support for these larger internetworks, OSPF supports the use of a more advanced, hierarchical topology. In this technique, the AS is no longer considered a single, flat structure of interconnected routers all of which are peers. Instead, a two-level hierarchical topology is constructed. The AS is divided into constructs called <a class="indexterm" id="idx-CHP-39-1470"/><span class="emphasis"><em>areas</em></span>, each of which contains a number of contiguous routers and networks. These areas are numbered and managed independently by the routers within them, so each area is almost as if it were an AS unto itself. The areas are interconnected so that routing information can be shared among areas across the entire AS.</p><p>The easiest way to understand this hierarchical topology is to consider each area like a sub-AS within the AS as a whole. The routers within any area maintain an LSDB that contains information about the routers and networks within that area. Routers within more than one area maintain LSDBs about each area that they are a part of, and they also link the areas together to share routing information between them.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-219"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> To allow for better control and management over larger internetworks, <a class="indexterm" id="idx-CHP-39-1471"/>OSPF allows a large AS to be structured into a hierarchical form. Contiguous routers and networks are grouped into areas that connect together using a logical backbone. These areas act as the equivalent of smaller ASes within the larger AS, yielding the same benefits of localized control and traffic management that ASes provide for a large internetwork between organizations.</p></div></div><div class="sect2" title="Router Roles in OSPF Hierarchical Topology"><div class="titlepage"><div><div><h2 class="title"><a id="router_roles_in_ospf_hierarchical_topolo"/>Router Roles in OSPF Hierarchical Topology</h2></div></div></div><p><a class="indexterm" id="idx-CHP-39-1472"/>The topology just described is hierarchical because the routers in the AS are no longer all peers in a single group. The two-level hierarchy consists of the lower level, which contains individual areas, and the higher level that connects them together, which is called the <span class="emphasis"><em>backbone</em></span> and is designated as Area 0. The routers play different roles, depending on where they are located and how they are connected. There are three different labels applied to routers in this configuration:</p><p><span class="strong"><strong>Internal Routers</strong></span> These are routers that are connected only to other routers or networks within a single area. They maintain an LSDB for only that area and have no knowledge of the topology of other areas.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-39-1473"/>Area Border Routers</strong></span> These are routers that connect to routers or networks in more than one area. They maintain an LSDB for each area of which they are a part. They also participate in the backbone.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-39-1474"/>Backbone Routers</strong></span> These are routers that are a part of the OSPF backbone. By definition, these include all <a class="indexterm" id="idx-CHP-39-1475"/>area border routers, since those routers pass routing information between areas. However, a backbone router may also be a router that connects only to other backbone (or area border) routers and is therefore not part of any area (other than Area 0).</p><p>To summarize, an <span class="emphasis"><em>area border router</em></span> is also always a <span class="emphasis"><em>backbone router</em></span>, but a backbone router is not necessarily an area border router.</p><div class="note" title="Note"><h3 class="title"><a id="note-110"/>Note</h3><p><span class="emphasis"><em>The classifications that I just mentioned are independent of the designation of a router as being a</em></span> boundary router, <span class="emphasis"><em>as described in the previous section. A boundary router is one that talks to routers or networks outside the AS. A boundary router will also often be an area border router or a backbone router, but this is not necessarily the case. A boundary router could be an internal router in one area</em></span>.</p></div><p>The point of all this is the same as the point of using AS architecture in the first place. The topology of each area matters only to the devices in that area. This means that changes in that topology need to be propagated only within the area. It also means that internal routers within Area 1 don't need to know about anything that goes on within Area 2 and don't need to maintain information about any area other than their own. Only the backbone routers (which include at least one area border router within each area) need to know the details of the entire AS. These backbone routers condense information about the areas so that only a summary of each area's topology needs to be advertised on the backbone.</p><p>Routing in a <a class="indexterm" id="idx-CHP-39-1476"/>hierarchical topology AS is performed in one of two ways, depending on the location of the devices:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If the source and destination are in the same area, routing occurs only over networks and routers in that area.</p></li><li class="listitem"><p>If the source and destination are in different areas, the datagram is routed from the source to an area border router in the source's area, over the backbone to an area border router in the destination's area, and then finally delivered to the destination.</p></li></ul></div><p>Again, this is analogous to how routing works between ASes in the big-picture internetwork.</p><p>Let's take an example to help make things more concrete. We can use the AS in the preceding example. This AS is really small enough that it's unlikely we would use hierarchical topology, but it will suffice for sake of illustration. Let's divide this AS into two areas, as follows (see <a class="xref" href="ch39s03.html#sample_ospf_hierarchical_topology_as_thi" title="Figure 39-2. Sample OSPF hierarchical topology AS This is the same AS you saw in Figure 39-1, but it's arranged into OSPF hierarchical topology. The AS has been split evenly into Area 1 and Area 2. Area 0 contains Routers RB and RC, which are area border routers for both Area 1 and Area 2 in this very simple example.">Figure 39-2</a>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Area 1 contains Network N1, Router RA, Network N2, Router RB, and Router RC.</p></li><li class="listitem"><p>Area 2 contains Router RB, Router RC, Network N3, Router RD, and Network N4.</p></li></ul></div><div class="figure"><a id="sample_ospf_hierarchical_topology_as_thi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e42282"/><img alt="Sample OSPF hierarchical topology AS This is the same AS you saw in , but it's arranged into OSPF hierarchical topology. The AS has been split evenly into Area 1 and Area 2. Area 0 contains Routers RB and RC, which are area border routers for both Area 1 and Area 2 in this very simple example." src="httpatomoreillycomsourcenostarchimages288045.png.jpg"/></div></div><p class="title">Figure 39-2. Sample OSPF hierarchical topology AS This is the same AS you saw in <a class="xref" href="ch39s02.html#sample_ospf_as_this_is_the_same_as_that_" title="Figure 39-1. Sample OSPF AS This is the same AS that you looked at in RIP (as shown in Figure 38-1 in Chapter 38), but with the addition of a link between the two Routers RB and RC.">Figure 39-1</a>, but it's arranged into OSPF hierarchical topology. The AS has been split evenly into Area 1 and Area 2. Area 0 contains Routers RB and RC, which are area border routers for both Area 1 and Area 2 in this very simple example.</p></div><p>In this example, Router RA and Router RD are internal routers. Router RB and Router RC are area border routers that make up the backbone (Area 0) of the internetwork. Routers RA, RB, and RC will maintain an LSDB describing Area 1, while Routers RB, RC, and RD will maintain an LSDB describing Area 2. Routers RB and RC maintain a separate LSDB for the backbone. There is no backbone router other than the area border routers RB and RC. However, suppose we had a Router RE that had only direct connections to Routers RB and RC. This would be a backbone router only.</p><p>This example has illustrated the chief drawback to hierarchical topology mentioned earlier in this chapter: complexity. For large ASes, however, it has significant advantages over making every router a peer. At the same time, the conceptual complexity is made worse by the need for very careful design, especially of the backbone. If the hierarchy is not set up properly, a single failure of a link between routers could disrupt the backbone and isolate one or more of the areas (including all the devices on all networks within the area!).</p></div></div>
<div class="sect1" title="OSPF Route Determination Using SPF Trees"><div class="titlepage"><div><div><h1 class="title"><a id="ospf_route_determination_using_spf_trees"/>OSPF Route Determination Using SPF Trees</h1></div></div></div><p><a class="indexterm" id="idx-CHP-39-1477"/><a class="indexterm" id="idx-CHP-39-1478"/><a class="indexterm" id="idx-CHP-39-1479"/>The key data structure maintained by each router in an OSPF AS is the LSDB, which contains a representation of the topology of either the entire AS (in the basic topology) or a single area (in the hierarchical topology). As you have seen, each router in the AS or area has the same LSDB, so it represents a neutral view of the connections between routers and networks.</p><div class="sect2" title="The SPF Tree"><div class="titlepage"><div><div><h2 class="title"><a id="the_spf_tree"/>The SPF Tree</h2></div></div></div><p>Each router needs to participate in keeping the LSDB up-to-date, but it also has its own concerns. It needs to be able to determine what routes it should use for datagrams it receives from its connected networks—this is, after all, the entire point of a routing protocol. To find the best route, it must determine the shortest path between itself and each router or network in the AS or area. For this, it needs not a neutral view of the internetwork but a view of it from its own perspective.</p><p>The router creates this perspective by taking the information in the LSDB and transforming it into an <span class="emphasis"><em>SPF tree</em></span>. The term <span class="emphasis"><em>tree</em></span> refers to a data structure with a root that has branches coming out that go to other nodes, which also have branches. The structure as a whole looks like an upside-down tree. In this case, the SPF tree shows the topology information of the AS or area with the router that constructs the tree at the top. Each directly connected router or network is one step down in the tree; each router or network connected to these first-level routers or networks is then connected, and so on, until the entire AS or area has been represented.</p><p>Again, the router doesn't really <span class="emphasis"><em>make</em></span> the tree; it is just an algorithmic calculation performed by the computer within the router. Once this is done, however, this logical construct can be used to calculate the cost for that router to reach any router or network in the AS (or area). In some cases, there may be more than one way to reach a router or network, so the tree is constructed to show only the shortest (lowest-cost) path to the network.</p><p>Each router is responsible only for sending a datagram on the next leg of its journey, and not for what happens to the journey as a whole. After the SPF tree is created, the router will create a routing table with an entry for each network, showing the cost to reach it, and also the next-hop router to use to reach it.</p><p>The SPF tree is created dynamically based on the current state of the LSDB. If the LSDB ever changes, the SPF tree and the routing information are recalculated.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-220"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> To determine what routes it should use to reach networks in its AS, a router generates a <span class="emphasis"><em>shortest-path first tree (SPF tree)</em></span> from its LSDB. This tree contains the same basic information as the LSDB, but presents it from the point of view of the router doing the calculation, so that router can see the costs of various paths to different networks.</p></div></div><div class="sect2" title="OSPF Route Determination"><div class="titlepage"><div><div><h2 class="title"><a id="ospf_route_determination"/>OSPF Route Determination</h2></div></div></div><p>I can almost see your eyes glazing over, so let's go back to the example we have been using in this chapter. Let's assume that we are looking at the AS as a whole in basic topology, for simplicity. <a class="xref" href="ch39s04.html#sample_ospf_lsdb_with_costs" title="Table 39-2. Sample OSPF LSDB with Costs">Table 39-2</a> repeats the LSDB for this AS shown earlier in <a class="xref" href="ch39s02.html#sample_ospf_link-state_database_lsdb" title="Table 39-1. Sample OSPF Link-State Database (LSDB)">Table 39-1</a>, but I have taken the liberty of replacing the bullets with cost metrics; these are shown in <a class="xref" href="ch39s04.html#sample_ospf_as_with_costs_this_is_the_sa" title="Figure 39-3. Sample OSPF AS with Costs This is the same sample AS that is shown in Figure 39-1, but with costs assigned to each of the links between routers and networks. Costs between routers and networks are applied only in the direction from the router to the network.">Figure 39-3</a> as well. Again, remember that there is no cost to reach a router from a network, so those links have a nonzero cost only going from the router to the network.</p><div class="table"><a id="sample_ospf_lsdb_with_costs"/><p class="title">Table 39-2. Sample OSPF LSDB with Costs</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Sample OSPF LSDB with Costs"><colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>To Router/Network</p></th><th colspan="4" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">From Router</th><th colspan="4" style="border-bottom: 0.5pt solid ; ">From Network</th></tr><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RA</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RB</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RC</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RD</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>N1</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>N2</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>N3</p></th><th style="border-bottom: 0.5pt solid ; "><p>N4</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>RA</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>RB</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>RC</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>RD</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-bottom: 0.5pt solid ; "><p>0</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>N1</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>N2</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>N3</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>N4</strong></span></p></td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "> </td><td style=""> </td></tr></tbody></table></div></div><div class="figure"><a id="sample_ospf_as_with_costs_this_is_the_sa"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e42548"/><img alt="Sample OSPF AS with Costs This is the same sample AS that is shown in , but with costs assigned to each of the links between routers and networks. Costs between routers and networks are applied only in the direction from the router to the network." src="httpatomoreillycomsourcenostarchimages288047.png.jpg"/></div></div><p class="title">Figure 39-3. Sample OSPF AS with Costs This is the same sample AS that is shown in <a class="xref" href="ch39s02.html#sample_ospf_as_this_is_the_same_as_that_" title="Figure 39-1. Sample OSPF AS This is the same AS that you looked at in RIP (as shown in Figure 38-1 in Chapter 38), but with the addition of a link between the two Routers RB and RC.">Figure 39-1</a>, but with costs assigned to each of the links between routers and networks. Costs between routers and networks are applied only in the direction from the router to the network.</p></div><p>Now let's construct the SPF tree for RC. We can do this in iterations, as follows (see <a class="xref" href="ch39s04.html#ospf_route_determination_using_the_spf_a" title="Figure 39-4. OSPF route determination using the SPF algorithm This diagram shows graphically how a router, in this case Router RC, determines the best path to various networks. The arrows here represent not the transfer of data, but rather the examination of various links from a router to other routers or networks. In panel 1, Router RC examines its LSDB and determines the cost for each of its directly linked devices. In panel 2, the second level of the SPF tree is constructed by adding to those numbers the costs of all routers/networks that connect to the routers/networks found in panel 1. (The black arrows represent looking back in the direction we came from in the prior step, which we don't pursue.) In panel 3 the process continues, resulting in the determination of a cost of 5 for Router RC to reach Network N1 and 10 to reach Network N4.">Figure 39-4</a>).</p><div class="figure"><a id="ospf_route_determination_using_the_spf_a"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e42560"/><img alt="OSPF route determination using the SPF algorithm This diagram shows graphically how a router, in this case Router RC, determines the best path to various networks. The arrows here represent not the transfer of data, but rather the examination of various links from a router to other routers or networks. In panel 1, Router RC examines its LSDB and determines the cost for each of its directly linked devices. In panel 2, the second level of the SPF tree is constructed by adding to those numbers the costs of all routers/networks that connect to the routers/networks found in panel 1. (The black arrows represent looking back in the direction we came from in the prior step, which we don't pursue.) In panel 3 the process continues, resulting in the determination of a cost of 5 for Router RC to reach Network N1 and 10 to reach Network N4." src="httpatomoreillycomsourcenostarchimages288049.png.jpg"/></div></div><p class="title">Figure 39-4. OSPF route determination using the SPF algorithm This diagram shows graphically how a router, in this case Router RC, determines the best path to various networks. The arrows here represent not the transfer of data, but rather the examination of various links from a router to other routers or networks. In panel 1, Router RC examines its LSDB and determines the cost for each of its directly linked devices. In panel 2, the second level of the SPF tree is constructed by adding to those numbers the costs of all routers/networks that connect to the routers/networks found in panel 1. (The black arrows represent looking back in the direction we came from in the prior step, which we don't pursue.) In panel 3 the process continues, resulting in the determination of a cost of 5 for Router RC to reach Network N1 and 10 to reach Network N4.</p></div><div class="sect3" title="First Level"><div class="titlepage"><div><div><h3 class="title"><a id="first_level"/>First Level</h3></div></div></div><p>To construct the first level of the tree, we look for all devices that Router RC can reach directly. We find the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Router RB, with a cost of 5</p></li><li class="listitem"><p>Network N2, with a cost of 3</p></li><li class="listitem"><p>Network N3, with a cost of 6</p></li></ul></div></div><div class="sect3" title="Second Level"><div class="titlepage"><div><div><h3 class="title"><a id="second_level"/>Second Level</h3></div></div></div><p>To construct the second level, we look for all devices that the devices on the first level can reach directly. We then add the cost to reach each device on the first level to the cost of each device at the second level.</p><p><span class="strong"><strong>RB</strong></span>: Router RB has a cost of 5 and can reach the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Router RC, with a cost of 5, total cost of 10</p></li><li class="listitem"><p>Network N2, with a cost of 4, total cost of 9</p></li><li class="listitem"><p>Network N3, with a cost of 5, total cost of 10</p></li></ul></div><p><span class="strong"><strong>N2</strong></span>: Network N2 has a cost of 3 and can reach the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Router RA, with a cost of 0, total cost of 3</p></li><li class="listitem"><p>Router RB, with a cost of 0, total cost of 3</p></li><li class="listitem"><p>Router RC, with a cost of 0, total cost of 3</p></li></ul></div><p><span class="strong"><strong>N3</strong></span>: Network N3 has a cost of 6 and can reach the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Router RB, with a cost of 0, total cost of 6</p></li><li class="listitem"><p>Router RC, with a cost of 0, total cost of 6</p></li><li class="listitem"><p>Router RD, with a cost of 0, total cost of 6</p></li></ul></div><p>You probably can see immediately that we ended up with a number of different paths to the same devices or networks, some of which make no sense. For example, we don't really care about any path that goes to Router RC, since we <span class="emphasis"><em>are</em></span> Router RC! Similarly, we can weed out certain paths immediately because we already have a shorter path to them. Taking a path through Router RB to Network N3 with a cost of 10 makes no sense when we can go directly at the first level for a cost of 6. So, after separating out the chaff, we end up with the following wheat at the second level:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Network N2 to Router RA, with a cost of 3</p></li><li class="listitem"><p>Network N3 to Router RD, with a cost of 6</p></li></ul></div></div><div class="sect3" title="Third Level"><div class="titlepage"><div><div><h3 class="title"><a id="third_level"/>Third Level</h3></div></div></div><p>We continue the process by looking for devices that connect to the weeded-out devices that we found on the second level (this time I am only showing the meaningful ones):</p><p><span class="strong"><strong>RA</strong></span>: Router RA connects to Network N1, with a cost of 2, total cost of 5.</p><p><span class="strong"><strong>RD</strong></span>: Router RD connects to Network N4, with a cost of 4, total cost of 10.</p><p>In this simple example, we only need three levels to construct the tree for Router RC. (We would need more for Router RA or RD.) The final results would be the tree shown in <a class="xref" href="ch39s04.html#ospf_calculated_spf_tree_this_is_a_graph" title="Figure 39-5. OSPF calculated SPF tree This is a graphical representation of the SPF tree calculated in Figure 39-4, showing only the final results of the calculation process.">Figure 39-5</a> and the routing information for RC to the four networks that is shown in <a class="xref" href="ch39s04.html#example_of_calculated_ospf_routes" title="Table 39-3. Example of Calculated OSPF Routes">Table 39-3</a>.</p><div class="figure"><a id="ospf_calculated_spf_tree_this_is_a_graph"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e42663"/><img alt="OSPF calculated SPF tree This is a graphical representation of the SPF tree calculated in , showing only the final results of the calculation process." src="httpatomoreillycomsourcenostarchimages288051.png.jpg"/></div></div><p class="title">Figure 39-5. OSPF calculated SPF tree This is a graphical representation of the SPF tree calculated in <a class="xref" href="ch39s04.html#ospf_route_determination_using_the_spf_a" title="Figure 39-4. OSPF route determination using the SPF algorithm This diagram shows graphically how a router, in this case Router RC, determines the best path to various networks. The arrows here represent not the transfer of data, but rather the examination of various links from a router to other routers or networks. In panel 1, Router RC examines its LSDB and determines the cost for each of its directly linked devices. In panel 2, the second level of the SPF tree is constructed by adding to those numbers the costs of all routers/networks that connect to the routers/networks found in panel 1. (The black arrows represent looking back in the direction we came from in the prior step, which we don't pursue.) In panel 3 the process continues, resulting in the determination of a cost of 5 for Router RC to reach Network N1 and 10 to reach Network N4.">Figure 39-4</a>, showing only the final results of the calculation process.</p></div><div class="table"><a id="example_of_calculated_ospf_routes"/><p class="title">Table 39-3. Example of Calculated OSPF Routes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Example of Calculated OSPF Routes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Destination Network</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Cost</p></th><th style="border-bottom: 0.5pt solid ; "><p>Next Hop</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>N1</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-bottom: 0.5pt solid ; "><p>RA</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>N2</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-bottom: 0.5pt solid ; "><p>(local)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="strong"><strong>N3</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-bottom: 0.5pt solid ; "><p>(local)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><span class="strong"><strong>N4</strong></span></p></td><td style="border-right: 0.5pt solid ; "><p>10</p></td><td style=""><p>RD</p></td></tr></tbody></table></div></div><p>This is what you would expect in this very simple example. Note that there are no specific entries for other routers, since they are the means to the end of reaching networks. However, if one of the other routers were a boundary router that connected the AS to the outside world, there would be entries for the networks to which the boundary router connected, so Router RC knew to send traffic for those networks to that boundary router.</p></div></div></div>
<div class="sect1" title="OSPF General Operation"><div class="titlepage"><div><div><h1 class="title"><a id="ospf_general_operation"/>OSPF General Operation</h1></div></div></div><p><a class="indexterm" id="idx-CHP-39-1480"/><a class="indexterm" id="idx-CHP-39-1481"/>As a routing protocol, the main job of <a class="indexterm" id="idx-CHP-39-1482"/>OSPF is to facilitate the exchange of routing information between routers. Each router in an OSPF AS that runs OSPF software is responsible for various tasks, such as setting timers to control certain activities that must occur on a regular basis, and the maintenance of important data structures, such as the LSDB. Most important, each OSPF router must both generate and respond to OSPF messages. It is this messaging system that allows important routing information to be shared within an AS or area, which makes it crucial to understanding how OSPF works. So it's worth starting a discussion of OSPF operation by taking a look at the message types and how they are used.</p><div class="sect2" title="OSPF Message Types"><div class="titlepage"><div><div><h2 class="title"><a id="ospf_message_types"/>OSPF Message Types</h2></div></div></div><p>Unlike RIP, OSPF does not send its information using the User Datagram Protocol (UDP). Instead, OSPF forms IP datagrams directly, packaging them using protocol number 89 for the Internet Protocol (IP) Protocol field. OSPF defines five different message types, for various types of communication:</p><p><span class="strong"><strong>Hello</strong></span> As the name suggests, these <a class="indexterm" id="idx-CHP-39-1483"/>messages are used as a form of greeting to allow a router to discover other adjacent routers on its local links and networks. The messages establish relationships between neighboring devices (called <span class="emphasis"><em>adjacencies</em></span>) and communicate key parameters about how OSPF is to be used in the AS or area.</p><p><span class="strong"><strong>Database Description</strong></span> These messages contain descriptions of the topology of the AS or area; that is, they convey the contents of the LSDB for the AS or area from one router to another. Communicating a large LSDB may require several messages to be sent; this is done by designating the sending device as a master device and sending messages in sequence, with the slave (recipient of the LSDB information) responding with acknowledgments.</p><p><span class="strong"><strong>Link State Request</strong></span> These messages are used by one router to request updated information about a portion of the LSDB from another router. The message specifies the link(s) about which the requesting device wants more current information.</p><p><span class="strong"><strong>Link State Update</strong></span> These messages contain updated information about the state of certain links on the LSDB. They are sent in response to a Link State Request message, and they are also broadcast or multicast by routers on a regular basis. Their contents are used to update the information in the LSDBs of routers that receive them.</p><p><span class="strong"><strong>Link State Acknowledgment</strong></span> These messages provide reliability to the link-state exchange process by explicitly acknowledging receipt of a Link State Update message.</p></div><div class="sect2" title="OSPF Messaging"><div class="titlepage"><div><div><h2 class="title"><a id="ospf_messaging"/>OSPF Messaging</h2></div></div></div><p><a class="indexterm" id="idx-CHP-39-1484"/>The use of these messages is approximately as follows. When a router first starts up it will send out a Hello message to see if any neighboring routers are around running OSPF, and it will also send them out periodically to discover any new neighbors that may show up. When an adjacency is set up with a new router, <a class="indexterm" id="idx-CHP-39-1485"/>Database Description messages will then be sent to initialize the router's LSDB.</p><p>Routers that have been initialized enter a steady state mode. They will each routinely flood their local networks with Link State Update messages, advertising the state of their links. They will also send out updates when they detect a change in topology that needs to be communicated. They will receive Link State Update messages sent by other devices, and respond with Link State Acknowledgments accordingly. Routers may also request updates using Link State Request messages.</p><p>When the hierarchical topology is used, internal routers maintain a single LSDB and perform messaging only within an area. Area border routers have multiple LSDBs and perform messaging in more than one area. They, along with any other OSPF backbone routers, also exchange messaging information on the backbone, including summarized link-state information for the areas they border.</p><p>Again, all of this is highly simplified; the OSPF standard contains pages and pages of detailed rules and procedures governing the exact timing for sending and receiving messages.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-221"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The operation of OSPF involves five message types. Hello messages establish contact between routers. Database Description messages initialize a router's LSDB. Routine LSDB updates are sent using Link State Update messages, which are acknowledged using Link State Acknowledgments. A device may also request a specific update using a Link State Request message.</p></div></div><div class="sect2" title="OSPF Message Authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ospf_message_authentication"/>OSPF Message Authentication</h2></div></div></div><p><a class="indexterm" id="idx-CHP-39-1486"/><a class="indexterm" id="idx-CHP-39-1487"/>The OSPF standard specifies that all OSPF messages are authenticated for security. This is a bit misleading, however, since one of the authentication methods supported is null authentication, meaning no authentication is used. More security is provided by using the optional simple password authentication method, and the most security is available through the use of cryptographic authentication. These methods are described in Appendix D of RFC 2328.</p><div class="note" title="Note"><h3 class="title"><a id="note-111"/>Note</h3><p><span class="emphasis"><em>The Hello messages used in OSPF are also sometimes called the</em></span> Hello Protocol. <span class="emphasis"><em>This is especially poor terminology, because there is an actual routing protocol called the</em></span> HELLO Protocol. <span class="emphasis"><em>The two protocols are not related. However, I suspect that the OSPF Hello messages may have been so named because they serve a similar purpose to the messages used in the independent HELLO Protocol</em></span>.</p></div></div></div>
<div class="sect1" title="OSPF Message Formats"><div class="titlepage"><div><div><h1 class="title"><a id="ospf_message_formats"/>OSPF Message Formats</h1></div></div></div><p>As explained in the previous section, OSPF uses five different types of messages to communicate both link-state and general information between routers within an AS or area. To help illustrate how the OSPF messages are used, it's worth taking a look at the format of each of these messages.</p><div class="sect2" title="OSPF Common Header Format"><div class="titlepage"><div><div><h2 class="title"><a id="ospf_common_header_format"/>OSPF Common Header Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-39-1488"/>Naturally, each type of OSPF message includes a slightly different set of information; otherwise, there wouldn't be different message types. However, all message types share a similar message structure, beginning with a shared 24-byte header. This common header allows certain standard information to be conveyed in a consistent manner, such as the number of the version of OSPF that generated the message. It also allows a device receiving an OSPF message to quickly determine which type of message it has received, so it knows whether or not it needs to bother examining the rest of the message. <a class="xref" href="ch39s06.html#ospf_common_header_format-id001" title="Table 39-4. OSPF Common Header Format">Table 39-4</a> and <a class="xref" href="ch39s06.html#ospf_common_header_format_following_this" title="Figure 39-6. OSPF common header format Following this header, the body of the message includes a variable number of fields that depend on the message type. Each of the message formats is described in detail in RFC 2328. Since some are quite long, I will describe their fields only briefly here.">Figure 39-6</a> show the common OSPF <a class="indexterm" id="idx-CHP-39-1489"/>header format.</p><div class="table"><a id="ospf_common_header_format-id001"/><p class="title">Table 39-4. OSPF Common Header Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="OSPF Common Header Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-39-1490"/>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Version #</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Set to 2 for OSPF version 2.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Indicates the type of OSPF message:</p>
<p>1 = Hello</p>
<p>2 = Database Description</p>
<p>3 = Link State Request</p>
<p>4 = Link State Update</p>
<p>5 = Link State Acknowledgment</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Packet Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The length of the message, in bytes, including the 24 bytes of this header.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Router ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The ID of the router that generated this message (generally its IP address on the interface over which the message was sent).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Area ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>An identification of the OSPF area to which this message belongs, when areas are used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A 16-bit checksum computed in a manner similar to a standard IP checksum. The entire message is included in the calculation except for the Authentication field.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>AuType</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Indicates the type of authentication used for this message:</p>
<p>0 = No Authentication</p>
<p>1 = Simple Password Authentication</p>
<p>2 = Cryptographic Authentication</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Authentication</p></td><td style="border-right: 0.5pt solid ; "><p>8</p></td><td style=""><p>A 64-bit field used for authentication of the message, as needed.</p></td></tr></tbody></table></div></div><div class="figure"><a id="ospf_common_header_format_following_this"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e42999"/><img alt="OSPF common header format Following this header, the body of the message includes a variable number of fields that depend on the message type. Each of the message formats is described in detail in RFC 2328. Since some are quite long, I will describe their fields only briefly here." src="httpatomoreillycomsourcenostarchimages288053.png"/></div></div><p class="title">Figure 39-6. OSPF common header format Following this header, the body of the message includes a variable number of fields that depend on the message type. Each of the message formats is described in detail in RFC 2328. Since some are quite long, I will describe their fields only briefly here.</p></div></div><div class="sect2" title="OSPF Hello Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="ospf_hello_message_format"/>OSPF Hello Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-39-1491"/>Hello messages have a Type value of 1 in the header, and the field structure shown in <a class="xref" href="ch39s06.html#ospf_hello_message_format-id001" title="Table 39-5. OSPF Hello Message Format">Table 39-5</a> and <a class="xref" href="ch39s06.html#ospf_hello_message_format-id002" title="Figure 39-7. OSPF Hello message format">Figure 39-7</a> in the body of the message.</p><div class="table"><a id="ospf_hello_message_format-id001"/><p class="title">Table 39-5. OSPF Hello Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="OSPF Hello Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-39-1492"/>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Network Mask</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The subnet mask of the network the router is sending to.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Hello Interval</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The number of seconds this router waits between sending <a class="indexterm" id="idx-CHP-39-1493"/>Hello messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Options</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Indicates which optional OSPF capabilities the router supports.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Rtr Pri</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Indicates the router's priority, when electing a backup designated router.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Router Dead Interval</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The number of seconds a router can be silent before it is considered to have failed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Designated Router</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The address of a router designated for certain special functions on some networks. Set to zeros if there is no designated router.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Backup Designated Router</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The address of a backup designated router. Set to all zeros if there is no backup designated router.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Neighbors</p></td><td style="border-right: 0.5pt solid ; "><p>Multiple of 4</p></td><td style=""><p>The addresses of each router from which this router has received <a class="indexterm" id="idx-CHP-39-1494"/>Hello messages recently.</p></td></tr></tbody></table></div></div><div class="figure"><a id="ospf_hello_message_format-id002"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e43139"/><img alt="OSPF Hello message format" src="httpatomoreillycomsourcenostarchimages288055.png"/></div></div><p class="title">Figure 39-7. OSPF Hello message format</p></div></div><div class="sect2" title="OSPF Database Description Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="ospf_database_description_message_format"/>OSPF Database Description Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-39-1495"/>Database Description messages have a Type value of 2 in the header and the body structure depicted in <a class="xref" href="ch39s06.html#ospf_database_description_message_-id001" title="Table 39-6. OSPF Database Description Message Format">Table 39-6</a> and <a class="xref" href="ch39s06.html#ospf_database_description_message_-id002" title="Figure 39-8. OSPF Database Description message format">Figure 39-8</a>.</p><div class="table"><a id="ospf_database_description_message_-id001"/><p class="title">Table 39-6. OSPF Database Description Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="OSPF Database Description Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Interface MTU</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The size of the largest IP message that can be sent on this router's interface without fragmentation.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Options</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Indicates which of several optional OSPF capabilities the router supports.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Flags</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Special flags used to indicate information about the exchange of <a class="indexterm" id="idx-CHP-39-1496"/>Database Description messages, as shown in <a class="xref" href="ch39s06.html#ospf_database_description_message_flags" title="Table 39-7. OSPF Database Description Message Flags">Table 39-7</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>DD Sequence Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used to number a sequence of <a class="indexterm" id="idx-CHP-39-1497"/>Database Description messages so that they are kept in order.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>LSA Headers</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Contains LSA headers, which carry information about the LSDB. See the "OSPF Link State Advertisements and the LSA Header Format" section later in this chapter for more information about LSAs. Please add correct cross-ref info.</p></td></tr></tbody></table></div></div><div class="table"><a id="ospf_database_description_message_flags"/><p class="title">Table 39-7. OSPF Database Description Message Flags</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="OSPF Database Description Message Flags"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5/8 (5 bits)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved: Sent and received as zero.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>I</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>I-Bit: Set to 1 to indicate that this is the first (initial) in a sequence of Database Description messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>M</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>M-Bit: Set to 1 to indicate that more Database Description messages follow this one.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>MS</p></td><td style="border-right: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style=""><p>MS-Bit: Set to 1 if the router sending this message is the master in the communication, or 0 if it is the slave.</p></td></tr></tbody></table></div></div><div class="figure"><a id="ospf_database_description_message_-id002"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e43309"/><img alt="OSPF Database Description message format" src="httpatomoreillycomsourcenostarchimages288057.png.jpg"/></div></div><p class="title">Figure 39-8. OSPF Database Description message format</p></div></div><div class="sect2" title="OSPF Link State Request Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="ospf_link_state_request_message_format"/>OSPF Link State Request Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-39-1498"/>Link State Request messages have a Type value of 3 in the header. Following the header comes one or more sets of three fields, each of which identify an LSA for which the router is requesting an update, as shown in <a class="xref" href="ch39s06.html#ospf_link_state_request_message_-id002" title="Figure 39-9. OSPF Link State Request Message format">Figure 39-9</a>. Each LSA identification has the format described in <a class="xref" href="ch39s06.html#ospf_link_state_request_message_-id001" title="Table 39-8. OSPF Link State Request Message Format">Table 39-8</a>.</p><div class="table"><a id="ospf_link_state_request_message_-id001"/><p class="title">Table 39-8. OSPF Link State Request Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="OSPF Link State Request Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>LS Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The type of LSA being sought.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Link State ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The identifier of the LSA, usually the IP address of either the router or network linked.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Advertising Router</p></td><td style="border-right: 0.5pt solid ; "><p>4</p></td><td style=""><p>The ID of the router that created the LSA whose update is being sought.</p></td></tr></tbody></table></div></div><div class="figure"><a id="ospf_link_state_request_message_-id002"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e43382"/><img alt="OSPF Link State Request Message format" src="httpatomoreillycomsourcenostarchimages288059.png"/></div></div><p class="title">Figure 39-9. OSPF Link State Request Message format</p></div></div><div class="sect2" title="OSPF Link State Update Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="ospf_link_state_update_message_format"/>OSPF Link State Update Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-39-1499"/>Link State Update messages have a Type value of 4 in the header and the fields illustrated in <a class="xref" href="ch39s06.html#ospf_link_state_update_message_for-id001" title="Table 39-9. OSPF Link State Update Message Format">Table 39-9</a> and <a class="xref" href="ch39s06.html#ospf_link_state_update_message_for-id002" title="Figure 39-10. OSPF Link State Update message format">Figure 39-10</a>.</p><div class="table"><a id="ospf_link_state_update_message_for-id001"/><p class="title">Table 39-9. OSPF Link State Update Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="OSPF Link State Update Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p># LSAs</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The number of LSAs included in this message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>LSAs</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>One or more LSAs. See the "OSPF Link State Advertisements and the LSA Header Format" section later in this chapter for more details.</p></td></tr></tbody></table></div></div><div class="figure"><a id="ospf_link_state_update_message_for-id002"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e43445"/><img alt="OSPF Link State Update message format" src="httpatomoreillycomsourcenostarchimages288061.png"/></div></div><p class="title">Figure 39-10. OSPF Link State Update message format</p></div></div><div class="sect2" title="OSPF Link State Acknowledgment Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="ospf_link_state_acknowledgment_message_f"/>OSPF Link State Acknowledgment Message Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-39-1500"/><a class="indexterm" id="idx-CHP-39-1501"/>Link State Acknowledgment messages have a Type value of 5 in the header. They then contain a list of LSA headers corresponding to the LSAs being acknowledged, as shown in <a class="xref" href="ch39s06.html#ospf_link_state_acknowledgment_mes-id001" title="Table 39-10. OSPF Link State Acknowledgment Message Format">Table 39-10</a> and <a class="xref" href="ch39s06.html#ospf_link_state_acknowledgment_mes-id002" title="Figure 39-11. OSPF Link State Acknowledgment message format">Figure 39-11</a>.</p><div class="table"><a id="ospf_link_state_acknowledgment_mes-id001"/><p class="title">Table 39-10. OSPF Link State Acknowledgment Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="OSPF Link State Acknowledgment Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; "><p>LSA Headers</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Contains LSA headers that identify the LSAs acknowledged.</p></td></tr></tbody></table></div></div><div class="figure"><a id="ospf_link_state_acknowledgment_mes-id002"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e43505"/><img alt="OSPF Link State Acknowledgment message format" src="httpatomoreillycomsourcenostarchimages288063.png"/></div></div><p class="title">Figure 39-11. OSPF Link State Acknowledgment message format</p></div></div><div class="sect2" title="OSPF Link State Advertisements and the LSA Header Format"><div class="titlepage"><div><div><h2 class="title"><a id="ospf_link_state_advertisements_and_the_l"/>OSPF Link State Advertisements and the LSA Header Format</h2></div></div></div><p><a class="indexterm" id="idx-CHP-39-1502"/>Several of the previous message types include LSAs, which are the fields that actually carry topological information about the LSDB. There are several types of LSAs, which are used to convey information about different types of links. Like the OSPF messages themselves, each LSA has a common header with 20 bytes and then a number of additional fields that describe the link.</p><p>The LSA header contains sufficient information to identify the link. It uses the subfield structure shown in <a class="xref" href="ch39s06.html#ospf_link_state_advertisement_header_for" title="Table 39-11. OSPF Link State Advertisement Header Format">Table 39-11</a> and <a class="xref" href="ch39s06.html#ospf_link_state_advertisement_head-id001" title="Figure 39-12. OSPF Link State Advertisement header format">Figure 39-12</a>.</p><div class="table"><a id="ospf_link_state_advertisement_header_for"/><p class="title">Table 39-11. OSPF Link State Advertisement Header Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="OSPF Link State Advertisement Header Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>LS Age</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The number of seconds elapsed since the LSA was created.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Options</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Indicates which of several optional OSPF capabilities the router supports.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>LS Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Indicates the type of link this LSA describes, as shown in <a class="xref" href="ch39s06.html#ospf_link_state_advertisement_header_ls_" title="Table 39-12. OSPF Link State Advertisement Header LS Types">Table 39-12</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Link State ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the link. This usually is the IP address of either the router or the network the link represents.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Advertising Router</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>The ID of the router originating the LSA.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>LS Sequence Number</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>A sequence number used to detect old or duplicate LSAs.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>LS Checksum</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A checksum of the LSA for data corruption protection.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Length</p></td><td style="border-right: 0.5pt solid ; "><p>2</p></td><td style=""><p>The length of the LSA, including the 20 bytes of the header.</p></td></tr></tbody></table></div></div><div class="table"><a id="ospf_link_state_advertisement_header_ls_"/><p class="title">Table 39-12. OSPF Link State Advertisement Header LS Types</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="OSPF Link State Advertisement Header LS Types"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-39-1503"/>Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Link Type</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Router-LSA</p></td><td style="border-bottom: 0.5pt solid ; "><p>Link to a router.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Network-LSA</p></td><td style="border-bottom: 0.5pt solid ; "><p>Link to a network.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Summary-LSA (IP Network)</p></td><td style="border-bottom: 0.5pt solid ; "><p>When areas are used, summary information is generated about a network.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Summary-LSA (ASBR)</p></td><td style="border-bottom: 0.5pt solid ; "><p>When areas are used, summary information is generated about a link to an AS boundary router.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; "><p>AS-External-LSA</p></td><td style=""><p>An external link outside the AS.</p></td></tr></tbody></table></div></div><div class="figure"><a id="ospf_link_state_advertisement_head-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e43708"/><img alt="OSPF Link State Advertisement header format" src="httpatomoreillycomsourcenostarchimages288065.png"/></div></div><p class="title">Figure 39-12. OSPF Link State Advertisement header format</p></div><p>Following the LSA header comes the body of the LSA. The specific fields in the body depend on the value of the LS Type field (see <a class="xref" href="ch39s06.html#ospf_link_state_advertisement_header_ls_" title="Table 39-12. OSPF Link State Advertisement Header LS Types">Table 39-12</a>). Here is a summary:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>For normal links to a router, the LSA includes an identification of the router and the metric to reach it, as well as details about the router such as whether it is a boundary or area border router.</p></li><li class="listitem"><p>LSAs for networks include a subnet mask and information about other routers on the network.</p></li><li class="listitem"><p>Summary LSAs include a metric and a summarized address as well as a subnet mask.</p></li><li class="listitem"><p>External LSAs include a number of additional fields that allow the external router to be communicated.</p></li></ul></div><p>Refer to Appendix A of RFC 2328 if you want all the details about the fields in the LSA body.</p></div></div>
<div class="chapter" title="Chapter&#xA0;40.&#xA0;BORDER GATEWAY PROTOCOL (BGP/BGP-4)"><div class="titlepage"><div><div><h1 class="title"><a id="border_gateway_protocol_bgp_bgp_4"/>Chapter 40. BORDER GATEWAY PROTOCOL (BGP/BGP-4)</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e43737"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> Modern TCP/IP internetworks are composed of autonomous systems (ASes) that are run independently. Each may use an interior routing protocol such as Routing Information Protocol (RIP), Open Shortest Path First (OSPF), Interior Gateway Routing Protocol (IGRP), or Enhanced Interior Gateway Routing Protocol (EIGRP) to select routes between networks within the AS. To form larger internetworks, and especially the "mother of all internetworks," the Internet, these ASes must be connected together. This requires use of a consistent exterior routing protocol that all ASes can agree upon, and in today's TCP/IP, that protocol is the <span class="emphasis"><em>Border Gateway Protocol (BGP)</em></span><a class="indexterm" id="idx-CHP-40-1504"/>.</p><p>If you were to ask the average Internet user, or even the typical network administrator, to make a list of the ten most important TCP/IP protocols, BGP probably wouldn't show up frequently. Routing protocols are worker bees of the TCP/IP protocol suite, and they just are not very exciting. The reality, however, is that BGP is a critically important protocol to the operation of larger internetworks and the Internet itself. It is the glue that binds smaller internetworks (ASes) together, and it ensures that every organization is able to share routing information. It is this function that lets us take disparate networks and internetworks and find efficient routes from any host to any other host, regardless of location.</p><p>In this chapter, I describe the characteristics, general operation, and detailed operation of <a class="indexterm" id="idx-CHP-40-1505"/>BGP. I start, as usual, with an overview of the protocol and discuss its history, standards, and versions, including a discussion of its key features and characteristics. I then cover basic operational concepts, including topology, the notion of BGP speakers, and neighbor relationships. I discuss BGP traffic types and how policies can be used to control traffic flows on the internetwork. I explain how BGP routers store and advertise routes and how Routing Information Bases function. I describe the basic algorithm used by BGP and how path attributes describe routes. I provide a summary of how the BGP route selection process operates. I then give a general description of BGP's operation and its high-level use of various messages. Finally, I present a more detailed analysis of the different message types, how they are used, and their format.</p><p>BGP is another in the rather large group of protocols and technologies that is so complex it would take dozens of chapters to do justice. Therefore, I include here my somewhat standard disclaimer that you will find in this chapter only a relatively high-level look at BGP. You will need to refer to the BGP standards (described in the section on BGP standards and versions) if you need more details.</p><div class="note" title="Note"><h3 class="title"><a id="note-112"/>Note</h3><p><span class="emphasis"><em>The current version of BGP is version 4, also called</em></span> BGP-4. <span class="emphasis"><em>This is the only version widely used today, so unless otherwise indicated, assume that I'm talking about BGP-4 wherever you see</em></span> BGP.</p></div><div class="sect1" title="BGP Overview"><div class="titlepage"><div><div><h1 class="title"><a id="bgp_overview"/>BGP Overview</h1></div></div></div><p>As I described briefly in the overview of routing protocol concepts in <a class="xref" href="ch37.html" title="Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS">Chapter 37</a>,  the way that routers were connected in the early Internet was quite different than it is today. The early Internet had a set of centralized routers functioning as a core AS. These routers used the Gateway-to-Gateway Protocol (GGP) for communication between them within the AS and the aptly named Exterior Gateway Protocol (EGP) to talk to routers outside the core. GGP and EGP are discussed in <a class="xref" href="ch41.html" title="Chapter 41. OTHER ROUTING PROTOCOLS">Chapter 41</a>.</p><p>When the Internet grew and moved to AS architecture, EGP was still able to function as the exterior routing protocol for the Internet. However, as the number of ASes in an internetwork grew, the importance of communication between them grew as well. EGP was functional but had several weaknesses that became more problematic as the Internet expanded. It was necessary to define a new exterior routing protocol that would provide enhanced capabilities for use on the growing Internet.</p><p>In June 1989, the first version of this new routing protocol was formalized, with the publishing of RFC 1105, "A Border Gateway Protocol (BGP)." This initial version of the BGP standard defined most of the concepts behind the protocol, as well as key fundamentals such as messaging, message formats, and how devices operate in general terms. It established BGP as the Internet's exterior routing protocol of the future.</p><div class="sect2" title="BGP Versions and Defining Standards"><div class="titlepage"><div><div><h2 class="title"><a id="bgp_versions_and_defining_standards"/>BGP Versions and Defining Standards</h2></div></div></div><p>Due to the importance of a protocol that spans the Internet, work continued on BGP for many years after the initial standard was published. The developers of BGP needed to correct problems with the initial protocol, refine BGP's operation, improve efficiency, and add features. It was also necessary to make adjustments to allow BGP to keep pace with other changes in the TCP/IP protocol suite, such as the invention of classless addressing and routing.</p><p>The result of this ongoing work is that BGP has evolved through several <a class="indexterm" id="idx-CHP-40-1506"/>versions and <a class="indexterm" id="idx-CHP-40-1507"/>standards. These are sometimes called BGP-<span class="emphasis"><em>N</em></span>, where <span class="emphasis"><em>N</em></span> is the version number. <a class="xref" href="ch40.html#border_gateway_protocol_bgp_versions_and" title="Table 40-1. Border Gateway Protocol (BGP) Versions and Defining Standards">Table 40-1</a> shows the history of BGP standards, providing the RFC numbers and names, and a brief summary of the changes made in each version.</p><div class="table"><a id="border_gateway_protocol_bgp_versions_and"/><p class="title">Table 40-1. Border Gateway Protocol (BGP) Versions and Defining Standards</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Border Gateway Protocol (BGP) Versions and Defining Standards"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-40-1508"/>RFC Number</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Date</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>BGP Version</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1105</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>June 1989</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A Border Gateway Protocol (BGP)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>BGP-1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Initial definition of the BGP.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1163</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>June 1990</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A Border Gateway Protocol (BGP)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>BGP-2</p></td><td style="border-bottom: 0.5pt solid ; "><p>This version cleaned up several issues with BGP-1 and refined the meaning and use of several of the message types. It also added the important concept of path attributes, which communicate information about routes. BGP-1 was designed around the notion of a directional topology, with certain routers being up, down, or horizontal relative to each other; BGP-2 removed this concept, making BGP better suited to an arbitrary AS topology. (Note that the RFC title is not a typo; they didn't put "version 2" in the title.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1267</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>October 1991</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Border Gateway Protocol 3 (BGP-3)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>BGP-3</p></td><td style="border-bottom: 0.5pt solid ; "><p>This version optimized and simplified route information exchange, adding an identification capability to the messages used to establish BGP communications, and incorporating several other improvements and corrections. (They left the "A" off the title of this one for some reason.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1654</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>July 1994</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A Border Gateway Protocol 4 (BGP-4)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>BGP-4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Initial standard for BGP-4, revised in RFC 1771.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>1771</p></td><td style="border-right: 0.5pt solid ; "><p>March 1995</p></td><td style="border-right: 0.5pt solid ; "><p>A Border Gateway Protocol 4 (BGP-4)</p></td><td style="border-right: 0.5pt solid ; "><p>BGP-4</p></td><td style=""><p>Current standard for BGP-4. The primary change in BGP-4 is support for Classless Inter-Domain Routing (CIDR). The protocol was changed to allow prefixes to be specified that represent a set of aggregated networks. Other minor improvements were also made to the protocol.</p></td></tr></tbody></table></div></div><p>As you might imagine, changing the version of a protocol like BGP is not an easy undertaking. Any modification of the protocol would require the coordination of many different organizations. The larger the Internet grows, the more difficult this would be. As a result, despite frequent version changes in the early 1990s, BGP-4 remains today the current version of the standard and is the one that is widely used. Unless otherwise specified, any mention of BGP in this book refers to BGP-4.</p><p>Supplementing RFC 1771 are three other consecutively numbered RFCs published simultaneously with it, which provide supporting information about BGP's functions and use, as shown in <a class="xref" href="ch40.html#additional_defining_standards_for_bgp-" title="Table 40-2. Additional Defining Standards for BGP-4">Table 40-2</a>.</p><div class="table"><a id="additional_defining_standards_for_bgp-"/><p class="title">Table 40-2. Additional Defining Standards for BGP-4</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Additional Defining Standards for BGP-4"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RFC Number</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Name</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1772</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Application of the Border Gateway Protocol in the Internet</p></td><td style="border-bottom: 0.5pt solid ; "><p>Provides additional conceptual information on the operation of BGP and how it is applied to and used on the Internet. This document is sometimes considered a companion of RFC 1771 with the pair defining BGP-4.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1773</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Experience with the BGP-4 Protocol</p></td><td style="border-bottom: 0.5pt solid ; "><p>Describes the experiences of those testing and using BGP-4 and provides information that justified its acceptance as a standard.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>1774</p></td><td style="border-right: 0.5pt solid ; "><p>BGP-4 Protocol Analysis</p></td><td style=""><p>Provides more detailed technical information about the operation of BGP-4.</p></td></tr></tbody></table></div></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-222"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The exterior routing protocol used in modern TCP/IP internetworks is the <span class="emphasis"><em>Border Gateway Protocol (BGP)</em></span>. Initially developed in the late 1980s as a successor to the Exterior Gateway Protocol (EGP), BGP has been revised many times; the current version is 4, so BGP is also commonly called BGP-4. BGP's primary function is the exchange of network reachability information between ASes to allow each AS on an internetwork to send messages efficiently to every other one.</p></div></div><div class="sect2" title="Overview of BGP Functions and Features"><div class="titlepage"><div><div><h2 class="title"><a id="overview_of_bgp_functions_and_features"/>Overview of BGP Functions and Features</h2></div></div></div><p><a class="indexterm" id="idx-CHP-40-1509"/>If I were to summarize the job of BGP in one phrase, it would be to exchange network reachability information between ASes and from this information determine routes to networks. In a typical internetwork (and in the Internet), each AS designates one or more routers that run BGP software. BGP routers in each AS are linked to those in one or more other ASes. Each BGP stores information about networks and the routes to them in a set of Routing Information Bases (RIBs). This route information is exchanged between BGP routers and propagated throughout the entire internetwork, allowing each AS to find paths to each other AS, and thereby enabling routing across the entire internetwork.</p><p>BGP supports an arbitrary topology of ASes, meaning that they can be connected in any manner. An AS must have a minimum of one router running BGP, but can have more than one. It is also possible to use BGP to communicate between BGP routers within the same AS.</p><p>BGP uses a fairly complex system for route determination. The protocol goes beyond the limited notion of considering only the next hop to a network the way distance-vector algorithms like RIP function. Instead, the BGP router stores more complete information about the path (sequence of ASes) from itself to a network. Special path attributes describe the characteristics of paths and are used in the process of route selection. Because of its storage of path information, BGP is sometimes called a <span class="emphasis"><em>path-vector</em></span> protocol.</p><p>BGP chooses routes using a deterministic algorithm that assesses path attributes and chooses an efficient route, while avoiding router loops and other problem conditions. The selection of routes by a BGP router can also be controlled through a set of BGP policies that specify, for example, whether an AS is willing to carry traffic from other ASes. However, BGP cannot guarantee the most efficient route to any destination, because it cannot know what happens within each AS and therefore what the cost is to traverse each AS.</p><p>BGP's operation is based on the exchange of messages that perform different functions. BGP routers use Open messages to contact neighboring routers and establish BGP sessions. They exchange Update messages to communicate information about reachable networks, sending only partial information as needed. They also use Keepalive and Notification messages to maintain sessions and inform peers of error conditions. The use of these messages is explained thoroughly later in this chapter.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-223"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> BGP supports an arbitrary <a class="indexterm" id="idx-CHP-40-1510"/>topology of ASes. Each AS using BGP assigns one or more routers to implement the protocol. These devices then exchange messages to establish contact with each other and share information about rates through the internetwork using the Transmission Control Protocol (TCP). BGP employs a sophisticated path vector route calculation algorithm that determines routes from path attributes that describe how different networks can be reached.</p></div><p>BGP uses the Transmission Control Protocol (TCP) as a reliable transport protocol so that it can take advantage of the many connection setup and maintenance features of that protocol. This also means that BGP doesn't need to worry about issues such as message sequencing, acknowledgments, or lost transmissions. Since unauthorized BGP messages could wreak havoc with the operation of the Internet, BGP includes an authentication scheme for security.</p><div class="note" title="Note"><h3 class="title"><a id="note-113"/>Note</h3><p><span class="emphasis"><em>BGP maintains backward compatibility with the older exterior routing protocol, EGP</em></span>.</p></div></div></div></div>
<div class="sect1" title="BGP Topology"><div class="titlepage"><div><div><h1 class="title"><a id="bgp_topology"/>BGP Topology</h1></div></div></div><p>In the preceding section, I boiled down the function of BGP into this summary: the exchange of network reachability information between ASes of routers and networks, and the determination of routes from this information. The actual method that BGP uses to accomplish this, however, is fairly complex.</p><p>One of the most important characteristics of BGP is its flexibility. The protocol can connect together any internetwork of ASes using an arbitrary topology. The only requirement is that each AS have at least one router that is able to run BGP and that this router connect to at least one other AS's BGP router. Beyond that, "the sky is the limit," as they say. BGP can handle a set of ASes connected in a full mesh topology (each AS to each other AS), a partial mesh, a chain of ASes linked one to the next, or any other configuration. It also handles changes to topology that may occur over time.</p><p>Another important assumption that BGP makes is that it doesn't know anything about what happens within the AS. This is an important prerequisite to the notion of an AS being autonomous—it has its own internal topology and uses its own choice of routing protocols to determine routes. BGP just takes the information conveyed to it from the AS and shares it with other ASes.</p><div class="sect2" title="BGP Speakers, Router Roles, Neighbors, and Peers"><div class="titlepage"><div><div><h2 class="title"><a id="bgp_speakers_router_roles_neighbors_and_"/>BGP Speakers, Router Roles, Neighbors, and Peers</h2></div></div></div><p>Creating a <a class="indexterm" id="idx-CHP-40-1511"/>BGP internetwork begins with the designation of certain <a class="indexterm" id="idx-CHP-40-1512"/>routers in each AS as ones that will run the protocol. In BGP parlance, these are called <span class="emphasis"><em>BGP speakers</em></span><a class="indexterm" id="idx-CHP-40-1513"/>, since they speak the BGP language. A protocol can reasonably be called a language, but I have not encountered this notion of a speaker in any other protocol, so it's somewhat interesting terminology.</p><p>An AS can contain many routers that are connected in an arbitrary topology. We can draw a distinction between routers in an AS that are connected only to other routers within the AS versus those that connect to other ASes. Routers in the former group are usually called <span class="emphasis"><em>internal routers</em></span>, while those in the latter group are called <a class="indexterm" id="idx-CHP-40-1514"/><span class="emphasis"><em>border routers</em></span> in BGP (as well as similar names in other protocols; for example, in OSPF they are called <span class="emphasis"><em>boundary routers</em></span>).</p><p>The notion of a border is the basis for the name of the BGP itself. To actually create the BGP internetwork, the BGP speakers bordering each AS are physically connected to one or more BGP speakers in other ASes, in whatever topology the internetwork designer decrees. When a BGP speaker in one AS is linked to a BGP speaker in another AS, they are deemed <a class="indexterm" id="idx-CHP-40-1515"/><span class="emphasis"><em>neighbors</em></span>. The direct connection between them allows them to exchange information about the ASes of which they are a part.</p><p>Most BGP speakers will be connected to more than one other speaker. This provides both greater efficiency in the form of more direct paths to different networks and redundancy to allow the internetwork to cope with either device or connection failures. It is possible (and in many cases, likely) for a BGP speaker to have neighbor relationships with other BGP speakers both within its own AS and outside its AS. A neighbor within the AS is called an <a class="indexterm" id="idx-CHP-40-1516"/><span class="emphasis"><em>internal peer</em></span>, while a neighbor outside the AS is an <span class="emphasis"><em>external peer</em></span>. BGP between internal peers is sometimes called <a class="indexterm" id="idx-CHP-40-1517"/><span class="emphasis"><em>Internal BGP (IBGP);</em></span><a class="indexterm" id="idx-CHP-40-1518"/> use of the protocol between <a class="indexterm" id="idx-CHP-40-1519"/>external peers is <a class="indexterm" id="idx-CHP-40-1520"/><a class="indexterm" id="idx-CHP-40-1521"/><span class="emphasis"><em>External BGP (EBGP)</em></span>. The two are similar, but differ in certain areas, especially path attributes and route selection. You can see an example of BGP topology and the designation of internal and external peers in <a class="xref" href="ch40s02.html#sample_bgp_topology_and_designations" title="Figure 40-1. Sample BGP topology and designations">Figure 40-1</a>.</p><p>This diagram is a variation on <a class="xref" href="ch37.html#tcpip_autonomous_system_as_routing_archi" title="Figure 37-1. TCP/IP autonomous system (AS) routing architecture This diagram shows a simplified Internet organized into three ASes, each of which is managed independently from the others. Communication within each AS is done using an interior routing protocol chosen by that AS's administrators (thin links). Communication between ASes must be done using a common exterior routing protocol (thick links). Internal routers are shown in lighter text, and border routers are shown in black text.">Figure 37-1</a> in <a class="xref" href="ch37.html" title="Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS">Chapter 37</a>. It shows the names used by BGP to refer to different types of routers and ASes. Internal routers are shown in faint type, while border routers are in bold type. BGP speakers that communicate within an AS are internal peers, while those that communicate between ASes are external peers. This highly simplified internetwork shows two stub ASes, both of which only connect to the multihomed AS 2. A peer connection between BGP speakers can be either a direct link using some form of layer 2 technology or an indirect link using TCP. This allows the BGP speakers to establish BGP sessions and then exchange routing information, using the messaging system you will see later in this chapter. It also is the means by which actual end-user traffic moves between ASes. External peers are normally connected directly, while internal peers are often linked indirectly.</p><p>You will see in a moment that the method in which ASes are connected has an important impact on the overall function of the internetwork and how traffic is carried on it.</p><div class="figure"><a id="sample_bgp_topology_and_designations"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e44132"/><img alt="Sample BGP topology and designations" src="httpatomoreillycomsourcenostarchimages288067.png.jpg"/></div></div><p class="title">Figure 40-1. Sample BGP topology and designations</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-224"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Each router configured to use BGP is called a BGP <span class="emphasis"><em>speaker</em></span>; these devices exchange route information using the BGP <span class="emphasis"><em>messaging system</em></span>. Routers that connect only to other routers in the same AS are called <span class="emphasis"><em>internal routers</em></span>, while those that connect to other ASes are <span class="emphasis"><em>border routers</em></span>. Neighboring BGP speakers in the same AS are called <span class="emphasis"><em>internal peers</em></span>, while those in different ASes are <span class="emphasis"><em>external peers</em></span>.</p></div></div><div class="sect2" title="BGP AS Types, Traffic Flows, and Routing Policies"><div class="titlepage"><div><div><h2 class="title"><a id="bgp_as_types_traffic_flows_and_routing_p"/>BGP AS Types, Traffic Flows, and Routing Policies</h2></div></div></div><p>When we connect ASes together to form an internetwork, the paths between AS border routers form the conduit by which messages move from one AS to another. It is very important that the flow of messages between ASes be carefully controlled. Depending on circumstances, we may wish to limit or even prohibit certain types of messages from going to or from a certain AS. These decisions in turn have a direct impact on BGP route determination.</p><div class="sect3" title="BGP Traffic Flow and Traffic Types"><div class="titlepage"><div><div><h3 class="title"><a id="bgp_traffic_flow_and_traffic_types"/>BGP Traffic Flow and Traffic Types</h3></div></div></div><p><a class="indexterm" id="idx-CHP-40-1522"/>The flow of messages in an internetwork is sometimes collectively called <span class="emphasis"><em>traffic</em></span>. This term presents a good analogy, because we can consider the matter of traffic flow control in a BGP internetwork in much the same way that we do the streets of a city. You have probably seen signs on residential streets that say "No Through Traffic" or "Local Traffic Only." These are attempts to control the flow of traffic over those streets. A more extreme example of this would be a street in the neighborhood where I used to live, where a barricade was intentionally erected in the middle to turn a busy through street into a pair of dead ends. Again, the goal was <a class="indexterm" id="idx-CHP-40-1523"/>traffic control.</p><p>These measures highlight a key distinction between local traffic and through traffic in a neighborhood. The very same categorization is important in BGP, as shown here:</p><p><span class="strong"><strong>Local Traffic</strong></span> Traffic carried within an AS that either originated in that same AS <span class="emphasis"><em>or</em></span> is intended to be delivered within that AS. This is like local traffic on a street.</p><p><span class="strong"><strong>Transit Traffic</strong></span> Traffic that was generated outside that AS and is intended to be delivered outside the AS. This is like through traffic on streets.</p></div><div class="sect3" title="BGP AS Types"><div class="titlepage"><div><div><h3 class="title"><a id="bgp_as_types"/>BGP AS Types</h3></div></div></div><p><a class="indexterm" id="idx-CHP-40-1524"/>In the previous section, I discussed the distinction between internal routers and border (or boundary) routers in an AS. We can make a similar distinction between different types of ASes, based on how they are interconnected in the overall BGP topology. There are two main types of ASes:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-40-1525"/>Stub AS</strong></span> This is an AS that is connected to only one other AS. It is comparable to a cul-de-sac (dead-end street) in a road analogy; usually, only vehicles coming from or going to houses on the street will be found on that street.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-40-1526"/>Multihomed AS</strong></span> This is an AS that is connected to two or more other ASes. It is comparable to a through street in the road analogy, because it is possible that vehicles may enter the street and pass through it, without stopping at any of the street's houses.</p><p>In the example BGP internetwork in <a class="xref" href="ch40s02.html#sample_bgp_topology_and_designations" title="Figure 40-1. Sample BGP topology and designations">Figure 40-1</a>, I have linked border routers in AS 2 to both AS 1 and AS 3. While traffic from AS 2 can flow both to and from AS 1 and AS 3, it is possible that traffic from AS 1 may also flow to AS 3 and vice versa. AS 2 acts as the "through street" for these datagrams.</p></div><div class="sect3" title="BGP AS Routing Policies"><div class="titlepage"><div><div><h3 class="title"><a id="bgp_as_routing_policies"/>BGP AS Routing Policies</h3></div></div></div><p><a class="indexterm" id="idx-CHP-40-1527"/><a class="indexterm" id="idx-CHP-40-1528"/>The reason why BGP makes a distinction between traffic types and AS types is the same reason why it is done on the streets: Many folks have a dim view of through traffic. In a neighborhood, everyone wants to be able to get from their homes to anywhere they need to go in the city, but they don't want a lot of other people using their streets. Similarly, every AS must use at least one other AS to communicate with distant ASes, but many are less than enthusiastic about being a conduit for a lot of external traffic.</p><p>This reluctance really does make sense in many cases, either in the case of a neighborhood or in the case of BGP. Having many cars and trucks on a residential street can be a problem in a number of ways: safety issues, wear and tear on the road, pollution, and so forth. Similarly, if a <a class="indexterm" id="idx-CHP-40-1529"/>multihomed AS was forced to carry all transit traffic that other ASes want to send to it, it might become overloaded.</p><p>To provide control over the carrying of <a class="indexterm" id="idx-CHP-40-1530"/>transit traffic, BGP allows an <a class="indexterm" id="idx-CHP-40-1531"/>AS to set up and use <a class="indexterm" id="idx-CHP-40-1532"/>routing policies. These are sets of rules that govern how an AS will handle transit traffic. A great deal of flexibility exists in how an AS decides to handle transit traffic. Some of the many options include the following:</p><p><span class="strong"><strong>No Transit Policy</strong></span> An AS can have a policy that it will not handle transit traffic at all.</p><p><span class="strong"><strong>Restricted AS Transit Policy</strong></span> An AS may allow for the handling of traffic from certain ASes but not others. In this case, it tells the ASes it will handle that they may send it traffic, but does not say this to the others.</p><p><span class="strong"><strong>Criteria-Based Transit Policy</strong></span> An AS may use a number of different criteria to decide whether to allow transit traffic. For example, it might allow transit traffic only during certain times or only when it has enough spare capacity.</p><div class="note" title="Note"><h3 class="title"><a id="note-114"/>Note</h3><p><span class="emphasis"><em>An AS that is willing to carry transit traffic is sometimes called a</em></span> transit AS.</p></div><p>In a similar manner, policies can be set that control how an AS will have its own traffic handled by other ASes. A stub AS will always connect to the internetwork as a whole using the single AS to which it connects. A multihomed AS, however, may have policies that influence route selection by specifying the conditions under which one AS should be used over another. These policies may be based on considerations of security (if one connecting AS is deemed more secure than another), performance (if one AS is faster than another), reliability, or other factors.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-225"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> One important issue in BGP is how to handle the flow of traffic between ASes. Each AS in a BGP internetwork is either a <span class="emphasis"><em>stub AS</em></span> if it connects to only one other AS, or a <span class="emphasis"><em>multihomed AS</em></span> if it connects to two or more others. BGP allows the administrators of a multihomed AS to establish routing policies that specify under what conditions the AS is willing to handle transit traffic (messages sent over the AS whose source and destination are both external to that AS).</p></div></div><div class="sect3" title="Issues with Routing Policies and Internetwork Design"><div class="titlepage"><div><div><h3 class="title"><a id="issues_with_routing_policies_and_interne"/>Issues with Routing Policies and Internetwork Design</h3></div></div></div><p>What would happen to a city if every street only allowed local traffic? It would be pretty hard to get around. Of course this problem never occurs in well-designed cities, because traffic planners understand the dual need for connectivity and through-traffic avoidance in residential areas. Cities are laid out in a somewhat hierarchical fashion, so local traffic funnels to thoroughfares intended specifically to carry nonlocal traffic.</p><p>The same basic situation exists in an internetwork. It wouldn't work very well if every AS declared that it was not interested in carrying transit traffic! Usually, internetworks are designed so that certain ASes are intended to carry large amounts of transit traffic. This is typically the function of high-speed, high-capacity backbone connections that serve other ASes as customers. An AS will usually carry another AS's traffic only if arrangements have been made to allow this.</p></div></div></div>
<div class="sect1" title="BGP Route Storage and Advertisement"><div class="titlepage"><div><div><h1 class="title"><a id="bgp_route_storage_and_advertisement"/>BGP Route Storage and Advertisement</h1></div></div></div><p>The job of the BGP is to facilitate the exchange of route information between BGP devices so that each router can determine efficient routes to each of the networks on an IP internetwork. This means that descriptions of routes are the key data that BGP devices work with. Every BGP speaker is responsible for managing route descriptions according to specific guidelines established in the BGP standards.</p><div class="sect2" title="BGP Route Information Management Functions"><div class="titlepage"><div><div><h2 class="title"><a id="bgp_route_information_management_functio"/>BGP Route Information Management Functions</h2></div></div></div><p>Conceptually, the overall activity of route information management can be considered to encompass four main tasks:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-40-1533"/>Route Storage</strong></span> Each BGP stores information about how to reach networks in a set of special databases. It also uses databases to hold routing information received from other devices.</p><p><span class="strong"><strong>Route Update</strong></span> When a BGP device receives an Update message from one of its peers, it must decide how to use this information. Special techniques are applied to determine when and how to use the information received from peers to properly update the device's knowledge of routes.</p><p><span class="strong"><strong>Route Selection</strong></span> Each BGP uses the information in its route databases to select good routes to each network on the internetwork.</p><p><span class="strong"><strong>Route Advertisement</strong></span> Each BGP speaker regularly tells its peers what it knows about various networks and methods to reach them. This is called <span class="emphasis"><em>route advertisement</em></span> and is accomplished using BGP Update messages. You'll learn more about these messages later in the chapter.</p></div><div class="sect2" title="BGP Routing Information Bases (RIBs)"><div class="titlepage"><div><div><h2 class="title"><a id="bgp_routing_information_bases_ribs"/>BGP Routing Information Bases (RIBs)</h2></div></div></div><p><a class="indexterm" id="idx-CHP-40-1534"/><a class="indexterm" id="idx-CHP-40-1535"/>The heart of BGP's system of routing information management and handling is the database where routes are stored. This database is collectively called the <span class="emphasis"><em>Routing Information Base (RIB)</em></span>, but it is not actually a monolithic entity. It is composed of three separate sections that are used by a BGP speaker to handle the input and output of routing information. Two of these sections consist of several individual parts, or copies.</p><p>The three RIB sections (using the cryptic names given them by the BGP standards) are as follows:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-40-1536"/>Adj-RIBs-In</strong></span> A set of input database parts that holds information about routes received from peer BGP speakers.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-40-1537"/>Loc-RIB</strong></span> The local RIB. This is the core database that stores routes that have been selected by this BGP device and are considered valid to it.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-40-1538"/>Adj-RIBs-Out</strong></span> A set of output database parts that holds information about routes that this BGP device has selected to be disseminated to its peers.</p><p>Thus, the RIB can be considered either a single database or a set of related databases, depending on how you look at it. (The previous divisions are conceptual in nature; the entire RIB can be implemented as a single database with an internal structure representing the different components, or implemented as separate databases.)</p><p>The RIB is a fairly complex data structure, not just because of this multisection structure, but also because BGP devices store considerably more information about routes than simpler routing protocols. Routes are also called <span class="emphasis"><em>paths</em></span> in BGP, and the detailed descriptions of them are stored in the form of special BGP <a class="indexterm" id="idx-CHP-40-1539"/>path attributes, which we will examine shortly.</p><p>The three sections of the RIB are the mechanism by which information flow is managed in a BGP speaker. Data received from Update messages transmitted by peer BGP speakers is held in the Adj-RIBs-In, with each Adj-RIB-In holding input from one peer. This data is then analyzed and appropriate portions of it are selected to update the Loc-RIB, which is the main database of routes this BGP speaker is using. On a regular basis, information from the Loc-RIB is placed into the Adj-RIBs-Out to be sent to other peers using Update messages. This information flow is accomplished as part of the system of route update, selection, and advertisement known as the BGP decision process, which I'll discuss in the "BGP Route Determination and the BGP Decision Process" section later in this chapter.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-226"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The routine operation of BGP requires BGP speakers to store, update, select, and advertise routing information. The central data structure used for this purpose is the <span class="emphasis"><em>BGP Routing Information Base (RIB)</em></span>. The RIB actually consists of three sections: a set of input databases <span class="emphasis"><em>(Adj-RIBs-In)</em></span> that hold routing information received from peers; a local database <span class="emphasis"><em>(Loc-RIB)</em></span> that contains the router's current routes; and a set of output databases <span class="emphasis"><em>(Adj-RIBs-Out)</em></span> used by the router to send its routing information to other routers.</p></div></div></div>
<div class="sect1" title="BGP Path Attributes and Algorithm Overview"><div class="titlepage"><div><div><h1 class="title"><a id="bgp_path_attributes_and_algorithm_overvi"/>BGP Path Attributes and Algorithm Overview</h1></div></div></div><p><a class="indexterm" id="idx-CHP-40-1540"/>Routing protocols that use a distance-vector algorithm, such as RIP, are relatively simple in large part because the information each device stores about each route is itself simple. Each router only knows that it can reach a network at a specific cost through a particular next-hop router. It doesn't have knowledge of the route that datagrams will take to reach any of these networks. This level of knowledge is simply insufficient for the needs of a protocol like BGP.</p><p>In order to handle the calculation of efficient, nonlooping routes in an arbitrary topology of ASes, we need to know not just that we must get Network N7 to send to Router R4, but also the characteristics of the entire path between ourselves and Network N7. By storing this additional information, it is possible to make decisions about how to compute and change routes, using knowledge of the entire path between a router and a network. Thus, instead of advertising networks in terms of a destination and the distance to that destination, BGP devices advertise networks as destination addresses and path descriptions to reach those destinations. This means BGP uses, instead of a distance-vector algorithm, a <span class="emphasis"><em>path-vector algorithm</em></span>.</p><p>Each communication of a reachable network provides considerable information about the entire sequence of routers to a destination. Due to this inclusion of topology information, path-vector protocols are sometimes described as a combination of distance-vector and link-state algorithms. This doesn't really do them justice, however, since they do not function in the same way as either of those algorithm types. (If you are interested in additional general information about path-vector algorithms, you can find some in RFC 1322, "A Unified Approach to Inter-Domain Routing." (Warning: do not read before operating heavy machinery.)</p><p>The information about the path to each route is stored in the RIB of each BGP speaker in the form of <a class="indexterm" id="idx-CHP-40-1541"/>BGP path attributes. These attributes are used to advertise routes to networks when BGP devices send out Update messages. The storing, processing, sending, and receiving of path attributes is the method by which routers decide how to create routes, so understanding them is obviously quite important.</p><p>There are several different path attributes, each of which describes a particular characteristic of a route. Attributes are divided into different categories based on their level of importance and specific rules designed to manage their propagation. The most important path attributes are called <span class="emphasis"><em>well-known attributes</em></span>; every BGP speaker must recognize and process these, but only some are required to be sent with every route. Other attributes are optional and may or not be implemented. These are further differentiated based on how they are handled when received by a device that does not recognize them.</p><div class="sect2" title="BGP Path Attribute Classes"><div class="titlepage"><div><div><h2 class="title"><a id="bgp_path_attribute_classes"/>BGP Path Attribute Classes</h2></div></div></div><p>The four formal classifications of path attributes are as follows:</p><p><span class="strong"><strong>Well-Known Mandatory</strong></span> These are the most important path attributes. They must be included in every route description in Update messages, and must be processed by each BGP device receiving them.</p><p><span class="strong"><strong>Well-Known Discretionary</strong></span> A BGP device, if received, must recognize these path attributes, but they may or may not be included in an Update message. Thus, they are optional for a sender of information, but mandatory for a receiver to process.</p><p><span class="strong"><strong>Optional Transitive</strong></span> These path attributes may be recognized by a BGP router and may be included in an Update message. They must be passed on to other BGP speakers when the route is advertised, even if received by a device that does not recognize the attribute.</p><p><span class="strong"><strong>Optional Nontransitive</strong></span> Optional attributes that may be recognized by a BGP device and may be included in an Update message. If received by a device that does not recognize the attribute, it is dropped and not passed on to the next router.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-227"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Unlike simpler routing protocols that store only limited information about how to reach a network, BGP stores detailed information about complete routes to various networks. This information takes the form of <span class="emphasis"><em>path attributes</em></span> that describe various characteristics of a path (route) through the ASes that connect a router to a destination network.</p></div><div class="note" title="Note"><h3 class="title"><a id="note-115"/>Note</h3><p><span class="emphasis"><em>As you might imagine, all well-known attributes are by definition transitive—they must be passed on from one BGP speaker to the next</em></span><a class="indexterm" id="idx-CHP-40-1542"/>.</p></div></div><div class="sect2" title="BGP Path Attribute Characteristics"><div class="titlepage"><div><div><h2 class="title"><a id="bgp_path_attribute_characteristics"/>BGP Path Attribute Characteristics</h2></div></div></div><p><a class="xref" href="ch40s04.html#summary_of_bgp_path_attributes" title="Table 40-3. Summary of BGP Path Attributes">Table 40-3</a> provides a summary of the characteristics of each of the most common BGP <a class="indexterm" id="idx-CHP-40-1543"/>path attributes used to describe the route to a destination. It also provides a summary of the Attribute Type code assigned to each characteristic in BGP Update messages.</p><div class="table"><a id="summary_of_bgp_path_attributes"/><p class="title">Table 40-3. Summary of BGP Path Attributes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Summary of BGP Path Attributes"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-40-1544"/>BGP Path Attribute</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Classification</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Attribute Type Value</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Origin</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Well-Known Mandatory</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the origin of the path information. This attribute indicates whether the path came originally from an interior routing protocol, the older exterior routing protocol, or some other source.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>AS_Path</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Well-Known Mandatory</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>A list of AS numbers that describes the sequence of ASes through which this route description has passed. This is a critically important attribute, since it contains the actual path of ASes to the network. It is used to calculate routes and to detect routing loops.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Next_Hop</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Well-Known Mandatory</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-bottom: 0.5pt solid ; "><p>The next-hop router to be used to reach this destination.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Multi_Exit_Disc (MED)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Optional Non-Transitive</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>When a path includes multiple exit or entry points to an AS, this value may be used as a metric to discriminate between them (that is, choose one exit or entry point over the others).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Local_Pref</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Well-Known Discretionary</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used in communication between BGP speakers in the same AS to indicate the level of preference for a particular route.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Atomic_Aggregate</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Well-Known Discretionary</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-bottom: 0.5pt solid ; "><p>In certain circumstances, a BGP speaker may receive a set of overlapping routes whereby one is more specific than the other. For example, consider a route to the network 34.15.67.0/24 and to the network 34.15.67.0/26. The latter network is a subset of the former, which makes it more specific. If the BGP speaker uses the less-specific route (in this case, 34.15.67.0/24), it sets this path attribute to a value of 1 to indicate that this was done.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Aggregator</p></td><td style="border-right: 0.5pt solid ; "><p>Optional Transitive</p></td><td style="border-right: 0.5pt solid ; "><p>7</p></td><td style=""><p>Contains the AS number and BGP ID of the router that performed route aggregation; used for troubleshooting.</p></td></tr></tbody></table></div></div><p>Some of these <a class="indexterm" id="idx-CHP-40-1545"/>path attributes are straightforward; others are fairly cryptic and probably confusing. Delving into any more detail on the path attributes leads us into a full-blown description of detailed inter-AS route calculations. We'll look at that to some degree in the next section.</p></div></div>
<div class="sect1" title="BGP Route Determination and the BGP Decision Process"><div class="titlepage"><div><div><h1 class="title"><a id="bgp_route_determination_and_the_bgp_deci"/>BGP Route Determination and the BGP Decision Process</h1></div></div></div><p><a class="indexterm" id="idx-CHP-40-1546"/><a class="indexterm" id="idx-CHP-40-1547"/>You have now looked at the fundamentals of how BGP devices store and manage information about routes to networks. This included an overview of the four route information management activities performed by BGP speakers: route storage, update, selection, and advertisement. Route storage is the function of the RIB in each BGP speaker. Path attributes are the mechanism by which BGP stores details about routes and also describes those details to BGP peers.</p><div class="sect2" title="BGP Decision Process Phases"><div class="titlepage"><div><div><h2 class="title"><a id="bgp_decision_process_phases"/>BGP Decision Process Phases</h2></div></div></div><p>As you have seen, the RIB also contains sections for holding input information received from BGP peers and for holding output information that each BGP device wants to send to those peers. The functions of route update, selection, and advertisement are concerned with analyzing this input information. They also decide what to include in the local database, update that database, and then choose what routes to send from it to peer devices. In BGP, a mechanism called the <span class="emphasis"><em>decision process</em></span> is responsible for these tasks. It consists of three overall phases:</p><p><span class="strong"><strong>Phase 1</strong></span> Each route received from a BGP speaker in a neighboring AS is analyzed and assigned a preference level. The routes are then ranked according to preference and the best one for each network advertised to other BGP speakers within the AS.</p><p><span class="strong"><strong>Phase 2</strong></span> The best route for each destination is selected from the incoming data based on preference levels, and it's used to update the local routing information base (the Loc-RIB).</p><p><span class="strong"><strong>Phase 3</strong></span> Routes in the Loc-RIB are selected to be sent to neighboring BGP speakers in other ASes.</p></div><div class="sect2" title="Criteria for Assigning Preferences to Routes"><div class="titlepage"><div><div><h2 class="title"><a id="criteria_for_assigning_preferences_to_ro"/>Criteria for Assigning Preferences to Routes</h2></div></div></div><p>Obviously, if a BGP speaker only knows of a single route to a network, it will install and use that route (assuming there are no problems with it). The assigning of preferences among routes becomes important only when more than one route has been received by a BGP speaker for a particular network. Preferences can be determined based on a number of different criteria. The following are a few typical ones:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The number of ASes between the router and the network (fewer generally being better).</p></li><li class="listitem"><p>The existence of certain policies that may make certain routes unusable; for example, a route may pass through an AS that as the BGP speaker is not willing to trust with its data.</p></li><li class="listitem"><p>The origin of the path—that is, where it came from.</p></li></ul></div><p>In the case where a set of routes to the same network are all calculated to have the same preference, a tie-breaking scheme is used to select from among them. Additional logic is used to handle special circumstances, such as the case of overlapping networks (see the description of the Atomic_Aggregate path attribute in <a class="xref" href="ch40s04.html#summary_of_bgp_path_attributes" title="Table 40-3. Summary of BGP Path Attributes">Table 40-3</a> for an example of this).</p><p>The selection of routes for dissemination to other routers in phase 3 is based on a rather complex algorithm that I cannot explain adequately here. Route advertisement is guided by the routing policies I discussed earlier in this chapter. Different rules are used to select routes for advertising to internal peers compared to external peers.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-228"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The method used by a BGP speaker to determine what new routes to accept from its peers and what routes to advertise back them is called the <span class="emphasis"><em>BGP decision process</em></span>. It is a complex algorithm in three phases that involves the computation of the best route based on both preexisting and incoming path information.</p></div></div><div class="sect2" title="Limitations on BGP's Ability to Select Efficient Routes"><div class="titlepage"><div><div><h2 class="title"><a id="limitations_on_bgps_ability_to_select_ef"/>Limitations on BGP's Ability to Select Efficient Routes</h2></div></div></div><p><a class="indexterm" id="idx-CHP-40-1548"/>When considering route selection, it's very important to remember that BGP is a routing protocol that operates at the inter-AS level. Thus, routes are chosen between ASes, not at the level of individual routers within an AS. So, for example, when BGP stores information about the path to a network, it stores it as a sequence of ASes, not a sequence of specific routers.</p><p>BGP cannot deal with individual routers in an AS because, by definition, the details of what happens within an AS are supposed to be hidden from the outside world. It doesn't know the structure of ASes outside its own. This has an important implication for how BGP selects routes: BGP cannot guarantee that it will pick the fastest, lowest-cost route to every network. It can select a route that minimizes the number of ASes that lie between itself and a particular network, but, of course, ASes are not all the same. Some ASes are large and consist of many slow links; others are small and fast. Choosing a route through two of the latter types of AS will be better than choosing a route through one of the former, but BGP can't know that. Policies can be used to influence AS selection to some extent, but in general, since BGP doesn't know what happens in an AS, it cannot guarantee the efficiency of a route overall. (Incidentally, this is the reason why there is no general cost or distance path attribute in BGP.)</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-229"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> As an exterior routing protocol, BGP operates at the AS level. Its routes are calculated based on paths between ASes, not individual routers. Since BGP, by definition, does not know the internal structure of routers within an AS, it cannot know for certain the cost to send a datagram across a given AS. This means that BGP cannot always guarantee that it will select the absolute lowest-cost route between any two networks.</p></div></div><div class="sect2" title="Originating New Routes and Withdrawing Unreachable Routes"><div class="titlepage"><div><div><h2 class="title"><a id="originating_new_routes_and_withdrawing_u"/>Originating New Routes and Withdrawing Unreachable Routes</h2></div></div></div><p>Naturally, a facility exists to allow BGP speakers to originate new routes to networks. A BGP speaker may obtain knowledge about a new route from an interior routing protocol on an AS to which it is directly attached, and then it may choose to share this information with other ASes. It will create a new entry in its RIB for this network and then send information about it out to other BGP peers.</p><p>BGP also includes a mechanism for advertising routes it cannot reach. These are called unfeasible or withdrawn routes and are mentioned in Update messages to indicate that a router can no longer reach the specific network.</p></div></div>
<div class="sect1" title="BGP General Operation and Messaging"><div class="titlepage"><div><div><h1 class="title"><a id="bgp_general_operation_and_messaging"/>BGP General Operation and Messaging</h1></div></div></div><p>In the previous sections, you have seen how BGP stores information about routes and uses it to determine paths to various networks. Let's now take a high-level look at how BGP operates in general terms. Like many other protocols covered in this book, BGP's <a class="indexterm" id="idx-CHP-40-1549"/>operation can be described primarily in the form of <a class="indexterm" id="idx-CHP-40-1550"/>messaging. The use of messages is the means by which route information is communicated between BGP peers. This eventually allows the knowledge of how to reach networks to spread throughout the entire internetwork.</p><div class="sect2" title="Speaker Designation and Connection Establishment"><div class="titlepage"><div><div><h2 class="title"><a id="speaker_designation_and_connection_estab"/>Speaker Designation and Connection Establishment</h2></div></div></div><p><a class="indexterm" id="idx-CHP-40-1551"/>Before messaging can begin, BGP speakers must be designated and then linked together. The BGP standard does not specify how neighboring speakers are determined; this must be done outside the protocol. Once accomplished, ASes are connected into a BGP-enabled internetwork. Topological linking provides the physical connection and the means for datagrams to flow between ASes. At this point, the dance floor is prepared, but nobody is dancing; BGP can function but isn't yet in operation.</p><p>BGP operation begins with BGP peers forming a transport protocol connection. BGP uses TCP for its reliable transport layer, so the two BGP speakers establish a TCP session that remains in place during the course of the subsequent message exchange. When this is done, each BGP speaker sends a BGP Open message. This message is like an invitation to dance, and it begins the process of setting up the BGP link between the devices. In this message, each router identifies itself and its AS, and also tells its peer what parameters it would like to use for the link. This includes an exchange of authentication parameters. Assuming that each device finds the contents of its peer's Open message acceptable, it acknowledges it with a Keepalive message, and the BGP session begins.</p><p>Under normal circumstances, most BGP speakers will maintain simultaneous sessions with more than one other BGP speaker, both within the speaker's own AS and outside its AS. Links between ASes are what enable BGP routers to learn how to route through the internetwork. Links within the AS are important to ensure that each BGP speaker in the AS maintains consistent information.</p></div><div class="sect2" title="Route Information Exchange"><div class="titlepage"><div><div><h2 class="title"><a id="route_information_exchange"/>Route Information Exchange</h2></div></div></div><p><a class="indexterm" id="idx-CHP-40-1552"/>Assuming the link is initialized, the two peers begin an ongoing process of telling each other what they know about networks and how to reach them. Each BGP speaker encodes information from its RIBs into BGP Update messages. These messages contain lists of known network addresses, as well as information about paths to various networks, as described in the form of path attributes, as you have already seen. This information is then used for the route determination, as described in the preceding section.</p><p>When a link is first set up between two peers, those peers ensure that each router holds complete information by exchanging their complete routing tables. Subsequently, Update messages are sent. They contain only incremental updates about routes that have changed. Exchanging only updated information as needed reduces unnecessary bandwidth on the network, thereby making BGP more efficient than it would be if it sent full routing table information on a regular basis.</p></div><div class="sect2" title="Connectivity Maintenance"><div class="titlepage"><div><div><h2 class="title"><a id="connectivity_maintenance"/>Connectivity Maintenance</h2></div></div></div><p>The TCP session between BGP speakers can be kept open for a very long time. Update messages need to be sent only when changes occur to routes, which are usually infrequent. This means many seconds may elapse between the transmission of Update messages.</p><p>To ensure that the peers maintain contact with each other, they both send Keepalive messages on a regular basis when they don't have other information to send. These are null messages that contain no data and just tell the peer device "I'm still here." These messages are sent infrequently—no more often than one per second—but regularly enough that the peers won't think the session was interrupted.</p></div><div class="sect2" title="Error Reporting"><div class="titlepage"><div><div><h2 class="title"><a id="error_reporting"/>Error Reporting</h2></div></div></div><p><a class="indexterm" id="idx-CHP-40-1553"/>The last type of BGP message is the BGP Notification message. This is an error message; it tells a peer that a problem occurred and describes the nature of the error condition. After sending a BGP Notification message, the device that sent it will terminate the BGP connection between the peers. A new connection will then need to be negotiated, possibly after the problem that led to the Notification message has been corrected.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-230"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> BGP is implemented through the exchange of four different message types between BGP speakers. A BGP session begins with a TCP connection being established between two routers and each sending an Open message to the other. BGP Update messages are the primary mechanism by which routing information is exchanged between devices. Small BGP Keepalive messages are used to maintain communication between devices between periods when they need to exchange information. Finally, Notification messages are used for problem reporting.</p></div></div></div>
<div class="sect1" title="BGP Detailed Messaging, Operation, and Message Formats"><div class="titlepage"><div><div><h1 class="title"><a id="bgp_detailed_messaging_operation_and_mes"/>BGP Detailed Messaging, Operation, and Message Formats</h1></div></div></div><p><a class="indexterm" id="idx-CHP-40-1554"/>So far, I have discussed the concepts and general operation of the BGP. To get a better understanding of exactly how BGP works, it is helpful to take a detailed look at its four different message types—Open, Update, Keepalive, and Notification—and how they are used. As we do this, we can examine the fields in each message type, so that you can comprehend not just the way that messaging is accomplished, but the way that routing data is actually communicated. Let's begin with a description of common attributes of BGP <a class="indexterm" id="idx-CHP-40-1555"/>message generation and transport, and the general format used for all BGP messages.</p><div class="sect2" title="BGP Message Generation and Transport"><div class="titlepage"><div><div><h2 class="title"><a id="bgp_message_generation_and_transport"/>BGP Message Generation and Transport</h2></div></div></div><p>Each router running BGP generates messages to implement the various functions of the protocol. Some of these messages are created on a regular basis by the BGP software during the course of its normal operation. These are generally controlled by timers that are set and counted down to cause them to be sent. Other messages are sent in response to messages received from BGP peers, possibly after a processing step.</p><p>BGP is different from most other routing protocols in that it was designed from the start to operate using a reliable method of message delivery. TCP is present in the software of every Internet Protocol (IP) router, thereby making it the obvious choice for reliable data communication in a TCP/IP Internet, and that's what BGP uses. Routing protocols are usually considered part of layer 3, but this one runs over a layer 4 protocol, thereby making BGP a good example of why architectural models are best used only as a guideline.</p><p>TCP provides numerous advantages to BGP by taking care of most of the details of session setup and management, thereby allowing BGP to focus on the data it needs to send. TCP takes care of session setup and negotiation, flow control, congestion handling, and any necessary retransmissions of lost messages, thereby ensuring that messages are received and acknowledged. BGP uses well-known TCP port 179 for connections.</p></div><div class="sect2" title="BGP General Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="bgp_general_message_format"/>BGP General Message Format</h2></div></div></div><p>The use of TCP also has an interesting impact on the way BGP messages are structured. One thing that stands out when you look at the BGP message format (as you will see shortly) is that a BGP message can have an odd number of bytes. Most routing protocols are sized in units of 4 or 8 bytes, but since TCP sends data as a stream of octets, there is no need for BGP messages to break on a 32-bit or 64-bit boundary. The other impact is the need of a special Marker field to help ensure that BGP messages can be differentiated from each other in the TCP stream (more about this in a moment).</p><p>Like most messaging protocols, BGP uses a common message format for each of its four message types. Each BGP message is conceptually divided into a header and a body (called the <span class="emphasis"><em>data portion</em></span> in the BGP standard). The header has three fields and is fixed in length at 19 bytes. The body is variable in length and is omitted entirely in Keepalive messages, since it is not needed for them.</p><p>The <a class="indexterm" id="idx-CHP-40-1556"/>general format for all BGP message types is shown in <a class="xref" href="ch40s07.html#bgp_general_message_format-id001" title="Table 40-4. BGP General Message Format">Table 40-4</a> and illustrated in <a class="xref" href="ch40s07.html#bgp_general_message_format-id002" title="Figure 40-2. BGP general message format">Figure 40-2</a>.</p><div class="table"><a id="bgp_general_message_format-id001"/><p class="title">Table 40-4. BGP General Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="BGP General Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Marker</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>This large field at the start of each BGP message is used for synchronization and authentication.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The total length of the message in bytes, including the fields of the header. The minimum value of this field is 19 for a Keepalive message; it may be as high as 4096.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Indicates the BGP message type:</p>
<p>1 = Open</p>
<p>2 = Update</p>
<p>3 = Notification</p>
<p>4 = Keepalive</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Message Body/Data Portion</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Contains the specific fields used to implement each message type for Open, Update, and Notification messages.</p></td></tr></tbody></table></div></div><div class="figure"><a id="bgp_general_message_format-id002"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e44896"/><img alt="BGP general message format" src="httpatomoreillycomsourcenostarchimages288069.png"/></div></div><p class="title">Figure 40-2. BGP general message format</p></div><p>The <a class="indexterm" id="idx-CHP-40-1557"/>Marker field is the most interesting one in the BGP message format. It is used for both synchronization and authentication. BGP uses a single TCP session to send many messages in a row. TCP is a stream-oriented transport protocol that sends bytes across the link without any knowledge of what the bytes represent. This means that the protocol using TCP is responsible for deciding where the line is drawn between data units—in this case, BGP messages.</p><p>Normally, the Length field tells each BGP device where to draw the line between the end of one message and the start of the next. However, it is possible that, due to various conditions, a device might lose track of where the message boundary is. The Marker field is filled with a recognizable pattern that clearly marks the start of each message; BGP peers keep synchronized by looking for that pattern.</p><p>Before a BGP connection is established, the Marker field is filled with all ones. Thus, this is the pattern used for Open messages. Once a BGP session is negotiated, if agreement is reached on an authentication method between the two devices, the Marker field takes on the additional role of authentication. Instead of looking for a Marker field containing all ones, BGP devices look for a pattern generated using the agreed-upon authentication method. Detection of this pattern simultaneously synchronizes the devices and ensures that messages are authentic.</p><p>In extreme cases, BGP peers may be unable to maintain synchronization, and if so, a Notification message is generated and the session is closed. This will also happen if the Marker field contains the wrong data when authentication is enabled.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-231"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> All four BGP message types use a <a class="indexterm" id="idx-CHP-40-1558"/>general message format that contains three fixed header fields—Marker, Length, and Type—and room for a message body that differs for each message type. The large Marker field is used to denote the start of a new BGP message, and it is also used to facilitate the BGP authentication method.</p></div></div><div class="sect2" title="BGP Connection Establishment: Open Messages"><div class="titlepage"><div><div><h2 class="title"><a id="bgp_connection_establishment_open_messag"/>BGP Connection Establishment: Open Messages</h2></div></div></div><p>Before a BGP session can be used to exchange routing information, a connection must first be established between BGP peers. This process begins with the creation of a TCP connection between the devices. Once this is done, the BGP devices will attempt to create a BGP session by exchanging BGP <a class="indexterm" id="idx-CHP-40-1559"/>Open messages.</p><div class="sect3" title="BGP Open Message Functions"><div class="titlepage"><div><div><h3 class="title"><a id="bgp_open_message_functions"/>BGP Open Message Functions</h3></div></div></div><p><a class="indexterm" id="idx-CHP-40-1560"/>The Open message has two main purposes. The first is identification and initiation of a link between the two devices; it allows one peer to tell the other, "I am a BGP speaker named X on AS Y, and I want to start exchanging BGP information with you." The second is the negotiation of session parameters. These are the terms by which the BGP session will be conducted. One important parameter negotiated using Open messages is the method that each device wants to use for authentication. The importance of BGP means that authentication is essential in order to prevent bad information or a malicious person from disrupting routes.</p><p>Each BGP receiving an Open message processes it. If the message's contents are acceptable, including the parameters the other device wants to use, it responds with a Keepalive message as an acknowledgment. Each peer must send an Open message and receive a Keepalive acknowledgment for the BGP link to be initialized. If either is not willing to accept the terms of the Open message, the link is not established. In that case, a Notification message may be sent to convey the nature of the problem.</p></div><div class="sect3" title="BGP Open Message Format"><div class="titlepage"><div><div><h3 class="title"><a id="bgp_open_message_format"/>BGP Open Message Format</h3></div></div></div><p>The specific format for BGP Open messages is shown in <a class="xref" href="ch40s07.html#bgp_open_message_format-id001" title="Table 40-5. BGP Open Message Format">Table 40-5</a> and <a class="xref" href="ch40s07.html#bgp_open_message_format-id002" title="Figure 40-3. BGP Open message format">Figure 40-3</a>.</p><div class="table"><a id="bgp_open_message_format-id001"/><p class="title">Table 40-5. BGP Open Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="BGP Open Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Marker</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>This large field at the start of each BGP message is used for synchronization and authentication.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The total length of the message in bytes, including the fields of the header. Open messages are variable in length.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>BGP message type; value is 1 for Open messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Version</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Indicates the BGP version the sender of the Open message is using. This field allows devices to reject connections with devices using versions that they may not be capable of understanding. The current value is 4, for BGP-4, and is used by most, if not all, current BGP implementations.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>My Autonomous System</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the AS number of the sender of the Open message. AS numbers are centrally managed across the Internet in a manner similar to how IP addresses are administered.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Hold Time</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The number of seconds that this device proposes to use for the BGP hold timer, which specifies how long a BGP peer will allow the connection to be left silent between receipt of BGP messages. A BGP device may refuse a connection if it doesn't like the value that its peer is suggesting; usually, however, the two devices agree to use the smaller of the values suggested by each device. The value must be at least 3 seconds, or 0. If 0, this specifies that the hold timer is not used. See the Keepalive message discussion later in this chapter for more on how the hold timer is used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>BGP Identifier</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Identifies the specific BGP speaker. You'll recall that IP addresses are associated with interfaces, not devices, so each router will have at least two IP addresses. Normally, the BGP identifier is chosen as one of these addresses. Once chosen, this identifier is used for all BGP communications with BGP peers. This includes BGP peers on the interface from which the identifier was chosen, and also BGP peers on other interfaces as well. So, if a BGP speaker with two interfaces has addresses IP1 and IP2, it will choose one as its identifier and use it on both of its interfaces.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Opt Parm Len</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>The number of bytes used for Optional Parameters (see the following entry). If 0, no optional parameters are in this message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Optional Parameters</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Allows the <a class="indexterm" id="idx-CHP-40-1561"/>Open message to communicate any number of extra parameters during BGP session setup. Each parameter is encoded using a rather standard type/length/value triple, as shown in <a class="xref" href="ch40s07.html#bgp_open_message_optional_parameters" title="Table 40-6. BGP Open Message Optional Parameters">Table 40-6</a>.</p></td></tr></tbody></table></div></div><div class="table"><a id="bgp_open_message_optional_parameters"/><p class="title">Table 40-6. BGP Open Message Optional Parameters</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="BGP Open Message Optional Parameters"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Parm Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Parameter Type: The type of the optional parameter. At present, only one value is defined, 1, for Authentication Information.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Parm Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Parameter Length: Specifies the length of the Parameter Value subfield (thus, this value is the length of the entire parameter, less 2).</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Parm Value</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Parameter Value: The value of the parameter being communicated.</p></td></tr></tbody></table></div></div><p>BGP Open messages currently use only one optional parameter: Authentication Information. Its Parameter Value subfield contains a one-byte Authentication Code sub-subfield, which specifies the type of authentication a device wishes to use. Following this is a variable-length Authentication Data sub-subfield. The Authentication Code specifies how authentication is to be performed, including the meaning of the Authentication Data field, and the manner in which Marker fields are to be calculated.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-232"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> BGP sessions begin with each peer in a connection sending the other a BGP Open message. The purpose of this message is to establish contact between devices, identify the sender of the message and its AS, and negotiate important parameters that dictate how the session will be conducted.</p></div></div></div><div class="sect2" title="BGP Route Information Exchange: Update Messages"><div class="titlepage"><div><div><h2 class="title"><a id="bgp_route_information_exchange_update_me"/>BGP Route Information Exchange: Update Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-40-1562"/>Once BGP speakers have made contact and a link has been established using Open messages, the devices begin the actual process of exchanging routing information. Each BGP router uses the BGP decision process described earlier in this chapter to select certain routes to be advertised to its peer. This information is then placed into BGP Update messages, which are sent to every BGP device for which a session has been established. These messages are the way that network reachability knowledge is propagated around the internetwork.</p><div class="figure"><a id="bgp_open_message_format-id002"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e45154"/><img alt="BGP Open message format" src="httpatomoreillycomsourcenostarchimages288071.png"/></div></div><p class="title">Figure 40-3. BGP Open message format</p></div><div class="sect3" title="BGP Update Message Contents"><div class="titlepage"><div><div><h3 class="title"><a id="bgp_update_message_contents"/>BGP Update Message Contents</h3></div></div></div><p>Each <a class="indexterm" id="idx-CHP-40-1563"/>Update message contains either one or both of the following:</p><p><span class="strong"><strong>Route Advertisement</strong></span> The characteristics of a single route.</p><p><span class="strong"><strong>Route Withdrawal</strong></span> A list of networks that are no longer reachable.</p><p>Only one route can be advertised in an Update message, but several can be withdrawn. This is because withdrawing a route is simple; it requires just the address of the network for which the route is being removed. In contrast, a route advertisement requires a fairly complex set of path attributes to be described, which takes up a significant amount of space. (Note that it is possible for an Update message to specify only withdrawn routes and not advertise a route at all.)</p></div><div class="sect3" title="BGP Update Message Format"><div class="titlepage"><div><div><h3 class="title"><a id="bgp_update_message_format"/>BGP Update Message Format</h3></div></div></div><p>Because of the amount of information it contains and the complexity of that information, BGP Update messages use one of the most complicated structures in TCP/IP. The basic structure of the message is described in <a class="xref" href="ch40s07.html#bgp_update_message_format-id001" title="Table 40-7. BGP Update Message Format">Table 40-7</a> and illustrated in <a class="xref" href="ch40s07.html#bgp_update_message_format_this_diagram_s" title="Figure 40-4. BGP Update message format This diagram shows the complete BGP Update message format, including a set of withdrawn routes, path attributes, and NLRI entries. The exploded view shows the substructure of the Attribute Type subfield of the Path Attributes, as described in Tables Table 40-9 and Table 40-10.">Figure 40-4</a>. As you can see in that table, several of the fields have their own substructure. The Path Attributes field has a complex substructure, which I have shown separately in other tables.</p><div class="table"><a id="bgp_update_message_format-id001"/><p class="title">Table 40-7. BGP Update Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="BGP Update Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Marker</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>This large field at the start of each BGP message is used for synchronization and authentication.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The total length of the message in bytes, including the fields of the header. <a class="indexterm" id="idx-CHP-40-1564"/>Update messages are variable in length.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>BGP message type; value is 2 for Update messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unfeasible Routes Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The length of the Withdrawn Routes field, in bytes. If 0, no routes are being withdrawn and the Withdrawn Routes field is omitted.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Withdrawn Routes</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the addresses of networks for which routes are being withdrawn from use. Each address is specified using the two subfields. The 1-byte Length field is the number of bits in the IP address Prefix subfield that are significant. The variable-length Prefix subfield is the IP address prefix of the network whose route is being withdrawn. If the number of bits in the prefix is not a multiple of 8, this field is padded with zeros so that it falls on a byte boundary. The length of this field is 1 byte if the preceding Length field is 8 or less; 2 bytes if it is 9 to 16; 3 bytes if it is 17 to 24; and 4 bytes if it is 25 or greater.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Total Path Attribute Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The length of the Path Attributes field, in bytes. If 0, indicates no route is being advertised in this message, so Path Attributes and Network Layer Reachability Information are omitted.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Path Attributes</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Describes the path attributes of the route advertised. Since some attributes require more information than others, attributes are described using a flexible structure that minimizes message size compared to using fixed fields that would often be empty. Unfortunately, it also makes the field structure confusing. Each attribute has the subfields shown in <a class="xref" href="ch40s07.html#bgp_update_message_path_attributes" title="Table 40-8. BGP Update Message Path Attributes">Table 40-8</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Network Layer Reachability Information (NLRI)</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Contains a list of IP address prefixes for the route being advertised. Each address is specified using the same general structure as the one used for Withdrawn Routes. The 1-byte Length subfield is the number of bits in the Prefix subfield that are significant. The variable-length Prefix subfield is the IP address prefix of the network whose route is being advertised. If the number of bits in the prefix is not a multiple of 8, this field is padded with zeros so that it falls on a byte boundary. The length of this field is 1 byte if the preceding Length field is 8 or less; 2 bytes if it is 9 to 16; 3 bytes if it is 17 to 24; and 4 bytes if it is25 or greater. Unlike most of the other fields in the Update message, the length of the NLRI field is not explicitly stated. It is computed from the overall message Length field, minus the lengths of the other fields that are explicitly specified.</p></td></tr></tbody></table></div></div><div class="table"><a id="bgp_update_message_path_attributes"/><p class="title">Table 40-8. BGP Update Message Path Attributes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="BGP Update Message Path Attributes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Attribute Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Defines the type of attribute and describes it. This subfield itself has a two-level substructure, with Attribute Type flags and Attribute Type codes, so it won't even fit it here! See Tables <a class="xref" href="ch40s07.html#bgp_update_message_attribute_flags" title="Table 40-9. BGP Update Message Attribute Flags">Table 40-9</a> and <a class="xref" href="ch40s07.html#bgp_update_message_attribute_type_codes" title="Table 40-10. BGP Update Message Attribute Type Codes">Table 40-10</a> for details.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Attribute Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1 or 2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The length of the attribute in bytes. This field is normally 1 byte, thereby allowing for fields with a length up to 255 bytes. For longer attributes, the Extended Length flag is set (see <a class="xref" href="ch40s07.html#bgp_update_message_attribute_flags" title="Table 40-9. BGP Update Message Attribute Flags">Table 40-9</a>), indicating that this Attribute Length field is 2 bytes, for attributes up to 65,535 bytes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Attribute Value</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>The value of the attribute. The size and meaning of this field depends on the type of path attribute. For example, for an Origin attribute, it is a single integer value indicating the origin of the route; for an AS_Path attribute, this field contains a variable-length list of the ASes in the path to the network.</p></td></tr></tbody></table></div></div><div class="figure"><a id="bgp_update_message_format_this_diagram_s"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e45362"/><img alt="BGP Update message format This diagram shows the complete BGP Update message format, including a set of withdrawn routes, path attributes, and NLRI entries. The exploded view shows the substructure of the Attribute Type subfield of the Path Attributes, as described in Tables and ." src="httpatomoreillycomsourcenostarchimages288073.png.jpg"/></div></div><p class="title">Figure 40-4. BGP Update message format This diagram shows the complete BGP Update message format, including a set of withdrawn routes, path attributes, and NLRI entries. The exploded view shows the substructure of the Attribute Type subfield of the Path Attributes, as described in Tables <a class="xref" href="ch40s07.html#bgp_update_message_attribute_flags" title="Table 40-9. BGP Update Message Attribute Flags">Table 40-9</a> and <a class="xref" href="ch40s07.html#bgp_update_message_attribute_type_codes" title="Table 40-10. BGP Update Message Attribute Type Codes">Table 40-10</a>.</p></div><p><a class="xref" href="ch40s07.html#bgp_update_message_attribute_flags" title="Table 40-9. BGP Update Message Attribute Flags">Table 40-9</a> shows the structure of the Attribute Flags sub-subfield of the Attribute Type subfield of the Path Attributes field. This subfield contains a set of flags that describe the nature of the attribute and how to process it. You may need to refer to the path attributes description in the "BGP Path Attributes and Algorithm Overview" section earlier in this chapter to make sense of these flags.</p><div class="table"><a id="bgp_update_message_attribute_flags"/><p class="title">Table 40-9. BGP Update Message Attribute Flags</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="BGP Update Message Attribute Flags"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-40-1565"/>Sub-Sub-Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Optional</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Set to 1 for optional attributes; 0 for well-known attributes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Transitive</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Set to 1 for optional transitive attributes; 0 for optional nontransitive attributes. Always set to 1 for well-known attributes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Partial</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>When 1, indicates that information about an optional transitive attribute is partial. This means that since it was optional and transitive, one or more of the routers that passed the path along did not implement that attribute but was forced to pass it along, so information about it may be missing (not supplied by the routers that didn't recognize it but just passed along). If 0, it means information is complete. This bit has meaning only for optional transitive attributes; for well-known or nontransitive attributes, it is 0.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Extended Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1/8 (1 bit)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Set to 1 for long attributes to indicate that the Attribute Length field is 2 bytes in size. Normally 0, meaning the Attribute Length field is a single byte.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; "><p>4/8 (4 bits)</p></td><td style=""><p>Set to 0 and ignored.</p></td></tr></tbody></table></div></div><p>The Attribute Type Code sub-subfield of the Attribute Type subfield of the Path Attributes field contains a number that identifies the attribute type. <a class="xref" href="ch40s07.html#bgp_update_message_attribute_type_codes" title="Table 40-10. BGP Update Message Attribute Type Codes">Table 40-10</a> shows the current values.</p><div class="table"><a id="bgp_update_message_attribute_type_codes"/><p class="title">Table 40-10. BGP Update Message Attribute Type Codes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="BGP Update Message Attribute Type Codes"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-40-1566"/>Value</p></th><th style="border-bottom: 0.5pt solid ; "><p>Attribute Type</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Origin</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>AS_Path</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-bottom: 0.5pt solid ; "><p>Next_Hop</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Multi_Exit_Disc (MED)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-bottom: 0.5pt solid ; "><p>Local_Pref</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-bottom: 0.5pt solid ; "><p>Atomic_Aggregate</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>7</p></td><td style=""><p>Aggregator</p></td></tr></tbody></table></div></div><p>It may seem confusing that there can be more than one prefix in the Network Layer Reachability Information (NLRI) field, even though I said earlier that an Update message advertises only one route. There is, in fact, no inconsistency here. A single route may be associated with more than one networks; to put it another way, multiple networks may have the same path and path attributes. In that case, specifying multiple network prefixes in the same Update message is more efficient than generating a new one for each network.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-233"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The most important message type in BGP is the Update message, which is used to send detailed information about routes between BGP devices. It uses a complex structure that allows a BGP speaker to efficiently specify new routes, update existing ones, and withdraw routes that are no longer valid. Each message may include the full description of one existing route and may also withdraw from use a list of multiple routes.</p></div></div></div><div class="sect2" title="BGP Connectivity Maintenance: Keepalive Messages"><div class="titlepage"><div><div><h2 class="title"><a id="bgp_connectivity_maintenance_keepalive_m"/>BGP Connectivity Maintenance: Keepalive Messages</h2></div></div></div><p>Once a <a class="indexterm" id="idx-CHP-40-1567"/>BGP connection is established using Open messages, BGP peers will initially use Update messages to send each other a large amount of routing information. They will then settle into a routine in which the BGP session is maintained, but Update messages are sent only when needed. Since these updates correspond to route changes, and route changes are normally infrequent, this means many seconds may elapse between the receipt of consecutive Update messages.</p><div class="sect3" title="The BGP Keepalive Message Interval"><div class="titlepage"><div><div><h3 class="title"><a id="the_bgp_keepalive_message_interval"/>The BGP Keepalive Message Interval</h3></div></div></div><p><a class="indexterm" id="idx-CHP-40-1568"/>Hold Timer and <a class="indexterm" id="idx-CHP-40-1569"/>While a BGP peer is waiting to hear the next Update message, it remains sort of like a person who has been put on hold on the telephone. Now seconds may not seem like much to us, but to a computer, they are a very long time. Like you, a BGP speaker that is put on hold for too long might become impatient and might start to wonder if maybe the other guy hung up. Computers don't get offended at being put on hold, but they might wonder if perhaps a problem arose that led to the connection being interrupted.</p><p>To keep track of how long it has been on hold, each BGP device maintains a special <a class="indexterm" id="idx-CHP-40-1570"/><span class="emphasis"><em>hold timer</em></span>. This hold timer is set to an initial value each time its peer sends a BGP message. The timer then counts down until the next message is received, and then it is reset. If the hold timer ever expires, the connection is assumed to have been interrupted and the BGP session is terminated.</p><p>The length of the hold timer is negotiated as part of session setup using Open messages. It must be at least three seconds long, or may be negotiated as a value of zero. If zero, the hold timer is not used; this means the devices are infinitely patient and don't care how much time elapses between messages.</p><p>To ensure that the timer doesn't expire even when no Update messages need to be sent for a long while, each peer periodically sends a BGP Keepalive message. The name says it all: The message just keeps the BGP connection alive. The rate at which Keepalive messages is sent depends on the implementation, but the standard recommends that they be sent with an interval of one-third the value of the hold timer. So if the hold timer has a value of three seconds, each peer sends a Keepalive message every second (unless it needs to send some other message type in that second). To prevent excess bandwidth use, Keepalive messages must be sent no more often than once per second, so that is the minimum interval, even if the hold timer is shorter than three seconds.</p></div><div class="sect3" title="BGP Keepalive Message Format"><div class="titlepage"><div><div><h3 class="title"><a id="bgp_keepalive_message_format"/>BGP Keepalive Message Format</h3></div></div></div><p>The point of a Keepalive message is the message itself; there's no data to be communicated. In fact, we want to keep the message short and sweet. Thus, it is really a dummy message that contains only a BGP header—a nice change after that incredibly long Update message format!  The format of the Keepalive message is shown in <a class="xref" href="ch40s07.html#bgp_keepalive_message_format-id001" title="Table 40-11. BGP Keepalive Message Format">Table 40-11</a> and <a class="xref" href="ch40s07.html#bgp_keepalive_message_format-id002" title="Figure 40-5. BGP Keepalive message format">Figure 40-5</a>.</p><div class="table"><a id="bgp_keepalive_message_format-id001"/><p class="title">Table 40-11. BGP Keepalive Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="BGP Keepalive Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Marker</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>This large field at the start of each <a class="indexterm" id="idx-CHP-40-1571"/>BGP message is used for synchronization and authentication.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The total length of the message in bytes, including the fields of the header. <a class="indexterm" id="idx-CHP-40-1572"/>Keepalive messages are fixed in length at 19 bytes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style=""><p>BGP message type; value is 4 for <a class="indexterm" id="idx-CHP-40-1573"/>Keepalive messages.</p></td></tr></tbody></table></div></div><div class="figure"><a id="bgp_keepalive_message_format-id002"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e45652"/><img alt="BGP Keepalive message format" src="httpatomoreillycomsourcenostarchimages288075.png"/></div></div><p class="title">Figure 40-5. BGP Keepalive message format</p></div><p>There is also a special use for Keepalive messages: They acknowledge the receipt of a valid Open message during the initial BGP session setup.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-234"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> BGP Keepalive messages are sent periodically during idle periods when no real information needs to be sent between connected BGP speakers. They serve only to keep the session alive, and thus contain only a BGP header and no data.</p></div></div></div><div class="sect2" title="BGP Error Reporting: Notification Messages"><div class="titlepage"><div><div><h2 class="title"><a id="bgp_error_reporting_notification_message"/>BGP Error Reporting: Notification Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-40-1574"/><a class="indexterm" id="idx-CHP-40-1575"/>Once established, a BGP session will remain open for a considerable period of time, allowing routing information to be exchanged between devices on a regular basis. During the course of operation, certain error conditions may crop up that may interfere with normal communication between BGP peers.</p><div class="sect3" title="BGP Notification Message Functions"><div class="titlepage"><div><div><h3 class="title"><a id="bgp_notification_message_functions"/>BGP Notification Message Functions</h3></div></div></div><p>Some of the error conditions that arise are serious enough that the BGP session must be terminated. When this occurs, the device detecting the error will inform its peer of the nature of the problem by sending it a BGP Notification message, and then it will close the connection.</p><p>Of course, having someone tell you, "I found an error, so I quit" is not of much value. Therefore, the BGP Notification message contains a number of fields that provide information about the nature of the error that caused the message to be sent. This includes a set of primary error codes as well as subcodes within some of these error codes. Depending on the nature of the error, an additional data field may also be included to aid in diagnosing the problem.</p><p>In addition to the use of <a class="indexterm" id="idx-CHP-40-1576"/>Notification messages to convey the occurrence of an error, this message type is also used for other purposes. For example, one may be sent if two devices cannot agree on how to negotiate a session, which isn't, strictly speaking, an error. A <a class="indexterm" id="idx-CHP-40-1577"/>Notification message is also used to allow a device to tear down a BGP session for reasons that have nothing to do with an error.</p></div><div class="sect3" title="BGP Notification Message Format"><div class="titlepage"><div><div><h3 class="title"><a id="bgp_notification_message_format"/>BGP Notification Message Format</h3></div></div></div><p>The format for the BGP Notification messages is detailed in <a class="xref" href="ch40s07.html#bgp_notification_message_format-id001" title="Table 40-12. BGP Notification Message Format">Table 40-12</a> and illustrated in <a class="xref" href="ch40s07.html#bgp_notification_message_format-id002" title="Figure 40-6. BGP Notification message format">Figure 40-6</a>.</p><div class="table"><a id="bgp_notification_message_format-id001"/><p class="title">Table 40-12. BGP Notification Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="BGP Notification Message Format"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Marker</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>This large field at the start of each BGP message is used for synchronization and authentication.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Length</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The total length of the message in bytes, including the fields of the header. Notification messages are variable in length.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>BGP message type; value is 3 for Notification messages.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Error Code</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specifies the general class of the error. <a class="xref" href="ch40s07.html#bgp_notification_message_error_codes" title="Table 40-13. BGP Notification Message Error Codes">Table 40-13</a> shows the possible error types with a brief description of each.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Error Subcode</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Provides a more specific indication of the cause of the error for three of the Error Code values. The possible values of this field for each Error Code value are shown in <a class="xref" href="ch40s07.html#bgp_notification_message_error_subcodes" title="Table 40-14. BGP Notification Message Error Subcodes">Table 40-14</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Data</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Contains additional information to help diagnose the error. Its meaning depends on the type of error specified in the Error Code and Error Subcode fields. In most cases, this field is filled in with whatever bad value caused the error to occur. For example, for "Message Header Error / Bad Message Type," the value of the bad Type field is placed here.</p></td></tr></tbody></table></div></div><div class="figure"><a id="bgp_notification_message_format-id002"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e45799"/><img alt="BGP Notification message format" src="httpatomoreillycomsourcenostarchimages288077.png"/></div></div><p class="title">Figure 40-6. BGP Notification message format</p></div><p>Tables <a class="xref" href="ch40s07.html#bgp_notification_message_error_codes" title="Table 40-13. BGP Notification Message Error Codes">Table 40-13</a> and <a class="xref" href="ch40s07.html#bgp_notification_message_error_subcodes" title="Table 40-14. BGP Notification Message Error Subcodes">Table 40-14</a> show the values permitted for the Error Code and Error Subcode fields, respectively, and thus provide a good summary of the types of errors that <a class="indexterm" id="idx-CHP-40-1578"/>Notification messages can report. They also demonstrate the other nonerror uses of the message type.</p><div class="table"><a id="bgp_notification_message_error_codes"/><p class="title">Table 40-13. BGP Notification Message Error Codes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="BGP Notification Message Error Codes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Error Code Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Code Name</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Message Header Error</p></td><td style="border-bottom: 0.5pt solid ; "><p>A problem was detected either with the contents or length of the BGP header. The Error Subcode field provides more details on the nature of the problem.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Open Message Error</p></td><td style="border-bottom: 0.5pt solid ; "><p>A problem was found in the body of an Open message. The Error Subcode field describes the problem in more detail. Note that authentication failures or the inability to agree on a parameter such as hold time are included here.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Update Message Error</p></td><td style="border-bottom: 0.5pt solid ; "><p>A problem was found in the body of an Update message. Again, the Error Subcode field provides more information. Many of the problems that fall under this code are related to issues detected in the routing data or path attributes sent in the Update message, so these messages provide feedback about such problems to the device sending the erroneous data.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Hold Timer Expired</p></td><td style="border-bottom: 0.5pt solid ; "><p>A message was not received before the hold time expired. See the description of the Keepalive message earlier in this chapter for details on this timer.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Finite State Machine Error</p></td><td style="border-bottom: 0.5pt solid ; "><p>The BGP finite state machine refers to the mechanism by which the BGP software on a peer moves from one operating state to another based on events (see the TCP finite state machine description in <a class="xref" href="ch47.html" title="Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION">Chapter 47</a> for some background on this concept). If an event occurs that is unexpected for the state the peer is currently in, it will generate this error.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; "><p>Cease</p></td><td style=""><p>Used when a BGP device wants to break the connection to a peer for a reason not related to any of the error conditions described by the other codes.</p></td></tr></tbody></table></div></div><div class="table"><a id="bgp_notification_message_error_subcodes"/><p class="title">Table 40-14. BGP Notification Message Error Subcodes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="BGP Notification Message Error Subcodes"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Error Type</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Error Subcode Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subcode Name</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Message Header Error (Error Code 1)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Connection Not Synchronized</p></td><td style="border-bottom: 0.5pt solid ; "><p>The expected value in the Marker field was not found, indicating that the connection has become unsynchronized. See the description of the Marker field in <a class="xref" href="ch40s07.html#bgp_notification_message_format" title="BGP Notification Message Format">BGP Notification Message Format</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bad Message Length</p></td><td style="border-bottom: 0.5pt solid ; "><p>The message was less than 19 bytes, greater than 4096 bytes, or not consistent with what was expected for the message type.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bad Message Type</p></td><td style="border-bottom: 0.5pt solid ; "><p>The Type field of the message contains an invalid value.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Open Message Error (Error Code 2)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unsupported Version Number</p></td><td style="border-bottom: 0.5pt solid ; "><p>The device does not "speak" the version number its peer is trying to use.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bad Peer AS</p></td><td style="border-bottom: 0.5pt solid ; "><p>The router doesn't recognize the peer's AS number or is not willing to communicate with it.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bad BGP Identifier</p></td><td style="border-bottom: 0.5pt solid ; "><p>The BGP Identifier field is invalid.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unsupported Optional Parameter</p></td><td style="border-bottom: 0.5pt solid ; "><p>The Open message contains an optional parameter that the recipient of the message doesn't understand.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Authentication Failure</p></td><td style="border-bottom: 0.5pt solid ; "><p>The data in the Authentication Information optional parameter could not be authenticated.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unacceptable Hold Time</p></td><td style="border-bottom: 0.5pt solid ; "><p>The router refuses to open a session because the proposed hold time its peer specified in its Open message is unacceptable.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Update Message Error (Error Code 3)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Malformed Attribute List</p></td><td style="border-bottom: 0.5pt solid ; "><p>The overall structure of the message's path attributes is incorrect, or an attribute has appeared twice.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unrecognized Well-Known Attribute</p></td><td style="border-bottom: 0.5pt solid ; "><p>One of the mandatory well-known attributes was not recognized.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Missing Well-Known Attribute</p></td><td style="border-bottom: 0.5pt solid ; "><p>One of the mandatory well-known attributes was not specified.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Attribute Flags Error</p></td><td style="border-bottom: 0.5pt solid ; "><p>An attribute has a flag set to a value that conflicts with the attribute's type code.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Attribute Length Error</p></td><td style="border-bottom: 0.5pt solid ; "><p>The length of an attribute is incorrect.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Invalid Origin Attribute</p></td><td style="border-bottom: 0.5pt solid ; "><p>The Origin attribute has an undefined value.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>AS Routing Loop</p></td><td style="border-bottom: 0.5pt solid ; "><p>A routing loop was detected.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Invalid Next_Hop Attribute</p></td><td style="border-bottom: 0.5pt solid ; "><p>The Next_Hop attribute is invalid.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Optional Attribute Error</p></td><td style="border-bottom: 0.5pt solid ; "><p>An error was detected in an optional attribute.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Invalid Network Field</p></td><td style="border-bottom: 0.5pt solid ; "><p>The Network Layer Reachability Information field is incorrect.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "> </td><td style="border-right: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; "><p>Malformed AS_Path</p></td><td style=""><p>The AS_Path attribute is incorrect.</p></td></tr></tbody></table></div></div><p>Note that, perhaps ironically, no mechanism exists to report an error in a Notification message itself. This is likely because the connection is normally terminated after such a message is sent.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-235"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> BGP Notification messages are used for error reporting between BGP peers. Each message contains an Error Code field that indicates what type of problem occurred. For certain Error Code fields, an Error Subcode field provides additional details about the specific nature of the problem. Despite these field names, Notification messages are also used for other types of special nonerror communication, such as terminating a BGP connection.</p></div></div></div></div>
<div class="chapter" title="Chapter&#xA0;41.&#xA0;OTHER ROUTING PROTOCOLS"><div class="titlepage"><div><div><h1 class="title"><a id="other_routing_protocols"/>Chapter 41. OTHER ROUTING PROTOCOLS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e46163"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The Routing Information Protocol (RIP), Open Shortest Path First (OSPF), and Border Gateway Protocol (BGP)—detailed in the preceding chapters—are the three most well-known routing protocols used in the TCP/IP protocol suite. But there are several other TCP/IP routing protocols, and they fall into one of two categories. Some protocols are no longer in use today but are nevertheless interesting from a historical perspective. Others are proprietary RIP and OSPF alternatives that you may occasionally encounter in today's networking world.</p><p>In this chapter, I provide a brief description of five additional TCP/IP routing protocols. I begin with a look at two obsolete interior routing protocols that played an important role in the early Internet: the Gateway-to-Gateway Protocol (GGP) and the HELLO Protocol. I then describe two interior routing protocols (developed by Cisco Systems) that are sometimes seen in the industry today as alternatives to RIP and OSPF: the Interior Gateway Routing Protocol (IGRP) and the Enhanced Interior Gateway Routing Protocol (EIGRP). I conclude with a discussion of the Exterior Gateway Protocol (EGP), the exterior routing protocol that preceded BGP.</p><div class="sect1" title="TCP/IP Gateway-to-Gateway Protocol (GGP)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_gateway-to-gateway_protocol_ggp"/>TCP/IP Gateway-to-Gateway Protocol (GGP)</h1></div></div></div><p>In <a class="xref" href="ch37.html" title="Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS">Chapter 37</a>, I described the evolution of TCP/IP routing architectures. The modern Internet is based on the concept of independent autonomous systems (ASes), which run interior routing protocols within them and exterior routing protocols between them. The early Internet, however, was somewhat simpler. It consisted of a relatively small number of core routers that carried detailed information about the Internet as a whole, as well as noncore routers that knew only partial information about the whole internetwork and were located around the core.</p><p>These core routers used a special routing protocol to communicate called the <a class="indexterm" id="idx-CHP-41-1579"/><span class="emphasis"><em>Gateway-to-Gateway Protocol (GGP)</em></span>. Bolt, Beranek, and Newman, one of the pioneers of the Internet and TCP/IP, originally developed <a class="indexterm" id="idx-CHP-41-1580"/>GGP in the early 1980s. It was documented in RFC 823, "The DARPA Internet Gateway," published September 1982. This protocol is now obsolete, but it played an important role in the early Internet by introducing certain concepts that developers used in later routing protocols.</p><p>GGP is similar in general operation to RIP (described in <a class="xref" href="ch38.html" title="Chapter 38. ROUTING INFORMATION PROTOCOL (RIP, RIP-2, AND RIPNG)">Chapter 38</a>) in that it uses a distance-vector algorithm to determine the best routes between devices. Like RIP, the metric is a simple hop count, so GGP will select a route with the shortest number of hops. Although you have seen that hop count is not always the best metric of cost for a router in RIP, it was actually a pretty good method of route determination back then. This is because the early Internet used both computers and links that would be considered glacially slow by today's standards, thereby making each hop fairly expensive (in terms of the time required to send data) compared to modern routing.</p><p>A router using GGP initially starts out in a null state. It then tests the status of its local networks by seeing if it can send and receive messages on the network. Every 15 seconds, the router sends a GGP Echo message to each of its neighbors. If the neighbor receives the message, it responds with a GGP Echo Reply message. The router sending the Echo messages considers the neighbor up if it receives replies to a certain percentage of messages (the default is 50 percent).</p><div class="note" title="Note"><h3 class="title"><a id="note-116"/>Note</h3><p><span class="emphasis"><em>These messages serve a similar function to the Internet Control Message Protocol version 4 (ICMPv4) Echo and Echo Reply messages (described in <a class="xref" href="ch33.html" title="Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS">Chapter 33</a>), but are not the same.</em></span></p></div><p>Actual routing information is communicated by sending GGP Routing Update messages. These are similar in nature to RIP Response messages used in RIP. Each Routing Update message contains the information in the sending router's routing table, which specifies the networks the router can reach and what the cost (in hops) will be for each.</p><p>A router that receives a Routing Update message knows that it can reach the router that sent the update. Because of that, it can reach all of the other routers' reachable networks at the cost of an additional hop. The router uses the information to update its own internal tables of destinations and metrics, and then it sends out its own Routing Update on its own attached networks. This way, it can propagate the information it acquired from other routers on its own networks. This process continues until eventually, routes to all GGP routers spreads across the internetwork, just as this process occurs in RIP.</p><p>One interesting difference between GGP and RIP is that in GGP networks and costs aren't sent in pairs. Instead, a GGP router sends its routing table in groups. If it has three networks it can communicate with directly at a cost of 1, it sends those in a group with a distance value of 1. Next, if the GGP router has a few networks it can reach at a cost of 2, it sends those in a group with a distance value of 2, and so on.</p><p>Another difference is that GGP Routing Update messages are acknowledged. Each Routing Update message is sent with a sequence number, which ensures that out-of-date information is not propagated. If the Routing Update is received and it has a new sequence number (indicating that it contains recent information), the router processing returns a GGP Acknowledgment message to the originator. If the sequence number indicates the message is stale, a Negative Acknowledgment is sent instead and the message is discarded.</p><p>As a distance-vector algorithm using hop count as a metric, GGP shared most of the same pros and cons as RIP. It had simplicity on its side, but it had numerous problems such as slow convergence and the counting to infinity issue. GGP was a much more rudimentary protocol than RIP, however, and did not include many of the features included in RIP to handle such issues, such as split horizon. GGP was also limited to unsubnetted classful networks, due to its age.</p><p>When Internet architecture moved to the use of ASes, GGP was obsoleted. While it was an important part of TCP/IP history, it is today not formally considered a part of the TCP/IP protocol suite.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-236"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <span class="emphasis"><em>Gateway-to-Gateway Protocol (GGP)</em></span> was used to communicate route information between core routers on the early Internet. It is a distance-vector protocol that operates in a manner that's very similar to RIP. Each router periodically sends out its routing table to neighboring routers so that each router can learn the cost, in hops, to reach every network in the AS. GGP is now considered a historical protocol and is no longer part of TCP/IP.</p></div></div></div>
<div class="sect1" title="The HELLO Protocol (HELLO)"><div class="titlepage"><div><div><h1 class="title"><a id="the_hello_protocol_hello"/>The HELLO Protocol (HELLO)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-41-1581"/>The TCP/IP Internet as we know it today evolved over the course of decades. It began as an experimental research project started by the United States Defense Advanced Research Projects Agency (DARPA or ARPA). Called the ARPAnet, the project grew through the addition of other networks, such as the important NSFnet developed by the National Science Foundation (NSF). The NSFnet backbone grew over the course of many years and was instrumental to the eventual creation of the modern Internet.</p><p>The original NSFnet backbone consisted of six Digital Equipment Corporation (absorbed by Compaq years ago) LSI-11 computers located across the United States. These computers ran special software that was colloquially called "fuzzball." This software enabled the computers to function as routers. These fuzzball routers connected various networks to the NSFnet and the ARPAnet.</p><p>The six NSFnet routers worked as an AS, and like any AS, used an interior routing protocol to exchange routing information. The routing protocol used in these early routers was called the <span class="emphasis"><em>HELLO Protocol</em></span>. Developed in the early 1980s, it was documented in RFC 891, "DCN Local-Network Protocols," which was published in December 1983. The name <span class="emphasis"><em>HELLO</em></span> is capitalized, but it is not an acronym; it simply refers to the word <span class="emphasis"><em>hello</em></span>, because the protocol uses messages that are sort of analogous to the routers greeting each other.</p><div class="note" title="Note"><h3 class="title"><a id="note-117"/>Note</h3><p><span class="emphasis"><em>The OSPF routing protocol has a message type called</em></span> Hello. <span class="emphasis"><em>The use of these messages is sometimes referred to as the</em></span> Hello protocol. <span class="emphasis"><em>OSPF is not directly related to the HELLO Protocol described in this section, other than the fact that an AS could use both protocols for routing. OSPF may have borrowed the name Hello from the HELLO Protocol.</em></span></p></div><p>The HELLO Protocol uses a distance-vector algorithm, like RIP and GGP. What's interesting about it, however, is that unlike RIP and GGP, HELLO does not use hop count as a metric. Instead, it attempts to select the best route by assessing network delays and choosing the path with the shortest delay.</p><p>One of the key jobs of routers that use HELLO is to compute the time delay required to send and receive datagrams to and from its neighbors. On a regular basis, routers exchange HELLO messages that contain clock and timestamp information. By using a special algorithm to compare the clock value and timestamp in the message to its own clock, a receiving device can compute an estimate for the amount of time it takes to send a datagram over the link.</p><p>Like RIP and GGP messages, HELLO messages also contain routing information in the form of pairs of destinations and metrics. These represent places that the sending router is able to reach and a cost to communicate with each one. However, in HELLO, the metric is an estimate of the round-trip delay cost for each destination. This information is added to the computed round-trip delay time for the link over which the message was received, and it is used to update the receiving router's own routing table.</p><p>This seems a bit confusing, but is really similar to the way a hop-count distance-vector protocol like RIP works. Router A, which is using RIP to receive an RIP Response message from Router B, knows it can reach every destination Router B can, but at a cost of one extra hop (the hop from Router A to Router B). Similarly, Router A, which receives a HELLO message from Router B, knows it can reach every destination that Router B can, but at an additional cost of the computed delay for the link between Router A and Router B.</p><p>In theory, using delay calculations should result in more efficient route selection than simply using a hop-count algorithm, but this comes at the cost of more complexity. This makes HELLO very interesting indeed, especially for a protocol that is more than 20 years old. However, since the latency of a link is often unrelated to its bandwidth, using time delay as a link metric may lead to spurious results.</p><p>Furthermore, it is normal for the delay on any link to vary over time; for example, if two routes are similar in cost, fluctuations in the delay for each route could result in rapid changes between routes (a phenomenon sometimes called <span class="emphasis"><em>route flapping</em></span>). Adjustments are needed to the basic overview of the operation of the HELLO Protocol in order to avoid these sorts of problems.</p><p>Like other early routing protocols, HELLO does not include anything fancy like authentication. Such features were not needed in the early days of the Internet, when the internetworks were small and could easily be controlled. As the Internet grew, newer routing protocols such as RIP eventually replaced HELLO. It is now considered a historical protocol (in other words, obsolete) and is no longer used.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-237"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <span class="emphasis"><em>HELLO Protocol</em></span> was used on very early routers on the precursors of the Internet to exchange routing information. It is a distance-vector protocol like RIP and GGP, but differs because it uses calculated delay instead of hop count as a metric. Like GGP, it is now considered a historical protocol and is no longer part of TCP/IP.</p></div></div>
<div class="sect1" title="Interior Gateway Routing Protocol (IGRP)"><div class="titlepage"><div><div><h1 class="title"><a id="interior_gateway_routing_protocol_igrp"/>Interior Gateway Routing Protocol (IGRP)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-41-1582"/>I greatly prefer universal, open standards to proprietary standards. I explain the reasons why in <a class="xref" href="ch03.html" title="Chapter 3. NETWORK STANDARDS AND STANDARDS ORGANIZATIONS">Chapter 3</a>, which discusses networking standards. I am not alone in this view, and it's no exaggeration to say that much of the success of TCP/IP and the Internet is tied to the fact that they were both developed, and still are being developed, with the open RFC process.</p><p>That said, in certain situations, a proprietary protocol can be a benefit and can even achieve considerable success if a minimum of two factors is true:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There is a lack of a suitable open protocol or a gap in the feature coverage of existing open protocols, creating an opportunity for a proprietary protocol to succeed.</p></li><li class="listitem"><p>The proprietary protocol must be either initiated or strongly supported by a big player in the industry. This helps to ensure that other companies will take notice and give the protocol a chance to become a standard.</p></li></ul></div><p>This situation arose in the 1980s in the world of routing protocols. At that time, the most popular interior routing protocol was RIP, which does a basically good job, but has a number of limitations and problems that are inherent to the protocol and are not easily resolved. In the mid-1980s, open alternatives like OSPF did not yet exist; even if they had, OSPF is much more complex than RIP and therefore sometimes not a good alternative to it.</p><p><a class="indexterm" id="idx-CHP-41-1583"/>Cisco Systems—definitely one of the big names in networking, internetworking, and routing—decided to develop a new routing protocol that would be similar to RIP but would provide greater functionality and solve some of RIP's inherent problems. Called the <a class="indexterm" id="idx-CHP-41-1584"/><span class="emphasis"><em>Interior Gateway Routing Protocol (IGRP)</em></span>, it conveniently uses the words <span class="emphasis"><em>gateway</em></span> and <span class="emphasis"><em>routing</em></span> in its name, illustrating that these two words are used interchangeably in internetworking standards. Cisco designed it as a replacement for RIP. It is similar in many ways and keeps RIP's simplicity, one of its key strengths. At the same time, IGRP overcomes two key limitations of RIP: the use of hop count solely as a routing metric and the hop count limit of 15.</p><p>Like RIP, IGRP is a distance-vector routing protocol designed for use with an AS, and thus uses the same basic mechanism for route determination. Each router routinely sends out a message on each attached local network that contains a copy of its routing table. This message contains pairs of reachable networks and costs (metrics) to reach each network. A router receiving this message knows it can reach all the networks in the message as long as it can reach the router that sent the message. It computes the cost to reach those networks by adding what it costs to reach the router that sent the message to the networks' costs. The routers update their tables accordingly and send this information out in their next routine update. Eventually, each router in the AS will have information about the cost to reach each network in it.</p><p>There's an important difference between RIP and IGRP, however. RIP allows the cost to reach a network to be expressed only in terms of hop count; IGRP provides a much more sophisticated metric. In IGRP, the overall cost to reach a network is computed based on several individual metrics, including internetwork delay, bandwidth, reliability, and load. An administrator can customize the calculation of cost by setting relative weightings to the component metrics that reflect the priorities of that AS. So, if a particular administrator feels that emphasizing reliability over bandwidth would best minimize route cost, he can do this. Such a system provides tremendous flexibility over the rigid hop-count system of RIP. Unlike RIP, IGRP also does not have an inherent limit of 15 hops between networks.</p><p>To this basic algorithm, IGRP adds a feature called <span class="emphasis"><em>multipath routing</em></span>. This allows multiple paths between routes to be used automatically, with traffic shared between them. The traffic can either be shared evenly or apportioned unevenly based on the relative cost metric of each path. This provides improved performance and flexibility.</p><p>Since IGRP is a distance-vector protocol like RIP, it shares many of RIP's algorithmic issues. Unsurprisingly, then, IGRP must incorporate many of the same stability features as RIP, including the use of split horizon, split horizon with poisoned reverse (in certain circumstances), and the employment of hold-down timers. Like RIP, IGRP also uses timers to control how often updates are sent, how long routers are held down, and how long routes are held in the routing table before they expire.</p><p>Cisco originally developed IGRP for Internet Protocol (IP) networks, and since IP is predominant in the industry, these networks are where it is most often seen. IGRP is not specific to IP, however, and can be used with other internetworking protocols if implemented for them. As you will see, Cisco also used IGRP as the basis for an improved routing protocol called <a class="indexterm" id="idx-CHP-41-1585"/>EIGRP, which it developed several years after the original.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-238"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> In the 1980s, Cisco Systems created the <span class="emphasis"><em>Interior Gateway Routing Protocol (IGRP)</em></span> as an improvement over the industry standard protocol, RIP. Like RIP, IGRP is a distance-vector protocol, but it includes several enhancements. Most important, it eliminates the 15-hop limit between routers and provides the ability to use metrics other than hop count to determine optimal routes.</p></div></div>
<div class="sect1" title="Enhanced Interior Gateway Routing Protocol (EIGRP)"><div class="titlepage"><div><div><h1 class="title"><a id="enhanced_interior_gateway_routing_protoc"/>Enhanced Interior Gateway Routing Protocol (EIGRP)</h1></div></div></div><p><a class="indexterm" id="idx-CHP-41-1586"/>As discussed in the previous section, IGRP represented a substantial improvement over RIP, but like any successful company, Cisco was not content to rest on its laurels. Cisco developers knew that IGRP had significant room for improvement, so they set to work on creating a better version of IGRP in the early 1990s. The result was the <span class="emphasis"><em>Enhanced Interior Gateway Routing Protocol (EIGRP)</em></span>.</p><p>Compared to the original protocol, EIGRP is more of an evolution than a revolution. EIGRP is still a distance-vector protocol, but it is more sophisticated than other distance-vector protocols like IGRP or RIP, and it includes certain features that are more often associated with link-state routing protocols like OSPF than distance-vector algorithms. Also, since the Cisco developers realized that many of the organizations that had decided to use EIGRP would be migrating to it from IGRP, they took special steps to ensure compatibility between the two.</p><p>The chief differences between IGRP and EIGRP are not in what they do, but how they do it. In an effort to improve the efficiency and speed of route convergence (that is, to improve the agreement between different routers in the internetwork), EIGRP changes the way that routes are calculated. EIGRP is based on a new route calculation algorithm called the <span class="emphasis"><em>Diffusing Update Algorithm (DUAL)</em></span>, developed at SRI International by Dr. J. J. Garcia-Luna-Aceves.</p><p>DUAL differs from a typical distance-vector algorithm primarily in that it maintains more topology information about the internetwork than RIP or IGRP do. It uses this information to automatically select least-cost, loop-free routes between networks. EIGRP uses a metric that combines an assessment of the bandwidth of a link with the total delay to send over the link. (Other metrics are configurable as well, though not recommended.) When a neighboring router sends changed metric information, routes are recalculated and updates sent as needed. DUAL will query neighboring routers for reachability information if needed (for example, if an existing route fails).</p><p>This "as needed" aspect of operation highlights an important way that EIGRP improves performance over IGRP. EIGRP does not send routine route updates, but instead sends only partial updates as required, thereby reducing the amount of traffic generated between routers. Furthermore, these updates are designed so that only the routers that need the updated information receive them.</p><p>In order to build the tables of information that it needs to calculate routes, EIGRP requires routers to make and maintain contact with other routers on their local networks. To facilitate this, EIGRP incorporates a neighbor discovery and recovery process. This system involves the exchange of small Hello messages that let routers discover the other routers on the local network and periodically check to see whether they're reachable. This is very similar to the way the identically named Hello messages are used in OSPF (as described in <a class="xref" href="ch39.html" title="Chapter 39. OPEN SHORTEST PATH FIRST (OSPF)">Chapter 39</a>) and has a low impact on bandwidth use because the messages are small and infrequently sent.</p><p>Some of the features in IGRP carry through to its successor, such as the use of split horizon with poisoned reverse for improved stability. In addition to the basic improvements of efficiency and route convergence that accrue from the algorithm itself, EIGRP includes some other features. These include support for Variable Length Subnet Masks (VLSM) as well as support for multiple network-layer protocols. This means that EIGRP could be configured to function on a network that is running IP as well as another layer 3 protocol.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-239"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Developed in the 1990s, the <span class="emphasis"><em>Enhanced Interior Gateway Routing Protocol (EIGRP)</em></span> is an improved version of Cisco's IGRP. It is similar to IGRP in many respects, but it uses a more sophisticated route calculation method called the <span class="emphasis"><em>Diffusing Update Algorithm (DUAL)</em></span>. EIGRP also includes several features that make it more intelligent with regard to how it computes routes; it borrows concepts from link-state routing protocols and uses more efficient partial updates, rather than sending out entire routing tables.</p></div></div>
<div class="sect1" title="TCP/IP Exterior Gateway Protocol (EGP)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_exterior_gateway_protocol_egp"/>TCP/IP Exterior Gateway Protocol (EGP)</h1></div></div></div><p>In the days of the early Internet, a small number of centralized core routers that maintained complete information about network reachability did the routing. These core routers exchanged information using the historical interior routing protocol, GGP, which we examined earlier in this chapter. Other noncore routers located around the periphery of this core, both stand-alone and in groups, exchanged network reachability information with the core routers using the first TCP/IP exterior routing protocol: the <span class="emphasis"><em>Exterior Gateway Protocol (EGP)</em></span><a class="indexterm" id="idx-CHP-41-1587"/>.</p><p>Internet pioneers Bolt, Beranek, and Newman developed EGP in the early 1980s. It was first formally described in an Internet standard in RFC 827, "<a class="indexterm" id="idx-CHP-41-1588"/>Exterior Gateway Protocol (EGP)," published in October 1982, which was later superseded by RFC 904, "Exterior Gateway Protocol Formal Specification," in April 1984. Like GGP, EGP is now considered obsolete, having been replaced by BGP. However, like GGP, it is an important part of the history of TCP/IP routing, so it is worth examining briefly.</p><div class="note" title="Note"><h3 class="title"><a id="note-118"/>Note</h3><p><span class="emphasis"><em>As I explained in <a class="xref" href="ch37.html" title="Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS">Chapter 37</a>, routers were in the past often called gateways. As such, exterior routing protocols were exterior gateway protocols. The EGP protocol discussed here is a specific instance of an exterior gateway protocol (also known as EGP). Thus, you may occasionally see BGP also called an</em></span> exterior gateway protocol <span class="emphasis"><em>or an EGP, which is the generic use of the term</em></span>.</p></div><p>EGP is responsible for the communication of network reachability information between neighboring routers that may or may not be in different ASes. The operation of EGP is somewhat similar to that of BGP (discussed in <a class="xref" href="ch40.html" title="Chapter 40. BORDER GATEWAY PROTOCOL (BGP/BGP-4)">Chapter 40</a>). Each EGP router maintains a database of information about which networks it can reach and how to reach them. It sends this information out on a regular basis to each router to which it is directly connected. Routers receive these messages and update their routing tables, and then use this new information to update other routers. Information about how to reach each network propagates across the entire internetwork.</p><p>The actual process of exchanging routing information involves several steps that discover neighbors and then set up and maintain communications. The steps are as follows:
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>Neighbor Acquisition</strong></span> Each router attempts to establish a connection to each of its neighboring routers by sending Neighbor Acquisition Request messages. A neighbor hearing a request can respond with a Neighbor Acquisition Confirm message, which says that it recognized the request and wishes to connect. It may reject the acquisition by replying with a Neighbor Acquisition Refuse message. For an EGP connection to be established between a pair of neighbors, each message must first successfully acquire the other with a Confirm message.</p></li><li class="listitem"><p><span class="strong"><strong>Neighbor Reachability</strong></span> After acquiring a neighbor, a router checks to make sure the neighbor is reachable and functioning properly on a regular basis. This is done by sending an EGP Hello message to each neighbor for which a connection has been established. The neighbor replies with an I Heard You (IHU) message. These messages are somewhat analogous to the BGP Keepalive message, but they are used in matched pairs.</p></li><li class="listitem"><p><span class="strong"><strong>Network Reachability Update</strong></span> A router sends Poll messages on a regular basis to each of its neighbors. The neighbor responds with an Update message, which contains details about the networks that it is able to reach. This information is used to update the routing tables of the device that sent the Poll message.</p></li></ol></div><p>A neighbor can decide to terminate a connection (called <span class="emphasis"><em>neighbor deacquisition</em></span>) by sending a Cease message; the neighbor responds with a Cease-ack (acknowledge) message.</p><p>An Error message, similar to the BGP Notification message in role and structure (see <a class="xref" href="ch40.html" title="Chapter 40. BORDER GATEWAY PROTOCOL (BGP/BGP-4)">Chapter 40</a>), is also defined. A neighbor may send this message in response to the receipt of an EGP message either when the message itself has a problem (such as a bad message length or unrecognized data in a field) or to indicate a problem with how the message is being used (such as receipt of Hello or Poll messages at a rate deemed excessive). Unlike with the BGP Notification message, an EGP router does not necessarily close the connection when sending an Error message.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-240"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <span class="emphasis"><em>Exterior Gateway Protocol (EGP)</em></span> was the first TCP/IP exterior routing protocol and was used with GGP on the early Internet. It functions in a manner similar to BGP. For example, an EGP router makes contact with neighboring routers and exchanges routing information with them. A mechanism is also provided to maintain a session and report errors. EGP is more limited than BGP in capability and is now considered a historical protocol.</p></div><p>The early Internet was designed to connect peripheral routers or groups of routers to the Internet core. It was therefore designed under the assumption that the internetwork was connected as a hierarchical tree, with the core as the root. EGP was designed based on this assumption of a tree structure and, for that reason, cannot handle an arbitrary topology of ASes like BGP. It likewise cannot guarantee the absence of routing loops if such loops exist in the interconnection of neighboring routers. This is part of why BGP needed to be developed as the Internet moved to a more arbitrary structure of AS connections, where loops would be possible if steps weren't taken to avoid them.</p></div></body></html>