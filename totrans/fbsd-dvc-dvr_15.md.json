["```\nstruct usb_config {\n        /* USB Module Private Data */\n        enum usb_hc_mode        usb_mode;\n\n        /* Mandatory Fields */\n        uint8_t                 type;\n        uint8_t                 endpoint;\n        uint8_t                 direction;\n        usb_callback_t         *callback;\n        usb_frlength_t          bufsize;\n\n        /* Optional Fields */\n        usb_timeout_t           timeout;\n        usb_timeout_t           interval;\n        usb_frcount_t           frames;\n        uint8_t                 ep_index;\n        uint8_t                 if_index;\n\n        /* USB Transfer Flags */\n        struct usb_xfer_flags   flags;\n};\n```", "```\nstruct usb_xfer_flags {\n        uint8_t force_short_xfer : 1;\n        uint8_t short_xfer_ok    : 1;\n        uint8_t short_frames_ok  : 1;\n        uint8_t pipe_bof         : 1;\n        uint8_t proxy_buffer     : 1;\n        uint8_t ext_buffer       : 1;\n        uint8_t manual_status    : 1;\n        uint8_t no_pipe_ok       : 1;\n        uint8_t stall_pipe       : 1;\n};\n```", "```\ntypedef void (usb_callback_t)(struct usb_xfer *, usb_error_t);\n```", "```\nstruct usb_xfer {\n...\n        uint8_t         usb_state;\n/* Set when callback is executed before a data transfer. */\n#define USB_ST_SETUP            0\n/* Set when callback is executed after a data transfer. */\n#define USB_ST_TRANSFERRED      1\n/* Set when a transfer error occurs. */\n#define USB_ST_ERROR            2\n...\n};\n```", "```\nstatic void\nulpt_status_callback(struct usb_xfer *transfer, usb_error_t error)\n{\n        struct ulpt_softc *sc = usbd_xfer_softc(transfer);\n        struct usb_device_request req;\n        struct usb_page_cache *pc;\n        uint8_t current_status, new_status;\n\n        switch (USB_GET_STATE(transfer)) {\n      case USB_ST_SETUP:\n                req.bmRequestType = UT_READ_CLASS_INTERFACE;\n                req.bRequest = UREQ_GET_PORT_STATUS;\n                USETW(req.wValue, 0);\n                req.wIndex[0] = sc->sc_iface_num;\n                req.wIndex[1] = 0;\n                USETW(req.wLength, 1);\n\n                pc = usbd_xfer_get_frame(transfer, 0);\n                usbd_copy_in(pc, 0, &req, sizeof(req));\n                usbd_xfer_set_frame_len(transfer, 0, sizeof(req));\n                usbd_xfer_set_frame_len(transfer, 1, 1);\n                usbd_xfer_set_frames(transfer, 2);\n              usbd_transfer_submit(transfer);\n\n                break;\n      case USB_ST_TRANSFERRED:\n                pc = usbd_xfer_get_frame(transfer, 1);\n                usbd_copy_out(pc, 0, &current_status, 1);\n\n                current_status = (current_status ^ LPS_INVERT) & LPS_MASK;\n                new_status = current_status & ˜sc->sc_previous_status;\n                sc->sc_previous_status = current_status;\n\n                if (new_status & LPS_NERR)\n                       log(LOG_NOTICE, \"%s: output error\\n\",\n                            device_get_nameunit(sc->sc_dev));\n                else if (new_status & LPS_SELECT)\n                       log(LOG_NOTICE, \"%s: offline\\n\",\n                            device_get_nameunit(sc->sc_dev));\n                else if (new_status & LPS_NOPAPER)\n                       log(LOG_NOTICE, \"%s: out of paper\\n\",\n                            device_get_nameunit(sc->sc_dev));\n\n                break;\n        default:\n                break;\n        }\n}\n```", "```\n#include <dev/usb/usb.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbdi_util.h>\n\nusb_error_t\nusbd_transfer_setup(struct usb_device *udev, const uint8_t *ifaces,\n    struct usb_xfer **pxfer, const struct usb_config *setup_start,\n    uint16_t n_setup, void *priv_sc, struct mtx *priv_mtx);\n\nvoid\nusbd_transfer_unsetup(struct usb_xfer **pxfer, uint16_t n_setup);\n\nvoid\nusbd_transfer_start(struct usb_xfer *xfer);\n\nvoid\nusbd_transfer_stop(struct usb_xfer *xfer);\n\nvoid\nusbd_transfer_drain(struct usb_xfer *xfer);\n```", "```\nstruct usb_fifo_methods {\n        /* Executed Unlocked */\n        usb_fifo_open_t         *f_open;\n        usb_fifo_close_t        *f_close;\n        usb_fifo_ioctl_t        *f_ioctl;\n        usb_fifo_ioctl_t        *f_ioctl_post;\n\n        /* Executed With Mutex Locked */\n        usb_fifo_cmd_t          *f_start_read;\n        usb_fifo_cmd_t          *f_stop_read;\n        usb_fifo_cmd_t          *f_start_write;\n        usb_fifo_cmd_t          *f_stop_write;\n        usb_fifo_filter_t       *f_filter_read;\n        usb_fifo_filter_t       *f_filter_write;\n\n        const char              *basename[4];\n        const char              *postfix[4];\n};\n```", "```\n#include <dev/usb/usb.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbdi_util.h>\n\nint\nusb_fifo_attach(struct usb_device *udev, void *priv_sc,\n    struct mtx *priv_mtx, struct usb_fifo_methods *pm,\n  struct usb_fifo_sc *f_sc, uint16_t unit, uint16_t subunit,\n    uint8_t iface_index, uid_t uid, gid_t gid, int mode);\n\nvoid\nusb_fifo_detach(struct usb_fifo_sc *f_sc);\n```", "```\n#include <sys/param.h>\n  #include <sys/module.h>\n  #include <sys/kernel.h>\n  #include <sys/systm.h>\n\n  #include <sys/conf.h>\n  #include <sys/bus.h>\n  #include <sys/lock.h>\n  #include <sys/mutex.h>\n  #include <sys/syslog.h>\n  #include <sys/fcntl.h>\n\n  #include <dev/usb/usb.h>\n  #include <dev/usb/usbdi.h>\n  #include <dev/usb/usbdi_util.h>\n\n  #define ULPT_BUF_SIZE           (1 << 15)\n  #define ULPT_IFQ_MAX_LEN        2\n\n  #define UREQ_GET_PORT_STATUS    0x01\n  #define UREQ_SOFT_RESET         0x02\n\n  #define LPS_NERR                0x08\n  #define LPS_SELECT              0x10\n  #define LPS_NOPAPER             0x20\n  #define LPS_INVERT              (LPS_NERR | LPS_SELECT)\n  #define LPS_MASK                (LPS_NERR | LPS_SELECT | LPS_NOPAPER)\n\n  enum {\n          ULPT_BULK_DT_WR,\n          ULPT_BULK_DT_RD,\n          ULPT_INTR_DT_RD,\n          ULPT_N_TRANSFER\n  };\n\n  struct ulpt_softc {\n          device_t                sc_dev;\n          struct usb_device      *sc_usb_device;\n          struct mtx              sc_mutex;\n          struct usb_callout      sc_watchdog;\n          uint8_t                 sc_iface_num;\n          struct usb_xfer        *sc_transfer[ULPT_N_TRANSFER];\n          struct usb_fifo_sc      sc_fifo;\n          struct usb_fifo_sc      sc_fifo_no_reset;\n          int                     sc_fflags;\n          struct usb_fifo        *sc_fifo_open[2];\n          uint8_t                 sc_zero_length_packets;\n          uint8_t                 sc_previous_status;\n  };\n\n  static device_probe_t           ulpt_probe;\n  static device_attach_t          ulpt_attach;\n  static device_detach_t          ulpt_detach;\n\n  static usb_fifo_open_t          ulpt_open;\n  static usb_fifo_open_t          unlpt_open;\n  static usb_fifo_close_t         ulpt_close;\n  static usb_fifo_ioctl_t         ulpt_ioctl;\n  static usb_fifo_cmd_t           ulpt_start_read;\n  static usb_fifo_cmd_t           ulpt_stop_read;\n  static usb_fifo_cmd_t           ulpt_start_write;\n  static usb_fifo_cmd_t           ulpt_stop_write;\n\n  static void                     ulpt_reset(struct ulpt_softc *);\n  static void                     ulpt_watchdog(void *);\n\n  static usb_callback_t           ulpt_write_callback;\n  static usb_callback_t           ulpt_read_callback;\n  static usb_callback_t           ulpt_status_callback;\n\n static struct usb_fifo_methods ulpt_fifo_methods = {\n          .f_open =               &ulpt_open,\n          .f_close =              &ulpt_close,\n          .f_ioctl =              &ulpt_ioctl,\n          .f_start_read =         &ulpt_start_read,\n          .f_stop_read =          &ulpt_stop_read,\n          .f_start_write =        &ulpt_start_write,\n          .f_stop_write =         &ulpt_stop_write,\n          .basename[0] =        \"ulpt\"\n  };\n\n static struct usb_fifo_methods unlpt_fifo_methods = {\n          .f_open =               &unlpt_open,\n          .f_close =              &ulpt_close,\n          .f_ioctl =              &ulpt_ioctl,\n          .f_start_read =         &ulpt_start_read,\n          .f_stop_read =          &ulpt_stop_read,\n          .f_start_write =        &ulpt_start_write,\n          .f_stop_write =         &ulpt_stop_write,\n          .basename[0] =        \"unlpt\"\n  };\n\n  static const struct usb_config ulpt_config[ULPT_N_TRANSFER] = {\n        [ULPT_BULK_DT_WR] = {\n                  .callback =     &ulpt_write_callback,\n                  .bufsize =      ULPT_BUF_SIZE,\n                  .flags =        {.pipe_bof = 1, .proxy_buffer = 1},\n                  .type =         UE_BULK,\n                  .endpoint =     UE_ADDR_ANY,\n                  .direction =    UE_DIR_OUT\n          },\n\n        [ULPT_BULK_DT_RD] = {\n                  .callback =     &ulpt_read_callback,\n                  .bufsize =      ULPT_BUF_SIZE,\n                  .flags =        {.short_xfer_ok = 1, .pipe_bof = 1,\n                                      .proxy_buffer = 1},\n                  .type =         UE_BULK,\n                  .endpoint =     UE_ADDR_ANY,\n                  .direction =    UE_DIR_IN\n          },\n\n        [ULPT_INTR_DT_RD] = {\n                  .callback =     &ulpt_status_callback,\n                  .bufsize =      sizeof(struct usb_device_request) + 1,\n                  .timeout =      1000,           /* 1 second. */\n                  .type =         UE_CONTROL,\n                  .endpoint =     0x00,\n                  .direction =    UE_DIR_ANY\n          }\n  };\n\n  static int\n  ulpt_open(struct usb_fifo *fifo, int fflags)\n  {\n  ...\n  }\n\n  static void\n  ulpt_reset(struct ulpt_softc *sc)\n  {\n  ...\n  }\n\n  static int\n  unlpt_open(struct usb_fifo *fifo, int fflags)\n  {\n  ...\n  }\n\n  static void\n  ulpt_close(struct usb_fifo *fifo, int fflags)\n  {\n  ...\n  }\n\n  static int\n  ulpt_ioctl(struct usb_fifo *fifo, u_long cmd, void *data, int fflags)\n  {\n  ...\n  }\n\n  static void\n  ulpt_watchdog(void *arg)\n  {\n  ...\n  }\n\n  static void\n  ulpt_start_read(struct usb_fifo *fifo)\n  {\n  ...\n  }\n\n  static void\n  ulpt_stop_read(struct usb_fifo *fifo)\n  {\n  ...\n  }\n\n  static void\n  ulpt_start_write(struct usb_fifo *fifo)\n  {\n  ...\n  }\n\n  static void\n  ulpt_stop_write(struct usb_fifo *fifo)\n  {\n  ...\n  }\n\n  static void\n  ulpt_write_callback(struct usb_xfer *transfer, usb_error_t error)\n  {\n  ...\n  }\n\n  static void\n  ulpt_read_callback(struct usb_xfer *transfer, usb_error_t error)\n  {\n  ...\n  }\n\n  static void\n  ulpt_status_callback(struct usb_xfer *transfer, usb_error_t error)\n  {\n  ...\n  }\n\n  static int\n  ulpt_probe(device_t dev)\n  {\n  ...\n  }\n\n  static int\n  ulpt_attach(device_t dev)\n  {\n  ...\n  }\n\n  static int\n  ulpt_detach(device_t dev)\n  {\n  ...\n  }\n\n  static device_method_t ulpt_methods[] = {\n          /* Device interface. */\n          DEVMETHOD(device_probe,         ulpt_probe),\n          DEVMETHOD(device_attach,        ulpt_attach),\n          DEVMETHOD(device_detach,        ulpt_detach),\n          { 0, 0 }\n  };\n\n  static driver_t ulpt_driver = {\n          \"ulpt\",\n          ulpt_methods,\n          sizeof(struct ulpt_softc)\n  };\n\n  static devclass_t ulpt_devclass;\n\n  DRIVER_MODULE(ulpt, uhub, ulpt_driver, ulpt_devclass, 0, 0);\n  MODULE_DEPEND(ulpt, usb, 1, 1, 1);\n  MODULE_DEPEND(ulpt, ucom, 1, 1, 1);\n```", "```\nstatic int\nulpt_probe(device_t dev)\n{\n      struct usb_attach_arg *uaa = device_get_ivars(dev);\n\n      if (uaa->usb_mode != USB_MODE_HOST)\n                return (ENXIO);\n\n      if ((uaa->info.bInterfaceClass == UICLASS_PRINTER) &&\n            (uaa->info.bInterfaceSubClass == UISUBCLASS_PRINTER) &&\n            ((uaa->info.bInterfaceProtocol == UIPROTO_PRINTER_UNI) ||\n             (uaa->info.bInterfaceProtocol == UIPROTO_PRINTER_BI) ||\n             (uaa->info.bInterfaceProtocol == UIPROTO_PRINTER_1284)))\n                return (BUS_PROBE_SPECIFIC);\n\n        return (ENXIO);\n}\n```", "```\nstatic int\nulpt_attach(device_t dev)\n{\n        struct usb_attach_arg *uaa = device_get_ivars(dev);\n        struct ulpt_softc *sc = device_get_softc(dev);\n        struct usb_interface_descriptor *idesc;\n        struct usb_config_descriptor *cdesc;\n        uint8_t alt_index, iface_index = uaa->info.bIfaceIndex;\n        int error, unit = device_get_unit(dev);\n\n        sc->sc_dev = dev;\n        sc->sc_usb_device = uaa->device;\n      device_set_usb_desc(dev);\n        mtx_init(&sc->sc_mutex, \"ulpt\", NULL, MTX_DEF | MTX_RECURSE);\n      usb_callout_init_mtx(&sc->sc_watchdog, &sc->sc_mutex, 0);\n\n        idesc = usbd_get_interface_descriptor(uaa->iface);\n        alt_index = −1;\n        for (;;) {\n                if (idesc == NULL)\n                        break;\n\n                if ((idesc->bDescriptorType == UDESC_INTERFACE) &&\n                    (idesc->bLength >= sizeof(*idesc))) {\n                        if (idesc->bInterfaceNumber != uaa->info.bIfaceNum)\n                                break;\n                        else {\n                                alt_index++;\n                                if ((idesc->bInterfaceClass ==\n                                     UICLASS_PRINTER) &&\n                                    (idesc->bInterfaceSubClass ==\n                                     UISUBCLASS_PRINTER) &&\n                                    (idesc->bInterfaceProtocol ==\n                                   UIPROTO_PRINTER_BI))\n                                        goto found;\n                        }\n                }\n\n                cdesc = usbd_get_config_descriptor(uaa->device);\n                idesc = (void *)usb_desc_foreach(cdesc, (void *)idesc);\n        }\n        goto detach;\n\nfound:\n        if (alt_index) {\n                error = usbd_set_alt_interface_index(uaa->device,\n                    iface_index, alt_index);\n                if (error)\n                        goto detach;\n        }\n\n        sc->sc_iface_num = idesc->bInterfaceNumber;\n\n        error = usbd_transfer_setup(uaa->device, &iface_index,\n            sc->sc_transfer, ulpt_config, ULPT_N_TRANSFER, sc,\n            &sc->sc_mutex);\n        if (error)\n                goto detach;\n\n        device_printf(dev, \"using bi-directional mode\\n\");\n\n        error = usb_fifo_attach(uaa->device, sc, &sc->sc_mutex,\n            &ulpt_fifo_methods, &sc->sc_fifo, unit, −1,\n            iface_index, UID_ROOT, GID_OPERATOR, 0644);\n        if (error)\n                goto detach;\n\n        error = usb_fifo_attach(uaa->device, sc, &sc->sc_mutex,\n            &unlpt_fifo_methods, &sc->sc_fifo_no_reset, unit, −1,\n            iface_index, UID_ROOT, GID_OPERATOR, 0644);\n        if (error)\n                goto detach;\n\n        mtx_lock(&sc->sc_mutex);\n      ulpt_watchdog(sc);\n        mtx_unlock(&sc->sc_mutex);\n        return (0);\n\ndetach:\n        ulpt_detach(dev);\n        return (ENOMEM);\n}\n```", "```\nstatic int\nulpt_detach(device_t dev)\n{\n        struct ulpt_softc *sc = device_get_softc(dev);\n\n      usb_fifo_detach(&sc->sc_fifo);\n      usb_fifo_detach(&sc->sc_fifo_no_reset);\n\n        mtx_lock(&sc->sc_mutex);\n      usb_callout_stop(&sc->sc_watchdog);\n        mtx_unlock(&sc->sc_mutex);\n\n      usbd_transfer_unsetup(sc->sc_transfer, ULPT_N_TRANSFER);\n      usb_callout_drain(&sc->sc_watchdog);\n      mtx_destroy(&sc->sc_mutex);\n\n        return (0);\n}\n```", "```\nstatic int\nulpt_open(struct usb_fifo *fifo, int fflags)\n{\n        struct ulpt_softc *sc = usb_fifo_softc(fifo);\n\n        if (sc->sc_fflags == 0)\n                ulpt_reset(sc);\n\n        return (unlpt_open(fifo, fflags));\n}\n```", "```\nstatic void\nulpt_reset(struct ulpt_softc *sc)\n{\n      struct usb_device_request req;\n        int error;\n\n        req.bRequest = UREQ_SOFT_RESET;\n        USETW(req.wValue, 0);\n        USETW(req.wIndex, sc->sc_iface_num);\n        USETW(req.wLength, 0);\n\n        mtx_lock(&sc->sc_mutex);\n\n        req.bmRequestType = UT_WRITE_CLASS_OTHER;\n        error = usbd_do_request_flags(sc->sc_usb_device, &sc->sc_mutex,\n            &req, NULL, 0, NULL, 2 * USB_MS_HZ);\n      if (error) {\n                req.bmRequestType = UT_WRITE_CLASS_INTERFACE;\n              usbd_do_request_flags(sc->sc_usb_device, &sc->sc_mutex,\n                    &req, NULL, 0, NULL, 2 * USB_MS_HZ);\n        }\n\n        mtx_unlock(&sc->sc_mutex);\n}\n```", "```\nstatic int\nunlpt_open(struct usb_fifo *fifo, int fflags)\n{\n        struct ulpt_softc *sc = usb_fifo_softc(fifo);\n        int error;\n\n      if (sc->sc_fflags & fflags)\n                return (EBUSY);\n\n      if (fflags & FREAD) {\n                mtx_lock(&sc->sc_mutex);\n              usbd_xfer_set_stall(sc->sc_transfer[ULPT_BULK_DT_RD]);\n                mtx_unlock(&sc->sc_mutex);\n\n                error = usb_fifo_alloc_buffer(fifo,\n                    usbd_xfer_max_len(sc->sc_transfer[ULPT_BULK_DT_RD]),\n                    ULPT_IFQ_MAX_LEN);\n                if (error)\n                        return (ENOMEM);\n\n              sc->sc_fifo_open[USB_FIFO_RX] = fifo;\n        }\n\n      if (fflags & FWRITE) {\n                mtx_lock(&sc->sc_mutex);\n              usbd_xfer_set_stall(sc->sc_transfer[ULPT_BULK_DT_WR]);\n                mtx_unlock(&sc->sc_mutex);\n\n                error = usb_fifo_alloc_buffer(fifo,\n                    usbd_xfer_max_len(sc->sc_transfer[ULPT_BULK_DT_WR]),\n                    ULPT_IFQ_MAX_LEN);\n                if (error)\n                        return (ENOMEM);\n\n              sc->sc_fifo_open[USB_FIFO_TX] = fifo;\n        }\n\n      sc->sc_fflags |= fflags & (FREAD | FWRITE);\n        return (0);\n}\n```", "```\nstatic void\nulpt_close(struct usb_fifo *fifo, int fflags)\n{\n        struct ulpt_softc *sc = usb_fifo_softc(fifo);\n\n      sc->sc_fflags &= ˜(fflags & (FREAD | FWRITE));\n\n        if (fflags & (FREAD | FWRITE))\n               usb_fifo_free_buffer(fifo);\n}\n```", "```\nstatic int\nulpt_ioctl(struct usb_fifo *fifo, u_long cmd, void *data, int fflags)\n{\n        return (ENODEV);\n}\n```", "```\nstatic void\nulpt_watchdog(void *arg)\n{\n        struct ulpt_softc *sc = arg;\n\n        mtx_assert(&sc->sc_mutex, MA_OWNED);\n\n      if (sc->sc_fflags == 0)\n               usbd_transfer_start(sc->sc_transfer[ULPT_INTR_DT_RD]);\n\n      usb_callout_reset(&sc->sc_watchdog, hz,\n &ulpt_watchdog, sc);\n}\n```", "```\nstatic void\nulpt_start_read(struct usb_fifo *fifo)\n{\n        struct ulpt_softc *sc = usb_fifo_softc(fifo);\n\n       usbd_transfer_start(sc->sc_transfer[ULPT_BULK_DT_RD]);\n}\n```", "```\nstatic void\nulpt_stop_read(struct usb_fifo *fifo)\n{\n        struct ulpt_softc *sc = usb_fifo_softc(fifo);\n\n      usbd_transfer_stop(sc->sc_transfer[ULPT_BULK_DT_RD]);\n}\n```", "```\nstatic void\nulpt_start_write(struct usb_fifo *fifo)\n{\n        struct ulpt_softc *sc = usb_fifo_softc(fifo);\n\n      usbd_transfer_start(sc->sc_transfer[ULPT_BULK_DT_WR]);\n}\n```", "```\nstatic void\nulpt_stop_write(struct usb_fifo *fifo)\n{\n        struct ulpt_softc *sc = usb_fifo_softc(fifo);\n\n      usbd_transfer_stop(sc->sc_transfer[ULPT_BULK_DT_WR]);\n}\n```", "```\nstatic void\nulpt_write_callback(struct usb_xfer *transfer, usb_error_t error)\n{\n        struct ulpt_softc *sc = usbd_xfer_softc(transfer);\n        struct usb_fifo *fifo = sc->sc_fifo_open[USB_FIFO_TX];\n        struct usb_page_cache *pc;\n        int actual, max;\n\n        usbd_xfer_status(transfer, &actual, NULL, NULL, NULL);\n\n        if (fifo == NULL)\n                return;\n\n        switch (USB_GET_STATE(transfer)) {\n      case USB_ST_SETUP:\n      case USB_ST_TRANSFERRED:\nsetup:\n                pc = usbd_xfer_get_frame(transfer, 0);\n                max = usbd_xfer_max_len(transfer);\n                if (usb_fifo_get_data(fifo, pc, 0,\n max,\n                    &actual, 0)) {\n                      usbd_xfer_set_frame_len(transfer, 0, actual);\n                      usbd_transfer_submit(transfer);\n                }\n                break;\n        default:\n                if (error != USB_ERR_CANCELLED) {\n                        /* Issue a clear-stall request. */\n                        usbd_xfer_set_stall(transfer);\n                        goto setup;\n                }\n                break;\n        }\n}\n```", "```\nstatic void\nulpt_read_callback(struct usb_xfer *transfer, usb_error_t error)\n{\n        struct ulpt_softc *sc = usbd_xfer_softc(transfer);\n        struct usb_fifo *fifo = sc->sc_fifo_open[USB_FIFO_RX];\n        struct usb_page_cache *pc;\n        int actual, max;\n\n        usbd_xfer_status(transfer, &actual, NULL, NULL, NULL);\n\n        if (fifo == NULL)\n                return;\n\n        switch (USB_GET_STATE(transfer)) {\n      case USB_ST_TRANSFERRED:\n             if (actual == 0) {\n                      if (sc->sc_zero_length_packets == 4)\n                                /* Throttle transfers. */\n                              usbd_xfer_set_interval(transfer, 500);\n                        else\n                                sc->sc_zero_length_packets++;\n                } else {\n                        /* Disable throttling. */\n                        usbd_xfer_set_interval(transfer, 0);\n                        sc->sc_zero_length_packets = 0;\n                }\n\n                pc = usbd_xfer_get_frame(transfer, 0);\n              usb_fifo_put_data(fifo, pc, 0, actual, 1);\n                /* FALLTHROUGH */\n        case USB_ST_SETUP:\nsetup:\n                if (usb_fifo_put_bytes_max(fifo) != 0) {\n                        max = usbd_xfer_max_len(transfer);\n                      usbd_xfer_set_frame_len(transfer, 0, max);\n                      usbd_transfer_submit(transfer);\n                }\n                break;\n        default:\n                /* Disable throttling. */\n                usbd_xfer_set_interval(transfer, 0);\n                sc->sc_zero_length_packets = 0;\n\n                if (error != USB_ERR_CANCELLED) {\n                        /* Issue a clear-stall request. */\n                        usbd_xfer_set_stall(transfer);\n                        goto setup;\n                }\n                break;\n        }\n}\n```", "```\nstatic void\nulpt_status_callback(struct usb_xfer *transfer, usb_error_t error)\n{\n        struct ulpt_softc *sc = usbd_xfer_softc(transfer);\n        struct usb_device_request req;\n        struct usb_page_cache *pc;\n        uint8_t current_status, new_status;\n\n        switch (USB_GET_STATE(transfer)) {\n        case USB_ST_SETUP:\n                req.bmRequestType = UT_READ_CLASS_INTERFACE;\n                req.bRequest = UREQ_GET_PORT_STATUS;\n                USETW(req.wValue, 0);\n                req.wIndex[0] = sc->sc_iface_num;\n                req.wIndex[1] = 0;\n                USETW(req.wLength, 1);\n\n                pc = usbd_xfer_get_frame(transfer, 0);\n              usbd_copy_in(pc, 0, &req, sizeof(req));\n              usbd_xfer_set_frame_len(transfer, 0, sizeof(req));\n              usbd_xfer_set_frame_len(transfer, 1, 1);\n                usbd_xfer_set_frames(transfer, 2);\n              usbd_transfer_submit(transfer);\n\n                break;\n      case USB_ST_TRANSFERRED:\n                pc = usbd_xfer_get_frame(transfer, 1);\n              usbd_copy_out(pc, 0, &current_status, 1);\n\n                current_status = (current_status ^ LPS_INVERT) & LPS_MASK;\n                new_status = current_status & ˜sc->sc_previous_status;\n                sc->sc_previous_status = current_status;\n\n                if (new_status & LPS_NERR)\n                        log(LOG_NOTICE, \"%s: output error\\n\",\n                            device_get_nameunit(sc->sc_dev));\n                else if (new_status & LPS_SELECT)\n                        log(LOG_NOTICE, \"%s: offline\\n\",\n                            device_get_nameunit(sc->sc_dev));\n                else if (new_status & LPS_NOPAPER)\n                        log(LOG_NOTICE, \"%s: out of paper\\n\",\n                            device_get_nameunit(sc->sc_dev));\n\n                break;\n        default:\n                break;\n        }\n}\n```"]