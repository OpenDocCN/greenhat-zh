["```\n==============================================\n Juggling with packets: floating data storage\n==============================================\n\n  \"Your dungeon is built on an incline. Angry monsters can't play marbles!\"\n\n  Wojciech Purczynski <cliph@isec.pl>\n  Michal Zalewski <lcamtuf@coredump.cx>\n\n1) Juggle with oranges!\n------------------------\n  Most of us, including the authors of this paper, have attempted to juggle\n with three or more apples, oranges, or other fragile ballistic objects. The\n effect is usually rather pathetic, but most adept juggler padawans sooner or\n later learn to do it without inflicting excessive collateral damage.\n\n  A particularly bright juggler trainee may notice that, as long as he\n continues to follow a simple procedure, at least one of the objects is in the\n air at all times and that he has to hold at most two objects in his hands at\n once. Yet, each and every apple goes through his hands every once in a while,\n and he can recover it at will.\n\n  After some fun with juggling, he may decide that the entire process is\n extremely boring and go back to his computer. While checking his e-mail, an\n educated juggler might notice that a typical network service has but one duty:\n to accept and process data coming from a remote system and take whatever steps\n it deems appropriate based on its interpretation of the data. Many of those\n services do their best to behave robustly, to be fault tolerant, and to supply\n useful feedback about the transaction.\n\n  In some cases, the mere fact that a service is attempting to process the\n data and reply according to protocol can be used in ways that the authors\n never dreamed of. One of the more spectacular examples of this, which our\n fellow juggler might be familiar with, is research done at the University of\n Notre Dame, titled \"Parasitic Computing\" and published in letters to \"Nature.\"\n\n  Nevertheless, our hero concludes that such attempts are quite impractical in\n the real world. The cost of preparing and delivering trivia to be solved far\n exceeds any eventual gain since the sender has to perform operations of\n comparable computational complexity simply to deliver the request. \"The\n computing power of such a device is puny!\" he says.\n\n  A real juggler would focus on a different kind of outsourced data\n processing, one that is much closer to his domain of expertise. Why not\n implement a distributed fruit-based data storage? What if I write a single\n letter on every orange and then start juggling? I can then store more orange\n bytes than my physical capacity (the number of oranges I can hold in my\n hands)! How brilliant. . . . But, but, would it work without oranges?\n\n2) The same, without oranges\n-----------------------------\n\n  This paper is based on the observation that for all network communications,\n there is a nonzero (and often considerable) delay between sending information\n and receiving a reply--a result of the physical constrains of the medium and\n the time it takes to process data on all computer equipment.\n\n  Like an orange with a message written on it, a packet used to store a piece\n of data travels for a period of time before returning to the source, and for\n this period of time we can safely forget its message without losing data. As\n such, the Internet has a nonzero momentary data storage capacity, and it is\n possible to push out a piece of information and effectively have it stored\n until echoed back. By establishing a mechanism for the cyclic transmission and\n reception of chunks of data to and from a number of remote hosts, it is\n possible to maintain an arbitrary amount of data constantly 'on the wire,'\n thus establishing a high-capacity, volatile medium.\n\n  This medium can be used for memory-expensive operations, either as regular\n storage or for certain types of sensitive data for which one does not want to\n have leave a physical trail on a hard disk or other nonvolatile media.\n\n  Since it is not considered bad programming practice to return as much\n relevant information to the sender as the sender sends to the service, and\n because many services or stacks maintain a high level of verbosity, our\n juggling experience tells us that it is not only possible, but also feasible,\n to establish this kind of storage, even over a low-end network hookup. Unlike\n traditional methods of parasitic data storage (such as P2P abuse, open FTP\n servers, binary Usenet postings, and so on), this particular method may or may\n not leave a trail of data (depending on how we implement it), and it does not\n put any single system under a noticeable load. Therefore, unlike the\n traditional methods, this technique is less likely to be detected and\n considered an abuse. Hence, the possibility of the data being intercepted and\n purposefully discarded is much less a problem.\n\n3) Class A data storage: memory buffers\n----------------------------------------\n\n  Class A data storage uses the capacity inherent in communication delays\n during the transmission and processing of live data as it travels across\n networks between two endpoints. The information stored herein remains cached\n in the memory of a remote machine and is not likely to be swapped out to a\n disk device.\n\n  Examples of class A memory are a variety of schemes that rely on sending a\n message that is known to result in partial or full echo of the original\n request, including the following:\n\n    - SYN+ACK, RST+ACK responses to SYN packets, and other bounces\n\n    - ICMP echo replies\n\n    - DNS lookup responses and cache data. It is possible to store some\n      information in a lookup request and have it bounce back with an NXDomain\n      reply or to store data in an NS cache.\n\n    - Cross-server chat network message relaying. Relaying text messages\n      across IRC servers and so on can exhibit considerable latency.\n\n    - HTTP, FTP, web proxy, or SMTP error or status replies.\n\n  The most important properties of class A storage are:\n\n    - Low latency (milliseconds to minutes), which makes it more useful for\n       near random access memory applications.\n\n    - Lower per-system capacity (usually kilobytes), which makes it less\n       suitable for massive storage.\n\n    - Only one chance to receive or few retransmits which make it less\n       reliable in case of a network failure.\n\n    - Lower likelihood of permanent recording. The data is not likely to be\n       stored on a nonvolatile medium or swapped out, increasing privacy and\n       deniability.\n\n  In particular, when using higher-level protocols, additional features appear\nthat might solve some of the low-capacity and short- recovery window problems\n shared by various types of class A storage. For example, it is possible to\n establish a connection to a service such as SMTP, FTP, HTTP, or any other\n text-based service and send a command that is known to result in an\n acknowledgment or error message being echoed along with part of the original\n data. We do not, however, send a fully formatted message; we leave some\n necessary characters unsent. In most cases, end-of-line characters are\n required in order to complete the command. In this state, our data is already\n stored on remote service waiting for a complete command or until connection\n time-out occurs. To prevent time-outs, either on TCP or at the application\n level, no-op packets need to be sent periodically. A \\0 character interpreted\n as an empty string has no effect on many services but is sufficient to reset\n TCP and service time-out timers. A prominent example of an application\n vulnerable to this attack is Microsoft Exchange.\n\n  The attacker can sustain the connection for an arbitrary amount of time,\n with a piece of data already stored at the other end. To recover the\n information, the command must be completed with the missing \\r\\n, and then the\n response is sent to the client.\n\n  A good example is the SMTP VRFY command:\n\n  220 inet-imc-01.redmond.corp.microsoft.com Microsoft.com ESMTP Server\n  Thu, 2 Oct 2003 15:13:22 âˆ’0700\n  VRFY AAAA...\n  252 2.1.5 Cannot VRFY user, but will take message for\n  <AAAA...@microsoft.com>\n\n  It is possible to store just over 300 bytes, including nonprintable\n characters, this way--and have it available almost instantly. More data can be\n stored if the HTTP TRACE method is used with data passed in arbitrary HTTP\n headers, depending on the server software. Sustained connections can give us\n arbitrarily high latency, thus creating large storage capacity.\n\n  This type of storage is naturally more suited for privacy-critical\n applications or low-latency lower to medium capacity storage (immediate RAM-\nextending storage for information that should leave no visible traces). The\n storage is not suitable for critical data that should be preserved at all\n costs, due to the risk of data being lost on network failure.\n\n4) Class B data storage: disk queues\n-------------------------------------\n\n  Class B data storage uses \"idle\" data queues that store information for an\n extended period of time (often on the disk). For example, MTA systems can\n queue e-mail messages for as many as 7 days (or more, depending on the\n configuration). This feature can give us a long delay between sending data to\n store on the remote host and receiving it. Because a typical SMTP server\n prevents the relay of e-mail from the client to itself, e-mail bounces can be\n used to have data returned after a long period of time.\n\n  For example, consider this potential attack scenario:\n\n  1\\. The user builds a list of SMTP servers (perhaps servers that provide a\n      reasonable expectation of being beyond the reach of their foes).\n\n  2\\. The user blocks (with block/drop, not reject) all incoming connections to\n      their port 25.\n\n  3\\. For each server, the attacker has to confirm its delivery time-outs and\n      the IP from which the server connects back while trying to return a\n      bounce. This is done by sending an appropriate probe to an address local\n      to the server (or requesting a DSN notification for a valid address) and\n      checking to see how long the server tries to connect back before giving\n      up. The server does not have to be an open relay.\n\n  4\\. After confirming targets, the attacker starts sending data at a pace\n      chosen so that the process is spread evenly over the period of one week.\n      The data should be divided so that there is one chunk per each server.\n      Every chunk is sent to a separate server to immediately generate a bounce\n      back to the sender.\n\n  5\\. The process of maintaining the data boils down to accepting an incoming\n      connection and receiving the return at most a week from the initial\n      submission, just before the entry is about to be removed from the queue.\n      This is done by allowing this particular server to go through the\n      firewall. Immediately after the chunk is received it is relayed back.\n\n  6\\. To access any portion of data, the attacker looks up which MTA is holding\n      this specific block and then allows this IP to connect and deliver the\n      bounce. Three scenarios are possible:\n\n     - If the remote MTA supports the ETRN command, the delivery can be\n        induced immediately.\n\n     - If the remote MTA was in the middle of a three-minute run in an attempt\n        to connect to a local system (keeps retrying thanks to the fact its SYN\n        packets are dropped, not rejected with RST+ACK), the connection can be\n        established in a matter of seconds.\n\n     - Otherwise, it is necessary to wait from five minutes to one hour,\n        depending on the queue settings.\n\n  This scheme can be enhanced using DNS names instead of IPs for users on\n dynamic IP or to provide additional protection (or when it is necessary to cut\n the chain immediately).\n\n  The important properties of class B storage are:\n\n    - High per-system capacity (megabytes), making it a perfect solution for\n       storing large files and so on\n\n    - Higher access latency (minutes to hours), likening it to a tape device,\n       not RAM (with the exception of SMTP hosts that accept the ETRN command\n       to immediately reattempt delivery)\n\n    - Very long lifetime, increasing per-user capacity and reliability\n\n    - Plenty of delivery attempts, making it easy to recover the data even\n       after temporary network or hardware problems\n\n    - Likely to leave a trace on the storage devices, making it a less-useful\n       solution for fully deniable storage (although it would still require\n       examining a number of foreign systems, which does not have to be\n       feasible)\n\n  Class B storage is suitable for storing regular file archives, large append-\nonly buffers, encrypted resources (with a proper selection of hosts, it\n remains practically deniable), etc.\n\n5) Discreet class A storage\n----------------------------\n\n  In certain situations, it might be necessary to devise a solution for\n discreet data storage that does not reside on the machine itself and that\n makes it possible to deny the presence of this information anywhere.\n\n  The basic requirement is that the data is:\n\n    - Not returned until a special key sequence is sent\n\n    - Permanently discarded without leaving any record on any nonvolatile\n       storage media in the absence of keep-alive requests\n\n  It is possible to use class A storage to implement this functionality using\n the sustained command method discussed earlier. The proper TCP sequence number\n is necessary to release the data, and until this sequence is delivered, the\n data is not returned or disclosed to any party. If the client node goes\n offline, the data is discarded and likely overwritten.\n\n  The sequence number is thus the key to the stored information, and, if the\n lifetime of the data is fairly short when keep-alive \\0s stop coming, it is\n often adequate protection.\n\n6) User-accessible capacity\n----------------------------\n\n  In this section, we attempt to estimate the storage capacity available to a\n single user.\n\n  In order to maintain a constant amount of data \"outsourced\" to the network,\n we must be able to receive and send it back on a regular basis.\n\n  The amount of time that data can be stored remotely is constrained by the\n maximum lifetime Tmax of a single packet (including packet queuing and\n processing delays). The maximum amount of data that can be sent is limited by\n maximum available network bandwidth (L). Thus, the maximum capacity\n can be defined as:\n\n    Cmax [bytes] = L [bytes/second] * Tmax [seconds] / Psize * Dsize\n\nwhere:\n\n    Dsize - The size of a packet required to store an initial portion of data\n on a remote host\n\nPsize - The size of a packet required to sustain the information stored on\n a remote host\n\n  Psize and Dsize are equal and thus can be omitted whenever the entire chunk\n of data is bounced back and forth; they differ only for \"sustained command\"\n scenarios. The smallest TCP/IP packet to accomplish this has 41 bytes. The\n maximum amount of data that can be sustained using HTTP headers is about 4096 bytes.\n\n  That all, in turn, gives us the following chart:\n\n            Bandwidth  | Class A | Class B\n           -----------+---------+---------\n            28.8 kbps |  105 MB |    2 GB\n             256 kbps |  936 MB |   18 GB\n               2 Mbps |  7.3 GB |  147 GB\n             100 Mbps |  365 GB |    7 TB\n\n7) Internet as a whole\n-----------------------\n\n  In this section, we attempt to estimate the theoretical momentary capacity\n of the Internet as a whole.\n\n  Class A\n\n    To estimate the theoretical class A storage capacity of the Internet, we\n     assume the following:\n\n      - ICMP messages offer the best balance between storage capacity and\n         preserving a remote system's resources.\n\n      - An average operating system has a packet input queue capable of\n         holding at least 64 packets.\n\n      - The default PMTU is approximately 1500 (the most common MTU).\n\n    As an estimate of the number of hosts on the Internet we use an ISC survey\n     for 2003, which lists 171,638,297 systems with reverse DNS entries\n     (although not all IPs with reverse DNS have to be operational). To take\n     this into account, we used the ICMP echo response ratio calculated from\n     the last survey that performed such a test (in 1999). The data then\n     suggested that approximately 20 percent of visible systems were alive,\n     which, in turn, sets the number of systems ready to respond to ICMP\n     requests at roughly 34,000,000.\n\n    By multiplying the number of systems that reply to ICMP echo requests by\n     the average packet cache size and maximum packet size (minus headers), we\n     estimate the total theoretical momentary capability for class A ICMP\n     storage to be approximately 3 TB.\n\nClass B:\n\n    To estimate theoretical class B storage capacity, we use the example of\n     MTA software. There is no upper cap for the amount of data we feed to a\n     single host. Although it is safe to assume that only messages under\n     approximately 1 MB will not cause noticeable system load and other\n     undesirable effects, we assume that the average maximum queue size is\n     500 MB.\n\n    Our own research suggests that roughly 15 percent of systems that respond\n     to ping requests have port 25 open. We thus estimate the population of\n     SMTP servers to be 3 percent (15 percent of 20 percent) of the total host\n     count, or just over 5,000,000 hosts.\n\n    This gives a total storage space capacity of 2500 TB.\n```"]