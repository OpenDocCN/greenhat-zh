- en: '[1] 123 4 5 6'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 123 4 5 6'
- en: scan("z2.txt")
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: scan("z2.txt")
- en: Read 4 items
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 读取4个项目
- en: '[1] 123.0 4.2 5.0 6.0'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 123.0 4.2 5.0 6.0'
- en: scan("z3.txt")
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: scan("z3.txt")
- en: 'Error in scan(file, what, nmax, sep, dec, quote, skip, nlines, na.strings,
    : scan() expected ''a real'', got ''abc'''
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 错误在scan(file, what, nmax, sep, dec, quote, skip, nlines, na.strings, )：scan()期望'a
    real'，但得到'abc'
- en: scan("z3.txt",what="")
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: scan("z3.txt",what="")
- en: '**232**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**232**'
- en: Chapter 10
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第10章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Read 4 items
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 读取4个项目
- en: '[1] "abc" "de" "f" "g"'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "abc" "de" "f" "g"'
- en: scan("z4.txt",what="")
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: scan("z4.txt",what="")
- en: Read 4 items
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 读取4个项目
- en: '[1] "abc" "123" "6" "y"'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "abc" "123" "6" "y"'
- en: In the first call, we got a vector of four integers (though the mode is numeric).
    The second time, since one number was nonintegral, the others were shown as floating-point
    numbers, too.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次调用中，我们得到了一个包含四个整数的向量（尽管模式是数值）。第二次调用时，由于一个数字不是整数，其他数字也显示为浮点数。
- en: In the third case, we got an error. The scan() function has an optional argument
    named what, which specifies mode, defaulting to double mode. So, the nonnumeric
    contents of the file *z3* produced an error. But we then tried again, with what="".
    This assigns a character string to what, indicating that we want character mode.
    (We could have set what to any character string.) The last call worked the same
    way. The first item was a character string, so it treated all the items that followed
    as strings too.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三种情况下，我们得到了一个错误。scan()函数有一个名为what的可选参数，它指定了模式，默认为双精度模式。因此，文件*z3*的非数值内容产生了错误。但然后我们再次尝试，with
    what="".这分配了一个字符字符串给what，表示我们想要字符模式。（我们也可以将what设置为任何字符字符串。）最后的调用以相同的方式工作。第一个项目是一个字符字符串，因此它将所有后续的项目也视为字符串。
- en: 'Of course, in typical usage, we would assign the return value of scan() to
    a variable. Here’s an example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在典型用法中，我们会将scan()的返回值赋给一个变量。以下是一个示例：
- en: v <- scan("z1.txt")
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: v <- scan("z1.txt")
- en: 'By default, scan() assumes that the items of the vector are separated by *whitespace*,
    which includes blanks, carriage return/line feeds, and horizontal tabs. You can
    use the optional sep argument for other situations. As example, we can set sep
    to the newline character to read in each line as a string, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，scan()假设向量的项由空白分隔，包括空格、回车/换行符和水平制表符。你可以使用可选的sep参数来处理其他情况。例如，我们可以将sep设置为换行符，以便将每一行作为字符串读取，如下所示：
- en: x1 <- scan("z3.txt",what="")
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x1 <- scan("z3.txt",what="")
- en: Read 4 items
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 读取4个项目
- en: x2 <- scan("z3.txt",what="",sep="\n") Read 3 items
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x2 <- scan("z3.txt",what="",sep="\n") 读取3个项目
- en: x1
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x1
- en: '[1] "abc" "de" "f"'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "abc" "de" "f"'
- en: '"g"'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '"g"'
- en: x2
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x2
- en: '[1] "abc" "de f" "g"'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "abc" "de f" "g"'
- en: x1[2]
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x1[2]
- en: '[1] "de"'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "de"'
- en: x2[2]
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x2[2]
- en: '[1] "de f"'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "de f"'
- en: In the first case, the strings "de" and "f" were assigned to separate elements
    of x1\. But in the second case, we specified that elements of x2 were to be delineated
    by end-of-line characters, not spaces. Since "de" and "f" are on the same line,
    they are assigned together to x[2].
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，字符串"de"和"f"被分配给了x1的不同元素。但在第二种情况下，我们指定x2的元素由换行符分隔，而不是空格。由于"de"和"f"在同一行，它们被一起分配给了x[2]。
- en: More sophisticated methods for reading files will be presented later in this
    chapter, such as methods to read in a file one line at a time. But if you want
    to read the entire file at once, scan() provides a quick solution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面将介绍更复杂的读取文件的方法，例如逐行读取文件的方法。但如果你想要一次性读取整个文件，scan()提供了一个快速解决方案。
- en: Input/Output
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出
- en: '**233**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**233**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'You can use scan() to read from the keyboard by specifying an empty string
    for the filename:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用scan()从键盘读取，通过指定空字符串作为文件名：
- en: v <- scan("")
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: v <- scan("")
- en: '1: 12 5 13'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '1: 12 5 13'
- en: '4: 3 4 5'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '4: 3 4 5'
- en: '7: 8'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '7: 8'
- en: '8:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '8:'
- en: Read 7 items
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 读取7个项目
- en: v
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: v
- en: '[1] 12 5 13 3 4 5 8'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 12 5 13 3 4 5 8'
- en: Note that we are prompted with the index of the next item to be input, and we
    signal the end of input with an empty line.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们会提示输入下一个项目的索引，并且通过空行来表示输入的结束。
- en: If you do not wish scan() to announce the number of items it has read, include
    the argument quiet=TRUE.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想scan()宣布它读取的项目数量，包括quiet=TRUE参数。
- en: '***10.1.2 Using the readline() Function***'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.1.2 使用readline()函数***'
- en: If you want to read in a single line from the keyboard, readline() is very handy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从键盘读取单行，readline()非常方便。
- en: w <- readline()
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: w <- readline()
- en: abc de f
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: abc de f
- en: w
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: w
- en: '[1] "abc de f"'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "abc de f"'
- en: 'Typically, readline() is called with its optional prompt, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，readline()函数会带上可选的提示符，如下所示：
- en: 'inits <- readline("type your initials: ")'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: inits <- readline("请输入您的首字母：")
- en: 'type your initials: NM'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请输入您的首字母：NM
- en: inits
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 初始化
- en: '[1] "NM"'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "NM"'
- en: '***10.1.3 Printing to the Screen***'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.1.3 打印到屏幕***'
- en: 'At the top level of interactive mode, you can print the value of a variable
    or expression by simply typing the variable name or expression. This won’t work
    if you need to print from within the body of a function. In that case, you can
    use the print() function, like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式模式的顶层，您可以通过简单地输入变量名或表达式来打印变量的值或表达式。如果您需要在函数体内部打印，则无法这样做。在这种情况下，您可以使用 print()
    函数，如下所示：
- en: x <- 1:3
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- 1:3
- en: print(x^2)
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print(x^2)
- en: '[1] 1 4 9'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 4 9'
- en: Recall that print() is a *generic* function, so the actual function called will
    depend on the class of the object that is printed. If, for example, the argument
    is of class "table", then the print.table() function will be called.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，print() 是一个 *通用* 函数，因此实际调用的函数将取决于打印的对象的类。例如，如果参数是 "table" 类，则将调用 print.table()
    函数。
- en: '**234**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**234**'
- en: Chapter 10
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter 10
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: It’s a little better to use cat() instead of print(), as the latter can print
    only one expression and its output is numbered, which may be a nuisance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cat() 而不是 print() 会更好一些，因为后者只能打印一个表达式，并且其输出是编号的，这可能会造成不便。
- en: 'Compare the results of the functions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 比较函数的结果：
- en: print("abc")
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("abc")
- en: '[1] "abc"'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "abc"'
- en: cat("abc\n")
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cat("abc\n")
- en: abc
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: abc
- en: Note that we needed to supply our own end-of-line character, "\n", in the call
    to cat(). Without it, our next call would continue to write to the same line.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在调用 cat() 时，我们需要提供自己的换行符，"\n"。如果没有它，我们的下一个调用将继续写入同一行。
- en: 'The arguments to cat() will be printed out with intervening spaces:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: cat() 的参数将以空格分隔打印出来：
- en: x
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x
- en: '[1] 1 2 3'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 2 3'
- en: cat(x,"abc","de\n")
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cat(x,"abc","de\n")
- en: 1 2 3 abc de
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 3 abc de
- en: 'If you don’t want the spaces, set sep to the empty string "", as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想有空间，将 sep 设置为空字符串 ""，如下所示：
- en: cat(x,"abc","de\n",sep="")
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cat(x,"abc","de\n",sep="")
- en: 123abcde
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 123abcde
- en: 'Any string can be used for sep. Here, we use the newline character:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用任何字符串作为 sep。在这里，我们使用换行符：
- en: cat(x,"abc","de\n",sep="\n")
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cat(x,"abc","de\n",sep="\n")
- en: '1'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: abc
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: abc
- en: de
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: de
- en: 'You can even set sep to be a vector of strings, like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以将 sep 设置为字符串向量，如下所示：
- en: x <- c(5,12,13,8,88)
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- c(5,12,13,8,88)
- en: cat(x,sep=c(".",".",".","\n","\n")) 5.12.13.8
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cat(x,sep=c(".",".",".","\n","\n")) 5.12.13.8
- en: '88'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '88'
- en: '**10.2 Reading and Writing Files**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.2 读取和写入文件**'
- en: Now that we’ve covered the basics of I/O, let’s get to some more practical applications
    of reading and writing files. The following sections discuss reading data frames
    or matrices from files, working with text files, accessing files on remote machines,
    and getting file and directory information.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了 I/O 的基础知识，让我们来看看读取和写入文件的一些更实际的应用。以下各节讨论从文件中读取数据框或矩阵、处理文本文件、访问远程机器上的文件以及获取文件和目录信息。
- en: Input/Output
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出
- en: '**235**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**235**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***10.2.1 Reading a Data Frame or Matrix from a File***'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2.1 从文件中读取数据框或矩阵***'
- en: 'In Section 5.1.2, we discussed the use of the function read.table() to read
    in a data frame. As a quick review, suppose the file *z* looks like this: name
    age'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 5.1.2 节中，我们讨论了使用 read.table() 函数读取数据框的使用。作为一个快速回顾，假设文件 *z* 看起来像这样：name age
- en: John 25
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: John 25
- en: Mary 28
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Mary 28
- en: Jim 19
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Jim 19
- en: 'The first line contains an optional header, specifying column names. We could
    read the file this way:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含一个可选的标题，指定列名。我们可以这样读取文件：
- en: z <- read.table("z",header=TRUE)
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z <- read.table("z",header=TRUE)
- en: z
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z
- en: name age
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: name age
- en: 1 John 25
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 1 John 25
- en: 2 Mary 28
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 2 Mary 28
- en: 3 Jim 19
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 3 Jim 19
- en: Note that scan() would not work here, because our file has a mixture of numeric
    and character data (and a header).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，scan() 在这里不会工作，因为我们的文件包含数字和字符数据的混合（以及一个标题）。
- en: There appears to be no direct way of reading in a matrix from a file, but it
    can be done easily with other tools. A simple, quick way is to use scan() to read
    in the matrix row by row. You use the byrow option in the function matrix() to
    indicate that you are defining the elements of the matrix in a row-wise, rather
    than column-wise, manner.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中直接读取矩阵似乎没有直接的方法，但可以使用其他工具轻松完成。一种简单快捷的方法是使用 scan() 逐行读取矩阵。您在 matrix() 函数中使用
    byrow 选项来指示您正在按行定义矩阵的元素，而不是按列定义。
- en: 'For instance, say the file *x* contains a 5-by-3 matrix, stored row-wise: 1
    0 1'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设文件 *x* 包含一个 5 行 3 列的矩阵，按行存储：1 0 1
- en: 1 1 1
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 1 1 1
- en: 1 1 0
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 1 1 0
- en: 1 1 0
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 1 1 0
- en: 0 0 1
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0 1
- en: 'We can read it into a matrix this way:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样将其读入矩阵：
- en: x <- matrix(scan("x"),nrow=5,byrow=TRUE)
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- matrix(scan("x"),nrow=5,byrow=TRUE)
- en: 'This is fine for quick, one-time operations, but for generality, you can use
    read.table(), which returns a data frame, and then convert via as.matrix(). Here
    is a general method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于快速的一次性操作是可行的，但为了通用性，您可以使用read.table()，它返回一个数据框，然后通过as.matrix()进行转换。这里有一个通用方法：
- en: read.matrix <- function(filename) {
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: read.matrix <- function(filename) {
- en: as.matrix(read.table(filename))
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: as.matrix(read.table(filename))
- en: '}'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**236**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**236**'
- en: Chapter 10
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第10章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***10.2.2 Reading Text Files***'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2.2 读取文本文件***'
- en: In computer literature, there is often a distinction made between *text files*
    and *binary files*. That distinction is somewhat misleading—every file is binary
    in the sense that it consists of 0s and 1s. Let’s take the term *text file* to
    mean a file that consists mainly of ASCII characters or coding for some other
    human language (such as GB for Chinese) and that uses newline characters to give
    humans the perception of lines. The latter aspect will turn out to be central
    here. Nontext files, such as JPEG images or executable program files, are generally
    called *binary files*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机文献中，经常将*文本文件*和*二进制文件*区分开来。这种区分有些误导——从本质上讲，每个文件都是由0和1组成的二进制文件。让我们将*文本文件*这个术语理解为主要由ASCII字符或其他人类语言（如中文的GB编码）编码组成的文件，并使用换行符来给人类提供行的感知。后一个方面将在这里变得至关重要。非文本文件，如JPEG图像或可执行程序文件，通常被称为*二进制文件*。
- en: 'You can use readLines() to read in a text file, either one line at a time or
    in a single operation. For example, suppose we have a file *z1* with the following
    contents:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用readLines()来读取文本文件，一次读取一行或一次性读取。例如，假设我们有一个名为*z1*的文件，其内容如下：
- en: John 25
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: John 25
- en: Mary 28
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Mary 28
- en: Jim 19
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Jim 19
- en: 'We can read the file all at once, like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以一次性读取整个文件，如下所示：
- en: z1 <- readLines("z1")
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z1 <- readLines("z1")
- en: z1
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z1
- en: '[1] "John 25" "Mary 28" "Jim 19"'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "John 25" "Mary 28" "Jim 19"'
- en: Since each line is treated as a string, the return value here is a vector of
    strings—that is, a vector of character mode. There is one vector element for each
    line read, thus three elements here.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每一行都被视为一个字符串，这里的返回值是一个字符串向量——即字符模式的向量。对于每读取一行，都有一个向量元素，因此这里有三个元素。
- en: Alternatively, we can read it in one line at a time. For this, we first need
    to create a connection, as described next.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以逐行读取。为此，我们首先需要创建一个连接，如下所述。
- en: '***10.2.3 Introduction to Connections***'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2.3 连接简介***'
- en: '*Connection* is R’s term for a fundamental mechanism used in various kinds
    of I/O operations. Here, it will be used for file access.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*连接*是R在各类输入/输出操作中使用的根本机制。在这里，它将被用于文件访问。'
- en: 'The connection is created by calling file(), url(), or one of several other
    R functions. To see a list of those functions, type this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 连接是通过调用file()、url()或R的几个其他函数创建的。要查看这些函数的列表，请输入以下内容：
- en: ?connection
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ?连接
- en: 'So, we can now read in the *z1* file (introduced in the previous section) line
    by line, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以按如下方式逐行读取上一节中介绍的*z1*文件：
- en: c <- file("z1","r")
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c <- file("z1","r")
- en: readLines(c,n=1)
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: readLines(c,n=1)
- en: '[1] "John 25"'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "John 25"'
- en: readLines(c,n=1)
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: readLines(c,n=1)
- en: '[1] "Mary 28"'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "Mary 28"'
- en: readLines(c,n=1)
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: readLines(c,n=1)
- en: '[1] "Jim 19"'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "Jim 19"'
- en: Input/Output
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出
- en: '**237**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**237**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: readLines(c,n=1)
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: readLines(c,n=1)
- en: character(0)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: character(0)
- en: We opened the connection, assigned the result to c, and then read the file one
    line at a time, as specified by the argument n=1\. When R encountered the end
    of file (EOF), it returned an empty result. We needed to set up a connection so
    that R could keep track of our position in the file as we read through it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开了连接，将结果赋值给c，然后按指定的n=1参数逐行读取文件。当R遇到文件末尾（EOF）时，它返回一个空结果。我们需要设置一个连接，以便R在读取文件时能够跟踪我们的位置。
- en: 'We can detect EOF in our code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在代码中检测到文件结束符（EOF）：
- en: c <- file("z","r")
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c <- file("z","r")
- en: while(TRUE) {
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: while(TRUE) {
- en: +
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: rl <- readLines(c,n=1)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: rl <- readLines(c,n=1)
- en: +
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: if (length(rl) == 0) {
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: if (length(rl) == 0) {
- en: +
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: print("reached the end")
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: print("到达文件末尾")
- en: +
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: break
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: +
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: '} else print(rl)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '} else print(rl)'
- en: + }
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: + }
- en: '[1] "John 25"'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "John 25"'
- en: '[1] "Mary 28"'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "Mary 28"'
- en: '[1] "Jim 19"'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "Jim 19"'
- en: '[1] "reached the end"'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "到达文件末尾"'
- en: 'If we wish to “rewind”—to start again at the beginning of the file—we can use
    seek():'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望“重置”——从文件开头重新开始，我们可以使用seek()：
- en: c <- file("z1","r")
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c <- file("z1","r")
- en: readLines(c,n=2)
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: readLines(c,n=2)
- en: '[1] "John 25" "Mary 28"'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "John 25" "Mary 28"'
- en: seek(con=c,where=0)
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: seek(con=c,where=0)
- en: '[1] 16'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 16'
- en: readLines(c,n=1)
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: readLines(c,n=1)
- en: '[1] "John 25"'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "John 25"'
- en: The argument where=0 in our call to seek() means that we wish to position the
    file pointer zero characters from the start of the file—in other words, directly
    at the beginning.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对seek()的调用中where=0的参数意味着我们希望将文件指针定位在文件开始处零个字符的位置——换句话说，直接在开头。
- en: The call returns 16, meaning that the file pointer was at position 16
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通话返回16，表示文件指针位于位置16
- en: before we made the call. That makes sense. The first line consists of "John
    25"
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们打电话之前。这很有道理。第一行由"John 25"组成
- en: '*plus* the end-of-line character, for a total of eight characters, and the
    same is true for the second line. So, after reading the first two lines, we were
    at position 16\.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*加上*行尾字符，总共八个字符，第二行也是如此。因此，在读取前两行之后，我们位于位置16。'
- en: You can close a connection by calling—what else?—close(). You would use this
    to let the system know that the file you have been writing is complete and should
    now be officially written to disk. As another example, in a client/server relationship
    over the Internet (see Section 10.3.1), a client would use close() to indicate
    to the server that the client is signing off.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用——还能是什么？——close()来关闭连接。你会使用这个来让系统知道你一直在写入的文件现在已经完成，应该现在正式写入磁盘。作为另一个例子，在互联网上的客户端/服务器关系（见第10.3.1节），客户端会使用close()来向服务器指示客户端正在注销。
- en: '**238**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**238**'
- en: Chapter 10
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第10章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***10.2.4 Extended Example: Reading PUMS Census Files***'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2.4 扩展示例：读取PUMS人口普查文件***'
- en: The U.S. Census Bureau makes census data available in the form of Public Use
    Microdata Samples (PUMS). The term *microdata* here means that we are dealing
    with raw data and each record is for a real person, as opposed to statistical
    summaries. Data on many, many variables are included.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 美国人口普查局以公共使用微观数据样本（PUMS）的形式提供人口普查数据。这里的*微观数据*意味着我们处理的是原始数据，每条记录对应一个真实的人，而不是统计摘要。包括许多变量的数据。
- en: The data is organized by household. For each unit, there is first a Household
    record, describing the various characteristics of that household, followed by
    one Person record for each person in the household. Character positions 106 and
    107 (with numbering starting at 1) in the Household record state the number of
    Person records for that household. (The number can be very large, since some institutions
    count as households.) To enhance the integrity of the data, character position
    1 contains H or P to confirm that this is a Household or Person record. So, if
    you read an H record, and it tells you there are three people in the household,
    then the following three records should be P records, followed by another H record;
    if not, you’ve encountered an error.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 数据按家庭组织。对于每个单位，首先有一个家庭记录，描述该家庭的各项特征，然后为家庭中的每个人提供一个个人记录。家庭记录中的第106位和第107位（从1开始编号）表示该家庭的个人记录数量。（这个数字可能非常大，因为一些机构被视为家庭。）为了增强数据的完整性，第1位字符包含H或P以确认这是一个家庭或个人记录。因此，如果你读取一个H记录，并且它告诉你家庭中有三个人，那么接下来的三个记录应该是P记录，然后是另一个H记录；如果不是，你遇到了错误。
- en: 'As our test file, we’ll take the first 1,000 records of the year 2000 1 percent
    sample. The first few records look like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的测试文件，我们将取2000年1%样本的前1000条记录。前几条记录看起来像这样：
- en: H000019510649
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: H000019510649
- en: '06010'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '06010'
- en: 99979997 70
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 99979997 70
- en: '631973'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '631973'
- en: '15758'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '15758'
- en: 59967658436650000012000000 0 0 0 0 0 0 0 0 0 0 0 0 0
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 59967658436650000012000000 0 0 0 0 0 0 0 0 0 0 0 0 0
- en: '0'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 0 0 0
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0 0
- en: 0 0
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0
- en: 0 0000 0
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0000 0
- en: '0'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 0 0 0
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0 0
- en: '00000000000000000000000000000'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '00000000000000000000000000000'
- en: '00000000000000000000000000'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '00000000000000000000000000'
- en: P00001950100010923000420190010110000010147050600206011099999904200000 0040010000
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: P00001950100010923000420190010110000010147050600206011099999904200000 0040010000
- en: 00300280
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 00300280
- en: 28600 70
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 28600 70
- en: '9997'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '9997'
- en: '9997202020202020220000040000000000000006000000'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '9997202020202020220000040000000000000006000000'
- en: 00000 00
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 00000 00
- en: '0000'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '0000'
- en: 00000000000000000132241057904MS
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 00000000000000000132241057904MS
- en: 476041-20311010310
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 476041-20311010310
- en: 07000049010000000000900100000100000100000100000010000001000139010000490000
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 07000049010000000000900100000100000100000100000010000001000139010000490000
- en: H000040710649
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: H000040710649
- en: '06010'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '06010'
- en: 99979997 70
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 99979997 70
- en: '631973'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '631973'
- en: '15758'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '15758'
- en: 599676584365300800200000300106060503010101010102010 01200006000000100001
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 599676584365300800200000300106060503010101010102010 01200006000000100001
- en: 00600020 0
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 00600020 0
- en: 0 0
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0
- en: 0 0000 0
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0000 0
- en: '0'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 0 0 0
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0 0
- en: '02000102010102200000000010750'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '02000102010102200000000010750'
- en: '02321125100004000000040000'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '02321125100004000000040000'
- en: P00004070100005301000010380010110000010147030400100009005199901200000 0006010000
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: P00004070100005301000010380010110000010147030400100009005199901200000 0006010000
- en: '00100000'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '00100000'
- en: 00000 00
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 00000 00
- en: '0000'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '0000'
- en: '0000202020202020220000040000000000000001000060'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '0000202020202020220000040000000000000001000060'
- en: 06010 70
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 06010 70
- en: '9997'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '9997'
- en: '99970101004900100000001018703221'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '99970101004900100000001018703221'
- en: 770051-10111010500
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 770051-10111010500
- en: '40004000000000000000000000000000000000000000000000000000004000000040000349'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '40004000000000000000000000000000000000000000000000000000004000000040000349'
- en: P00004070200005303011010140010110000010147050000204004005199901200000 0006010000
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: P00004070200005303011010140010110000010147050000204004005199901200000 0006010000
- en: '00100000'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '00100000'
- en: 00000 00
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 00000 00
- en: '0000'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '0000'
- en: 000020202020 0 0200000000000000000000000050000
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '00002020202002000000000000000000000050000'
- en: 00000 00
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 00000 00
- en: '0000'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '0000'
- en: 000000000000000000000000000000000000000000-00000000000
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 000000000000000000000000000000000000000000-00000000000
- en: '000'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '000'
- en: '0'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 00000000349
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 00000000349
- en: H000061010649
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: H000061010649
- en: '06010'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '06010'
- en: 99979997 70
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 99979997 70
- en: '631973'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '631973'
- en: '15758'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '15758'
- en: 599676584360801190100000200204030502010101010102010 00770004800064000001
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '59967658436080119010000020020403050201010101010201000770004800064000001'
- en: '1'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 0 030
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 0 030
- en: 0 0
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0
- en: 0 0340 00660000000170 0
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0340 00660000000170 0
- en: 06010000000004410039601000000
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 06010000000004410039601000000
- en: 00021100000004940000000000
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 00021100000004940000000000
- en: The records are very wide and thus wrap around. Each one occupies
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 记录非常宽，因此会换行。每一行都占据
- en: four lines on the page here.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上这里有四行。
- en: Input/Output
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出
- en: '**239**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**239**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: We’ll create a function called extractpums() to read in a PUMS file and create
    a data frame from its Person records. The user specifies the filename and lists
    fields to extract and names to assign to those fields.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 extractpums() 的函数，用于读取 PUMS 文件并从其 Person 记录中创建一个数据框。用户指定文件名、要提取的字段列表以及分配给这些字段的名称。
- en: We also want to retain the household serial number. This is good to have because
    data for persons in the same household may be correlated and we may want to add
    that aspect to our statistical model. Also, the household data may provide important
    covariates. (In the latter case, we would want to retain the covariate data as
    well.)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望保留家庭序列号。这很好，因为同一家庭中的人的数据可能相关，我们可能希望将这一方面添加到我们的统计模型中。此外，家庭数据可能提供重要的协变量。（在后一种情况下，我们还想保留协变量数据。）
- en: Before looking at the function code, let’s see what the function does.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看函数代码之前，让我们看看该函数的功能。
- en: In this data set, gender is in column 23 and age in columns 25 and 26\. In the
    example, our filename is *pumsa*. The following call creates a data frame consisting
    of those two variables.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数据集中，性别在第 23 列，年龄在第 25 和 26 列。在示例中，我们的文件名是 *pumsa*。下面的调用创建了一个包含这两个变量的数据框。
- en: pumsdf <- extractpums("pumsa",list(Gender=c(23,23),Age=c(25,26))) Note that
    we are stating here the names we want the columns to have in the resulting data
    frame. We can use any names we want—say Sex and Ancientness.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: pumsdf <- extractpums("pumsa",list(Gender=c(23,23),Age=c(25,26))) Note that
    we are stating here the names we want the columns to have in the resulting data
    frame. We can use any names we want—say Sex and Ancientness.
- en: 'Here is the first part of that data frame:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是该数据框的第一部分：
- en: head(pumsdf)
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: head(pumsdf)
- en: serno Gender Age
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: serno Gender Age
- en: '2'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '195'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '195'
- en: 2 19
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 2 19
- en: '3'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '407'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '407'
- en: 1 38
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 1 38
- en: '4'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '407'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '407'
- en: 1 14
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 1 14
- en: '5'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '610'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '610'
- en: 2 65
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 2 65
- en: 6 1609
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 6 1609
- en: 1 50
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 1 50
- en: 7 1609
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 7 1609
- en: 2 49
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 2 49
- en: The following is the code for the extractpums() function.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为 extractpums() 函数编写的代码。
- en: '1'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: reads in PUMS file pf, extracting the Person records, returning a data 2
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: reads in PUMS file pf, extracting the Person records, returning a data 2
- en: frame; each row of the output will consist of the Household serial 3
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: frame; each row of the output will consist of the Household serial 3
- en: number and the fields specified in the list flds; the columns of
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: number and the fields specified in the list flds; the columns of
- en: '4'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: the data frame will have the names of the indices in flds
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: the data frame will have the names of the indices in flds
- en: '5'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: extractpums <- function(pf,flds) {
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: extractpums <- function(pf,flds) {
- en: '7'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: 'dtf <- data.frame() # data frame to be built'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 'dtf <- data.frame() # data frame to be built'
- en: '8'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: 'con <- file(pf,"r") # connection'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 'con <- file(pf,"r") # connection'
- en: '9'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: process the input file
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理输入文件
- en: '10'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: repeat {
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: repeat {
- en: '11'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: 'hrec <- readLines(con,1) # read Household record'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 'hrec <- readLines(con,1) # read Household record'
- en: '12'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: 'if (length(hrec) == 0) break # end of file, leave loop'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 'if (length(hrec) == 0) break # end of file, leave loop'
- en: '13'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: get household serial number
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取家庭序列号
- en: '14'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: serno <- intextract(hrec,c(2,8))
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: serno <- intextract(hrec,c(2,8))
- en: '**240**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**240**'
- en: Chapter 10
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 第10章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '15'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: how many Person records?
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有多少 Person 记录？
- en: '16'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: npr <- intextract(hrec,c(106,107))
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: npr <- intextract(hrec,c(106,107))
- en: '17'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: if (npr > 0)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: if (npr > 0)
- en: '18'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: for (i in 1:npr) {
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:npr) {
- en: '19'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: 'prec <- readLines(con,1) # get Person record'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 'prec <- readLines(con,1) # get Person record'
- en: '20'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: make this person's row for the data frame
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为这个人的数据框制作一行
- en: '21'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: person <- makerow(serno,prec,flds)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: person <- makerow(serno,prec,flds)
- en: '22'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: add it to the data frame
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: add it to the data frame
- en: '23'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: dtf <- rbind(dtf,person)
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: dtf <- rbind(dtf,person)
- en: '24'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: '}'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '25'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: '}'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '26'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '26'
- en: return(dtf)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: return(dtf)
- en: '27'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '27'
- en: '}'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '28'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '28'
- en: '29'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '29'
- en: set up this person's row for the data frame
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为此人的行设置数据框
- en: '30'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: makerow <- function(srn,pr,fl) {
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: makerow <- function(srn,pr,fl) {
- en: '31'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '31'
- en: l <- list()
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: l <- list()
- en: '32'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '32'
- en: l[["serno"]] <- srn
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: l[["serno"]] <- srn
- en: '33'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '33'
- en: for (nm in names(fl)) {
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: for (nm in names(fl)) {
- en: '34'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '34'
- en: l[[nm]] <- intextract(pr,fl[[nm]])
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: l[[nm]] <- intextract(pr,fl[[nm]])
- en: '35'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '35'
- en: '}'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '36'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '36'
- en: return(l)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 返回(l)
- en: '37'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '37'
- en: '}'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '38'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '38'
- en: '39'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '39'
- en: extracts an integer field in the string s, in character positions 40
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从字符串s中提取整数字段，在字符位置40
- en: rng[1] through rng[2]
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rng[1] through rng[2]
- en: '41'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '41'
- en: intextract <- function(s,rng) {
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: intextract <- function(s,rng) {
- en: '42'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: fld <- substr(s,rng[1],rng[2])
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: fld <- substr(s,rng[1],rng[2])
- en: '43'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '43'
- en: return(as.integer(fld))
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: return(as.integer(fld))
- en: '44'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '44'
- en: '}'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Let’s see how this works. At the beginning of extractpums(), we create an empty
    data frame and set up the connection for the PUMS file read.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的。在extractpums()的开始，我们创建一个空的数据框并设置读取PUMS文件的连接。
- en: 'dtf <- data.frame() # data frame to be built'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 'dtf <- data.frame() # 要构建的数据框'
- en: 'con <- file(pf,"r") # connection'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 'con <- file(pf,"r") # 连接'
- en: The main body of the code then consists of a repeat loop.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的主体部分由一个重复循环组成。
- en: repeat {
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: repeat {
- en: 'hrec <- readLines(con,1) # read Household record'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 'hrec <- readLines(con,1) # 读取家庭记录'
- en: 'if (length(hrec) == 0) break # end of file, leave loop'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 'if (length(hrec) == 0) break # 文件结束，离开循环'
- en: get household serial number
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取家庭序列号
- en: serno <- intextract(hrec,c(2,8))
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: serno <- intextract(hrec,c(2,8))
- en: how many Person records?
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有多少个人记录？
- en: npr <- intextract(hrec,c(106,107))
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: npr <- intextract(hrec,c(106,107))
- en: Input/Output
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出
- en: '**241**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**241**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: if (npr > 0)
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: if (npr > 0)
- en: for (i in 1:npr) {
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:npr) {
- en: '...'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: This loop iterates until the end of the input file is reached. The latter condition
    will be sensed by encountering a zero-length Household record, as seen in the
    preceding code.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环会一直迭代到输入文件结束。后者条件将通过遇到零长度的家庭记录来感知，如前所述代码所示。
- en: Within the repeat loop, we alternate reading a Household record and reading
    the associated Person records. The number of Person records for the current Household
    record is extracted from columns 106 and 107 of that record, storing this number
    in npr. That extraction is done by a call to our function intextract().
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在重复循环中，我们交替读取家庭记录和相关的个人记录。当前家庭记录的个人记录数从该记录的第106和第107列提取，并将此数字存储在npr中。这种提取是通过调用我们的函数intextract()完成的。
- en: 'The for loop then reads in the Person records one by one, in each case forming
    the desired row for the output data frame and then attaching it to the latter
    via rbind():'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 然后for循环逐个读取个人记录，在每种情况下形成输出数据框所需的行，然后通过rbind()将其附加到后者：
- en: for (i in 1:npr) {
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:npr) {
- en: 'prec <- readLines(con,1) # get Person record'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 'prec <- readLines(con,1) # 获取个人记录'
- en: make this person's row for the data frame
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为此人的行创建数据框
- en: person <- makerow(serno,prec,flds)
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: person <- makerow(serno,prec,flds)
- en: add it to the data frame
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将它添加到数据框中
- en: dtf <- rbind(dtf,person)
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: dtf <- rbind(dtf,person)
- en: '}'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Note how makerow() creates the row to be added for a given person. Here the
    formal arguments are srn for the household serial number, pr for the given Person
    record, and fl for the list of variable names and column fields.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 注意makerow()如何创建要添加的给定人员的行。在这里，形式参数是srn（家庭序列号），pr（给定的个人记录），fl（变量名称和列字段列表）。
- en: makerow <- function(srn,pr,fl) {
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: makerow <- function(srn,pr,fl) {
- en: l <- list()
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: l <- list()
- en: l[["serno"]] <- srn
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: l[["serno"]] <- srn
- en: for (nm in names(fl)) {
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: for (nm in names(fl)) {
- en: l[[nm]] <- intextract(pr,fl[[nm]])
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: l[[nm]] <- intextract(pr,fl[[nm]])
- en: '}'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return(l)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: return(l)
- en: '}'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'For instance, consider our sample call:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们的示例调用：
- en: pumsdf <- extractpums("pumsa",list(Gender=c(23,23),Age=c(25,26))) When makerow()
    executes, fl will be a list with two elements, named Gender and Age. The string
    pr, the current Person record, will have Gender in column 23 and Age in columns
    25 and 26\. We call intextract() to pull out the desired numbers.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: pumsdf <- extractpums("pumsa",list(Gender=c(23,23),Age=c(25,26))) 当makerow()执行时，fl将是一个包含两个元素的列表，分别命名为Gender和Age。字符串pr，当前的个人记录，Gender位于第23列，Age位于第25和第26列。我们调用intextract()来提取所需的数字。
- en: '**242**'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '**242**'
- en: Chapter 10
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 第10章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The intextract() function itself is a straightforward conversion of characters
    to numbers, such as converting the string "12" to the number 12\.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: intextract()函数本身是将字符转换为数字的简单转换，例如将字符串"12"转换为数字12。
- en: 'Note that, if not for the presence of Household records, we could do all of
    this much more easily with a handy built-in R function: read.fwf(). The name of
    this function is an abbreviation for “read fixed-width formatted,”'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有家庭记录的存在，我们可以使用一个方便的内置 R 函数（read.fwf()）轻松地完成所有这些操作。这个函数的名称是“read fixed-width
    formatted”的缩写。
- en: alluding to the fact that each variable is stored in given character positions
    of a record. In essence, this function alleviates the need to write a function
    like intextract().
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 暗示每个变量都存储在记录的指定字符位置。本质上，这个函数减轻了编写类似 intextract() 函数的需求。
- en: '***10.2.5 Accessing Files on Remote Machines via URLs***'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2.5 通过 URL 访问远程机器上的文件***'
- en: Certain I/O functions, such as read.table() and scan(), accept web URLs as arguments.
    (Check R’s online help facility to see if your favorite function allows this.)
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 某些 I/O 函数，如 read.table() 和 scan()，接受网络 URL 作为参数。（检查 R 的在线帮助功能，看看您喜欢的函数是否允许这样做。）
- en: As an example, we’ll read some data from the University of Califor-
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们将从加州大学读取一些数据。
- en: 'nia, Irvine archive at *http://archive.ics.uci.edu/ml/datasets.html*, using
    the Echocardiogram data set. After navigating the links, we find the location
    of that file and then read it from R, as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: nia, Irvine archive at *http://archive.ics.uci.edu/ml/datasets.html*，使用 Echocardiogram
    数据集。在导航链接后，我们找到该文件的位置，然后从 R 中读取，如下所示：
- en: uci <- "http://archive.ics.uci.edu/ml/machine-learning-databases/"
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: uci <- "http://archive.ics.uci.edu/ml/machine-learning-databases/"
- en: uci <- paste(uci,"echocardiogram/echocardiogram.data",sep="")
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: uci <- paste(uci,"echocardiogram/echocardiogram.data",sep="")
- en: ecc <- read.csv(uci)
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ecc <- read.csv(uci)
- en: (We’ve built up the URL in stages here to fit the page.)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: （我们在这里分阶段构建 URL 以适应页面。）
- en: 'Let’s take a look at what we downloaded:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们下载了什么：
- en: head(ecc)
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: head(ecc)
- en: X11 X0 X71 X0.1 X0.260
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: X11 X0 X71 X0.1 X0.260
- en: X9 X4.600 X14
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: X9 X4.600 X14
- en: X1 X1.1 name X1.2 X0.2
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: X1 X1.1 name X1.2 X0.2
- en: 1 19 0 72
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 1 19 0 72
- en: 0 0.380
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0.380
- en: 6 4.100
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 6 4.100
- en: 14 1.700 0.588 name
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 14 1.700 0.588 name
- en: '1'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '0'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 2 16 0 55
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 2 16 0 55
- en: 0 0.260
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0.260
- en: 4 3.420
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 4 3.420
- en: '14'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '1'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 1 name
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 1 name
- en: '1'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '0'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 3 57 0 60
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 3 57 0 60
- en: 0 0.253 12.062 4.603
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0.253 12.062 4.603
- en: 16 1.450 0.788 name
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 16 1.450 0.788 name
- en: '1'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '0'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 4 19 1 57
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 4 19 1 57
- en: 0 0.160
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0.160
- en: 22 5.750
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 22 5.750
- en: 18 2.250 0.571 name
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 18 2.250 0.571 name
- en: '1'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '0'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 5 26 0 68
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 5 26 0 68
- en: 0 0.260
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0.260
- en: 5 4.310
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 5 4.310
- en: '12'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: 1 0.857 name
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 1 0.857 name
- en: '1'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '0'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 6 13 0 62
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 6 13 0 62
- en: 0 0.230
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0.230
- en: 31 5.430 22.5 1.875 0.857 name
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 31 5.430 22.5 1.875 0.857 name
- en: '1'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '0'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: We could then do our analyses. For example, the third column is age, so we could
    find its mean or perform other calculations on that data. See the echocardiogram.names
    page at *http://archive.ics.uci.edu/ml/machine-learning-databases/echocardiogram/echocardiogram.names*
    for descriptions of all of the variables.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行我们的分析。例如，第三列是年龄，因此我们可以找到它的平均值或对数据进行其他计算。请参阅 *http://archive.ics.uci.edu/ml/machine-learning-databases/echocardiogram/echocardiogram.names*
    页面上的 echocardiogram.names 页面，了解所有变量的描述。
- en: '***10.2.6 Writing to a File***'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2.6 写入文件***'
- en: Given the statistical basis of R, file reads are probably much more common than
    writes. But writes are sometimes necessary, and this section will present methods
    for writing to files.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 R 的统计基础，文件读取可能比写入更常见。但是，有时写入是必要的，本节将介绍写入文件的方法。
- en: Input/Output
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出
- en: '**243**'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '**243**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'The function write.table() works very much like read.table(), except that it
    writes a data frame instead of reading one. For instance, let’s take the little
    Jack and Jill example from the beginning of Chapter 5:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 write.table() 与 read.table() 非常相似，除了它写入一个数据框而不是读取一个。例如，让我们从第 5 章开头的 Jack
    和 Jill 小例子开始：
- en: kids <- c("Jack","Jill")
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: kids <- c("Jack","Jill")
- en: ages <- c(12,10)
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ages <- c(12,10)
- en: d <- data.frame(kids,ages,stringsAsFactors=FALSE)
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d <- data.frame(kids,ages,stringsAsFactors=FALSE)
- en: d
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d
- en: kids ages
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: kids ages
- en: 1 Jack
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 1 Jack
- en: '12'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: 2 Jill
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 2 Jill
- en: '10'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: write.table(d,"kds")
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: write.table(d,"kds")
- en: 'The file *kds* will now have these contents:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *kds* 现在将包含以下内容：
- en: '"kids" "ages"'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '"kids" "ages"'
- en: '"1" "Jack" 12'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '"1" "Jack" 12'
- en: '"2" "Jill" 10'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '"2" "Jill" 10'
- en: 'In the case of writing a matrix to a file, just state that you do not want
    row or column names, as follows:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在将矩阵写入文件的情况下，只需声明您不需要行或列名，如下所示：
- en: write.table(xc,"xcnew",row.names=FALSE,col.names=FALSE) The function cat() can
    also be used to write to a file, one part at a time.
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: write.table(xc,"xcnew",row.names=FALSE,col.names=FALSE) 函数 cat() 也可以用来分部分写入文件。
- en: 'Here’s an example:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: cat("abc\n",file="u")
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cat("abc\n",file="u")
- en: cat("de\n",file="u",append=TRUE)
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cat("de\n",file="u",append=TRUE)
- en: 'The first call to cat() creates the file *u*, consisting of one line with contents
    "abc". The second call appends a second line. Unlike the case of using the writeLines()
    function (which we’ll discuss next), the file is automatically saved after each
    operation. For instance, after the previous calls, the file will look like this:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 cat() 创建了文件 *u*，包含一行内容 "abc"。第二次调用追加第二行。与使用 writeLines() 函数的情况不同（我们将在下一节讨论），文件在每次操作后都会自动保存。例如，在之前的调用之后，文件将看起来像这样：
- en: abc
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: abc
- en: de
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: de
- en: 'You can write multiple fields as well. So:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以写入多个字段。所以：
- en: cat(file="v",1,2,"xyz\n")
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cat(file="v",1,2,"xyz\n")
- en: 'would produce a file *v* consisting of a single line:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成一个包含单行的文件 *v*：
- en: 1 2 xyz
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 xyz
- en: '**244**'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '**244**'
- en: Chapter 10
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 第 10 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'You can also use writeLines(), the counterpart of readLines(). If you use a
    connection, you must specify "w" to indicate you are writing to the file, not
    reading from it:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 writeLines()，它是 readLines() 的对应函数。如果您使用连接，必须指定 "w" 来表示您正在写入文件，而不是从文件中读取：
- en: c <- file("www","w")
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c <- file("www","w")
- en: writeLines(c("abc","de","f"),c)
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: writeLines(c("abc","de","f"),c)
- en: close(c)
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: close(c)
- en: 'The file *www* will be created with these contents:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *www* 将包含以下内容：
- en: abc
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: abc
- en: de
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: de
- en: f
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: f
- en: Note the need to proactively close the file.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 注意需要主动关闭文件。
- en: '***10.2.7 Getting File and Directory Information***'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2.7 获取文件和目录信息***'
- en: 'R has a variety of functions for getting information about directories and
    files, setting file access permissions, and the like. The following are a few
    examples:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: R 有各种用于获取目录和文件信息、设置文件访问权限等的函数。以下是一些示例：
- en: •
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'file.info(): Gives file size, creation time, directory-versus-ordinary file
    status, and so on for each file whose name is in the argument, a character vector.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: file.info()：为每个在参数中的文件名（一个字符向量）提供文件大小、创建时间、目录与普通文件状态等信息。
- en: •
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'dir(): Returns a character vector listing the names of all the files in the
    directory specified in its first argument. If the optional argument recursive=TRUE
    is specified, the result will show the entire directory tree rooted at the first
    argument.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: dir()：返回一个字符向量，列出其第一个参数指定的目录中所有文件的名字。如果指定了可选参数 recursive=TRUE，则结果将显示以第一个参数为根的整个目录树。
- en: •
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'file.exists(): Returns a Boolean vector indicating whether the given file exists
    for each name in the first argument, a character vector.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: file.exists()：返回一个布尔向量，指示第一个参数中的每个名字所指定的文件是否存在。
- en: •
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'getwd() and setwd(): Used to determine or change the current working directory.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: getwd() 和 setwd()：用于确定或更改当前工作目录。
- en: 'To see all the file- and directory-related functions, type the following:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有与文件和目录相关的函数，请输入以下内容：
- en: ?files
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ?files
- en: Some of these options will be demonstrated in the next example.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例中将演示一些这些选项。
- en: '***10.2.8 Extended Example: Sum the Contents of Many Files***'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2.8 扩展示例：计算多个文件的内容总和***'
- en: Here, we’ll develop a function to find the sum of the contents (assumed numeric)
    in all files in a directory tree. In our example, a directory *dir1*
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将开发一个函数来查找目录树中所有文件内容的总和（假设为数值）。在我们的示例中，目录 *dir1*
- en: Input/Output
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出
- en: '**245**'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '**245**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'contains the files *filea* and *fileb*, as well as a subdirectory *dir2*, which
    holds the file *filec*. The contents of the files are as follows:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 包含文件 *filea* 和 *fileb*，以及一个子目录 *dir2*，其中包含文件 *filec*。文件内容如下：
- en: •
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: '*filea*: 5, 12, 13'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '*filea*: 5, 12, 13'
- en: •
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: '*fileb*: 3, 4, 5'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '*fileb*: 3, 4, 5'
- en: •
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: '*filec*: 24, 25, 7'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '*filec*: 24, 25, 7'
- en: 'If *dir1* is in our current directory, the call sumtree("dir1") will yield
    the sum of those nine numbers, 98\. Otherwise, we need to specify the full pathname
    of *dir1*, such as sumtree("/home/nm/dir1"). Here is the code: 1'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *dir1* 在我们的当前目录中，调用 sumtree("dir1") 将得到这九个数字的总和，98。否则，我们需要指定 *dir1* 的完整路径名，例如
    sumtree("/home/nm/dir1")。以下是代码：1
- en: sumtree <- function(drtr) {
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: sumtree <- function(drtr) {
- en: '2'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: tot <- 0
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: tot <- 0
- en: '3'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: get names of all files in the tree
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取树中所有文件的名字
- en: '4'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: fls <- dir(drtr,recursive=TRUE)
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: fls <- dir(drtr,recursive=TRUE)
- en: '5'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: for (f in fls) {
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: for (f in fls) {
- en: '6'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: is f a directory?
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: f 是否是一个目录？
- en: '7'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: f <- file.path(drtr,f)
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: f <- file.path(drtr,f)
- en: '8'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: if (!file.info(f)$isdir) {
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: if (!file.info(f)$isdir) {
- en: '9'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: tot <- tot + sum(scan(f,quiet=TRUE))
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: tot <- tot + sum(scan(f,quiet=TRUE))
- en: '10'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: '}'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '11'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: '}'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '12'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: return(tot)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: return(tot)
- en: '13'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: '}'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Note that this problem is a natural for recursion, which we discussed in Section
    7.9\. But here, R has done the recursion for us by allowing it as an option in
    dir(). Thus, in line 4, we set recursive=TRUE in order to find the files throughout
    the various levels of the directory tree.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个问题是递归的自然选择，我们在第7.9节中讨论了递归。但在这里，R通过在dir()中允许它作为选项来为我们执行递归。因此，在第4行，我们设置recursive=TRUE，以便在整个目录树的不同级别中找到文件。
- en: To call file.info(), we need to account for the fact that the current filename
    *f* is relative to drtr, so our file *filea* would be referred to as *dir1/filea*.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用file.info()，我们需要考虑到当前文件名*f*相对于drtr是相对的，因此我们的文件*filea*将被引用为*dir1/filea*。
- en: In order to form that pathname, we need to concatenate drtr, a slash, and filea.
    We could use the R string concatenation function paste() for this, but we would
    need a separate case for Windows, which uses a backslash instead of a slash. But
    file.path() does all that for us.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形成该路径名，我们需要连接drtr、一个斜杠和filea。我们可以使用R字符串连接函数paste()来做这件事，但我们需要为Windows使用一个单独的情况，Windows使用反斜杠而不是斜杠。但file.path()为我们做了所有这些。
- en: Some commentary pertaining to line 8 is in order. The function
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第8行的某些评论是必要的。函数
- en: file.info() returns information about f as a data frame, one of whose columns
    is isdir, with one row for each file and with row names being the filenames. That
    column consists of Boolean values indicating whether each file is a directory.
    In line 8, then, we can detect whether the current file *f* is a directory. If
    *f* is an ordinary file, we go ahead and add its contents to our running total.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: file.info()返回有关f的信息作为数据框，其中一个列是isdir，每行对应一个文件，行名是文件名。该列由布尔值组成，指示每个文件是否是目录。因此，在第8行，我们可以检测当前文件*f*是否是目录。如果*f*是一个普通文件，我们就继续将其内容添加到我们的运行总和中。
- en: '**10.3 Accessing the Internet**'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.3 访问互联网**'
- en: R’s socket facilities give the programmer access to the Internet’s TCP/IP
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: R的套接字功能为程序员提供了访问互联网的TCP/IP的接口。
- en: protocol. For readers who are not familiar with this protocol, we begin with
    an overview of TCP/IP.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 协议。对于不熟悉此协议的读者，我们将从TCP/IP的概述开始。
- en: '**246**'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '**246**'
- en: Chapter 10
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 第10章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***10.3.1 Overview of TCP/IP***'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.3.1 TCP/IP概述***'
- en: TCP/IP is quite complex, so the overview here will be something of an over-simplification,
    but we’ll cover enough for you to understand what R’s socket functions are doing.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP相当复杂，所以这里的概述将是一种过度简化，但我们将涵盖足够的内容，以便您理解R的套接字函数正在做什么。
- en: For our purposes here, the term *network* refers to a set of computers connected
    together locally, without going through the Internet. This typically consists
    of all the computers in a home, all the computers in a smaller business, and so
    on. The physical medium between them is usually an Ethernet connection of some
    form.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这里的目的中，术语*网络*指的是一组本地连接在一起的计算机，而不通过互联网。这通常包括家庭中的所有计算机，较小企业中的所有计算机，等等。它们之间的物理介质通常是某种形式的以太网连接。
- en: The Internet, as its name implies, connects networks. A network in the Internet
    is connected to one or more other networks via *routers*, which are special-purpose
    computers that connect two or more networks together.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网，正如其名所暗示的，连接网络。互联网中的网络通过*路由器*连接到一个或多个其他网络，路由器是专门用于连接两个或更多网络的特殊用途计算机。
- en: Every computer on the Internet has an Internet Protocol (IP) address. This is
    numeric, but it can be stated in characters, as in *www.google.com*, which is
    then translated into the numeric address by the Domain Name Service.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上的每台计算机都有一个互联网协议（IP）地址。这是一个数字，但它可以用字符表示，例如*www.google.com*，然后由域名服务将其转换为数字地址。
- en: However, the IP address is not enough. When A sends a message to
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，IP地址是不够的。当A向B发送消息时，
- en: B, there may be several applications at computer B that are receiving Internet
    messages, such as web browsing, email service, and so on. How does the operating
    system at B know to which of these to send the message from A? The answer is that
    A will specify a *port number* in addition to the IP address.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: B，可能有几个应用程序在计算机B上接收互联网消息，例如网页浏览、电子邮件服务等等。B的操作系统如何知道将来自A的消息发送给这些中的哪一个？答案是A将指定一个*端口号*，除了IP地址。
- en: The port number indicates which program running at B is intended as the recipient.
    And A will also have a port number so that the response from B
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 端口号表示B上运行哪个程序作为接收者。A也将有一个端口号，以便B的响应
- en: reaches the correct application at A.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 达到A的正确应用程序。
- en: When A wishes to send something to B, it writes to a software entity called
    a *socket*, using a system call syntactically similar to the one for writing to
    a file. In the call, A specifies B’s IP address and the port number to which A
    wishes to send a message. B has a socket, too, and it writes its responses to
    A in that socket. We say there is a *connection* between A and B via those sockets,
    but that doesn’t mean anything physical—it’s just an agreement between A and B
    to exchange data.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 当A想要向B发送某些内容时，它会向一个名为*socket*的软件实体写入，使用与写入文件的系统调用在语法上相似的调用。在调用中，A指定了B的IP地址和A希望发送消息的端口号。B也有一个socket，它将响应写入到该socket中。我们说A和B通过这些socket之间存在*连接*，但这并不意味着任何物理上的东西——这只是A和B之间交换数据的协议。
- en: Applications follow a *client/server* model. Say a web server is running at
    B, at the standard port for the Web, port 80\. The server at B is *listening*
    at port 80\. Again, this term should not be taken literally; it just means that
    the server program has made a function call that notifies the operating system
    that the server program is willing to have connections at port 80\. When network
    node A requests such a connection, the function call at the server returns, and
    the connection is set up.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序遵循*客户端/服务器*模型。比如说，一个Web服务器在B处运行，在Web的标准端口80上。B处的服务器正在端口80上*监听*。同样，这个术语不应被字面理解；它只是意味着服务器程序已经调用了一个通知操作系统服务器程序愿意在端口80上建立连接的功能。当网络节点A请求这样的连接时，服务器上的函数调用返回，连接就建立了。
- en: If you are a nonprivileged user and write some kind of server program—
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个非特权用户并且编写某种类型的服务器程序——
- en: say in R!—you must assign a port number above 1024\.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 比如在R中！——你必须分配一个大于1024的端口号。
- en: '**NOTE**'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If a server program is taken down or crashes, there may be a few seconds’
    delay before* *the same port is reusable again.*'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果服务器程序被关闭或崩溃，在相同的端口再次可重用之前可能会有几秒钟的延迟。*'
- en: '***10.3.2 Sockets in R***'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.3.2 R中的套接字***'
- en: A very important point to keep in mind is that all the bytes sent by A to B
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 需要牢记的一个重要观点是，A向B发送的所有字节
- en: during the time the connection between them exists are collectively considered
    *one big message*. Say A sends one line of text of 8 characters and then Input/Output
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们之间存在的连接存在期间，被认为是*一个大的消息*。比如说，A发送了一行8个字符的文本，然后输入/输出
- en: '**247**'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '**247**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'another of 20 characters. From A’s point of view, that’s two lines, but to
    TCP/IP, it’s just 28 characters of a yet incomplete message. Splitting that long
    message back into lines can take a bit of doing. R provides various functions
    for this purpose, including the following:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个20个字符。从A的角度来看，这是两行，但对TCP/IP来说，这只是尚未完成的消息的28个字符。将这个长消息拆分成行可能需要一些工作。R为此提供了各种函数，包括以下：
- en: •
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'readLines() and writeLines(): These allow you to program as if TCP/IP'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: readLines()和writeLines()：这些允许你以TCP/IP
- en: were sending messages line by line, even though this is not actually the case.
    If your application is naturally viewed in terms of lines, these two functions
    can be quite handy.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在逐行发送消息，尽管实际上并非如此。如果你的应用程序自然地以行为单位来考虑，这两个函数可能非常有用。
- en: •
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'serialize() and unserialize(): You can use these to send R objects, such as
    a matrix or the complex output of a call to a statistical function. The object
    is converted to character string form by the sender and then converted back to
    the original object form at the receiver.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: serialize()和unserialize()：你可以使用这些函数发送R对象，例如矩阵或统计函数调用的复杂输出。发送方将对象转换为字符字符串形式，然后在接收方将其转换回原始对象形式。
- en: •
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'readBin() and writeBin(): These are for sending data in binary form.'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: readBin()和writeBin()：这些用于以二进制形式发送数据。
- en: (Recall the comment on terminology at the beginning of Section 10.2.2.) Each
    of these functions operates on R connections, as you’ll see in the next example.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: （回想一下第10.2.2节开头关于术语的注释。）这些函数中的每一个都在R连接上操作，正如你将在下一个示例中看到的。
- en: It’s important to choose the right function for each job. If you have a long
    vector, for example, using serialize() and unserialize() may be more convenient
    but far more time-consuming. This is not only because numbers must be converted
    to and from their character representations but also because the character representation
    is typically much longer, which means greater transmission time.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 选择每个任务正确的函数很重要。例如，如果你有一个长向量，使用serialize()和unserialize()可能更方便，但耗时更多。这不仅是因为数字必须转换为它们的字符表示形式，然后又转换回，而且因为字符表示形式通常要长得多，这意味着传输时间更长。
- en: 'Here are two other R socket functions:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是两个其他的R套接字函数：
- en: •
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'socketConnection(): This establishes an R connection via sockets. You specify
    the port number in the argument port, and state whether a'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 'socketConnection(): 通过套接字建立R连接。您在参数port中指定端口号，并说明是否需要建立一个'
- en: server or client is to be created, by setting the argument server to TRUE
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务器或客户端，通过将参数server设置为TRUE
- en: or FALSE, respectively. In the client case, you must also supply the server’s
    IP address in the argument host.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 或FALSE，分别。在客户端的情况下，你还必须在参数host中提供服务器的IP地址。
- en: •
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'socketSelect(): This is useful when a server is connected to multiple clients.
    Its main argument, socklist, is a list of connections, and its return value is
    the sublist of connections that have data ready for the server to read.'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 'socketSelect(): 当服务器连接到多个客户端时很有用。其主要参数socklist是一个连接列表，其返回值是已准备好供服务器读取数据的连接子列表。'
- en: '***10.3.3 Extended Example: Implementing Parallel R***'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.3.3 扩展示例：实现并行R***'
- en: Some statistical analyses have very long runtimes, so there naturally has been
    quite a bit of interest in “parallel R,” in which several R processes cooperate
    on a given task. Another possible reason to “go parallel” is memory limita-tions.
    If one machine does not have enough memory for the task at hand, it may help to
    pool the memories of several machines in some way. Chapter 16
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 一些统计分析的运行时间非常长，因此对“并行R”产生了很大的兴趣，其中几个R进程合作完成给定任务。另一个“并行化”的可能原因是内存限制。如果一台机器没有足够的内存来处理当前任务，通过某种方式汇集几台机器的内存可能会有所帮助。第16章
- en: gives an introduction to this important topic.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍这个重要主题。
- en: Sockets play a key role in many parallel R packages. The cooperating R
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字在许多并行R包中扮演着关键角色。合作的R
- en: processes could be either on the same machine or on separate machines. In the
    latter case (and even the former), a natural approach to implementing parallelism
    is to use R sockets. This is one of the choices in the snow package **248**
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以在同一台机器上或不同的机器上。在后一种情况（甚至在前一种情况），实现并行化的自然方法是用R套接字。这是snow包中的选择之一**248**
- en: Chapter 10
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 第10章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'and in my Rdsm package (both available on CRAN, R’s code repository; see this
    book’s appendix for details), as follows:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的Rdsm包中（两者都可在CRAN，R的代码存储库中找到；有关详细信息，请参阅本书附录），如下所示：
- en: •
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: In snow, the server sends out work tasks to the clients. The clients perform
    their tasks and send the results back to the server, which assembles them into
    the final result. Communication is done with serialize() and unserialize(), and
    the server uses socketSelect() to determine which client results are ready.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 在snow中，服务器向客户端发送工作任务。客户端执行任务并将结果发送回服务器，服务器将它们组装成最终结果。通信是通过serialize()和unserialize()完成的，服务器使用socketSelect()来确定哪些客户端结果已准备好。
- en: •
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: Rdsm implements a virtual shared-memory paradigm, and the server is used to
    store the shared variables. The clients contact the server whenever they need
    to read or write a shared variable. To optimize speed, communication between server
    and clients is done with readBin() and writebin(), instead of serialize() and
    unserialize().
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: Rdsm实现了一个虚拟共享内存范式，服务器用于存储共享变量。客户端在需要读取或写入共享变量时联系服务器。为了优化速度，服务器和客户端之间的通信使用readBin()和writebin()，而不是serialize()和unserialize()。
- en: 'Let’s look at some of the socket-related details of Rdsm. First, here is the
    server code in which connections with the clients are set up, storing them in
    a list cons (there are ncon clients):'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Rdsm的一些与套接字相关的细节。首先，这是设置与客户端连接的服务器代码，将它们存储在列表cons中（有ncon个客户端）：
- en: '1'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: set up socket connections with clients
  id: totrans-644
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与客户端建立套接字连接
- en: '2'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '#'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: '3'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: 'cons <<- vector(mode="list",length=ncon) # list of connections 4'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 'cons <<- vector(mode="list",length=ncon) # 连接列表 4'
- en: prevent connection from dying during debug or long compute spell
  id: totrans-649
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止在调试或长时间计算期间连接中断
- en: '5'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: options("timeout"=10000)
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 设置选项("timeout"=10000)
- en: '6'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: for (i in 1:ncon) {
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:ncon) {
- en: '7'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: cons[[i]] <<-
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: cons[[i]] <<-
- en: '8'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: socketConnection(port=port,server=TRUE,blocking=TRUE,open="a+b") 9
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: socketConnection(port=port,server=TRUE,blocking=TRUE,open="a+b") 9
- en: wait to hear from client i
  id: totrans-658
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待从客户端i接收消息
- en: '10'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: checkin <- unserialize(cons[[i]])
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: checkin <- unserialize(cons[[i]])
- en: '11'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: '}'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '12'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: send ACKs
  id: totrans-664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送确认消息
- en: '13'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: for (i in 1:ncon) {
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:ncon) {
- en: '14'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: send the client its ID number, and the group size
  id: totrans-668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向客户端发送其ID号和组大小
- en: '15'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: serialize(c(i,ncon),cons[[i]])
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: serialize(c(i,ncon),cons[[i]])
- en: '16'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: '}'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Since the client messages and server acknowledgments are short mes-
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 由于客户端消息和服务器确认消息都很短，
- en: sages, serialize() and unserialize() are good enough for the purpose here.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: sages, serialize()和unserialize()在这里足够好。
- en: The first part of the main loop of the server finds a ready client and reads
    from it.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器主循环的第一部分是找到一个就绪客户端并从中读取。
- en: '1'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: repeat {
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: repeat {
- en: '2'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: any clients still there?
  id: totrans-679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是否还有客户端仍在？
- en: '3'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: if (remainingclients == 0) break
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: if (remainingclients == 0) break
- en: '4'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: wait for service request, then read it
  id: totrans-683
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待服务请求，然后读取它
- en: '5'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: find all the pending client requests
  id: totrans-685
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找所有挂起的客户端请求
- en: '6'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: rdy <- which(socketSelect(cons))
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: rdy <- which(socketSelect(cons))
- en: '7'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: choose one
  id: totrans-689
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个
- en: '8'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: j <- sample(1:length(rdy),1)
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: j <- sample(1:length(rdy),1)
- en: Input/Output
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出
- en: '**249**'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '**249**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '9'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: con <- cons[[rdy[j]]]
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: con <- cons[[rdy[j]]]
- en: '10'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: read client request
  id: totrans-698
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取客户端请求
- en: '11'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: req <- unserialize(con)
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: req <- unserialize(con)
- en: 'Again serialize() and unserialize() are good enough here to read the short
    message from the client indicating what kind of operation—typically reading a
    shared variable or writing one—it’s requesting. But the reads and writes of the
    shared variables themselves use the faster readBin() and writeBin() functions.
    Here’s the write part:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用serialize()和unserialize()在这里足够好，用于读取客户端指示的操作类型——通常是读取共享变量或写入一个——的简短消息。但是，共享变量的读取和写入本身使用更快的readBin()和writeBin()函数。以下是写入部分：
- en: write data dt, of mode md (integer of double), to connection cn
  id: totrans-702
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据dt，模式md（整数或双精度浮点数），写入连接cn
- en: binwrite <- function(dt,md,cn) {
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: binwrite <- function(dt,md,cn) {
- en: writeBin(dt,con=cn)
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: writeBin(dt,con=cn)
- en: 'And here’s the read part:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是读取部分：
- en: read sz elements of mode md (integer of double) from connection cn binread <-
    function(cn,md,sz) {
  id: totrans-706
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从连接cn读取sz个元素的模式md（整数或双精度浮点数）binread <- function(cn,md,sz) {
- en: return(readBin(con=cn,what=md,n=sz))
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: return(readBin(con=cn,what=md,n=sz))
- en: 'On the client side, the connection setup code is as follows:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，连接设置代码如下：
- en: '1'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: options("timeout"=10000)
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: options("timeout"=10000)
- en: '2'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: connect to server
  id: totrans-712
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到服务器
- en: '3'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: con <- socketConnection(host=host,port=port,blocking=TRUE,open="a+b") 4
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: con <- socketConnection(host=host,port=port,blocking=TRUE,open="a+b") 4
- en: serialize(list(req="checking in"),con)
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: serialize(list(req="checking in"),con)
- en: '5'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: receive this client's ID and total number of clients from server
  id: totrans-717
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器接收此客户端的ID和客户端总数
- en: '6'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: myidandnclnt <- unserialize(con)
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: myidandnclnt <- unserialize(con)
- en: '7'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: myinfo <<-
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: myinfo <<-
- en: '8'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: list(con=con,myid=myidandnclnt[1],nclnt=myidandnclnt[2])
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: list(con=con,myid=myidandnclnt[1],nclnt=myidandnclnt[2])
- en: The code for reading from and writing to the server is similar to the preceding
    server examples.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器读取和写入的代码与前面的服务器示例类似。
- en: '**250**'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '**250**'
- en: Chapter 10
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 第10章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 23](index-277_1.png)'
  id: totrans-728
  prefs: []
  type: TYPE_IMG
  zh: '![Image 23](index-277_1.png)'
- en: '**11**'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '**11**'
- en: '**STRING MANIPULATION**'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串操作**'
- en: Although R is a statistical language with
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管R是一种统计语言，具有
- en: numeric vectors and matrices playing a
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 数字向量和矩阵扮演着
- en: central role, character strings are surpris-
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串在R程序中起着核心作用，字符字符串出人意料地重要。
- en: ingly important as well. Ranging from birth
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计应用中也非常重要。从出生到
- en: dates stored in medical research data files to text-
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 医学研究数据文件中存储的日期转换为文本格式
- en: mining applications, character data arises quite fre-
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 数据挖掘应用中，字符数据出现得相当频繁。
- en: quently in R programs. Accordingly, R has a number
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 在R程序中频繁出现。相应地，R提供了一些
- en: of string-manipulation utilities, many of which will be
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作工具，其中许多将在
- en: introduced in this chapter.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中介绍。
- en: '**11.1 An Overview of String-Manipulation Functions**'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '**11.1 字符串操作函数概述**'
- en: Here, we’ll briefly review just some of the many string-manipulation functions
    R has to offer. Note that the call forms shown in this introduction are very simple,
    usually omitting many optional arguments. We’ll use some of those arguments in
    our extended examples later in the chapter, but do check R’s online help for further
    details.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将简要回顾R提供的许多字符串操作函数中的一些。请注意，在本介绍中显示的调用形式非常简单，通常省略了许多可选参数。我们将在本章后面的扩展示例中使用一些这些参数，但请检查R的在线帮助以获取更多详细信息。
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***11.1.1 grep()***'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '***11.1.1 grep()***'
- en: The call grep(pattern,x) searches for a specified substring pattern in a vector
    x of strings. If x has *n* elements—that is, it contains *n* strings—then grep(pattern,x)
    will return a vector of length up to *n*. Each element of this vector will be
    the index in x at which a match of pattern as a substring of x[i]) was found.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 调用grep(pattern,x)在字符串向量x中搜索指定的子串模式。如果x有*n*个元素——即它包含*n*个字符串——那么grep(pattern,x)将返回一个长度最多为*n*的向量。此向量的每个元素将是x中找到模式作为子串的索引。
- en: 'Here’s an example of using grep:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用grep的一个示例：
- en: grep("Pole",c("Equator","North Pole","South Pole"))
  id: totrans-746
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: grep("Pole",c("Equator","North Pole","South Pole"))
- en: '[1] 2 3'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2 3'
- en: grep("pole",c("Equator","North Pole","South Pole")) integer(0)
  id: totrans-748
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: grep("pole",c("Equator","North Pole","South Pole")) integer(0)
- en: In the first case, the string "Pole" was found in elements 2 and 3 of the second
    argument, hence the output (2,3). In the second case, string "pole"
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，字符串 "Pole" 被发现在第二个参数的第二个和第三个元素中，因此输出为 (2,3)。在第二种情况下，字符串 "pole"
- en: was not found anywhere, so an empty vector was returned.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何地方都没有找到，因此返回了一个空向量。
- en: '***11.1.2 nchar()***'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '***11.1.2 nchar()***'
- en: 'The call nchar(x) finds the length of a string x. Here’s an example:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: nchar(x) 函数的调用用于查找字符串 x 的长度。以下是一个示例：
- en: nchar("South Pole")
  id: totrans-753
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: nchar("South Pole")
- en: '[1] 10'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 10'
- en: 'The string "South Pole" was found to have 10 characters. C programmers, take
    note: There is no NULL character terminating R strings.'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 发现字符串 "South Pole" 有 10 个字符。C 程序员请注意：R 字符串没有 NULL 字符终止。
- en: Also note that the results of nchar() will be unpredictable if x is not in character
    mode. For instance, nchar(NA) turns out to be 2, and nchar(factor("abc")) is 1\.
    For more consistent results on nonstring objects, use Hadley Wickham’s stringr
    package on CRAN.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，如果 x 不在字符模式下，nchar() 的结果将不可预测。例如，nchar(NA) 的结果是 2，而 nchar(factor("abc"))
    是 1。为了在非字符串对象上获得更一致的结果，请使用 CRAN 上的 Hadley Wickham 的 stringr 包。
- en: '***11.1.3 paste()***'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '***11.1.3 paste()***'
- en: 'The call paste(...) concatenates several strings, returning the result in one
    long string. Here are some examples:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: paste(...) 函数的调用将多个字符串连接起来，并返回一个长字符串的结果。以下是一些示例：
- en: paste("North","Pole")
  id: totrans-759
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: paste("North","Pole")
- en: '[1] "North Pole"'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "North Pole"'
- en: paste("North","Pole",sep="")
  id: totrans-761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: paste("North","Pole",sep="")
- en: '[1] "NorthPole"'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "NorthPole"'
- en: paste("North","Pole",sep=".")
  id: totrans-763
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: paste("North","Pole",sep=".")
- en: '[1] "North.Pole"'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "North.Pole"'
- en: paste("North","and","South","Poles")
  id: totrans-765
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: paste("North","and","South","Poles")
- en: '[1] "North and South Poles"'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "North and South Poles"'
- en: '**252**'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '**252**'
- en: Chapter 11
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 第 11 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: As you can see, the optional argument sep can be used to put something other
    than a space between the pieces being spliced together. If you specify sep as
    an empty string, the pieces won’t have any character between them.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，可选参数 sep 可以用于在拼接在一起的片段之间放置除空格之外的内容。如果您指定 sep 为空字符串，则片段之间不会有任何字符。
- en: '***11.1.4 sprintf()***'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '***11.1.4 sprintf()***'
- en: The call sprintf(...) assembles a string from parts in a formatted manner.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: sprintf(...) 函数的调用以格式化的方式组装字符串。
- en: 'Here’s a simple example:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的示例：
- en: i <- 8
  id: totrans-774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: i <- 8
- en: s <- sprintf("the square of %d is %d",i,i^2)
  id: totrans-775
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: s <- sprintf("the square of %d is %d",i,i^2)
- en: s
  id: totrans-776
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: s
- en: '[1] "the square of 8 is 64"'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "the square of 8 is 64"'
- en: The name of the function is intended to evoke *string print* for “printing”
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的名称旨在唤起“字符串打印”的“打印”
- en: to a string rather than to the screen. Here, we are printing to the string s.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 将其打印到字符串 s 而不是屏幕上。在这里，我们正在将打印到字符串 s。
- en: What are we printing? The function says to first print “the square of”
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印的是什么？函数指示首先打印“平方”
- en: and then print the decimal value of i. (The term *decimal* here means in the
    base-10 number system, not that there will be a decimal point in the result.)
    The result is the string "the square of 8 is 64."
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打印 i 的十进制值。（这里的“十进制”意味着十进制数系统，而不是结果中会有小数点。）结果是字符串 "the square of 8 is 64."
- en: '***11.1.5 substr()***'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '***11.1.5 substr()***'
- en: 'The call substr(x,start,stop) returns the substring in the given character
    position range start:stop in the given string x. Here’s an example:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: substr(x,start,stop) 函数的调用返回给定字符串 x 中给定字符位置范围 start:stop 的子字符串。以下是一个示例：
- en: substring("Equator",3,5)
  id: totrans-784
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: substring("Equator",3,5)
- en: '[1] "uat"'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "uat"'
- en: '***11.1.6 strsplit()***'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '***11.1.6 strsplit()***'
- en: 'The call strsplit(x,split) splits a string x into an R list of substrings based
    on another string split in x. Here’s an example:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: strsplit(x,split) 函数的调用根据另一个字符串 split 在 x 中分割字符串，并将字符串 x 分割成 R 列表中的子字符串。以下是一个示例：
- en: strsplit("6-16-2011",split="-")
  id: totrans-788
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: strsplit("6-16-2011",split="-")
- en: '[[1]]'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1]]'
- en: '[1] "6"'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "6"'
- en: '"16"'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '"16"'
- en: '"2011"'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '"2011"'
- en: '***11.1.7 regexpr()***'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '***11.1.7 regexpr()***'
- en: 'The call regexpr(pattern,text) finds the character position of the first instance
    of pattern within text, as in this example:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: regexpr(pattern,text) 函数的调用用于在文本中找到模式的第一实例的字符位置，如下例所示：
- en: regexpr("uat","Equator")
  id: totrans-795
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: regexpr("uat","Equator")
- en: '[1] 3'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 3'
- en: String Manipulation
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作
- en: '**253**'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '**253**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: This reports that “uat” did indeed appear in “Equator,” starting at character
    position 3\.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 这报告了“uat”确实出现在“Equator”中，起始字符位置为 3。
- en: '***11.1.8 gregexpr()***'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '***11.1.8 gregexpr()***'
- en: 'The call gregexpr(pattern,text) is the same as regexpr(), but it finds all
    instances of pattern. Here’s an example:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: gregexpr(pattern,text) 函数的调用与 regexpr() 相同，但它找到模式的所有实例。以下是一个示例：
- en: gregexpr("iss","Mississippi")
  id: totrans-803
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: gregexpr("iss","Mississippi")
- en: '[[1]]'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1]]'
- en: '[1] 2 5'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2 5'
- en: This finds that “iss” appears twice in “Mississippi,” starting at character
    positions 2 and 5\.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 这发现 "iss" 在 "Mississippi" 中出现两次，起始字符位置为 2 和 5。
- en: '**11.2 Regular Expressions**'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '**11.2 正则表达式**'
- en: When dealing with string-manipulation functions in programming languages, the
    notion of *regular expressions* sometimes arises. In R, you must pay attention
    to this point when using the string functions grep(), grepl(), regexpr(), gregexpr(),
    sub(), gsub(), and strsplit().
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理编程语言中的字符串操作函数时，有时会涉及到 *正则表达式* 的概念。在 R 中，使用字符串函数 grep()、grepl()、regexpr()、gregexpr()、sub()、gsub()
    和 strsplit() 时，你必须注意这一点。
- en: 'A regular expression is a kind of wild card. It’s shorthand to specify broad
    classes of strings. For example, the expression "[au]" refers to any string that
    contains either of the letters *a* or *u*. You could use it like this:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一种通配符。它是指定字符串广泛类别的简写。例如，表达式 "[au]" 指的是包含字母 *a* 或 *u* 的任意字符串。你可以这样使用它：
- en: grep("[au]",c("Equator","North Pole","South Pole"))
  id: totrans-810
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: grep("[au]",c("Equator","North Pole","South Pole"))
- en: '[1] 1 3'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 3'
- en: This reports that elements 1 and 3 of ("Equator","North Pole","South Pole")—that
    is, “Equator” and “South Pole”—contain either an *a* or a *u*.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 这报告说 ("Equator","North Pole","South Pole") 中的元素 1 和 3 —— 即 "Equator" 和 "South
    Pole" —— 包含 *a* 或 *u*。
- en: A period (.) represents any single character. Here’s an example of
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 一个点 (.) 代表任意单个字符。这里是一个使用它的例子：
- en: 'using it:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它：
- en: grep("o.e",c("Equator","North Pole","South Pole"))
  id: totrans-815
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: grep("o.e",c("Equator","North Pole","South Pole"))
- en: '[1] 2 3'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2 3'
- en: 'This searches for three-character strings in which an *o* is followed by any
    single character, which is in turn followed by an *e*. Here is an example of the
    use of two periods to represent any pair of characters:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 这将搜索由一个 *o* 后跟任何单个字符，然后是 *e* 的三个字符字符串。这里是一个使用两个点来表示任意字符对的示例：
- en: grep("N..t",c("Equator","North Pole","South Pole"))
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: grep("N..t",c("Equator","North Pole","South Pole"))
- en: '[1] 2'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2'
- en: Here, we searched for four-letter strings consisting of an *N*, followed by
    any pair of characters, followed by a *t*.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们搜索由 *N* 后跟任意两个字符，然后是 *t* 组成的四个字符字符串。
- en: A period is an example of a *metacharacter*, which is a character that is not
    to be taken literally. For example, if a period appears in the first argument
    of grep(), it doesn’t actually mean a period; it means any character.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 点是一个 *元字符* 的例子，它不是一个字面意义上的字符。例如，如果点出现在 grep() 的第一个参数中，它实际上并不代表点；它代表任意字符。
- en: '**254**'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '**254**'
- en: Chapter 11
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 第11章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'But what if you want to search for a period using grep()? Here’s the naive
    approach:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你想要使用 grep() 搜索点，这里有一个简单的方法：
- en: grep(".",c("abc","de","f.g"))
  id: totrans-826
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: grep(".",c("abc","de","f.g"))
- en: '[1] 1 2 3'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 2 3'
- en: 'The result should have been 3, not (1,2,3). This call failed because periods
    are metacharacters. You need to *escape* the metacharacter nature of the period,
    which is done via a backslash:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是 3，而不是 (1,2,3)。这次调用失败是因为点是一个元字符。你需要 *转义* 点的元字符性质，这通过反斜杠来完成：
- en: grep("\\.",c("abc","de","f.g"))
  id: totrans-829
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: grep("\\.",c("abc","de","f.g"))
- en: '[1] 3'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 3'
- en: Now, didn’t I say *a* backslash? Then why are there two? Well, the sad truth
    is that the backslash itself must be escaped, which is accomplished by its own
    backslash! This goes to show how arcanely complex regular expressions can become.
    Indeed, a number of books have been written on the subject of regular expressions
    (for various programming languages). As a start in learning about the topic, refer
    to R’s online help (type ?regex).
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我没有说 *一个* 反斜杠吗？那么为什么有两个？好吧，令人悲伤的真相是反斜杠本身必须被转义，这是通过它自己的反斜杠来完成的！这表明正则表达式可以多么神秘复杂。确实，已经有许多关于正则表达式（针对各种编程语言）的书籍被写出来。作为了解这个主题的起点，请参考
    R 的在线帮助（输入 ?regex）。
- en: '***11.2.1 Extended Example: Testing a Filename for a Given Suffix***'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '***11.2.1 扩展示例：测试文件名是否具有给定后缀***'
- en: 'Suppose we wish to test for a specified suffix in a filename. We might, for
    instance, want to find all HTML files (those with suffix *.html*, *.htm*, and
    so on). Here is code for that:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望测试文件名中是否存在指定的后缀。例如，我们可能想要找到所有 HTML 文件（那些具有后缀 *.html*、*.htm* 等）。以下是相应的代码：
- en: '1'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: testsuffix <- function(fn,suff) {
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: testsuffix <- function(fn,suff) {
- en: '2'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: parts <- strsplit(fn,".",fixed=TRUE)
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: parts <- strsplit(fn,".",fixed=TRUE)
- en: '3'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: nparts <- length(parts[[1]])
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: nparts <- length(parts[[1]])
- en: '4'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: return(parts[[1]][nparts] == suff)
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: return(parts[[1]][nparts] == suff)
- en: '5'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '}'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Let’s test it.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下。
- en: testsuffix("x.abc","abc")
  id: totrans-845
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: testsuffix("x.abc","abc")
- en: '[1] TRUE'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] TRUE'
- en: testsuffix("x.abc","ac")
  id: totrans-847
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: testsuffix("x.abc","ac")
- en: '[1] FALSE'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] FALSE'
- en: testsuffix("x.y.abc","ac")
  id: totrans-849
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: testsuffix("x.y.abc","ac")
- en: '[1] FALSE'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] FALSE'
- en: testsuffix("x.y.abc","abc")
  id: totrans-851
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: testsuffix("x.y.abc","abc")
- en: '[1] TRUE'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] TRUE'
- en: How does the function work? First note that the call to strsplit() on line 2
    returns a list consisting of one element (because fn is a one-element vector)—a
    vector of strings. For example, calling testsuffix("x.y.abc","abc") will result
    in parts being a list consisting of a three-element vector with elements x, y,
    and abc. We then pick up the last element and compare it to suff.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是如何工作的？首先注意，第 2 行对 strsplit() 的调用返回一个包含一个元素的列表（因为 fn 是一个元素向量）——一个字符串向量。例如，调用
    testsuffix("x.y.abc","abc") 将导致 parts 是一个包含三个元素（x, y, 和 abc）的向量列表。然后我们选择最后一个元素并将其与
    suff 进行比较。
- en: String Manipulation
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作
- en: '**255**'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '**255**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: A key aspect is the argument fixed=TRUE. Without it, the splitting argument
    . (called split in the list of strsplit()’s formal arguments) would have been
    treated as a regular expression. Without setting fixed=TRUE, strsplit() would
    have just separated all the letters.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键方面是参数 fixed=TRUE。没有它，分割参数 .（在 strsplit() 的形式参数列表中称为 split）将被视为一个正则表达式。如果不设置
    fixed=TRUE，strsplit() 就只会将所有字母分开。
- en: 'Of course, we could also escape the period, as follows:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以转义点号，如下所示：
- en: '1'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: testsuffix <- function(fn,suff) {
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: testsuffix <- function(fn,suff) {
- en: '2'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: parts <- strsplit(fn,"\\.")
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: parts <- strsplit(fn,"\\.")
- en: '3'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: nparts <- length(parts[[1]])
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: nparts <- length(parts[[1]])
- en: '4'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: return(parts[[1]][nparts] == suff)
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: return(parts[[1]][nparts] == suff)
- en: '5'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '}'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Let’s check to see if it still works.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查它是否仍然有效。
- en: testsuffix("x.y.abc","abc")
  id: totrans-870
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: testsuffix("x.y.abc","abc")
- en: '[1] TRUE'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] TRUE'
- en: 'Here’s another way to do the suffix-test code that’s a bit more involved but
    a good illustration:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一种执行后缀测试代码的方法，它稍微复杂一些，但是一个很好的说明：
- en: '1'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: testsuffix <- function(fn,suff) {
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: testsuffix <- function(fn,suff) {
- en: '2'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: 'ncf <- nchar(fn) # nchar() gives the string length'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 'ncf <- nchar(fn) # nchar() 获取字符串长度'
- en: '3'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: determine where the period would start if suff is the suffix in fn 4
  id: totrans-878
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定如果 suff 是 fn 中的后缀，则点号将从哪里开始 4
- en: dotpos <- ncf - nchar(suff) + 1
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: dotpos <- ncf - nchar(suff) + 1
- en: '5'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: now check that suff is there
  id: totrans-881
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在检查 suff 是否存在
- en: '6'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: return(substr(fn,dotpos,ncf)==suff)
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: return(substr(fn,dotpos,ncf)==suff)
- en: '7'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '}'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Let’s look at the call to substr() here, again with fn = "x.ac" and suff = "abc".
    In this case, dotpos will be 1, which means there should be a period at the first
    character in fn if there is an abc suffix. The call to substr() then becomes substr("x.ac",1,4),
    which extracts the substring in character positions 1 through 4 of x.ac. That
    substring will be x.ac, which is not abc, so the filename’s suffix is found not
    to be the latter.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看 substr() 的调用，这里 fn = "x.ac" 且 suff = "abc"。在这种情况下，dotpos 将是 1，这意味着如果存在
    abc 后缀，fn 中的第一个字符应该有点号。然后 substr() 的调用变为 substr("x.ac",1,4)，它从 x.ac 中提取字符位置 1
    到 4 的子字符串。这个子字符串将是 x.ac，它不是 abc，因此文件名的后缀没有被找到是后者。
- en: '***11.2.2 Extended Example: Forming Filenames***'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '***11.2.2 扩展示例：形成文件名***'
- en: 'Suppose we want to create five files, *q1.pdf* through *q5.pdf*, consisting
    of histograms of 100 random N(0, *i* 2) variates. We could execute the following
    code:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建五个文件，*q1.pdf* 到 *q5.pdf*，这些文件包含 100 个随机 N(0, *i* 2) 变量的直方图。我们可以执行以下代码：
- en: '1'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: for (i in 1:5) {
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:5) {
- en: '2'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: fname <- paste("q",i,".pdf")
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: fname <- paste("q",i,".pdf")
- en: '3'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: pdf(fname)
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: pdf(fname)
- en: '4'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: hist(rnorm(100,sd=i))
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: hist(rnorm(100,sd=i))
- en: '5'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: dev.off()
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: dev.off()
- en: '6'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '}'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**256**'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '**256**'
- en: Chapter 11
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 第 11 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The main point in this example is the string manipulation we use to create the
    filename fname. For more details about the graphics operations used in this example,
    refer to Section 12.3\.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的主要点是用于创建文件名 fname 的字符串操作。有关本例中使用的图形操作的更多详细信息，请参阅第 12.3 节。
- en: The paste() function concatenates the string "q" with the string form of the
    number i. For example, when i = 2, the variable fname will be q 2 .pdf.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: paste() 函数将字符串 "q" 与数字 i 的字符串形式连接起来。例如，当 i = 2 时，变量 fname 将是 q2.pdf。
- en: 'However, that isn’t quite what we want. On Linux systems, filenames with embedded
    spaces create headaches, so we want to remove the spaces. One solution is to use
    the sep argument, specifying an empty string for the separator, as follows:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是我们想要的。在 Linux 系统上，包含空格的文件名会带来麻烦，因此我们想要删除空格。一种解决方案是使用 sep 参数，指定一个空字符串作为分隔符，如下所示：
- en: '1'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: for (i in 1:5) {
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:5) {
- en: '2'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: fname <- paste("q",i,".pdf",sep="") 3
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: fname <- paste("q",i,".pdf",sep="")
- en: pdf(fname)
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: pdf(fname)
- en: '4'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: hist(rnorm(100,sd=i))
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: hist(rnorm(100,sd=i))
- en: '5'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: dev.off()
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: dev.off()
- en: '6'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '}'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Another approach is to employ the sprintf() function, borrowed from C: 1'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用从 C 中借来的 sprintf() 函数：1
- en: for (i in 1:5) {
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:5) {
- en: '2'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: fname <- sprintf("q%d.pdf",i)
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: fname <- sprintf("q%d.pdf",i)
- en: '3'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: pdf(fname)
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: pdf(fname)
- en: '4'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: hist(rnorm(100,sd=i))
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: hist(rnorm(100,sd=i))
- en: '5'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: dev.off()
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: dev.off()
- en: '6'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '}'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'For floating-point quantities, note also the difference between %f and %g formats:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 对于浮点数，还要注意 %f 和 %g 格式之间的区别：
- en: sprintf("abc%fdef",1.5)
  id: totrans-931
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sprintf("abc%fdef",1.5)
- en: '[1] "abc1.500000def"'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "abc1.500000def"'
- en: sprintf("abc%gdef",1.5)
  id: totrans-933
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sprintf("abc%gdef",1.5)
- en: '[1] "abc1.5def"'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "abc1.5def"'
- en: The %g format eliminated the superfluous zeros.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '%g 格式消除了多余的零。'
- en: '**11.3 Use of String Utilities in the edtdbg Debugging Tool**'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '**11.3 在 edtdbg 调试工具中使用字符串实用工具**'
- en: 'The internal code of the edtdbg debugging tool, which will be discussed in
    Section 13.4, makes heavy use of string utilities. A typical example of such usage
    is the dgbsendeditcmd() function:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: edtdbg 调试工具的内部代码，将在第 13.4 节中讨论，大量使用了字符串实用工具。此类使用的典型示例是 dgbsendeditcmd() 函数：
- en: send command to editor
  id: totrans-938
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向编辑器发送命令
- en: dbgsendeditcmd <- function(cmd) {
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: dbgsendeditcmd <- function(cmd) {
- en: syscmd <- paste("vim --remote-send ",cmd," --servername ",vimserver,sep="")
    system(syscmd)
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: syscmd <- paste("vim --remote-send ",cmd," --servername ",vimserver,sep="")
    system(syscmd)
- en: '}'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: String Manipulation
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作
- en: '**257**'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '**257**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'What is going on here? The main point is that edtdbg sends remote commands
    to the Vim text editor. For instance, if you are running Vim with a server name
    of 168 and you want the cursor in Vim to move to line 12, you could type this
    into a terminal (shell) window:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？主要点是 edtdbg 向 Vim 文本编辑器发送远程命令。例如，如果你使用服务器名为 168 运行 Vim，并且想要将 Vim 中的光标移动到第
    12 行，你可以在终端（shell）窗口中输入以下内容：
- en: vim --remote-send 12G --servername 168
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: vim --remote-send 12G --servername 168
- en: 'The effect would be the same as if you had physically typed 12G at the Vim
    window. Since 12G is the Vim command to move the cursor to line 12, that’s what
    would occur. Consider this call:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果与你在 Vim 窗口中实际输入 12G 是一样的。由于 12G 是 Vim 命令，用于将光标移动到第 12 行，因此会发生这种情况。考虑以下调用：
- en: 'paste("vim --remote-send ",cmd," --servername ",vimserver,sep="") Here, cmd
    is the string "12G", vimserver is 168, and paste() concatenates all the indicated
    strings. The argument sep="" says to use the empty string as separator in this
    concatenation—that is, no separation. Thus, paste() returns the following:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: paste("vim --remote-send ",cmd," --servername ",vimserver,sep="") 这里，cmd 是字符串
    "12G"，vimserver 是 168，paste() 连接所有指示的字符串。参数 sep="" 表示在此连接中使用空字符串作为分隔符——也就是说，没有分隔。因此，paste()
    返回以下内容：
- en: vim --remote-send 12G --servername 168
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: vim --remote-send 12G --servername 168
- en: Another core element in the operation of edtdbg is that the program has arranged,
    via a call to R’s sink() function, to record to the file *dbgsink* most output
    from R’s debugger in your R window. (The edtdbg utility works in concert with
    that debugger.) That information includes the line numbers of your positions in
    your source file as you step through it using R’s debugger.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 'edtdbg 运作中的另一个核心元素是，程序通过调用 R 的 sink() 函数，安排将 R 调试器的大部分输出记录到名为 *dbgsink* 的文件中。（edtdbg
    工具与该调试器协同工作。）这些信息包括你在使用 R 调试器逐步通过源文件时，你的位置所在的行号。 '
- en: 'The line position information in the debugger output looks like this: debug
    at cities.r#16: {'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '调试器输出中的行位置信息如下所示：debug at cities.r#16: {'
- en: 'So, there is code in edtdbg to determine the latest line in *dbgsink* that
    begins with “debug at.” That line is then placed, as a string, in a variable named
    debugline. The following code then extracts the line number (16 in the example)
    and the source filename/Vim buffer name ( *cities.r* here): linenumstart <- regexpr("#",debugline)
    + 1'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 edtdbg 中有代码来确定 *dbgsink* 中以“debug at.”开头的最新行。然后，将该行作为一个字符串放入名为 debugline
    的变量中。接下来的代码然后提取行号（示例中的 16）和源文件名/Vim 缓冲区名（这里为 *cities.r*）：linenumstart <- regexpr("#",debugline)
    + 1
- en: buffname <- substr(debugline,10,linenumstart-2)
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: buffname <- substr(debugline,10,linenumstart-2)
- en: colon <- regexpr(":",debugline)
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: colon <- regexpr(":",debugline)
- en: linenum <- substr(debugline,linenumstart,colon-1)
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: linenum <- substr(debugline,linenumstart,colon-1)
- en: 'The call to regexpr() determines where in debugline the # character is located
    (character 18 in this example). Adding 1 to that gives the position of the line
    number within debugline.'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 'regexpr() 的调用确定了 # 字符在 debugline 中的位置（本例中的第 18 个字符）。加 1 后给出行号在 debugline 中的位置。'
- en: '**258**'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '**258**'
- en: Chapter 11
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 第 11 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'To get the buffer name, using the preceding example as a guide, we see that
    the name comes after debug at and ends just before the #. Since “debug at” contains
    nine characters, the buffer name will start at position 10—hence the 10 in the
    call,'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '要获取缓冲区名称，以先前的示例为指南，我们看到名称位于 debug 之后，并在 # 之前结束。由于“debug at”包含九个字符，缓冲区名称将从位置
    10 开始——因此调用中的 10，'
- en: substr(debugline,10,linenumstart-2)
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: substr(debugline,10,linenumstart-2)
- en: 'The end of the buffer name field is at linenumstart-2, as it is just before
    the #, which precedes the start of the line number. The line number computation
    is then similar.'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '缓冲区名称字段的末尾位于 linenumstart-2，因为它位于 # 之前，而 # 位于行号开始之前。行号计算方式类似。'
- en: 'Another illustrative example of edtdbg’s internal code is its use of the strsplit()
    function. For example, at one point, it prints out a prompt to the user:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: edtdbg 内部代码的另一个示例是它对 strsplit() 函数的使用。例如，在某个时刻，它向用户打印出一个提示：
- en: 'kbdin <- readline(prompt="enter number(s) of fns you wish to toggle dbg: ")
    As you can see, the user’s response is stored in kbdin. It will consist of a set
    of numbers separated by spaces, such as this:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 'kbdin <- readline(prompt="enter number(s) of fns you wish to toggle dbg: ")
    如你所见，用户的响应存储在 kbdin 中。它将包含由空格分隔的一组数字，例如：'
- en: 1 4 5
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 1 4 5
- en: 'We need to extract the numbers from the string 1 4 5 into an integer vector.
    This is done first via strsplit(), which produces three strings: "1", "4", and
    "5". Then we call as.integer() to convert from characters to numbers: tognums
    <- as.integer(strsplit(kbdin,split=" ")[[1]])'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从字符串 1 4 5 中提取数字到一个整数向量中。这是首先通过 strsplit() 完成的，它产生了三个字符串："1"、"4" 和 "5"。然后我们调用
    as.integer() 将字符转换为数字：tognums <- as.integer(strsplit(kbdin,split=" ")[[1]])
- en: Note that the output of strsplit() is an R list, in this case consisting of
    one element, which is in turn the vector ("1","4","5"). This leads to the expression
    [[1]] in the example.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 strsplit() 的输出是一个 R 列表，在这种情况下，它包含一个元素，该元素是一个向量 ("1","4","5")。这导致了示例中的 [[1]]
    表达式。
- en: String Manipulation
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作
- en: '**259**'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '**259**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 24](index-287_1.png)'
  id: totrans-972
  prefs: []
  type: TYPE_IMG
  zh: '![图像 24](index-287_1.png)'
- en: '**12**'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '**12**'
- en: '**GRAPHICS**'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形**'
- en: R has a very rich set of graphics facilities.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: R 拥有一套非常丰富的图形功能。
- en: The R home page ( *http://www.r-project*
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: R 的主页（ *http://www.r-project*
- en: '*.org/* ) has a few colorful examples, but to'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '*.org/* ) 有一些色彩丰富的示例，但为了'
- en: really appreciate R’s graphical power, browse
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 真实地欣赏 R 的图形能力，浏览
- en: through the R Graph Gallery at *http://addictedtor.free*
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: R 图形画廊在 *http://addictedtor.free*
- en: '*.fr/graphiques*.'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '*.fr/graphiques*.'
- en: In this chapter, we cover the basics of using R’s base, or traditional, graphics
    package. This will give you enough foundation to start working with graphics in
    R. If you’re interested in pursuing R graphics further, you may want to refer
    to the excellent books on the subject.1
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用 R 的基础或传统图形包的基本方法。这将为你提供足够的基礎，以便开始使用 R 进行图形操作。如果你对进一步学习 R 图形感兴趣，你可能需要参考该主题的优秀书籍。1
- en: '**12.1 Creating Graphs**'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.1 创建图形**'
- en: 'To begin, we’ll look at the foundational function for creating graphs: plot().'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看创建图形的基础函数：plot()。
- en: Then we’ll explore how to build a graph, from adding lines and points to attaching
    a legend.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探讨如何构建图形，从添加线条和点到最后添加图例。
- en: '1 These include Hadley Wickham, *ggplot2: Elegant Graphics for Data Analysis*
    (New York: Springer-Verlag, 2009); Dianne Cook and Deborah F. Swayne, *Interactive
    and Dynamic Graphics for Data* *Analysis: With R and GGobi* (New York: Springer-Verlag,
    2007); Deepayan Sarkar, *Lattice: Multivariate Data Visualization with R* (New
    York: Springer-Verlag, 2008); and Paul Murrell, *R Graphics* (Boca Raton, FL:
    Chapman and Hall/CRC, 2011).'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '1 这些包括 Hadley Wickham 的 *ggplot2: 数据分析中的优雅图形*（纽约：Springer-Verlag，2009）；Dianne
    Cook 和 Deborah F. Swayne 的 *使用 R 和 GGobi 的交互式和动态数据图形分析*（纽约：Springer-Verlag，2007）；Deepayan
    Sarkar 的 *Lattice: 使用 R 的多元数据可视化*（纽约：Springer-Verlag，2008）；以及 Paul Murrell 的 *R
    Graphics*（博卡雷顿，FL：Chapman and Hall/CRC，2011）。'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 25](index-288_1.png)'
  id: totrans-987
  prefs: []
  type: TYPE_IMG
  zh: '![图像 25](index-288_1.png)'
- en: '***12.1.1 The Workhorse of R Base Graphics: The plot() Function***'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.1.1 R 基础图形的引擎：plot() 函数***'
- en: The plot() function forms the foundation for much of R’s base graphing operations,
    serving as the vehicle for producing many different kinds of graphs. As mentioned
    in Section 9.1.1, plot() is a generic function, or a placeholder for a family
    of functions. The function that is actually called depends on the class of the
    object on which it is called.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()`函数是R的基础绘图操作的基础，作为产生许多不同类型图表的工具。如第9.1.1节所述，`plot()`是一个泛型函数，或是一系列函数的占位符。实际调用的函数取决于被调用对象的类别。'
- en: Let’s see what happens when we call plot() with an X vector and a Y
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们用X向量和Y向量调用`plot()`时会发生什么
- en: vector, which are interpreted as a set of pairs in the ( *x*, *y*) plane.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 向量，这些在(*x*, *y*)平面上被解释为一组对。
- en: plot(c(1,2,3), c(1,2,4))
  id: totrans-992
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`plot(c(1,2,3), c(1,2,4))`'
- en: This will cause a window to pop up, plotting the points (1,1), (2,2), and (3,4),
    as shown in Figure 12-1\. As you can see, this is a very plain-Jane graph.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 这将弹出一个窗口，绘制点(1,1)，(2,2)和(3,4)，如图12-1所示。正如你所看到的，这是一个非常简单的图表。
- en: We’ll discuss adding some of the fancy bells and whistles later in the chapter.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论添加一些花哨的功能。
- en: '*Figure 12-1: Simple point plot*'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-1：简单的点图*'
- en: '**NOTE**'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The points in the graph in Figure 12-1 are denoted by empty circles. If you
    want to* *use a different character type, specify a value for the named argument
    pch (for* point character *).*'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-1中的点用空心圆表示。如果你想要* *使用不同的字符类型，请为名为pch的命名参数指定一个值（对于* 点字符 *）。*'
- en: 'The plot() function works in stages, which means you can build up a graph in
    stages by issuing a series of commands. For example, as a base, we might first
    draw an empty graph, with only axes, like this:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()`函数分阶段工作，这意味着你可以通过发出一系列命令逐步构建一个图表。例如，作为基础，我们可能首先绘制一个空图表，只包含坐标轴，如下所示：'
- en: plot(c(-3,3), c(-1,5), type = "n", xlab="x", ylab="y") This draws axes labeled
    *x* and *y*. The horizontal ( *x*) axis ranges from *−* 3
  id: totrans-999
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`plot(c(-3,3), c(-1,5), type = "n", xlab="x", ylab="y")` 这绘制了标记为*x*和*y*的坐标轴。水平轴（*x*）的范围从*−*3'
- en: to 3\. The vertical ( *y*) axis ranges from *−* 1 to 5\. The argument type="n"
    means that there is nothing in the graph itself.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 到3。垂直轴（*y*）的范围从*−*1到5。参数类型="n"表示图表本身没有任何内容。
- en: '**262**'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: '**262**'
- en: Chapter 12
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 第12章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 26](index-289_1.png)'
  id: totrans-1004
  prefs: []
  type: TYPE_IMG
  zh: '![Image 26](index-289_1.png)'
- en: '***12.1.2 Adding Lines: The abline() Function***'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.1.2 添加线条：`abline()`函数***'
- en: 'We now have an empty graph, ready for the next stage, which is adding a line:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个空图表，准备进入下一阶段，即添加线条：
- en: x <- c(1,2,3)
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`x <- c(1,2,3)`'
- en: y <- c(1,3,8)
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`y <- c(1,3,8)`'
- en: plot(x,y)
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`plot(x,y)`'
- en: lmout <- lm(y ~ x)
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`lmout <- lm(y ~ x)`'
- en: abline(lmout)
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`abline(lmout)`'
- en: After the call to plot(), the graph will simply show the three points, along
    with the *x*- and *y*- axes with hash marks. The call to abline() then adds a
    line to the current graph. Now, which line is this?
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`plot()`之后，图表将简单地显示三个点，以及带有刻度的*x*和*y*轴。然后`abline()`调用向当前图表添加一条线。现在，这条线是哪一条？
- en: As you learned in Section 1.5, the result of the call to the linear-regression
    function lm() is a class instance containing the slope and intercept of the fitted
    line, as well as various other quantities that don’t concern us here. We’ve assigned
    that class instance to lmout. The slope and intercept will now be in lmout$coefficients.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在第1.5节所学，线性回归函数`lm()`的调用结果是一个包含拟合线的斜率和截距以及各种其他不在此处关心的量的类实例。我们将该类实例赋值给`lmout`。斜率和截距现在将在`lmout$coefficients`中。
- en: So, what happens when we call abline()? This function simply draws
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们调用`abline()`时会发生什么？这个函数只是简单地绘制
- en: 'a straight line, with the function’s arguments treated as the intercept and
    slope of the line. For instance, the call abline(c(2,1)) draws this line on whatever
    graph you’ve built up so far:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 一条直线，函数的参数被视为直线的截距和斜率。例如，调用`abline(c(2,1))`将在你构建的任何图表上绘制这条线：
- en: '*y* = 2 + 1 *· x*'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = 2 + 1 *· x*'
- en: But abline() is written to take special action if it is called on a regression
    object (though, surprisingly, it is not a generic function). Thus, it will pick
    up the slope and intercept it needs from lmout$coefficients and plot that line.
    It superimposes this line onto the current graph, the one that graphs the three
    points. In other words, the new graph will show both the points and the line,
    as in Figure 12-2\.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 但`abline()`被编写为在回归对象上调用时执行特殊操作（尽管令人惊讶，它不是一个泛型函数）。因此，它将从`lmout$coefficients`中获取所需的斜率和截距，并绘制这条线。它将这条线叠加到当前图表上，即绘制三个点的图表。换句话说，新的图表将显示点和线，如图12-2所示。
- en: '*Figure 12-2: Using* abline()'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-2：使用 abline()*'
- en: Graphics
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 图形
- en: '**263**'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '**263**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: You can add more lines using the lines() function. Though there are many options,
    the two basic arguments to lines() are a vector of *x*-values and a vector of
    *y*-values. These are interpreted as ( *x*, *y*) pairs representing points to
    be added to the current graph, with lines connecting the points.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 lines() 函数添加更多线条。尽管有很多选项，但 lines() 的两个基本参数是 *x* 值的向量和一个 *y* 值的向量。这些被解释为
    ( *x*, *y*) 对，表示要添加到当前图表中的点，并通过线条连接这些点。
- en: 'For instance, if X and Y are the vectors (1.5,2.5) and (3,3), you could use
    this call to add a line from (1.5,3) to (2.5,3) to the present graph:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 X 和 Y 是向量 (1.5,2.5) 和 (3,3)，你可以使用以下调用将一条从 (1.5,3) 到 (2.5,3) 的线添加到当前图表中：
- en: lines(c(1.5,2.5),c(3,3))
  id: totrans-1024
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lines(c(1.5,2.5),c(3,3))
- en: 'If you want the lines to “connect the dots,” but don’t want the dots themselves,
    include type="l" in your call to lines() or to plot(), as follows:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要线条“连接点”，但又不想显示点本身，请在调用 lines() 或 plot() 时包含 type="l"，如下所示：
- en: plot(x,y,type="l")
  id: totrans-1026
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: plot(x,y,type="l")
- en: 'You can use the lty parameter in plot() to specify the type of line, such as
    solid or dashed. To see the types available and their codes, enter this command:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 plot() 函数中使用 lty 参数来指定线的类型，例如实线或虚线。要查看可用的类型及其代码，请输入以下命令：
- en: help(par)
  id: totrans-1028
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: help(par)
- en: '***12.1.3 Starting a New Graph While Keeping the Old Ones***'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.1.3 在保留旧图的同时开始新图***'
- en: 'Each time you call plot(), directly or indirectly, the current graph window
    will be replaced by the new one. If you don’t want that to happen, use the command
    for your operating system:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你调用 plot()，无论是直接还是间接，当前的图表窗口都会被新的一个替换。如果你不希望发生这种情况，请使用适用于你操作系统的命令：
- en: •
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: On Linux systems, call X11().
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统上，调用 X11()。
- en: •
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: On a Mac, call macintosh().
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 上，调用 macintosh()。
- en: •
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: On Windows, call windows().
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，调用 windows()。
- en: For instance, suppose you wish to plot two histograms of vectors X
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你希望绘制向量 X 的两个直方图
- en: 'and Y and view them side by side. On a Linux system, you would type the following:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 并在 Linux 系统上并排查看它们。你会输入以下内容：
- en: hist(x)
  id: totrans-1039
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hist(x)
- en: x11()
  id: totrans-1040
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x11()
- en: hist(y)
  id: totrans-1041
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hist(y)
- en: '***12.1.4 Extended Example: Two Density Estimates on the Same Graph***'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.1.4 扩展示例：同一图上的两个密度估计***'
- en: 'Let’s plot nonparametric density estimates (these are basically smoothed histograms)
    for two sets of examination scores in the same graph. We use the function density()
    to generate the estimates. Here are the commands we issue:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制两个考试分数集合的非参数密度估计（这些基本上是平滑的直方图）在同一图上。我们使用 density() 函数生成估计。以下是我们要执行的命令：
- en: d1 = density(testscores$Exam1,from=0,to=100)
  id: totrans-1044
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d1 = density(testscores$Exam1,from=0,to=100)
- en: d2 = density(testscores$Exam2,from=0,to=100)
  id: totrans-1045
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d2 = density(testscores$Exam2,from=0,to=100)
- en: '**264**'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '**264**'
- en: Chapter 12
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 第 12 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 27](index-291_1.png)'
  id: totrans-1049
  prefs: []
  type: TYPE_IMG
  zh: '![Image 27](index-291_1.png)'
- en: '![Image 28](index-291_2.png)'
  id: totrans-1050
  prefs: []
  type: TYPE_IMG
  zh: '![Image 28](index-291_2.png)'
- en: plot(d1,main="",xlab="")
  id: totrans-1051
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: plot(d1,main="",xlab="")
- en: lines(d2)
  id: totrans-1052
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lines(d2)
- en: First, we compute nonparametric density estimates from the two variables, saving
    them in objects d1 and d2 for later use. We then call plot() to draw the curve
    for exam 1, at which point the plot looks like Figure 12-3\. We then call lines()
    to add exam 2’s curve to the graph, producing Figure 12-4\.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算两个变量的非参数密度估计，并将它们保存在对象 d1 和 d2 中以供以后使用。然后我们调用 plot() 来绘制考试 1 的曲线，此时图表看起来像图
    12-3。然后我们调用 lines() 来将考试 2 的曲线添加到图表中，生成图 12-4。
- en: '*Figure 12-3: Plot of first density*'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-3：第一个密度估计的图*'
- en: '*Figure 12-4: Addition of second density*'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-4：第二个密度估计的添加*'
- en: Graphics
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 图形
- en: '**265**'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '**265**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Note that we asked R to use blank labels for the figure as a whole and for the
    *x*-axis. Otherwise, R would have gotten such labels from d1, which would have
    been specific to exam 1\.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们要求 R 使用空白标签为整个图和 *x* 轴设置标签。否则，R 会从 d1 获取这些标签，这些标签将特定于考试 1。
- en: Also note that we needed to plot exam 1 first. The scores there were less diverse,
    so the density estimate was narrower and taller. Had we plotted exam 2, with its
    shorter curve, first, exam 1’s curve would have been too tall for the plot window.
    Here, we first ran the two plots separately to see which was taller, but let’s
    consider a more general situation.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们首先绘制了考试 1 的图表。那里的分数多样性较低，因此密度估计较窄且较高。如果我们首先绘制了曲线较短的考试 2，那么考试 1 的曲线就会太高，无法在绘图窗口中显示。在这里，我们首先分别运行了两个图表，以查看哪个更高，但让我们考虑一个更普遍的情况。
- en: Say we wish to write a broadly usable function that will plot several density
    estimates on the same graph. For this, we would need to automate the process of
    determining which density estimate is tallest. To do so, we would use the fact
    that the estimated density values are contained in the y component of the return
    value from the call to density(). We would then call max() on each density estimate
    and use which.max() to determine which density estimate is the tallest.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望编写一个广泛使用的函数，该函数可以在同一张图上绘制多个密度估计值。为此，我们需要自动化确定哪个密度估计值最高的过程。要做到这一点，我们可以使用这样一个事实：估计的密度值包含在调用density()的返回值的y组件中。然后我们对每个密度估计值调用max()，并使用which.max()来确定哪个密度估计值是最高的。
- en: The call to plot() both initiates the plot and draws the first curve. (Without
    specifying type="l", only the points would have been plotted.) The call to lines()
    then adds the second curve.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: The call to plot() both initiates the plot and draws the first curve. (Without
    specifying type="l", only the points would have been plotted.) The call to lines()
    then adds the second curve.
- en: '***12.1.5 Extended Example: More on the Polynomial Regression Example***'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.1.5 扩展示例：多项式回归示例的更多内容***'
- en: 'In Section 9.1.7, we defined a class "polyreg" that facilitates fitting polynomial
    regression models. Our code there included an implementation of the generic print()
    function. Let’s now add one for the generic plot() function: 1'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9.1.7节中，我们定义了一个类 "polyreg"，它简化了拟合多项式回归模型的过程。我们那里的代码包括了一个通用print()函数的实现。现在让我们为通用plot()函数添加一个：1
- en: polyfit(x,maxdeg) fits all polynomials up to degree maxdeg; y is
  id: totrans-1065
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: polyfit(x,maxdeg) 拟合所有最高到maxdeg度的多项式；y是
- en: '2'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: vector for response variable, x for predictor; creates an object of 3
  id: totrans-1067
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应变量的向量，x为预测变量；创建一个包含3个对象的
- en: class "polyreg", consisting of outputs from the various regression 4
  id: totrans-1068
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类 "polyreg"，由各种回归的输出组成 4
- en: models, plus the original data
  id: totrans-1069
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型，以及原始数据
- en: '5'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: polyfit <- function(y,x,maxdeg) {
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: polyfit <- function(y,x,maxdeg) {
- en: '6'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: 'pwrs <- powers(x,maxdeg) # form powers of predictor variable'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 'pwrs <- powers(x,maxdeg) # 形成预测变量的幂'
- en: '7'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: 'lmout <- list() # start to build class'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 'lmout <- list() # start to build class'
- en: '8'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: 'class(lmout) <- "polyreg" # create a new class'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 'class(lmout) <- "polyreg" # 创建一个新的类'
- en: '9'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: for (i in 1:maxdeg) {
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:maxdeg) {
- en: '10'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: lmo <- lm(y ~ pwrs[,1:i])
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: lmo <- lm(y ~ pwrs[,1:i])
- en: '11'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: extend the lm class here, with the cross-validated predictions
  id: totrans-1083
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在这里扩展lm类，包括交叉验证的预测
- en: '12'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: lmo$fitted.xvvalues <- lvoneout(y,pwrs[,1:i,drop=F])
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: lmo$fitted.xvvalues <- lvoneout(y,pwrs[,1:i,drop=F])
- en: '13'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: lmout[[i]] <- lmo
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: lmout[[i]] <- lmo
- en: '14'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '}'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '15'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: lmout$x <- x
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: lmout$x <- x
- en: '16'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: lmout$y <- y
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: lmout$y <- y
- en: '17'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: return(lmout)
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: return(lmout)
- en: '18'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: '}'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '19'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: '20'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: 'generic print() for an object fits of class "polyreg": print 21'
  id: totrans-1100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对类 "polyreg" 的对象 fits 的通用print()：print 21
- en: cross-validated mean-squared prediction errors
  id: totrans-1101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交叉验证均方预测误差
- en: '22'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: print.polyreg <- function(fits) {
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: print.polyreg <- function(fits) {
- en: '23'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: 'maxdeg <- length(fits) - 2 # count lm() outputs only, not $x and $y **266**'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 'maxdeg <- length(fits) - 2 # 仅计算lm()的输出，不包括$x和$y **266**'
- en: Chapter 12
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 第12章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '24'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: n <- length(fits$y)
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(fits$y)
- en: '25'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: tbl <- matrix(nrow=maxdeg,ncol=1)
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: tbl <- matrix(nrow=maxdeg,ncol=1)
- en: '26'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '26'
- en: cat("mean squared prediction errors, by degree\n")
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: cat("均方预测误差，按度数\n")
- en: '27'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '27'
- en: colnames(tbl) <- "MSPE"
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: colnames(tbl) <- "MSPE"
- en: '28'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '28'
- en: for (i in 1:maxdeg) {
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:maxdeg) {
- en: '29'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '29'
- en: fi <- fits[[i]]
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: fi <- fits[[i]]
- en: '30'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: errs <- fits$y - fi$fitted.xvvalues
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: errs <- fits$y - fi$fitted.xvvalues
- en: '31'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '31'
- en: spe <- sum(errs^2)
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: spe <- sum(errs^2)
- en: '32'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '32'
- en: tbl[i,1] <- spe/n
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: tbl[i,1] <- spe/n
- en: '33'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: '33'
- en: '}'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '34'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '34'
- en: print(tbl)
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: print(tbl)
- en: '35'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '35'
- en: '}'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '36'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: '36'
- en: '37'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '37'
- en: generic plot(); plots fits against raw data
  id: totrans-1134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用plot()；绘制拟合值与原始数据
- en: '38'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '38'
- en: plot.polyreg <- function(fits) {
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: plot.polyreg <- function(fits) {
- en: '39'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '39'
- en: 'plot(fits$x,fits$y,xlab="X",ylab="Y") # plot data points as background 40'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 'plot(fits$x,fits$y,xlab="X",ylab="Y") # 以背景形式绘制数据点 40'
- en: maxdg <- length(fits) - 2
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: maxdg <- length(fits) - 2
- en: '41'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '41'
- en: cols <- c("red","green","blue")
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: cols <- c("red","green","blue")
- en: '42'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: dg <- curvecount <- 1
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: dg <- curvecount <- 1
- en: '43'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '43'
- en: while (dg < maxdg) {
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: while (dg < maxdg) {
- en: '44'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '44'
- en: prompt <- paste("RETURN for XV fit for degree",dg,"or type degree", 45
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: prompt <- paste("RETURN for XV fit for degree",dg,"or type degree", 45
- en: '"or q for quit ")'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '"或 q 退出 ")'
- en: '46'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '46'
- en: rl <- readline(prompt)
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: rl <- readline(prompt)
- en: '47'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '47'
- en: dg <- if (rl == "") dg else if (rl != "q") as.integer(rl) else break 48
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: dg <- if (rl == "") dg else if (rl != "q") as.integer(rl) else break 48
- en: lines(fits$x,fits[[dg]]$fitted.values,col=cols[curvecount%%3 + 1])
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: lines(fits$x,fits[[dg]]$fitted.values,col=cols[curvecount%%3 + 1])
- en: '49'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: '49'
- en: dg <- dg + 1
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: dg <- dg + 1
- en: '50'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '50'
- en: curvecount <- curvecount + 1
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: curvecount <- curvecount + 1
- en: '51'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '51'
- en: '}'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '52'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '52'
- en: '}'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '53'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '53'
- en: '54'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '54'
- en: forms matrix of powers of the vector x, through degree dg
  id: totrans-1164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: forms matrix of powers of the vector x, through degree dg
- en: '55'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '55'
- en: powers <- function(x,dg) {
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: powers <- function(x,dg) {
- en: '56'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '56'
- en: pw <- matrix(x,nrow=length(x))
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: pw <- matrix(x,nrow=length(x))
- en: '57'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '57'
- en: prod <- x
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: prod <- x
- en: '58'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: '58'
- en: for (i in 2:dg) {
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 2:dg) {
- en: '59'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '59'
- en: prod <- prod * x
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: '60'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: pw <- cbind(pw,prod)
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: '61'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: '62'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: return(pw)
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: '63'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: '64'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: '65'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: finds cross-validated predicted values; could be made much faster via 66
  id: totrans-1185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: matrix-update methods
  id: totrans-1186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '67'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: lvoneout <- function(y,xmat) {
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: '68'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(y)
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: '69'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: predy <- vector(length=n)
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: '70'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:n) {
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: '**267**'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: '71'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: regress, leaving out ith observation
  id: totrans-1199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '72'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: lmo <- lm(y[-i] ~ xmat[-i,])
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: '73'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: betahat <- as.vector(lmo$coef)
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '74'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: the 1 accommodates the constant term
  id: totrans-1205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '75'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: predy[i] <- betahat %*% c(1,xmat[i,])
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: '76'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: '77'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: return(predy)
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: '78'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: '79'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: '80'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: polynomial function of x, coefficients cfs
  id: totrans-1216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '81'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: poly <- function(x,cfs) {
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: '82'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: val <- cfs[1]
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: '83'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: prod <- 1
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: '84'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: dg <- length(cfs) - 1
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: '85'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:dg) {
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: '86'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: prod <- prod * x
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: '87'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: val <- val + cfs[i+1] * prod
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: '88'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: '89'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted, the only new code is plot.polyreg(). For convenience, the code is
    reproduced here:'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: generic plot(); plots fits against raw data
  id: totrans-1236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: plot.polyreg <- function(fits) {
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: 'plot(fits$x,fits$y,xlab="X",ylab="Y") # plot data points as background maxdg
    <- length(fits) - 2'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: cols <- c("red","green","blue")
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: dg <- curvecount <- 1
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: while (dg < maxdg) {
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: prompt <- paste("RETURN for XV fit for degree",dg,"or type degree",
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: '"or q for quit ")'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: rl <- readline(prompt)
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: dg <- if (rl == "") dg else if (rl != "q") as.integer(rl) else break lines(fits$x,fits[[dg]]$fitted.values,col=cols[curvecount%%3
    + 1])
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: dg <- dg + 1
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: curvecount <- curvecount + 1
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: As before, our implementation of the generic function takes the name of the
    class, which is plot.polyreg() here.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: The while loop iterates through the various polynomial degrees. We
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: cycle through three colors, by setting the vector cols; note the expression
    curvecount %%3 for this purpose.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: '**268**'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 29](index-295_1.png)'
  id: totrans-1256
  prefs: []
  type: TYPE_IMG
- en: 'The user can choose either to plot the next sequential degree or select a different
    one. The query, both user prompt and reading of the user’s reply, is done in this
    line:'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: rl <- readline(prompt)
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the R string function paste() to assemble a prompt, offering the user
    a choice of plotting the next fitted polynomial, plotting one of a different degree,
    or quitting. The prompt appears in the interactive R window in which we issued
    the plot() call. For instance, after taking the default choice twice, the command
    window looks like this:'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: plot(lmo)
  id: totrans-1260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: RETURN for XV fit for degree 1 or type degree or q for quit
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: RETURN for XV fit for degree 2 or type degree or q for quit
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: RETURN for XV fit for degree 3 or type degree or q for quit
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: The plot window looks like Figure 12-5\.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-5: Plotting a polynomial fit*'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: '***12.1.6 Adding Points: The points() Function***'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: 'The points() function adds a set of ( *x*, *y*) points, with labels for each,
    to the currently displayed graph. For instance, in our first example, suppose
    we entered this command:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: points(testscores$Exam1,testscores$Exam3,pch="+")
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: '**269**'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: The result would be to superimpose onto the current graph the points of the
    exam scores from that example, using plus signs (+) to mark them.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是将示例中的考试成绩点叠加到当前图上，使用加号（+）标记它们。
- en: 'As with most of the other graphics functions, there are many options, such
    as point color and background color. For instance, if you want a yellow background,
    type this command:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他图形函数一样，有许多选项，例如点颜色和背景颜色。例如，如果您想要黄色背景，请输入以下命令：
- en: par(bg="yellow")
  id: totrans-1274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: par(bg="yellow")
- en: Now your graphs will have a yellow background, until you specify
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的图表将具有黄色背景，直到您指定
- en: otherwise.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: otherwise.
- en: 'As with other functions, to explore the myriad of options, type this:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他函数一样，为了探索众多选项，请输入以下内容：
- en: help(par)
  id: totrans-1278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: help(par)
- en: '***12.1.7 Adding a Legend: The legend() Function***'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.1.7 添加图例：legend() 函数***'
- en: 'The legend() function is used, not surprisingly, to add a legend to a multi-curve
    graph. This could tell the viewer something like, “The green curve is for the
    men, and the red curve displays the data for the women.” Type the following to
    see some nice examples:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不意外，legend() 函数用于向多曲线图添加图例。这可以告诉观众类似的信息，例如，“绿色曲线代表男性，红色曲线显示女性的数据。”输入以下内容以查看一些示例：
- en: example(legend)
  id: totrans-1281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: example(legend)
- en: '***12.1.8 Adding Text: The text() Function***'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.1.8 添加文本：text() 函数***'
- en: Use the text() function to place some text anywhere in the current graph.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 text() 函数将文本放置在当前图的任何位置。
- en: 'Here’s an example:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: text(2.5,4,"abc")
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: text(2.5,4,"abc")
- en: This writes the text “abc” at the point (2.5,4) in the graph. The center of
    the string, in this case “b,” would go at that point.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在图中的点 (2.5,4) 处写入文本“abc”。在这种情况下，字符串的中心，“b”，将位于该点。
- en: 'To see a more practical example, let’s add some labels to the curves in our
    exam scores graph, as follows:'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到一个更实际的示例，让我们向我们的考试成绩图中的曲线添加一些标签，如下所示：
- en: text(46.7,0.02,"Exam 1")
  id: totrans-1288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: text(46.7,0.02,"Exam 1")
- en: text(12.3,0.008,"Exam 2")
  id: totrans-1289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: text(12.3,0.008,"Exam 2")
- en: The result is shown in Figure 12-6\.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如图 12-6 所示。
- en: In order to get a certain string placed exactly where you want it, you may need
    to engage in some trial and error. Or you may find the locator() function to be
    a much quicker way to go, as detailed in the next section.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将某个字符串放置在您想要的确切位置，您可能需要进行一些试错。或者，您可能会发现 locator() 函数是一个更快的方法，如下一节所述。
- en: '**270**'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: '**270**'
- en: Chapter 12
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 第 12 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 30](index-297_1.png)'
  id: totrans-1295
  prefs: []
  type: TYPE_IMG
  zh: '![Image 30](index-297_1.png)'
- en: '*Figure 12-6: Placing text*'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-6：放置文本*'
- en: '***12.1.9 Pinpointing Locations: The locator() Function***'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.1.9 精确定位位置：locator() 函数***'
- en: Placing text exactly where you wish can be tricky. You could repeatedly try
    different *x*- and *y*-coordinates until you find a good position, but the locator()
    function can save you a lot of trouble. You simply call the function and then
    click the mouse at the desired spot in the graph. The function returns the *x*-
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本精确放置在您希望的位置可能很棘手。您可以通过反复尝试不同的 *x*-和 *y*-坐标直到找到一个好的位置，但 locator() 函数可以为您节省很多麻烦。您只需调用该函数，然后在图中的所需位置点击鼠标。该函数返回
    *x*-
- en: 'and *y*-coordinates of your click point. Specifically, typing the following
    will tell R that you will click in one place in the graph:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 和 *y*-坐标的点击点。具体来说，输入以下内容将告诉 R 你将在图中的一个位置点击：
- en: locator(1)
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: locator(1)
- en: 'Once you click, R will tell you the exact coordinates of the point you clicked.
    Call locator(2) to get the locations of two places, and so on. (Warning: Make
    sure to include the argument.)'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击，R 将告诉您您点击的点的确切坐标。调用 locator(2) 获取两个位置的位置，依此类推。（警告：请确保包含参数。）
- en: 'Here is a simple example:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的示例：
- en: hist(c(12,5,13,25,16))
  id: totrans-1303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hist(c(12,5,13,25,16))
- en: locator(1)
  id: totrans-1304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: locator(1)
- en: $x
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: $x
- en: '[1] 6.239237'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 6.239237'
- en: $y
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: $y
- en: '[1] 1.221038'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1.221038'
- en: Graphics
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 图形
- en: '**271**'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '**271**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: This has R draw a histogram and then calls locator() with the argument 1, indicating
    we will click the mouse once. After the click, the function returns a list with
    components x and y, the *x*- and *y*-coordinates of the point where we clicked.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让 R 绘制直方图，然后使用参数 1 调用 locator()，表示我们将点击鼠标一次。点击后，函数返回一个包含 x 和 y 成分的列表，即我们点击点的
    *x*-和 *y*-坐标。
- en: 'To use this information to place text, combine it with text():'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此信息放置文本，请将其与 text() 函数结合使用：
- en: text(locator(1),"nv=75")
  id: totrans-1314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: text(locator(1),"nv=75")
- en: Here, text() was expecting an *x*-coordinate and a *y*-coordinate, specifying
    the point at which to draw the text “nv=75.” The return value of locator() supplied
    those coordinates.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，text()期望一个*x*坐标和一个*y*坐标，指定绘制文本“nv=75.”的点。locator()的返回值提供了这些坐标。
- en: '***12.1.10 Restoring a Plot***'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.1.10 恢复图形***'
- en: R has no “undo” command. However, if you suspect you may need to undo your next
    step when building a graph, you can save it using recordPlot() and then later
    restore it with replayPlot().
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: R没有“撤销”命令。然而，如果你在构建图形时怀疑你可能需要撤销下一步，你可以使用recordPlot()保存它，然后稍后使用replayPlot()恢复它。
- en: Less formally but more conveniently, you can put all the commands
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 不太正式但更方便的是，你可以将所有命令
- en: you’re using to build up a graph in a file and then use source(), or cut and
    paste with the mouse, to execute them. If you change one command, you can redo
    the whole graph by sourcing or copying and pasting your file.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用它来在文件中构建图形，然后使用source()或使用鼠标剪切和粘贴来执行它们。如果你更改一个命令，你可以通过source()或复制粘贴你的文件来重新绘制整个图形。
- en: For our current graph, for instance, we could create file named
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于我们的当前图形，我们可以创建一个名为
- en: 'examplot.R with the following contents:'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: examplot.R包含以下内容：
- en: d1 = density(testscores$Exam1,from=0,to=100)
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: d1 = density(testscores$Exam1,from=0,to=100)
- en: d2 = density(testscores$Exam2,from=0,to=100)
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: d2 = density(testscores$Exam2,from=0,to=100)
- en: plot(d1,main="",xlab="")
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: plot(d1,main="",xlab="")
- en: lines(d2)
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: lines(d2)
- en: text(46.7,0.02,"Exam 1")
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: text(46.7,0.02,"Exam 1")
- en: text(12.3,0.008,"Exam 2")
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: text(12.3,0.008,"Exam 2")
- en: 'If we decide that the label for exam 1 was a bit too far to the right, we can
    edit the file and then either do the copy-and-paste or execute the following:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定考试1的标签稍微偏右了一些，我们可以编辑文件，然后执行以下操作之一：
- en: source("examplot.R")
  id: totrans-1329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: source("examplot.R")
- en: '**12.2 Customizing Graphs**'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.2 自定义图形**'
- en: You’ve seen how easy it is to build simple graphs in stages, starting with plot().
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何通过plot()逐步构建简单图形，非常容易。
- en: Now you can begin to enhance those graphs, using the many options R
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始使用R的许多选项来增强这些图形。
- en: provides.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 提供。
- en: '***12.2.1 Changing Character Sizes: The cex Option***'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.2.1 改变字符大小：cex选项***'
- en: The cex (for *character expand*) function allows you to expand or shrink characters
    within a graph, which can be very useful. You can use it as a named **272**
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: cex（代表*字符扩展*）函数允许你在图形内扩展或缩小字符，这非常有用。你可以将其用作各种绘图函数中的命名**272**
- en: Chapter 12
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 第12章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'parameter in various graphing functions. For instance, you may wish to draw
    the text “abc” at some point, say (2.5,4), in your graph but with a larger font,
    in order to call attention to this particular text. You could do this by typing
    the following:'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 参数，以在文件中构建图形，然后使用source()，或者使用鼠标剪切和粘贴来执行它们。如果你更改一个命令，你可以通过source()或复制粘贴你的文件来重新绘制整个图形。
- en: text(2.5,4,"abc",cex = 1.5)
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: text(2.5,4,"abc",cex = 1.5)
- en: This prints the same text as in our earlier example but with characters 1.5
    times the normal size.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出与早期示例相同的文本，但字符大小是正常大小的1.5倍。
- en: '***12.2.2 Changing the Range of Axes: The xlim and ylim Options***'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.2.2 改变坐标轴范围：xlim和ylim选项***'
- en: You may wish to have the ranges on the *x*- and *y*-axes of your plot be broader
    or narrower than the default. This is especially useful if you will be displaying
    several curves in the same graph.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望你的图形的*x*轴和*y*轴的范围比默认范围更宽或更窄。如果你将在同一图形中显示多个曲线，这特别有用。
- en: You can adjust the axes by specifying the xlim and/or ylim parameters in your
    call to plot() or points(). For example, ylim=c(0,90000) specifies a range on
    the *y*-axis of 0 to 90,000\.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在plot()或points()调用中指定xlim和/或ylim参数来调整坐标轴。例如，ylim=c(0,90000)指定*y*轴的范围为0到90,000。
- en: If you have several curves and do not specify xlim and/or ylim, you should draw
    the tallest curve first so there is room for all of them. Otherwise, R will fit
    the plot to the first one your draw and then cut off taller ones at the top!
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有几个曲线，并且没有指定xlim和/或ylim，你应该先绘制最高的曲线，以便为所有曲线留出空间。否则，R将根据你首先绘制的曲线调整图形，然后在上部截断较高的曲线！
- en: 'We took this approach earlier, when we plotted two density estimates on the
    same graph (Figures 12-3 and 12-4). Instead, we could have first found the highest
    values of the two density estimates. For d1, we find the following:'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前采取了这种方法，当时我们在同一图形上绘制了两个密度估计（图12-3和12-4）。相反，我们首先可以找到两个密度估计的最高值。对于d1，我们找到以下内容：
- en: d1
  id: totrans-1346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d1
- en: 'Call:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 调用：
- en: density.default(x = testscores$Exam1, from = 0, to = 100)
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: density.default(x = testscores$Exam1, from = 0, to = 100)
- en: 'Data: testscores$Exam1 (39 obs.);'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 数据：testscores$Exam1（39个观测值）；
- en: Bandwidth 'bw' = 6.967
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 带宽 'bw' = 6.967
- en: x
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: x
- en: y
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: y
- en: Min.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值
- en: ': 0'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: ': 0'
- en: Min.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值
- en: :1.423e-07
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: :1.423e-07
- en: '1st Qu.: 25'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 第一四分位数：25
- en: 1st Qu.:1.629e-03
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 第一四分位数：1.629e-03
- en: 'Median : 50'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数：50
- en: Median :9.442e-03
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数：9.442e-03
- en: Mean
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值
- en: ': 50'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: ': 50'
- en: Mean
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值
- en: :9.844e-03
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: :9.844e-03
- en: '3rd Qu.: 75'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 第三四分位数：75
- en: 3rd Qu.:1.756e-02
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 第三四分位数：1.756e-02
- en: Max.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值.
- en: :100
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: :100
- en: Max.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值
- en: :2.156e-02
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: :2.156e-02
- en: 'So, the largest y-value is 0.022\. For d2, it was only 0.017\. That means we
    should have plenty of room if we set ylim at 0.03\. Here is how we could draw
    the two plots on the same picture:'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最大的 y 值是 0.022。对于 d2，它只有 0.017。这意味着如果我们把 ylim 设置为 0.03，我们就有足够的空间。以下是我们在同一张图上绘制两个图形的方法：
- en: plot(c(0, 100), c(0, 0.03), type = "n", xlab="score", ylab="density")
  id: totrans-1372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: plot(c(0, 100), c(0, 0.03), type = "n", xlab="score", ylab="density")
- en: lines(d2)
  id: totrans-1373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lines(d2)
- en: lines(d1)
  id: totrans-1374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lines(d1)
- en: Graphics
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 图形
- en: '**273**'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: '**273**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 31](index-300_1.jpg)'
  id: totrans-1378
  prefs: []
  type: TYPE_IMG
  zh: '![Image 31](index-300_1.jpg)'
- en: '![Image 32](index-300_2.jpg)'
  id: totrans-1379
  prefs: []
  type: TYPE_IMG
  zh: '![Image 32](index-300_2.jpg)'
- en: First we drew the bare-bones plot—just axes without innards, as shown in Figure
    12-7\. The first two arguments to plot() give xlim and ylim, so that the lower
    and upper limits on the Y axis will be 0 and 0.03\. Calling lines() twice then
    fills in the graph, yielding Figures 12-8 and 12-9\. (Either of the two lines()
    calls could come first, as we’ve left enough room.)
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先绘制了裸骨图——仅坐标轴，没有内部结构，如图12-7所示。plot() 的前两个参数给出 xlim 和 ylim，因此 Y 轴的下限和上限将是
    0 和 0.03。然后调用 lines() 两次填充图形，得到图12-8和12-9。（两个 lines() 调用中的任何一个都可以先进行，因为我们留下了足够的空间。）
- en: '*Figure 12-7: Axes only*'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-7：仅坐标轴*'
- en: '*Figure 12-8: Addition of* d2'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-8：d2的加法*'
- en: '**274**'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: '**274**'
- en: Chapter 12
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 第12章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 33](index-301_1.jpg)'
  id: totrans-1386
  prefs: []
  type: TYPE_IMG
  zh: '![Image 33](index-301_1.jpg)'
- en: '*Figure 12-9: Addition of* d1'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-9：d1的加法*'
- en: '***12.2.3 Adding a Polygon: The polygon() Function***'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.2.3 添加多边形：polygon() 函数***'
- en: You can use polygon() to draw arbitrary polygonal objects. For example, the
    following code draws the graph of the function *f* ( *x*) = 1 *− e−x* and then
    adds a rectangle that approximates the area under the curve from *x* = 1.2 to
    *x* = 1.4\.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 polygon() 绘制任意多边形对象。例如，以下代码绘制了函数 *f* ( *x*) = 1 *− e−x* 的图形，然后添加了一个近似曲线下从
    *x* = 1.2 到 *x* = 1.4区域的矩形。
- en: f <- function(x) return(1-exp(-x))
  id: totrans-1390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: f <- function(x) return(1-exp(-x))
- en: curve(f,0,2)
  id: totrans-1391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: curve(f,0,2)
- en: polygon(c(1.2,1.4,1.4,1.2),c(0,0,f(1.3),f(1.3)),col="gray") The result is shown
    in Figure 12-10\.
  id: totrans-1392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: polygon(c(1.2,1.4,1.4,1.2),c(0,0,f(1.3),f(1.3)),col="gray") 结果显示在图12-10中。
- en: In the call to polygon() here, the first argument is the set of *x*-coordinates
    for the rectangle, and the second argument specifies the *y*-coordinates. The
    third argument specifies that the rectangle in this case should be shaded in solid
    gray.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 在 polygon() 的调用中，第一个参数是矩形的 *x* 坐标集合，第二个参数指定 *y* 坐标。第三个参数指定在这种情况下矩形应以实灰色填充。
- en: 'As another example, we could use the density argument to fill the rectangle
    with striping. This call specifies 10 lines per inch:'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，我们可以使用密度参数用条纹填充矩形。此调用指定每英寸10条线：
- en: polygon(c(1.2,1.4,1.4,1.2),c(0,0,f(1.3),f(1.3)),density=10)
  id: totrans-1395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: polygon(c(1.2,1.4,1.4,1.2),c(0,0,f(1.3),f(1.3)),density=10)
- en: Graphics
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 图形
- en: '**275**'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: '**275**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 34](index-302_1.jpg)'
  id: totrans-1399
  prefs: []
  type: TYPE_IMG
  zh: '![Image 34](index-302_1.jpg)'
- en: '*Figure 12-10: Rectangular area strip*'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-10：矩形区域条纹*'
- en: '***12.2.4 Smoothing Points: The lowess() and loess() Functions***'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.2.4 平滑点：lowess() 和 loess() 函数***'
- en: Just plotting a cloud of points, connected or not, may give you nothing but
    an uninformative mess. In many cases, it is better to smooth out the data by fitting
    a nonparametric regression estimator such as lowess().
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 仅绘制点云，无论是否连接，可能只会给你一个无信息性的混乱。在许多情况下，通过拟合非参数回归估计量（如lowess()）来平滑数据会更好。
- en: Let’s do that for our test score data. We’ll plot the scores of exam 2
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的考试成绩数据做这个。我们将绘制考试2的分数
- en: 'against those of exam 1:'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 与考试1的分数进行比较：
- en: plot(testscores)
  id: totrans-1405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: plot(testscores)
- en: lines(lowess(testscores))
  id: totrans-1406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lines(lowess(testscores))
- en: The result is shown in Figure 12-11\.
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在图12-11中。
- en: A newer alternative to lowess() is loess(). The two functions are similar but
    have different defaults and other options. You need some advanced knowledge of
    statistics to appreciate the differences. Use whichever you find gives better
    smoothing.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: lowess() 的一个较新的替代方法是 loess()。这两个函数相似，但默认值和其他选项不同。您需要一些高级的统计知识来欣赏它们之间的差异。使用您认为能提供更好平滑效果的函数。
- en: '***12.2.5 Graphing Explicit Functions***'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.2.5 显式函数绘图***'
- en: Say you want to plot the function *g*( *t*) = ( *t* 2 + 1)0 *.* 5 for t between
    0 and 5\.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想绘制函数 *g*( *t*) = ( *t* 2 + 1)0 *.* 5 在 t 介于 0 和 5 之间的图形。
- en: 'You could use the following R code:'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下 R 代码：
- en: 'g <- function(t) { return (t^2+1)^0.5 } # define g()'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 'g <- function(t) { return (t^2+1)^0.5 } # 定义 g()'
- en: 'x <- seq(0,5,length=10000) # x = [0.0004, 0.0008, 0.0012,..., 5]'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 'x <- seq(0,5,length=10000) # x = [0.0004, 0.0008, 0.0012,..., 5]'
- en: 'y <- g(x) # y = [g(0.0004), g(0.0008), g(0.0012), ..., g(5)]'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 'y <- g(x) # y = [g(0.0004), g(0.0008), g(0.0012), ..., g(5)]'
- en: plot(x,y,type="l")
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制 x 和 y，类型为 "l"
- en: '**276**'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: '**276**'
- en: Chapter 12
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 第 12 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 35](index-303_1.jpg)'
  id: totrans-1419
  prefs: []
  type: TYPE_IMG
  zh: '![Image 35](index-303_1.jpg)'
- en: '*Figure 12-11: Smoothing the exam score relation*'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-11：平滑考试成绩关系*'
- en: 'But you could avoid some work by using the curve() function, which basically
    uses the same method:'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可以通过使用 curve() 函数来避免一些工作，该函数基本上使用相同的方法：
- en: curve((x^2+1)^0.5,0,5)
  id: totrans-1422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 绘制曲线((x^2+1)^0.5,0,5)
- en: 'If you are adding this curve to an existing plot, use the add argument:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要将此曲线添加到现有图中，请使用 add 参数：
- en: curve((x^2+1)^0.5,0,5,add=T)
  id: totrans-1424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: curve((x^2+1)^0.5,0,5,add=T)
- en: The optional argument n has the default value 101, meaning that the function
    will be evaluated at 101 equally spaced points in the specified range of x.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数 n 的默认值为 101，这意味着函数将在 x 的指定范围内以 101 个等间距的点进行评估。
- en: Use just enough points for visual smoothness. If you find 101 is not enough,
    experiment with higher values of n.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用足够多的点以获得视觉平滑度。如果您发现 101 个点不够，请尝试更高的 n 值。
- en: 'You can also use plot(), as follows:'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 plot()，如下所示：
- en: f <- function(x) return((x^2+1)^0.5)
  id: totrans-1428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: f <- function(x) return((x^2+1)^0.5)
- en: 'plot(f,0,5) # the argument must be a function name'
  id: totrans-1429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '绘制 f,0,5 # 参数必须是函数名'
- en: Here, the call plot() leads to calling plot.function(), the implementation of
    the generic plot() function for the function class.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，调用 plot() 导致调用 plot.function()，这是函数类通用的 plot() 函数的实现。
- en: Again, the approach is your choice; use whichever one you prefer.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，方法由您选择；使用您喜欢的任何一种。
- en: '***12.2.6 Extended Example: Magnifying a Portion of a Curve***'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.2.6 扩展示例：放大曲线的一部分***'
- en: After you use curve() to graph a function, you may want to “zoom in” on one
    portion of the curve. You could do this by simply calling curve() again on Graphics
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 在您使用 curve() 绘制函数图后，您可能希望“放大”曲线的一部分。您可以通过在 Graphics 上再次调用 curve() 来实现这一点。
- en: '**277**'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: '**277**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: the same function but with a restricted *x* range. But suppose you wish to display
    the original plot and the close-up one in the same picture. Here, we will develop
    a function, which we’ll name inset(), to do this.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的函数，但具有限制的 *x* 范围。但假设您希望在同一张图中显示原始图和放大图。在这里，我们将开发一个函数，我们将其命名为 inset() 来完成此操作。
- en: 'In order to avoid redoing the work that curve() did in plotting the original
    graph, we will modify its code slightly to save that work, via a return value.
    We can do this by taking advantage of the fact that you can easily inspect the
    code of R functions written in R (as opposed to the fundamental R functions written
    in C), as follows:'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复 curve() 在绘制原始图形时所做的所有工作，我们将稍微修改其代码以保存这项工作，通过返回值来实现。我们可以通过利用您可以轻松检查用 R
    编写的 R 函数的代码（与用 C 编写的 R 的基本函数相反）来实现这一点，如下所示：
- en: '1'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: curve
  id: totrans-1439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: curve
- en: '2'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: function (expr, from = NULL, to = NULL, n = 101, add = FALSE,
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: function (expr, from = NULL, to = NULL, n = 101, add = FALSE,
- en: '3'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: type = "l", ylab = NULL, log = NULL, xlim = NULL, ...)
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: type = "l", ylab = NULL, log = NULL, xlim = NULL, ...)
- en: '4'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '{'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '5'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: sexpr <- substitute(expr)
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: sexpr <- substitute(expr)
- en: '6'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: if (is.name(sexpr)) {
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: if (is.name(sexpr)) {
- en: '7'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '...lots of lines omitted here...'
  id: totrans-1451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '...此处省略大量行...'
- en: '8'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: x <- if (lg != "" && "x" %in% strsplit(lg, NULL)[[1]]) {
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: x <- if (lg != "" && "x" %in% strsplit(lg, NULL)[[1]]) {
- en: '9'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: if (any(c(from, to) <= 0))
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: if (any(c(from, to) <= 0))
- en: '10'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: stop("'from' and 'to' must be > 0 with log=\"x\"") 11
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 停止错误("'from' 和 'to' 必须大于 0，当 log=\"x\" 时") 11
- en: exp(seq.int(log(from), log(to), length.out = n))
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: exp(seq.int(log(from), log(to), length.out = n))
- en: '12'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '}'
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '13'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: else seq.int(from, to, length.out = n)
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 否则 seq.int(from, to, length.out = n)
- en: '14'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: y <- eval(expr, envir = list(x = x), enclos = parent.frame())
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: y <- eval(expr, envir = list(x = x), enclos = parent.frame())
- en: '15'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: if (add)
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: if (add)
- en: '16'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: lines(x, y, type = type, ...)
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: lines(x, y, type = type, ...)
- en: '17'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: else plot(x, y, type = type, ylab = ylab, xlim = xlim, log = lg, ...) 18
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 否则绘制 x 和 y，类型为 type，y 轴标签为 ylab，x 轴限制为 xlim，log 为 lg，... 18
- en: '}'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The code forms vectors x and y, consisting of the *x*- and *y*-coordinates of
    the curve to be plotted, at n equally spaced points in the range of *x*. Since
    we’ll make use of those in inset(), let’s modify this code to return x and y.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 代码形成向量 x 和 y，包含要绘制的曲线的 x 和 y 坐标，在 x 的范围内以 n 个等间距的点。由于我们将在 inset() 中使用这些，让我们修改此代码以返回
    x 和 y。
- en: 'Here’s the modified version, which we’ve named crv():'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修改后的版本，我们将其命名为 crv()：
- en: '1'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: crv
  id: totrans-1475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: crv
- en: '2'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: function (expr, from = NULL, to = NULL, n = 101, add = FALSE,
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: function (expr, from = NULL, to = NULL, n = 101, add = FALSE,
- en: '3'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: type = "l", ylab = NULL, log = NULL, xlim = NULL, ...)
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: type = "l", ylab = NULL, log = NULL, xlim = NULL, ...)
- en: '4'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '{'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '5'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: sexpr <- substitute(expr)
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: sexpr <- substitute(expr)
- en: '6'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: if (is.name(sexpr)) {
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: if (is.name(sexpr)) {
- en: '7'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '...lots of lines omitted here...'
  id: totrans-1487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '...此处省略大量行...'
- en: '8'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: x <- if (lg != "" && "x" %in% strsplit(lg, NULL)[[1]]) {
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: x <- if (lg != "" && "x" %in% strsplit(lg, NULL)[[1]]) {
- en: '9'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: if (any(c(from, to) <= 0))
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: if (any(c(from, to) <= 0))
- en: '10'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: stop("'from' and 'to' must be > 0 with log=\"x\"") 11
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: stop("'from' and 'to' must be > 0 with log=\"x\"") 11
- en: exp(seq.int(log(from), log(to), length.out = n))
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: exp(seq.int(log(from), log(to), length.out = n))
- en: '12'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '}'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '13'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: else seq.int(from, to, length.out = n)
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: else seq.int(from, to, length.out = n)
- en: '14'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: y <- eval(expr, envir = list(x = x), enclos = parent.frame())
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: y <- eval(expr, envir = list(x = x), enclos = parent.frame())
- en: '15'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: if (add)
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: if (add)
- en: '**278**'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: '**278**'
- en: Chapter 12
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 第12章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '16'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: lines(x, y, type = type, ...)
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: lines(x, y, type = type, ...)
- en: '17'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: else plot(x, y, type = type, ylab = ylab, xlim = xlim, log = lg, ...) 18
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: else plot(x, y, type = type, ylab = ylab, xlim = xlim, log = lg, ...) 18
- en: 'return(list(x=x,y=y)) # this is the only modification'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 'return(list(x=x,y=y)) # 这是唯一的修改'
- en: '19'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: '}'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Now we can get to our inset() function.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进入我们的inset()函数。
- en: '1'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'savexy: list consisting of x and y vectors returned by crv()'
  id: totrans-1515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'savexy: 由crv()返回的x和y向量组成的列表'
- en: '2'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: 'x1,y1,x2,y2: coordinates of rectangular region to be magnified'
  id: totrans-1517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'x1,y1,x2,y2: 要放大的矩形区域的坐标'
- en: '3'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: 'x3,y3,x4,y4: coordinates of inset region'
  id: totrans-1519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'x3,y3,x4,y4: 嵌入区域的坐标'
- en: '4'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: inset <- function(savexy,x1,y1,x2,y2,x3,y3,x4,y4) {
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: inset <- function(savexy,x1,y1,x2,y2,x3,y3,x4,y4) {
- en: '5'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: 'rect(x1,y1,x2,y2) # draw rectangle around region to be magnified'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect(x1,y1,x2,y2) # 在要放大的区域周围绘制矩形'
- en: '6'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: 'rect(x3,y3,x4,y4) # draw rectangle around the inset'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect(x3,y3,x4,y4) # 在嵌入区域周围绘制矩形'
- en: '7'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: get vectors of coordinates of previously plotted points
  id: totrans-1527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取先前绘制点的坐标向量
- en: '8'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: savex <- savexy$x
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: savex <- savexy$x
- en: '9'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: savey <- savexy$y
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: savey <- savexy$y
- en: '10'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: get subscripts of xi our range to be magnified
  id: totrans-1533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取要放大的xi范围的子索引
- en: '11'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: n <- length(savex)
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(savex)
- en: '12'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: xvalsinrange <- which(savex >= x1 & savex <= x2)
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: xvalsinrange <- which(savex >= x1 & savex <= x2)
- en: '13'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: yvalsforthosex <- savey[xvalsinrange]
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: yvalsforthosex <- savey[xvalsinrange]
- en: '14'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: check that our first box contains the entire curve for that X range 15
  id: totrans-1541
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查我们的第一个框是否包含该X范围的整个曲线 15
- en: if (any(yvalsforthosex < y1 | yvalsforthosex > y2)) {
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: if (any(yvalsforthosex < y1 | yvalsforthosex > y2)) {
- en: '16'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: print("Y value outside first box")
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: print("Y value outside first box")
- en: '17'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: return()
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: return()
- en: '18'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: '}'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '19'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: record some differences
  id: totrans-1550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录一些差异
- en: '20'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: x2mnsx1 <- x2 - x1
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: x2mnsx1 <- x2 - x1
- en: '21'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: x4mnsx3 <- x4 - x3
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: x4mnsx3 <- x4 - x3
- en: '22'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: y2mnsy1 <- y2 - y1
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: y2mnsy1 <- y2 - y1
- en: '23'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: y4mnsy3 <- y4 - y3
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: y4mnsy3 <- y4 - y3
- en: '24'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: for the ith point in the original curve, the function plotpt() will 25
  id: totrans-1560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于原始曲线的第i个点，函数plotpt()将 25
- en: calculate the position of this point in the inset curve
  id: totrans-1561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算此点在嵌入曲线中的位置
- en: '26'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: '26'
- en: plotpt <- function(i) {
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: plotpt <- function(i) {
- en: '27'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: '27'
- en: newx <- x3 + ((savex[i] - x1)/x2mnsx1) * x4mnsx3
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: newx <- x3 + ((savex[i] - x1)/x2mnsx1) * x4mnsx3
- en: '28'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: '28'
- en: newy <- y3 + ((savey[i] - y1)/y2mnsy1) * y4mnsy3
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: newy <- y3 + ((savey[i] - y1)/y2mnsy1) * y4mnsy3
- en: '29'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '29'
- en: return(c(newx,newy))
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: return(c(newx,newy))
- en: '30'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: '}'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '31'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: '31'
- en: newxy <- sapply(xvalsinrange,plotpt)
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: newxy <- sapply(xvalsinrange,plotpt)
- en: '32'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: '32'
- en: lines(newxy[1,],newxy[2,])
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: lines(newxy[1,],newxy[2,])
- en: '33'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: '33'
- en: '}'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Let’s try it out.
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试。
- en: xyout <- crv(exp(-x)*sin(1/(x-1.5)),0.1,4,n=5001)
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: xyout <- crv(exp(-x)*sin(1/(x-1.5)),0.1,4,n=5001)
- en: inset(xyout,1.3,-0.3,1.47,0.3, 2.5,-0.3,4,-0.1)
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: inset(xyout,1.3,-0.3,1.47,0.3, 2.5,-0.3,4,-0.1)
- en: The resulting plot looks like Figure 12-12\.
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表看起来像图12-12。
- en: Graphics
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 图形
- en: '**279**'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: '**279**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 36](index-306_1.png)'
  id: totrans-1585
  prefs: []
  type: TYPE_IMG
  zh: '![图像36](index-306_1.png)'
- en: '*Figure 12-12: Adding an inset graph*'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-12：添加嵌入图表*'
- en: '**12.3 Saving Graphs to Files**'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.3 将图表保存到文件**'
- en: The R graphics display can consist of various graphics devices. The default
    device is the screen. If you want to save a graph to a file, you must set up another
    device.
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: R图形显示可以由各种图形设备组成。默认设备是屏幕。如果您想将图表保存到文件，您必须设置另一个设备。
- en: Let’s go through the basics of R graphics devices first to introduce R
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解R图形设备的基础，以介绍R
- en: graphics device concepts, and then discuss a second approach that is much more
    direct and convenient.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 图形设备概念，然后讨论第二种更直接、更方便的方法。
- en: '***12.3.1 R Graphics Devices***'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.3.1 R图形设备***'
- en: 'Let’s open a file:'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个文件：
- en: pdf("d12.pdf")
  id: totrans-1593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pdf("d12.pdf")
- en: 'This opens the file *d12.pdf*. We now have two devices open, as we can confirm:'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 这打开了文件*d12.pdf*。我们现在有两个设备打开，正如我们可以确认的那样：
- en: dev.list()
  id: totrans-1595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dev.list()
- en: X11 pdf
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: X11 pdf
- en: '2'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '**280**'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: '**280**'
- en: Chapter 12
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 第12章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'The screen is named X11 when R runs on Linux. (It’s named windows on Windows
    systems.) It is device number 2 here. Our PDF file is device number 3\. Our active
    device is the PDF file:'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 当R在Linux上运行时，屏幕被命名为X11。（在Windows系统上被命名为windows。）在这里，它是设备号2。我们的PDF文件是设备号3。我们的活动设备是PDF文件：
- en: dev.cur()
  id: totrans-1603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dev.cur()
- en: pdf
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: pdf
- en: '3'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: All graphics output will now go to this file instead of to the screen. But what
    if we wish to save what’s already on the screen?
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 所有图形输出现在将发送到这个文件而不是屏幕。但如果我们希望保存屏幕上已有的内容呢？
- en: '***12.3.2 Saving the Displayed Graph***'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.3.2 保存显示的图形***'
- en: 'One way to save the graph currently displayed on the screen is to reestablish
    the screen as the current device and then copy it to the PDF device, which is
    3 in our example, as follows:'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 保存当前屏幕上显示的图形的一种方法是将屏幕重新设置为当前设备，然后将其复制到PDF设备，在我们的例子中是3，如下所示：
- en: dev.set(2)
  id: totrans-1609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dev.set(2)
- en: X11
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: X11
- en: '2'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: dev.copy(which=3)
  id: totrans-1612
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dev.copy(which=3)
- en: pdf
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: pdf
- en: '3'
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: But actually, it is best to set up a PDF device as shown earlier and then rerun
    whatever analyses led to the current screen. This is because the copy operation
    can result in distortions due to mismatches between screen devices and file devices.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，最好像前面所示设置一个PDF设备，然后重新运行导致当前屏幕的任何分析。这是因为复制操作可能会由于屏幕设备和文件设备之间的不匹配而产生扭曲。
- en: '***12.3.3 Closing an R Graphics Device***'
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.3.3 关闭R图形设备***'
- en: 'Note that the PDF file we create is not usable until we close it, which we
    do as follows:'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们创建的PDF文件在关闭之前是不可用的，我们按照以下方式关闭：
- en: dev.set(3)
  id: totrans-1618
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dev.set(3)
- en: pdf
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: pdf
- en: '3'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: dev.off()
  id: totrans-1621
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dev.off()
- en: X11
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: X11
- en: '2'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: You can also close the device by exiting R, if you’re finished working with
    it. But in future versions of R, this behavior may not exist, so it’s probably
    better to proactively close.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完成与R的工作，你也可以通过退出R来关闭设备。但在R的未来版本中，这种行为可能不存在，所以最好是主动关闭。
- en: Graphics
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 图形
- en: '**281**'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: '**281**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 37](index-308_1.jpg)'
  id: totrans-1628
  prefs: []
  type: TYPE_IMG
  zh: '![图像37](index-308_1.jpg)'
- en: '**12.4 Creating Three-Dimensional Plots**'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.4 创建三维图形**'
- en: R offers a number of functions to plot data in three dimensions such as persp()
    and wireframe(), which draw surfaces, and cloud(), which draws three-dimensional
    scatter plots. Here, we’ll look at a simple example that uses wireframe().
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: R提供了一些函数来绘制三维数据，如persp()和wireframe()，它们绘制表面，以及cloud()，它绘制三维散点图。在这里，我们将查看一个使用wireframe()的简单示例。
- en: library(lattice)
  id: totrans-1631
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: library(lattice)
- en: a <- 1:10
  id: totrans-1632
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a <- 1:10
- en: b <- 1:15
  id: totrans-1633
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b <- 1:15
- en: eg <- expand.grid(x=a,y=b)
  id: totrans-1634
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: eg <- expand.grid(x=a,y=b)
- en: eg$z <- eg$x^2 + eg$x * eg$y
  id: totrans-1635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: eg$z <- eg$x^2 + eg$x * eg$y
- en: wireframe(z ~ x+y, eg)
  id: totrans-1636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: wireframe(z ~ x+y, eg)
- en: First, we load the lattice library. Then the call to expand.grid() creates a
    data frame, consisting of two columns named x and y, in all possible combinations
    of the values of the two inputs. Here, a and b had 10 and 15 values, respectively,
    so the resulting data frame will have 150 rows. (Note that the data frame that
    is input to wireframe() does not need to be created by expand.grid().)
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载了lattice库。然后，调用expand.grid()创建了一个数据框，包含名为x和y的两列，包含两个输入值的所有可能组合。在这里，a和b分别有10和15个值，所以结果数据框将有150行。（注意，输入wireframe()的数据框不需要由expand.grid()创建。）
- en: We then added a third column, named z, as a function of the first two columns.
    Our call to wireframe() creates the graph. The arguments, given in regression
    model form, specify that z is to be graphed against x and y. Of course, z, x,
    and y refer to names of columns in eg. The result is shown in Figure 12-13\.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后添加了第三列，命名为z，作为前两列的函数。我们的wireframe()调用创建了图形。以回归模型形式给出的参数指定z要相对于x和y进行绘图。当然，z、x和y指的是eg中的列名。结果如图12-13所示。
- en: '*Figure 12-13: Example of using* wireframe()'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-13：使用wireframe()的示例*'
- en: '**282**'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: '**282**'
- en: Chapter 12
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 第12章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: All the points are connected as a surface (like connecting points by lines in
    two dimensions). In contrast, with cloud(), the points are isolated.
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 所有点都连接成一个表面（就像在二维中通过线连接点一样）。相比之下，使用cloud()时，点则是孤立的。
- en: For wireframe(), the ( *x*, *y*) pairs must form a rectangular grid, though
    not necessarily be evenly spaced.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 对于wireframe()，(*x*, *y*)对必须形成一个矩形网格，尽管不一定均匀分布。
- en: The three-dimensional plotting functions have many different options.
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 三维绘图函数有许多不同的选项。
- en: For instance, a nice one for wireframe() is shade=T, which makes the data easier
    to see. Many functions, some with elaborate options, and whole new graphics packages
    work at a higher (read “more convenient and powerful”) level of abstraction than
    R’s base graphics package. For more information, refer to the books cited in footnote
    1 at the beginning of this chapter.
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于 wireframe() 函数，一个不错的选项是 shade=T，这使得数据更容易看到。许多函数，一些具有详细选项，以及全新的图形包，在比 R
    的基础图形包更高的（即“更方便、更强大”）抽象级别上工作。有关更多信息，请参阅本章开头脚注 1 中引用的书籍。
- en: Graphics
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 图形
- en: '**283**'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: '**283**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 38](index-311_1.png)'
  id: totrans-1651
  prefs: []
  type: TYPE_IMG
  zh: '![Image 38](index-311_1.png)'
- en: '**13**'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: '**13**'
- en: '**DEBUGGING**'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: '**DEBUGGING**'
- en: Programmers often find that they spend
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常发现，他们花在调试程序上的时间
- en: more time debugging a program than
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 调试程序比
- en: actually writing it. Good debugging skills
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 实际编写它。良好的调试技能
- en: are invaluable. In this chapter, we’ll discuss
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 是无价的。在本章中，我们将讨论
- en: debugging in R.
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的调试。
- en: '**13.1 Fundamental Principles of Debugging**'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.1 调试的基本原则**'
- en: Beware of bugs in the above code; I have only proved it correct,
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 谨防上述代码中的错误；我仅证明它是正确的，
- en: not tried it.
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 尚未尝试。
- en: —Donald Knuth, pioneer of computer science
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: ——计算机科学先驱唐纳德·克努特
- en: Though debugging is an art rather than a science, it involves some fundamental
    principles. Here, we’ll look at some debugging best practices.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然调试是一种艺术而不是科学，但它涉及一些基本原理。在这里，我们将探讨一些调试的最佳实践。
- en: '***13.1.1 The Essence of Debugging: The Principle of Confirmation***'
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: '***13.1.1 调试的本质：确认原则***'
- en: As Pete Salzman and I said in our book on debugging, *The Art of Debugging,*
    *with GDB, DDD, and Eclipse* (No Starch Press, 2008), the principle of confirmation
    is the essence of debugging.
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 正如皮特·萨尔茨曼和我在我们关于调试的书中所说，*《调试的艺术：使用 GDB、DDD 和 Eclipse》*（No Starch Press，2008年），确认原则是调试的本质。
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Fixing a buggy program is a process of confirming, one by one, that the many
    things you *believe* to be true about the code actually *are* true. When you find
    that one of your assumptions is *not* true, you have found a clue to the location
    (if not the exact nature) of
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 修复有缺陷的程序是一个逐一确认的过程，即确认你关于代码的许多你认为正确的事情实际上确实是正确的。当你发现你的某个假设不正确时，你就找到了关于错误位置（如果不是错误的本质）的线索。
- en: a bug.
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: 一个错误。
- en: 'Another way of saying this is, “Surprises are good!” For example, say you have
    the following code:'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以说成，“惊喜是好的！”例如，假设你有以下代码：
- en: x <- y^2 + 3*g(z,2)
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: x <- y^2 + 3*g(z,2)
- en: w <- 28
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: w <- 28
- en: if (w+q > 0) u <- 1 else v <- 10
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: if (w+q > 0) u <- 1 else v <- 10
- en: Do you think the value of your variable x should be 3 after x is assigned?
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为变量 x 被赋值后其值应该是 3 吗？
- en: Confirm it! Do you think the else will be executed, not the if on that third
    line? Confirm it!
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 确认它！你认为第三行的 else 会执行，而不是 if 吗？确认它！
- en: Eventually, one of these assertions that you are so sure of will turn out to
    not confirm. Then you will have pinpointed the likely location of the error, thus
    enabling you to focus on the nature of the error.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你如此确信的这些断言中之一将证明是错误的。然后你将确定错误的可能位置，从而让你能够专注于错误的本质。
- en: '***13.1.2 Start Small***'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: '***13.1.2 从小开始***'
- en: At least at the beginning of the debugging process, stick to small, simple test
    cases. Working with large data objects may make it harder to think about the problem.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 至少在调试过程的开始阶段，坚持使用小而简单的测试用例。处理大型数据对象可能会使思考问题变得更难。
- en: Of course, you should eventually test your code on large, complicated cases,
    but start small.
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你最终应该在大型、复杂的案例上测试你的代码，但要从小开始。
- en: '***13.1.3 Debug in a Modular, Top-Down Manner***'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: '***13.1.3 以模块化、自顶向下的方式调试***'
- en: Most good software developers agree that code should be written in a modular
    manner. Your first-level code should not be longer than, say, a dozen lines, with
    much of it consisting of function calls. And those functions should not be too
    lengthy and should call other functions if necessary. This makes the code easier
    to organize during the writing stage and easier for others to understand when
    it comes time for the code to be extended.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数优秀的软件开发者都认为代码应该以模块化的方式编写。你的第一级代码不应超过，比如说，十几行，其中大部分是函数调用。而且这些函数不应太长，如果需要，应该调用其他函数。这使得在编写阶段更容易组织代码，在代码需要扩展时也更容易被他人理解。
- en: 'You should debug in a top-down manner, too. Suppose that you have set the debug
    status of your function f() (that is, you have called debug(f), to be explained
    shortly) and f() contains this line:'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 你也应该以自顶向下的方式进行调试。假设你已经设置了函数 f() 的调试状态（即，你已经调用了 debug(f)，稍后将会解释），并且 f() 包含以下这行代码：
- en: y <- g(x,8)
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: y <- g(x,8)
- en: You should take an “innocent until proven guilty” approach to g(). Do *not*
    call debug(g) yet. Execute that line and see if g() returns the value you expect.
    If it does, then you’ve just avoided the time-consuming process of single-stepping
    through g(). If g() returns the wrong value, then now is the time to call debug(g).
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该对 g() 采用“无罪推定”的方法。**不要**立即调用 debug(g)。执行该行并查看 g() 是否返回你期望的值。如果它确实返回了，那么你刚刚避免了单步调试
    g() 的耗时过程。如果 g() 返回了错误的值，那么现在是调用 debug(g) 的时候了。
- en: '**286**'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: '**286**'
- en: Chapter 13
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***13.1.4 Antibugging***'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: '***13.1.4 抗错误调试***'
- en: 'You may adopt some “antibugging” strategies as well. Suppose you have a section
    of code in which a variable x should be positive. You could insert this line:'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以采用一些“抗错误”策略。假设你有一段代码，其中变量 x 应该是正数。你可以插入以下这行代码：
- en: stopifnot(x > 0)
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: stopifnot(x > 0)
- en: 'If there is a bug earlier in the code that renders x equal to, say, *−* 12,
    the call to stopifnot() will bring things to a halt right there, with an error
    message like this:'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码中较早的地方有一个错误，使得 x 等于，比如说，*−* 12，那么 stopifnot() 的调用将立即停止，并显示如下错误信息：
- en: 'Error: x > 0 is not TRUE'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：x > 0 不为真
- en: (C programmers may notice the similarity to C’s assert statement.)
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: （C 程序员可能会注意到这与 C 的 assert 语句的相似性。）
- en: After fixing a bug and testing the new code, you might want to keep that code
    handy so you can check later that the bug did not somehow reappear.
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 修复错误并测试新代码后，你可能想保留这段代码，以便稍后检查错误是否以某种方式再次出现。
- en: '**13.2 Why Use a Debugging Tool?**'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.2 为什么使用调试工具？**'
- en: 'In the old days, programmers would perform the debugging confirmation process
    by temporarily inserting print statements into their code and rerunning the program
    to see what printed out. For example, to confirm that x = 3 in our previous code,
    we would insert into our code a statement that printed the value of x and do something
    similar for the if-else, like this: x <- y^2 + 3*g(z,2)'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，程序员会通过临时在代码中插入打印语句并重新运行程序来执行调试确认过程，以查看打印了什么。例如，为了确认我们之前代码中的 x = 3，我们会在代码中插入一个打印
    x 值的语句，并对 if-else 做类似处理，如下所示：x <- y^2 + 3*g(z,2)
- en: cat("x =",x,"\n")
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: cat("x =",x,"\n")
- en: w <- 28
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: w <- 28
- en: if (w+q > 0) {
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: if (w+q > 0) {
- en: u <- 1
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: u <- 1
- en: print("the 'if' was done")
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: print("the 'if' was done")
- en: '} else {'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: v <- 10
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: v <- 10
- en: print("the 'else' was done")
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: print("the 'else' was done")
- en: '}'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: We would rerun the program and inspect the feedback printed out. We would then
    remove the print statements and put in new ones to track down the next bug.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会重新运行程序并检查打印出的反馈。然后我们会移除打印语句并插入新的语句以追踪下一个错误。
- en: This manual process is fine for one or two cycles, but it gets really tedious
    during a long debugging session. And worse, all that editing work distracts your
    attention, making it harder to concentrate on finding the bug.
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 这种手动过程对于一两个循环来说是可以的，但在长时间的调试会话中会变得非常繁琐。更糟糕的是，所有这些编辑工作都会分散你的注意力，使你更难集中精力寻找错误。
- en: Debugging
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 调试
- en: '**287**'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: '**287**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: So, debugging by inserting print statements into your code is slow, cum-bersome,
    and distracting. If you are serious about programming in any particular language,
    you should seek a good debugging tool for that language.
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过在代码中插入打印语句进行调试是缓慢的、繁琐的，并且会分散注意力。如果你对任何特定的编程语言认真负责，你应该寻找该语言的优秀调试工具。
- en: Using a debugging tool will make it much easier to query the values of variables,
    check whether the if or the else gets executed, and so on. Moreover, if your bug
    causes an execution error, debugging tools can analyze it for you, possibly providing
    major clues as to the source of the error. All of this will increase your productivity
    substantially.
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试工具将使查询变量值、检查是否执行了 if 或 else 等操作变得容易得多。此外，如果你的错误导致执行错误，调试工具可以为你分析它，可能提供关于错误来源的重要线索。所有这些都将大大提高你的生产力。
- en: '**13.3 Using R Debugging Facilities**'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.3 使用 R 调试工具**'
- en: The R base package includes a number of debugging facilities, and more functional
    debugging packages are also available. We’ll discuss both the base facilities
    and other packages, and our extended example will present a fully detailed debugging
    session.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: R 的基础包包含了一些调试功能，还有更多功能性的调试包也可用。我们将讨论基础功能和其它包，我们的扩展示例将展示一个完整的调试会话。
- en: '***13.3.1 Single-Stepping with the debug() and browser() Functions***'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: '***13.3.1 使用 debug() 和 browser() 函数进行单步执行***'
- en: The core of R’s debugging facility consists of the *browser*. It allows you
    to single-step through your code, line by line, taking a look around as you go.
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: R 的调试功能的核心是 *browser*。它允许你逐行单步执行你的代码，同时可以随时查看代码。
- en: You can invoke the browser through a call to either the debug() or browser()
    function.
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用 debug() 或 browser() 函数来调用浏览器。
- en: R’s debugging facility is specific to individual functions. If you believe there
    is a bug in your function f(), you can make the call debug(f) to set the debug
    status for the function f(). This means that from that point onward, each time
    you call the function, you will automatically enter the browser at the beginning
    of the function. Calling undebug(f) will unset the debug status of the function
    so that entry to the function will no longer invoke the browser.
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: R 的调试功能是针对单个函数的。如果你认为你的函数 f() 中存在错误，你可以通过调用 debug(f) 来设置函数 f() 的调试状态。这意味着从那时起，每次调用该函数时，你将自动进入函数的开始处的浏览器。调用
    undebug(f) 将取消函数的调试状态，这样进入函数将不再调用浏览器。
- en: On the other hand, if you place a call to browser() at some line within f(),
    the browser will be invoked only when execution reaches that line. You then can
    single-step through your code until you exit the function. If you believe the
    bug’s location is not near the beginning of the function, you probably don’t want
    to be single-stepping from the beginning, so this approach is more direct.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你在 f() 函数中的某行放置了对 browser() 的调用，浏览器只有在执行到达该行时才会被调用。然后你可以单步执行你的代码，直到退出函数。如果你认为错误的位置不在函数的开始附近，你可能不想从开始处单步执行，因此这种方法更为直接。
- en: Readers who have used C debuggers such as GDB (the GNU debugger)
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 使用过 C 调试器（如 GDB，GNU 调试器）的读者
- en: will find similarity here, but some aspects will come as a surprise. As noted,
    for instance, debug() is called on the function level, not on the overall program
    level. If you believe you have bugs in several of your functions, you’ll need
    to call debug() on each one.
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你会找到相似之处，但也有一些方面可能会让你感到惊讶。例如，正如所注，debug() 是在函数级别上调用，而不是在整体程序级别上。如果你认为你的几个函数中存在错误，你需要对每个函数都调用
    debug()。
- en: It can become tedious to call debug(f) and then undebug(f) when you just want
    to go through one debugging session for f(). Starting with R 2.10, one can now
    call debugonce() instead; calling debugonce(f) puts f() into debugging status
    the first time you execute it, but that status is reversed immediately upon exit
    from the function.
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只想为 f() 函数进行一次调试会话时，调用 debug(f) 然后undebug(f) 可能会变得繁琐。从 R 2.10 版本开始，现在可以调用
    debugonce()；调用 debugonce(f) 将 f() 函数置于调试状态，首次执行时，但该状态会在退出函数后立即反转。
- en: '**288**'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: '**288**'
- en: Chapter 13
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***13.3.2 Using Browser Commands***'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: '***13.3.2 使用浏览器命令***'
- en: While you are in the browser, the prompt changes from *>* to Browse[d] *>* .
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中时，提示符会从 *>* 变为 Browse[d] *>* 。
- en: '(Here, d is the depth of the call chain.) You may submit any of the following
    commands at that prompt:'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: (在此，d 表示调用链的深度。)你可以在该提示符下提交以下任何命令：
- en: •
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'n (for *next*): Tells R to execute the next line and then pause again. Hitting
    ENTER causes this action, too.'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: n（对于 *next*）：告诉 R 执行下一行，然后再次暂停。按回车键也会执行此操作。
- en: •
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'c (for *continue*): This is like n, except that several lines of code may be
    executed before the next pause. If you are currently in a loop, this command will
    result in the remainder of the loop being executed and then pausing upon exit
    from the loop. If you are in a function but not in a loop, the remainder of the
    function will be executed before the next pause.'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: c（对于 *continue*）：这与 n 类似，但可能在下一次暂停之前执行多行代码。如果你当前在一个循环中，此命令将导致循环的其余部分被执行，然后从循环退出时暂停。如果你在一个函数中但不在循环中，函数的其余部分将在下一次暂停之前被执行。
- en: •
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'Any R command: While in the browser, you are still in R’s interactive mode
    and thus can query the value of, say, x by simply typing x. Of course, if you
    have a variable with the same name as a browser command, you must explicitly call
    something like print(), as in print(n).'
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 任何R命令：在浏览器中，您仍然处于R的交互模式，因此可以通过简单地输入x来查询变量的值。当然，如果您有一个与浏览器命令同名变量，您必须显式调用类似print()的东西，例如print(n)。
- en: •
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'where: This prints a *stack trace*. It displays what sequence of function calls
    led execution to the current location.'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：这将打印一个*堆栈跟踪*。它显示了导致执行到达当前位置的函数调用序列。
- en: •
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'Q: This quits the browser, bringing you back to R’s main interactive mode.'
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 'Q: 这将退出浏览器，带您回到R的主交互模式。'
- en: '***13.3.3 Setting Breakpoints***'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: '***13.3.3 设置断点***'
- en: Calling debug(f) places a call to browser() at the beginning of f(). However,
    this may be too coarse a tool in some cases. If you suspect that the bug is in
    the middle of the function, it’s wasteful to trudge through all the intervening
    code.
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 调用debug(f)将在f()的开始处放置一个browser()调用。然而，在某些情况下，这可能是一个过于粗糙的工具。如果您怀疑错误在函数的中间，逐行遍历所有中间代码是浪费时间的。
- en: The solution is to set *breakpoints* at certain key locations of your code—
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在代码的某些关键位置设置*断点*—
- en: places where you want execution to be paused. How can this be done in R?
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要执行暂停的地方。在R中如何做到这一点？
- en: You can call browser directly or use the setBreakpoint() function (with R version
    2.10 and later).
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接调用browser或使用setBreakpoint()函数（R版本2.10及以后）。
- en: '**13.3.3.1 Calling browser() Directly**'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.3.3.1 直接调用browser()**'
- en: You can set a breakpoint by simply inserting calls to browser() at the places
    of interest in your code. This has the effect, essentially, of setting breakpoints
    there.
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在代码中感兴趣的地方插入browser()调用来设置断点。这基本上具有设置断点的效果。
- en: 'You can make invoking the browser conditional so that it is entered only in
    specified situations. Use the expr argument to define those situations. For instance,
    suppose you suspect that your bug arises only when a certain variable s is larger
    than 1\. You could use this code:'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将调用浏览器的条件设置为仅在指定情况下执行。使用expr参数来定义这些情况。例如，假设您怀疑您的错误仅在某个变量s大于1时出现。您可以使用以下代码：
- en: browser(s > 1)
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: browser(s > 1)
- en: Debugging
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 调试
- en: '**289**'
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: '**289**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'The browser will be invoked only if s is larger than 1\. The following would
    have the same effect:'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当s大于1时，浏览器才会被调用。以下会有相同的效果：
- en: if (s > 1) browser()
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: if (s > 1) browser()
- en: 'Calling the browser directly, rather than entering the debugger via debug()
    is very useful in situations in which you have a loop with many iterations and
    the bug surfaces only after, say, the 50th iteration. If the loop index is i,
    then you could write this:'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: 直接调用browser，而不是通过debug()进入调试器，在您有一个许多迭代的循环并且错误仅在，比如说，第50次迭代后出现的情况下非常有用。如果循环索引是i，那么您可以编写以下内容：
- en: if (i > 49) browser()
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: if (i > 49) browser()
- en: That way, you would avoid the tedium of stepping through the first 49
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您就可以避免逐行执行前49次迭代的无聊。
- en: iterations!
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代！
- en: '**13.3.3.2 Using the setBreakpoint() Function**'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.3.3.2 使用setBreakpoint()函数**'
- en: Starting with R 2.10, you can use setBreakpoint() in the format
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 从R 2.10版本开始，您可以使用setBreakpoint()格式
- en: setBreakpoint( *filename,linenumber*)
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: setBreakpoint( *filename,linenumber*)
- en: This will result in browser() being called at line *linenumber* of our source
    file *filename*.
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的源文件*filename*的第*linenumber*行调用browser()。
- en: 'This is especially useful when you are in the midst of using the debugger,
    single-stepping through code. Say you are currently at line 12 of your source
    file *x.R* and want to have a breakpoint at line 28\. Instead of exiting the debugger,
    adding a call to browser() at line 28, and then re-entering the function, you
    could simply type this:'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 这在您正在使用调试器，逐行单步执行代码时特别有用。比如说，您目前位于源文件*x.R*的第12行，并想在第28行设置一个断点。您不必退出调试器，在第28行添加对browser()的调用，然后重新进入函数，您只需简单地输入以下内容：
- en: setBreakpoint("x.R",28)
  id: totrans-1761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: setBreakpoint("x.R",28)
- en: You could then resume execution within the debugger, say by issuing the c command.
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在调试器中继续执行，例如通过发出c命令。
- en: 'The setBreakpoint() function works by calling the trace() function, discussed
    in the next section. Thus, to cancel the breakpoint, you cancel the trace. For
    instance, if we had called setBreakpoint() at a line in the function g(), we would
    cancel the breakpoint by typing the following:'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: setBreakpoint() 函数通过调用下一节中讨论的 trace() 函数来工作。因此，要取消断点，您需要取消跟踪。例如，如果我们曾在函数 g()
    的某一行调用 setBreakpoint()，我们可以通过输入以下内容来取消断点：
- en: untrace(g)
  id: totrans-1764
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: untrace(g)
- en: You can call setBreakpoint() whether or not you are currently in the debugger.
    If you are not currently running the debugger and you execute the affected function
    and hit the breakpoint during that execution, you will be put into the browser
    automatically. This is similar to the case of browser(), but using this approach,
    you save yourself the trouble of changing your code via your text editor.
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在是否在调试器中时调用 setBreakpoint()。如果您当前没有运行调试器，并且执行受影响的函数并在执行过程中遇到断点，您将自动进入浏览器。这与
    browser() 的情况类似，但使用这种方法，您可以省去通过文本编辑器更改代码的麻烦。
- en: '**290**'
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: '**290**'
- en: Chapter 13
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***13.3.4 Tracking with the trace() Function***'
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: '***13.3.4 使用 trace() 函数进行跟踪***'
- en: 'The trace() function is flexible and powerful, though it takes some initial
    effort to learn. We will discuss some of the simpler usage forms here, beginning
    with the following:'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: trace() 函数灵活且功能强大，尽管学习它需要一些初始努力。我们将在以下内容中讨论一些简单的用法形式，从以下内容开始：
- en: trace(f,t)
  id: totrans-1771
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: trace(f,t)
- en: 'This call instructs R to call the function t() every time we enter the function
    f(). For instance, say we wish to set a breakpoint at the beginning of the function
    gy(). We could use this command:'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用指示 R 在每次进入函数 f() 时调用函数 t()。例如，如果我们希望在函数 gy() 的开始处设置断点，我们可以使用以下命令：
- en: trace(gy,browser)
  id: totrans-1773
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: trace(gy,browser)
- en: 'This has the same effect as placing the command browser() in our source code
    for gy(), but it’s quicker and more convenient than inserting such a line, saving
    the file, and rerunning source() to load in the new version of the file. Calling
    trace() does *not* change your source file, though it does change a temporary
    version of your file maintained by R. It would also be quicker and more convenient
    to undo, by simply running untrace:'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在 gy() 的源代码中放置命令 browser() 有相同的效果，但它比插入这样的行、保存文件和重新运行 source() 来加载新版本的文件更快、更方便。调用
    trace() 不会更改您的源文件，尽管它会更改 R 维护的临时文件版本。通过简单地运行 untrace，也可以更快、更方便地撤销操作。
- en: untrace(gy)
  id: totrans-1775
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: untrace(gy)
- en: You can turn tracing on or off globally by calling tracingState(), using the
    argument TRUE to turn it on or FALSE to turn it off.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用 tracingState() 来全局开启或关闭跟踪，使用参数 TRUE 开启，FALSE 关闭。
- en: '***13.3.5 Performing Checks After a Crash with the traceback() and***'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: '***13.3.5 使用 traceback() 和...在崩溃后执行检查***'
- en: '***debugger() Functions***'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: '***调试器() 函数***'
- en: Say your R code crashes when you are not running the debugger. There is still
    a debugging tool available to you after the fact. You can do a “post-mortem” by
    simply calling traceback(). It will tell you in which function the problem occurred
    and the call chain that led to that function.
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的 R 代码在没有运行调试器的情况下崩溃。在事后，您仍然可以使用调试工具。您可以通过简单地调用 traceback() 来进行“尸检”。它将告诉您问题发生在哪个函数中，以及导致该函数的调用链。
- en: 'You can get a lot more information if you set up R to dump frames in the event
    of a crash:'
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您设置 R 在崩溃时转储框架，您可以获得更多信息：
- en: options(error=dump.frames)
  id: totrans-1781
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: options(error=dump.frames)
- en: 'If you’ve done this, then after a crash, run this command:'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经这样做，那么在崩溃后，运行以下命令：
- en: debugger()
  id: totrans-1783
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: debugger()
- en: You will then be presented with a choice of levels of function calls to view.
    For each one that you choose, you can take a look at the values of the variables
    there. After browsing through one level, you can return to the debugger() main
    menu by hitting N.
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到可以选择查看函数调用级别的选项。对于您选择的每个级别，您都可以查看那里的变量值。浏览完一个级别后，您可以通过按 N 键返回到 debugger()
    主菜单。
- en: Debugging
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 调试
- en: '**291**'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: '**291**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'You can arrange to automatically enter the debugger by writing this code:'
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过编写以下代码来安排自动进入调试器：
- en: options(error=recover)
  id: totrans-1789
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: options(error=recover)
- en: Note, though, that if you do choose this automatic route, it will whisk you
    into the debugger, even if you simply have a syntax error (not a useful time to
    enter the debugger).
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管如此，如果您选择这条自动路径，它将带您进入调试器，即使您只是有一个语法错误（这不是进入调试器的好时机）。
- en: 'To turn off any of this behavior, type the following:'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭任何这种行为，请输入以下内容：
- en: options(error=NULL)
  id: totrans-1792
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: options(error=NULL)
- en: You’ll see a demonstration of this approach in the next section.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一节中看到这种方法的演示。
- en: '***13.3.6 Extended Example: Two Full Debugging Sessions***'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: '***13.3.6 扩展示例：两个完整的调试会话***'
- en: Now that we’ve looked at R’s debugging tools, let’s try using them to find and
    fix code problems. We’ll begin with a simple example and then move on to a more
    complicated one.
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了R的调试工具，让我们尝试使用它们来查找和修复代码问题。我们将从一个简单的例子开始，然后过渡到一个更复杂的例子。
- en: '**13.3.6.1 Debugging Finding Runs of Ones**'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.3.6.1 调试：寻找连续1的序列**'
- en: 'First recall our extended example of finding runs of 1s in Chapter 2\. Here
    is a buggy version of the code:'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，回忆一下我们在第2章中扩展的寻找连续1的序列的例子。以下是代码的一个有缺陷版本：
- en: '1'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: findruns <- function(x,k) {
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: findruns <- function(x,k) {
- en: '2'
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: n <- length(x)
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(x)
- en: '3'
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: runs <- NULL
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: runs <- NULL
- en: '4'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: for (i in 1:(n-k)) {
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:(n-k)) {
- en: '5'
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: if (all(x[i:i+k-1]==1)) runs <- c(runs,i)
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: if (all(x[i:i+k-1]==1)) runs <- c(runs,i)
- en: '6'
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '}'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '7'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: return(runs)
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: return(runs)
- en: '8'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '}'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Let’s try it on a small test case:'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个小测试用例上试一试：
- en: source("findruns.R")
  id: totrans-1815
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: source("findruns.R")
- en: findruns(c(1,0,0,1,1,0,1,1,1),2)
  id: totrans-1816
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: findruns(c(1,0,0,1,1,0,1,1,1),2)
- en: '[1] 3 4 6 7'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 3 4 6 7'
- en: The function was supposed to report runs at indices 4, 7, and 8, but it found
    some indices that it shouldn’t have and missed some as well. Something is wrong.
    Let’s enter the debugger and take a look around.
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: 函数本应报告索引为4、7和8的序列，但它找到了一些不应该找到的索引，也遗漏了一些。有些地方出错了。让我们进入调试器并四处看看。
- en: debug(findruns)
  id: totrans-1819
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: debug(findruns)
- en: findruns(c(1,0,0,1,1,0,1,1,1),2)
  id: totrans-1820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: findruns(c(1,0,0,1,1,0,1,1,1),2)
- en: 'debugging in: findruns(c(1, 0, 0, 1, 1, 0, 1, 1, 1), 2)'
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: 'debugging in: findruns(c(1, 0, 0, 1, 1, 0, 1, 1, 1), 2)'
- en: 'debug at findruns.R#1: {'
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at findruns.R#1: {'
- en: '**292**'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: '**292**'
- en: Chapter 13
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: 第13章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: n <- length(x)
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(x)
- en: runs <- NULL
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: runs <- NULL
- en: for (i in 1:(n - k)) {
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:(n - k)) {
- en: if (all(x[i:i + k - 1] == 1))
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: if (all(x[i:i+k-1]==1))
- en: runs <- c(runs, i)
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: runs <- c(runs, i)
- en: '}'
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return(runs)
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: return(runs)
- en: '}'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: attr(,"srcfile")
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: attr(,"srcfile")
- en: findruns.R
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: findruns.R
- en: 'So, according to the principle of confirmation, let’s first make sure our test
    vector was received correctly:'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 根据确认原则，我们首先确保我们的测试向量被正确接收：
- en: Browse[2]> x
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> x
- en: '[1] 1 0 0 1 1 0 1 1 1'
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 0 0 1 1 0 1 1 1'
- en: So far, so good. Let’s step through the code a bit. We hit n a couple of times
    to single-step through the code.
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。让我们逐步执行代码，我们点击了几次n来单步执行代码。
- en: Browse[2]> n
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> n
- en: 'debug at findruns.R#2: n <- length(x)'
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at findruns.R#2: n <- length(x)'
- en: Browse[2]> n
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> n
- en: 'debug at findruns.R#3: runs <- NULL'
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at findruns.R#3: runs <- NULL'
- en: Browse[2]> print(n)
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> print(n)
- en: '[1] 9'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 9'
- en: Note that after each single step, R tells us which statement would be the *next*
    one to execute. In other words, at the time we executed print(n), we had *not*
    yet executed the assignment of NULL to runs.
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在每次单步执行后，R都会告诉我们下一个将要执行的语句。换句话说，当我们执行print(n)时，我们还没有执行将NULL赋值给runs的操作。
- en: Note, too, that although normally you can print out the value of a variable
    by simply typing its name, we could not do so here for our variable n, because
    n is also the abbreviation for the debugger’s next command. Thus, we needed print().
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管通常你可以通过简单地输入变量的名称来打印变量的值，但我们不能在这里打印变量n的值，因为n也是调试器下一个命令的缩写。因此，我们需要使用print()。
- en: At any rate, we found that the length of our test vector was 9, confirming what
    we knew. Now, let’s single-step some more, getting into the loop.
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们发现我们的测试向量的长度是9，这证实了我们所知道的情况。现在，让我们继续单步执行，进入循环。
- en: Browse[2]> n
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> n
- en: 'debug at findruns.R#4: for (i in 1:(n - k + 1)) {'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at findruns.R#4: for (i in 1:(n - k + 1)) {'
- en: if (all(x[i:i + k - 1] == 1))
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: if (all(x[i:i + k - 1] == 1))
- en: runs <- c(runs, i)
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: runs <- c(runs, i)
- en: '}'
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Browse[2]> n
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> n
- en: 'debug at findruns.R#4: i'
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at findruns.R#4: i'
- en: Browse[2]> n
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> n
- en: 'debug at findruns.R#5: if (all(x[i:i + k - 1] == 1)) runs <- c(runs, i) Debugging'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 'debug at findruns.R#5: if (all(x[i:i + k - 1] == 1)) runs <- c(runs, i) 调试'
- en: '**293**'
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: '**293**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Since k is 2—that is, we are checking for runs of length 2— the if() statement
    should be checking the first two elements of x, which are (1,0).
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: 由于k是2——也就是说，我们正在检查长度为2的序列——if()语句应该检查x的前两个元素，即(1,0)。
- en: 'Let’s confirm:'
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认一下：
- en: Browse[2]> x[i:i + k - 1]
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> x[i:i + k - 1]
- en: '[1] 0'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0'
- en: So, it did *not* confirm. Let’s check that we have the correct subscript range,
    which should be 1:2\. Is it?
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，它并没有确认。让我们检查我们是否有正确的子索引范围，应该是1:2。是吗？
- en: Browse[2]> i:i + k - 1
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: Browse[2]> i:i + k - 1
- en: '[1] 2'
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2'
- en: Also wrong. Well, how about i and k? They should be 1 and 2, respectively. Are
    they?
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然不对。嗯，关于 i 和 k，它们应该是 1 和 2，对吗？
- en: Browse[2]> i
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[2]> i
- en: '[1] 1'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1'
- en: Browse[2]> k
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[2]> k
- en: '[1] 2'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2'
- en: Well, those do confirm. Thus, our problem must be with the expression i:i +
    k - 1\. After some thought, we realize there is an operator precedence problem
    there, and we correct it to i:(i + k - 1).
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这些确实确认了。因此，我们的问题一定出在表达式 i:i + k - 1 上。经过一番思考，我们意识到这里存在一个运算符优先级问题，并将其更正为 i:(i
    + k - 1)。
- en: Is it okay now?
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以了吗？
- en: source("findruns.R")
  id: totrans-1874
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: source("findruns.R")
- en: findruns(c(1,0,0,1,1,0,1,1,1),2)
  id: totrans-1875
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: findruns(c(1,0,0,1,1,0,1,1,1),2)
- en: '[1] 4 7'
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 4 7'
- en: No, as mentioned, it should be (4,7,8).
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 不，正如提到的，应该是 (4,7,8)。
- en: Let’s set a breakpoint inside the loop and take a closer look.
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在循环内部设置一个断点并仔细查看。
- en: setBreakpoint("findruns.R",5)
  id: totrans-1879
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: setBreakpoint("findruns.R",5)
- en: '/home/nm/findruns.R#5:'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: '/home/nm/findruns.R#5:'
- en: 'findruns step 4,4,2 in <environment: R_GlobalEnv>'
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 'findruns step 4,4,2 in <环境: R_GlobalEnv>'
- en: findruns(c(1,0,0,1,1,0,1,1,1),2)
  id: totrans-1882
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: findruns(c(1,0,0,1,1,0,1,1,1),2)
- en: findruns.R#5
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: findruns.R#5
- en: 'Called from: eval(expr, envir, enclos)'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: '调用来自: eval(expr, envir, enclos)'
- en: Browse[1]> x[i:(i+k-1)]
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[1]> x[i:(i+k-1)]
- en: '[1] 1 0'
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 0'
- en: Good, we’re dealing with the first two elements of the vector, so our bug fix
    is working so far. Let’s look at the second iteration of the loop.
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在正在处理向量的前两个元素，所以我们的错误修复到目前为止是有效的。让我们看看循环的第二次迭代。
- en: Browse[1]> c
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[1]> c
- en: findruns.R#5
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: findruns.R#5
- en: 'Called from: eval(expr, envir, enclos)'
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: '调用来自: eval(expr, envir, enclos)'
- en: '**294**'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: '**294**'
- en: Chapter 13
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Browse[1]> i
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[1]> i
- en: '[1] 2'
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2'
- en: Browse[1]> x[i:(i+k-1)]
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[1]> x[i:(i+k-1)]
- en: '[1] 0 0'
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0 0'
