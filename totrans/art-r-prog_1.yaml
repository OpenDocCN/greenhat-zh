- en: '[1] 123 4 5 6'
  prefs: []
  type: TYPE_NORMAL
- en: scan("z2.txt")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Read 4 items
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 123.0 4.2 5.0 6.0'
  prefs: []
  type: TYPE_NORMAL
- en: scan("z3.txt")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Error in scan(file, what, nmax, sep, dec, quote, skip, nlines, na.strings,
    : scan() expected ''a real'', got ''abc'''
  prefs: []
  type: TYPE_NORMAL
- en: scan("z3.txt",what="")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**232**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Read 4 items
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "abc" "de" "f" "g"'
  prefs: []
  type: TYPE_NORMAL
- en: scan("z4.txt",what="")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Read 4 items
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "abc" "123" "6" "y"'
  prefs: []
  type: TYPE_NORMAL
- en: In the first call, we got a vector of four integers (though the mode is numeric).
    The second time, since one number was nonintegral, the others were shown as floating-point
    numbers, too.
  prefs: []
  type: TYPE_NORMAL
- en: In the third case, we got an error. The scan() function has an optional argument
    named what, which specifies mode, defaulting to double mode. So, the nonnumeric
    contents of the file *z3* produced an error. But we then tried again, with what="".
    This assigns a character string to what, indicating that we want character mode.
    (We could have set what to any character string.) The last call worked the same
    way. The first item was a character string, so it treated all the items that followed
    as strings too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, in typical usage, we would assign the return value of scan() to
    a variable. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: v <- scan("z1.txt")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'By default, scan() assumes that the items of the vector are separated by *whitespace*,
    which includes blanks, carriage return/line feeds, and horizontal tabs. You can
    use the optional sep argument for other situations. As example, we can set sep
    to the newline character to read in each line as a string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: x1 <- scan("z3.txt",what="")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Read 4 items
  prefs: []
  type: TYPE_NORMAL
- en: x2 <- scan("z3.txt",what="",sep="\n") Read 3 items
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: x1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "abc" "de" "f"'
  prefs: []
  type: TYPE_NORMAL
- en: '"g"'
  prefs: []
  type: TYPE_NORMAL
- en: x2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "abc" "de f" "g"'
  prefs: []
  type: TYPE_NORMAL
- en: x1[2]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "de"'
  prefs: []
  type: TYPE_NORMAL
- en: x2[2]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "de f"'
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, the strings "de" and "f" were assigned to separate elements
    of x1\. But in the second case, we specified that elements of x2 were to be delineated
    by end-of-line characters, not spaces. Since "de" and "f" are on the same line,
    they are assigned together to x[2].
  prefs: []
  type: TYPE_NORMAL
- en: More sophisticated methods for reading files will be presented later in this
    chapter, such as methods to read in a file one line at a time. But if you want
    to read the entire file at once, scan() provides a quick solution.
  prefs: []
  type: TYPE_NORMAL
- en: Input/Output
  prefs: []
  type: TYPE_NORMAL
- en: '**233**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use scan() to read from the keyboard by specifying an empty string
    for the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: v <- scan("")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '1: 12 5 13'
  prefs: []
  type: TYPE_NORMAL
- en: '4: 3 4 5'
  prefs: []
  type: TYPE_NORMAL
- en: '7: 8'
  prefs: []
  type: TYPE_NORMAL
- en: '8:'
  prefs: []
  type: TYPE_NORMAL
- en: Read 7 items
  prefs: []
  type: TYPE_NORMAL
- en: v
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 12 5 13 3 4 5 8'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are prompted with the index of the next item to be input, and we
    signal the end of input with an empty line.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not wish scan() to announce the number of items it has read, include
    the argument quiet=TRUE.
  prefs: []
  type: TYPE_NORMAL
- en: '***10.1.2 Using the readline() Function***'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to read in a single line from the keyboard, readline() is very handy.
  prefs: []
  type: TYPE_NORMAL
- en: w <- readline()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: abc de f
  prefs: []
  type: TYPE_NORMAL
- en: w
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "abc de f"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, readline() is called with its optional prompt, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'inits <- readline("type your initials: ")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'type your initials: NM'
  prefs: []
  type: TYPE_NORMAL
- en: inits
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "NM"'
  prefs: []
  type: TYPE_NORMAL
- en: '***10.1.3 Printing to the Screen***'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top level of interactive mode, you can print the value of a variable
    or expression by simply typing the variable name or expression. This won’t work
    if you need to print from within the body of a function. In that case, you can
    use the print() function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: x <- 1:3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(x^2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 4 9'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that print() is a *generic* function, so the actual function called will
    depend on the class of the object that is printed. If, for example, the argument
    is of class "table", then the print.table() function will be called.
  prefs: []
  type: TYPE_NORMAL
- en: '**234**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a little better to use cat() instead of print(), as the latter can print
    only one expression and its output is numbered, which may be a nuisance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare the results of the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: print("abc")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "abc"'
  prefs: []
  type: TYPE_NORMAL
- en: cat("abc\n")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: abc
  prefs: []
  type: TYPE_NORMAL
- en: Note that we needed to supply our own end-of-line character, "\n", in the call
    to cat(). Without it, our next call would continue to write to the same line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arguments to cat() will be printed out with intervening spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: x
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 2 3'
  prefs: []
  type: TYPE_NORMAL
- en: cat(x,"abc","de\n")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 1 2 3 abc de
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want the spaces, set sep to the empty string "", as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: cat(x,"abc","de\n",sep="")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 123abcde
  prefs: []
  type: TYPE_NORMAL
- en: 'Any string can be used for sep. Here, we use the newline character:'
  prefs: []
  type: TYPE_NORMAL
- en: cat(x,"abc","de\n",sep="\n")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: abc
  prefs: []
  type: TYPE_NORMAL
- en: de
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even set sep to be a vector of strings, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: x <- c(5,12,13,8,88)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: cat(x,sep=c(".",".",".","\n","\n")) 5.12.13.8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '88'
  prefs: []
  type: TYPE_NORMAL
- en: '**10.2 Reading and Writing Files**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the basics of I/O, let’s get to some more practical applications
    of reading and writing files. The following sections discuss reading data frames
    or matrices from files, working with text files, accessing files on remote machines,
    and getting file and directory information.
  prefs: []
  type: TYPE_NORMAL
- en: Input/Output
  prefs: []
  type: TYPE_NORMAL
- en: '**235**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***10.2.1 Reading a Data Frame or Matrix from a File***'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Section 5.1.2, we discussed the use of the function read.table() to read
    in a data frame. As a quick review, suppose the file *z* looks like this: name
    age'
  prefs: []
  type: TYPE_NORMAL
- en: John 25
  prefs: []
  type: TYPE_NORMAL
- en: Mary 28
  prefs: []
  type: TYPE_NORMAL
- en: Jim 19
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line contains an optional header, specifying column names. We could
    read the file this way:'
  prefs: []
  type: TYPE_NORMAL
- en: z <- read.table("z",header=TRUE)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: z
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: name age
  prefs: []
  type: TYPE_NORMAL
- en: 1 John 25
  prefs: []
  type: TYPE_NORMAL
- en: 2 Mary 28
  prefs: []
  type: TYPE_NORMAL
- en: 3 Jim 19
  prefs: []
  type: TYPE_NORMAL
- en: Note that scan() would not work here, because our file has a mixture of numeric
    and character data (and a header).
  prefs: []
  type: TYPE_NORMAL
- en: There appears to be no direct way of reading in a matrix from a file, but it
    can be done easily with other tools. A simple, quick way is to use scan() to read
    in the matrix row by row. You use the byrow option in the function matrix() to
    indicate that you are defining the elements of the matrix in a row-wise, rather
    than column-wise, manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, say the file *x* contains a 5-by-3 matrix, stored row-wise: 1
    0 1'
  prefs: []
  type: TYPE_NORMAL
- en: 1 1 1
  prefs: []
  type: TYPE_NORMAL
- en: 1 1 0
  prefs: []
  type: TYPE_NORMAL
- en: 1 1 0
  prefs: []
  type: TYPE_NORMAL
- en: 0 0 1
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read it into a matrix this way:'
  prefs: []
  type: TYPE_NORMAL
- en: x <- matrix(scan("x"),nrow=5,byrow=TRUE)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is fine for quick, one-time operations, but for generality, you can use
    read.table(), which returns a data frame, and then convert via as.matrix(). Here
    is a general method:'
  prefs: []
  type: TYPE_NORMAL
- en: read.matrix <- function(filename) {
  prefs: []
  type: TYPE_NORMAL
- en: as.matrix(read.table(filename))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**236**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***10.2.2 Reading Text Files***'
  prefs: []
  type: TYPE_NORMAL
- en: In computer literature, there is often a distinction made between *text files*
    and *binary files*. That distinction is somewhat misleading—every file is binary
    in the sense that it consists of 0s and 1s. Let’s take the term *text file* to
    mean a file that consists mainly of ASCII characters or coding for some other
    human language (such as GB for Chinese) and that uses newline characters to give
    humans the perception of lines. The latter aspect will turn out to be central
    here. Nontext files, such as JPEG images or executable program files, are generally
    called *binary files*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use readLines() to read in a text file, either one line at a time or
    in a single operation. For example, suppose we have a file *z1* with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: John 25
  prefs: []
  type: TYPE_NORMAL
- en: Mary 28
  prefs: []
  type: TYPE_NORMAL
- en: Jim 19
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read the file all at once, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: z1 <- readLines("z1")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: z1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "John 25" "Mary 28" "Jim 19"'
  prefs: []
  type: TYPE_NORMAL
- en: Since each line is treated as a string, the return value here is a vector of
    strings—that is, a vector of character mode. There is one vector element for each
    line read, thus three elements here.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can read it in one line at a time. For this, we first need
    to create a connection, as described next.
  prefs: []
  type: TYPE_NORMAL
- en: '***10.2.3 Introduction to Connections***'
  prefs: []
  type: TYPE_NORMAL
- en: '*Connection* is R’s term for a fundamental mechanism used in various kinds
    of I/O operations. Here, it will be used for file access.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The connection is created by calling file(), url(), or one of several other
    R functions. To see a list of those functions, type this:'
  prefs: []
  type: TYPE_NORMAL
- en: ?connection
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So, we can now read in the *z1* file (introduced in the previous section) line
    by line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: c <- file("z1","r")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: readLines(c,n=1)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "John 25"'
  prefs: []
  type: TYPE_NORMAL
- en: readLines(c,n=1)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "Mary 28"'
  prefs: []
  type: TYPE_NORMAL
- en: readLines(c,n=1)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "Jim 19"'
  prefs: []
  type: TYPE_NORMAL
- en: Input/Output
  prefs: []
  type: TYPE_NORMAL
- en: '**237**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: readLines(c,n=1)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: character(0)
  prefs: []
  type: TYPE_NORMAL
- en: We opened the connection, assigned the result to c, and then read the file one
    line at a time, as specified by the argument n=1\. When R encountered the end
    of file (EOF), it returned an empty result. We needed to set up a connection so
    that R could keep track of our position in the file as we read through it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can detect EOF in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: c <- file("z","r")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: while(TRUE) {
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: rl <- readLines(c,n=1)
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: if (length(rl) == 0) {
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: print("reached the end")
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: '} else print(rl)'
  prefs: []
  type: TYPE_NORMAL
- en: + }
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "John 25"'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "Mary 28"'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "Jim 19"'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "reached the end"'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wish to “rewind”—to start again at the beginning of the file—we can use
    seek():'
  prefs: []
  type: TYPE_NORMAL
- en: c <- file("z1","r")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: readLines(c,n=2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "John 25" "Mary 28"'
  prefs: []
  type: TYPE_NORMAL
- en: seek(con=c,where=0)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 16'
  prefs: []
  type: TYPE_NORMAL
- en: readLines(c,n=1)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "John 25"'
  prefs: []
  type: TYPE_NORMAL
- en: The argument where=0 in our call to seek() means that we wish to position the
    file pointer zero characters from the start of the file—in other words, directly
    at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: The call returns 16, meaning that the file pointer was at position 16
  prefs: []
  type: TYPE_NORMAL
- en: before we made the call. That makes sense. The first line consists of "John
    25"
  prefs: []
  type: TYPE_NORMAL
- en: '*plus* the end-of-line character, for a total of eight characters, and the
    same is true for the second line. So, after reading the first two lines, we were
    at position 16\.'
  prefs: []
  type: TYPE_NORMAL
- en: You can close a connection by calling—what else?—close(). You would use this
    to let the system know that the file you have been writing is complete and should
    now be officially written to disk. As another example, in a client/server relationship
    over the Internet (see Section 10.3.1), a client would use close() to indicate
    to the server that the client is signing off.
  prefs: []
  type: TYPE_NORMAL
- en: '**238**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***10.2.4 Extended Example: Reading PUMS Census Files***'
  prefs: []
  type: TYPE_NORMAL
- en: The U.S. Census Bureau makes census data available in the form of Public Use
    Microdata Samples (PUMS). The term *microdata* here means that we are dealing
    with raw data and each record is for a real person, as opposed to statistical
    summaries. Data on many, many variables are included.
  prefs: []
  type: TYPE_NORMAL
- en: The data is organized by household. For each unit, there is first a Household
    record, describing the various characteristics of that household, followed by
    one Person record for each person in the household. Character positions 106 and
    107 (with numbering starting at 1) in the Household record state the number of
    Person records for that household. (The number can be very large, since some institutions
    count as households.) To enhance the integrity of the data, character position
    1 contains H or P to confirm that this is a Household or Person record. So, if
    you read an H record, and it tells you there are three people in the household,
    then the following three records should be P records, followed by another H record;
    if not, you’ve encountered an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'As our test file, we’ll take the first 1,000 records of the year 2000 1 percent
    sample. The first few records look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: H000019510649
  prefs: []
  type: TYPE_NORMAL
- en: '06010'
  prefs: []
  type: TYPE_NORMAL
- en: 99979997 70
  prefs: []
  type: TYPE_NORMAL
- en: '631973'
  prefs: []
  type: TYPE_NORMAL
- en: '15758'
  prefs: []
  type: TYPE_NORMAL
- en: 59967658436650000012000000 0 0 0 0 0 0 0 0 0 0 0 0 0
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: 0 0 0
  prefs: []
  type: TYPE_NORMAL
- en: 0 0
  prefs: []
  type: TYPE_NORMAL
- en: 0 0000 0
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: 0 0 0
  prefs: []
  type: TYPE_NORMAL
- en: '00000000000000000000000000000'
  prefs: []
  type: TYPE_NORMAL
- en: '00000000000000000000000000'
  prefs: []
  type: TYPE_NORMAL
- en: P00001950100010923000420190010110000010147050600206011099999904200000 0040010000
  prefs: []
  type: TYPE_NORMAL
- en: 00300280
  prefs: []
  type: TYPE_NORMAL
- en: 28600 70
  prefs: []
  type: TYPE_NORMAL
- en: '9997'
  prefs: []
  type: TYPE_NORMAL
- en: '9997202020202020220000040000000000000006000000'
  prefs: []
  type: TYPE_NORMAL
- en: 00000 00
  prefs: []
  type: TYPE_NORMAL
- en: '0000'
  prefs: []
  type: TYPE_NORMAL
- en: 00000000000000000132241057904MS
  prefs: []
  type: TYPE_NORMAL
- en: 476041-20311010310
  prefs: []
  type: TYPE_NORMAL
- en: 07000049010000000000900100000100000100000100000010000001000139010000490000
  prefs: []
  type: TYPE_NORMAL
- en: H000040710649
  prefs: []
  type: TYPE_NORMAL
- en: '06010'
  prefs: []
  type: TYPE_NORMAL
- en: 99979997 70
  prefs: []
  type: TYPE_NORMAL
- en: '631973'
  prefs: []
  type: TYPE_NORMAL
- en: '15758'
  prefs: []
  type: TYPE_NORMAL
- en: 599676584365300800200000300106060503010101010102010 01200006000000100001
  prefs: []
  type: TYPE_NORMAL
- en: 00600020 0
  prefs: []
  type: TYPE_NORMAL
- en: 0 0
  prefs: []
  type: TYPE_NORMAL
- en: 0 0000 0
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: 0 0 0
  prefs: []
  type: TYPE_NORMAL
- en: '02000102010102200000000010750'
  prefs: []
  type: TYPE_NORMAL
- en: '02321125100004000000040000'
  prefs: []
  type: TYPE_NORMAL
- en: P00004070100005301000010380010110000010147030400100009005199901200000 0006010000
  prefs: []
  type: TYPE_NORMAL
- en: '00100000'
  prefs: []
  type: TYPE_NORMAL
- en: 00000 00
  prefs: []
  type: TYPE_NORMAL
- en: '0000'
  prefs: []
  type: TYPE_NORMAL
- en: '0000202020202020220000040000000000000001000060'
  prefs: []
  type: TYPE_NORMAL
- en: 06010 70
  prefs: []
  type: TYPE_NORMAL
- en: '9997'
  prefs: []
  type: TYPE_NORMAL
- en: '99970101004900100000001018703221'
  prefs: []
  type: TYPE_NORMAL
- en: 770051-10111010500
  prefs: []
  type: TYPE_NORMAL
- en: '40004000000000000000000000000000000000000000000000000000004000000040000349'
  prefs: []
  type: TYPE_NORMAL
- en: P00004070200005303011010140010110000010147050000204004005199901200000 0006010000
  prefs: []
  type: TYPE_NORMAL
- en: '00100000'
  prefs: []
  type: TYPE_NORMAL
- en: 00000 00
  prefs: []
  type: TYPE_NORMAL
- en: '0000'
  prefs: []
  type: TYPE_NORMAL
- en: 000020202020 0 0200000000000000000000000050000
  prefs: []
  type: TYPE_NORMAL
- en: 00000 00
  prefs: []
  type: TYPE_NORMAL
- en: '0000'
  prefs: []
  type: TYPE_NORMAL
- en: 000000000000000000000000000000000000000000-00000000000
  prefs: []
  type: TYPE_NORMAL
- en: '000'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: 00000000349
  prefs: []
  type: TYPE_NORMAL
- en: H000061010649
  prefs: []
  type: TYPE_NORMAL
- en: '06010'
  prefs: []
  type: TYPE_NORMAL
- en: 99979997 70
  prefs: []
  type: TYPE_NORMAL
- en: '631973'
  prefs: []
  type: TYPE_NORMAL
- en: '15758'
  prefs: []
  type: TYPE_NORMAL
- en: 599676584360801190100000200204030502010101010102010 00770004800064000001
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 0 030
  prefs: []
  type: TYPE_NORMAL
- en: 0 0
  prefs: []
  type: TYPE_NORMAL
- en: 0 0340 00660000000170 0
  prefs: []
  type: TYPE_NORMAL
- en: 06010000000004410039601000000
  prefs: []
  type: TYPE_NORMAL
- en: 00021100000004940000000000
  prefs: []
  type: TYPE_NORMAL
- en: The records are very wide and thus wrap around. Each one occupies
  prefs: []
  type: TYPE_NORMAL
- en: four lines on the page here.
  prefs: []
  type: TYPE_NORMAL
- en: Input/Output
  prefs: []
  type: TYPE_NORMAL
- en: '**239**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a function called extractpums() to read in a PUMS file and create
    a data frame from its Person records. The user specifies the filename and lists
    fields to extract and names to assign to those fields.
  prefs: []
  type: TYPE_NORMAL
- en: We also want to retain the household serial number. This is good to have because
    data for persons in the same household may be correlated and we may want to add
    that aspect to our statistical model. Also, the household data may provide important
    covariates. (In the latter case, we would want to retain the covariate data as
    well.)
  prefs: []
  type: TYPE_NORMAL
- en: Before looking at the function code, let’s see what the function does.
  prefs: []
  type: TYPE_NORMAL
- en: In this data set, gender is in column 23 and age in columns 25 and 26\. In the
    example, our filename is *pumsa*. The following call creates a data frame consisting
    of those two variables.
  prefs: []
  type: TYPE_NORMAL
- en: pumsdf <- extractpums("pumsa",list(Gender=c(23,23),Age=c(25,26))) Note that
    we are stating here the names we want the columns to have in the resulting data
    frame. We can use any names we want—say Sex and Ancientness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the first part of that data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: head(pumsdf)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: serno Gender Age
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '195'
  prefs: []
  type: TYPE_NORMAL
- en: 2 19
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '407'
  prefs: []
  type: TYPE_NORMAL
- en: 1 38
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '407'
  prefs: []
  type: TYPE_NORMAL
- en: 1 14
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '610'
  prefs: []
  type: TYPE_NORMAL
- en: 2 65
  prefs: []
  type: TYPE_NORMAL
- en: 6 1609
  prefs: []
  type: TYPE_NORMAL
- en: 1 50
  prefs: []
  type: TYPE_NORMAL
- en: 7 1609
  prefs: []
  type: TYPE_NORMAL
- en: 2 49
  prefs: []
  type: TYPE_NORMAL
- en: The following is the code for the extractpums() function.
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: reads in PUMS file pf, extracting the Person records, returning a data 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: frame; each row of the output will consist of the Household serial 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: number and the fields specified in the list flds; the columns of
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: the data frame will have the names of the indices in flds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: extractpums <- function(pf,flds) {
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: 'dtf <- data.frame() # data frame to be built'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: 'con <- file(pf,"r") # connection'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: process the input file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: repeat {
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: 'hrec <- readLines(con,1) # read Household record'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: 'if (length(hrec) == 0) break # end of file, leave loop'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: get household serial number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: serno <- intextract(hrec,c(2,8))
  prefs: []
  type: TYPE_NORMAL
- en: '**240**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: how many Person records?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: npr <- intextract(hrec,c(106,107))
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: if (npr > 0)
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:npr) {
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: 'prec <- readLines(con,1) # get Person record'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: make this person's row for the data frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: person <- makerow(serno,prec,flds)
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: add it to the data frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: dtf <- rbind(dtf,person)
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: return(dtf)
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: set up this person's row for the data frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: makerow <- function(srn,pr,fl) {
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: l <- list()
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: l[["serno"]] <- srn
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: for (nm in names(fl)) {
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: l[[nm]] <- intextract(pr,fl[[nm]])
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  prefs: []
  type: TYPE_NORMAL
- en: return(l)
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  prefs: []
  type: TYPE_NORMAL
- en: extracts an integer field in the string s, in character positions 40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: rng[1] through rng[2]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '41'
  prefs: []
  type: TYPE_NORMAL
- en: intextract <- function(s,rng) {
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  prefs: []
  type: TYPE_NORMAL
- en: fld <- substr(s,rng[1],rng[2])
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  prefs: []
  type: TYPE_NORMAL
- en: return(as.integer(fld))
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how this works. At the beginning of extractpums(), we create an empty
    data frame and set up the connection for the PUMS file read.
  prefs: []
  type: TYPE_NORMAL
- en: 'dtf <- data.frame() # data frame to be built'
  prefs: []
  type: TYPE_NORMAL
- en: 'con <- file(pf,"r") # connection'
  prefs: []
  type: TYPE_NORMAL
- en: The main body of the code then consists of a repeat loop.
  prefs: []
  type: TYPE_NORMAL
- en: repeat {
  prefs: []
  type: TYPE_NORMAL
- en: 'hrec <- readLines(con,1) # read Household record'
  prefs: []
  type: TYPE_NORMAL
- en: 'if (length(hrec) == 0) break # end of file, leave loop'
  prefs: []
  type: TYPE_NORMAL
- en: get household serial number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: serno <- intextract(hrec,c(2,8))
  prefs: []
  type: TYPE_NORMAL
- en: how many Person records?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: npr <- intextract(hrec,c(106,107))
  prefs: []
  type: TYPE_NORMAL
- en: Input/Output
  prefs: []
  type: TYPE_NORMAL
- en: '**241**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: if (npr > 0)
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:npr) {
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: This loop iterates until the end of the input file is reached. The latter condition
    will be sensed by encountering a zero-length Household record, as seen in the
    preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Within the repeat loop, we alternate reading a Household record and reading
    the associated Person records. The number of Person records for the current Household
    record is extracted from columns 106 and 107 of that record, storing this number
    in npr. That extraction is done by a call to our function intextract().
  prefs: []
  type: TYPE_NORMAL
- en: 'The for loop then reads in the Person records one by one, in each case forming
    the desired row for the output data frame and then attaching it to the latter
    via rbind():'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:npr) {
  prefs: []
  type: TYPE_NORMAL
- en: 'prec <- readLines(con,1) # get Person record'
  prefs: []
  type: TYPE_NORMAL
- en: make this person's row for the data frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: person <- makerow(serno,prec,flds)
  prefs: []
  type: TYPE_NORMAL
- en: add it to the data frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: dtf <- rbind(dtf,person)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Note how makerow() creates the row to be added for a given person. Here the
    formal arguments are srn for the household serial number, pr for the given Person
    record, and fl for the list of variable names and column fields.
  prefs: []
  type: TYPE_NORMAL
- en: makerow <- function(srn,pr,fl) {
  prefs: []
  type: TYPE_NORMAL
- en: l <- list()
  prefs: []
  type: TYPE_NORMAL
- en: l[["serno"]] <- srn
  prefs: []
  type: TYPE_NORMAL
- en: for (nm in names(fl)) {
  prefs: []
  type: TYPE_NORMAL
- en: l[[nm]] <- intextract(pr,fl[[nm]])
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return(l)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider our sample call:'
  prefs: []
  type: TYPE_NORMAL
- en: pumsdf <- extractpums("pumsa",list(Gender=c(23,23),Age=c(25,26))) When makerow()
    executes, fl will be a list with two elements, named Gender and Age. The string
    pr, the current Person record, will have Gender in column 23 and Age in columns
    25 and 26\. We call intextract() to pull out the desired numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**242**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The intextract() function itself is a straightforward conversion of characters
    to numbers, such as converting the string "12" to the number 12\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, if not for the presence of Household records, we could do all of
    this much more easily with a handy built-in R function: read.fwf(). The name of
    this function is an abbreviation for “read fixed-width formatted,”'
  prefs: []
  type: TYPE_NORMAL
- en: alluding to the fact that each variable is stored in given character positions
    of a record. In essence, this function alleviates the need to write a function
    like intextract().
  prefs: []
  type: TYPE_NORMAL
- en: '***10.2.5 Accessing Files on Remote Machines via URLs***'
  prefs: []
  type: TYPE_NORMAL
- en: Certain I/O functions, such as read.table() and scan(), accept web URLs as arguments.
    (Check R’s online help facility to see if your favorite function allows this.)
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we’ll read some data from the University of Califor-
  prefs: []
  type: TYPE_NORMAL
- en: 'nia, Irvine archive at *http://archive.ics.uci.edu/ml/datasets.html*, using
    the Echocardiogram data set. After navigating the links, we find the location
    of that file and then read it from R, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: uci <- "http://archive.ics.uci.edu/ml/machine-learning-databases/"
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: uci <- paste(uci,"echocardiogram/echocardiogram.data",sep="")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ecc <- read.csv(uci)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (We’ve built up the URL in stages here to fit the page.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at what we downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: head(ecc)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: X11 X0 X71 X0.1 X0.260
  prefs: []
  type: TYPE_NORMAL
- en: X9 X4.600 X14
  prefs: []
  type: TYPE_NORMAL
- en: X1 X1.1 name X1.2 X0.2
  prefs: []
  type: TYPE_NORMAL
- en: 1 19 0 72
  prefs: []
  type: TYPE_NORMAL
- en: 0 0.380
  prefs: []
  type: TYPE_NORMAL
- en: 6 4.100
  prefs: []
  type: TYPE_NORMAL
- en: 14 1.700 0.588 name
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: 2 16 0 55
  prefs: []
  type: TYPE_NORMAL
- en: 0 0.260
  prefs: []
  type: TYPE_NORMAL
- en: 4 3.420
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 1 name
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: 3 57 0 60
  prefs: []
  type: TYPE_NORMAL
- en: 0 0.253 12.062 4.603
  prefs: []
  type: TYPE_NORMAL
- en: 16 1.450 0.788 name
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: 4 19 1 57
  prefs: []
  type: TYPE_NORMAL
- en: 0 0.160
  prefs: []
  type: TYPE_NORMAL
- en: 22 5.750
  prefs: []
  type: TYPE_NORMAL
- en: 18 2.250 0.571 name
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: 5 26 0 68
  prefs: []
  type: TYPE_NORMAL
- en: 0 0.260
  prefs: []
  type: TYPE_NORMAL
- en: 5 4.310
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: 1 0.857 name
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: 6 13 0 62
  prefs: []
  type: TYPE_NORMAL
- en: 0 0.230
  prefs: []
  type: TYPE_NORMAL
- en: 31 5.430 22.5 1.875 0.857 name
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: We could then do our analyses. For example, the third column is age, so we could
    find its mean or perform other calculations on that data. See the echocardiogram.names
    page at *http://archive.ics.uci.edu/ml/machine-learning-databases/echocardiogram/echocardiogram.names*
    for descriptions of all of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: '***10.2.6 Writing to a File***'
  prefs: []
  type: TYPE_NORMAL
- en: Given the statistical basis of R, file reads are probably much more common than
    writes. But writes are sometimes necessary, and this section will present methods
    for writing to files.
  prefs: []
  type: TYPE_NORMAL
- en: Input/Output
  prefs: []
  type: TYPE_NORMAL
- en: '**243**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function write.table() works very much like read.table(), except that it
    writes a data frame instead of reading one. For instance, let’s take the little
    Jack and Jill example from the beginning of Chapter 5:'
  prefs: []
  type: TYPE_NORMAL
- en: kids <- c("Jack","Jill")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ages <- c(12,10)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d <- data.frame(kids,ages,stringsAsFactors=FALSE)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: kids ages
  prefs: []
  type: TYPE_NORMAL
- en: 1 Jack
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: 2 Jill
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: write.table(d,"kds")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The file *kds* will now have these contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '"kids" "ages"'
  prefs: []
  type: TYPE_NORMAL
- en: '"1" "Jack" 12'
  prefs: []
  type: TYPE_NORMAL
- en: '"2" "Jill" 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of writing a matrix to a file, just state that you do not want
    row or column names, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: write.table(xc,"xcnew",row.names=FALSE,col.names=FALSE) The function cat() can
    also be used to write to a file, one part at a time.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: cat("abc\n",file="u")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: cat("de\n",file="u",append=TRUE)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The first call to cat() creates the file *u*, consisting of one line with contents
    "abc". The second call appends a second line. Unlike the case of using the writeLines()
    function (which we’ll discuss next), the file is automatically saved after each
    operation. For instance, after the previous calls, the file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: abc
  prefs: []
  type: TYPE_NORMAL
- en: de
  prefs: []
  type: TYPE_NORMAL
- en: 'You can write multiple fields as well. So:'
  prefs: []
  type: TYPE_NORMAL
- en: cat(file="v",1,2,"xyz\n")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'would produce a file *v* consisting of a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 2 xyz
  prefs: []
  type: TYPE_NORMAL
- en: '**244**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use writeLines(), the counterpart of readLines(). If you use a
    connection, you must specify "w" to indicate you are writing to the file, not
    reading from it:'
  prefs: []
  type: TYPE_NORMAL
- en: c <- file("www","w")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: writeLines(c("abc","de","f"),c)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: close(c)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The file *www* will be created with these contents:'
  prefs: []
  type: TYPE_NORMAL
- en: abc
  prefs: []
  type: TYPE_NORMAL
- en: de
  prefs: []
  type: TYPE_NORMAL
- en: f
  prefs: []
  type: TYPE_NORMAL
- en: Note the need to proactively close the file.
  prefs: []
  type: TYPE_NORMAL
- en: '***10.2.7 Getting File and Directory Information***'
  prefs: []
  type: TYPE_NORMAL
- en: 'R has a variety of functions for getting information about directories and
    files, setting file access permissions, and the like. The following are a few
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'file.info(): Gives file size, creation time, directory-versus-ordinary file
    status, and so on for each file whose name is in the argument, a character vector.'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'dir(): Returns a character vector listing the names of all the files in the
    directory specified in its first argument. If the optional argument recursive=TRUE
    is specified, the result will show the entire directory tree rooted at the first
    argument.'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'file.exists(): Returns a Boolean vector indicating whether the given file exists
    for each name in the first argument, a character vector.'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'getwd() and setwd(): Used to determine or change the current working directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see all the file- and directory-related functions, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: ?files
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some of these options will be demonstrated in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: '***10.2.8 Extended Example: Sum the Contents of Many Files***'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ll develop a function to find the sum of the contents (assumed numeric)
    in all files in a directory tree. In our example, a directory *dir1*
  prefs: []
  type: TYPE_NORMAL
- en: Input/Output
  prefs: []
  type: TYPE_NORMAL
- en: '**245**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'contains the files *filea* and *fileb*, as well as a subdirectory *dir2*, which
    holds the file *filec*. The contents of the files are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: '*filea*: 5, 12, 13'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: '*fileb*: 3, 4, 5'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: '*filec*: 24, 25, 7'
  prefs: []
  type: TYPE_NORMAL
- en: 'If *dir1* is in our current directory, the call sumtree("dir1") will yield
    the sum of those nine numbers, 98\. Otherwise, we need to specify the full pathname
    of *dir1*, such as sumtree("/home/nm/dir1"). Here is the code: 1'
  prefs: []
  type: TYPE_NORMAL
- en: sumtree <- function(drtr) {
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: tot <- 0
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: get names of all files in the tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: fls <- dir(drtr,recursive=TRUE)
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: for (f in fls) {
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: is f a directory?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: f <- file.path(drtr,f)
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: if (!file.info(f)$isdir) {
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: tot <- tot + sum(scan(f,quiet=TRUE))
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: return(tot)
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Note that this problem is a natural for recursion, which we discussed in Section
    7.9\. But here, R has done the recursion for us by allowing it as an option in
    dir(). Thus, in line 4, we set recursive=TRUE in order to find the files throughout
    the various levels of the directory tree.
  prefs: []
  type: TYPE_NORMAL
- en: To call file.info(), we need to account for the fact that the current filename
    *f* is relative to drtr, so our file *filea* would be referred to as *dir1/filea*.
  prefs: []
  type: TYPE_NORMAL
- en: In order to form that pathname, we need to concatenate drtr, a slash, and filea.
    We could use the R string concatenation function paste() for this, but we would
    need a separate case for Windows, which uses a backslash instead of a slash. But
    file.path() does all that for us.
  prefs: []
  type: TYPE_NORMAL
- en: Some commentary pertaining to line 8 is in order. The function
  prefs: []
  type: TYPE_NORMAL
- en: file.info() returns information about f as a data frame, one of whose columns
    is isdir, with one row for each file and with row names being the filenames. That
    column consists of Boolean values indicating whether each file is a directory.
    In line 8, then, we can detect whether the current file *f* is a directory. If
    *f* is an ordinary file, we go ahead and add its contents to our running total.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.3 Accessing the Internet**'
  prefs: []
  type: TYPE_NORMAL
- en: R’s socket facilities give the programmer access to the Internet’s TCP/IP
  prefs: []
  type: TYPE_NORMAL
- en: protocol. For readers who are not familiar with this protocol, we begin with
    an overview of TCP/IP.
  prefs: []
  type: TYPE_NORMAL
- en: '**246**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***10.3.1 Overview of TCP/IP***'
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP is quite complex, so the overview here will be something of an over-simplification,
    but we’ll cover enough for you to understand what R’s socket functions are doing.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes here, the term *network* refers to a set of computers connected
    together locally, without going through the Internet. This typically consists
    of all the computers in a home, all the computers in a smaller business, and so
    on. The physical medium between them is usually an Ethernet connection of some
    form.
  prefs: []
  type: TYPE_NORMAL
- en: The Internet, as its name implies, connects networks. A network in the Internet
    is connected to one or more other networks via *routers*, which are special-purpose
    computers that connect two or more networks together.
  prefs: []
  type: TYPE_NORMAL
- en: Every computer on the Internet has an Internet Protocol (IP) address. This is
    numeric, but it can be stated in characters, as in *www.google.com*, which is
    then translated into the numeric address by the Domain Name Service.
  prefs: []
  type: TYPE_NORMAL
- en: However, the IP address is not enough. When A sends a message to
  prefs: []
  type: TYPE_NORMAL
- en: B, there may be several applications at computer B that are receiving Internet
    messages, such as web browsing, email service, and so on. How does the operating
    system at B know to which of these to send the message from A? The answer is that
    A will specify a *port number* in addition to the IP address.
  prefs: []
  type: TYPE_NORMAL
- en: The port number indicates which program running at B is intended as the recipient.
    And A will also have a port number so that the response from B
  prefs: []
  type: TYPE_NORMAL
- en: reaches the correct application at A.
  prefs: []
  type: TYPE_NORMAL
- en: When A wishes to send something to B, it writes to a software entity called
    a *socket*, using a system call syntactically similar to the one for writing to
    a file. In the call, A specifies B’s IP address and the port number to which A
    wishes to send a message. B has a socket, too, and it writes its responses to
    A in that socket. We say there is a *connection* between A and B via those sockets,
    but that doesn’t mean anything physical—it’s just an agreement between A and B
    to exchange data.
  prefs: []
  type: TYPE_NORMAL
- en: Applications follow a *client/server* model. Say a web server is running at
    B, at the standard port for the Web, port 80\. The server at B is *listening*
    at port 80\. Again, this term should not be taken literally; it just means that
    the server program has made a function call that notifies the operating system
    that the server program is willing to have connections at port 80\. When network
    node A requests such a connection, the function call at the server returns, and
    the connection is set up.
  prefs: []
  type: TYPE_NORMAL
- en: If you are a nonprivileged user and write some kind of server program—
  prefs: []
  type: TYPE_NORMAL
- en: say in R!—you must assign a port number above 1024\.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If a server program is taken down or crashes, there may be a few seconds’
    delay before* *the same port is reusable again.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***10.3.2 Sockets in R***'
  prefs: []
  type: TYPE_NORMAL
- en: A very important point to keep in mind is that all the bytes sent by A to B
  prefs: []
  type: TYPE_NORMAL
- en: during the time the connection between them exists are collectively considered
    *one big message*. Say A sends one line of text of 8 characters and then Input/Output
  prefs: []
  type: TYPE_NORMAL
- en: '**247**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'another of 20 characters. From A’s point of view, that’s two lines, but to
    TCP/IP, it’s just 28 characters of a yet incomplete message. Splitting that long
    message back into lines can take a bit of doing. R provides various functions
    for this purpose, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'readLines() and writeLines(): These allow you to program as if TCP/IP'
  prefs: []
  type: TYPE_NORMAL
- en: were sending messages line by line, even though this is not actually the case.
    If your application is naturally viewed in terms of lines, these two functions
    can be quite handy.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'serialize() and unserialize(): You can use these to send R objects, such as
    a matrix or the complex output of a call to a statistical function. The object
    is converted to character string form by the sender and then converted back to
    the original object form at the receiver.'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'readBin() and writeBin(): These are for sending data in binary form.'
  prefs: []
  type: TYPE_NORMAL
- en: (Recall the comment on terminology at the beginning of Section 10.2.2.) Each
    of these functions operates on R connections, as you’ll see in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to choose the right function for each job. If you have a long
    vector, for example, using serialize() and unserialize() may be more convenient
    but far more time-consuming. This is not only because numbers must be converted
    to and from their character representations but also because the character representation
    is typically much longer, which means greater transmission time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two other R socket functions:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'socketConnection(): This establishes an R connection via sockets. You specify
    the port number in the argument port, and state whether a'
  prefs: []
  type: TYPE_NORMAL
- en: server or client is to be created, by setting the argument server to TRUE
  prefs: []
  type: TYPE_NORMAL
- en: or FALSE, respectively. In the client case, you must also supply the server’s
    IP address in the argument host.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'socketSelect(): This is useful when a server is connected to multiple clients.
    Its main argument, socklist, is a list of connections, and its return value is
    the sublist of connections that have data ready for the server to read.'
  prefs: []
  type: TYPE_NORMAL
- en: '***10.3.3 Extended Example: Implementing Parallel R***'
  prefs: []
  type: TYPE_NORMAL
- en: Some statistical analyses have very long runtimes, so there naturally has been
    quite a bit of interest in “parallel R,” in which several R processes cooperate
    on a given task. Another possible reason to “go parallel” is memory limita-tions.
    If one machine does not have enough memory for the task at hand, it may help to
    pool the memories of several machines in some way. Chapter 16
  prefs: []
  type: TYPE_NORMAL
- en: gives an introduction to this important topic.
  prefs: []
  type: TYPE_NORMAL
- en: Sockets play a key role in many parallel R packages. The cooperating R
  prefs: []
  type: TYPE_NORMAL
- en: processes could be either on the same machine or on separate machines. In the
    latter case (and even the former), a natural approach to implementing parallelism
    is to use R sockets. This is one of the choices in the snow package **248**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'and in my Rdsm package (both available on CRAN, R’s code repository; see this
    book’s appendix for details), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: In snow, the server sends out work tasks to the clients. The clients perform
    their tasks and send the results back to the server, which assembles them into
    the final result. Communication is done with serialize() and unserialize(), and
    the server uses socketSelect() to determine which client results are ready.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: Rdsm implements a virtual shared-memory paradigm, and the server is used to
    store the shared variables. The clients contact the server whenever they need
    to read or write a shared variable. To optimize speed, communication between server
    and clients is done with readBin() and writebin(), instead of serialize() and
    unserialize().
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some of the socket-related details of Rdsm. First, here is the
    server code in which connections with the clients are set up, storing them in
    a list cons (there are ncon clients):'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: set up socket connections with clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: 'cons <<- vector(mode="list",length=ncon) # list of connections 4'
  prefs: []
  type: TYPE_NORMAL
- en: prevent connection from dying during debug or long compute spell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: options("timeout"=10000)
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:ncon) {
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: cons[[i]] <<-
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: socketConnection(port=port,server=TRUE,blocking=TRUE,open="a+b") 9
  prefs: []
  type: TYPE_NORMAL
- en: wait to hear from client i
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: checkin <- unserialize(cons[[i]])
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: send ACKs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:ncon) {
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: send the client its ID number, and the group size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: serialize(c(i,ncon),cons[[i]])
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Since the client messages and server acknowledgments are short mes-
  prefs: []
  type: TYPE_NORMAL
- en: sages, serialize() and unserialize() are good enough for the purpose here.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the main loop of the server finds a ready client and reads
    from it.
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: repeat {
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: any clients still there?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: if (remainingclients == 0) break
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: wait for service request, then read it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: find all the pending client requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: rdy <- which(socketSelect(cons))
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: choose one
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: j <- sample(1:length(rdy),1)
  prefs: []
  type: TYPE_NORMAL
- en: Input/Output
  prefs: []
  type: TYPE_NORMAL
- en: '**249**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: con <- cons[[rdy[j]]]
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: read client request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: req <- unserialize(con)
  prefs: []
  type: TYPE_NORMAL
- en: 'Again serialize() and unserialize() are good enough here to read the short
    message from the client indicating what kind of operation—typically reading a
    shared variable or writing one—it’s requesting. But the reads and writes of the
    shared variables themselves use the faster readBin() and writeBin() functions.
    Here’s the write part:'
  prefs: []
  type: TYPE_NORMAL
- en: write data dt, of mode md (integer of double), to connection cn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: binwrite <- function(dt,md,cn) {
  prefs: []
  type: TYPE_NORMAL
- en: writeBin(dt,con=cn)
  prefs: []
  type: TYPE_NORMAL
- en: 'And here’s the read part:'
  prefs: []
  type: TYPE_NORMAL
- en: read sz elements of mode md (integer of double) from connection cn binread <-
    function(cn,md,sz) {
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: return(readBin(con=cn,what=md,n=sz))
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client side, the connection setup code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: options("timeout"=10000)
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: connect to server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: con <- socketConnection(host=host,port=port,blocking=TRUE,open="a+b") 4
  prefs: []
  type: TYPE_NORMAL
- en: serialize(list(req="checking in"),con)
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: receive this client's ID and total number of clients from server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: myidandnclnt <- unserialize(con)
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: myinfo <<-
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: list(con=con,myid=myidandnclnt[1],nclnt=myidandnclnt[2])
  prefs: []
  type: TYPE_NORMAL
- en: The code for reading from and writing to the server is similar to the preceding
    server examples.
  prefs: []
  type: TYPE_NORMAL
- en: '**250**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 23](index-277_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**11**'
  prefs: []
  type: TYPE_NORMAL
- en: '**STRING MANIPULATION**'
  prefs: []
  type: TYPE_NORMAL
- en: Although R is a statistical language with
  prefs: []
  type: TYPE_NORMAL
- en: numeric vectors and matrices playing a
  prefs: []
  type: TYPE_NORMAL
- en: central role, character strings are surpris-
  prefs: []
  type: TYPE_NORMAL
- en: ingly important as well. Ranging from birth
  prefs: []
  type: TYPE_NORMAL
- en: dates stored in medical research data files to text-
  prefs: []
  type: TYPE_NORMAL
- en: mining applications, character data arises quite fre-
  prefs: []
  type: TYPE_NORMAL
- en: quently in R programs. Accordingly, R has a number
  prefs: []
  type: TYPE_NORMAL
- en: of string-manipulation utilities, many of which will be
  prefs: []
  type: TYPE_NORMAL
- en: introduced in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**11.1 An Overview of String-Manipulation Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ll briefly review just some of the many string-manipulation functions
    R has to offer. Note that the call forms shown in this introduction are very simple,
    usually omitting many optional arguments. We’ll use some of those arguments in
    our extended examples later in the chapter, but do check R’s online help for further
    details.
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.1 grep()***'
  prefs: []
  type: TYPE_NORMAL
- en: The call grep(pattern,x) searches for a specified substring pattern in a vector
    x of strings. If x has *n* elements—that is, it contains *n* strings—then grep(pattern,x)
    will return a vector of length up to *n*. Each element of this vector will be
    the index in x at which a match of pattern as a substring of x[i]) was found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using grep:'
  prefs: []
  type: TYPE_NORMAL
- en: grep("Pole",c("Equator","North Pole","South Pole"))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 2 3'
  prefs: []
  type: TYPE_NORMAL
- en: grep("pole",c("Equator","North Pole","South Pole")) integer(0)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the first case, the string "Pole" was found in elements 2 and 3 of the second
    argument, hence the output (2,3). In the second case, string "pole"
  prefs: []
  type: TYPE_NORMAL
- en: was not found anywhere, so an empty vector was returned.
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.2 nchar()***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The call nchar(x) finds the length of a string x. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: nchar("South Pole")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'The string "South Pole" was found to have 10 characters. C programmers, take
    note: There is no NULL character terminating R strings.'
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the results of nchar() will be unpredictable if x is not in character
    mode. For instance, nchar(NA) turns out to be 2, and nchar(factor("abc")) is 1\.
    For more consistent results on nonstring objects, use Hadley Wickham’s stringr
    package on CRAN.
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.3 paste()***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The call paste(...) concatenates several strings, returning the result in one
    long string. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: paste("North","Pole")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "North Pole"'
  prefs: []
  type: TYPE_NORMAL
- en: paste("North","Pole",sep="")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "NorthPole"'
  prefs: []
  type: TYPE_NORMAL
- en: paste("North","Pole",sep=".")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "North.Pole"'
  prefs: []
  type: TYPE_NORMAL
- en: paste("North","and","South","Poles")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "North and South Poles"'
  prefs: []
  type: TYPE_NORMAL
- en: '**252**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the optional argument sep can be used to put something other
    than a space between the pieces being spliced together. If you specify sep as
    an empty string, the pieces won’t have any character between them.
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.4 sprintf()***'
  prefs: []
  type: TYPE_NORMAL
- en: The call sprintf(...) assembles a string from parts in a formatted manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: i <- 8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: s <- sprintf("the square of %d is %d",i,i^2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: s
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "the square of 8 is 64"'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the function is intended to evoke *string print* for “printing”
  prefs: []
  type: TYPE_NORMAL
- en: to a string rather than to the screen. Here, we are printing to the string s.
  prefs: []
  type: TYPE_NORMAL
- en: What are we printing? The function says to first print “the square of”
  prefs: []
  type: TYPE_NORMAL
- en: and then print the decimal value of i. (The term *decimal* here means in the
    base-10 number system, not that there will be a decimal point in the result.)
    The result is the string "the square of 8 is 64."
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.5 substr()***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The call substr(x,start,stop) returns the substring in the given character
    position range start:stop in the given string x. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: substring("Equator",3,5)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "uat"'
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.6 strsplit()***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The call strsplit(x,split) splits a string x into an R list of substrings based
    on another string split in x. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: strsplit("6-16-2011",split="-")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[[1]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "6"'
  prefs: []
  type: TYPE_NORMAL
- en: '"16"'
  prefs: []
  type: TYPE_NORMAL
- en: '"2011"'
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.7 regexpr()***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The call regexpr(pattern,text) finds the character position of the first instance
    of pattern within text, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: regexpr("uat","Equator")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 3'
  prefs: []
  type: TYPE_NORMAL
- en: String Manipulation
  prefs: []
  type: TYPE_NORMAL
- en: '**253**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: This reports that “uat” did indeed appear in “Equator,” starting at character
    position 3\.
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.8 gregexpr()***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The call gregexpr(pattern,text) is the same as regexpr(), but it finds all
    instances of pattern. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: gregexpr("iss","Mississippi")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[[1]]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 2 5'
  prefs: []
  type: TYPE_NORMAL
- en: This finds that “iss” appears twice in “Mississippi,” starting at character
    positions 2 and 5\.
  prefs: []
  type: TYPE_NORMAL
- en: '**11.2 Regular Expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with string-manipulation functions in programming languages, the
    notion of *regular expressions* sometimes arises. In R, you must pay attention
    to this point when using the string functions grep(), grepl(), regexpr(), gregexpr(),
    sub(), gsub(), and strsplit().
  prefs: []
  type: TYPE_NORMAL
- en: 'A regular expression is a kind of wild card. It’s shorthand to specify broad
    classes of strings. For example, the expression "[au]" refers to any string that
    contains either of the letters *a* or *u*. You could use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: grep("[au]",c("Equator","North Pole","South Pole"))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 3'
  prefs: []
  type: TYPE_NORMAL
- en: This reports that elements 1 and 3 of ("Equator","North Pole","South Pole")—that
    is, “Equator” and “South Pole”—contain either an *a* or a *u*.
  prefs: []
  type: TYPE_NORMAL
- en: A period (.) represents any single character. Here’s an example of
  prefs: []
  type: TYPE_NORMAL
- en: 'using it:'
  prefs: []
  type: TYPE_NORMAL
- en: grep("o.e",c("Equator","North Pole","South Pole"))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 2 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'This searches for three-character strings in which an *o* is followed by any
    single character, which is in turn followed by an *e*. Here is an example of the
    use of two periods to represent any pair of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: grep("N..t",c("Equator","North Pole","South Pole"))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 2'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we searched for four-letter strings consisting of an *N*, followed by
    any pair of characters, followed by a *t*.
  prefs: []
  type: TYPE_NORMAL
- en: A period is an example of a *metacharacter*, which is a character that is not
    to be taken literally. For example, if a period appears in the first argument
    of grep(), it doesn’t actually mean a period; it means any character.
  prefs: []
  type: TYPE_NORMAL
- en: '**254**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you want to search for a period using grep()? Here’s the naive
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: grep(".",c("abc","de","f.g"))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 2 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should have been 3, not (1,2,3). This call failed because periods
    are metacharacters. You need to *escape* the metacharacter nature of the period,
    which is done via a backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: grep("\\.",c("abc","de","f.g"))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 3'
  prefs: []
  type: TYPE_NORMAL
- en: Now, didn’t I say *a* backslash? Then why are there two? Well, the sad truth
    is that the backslash itself must be escaped, which is accomplished by its own
    backslash! This goes to show how arcanely complex regular expressions can become.
    Indeed, a number of books have been written on the subject of regular expressions
    (for various programming languages). As a start in learning about the topic, refer
    to R’s online help (type ?regex).
  prefs: []
  type: TYPE_NORMAL
- en: '***11.2.1 Extended Example: Testing a Filename for a Given Suffix***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we wish to test for a specified suffix in a filename. We might, for
    instance, want to find all HTML files (those with suffix *.html*, *.htm*, and
    so on). Here is code for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix <- function(fn,suff) {
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: parts <- strsplit(fn,".",fixed=TRUE)
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: nparts <- length(parts[[1]])
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: return(parts[[1]][nparts] == suff)
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test it.
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix("x.abc","abc")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] TRUE'
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix("x.abc","ac")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] FALSE'
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix("x.y.abc","ac")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] FALSE'
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix("x.y.abc","abc")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] TRUE'
  prefs: []
  type: TYPE_NORMAL
- en: How does the function work? First note that the call to strsplit() on line 2
    returns a list consisting of one element (because fn is a one-element vector)—a
    vector of strings. For example, calling testsuffix("x.y.abc","abc") will result
    in parts being a list consisting of a three-element vector with elements x, y,
    and abc. We then pick up the last element and compare it to suff.
  prefs: []
  type: TYPE_NORMAL
- en: String Manipulation
  prefs: []
  type: TYPE_NORMAL
- en: '**255**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: A key aspect is the argument fixed=TRUE. Without it, the splitting argument
    . (called split in the list of strsplit()’s formal arguments) would have been
    treated as a regular expression. Without setting fixed=TRUE, strsplit() would
    have just separated all the letters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we could also escape the period, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix <- function(fn,suff) {
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: parts <- strsplit(fn,"\\.")
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: nparts <- length(parts[[1]])
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: return(parts[[1]][nparts] == suff)
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s check to see if it still works.
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix("x.y.abc","abc")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] TRUE'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another way to do the suffix-test code that’s a bit more involved but
    a good illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix <- function(fn,suff) {
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: 'ncf <- nchar(fn) # nchar() gives the string length'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: determine where the period would start if suff is the suffix in fn 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: dotpos <- ncf - nchar(suff) + 1
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: now check that suff is there
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: return(substr(fn,dotpos,ncf)==suff)
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the call to substr() here, again with fn = "x.ac" and suff = "abc".
    In this case, dotpos will be 1, which means there should be a period at the first
    character in fn if there is an abc suffix. The call to substr() then becomes substr("x.ac",1,4),
    which extracts the substring in character positions 1 through 4 of x.ac. That
    substring will be x.ac, which is not abc, so the filename’s suffix is found not
    to be the latter.
  prefs: []
  type: TYPE_NORMAL
- en: '***11.2.2 Extended Example: Forming Filenames***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to create five files, *q1.pdf* through *q5.pdf*, consisting
    of histograms of 100 random N(0, *i* 2) variates. We could execute the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:5) {
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: fname <- paste("q",i,".pdf")
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: pdf(fname)
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: hist(rnorm(100,sd=i))
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: dev.off()
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**256**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The main point in this example is the string manipulation we use to create the
    filename fname. For more details about the graphics operations used in this example,
    refer to Section 12.3\.
  prefs: []
  type: TYPE_NORMAL
- en: The paste() function concatenates the string "q" with the string form of the
    number i. For example, when i = 2, the variable fname will be q 2 .pdf.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, that isn’t quite what we want. On Linux systems, filenames with embedded
    spaces create headaches, so we want to remove the spaces. One solution is to use
    the sep argument, specifying an empty string for the separator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:5) {
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: fname <- paste("q",i,".pdf",sep="") 3
  prefs: []
  type: TYPE_NORMAL
- en: pdf(fname)
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: hist(rnorm(100,sd=i))
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: dev.off()
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach is to employ the sprintf() function, borrowed from C: 1'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:5) {
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: fname <- sprintf("q%d.pdf",i)
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: pdf(fname)
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: hist(rnorm(100,sd=i))
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: dev.off()
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'For floating-point quantities, note also the difference between %f and %g formats:'
  prefs: []
  type: TYPE_NORMAL
- en: sprintf("abc%fdef",1.5)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "abc1.500000def"'
  prefs: []
  type: TYPE_NORMAL
- en: sprintf("abc%gdef",1.5)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "abc1.5def"'
  prefs: []
  type: TYPE_NORMAL
- en: The %g format eliminated the superfluous zeros.
  prefs: []
  type: TYPE_NORMAL
- en: '**11.3 Use of String Utilities in the edtdbg Debugging Tool**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The internal code of the edtdbg debugging tool, which will be discussed in
    Section 13.4, makes heavy use of string utilities. A typical example of such usage
    is the dgbsendeditcmd() function:'
  prefs: []
  type: TYPE_NORMAL
- en: send command to editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: dbgsendeditcmd <- function(cmd) {
  prefs: []
  type: TYPE_NORMAL
- en: syscmd <- paste("vim --remote-send ",cmd," --servername ",vimserver,sep="")
    system(syscmd)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: String Manipulation
  prefs: []
  type: TYPE_NORMAL
- en: '**257**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'What is going on here? The main point is that edtdbg sends remote commands
    to the Vim text editor. For instance, if you are running Vim with a server name
    of 168 and you want the cursor in Vim to move to line 12, you could type this
    into a terminal (shell) window:'
  prefs: []
  type: TYPE_NORMAL
- en: vim --remote-send 12G --servername 168
  prefs: []
  type: TYPE_NORMAL
- en: 'The effect would be the same as if you had physically typed 12G at the Vim
    window. Since 12G is the Vim command to move the cursor to line 12, that’s what
    would occur. Consider this call:'
  prefs: []
  type: TYPE_NORMAL
- en: 'paste("vim --remote-send ",cmd," --servername ",vimserver,sep="") Here, cmd
    is the string "12G", vimserver is 168, and paste() concatenates all the indicated
    strings. The argument sep="" says to use the empty string as separator in this
    concatenation—that is, no separation. Thus, paste() returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: vim --remote-send 12G --servername 168
  prefs: []
  type: TYPE_NORMAL
- en: Another core element in the operation of edtdbg is that the program has arranged,
    via a call to R’s sink() function, to record to the file *dbgsink* most output
    from R’s debugger in your R window. (The edtdbg utility works in concert with
    that debugger.) That information includes the line numbers of your positions in
    your source file as you step through it using R’s debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line position information in the debugger output looks like this: debug
    at cities.r#16: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, there is code in edtdbg to determine the latest line in *dbgsink* that
    begins with “debug at.” That line is then placed, as a string, in a variable named
    debugline. The following code then extracts the line number (16 in the example)
    and the source filename/Vim buffer name ( *cities.r* here): linenumstart <- regexpr("#",debugline)
    + 1'
  prefs: []
  type: TYPE_NORMAL
- en: buffname <- substr(debugline,10,linenumstart-2)
  prefs: []
  type: TYPE_NORMAL
- en: colon <- regexpr(":",debugline)
  prefs: []
  type: TYPE_NORMAL
- en: linenum <- substr(debugline,linenumstart,colon-1)
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to regexpr() determines where in debugline the # character is located
    (character 18 in this example). Adding 1 to that gives the position of the line
    number within debugline.'
  prefs: []
  type: TYPE_NORMAL
- en: '**258**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the buffer name, using the preceding example as a guide, we see that
    the name comes after debug at and ends just before the #. Since “debug at” contains
    nine characters, the buffer name will start at position 10—hence the 10 in the
    call,'
  prefs: []
  type: TYPE_NORMAL
- en: substr(debugline,10,linenumstart-2)
  prefs: []
  type: TYPE_NORMAL
- en: 'The end of the buffer name field is at linenumstart-2, as it is just before
    the #, which precedes the start of the line number. The line number computation
    is then similar.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another illustrative example of edtdbg’s internal code is its use of the strsplit()
    function. For example, at one point, it prints out a prompt to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: 'kbdin <- readline(prompt="enter number(s) of fns you wish to toggle dbg: ")
    As you can see, the user’s response is stored in kbdin. It will consist of a set
    of numbers separated by spaces, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 4 5
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to extract the numbers from the string 1 4 5 into an integer vector.
    This is done first via strsplit(), which produces three strings: "1", "4", and
    "5". Then we call as.integer() to convert from characters to numbers: tognums
    <- as.integer(strsplit(kbdin,split=" ")[[1]])'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the output of strsplit() is an R list, in this case consisting of
    one element, which is in turn the vector ("1","4","5"). This leads to the expression
    [[1]] in the example.
  prefs: []
  type: TYPE_NORMAL
- en: String Manipulation
  prefs: []
  type: TYPE_NORMAL
- en: '**259**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 24](index-287_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**12**'
  prefs: []
  type: TYPE_NORMAL
- en: '**GRAPHICS**'
  prefs: []
  type: TYPE_NORMAL
- en: R has a very rich set of graphics facilities.
  prefs: []
  type: TYPE_NORMAL
- en: The R home page ( *http://www.r-project*
  prefs: []
  type: TYPE_NORMAL
- en: '*.org/* ) has a few colorful examples, but to'
  prefs: []
  type: TYPE_NORMAL
- en: really appreciate R’s graphical power, browse
  prefs: []
  type: TYPE_NORMAL
- en: through the R Graph Gallery at *http://addictedtor.free*
  prefs: []
  type: TYPE_NORMAL
- en: '*.fr/graphiques*.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we cover the basics of using R’s base, or traditional, graphics
    package. This will give you enough foundation to start working with graphics in
    R. If you’re interested in pursuing R graphics further, you may want to refer
    to the excellent books on the subject.1
  prefs: []
  type: TYPE_NORMAL
- en: '**12.1 Creating Graphs**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we’ll look at the foundational function for creating graphs: plot().'
  prefs: []
  type: TYPE_NORMAL
- en: Then we’ll explore how to build a graph, from adding lines and points to attaching
    a legend.
  prefs: []
  type: TYPE_NORMAL
- en: '1 These include Hadley Wickham, *ggplot2: Elegant Graphics for Data Analysis*
    (New York: Springer-Verlag, 2009); Dianne Cook and Deborah F. Swayne, *Interactive
    and Dynamic Graphics for Data* *Analysis: With R and GGobi* (New York: Springer-Verlag,
    2007); Deepayan Sarkar, *Lattice: Multivariate Data Visualization with R* (New
    York: Springer-Verlag, 2008); and Paul Murrell, *R Graphics* (Boca Raton, FL:
    Chapman and Hall/CRC, 2011).'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 25](index-288_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '***12.1.1 The Workhorse of R Base Graphics: The plot() Function***'
  prefs: []
  type: TYPE_NORMAL
- en: The plot() function forms the foundation for much of R’s base graphing operations,
    serving as the vehicle for producing many different kinds of graphs. As mentioned
    in Section 9.1.1, plot() is a generic function, or a placeholder for a family
    of functions. The function that is actually called depends on the class of the
    object on which it is called.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens when we call plot() with an X vector and a Y
  prefs: []
  type: TYPE_NORMAL
- en: vector, which are interpreted as a set of pairs in the ( *x*, *y*) plane.
  prefs: []
  type: TYPE_NORMAL
- en: plot(c(1,2,3), c(1,2,4))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This will cause a window to pop up, plotting the points (1,1), (2,2), and (3,4),
    as shown in Figure 12-1\. As you can see, this is a very plain-Jane graph.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss adding some of the fancy bells and whistles later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-1: Simple point plot*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The points in the graph in Figure 12-1 are denoted by empty circles. If you
    want to* *use a different character type, specify a value for the named argument
    pch (for* point character *).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The plot() function works in stages, which means you can build up a graph in
    stages by issuing a series of commands. For example, as a base, we might first
    draw an empty graph, with only axes, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: plot(c(-3,3), c(-1,5), type = "n", xlab="x", ylab="y") This draws axes labeled
    *x* and *y*. The horizontal ( *x*) axis ranges from *−* 3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: to 3\. The vertical ( *y*) axis ranges from *−* 1 to 5\. The argument type="n"
    means that there is nothing in the graph itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**262**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 26](index-289_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '***12.1.2 Adding Lines: The abline() Function***'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have an empty graph, ready for the next stage, which is adding a line:'
  prefs: []
  type: TYPE_NORMAL
- en: x <- c(1,2,3)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y <- c(1,3,8)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: plot(x,y)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lmout <- lm(y ~ x)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: abline(lmout)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After the call to plot(), the graph will simply show the three points, along
    with the *x*- and *y*- axes with hash marks. The call to abline() then adds a
    line to the current graph. Now, which line is this?
  prefs: []
  type: TYPE_NORMAL
- en: As you learned in Section 1.5, the result of the call to the linear-regression
    function lm() is a class instance containing the slope and intercept of the fitted
    line, as well as various other quantities that don’t concern us here. We’ve assigned
    that class instance to lmout. The slope and intercept will now be in lmout$coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: So, what happens when we call abline()? This function simply draws
  prefs: []
  type: TYPE_NORMAL
- en: 'a straight line, with the function’s arguments treated as the intercept and
    slope of the line. For instance, the call abline(c(2,1)) draws this line on whatever
    graph you’ve built up so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = 2 + 1 *· x*'
  prefs: []
  type: TYPE_NORMAL
- en: But abline() is written to take special action if it is called on a regression
    object (though, surprisingly, it is not a generic function). Thus, it will pick
    up the slope and intercept it needs from lmout$coefficients and plot that line.
    It superimposes this line onto the current graph, the one that graphs the three
    points. In other words, the new graph will show both the points and the line,
    as in Figure 12-2\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-2: Using* abline()'
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  prefs: []
  type: TYPE_NORMAL
- en: '**263**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: You can add more lines using the lines() function. Though there are many options,
    the two basic arguments to lines() are a vector of *x*-values and a vector of
    *y*-values. These are interpreted as ( *x*, *y*) pairs representing points to
    be added to the current graph, with lines connecting the points.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if X and Y are the vectors (1.5,2.5) and (3,3), you could use
    this call to add a line from (1.5,3) to (2.5,3) to the present graph:'
  prefs: []
  type: TYPE_NORMAL
- en: lines(c(1.5,2.5),c(3,3))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you want the lines to “connect the dots,” but don’t want the dots themselves,
    include type="l" in your call to lines() or to plot(), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: plot(x,y,type="l")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You can use the lty parameter in plot() to specify the type of line, such as
    solid or dashed. To see the types available and their codes, enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: help(par)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***12.1.3 Starting a New Graph While Keeping the Old Ones***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time you call plot(), directly or indirectly, the current graph window
    will be replaced by the new one. If you don’t want that to happen, use the command
    for your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: On Linux systems, call X11().
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: On a Mac, call macintosh().
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, call windows().
  prefs: []
  type: TYPE_NORMAL
- en: For instance, suppose you wish to plot two histograms of vectors X
  prefs: []
  type: TYPE_NORMAL
- en: 'and Y and view them side by side. On a Linux system, you would type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: hist(x)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: x11()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: hist(y)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***12.1.4 Extended Example: Two Density Estimates on the Same Graph***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s plot nonparametric density estimates (these are basically smoothed histograms)
    for two sets of examination scores in the same graph. We use the function density()
    to generate the estimates. Here are the commands we issue:'
  prefs: []
  type: TYPE_NORMAL
- en: d1 = density(testscores$Exam1,from=0,to=100)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d2 = density(testscores$Exam2,from=0,to=100)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**264**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 27](index-291_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 28](index-291_2.png)'
  prefs: []
  type: TYPE_IMG
- en: plot(d1,main="",xlab="")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lines(d2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: First, we compute nonparametric density estimates from the two variables, saving
    them in objects d1 and d2 for later use. We then call plot() to draw the curve
    for exam 1, at which point the plot looks like Figure 12-3\. We then call lines()
    to add exam 2’s curve to the graph, producing Figure 12-4\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-3: Plot of first density*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-4: Addition of second density*'
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  prefs: []
  type: TYPE_NORMAL
- en: '**265**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we asked R to use blank labels for the figure as a whole and for the
    *x*-axis. Otherwise, R would have gotten such labels from d1, which would have
    been specific to exam 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that we needed to plot exam 1 first. The scores there were less diverse,
    so the density estimate was narrower and taller. Had we plotted exam 2, with its
    shorter curve, first, exam 1’s curve would have been too tall for the plot window.
    Here, we first ran the two plots separately to see which was taller, but let’s
    consider a more general situation.
  prefs: []
  type: TYPE_NORMAL
- en: Say we wish to write a broadly usable function that will plot several density
    estimates on the same graph. For this, we would need to automate the process of
    determining which density estimate is tallest. To do so, we would use the fact
    that the estimated density values are contained in the y component of the return
    value from the call to density(). We would then call max() on each density estimate
    and use which.max() to determine which density estimate is the tallest.
  prefs: []
  type: TYPE_NORMAL
- en: The call to plot() both initiates the plot and draws the first curve. (Without
    specifying type="l", only the points would have been plotted.) The call to lines()
    then adds the second curve.
  prefs: []
  type: TYPE_NORMAL
- en: '***12.1.5 Extended Example: More on the Polynomial Regression Example***'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Section 9.1.7, we defined a class "polyreg" that facilitates fitting polynomial
    regression models. Our code there included an implementation of the generic print()
    function. Let’s now add one for the generic plot() function: 1'
  prefs: []
  type: TYPE_NORMAL
- en: polyfit(x,maxdeg) fits all polynomials up to degree maxdeg; y is
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: vector for response variable, x for predictor; creates an object of 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: class "polyreg", consisting of outputs from the various regression 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: models, plus the original data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: polyfit <- function(y,x,maxdeg) {
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: 'pwrs <- powers(x,maxdeg) # form powers of predictor variable'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: 'lmout <- list() # start to build class'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: 'class(lmout) <- "polyreg" # create a new class'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:maxdeg) {
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: lmo <- lm(y ~ pwrs[,1:i])
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: extend the lm class here, with the cross-validated predictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: lmo$fitted.xvvalues <- lvoneout(y,pwrs[,1:i,drop=F])
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: lmout[[i]] <- lmo
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: lmout$x <- x
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: lmout$y <- y
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: return(lmout)
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: 'generic print() for an object fits of class "polyreg": print 21'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: cross-validated mean-squared prediction errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: print.polyreg <- function(fits) {
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: 'maxdeg <- length(fits) - 2 # count lm() outputs only, not $x and $y **266**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(fits$y)
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: tbl <- matrix(nrow=maxdeg,ncol=1)
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: cat("mean squared prediction errors, by degree\n")
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: colnames(tbl) <- "MSPE"
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:maxdeg) {
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: fi <- fits[[i]]
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: errs <- fits$y - fi$fitted.xvvalues
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: spe <- sum(errs^2)
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: tbl[i,1] <- spe/n
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: print(tbl)
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  prefs: []
  type: TYPE_NORMAL
- en: generic plot(); plots fits against raw data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '38'
  prefs: []
  type: TYPE_NORMAL
- en: plot.polyreg <- function(fits) {
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  prefs: []
  type: TYPE_NORMAL
- en: 'plot(fits$x,fits$y,xlab="X",ylab="Y") # plot data points as background 40'
  prefs: []
  type: TYPE_NORMAL
- en: maxdg <- length(fits) - 2
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  prefs: []
  type: TYPE_NORMAL
- en: cols <- c("red","green","blue")
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  prefs: []
  type: TYPE_NORMAL
- en: dg <- curvecount <- 1
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  prefs: []
  type: TYPE_NORMAL
- en: while (dg < maxdg) {
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  prefs: []
  type: TYPE_NORMAL
- en: prompt <- paste("RETURN for XV fit for degree",dg,"or type degree", 45
  prefs: []
  type: TYPE_NORMAL
- en: '"or q for quit ")'
  prefs: []
  type: TYPE_NORMAL
- en: '46'
  prefs: []
  type: TYPE_NORMAL
- en: rl <- readline(prompt)
  prefs: []
  type: TYPE_NORMAL
- en: '47'
  prefs: []
  type: TYPE_NORMAL
- en: dg <- if (rl == "") dg else if (rl != "q") as.integer(rl) else break 48
  prefs: []
  type: TYPE_NORMAL
- en: lines(fits$x,fits[[dg]]$fitted.values,col=cols[curvecount%%3 + 1])
  prefs: []
  type: TYPE_NORMAL
- en: '49'
  prefs: []
  type: TYPE_NORMAL
- en: dg <- dg + 1
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  prefs: []
  type: TYPE_NORMAL
- en: curvecount <- curvecount + 1
  prefs: []
  type: TYPE_NORMAL
- en: '51'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '52'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '53'
  prefs: []
  type: TYPE_NORMAL
- en: '54'
  prefs: []
  type: TYPE_NORMAL
- en: forms matrix of powers of the vector x, through degree dg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '55'
  prefs: []
  type: TYPE_NORMAL
- en: powers <- function(x,dg) {
  prefs: []
  type: TYPE_NORMAL
- en: '56'
  prefs: []
  type: TYPE_NORMAL
- en: pw <- matrix(x,nrow=length(x))
  prefs: []
  type: TYPE_NORMAL
- en: '57'
  prefs: []
  type: TYPE_NORMAL
- en: prod <- x
  prefs: []
  type: TYPE_NORMAL
- en: '58'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 2:dg) {
  prefs: []
  type: TYPE_NORMAL
- en: '59'
  prefs: []
  type: TYPE_NORMAL
- en: prod <- prod * x
  prefs: []
  type: TYPE_NORMAL
- en: '60'
  prefs: []
  type: TYPE_NORMAL
- en: pw <- cbind(pw,prod)
  prefs: []
  type: TYPE_NORMAL
- en: '61'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '62'
  prefs: []
  type: TYPE_NORMAL
- en: return(pw)
  prefs: []
  type: TYPE_NORMAL
- en: '63'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '64'
  prefs: []
  type: TYPE_NORMAL
- en: '65'
  prefs: []
  type: TYPE_NORMAL
- en: finds cross-validated predicted values; could be made much faster via 66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: matrix-update methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '67'
  prefs: []
  type: TYPE_NORMAL
- en: lvoneout <- function(y,xmat) {
  prefs: []
  type: TYPE_NORMAL
- en: '68'
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(y)
  prefs: []
  type: TYPE_NORMAL
- en: '69'
  prefs: []
  type: TYPE_NORMAL
- en: predy <- vector(length=n)
  prefs: []
  type: TYPE_NORMAL
- en: '70'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:n) {
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  prefs: []
  type: TYPE_NORMAL
- en: '**267**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '71'
  prefs: []
  type: TYPE_NORMAL
- en: regress, leaving out ith observation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '72'
  prefs: []
  type: TYPE_NORMAL
- en: lmo <- lm(y[-i] ~ xmat[-i,])
  prefs: []
  type: TYPE_NORMAL
- en: '73'
  prefs: []
  type: TYPE_NORMAL
- en: betahat <- as.vector(lmo$coef)
  prefs: []
  type: TYPE_NORMAL
- en: '74'
  prefs: []
  type: TYPE_NORMAL
- en: the 1 accommodates the constant term
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '75'
  prefs: []
  type: TYPE_NORMAL
- en: predy[i] <- betahat %*% c(1,xmat[i,])
  prefs: []
  type: TYPE_NORMAL
- en: '76'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '77'
  prefs: []
  type: TYPE_NORMAL
- en: return(predy)
  prefs: []
  type: TYPE_NORMAL
- en: '78'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '79'
  prefs: []
  type: TYPE_NORMAL
- en: '80'
  prefs: []
  type: TYPE_NORMAL
- en: polynomial function of x, coefficients cfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '81'
  prefs: []
  type: TYPE_NORMAL
- en: poly <- function(x,cfs) {
  prefs: []
  type: TYPE_NORMAL
- en: '82'
  prefs: []
  type: TYPE_NORMAL
- en: val <- cfs[1]
  prefs: []
  type: TYPE_NORMAL
- en: '83'
  prefs: []
  type: TYPE_NORMAL
- en: prod <- 1
  prefs: []
  type: TYPE_NORMAL
- en: '84'
  prefs: []
  type: TYPE_NORMAL
- en: dg <- length(cfs) - 1
  prefs: []
  type: TYPE_NORMAL
- en: '85'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:dg) {
  prefs: []
  type: TYPE_NORMAL
- en: '86'
  prefs: []
  type: TYPE_NORMAL
- en: prod <- prod * x
  prefs: []
  type: TYPE_NORMAL
- en: '87'
  prefs: []
  type: TYPE_NORMAL
- en: val <- val + cfs[i+1] * prod
  prefs: []
  type: TYPE_NORMAL
- en: '88'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '89'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted, the only new code is plot.polyreg(). For convenience, the code is
    reproduced here:'
  prefs: []
  type: TYPE_NORMAL
- en: generic plot(); plots fits against raw data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: plot.polyreg <- function(fits) {
  prefs: []
  type: TYPE_NORMAL
- en: 'plot(fits$x,fits$y,xlab="X",ylab="Y") # plot data points as background maxdg
    <- length(fits) - 2'
  prefs: []
  type: TYPE_NORMAL
- en: cols <- c("red","green","blue")
  prefs: []
  type: TYPE_NORMAL
- en: dg <- curvecount <- 1
  prefs: []
  type: TYPE_NORMAL
- en: while (dg < maxdg) {
  prefs: []
  type: TYPE_NORMAL
- en: prompt <- paste("RETURN for XV fit for degree",dg,"or type degree",
  prefs: []
  type: TYPE_NORMAL
- en: '"or q for quit ")'
  prefs: []
  type: TYPE_NORMAL
- en: rl <- readline(prompt)
  prefs: []
  type: TYPE_NORMAL
- en: dg <- if (rl == "") dg else if (rl != "q") as.integer(rl) else break lines(fits$x,fits[[dg]]$fitted.values,col=cols[curvecount%%3
    + 1])
  prefs: []
  type: TYPE_NORMAL
- en: dg <- dg + 1
  prefs: []
  type: TYPE_NORMAL
- en: curvecount <- curvecount + 1
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: As before, our implementation of the generic function takes the name of the
    class, which is plot.polyreg() here.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop iterates through the various polynomial degrees. We
  prefs: []
  type: TYPE_NORMAL
- en: cycle through three colors, by setting the vector cols; note the expression
    curvecount %%3 for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '**268**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 29](index-295_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The user can choose either to plot the next sequential degree or select a different
    one. The query, both user prompt and reading of the user’s reply, is done in this
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: rl <- readline(prompt)
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the R string function paste() to assemble a prompt, offering the user
    a choice of plotting the next fitted polynomial, plotting one of a different degree,
    or quitting. The prompt appears in the interactive R window in which we issued
    the plot() call. For instance, after taking the default choice twice, the command
    window looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: plot(lmo)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: RETURN for XV fit for degree 1 or type degree or q for quit
  prefs: []
  type: TYPE_NORMAL
- en: RETURN for XV fit for degree 2 or type degree or q for quit
  prefs: []
  type: TYPE_NORMAL
- en: RETURN for XV fit for degree 3 or type degree or q for quit
  prefs: []
  type: TYPE_NORMAL
- en: The plot window looks like Figure 12-5\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-5: Plotting a polynomial fit*'
  prefs: []
  type: TYPE_NORMAL
- en: '***12.1.6 Adding Points: The points() Function***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The points() function adds a set of ( *x*, *y*) points, with labels for each,
    to the currently displayed graph. For instance, in our first example, suppose
    we entered this command:'
  prefs: []
  type: TYPE_NORMAL
- en: points(testscores$Exam1,testscores$Exam3,pch="+")
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  prefs: []
  type: TYPE_NORMAL
- en: '**269**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The result would be to superimpose onto the current graph the points of the
    exam scores from that example, using plus signs (+) to mark them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with most of the other graphics functions, there are many options, such
    as point color and background color. For instance, if you want a yellow background,
    type this command:'
  prefs: []
  type: TYPE_NORMAL
- en: par(bg="yellow")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now your graphs will have a yellow background, until you specify
  prefs: []
  type: TYPE_NORMAL
- en: otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with other functions, to explore the myriad of options, type this:'
  prefs: []
  type: TYPE_NORMAL
- en: help(par)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***12.1.7 Adding a Legend: The legend() Function***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The legend() function is used, not surprisingly, to add a legend to a multi-curve
    graph. This could tell the viewer something like, “The green curve is for the
    men, and the red curve displays the data for the women.” Type the following to
    see some nice examples:'
  prefs: []
  type: TYPE_NORMAL
- en: example(legend)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***12.1.8 Adding Text: The text() Function***'
  prefs: []
  type: TYPE_NORMAL
- en: Use the text() function to place some text anywhere in the current graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: text(2.5,4,"abc")
  prefs: []
  type: TYPE_NORMAL
- en: This writes the text “abc” at the point (2.5,4) in the graph. The center of
    the string, in this case “b,” would go at that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see a more practical example, let’s add some labels to the curves in our
    exam scores graph, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: text(46.7,0.02,"Exam 1")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: text(12.3,0.008,"Exam 2")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The result is shown in Figure 12-6\.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get a certain string placed exactly where you want it, you may need
    to engage in some trial and error. Or you may find the locator() function to be
    a much quicker way to go, as detailed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**270**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 30](index-297_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Placing text*'
  prefs: []
  type: TYPE_NORMAL
- en: '***12.1.9 Pinpointing Locations: The locator() Function***'
  prefs: []
  type: TYPE_NORMAL
- en: Placing text exactly where you wish can be tricky. You could repeatedly try
    different *x*- and *y*-coordinates until you find a good position, but the locator()
    function can save you a lot of trouble. You simply call the function and then
    click the mouse at the desired spot in the graph. The function returns the *x*-
  prefs: []
  type: TYPE_NORMAL
- en: 'and *y*-coordinates of your click point. Specifically, typing the following
    will tell R that you will click in one place in the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: locator(1)
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click, R will tell you the exact coordinates of the point you clicked.
    Call locator(2) to get the locations of two places, and so on. (Warning: Make
    sure to include the argument.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: hist(c(12,5,13,25,16))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: locator(1)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $x
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 6.239237'
  prefs: []
  type: TYPE_NORMAL
- en: $y
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1.221038'
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  prefs: []
  type: TYPE_NORMAL
- en: '**271**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: This has R draw a histogram and then calls locator() with the argument 1, indicating
    we will click the mouse once. After the click, the function returns a list with
    components x and y, the *x*- and *y*-coordinates of the point where we clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this information to place text, combine it with text():'
  prefs: []
  type: TYPE_NORMAL
- en: text(locator(1),"nv=75")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here, text() was expecting an *x*-coordinate and a *y*-coordinate, specifying
    the point at which to draw the text “nv=75.” The return value of locator() supplied
    those coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '***12.1.10 Restoring a Plot***'
  prefs: []
  type: TYPE_NORMAL
- en: R has no “undo” command. However, if you suspect you may need to undo your next
    step when building a graph, you can save it using recordPlot() and then later
    restore it with replayPlot().
  prefs: []
  type: TYPE_NORMAL
- en: Less formally but more conveniently, you can put all the commands
  prefs: []
  type: TYPE_NORMAL
- en: you’re using to build up a graph in a file and then use source(), or cut and
    paste with the mouse, to execute them. If you change one command, you can redo
    the whole graph by sourcing or copying and pasting your file.
  prefs: []
  type: TYPE_NORMAL
- en: For our current graph, for instance, we could create file named
  prefs: []
  type: TYPE_NORMAL
- en: 'examplot.R with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: d1 = density(testscores$Exam1,from=0,to=100)
  prefs: []
  type: TYPE_NORMAL
- en: d2 = density(testscores$Exam2,from=0,to=100)
  prefs: []
  type: TYPE_NORMAL
- en: plot(d1,main="",xlab="")
  prefs: []
  type: TYPE_NORMAL
- en: lines(d2)
  prefs: []
  type: TYPE_NORMAL
- en: text(46.7,0.02,"Exam 1")
  prefs: []
  type: TYPE_NORMAL
- en: text(12.3,0.008,"Exam 2")
  prefs: []
  type: TYPE_NORMAL
- en: 'If we decide that the label for exam 1 was a bit too far to the right, we can
    edit the file and then either do the copy-and-paste or execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: source("examplot.R")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**12.2 Customizing Graphs**'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen how easy it is to build simple graphs in stages, starting with plot().
  prefs: []
  type: TYPE_NORMAL
- en: Now you can begin to enhance those graphs, using the many options R
  prefs: []
  type: TYPE_NORMAL
- en: provides.
  prefs: []
  type: TYPE_NORMAL
- en: '***12.2.1 Changing Character Sizes: The cex Option***'
  prefs: []
  type: TYPE_NORMAL
- en: The cex (for *character expand*) function allows you to expand or shrink characters
    within a graph, which can be very useful. You can use it as a named **272**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'parameter in various graphing functions. For instance, you may wish to draw
    the text “abc” at some point, say (2.5,4), in your graph but with a larger font,
    in order to call attention to this particular text. You could do this by typing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: text(2.5,4,"abc",cex = 1.5)
  prefs: []
  type: TYPE_NORMAL
- en: This prints the same text as in our earlier example but with characters 1.5
    times the normal size.
  prefs: []
  type: TYPE_NORMAL
- en: '***12.2.2 Changing the Range of Axes: The xlim and ylim Options***'
  prefs: []
  type: TYPE_NORMAL
- en: You may wish to have the ranges on the *x*- and *y*-axes of your plot be broader
    or narrower than the default. This is especially useful if you will be displaying
    several curves in the same graph.
  prefs: []
  type: TYPE_NORMAL
- en: You can adjust the axes by specifying the xlim and/or ylim parameters in your
    call to plot() or points(). For example, ylim=c(0,90000) specifies a range on
    the *y*-axis of 0 to 90,000\.
  prefs: []
  type: TYPE_NORMAL
- en: If you have several curves and do not specify xlim and/or ylim, you should draw
    the tallest curve first so there is room for all of them. Otherwise, R will fit
    the plot to the first one your draw and then cut off taller ones at the top!
  prefs: []
  type: TYPE_NORMAL
- en: 'We took this approach earlier, when we plotted two density estimates on the
    same graph (Figures 12-3 and 12-4). Instead, we could have first found the highest
    values of the two density estimates. For d1, we find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: d1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Call:'
  prefs: []
  type: TYPE_NORMAL
- en: density.default(x = testscores$Exam1, from = 0, to = 100)
  prefs: []
  type: TYPE_NORMAL
- en: 'Data: testscores$Exam1 (39 obs.);'
  prefs: []
  type: TYPE_NORMAL
- en: Bandwidth 'bw' = 6.967
  prefs: []
  type: TYPE_NORMAL
- en: x
  prefs: []
  type: TYPE_NORMAL
- en: y
  prefs: []
  type: TYPE_NORMAL
- en: Min.
  prefs: []
  type: TYPE_NORMAL
- en: ': 0'
  prefs: []
  type: TYPE_NORMAL
- en: Min.
  prefs: []
  type: TYPE_NORMAL
- en: :1.423e-07
  prefs: []
  type: TYPE_NORMAL
- en: '1st Qu.: 25'
  prefs: []
  type: TYPE_NORMAL
- en: 1st Qu.:1.629e-03
  prefs: []
  type: TYPE_NORMAL
- en: 'Median : 50'
  prefs: []
  type: TYPE_NORMAL
- en: Median :9.442e-03
  prefs: []
  type: TYPE_NORMAL
- en: Mean
  prefs: []
  type: TYPE_NORMAL
- en: ': 50'
  prefs: []
  type: TYPE_NORMAL
- en: Mean
  prefs: []
  type: TYPE_NORMAL
- en: :9.844e-03
  prefs: []
  type: TYPE_NORMAL
- en: '3rd Qu.: 75'
  prefs: []
  type: TYPE_NORMAL
- en: 3rd Qu.:1.756e-02
  prefs: []
  type: TYPE_NORMAL
- en: Max.
  prefs: []
  type: TYPE_NORMAL
- en: :100
  prefs: []
  type: TYPE_NORMAL
- en: Max.
  prefs: []
  type: TYPE_NORMAL
- en: :2.156e-02
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the largest y-value is 0.022\. For d2, it was only 0.017\. That means we
    should have plenty of room if we set ylim at 0.03\. Here is how we could draw
    the two plots on the same picture:'
  prefs: []
  type: TYPE_NORMAL
- en: plot(c(0, 100), c(0, 0.03), type = "n", xlab="score", ylab="density")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lines(d2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lines(d1)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Graphics
  prefs: []
  type: TYPE_NORMAL
- en: '**273**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 31](index-300_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 32](index-300_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First we drew the bare-bones plot—just axes without innards, as shown in Figure
    12-7\. The first two arguments to plot() give xlim and ylim, so that the lower
    and upper limits on the Y axis will be 0 and 0.03\. Calling lines() twice then
    fills in the graph, yielding Figures 12-8 and 12-9\. (Either of the two lines()
    calls could come first, as we’ve left enough room.)
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-7: Axes only*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-8: Addition of* d2'
  prefs: []
  type: TYPE_NORMAL
- en: '**274**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 33](index-301_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-9: Addition of* d1'
  prefs: []
  type: TYPE_NORMAL
- en: '***12.2.3 Adding a Polygon: The polygon() Function***'
  prefs: []
  type: TYPE_NORMAL
- en: You can use polygon() to draw arbitrary polygonal objects. For example, the
    following code draws the graph of the function *f* ( *x*) = 1 *− e−x* and then
    adds a rectangle that approximates the area under the curve from *x* = 1.2 to
    *x* = 1.4\.
  prefs: []
  type: TYPE_NORMAL
- en: f <- function(x) return(1-exp(-x))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: curve(f,0,2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: polygon(c(1.2,1.4,1.4,1.2),c(0,0,f(1.3),f(1.3)),col="gray") The result is shown
    in Figure 12-10\.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the call to polygon() here, the first argument is the set of *x*-coordinates
    for the rectangle, and the second argument specifies the *y*-coordinates. The
    third argument specifies that the rectangle in this case should be shaded in solid
    gray.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, we could use the density argument to fill the rectangle
    with striping. This call specifies 10 lines per inch:'
  prefs: []
  type: TYPE_NORMAL
- en: polygon(c(1.2,1.4,1.4,1.2),c(0,0,f(1.3),f(1.3)),density=10)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Graphics
  prefs: []
  type: TYPE_NORMAL
- en: '**275**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 34](index-302_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-10: Rectangular area strip*'
  prefs: []
  type: TYPE_NORMAL
- en: '***12.2.4 Smoothing Points: The lowess() and loess() Functions***'
  prefs: []
  type: TYPE_NORMAL
- en: Just plotting a cloud of points, connected or not, may give you nothing but
    an uninformative mess. In many cases, it is better to smooth out the data by fitting
    a nonparametric regression estimator such as lowess().
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do that for our test score data. We’ll plot the scores of exam 2
  prefs: []
  type: TYPE_NORMAL
- en: 'against those of exam 1:'
  prefs: []
  type: TYPE_NORMAL
- en: plot(testscores)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lines(lowess(testscores))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The result is shown in Figure 12-11\.
  prefs: []
  type: TYPE_NORMAL
- en: A newer alternative to lowess() is loess(). The two functions are similar but
    have different defaults and other options. You need some advanced knowledge of
    statistics to appreciate the differences. Use whichever you find gives better
    smoothing.
  prefs: []
  type: TYPE_NORMAL
- en: '***12.2.5 Graphing Explicit Functions***'
  prefs: []
  type: TYPE_NORMAL
- en: Say you want to plot the function *g*( *t*) = ( *t* 2 + 1)0 *.* 5 for t between
    0 and 5\.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could use the following R code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'g <- function(t) { return (t^2+1)^0.5 } # define g()'
  prefs: []
  type: TYPE_NORMAL
- en: 'x <- seq(0,5,length=10000) # x = [0.0004, 0.0008, 0.0012,..., 5]'
  prefs: []
  type: TYPE_NORMAL
- en: 'y <- g(x) # y = [g(0.0004), g(0.0008), g(0.0012), ..., g(5)]'
  prefs: []
  type: TYPE_NORMAL
- en: plot(x,y,type="l")
  prefs: []
  type: TYPE_NORMAL
- en: '**276**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 35](index-303_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-11: Smoothing the exam score relation*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But you could avoid some work by using the curve() function, which basically
    uses the same method:'
  prefs: []
  type: TYPE_NORMAL
- en: curve((x^2+1)^0.5,0,5)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you are adding this curve to an existing plot, use the add argument:'
  prefs: []
  type: TYPE_NORMAL
- en: curve((x^2+1)^0.5,0,5,add=T)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The optional argument n has the default value 101, meaning that the function
    will be evaluated at 101 equally spaced points in the specified range of x.
  prefs: []
  type: TYPE_NORMAL
- en: Use just enough points for visual smoothness. If you find 101 is not enough,
    experiment with higher values of n.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use plot(), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: f <- function(x) return((x^2+1)^0.5)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'plot(f,0,5) # the argument must be a function name'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here, the call plot() leads to calling plot.function(), the implementation of
    the generic plot() function for the function class.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the approach is your choice; use whichever one you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: '***12.2.6 Extended Example: Magnifying a Portion of a Curve***'
  prefs: []
  type: TYPE_NORMAL
- en: After you use curve() to graph a function, you may want to “zoom in” on one
    portion of the curve. You could do this by simply calling curve() again on Graphics
  prefs: []
  type: TYPE_NORMAL
- en: '**277**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: the same function but with a restricted *x* range. But suppose you wish to display
    the original plot and the close-up one in the same picture. Here, we will develop
    a function, which we’ll name inset(), to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to avoid redoing the work that curve() did in plotting the original
    graph, we will modify its code slightly to save that work, via a return value.
    We can do this by taking advantage of the fact that you can easily inspect the
    code of R functions written in R (as opposed to the fundamental R functions written
    in C), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: curve
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: function (expr, from = NULL, to = NULL, n = 101, add = FALSE,
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: type = "l", ylab = NULL, log = NULL, xlim = NULL, ...)
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: sexpr <- substitute(expr)
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: if (is.name(sexpr)) {
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '...lots of lines omitted here...'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: x <- if (lg != "" && "x" %in% strsplit(lg, NULL)[[1]]) {
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: if (any(c(from, to) <= 0))
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: stop("'from' and 'to' must be > 0 with log=\"x\"") 11
  prefs: []
  type: TYPE_NORMAL
- en: exp(seq.int(log(from), log(to), length.out = n))
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: else seq.int(from, to, length.out = n)
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: y <- eval(expr, envir = list(x = x), enclos = parent.frame())
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: if (add)
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: lines(x, y, type = type, ...)
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: else plot(x, y, type = type, ylab = ylab, xlim = xlim, log = lg, ...) 18
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: The code forms vectors x and y, consisting of the *x*- and *y*-coordinates of
    the curve to be plotted, at n equally spaced points in the range of *x*. Since
    we’ll make use of those in inset(), let’s modify this code to return x and y.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the modified version, which we’ve named crv():'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: crv
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: function (expr, from = NULL, to = NULL, n = 101, add = FALSE,
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: type = "l", ylab = NULL, log = NULL, xlim = NULL, ...)
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: sexpr <- substitute(expr)
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: if (is.name(sexpr)) {
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '...lots of lines omitted here...'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: x <- if (lg != "" && "x" %in% strsplit(lg, NULL)[[1]]) {
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: if (any(c(from, to) <= 0))
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: stop("'from' and 'to' must be > 0 with log=\"x\"") 11
  prefs: []
  type: TYPE_NORMAL
- en: exp(seq.int(log(from), log(to), length.out = n))
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: else seq.int(from, to, length.out = n)
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: y <- eval(expr, envir = list(x = x), enclos = parent.frame())
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: if (add)
  prefs: []
  type: TYPE_NORMAL
- en: '**278**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: lines(x, y, type = type, ...)
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: else plot(x, y, type = type, ylab = ylab, xlim = xlim, log = lg, ...) 18
  prefs: []
  type: TYPE_NORMAL
- en: 'return(list(x=x,y=y)) # this is the only modification'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can get to our inset() function.
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 'savexy: list consisting of x and y vectors returned by crv()'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: 'x1,y1,x2,y2: coordinates of rectangular region to be magnified'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: 'x3,y3,x4,y4: coordinates of inset region'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: inset <- function(savexy,x1,y1,x2,y2,x3,y3,x4,y4) {
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: 'rect(x1,y1,x2,y2) # draw rectangle around region to be magnified'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: 'rect(x3,y3,x4,y4) # draw rectangle around the inset'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: get vectors of coordinates of previously plotted points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: savex <- savexy$x
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: savey <- savexy$y
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: get subscripts of xi our range to be magnified
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(savex)
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: xvalsinrange <- which(savex >= x1 & savex <= x2)
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: yvalsforthosex <- savey[xvalsinrange]
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: check that our first box contains the entire curve for that X range 15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: if (any(yvalsforthosex < y1 | yvalsforthosex > y2)) {
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: print("Y value outside first box")
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: return()
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: record some differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: x2mnsx1 <- x2 - x1
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: x4mnsx3 <- x4 - x3
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: y2mnsy1 <- y2 - y1
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: y4mnsy3 <- y4 - y3
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: for the ith point in the original curve, the function plotpt() will 25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: calculate the position of this point in the inset curve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: plotpt <- function(i) {
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: newx <- x3 + ((savex[i] - x1)/x2mnsx1) * x4mnsx3
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: newy <- y3 + ((savey[i] - y1)/y2mnsy1) * y4mnsy3
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: return(c(newx,newy))
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: newxy <- sapply(xvalsinrange,plotpt)
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: lines(newxy[1,],newxy[2,])
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try it out.
  prefs: []
  type: TYPE_NORMAL
- en: xyout <- crv(exp(-x)*sin(1/(x-1.5)),0.1,4,n=5001)
  prefs: []
  type: TYPE_NORMAL
- en: inset(xyout,1.3,-0.3,1.47,0.3, 2.5,-0.3,4,-0.1)
  prefs: []
  type: TYPE_NORMAL
- en: The resulting plot looks like Figure 12-12\.
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  prefs: []
  type: TYPE_NORMAL
- en: '**279**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 36](index-306_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-12: Adding an inset graph*'
  prefs: []
  type: TYPE_NORMAL
- en: '**12.3 Saving Graphs to Files**'
  prefs: []
  type: TYPE_NORMAL
- en: The R graphics display can consist of various graphics devices. The default
    device is the screen. If you want to save a graph to a file, you must set up another
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through the basics of R graphics devices first to introduce R
  prefs: []
  type: TYPE_NORMAL
- en: graphics device concepts, and then discuss a second approach that is much more
    direct and convenient.
  prefs: []
  type: TYPE_NORMAL
- en: '***12.3.1 R Graphics Devices***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s open a file:'
  prefs: []
  type: TYPE_NORMAL
- en: pdf("d12.pdf")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This opens the file *d12.pdf*. We now have two devices open, as we can confirm:'
  prefs: []
  type: TYPE_NORMAL
- en: dev.list()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: X11 pdf
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '**280**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The screen is named X11 when R runs on Linux. (It’s named windows on Windows
    systems.) It is device number 2 here. Our PDF file is device number 3\. Our active
    device is the PDF file:'
  prefs: []
  type: TYPE_NORMAL
- en: dev.cur()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: pdf
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: All graphics output will now go to this file instead of to the screen. But what
    if we wish to save what’s already on the screen?
  prefs: []
  type: TYPE_NORMAL
- en: '***12.3.2 Saving the Displayed Graph***'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to save the graph currently displayed on the screen is to reestablish
    the screen as the current device and then copy it to the PDF device, which is
    3 in our example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: dev.set(2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: X11
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: dev.copy(which=3)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: pdf
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: But actually, it is best to set up a PDF device as shown earlier and then rerun
    whatever analyses led to the current screen. This is because the copy operation
    can result in distortions due to mismatches between screen devices and file devices.
  prefs: []
  type: TYPE_NORMAL
- en: '***12.3.3 Closing an R Graphics Device***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the PDF file we create is not usable until we close it, which we
    do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: dev.set(3)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: pdf
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: dev.off()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: X11
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: You can also close the device by exiting R, if you’re finished working with
    it. But in future versions of R, this behavior may not exist, so it’s probably
    better to proactively close.
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  prefs: []
  type: TYPE_NORMAL
- en: '**281**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 37](index-308_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**12.4 Creating Three-Dimensional Plots**'
  prefs: []
  type: TYPE_NORMAL
- en: R offers a number of functions to plot data in three dimensions such as persp()
    and wireframe(), which draw surfaces, and cloud(), which draws three-dimensional
    scatter plots. Here, we’ll look at a simple example that uses wireframe().
  prefs: []
  type: TYPE_NORMAL
- en: library(lattice)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a <- 1:10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b <- 1:15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: eg <- expand.grid(x=a,y=b)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: eg$z <- eg$x^2 + eg$x * eg$y
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: wireframe(z ~ x+y, eg)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: First, we load the lattice library. Then the call to expand.grid() creates a
    data frame, consisting of two columns named x and y, in all possible combinations
    of the values of the two inputs. Here, a and b had 10 and 15 values, respectively,
    so the resulting data frame will have 150 rows. (Note that the data frame that
    is input to wireframe() does not need to be created by expand.grid().)
  prefs: []
  type: TYPE_NORMAL
- en: We then added a third column, named z, as a function of the first two columns.
    Our call to wireframe() creates the graph. The arguments, given in regression
    model form, specify that z is to be graphed against x and y. Of course, z, x,
    and y refer to names of columns in eg. The result is shown in Figure 12-13\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-13: Example of using* wireframe()'
  prefs: []
  type: TYPE_NORMAL
- en: '**282**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: All the points are connected as a surface (like connecting points by lines in
    two dimensions). In contrast, with cloud(), the points are isolated.
  prefs: []
  type: TYPE_NORMAL
- en: For wireframe(), the ( *x*, *y*) pairs must form a rectangular grid, though
    not necessarily be evenly spaced.
  prefs: []
  type: TYPE_NORMAL
- en: The three-dimensional plotting functions have many different options.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a nice one for wireframe() is shade=T, which makes the data easier
    to see. Many functions, some with elaborate options, and whole new graphics packages
    work at a higher (read “more convenient and powerful”) level of abstraction than
    R’s base graphics package. For more information, refer to the books cited in footnote
    1 at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  prefs: []
  type: TYPE_NORMAL
- en: '**283**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 38](index-311_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**13**'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEBUGGING**'
  prefs: []
  type: TYPE_NORMAL
- en: Programmers often find that they spend
  prefs: []
  type: TYPE_NORMAL
- en: more time debugging a program than
  prefs: []
  type: TYPE_NORMAL
- en: actually writing it. Good debugging skills
  prefs: []
  type: TYPE_NORMAL
- en: are invaluable. In this chapter, we’ll discuss
  prefs: []
  type: TYPE_NORMAL
- en: debugging in R.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.1 Fundamental Principles of Debugging**'
  prefs: []
  type: TYPE_NORMAL
- en: Beware of bugs in the above code; I have only proved it correct,
  prefs: []
  type: TYPE_NORMAL
- en: not tried it.
  prefs: []
  type: TYPE_NORMAL
- en: —Donald Knuth, pioneer of computer science
  prefs: []
  type: TYPE_NORMAL
- en: Though debugging is an art rather than a science, it involves some fundamental
    principles. Here, we’ll look at some debugging best practices.
  prefs: []
  type: TYPE_NORMAL
- en: '***13.1.1 The Essence of Debugging: The Principle of Confirmation***'
  prefs: []
  type: TYPE_NORMAL
- en: As Pete Salzman and I said in our book on debugging, *The Art of Debugging,*
    *with GDB, DDD, and Eclipse* (No Starch Press, 2008), the principle of confirmation
    is the essence of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Fixing a buggy program is a process of confirming, one by one, that the many
    things you *believe* to be true about the code actually *are* true. When you find
    that one of your assumptions is *not* true, you have found a clue to the location
    (if not the exact nature) of
  prefs: []
  type: TYPE_NORMAL
- en: a bug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of saying this is, “Surprises are good!” For example, say you have
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: x <- y^2 + 3*g(z,2)
  prefs: []
  type: TYPE_NORMAL
- en: w <- 28
  prefs: []
  type: TYPE_NORMAL
- en: if (w+q > 0) u <- 1 else v <- 10
  prefs: []
  type: TYPE_NORMAL
- en: Do you think the value of your variable x should be 3 after x is assigned?
  prefs: []
  type: TYPE_NORMAL
- en: Confirm it! Do you think the else will be executed, not the if on that third
    line? Confirm it!
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, one of these assertions that you are so sure of will turn out to
    not confirm. Then you will have pinpointed the likely location of the error, thus
    enabling you to focus on the nature of the error.
  prefs: []
  type: TYPE_NORMAL
- en: '***13.1.2 Start Small***'
  prefs: []
  type: TYPE_NORMAL
- en: At least at the beginning of the debugging process, stick to small, simple test
    cases. Working with large data objects may make it harder to think about the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you should eventually test your code on large, complicated cases,
    but start small.
  prefs: []
  type: TYPE_NORMAL
- en: '***13.1.3 Debug in a Modular, Top-Down Manner***'
  prefs: []
  type: TYPE_NORMAL
- en: Most good software developers agree that code should be written in a modular
    manner. Your first-level code should not be longer than, say, a dozen lines, with
    much of it consisting of function calls. And those functions should not be too
    lengthy and should call other functions if necessary. This makes the code easier
    to organize during the writing stage and easier for others to understand when
    it comes time for the code to be extended.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should debug in a top-down manner, too. Suppose that you have set the debug
    status of your function f() (that is, you have called debug(f), to be explained
    shortly) and f() contains this line:'
  prefs: []
  type: TYPE_NORMAL
- en: y <- g(x,8)
  prefs: []
  type: TYPE_NORMAL
- en: You should take an “innocent until proven guilty” approach to g(). Do *not*
    call debug(g) yet. Execute that line and see if g() returns the value you expect.
    If it does, then you’ve just avoided the time-consuming process of single-stepping
    through g(). If g() returns the wrong value, then now is the time to call debug(g).
  prefs: []
  type: TYPE_NORMAL
- en: '**286**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***13.1.4 Antibugging***'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may adopt some “antibugging” strategies as well. Suppose you have a section
    of code in which a variable x should be positive. You could insert this line:'
  prefs: []
  type: TYPE_NORMAL
- en: stopifnot(x > 0)
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is a bug earlier in the code that renders x equal to, say, *−* 12,
    the call to stopifnot() will bring things to a halt right there, with an error
    message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Error: x > 0 is not TRUE'
  prefs: []
  type: TYPE_NORMAL
- en: (C programmers may notice the similarity to C’s assert statement.)
  prefs: []
  type: TYPE_NORMAL
- en: After fixing a bug and testing the new code, you might want to keep that code
    handy so you can check later that the bug did not somehow reappear.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.2 Why Use a Debugging Tool?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the old days, programmers would perform the debugging confirmation process
    by temporarily inserting print statements into their code and rerunning the program
    to see what printed out. For example, to confirm that x = 3 in our previous code,
    we would insert into our code a statement that printed the value of x and do something
    similar for the if-else, like this: x <- y^2 + 3*g(z,2)'
  prefs: []
  type: TYPE_NORMAL
- en: cat("x =",x,"\n")
  prefs: []
  type: TYPE_NORMAL
- en: w <- 28
  prefs: []
  type: TYPE_NORMAL
- en: if (w+q > 0) {
  prefs: []
  type: TYPE_NORMAL
- en: u <- 1
  prefs: []
  type: TYPE_NORMAL
- en: print("the 'if' was done")
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: v <- 10
  prefs: []
  type: TYPE_NORMAL
- en: print("the 'else' was done")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: We would rerun the program and inspect the feedback printed out. We would then
    remove the print statements and put in new ones to track down the next bug.
  prefs: []
  type: TYPE_NORMAL
- en: This manual process is fine for one or two cycles, but it gets really tedious
    during a long debugging session. And worse, all that editing work distracts your
    attention, making it harder to concentrate on finding the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**287**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: So, debugging by inserting print statements into your code is slow, cum-bersome,
    and distracting. If you are serious about programming in any particular language,
    you should seek a good debugging tool for that language.
  prefs: []
  type: TYPE_NORMAL
- en: Using a debugging tool will make it much easier to query the values of variables,
    check whether the if or the else gets executed, and so on. Moreover, if your bug
    causes an execution error, debugging tools can analyze it for you, possibly providing
    major clues as to the source of the error. All of this will increase your productivity
    substantially.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.3 Using R Debugging Facilities**'
  prefs: []
  type: TYPE_NORMAL
- en: The R base package includes a number of debugging facilities, and more functional
    debugging packages are also available. We’ll discuss both the base facilities
    and other packages, and our extended example will present a fully detailed debugging
    session.
  prefs: []
  type: TYPE_NORMAL
- en: '***13.3.1 Single-Stepping with the debug() and browser() Functions***'
  prefs: []
  type: TYPE_NORMAL
- en: The core of R’s debugging facility consists of the *browser*. It allows you
    to single-step through your code, line by line, taking a look around as you go.
  prefs: []
  type: TYPE_NORMAL
- en: You can invoke the browser through a call to either the debug() or browser()
    function.
  prefs: []
  type: TYPE_NORMAL
- en: R’s debugging facility is specific to individual functions. If you believe there
    is a bug in your function f(), you can make the call debug(f) to set the debug
    status for the function f(). This means that from that point onward, each time
    you call the function, you will automatically enter the browser at the beginning
    of the function. Calling undebug(f) will unset the debug status of the function
    so that entry to the function will no longer invoke the browser.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you place a call to browser() at some line within f(),
    the browser will be invoked only when execution reaches that line. You then can
    single-step through your code until you exit the function. If you believe the
    bug’s location is not near the beginning of the function, you probably don’t want
    to be single-stepping from the beginning, so this approach is more direct.
  prefs: []
  type: TYPE_NORMAL
- en: Readers who have used C debuggers such as GDB (the GNU debugger)
  prefs: []
  type: TYPE_NORMAL
- en: will find similarity here, but some aspects will come as a surprise. As noted,
    for instance, debug() is called on the function level, not on the overall program
    level. If you believe you have bugs in several of your functions, you’ll need
    to call debug() on each one.
  prefs: []
  type: TYPE_NORMAL
- en: It can become tedious to call debug(f) and then undebug(f) when you just want
    to go through one debugging session for f(). Starting with R 2.10, one can now
    call debugonce() instead; calling debugonce(f) puts f() into debugging status
    the first time you execute it, but that status is reversed immediately upon exit
    from the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**288**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***13.3.2 Using Browser Commands***'
  prefs: []
  type: TYPE_NORMAL
- en: While you are in the browser, the prompt changes from *>* to Browse[d] *>* .
  prefs: []
  type: TYPE_NORMAL
- en: '(Here, d is the depth of the call chain.) You may submit any of the following
    commands at that prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'n (for *next*): Tells R to execute the next line and then pause again. Hitting
    ENTER causes this action, too.'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'c (for *continue*): This is like n, except that several lines of code may be
    executed before the next pause. If you are currently in a loop, this command will
    result in the remainder of the loop being executed and then pausing upon exit
    from the loop. If you are in a function but not in a loop, the remainder of the
    function will be executed before the next pause.'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'Any R command: While in the browser, you are still in R’s interactive mode
    and thus can query the value of, say, x by simply typing x. Of course, if you
    have a variable with the same name as a browser command, you must explicitly call
    something like print(), as in print(n).'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'where: This prints a *stack trace*. It displays what sequence of function calls
    led execution to the current location.'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'Q: This quits the browser, bringing you back to R’s main interactive mode.'
  prefs: []
  type: TYPE_NORMAL
- en: '***13.3.3 Setting Breakpoints***'
  prefs: []
  type: TYPE_NORMAL
- en: Calling debug(f) places a call to browser() at the beginning of f(). However,
    this may be too coarse a tool in some cases. If you suspect that the bug is in
    the middle of the function, it’s wasteful to trudge through all the intervening
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to set *breakpoints* at certain key locations of your code—
  prefs: []
  type: TYPE_NORMAL
- en: places where you want execution to be paused. How can this be done in R?
  prefs: []
  type: TYPE_NORMAL
- en: You can call browser directly or use the setBreakpoint() function (with R version
    2.10 and later).
  prefs: []
  type: TYPE_NORMAL
- en: '**13.3.3.1 Calling browser() Directly**'
  prefs: []
  type: TYPE_NORMAL
- en: You can set a breakpoint by simply inserting calls to browser() at the places
    of interest in your code. This has the effect, essentially, of setting breakpoints
    there.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make invoking the browser conditional so that it is entered only in
    specified situations. Use the expr argument to define those situations. For instance,
    suppose you suspect that your bug arises only when a certain variable s is larger
    than 1\. You could use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: browser(s > 1)
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**289**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The browser will be invoked only if s is larger than 1\. The following would
    have the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: if (s > 1) browser()
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling the browser directly, rather than entering the debugger via debug()
    is very useful in situations in which you have a loop with many iterations and
    the bug surfaces only after, say, the 50th iteration. If the loop index is i,
    then you could write this:'
  prefs: []
  type: TYPE_NORMAL
- en: if (i > 49) browser()
  prefs: []
  type: TYPE_NORMAL
- en: That way, you would avoid the tedium of stepping through the first 49
  prefs: []
  type: TYPE_NORMAL
- en: iterations!
  prefs: []
  type: TYPE_NORMAL
- en: '**13.3.3.2 Using the setBreakpoint() Function**'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with R 2.10, you can use setBreakpoint() in the format
  prefs: []
  type: TYPE_NORMAL
- en: setBreakpoint( *filename,linenumber*)
  prefs: []
  type: TYPE_NORMAL
- en: This will result in browser() being called at line *linenumber* of our source
    file *filename*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is especially useful when you are in the midst of using the debugger,
    single-stepping through code. Say you are currently at line 12 of your source
    file *x.R* and want to have a breakpoint at line 28\. Instead of exiting the debugger,
    adding a call to browser() at line 28, and then re-entering the function, you
    could simply type this:'
  prefs: []
  type: TYPE_NORMAL
- en: setBreakpoint("x.R",28)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You could then resume execution within the debugger, say by issuing the c command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The setBreakpoint() function works by calling the trace() function, discussed
    in the next section. Thus, to cancel the breakpoint, you cancel the trace. For
    instance, if we had called setBreakpoint() at a line in the function g(), we would
    cancel the breakpoint by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: untrace(g)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can call setBreakpoint() whether or not you are currently in the debugger.
    If you are not currently running the debugger and you execute the affected function
    and hit the breakpoint during that execution, you will be put into the browser
    automatically. This is similar to the case of browser(), but using this approach,
    you save yourself the trouble of changing your code via your text editor.
  prefs: []
  type: TYPE_NORMAL
- en: '**290**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***13.3.4 Tracking with the trace() Function***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The trace() function is flexible and powerful, though it takes some initial
    effort to learn. We will discuss some of the simpler usage forms here, beginning
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: trace(f,t)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This call instructs R to call the function t() every time we enter the function
    f(). For instance, say we wish to set a breakpoint at the beginning of the function
    gy(). We could use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: trace(gy,browser)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This has the same effect as placing the command browser() in our source code
    for gy(), but it’s quicker and more convenient than inserting such a line, saving
    the file, and rerunning source() to load in the new version of the file. Calling
    trace() does *not* change your source file, though it does change a temporary
    version of your file maintained by R. It would also be quicker and more convenient
    to undo, by simply running untrace:'
  prefs: []
  type: TYPE_NORMAL
- en: untrace(gy)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can turn tracing on or off globally by calling tracingState(), using the
    argument TRUE to turn it on or FALSE to turn it off.
  prefs: []
  type: TYPE_NORMAL
- en: '***13.3.5 Performing Checks After a Crash with the traceback() and***'
  prefs: []
  type: TYPE_NORMAL
- en: '***debugger() Functions***'
  prefs: []
  type: TYPE_NORMAL
- en: Say your R code crashes when you are not running the debugger. There is still
    a debugging tool available to you after the fact. You can do a “post-mortem” by
    simply calling traceback(). It will tell you in which function the problem occurred
    and the call chain that led to that function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get a lot more information if you set up R to dump frames in the event
    of a crash:'
  prefs: []
  type: TYPE_NORMAL
- en: options(error=dump.frames)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you’ve done this, then after a crash, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: debugger()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You will then be presented with a choice of levels of function calls to view.
    For each one that you choose, you can take a look at the values of the variables
    there. After browsing through one level, you can return to the debugger() main
    menu by hitting N.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs: []
  type: TYPE_NORMAL
- en: '**291**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can arrange to automatically enter the debugger by writing this code:'
  prefs: []
  type: TYPE_NORMAL
- en: options(error=recover)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note, though, that if you do choose this automatic route, it will whisk you
    into the debugger, even if you simply have a syntax error (not a useful time to
    enter the debugger).
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn off any of this behavior, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: options(error=NULL)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You’ll see a demonstration of this approach in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '***13.3.6 Extended Example: Two Full Debugging Sessions***'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at R’s debugging tools, let’s try using them to find and
    fix code problems. We’ll begin with a simple example and then move on to a more
    complicated one.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.3.6.1 Debugging Finding Runs of Ones**'
  prefs: []
  type: TYPE_NORMAL
- en: 'First recall our extended example of finding runs of 1s in Chapter 2\. Here
    is a buggy version of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: findruns <- function(x,k) {
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(x)
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: runs <- NULL
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:(n-k)) {
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: if (all(x[i:i+k-1]==1)) runs <- c(runs,i)
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: return(runs)
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it on a small test case:'
  prefs: []
  type: TYPE_NORMAL
- en: source("findruns.R")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: findruns(c(1,0,0,1,1,0,1,1,1),2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 3 4 6 7'
  prefs: []
  type: TYPE_NORMAL
- en: The function was supposed to report runs at indices 4, 7, and 8, but it found
    some indices that it shouldn’t have and missed some as well. Something is wrong.
    Let’s enter the debugger and take a look around.
  prefs: []
  type: TYPE_NORMAL
- en: debug(findruns)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: findruns(c(1,0,0,1,1,0,1,1,1),2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'debugging in: findruns(c(1, 0, 0, 1, 1, 0, 1, 1, 1), 2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at findruns.R#1: {'
  prefs: []
  type: TYPE_NORMAL
- en: '**292**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(x)
  prefs: []
  type: TYPE_NORMAL
- en: runs <- NULL
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:(n - k)) {
  prefs: []
  type: TYPE_NORMAL
- en: if (all(x[i:i + k - 1] == 1))
  prefs: []
  type: TYPE_NORMAL
- en: runs <- c(runs, i)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return(runs)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: attr(,"srcfile")
  prefs: []
  type: TYPE_NORMAL
- en: findruns.R
  prefs: []
  type: TYPE_NORMAL
- en: 'So, according to the principle of confirmation, let’s first make sure our test
    vector was received correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> x
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1 0 0 1 1 0 1 1 1'
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good. Let’s step through the code a bit. We hit n a couple of times
    to single-step through the code.
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> n
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at findruns.R#2: n <- length(x)'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> n
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at findruns.R#3: runs <- NULL'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> print(n)
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 9'
  prefs: []
  type: TYPE_NORMAL
- en: Note that after each single step, R tells us which statement would be the *next*
    one to execute. In other words, at the time we executed print(n), we had *not*
    yet executed the assignment of NULL to runs.
  prefs: []
  type: TYPE_NORMAL
- en: Note, too, that although normally you can print out the value of a variable
    by simply typing its name, we could not do so here for our variable n, because
    n is also the abbreviation for the debugger’s next command. Thus, we needed print().
  prefs: []
  type: TYPE_NORMAL
- en: At any rate, we found that the length of our test vector was 9, confirming what
    we knew. Now, let’s single-step some more, getting into the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> n
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at findruns.R#4: for (i in 1:(n - k + 1)) {'
  prefs: []
  type: TYPE_NORMAL
- en: if (all(x[i:i + k - 1] == 1))
  prefs: []
  type: TYPE_NORMAL
- en: runs <- c(runs, i)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> n
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at findruns.R#4: i'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> n
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at findruns.R#5: if (all(x[i:i + k - 1] == 1)) runs <- c(runs, i) Debugging'
  prefs: []
  type: TYPE_NORMAL
- en: '**293**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Since k is 2—that is, we are checking for runs of length 2— the if() statement
    should be checking the first two elements of x, which are (1,0).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s confirm:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> x[i:i + k - 1]
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0'
  prefs: []
  type: TYPE_NORMAL
- en: So, it did *not* confirm. Let’s check that we have the correct subscript range,
    which should be 1:2\. Is it?
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> i:i + k - 1
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 2'
  prefs: []
  type: TYPE_NORMAL
- en: Also wrong. Well, how about i and k? They should be 1 and 2, respectively. Are
    they?
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> i
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> k
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 2'
  prefs: []
  type: TYPE_NORMAL
- en: Well, those do confirm. Thus, our problem must be with the expression i:i +
    k - 1\. After some thought, we realize there is an operator precedence problem
    there, and we correct it to i:(i + k - 1).
  prefs: []
  type: TYPE_NORMAL
- en: Is it okay now?
  prefs: []
  type: TYPE_NORMAL
- en: source("findruns.R")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: findruns(c(1,0,0,1,1,0,1,1,1),2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 4 7'
  prefs: []
  type: TYPE_NORMAL
- en: No, as mentioned, it should be (4,7,8).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s set a breakpoint inside the loop and take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: setBreakpoint("findruns.R",5)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '/home/nm/findruns.R#5:'
  prefs: []
  type: TYPE_NORMAL
- en: 'findruns step 4,4,2 in <environment: R_GlobalEnv>'
  prefs: []
  type: TYPE_NORMAL
- en: findruns(c(1,0,0,1,1,0,1,1,1),2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: findruns.R#5
  prefs: []
  type: TYPE_NORMAL
- en: 'Called from: eval(expr, envir, enclos)'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[1]> x[i:(i+k-1)]
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1 0'
  prefs: []
  type: TYPE_NORMAL
- en: Good, we’re dealing with the first two elements of the vector, so our bug fix
    is working so far. Let’s look at the second iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Browse[1]> c
  prefs: []
  type: TYPE_NORMAL
- en: findruns.R#5
  prefs: []
  type: TYPE_NORMAL
- en: 'Called from: eval(expr, envir, enclos)'
  prefs: []
  type: TYPE_NORMAL
- en: '**294**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[1]> i
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 2'
  prefs: []
  type: TYPE_NORMAL
- en: Browse[1]> x[i:(i+k-1)]
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0 0'
  prefs: []
  type: TYPE_NORMAL
