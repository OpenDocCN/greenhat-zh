- en: '[1] 123 4 5 6'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: scan("z2.txt")
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Read 4 items
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 123.0 4.2 5.0 6.0'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: scan("z3.txt")
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Error in scan(file, what, nmax, sep, dec, quote, skip, nlines, na.strings,
    : scan() expected ''a real'', got ''abc'''
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: scan("z3.txt",what="")
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**232**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Read 4 items
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "abc" "de" "f" "g"'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: scan("z4.txt",what="")
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Read 4 items
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "abc" "123" "6" "y"'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: In the first call, we got a vector of four integers (though the mode is numeric).
    The second time, since one number was nonintegral, the others were shown as floating-point
    numbers, too.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: In the third case, we got an error. The scan() function has an optional argument
    named what, which specifies mode, defaulting to double mode. So, the nonnumeric
    contents of the file *z3* produced an error. But we then tried again, with what="".
    This assigns a character string to what, indicating that we want character mode.
    (We could have set what to any character string.) The last call worked the same
    way. The first item was a character string, so it treated all the items that followed
    as strings too.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, in typical usage, we would assign the return value of scan() to
    a variable. Here’s an example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: v <- scan("z1.txt")
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'By default, scan() assumes that the items of the vector are separated by *whitespace*,
    which includes blanks, carriage return/line feeds, and horizontal tabs. You can
    use the optional sep argument for other situations. As example, we can set sep
    to the newline character to read in each line as a string, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: x1 <- scan("z3.txt",what="")
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Read 4 items
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: x2 <- scan("z3.txt",what="",sep="\n") Read 3 items
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: x1
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "abc" "de" "f"'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '"g"'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: x2
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "abc" "de f" "g"'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: x1[2]
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "de"'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: x2[2]
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "de f"'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, the strings "de" and "f" were assigned to separate elements
    of x1\. But in the second case, we specified that elements of x2 were to be delineated
    by end-of-line characters, not spaces. Since "de" and "f" are on the same line,
    they are assigned together to x[2].
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: More sophisticated methods for reading files will be presented later in this
    chapter, such as methods to read in a file one line at a time. But if you want
    to read the entire file at once, scan() provides a quick solution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Input/Output
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**233**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use scan() to read from the keyboard by specifying an empty string
    for the filename:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: v <- scan("")
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '1: 12 5 13'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '4: 3 4 5'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '7: 8'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '8:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Read 7 items
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: v
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 12 5 13 3 4 5 8'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are prompted with the index of the next item to be input, and we
    signal the end of input with an empty line.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: If you do not wish scan() to announce the number of items it has read, include
    the argument quiet=TRUE.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '***10.1.2 Using the readline() Function***'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: If you want to read in a single line from the keyboard, readline() is very handy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: w <- readline()
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: abc de f
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: w
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "abc de f"'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, readline() is called with its optional prompt, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'inits <- readline("type your initials: ")'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'type your initials: NM'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: inits
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "NM"'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '***10.1.3 Printing to the Screen***'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.1.3 打印到屏幕***'
- en: 'At the top level of interactive mode, you can print the value of a variable
    or expression by simply typing the variable name or expression. This won’t work
    if you need to print from within the body of a function. In that case, you can
    use the print() function, like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式模式的顶层，您可以通过简单地输入变量名或表达式来打印变量的值或表达式。如果您需要在函数体内部打印，则无法这样做。在这种情况下，您可以使用 print()
    函数，如下所示：
- en: x <- 1:3
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- 1:3
- en: print(x^2)
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print(x^2)
- en: '[1] 1 4 9'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 4 9'
- en: Recall that print() is a *generic* function, so the actual function called will
    depend on the class of the object that is printed. If, for example, the argument
    is of class "table", then the print.table() function will be called.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，print() 是一个 *通用* 函数，因此实际调用的函数将取决于打印的对象的类。例如，如果参数是 "table" 类，则将调用 print.table()
    函数。
- en: '**234**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**234**'
- en: Chapter 10
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter 10
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: It’s a little better to use cat() instead of print(), as the latter can print
    only one expression and its output is numbered, which may be a nuisance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cat() 而不是 print() 会更好一些，因为后者只能打印一个表达式，并且其输出是编号的，这可能会造成不便。
- en: 'Compare the results of the functions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 比较函数的结果：
- en: print("abc")
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("abc")
- en: '[1] "abc"'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "abc"'
- en: cat("abc\n")
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cat("abc\n")
- en: abc
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: abc
- en: Note that we needed to supply our own end-of-line character, "\n", in the call
    to cat(). Without it, our next call would continue to write to the same line.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在调用 cat() 时，我们需要提供自己的换行符，"\n"。如果没有它，我们的下一个调用将继续写入同一行。
- en: 'The arguments to cat() will be printed out with intervening spaces:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: cat() 的参数将以空格分隔打印出来：
- en: x
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x
- en: '[1] 1 2 3'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 2 3'
- en: cat(x,"abc","de\n")
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cat(x,"abc","de\n")
- en: 1 2 3 abc de
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 3 abc de
- en: 'If you don’t want the spaces, set sep to the empty string "", as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想有空间，将 sep 设置为空字符串 ""，如下所示：
- en: cat(x,"abc","de\n",sep="")
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cat(x,"abc","de\n",sep="")
- en: 123abcde
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 123abcde
- en: 'Any string can be used for sep. Here, we use the newline character:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用任何字符串作为 sep。在这里，我们使用换行符：
- en: cat(x,"abc","de\n",sep="\n")
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cat(x,"abc","de\n",sep="\n")
- en: '1'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: abc
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: abc
- en: de
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: de
- en: 'You can even set sep to be a vector of strings, like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以将 sep 设置为字符串向量，如下所示：
- en: x <- c(5,12,13,8,88)
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- c(5,12,13,8,88)
- en: cat(x,sep=c(".",".",".","\n","\n")) 5.12.13.8
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cat(x,sep=c(".",".",".","\n","\n")) 5.12.13.8
- en: '88'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '88'
- en: '**10.2 Reading and Writing Files**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.2 读取和写入文件**'
- en: Now that we’ve covered the basics of I/O, let’s get to some more practical applications
    of reading and writing files. The following sections discuss reading data frames
    or matrices from files, working with text files, accessing files on remote machines,
    and getting file and directory information.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了 I/O 的基础知识，让我们来看看读取和写入文件的一些更实际的应用。以下各节讨论从文件中读取数据框或矩阵、处理文本文件、访问远程机器上的文件以及获取文件和目录信息。
- en: Input/Output
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出
- en: '**235**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**235**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***10.2.1 Reading a Data Frame or Matrix from a File***'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2.1 从文件中读取数据框或矩阵***'
- en: 'In Section 5.1.2, we discussed the use of the function read.table() to read
    in a data frame. As a quick review, suppose the file *z* looks like this: name
    age'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 5.1.2 节中，我们讨论了使用 read.table() 函数读取数据框的使用。作为一个快速回顾，假设文件 *z* 看起来像这样：name age
- en: John 25
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: John 25
- en: Mary 28
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Mary 28
- en: Jim 19
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Jim 19
- en: 'The first line contains an optional header, specifying column names. We could
    read the file this way:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含一个可选的标题，指定列名。我们可以这样读取文件：
- en: z <- read.table("z",header=TRUE)
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z <- read.table("z",header=TRUE)
- en: z
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z
- en: name age
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: name age
- en: 1 John 25
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 1 John 25
- en: 2 Mary 28
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 2 Mary 28
- en: 3 Jim 19
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 3 Jim 19
- en: Note that scan() would not work here, because our file has a mixture of numeric
    and character data (and a header).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，scan() 在这里不会工作，因为我们的文件包含数字和字符数据的混合（以及一个标题）。
- en: There appears to be no direct way of reading in a matrix from a file, but it
    can be done easily with other tools. A simple, quick way is to use scan() to read
    in the matrix row by row. You use the byrow option in the function matrix() to
    indicate that you are defining the elements of the matrix in a row-wise, rather
    than column-wise, manner.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中直接读取矩阵似乎没有直接的方法，但可以使用其他工具轻松完成。一种简单快捷的方法是使用 scan() 逐行读取矩阵。您在 matrix() 函数中使用
    byrow 选项来指示您正在按行定义矩阵的元素，而不是按列定义。
- en: 'For instance, say the file *x* contains a 5-by-3 matrix, stored row-wise: 1
    0 1'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设文件 *x* 包含一个 5 行 3 列的矩阵，按行存储：1 0 1
- en: 1 1 1
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 1 1 1
- en: 1 1 0
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 1 1 0
- en: 1 1 0
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 1 1 0
- en: 0 0 1
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0 1
- en: 'We can read it into a matrix this way:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样将其读入矩阵：
- en: x <- matrix(scan("x"),nrow=5,byrow=TRUE)
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- matrix(scan("x"),nrow=5,byrow=TRUE)
- en: 'This is fine for quick, one-time operations, but for generality, you can use
    read.table(), which returns a data frame, and then convert via as.matrix(). Here
    is a general method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: read.matrix <- function(filename) {
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: as.matrix(read.table(filename))
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '**236**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '***10.2.2 Reading Text Files***'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: In computer literature, there is often a distinction made between *text files*
    and *binary files*. That distinction is somewhat misleading—every file is binary
    in the sense that it consists of 0s and 1s. Let’s take the term *text file* to
    mean a file that consists mainly of ASCII characters or coding for some other
    human language (such as GB for Chinese) and that uses newline characters to give
    humans the perception of lines. The latter aspect will turn out to be central
    here. Nontext files, such as JPEG images or executable program files, are generally
    called *binary files*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use readLines() to read in a text file, either one line at a time or
    in a single operation. For example, suppose we have a file *z1* with the following
    contents:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: John 25
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Mary 28
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Jim 19
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read the file all at once, like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: z1 <- readLines("z1")
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: z1
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "John 25" "Mary 28" "Jim 19"'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Since each line is treated as a string, the return value here is a vector of
    strings—that is, a vector of character mode. There is one vector element for each
    line read, thus three elements here.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can read it in one line at a time. For this, we first need
    to create a connection, as described next.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '***10.2.3 Introduction to Connections***'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '*Connection* is R’s term for a fundamental mechanism used in various kinds
    of I/O operations. Here, it will be used for file access.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'The connection is created by calling file(), url(), or one of several other
    R functions. To see a list of those functions, type this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: ?connection
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So, we can now read in the *z1* file (introduced in the previous section) line
    by line, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: c <- file("z1","r")
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: readLines(c,n=1)
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "John 25"'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: readLines(c,n=1)
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "Mary 28"'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: readLines(c,n=1)
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "Jim 19"'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Input/Output
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '**237**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: readLines(c,n=1)
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: character(0)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: We opened the connection, assigned the result to c, and then read the file one
    line at a time, as specified by the argument n=1\. When R encountered the end
    of file (EOF), it returned an empty result. We needed to set up a connection so
    that R could keep track of our position in the file as we read through it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'We can detect EOF in our code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: c <- file("z","r")
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: while(TRUE) {
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: +
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: rl <- readLines(c,n=1)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: +
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: if (length(rl) == 0) {
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: +
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: print("reached the end")
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: +
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: break
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: +
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '} else print(rl)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: + }
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "John 25"'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "Mary 28"'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "Jim 19"'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "reached the end"'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wish to “rewind”—to start again at the beginning of the file—we can use
    seek():'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: c <- file("z1","r")
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: readLines(c,n=2)
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "John 25" "Mary 28"'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: seek(con=c,where=0)
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 16'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: readLines(c,n=1)
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "John 25"'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The argument where=0 in our call to seek() means that we wish to position the
    file pointer zero characters from the start of the file—in other words, directly
    at the beginning.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The call returns 16, meaning that the file pointer was at position 16
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: before we made the call. That makes sense. The first line consists of "John
    25"
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '*plus* the end-of-line character, for a total of eight characters, and the
    same is true for the second line. So, after reading the first two lines, we were
    at position 16\.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: You can close a connection by calling—what else?—close(). You would use this
    to let the system know that the file you have been writing is complete and should
    now be officially written to disk. As another example, in a client/server relationship
    over the Internet (see Section 10.3.1), a client would use close() to indicate
    to the server that the client is signing off.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '**238**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '***10.2.4 Extended Example: Reading PUMS Census Files***'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The U.S. Census Bureau makes census data available in the form of Public Use
    Microdata Samples (PUMS). The term *microdata* here means that we are dealing
    with raw data and each record is for a real person, as opposed to statistical
    summaries. Data on many, many variables are included.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The data is organized by household. For each unit, there is first a Household
    record, describing the various characteristics of that household, followed by
    one Person record for each person in the household. Character positions 106 and
    107 (with numbering starting at 1) in the Household record state the number of
    Person records for that household. (The number can be very large, since some institutions
    count as households.) To enhance the integrity of the data, character position
    1 contains H or P to confirm that this is a Household or Person record. So, if
    you read an H record, and it tells you there are three people in the household,
    then the following three records should be P records, followed by another H record;
    if not, you’ve encountered an error.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'As our test file, we’ll take the first 1,000 records of the year 2000 1 percent
    sample. The first few records look like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: H000019510649
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '06010'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 99979997 70
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '631973'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '15758'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 59967658436650000012000000 0 0 0 0 0 0 0 0 0 0 0 0 0
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 0 0 0
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 0 0
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 0 0000 0
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 0 0 0
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '00000000000000000000000000000'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '00000000000000000000000000'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: P00001950100010923000420190010110000010147050600206011099999904200000 0040010000
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 00300280
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 28600 70
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '9997'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '9997202020202020220000040000000000000006000000'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 00000 00
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '0000'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 00000000000000000132241057904MS
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 476041-20311010310
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 07000049010000000000900100000100000100000100000010000001000139010000490000
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: H000040710649
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '06010'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 99979997 70
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '631973'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '15758'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 599676584365300800200000300106060503010101010102010 01200006000000100001
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 00600020 0
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 0 0
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 0 0000 0
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 0 0 0
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '02000102010102200000000010750'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '02321125100004000000040000'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: P00004070100005301000010380010110000010147030400100009005199901200000 0006010000
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '00100000'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 00000 00
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '0000'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '0000202020202020220000040000000000000001000060'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 06010 70
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '9997'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '99970101004900100000001018703221'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 770051-10111010500
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '40004000000000000000000000000000000000000000000000000000004000000040000349'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: P00004070200005303011010140010110000010147050000204004005199901200000 0006010000
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '00100000'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 00000 00
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '0000'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 000020202020 0 0200000000000000000000000050000
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 00000 00
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '0000'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 000000000000000000000000000000000000000000-00000000000
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '000'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 00000000349
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: H000061010649
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '06010'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 99979997 70
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '631973'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '15758'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 599676584360801190100000200204030502010101010102010 00770004800064000001
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 0 030
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 0 0
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 0 0340 00660000000170 0
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 06010000000004410039601000000
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 00021100000004940000000000
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The records are very wide and thus wrap around. Each one occupies
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: four lines on the page here.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Input/Output
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '**239**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a function called extractpums() to read in a PUMS file and create
    a data frame from its Person records. The user specifies the filename and lists
    fields to extract and names to assign to those fields.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: We also want to retain the household serial number. This is good to have because
    data for persons in the same household may be correlated and we may want to add
    that aspect to our statistical model. Also, the household data may provide important
    covariates. (In the latter case, we would want to retain the covariate data as
    well.)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Before looking at the function code, let’s see what the function does.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: In this data set, gender is in column 23 and age in columns 25 and 26\. In the
    example, our filename is *pumsa*. The following call creates a data frame consisting
    of those two variables.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: pumsdf <- extractpums("pumsa",list(Gender=c(23,23),Age=c(25,26))) Note that
    we are stating here the names we want the columns to have in the resulting data
    frame. We can use any names we want—say Sex and Ancientness.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the first part of that data frame:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: head(pumsdf)
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: serno Gender Age
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '195'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 2 19
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '407'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 1 38
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '407'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 1 14
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '610'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 2 65
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 6 1609
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 1 50
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 7 1609
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 2 49
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The following is the code for the extractpums() function.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: reads in PUMS file pf, extracting the Person records, returning a data 2
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: frame; each row of the output will consist of the Household serial 3
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: number and the fields specified in the list flds; the columns of
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: the data frame will have the names of the indices in flds
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: extractpums <- function(pf,flds) {
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'dtf <- data.frame() # data frame to be built'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'con <- file(pf,"r") # connection'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: process the input file
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '10'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: repeat {
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'hrec <- readLines(con,1) # read Household record'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'if (length(hrec) == 0) break # end of file, leave loop'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: get household serial number
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '14'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: serno <- intextract(hrec,c(2,8))
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '**240**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: how many Person records?
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '16'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: npr <- intextract(hrec,c(106,107))
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: if (npr > 0)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:npr) {
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'prec <- readLines(con,1) # get Person record'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: make this person's row for the data frame
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '21'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: person <- makerow(serno,prec,flds)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: add it to the data frame
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '23'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: dtf <- rbind(dtf,person)
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: return(dtf)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: set up this person's row for the data frame
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '30'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: makerow <- function(srn,pr,fl) {
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: l <- list()
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: l[["serno"]] <- srn
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: for (nm in names(fl)) {
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: l[[nm]] <- intextract(pr,fl[[nm]])
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: return(l)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: extracts an integer field in the string s, in character positions 40
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: rng[1] through rng[2]
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '41'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: intextract <- function(s,rng) {
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: fld <- substr(s,rng[1],rng[2])
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: return(as.integer(fld))
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how this works. At the beginning of extractpums(), we create an empty
    data frame and set up the connection for the PUMS file read.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'dtf <- data.frame() # data frame to be built'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'con <- file(pf,"r") # connection'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: The main body of the code then consists of a repeat loop.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: repeat {
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'hrec <- readLines(con,1) # read Household record'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'if (length(hrec) == 0) break # end of file, leave loop'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: get household serial number
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: serno <- intextract(hrec,c(2,8))
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: how many Person records?
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: npr <- intextract(hrec,c(106,107))
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Input/Output
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '**241**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: if (npr > 0)
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:npr) {
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: This loop iterates until the end of the input file is reached. The latter condition
    will be sensed by encountering a zero-length Household record, as seen in the
    preceding code.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Within the repeat loop, we alternate reading a Household record and reading
    the associated Person records. The number of Person records for the current Household
    record is extracted from columns 106 and 107 of that record, storing this number
    in npr. That extraction is done by a call to our function intextract().
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'The for loop then reads in the Person records one by one, in each case forming
    the desired row for the output data frame and then attaching it to the latter
    via rbind():'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:npr) {
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'prec <- readLines(con,1) # get Person record'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: make this person's row for the data frame
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: person <- makerow(serno,prec,flds)
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: add it to the data frame
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: dtf <- rbind(dtf,person)
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Note how makerow() creates the row to be added for a given person. Here the
    formal arguments are srn for the household serial number, pr for the given Person
    record, and fl for the list of variable names and column fields.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: makerow <- function(srn,pr,fl) {
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: l <- list()
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: l[["serno"]] <- srn
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: for (nm in names(fl)) {
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: l[[nm]] <- intextract(pr,fl[[nm]])
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: return(l)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider our sample call:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: pumsdf <- extractpums("pumsa",list(Gender=c(23,23),Age=c(25,26))) When makerow()
    executes, fl will be a list with two elements, named Gender and Age. The string
    pr, the current Person record, will have Gender in column 23 and Age in columns
    25 and 26\. We call intextract() to pull out the desired numbers.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '**242**'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: The intextract() function itself is a straightforward conversion of characters
    to numbers, such as converting the string "12" to the number 12\.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, if not for the presence of Household records, we could do all of
    this much more easily with a handy built-in R function: read.fwf(). The name of
    this function is an abbreviation for “read fixed-width formatted,”'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: alluding to the fact that each variable is stored in given character positions
    of a record. In essence, this function alleviates the need to write a function
    like intextract().
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '***10.2.5 Accessing Files on Remote Machines via URLs***'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Certain I/O functions, such as read.table() and scan(), accept web URLs as arguments.
    (Check R’s online help facility to see if your favorite function allows this.)
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we’ll read some data from the University of Califor-
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'nia, Irvine archive at *http://archive.ics.uci.edu/ml/datasets.html*, using
    the Echocardiogram data set. After navigating the links, we find the location
    of that file and then read it from R, as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: uci <- "http://archive.ics.uci.edu/ml/machine-learning-databases/"
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: uci <- paste(uci,"echocardiogram/echocardiogram.data",sep="")
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ecc <- read.csv(uci)
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (We’ve built up the URL in stages here to fit the page.)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at what we downloaded:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: head(ecc)
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: X11 X0 X71 X0.1 X0.260
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: X9 X4.600 X14
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: X1 X1.1 name X1.2 X0.2
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 1 19 0 72
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 0 0.380
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 6 4.100
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 14 1.700 0.588 name
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 2 16 0 55
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 0 0.260
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 4 3.420
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 1 name
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 3 57 0 60
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 0 0.253 12.062 4.603
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 16 1.450 0.788 name
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 4 19 1 57
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 0 0.160
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 22 5.750
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 18 2.250 0.571 name
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 5 26 0 68
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 0 0.260
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 5 4.310
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 1 0.857 name
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 6 13 0 62
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 0 0.230
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 31 5.430 22.5 1.875 0.857 name
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: We could then do our analyses. For example, the third column is age, so we could
    find its mean or perform other calculations on that data. See the echocardiogram.names
    page at *http://archive.ics.uci.edu/ml/machine-learning-databases/echocardiogram/echocardiogram.names*
    for descriptions of all of the variables.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '***10.2.6 Writing to a File***'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Given the statistical basis of R, file reads are probably much more common than
    writes. But writes are sometimes necessary, and this section will present methods
    for writing to files.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Input/Output
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '**243**'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 'The function write.table() works very much like read.table(), except that it
    writes a data frame instead of reading one. For instance, let’s take the little
    Jack and Jill example from the beginning of Chapter 5:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: kids <- c("Jack","Jill")
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ages <- c(12,10)
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d <- data.frame(kids,ages,stringsAsFactors=FALSE)
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: kids ages
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 1 Jack
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 2 Jill
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: write.table(d,"kds")
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The file *kds* will now have these contents:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '"kids" "ages"'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '"1" "Jack" 12'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '"2" "Jill" 10'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of writing a matrix to a file, just state that you do not want
    row or column names, as follows:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: write.table(xc,"xcnew",row.names=FALSE,col.names=FALSE) The function cat() can
    also be used to write to a file, one part at a time.
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: cat("abc\n",file="u")
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: cat("de\n",file="u",append=TRUE)
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The first call to cat() creates the file *u*, consisting of one line with contents
    "abc". The second call appends a second line. Unlike the case of using the writeLines()
    function (which we’ll discuss next), the file is automatically saved after each
    operation. For instance, after the previous calls, the file will look like this:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 cat() 创建了文件 *u*，包含一行内容 "abc"。第二次调用追加第二行。与使用 writeLines() 函数的情况不同（我们将在下一节讨论），文件在每次操作后都会自动保存。例如，在之前的调用之后，文件将看起来像这样：
- en: abc
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: abc
- en: de
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: de
- en: 'You can write multiple fields as well. So:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以写入多个字段。所以：
- en: cat(file="v",1,2,"xyz\n")
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cat(file="v",1,2,"xyz\n")
- en: 'would produce a file *v* consisting of a single line:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成一个包含单行的文件 *v*：
- en: 1 2 xyz
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 xyz
- en: '**244**'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '**244**'
- en: Chapter 10
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 第 10 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'You can also use writeLines(), the counterpart of readLines(). If you use a
    connection, you must specify "w" to indicate you are writing to the file, not
    reading from it:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 writeLines()，它是 readLines() 的对应函数。如果您使用连接，必须指定 "w" 来表示您正在写入文件，而不是从文件中读取：
- en: c <- file("www","w")
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c <- file("www","w")
- en: writeLines(c("abc","de","f"),c)
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: writeLines(c("abc","de","f"),c)
- en: close(c)
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: close(c)
- en: 'The file *www* will be created with these contents:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *www* 将包含以下内容：
- en: abc
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: abc
- en: de
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: de
- en: f
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: f
- en: Note the need to proactively close the file.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 注意需要主动关闭文件。
- en: '***10.2.7 Getting File and Directory Information***'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2.7 获取文件和目录信息***'
- en: 'R has a variety of functions for getting information about directories and
    files, setting file access permissions, and the like. The following are a few
    examples:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: R 有各种用于获取目录和文件信息、设置文件访问权限等的函数。以下是一些示例：
- en: •
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'file.info(): Gives file size, creation time, directory-versus-ordinary file
    status, and so on for each file whose name is in the argument, a character vector.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: file.info()：为每个在参数中的文件名（一个字符向量）提供文件大小、创建时间、目录与普通文件状态等信息。
- en: •
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'dir(): Returns a character vector listing the names of all the files in the
    directory specified in its first argument. If the optional argument recursive=TRUE
    is specified, the result will show the entire directory tree rooted at the first
    argument.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: dir()：返回一个字符向量，列出其第一个参数指定的目录中所有文件的名字。如果指定了可选参数 recursive=TRUE，则结果将显示以第一个参数为根的整个目录树。
- en: •
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'file.exists(): Returns a Boolean vector indicating whether the given file exists
    for each name in the first argument, a character vector.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: file.exists()：返回一个布尔向量，指示第一个参数中的每个名字所指定的文件是否存在。
- en: •
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'getwd() and setwd(): Used to determine or change the current working directory.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: getwd() 和 setwd()：用于确定或更改当前工作目录。
- en: 'To see all the file- and directory-related functions, type the following:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有与文件和目录相关的函数，请输入以下内容：
- en: ?files
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ?files
- en: Some of these options will be demonstrated in the next example.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例中将演示一些这些选项。
- en: '***10.2.8 Extended Example: Sum the Contents of Many Files***'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2.8 扩展示例：计算多个文件的内容总和***'
- en: Here, we’ll develop a function to find the sum of the contents (assumed numeric)
    in all files in a directory tree. In our example, a directory *dir1*
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将开发一个函数来查找目录树中所有文件内容的总和（假设为数值）。在我们的示例中，目录 *dir1*
- en: Input/Output
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出
- en: '**245**'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '**245**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'contains the files *filea* and *fileb*, as well as a subdirectory *dir2*, which
    holds the file *filec*. The contents of the files are as follows:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 包含文件 *filea* 和 *fileb*，以及一个子目录 *dir2*，其中包含文件 *filec*。文件内容如下：
- en: •
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: '*filea*: 5, 12, 13'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '*filea*: 5, 12, 13'
- en: •
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: '*fileb*: 3, 4, 5'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '*fileb*: 3, 4, 5'
- en: •
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: '*filec*: 24, 25, 7'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '*filec*: 24, 25, 7'
- en: 'If *dir1* is in our current directory, the call sumtree("dir1") will yield
    the sum of those nine numbers, 98\. Otherwise, we need to specify the full pathname
    of *dir1*, such as sumtree("/home/nm/dir1"). Here is the code: 1'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *dir1* 在我们的当前目录中，调用 sumtree("dir1") 将得到这九个数字的总和，98。否则，我们需要指定 *dir1* 的完整路径名，例如
    sumtree("/home/nm/dir1")。以下是代码：1
- en: sumtree <- function(drtr) {
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: sumtree <- function(drtr) {
- en: '2'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: tot <- 0
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: tot <- 0
- en: '3'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: get names of all files in the tree
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取树中所有文件的名字
- en: '4'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: fls <- dir(drtr,recursive=TRUE)
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: fls <- dir(drtr,recursive=TRUE)
- en: '5'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: for (f in fls) {
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: for (f in fls) {
- en: '6'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: is f a directory?
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: f 是否是一个目录？
- en: '7'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: f <- file.path(drtr,f)
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: f <- file.path(drtr,f)
- en: '8'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: if (!file.info(f)$isdir) {
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: if (!file.info(f)$isdir) {
- en: '9'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: tot <- tot + sum(scan(f,quiet=TRUE))
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: tot <- tot + sum(scan(f,quiet=TRUE))
- en: '10'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: '}'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '11'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: '}'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '12'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: return(tot)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: return(tot)
- en: '13'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: '}'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Note that this problem is a natural for recursion, which we discussed in Section
    7.9\. But here, R has done the recursion for us by allowing it as an option in
    dir(). Thus, in line 4, we set recursive=TRUE in order to find the files throughout
    the various levels of the directory tree.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个问题是递归的自然选择，我们在第7.9节中讨论了递归。但在这里，R通过在dir()中允许它作为选项来为我们执行递归。因此，在第4行，我们设置recursive=TRUE，以便在整个目录树的不同级别中找到文件。
- en: To call file.info(), we need to account for the fact that the current filename
    *f* is relative to drtr, so our file *filea* would be referred to as *dir1/filea*.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用file.info()，我们需要考虑到当前文件名*f*相对于drtr是相对的，因此我们的文件*filea*将被引用为*dir1/filea*。
- en: In order to form that pathname, we need to concatenate drtr, a slash, and filea.
    We could use the R string concatenation function paste() for this, but we would
    need a separate case for Windows, which uses a backslash instead of a slash. But
    file.path() does all that for us.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形成该路径名，我们需要连接drtr、一个斜杠和filea。我们可以使用R字符串连接函数paste()来做这件事，但我们需要为Windows使用一个单独的情况，Windows使用反斜杠而不是斜杠。但file.path()为我们做了所有这些。
- en: Some commentary pertaining to line 8 is in order. The function
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第8行的某些评论是必要的。函数
- en: file.info() returns information about f as a data frame, one of whose columns
    is isdir, with one row for each file and with row names being the filenames. That
    column consists of Boolean values indicating whether each file is a directory.
    In line 8, then, we can detect whether the current file *f* is a directory. If
    *f* is an ordinary file, we go ahead and add its contents to our running total.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: file.info()返回有关f的信息作为数据框，其中一个列是isdir，每行对应一个文件，行名是文件名。该列由布尔值组成，指示每个文件是否是目录。因此，在第8行，我们可以检测当前文件*f*是否是目录。如果*f*是一个普通文件，我们就继续将其内容添加到我们的运行总和中。
- en: '**10.3 Accessing the Internet**'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.3 访问互联网**'
- en: R’s socket facilities give the programmer access to the Internet’s TCP/IP
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: R的套接字功能为程序员提供了访问互联网的TCP/IP的接口。
- en: protocol. For readers who are not familiar with this protocol, we begin with
    an overview of TCP/IP.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 协议。对于不熟悉此协议的读者，我们将从TCP/IP的概述开始。
- en: '**246**'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '**246**'
- en: Chapter 10
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 第10章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***10.3.1 Overview of TCP/IP***'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.3.1 TCP/IP概述***'
- en: TCP/IP is quite complex, so the overview here will be something of an over-simplification,
    but we’ll cover enough for you to understand what R’s socket functions are doing.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP相当复杂，所以这里的概述将是一种过度简化，但我们将涵盖足够的内容，以便您理解R的套接字函数正在做什么。
- en: For our purposes here, the term *network* refers to a set of computers connected
    together locally, without going through the Internet. This typically consists
    of all the computers in a home, all the computers in a smaller business, and so
    on. The physical medium between them is usually an Ethernet connection of some
    form.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这里的目的中，术语*网络*指的是一组本地连接在一起的计算机，而不通过互联网。这通常包括家庭中的所有计算机，较小企业中的所有计算机，等等。它们之间的物理介质通常是某种形式的以太网连接。
- en: The Internet, as its name implies, connects networks. A network in the Internet
    is connected to one or more other networks via *routers*, which are special-purpose
    computers that connect two or more networks together.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网，正如其名所暗示的，连接网络。互联网中的网络通过*路由器*连接到一个或多个其他网络，路由器是专门用于连接两个或更多网络的特殊用途计算机。
- en: Every computer on the Internet has an Internet Protocol (IP) address. This is
    numeric, but it can be stated in characters, as in *www.google.com*, which is
    then translated into the numeric address by the Domain Name Service.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上的每台计算机都有一个互联网协议（IP）地址。这是一个数字，但它可以用字符表示，例如*www.google.com*，然后由域名服务将其转换为数字地址。
- en: However, the IP address is not enough. When A sends a message to
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，IP地址是不够的。当A向B发送消息时，
- en: B, there may be several applications at computer B that are receiving Internet
    messages, such as web browsing, email service, and so on. How does the operating
    system at B know to which of these to send the message from A? The answer is that
    A will specify a *port number* in addition to the IP address.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: B，可能有几个应用程序在计算机B上接收互联网消息，例如网页浏览、电子邮件服务等等。B的操作系统如何知道将来自A的消息发送给这些中的哪一个？答案是A将指定一个*端口号*，除了IP地址。
- en: The port number indicates which program running at B is intended as the recipient.
    And A will also have a port number so that the response from B
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 端口号表示B上运行哪个程序作为接收者。A也将有一个端口号，以便B的响应
- en: reaches the correct application at A.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 达到A的正确应用程序。
- en: When A wishes to send something to B, it writes to a software entity called
    a *socket*, using a system call syntactically similar to the one for writing to
    a file. In the call, A specifies B’s IP address and the port number to which A
    wishes to send a message. B has a socket, too, and it writes its responses to
    A in that socket. We say there is a *connection* between A and B via those sockets,
    but that doesn’t mean anything physical—it’s just an agreement between A and B
    to exchange data.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 当A想要向B发送某些内容时，它会向一个名为*socket*的软件实体写入，使用与写入文件的系统调用在语法上相似的调用。在调用中，A指定了B的IP地址和A希望发送消息的端口号。B也有一个socket，它将响应写入到该socket中。我们说A和B通过这些socket之间存在*连接*，但这并不意味着任何物理上的东西——这只是A和B之间交换数据的协议。
- en: Applications follow a *client/server* model. Say a web server is running at
    B, at the standard port for the Web, port 80\. The server at B is *listening*
    at port 80\. Again, this term should not be taken literally; it just means that
    the server program has made a function call that notifies the operating system
    that the server program is willing to have connections at port 80\. When network
    node A requests such a connection, the function call at the server returns, and
    the connection is set up.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序遵循*客户端/服务器*模型。比如说，一个Web服务器在B处运行，在Web的标准端口80上。B处的服务器正在端口80上*监听*。同样，这个术语不应被字面理解；它只是意味着服务器程序已经调用了一个通知操作系统服务器程序愿意在端口80上建立连接的功能。当网络节点A请求这样的连接时，服务器上的函数调用返回，连接就建立了。
- en: If you are a nonprivileged user and write some kind of server program—
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个非特权用户并且编写某种类型的服务器程序——
- en: say in R!—you must assign a port number above 1024\.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 比如在R中！——你必须分配一个大于1024的端口号。
- en: '**NOTE**'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If a server program is taken down or crashes, there may be a few seconds’
    delay before* *the same port is reusable again.*'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果服务器程序被关闭或崩溃，在相同的端口再次可重用之前可能会有几秒钟的延迟。*'
- en: '***10.3.2 Sockets in R***'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.3.2 R中的套接字***'
- en: A very important point to keep in mind is that all the bytes sent by A to B
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 需要牢记的一个重要观点是，A向B发送的所有字节
- en: during the time the connection between them exists are collectively considered
    *one big message*. Say A sends one line of text of 8 characters and then Input/Output
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们之间存在的连接存在期间，被认为是*一个大的消息*。比如说，A发送了一行8个字符的文本，然后输入/输出
- en: '**247**'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '**247**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'another of 20 characters. From A’s point of view, that’s two lines, but to
    TCP/IP, it’s just 28 characters of a yet incomplete message. Splitting that long
    message back into lines can take a bit of doing. R provides various functions
    for this purpose, including the following:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个20个字符。从A的角度来看，这是两行，但对TCP/IP来说，这只是尚未完成的消息的28个字符。将这个长消息拆分成行可能需要一些工作。R为此提供了各种函数，包括以下：
- en: •
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'readLines() and writeLines(): These allow you to program as if TCP/IP'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: readLines()和writeLines()：这些允许你以TCP/IP
- en: were sending messages line by line, even though this is not actually the case.
    If your application is naturally viewed in terms of lines, these two functions
    can be quite handy.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在逐行发送消息，尽管实际上并非如此。如果你的应用程序自然地以行为单位来考虑，这两个函数可能非常有用。
- en: •
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'serialize() and unserialize(): You can use these to send R objects, such as
    a matrix or the complex output of a call to a statistical function. The object
    is converted to character string form by the sender and then converted back to
    the original object form at the receiver.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: serialize()和unserialize()：你可以使用这些函数发送R对象，例如矩阵或统计函数调用的复杂输出。发送方将对象转换为字符字符串形式，然后在接收方将其转换回原始对象形式。
- en: •
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'readBin() and writeBin(): These are for sending data in binary form.'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: readBin()和writeBin()：这些用于以二进制形式发送数据。
- en: (Recall the comment on terminology at the beginning of Section 10.2.2.) Each
    of these functions operates on R connections, as you’ll see in the next example.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: （回想一下第10.2.2节开头关于术语的注释。）这些函数中的每一个都在R连接上操作，正如你将在下一个示例中看到的。
- en: It’s important to choose the right function for each job. If you have a long
    vector, for example, using serialize() and unserialize() may be more convenient
    but far more time-consuming. This is not only because numbers must be converted
    to and from their character representations but also because the character representation
    is typically much longer, which means greater transmission time.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 选择每个任务正确的函数很重要。例如，如果你有一个长向量，使用serialize()和unserialize()可能更方便，但耗时更多。这不仅是因为数字必须转换为它们的字符表示形式，然后又转换回，而且因为字符表示形式通常要长得多，这意味着传输时间更长。
- en: 'Here are two other R socket functions:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: 'socketConnection(): This establishes an R connection via sockets. You specify
    the port number in the argument port, and state whether a'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: server or client is to be created, by setting the argument server to TRUE
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: or FALSE, respectively. In the client case, you must also supply the server’s
    IP address in the argument host.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: 'socketSelect(): This is useful when a server is connected to multiple clients.
    Its main argument, socklist, is a list of connections, and its return value is
    the sublist of connections that have data ready for the server to read.'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '***10.3.3 Extended Example: Implementing Parallel R***'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: Some statistical analyses have very long runtimes, so there naturally has been
    quite a bit of interest in “parallel R,” in which several R processes cooperate
    on a given task. Another possible reason to “go parallel” is memory limita-tions.
    If one machine does not have enough memory for the task at hand, it may help to
    pool the memories of several machines in some way. Chapter 16
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: gives an introduction to this important topic.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: Sockets play a key role in many parallel R packages. The cooperating R
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: processes could be either on the same machine or on separate machines. In the
    latter case (and even the former), a natural approach to implementing parallelism
    is to use R sockets. This is one of the choices in the snow package **248**
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: 'and in my Rdsm package (both available on CRAN, R’s code repository; see this
    book’s appendix for details), as follows:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: In snow, the server sends out work tasks to the clients. The clients perform
    their tasks and send the results back to the server, which assembles them into
    the final result. Communication is done with serialize() and unserialize(), and
    the server uses socketSelect() to determine which client results are ready.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: Rdsm implements a virtual shared-memory paradigm, and the server is used to
    store the shared variables. The clients contact the server whenever they need
    to read or write a shared variable. To optimize speed, communication between server
    and clients is done with readBin() and writebin(), instead of serialize() and
    unserialize().
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some of the socket-related details of Rdsm. First, here is the
    server code in which connections with the clients are set up, storing them in
    a list cons (there are ncon clients):'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: set up socket connections with clients
  id: totrans-644
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '#'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: 'cons <<- vector(mode="list",length=ncon) # list of connections 4'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: prevent connection from dying during debug or long compute spell
  id: totrans-649
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: options("timeout"=10000)
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:ncon) {
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: cons[[i]] <<-
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: socketConnection(port=port,server=TRUE,blocking=TRUE,open="a+b") 9
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: wait to hear from client i
  id: totrans-658
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '10'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: checkin <- unserialize(cons[[i]])
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: send ACKs
  id: totrans-664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '13'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:ncon) {
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: send the client its ID number, and the group size
  id: totrans-668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '15'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: serialize(c(i,ncon),cons[[i]])
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: Since the client messages and server acknowledgments are short mes-
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: sages, serialize() and unserialize() are good enough for the purpose here.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the main loop of the server finds a ready client and reads
    from it.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: repeat {
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: any clients still there?
  id: totrans-679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: if (remainingclients == 0) break
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: wait for service request, then read it
  id: totrans-683
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: find all the pending client requests
  id: totrans-685
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: rdy <- which(socketSelect(cons))
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: choose one
  id: totrans-689
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: j <- sample(1:length(rdy),1)
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: Input/Output
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '**249**'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: con <- cons[[rdy[j]]]
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: read client request
  id: totrans-698
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '11'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: req <- unserialize(con)
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 'Again serialize() and unserialize() are good enough here to read the short
    message from the client indicating what kind of operation—typically reading a
    shared variable or writing one—it’s requesting. But the reads and writes of the
    shared variables themselves use the faster readBin() and writeBin() functions.
    Here’s the write part:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: write data dt, of mode md (integer of double), to connection cn
  id: totrans-702
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: binwrite <- function(dt,md,cn) {
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: writeBin(dt,con=cn)
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: 'And here’s the read part:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: read sz elements of mode md (integer of double) from connection cn binread <-
    function(cn,md,sz) {
  id: totrans-706
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: return(readBin(con=cn,what=md,n=sz))
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client side, the connection setup code is as follows:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: options("timeout"=10000)
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: connect to server
  id: totrans-712
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: con <- socketConnection(host=host,port=port,blocking=TRUE,open="a+b") 4
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: serialize(list(req="checking in"),con)
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: receive this client's ID and total number of clients from server
  id: totrans-717
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: myidandnclnt <- unserialize(con)
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: myinfo <<-
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: list(con=con,myid=myidandnclnt[1],nclnt=myidandnclnt[2])
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: The code for reading from and writing to the server is similar to the preceding
    server examples.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: '**250**'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 23](index-277_1.png)'
  id: totrans-728
  prefs: []
  type: TYPE_IMG
- en: '**11**'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: '**STRING MANIPULATION**'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: Although R is a statistical language with
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: numeric vectors and matrices playing a
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: central role, character strings are surpris-
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: ingly important as well. Ranging from birth
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: dates stored in medical research data files to text-
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: mining applications, character data arises quite fre-
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: quently in R programs. Accordingly, R has a number
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: of string-manipulation utilities, many of which will be
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: introduced in this chapter.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '**11.1 An Overview of String-Manipulation Functions**'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ll briefly review just some of the many string-manipulation functions
    R has to offer. Note that the call forms shown in this introduction are very simple,
    usually omitting many optional arguments. We’ll use some of those arguments in
    our extended examples later in the chapter, but do check R’s online help for further
    details.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.1 grep()***'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: The call grep(pattern,x) searches for a specified substring pattern in a vector
    x of strings. If x has *n* elements—that is, it contains *n* strings—then grep(pattern,x)
    will return a vector of length up to *n*. Each element of this vector will be
    the index in x at which a match of pattern as a substring of x[i]) was found.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using grep:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: grep("Pole",c("Equator","North Pole","South Pole"))
  id: totrans-746
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 2 3'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: grep("pole",c("Equator","North Pole","South Pole")) integer(0)
  id: totrans-748
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the first case, the string "Pole" was found in elements 2 and 3 of the second
    argument, hence the output (2,3). In the second case, string "pole"
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: was not found anywhere, so an empty vector was returned.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.2 nchar()***'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: 'The call nchar(x) finds the length of a string x. Here’s an example:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: nchar("South Pole")
  id: totrans-753
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 10'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: 'The string "South Pole" was found to have 10 characters. C programmers, take
    note: There is no NULL character terminating R strings.'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the results of nchar() will be unpredictable if x is not in character
    mode. For instance, nchar(NA) turns out to be 2, and nchar(factor("abc")) is 1\.
    For more consistent results on nonstring objects, use Hadley Wickham’s stringr
    package on CRAN.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.3 paste()***'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: 'The call paste(...) concatenates several strings, returning the result in one
    long string. Here are some examples:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: paste("North","Pole")
  id: totrans-759
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "North Pole"'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: paste("North","Pole",sep="")
  id: totrans-761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "NorthPole"'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: paste("North","Pole",sep=".")
  id: totrans-763
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "North.Pole"'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: paste("North","and","South","Poles")
  id: totrans-765
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "North and South Poles"'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: '**252**'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the optional argument sep can be used to put something other
    than a space between the pieces being spliced together. If you specify sep as
    an empty string, the pieces won’t have any character between them.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.4 sprintf()***'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: The call sprintf(...) assembles a string from parts in a formatted manner.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: i <- 8
  id: totrans-774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: s <- sprintf("the square of %d is %d",i,i^2)
  id: totrans-775
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: s
  id: totrans-776
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "the square of 8 is 64"'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: The name of the function is intended to evoke *string print* for “printing”
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: to a string rather than to the screen. Here, we are printing to the string s.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: What are we printing? The function says to first print “the square of”
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: and then print the decimal value of i. (The term *decimal* here means in the
    base-10 number system, not that there will be a decimal point in the result.)
    The result is the string "the square of 8 is 64."
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.5 substr()***'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: 'The call substr(x,start,stop) returns the substring in the given character
    position range start:stop in the given string x. Here’s an example:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: substring("Equator",3,5)
  id: totrans-784
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "uat"'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.6 strsplit()***'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: 'The call strsplit(x,split) splits a string x into an R list of substrings based
    on another string split in x. Here’s an example:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: strsplit("6-16-2011",split="-")
  id: totrans-788
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[[1]]'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "6"'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: '"16"'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '"2011"'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.7 regexpr()***'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: 'The call regexpr(pattern,text) finds the character position of the first instance
    of pattern within text, as in this example:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: regexpr("uat","Equator")
  id: totrans-795
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 3'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: String Manipulation
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: '**253**'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: This reports that “uat” did indeed appear in “Equator,” starting at character
    position 3\.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: '***11.1.8 gregexpr()***'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: 'The call gregexpr(pattern,text) is the same as regexpr(), but it finds all
    instances of pattern. Here’s an example:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: gregexpr("iss","Mississippi")
  id: totrans-803
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[[1]]'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 2 5'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: This finds that “iss” appears twice in “Mississippi,” starting at character
    positions 2 and 5\.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: '**11.2 Regular Expressions**'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with string-manipulation functions in programming languages, the
    notion of *regular expressions* sometimes arises. In R, you must pay attention
    to this point when using the string functions grep(), grepl(), regexpr(), gregexpr(),
    sub(), gsub(), and strsplit().
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: 'A regular expression is a kind of wild card. It’s shorthand to specify broad
    classes of strings. For example, the expression "[au]" refers to any string that
    contains either of the letters *a* or *u*. You could use it like this:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: grep("[au]",c("Equator","North Pole","South Pole"))
  id: totrans-810
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 3'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: This reports that elements 1 and 3 of ("Equator","North Pole","South Pole")—that
    is, “Equator” and “South Pole”—contain either an *a* or a *u*.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: A period (.) represents any single character. Here’s an example of
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: 'using it:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: grep("o.e",c("Equator","North Pole","South Pole"))
  id: totrans-815
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 2 3'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: 'This searches for three-character strings in which an *o* is followed by any
    single character, which is in turn followed by an *e*. Here is an example of the
    use of two periods to represent any pair of characters:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: grep("N..t",c("Equator","North Pole","South Pole"))
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 2'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: Here, we searched for four-letter strings consisting of an *N*, followed by
    any pair of characters, followed by a *t*.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: A period is an example of a *metacharacter*, which is a character that is not
    to be taken literally. For example, if a period appears in the first argument
    of grep(), it doesn’t actually mean a period; it means any character.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: '**254**'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you want to search for a period using grep()? Here’s the naive
    approach:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: grep(".",c("abc","de","f.g"))
  id: totrans-826
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 2 3'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should have been 3, not (1,2,3). This call failed because periods
    are metacharacters. You need to *escape* the metacharacter nature of the period,
    which is done via a backslash:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: grep("\\.",c("abc","de","f.g"))
  id: totrans-829
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 3'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: Now, didn’t I say *a* backslash? Then why are there two? Well, the sad truth
    is that the backslash itself must be escaped, which is accomplished by its own
    backslash! This goes to show how arcanely complex regular expressions can become.
    Indeed, a number of books have been written on the subject of regular expressions
    (for various programming languages). As a start in learning about the topic, refer
    to R’s online help (type ?regex).
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: '***11.2.1 Extended Example: Testing a Filename for a Given Suffix***'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we wish to test for a specified suffix in a filename. We might, for
    instance, want to find all HTML files (those with suffix *.html*, *.htm*, and
    so on). Here is code for that:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix <- function(fn,suff) {
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: parts <- strsplit(fn,".",fixed=TRUE)
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: nparts <- length(parts[[1]])
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: return(parts[[1]][nparts] == suff)
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test it.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix("x.abc","abc")
  id: totrans-845
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] TRUE'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix("x.abc","ac")
  id: totrans-847
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] FALSE'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix("x.y.abc","ac")
  id: totrans-849
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] FALSE'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix("x.y.abc","abc")
  id: totrans-851
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] TRUE'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: How does the function work? First note that the call to strsplit() on line 2
    returns a list consisting of one element (because fn is a one-element vector)—a
    vector of strings. For example, calling testsuffix("x.y.abc","abc") will result
    in parts being a list consisting of a three-element vector with elements x, y,
    and abc. We then pick up the last element and compare it to suff.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: String Manipulation
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: '**255**'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: A key aspect is the argument fixed=TRUE. Without it, the splitting argument
    . (called split in the list of strsplit()’s formal arguments) would have been
    treated as a regular expression. Without setting fixed=TRUE, strsplit() would
    have just separated all the letters.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we could also escape the period, as follows:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix <- function(fn,suff) {
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: parts <- strsplit(fn,"\\.")
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: nparts <- length(parts[[1]])
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: return(parts[[1]][nparts] == suff)
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: Let’s check to see if it still works.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix("x.y.abc","abc")
  id: totrans-870
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] TRUE'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another way to do the suffix-test code that’s a bit more involved but
    a good illustration:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: testsuffix <- function(fn,suff) {
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: 'ncf <- nchar(fn) # nchar() gives the string length'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: determine where the period would start if suff is the suffix in fn 4
  id: totrans-878
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: dotpos <- ncf - nchar(suff) + 1
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: now check that suff is there
  id: totrans-881
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: return(substr(fn,dotpos,ncf)==suff)
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the call to substr() here, again with fn = "x.ac" and suff = "abc".
    In this case, dotpos will be 1, which means there should be a period at the first
    character in fn if there is an abc suffix. The call to substr() then becomes substr("x.ac",1,4),
    which extracts the substring in character positions 1 through 4 of x.ac. That
    substring will be x.ac, which is not abc, so the filename’s suffix is found not
    to be the latter.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: '***11.2.2 Extended Example: Forming Filenames***'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to create five files, *q1.pdf* through *q5.pdf*, consisting
    of histograms of 100 random N(0, *i* 2) variates. We could execute the following
    code:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:5) {
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: fname <- paste("q",i,".pdf")
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: pdf(fname)
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: hist(rnorm(100,sd=i))
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: dev.off()
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: '**256**'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: The main point in this example is the string manipulation we use to create the
    filename fname. For more details about the graphics operations used in this example,
    refer to Section 12.3\.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: The paste() function concatenates the string "q" with the string form of the
    number i. For example, when i = 2, the variable fname will be q 2 .pdf.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: 'However, that isn’t quite what we want. On Linux systems, filenames with embedded
    spaces create headaches, so we want to remove the spaces. One solution is to use
    the sep argument, specifying an empty string for the separator, as follows:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:5) {
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: fname <- paste("q",i,".pdf",sep="") 3
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: pdf(fname)
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: hist(rnorm(100,sd=i))
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: dev.off()
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach is to employ the sprintf() function, borrowed from C: 1'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:5) {
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:5) {
- en: '2'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: fname <- sprintf("q%d.pdf",i)
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: fname <- sprintf("q%d.pdf",i)
- en: '3'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: pdf(fname)
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: pdf(fname)
- en: '4'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: hist(rnorm(100,sd=i))
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: hist(rnorm(100,sd=i))
- en: '5'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: dev.off()
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: dev.off()
- en: '6'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '}'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'For floating-point quantities, note also the difference between %f and %g formats:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 对于浮点数，还要注意 %f 和 %g 格式之间的区别：
- en: sprintf("abc%fdef",1.5)
  id: totrans-931
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sprintf("abc%fdef",1.5)
- en: '[1] "abc1.500000def"'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "abc1.500000def"'
- en: sprintf("abc%gdef",1.5)
  id: totrans-933
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sprintf("abc%gdef",1.5)
- en: '[1] "abc1.5def"'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "abc1.5def"'
- en: The %g format eliminated the superfluous zeros.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '%g 格式消除了多余的零。'
- en: '**11.3 Use of String Utilities in the edtdbg Debugging Tool**'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '**11.3 在 edtdbg 调试工具中使用字符串实用工具**'
- en: 'The internal code of the edtdbg debugging tool, which will be discussed in
    Section 13.4, makes heavy use of string utilities. A typical example of such usage
    is the dgbsendeditcmd() function:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: edtdbg 调试工具的内部代码，将在第 13.4 节中讨论，大量使用了字符串实用工具。此类使用的典型示例是 dgbsendeditcmd() 函数：
- en: send command to editor
  id: totrans-938
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向编辑器发送命令
- en: dbgsendeditcmd <- function(cmd) {
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: dbgsendeditcmd <- function(cmd) {
- en: syscmd <- paste("vim --remote-send ",cmd," --servername ",vimserver,sep="")
    system(syscmd)
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: syscmd <- paste("vim --remote-send ",cmd," --servername ",vimserver,sep="")
    system(syscmd)
- en: '}'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: String Manipulation
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作
- en: '**257**'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '**257**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'What is going on here? The main point is that edtdbg sends remote commands
    to the Vim text editor. For instance, if you are running Vim with a server name
    of 168 and you want the cursor in Vim to move to line 12, you could type this
    into a terminal (shell) window:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？主要点是 edtdbg 向 Vim 文本编辑器发送远程命令。例如，如果你使用服务器名为 168 运行 Vim，并且想要将 Vim 中的光标移动到第
    12 行，你可以在终端（shell）窗口中输入以下内容：
- en: vim --remote-send 12G --servername 168
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: vim --remote-send 12G --servername 168
- en: 'The effect would be the same as if you had physically typed 12G at the Vim
    window. Since 12G is the Vim command to move the cursor to line 12, that’s what
    would occur. Consider this call:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果与你在 Vim 窗口中实际输入 12G 是一样的。由于 12G 是 Vim 命令，用于将光标移动到第 12 行，因此会发生这种情况。考虑以下调用：
- en: 'paste("vim --remote-send ",cmd," --servername ",vimserver,sep="") Here, cmd
    is the string "12G", vimserver is 168, and paste() concatenates all the indicated
    strings. The argument sep="" says to use the empty string as separator in this
    concatenation—that is, no separation. Thus, paste() returns the following:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: paste("vim --remote-send ",cmd," --servername ",vimserver,sep="") 这里，cmd 是字符串
    "12G"，vimserver 是 168，paste() 连接所有指示的字符串。参数 sep="" 表示在此连接中使用空字符串作为分隔符——也就是说，没有分隔。因此，paste()
    返回以下内容：
- en: vim --remote-send 12G --servername 168
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: vim --remote-send 12G --servername 168
- en: Another core element in the operation of edtdbg is that the program has arranged,
    via a call to R’s sink() function, to record to the file *dbgsink* most output
    from R’s debugger in your R window. (The edtdbg utility works in concert with
    that debugger.) That information includes the line numbers of your positions in
    your source file as you step through it using R’s debugger.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 'edtdbg 运作中的另一个核心元素是，程序通过调用 R 的 sink() 函数，安排将 R 调试器的大部分输出记录到名为 *dbgsink* 的文件中。（edtdbg
    工具与该调试器协同工作。）这些信息包括你在使用 R 调试器逐步通过源文件时，你的位置所在的行号。 '
- en: 'The line position information in the debugger output looks like this: debug
    at cities.r#16: {'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '调试器输出中的行位置信息如下所示：debug at cities.r#16: {'
- en: 'So, there is code in edtdbg to determine the latest line in *dbgsink* that
    begins with “debug at.” That line is then placed, as a string, in a variable named
    debugline. The following code then extracts the line number (16 in the example)
    and the source filename/Vim buffer name ( *cities.r* here): linenumstart <- regexpr("#",debugline)
    + 1'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 edtdbg 中有代码来确定 *dbgsink* 中以“debug at.”开头的最新行。然后，将该行作为一个字符串放入名为 debugline
    的变量中。接下来的代码然后提取行号（示例中的 16）和源文件名/Vim 缓冲区名（这里为 *cities.r*）：linenumstart <- regexpr("#",debugline)
    + 1
- en: buffname <- substr(debugline,10,linenumstart-2)
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: buffname <- substr(debugline,10,linenumstart-2)
- en: colon <- regexpr(":",debugline)
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: colon <- regexpr(":",debugline)
- en: linenum <- substr(debugline,linenumstart,colon-1)
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: linenum <- substr(debugline,linenumstart,colon-1)
- en: 'The call to regexpr() determines where in debugline the # character is located
    (character 18 in this example). Adding 1 to that gives the position of the line
    number within debugline.'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 'regexpr() 的调用确定了 # 字符在 debugline 中的位置（本例中的第 18 个字符）。加 1 后给出行号在 debugline 中的位置。'
- en: '**258**'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '**258**'
- en: Chapter 11
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 第 11 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'To get the buffer name, using the preceding example as a guide, we see that
    the name comes after debug at and ends just before the #. Since “debug at” contains
    nine characters, the buffer name will start at position 10—hence the 10 in the
    call,'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '要获取缓冲区名称，以先前的示例为指南，我们看到名称位于 debug 之后，并在 # 之前结束。由于“debug at”包含九个字符，缓冲区名称将从位置
    10 开始——因此调用中的 10，'
- en: substr(debugline,10,linenumstart-2)
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: substr(debugline,10,linenumstart-2)
- en: 'The end of the buffer name field is at linenumstart-2, as it is just before
    the #, which precedes the start of the line number. The line number computation
    is then similar.'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '缓冲区名称字段的末尾位于 linenumstart-2，因为它位于 # 之前，而 # 位于行号开始之前。行号计算方式类似。'
- en: 'Another illustrative example of edtdbg’s internal code is its use of the strsplit()
    function. For example, at one point, it prints out a prompt to the user:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: edtdbg 内部代码的另一个示例是它对 strsplit() 函数的使用。例如，在某个时刻，它向用户打印出一个提示：
- en: 'kbdin <- readline(prompt="enter number(s) of fns you wish to toggle dbg: ")
    As you can see, the user’s response is stored in kbdin. It will consist of a set
    of numbers separated by spaces, such as this:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 'kbdin <- readline(prompt="enter number(s) of fns you wish to toggle dbg: ")
    如你所见，用户的响应存储在 kbdin 中。它将包含由空格分隔的一组数字，例如：'
- en: 1 4 5
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 1 4 5
- en: 'We need to extract the numbers from the string 1 4 5 into an integer vector.
    This is done first via strsplit(), which produces three strings: "1", "4", and
    "5". Then we call as.integer() to convert from characters to numbers: tognums
    <- as.integer(strsplit(kbdin,split=" ")[[1]])'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从字符串 1 4 5 中提取数字到一个整数向量中。这是首先通过 strsplit() 完成的，它产生了三个字符串："1"、"4" 和 "5"。然后我们调用
    as.integer() 将字符转换为数字：tognums <- as.integer(strsplit(kbdin,split=" ")[[1]])
- en: Note that the output of strsplit() is an R list, in this case consisting of
    one element, which is in turn the vector ("1","4","5"). This leads to the expression
    [[1]] in the example.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 strsplit() 的输出是一个 R 列表，在这种情况下，它包含一个元素，该元素是一个向量 ("1","4","5")。这导致了示例中的 [[1]]
    表达式。
- en: String Manipulation
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作
- en: '**259**'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '**259**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 24](index-287_1.png)'
  id: totrans-972
  prefs: []
  type: TYPE_IMG
  zh: '![图像 24](index-287_1.png)'
- en: '**12**'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '**12**'
- en: '**GRAPHICS**'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形**'
- en: R has a very rich set of graphics facilities.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: R 拥有一套非常丰富的图形功能。
- en: The R home page ( *http://www.r-project*
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: R 的主页（ *http://www.r-project*
- en: '*.org/* ) has a few colorful examples, but to'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '*.org/* ) 有一些色彩丰富的示例，但为了'
- en: really appreciate R’s graphical power, browse
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 真实地欣赏 R 的图形能力，浏览
- en: through the R Graph Gallery at *http://addictedtor.free*
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: R 图形画廊在 *http://addictedtor.free*
- en: '*.fr/graphiques*.'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '*.fr/graphiques*.'
- en: In this chapter, we cover the basics of using R’s base, or traditional, graphics
    package. This will give you enough foundation to start working with graphics in
    R. If you’re interested in pursuing R graphics further, you may want to refer
    to the excellent books on the subject.1
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用 R 的基础或传统图形包的基本方法。这将为你提供足够的基礎，以便开始使用 R 进行图形操作。如果你对进一步学习 R 图形感兴趣，你可能需要参考该主题的优秀书籍。1
- en: '**12.1 Creating Graphs**'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.1 创建图形**'
- en: 'To begin, we’ll look at the foundational function for creating graphs: plot().'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看创建图形的基础函数：plot()。
- en: Then we’ll explore how to build a graph, from adding lines and points to attaching
    a legend.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探讨如何构建图形，从添加线条和点到最后添加图例。
- en: '1 These include Hadley Wickham, *ggplot2: Elegant Graphics for Data Analysis*
    (New York: Springer-Verlag, 2009); Dianne Cook and Deborah F. Swayne, *Interactive
    and Dynamic Graphics for Data* *Analysis: With R and GGobi* (New York: Springer-Verlag,
    2007); Deepayan Sarkar, *Lattice: Multivariate Data Visualization with R* (New
    York: Springer-Verlag, 2008); and Paul Murrell, *R Graphics* (Boca Raton, FL:
    Chapman and Hall/CRC, 2011).'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '1 这些包括 Hadley Wickham 的 *ggplot2: 数据分析中的优雅图形*（纽约：Springer-Verlag，2009）；Dianne
    Cook 和 Deborah F. Swayne 的 *使用 R 和 GGobi 的交互式和动态数据图形分析*（纽约：Springer-Verlag，2007）；Deepayan
    Sarkar 的 *Lattice: 使用 R 的多元数据可视化*（纽约：Springer-Verlag，2008）；以及 Paul Murrell 的 *R
    Graphics*（博卡雷顿，FL：Chapman and Hall/CRC，2011）。'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 25](index-288_1.png)'
  id: totrans-987
  prefs: []
  type: TYPE_IMG
  zh: '![图像 25](index-288_1.png)'
- en: '***12.1.1 The Workhorse of R Base Graphics: The plot() Function***'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.1.1 R 基础图形的引擎：plot() 函数***'
- en: The plot() function forms the foundation for much of R’s base graphing operations,
    serving as the vehicle for producing many different kinds of graphs. As mentioned
    in Section 9.1.1, plot() is a generic function, or a placeholder for a family
    of functions. The function that is actually called depends on the class of the
    object on which it is called.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()`函数是R的基础绘图操作的基础，作为产生许多不同类型图表的工具。如第9.1.1节所述，`plot()`是一个泛型函数，或是一系列函数的占位符。实际调用的函数取决于被调用对象的类别。'
- en: Let’s see what happens when we call plot() with an X vector and a Y
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们用X向量和Y向量调用`plot()`时会发生什么
- en: vector, which are interpreted as a set of pairs in the ( *x*, *y*) plane.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 向量，这些在(*x*, *y*)平面上被解释为一组对。
- en: plot(c(1,2,3), c(1,2,4))
  id: totrans-992
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`plot(c(1,2,3), c(1,2,4))`'
- en: This will cause a window to pop up, plotting the points (1,1), (2,2), and (3,4),
    as shown in Figure 12-1\. As you can see, this is a very plain-Jane graph.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 这将弹出一个窗口，绘制点(1,1)，(2,2)和(3,4)，如图12-1所示。正如你所看到的，这是一个非常简单的图表。
- en: We’ll discuss adding some of the fancy bells and whistles later in the chapter.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论添加一些花哨的功能。
- en: '*Figure 12-1: Simple point plot*'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-1：简单的点图*'
- en: '**NOTE**'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The points in the graph in Figure 12-1 are denoted by empty circles. If you
    want to* *use a different character type, specify a value for the named argument
    pch (for* point character *).*'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-1中的点用空心圆表示。如果你想要* *使用不同的字符类型，请为名为pch的命名参数指定一个值（对于* 点字符 *）。*'
- en: 'The plot() function works in stages, which means you can build up a graph in
    stages by issuing a series of commands. For example, as a base, we might first
    draw an empty graph, with only axes, like this:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot()`函数分阶段工作，这意味着你可以通过发出一系列命令逐步构建一个图表。例如，作为基础，我们可能首先绘制一个空图表，只包含坐标轴，如下所示：'
- en: plot(c(-3,3), c(-1,5), type = "n", xlab="x", ylab="y") This draws axes labeled
    *x* and *y*. The horizontal ( *x*) axis ranges from *−* 3
  id: totrans-999
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`plot(c(-3,3), c(-1,5), type = "n", xlab="x", ylab="y")` 这绘制了标记为*x*和*y*的坐标轴。水平轴（*x*）的范围从*−*3'
- en: to 3\. The vertical ( *y*) axis ranges from *−* 1 to 5\. The argument type="n"
    means that there is nothing in the graph itself.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 到3。垂直轴（*y*）的范围从*−*1到5。参数类型="n"表示图表本身没有任何内容。
- en: '**262**'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: '**262**'
- en: Chapter 12
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 第12章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 26](index-289_1.png)'
  id: totrans-1004
  prefs: []
  type: TYPE_IMG
  zh: '![Image 26](index-289_1.png)'
- en: '***12.1.2 Adding Lines: The abline() Function***'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.1.2 添加线条：`abline()`函数***'
- en: 'We now have an empty graph, ready for the next stage, which is adding a line:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个空图表，准备进入下一阶段，即添加线条：
- en: x <- c(1,2,3)
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`x <- c(1,2,3)`'
- en: y <- c(1,3,8)
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`y <- c(1,3,8)`'
- en: plot(x,y)
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`plot(x,y)`'
- en: lmout <- lm(y ~ x)
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`lmout <- lm(y ~ x)`'
- en: abline(lmout)
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`abline(lmout)`'
- en: After the call to plot(), the graph will simply show the three points, along
    with the *x*- and *y*- axes with hash marks. The call to abline() then adds a
    line to the current graph. Now, which line is this?
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`plot()`之后，图表将简单地显示三个点，以及带有刻度的*x*和*y*轴。然后`abline()`调用向当前图表添加一条线。现在，这条线是哪一条？
- en: As you learned in Section 1.5, the result of the call to the linear-regression
    function lm() is a class instance containing the slope and intercept of the fitted
    line, as well as various other quantities that don’t concern us here. We’ve assigned
    that class instance to lmout. The slope and intercept will now be in lmout$coefficients.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在第1.5节所学，线性回归函数`lm()`的调用结果是一个包含拟合线的斜率和截距以及各种其他不在此处关心的量的类实例。我们将该类实例赋值给`lmout`。斜率和截距现在将在`lmout$coefficients`中。
- en: So, what happens when we call abline()? This function simply draws
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们调用`abline()`时会发生什么？这个函数只是简单地绘制
- en: 'a straight line, with the function’s arguments treated as the intercept and
    slope of the line. For instance, the call abline(c(2,1)) draws this line on whatever
    graph you’ve built up so far:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 一条直线，函数的参数被视为直线的截距和斜率。例如，调用`abline(c(2,1))`将在你构建的任何图表上绘制这条线：
- en: '*y* = 2 + 1 *· x*'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = 2 + 1 *· x*'
- en: But abline() is written to take special action if it is called on a regression
    object (though, surprisingly, it is not a generic function). Thus, it will pick
    up the slope and intercept it needs from lmout$coefficients and plot that line.
    It superimposes this line onto the current graph, the one that graphs the three
    points. In other words, the new graph will show both the points and the line,
    as in Figure 12-2\.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 但`abline()`被编写为在回归对象上调用时执行特殊操作（尽管令人惊讶，它不是一个泛型函数）。因此，它将从`lmout$coefficients`中获取所需的斜率和截距，并绘制这条线。它将这条线叠加到当前图表上，即绘制三个点的图表。换句话说，新的图表将显示点和线，如图12-2所示。
- en: '*Figure 12-2: Using* abline()'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: '**263**'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: You can add more lines using the lines() function. Though there are many options,
    the two basic arguments to lines() are a vector of *x*-values and a vector of
    *y*-values. These are interpreted as ( *x*, *y*) pairs representing points to
    be added to the current graph, with lines connecting the points.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if X and Y are the vectors (1.5,2.5) and (3,3), you could use
    this call to add a line from (1.5,3) to (2.5,3) to the present graph:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: lines(c(1.5,2.5),c(3,3))
  id: totrans-1024
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you want the lines to “connect the dots,” but don’t want the dots themselves,
    include type="l" in your call to lines() or to plot(), as follows:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: plot(x,y,type="l")
  id: totrans-1026
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You can use the lty parameter in plot() to specify the type of line, such as
    solid or dashed. To see the types available and their codes, enter this command:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: help(par)
  id: totrans-1028
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***12.1.3 Starting a New Graph While Keeping the Old Ones***'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time you call plot(), directly or indirectly, the current graph window
    will be replaced by the new one. If you don’t want that to happen, use the command
    for your operating system:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: On Linux systems, call X11().
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: On a Mac, call macintosh().
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, call windows().
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: For instance, suppose you wish to plot two histograms of vectors X
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: 'and Y and view them side by side. On a Linux system, you would type the following:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: hist(x)
  id: totrans-1039
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: x11()
  id: totrans-1040
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: hist(y)
  id: totrans-1041
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***12.1.4 Extended Example: Two Density Estimates on the Same Graph***'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s plot nonparametric density estimates (these are basically smoothed histograms)
    for two sets of examination scores in the same graph. We use the function density()
    to generate the estimates. Here are the commands we issue:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: d1 = density(testscores$Exam1,from=0,to=100)
  id: totrans-1044
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d2 = density(testscores$Exam2,from=0,to=100)
  id: totrans-1045
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**264**'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 27](index-291_1.png)'
  id: totrans-1049
  prefs: []
  type: TYPE_IMG
- en: '![Image 28](index-291_2.png)'
  id: totrans-1050
  prefs: []
  type: TYPE_IMG
- en: plot(d1,main="",xlab="")
  id: totrans-1051
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lines(d2)
  id: totrans-1052
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: First, we compute nonparametric density estimates from the two variables, saving
    them in objects d1 and d2 for later use. We then call plot() to draw the curve
    for exam 1, at which point the plot looks like Figure 12-3\. We then call lines()
    to add exam 2’s curve to the graph, producing Figure 12-4\.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-3: Plot of first density*'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-4: Addition of second density*'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: '**265**'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: Note that we asked R to use blank labels for the figure as a whole and for the
    *x*-axis. Otherwise, R would have gotten such labels from d1, which would have
    been specific to exam 1\.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: Also note that we needed to plot exam 1 first. The scores there were less diverse,
    so the density estimate was narrower and taller. Had we plotted exam 2, with its
    shorter curve, first, exam 1’s curve would have been too tall for the plot window.
    Here, we first ran the two plots separately to see which was taller, but let’s
    consider a more general situation.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: Say we wish to write a broadly usable function that will plot several density
    estimates on the same graph. For this, we would need to automate the process of
    determining which density estimate is tallest. To do so, we would use the fact
    that the estimated density values are contained in the y component of the return
    value from the call to density(). We would then call max() on each density estimate
    and use which.max() to determine which density estimate is the tallest.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: The call to plot() both initiates the plot and draws the first curve. (Without
    specifying type="l", only the points would have been plotted.) The call to lines()
    then adds the second curve.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: '***12.1.5 Extended Example: More on the Polynomial Regression Example***'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: 'In Section 9.1.7, we defined a class "polyreg" that facilitates fitting polynomial
    regression models. Our code there included an implementation of the generic print()
    function. Let’s now add one for the generic plot() function: 1'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: polyfit(x,maxdeg) fits all polynomials up to degree maxdeg; y is
  id: totrans-1065
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: vector for response variable, x for predictor; creates an object of 3
  id: totrans-1067
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: class "polyreg", consisting of outputs from the various regression 4
  id: totrans-1068
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: models, plus the original data
  id: totrans-1069
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: polyfit <- function(y,x,maxdeg) {
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: 'pwrs <- powers(x,maxdeg) # form powers of predictor variable'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: 'lmout <- list() # start to build class'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: 'class(lmout) <- "polyreg" # create a new class'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:maxdeg) {
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: lmo <- lm(y ~ pwrs[,1:i])
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: extend the lm class here, with the cross-validated predictions
  id: totrans-1083
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '12'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: lmo$fitted.xvvalues <- lvoneout(y,pwrs[,1:i,drop=F])
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: lmout[[i]] <- lmo
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: lmout$x <- x
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: lmout$y <- y
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: return(lmout)
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: 'generic print() for an object fits of class "polyreg": print 21'
  id: totrans-1100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: cross-validated mean-squared prediction errors
  id: totrans-1101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '22'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: print.polyreg <- function(fits) {
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: 'maxdeg <- length(fits) - 2 # count lm() outputs only, not $x and $y **266**'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(fits$y)
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: tbl <- matrix(nrow=maxdeg,ncol=1)
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: cat("mean squared prediction errors, by degree\n")
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: colnames(tbl) <- "MSPE"
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:maxdeg) {
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: fi <- fits[[i]]
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: errs <- fits$y - fi$fitted.xvvalues
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: spe <- sum(errs^2)
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: tbl[i,1] <- spe/n
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: print(tbl)
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: generic plot(); plots fits against raw data
  id: totrans-1134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '38'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: plot.polyreg <- function(fits) {
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: 'plot(fits$x,fits$y,xlab="X",ylab="Y") # plot data points as background 40'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: maxdg <- length(fits) - 2
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: cols <- c("red","green","blue")
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: dg <- curvecount <- 1
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: while (dg < maxdg) {
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: prompt <- paste("RETURN for XV fit for degree",dg,"or type degree", 45
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: '"or q for quit ")'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '46'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: rl <- readline(prompt)
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: '47'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: dg <- if (rl == "") dg else if (rl != "q") as.integer(rl) else break 48
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: lines(fits$x,fits[[dg]]$fitted.values,col=cols[curvecount%%3 + 1])
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: '49'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: dg <- dg + 1
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: curvecount <- curvecount + 1
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: '51'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: '52'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: '53'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: '54'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: forms matrix of powers of the vector x, through degree dg
  id: totrans-1164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '55'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: powers <- function(x,dg) {
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: '56'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: pw <- matrix(x,nrow=length(x))
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: '57'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: prod <- x
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: '58'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 2:dg) {
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: '59'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: prod <- prod * x
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: '60'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: pw <- cbind(pw,prod)
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: '61'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: '62'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: return(pw)
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: '63'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: '64'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: '65'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: finds cross-validated predicted values; could be made much faster via 66
  id: totrans-1185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: matrix-update methods
  id: totrans-1186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '67'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: lvoneout <- function(y,xmat) {
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: '68'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(y)
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: '69'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: predy <- vector(length=n)
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: '70'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:n) {
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: '**267**'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: '71'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: regress, leaving out ith observation
  id: totrans-1199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '72'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: lmo <- lm(y[-i] ~ xmat[-i,])
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: '73'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: betahat <- as.vector(lmo$coef)
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '74'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: the 1 accommodates the constant term
  id: totrans-1205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '75'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: predy[i] <- betahat %*% c(1,xmat[i,])
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: '76'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: '77'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: return(predy)
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: '78'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: '79'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: '80'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: polynomial function of x, coefficients cfs
  id: totrans-1216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '81'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: poly <- function(x,cfs) {
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: '82'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: val <- cfs[1]
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: '83'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: prod <- 1
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: '84'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: dg <- length(cfs) - 1
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: '85'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:dg) {
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: '86'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: prod <- prod * x
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: '87'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: val <- val + cfs[i+1] * prod
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: '88'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: '89'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted, the only new code is plot.polyreg(). For convenience, the code is
    reproduced here:'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: generic plot(); plots fits against raw data
  id: totrans-1236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: plot.polyreg <- function(fits) {
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: 'plot(fits$x,fits$y,xlab="X",ylab="Y") # plot data points as background maxdg
    <- length(fits) - 2'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: cols <- c("red","green","blue")
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: dg <- curvecount <- 1
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: while (dg < maxdg) {
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: prompt <- paste("RETURN for XV fit for degree",dg,"or type degree",
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: '"or q for quit ")'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: rl <- readline(prompt)
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: dg <- if (rl == "") dg else if (rl != "q") as.integer(rl) else break lines(fits$x,fits[[dg]]$fitted.values,col=cols[curvecount%%3
    + 1])
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: dg <- dg + 1
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: curvecount <- curvecount + 1
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: As before, our implementation of the generic function takes the name of the
    class, which is plot.polyreg() here.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: The while loop iterates through the various polynomial degrees. We
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: cycle through three colors, by setting the vector cols; note the expression
    curvecount %%3 for this purpose.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: '**268**'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 29](index-295_1.png)'
  id: totrans-1256
  prefs: []
  type: TYPE_IMG
- en: 'The user can choose either to plot the next sequential degree or select a different
    one. The query, both user prompt and reading of the user’s reply, is done in this
    line:'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: rl <- readline(prompt)
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the R string function paste() to assemble a prompt, offering the user
    a choice of plotting the next fitted polynomial, plotting one of a different degree,
    or quitting. The prompt appears in the interactive R window in which we issued
    the plot() call. For instance, after taking the default choice twice, the command
    window looks like this:'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: plot(lmo)
  id: totrans-1260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: RETURN for XV fit for degree 1 or type degree or q for quit
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: RETURN for XV fit for degree 2 or type degree or q for quit
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: RETURN for XV fit for degree 3 or type degree or q for quit
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: The plot window looks like Figure 12-5\.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-5: Plotting a polynomial fit*'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: '***12.1.6 Adding Points: The points() Function***'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: 'The points() function adds a set of ( *x*, *y*) points, with labels for each,
    to the currently displayed graph. For instance, in our first example, suppose
    we entered this command:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: points(testscores$Exam1,testscores$Exam3,pch="+")
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: '**269**'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: The result would be to superimpose onto the current graph the points of the
    exam scores from that example, using plus signs (+) to mark them.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: 'As with most of the other graphics functions, there are many options, such
    as point color and background color. For instance, if you want a yellow background,
    type this command:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: par(bg="yellow")
  id: totrans-1274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now your graphs will have a yellow background, until you specify
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: otherwise.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: 'As with other functions, to explore the myriad of options, type this:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: help(par)
  id: totrans-1278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***12.1.7 Adding a Legend: The legend() Function***'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: 'The legend() function is used, not surprisingly, to add a legend to a multi-curve
    graph. This could tell the viewer something like, “The green curve is for the
    men, and the red curve displays the data for the women.” Type the following to
    see some nice examples:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: example(legend)
  id: totrans-1281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***12.1.8 Adding Text: The text() Function***'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: Use the text() function to place some text anywhere in the current graph.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: text(2.5,4,"abc")
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: This writes the text “abc” at the point (2.5,4) in the graph. The center of
    the string, in this case “b,” would go at that point.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: 'To see a more practical example, let’s add some labels to the curves in our
    exam scores graph, as follows:'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: text(46.7,0.02,"Exam 1")
  id: totrans-1288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: text(12.3,0.008,"Exam 2")
  id: totrans-1289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The result is shown in Figure 12-6\.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: In order to get a certain string placed exactly where you want it, you may need
    to engage in some trial and error. Or you may find the locator() function to be
    a much quicker way to go, as detailed in the next section.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: '**270**'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 30](index-297_1.png)'
  id: totrans-1295
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Placing text*'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: '***12.1.9 Pinpointing Locations: The locator() Function***'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: Placing text exactly where you wish can be tricky. You could repeatedly try
    different *x*- and *y*-coordinates until you find a good position, but the locator()
    function can save you a lot of trouble. You simply call the function and then
    click the mouse at the desired spot in the graph. The function returns the *x*-
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: 'and *y*-coordinates of your click point. Specifically, typing the following
    will tell R that you will click in one place in the graph:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: locator(1)
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click, R will tell you the exact coordinates of the point you clicked.
    Call locator(2) to get the locations of two places, and so on. (Warning: Make
    sure to include the argument.)'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: hist(c(12,5,13,25,16))
  id: totrans-1303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: locator(1)
  id: totrans-1304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $x
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 6.239237'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: $y
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1.221038'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: '**271**'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: This has R draw a histogram and then calls locator() with the argument 1, indicating
    we will click the mouse once. After the click, the function returns a list with
    components x and y, the *x*- and *y*-coordinates of the point where we clicked.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this information to place text, combine it with text():'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: text(locator(1),"nv=75")
  id: totrans-1314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here, text() was expecting an *x*-coordinate and a *y*-coordinate, specifying
    the point at which to draw the text “nv=75.” The return value of locator() supplied
    those coordinates.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: '***12.1.10 Restoring a Plot***'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: R has no “undo” command. However, if you suspect you may need to undo your next
    step when building a graph, you can save it using recordPlot() and then later
    restore it with replayPlot().
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: Less formally but more conveniently, you can put all the commands
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: you’re using to build up a graph in a file and then use source(), or cut and
    paste with the mouse, to execute them. If you change one command, you can redo
    the whole graph by sourcing or copying and pasting your file.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
- en: For our current graph, for instance, we could create file named
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: 'examplot.R with the following contents:'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: d1 = density(testscores$Exam1,from=0,to=100)
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: d2 = density(testscores$Exam2,from=0,to=100)
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: plot(d1,main="",xlab="")
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
- en: lines(d2)
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: text(46.7,0.02,"Exam 1")
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: text(12.3,0.008,"Exam 2")
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: 'If we decide that the label for exam 1 was a bit too far to the right, we can
    edit the file and then either do the copy-and-paste or execute the following:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: source("examplot.R")
  id: totrans-1329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**12.2 Customizing Graphs**'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen how easy it is to build simple graphs in stages, starting with plot().
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: Now you can begin to enhance those graphs, using the many options R
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: provides.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: '***12.2.1 Changing Character Sizes: The cex Option***'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: The cex (for *character expand*) function allows you to expand or shrink characters
    within a graph, which can be very useful. You can use it as a named **272**
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: 'parameter in various graphing functions. For instance, you may wish to draw
    the text “abc” at some point, say (2.5,4), in your graph but with a larger font,
    in order to call attention to this particular text. You could do this by typing
    the following:'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
- en: text(2.5,4,"abc",cex = 1.5)
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: This prints the same text as in our earlier example but with characters 1.5
    times the normal size.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: '***12.2.2 Changing the Range of Axes: The xlim and ylim Options***'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
- en: You may wish to have the ranges on the *x*- and *y*-axes of your plot be broader
    or narrower than the default. This is especially useful if you will be displaying
    several curves in the same graph.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: You can adjust the axes by specifying the xlim and/or ylim parameters in your
    call to plot() or points(). For example, ylim=c(0,90000) specifies a range on
    the *y*-axis of 0 to 90,000\.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: If you have several curves and do not specify xlim and/or ylim, you should draw
    the tallest curve first so there is room for all of them. Otherwise, R will fit
    the plot to the first one your draw and then cut off taller ones at the top!
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: 'We took this approach earlier, when we plotted two density estimates on the
    same graph (Figures 12-3 and 12-4). Instead, we could have first found the highest
    values of the two density estimates. For d1, we find the following:'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: d1
  id: totrans-1346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Call:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: density.default(x = testscores$Exam1, from = 0, to = 100)
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: 'Data: testscores$Exam1 (39 obs.);'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: Bandwidth 'bw' = 6.967
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: x
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: y
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: Min.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: ': 0'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: Min.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: :1.423e-07
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: '1st Qu.: 25'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: 1st Qu.:1.629e-03
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: 'Median : 50'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: Median :9.442e-03
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: Mean
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: ': 50'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: Mean
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
- en: :9.844e-03
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: '3rd Qu.: 75'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
- en: 3rd Qu.:1.756e-02
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: Max.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: :100
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: Max.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: :2.156e-02
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the largest y-value is 0.022\. For d2, it was only 0.017\. That means we
    should have plenty of room if we set ylim at 0.03\. Here is how we could draw
    the two plots on the same picture:'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: plot(c(0, 100), c(0, 0.03), type = "n", xlab="score", ylab="density")
  id: totrans-1372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lines(d2)
  id: totrans-1373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lines(d1)
  id: totrans-1374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Graphics
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: '**273**'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 31](index-300_1.jpg)'
  id: totrans-1378
  prefs: []
  type: TYPE_IMG
- en: '![Image 32](index-300_2.jpg)'
  id: totrans-1379
  prefs: []
  type: TYPE_IMG
- en: First we drew the bare-bones plot—just axes without innards, as shown in Figure
    12-7\. The first two arguments to plot() give xlim and ylim, so that the lower
    and upper limits on the Y axis will be 0 and 0.03\. Calling lines() twice then
    fills in the graph, yielding Figures 12-8 and 12-9\. (Either of the two lines()
    calls could come first, as we’ve left enough room.)
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-7: Axes only*'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12-8: Addition of* d2'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: '**274**'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 33](index-301_1.jpg)'
  id: totrans-1386
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-9: Addition of* d1'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: '***12.2.3 Adding a Polygon: The polygon() Function***'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: You can use polygon() to draw arbitrary polygonal objects. For example, the
    following code draws the graph of the function *f* ( *x*) = 1 *− e−x* and then
    adds a rectangle that approximates the area under the curve from *x* = 1.2 to
    *x* = 1.4\.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
- en: f <- function(x) return(1-exp(-x))
  id: totrans-1390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: curve(f,0,2)
  id: totrans-1391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: polygon(c(1.2,1.4,1.4,1.2),c(0,0,f(1.3),f(1.3)),col="gray") The result is shown
    in Figure 12-10\.
  id: totrans-1392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the call to polygon() here, the first argument is the set of *x*-coordinates
    for the rectangle, and the second argument specifies the *y*-coordinates. The
    third argument specifies that the rectangle in this case should be shaded in solid
    gray.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, we could use the density argument to fill the rectangle
    with striping. This call specifies 10 lines per inch:'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: polygon(c(1.2,1.4,1.4,1.2),c(0,0,f(1.3),f(1.3)),density=10)
  id: totrans-1395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Graphics
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: '**275**'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 34](index-302_1.jpg)'
  id: totrans-1399
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-10: Rectangular area strip*'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: '***12.2.4 Smoothing Points: The lowess() and loess() Functions***'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: Just plotting a cloud of points, connected or not, may give you nothing but
    an uninformative mess. In many cases, it is better to smooth out the data by fitting
    a nonparametric regression estimator such as lowess().
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do that for our test score data. We’ll plot the scores of exam 2
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: 'against those of exam 1:'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: plot(testscores)
  id: totrans-1405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lines(lowess(testscores))
  id: totrans-1406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The result is shown in Figure 12-11\.
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: A newer alternative to lowess() is loess(). The two functions are similar but
    have different defaults and other options. You need some advanced knowledge of
    statistics to appreciate the differences. Use whichever you find gives better
    smoothing.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: '***12.2.5 Graphing Explicit Functions***'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: Say you want to plot the function *g*( *t*) = ( *t* 2 + 1)0 *.* 5 for t between
    0 and 5\.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: 'You could use the following R code:'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: 'g <- function(t) { return (t^2+1)^0.5 } # define g()'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: 'x <- seq(0,5,length=10000) # x = [0.0004, 0.0008, 0.0012,..., 5]'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: 'y <- g(x) # y = [g(0.0004), g(0.0008), g(0.0012), ..., g(5)]'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: plot(x,y,type="l")
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: '**276**'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 35](index-303_1.jpg)'
  id: totrans-1419
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-11: Smoothing the exam score relation*'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: 'But you could avoid some work by using the curve() function, which basically
    uses the same method:'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: curve((x^2+1)^0.5,0,5)
  id: totrans-1422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you are adding this curve to an existing plot, use the add argument:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: curve((x^2+1)^0.5,0,5,add=T)
  id: totrans-1424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The optional argument n has the default value 101, meaning that the function
    will be evaluated at 101 equally spaced points in the specified range of x.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: Use just enough points for visual smoothness. If you find 101 is not enough,
    experiment with higher values of n.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use plot(), as follows:'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: f <- function(x) return((x^2+1)^0.5)
  id: totrans-1428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'plot(f,0,5) # the argument must be a function name'
  id: totrans-1429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here, the call plot() leads to calling plot.function(), the implementation of
    the generic plot() function for the function class.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: Again, the approach is your choice; use whichever one you prefer.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: '***12.2.6 Extended Example: Magnifying a Portion of a Curve***'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: After you use curve() to graph a function, you may want to “zoom in” on one
    portion of the curve. You could do this by simply calling curve() again on Graphics
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: '**277**'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: the same function but with a restricted *x* range. But suppose you wish to display
    the original plot and the close-up one in the same picture. Here, we will develop
    a function, which we’ll name inset(), to do this.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to avoid redoing the work that curve() did in plotting the original
    graph, we will modify its code slightly to save that work, via a return value.
    We can do this by taking advantage of the fact that you can easily inspect the
    code of R functions written in R (as opposed to the fundamental R functions written
    in C), as follows:'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: curve
  id: totrans-1439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: function (expr, from = NULL, to = NULL, n = 101, add = FALSE,
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: type = "l", ylab = NULL, log = NULL, xlim = NULL, ...)
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: sexpr <- substitute(expr)
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: if (is.name(sexpr)) {
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: '...lots of lines omitted here...'
  id: totrans-1451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: x <- if (lg != "" && "x" %in% strsplit(lg, NULL)[[1]]) {
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: if (any(c(from, to) <= 0))
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: stop("'from' and 'to' must be > 0 with log=\"x\"") 11
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: exp(seq.int(log(from), log(to), length.out = n))
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: else seq.int(from, to, length.out = n)
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: y <- eval(expr, envir = list(x = x), enclos = parent.frame())
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: if (add)
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: lines(x, y, type = type, ...)
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: else plot(x, y, type = type, ylab = ylab, xlim = xlim, log = lg, ...) 18
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: The code forms vectors x and y, consisting of the *x*- and *y*-coordinates of
    the curve to be plotted, at n equally spaced points in the range of *x*. Since
    we’ll make use of those in inset(), let’s modify this code to return x and y.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the modified version, which we’ve named crv():'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: crv
  id: totrans-1475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: function (expr, from = NULL, to = NULL, n = 101, add = FALSE,
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: type = "l", ylab = NULL, log = NULL, xlim = NULL, ...)
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: sexpr <- substitute(expr)
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: if (is.name(sexpr)) {
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: '...lots of lines omitted here...'
  id: totrans-1487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: x <- if (lg != "" && "x" %in% strsplit(lg, NULL)[[1]]) {
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: if (any(c(from, to) <= 0))
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: stop("'from' and 'to' must be > 0 with log=\"x\"") 11
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: exp(seq.int(log(from), log(to), length.out = n))
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: else seq.int(from, to, length.out = n)
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: y <- eval(expr, envir = list(x = x), enclos = parent.frame())
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: if (add)
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: '**278**'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: lines(x, y, type = type, ...)
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: else plot(x, y, type = type, ylab = ylab, xlim = xlim, log = lg, ...) 18
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: 'return(list(x=x,y=y)) # this is the only modification'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: Now we can get to our inset() function.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: 'savexy: list consisting of x and y vectors returned by crv()'
  id: totrans-1515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: 'x1,y1,x2,y2: coordinates of rectangular region to be magnified'
  id: totrans-1517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: 'x3,y3,x4,y4: coordinates of inset region'
  id: totrans-1519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: inset <- function(savexy,x1,y1,x2,y2,x3,y3,x4,y4) {
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: 'rect(x1,y1,x2,y2) # draw rectangle around region to be magnified'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: 'rect(x3,y3,x4,y4) # draw rectangle around the inset'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: get vectors of coordinates of previously plotted points
  id: totrans-1527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: savex <- savexy$x
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: savey <- savexy$y
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: get subscripts of xi our range to be magnified
  id: totrans-1533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '11'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(savex)
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: xvalsinrange <- which(savex >= x1 & savex <= x2)
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: yvalsforthosex <- savey[xvalsinrange]
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: check that our first box contains the entire curve for that X range 15
  id: totrans-1541
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: if (any(yvalsforthosex < y1 | yvalsforthosex > y2)) {
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: print("Y value outside first box")
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: return()
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: record some differences
  id: totrans-1550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '20'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: x2mnsx1 <- x2 - x1
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: x4mnsx3 <- x4 - x3
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: y2mnsy1 <- y2 - y1
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: y4mnsy3 <- y4 - y3
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: for the ith point in the original curve, the function plotpt() will 25
  id: totrans-1560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: calculate the position of this point in the inset curve
  id: totrans-1561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '26'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: plotpt <- function(i) {
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: newx <- x3 + ((savex[i] - x1)/x2mnsx1) * x4mnsx3
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: newy <- y3 + ((savey[i] - y1)/y2mnsy1) * y4mnsy3
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: return(c(newx,newy))
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: newxy <- sapply(xvalsinrange,plotpt)
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: lines(newxy[1,],newxy[2,])
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try it out.
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: xyout <- crv(exp(-x)*sin(1/(x-1.5)),0.1,4,n=5001)
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: inset(xyout,1.3,-0.3,1.47,0.3, 2.5,-0.3,4,-0.1)
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: The resulting plot looks like Figure 12-12\.
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: '**279**'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 36](index-306_1.png)'
  id: totrans-1585
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-12: Adding an inset graph*'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: '**12.3 Saving Graphs to Files**'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: The R graphics display can consist of various graphics devices. The default
    device is the screen. If you want to save a graph to a file, you must set up another
    device.
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through the basics of R graphics devices first to introduce R
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: graphics device concepts, and then discuss a second approach that is much more
    direct and convenient.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: '***12.3.1 R Graphics Devices***'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s open a file:'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: pdf("d12.pdf")
  id: totrans-1593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This opens the file *d12.pdf*. We now have two devices open, as we can confirm:'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: dev.list()
  id: totrans-1595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: X11 pdf
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: '**280**'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: 'The screen is named X11 when R runs on Linux. (It’s named windows on Windows
    systems.) It is device number 2 here. Our PDF file is device number 3\. Our active
    device is the PDF file:'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 当R在Linux上运行时，屏幕被命名为X11。（在Windows系统上被命名为windows。）在这里，它是设备号2。我们的PDF文件是设备号3。我们的活动设备是PDF文件：
- en: dev.cur()
  id: totrans-1603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dev.cur()
- en: pdf
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: pdf
- en: '3'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: All graphics output will now go to this file instead of to the screen. But what
    if we wish to save what’s already on the screen?
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 所有图形输出现在将发送到这个文件而不是屏幕。但如果我们希望保存屏幕上已有的内容呢？
- en: '***12.3.2 Saving the Displayed Graph***'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.3.2 保存显示的图形***'
- en: 'One way to save the graph currently displayed on the screen is to reestablish
    the screen as the current device and then copy it to the PDF device, which is
    3 in our example, as follows:'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 保存当前屏幕上显示的图形的一种方法是将屏幕重新设置为当前设备，然后将其复制到PDF设备，在我们的例子中是3，如下所示：
- en: dev.set(2)
  id: totrans-1609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dev.set(2)
- en: X11
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: X11
- en: '2'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: dev.copy(which=3)
  id: totrans-1612
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dev.copy(which=3)
- en: pdf
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: pdf
- en: '3'
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: But actually, it is best to set up a PDF device as shown earlier and then rerun
    whatever analyses led to the current screen. This is because the copy operation
    can result in distortions due to mismatches between screen devices and file devices.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，最好像前面所示设置一个PDF设备，然后重新运行导致当前屏幕的任何分析。这是因为复制操作可能会由于屏幕设备和文件设备之间的不匹配而产生扭曲。
- en: '***12.3.3 Closing an R Graphics Device***'
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: '***12.3.3 关闭R图形设备***'
- en: 'Note that the PDF file we create is not usable until we close it, which we
    do as follows:'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们创建的PDF文件在关闭之前是不可用的，我们按照以下方式关闭：
- en: dev.set(3)
  id: totrans-1618
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dev.set(3)
- en: pdf
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: pdf
- en: '3'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: dev.off()
  id: totrans-1621
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dev.off()
- en: X11
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: X11
- en: '2'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: You can also close the device by exiting R, if you’re finished working with
    it. But in future versions of R, this behavior may not exist, so it’s probably
    better to proactively close.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完成与R的工作，你也可以通过退出R来关闭设备。但在R的未来版本中，这种行为可能不存在，所以最好是主动关闭。
- en: Graphics
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 图形
- en: '**281**'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: '**281**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 37](index-308_1.jpg)'
  id: totrans-1628
  prefs: []
  type: TYPE_IMG
  zh: '![图像37](index-308_1.jpg)'
- en: '**12.4 Creating Three-Dimensional Plots**'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.4 创建三维图形**'
- en: R offers a number of functions to plot data in three dimensions such as persp()
    and wireframe(), which draw surfaces, and cloud(), which draws three-dimensional
    scatter plots. Here, we’ll look at a simple example that uses wireframe().
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: R提供了一些函数来绘制三维数据，如persp()和wireframe()，它们绘制表面，以及cloud()，它绘制三维散点图。在这里，我们将查看一个使用wireframe()的简单示例。
- en: library(lattice)
  id: totrans-1631
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: library(lattice)
- en: a <- 1:10
  id: totrans-1632
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a <- 1:10
- en: b <- 1:15
  id: totrans-1633
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b <- 1:15
- en: eg <- expand.grid(x=a,y=b)
  id: totrans-1634
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: eg <- expand.grid(x=a,y=b)
- en: eg$z <- eg$x^2 + eg$x * eg$y
  id: totrans-1635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: eg$z <- eg$x^2 + eg$x * eg$y
- en: wireframe(z ~ x+y, eg)
  id: totrans-1636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: wireframe(z ~ x+y, eg)
- en: First, we load the lattice library. Then the call to expand.grid() creates a
    data frame, consisting of two columns named x and y, in all possible combinations
    of the values of the two inputs. Here, a and b had 10 and 15 values, respectively,
    so the resulting data frame will have 150 rows. (Note that the data frame that
    is input to wireframe() does not need to be created by expand.grid().)
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载了lattice库。然后，调用expand.grid()创建了一个数据框，包含名为x和y的两列，包含两个输入值的所有可能组合。在这里，a和b分别有10和15个值，所以结果数据框将有150行。（注意，输入wireframe()的数据框不需要由expand.grid()创建。）
- en: We then added a third column, named z, as a function of the first two columns.
    Our call to wireframe() creates the graph. The arguments, given in regression
    model form, specify that z is to be graphed against x and y. Of course, z, x,
    and y refer to names of columns in eg. The result is shown in Figure 12-13\.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后添加了第三列，命名为z，作为前两列的函数。我们的wireframe()调用创建了图形。以回归模型形式给出的参数指定z要相对于x和y进行绘图。当然，z、x和y指的是eg中的列名。结果如图12-13所示。
- en: '*Figure 12-13: Example of using* wireframe()'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-13：使用wireframe()的示例*'
- en: '**282**'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: '**282**'
- en: Chapter 12
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 第12章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: All the points are connected as a surface (like connecting points by lines in
    two dimensions). In contrast, with cloud(), the points are isolated.
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 所有点都连接成一个表面（就像在二维中通过线连接点一样）。相比之下，使用cloud()时，点则是孤立的。
- en: For wireframe(), the ( *x*, *y*) pairs must form a rectangular grid, though
    not necessarily be evenly spaced.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 对于wireframe()，(*x*, *y*)对必须形成一个矩形网格，尽管不一定均匀分布。
- en: The three-dimensional plotting functions have many different options.
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 三维绘图函数有许多不同的选项。
- en: For instance, a nice one for wireframe() is shade=T, which makes the data easier
    to see. Many functions, some with elaborate options, and whole new graphics packages
    work at a higher (read “more convenient and powerful”) level of abstraction than
    R’s base graphics package. For more information, refer to the books cited in footnote
    1 at the beginning of this chapter.
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: '**283**'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 38](index-311_1.png)'
  id: totrans-1651
  prefs: []
  type: TYPE_IMG
- en: '**13**'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: '**DEBUGGING**'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: Programmers often find that they spend
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: more time debugging a program than
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: actually writing it. Good debugging skills
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: are invaluable. In this chapter, we’ll discuss
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: debugging in R.
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: '**13.1 Fundamental Principles of Debugging**'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: Beware of bugs in the above code; I have only proved it correct,
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: not tried it.
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: —Donald Knuth, pioneer of computer science
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: Though debugging is an art rather than a science, it involves some fundamental
    principles. Here, we’ll look at some debugging best practices.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: '***13.1.1 The Essence of Debugging: The Principle of Confirmation***'
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: As Pete Salzman and I said in our book on debugging, *The Art of Debugging,*
    *with GDB, DDD, and Eclipse* (No Starch Press, 2008), the principle of confirmation
    is the essence of debugging.
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: Fixing a buggy program is a process of confirming, one by one, that the many
    things you *believe* to be true about the code actually *are* true. When you find
    that one of your assumptions is *not* true, you have found a clue to the location
    (if not the exact nature) of
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: a bug.
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of saying this is, “Surprises are good!” For example, say you have
    the following code:'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: x <- y^2 + 3*g(z,2)
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: w <- 28
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: if (w+q > 0) u <- 1 else v <- 10
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: Do you think the value of your variable x should be 3 after x is assigned?
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: Confirm it! Do you think the else will be executed, not the if on that third
    line? Confirm it!
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, one of these assertions that you are so sure of will turn out to
    not confirm. Then you will have pinpointed the likely location of the error, thus
    enabling you to focus on the nature of the error.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: '***13.1.2 Start Small***'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: At least at the beginning of the debugging process, stick to small, simple test
    cases. Working with large data objects may make it harder to think about the problem.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you should eventually test your code on large, complicated cases,
    but start small.
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: '***13.1.3 Debug in a Modular, Top-Down Manner***'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: Most good software developers agree that code should be written in a modular
    manner. Your first-level code should not be longer than, say, a dozen lines, with
    much of it consisting of function calls. And those functions should not be too
    lengthy and should call other functions if necessary. This makes the code easier
    to organize during the writing stage and easier for others to understand when
    it comes time for the code to be extended.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: 'You should debug in a top-down manner, too. Suppose that you have set the debug
    status of your function f() (that is, you have called debug(f), to be explained
    shortly) and f() contains this line:'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 你也应该以自顶向下的方式进行调试。假设你已经设置了函数 f() 的调试状态（即，你已经调用了 debug(f)，稍后将会解释），并且 f() 包含以下这行代码：
- en: y <- g(x,8)
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: y <- g(x,8)
- en: You should take an “innocent until proven guilty” approach to g(). Do *not*
    call debug(g) yet. Execute that line and see if g() returns the value you expect.
    If it does, then you’ve just avoided the time-consuming process of single-stepping
    through g(). If g() returns the wrong value, then now is the time to call debug(g).
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该对 g() 采用“无罪推定”的方法。**不要**立即调用 debug(g)。执行该行并查看 g() 是否返回你期望的值。如果它确实返回了，那么你刚刚避免了单步调试
    g() 的耗时过程。如果 g() 返回了错误的值，那么现在是调用 debug(g) 的时候了。
- en: '**286**'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: '**286**'
- en: Chapter 13
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***13.1.4 Antibugging***'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: '***13.1.4 抗错误调试***'
- en: 'You may adopt some “antibugging” strategies as well. Suppose you have a section
    of code in which a variable x should be positive. You could insert this line:'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以采用一些“抗错误”策略。假设你有一段代码，其中变量 x 应该是正数。你可以插入以下这行代码：
- en: stopifnot(x > 0)
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: stopifnot(x > 0)
- en: 'If there is a bug earlier in the code that renders x equal to, say, *−* 12,
    the call to stopifnot() will bring things to a halt right there, with an error
    message like this:'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码中较早的地方有一个错误，使得 x 等于，比如说，*−* 12，那么 stopifnot() 的调用将立即停止，并显示如下错误信息：
- en: 'Error: x > 0 is not TRUE'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：x > 0 不为真
- en: (C programmers may notice the similarity to C’s assert statement.)
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: （C 程序员可能会注意到这与 C 的 assert 语句的相似性。）
- en: After fixing a bug and testing the new code, you might want to keep that code
    handy so you can check later that the bug did not somehow reappear.
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 修复错误并测试新代码后，你可能想保留这段代码，以便稍后检查错误是否以某种方式再次出现。
- en: '**13.2 Why Use a Debugging Tool?**'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.2 为什么使用调试工具？**'
- en: 'In the old days, programmers would perform the debugging confirmation process
    by temporarily inserting print statements into their code and rerunning the program
    to see what printed out. For example, to confirm that x = 3 in our previous code,
    we would insert into our code a statement that printed the value of x and do something
    similar for the if-else, like this: x <- y^2 + 3*g(z,2)'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，程序员会通过临时在代码中插入打印语句并重新运行程序来执行调试确认过程，以查看打印了什么。例如，为了确认我们之前代码中的 x = 3，我们会在代码中插入一个打印
    x 值的语句，并对 if-else 做类似处理，如下所示：x <- y^2 + 3*g(z,2)
- en: cat("x =",x,"\n")
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: cat("x =",x,"\n")
- en: w <- 28
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: w <- 28
- en: if (w+q > 0) {
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: if (w+q > 0) {
- en: u <- 1
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: u <- 1
- en: print("the 'if' was done")
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: print("the 'if' was done")
- en: '} else {'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: v <- 10
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: v <- 10
- en: print("the 'else' was done")
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: print("the 'else' was done")
- en: '}'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: We would rerun the program and inspect the feedback printed out. We would then
    remove the print statements and put in new ones to track down the next bug.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会重新运行程序并检查打印出的反馈。然后我们会移除打印语句并插入新的语句以追踪下一个错误。
- en: This manual process is fine for one or two cycles, but it gets really tedious
    during a long debugging session. And worse, all that editing work distracts your
    attention, making it harder to concentrate on finding the bug.
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 这种手动过程对于一两个循环来说是可以的，但在长时间的调试会话中会变得非常繁琐。更糟糕的是，所有这些编辑工作都会分散你的注意力，使你更难集中精力寻找错误。
- en: Debugging
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 调试
- en: '**287**'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: '**287**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: So, debugging by inserting print statements into your code is slow, cum-bersome,
    and distracting. If you are serious about programming in any particular language,
    you should seek a good debugging tool for that language.
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过在代码中插入打印语句进行调试是缓慢的、繁琐的，并且会分散注意力。如果你对任何特定的编程语言认真负责，你应该寻找该语言的优秀调试工具。
- en: Using a debugging tool will make it much easier to query the values of variables,
    check whether the if or the else gets executed, and so on. Moreover, if your bug
    causes an execution error, debugging tools can analyze it for you, possibly providing
    major clues as to the source of the error. All of this will increase your productivity
    substantially.
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试工具将使查询变量值、检查是否执行了 if 或 else 等操作变得容易得多。此外，如果你的错误导致执行错误，调试工具可以为你分析它，可能提供关于错误来源的重要线索。所有这些都将大大提高你的生产力。
- en: '**13.3 Using R Debugging Facilities**'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.3 使用 R 调试工具**'
- en: The R base package includes a number of debugging facilities, and more functional
    debugging packages are also available. We’ll discuss both the base facilities
    and other packages, and our extended example will present a fully detailed debugging
    session.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: '***13.3.1 Single-Stepping with the debug() and browser() Functions***'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: The core of R’s debugging facility consists of the *browser*. It allows you
    to single-step through your code, line by line, taking a look around as you go.
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: You can invoke the browser through a call to either the debug() or browser()
    function.
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
- en: R’s debugging facility is specific to individual functions. If you believe there
    is a bug in your function f(), you can make the call debug(f) to set the debug
    status for the function f(). This means that from that point onward, each time
    you call the function, you will automatically enter the browser at the beginning
    of the function. Calling undebug(f) will unset the debug status of the function
    so that entry to the function will no longer invoke the browser.
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you place a call to browser() at some line within f(),
    the browser will be invoked only when execution reaches that line. You then can
    single-step through your code until you exit the function. If you believe the
    bug’s location is not near the beginning of the function, you probably don’t want
    to be single-stepping from the beginning, so this approach is more direct.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: Readers who have used C debuggers such as GDB (the GNU debugger)
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: will find similarity here, but some aspects will come as a surprise. As noted,
    for instance, debug() is called on the function level, not on the overall program
    level. If you believe you have bugs in several of your functions, you’ll need
    to call debug() on each one.
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: It can become tedious to call debug(f) and then undebug(f) when you just want
    to go through one debugging session for f(). Starting with R 2.10, one can now
    call debugonce() instead; calling debugonce(f) puts f() into debugging status
    the first time you execute it, but that status is reversed immediately upon exit
    from the function.
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: '**288**'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: '***13.3.2 Using Browser Commands***'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
- en: While you are in the browser, the prompt changes from *>* to Browse[d] *>* .
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: '(Here, d is the depth of the call chain.) You may submit any of the following
    commands at that prompt:'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: 'n (for *next*): Tells R to execute the next line and then pause again. Hitting
    ENTER causes this action, too.'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: 'c (for *continue*): This is like n, except that several lines of code may be
    executed before the next pause. If you are currently in a loop, this command will
    result in the remainder of the loop being executed and then pausing upon exit
    from the loop. If you are in a function but not in a loop, the remainder of the
    function will be executed before the next pause.'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: 'Any R command: While in the browser, you are still in R’s interactive mode
    and thus can query the value of, say, x by simply typing x. Of course, if you
    have a variable with the same name as a browser command, you must explicitly call
    something like print(), as in print(n).'
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 任何R命令：在浏览器中，您仍然处于R的交互模式，因此可以通过简单地输入x来查询变量的值。当然，如果您有一个与浏览器命令同名变量，您必须显式调用类似print()的东西，例如print(n)。
- en: •
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'where: This prints a *stack trace*. It displays what sequence of function calls
    led execution to the current location.'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：这将打印一个*堆栈跟踪*。它显示了导致执行到达当前位置的函数调用序列。
- en: •
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'Q: This quits the browser, bringing you back to R’s main interactive mode.'
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 'Q: 这将退出浏览器，带您回到R的主交互模式。'
- en: '***13.3.3 Setting Breakpoints***'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: '***13.3.3 设置断点***'
- en: Calling debug(f) places a call to browser() at the beginning of f(). However,
    this may be too coarse a tool in some cases. If you suspect that the bug is in
    the middle of the function, it’s wasteful to trudge through all the intervening
    code.
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 调用debug(f)将在f()的开始处放置一个browser()调用。然而，在某些情况下，这可能是一个过于粗糙的工具。如果您怀疑错误在函数的中间，逐行遍历所有中间代码是浪费时间的。
- en: The solution is to set *breakpoints* at certain key locations of your code—
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在代码的某些关键位置设置*断点*—
- en: places where you want execution to be paused. How can this be done in R?
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要执行暂停的地方。在R中如何做到这一点？
- en: You can call browser directly or use the setBreakpoint() function (with R version
    2.10 and later).
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接调用browser或使用setBreakpoint()函数（R版本2.10及以后）。
- en: '**13.3.3.1 Calling browser() Directly**'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.3.3.1 直接调用browser()**'
- en: You can set a breakpoint by simply inserting calls to browser() at the places
    of interest in your code. This has the effect, essentially, of setting breakpoints
    there.
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在代码中感兴趣的地方插入browser()调用来设置断点。这基本上具有设置断点的效果。
- en: 'You can make invoking the browser conditional so that it is entered only in
    specified situations. Use the expr argument to define those situations. For instance,
    suppose you suspect that your bug arises only when a certain variable s is larger
    than 1\. You could use this code:'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将调用浏览器的条件设置为仅在指定情况下执行。使用expr参数来定义这些情况。例如，假设您怀疑您的错误仅在某个变量s大于1时出现。您可以使用以下代码：
- en: browser(s > 1)
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: browser(s > 1)
- en: Debugging
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 调试
- en: '**289**'
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: '**289**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'The browser will be invoked only if s is larger than 1\. The following would
    have the same effect:'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当s大于1时，浏览器才会被调用。以下会有相同的效果：
- en: if (s > 1) browser()
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: if (s > 1) browser()
- en: 'Calling the browser directly, rather than entering the debugger via debug()
    is very useful in situations in which you have a loop with many iterations and
    the bug surfaces only after, say, the 50th iteration. If the loop index is i,
    then you could write this:'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: 直接调用browser，而不是通过debug()进入调试器，在您有一个许多迭代的循环并且错误仅在，比如说，第50次迭代后出现的情况下非常有用。如果循环索引是i，那么您可以编写以下内容：
- en: if (i > 49) browser()
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: if (i > 49) browser()
- en: That way, you would avoid the tedium of stepping through the first 49
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您就可以避免逐行执行前49次迭代的无聊。
- en: iterations!
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代！
- en: '**13.3.3.2 Using the setBreakpoint() Function**'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.3.3.2 使用setBreakpoint()函数**'
- en: Starting with R 2.10, you can use setBreakpoint() in the format
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 从R 2.10版本开始，您可以使用setBreakpoint()格式
- en: setBreakpoint( *filename,linenumber*)
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: setBreakpoint( *filename,linenumber*)
- en: This will result in browser() being called at line *linenumber* of our source
    file *filename*.
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的源文件*filename*的第*linenumber*行调用browser()。
- en: 'This is especially useful when you are in the midst of using the debugger,
    single-stepping through code. Say you are currently at line 12 of your source
    file *x.R* and want to have a breakpoint at line 28\. Instead of exiting the debugger,
    adding a call to browser() at line 28, and then re-entering the function, you
    could simply type this:'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 这在您正在使用调试器，逐行单步执行代码时特别有用。比如说，您目前位于源文件*x.R*的第12行，并想在第28行设置一个断点。您不必退出调试器，在第28行添加对browser()的调用，然后重新进入函数，您只需简单地输入以下内容：
- en: setBreakpoint("x.R",28)
  id: totrans-1761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: setBreakpoint("x.R",28)
- en: You could then resume execution within the debugger, say by issuing the c command.
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在调试器中继续执行，例如通过发出c命令。
- en: 'The setBreakpoint() function works by calling the trace() function, discussed
    in the next section. Thus, to cancel the breakpoint, you cancel the trace. For
    instance, if we had called setBreakpoint() at a line in the function g(), we would
    cancel the breakpoint by typing the following:'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: setBreakpoint() 函数通过调用下一节中讨论的 trace() 函数来工作。因此，要取消断点，您需要取消跟踪。例如，如果我们曾在函数 g()
    的某一行调用 setBreakpoint()，我们可以通过输入以下内容来取消断点：
- en: untrace(g)
  id: totrans-1764
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: untrace(g)
- en: You can call setBreakpoint() whether or not you are currently in the debugger.
    If you are not currently running the debugger and you execute the affected function
    and hit the breakpoint during that execution, you will be put into the browser
    automatically. This is similar to the case of browser(), but using this approach,
    you save yourself the trouble of changing your code via your text editor.
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在是否在调试器中时调用 setBreakpoint()。如果您当前没有运行调试器，并且执行受影响的函数并在执行过程中遇到断点，您将自动进入浏览器。这与
    browser() 的情况类似，但使用这种方法，您可以省去通过文本编辑器更改代码的麻烦。
- en: '**290**'
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: '**290**'
- en: Chapter 13
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***13.3.4 Tracking with the trace() Function***'
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: '***13.3.4 使用 trace() 函数进行跟踪***'
- en: 'The trace() function is flexible and powerful, though it takes some initial
    effort to learn. We will discuss some of the simpler usage forms here, beginning
    with the following:'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: trace() 函数灵活且功能强大，尽管学习它需要一些初始努力。我们将在以下内容中讨论一些简单的用法形式，从以下内容开始：
- en: trace(f,t)
  id: totrans-1771
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: trace(f,t)
- en: 'This call instructs R to call the function t() every time we enter the function
    f(). For instance, say we wish to set a breakpoint at the beginning of the function
    gy(). We could use this command:'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用指示 R 在每次进入函数 f() 时调用函数 t()。例如，如果我们希望在函数 gy() 的开始处设置断点，我们可以使用以下命令：
- en: trace(gy,browser)
  id: totrans-1773
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: trace(gy,browser)
- en: 'This has the same effect as placing the command browser() in our source code
    for gy(), but it’s quicker and more convenient than inserting such a line, saving
    the file, and rerunning source() to load in the new version of the file. Calling
    trace() does *not* change your source file, though it does change a temporary
    version of your file maintained by R. It would also be quicker and more convenient
    to undo, by simply running untrace:'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在 gy() 的源代码中放置命令 browser() 有相同的效果，但它比插入这样的行、保存文件和重新运行 source() 来加载新版本的文件更快、更方便。调用
    trace() 不会更改您的源文件，尽管它会更改 R 维护的临时文件版本。通过简单地运行 untrace，也可以更快、更方便地撤销操作。
- en: untrace(gy)
  id: totrans-1775
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: untrace(gy)
- en: You can turn tracing on or off globally by calling tracingState(), using the
    argument TRUE to turn it on or FALSE to turn it off.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用 tracingState() 来全局开启或关闭跟踪，使用参数 TRUE 开启，FALSE 关闭。
- en: '***13.3.5 Performing Checks After a Crash with the traceback() and***'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: '***13.3.5 使用 traceback() 和...在崩溃后执行检查***'
- en: '***debugger() Functions***'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: '***调试器() 函数***'
- en: Say your R code crashes when you are not running the debugger. There is still
    a debugging tool available to you after the fact. You can do a “post-mortem” by
    simply calling traceback(). It will tell you in which function the problem occurred
    and the call chain that led to that function.
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的 R 代码在没有运行调试器的情况下崩溃。在事后，您仍然可以使用调试工具。您可以通过简单地调用 traceback() 来进行“尸检”。它将告诉您问题发生在哪个函数中，以及导致该函数的调用链。
- en: 'You can get a lot more information if you set up R to dump frames in the event
    of a crash:'
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您设置 R 在崩溃时转储框架，您可以获得更多信息：
- en: options(error=dump.frames)
  id: totrans-1781
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: options(error=dump.frames)
- en: 'If you’ve done this, then after a crash, run this command:'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经这样做，那么在崩溃后，运行以下命令：
- en: debugger()
  id: totrans-1783
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: debugger()
- en: You will then be presented with a choice of levels of function calls to view.
    For each one that you choose, you can take a look at the values of the variables
    there. After browsing through one level, you can return to the debugger() main
    menu by hitting N.
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到可以选择查看函数调用级别的选项。对于您选择的每个级别，您都可以查看那里的变量值。浏览完一个级别后，您可以通过按 N 键返回到 debugger()
    主菜单。
- en: Debugging
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 调试
- en: '**291**'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: '**291**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'You can arrange to automatically enter the debugger by writing this code:'
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过编写以下代码来安排自动进入调试器：
- en: options(error=recover)
  id: totrans-1789
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: options(error=recover)
- en: Note, though, that if you do choose this automatic route, it will whisk you
    into the debugger, even if you simply have a syntax error (not a useful time to
    enter the debugger).
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管如此，如果您选择这条自动路径，它将带您进入调试器，即使您只是有一个语法错误（这不是进入调试器的好时机）。
- en: 'To turn off any of this behavior, type the following:'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: options(error=NULL)
  id: totrans-1792
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You’ll see a demonstration of this approach in the next section.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: '***13.3.6 Extended Example: Two Full Debugging Sessions***'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at R’s debugging tools, let’s try using them to find and
    fix code problems. We’ll begin with a simple example and then move on to a more
    complicated one.
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: '**13.3.6.1 Debugging Finding Runs of Ones**'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: 'First recall our extended example of finding runs of 1s in Chapter 2\. Here
    is a buggy version of the code:'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: findruns <- function(x,k) {
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(x)
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: runs <- NULL
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:(n-k)) {
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
- en: if (all(x[i:i+k-1]==1)) runs <- c(runs,i)
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: return(runs)
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it on a small test case:'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
- en: source("findruns.R")
  id: totrans-1815
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: findruns(c(1,0,0,1,1,0,1,1,1),2)
  id: totrans-1816
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 3 4 6 7'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
- en: The function was supposed to report runs at indices 4, 7, and 8, but it found
    some indices that it shouldn’t have and missed some as well. Something is wrong.
    Let’s enter the debugger and take a look around.
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
- en: debug(findruns)
  id: totrans-1819
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: findruns(c(1,0,0,1,1,0,1,1,1),2)
  id: totrans-1820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'debugging in: findruns(c(1, 0, 0, 1, 1, 0, 1, 1, 1), 2)'
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at findruns.R#1: {'
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
- en: '**292**'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(x)
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: runs <- NULL
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:(n - k)) {
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
- en: if (all(x[i:i + k - 1] == 1))
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
- en: runs <- c(runs, i)
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
- en: return(runs)
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: attr(,"srcfile")
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
- en: findruns.R
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
- en: 'So, according to the principle of confirmation, let’s first make sure our test
    vector was received correctly:'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> x
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1 0 0 1 1 0 1 1 1'
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good. Let’s step through the code a bit. We hit n a couple of times
    to single-step through the code.
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> n
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at findruns.R#2: n <- length(x)'
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> n
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at findruns.R#3: runs <- NULL'
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> print(n)
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 9'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
- en: Note that after each single step, R tells us which statement would be the *next*
    one to execute. In other words, at the time we executed print(n), we had *not*
    yet executed the assignment of NULL to runs.
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
- en: Note, too, that although normally you can print out the value of a variable
    by simply typing its name, we could not do so here for our variable n, because
    n is also the abbreviation for the debugger’s next command. Thus, we needed print().
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
- en: At any rate, we found that the length of our test vector was 9, confirming what
    we knew. Now, let’s single-step some more, getting into the loop.
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> n
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at findruns.R#4: for (i in 1:(n - k + 1)) {'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
- en: if (all(x[i:i + k - 1] == 1))
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
- en: runs <- c(runs, i)
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> n
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at findruns.R#4: i'
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> n
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
- en: 'debug at findruns.R#5: if (all(x[i:i + k - 1] == 1)) runs <- c(runs, i) Debugging'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
- en: '**293**'
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
- en: Since k is 2—that is, we are checking for runs of length 2— the if() statement
    should be checking the first two elements of x, which are (1,0).
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s confirm:'
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> x[i:i + k - 1]
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
- en: So, it did *not* confirm. Let’s check that we have the correct subscript range,
    which should be 1:2\. Is it?
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
- en: Browse[2]> i:i + k - 1
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 2'
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
- en: Also wrong. Well, how about i and k? They should be 1 and 2, respectively. Are
    they?
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然不对。嗯，关于 i 和 k，它们应该是 1 和 2，对吗？
- en: Browse[2]> i
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[2]> i
- en: '[1] 1'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1'
- en: Browse[2]> k
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[2]> k
- en: '[1] 2'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2'
- en: Well, those do confirm. Thus, our problem must be with the expression i:i +
    k - 1\. After some thought, we realize there is an operator precedence problem
    there, and we correct it to i:(i + k - 1).
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这些确实确认了。因此，我们的问题一定出在表达式 i:i + k - 1 上。经过一番思考，我们意识到这里存在一个运算符优先级问题，并将其更正为 i:(i
    + k - 1)。
- en: Is it okay now?
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以了吗？
- en: source("findruns.R")
  id: totrans-1874
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: source("findruns.R")
- en: findruns(c(1,0,0,1,1,0,1,1,1),2)
  id: totrans-1875
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: findruns(c(1,0,0,1,1,0,1,1,1),2)
- en: '[1] 4 7'
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 4 7'
- en: No, as mentioned, it should be (4,7,8).
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 不，正如提到的，应该是 (4,7,8)。
- en: Let’s set a breakpoint inside the loop and take a closer look.
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在循环内部设置一个断点并仔细查看。
- en: setBreakpoint("findruns.R",5)
  id: totrans-1879
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: setBreakpoint("findruns.R",5)
- en: '/home/nm/findruns.R#5:'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: '/home/nm/findruns.R#5:'
- en: 'findruns step 4,4,2 in <environment: R_GlobalEnv>'
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 'findruns step 4,4,2 in <环境: R_GlobalEnv>'
- en: findruns(c(1,0,0,1,1,0,1,1,1),2)
  id: totrans-1882
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: findruns(c(1,0,0,1,1,0,1,1,1),2)
- en: findruns.R#5
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: findruns.R#5
- en: 'Called from: eval(expr, envir, enclos)'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: '调用来自: eval(expr, envir, enclos)'
- en: Browse[1]> x[i:(i+k-1)]
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[1]> x[i:(i+k-1)]
- en: '[1] 1 0'
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 0'
- en: Good, we’re dealing with the first two elements of the vector, so our bug fix
    is working so far. Let’s look at the second iteration of the loop.
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在正在处理向量的前两个元素，所以我们的错误修复到目前为止是有效的。让我们看看循环的第二次迭代。
- en: Browse[1]> c
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[1]> c
- en: findruns.R#5
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: findruns.R#5
- en: 'Called from: eval(expr, envir, enclos)'
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: '调用来自: eval(expr, envir, enclos)'
- en: '**294**'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: '**294**'
- en: Chapter 13
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Browse[1]> i
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[1]> i
- en: '[1] 2'
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2'
- en: Browse[1]> x[i:(i+k-1)]
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[1]> x[i:(i+k-1)]
- en: '[1] 0 0'
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0 0'
