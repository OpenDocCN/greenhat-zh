- en: 'Part III: Answers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Answer 1:** The problem is that a large herd contains 10,000 sheep. That''s
    40,000 legs. The maximum number you can fit in a short int is 32,767\. That''s
    smaller than 40,000, so (10,000*4) causes an overflow that results in wrong data
    being output.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 2:** The problem is that the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: does not set the variable bit to 1000 0000 0000 0000(b). Instead, it sets it
    to 1 0000 0000 0000 0000(b). Unfortunately, it can't hold 17 bits, so the result
    is that it's set to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because it is zero, the bit test statement will always fail, giving use the
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 3:** Global classes are initialized before main. Order is not guaranteed
    by the compiler. In particular, there is nothing to guarantee that first_name
    is initialized before it is used. So if the compiler chooses the wrong order,
    the program will output incorrect data or die.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 4:** The programmer thought he put two statements inside the if, but
    he forgot the curly braces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'properly indented looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'What the programmer should have written is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 5:** The problem is that the file type was not specified as binary
    (ios::bin). The Microsoft Windows runtime library edits character output and inserts
    <carriage-return (0xD)> before each <line-feed (0xA)>. This explains the extra
    0D in the file just before the 0A character.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 6:** The problem is the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The function main is not a void function. It''s an int. The function returns
    an exit code to the operating system. A properly written "[Hello World](LiB0005.html#7)"
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When my wife first took programming, this was the first program she was taught
    (the void version). I changed the void to an int and she turned the paper in.
    The teaching assistant counted it wrong and changed it back.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, I was not happy about this and wrote him a very snooty letter
    telling him that main was an int and quoting him chapter and verse of the C++
    standard proving it. He wrote back and was extremely nice about the whole thing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 7:** The problem is that *sub.cpp* defines str as a character array
    (char []). The extern statement in *main.cpp* defines str as a character *pointer*
    (char *).'
  prefs: []
  type: TYPE_NORMAL
- en: Now character arrays and character pointers are interchangeable *almost* everywhere
    in C++. This is one of the few cases they are not. In this case, the program main
    thinks that str is a character pointer, so it goes to that location and reads
    the first four bytes expecting an address. The first four bytes are "Hell," which
    is not an address, and so the program crashes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 1:** Always define externs in a header file. This header should
    always be included by the module where the item is defined and every module where
    it''s used.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 8:** The problem is that ch can be a signed character. That means
    that if ch is 0xFF when converted to a signed integer for comparison purposes
    you get int(ch)=-1 (0xFFFFFFF). That''s not 0xFF and the comparison fails.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 2:** Be careful when you use character variables to hold numbers.
    They may not do what you want them to.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 9:** The problem is that the optimizer looks at the code and sees
    that we read *in_port_ptr three times and then throws away the result. The optimizer
    then figures out that it can optimize the program and produce the same apparent
    results by taking out the lines 20, 21, and 22.'
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to declare the port pointers volatile. In Program 107 we've
    done this, but something is not quite right.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 10:** The answer is that the printf format (%d) does not match the
    parameter type (double). The programmer should have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 11:** A character has 8 bits numbered 0 to 7\. The bits can be represented
    by the constants (1 << 0) to (1 << 7).'
  prefs: []
  type: TYPE_NORMAL
- en: There is no bit number 8, so the expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: does nothing because it sets a bit outside the boundary of the character. The
    result is that only the administration privilege is really set.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 12:** The operator = function call takes a single parameter of type
    data_holder. This type of parameter is a call by value parameter, so the copy
    constructor is called. The programmer making the copy constructor decided to take
    a shortcut and uses the operator = to implement the copy. So operator = calls
    the copy constructor, which calls operator = which calls the copy constructor
    ... and so on until you run out of stack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The operator = function should take a constant reference as its parameter type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It should also return a reference to a data holder.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 3:** Use const references if possible when passing parameters.
    This avoids the extra cost of doing a copy of a call by value parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 13:** The problem is with the if statement. In the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'the programmer forgot to put in the closing curly brace. That''s OK; he made
    up for it by forgetting to put in an opening brace for the next if statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we properly indent the code, we can see the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'What the programmer should have written is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 14:** The statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: copies a queue of size 30 to a queue of size 20\. In other words, the assignment
    operator (as implemented) allows us to copy different size queue. We should not
    be allowed to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four ways to solve this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the STL queue class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the assignment operator private (and not allow any assignments).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the assignment operator so that it throws an exception if the size of
    the queue is not the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the queue class so that you can assign different size queues to each
    other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Answer 15:** The constant 02126 is octal because the leading digit is a zero.
    So in C++, 02126 (octal) is 1110 (decimal) and is not the zip code for Boston.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 16:** The problem is that the compiler knows what 12 * 34 equals,
    so instead of doing the multiply it optimizes the statement and turns it into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Since the multiply is not done, the timing is off. Program 109 is an attempt
    to fix this problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 17:** The problem is that the programmer used bitwise and (&) instead
    of logical and (&&). A bitwise and of the two numbers gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So the result is 0, the if clause is skipped, and the else clause is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some programmers use the shorthand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: for
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: (I discourage such shorthand.)
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one example of why I don''t like shortcuts. A better way of writing
    the if statement is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Shortly after discovering this bug I told a colleague about it. I explained
    what happened and said, "I now know the difference between 'and' and 'and and'."
    I'm not sure what amazed me more, the fact that I came up with this sentence or
    the fact the he understood it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 18:** The problem is that tmp_name returns a pointer to the local
    variable name. When the function ends, the storage for all nonstatic local variables
    is reclamined. This includes the storage for name. Thus, the pointer returned
    points to a random, unallocated section of memory.'
  prefs: []
  type: TYPE_NORMAL
- en: The next function call that comes along will probably clobber that storage and
    make a_name look really strange.
  prefs: []
  type: TYPE_NORMAL
- en: A solution to this problem is to declare name **static.**
  prefs: []
  type: TYPE_NORMAL
- en: (See [Program 59](LiB0063.html#69) for a similar problem.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 19:** The problem is that the statement'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: does not move the bit over to the right one. Instead it does a "signed" shift,
    which copies the sign bit. Thus
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: is not
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: as expected but instead
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Because of this problem, the bit testing gives incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 20:** The arguments to memset are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the value is sizeof(array) and the number of bytes to fill is
    0\. Since size=0 nothing was done.
  prefs: []
  type: TYPE_NORMAL
- en: 'The programmer should have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 21:** The C++ standard states that all pointers must point to the
    array or above. You can''t point below the array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have an array on an Intel machine. The address of the array,
    in Intel strange pointer parlance, is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The data_ptr variable starts out at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It then gets decremented as long as it is greater than data. During its decrementation
    data_ptr goes to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s equal to the address of the array data, so it''s decremented again.
    (Remember that in this memory model, only the address part is changed.) The result
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: is evaluated. But data_ptr is now much greater than data, so the program continues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is that the program writes over random data, which can cause the
    system to crash. But if it doesn''t, data_ptr will go down to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: wrap, and the process will continue again.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 22:** The problem is that the function max returns a reference to
    a parameter. That parameter is 3+4, which is an expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What C++ actually does when min is called is:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a temporary (tmp1) and assigns it 1+2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a temporary (tmp2) and assigns it 3+4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls max(tmp1, tmp2)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function returns a reference to tmp2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The variable i is now a reference to nothing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The problem is caused by returning a reference to a parameter. This creates
    a dangling reference.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 23:** The programmer did not put spaces in the output text for the
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: as a result, the output looks like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'What he should have written is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](fig237_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Answer 24:** This is a classic deadlock problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Process 1 requires resources #1 and #2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Process 2 requires resources #2 and #1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They get the resources in that order. Remember that thread switches can occur
    at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we have a race condition in which the following can occur:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Process 1 gets resource #1'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thread switch to process 2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Process 2 gets resource #2'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Process 2 attempts to get resource #1'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Resource #1 is unavailable, so the process sleeps until it is freed (keeping
    resource #2 locked while it works)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thread switch to process 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Process 1 attempts to get resource #2\. It''s locked, so the process sleeps
    until it is freed. (Resource #1 is kept locked in the meantime.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result is that process 1 is waiting for resource #2 while holding resource
    #1\. It will not give up resource #1 until it gets resource #2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Process 2 is waiting for resource #1 while holding resource #2\. It will not
    give up resource #2 until it gets process #1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 4:** Define locking order (for example, you must get the locks
    in the order #1, #2). Always use this locking order when getting multiple locks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternate:** When getting multiple locks, use the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Attempt to get all the locks (do not block if they are not available).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you've got everything, then go on and do your job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you didn't get all the locks, free the ones you didn't get, sleep a while,
    and try again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Answer 25:** The problem is the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an assignment statement inside an if. If we rewrite the code to avoid
    the shortcut, we get the two statements.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The use of the logical not in this context ( !0 ) gives us a result of 1\. So
    we always assign n2 the value 1, then do the comparison and divide.
  prefs: []
  type: TYPE_NORMAL
- en: The != was written backwards as =! thus giving us the surprise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The statement should have read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 26:** The problem is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the compiler to:'
  prefs: []
  type: TYPE_NORMAL
- en: Increment i
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use it to index array (first occurrence)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment i
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use it to index array (second occurrence)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute the difference
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The problem is that steps 1-4 can occur in a different order:'
  prefs: []
  type: TYPE_NORMAL
- en: Increment i
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment i
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use it to index array (first occurrence)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use it to index array (second occurrence)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Statements with many side effects give the C++ compiler latitude to screw things
    up.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 5:** Put side effects like ++ and -- on lines by themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 27:** The problem is that "1" is an integer. The number "3" is also
    an integer. So "1/3" is an integer divide.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: does an integer divide of 1 by 3\. Integer divides truncate the fractional part
    so the result is 0\. The integer "0" is turned into floating-point and assigned
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The programmer should have written this as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 28:** The scanf function is extremely tricky to use. In this program
    the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'gets a character and a integer. The next time scanf is called, it will read
    another character and integer. So what''s the next character? Let''s look at the
    sample run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line we type is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: After the first scanf call, the input pointer is position just before the newline
    just after the 5. The next scanf tries to read the operator and gets the newline.
    It keeps reading and sees a + instead of a number. The result is a lot of confusion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 6:** The scanf function is tricky to get right. But I have a simple
    way of dealing with this problem: I never use it. Instead I always use a combination
    of fgets and sscanf instead.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 29:** The preprocessor does not understand C++ syntax. When we define
    TOTAL to be 37 + 33, it is literally 37 + 33 and not 70.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The AREA macro is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Operator precedence takes over and gives us the wrong answer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 7:** Use constants instead of defined macros whenever possible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 8:** Put parenthesis around all #defines that define anything other
    than a simple number.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 30:** The problem is that the function is returning a reference to
    a local variable. This is a bad thing because the local variable is destroyed
    by the return; the reference is what is called a *dangling reference.* It''s referring
    to something that is no longer there.'
  prefs: []
  type: TYPE_NORMAL
- en: When we try to print the string that is no longer there, we run into trouble.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 9:** Do not return references to local variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 31:** The problem is that the else clause goes with the nearest if.
    The properly indented code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not what the programmer intented. What he wanted to do was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '**Avoidance 10:** Use {} around statements under the control of an if, for,
    while, or other control statement if there is more than one statement conditional
    control.'
  prefs: []
  type: TYPE_NORMAL
- en: '(That''s a fancy way of saying: Don''t write code like this.)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **![Start Sidebar](_1.gif)** |'
  prefs: []
  type: TYPE_TB
- en: 'Bonus question: This fixes most of the problems, but there''s still a bug in
    this program. What is it? (Next [Hint 112](LiB0120.html#248). [Answer 38](#ch13p38).)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **![End Sidebar](_1.gif)** |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '**Answer 32:** The problem is that memory is allocated in the constructor and
    never freed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 11:** Always **delete** in the destructor what you **new** in the
    constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: This rule was not followed, so every time we created a stack some of the heap
    permanently went away.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 33:** The program prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that fgets gets a line including the newline. So when the first
    name is read, it's read as John\n. The same thing happens with Smith, and the
    result is our funny output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 34:** There is a extra semicolon at the end of the for statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the for controls absolutely nothing. Properly indented the
    program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'or if we add a little commenting this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: From this we can see that the std::cout line is not inside the for loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 35:** The problem is that we declared a local variable named remove.
    There is a standard function named remove as well. Our local variable hid the
    function for the scope of the local variable.'
  prefs: []
  type: TYPE_NORMAL
- en: That scope ended at the end of the first if on line 15.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: checks to see if the address of the function remove is non-zero and executes
    the next statement if it is.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Click To expand](fig242_01.jpg)](fig242_01_0.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 12:** Avoid hidden variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 36:** The problem is that the string we return is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This is a local variable. The subroutine returns a reference to this string.
    But because it's a local variable, it's destroyed at the end of the function.
    That means when we use the result, the variable holding the result has been destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 37:** The problem is that the backslash character is used as an escape
    character. So \n is newline. \new is <newline>ew.'
  prefs: []
  type: TYPE_NORMAL
- en: So the string \root\new\table decodes as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'What the programmer really wanted was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Ironically, this rule does not apply to #include file names so'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: works and is correct.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 38:** The problem is the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This is used to check to see if the customer owes the company something. Thus,
    the customer can see a message like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '|  | Note  | This actually happened to one person. He got a bill for $0.00\.
    He called up the company, they apologized, and the next month he got a bill for
    $0.00\. This continued for many months. Each time he called the company, they
    would apologize and tell him they would fix the problem, but nothing would happen.
    |'
  prefs: []
  type: TYPE_TB
- en: He even got charged a late fee of 5%. This brought his bill up to $0.00.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, he sent them a check for $0.00.
  prefs: []
  type: TYPE_NORMAL
- en: That week he got a nasty phone call from his bank. "Why did you write out such
    a check?" they demanded to know.
  prefs: []
  type: TYPE_NORMAL
- en: It seems that the check crashed its computer system. So the check was bounced,
    and the next week he received a bill for $0.00.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 39:** The problem is that the optimizer is smart. It sees that we
    are computing the result of'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'inside the for loop. The answer won''t change if we move this to outside the
    for loop, but things will go quicker. So the optimized version of this program
    does the multiply only one time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: To fix this problem we need to declare our factor volatile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: It's things like this that make embedded programming so simple.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 40:** The problem is that ostream is passed as "pass by value". You
    can''t copy stream variables. (If you did it would mean that the system would
    have to make a copy of the file.) The parameter should be changed to a "pass by
    reference" parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 41:** The problem is the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The strcat function takes two strings as arguments. In this example, we've given
    it a string and a character. Because there are no prototypes, C can't do parameter
    checking; the incorrect parameter is passed to strcat, which gets very confused.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 13:** All functions should be explicitly declared. Never let C
    declare them implicitly. Make sure you include the headers that define the prototypes
    for all the functions that you use.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 42:** A signed one-bit number can have one of two values: 0 and -1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'fails because the one-bit-wide field can''t hold the value 1\. (So it overflows
    and assigns the variable the value -1!) The result is that the next statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: fails.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 14:** Single bit fields should be unsigned.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 43:** On MS-DOS you''ll get something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'On UNIX you might get something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that the programmer did not add an end of line at the end of
    the std::cout statement. The result is that the program runs, outputs a statement,
    and exists leaving the cursor positioned at the end of a line. The command processor
    then runs and outputs its prompt (C:> for MS-DOS, $ for UNIX) right next to the
    program's output.
  prefs: []
  type: TYPE_NORMAL
- en: 'What the programmer should have written is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 44:** Commas can be used to separate C++ statements. It''s used like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: (Don't program like this, please!)
  prefs: []
  type: TYPE_NORMAL
- en: The statment
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'is the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: From this, we can see why we get 1 as out output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 45:** The problem is that the expression ch+1 is an integer (value
    66). C++ detects this and calls the std::cout.operator <<(int) function and outputs
    an integer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What the programer should have written is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 46:** The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason is that DOUBLE(i+1) expands to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: When C++ sees this, it multiplies 1 by 2 and adds i. This result is not what
    the programmer intended.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 15:** Use **inline** functions instead of macros whenever possible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 16:** Always put () around the parameters of macros. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 47:** The statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: assigns 0 to amount, then compares the result to see if it's not zero. It is
    zero, so the else clause is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The programmer should have written the statement as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '|  | Note  | One of the most rewarding experiences I had when I was teaching
    programming was when I met a student about two months after the class had finished."Steve,"
    he said. "I have to tell you that during the class I thought you were going a
    bit overboard about this ''='' vs. ''=='' stuff — until yesterday. You see, I
    wrote my first real program and guess what mistake I made?" |'
  prefs: []
  type: TYPE_TB
- en: '**Answer 48:** Use the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '|  | Note  | This algorithm was first found lurking in an article as an example
    of how not to do the job. The author''s "ideal" way of doing things was to use
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The point the author was trying to make was that you should check for illegal
    values in your code.Sharp-eyed readers may notice that there's a syntax error
    in this code. There was a similar problem in the "ideal" solution in the original
    article. In other words, the code the author presented as "ideal" wouldn't work.
    |
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 49:** The problem is that C++''s operator precedence is not what the
    programmer thought it was. The + operator comes before << so'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'gets parsed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The result is 1<<4 or 8.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 17:** Use the simple C++ precedence rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '*, / and % come before + and -.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put () around everything else.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Answer 50:** It prints'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that when the fork occurs, there is data in the printf buffer.
    The fork creates two copies of the process and two copies of the data in the printf
    buffer. Thus, when the buffer is flushed later (in both processes) we get a Hello
    from each of them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 51:** The programmer never bothered to initialize sum. You can''t
    count on a uninitialized value containing anything. So sum may start out at 0,
    5190, 123, 5, or something else.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What the programmer should have written is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 52:** The problem is the line'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation is not protected against thread switches. On a complex instruction
    machine, the assembly code for this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Thread switches occur only on an instruction boundary. So this operation cannot
    be interrupted on the 80x86 machine family.
  prefs: []
  type: TYPE_NORMAL
- en: 'But on a RISC machine such as a Sparc, the code looks a little different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'So now the C++ statement is interruptible. In particular, the following can
    happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The program runs and completes instruction 3\. At this point, the value of flags
    is in register %o2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A thread switch occurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other process modifies flags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The thread switches back.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The old value of flags is in register %o2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bit is set, and the result is stored. Because this contained the old value
    of flags, any changes made in the other thread are discarded accidently.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The solution to this problem is to use locks to prevent a task switch from occurring
    during the statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 53:** The statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: prints the answer in octal. The programmer made an error and put %o where he
    wanted %d. The result is that the numbers are correct, just in the wrong base.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 54:** The problem is that you can''t represent 1/3 exactly in floatingpoint.
    Let''s see what happens when we add the numbers in decimal.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Because of the roundoff error, the result is not 1.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when using floating-point, the numbers are not exact.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 55:** The problem is that we throw an exception in a destructor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the program reaches the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: the exception code takes charge. It destroys all the local variables. That includes
    the variable a_stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a_stack is destroyed, the destructor is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The destructor throws an exception. C++ does not like it when you throw an exception
    in an exception. When that happens the program calls the terminate() function.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to catch the second exception and other similar exception problems,
    use the standard function set_terminate to establish a function to take care of
    unexpected problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 18:** Don''t throw exceptions in destructors.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 56:** The problem is that the redefined new function is implemented
    incorrectly. The programmer assumed that when a person does a'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: the size of the allocated object is sizeof(fast_bit_array). This is not true
    when fast_bit_array is used as a base class. In this case, the size of the allocated
    memory is the size of the derived class safe_bit_array, which is bigger than fast_bit_array,
    thus resulting in memory confusion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 19:** Don''t define your own operator new function unless you''re
    sure what you''re doing. If you are sure you know what you''re doing, make sure
    you''re really really sure. Even then don''t do it unless it''s absolutely necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 57:** The problem is that there are two variable declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*File: main.cpp*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '*File: check.cpp*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'That means that the value is set to 20 or 30\. But which one? The result is
    compiler-dependent. If you want value to be local to the files in which they are
    declared, you need to declare them static:'
  prefs: []
  type: TYPE_NORMAL
- en: '*File: main.cpp*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '*File: check.cpp*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Or better yet, give them two different names.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 58:** According to the C++ standard, once you define a derived class
    member function with the same name as a base class''s member function, all member
    functions of that name are hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: 'So der::print_it(float) hides both base: :print_it(float) and base: :print_it(int).'
  prefs: []
  type: TYPE_NORMAL
- en: When we call print_it(2) C++ looks for aversion of print_it it can use. The
    only visible print_it is der::print_it(float). C++ would rather have a function
    that takes **int** as its argument, but it knows how to turn an **int** into a
    **float,** so it promotes 2 to 2.0 and uses der::print_it(float).
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 59:** The problem is that we didn''t define a copy constructor. When
    that happens, C++ defines one for you and generally does a bad job of it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The copy constructor is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The copy constructor is called to create a copy of an_array for the function
    store_it. The pointer to the data is copied.
  prefs: []
  type: TYPE_NORMAL
- en: When var_array::^~var_array is called at the end of pushy, it returns the data
    to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: When var_array::^~var_array is called at the end of main, it returns the same
    data to heap. Because we delete the same memory twice, the result is a corrupt
    heap.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 20:** Always declare a copy constructor in some way or other. The
    three major was are:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicitly declare it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you never want anyone to be able to call it, declare it private:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the default works, use the comment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: in your program. That way you tell people reading your code that you thought
    about it and know that the C++ default will not be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 60:** The programmer has a very bad habit of not closing files after
    opening them. Pretty soon the maximum number of files are opened and the system
    won''t let him open any more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Closes needed to be added at key points in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Also the programmer uses opendir to open a directory. He never closes it. So
    a closedir is needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 61:** The problem is that the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'tells C++ that the *pointer* is volatile. The data being pointed to is not
    volatile. The result is that the optimizer still optimizes us out of existence.
    The solution is to place the volatile where it modifies the data being pointed
    to. We also have added a const to the declaration to make sure that the pointer
    can''t be modified. The resulting declarations are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells C++:'
  prefs: []
  type: TYPE_NORMAL
- en: in_port_ptr is a const pointer and cannot be modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*in_port_ptr is a volatile char whose value can be changed outside the normal
    C++ programming rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Answer 62:** The problem is that the comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'does not contain a close comment. So it continues engulfing the statement below
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: From this it's easy to see why height was not set.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 63:** The problem is that getchar returns an int. We are assigning
    it to a character. Some systems treat characters as unsigned characters. The result
    is that when we get EOF (-1) the system assigns'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: or ch = 0xFF. It then compares the 0xFF to -1 (they are not the same) and does
    not exit the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'This program is also a stylistic disaster. The goal of every C++ programmer
    should be writing a clear program. This program was written to be compact. A much
    better program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 64:** The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this is that although we have two pointers, they both point
    to one variable name. When tmp_name is called the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'After the second call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'But a_name also points to name so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The second call overwrote storage that was being used to hold the result of
    the first call.
  prefs: []
  type: TYPE_NORMAL
- en: One solution to this is to copy the string after each call or to have the caller
    provide his own character array for name storage.
  prefs: []
  type: TYPE_NORMAL
- en: Another solution is to use C++ style strings that handle their own memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 65:** Every put is followed by a flush. This means that a system call
    is made for each character output. System calls are expensive and take up a lot
    of CPU time.'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, although the I/O library is designed for buffered I/O, the excessive
    flush calls for it to do unbuffered I/O one character at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to flush at the end of each block to make sure that the remote system
    receives a full block. That''s *block,* not *character,* so we can speed up the
    system by moving the flush down to after the block is sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 66:** The setjmp marks a location in the code. The longjmp call jumps
    to it. It jumps directly to it, it does not pass go, it does not collect $200\.
    It also skips all the destructors for all the variables on the stack. In this
    case, because the destructor for std::string returns the memory allocated for
    the string, we have a memory leak.'
  prefs: []
  type: TYPE_NORMAL
- en: That's because the setjmp and longjmp functions are C functions that should
    not be used in C++.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 21:** Do not use setjmp and longjmp in a C++ program. Use exceptions
    instead.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 67:** In the default case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The "default" keyword is misspelled. The result is that the C++ compiler thinks
    that "defualt" is a goto label.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 68:** The printf function buffers its output. It won''t actually write
    anything until the buffer gets full or a newline is sent.'
  prefs: []
  type: TYPE_NORMAL
- en: So the program hits the printf, the "Starting" message goes into the buffer
    and not to the screen, and the function average is executed and gets a divide
    by zero error.
  prefs: []
  type: TYPE_NORMAL
- en: The result is that the "Starting" message is lost, making us think that average
    was never called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem is to flush the buffer explicitly after the starting
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '|  | Warning  | The rules for when a buffer gets flushed change depending on
    the type of file being written. The rules are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*If* *stdout* *or* *stderr* *are being written to the screen then the output
    is buffered until:*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*When a line is written.*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*When* *stdin* *is read.*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*When the buffer gets full.*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*If* *stdout* *or* *stderr* *are being written to a disk then the output is
    buffered until:*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*When the buffer gets full.*'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: (These are the rules you'll probably find on your system. The actual rules are
    system-dependent.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 69:** The problem is the programmer wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'so the output is literally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 70:** The problem is the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The statement checks the data pointed to by cur_cmd->cmd, then checks to see
    if cur_cmd->cmd is valid. On some systems, dereferencing NULL (which we do if
    we are at the end of the list) causes core dumps.
  prefs: []
  type: TYPE_NORMAL
- en: On MS-DOS and other brain-damaged systems, there is no memory protection, so
    dererferencing NULL is allowed, although you get strange results. Microsoft Windows
    fixed this, and dereferencing a NULL pointer will result in a General Protection
    Fault (GPF).
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop should be written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'But even this is tricky. The statement depends on the C++ standard being correctly
    implemented. That C++ standard states that for && the first part is evaluated.
    If the first term is false, the second term is skipped. Just to be safe, it''s
    better to write this as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 71:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alignment**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some machines require that long integer values line up on a 2-byte or 4-byte
    boundary. Some do not. C++ will insert padding in the structure to make things
    line up.
  prefs: []
  type: TYPE_NORMAL
- en: 'So on one machine, the structure will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'for a total of 5 bytes. While on another it may be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: for a total of 8 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Byte order**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some machines write out long integers using the byte order ABCD. Others use
    DCBA. This prevents things from being portable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Integer size**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The 64-bit machines are coming. That means that on some systems a long int is
    64 bits, not 32.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 72:** We have an array of a derived class called safe stack. In C++,
    you can use a base class pointer (stack*) to point to a derived class (safe_stack).
    The system will see only the base part of the object, but you can still point
    to it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![Click To expand](fig257_01.jpg)](fig257_01_0.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Now a pointer can point to a single instance of a class or an array of objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Click To expand](fig257_02.jpg)](fig257_02_0.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'So we have the following two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: A base pointer can point to a derived object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An object pointer can point to an array of objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From this, we can conclude:'
  prefs: []
  type: TYPE_NORMAL
- en: A base pointer can point to an array of derived objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's wrong.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that an array of derived objects is not the same as an array
    of base objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Click To expand](fig257_03.jpg)](fig257_03_0.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: So if we take a base pointer and point it a derived array, the memory layout
    will be wrong.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Click To expand](fig258_01.jpg)](fig258_01_0.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 22:** Use the STL vector template instead of an array. It avoids
    a lot of problems.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 23:** Do not pass base-class arrays as parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 73:** The problem is how the compiler generates machine code for program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'generates something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: In this example fp_0 and fp_1 are floating-point registers. In floating-point
    coprocessors, the registers have the largest precision available. So in this case,
    while the numbers may be only 32-bit, the floating-point processor does things
    in 80 bits, resulting in a high precision being reported.
  prefs: []
  type: TYPE_NORMAL
- en: This sort of problem occurs on most machines with a floating-point processor.
    On the other hand, if you have an old machine that uses software to do the floating-point,
    you'll probably get the right answer. That's because, in general, software floating-point
    uses only enough bits to do the work.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix the program, we need to turn the main loop into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 74:** The problem is that the words are stored in the input file in
    alphabetical order and the tree is unbalanced. Thus, when words are inserted the
    following data structure is built up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![Click To expand](fig259_01.jpg)](fig259_01_0.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: The result is that we have a linked list, not a tree. Words are added to the
    end of the linked list (expensive), and lookups are done by linear search (also
    expensive).
  prefs: []
  type: TYPE_NORMAL
- en: A balanced binary tree would solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 75:** The problem is that we have in our code the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'This is disguised as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: The operator = function deletes the data of the destination array. That's fine
    except that the source array is the same stack, so its data gets destroyed, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is to check explicitly for self-assignment in the operator = function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '**Avoidance 24:** The operator = function should check for self-assignment.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 76:** The problem is that strcmp returns 0 if the strings are equal
    and non-zero otherwise. That means that if you have the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: The if will execute only if the strings are *not* equal.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 25:** Use'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: to test if two strings are equal. It's clearer than if (strcmp(x,y), and it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 26:** Whenever possible, use the C++ string class instead of the
    old C style strings. That way you can use the relational operators (<,>, ==, etc.)
    instead of strcmp.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 77:** The problem is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: It deletes data, then uses it. After things are deleted, they really should
    go away.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 27:** Always set a pointer to NULL after delete or free.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the code is written with a little bit of added protection, the problem
    is obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Also, because of the added protection of setting first to NULL, if we do attempt
    to use the pointer, we will abort in a well-defined manner (on most systems).
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 78:** The types of the variables are:'
  prefs: []
  type: TYPE_NORMAL
- en: sam is a character pointer (char *).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: joe is a character (char).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The declaration, after the preprocessor gets through with it results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '**Avoidance 28:** Use typedef to define new types, not #define.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 79:** C++ has no ** operator. (At least for integers.) So (12 ** 2)
    is an invalid construct.'
  prefs: []
  type: TYPE_NORMAL
- en: The trouble is that this bad syntax is hidden in a preprocessor macro that's
    not expanded until line 16\. That's why line 16 is the one with the syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 29:** Use const instead of preprocessor macros whenever possible.
    The statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: would still generate an error message, but at least the line number would be
    right.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 80:** The problem is that the result of a comparison is an integer
    1 or 0\. So the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Because a is greater than b, the result of a > b is 1, so we now have
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: which is false, so the else clause is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 81:** The programmer suspects that something funny is happening when
    data item #500 is read. He wants to put a breakpoint right before this item is
    read.'
  prefs: []
  type: TYPE_NORMAL
- en: The trouble is that if he puts a breakpoint at the top of get_data, he will
    have to do 500 debugger continue commands before he reaches the point he wants.
  prefs: []
  type: TYPE_NORMAL
- en: 'So he puts his breakpoint at the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '|  | Note  | The fancier debuggers allow the user to set a skip count to skip
    the first *x* number of breakpoint stops. Our friendly programmer doesn''t have
    such a nice tool. |'
  prefs: []
  type: TYPE_TB
- en: '**Answer 82:** The programmer used semicolons to end the #define declaration.
    Because the preprocessor is rather literal about things, the semicolon becomes
    part of the text. The result is that USABLE is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: The initialization of text_width now becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: or, properly indented,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: From this we can see our problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 30:** Use const instead of #define whenever possible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 83:** The problem is the buffer is a local variable. That means that
    it goes away at the end of the function call. Unfortunately, printf doesn''t know
    this, so it will still stuff data into it afterwards.'
  prefs: []
  type: TYPE_NORMAL
- en: The
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: will still try to use the local variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this problem declare the buffer as static:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 84:** The problem is the optimizer. The optimizer knows that the variable
    debugging is zero. It''s always zero.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know that, let''s take a look at the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'This is always false, because debugging is always zero. So this block is never
    executed. That means that we can optimize the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'into the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Now let's look at the number of times debugging is used. It's initialized on
    line 11 and used on line 13\. Line 13 is optimized out, so debugging is never
    used. If a variable is never used, it can be optimized out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is an optimized program that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Now our programmer wanted to use the debugging variable to help him debug things.
    The trouble is there is no debugging variable after optimization.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that C++ didn't know that the programmer was going to use magic
    (a debugger) to change variables behind its back. If you plan on doing something
    like this, you must tell the compiler. This is done by declaring the debugging
    variable volatile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: The "volatile" keyword tells C++, "Something strange such as an interrupt routine,
    a debugger command, or something else may change this variable behind your back.
    You can make no assumptions about its value."
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 85:** The printf statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: tells C to print an integer, but fails to supply one. The printf function doesn't
    know this, so it will take the next number off the stack (some random number)
    and print it.
  prefs: []
  type: TYPE_NORMAL
- en: 'What the programmer should have written is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 86:** The problem is the use of matrix[1,2]. The comma operator in
    C++ merely returns the result of the second part. So the expression "1,2" tells
    C++ throw the first part (1) away and the value is 2\. So matrix[1,2] is really
    matrix[2]. This is a pointer into an integer array, and C++ will treat it as a
    pointer for printing. That''s why strange values get printed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What the programmer really wanted is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 87:** The prefix version of ++ returns the number after incrementing.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: tells C++ increment i, returns the result, then increments the variable i again.
  prefs: []
  type: TYPE_NORMAL
- en: The postfix version of ++ (i++) returns a copy of the variable, then increments
    it.
  prefs: []
  type: TYPE_NORMAL
- en: So
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Tells C++ to make a copy of i (call it tmp_1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increments i
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the rest of the work on tmp_1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Makes a copy of tmp_1 (call it tmp_2)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increments tmp_2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returns tmp_1 as the value of the expression
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|  | Note  | C++ won''t let you get away with ++++ on integers. Only with some
    added class silliness can you get away with it. |'
  prefs: []
  type: TYPE_TB
- en: '**Avoidance 31:** Use ++ and -- singly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 88:** The problem is the macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: when called with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: This expands to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: This increments number twice, instead of once as the programmer intended. What's
    worse, the compiler can make some decisions as to the order in which the various
    operations are done; therefore, the result of this expression is compiler-dependent.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 32:** Use **inline** functions instead of parameterized macros.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 33:** Put ++ and - on lines by themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 89:** The optimizer knows that although the subroutine computes the
    value of result, it does nothing with it. So the program will work the same whether
    or not result is computed. Thus, the optimizer takes a look at the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'is optimized down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course we don''t need to do nothing 1,863 times, so this is optimized down
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: This is about as optimized as you can get. The way to keep the optimizer from
    doing this to us is to declare the variable result is volatile. Program 110 shows
    what happens when you add this fix.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 90:** C++ uses zero-based indexing. So for array [5] the valid elements
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: The programmer, however, uses the elements 1-5\. There is no array [5], so the
    program modifies random memory, causing the memory corruption.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s why most C++ programs don''t use statements like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead they count using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 91:** The problem is that with the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'the first /* (the one in the middle of the statement) starts a comment; it
    does not do a divide. So this statement is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '**Avoidance 34:** Put spaces around operators. It not only avoids problems
    but also makes the program easier to read.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 92:** The problem is that a thread switch can occur at any time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The writer will remove a character from the buffer when count > 0\. The reader
    performs the two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: But a thread switch can occur between these two steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the following can happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: A solution is to change the sequence of the steps
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the sequence of instructions to protect shared data is difficult
    and tricky.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is much better and simpler is to tell the task manager when you are doing
    a set of statements that can''t be interrupted. In pthreads, this is done with
    a mutex lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 93:** Member variables are initialized in *declaration* order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'are executed in declaration order: 1) area, 2) width, 3) height. This means
    that area is initialized with undefined values of width and height, and then width
    and height are initialized.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 35:** Write constructors so that variables are initialized in the
    order in which they are declared. (If you don''t do this, the compiler will do
    it for you and cause confusion.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 36:** Never use member variables to initialize other member variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 94:** In K&R style functions, the parameter declarations come immediately
    *before* the first curly brace.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That means that the declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: declares three parameters of default (int) type. Anything after that is declared
    as a local variable.
  prefs: []
  type: TYPE_NORMAL
- en: In particular
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: The result is instead of summing three parameters, the program adds three uninitialized
    local variables. No wonder we get a strange result.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 95:** The problem is the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'The sscanf function takes pointers as its arguments. (Remember C doesn''t check
    arguments for the correct type.) In this case, we gave sscanf a character and
    an integer. We should have given it a pointer to a character and a pointer to
    an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 96:** The program use raw I/O to do its work (using the read and write
    system calls). This program does one raw read and raw write for each character.
    Operating calls are expensive, and this program uses 2 (one read and one write)
    per byte copied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To speed up the program, cut down on the operating system calls. This can be
    done two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the buffered I/O system by making the input and output fstreams instead
    of file descriptors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read and write more than one character at a time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Answer 97:** The problem is the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: There is no semicolon after the /* do nothing */ statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return is part of the for statement. The code should look like this after
    it is indented properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: From this code section we can see that the first time through, the for loop
    index will be zero and the return taken. That's why all the strings are of zero
    length.
  prefs: []
  type: TYPE_NORMAL
- en: 'What the programmer wanted was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 98:** The problem is that class is allocated not by the C++ new operator,
    but instead uses the old style C malloc operator. This creates the space for the
    class without calling the constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: Then just to add insult to injury, memset is called to zero the class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'What the programmer should have written is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '|  | Note  | The author first found this problem in a large library he was
    trying to debug. Because of the large size of the library and the complexity of
    the mess, it took him a week to find the location of the *malloc*. |'
  prefs: []
  type: TYPE_TB
- en: '**Answer 99:** The statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: does not send a character to the output. Regardless of its name, the ch variable
    is of type integer. The result is that the integer is printed to the output. That's
    why the output file is full of integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the one case in which C++''s automatic type detection of output parameters
    gets in your way. The old C printf statement would handle things correctly like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'But with C++ you must cast to get the correct results in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 100:** The program outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that the readdir returns a pointer to static data. This data
    is owned by readdir and overwritten by subsequent calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what happens is this: We call scan_dir and set first_ptr to point to the
    string first. That''s what we want, but the array containing the name is static
    and when we call readdir again, it uses the same buffer to store the name second.
    So now first_ptr points to second, which is the cause of our trouble.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![Click To expand](fig269_01.jpg)](fig269_01_0.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 101:** In the base class destructor, we call the function clear.'
  prefs: []
  type: TYPE_NORMAL
- en: This function calls a pure virtual function, delete_data.
  prefs: []
  type: TYPE_NORMAL
- en: During destruction, the derived class gets deleted first. When the derived class
    goes, so does the definition of delete_data. Next, the base class destructor is
    called. In this case, our list class indirectly calls delete_data, which is pure
    virtual. Because there is no derived class, the runtime system causes the program
    to abort.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 37:** Do not call pure virtual functions from a constructor or
    destructor of an abstract class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 102:** I expect the results to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'but the results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I *knew* that this added one to i and returned. The problem is that i++
    is the value of i *before the increment.* So what the statement really does is:'
  prefs: []
  type: TYPE_NORMAL
- en: Save the value of i.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment i.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the saved value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So the lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: cause a 1 to be returned, not a 2 as one might expect.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 38:** Put ++ and - on lines by themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 103:** The problem is that on some systems, longs must align on a
    four-byte boundary. So let''s take a look at our structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '6 is not divisible by 4, so the compiler adds two padding bytes to make it
    jump to 8\. So what we really have is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: This is not what's indented.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 39:** Put statements like'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: in your code to catch compilers that cause this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Another avoidance is to make every member of the structure a byte and assemble
    the short and long ints yourself. This is more work, however.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 104:** The zip code 44101 is too large for MS-DOS''s 16-bit integer.
    The largest number a 16-bit integer can hold is 32,767\. The result is that the
    number overflows into the sign bit, and things go wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Note  | Win32 systems use 32-bit integers, so this problem does not occur
    on the current versions of Microsoft Windows. |'
  prefs: []
  type: TYPE_TB
- en: '**Answer 105:** The ABORT macro is expanded into two statements. So the result
    of the if statement is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'or properly indented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: From this output it's easy to see why we always exit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 40:** Use inline functions instead of multistatement macros.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '**Avoidance 41:** If you must use multistatement macros, enclose them in curly
    braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 106:** The problem is the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Because prev_ch is an automatic variable, this variable is created and initialized
    at the beginning of each loop. This means for the first if the variable prev_ch
    will always hold '\0' and we'll never match double letters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 107:** This program makes the big mistake of using floating-point
    for money. Floating-point numbers may not be exact. When adding up a lot of floating-point
    numbers, some errors may creep in.'
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to change the program to store money not in fractional dollars
    but as an integer number of cents.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 42:** Don''t use floating-point for money or anything else you
    want represented exactly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 108:** The printf call prints whatever string you give it. If you
    add 1 to a character string, you get the string minus the first character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: The expression ((flags & 0x4) != 0) returns a 0 or 1 depending on whether the
    bit is set.
  prefs: []
  type: TYPE_NORMAL
- en: The programmer is printing -word if the bit is set ("-word" + 0). The output
    is word if it is clear ("-word" + 1).
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Note  | If you are going to be this clever in your code, comment it to
    tell the maintenance programmers how smart you are. |'
  prefs: []
  type: TYPE_TB
- en: '**Answer 109:** The problem is the operator = function. It''s defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: The return value of this function is the class trouble. But there's a problem.
    Because the function does not return a reference, a copy of the variable has to
    be made. That means that the copy constructor has to be called. This calls the
    operator = function, which does the return, calling the copy constructor and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to have the operator = function return a reference to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 110:** The initialization of log_file can call new. Of course, our
    new new uses the log_file, so the log_file may be used before it gets constructed,
    confusing the whole mess.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoidance 43:** Don''t redefine the global new and delete unless you know
    what you are doing. Really know what you are doing. Even then don''t do it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 111:** The problem is that the initialization order of global variable
    is not guaranteed. In this case, a_var assumes that std::cout is initialized.
    That may not be the case.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume the worse and assume that the initialization order is a_var, std::cout.
    In that case, a_var is created. The constructor is called and output a message
    to std::cout. Because std::cout has not been created yet, things get very confused
    and the program crashes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 112:** The problem is that MAX is defined to be literally the text
    "=10" That means that'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: expands to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: This does not initialize the counter (it merely compares counter to 10 and throws
    the result). Because the counter is not initialized we get a random number of
    greetings.
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Note  | The GNU preprocessor sticks spaces around macro expansions so
    that the GNU version of the expansions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: It's unfortunate that the good GNU technology is robbing us of the opportunity
    of debugging strangely failing programs. |
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 113:** The space after the name DOUBLE makes this macro a simple text
    replacement macro. Thus,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'causes DOUBLE to be replaced with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Literally!
  prefs: []
  type: TYPE_NORMAL
- en: This means that the line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: (Indentation added.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution: Define DOUBLE as'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '**Avoidance 44:** Use inline functions instead of parameterized macros whenever
    possible. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '**Answer 114:** The problem is that the optimizer feels free to rewrite the
    code. Some optimizers will stick variables in registers to make the code go faster.
    For example, one optimized version of this program looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: From this, we can see that counter is updated only after the program finishes.
    If we try to examine it at any time in the other thread we die.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution it to declare the variable volatile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Then the compiler will make no assumptions about what it can do about it regarding
    optimization, and will generate code that keeps counter is kept up-to-date.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer 115:** I am trying to always make sure I delete the variable data
    before I overwrite it so I don''t have a memory leak. I even delete it in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the copy constructor. The first thing it does is to see if data has
    anything in it and, if so, delete it. But what could data possibly have in it?
    We just created the class and haven''t initialized it yet. So we are deleting
    a random pointer and as a result, crashing. Properly written our copy constructor
    should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: List of Sidebars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
