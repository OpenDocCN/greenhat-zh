- en: '![](../images/193-1.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/193-1.jpg)'
- en: '[**DESIGNING A FRAMEBUFFER INTERFACE**](toc.html#chapter11)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[**设计缓冲区接口**](toc.html#chapter11)'
- en: '![](../images/as.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/as.jpg)'
- en: If you decide to add a graphical user interface (GUI) to your appliance, you
    will be faced with the following challenge. On one hand, your appliance’s graphics
    hardware is controlled by low-level commands that manipulate video memory. On
    the other hand, your users don’t want to manipulate video memory; they want to
    manipulate high-level objects like menus and buttons. In order to build the kind
    of interface your users want, you will use a set of software layers known collectively
    as the *graphics stack*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定向你的设备添加图形用户界面（GUI），你将面临以下挑战。一方面，你的设备图形硬件由低级命令控制，这些命令操作视频内存。另一方面，你的用户不想操作视频内存；他们想操作高级对象，如菜单和按钮。为了构建用户想要的界面，你将使用一组称为
    *图形堆栈* 的软件层。
- en: The graphics stack, as used for the Laddie appliance, is illustrated in Figure
    11-1\. The Linux framebuffer device driver provides a low-level but uniform interface
    to the graphics hardware’s video memory. The graphics library provides support
    for manipulating points, lines, images, and text. The GUI toolkit provides widgets
    and manages user input for the appliance GUI.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 Laddie 设备的图形堆栈如图 11-1 所示。Linux 缓冲区设备驱动程序为图形硬件的视频内存提供了一个低级但统一的接口。图形库提供了操作点、线、图像和文本的支持。GUI
    工具包提供了小部件并管理设备 GUI 的用户输入。
- en: Here, we will present the graphics stack layers we used to design the Laddie
    framebuffer UI. But first, we will provide a brief review of how video memory
    works, since this will make the remainder of the chapter easier to understand.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将展示我们用来设计 Laddie 缓冲区帧 UI 的图形堆栈层。但首先，我们将简要回顾视频内存的工作原理，因为这会使本章的其余部分更容易理解。
- en: '![](../images/194-1.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/194-1.jpg)'
- en: '*Figure 11-1: The graphics stack*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：图形堆栈*'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: How video memory works
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频内存的工作原理
- en: The Linux framebuffer device driver
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 缓冲区设备驱动程序
- en: Graphics libraries
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形库
- en: “Hello, world!” with Simple DirectMedia Layer
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Simple DirectMedia Layer 的“Hello, world!”
- en: Graphical UI toolkits
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形 UI 工具包
- en: The Laddie framebuffer UI
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laddie 缓冲区帧 UI
- en: '[**How Video Memory Works**](toc.html#chapter11.1)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[**视频内存的工作原理**](toc.html#chapter11.1)'
- en: From a programming point of view, the most important part of the graphics hardware
    is the video memory. Software creates graphical images by manipulating this video
    memory, and hardware interprets this memory to render images on the display. Before
    we can effectively display text or graphics, we need to understand how bytes in
    video memory are interpreted, and in what order they are mapped onto the display.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程的角度来看，图形硬件最重要的部分是视频内存。软件通过操作这个视频内存来创建图形图像，硬件则解释这个内存以在显示上渲染图像。在我们能够有效地显示文本或图形之前，我们需要了解视频内存中的字节是如何被解释的，以及它们是如何按顺序映射到显示上的。
- en: '[***How Bytes in Video Memory are Interpreted***](toc.html#chapter11.2)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[***视频内存中字节的解释方式***](toc.html#chapter11.2)'
- en: To understand the different ways in which hardware can interpret video memory,
    it’s useful to remember that memory has historically been an expensive resource.
    Many of the earliest computers didn’t display arbitrary graphics; instead, they
    interpreted each byte of video memory as a single character (see Figure 11-2).
    A character might be drawn as a 7-by-9-pixel image, which would be quite efficient—a
    single byte would represent 63 pixels, and 2KB of memory could support a display
    of 32 lines with 64 characters each. However, only text could be rendered, and
    only 256 different characters could be displayed at a time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解硬件可以如何解释视频内存的不同方式，记住内存在历史上一直是一种昂贵的资源是有用的。许多最早的计算机不显示任意图形；相反，它们将视频内存的每个字节解释为单个字符（见图
    11-2）。一个字符可能被绘制为一个 7x9 像素的图像，这将非常高效——一个字节可以表示 63 个像素，2KB 的内存可以支持 32 行，每行 64 个字符的显示。然而，只能渲染文本，并且一次只能显示
    256 个不同的字符。
- en: Incidentally, we can think of character graphics as a form of image compression.
    The number of repeating pixel patterns that occur in a displayable text “image”
    are fewer than 256, so we can use a single byte to encode each one. All other
    pixel patterns occur with frequency zero, and therefore, are not encoded at all.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，我们可以将字符图形视为一种图像压缩形式。在可显示的文本“图像”中出现的重复像素模式数量少于 256，因此我们可以使用单个字节来编码每一个。所有其他像素模式出现的频率为零，因此根本不进行编码。
- en: '![](../images/195-1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/195-1.jpg)'
- en: '*Figure 11-2: Character graphics*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-2：字符图形*'
- en: With additional memory, graphics cards can dedicate one bit to every pixel.
    This creates *monochrome* graphics, which are illustrated in Figure 11-3\. Although
    this approach requires roughly an eight-fold increase in memory over using character
    graphics, it removes all limitations on the character set. It supports all typefaces,
    styles, and sizes, and even Kanji can be displayed as easily as Roman characters.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过增加内存，显卡可以为每个像素分配一个比特。这创建了*单色*图形，如图11-3所示。尽管这种方法在使用字符图形时需要大约八倍的记忆增加，但它消除了字符集的所有限制。它支持所有字体、样式和大小，甚至可以像罗马字符一样轻松地显示日文假名。
- en: '![](../images/195-2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/195-2.jpg)'
- en: '*Figure 11-3: Monochrome graphics*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-3：单色图形*'
- en: If we dedicate an entire byte to each pixel, we have a few options. For single-color
    displays, the graphics hardware could be designed to produce 256 different intensity
    (*grayscale*) levels. This would be appropriate for rendering text with *anti-aliasing*,
    in which shades of gray are used to soften jagged edges.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为每个像素分配一个完整的字节，我们有一些选择。对于单色显示器，图形硬件可以设计成产生256种不同的强度（*灰度*）级别。这对于使用*抗锯齿*渲染文本是合适的，其中使用灰色阴影来软化锯齿边缘。
- en: Alternatively, we could use each pixel’s byte to signify one of 256 different
    colors. In this approach, known as *pseudocolor*, the graphics hardware maintains
    a 256-entry table of colors, known as a *palette* or *colormap*. Each color in
    the palette is typically represented by three bytes, one each for the red, green,
    and blue intensity levels. This approach is illustrated in Figure 11-4\. In this
    example, the first pixel in the displayed image is represented by the value 0x3F,
    which indexes a 3-byte entry with red, green, and blue intensity levels that correspond
    to a light blue pixel, with a touch of green.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用每个像素的字节来表示256种不同的颜色之一。在这种方法中，称为*伪彩色*，图形硬件维护一个256个条目的颜色表，称为*调色板*或*颜色映射表*。调色板中的每种颜色通常由三个字节表示，每个字节分别代表红色、绿色和蓝色的强度级别。这种方法在图11-4中得到了说明。在这个例子中，显示图像中的第一个像素由值0x3F表示，它索引一个包含红色、绿色和蓝色强度级别的3字节条目，这些级别对应于一个带有绿色点缀的浅蓝色像素。
- en: As in the character graphics case, we can think of pseudocolor as a form of
    compression, driven by the need to conserve memory. To display an image in pseudocolor,
    we choose the 256 most important colors and represent each with one byte, neglecting
    all other colors.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如字符图形的情况一样，我们可以将伪彩色视为一种压缩形式，这是由节省内存的需求驱动的。要使用伪彩色显示图像，我们选择256种最重要的颜色，并用一个字节来表示每种颜色，忽略所有其他颜色。
- en: Using even more memory, we can dedicate two or three bytes to each pixel and
    directly represent the red, green, and blue intensity levels, without the use
    of a look-up table. With two bytes (*highcolor*), we might, for example, use 5
    bits for red, 6 for green, and 5 for blue. This supports over 65 thousand colors
    in an image, but it is still limited. For example, it only supports 2⁵ = 32 different
    shades of gray.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更多的内存，我们可以为每个像素分配两个或三个字节，并直接表示红色、绿色和蓝色的强度级别，而不使用查找表。例如，使用两个字节（*高彩色*），我们可以为红色分配5位，绿色6位，蓝色5位。这可以在图像中支持超过65千种颜色，但仍然有限。例如，它只支持2⁵
    = 32种不同的灰色阴影。
- en: '![](../images/196-1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/196-1.jpg)'
- en: '*Figure 11-4: Pseudocolor graphics*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-4：伪彩色图形*'
- en: The three-byte case, with one byte each for red, green, and blue, is illustrated
    in Figure 11-5\. This is referred to as *truecolor*, since it is capable of representing
    images with near-photographic quality.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 三字节的情况，每个颜色分别用一字节表示，如图11-5所示。这被称为*真彩色*，因为它能够以接近照片质量表示图像。
- en: '![](../images/196-2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/196-2.jpg)'
- en: '*Figure 11-5: Truecolor graphics*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-5：真彩色图形*'
- en: '[***How Video Memory Is Mapped to the Display***](toc.html#chapter11.3)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[***视频内存如何映射到显示**](toc.html#chapter11.3)'
- en: 'If the video memory provided by a graphics card is the same size (in pixels)
    as the display, then the mapping between video memory pixels and display pixels
    is straightforward: The first pixel of video memory corresponds to the pixel at
    the top left of the display, and the following pixels are mapped from left to
    right and top to bottom, the same way we read a page in English. To state this
    mathematically:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果显卡提供的视频内存大小（以像素为单位）与显示器相同，那么视频内存像素和显示器像素之间的映射就很简单：视频内存的第一个像素对应于显示器左上角的像素，接下来的像素从左到右、从上到下映射，就像我们阅读英文页面一样。用数学方式表达：
- en: '*address of pixel at (x, y) = address of video memory + (y*xres + x)*pix_width*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*像素在(x, y)处的地址 = 视频内存地址 + (y*xres + x)*pix_width*'
- en: where *xres* (the *x* resolution) is the number of pixels in a row, and *pix_width*
    is the number of bytes in a pixel.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*xres*（*x*分辨率）是行中的像素数，*pix_width*是像素中的字节数。
- en: 'But memory is no longer the critical resource it once was, and it is now common
    for graphics hardware to provide more video memory than necessary to fill the
    display. In one approach to using this extra memory, we can think of the available
    video memory as corresponding to a virtual display. The visible display is too
    small to show us all the virtual pixels at once, but we can pan the visible display
    left and right or up and down in order to expose any portion of the virtual display
    we are interested in. This situation is illustrated in Figure 11-6\. If we want
    to find the memory address of a pixel at position (*x*, *y*) in the visible display,
    we have to consider where the pixel resides in the virtual display. If the visible
    display is panned *xoffset* pixels to the right and *yoffset* pixels down, then
    the virtual position of our pixel is (*x*+*xoffset*, *y*+*yoffset*). If *line_length*
    is the length of a virtual row, then, applying the earlier formula, we have a
    memory address of:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但内存不再是曾经的关键资源，现在图形硬件通常提供的视频内存比填充显示所需的要多。在利用这部分额外内存的一种方法中，我们可以将可用的视频内存视为对应于一个虚拟显示。可见的显示区域太小，无法一次性显示所有虚拟像素，但我们可以左右或上下平移可见显示，以显示我们感兴趣的虚拟显示的任何部分。这种情况在图11-6中得到了说明。如果我们想在可见显示中找到位置(*x*,
    *y*)处的像素的内存地址，我们必须考虑像素在虚拟显示中的位置。如果可见显示向右平移*xoffset*像素和向下平移*yoffset*像素，那么我们像素的虚拟位置是(*x*+*xoffset*,
    *y*+*yoffset*)。如果*line_length*是虚拟行的长度，那么，应用前面的公式，我们有一个内存地址为：
- en: '![](../images/197-1.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/197-1.jpg)'
- en: '*Figure 11-6: Virtual and visible displays*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-6：虚拟和可见显示*'
- en: If we have an object that we want to render on the visible display, we can use
    this formula to determine which bytes to manipulate in video memory. In the remainder
    of the chapter, we will look at the layers that allow us to effectively manipulate
    video memory in software.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在可见显示上渲染一个对象，我们可以使用这个公式来确定在视频内存中要操作哪些字节。在本章的剩余部分，我们将探讨允许我们在软件中有效操作视频内存的层。
- en: '[**The Linux Framebuffer Device Driver**](toc.html#chapter11.4)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[**Linux帧缓冲区设备驱动程序**](toc.html#chapter11.4)'
- en: Linux provides access to video memory (also known as the *framebuffer*) the
    same way it provides access to most other devices—via a device file. The frame-buffer
    device file is /dev/fb0, and as with other files, we can access the data in the
    file using the system calls open, read, write, and close. You can learn more about
    these system calls from their man pages (e.g., execute man 2 write). Most system
    calls that access files do so using a small integer called a *file descriptor*.
    The system call open is an exception; it returns a file descriptor using a path
    to a file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Linux以与它提供对大多数其他设备访问相同的方式提供对视频内存（也称为*帧缓冲区*）的访问——通过设备文件。帧缓冲区设备文件是/dev/fb0，并且与其他文件一样，我们可以使用open、read、write和close系统调用来访问文件中的数据。你可以从它们的man页面（例如，执行man
    2 write）中了解更多关于这些系统调用的信息。大多数访问文件的系统调用都使用一个小整数，称为*文件描述符*。系统调用open是一个例外；它使用文件路径返回一个文件描述符。
- en: '[***Manipulating the Framebuffer with open, read, write, and close***](toc.html#chapter11.5)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[***使用open、read、write和close操作帧缓冲区***](toc.html#chapter11.5)'
- en: Because of this device file interface, it is easy to exercise the framebuffer
    with some simple Unix commands. At this point, we recommend you boot the Laddie
    CD and try these commands yourself. (You could also try these examples on your
    own system. See Appendix C if you need help setting up your framebuffer.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种设备文件接口，使用一些简单的Unix命令来练习帧缓冲区变得很容易。在此阶段，我们建议你启动Laddie CD并亲自尝试这些命令。（你也可以在自己的系统上尝试这些示例。如果你需要帮助设置帧缓冲区，请参阅附录C。）
- en: 'Once you’ve booted the Laddie CD, wait for the framebuffer UI to load, then
    press ESC to get a login prompt. Log in as root with an empty password. Now execute
    the following commands:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Laddie CD后，等待帧缓冲区UI加载，然后按ESC键获取登录提示。使用空密码以root身份登录。现在执行以下命令：
- en: '![](../images/198-1.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/198-1.jpg)'
- en: The cat command, as used in the first line, invokes the open, read, and close
    system calls to make a copy of the framebuffer in a separate file. The second
    line clears the console display. In the third line, the redirection invokes the
    open, write, and close system calls to replace the contents of the console display
    with what was originally there. The result may be confusing, since the cursor
    position will no longer match the display (you can clean up the display with another
    clear command). However, this experiment illustrates that, to the cat command,
    the framebuffer is just another file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中使用的`cat`命令调用了open、read和close系统调用来在单独的文件中复制帧缓冲区。第二行清除控制台显示。在第三行中，重定向调用了open、write和close系统调用来用原始内容替换控制台显示的内容。结果可能令人困惑，因为光标位置将不再与显示匹配（你可以使用另一个`clear`命令来清理显示）。然而，这个实验说明了，对于`cat`命令来说，帧缓冲区只是另一个文件。
- en: If your graphics adapter has a large amount of video memory, the first cat command
    may take a while (and produce a large file in /tmp). If the first command (cat
    /dev/fb0 > /tmp/screen) returns immediately with
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的图形适配器有大量的视频内存，第一个`cat`命令可能需要一段时间（并在/tmp中产生一个大的文件）。如果第一个命令（`cat /dev/fb0
    > /tmp/screen`）立即返回
- en: 'cat: /dev/fb0: No such file or directory'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 'cat: /dev/fb0: 没有这样的文件或目录'
- en: 'you need to use mknod to create the /dev/fb0 device file. Do so by running:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用`mknod`来创建`/dev/fb0`设备文件。通过运行以下命令来完成：
- en: laddie:~# mknod /dev/fb0 c 29 0
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: laddie:~# mknod /dev/fb0 c 29 0
- en: If the command cat /dev/fb0 > /tmp/screen produces the error
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令`cat /dev/fb0 > /tmp/screen`产生错误
- en: 'cat: /dev/fb0: No such device'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 'cat: /dev/fb0: 没有这样的设备'
- en: the framebuffer device driver has not been loaded successfully. Again, see Appendix
    C if you need help setting up the framebuffer device.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 帧缓冲区设备驱动程序未成功加载。再次，如果需要帮助设置帧缓冲区设备，请参阅附录C。
- en: '**NOTE**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For the remainder of this chapter, we will assume that you have a working
    framebuffer.*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章的剩余部分，我们将假设你已经有一个正常工作的帧缓冲区。*'
- en: 'To experiment with the relationship between pixel data and what is displayed
    on the screen, try any of the following commands:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要实验像素数据与屏幕上显示内容之间的关系，尝试以下任何命令：
- en: '![](../images/198-2.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/198-2.jpg)'
- en: 'On successful completion of each command (which may take a while for large
    framebuffers) you should see the error:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令成功完成后（对于大帧缓冲区可能需要一段时间）你应该看到以下错误：
- en: 'cat: write error: No space left on device'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'cat: 写入错误：设备空间不足'
- en: You see this error because you are attempting to cat an infinite supply of bits
    into a finite supply of memory. After each experiment, type the command clear
    to restore the console.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到这个错误是因为你试图将无限数量的位数据输入到有限内存中。每次实验后，输入命令`clear`以恢复控制台。
- en: '[***Configuring the Framebuffer with the ioctl Command***](toc.html#chapter11.6)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用ioctl命令配置帧缓冲区](toc.html#chapter11.6)'
- en: In our experiments so far, we have manipulated video memory without any regard
    to the way pixel data is interpreted. The way that graphics hardware interprets
    video memory is determined by the framebuffer configuration data, which also includes
    the physical address of video memory, the screen resolution (virtual and visible),
    the placement of the visible screen relative to the virtual one, as well as timing
    and other information that is outside the scope of this chapter. To access the
    video mode, we need an additional system call, ioctl, which allows us to access
    or modify parameters for devices.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止的实验中，我们操作了视频内存，而没有考虑像素数据的解释方式。图形硬件解释视频内存的方式由帧缓冲区配置数据决定，这还包括视频内存的物理地址、屏幕分辨率（虚拟和可见）、可见屏幕相对于虚拟屏幕的位置，以及本章范围之外的时间和其他信息。要访问视频模式，我们需要一个额外的系统调用ioctl，它允许我们访问或修改设备的参数。
- en: 'The ioctl system call takes a file descriptor for a device and an integer representing
    a request (see the ioctl man page for details). In the case of the framebuffer,
    the possible ioctl commands are listed in the /usr/include/ linux/fb.h header
    file and include the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ioctl系统调用需要一个设备文件描述符和一个表示请求的整数（有关详细信息，请参阅ioctl手册页）。在帧缓冲区的情况下，可能的ioctl命令列在`/usr/include/linux/fb.h`头文件中，包括以下命令：
- en: '![](../images/199-1.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/199-1.jpg)'
- en: 'The first two ioctl requests allow us to retrieve or update variable framebuffer
    parameters, and the third allows us to retrieve fixed frame-buffer parameters.
    The variable parameters are summarized in the following data structure (with some
    fields omitted), taken from fb.h:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个ioctl请求允许我们检索或更新可变帧缓冲区参数，第三个请求允许我们检索固定帧缓冲区参数。可变参数总结在以下数据结构中（省略了一些字段），来自fb.h文件：
- en: '![](../images/199-2.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](../images/199-2.jpg)'
- en: For the most part, it should be clear from the identifiers how the fields in
    this data structure correspond to the notions we discussed in the section “How
    Video Memory Works” on page 170\. The fb_bitfield structs characterize the way
    pixel bits are interpreted when they are used to specify color intensities directly
    (as in truecolor mode).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在很大程度上，从标识符中应该可以清楚地看出，这个数据结构中的字段如何对应于我们在第170页“视频内存工作原理”一节中讨论的概念。fb_bitfield结构描述了当像素位直接用于指定颜色强度时（如在真彩色模式下）如何解释这些位。
- en: For the Laddie appliance, we had no need to modify the variable frame-buffer
    data. In fact, the VESA framebuffer driver that we used does not easily support
    modification after system startup. If you are using a non-VESA frame-buffer and
    you need to modify its configuration at run time, consult the documentation for
    the fbset utility.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Laddie设备，我们没有必要修改可变帧缓冲区数据。实际上，我们使用的VESA帧缓冲区驱动程序在系统启动后不支持轻松修改。如果您使用非VESA帧缓冲区并且需要在运行时修改其配置，请参阅fbset实用程序的文档。
- en: 'The fixed framebuffer configuration parameters are provided by the following
    data structure (with some fields omitted), also in fb.h:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 固定帧缓冲区配置参数由以下数据结构提供（省略了一些字段），也在fb.h文件中：
- en: '![](../images/200-1.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](../images/200-1.jpg)'
- en: The main fields we will use here are visual, which specifies how pixels are
    interpreted (e.g., monochromatic, pseudocolor, or truecolor), and line_length,
    which we need when computing the mapping between video memory and the display.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里使用的主要字段是visual，它指定了像素的解释方式（例如，单色、伪彩色或真彩色），以及line_length，当我们在视频内存和显示之间计算映射时需要它。
- en: Finally, the following ioctl requests allow us to retrieve or update the palette
    (colormap) for video modes that use one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下ioctl请求允许我们检索或更新使用一种视频模式的调色板（颜色图例）。
- en: '![](../images/200-2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](../images/200-2.jpg)'
- en: We will show an example of how to update colormaps in the next section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示如何更新颜色图例的示例。
- en: 'At this point, we can determine the way pixel data is interpreted, so we can
    also update framebuffer memory in a meaningful way. We could use the write system
    call, just as the cat utility does, but making system calls with every framebuffer
    update is too expensive. A better approach is provided by a different system call:
    mmap. The mmap system call takes the file descriptor for our framebuffer, maps
    the framebuffer memory into the virtual address space of our process, and returns
    a pointer to the beginning of that memory. With this mapping in place, updating
    the framebuffer becomes as simple as writing to memory.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以确定像素数据的解释方式，因此我们也可以以有意义的方式更新帧缓冲区内存。我们可以使用write系统调用，就像cat实用程序一样，但每次帧缓冲区更新都进行系统调用太昂贵了。一个更好的方法是使用不同的系统调用：mmap。mmap系统调用接受我们的帧缓冲区的文件描述符，将帧缓冲区内存映射到我们进程的虚拟地址空间，并返回指向该内存开始的指针。有了这种映射，更新帧缓冲区就像写入内存一样简单。
- en: In summary, to efficiently manipulate the framebuffer, we open the appropriate
    device file, use ioctl commands to establish the graphics hardware configuration,
    use mmap to provide simple access to pixel data, and write the appropriate pixel
    data for our application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，为了有效地操作帧缓冲区，我们打开适当的设备文件，使用ioctl命令建立图形硬件配置，使用mmap提供对像素数据的简单访问，并为我们应用程序写入适当的像素数据。
- en: '[***A Simple Graphics Program for the Framebuffer***](toc.html#chapter11.7)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[***帧缓冲区的简单图形程序***](toc.html#chapter11.7)'
- en: In the remainder of this section, we’ll illustrate the Linux framebuffer interface
    by writing a simple graphics program. Our program, hazy_moon, will display a disk,
    240 pixels in diameter, that fades from bright cyan at the top to a hazy red at
    the bottom. The picture we have in mind, rendered in grayscale, is shown in Figure
    11-7\. Our program will illustrate the use of a colormap and will provide a quick,
    visual indication of whether or not we have configured the framebuffer correctly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的剩余部分，我们将通过编写一个简单的图形程序来展示 Linux 帧缓冲区接口。我们的程序 hazy_moon 将显示一个直径为 240 像素的磁盘，从顶部明亮的青色渐变到底部的模糊红色。我们心中的图片，以灰度渲染，如图
    11-7 所示。我们的程序将展示颜色映射的使用，并快速直观地指示我们是否正确配置了帧缓冲区。
- en: '![](../images/201-1.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/201-1.jpg)'
- en: '*Figure 11-7: A hazy moon*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-7：模糊的月亮*'
- en: The complete source for this program is on the Laddie CD in the directory /Code/src/examples/hazy_moon.
    Before working through the rest of this section, we recommend building and running
    the program. After booting the CD and logging in, change to the program’s directory,
    type **make**, and then type **./hazy_moon**. You should see the disk in the middle
    and a thin cyan border around the visible screen. If you don’t see all of the
    border lines, try adjusting the width and height of the image on your monitor.
    To return to the original virtual terminal, use ctrl-alt-F1\. If the dimensions
    of the graphics virtual terminal are not what you expected, try the command deallocvt
    at the bash prompt to deallocate resources for the unused terminals, and then
    run the test program again.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的完整源代码位于 Laddie CD 上的 /Code/src/examples/hazy_moon 目录中。在阅读本节剩余内容之前，我们建议构建并运行该程序。启动
    CD 并登录后，切换到程序目录，输入 **make**，然后输入 **./hazy_moon**。你应该会看到中间的磁盘以及围绕可见屏幕的浅蓝色边框。如果你看不到所有的边框线，尝试调整你显示器上图像的宽度和高度。要返回原始虚拟终端，使用
    ctrl-alt-F1。如果图形虚拟终端的尺寸不是你预期的，尝试在 bash 提示符下输入 deallocvt 命令来释放未使用的终端资源，然后再次运行测试程序。
- en: '**NOTE**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When using the Laddie CD, you can view source files using vim or less. Use
    the commands* man vim *or* vimtutor *if you’re not familiar with the vim editor.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*当使用 Laddie CD 时，您可以使用 vim 或 less 查看源文件。如果您不熟悉 vim 编辑器，可以使用命令* man vim *或*
    vimtutor *。*'
- en: Now we’ll discuss the details of the hazy_moon program. The first detail requires
    a little working knowledge of virtual terminals.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论 hazy_moon 程序的细节。第一个细节需要一点关于虚拟终端的工作知识。
- en: '**A Virtual Terminal for Graphics**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形虚拟终端**'
- en: One of the advantages and challenges of Linux is that it uses framebuffers for
    text consoles. This use of framebuffers is an advantage because it supports colored
    text and a wide range of fonts and character sets. However, using framebuffers
    in this way also presents a challenge, because while developing a framebuffer
    application, it’s easy to trip over Linux’s machinery for managing consoles.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的一个优点和挑战是它使用帧缓冲区来处理文本控制台。这种使用帧缓冲区的方式是一个优点，因为它支持彩色文本和广泛的字体和字符集。然而，以这种方式使用帧缓冲区也带来挑战，因为在开发帧缓冲区应用程序时，很容易遇到
    Linux 管理控制台的机制。
- en: For example, a program that prints a one-line message to the console can modify
    the position of the visible display relative to the virtual display; the result
    is that a displayed graphic is misplaced by the width of that line. Or, if the
    graphics hardware is configured to use a palette, and if a program modifies the
    colors used to display text in the console, printed messages may become hard to
    read or even invisible.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个将单行消息打印到控制台的程序可以修改可见显示相对于虚拟显示的位置；结果是显示的图形被该行的宽度所错位。或者，如果图形硬件配置为使用调色板，并且如果程序修改了用于在控制台显示文本的颜色，打印的消息可能难以阅读甚至看不见。
- en: For these reasons, it’s best to use a separate virtual terminal for graphical
    displays. We accomplish this in the hazy_moon program with the following lines.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，最好为图形显示使用单独的虚拟终端。我们在 hazy_moon 程序中通过以下几行代码实现这一点。
- en: '![](../images/202-1.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/202-1.jpg)'
- en: Note that we’re using the familiar open and ioctl system calls, though in this
    case, it’s not with the framebuffer. The first call (console_fd = open("/dev/
    tty", O_RDWR);) opens the console device; the second (ioctl(console_fd, VT_ACTIVATE,
    7);) requests a switch to virtual terminal 7; and the third (ioctl(console_fd,
    VT_WAITACTIVE, 7);) waits until the switch is complete. (We chose virtual terminal
    7 because our system uses terminals 1 through 6 for consoles.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们正在使用熟悉的open和ioctl系统调用，尽管在这种情况下，它不是用于framebuffer。第一个调用（console_fd = open("/dev/tty",
    O_RDWR);）打开控制台设备；第二个调用（ioctl(console_fd, VT_ACTIVATE, 7);）请求切换到虚拟终端7；第三个调用（ioctl(console_fd,
    VT_WAITACTIVE, 7);）等待切换完成。（我们选择虚拟终端7，因为我们的系统使用1到6的终端作为控制台。）
- en: '**open**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**open**'
- en: Now we use the open system call on the framebuffer device file, specifying the
    device file as read/write.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用open系统调用在framebuffer设备文件上，指定设备文件为读写。
- en: fb_fd = open("/dev/fb0", O_RDWR);
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: fb_fd = open("/dev/fb0", O_RDWR);
- en: The function open returns -1 on error; otherwise, it returns an integer file
    descriptor that we will use in making subsequent system calls for this device.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 函数open在错误时返回-1；否则，它返回一个整数文件描述符，我们将使用它来为该设备进行后续的系统调用。
- en: '**NOTE**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* open *system call returns an error value that should be handled. We won’t
    discuss error handling here, but you can see how we handled errors by looking
    at the full source in the hazy_moon.c file.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*open*系统调用返回一个错误值，应该被处理。我们在这里不会讨论错误处理，但你可以通过查看hazy_moon.c文件中的完整源代码来了解我们是如何处理错误的。'
- en: '**ioctl**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**ioctl**'
- en: Using the framebuffer’s file descriptor, we can make the ioctl calls to retrieve
    the fixed and variable configuration data for a framebuffer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用framebuffer的文件描述符，我们可以进行ioctl调用以检索framebuffer的固定和可变配置数据。
- en: '![](../images/202-2.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/202-2.jpg)'
- en: Before updating the display, hazy_moon calls two helper routines to display
    the fixed and variable data. This information can be useful when you’re trying
    to debug—or simply understand—a framebuffer application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新显示之前，hazy_moon调用两个辅助例程来显示固定和可变数据。当你试图调试或简单地理解framebuffer应用程序时，这些信息可能很有用。
- en: display_fb_fixed_info(&fixed_info);
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: display_fb_fixed_info(&fixed_info);
- en: display_fb_var_info(&var_info);
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: display_fb_var_info(&var_info);
- en: If you ran the program earlier, you saw this output after returning to the virtual
    terminal from which you launched the program. The output would have shown, in
    particular, that our display screen is 640 by 480, that we have 8 bits per pixel,
    and that our visual type is pseudocolor.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前运行过程序，当你从启动程序的虚拟终端返回时，你会看到这个输出。输出会特别显示，我们的显示屏幕是640×480，每个像素有8位，我们的视觉类型是伪彩色。
- en: The following code first ![](../images/1.jpg) creates a new colormap using a
    helper function new_fb_cmap. This function is defined in the accompanying file
    colormap.c. The program then ![](../images/2.jpg) copies the current values from
    the framebuffer using an ioctl call and ![](../images/3.jpg) updates the entries
    to provide a gradient from cyan to dark red. Finally, the program ![](../images/4.jpg)
    updates the framebuffer with the new colormap using a second ioctl call.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码首先使用辅助函数new_fb_cmap创建一个新的调色板，该函数定义在附带的文件colormap.c中。然后程序使用ioctl调用复制framebuffer中的当前值，并更新条目以提供从青色到深红色的渐变。最后，程序使用第二个ioctl调用使用新的调色板更新framebuffer。
- en: '![](../images/203-1.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/203-1.jpg)'
- en: The first argument to mmap is 0, indicating that mmap will choose where the
    framebuffer is mapped. The value fixed_info.smem_len is the length of the framebuffer.
    We specify that the framebuffer can be read or written with PROT_READ|PROT_WRITE,
    and we use MAP_SHARED to indicate that changes to this memory region will propagate
    to the actual framebuffer. The file descriptor for the opened framebuffer device
    is fb_fd, and we specify an offset of 0, since we want to map the entire framebuffer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: mmap的第一个参数是0，表示mmap将选择framebuffer映射的位置。fixed_info.smem_len的值是framebuffer的长度。我们指定framebuffer可以读取或写入，使用PROT_READ|PROT_WRITE，并使用MAP_SHARED来指示对这个内存区域的更改将传播到实际的framebuffer。打开的framebuffer设备的文件描述符是fb_fd，我们指定偏移量为0，因为我们想映射整个framebuffer。
- en: If this call succeeds (again, see the source on the CD for error handling),
    frame will point to the start of framebuffer memory.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个调用成功（再次，请参阅CD上的源代码以了解错误处理），frame将指向framebuffer内存的起始位置。
- en: '**Writing Pixel Data**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**写入像素数据**'
- en: Now that we have a colormap and a way to place pixels on the screen, we can
    write a simple graphics program. The following code will create the promised 240-by-240–pixel
    hazy moon, as well as the single-pixel border around the perimeter of the display.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了颜色映射表和将像素放置在屏幕上的方法，我们可以编写一个简单的图形程序。以下代码将创建承诺的240-by-240像素的模糊月亮，以及围绕显示边界的单像素边界。
- en: '![](../images/204-1.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/204-1.jpg)'
- en: As we illustrated in Figure 11-6, the visible display might be a subset of the
    available framebuffer memory. We first find the beginning of displayed memory,
    ![](../images/1.jpg) visible_frame, using the xoffset, yoffset, and line_length
    values from the framebuffer device’s variable information. In the rest of this
    code, we compute memory offsets relative to visible_frame, and therefore have
    no further need for xoffset or yoffset. However, we have to use ![](../images/2.jpg)
    line_length consistently whenever we compute an offset for a number of rows.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在图11-6中所示，可见显示可能只是可用帧缓冲区内存的一个子集。我们首先使用帧缓冲区设备的变量信息中的xoffset、yoffset和line_length值找到显示内存的起始位置，即![](../images/1.jpg)
    visible_frame。在接下来的代码中，我们计算相对于visible_frame的内存偏移量，因此不再需要xoffset或yoffset。然而，每次我们计算多行偏移量时，都必须一致地使用![](../images/2.jpg)
    line_length。
- en: '**Cleaning Up**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**清理**'
- en: At this point, we can clean up and exit the program.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以清理并退出程序。
- en: munmap(frame, fixed_info.smem_len);
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: munmap(frame, fixed_info.smem_len);
- en: free_fb_cmap(new_cmap);
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: free_fb_cmap(new_cmap);
- en: This program is meant to be a simple demonstration; to build a useful framebuffer
    interface would require a good deal more work. For example, we haven’t discussed
    displaying text or responding to keyboard input, and we haven’t written code to
    recover the screen after blanking out or to get rid of the cursor in the upper-left
    corner. We could write code to address these problems, but in fact, they have
    already been solved by graphics libraries that work on top of the framebuffer
    interface. In the next section, we’ll consider two choices for graphics libraries
    and work through an example with one of them, the Simple DirectMedia Library.
    If you would still like to spend more time mastering the framebuffer interface,
    see the header file /usr/src/linux/include/linux/fb.h and the documentation files
    in the directory /usr/src/linux/Documentation/fb.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序旨在作为一个简单的演示；要构建一个有用的帧缓冲区接口，需要做更多的工作。例如，我们还没有讨论显示文本或响应键盘输入，我们也没有编写在屏幕变暗后恢复屏幕或消除左上角光标的代码。我们可以编写代码来解决这些问题，但实际上，这些问题已经被在帧缓冲区接口之上工作的图形库解决了。在下一节中，我们将考虑两个图形库的选择，并使用其中一个进行示例，即简单直接媒体库（Simple
    DirectMedia Library）。如果您还想花更多时间掌握帧缓冲区接口，请参阅头文件/usr/src/linux/include/linux/fb.h以及目录/usr/src/linux/Documentation/fb中的文档文件。
- en: '[**Graphics Libraries**](toc.html#chapter11.8)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图形库**](toc.html#chapter11.8)'
- en: 'Using the Linux framebuffer interface, we have reduced the problem of manipulating
    pixels on the display to the problem of writing bytes to memory. But think of
    some of the ways in which we would like to manipulate display pixels: drawing
    lines of a specified thickness, drawing windows with rounded edges and a three-dimensional
    look, transferring images, or drawing text with a given font and size. These are
    nontrivial problems; that’s why we need a graphics library. With an appropriate
    graphics library, we can write programs that manipulate lines, windows, images,
    and text, and let the underlying library decide what to do with the pixels.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Linux帧缓冲区接口，我们将显示上像素操作的问题简化为写入内存的字节问题。但考虑一下我们想要操纵显示像素的一些方式：绘制指定厚度的线条，绘制边缘圆润且具有三维效果的窗口，传输图像，或者用给定的字体和大小绘制文本。这些都是非平凡的问题；这就是为什么我们需要图形库。有了合适的图形库，我们可以编写操作线条、窗口、图像和文本的程序，并让底层库决定如何处理像素。
- en: The most common library for manipulating graphics objects in Linux is Xlib.
    Xlib is actually more than a graphics library; it is the interface by which clients
    access an X Window display server. In particular, it also manages user input events.
    Because of its popularity, building a Linux appliance on top of X can be a good
    choice. Xlib is cumbersome to program directly, but with an X system, a UI developer
    can choose among several competing GUI toolkits (for example, Qt, which is used
    by the KDE desktop, or GTK+, which is used by the Gnome desktop). Alternatively,
    UI developers can include an X-based web browser on the appliance and provide
    the UI as a set of web pages. In any of these cases, UI development for the appliance
    would be little different from UI development on a Linux desktop.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中操作图形对象最常见的库是Xlib。实际上，Xlib不仅仅是一个图形库；它是客户端访问X Window显示服务器的接口。特别是，它还管理用户输入事件。由于其流行，在X之上构建Linux设备可能是一个不错的选择。Xlib直接编程比较繁琐，但有了X系统，UI开发者可以在几个竞争的GUI工具包（例如，被KDE桌面使用的Qt，或被Gnome桌面使用的GTK+）之间进行选择。或者，UI开发者可以在设备上包含基于X的网页浏览器，并将UI作为一组网页提供。在任何这些情况下，设备的UI开发与Linux桌面上的UI开发几乎没有什么不同。
- en: On the other hand, the X Window system is complex and provides features that
    will often not be needed on an appliance. Because X is network-oriented, it involves
    an additional network layer between Xlib and the Xserver. X incorporates support
    for multiscreen displays and multiple clients, and it also provides for window
    management that is not controlled by the client application. These are nice features
    for a distributed networking environment, but their complexity makes X an expensive
    option for appliances with tight memory and storage budgets. If you have resource
    constraints but would still like to use X, you may want to investigate TinyX,
    described at [http://XFree86.org](http://XFree86.org) as “a family of X servers
    designed to be particularly small.” For more information on Xlib, see the *Xlib
    Programming Manual* by Adrian Nye, (O’Reilly, 1994). There are also several articles
    about X on Wikipedia, such as [http://en.wikipedia.org/wiki/Xlib](http://en.wikipedia.org/wiki/Xlib).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，X Window系统复杂且提供了在设备上通常不需要的功能。由于X是网络导向的，它涉及Xlib和Xserver之间的一个额外网络层。X集成了对多屏显示和多个客户端的支持，并且它还提供了不由客户端应用程序控制的窗口管理功能。这些是分布式网络环境中的不错特性，但它们的复杂性使得X成为内存和存储预算紧张的设备上的昂贵选择。如果你有资源限制但仍然想使用X，你可能想调查TinyX，它被描述为“专为特别小巧设计的X服务器家族”，详情请见[http://XFree86.org](http://XFree86.org)。关于Xlib的更多信息，请参阅Adrian
    Nye所著的《*Xlib编程手册*》（O’Reilly，1994年）。维基百科上也有关于X的几篇文章，例如[http://en.wikipedia.org/wiki/Xlib](http://en.wikipedia.org/wiki/Xlib)。
- en: Another option for a graphics library is the *Simple DirectMedia Layer (SDL)*,
    a multimedia library originally designed for developing and porting games. Like
    Xlib, SDL is cross-platform and manages user input as well as graphics. Unlike
    Xlib, SDL provides only minimal support for managing windows. It has a small footprint;
    the libraries for SDL (including SDL_ttf for TrueType fonts) take up about 330KB,
    stripped.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个图形库的选项是*简单直接媒体层（SDL）*，这是一个最初为开发和移植游戏而设计的多媒体库。像Xlib一样，SDL是跨平台的，它管理用户输入以及图形。与Xlib不同，SDL仅提供对管理窗口的最小支持。它具有小巧的体积；SDL的库（包括用于TrueType字体的SDL_ttf）大约占用330KB，去除了未使用部分。
- en: Because of its simplicity (we didn’t need windowing support), we chose SDL as
    the graphics library for the Laddie appliance, and we will demonstrate this library
    with a simple example in the next section. For more details on SDL, especially
    on multimedia support, see *Programming Linux Games* by John R. Hall, (No Starch
    Press, 2001). The SDL website ([http://www.libsdl.org](http://www.libsdl.org/))
    also provides good documentation on the SDL API. We used the SDL_ttf library as
    a wrapper for TrueType fonts, which in turn required the FreeType package from
    [http://www.freetype.org](http://www.freetype.org/). See [http://www.libsdl.org/projects/SDL_ttf](http://www.libsdl.org/projects/SDL_ttf)
    for links to documentation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其简单性（我们不需要窗口支持），我们选择了SDL作为Laddie设备的图形库，我们将在下一节中通过一个简单的示例来展示这个库。关于SDL的更多详细信息，特别是关于多媒体支持，请参阅John
    R. Hall所著的《*Linux游戏编程*》（No Starch Press，2001年）。SDL网站([http://www.libsdl.org](http://www.libsdl.org/))也提供了SDL
    API的良好文档。我们使用了SDL_ttf库作为TrueType字体的包装器，这又需要从[http://www.freetype.org](http://www.freetype.org/)获取FreeType包。有关文档链接，请见[http://www.libsdl.org/projects/SDL_ttf](http://www.libsdl.org/projects/SDL_ttf)。
- en: '[**“Hello, world!” with SDL**](toc.html#chapter11.9)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[**“使用SDL的‘Hello, world！’**](toc.html#chapter11.9)'
- en: To introduce SDL, let’s work through a simple program to display *Hello, world!*,
    monitor the keyboard, and exit gracefully when the spacebar is pressed (see Figure
    11-8).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍SDL，让我们通过一个简单的程序来显示*Hello, world!*，监控键盘，并在按下空格键时优雅地退出（见图11-8）。
- en: This program is on the Laddie CD; before looking at the details, we recommend
    building and running the program. Boot the Laddie CD and, after the framebuffer
    UI loads, exit by pressing ESC.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序位于Laddie光盘上；在查看细节之前，我们建议构建并运行程序。启动Laddie光盘，在帧缓冲区用户界面加载后，通过按ESC键退出。
- en: '![](../images/206-1.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/206-1.jpg)'
- en: '*Figure 11-8: “Hello, world!” with SDL*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-8：“Hello, world!”使用SDL*'
- en: '**NOTE**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It’s important that the framebuffer isn’t running, because it would interfere
    with our current example. Incidentally, if the framebuffer UI didn’t start automatically
    when you booted the CD, you may have problems with your framebuffer. In this case,
    see Appendix C for help. The framebuffer UI display is shown in Figure 11-10.*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*重要的是确保帧缓冲区没有运行，因为它会干扰我们的当前示例。顺便说一句，如果你在启动光盘时帧缓冲区用户界面没有自动启动，你可能遇到了帧缓冲区的问题。在这种情况下，请参阅附录C以获取帮助。帧缓冲区用户界面显示如图11-10所示。*'
- en: Log in as root with an empty password, change to the sdl_hello directory, then
    build and run the program.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以空密码登录root，切换到sdl_hello目录，然后构建并运行程序。
- en: laddie:~# cd /Code/src/examples/sdl_hello
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: laddie:~# cd /Code/src/examples/sdl_hello
- en: laddie:~# make
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: laddie:~# make
- en: laddie:~# ./sdl_hello
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: laddie:~# ./sdl_hello
- en: You should see the display shown in Figure 11-8\. When you press the spacebar,
    the display will disappear and you will be back at the command prompt. In the
    remainder of this section we’ll show how we implemented the sdl_hello program.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到图11-8所示的显示。当你按下空格键时，显示将消失，你将回到命令提示符。在本节的剩余部分，我们将展示如何实现sdl_hello程序。
- en: 'Our program uses a single main function and includes five steps: initialize
    the libraries, initialize the framebuffer, create a *surface* (SDL’s term for
    a rectangular area of pixels), display the surface, and handle events. As in our
    earlier example, we will not show error handling here. Please see the source for
    the sdl_hello program on the CD in the /Code/src/examples/sdl_hello directory
    for example error-handling code.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序使用一个主函数，包括五个步骤：初始化库、初始化帧缓冲区、创建一个*表面*（SDL对像素矩形区域的术语）、显示表面和处理事件。正如我们之前的示例，我们这里不会展示错误处理。请参阅光盘上/Code/src/examples/sdl_hello目录中的sdl_hello程序的源代码以获取示例错误处理代码。
- en: '[***Initialize the Libraries***](toc.html#chapter11.10)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[***初始化库***](toc.html#chapter11.10)'
- en: The following lines from our example program initialize the SDL and SDL_ttf
    libraries.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们示例程序中初始化SDL和SDL_ttf库的行。
- en: '![](../images/207-1.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/207-1.jpg)'
- en: SDL supports several subsystems, including TIMER, AUDIO, VIDEO, CDROM, and JOYSTICK,
    and we ![](../images/1.jpg) select these when calling SDL_Init(). (We will only
    use the VIDEO subsystem in this chapter.) In order to display text, we ![](../images/2.jpg)
    initialize SDL’s support for TrueType fonts. The calls to ![](../images/3.jpg)
    atexit() provide functions (SDL_Quit and TTF_Quit) to be invoked at program exit;
    they ensure that SDL quits cleanly at the end of the program.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SDL支持多个子系统，包括TIMER、AUDIO、VIDEO、CDROM和JOYSTICK，我们在调用SDL_Init()时选择这些子系统。（在本章中，我们只会使用VIDEO子系统。）为了显示文本，我们初始化SDL对TrueType字体的支持。对atexit()的调用提供了在程序退出时调用的函数（SDL_Quit和TTF_Quit）；它们确保SDL在程序结束时干净地退出。
- en: '[***Initialize the Framebuffer***](toc.html#chapter11.11)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[***初始化帧缓冲区***](toc.html#chapter11.11)'
- en: To configure the framebuffer’s resolution and bits per pixel, we use the function
    SDL_SetVideoMode.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置帧缓冲区的分辨率和每像素位数，我们使用函数SDL_SetVideoMode。
- en: '![](../images/207-2.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/207-2.jpg)'
- en: 'When a desired video mode is unavailable, SDL will emulate it; however, we
    will keep things simple and choose a mode that works natively with most graphics
    adapters: 640 by 480, with 8 bits per pixel. The final argument to SDL_SetVideoMode
    provides flags for features such as whether to use video memory or system memory,
    whether to support double buffering, and whether to support OpenGL. For our purposes,
    the defaults are fine. The return value, ![](../images/1.jpg) Screen, has type
    SDL_Surface. These surfaces represent rectangular collections of pixels and are
    characterized by height, width, pixel format, scanline length, a clipping rectangle,
    and, of course, the actual pixel data. The Screen surface is special, since it
    corresponds directly to the displayed memory. But surfaces can also represent
    any graphical object, such as an image or a piece of text. For the examples in
    this chapter, we will create graphical objects from bitmaps or by rendering text,
    but it is also possible to create an empty surface and then manipulate its pixel
    data directly.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当所需的视频模式不可用时，SDL 将进行模拟；然而，我们将保持简单，并选择与大多数图形适配器原生兼容的模式：640 x 480，每像素8位。传递给 SDL_SetVideoMode
    的最后一个参数提供了用于视频内存或系统内存、是否支持双缓冲以及是否支持 OpenGL 等功能的标志。对于我们的目的，默认设置就足够了。返回值，![图片](../images/1.jpg)
    屏幕具有 SDL_Surface 类型。这些表面代表像素的矩形集合，并具有高度、宽度、像素格式、扫描行长度、裁剪矩形，当然还有实际的像素数据。屏幕表面是特殊的，因为它直接对应于显示内存。但表面也可以代表任何图形对象，例如图像或文本。在本章的示例中，我们将从位图或通过渲染文本创建图形对象，但也可以创建一个空表面，然后直接操作其像素数据。
- en: After setting the video mode, we ![](../images/2.jpg) call the function SDL_ShowCursor
    to hide the cursor, since we are not using a mouse for input.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置视频模式后，我们![图片](../images/2.jpg) 调用 SDL_ShowCursor 函数来隐藏光标，因为我们不使用鼠标进行输入。
- en: '[***Create a Surface***](toc.html#chapter11.12)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[***创建表面***](toc.html#chapter11.12)'
- en: To create a text object, we need to open a font and then render the text to
    create a surface.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个文本对象，我们需要打开一个字体，然后将文本渲染到创建一个表面。
- en: '![](../images/208-1.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/208-1.jpg)'
- en: The ![](../images/2.jpg) TTF_OpenFont() function requires a pathname to a TrueType
    font file and a font size. The ![](../images/3.jpg) TTF_RenderText_Solid() function
    uses a font, a string of text, and a color to create a surface. An ![](../images/1.jpg)
    SDL color consists of four 16-bit values for red, green, blue, and an alpha channel.
    The alpha channel value is used for blending translucent surfaces and is not practical
    when using pseudocolor graphics; we won’t consider it further in this chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/2.jpg) TTF_OpenFont() 函数需要一个 TrueType 字体文件的路径名和字体大小。![图片](../images/3.jpg)
    TTF_RenderText_Solid() 函数使用一个字体、一个文本字符串和一个颜色来创建一个表面。一个![图片](../images/1.jpg) SDL
    颜色由红色、绿色、蓝色和 alpha 通道的四个 16 位值组成。alpha 通道值用于混合半透明表面，在伪彩色图形中使用时不实用；我们在此章中不会进一步考虑它。'
- en: Since fonts are subject to copyright, you will need to put some thought into
    the fonts you choose for your application. For the Laddie CD, we chose the liberally
    licensed Bitstream Vera fonts, associated with the GNOME foundation (available
    from [http://www.gnome.org/fonts](http://www.gnome.org/fonts)). These include
    monospace and proportionally spaced fonts, serif and sans-serif, normal, italicized,
    bold, and bold-italicized. These may already be installed on your system in /usr/X11R6/lib/X11/fonts/truetype.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字体受版权保护，您在选择应用程序中的字体时需要考虑一些问题。对于 Laddie CD，我们选择了自由许可的 Bitstream Vera 字体，与
    GNOME 基金会相关联（可在 [http://www.gnome.org/fonts](http://www.gnome.org/fonts) 获取）。这些包括等宽和比例间距字体、有衬线和无衬线、正常、斜体、粗体和粗斜体。这些字体可能已经安装在了您的系统中的
    /usr/X11R6/lib/X11/fonts/truetype 目录下。
- en: '[***Display the Surface***](toc.html#chapter11.13)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[***显示表面***](toc.html#chapter11.13)'
- en: 'Displaying rendered text is no different than displaying any other object in
    SDL: We just blit (transfer) the surface onto the screen (i.e., the Screen surface).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 显示渲染的文本与在 SDL 中显示任何其他对象没有区别：我们只需将表面（即屏幕表面）复制（传输）到屏幕上。
- en: '![](../images/209-1.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/209-1.jpg)'
- en: The ![](../images/1.jpg) SDL_BlitSurface function takes a source surface, a
    rectangle specifying a subset of this surface (NULL for the entire surface), a
    destination surface, and a rectangle whose *x* and *y* values indicate the position
    where the source is to be placed. The SDL_BlitSurface function fills out the width
    and height values for the destination rectangle based on the portion of the destination
    that was updated. We use this rectangle to update the Screen surface with ![](../images/2.jpg)
    the SDL_UpdateRects function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/1.jpg) SDL_BlitSurface函数接受一个源表面，一个指定此表面子集的矩形（NULL表示整个表面），一个目标表面，以及一个矩形，其*x*和*y*值指示源放置的位置。SDL_BlitSurface函数根据目标更新部分填充目标矩形的宽度和高度值。我们使用这个矩形通过![](../images/2.jpg)
    SDL_UpdateRects函数更新屏幕表面。'
- en: '[***Handle Events***](toc.html#chapter11.14)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[***处理事件***](toc.html#chapter11.14)'
- en: At this point, we have displayed the *Hello, world!* message. Now we need to
    monitor the keyboard and exit when the spacebar is pressed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经显示了*Hello, world!*消息。现在我们需要监控键盘，并在按下空格键时退出。
- en: '![](../images/209-2.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/209-2.jpg)'
- en: This code could be simplified for the “Hello, world!” application, but in this
    form it represents a general approach to event handling with SDL. The ![](../images/1.jpg)
    SDL_WaitEvent function suspends the main thread until an event occurs. The event
    variable has a union type corresponding to more than a dozen SDL events, including
    keyboard, mouse, and user-defined events. SDL also distinguishes keypresses from
    key releases. In the case of a keyboard event, we can check the particular key
    using ![](../images/2.jpg) the event.key.keysym.sym field, which can take on values
    such as ![](../images/3.jpg) SDLK_SPACE, SDL_TAB, SDLK_0, SDLK_a, and so on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“Hello, world!”应用程序，这段代码可以简化，但以这种形式，它代表了使用SDL处理事件的通用方法。![](../images/1.jpg)
    SDL_WaitEvent函数会挂起主线程，直到发生事件。事件变量具有联合类型，对应于十几个SDL事件，包括键盘、鼠标和用户定义的事件。SDL还区分按键和按键释放。在键盘事件的情况下，我们可以使用![](../images/2.jpg)
    event.key.keysym.sym字段来检查特定的键，它可以取如![](../images/3.jpg) SDLK_SPACE, SDL_TAB, SDLK_0,
    SDLK_a等值。
- en: '[**Graphical UI Toolkits**](toc.html#chapter11.15)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图形用户界面工具包**](toc.html#chapter11.15)'
- en: While the SDL API is easier to use than the framebuffer interface, it is not,
    in itself, a convenient library for developing a GUI. SDL supports event handling
    and graphics, but the two are only loosely coupled. When building a GUI, we use
    objects for which the display and the input mechanism are inherently connected.
    Examples include scroll bars, drop-down menus, and text-entry forms. GUI toolkits
    support GUI development by providing a collection of these objects (*widgets*).
    Figure 11-9 illustrates the relationships between a widget, a user, and the underlying
    application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SDL API比帧缓冲区接口更容易使用，但它本身并不是开发GUI的方便库。SDL支持事件处理和图形，但两者仅松散耦合。在构建GUI时，我们使用显示和输入机制固有连接的对象。例如，包括滚动条、下拉菜单和文本输入表单。GUI工具包通过提供这些对象（*小部件*）的集合来支持GUI开发。图11-9说明了小部件、用户和底层应用程序之间的关系。
- en: '![](../images/210-1.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/210-1.jpg)'
- en: '*Figure 11-9: A typical, full-featured widget*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-9：一个典型、功能齐全的小部件*'
- en: User input events (e.g., mouse movements or keypresses), update the widget and
    control the underlying application by initiating callbacks. The application can
    control the widget or exchange data with it by calling the widget’s functions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入事件（例如，鼠标移动或按键），通过初始化回调函数来更新小部件并控制底层应用程序。应用程序可以通过调用小部件的函数来控制小部件或与其交换数据。
- en: In addition to providing widgets, a GUI toolkit also provides a framework for
    managing them. The framework is typically built on top of a window manager. It
    routes events, determines which widget has focus, and ensures that overlapping
    widgets are displayed appropriately.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供小部件外，GUI工具包还提供了一个管理它们的框架。该框架通常建立在窗口管理器之上。它路由事件，确定哪个小部件具有焦点，并确保重叠的小部件适当地显示。
- en: The two most popular GUI toolkits for Linux are GTK+ ([www.gtk.org](http://www.gtk.org/))
    and Qt ([http://www.trolltech.com](http://www.trolltech.com/)); if you choose
    one of these, your decision will probably come down to cost and licensing. GTK+
    is released under the more liberal LGPL license, allowing you to link your proprietary
    software to GTK+ libraries. Qt may be licensed under the GPL, but this requires
    that your GUI application also be released under the GPL. To build a proprietary
    application on top of Qt, you will need to pay Trolltech for the commercial license.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Linux上最流行的两个GUI工具包是GTK+ ([www.gtk.org](http://www.gtk.org/)) 和 Qt ([http://www.trolltech.com](http://www.trolltech.com/))；如果你选择其中之一，你的决定可能取决于成本和许可。GTK+在更自由的LGPL许可证下发布，允许你将你的专有软件链接到GTK+库。Qt可能根据GPL许可，但这要求你的GUI应用程序也必须在GPL下发布。要在Qt上构建专有应用程序，你需要向Trolltech支付商业许可证费用。
- en: 'If your application will be licensed under GPL or if money is not an object,
    there are other differences to consider. GTK+ is written in C, though it does
    have many object-oriented features. Qt is written in C++. Both have a broad user
    base: GTK+ is the basis for the Gnome desktop, and Qt is the basis for the KDE
    desktop.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序将根据GPL许可，或者钱不是问题，还有其他差异需要考虑。GTK+是用C编写的，尽管它具有许多面向对象的功能。Qt是用C++编写的。它们都有广泛的用户基础：GTK+是Gnome桌面的基础，Qt是KDE桌面的基础。
- en: In case you are not using X on your appliance, Qt also has support for the Linux
    framebuffer. Some work has been done on a framebuffer back end for GTK+ using
    DirectFB, which is also released under the LGPL. See [http://www.directfb.org/wiki/index.php/Projects:GTK_on_DirectFB](http://www.directfb.org/wiki/index.php/Projects:GTK_on_DirectFB)
    for more information.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你的设备上没有使用X，Qt也支持Linux帧缓冲区。有人使用DirectFB对GTK+的帧缓冲区后端进行了工作，DirectFB也是在LGPL下发布的。有关更多信息，请参阅[http://www.directfb.org/wiki/index.php/Projects:GTK_on_DirectFB](http://www.directfb.org/wiki/index.php/Projects:GTK_on_DirectFB)。
- en: The Fast Light Toolkit (FLTK; [http://www.fltk.org](http://www.fltk.org/)) is
    a promising choice for a free GUI toolkit if you would like a smaller footprint
    than GTK+ but are still willing to adopt X. FLTK is designed for tight, statically
    linked applications, and its modified LGPL license allows static linking in proprietary
    applications. It is written in C++ and supports Windows in addition to Linux.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 快速轻量工具包（FLTK；[http://www.fltk.org](http://www.fltk.org/））是一个很有前景的选择，如果你希望比GTK+占用更小的空间，但仍然愿意采用X。FLTK是为紧密、静态链接的应用程序设计的，并且其修改后的LGPL许可证允许在专有应用程序中进行静态链接。它使用C++编写，并支持Linux以外的Windows。
- en: We won’t discuss the popular GUI toolkits any further here; they are documented
    well elsewhere.¹ In fact, for the Laddie appliance, we found that these toolkits
    provided a good deal of functionality that we didn’t need, and, because of their
    orientation toward the mouse and keyboard, they didn’t cleanly match our approach
    of using a simple, handheld remote control. In the remainder of this section,
    we will describe STBmenu, a thin layer built on SDL that we developed with set-top
    box interfaces in mind.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会进一步讨论流行的GUI工具包；它们在其他地方有很好的文档。实际上，对于Laddie设备，我们发现这些工具包提供了我们不需要的大量功能，并且由于它们面向鼠标和键盘，它们没有很好地匹配我们使用简单、手持遥控器的方法。在本节的剩余部分，我们将描述STBmenu，这是一个基于SDL的薄层，我们考虑到机顶盒接口进行了开发。
- en: '[***Building Simple UIs with STBmenu***](toc.html#chapter11.16)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[***使用STBmenu构建简单的UI***](toc.html#chapter11.16)'
- en: Besides having a framework that functioned naturally with remotes, we saw two
    other advantages of writing our own GUI toolkit. We thought it would be useful
    for illustrating how GUI toolkits work (at about 1,300 lines including comments,
    it doesn’t take long to read), and, in keeping with the philosophy of this book,
    we wanted to see how clean a separation we could make between the UI and the underlying
    application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拥有与遥控器自然协同工作的框架外，我们还看到了编写我们自己的GUI工具包的两个其他优点。我们认为这有助于说明GUI工具包是如何工作的（包括注释大约有1,300行，阅读起来并不费时），并且，遵循本书的哲学，我们想看看我们能在UI和底层应用程序之间实现多干净的分隔。
- en: At this point, we recommend taking a quick tour of the Laddie frame-buffer UI
    in order to see the kind of GUI STBmenu can support. As we noted in the section
    “‘Hello, world!’ with SDL” on page 182, when you boot the Laddie CD, it will attempt
    to launch the Laddie framebuffer UI automatically. (If it doesn’t, see Appendix
    C for help on setting up your framebuffer.) If you are already running the CD
    and have a command prompt, start the frame-buffer UI with the fbmenuctl start
    command. If the UI is already running, but isn’t visible, use ctrl-alt-F7 to switch
    to the appropriate virtual terminal.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，我们建议快速浏览一下 Laddie 帧缓冲 UI，以便了解 STBmenu 可以支持的 GUI 类型。正如我们在第 182 页的“使用 SDL
    的‘Hello, world!’”一节中提到的，当你启动 Laddie CD 时，它会尝试自动启动 Laddie 帧缓冲 UI。（如果它没有启动，请参阅附录
    C 了解设置帧缓冲的帮助信息。）如果你已经在运行 CD 并有命令提示符，请使用 fbmenuctl start 命令启动帧缓冲 UI。如果 UI 已经运行但不可见，请使用
    ctrl-alt-F7 切换到适当的虚拟终端。
- en: The Laddie framebuffer UI consists of two pages, as illustrated in Figure 11-10\.
    We will discuss remote control in the next chapter; for now, use the arrow keys
    to navigate the UI and the enter key to activate a selection. Use the Setup and
    Status buttons to switch between pages. As you make changes, use ctrl-alt-F1 to
    switch to a command prompt and check the results with the cli utility described
    in Chapter 9\. Make changes using the cli utility, and confirm these by returning
    to the framebuffer UI with ctrl-alt-F7\. (Alternatively, you could use another
    machine on the network to check results using the web interface described in Chapter
    8.)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Laddie 帧缓冲 UI 由两个页面组成，如图 11-10 所示。我们将在下一章讨论远程控制；现在，请使用箭头键导航 UI，并使用回车键激活选择。使用设置和状态按钮在页面之间切换。当你进行更改时，请使用
    ctrl-alt-F1 切换到命令提示符，并使用第 9 章中描述的 cli 工具检查结果。使用 cli 工具进行更改，并通过使用 ctrl-alt-F7 返回到帧缓冲
    UI 来确认这些更改。（或者，你也可以使用网络上的另一台机器，使用第 8 章中描述的 Web 界面来检查结果。）
- en: '![](../images/211-1.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 11-10：Laddie 帧缓冲 UI](../images/211-1.jpg)'
- en: '*Figure 11-10: The Laddie framebuffer UI*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-10：Laddie 帧缓冲 UI*'
- en: '**The STBmenu Framework**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**STBmenu 框架**'
- en: 'Having experimented a bit with the Laddie framebuffer UI, you will have noticed
    some differences between it and a fully featured GUI. The Laddie framebuffer UI
    does not have windows that can be moved around the screen; it consists, instead,
    of a series of full-screen pages. There is no free-floating cursor that can select
    any point on the screen; instead, it is the two-dimensional geometry of the input
    widgets that determines how the arrow keys shift focus. And finally, the input
    options for widgets are minimal: There is only one, and it corresponds with pressing
    ENTER.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 Laddie 帧缓冲 UI 进行了一些实验后，你可能会注意到它与功能齐全的 GUI 之间的差异。Laddie 帧缓冲 UI 没有可以移动到屏幕上的窗口；它由一系列全屏页面组成。没有可以选中屏幕上任何点的自由浮动光标；相反，输入小部件的二维几何形状决定了箭头键如何切换焦点。最后，小部件的输入选项非常有限：只有一个，对应于按下
    ENTER 键。
- en: '**NOTE**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When experimenting with DVD interfaces, we’ve been surprised that pressing
    arrow keys to get to the icon you want can be like solving a puzzle. One attribute
    of the STBmenu framework is that each of the arrow keys is guaranteed to traverse
    all input widgets. It may seem like a trivial point, but when you’re trying to
    disable a home alarm that is unnecessarily waking up the neighbors, you don’t
    want to be tripped up by a challenging UI.*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*在实验 DVD 界面时，我们惊讶地发现，通过按箭头键到达你想要的图标就像解决一个谜题。STBmenu 框架的一个特性是，每个箭头键都保证可以遍历所有输入小部件。这看起来可能是一个微不足道的问题，但当你试图关闭一个不必要地吵醒邻居的家庭警报时，你不想被一个具有挑战性的
    UI 所困扰。*'
- en: '**The STBmenu Widgets**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**STBmenu 小部件**'
- en: The Status page, shown on the left of Figure 11-10, contains 25 visible widgets.
    Eight of these are static displays (the title, the column headings, and the zone
    numbers); five present variable text (the zone descriptions); five display the
    state of the alarm; and the remaining seven are buttons. (The background screen
    is not a widget.) Figure 11-11 illustrates the relationships between an STBmenu
    widget, a user, and the underlying application.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 状态页面，如图 11-10 左侧所示，包含 25 个可见的小部件。其中 8 个是静态显示（标题、列标题和区域编号）；5 个显示可变文本（区域描述）；5
    个显示警报状态；剩下的 7 个是按钮。（背景屏幕不是一个小部件。）图 11-11 展示了 STBmenu 小部件、用户和底层应用程序之间的关系。
- en: '![](../images/212-1.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 11-11：STBmenu 小部件](../images/212-1.jpg)'
- en: '*Figure 11-11: An STBmenu widget*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-11：STBmenu 小部件*'
- en: 'Comparing the STBmenu widget to the full-featured widget of Figure 11-9, we
    notice several simplifications. The STBmenu widget responds to only two kinds
    of events: Activate, and Update. The *Activate* event invokes the widget’s single
    callback, and the *Update* event tells the widget to redraw itself, since the
    data it represents may have changed. With full-featured widgets, the application
    can call functions to configure the widget (e.g., change its size or position)
    and retrieve its input data (e.g., its entered text or its scrollbar position).
    However, STBmenu widgets are fully configured when they are constructed, and data
    is only passed to the application when the Activate callback is invoked. With
    full-featured widgets, the application can call functions to change the widget’s
    output data (e.g., status text or meter position), but STBmenu widgets use static
    pointers into application data structures to retrieve the data they display. Finally,
    the type of data displayed by STBmenu widgets is limited to integers and strings.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将STBmenu小部件与图11-9所示的完整功能小部件进行比较，我们注意到几个简化之处。STBmenu小部件只响应两种事件：Activate和Update。*Activate*事件调用小部件的单个回调函数，而*Update*事件告诉小部件重新绘制自己，因为它所表示的数据可能已更改。对于完整功能小部件，应用程序可以调用函数来配置小部件（例如，更改其大小或位置）并检索其输入数据（例如，输入的文本或滚动条位置）。然而，STBmenu小部件在构建时就已经完全配置好了，并且只有在调用Activate回调函数时才会将数据传递给应用程序。对于完整功能小部件，应用程序可以调用函数来更改小部件的输出数据（例如，状态文本或仪表位置），但STBmenu小部件使用指向应用程序数据结构的静态指针来检索它们显示的数据。最后，STBmenu小部件显示的数据类型限于整数和字符串。
- en: Because there are no functions for configuring STBmenu widgets or setting their
    displayed data, the developers of the underlying application don’t have to be
    familiar with the toolkit. All they are required to do is expose the displayed
    application data and provide appropriate callbacks for user input.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有用于配置STBmenu小部件或设置其显示数据的函数，所以底层应用程序的开发者不需要熟悉工具包。他们只需暴露显示的应用程序数据并提供适当的回调函数以处理用户输入。
- en: We summarize the STBmenu API below. Class constructors are in bold, and methods
    are in italics.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下面总结了STBmenu API。类构造函数用粗体表示，方法用斜体表示。
- en: '**Menu(nPages, width, height, bpp);**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**Menu(nPages, width, height, bpp);**'
- en: '*AttachPage(n, page);'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*AttachPage(n, page)*;'
- en: SetCursor(page,row,col);
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: SetCursor(page,row,col);
- en: DisplayCurrentPage();
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: DisplayCurrentPage();
- en: CursorLeft();
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: CursorLeft();
- en: CursorRight();
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: CursorRight();
- en: CursorUp();
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: CursorUp();
- en: CursorDown();
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: CursorDown();
- en: Activate();
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Activate();
- en: Update();*
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Update();*
- en: '**Page(nRows, nCols, background);**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**Page(nRows, nCols, background);**'
- en: '*AttachWidget(row, col, xPos, yPos, widget);*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*AttachWidget(row, col, xPos, yPos, widget)*;'
- en: '**Font(fontPath, fontSize);'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**Font(fontPath, fontSize);'
- en: Surface(width, height, color);
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Surface(width, height, color);
- en: Surface(font, color, text);
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Surface(font, color, text);
- en: Surface(imagePath);
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Surface(imagePath);
- en: SurfaceArray(n, &surface,...);
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: SurfaceArray(n, &surface,...);
- en: Button(nfSurface, fSurface);
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Button(nfSurface, fSurface);
- en: ButtonArray(n, &button,...);**
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ButtonArray(n, &button,...);**
- en: 'Here are the STBmenu Widgets:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是STBmenu小部件：
- en: '**WIcon(font, color, text) and WIcon(imagePath)**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**WIcon(font, color, text)和WIcon(imagePath)**'
- en: Display a static image created from a constant text string or an image file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 显示由常量文本字符串或图像文件创建的静态图像。
- en: '**WText(font, color, text)**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**WText(font, color, text)**'
- en: Displays a variable text string.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个可变文本字符串。
- en: '**WIconArray(surfaceArray, trackedIndex)**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**WIconArray(surfaceArray, trackedIndex)**'
- en: Displays one of an array of static images, depending on an application index
    variable.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个数组中的静态图像，取决于应用程序索引变量。
- en: '**WButton(button, callback, data)**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**WButton(button, callback, data)**'
- en: Displays a button consisting of one static image when highlighted, and another
    when not highlighted. When activated, invokes an application callback with specified
    data.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个由一个静态图像组成的按钮，当高亮显示时，以及当未高亮显示时。当激活时，调用带有指定数据的应用程序回调函数。
- en: '**WButtonArray(buttonArray, trackedIndex, callback, data)**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**WButtonArray(buttonArray, trackedIndex, callback, data)**'
- en: Displays one of an array of buttons, depending on an application index variable.
    When activated, invokes an application callback with specified data.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个数组中的按钮，取决于应用程序索引变量。当激活时，调用带有指定数据的应用程序回调函数。
- en: '[***“Hello, world!” with STBmenu***](toc.html#chapter11.17)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[***“使用STBmenu的‘Hello, world!’”](toc.html#chapter11.17)'
- en: In the remainder of this section, we will demonstrate the STBmenu toolkit by
    working through a simple example. This example is on the Laddie CD in the directory
    /Code/src/examples/stb_hello. At this point, we recommend you return to the Laddie
    CD and exit the Laddie framebuffer UI, if it’s still running (remember to switch
    between consoles with ctrl-alt-F1 or ctrl-alt-F7, and use the arrow keys and enter
    to navigate the framebuffer menu). Then change to the stb_hello directory, make
    and run the example using the following commands.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: laddie:~# cd /Code/src/examples/stb_hello
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: laddie:~# make
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: laddie:~# ./stb_hello
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: You should see the display illustrated in Figure 11-12.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/214-1.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-12: “Hello, world!” with STBmenu*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: This example implements two button widgets. You can select the buttons by pressing
    the arrow keys on your keyboard, and you can activate them with the ENTER key.
    When you activate the Hello button, it prints *Hello, world!* to the standard
    output, which you can verify after closing the UI by activating the Exit button.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: In the remainder of this section, we will work through the implementation of
    the stb_hello example.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Building a UI with STBmenu involves three steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Define any data structures and callbacks required for monitoring and controlling
    the application.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the UI with widgets that point to these data structures and callbacks.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle events using the STBmenu framework’s methods.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll demonstrate these steps for the two-button example.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '**Define Data Structures and Callbacks**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: In this simple example, there is no data to monitor. Control consists of printing
    a message or exiting the program, and it requires a single piece of data and two
    callbacks.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/215-1.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: The ![](../images/1.jpg) Hello() callback (invoked by the Hello button) will
    print a message to the console. The ![](../images/2.jpg) QuitApplication() callback
    (invoked by the Exit button) will set ![](../images/3.jpg) the enableQuit variable
    to 1\. All widget callbacks take a pointer to the widget that invoked them as
    an argument. All such widgets will have the STBmenu type InputClass and may provide
    additional data useful to the callback; however, we don’t use that capability
    here.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '**Build the UI**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The first step in building a UI is to declare a menu object.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '#include "STBmenu.h"'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Menu* menu = new Menu(1, 640, 480, 8);
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: This has to be done before any other UI objects are declared, since it initializes
    the underlying SDL video context. We specify the number of pages (1), the width
    (640) and height (480)of the UI’s screen (in pixels), and the number of bits per
    pixel (8).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare and attach the single page for the menu object.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '#define BLACK 0x000000'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Surface background(640,480,BLACK);
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Page page(2, 1, background);
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: menu->AttachPage(0, page);
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: For a real UI, we would want a more interesting background, but for a quick
    example, we specify a black, 640-by-480-pixel surface. Then we declare the page,
    providing the number of rows (2), number of columns (1), and background. We attach
    the page to the menu object using AttachPage(), specifying a page number.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个真实的用户界面，我们可能希望有一个更有趣的背景，但为了快速示例，我们指定了一个黑色、640×480像素的表面。然后我们声明页面，提供行数（2）、列数（1）和背景。我们使用AttachPage()将页面附加到菜单对象，指定页面编号。
- en: We can now specify the button widgets. Here is the code for the Test button.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以指定按钮小部件。以下是测试按钮的代码。
- en: '![](../images/216-1.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/216-1.jpg)'
- en: We declare a TrueType font by ![](../images/1.jpg) specifying a pathname and
    a font size. We use that font to construct two surfaces, ![](../images/2.jpg)
    one with cyan text for the button when it isn’t selected (i.e., doesn’t have focus),
    and ![](../images/3.jpg) one with yellow text and a *<* symbol for the button
    when it is selected. We ![](../images/4.jpg) construct a button from the two surfaces,
    specifying the surface without focus first. Finally, we ![](../images/5.jpg) construct
    a button widget, specifying the button, the callback, and any data that callback
    might require (NULL, in this case).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过![](../images/1.jpg)指定路径名和字体大小来声明一个TrueType字体。我们使用该字体构建两个表面，![](../images/2.jpg)一个用于按钮未选中时（即，没有焦点）的青色文本，![](../images/3.jpg)另一个用于按钮选中时的黄色文本和*<*符号。我们![](../images/4.jpg)从两个表面构建一个按钮，指定无焦点的表面。最后，我们![](../images/5.jpg)构建一个按钮小部件，指定按钮、回调函数以及回调函数可能需要的数据（在这种情况下为NULL）。
- en: After constructing the button widget, we attach it to the page.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 构建按钮小部件后，我们将其附加到页面上。
- en: page.AttachWidget(0, 0, 250, 200, wHello);
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: page.AttachWidget(0, 0, 250, 200, wHello);
- en: Recall that we declared this page to have two rows and one column. When attaching
    the widgets, we specify their row (0) and column (0) within the page, as well
    as their absolute *x* (250) and *y* (200) pixel positions. The row and column
    will determine how the Up, Down, Left, and Right cursor inputs will select the
    various button widgets.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们声明了这个页面有两条行和一列。在附加小部件时，我们在页面内指定它们的行（0）和列（0），以及它们的绝对*x*（250）和*y*（200）像素位置。行和列将确定上、下、左、右光标输入如何选择各种按钮小部件。
- en: The Exit button is constructed and attached analogously to the Hello widget.
    You can see the example code on the CD in /Code/src/examples/ stb_hello.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 退出按钮是类似于“Hello”小部件构建并附加的。您可以在光盘中的/Code/src/examples/stb_hello目录下的示例代码中看到。
- en: With the menu, pages, and widgets constructed, we can now display the menu.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了菜单、页面和小部件之后，我们现在可以显示菜单。
- en: '![](../images/216-2.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/216-2.jpg)'
- en: Here, the ![](../images/1.jpg) SetCursor() method specifies a page, row, and
    column for the initially highlighted widget. In the current case, this is the
    Hello button. The ![](../images/2.jpg) DisplayCurrentPage() method produces the
    screen shown in Figure 11-12.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![](../images/1.jpg) SetCursor() 方法指定了一个页面、行和列，用于最初高亮显示的小部件。在当前情况下，这是“Hello”按钮。![](../images/2.jpg)
    DisplayCurrentPage() 方法生成了图11-12所示的屏幕。
- en: '**Handle Events**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理事件**'
- en: The rest of our program includes a simple event loop.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的其他部分包括一个简单的事件循环。
- en: '![](../images/216-3.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/216-3.jpg)'
- en: '![](../images/217-1.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/217-1.jpg)'
- en: When arrow key events are received, the menu’s four navigation methods (![](../images/1.jpg)
    CursorLeft(), CursorRight(), etc.) are used to update the highlighted button.
    The ENTER key invokes ![](../images/2.jpg) the Activate() method, which invokes
    the callback for the currently highlighted button. We’ll learn in the next chapter
    how to use an infrared remote control in place of the keyboard, but this segment
    of code won’t have to change, since we will use the IR interface to produce SDL
    keyboard events.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到箭头键事件时，菜单的四个导航方法(![](../images/1.jpg) CursorLeft(), CursorRight(), 等)用于更新高亮按钮。按回车键调用![](../images/2.jpg)
    Activate() 方法，该方法调用当前高亮按钮的回调函数。我们将在下一章学习如何使用红外遥控器代替键盘，但这段代码将不会改变，因为我们将使用红外接口生成SDL键盘事件。
- en: Each time an event occurs, we use ![](../images/3.jpg) the Update() method to
    redraw any widgets that have changed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每当发生事件时，我们使用![](../images/3.jpg) Update() 方法重新绘制任何已更改的小部件。
- en: '[**The Laddie Framebuffer UI**](toc.html#chapter11.18)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[**Laddie帧缓冲UI**](toc.html#chapter11.18)'
- en: 'As we saw in the previous section, an application that uses STBmenu has two
    obligations: provide pointers to data to be displayed, and provide callbacks for
    UI inputs. Figure 11-13 illustrates how the Laddie framebuffer UI meets these
    two obligations.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中看到的，使用STBmenu的应用程序有两个义务：提供要显示的数据的指针，并提供UI输入的回调。图11-13说明了Laddie帧缓冲区UI如何满足这两个义务。
- en: On the user side, keyboard or remote control events select a widget and then
    invoke that widget’s Activate method. This action invokes a callback in the application
    interface, which controls the alarm daemon via the RTA/ PostgreSQL protocol. On
    the application side, logmuxd relays events indicating that the Laddie alarm daemon’s
    status has changed. Responding to these events, the UpdateZoneData code uses the
    RTA/PostgreSQL protocol to update a local copy of the alarm daemon’s Zone data
    and invoke the menu’s Update method. This action prompts the menu’s widgets to
    redraw themselves, based on the new Zone data.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户端，键盘或遥控事件选择一个小部件，然后调用该小部件的激活方法。这个动作会在应用程序接口中调用一个回调，通过RTA/ PostgreSQL协议控制警报守护进程。在应用程序端，logmuxd转发了指示Laddie警报守护进程状态已更改的事件。响应这些事件，UpdateZoneData代码使用RTA/PostgreSQL协议更新警报守护进程区域数据的本地副本，并调用菜单的更新方法。这个动作会根据新的区域数据提示菜单的小部件重新绘制自己。
- en: '![](../images/218-1.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/218-1.jpg)'
- en: '*Figure 11-13: Using STBmenu for the Laddie framebuffer UI*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-13：使用STBmenu构建Laddie帧缓冲区UI*'
- en: '**NOTE**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re reading this book’s chapters out of order, please refer to Chapter
    3 for a description of the RTA/PostrgeSQL protocol, Chapter 5 to learn about the
    alarm daemon ladd, and Chapter 6 for an introduction to logmuxd.*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您是按照顺序之外的章节阅读本书，请参考第3章了解RTA/PostgreSQL协议的描述，第5章学习关于alarm daemon ladd的内容，以及第6章了解logmuxd的介绍。*'
- en: In the “Hello, world!” example, we saw how to build widgets with callbacks.
    Now, using the Laddie framebuffer UI as an example, we’ll demonstrate how to build
    widgets that display application data.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Hello, world!”示例中，我们看到了如何构建带有回调的控件。现在，以Laddie帧缓冲区UI为例，我们将演示如何构建显示应用程序数据的控件。
- en: We start by providing data structures that capture the state of the Laddie alarm
    daemon.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先提供数据结构来捕捉Laddie警报守护进程的状态。
- en: '![](../images/218-2.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/218-2.jpg)'
- en: The fields in ![](../images/1.jpg) the LaddZone data structure correspond directly
    to the fields that are displayed on the two menu pages. The ![](../images/2.jpg)
    laddAlarm variable is nonzero when at least one zone is in alarm, and it is used
    to enable the Clear All button.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: LaddZone数据结构中的字段直接对应于在两个菜单页面上显示的字段。当至少有一个区域处于警报状态时，![](../images/1.jpg) laddAlarm变量不为零，并用于启用清除所有按钮。
- en: Recall from Chapter 6 that the event handler logmuxd can be configured to route
    events through pipes. We configure logmuxd (using the files Filters.sql and FileDest.sql
    in the directory /opt/laddie/logmuxd) to route all Laddie Alarm events to the
    pipe /opt/laddie/fbmenu/laddevents. The framebuffer UI’s main thread uses a select()
    system call to wait on messages received via this pipe, then uses the alarm daemon’s
    RTA interface to update the array of LaddZone structures.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 回想第6章，事件处理器logmuxd可以被配置为通过管道路由事件。我们配置logmuxd（使用目录/opt/laddie/logmuxd中的文件Filters.sql和FileDest.sql）将所有Laddie警报事件路由到管道/opt/laddie/fbmenu/laddevents。帧缓冲区UI的主线程使用select()系统调用来等待通过此管道接收到的消息，然后使用警报守护进程的RTA接口更新LaddZone结构体的数组。
- en: For our UI, we will provide several columns of widgets to display the laddZones
    alarm data. Let’s just consider the State column from the Status page. As we saw
    in Figure 11-10, these widgets display an *Inactive*, *Safe*, or *Alarm* indication,
    depending on the state of each zone. We use a WIconArray widget, as demonstrated
    in the following code, to display the alarm states.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的UI，我们将提供几个列的控件来显示laddZones警报数据。让我们只考虑状态页面中的状态列。正如我们在图11-10中看到的，这些控件根据每个区域的状态显示*不活动*、*安全*或*警报*指示。我们使用WIconArray控件，如下面的代码所示，来显示警报状态。
- en: '![](../images/219-1.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/219-1.jpg)'
- en: Here we ![](../images/1.jpg) declare three surfaces, corresponding to the three
    alarm states, with appropriate colors. We form ![](../images/2.jpg) a SurfaceArray
    from these surfaces and use it to build the alarm state widgets. In declaring
    ![](../images/3.jpg) a WIconArray widget, we provide a pointer to an integer value
    in the application interface’s local data structures. Note that the order of the
    alarmState surfaces corresponds to the possible values for laddZones[W].state.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们 ![](../images/1.jpg) 声明三个表面，对应于三种报警状态，并使用适当的颜色。我们 ![](../images/2.jpg)
    从这些表面形成 SurfaceArray，并使用它来构建报警状态控件。在 ![](../images/3.jpg) 声明 WIconArray 控件时，我们提供一个指向应用程序接口本地数据结构中整数值的指针。请注意，alarmState
    表面的顺序对应于 laddZones[W].state 的可能值。
- en: To complete this UI, we have to define additional widgets to display the remaining
    data in the laddZones array and, where appropriate, to update the Laddie alarm
    daemon with callbacks. As in the “Hello, world!” example, we also have to attach
    the widgets to pages and the pages to the main menu. One item we haven’t discussed
    yet is how to switch between pages. Fortunately, this is straightforward. The
    STBmenu framework provides a SetCursor function for selecting a page and cursor
    position. Therefore, we switch pages by providing button widgets on each page
    with callbacks to set the cursor to the opposite page.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个 UI，我们必须定义额外的控件来显示 laddZones 数组中剩余的数据，并在适当的时候通过回调更新 Laddie 报警守护进程。与“Hello,
    world!”示例一样，我们还需要将控件附加到页面上，并将页面附加到主菜单。我们尚未讨论的一个问题是如何在页面之间切换。幸运的是，这很简单。STBmenu
    框架提供了一个 SetCursor 函数来选择页面和光标位置。因此，我们通过在每个页面上提供带有回调的按钮控件来切换页面，以将光标设置到对面的页面。
- en: The event handler for the Laddie framebuffer UI is a little different than that
    of the stb_hello example. Instead of waiting on SDL events, it uses a select system
    call to wait on Laddie alarm daemon events from logmuxd. It uses a time-out of
    100 milliseconds, and when it completes or times out, it uses the function SDL_PollEvent
    to check for keypresses. As in the stb_hello example, we only need five inputs,
    so we monitor and respond to the arrow keys and ENTER key. In the next chapter
    we’ll see how to control this UI using a handheld remote.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Laddie 缓冲区帧 UI 的事件处理程序与 stb_hello 示例略有不同。它不是等待 SDL 事件，而是使用 select 系统调用来等待来自
    logmuxd 的 Laddie 报警守护进程事件。它使用 100 毫秒的超时时间，当完成或超时时，它使用 SDL_PollEvent 函数来检查按键。与
    stb_hello 示例一样，我们只需要五个输入，所以我们监控并响应箭头键和 ENTER 键。在下一章中，我们将看到如何使用手持遥控器控制此 UI。
- en: For the details we’ve omitted, please see the code on the Laddie CD in the directory
    /Code/src/fbmenu. The code for STBmenu is included in /Code/src/stbmenu.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们省略的细节，请参阅 Laddie CD 上的代码，位于目录 /Code/src/fbmenu。STBmenu 的代码包含在 /Code/src/stbmenu。
- en: '[**Summary**](toc.html#chapter11.19)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[**总结**](toc.html#chapter11.19)'
- en: As illustrated in Figure 11-14, building an appliance’s GUI requires the use
    of several layers.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 11-14 所示，构建一个设备的 GUI 需要使用几个层级。
- en: '![](../images/220-1.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/220-1.jpg)'
- en: '*Figure 11-14: The Laddie framebuffer UI and graphics stack*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-14：Laddie 缓冲区帧 UI 和图形堆栈*'
- en: The Linux framebuffer device driver provides an abstraction of video hardware
    that facilitates configuring the video mode and manipulating pixel memory. Various
    graphics libraries are available that use this device driver, and these libraries
    provide support for manipulating graphical objects and text. These libraries typically
    provide support for event handling, as well. We chose to use the Simple DirectMedia
    Layer for the Laddie appliance because it is well supported, well documented,
    and lightweight. GUI toolkits supply the next layer; they provide and manage widgets,
    objects for which the input events and the graphical display are tightly coupled.
    For the Laddie appliance, we developed a thin GUI toolkit, STBmenu, which is intended
    for use with simple, handheld remotes, and which facilitates adding a GUI layer
    to an existing application with little additional effort. In support of this last
    point, we also showed how we connected the Laddie framebuffer UI to the Laddie
    alarm daemon using the RTA/PostgreSQL protocol and the logmuxd event handler.
    In the next chapter, we will complete the Laddie framebuffer UI by adding support
    for remote control.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Linux帧缓冲设备驱动程序提供了一个视频硬件的抽象层，这有助于配置视频模式和操作像素内存。有各种图形库可以使用这个设备驱动程序，这些库提供了操作图形对象和文本的支持。这些库通常还提供事件处理的支持。我们选择使用Simple
    DirectMedia Layer（SDL）为Laddie设备，因为它得到了良好的支持，文档齐全，且轻量级。GUI工具包提供了下一层；它们提供并管理小部件，这些小部件的输入事件和图形显示紧密耦合。对于Laddie设备，我们开发了一个轻量级的GUI工具包，STBmenu，它旨在与简单的手持遥控器一起使用，并且可以简化向现有应用程序添加GUI层的工作。为了支持这一点，我们还展示了如何使用RTA/PostgreSQL协议和logmuxd事件处理器将Laddie帧缓冲UI连接到Laddie警报守护进程。在下一章中，我们将通过添加远程控制支持来完成Laddie帧缓冲UI。
- en: __________________
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: __________________
- en: ¹ For example, *Beginning Linux Programming*, 3rd ed., by Richard Stones, Neil
    Matthew, and Alan Cox (Wrox, 2004) includes one chapter each on GTK+ and Qt.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 例如，Richard Stones、Neil Matthew和Alan Cox合著的《Linux编程入门》（第3版，Wrox，2004年）各包含一章关于GTK+和Qt的内容。
