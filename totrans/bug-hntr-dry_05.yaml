- en: Chapter 5. Browse and You’re Owned
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。浏览即被控制
- en: Note
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Sunday, April 6, 2008*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*2008年4月6日，星期日*'
- en: '*Dear Diary*,'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*亲爱的日记*，'
- en: Vulnerabilities in browsers and browser add-ons are all the rage these days,
    so I decided to have a look at some ActiveX controls. The first one on my list
    was Cisco’s online meeting and web-conferencing software called WebEx, which is
    widely used in business. After spending some time reverse engineering the WebEx
    ActiveX control for Microsoft’s Internet Explorer, I found an obvious bug that
    I could have found in a few seconds if I had fuzzed the control instead of reading
    the assembly. Fail. ![](httpatomoreillycomsourcenostarchimages939227.png)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器和浏览器插件中的漏洞目前非常流行，所以我决定查看一些 ActiveX 控件。我列表上的第一个是思科的在线会议和网页会议软件，名为 WebEx，它在商业中广泛使用。在花了一些时间对
    Microsoft 的 Internet Explorer 中的 WebEx ActiveX 控件进行逆向工程之后，我发现了一个明显的错误，如果我用模糊测试而不是阅读汇编代码，我可以在几秒钟内找到这个错误。失败！![httpatomoreillycomsourcenostarchimages939227.png](httpatomoreillycomsourcenostarchimages939227.png)
- en: 5.1 Vulnerability Discovery
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 漏洞发现
- en: 'I used the following process to search for a vulnerability:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用以下过程来搜索漏洞：
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*I used Windows XP SP3 32-bit and Internet Explorer 6 as the platform for all
    the following steps*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*我使用 Windows XP SP3 32 位和 Internet Explorer 6 作为以下所有步骤的平台*。'
- en: 'Step 1: List the registered WebEx objects and exported methods.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1步：列出已注册的 WebEx 对象和导出方法。
- en: 'Step 2: Test the exported methods in the browser.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2步：在浏览器中测试导出方法。
- en: 'Step 3: Find the object methods in the binary.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3步：在二进制文件中查找对象方法。
- en: 'Step 4: Find the user-controlled input values.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4步：查找用户可控的输入值。
- en: 'Step 5: Reverse engineer the object methods.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第5步：逆向工程对象方法。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A download link for the vulnerable version of WebEx Meeting Manager can be found
    at [http://www.trapkit.de/books/bhd/](http://www.trapkit.de/books/bhd/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可疑版本的 WebEx 会议管理器的下载链接可以在 [http://www.trapkit.de/books/bhd/](http://www.trapkit.de/books/bhd/)
    找到。
- en: 'Step 1: List the Registered WebEx Objects and Exported Methods'
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1步：列出已注册的 WebEx 对象和导出方法。
- en: After downloading and installing the WebEx Meeting Manager software, I fired
    up COMRaider^([[45](ch05s05.html#ftn.CHP-5-FN-1)]) to generate a list of the exported
    interfaces the control provides to the caller. I clicked the **Start** button
    in COMRaider and selected **Scan a directory for registered COM servers** to test
    the WebEx components installed in *C:\Program Files\Webex\*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在下载并安装了 WebEx 会议管理器软件之后，我启动了 COMRaider^([[45](ch05s05.html#ftn.CHP-5-FN-1)))
    以生成控制提供给调用者的导出接口列表。我在 COMRaider 中点击了 **开始** 按钮，并选择 **扫描目录以查找已注册的 COM 服务器** 来测试安装在
    *C:\Program Files\Webex\* 中的 WebEx 组件。
- en: As [Figure 5-1](ch05.html#registered_webex_objects_in_comraider "Figure 5-1. Registered
    WebEx objects in COMRaider") illustrates, two objects are registered in the WebEx
    install directory, and the object with GUID `{32E26FD9-F435-4A20-A561-35D4B987CFDC}`
    and ProgID `WebexUCFObject.WebexUCFObject.1` implements `IObjectSafety`. Internet
    Explorer will trust this object since it’s marked as *safe for initialization*
    and *safe for scripting*. That makes the object a promising target for “browse
    and you’re owned” attacks, since it’s possible to call its methods from within
    a web page.^([[46](ch05s05.html#ftn.CHP-5-FN-2)])
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图5-1](ch05.html#registered_webex_objects_in_comraider "图5-1. COMRaider 中注册的
    WebEx 对象") 所示，WebEx 安装目录中注册了两个对象，具有 GUID `{32E26FD9-F435-4A20-A561-35D4B987CFDC}`
    和 ProgID `WebexUCFObject.WebexUCFObject.1` 的对象实现了 `IObjectSafety`。由于它被标记为 *安全初始化*
    和 *安全脚本*，Internet Explorer 将信任此对象。这使得该对象成为“浏览即被控制”攻击的潜在目标，因为可以从网页内部调用其方法.^([[46](ch05s05.html#ftn.CHP-5-FN-2)])
- en: '![Registered WebEx objects in COMRaider](httpatomoreillycomsourcenostarchimages939281.png.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![COMRaider 中注册的 WebEx 对象](httpatomoreillycomsourcenostarchimages939281.png.jpg)'
- en: Figure 5-1. Registered WebEx objects in COMRaider
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-1. COMRaider 中注册的 WebEx 对象
- en: 'Microsoft also provides a handy C# class called `ClassId.cs`^([[47](ch05s05.html#ftn.CHP-5-FN-3)])
    that lists various properties of ActiveX controls. To use that class, I added
    the following lines to the source file and compiled it with the command-line version
    of Visual Studio’s C# compiler (`csc`):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 微软还提供了一个名为 `ClassId.cs` 的方便的 C# 类，该类列出了 ActiveX 控件的各个属性。要使用该类，我在源文件中添加了以下行，并使用
    Visual Studio 的 C# 编译器的命令行版本 (`csc`) 编译它：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To compile and use the tool, I ran the following commands in a command-prompt
    window:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和使用该工具，我在命令提示符窗口中运行了以下命令：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The output of the tool shows that the object was indeed marked as *safe for
    initialization* and *safe for scripting* using `IObjectSafety`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 工具的输出显示，该对象确实使用 `IObjectSafety` 被标记为 *安全初始化* 和 *安全脚本*。
- en: I then clicked the **Select** button in COMRaider to see a list of the public
    methods exported by the object with GUID `{32E26FD9-F435-4A20-A561-35D4B987CFDC}`.
    As illustrated in [Figure 5-2](ch05.html#public_methods_exported_by_the_object_wi
    "Figure 5-2. Public methods exported by the object with GUID {32E26FD9-F435-4A20-A561-35D4B987CFDC}."),
    a method called `NewObject()` is exported by the object and takes a string value
    as input.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我随后在 COMRaider 中点击了 **选择** 按钮，以查看由具有 GUID `{32E26FD9-F435-4A20-A561-35D4B987CFDC}`
    的对象导出的公共方法列表。如图 [图 5-2](ch05.html#public_methods_exported_by_the_object_wi "图
    5-2. 由具有 GUID {32E26FD9-F435-4A20-A561-35D4B987CFDC} 的对象导出的公共方法。") 所示，该对象导出了一个名为
    `NewObject()` 的方法，并接受一个字符串值作为输入。
- en: '![Public methods exported by the object with GUID {32E26FD9-F435-4A20-A561-35D4B987CFDC}.](httpatomoreillycomsourcenostarchimages939283.png.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![由具有 GUID {32E26FD9-F435-4A20-A561-35D4B987CFDC} 的对象导出的公共方法](httpatomoreillycomsourcenostarchimages939283.png.jpg)'
- en: Figure 5-2. Public methods exported by the object with GUID `{32E26FD9-F435-4A20-A561-35D4B987CFDC}`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2. 由具有 GUID `{32E26FD9-F435-4A20-A561-35D4B987CFDC}` 的对象导出的公共方法。
- en: 'Step 2: Test the Exported Methods in the Browser'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 步：在浏览器中测试导出的方法
- en: 'After I generated lists of the available objects and exported methods, I wrote
    a little HTML file that calls the `NewObject()` method with the help of VBScript:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我生成了可用对象和导出方法的列表之后，我编写了一个小的 HTML 文件，该文件使用 VBScript 调用 `NewObject()` 方法：
- en: Example 5-1. HTML file to call the `NewObject()` method (*webex_poc1.html*)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-1. 调用 NewObject() 方法的 HTML 文件 (*webex_poc1.html*)
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In line 4 of [Example 5-1](ch05.html#html_file_to_call_the "Example 5-1. HTML
    file to call the NewObject() method (webex_poc1.html)"), the object with GUID
    or ClassID `{32E26FD9-F435-4A20-A561-35D4B987CFDC}` is instantiated. In line 7
    the `NewObject()` method is called with a string value of 12 As as a parameter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 5-1](ch05.html#html_file_to_call_the "示例 5-1. 调用 NewObject() 方法的 HTML
    文件 (webex_poc1.html)") 的第 4 行中，实例化了具有 GUID 或 ClassID `{32E26FD9-F435-4A20-A561-35D4B987CFDC}`
    的对象。在第 7 行，使用字符串值 12 作为参数调用了 `NewObject()` 方法。
- en: 'To test the HTML file, I implemented a little web server in Python that would
    serve the *webex_poc1.html* file to the browser (see [Example 5-2](ch05.html#simple_web_server_implemented
    "Example 5-2. Simple web server implemented in Python that serves the webex_poc1.html
    file to the browser (wwwserv.py)")):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 HTML 文件，我在 Python 中实现了一个小型网络服务器，该服务器会将 *webex_poc1.html* 文件提供给浏览器（见图 [示例
    5-2](ch05.html#simple_web_server_implemented "示例 5-2. 在 Python 中实现的简单网络服务器，该服务器将
    webex_poc1.html 文件提供给浏览器 (wwwserv.py)"))：
- en: Example 5-2. Simple web server implemented in Python that serves the *webex_poc1.html*
    file to the browser (*wwwserv.py*)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-2. 在 Python 中实现的简单网络服务器，该服务器将 *webex_poc1.html* 文件提供给浏览器 (*wwwserv.py*)
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While the ActiveX control of WebEx is marked as safe for scripting (see [Figure 5-1](ch05.html#registered_webex_objects_in_comraider
    "Figure 5-1. Registered WebEx objects in COMRaider")), it has been designed so
    that it can be run only from the [webex.com](http://webex.com) domain. In practice,
    this requirement can be bypassed with the help of a *Cross-Site Scripting (XSS)*^([[48](ch05s05.html#ftn.CHP-5-FN-4)])
    vulnerability in the WebEx domain. Since XSS vulnerabilities are quite common
    in modern web applications, it shouldn’t be hard to identify such a vulnerability
    in the [webex.com](http://webex.com) domain. To test the control without the need
    of an XSS vulnerability, I just added the following entry to my Windows `hosts`
    file (see *C:\WINDOWS\system32\drivers\etc\hosts\*):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 WebEx 的 ActiveX 控件被标记为脚本安全（见图 [图 5-1](ch05.html#registered_webex_objects_in_comraider
    "图 5-1. COMRaider 中注册的 WebEx 对象")），但它被设计成只能从 [webex.com](http://webex.com) 域运行。实际上，可以通过
    WebEx 域中的 *跨站脚本 (XSS)*^([[48](ch05s05.html#ftn.CHP-5-FN-4)]) 漏洞来绕过这一要求。由于 XSS
    漏洞在现代网络应用程序中相当普遍，因此在 [webex.com](http://webex.com) 域中识别此类漏洞不应很难。为了在不需要 XSS 漏洞的情况下测试控件，我只需在我的
    Windows `hosts` 文件中添加以下条目（见图 *C:\WINDOWS\system32\drivers\etc\hosts\*）：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After that, I started my little Python web server and pointed Internet Explorer
    to [http://www.webex.com/](http://www.webex.com/) (see [Figure 5-3](ch05.html#testing_webex_underscore_poc1.html_with
    "Figure 5-3. Testing webex_poc1.html with my little Python web server")).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我开始运行我的小型 Python 网络服务器，并将 Internet Explorer 指向 [http://www.webex.com/](http://www.webex.com/)（见图
    [图 5-3](ch05.html#testing_webex_underscore_poc1.html_with "图 5-3. 使用我的小型 Python
    网络服务器测试 webex_poc1.html")）。
- en: '![Testing webex_poc1.html with my little Python web server](httpatomoreillycomsourcenostarchimages939285.png.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![使用我的小型 Python 网络服务器测试 webex_poc1.html](httpatomoreillycomsourcenostarchimages939285.png.jpg)'
- en: Figure 5-3. Testing *webex_poc1.html* with my little Python web server
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3. 使用我的小型 Python 网络服务器测试 *webex_poc1.html*
- en: 'Step 3: Find the Object Methods in the Binary'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 步：在二进制文件中查找对象方法
- en: 'So far I had collected the following information:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我收集了以下信息：
- en: There is a WebEx object with ClassID `{32E26FD9-F435-4A20-A561-35D4B987CFDC}`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个具有 ClassID `{32E26FD9-F435-4A20-A561-35D4B987CFDC}` 的 WebEx 对象。
- en: This object implements `IObjectSafety` and is therefore a promising target,
    since its methods can be called from within the browser.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此对象实现了 `IObjectSafety` 接口，因此是一个有潜力的目标，因为其方法可以从浏览器内部调用。
- en: The object exports a method called `NewObject()` that takes a user-controlled
    string value as input.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该对象导出一个名为 `NewObject()` 的方法，该方法接受一个用户控制的字符串值作为输入。
- en: To reverse engineer the exported `NewObject()` method, I had to find it in the
    binary `atucfobj.dll`. To achieve this, I used a technique similar to the one
    Cody Pierce describes in one of his great MindshaRE articles.^([[49](ch05s05.html#ftn.CHP-5-FN-5)])
    The general idea is to extract the addresses of the invoked methods from the arguments
    of `OLEAUT32!DispCallFunc` while debugging the browser.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了逆向工程导出的 `NewObject()` 方法，我必须在二进制文件 `atucfobj.dll` 中找到它。为了实现这一点，我使用了一种类似于 Cody
    Pierce 在他的优秀 MindshaRE 文章中描述的技术.^([[49](ch05s05.html#ftn.CHP-5-FN-5)]) 通用思路是在调试浏览器时从
    `OLEAUT32!DispCallFunc` 的参数中提取被调用方法的地址。
- en: If a method of an ActiveX control gets invoked, the `DispCallFunc()`^([[50](ch05s05.html#ftn.CHP-5-FN-6)])
    function usually performs the actual call. This function is exported by `OLEAUT32.dll`.
    The address of the invoked method can be determined with the help of the first
    two parameters (called `pvInstance` and `oVft`) of `DispCallFunc()`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 ActiveX 控件的方法被调用，`DispCallFunc()`^([[50](ch05s05.html#ftn.CHP-5-FN-6)])
    函数通常会执行实际的调用。此函数由 `OLEAUT32.dll` 导出。调用方法的地址可以通过 `DispCallFunc()` 的前两个参数（称为 `pvInstance`
    和 `oVft`）来确定。
- en: 'To find the address of the `NewObject()` method, I started Internet Explorer
    from within WinDbg^([[51](ch05s05.html#ftn.CHP-5-FN-7)]) (also see Section B.2
    for a description of the debugger commands) and set the following breakpoint at
    `OLEAUT32!DispCallFunc` (see also [Figure 5-4](ch05.html#defining_a_breakpoint_at_oleaut32_exclam
    "Figure 5-4. Defining a breakpoint at OLEAUT32!DispCallFunc in Internet Explorer")):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到 `NewObject()` 方法的地址，我从 WinDbg 内启动了 Internet Explorer^([[51](ch05s05.html#ftn.CHP-5-FN-7)))（也可以参考
    B.2 节中关于调试器命令的描述）并在 `OLEAUT32!DispCallFunc` 上设置了以下断点（参见[图 5-4](ch05.html#defining_a_breakpoint_at_oleaut32_exclam
    "图 5-4. 在 Internet Explorer 中定义 OLEAUT32!DispCallFunc 的断点"))）：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The debugger command `bp OLEAUT32!DispCallFunc` defines a breakpoint at the
    beginning of `DispCallFunc()`. If the breakpoint is triggered, the first two parameters
    of the function are evaluated. The first function parameter is referenced using
    the command `poi(poi(esp+4))`, and the second parameter is referenced by `poi(esp+8)`.
    These values are added together, and their sum represents the address of the invoked
    method. Subsequently, the first line (`L1`) of the method’s disassembly is printed
    to the screen (`u poi(result of the computation)`), and the execution of the control
    is resumed (`gc`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器命令 `bp OLEAUT32!DispCallFunc` 在 `DispCallFunc()` 的开始处定义了一个断点。如果断点被触发，则评估函数的前两个参数。第一个函数参数使用命令
    `poi(poi(esp+4))` 进行引用，第二个参数通过 `poi(esp+8)` 引用。这些值相加，它们的和代表被调用方法的地址。随后，方法反汇编的第一行（`L1`）被打印到屏幕上（`u
    poi(result of the computation)`），并且控制执行继续（`gc`）。
- en: I then started Internet Explorer with the `g` (Go) command of WinDbg and navigated
    to [http://www.webex.com/](http://www.webex.com/) again. As expected, the breakpoint
    triggered in WinDbg showed the memory address of the called `NewObject()` method
    in `atucfobj.dll`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我使用 WinDbg 的 `g`（Go）命令启动了 Internet Explorer，并再次导航到 [http://www.webex.com/](http://www.webex.com/)。不出所料，WinDbg
    中触发的断点显示了 `atucfobj.dll` 中被调用的 `NewObject()` 方法的内存地址。
- en: 'As illustrated in [Figure 5-5](ch05.html#windbg_showing_the_memory_address_of_the
    "Figure 5-5. WinDbg showing the memory address of the NewObject() method"), the
    memory address of the `NewObject()` method was `0x01d5767f` in this example. The
    `atucfobj.dll` itself was loaded at address `0x01d50000` (see `ModLoad: 01d50000
    01d69000 C:\Program Files\WebEx\WebEx\824\atucfobj.dll` in [Figure 5-5](ch05.html#windbg_showing_the_memory_address_of_the
    "Figure 5-5. WinDbg showing the memory address of the NewObject() method")). So
    the offset of `NewObject()` in `atucfobj.dll` was `0x01d5767f - 0x01d50000 = 0x767F`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '如[图5-5](ch05.html#windbg_showing_the_memory_address_of_the "图5-5. WinDbg显示NewObject()方法的内存地址")所示，在这个例子中，`NewObject()`方法的内存地址是`0x01d5767f`。`atucfobj.dll`本身在地址`0x01d50000`处加载（参见[图5-5](ch05.html#windbg_showing_the_memory_address_of_the
    "图5-5. WinDbg显示NewObject()方法的内存地址")中的`ModLoad: 01d50000 01d69000 C:\Program Files\WebEx\WebEx\824\atucfobj.dll`）。因此，`atucfobj.dll`中`NewObject()`的偏移量是`0x01d5767f
    - 0x01d50000 = 0x767F`。'
- en: '![Defining a breakpoint at OLEAUT32!DispCallFunc in Internet Explorer](httpatomoreillycomsourcenostarchimages939287.png.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![在Internet Explorer中在OLEAUT32!DispCallFunc处设置断点](httpatomoreillycomsourcenostarchimages939287.png.jpg)'
- en: Figure 5-4. Defining a breakpoint at `OLEAUT32!DispCallFunc` in Internet Explorer
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-4. 在Internet Explorer中在`OLEAUT32!DispCallFunc`处设置断点
- en: '![WinDbg showing the memory address of the NewObject() method](httpatomoreillycomsourcenostarchimages939289.png.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![WinDbg显示NewObject()方法的内存地址](httpatomoreillycomsourcenostarchimages939289.png.jpg)'
- en: Figure 5-5. WinDbg showing the memory address of the `NewObject()` method
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-5. WinDbg显示`NewObject()`方法的内存地址
- en: 'Step 4: Find the User-Controlled Input Values'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4步：查找用户可控输入值
- en: 'Next, I disassembled the binary *C:\Program Files\WebEx\WebEx\824\atucfobj.dll*
    with IDA Pro.^([[52](ch05s05.html#ftn.CHP-5-FN-8)]) In IDA, the imagebase of `atucfobj.dll`
    was `0x10000000`. So `NewObject()` was located at address `0x1000767f` (imagebase
    + offset of `NewObject()`: `0x10000000 + 0x767F`) in the disassembly (see [Figure 5-6](ch05.html#disassembly_of_the_newobject_open_parent
    "Figure 5-6. Disassembly of the NewObject() method in IDA Pro")).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我使用IDA Pro反汇编了二进制文件*C:\Program Files\WebEx\WebEx\824\atucfobj.dll*。在IDA中，`atucfobj.dll`的imagebase是`0x10000000`。因此，`NewObject()`在反汇编中的地址是`0x1000767f`（imagebase
    + `NewObject()`的偏移量：`0x10000000 + 0x767F`）（参见[图5-6](ch05.html#disassembly_of_the_newobject_open_parent
    "图5-6. IDA Pro中NewObject()方法的反汇编")）。
- en: '![Disassembly of the NewObject() method in IDA Pro](httpatomoreillycomsourcenostarchimages939291.png.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![IDA Pro中NewObject()方法的反汇编](httpatomoreillycomsourcenostarchimages939291.png.jpg)'
- en: Figure 5-6. Disassembly of the `NewObject()` method in IDA Pro
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-6. IDA Pro中`NewObject()`方法的反汇编
- en: Before I started reading the assembly, I had to ensure what function argument
    holds the user-controlled string value provided through the VBScript in [Example 5-1](ch05.html#html_file_to_call_the
    "Example 5-1. HTML file to call the NewObject() method (webex_poc1.html)"). Since
    the argument is a string, I guessed that my value was being held in the second
    parameter, `lpWideCharStr`, shown in IDA. I wanted to be sure, however, so I defined
    a new breakpoint at the `NewObject()` method and had a look at the arguments in
    the debugger (see Section B.2 for a description of the following debugger commands).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始阅读汇编代码之前，我必须确保哪个函数参数持有通过[示例5-1](ch05.html#html_file_to_call_the "示例5-1.
    调用NewObject()方法的HTML文件 (webex_poc1.html)")中的VBScript提供的用户可控字符串值。由于参数是一个字符串，我猜测我的值被保存在IDA中显示的第二个参数`lpWideCharStr`中。然而，我想确保这一点，因此我在`NewObject()`方法处定义了一个新的断点，并在调试器中查看参数（有关以下调试器命令的描述，请参见B.2节）。
- en: As illustrated in [Figure 5-7](ch05.html#user-controlled_argument_of_newobject_op
    "Figure 5-7. User-controlled argument of NewObject() after defining a new breakpoint"),
    I defined the new breakpoint at the address of `NewObject()` (`0:009> bp 01d5767f`),
    continued the execution of Internet Explorer (`0:009> g`), and again navigated
    to the [http://www.webex.com/](http://www.webex.com/) domain. When the breakpoint
    was triggered, I inspected the value of the second function argument of `NewObject()`
    (`0:000> dd poi(esp+8)` and `0:000> du poi(esp+8)`). As the debugger output shows,
    the user-controlled data (a wide-character string consisting of 12 As) was indeed
    passed to the function through the second argument.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 5-7](ch05.html#user-controlled_argument_of_newobject_op "图 5-7. 定义新断点后
    NewObject() 的用户控制参数") 所示，我在 `NewObject()` 的地址处定义了一个新的断点（`0:009> bp 01d5767f`），继续执行
    Internet Explorer (`0:009> g`)，并再次导航到 [http://www.webex.com/](http://www.webex.com/)
    域。当断点被触发时，我检查了 `NewObject()` 的第二个函数参数的值（`0:000> dd poi(esp+8)` 和 `0:000> du poi(esp+8)`）。如调试器输出所示，用户控制的数据（由
    12 个 A 组成的宽字符字符串）确实通过第二个参数传递给了该函数。
- en: Finally, I had all information I needed to start auditing the method for security
    bugs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我拥有了开始审计安全漏洞所需的所有信息。
- en: '![User-controlled argument of NewObject() after defining a new breakpoint](httpatomoreillycomsourcenostarchimages939293.png.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![定义新断点后 NewObject() 的用户控制参数](httpatomoreillycomsourcenostarchimages939293.png.jpg)'
- en: Figure 5-7. User-controlled argument of `NewObject()` after defining a new breakpoint
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-7. 定义新断点后 `NewObject()` 的用户控制参数
- en: 'Step 5: Reverse Engineer the Object Methods'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 5 步：逆向工程对象方法
- en: To recap, I found an obvious vulnerability that happens while the ActiveX control
    processes the user-supplied string value that gets passed to `NewObject()`. [Figure 5-8](ch05.html#code_path_to_reach_the_vulnerable_functi
    "Figure 5-8. Code path to reach the vulnerable function (created in IDA Pro)")
    illustrates the code path to reach the vulnerable function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我发现了一个明显的漏洞，这个漏洞发生在 ActiveX 控件处理传递给 `NewObject()` 的用户提供的字符串值时。[图 5-8](ch05.html#code_path_to_reach_the_vulnerable_functi
    "图 5-8. 到达有漏洞函数的代码路径（由 IDA Pro 创建)") 展示了到达有漏洞函数的代码路径。
- en: '![Code path to reach the vulnerable function (created in IDA Pro)](httpatomoreillycomsourcenostarchimages939295.png.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![到达有漏洞函数的代码路径（由 IDA Pro 创建)](httpatomoreillycomsourcenostarchimages939295.png.jpg)'
- en: Figure 5-8. Code path to reach the vulnerable function (created in IDA Pro)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-8. 到达有漏洞函数的代码路径（由 IDA Pro 创建）
- en: 'In `sub_1000767F` the user-provided wide-character string is converted to a
    character string using the `WideCharToMultiByte()` function. After that, `sub_10009642`
    is called, and the user-controlled character string is copied into another buffer.
    The code in `sub_10009642` allows a maximum of 256 user-controlled bytes to be
    copied into this new character buffer (pseudo C code: `strncpy (new_buffer, user_controlled_string,
    256)`). The function `sub_10009826` is called, and it calls `sub_100096D0`, which
    then calls the vulnerable function `sub_1000B37D`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sub_1000767F` 中，使用 `WideCharToMultiByte()` 函数将用户提供的宽字符字符串转换为字符字符串。之后，调用 `sub_10009642`，并将用户控制的字符字符串复制到另一个缓冲区。`sub_10009642`
    中的代码允许最多复制 256 个用户控制的字节到这个新的字符缓冲区（伪 C 代码：`strncpy (new_buffer, user_controlled_string,
    256)`）。调用 `sub_10009826` 函数，它随后调用 `sub_100096D0`，然后调用有漏洞的函数 `sub_1000B37D`。
- en: Example 5-3. Disassembly of the vulnerable function `sub_1000B37D` (created
    in IDA Pro)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-3. 有漏洞函数 `sub_1000B37D` 的反汇编（由 IDA Pro 创建）
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first argument of `sub_1000B37D`, called `cbData`, holds a pointer to the
    user-controlled data stored in the new character buffer (see `new_buffer` in the
    description of [Figure 5-8](ch05.html#code_path_to_reach_the_vulnerable_functi
    "Figure 5-8. Code path to reach the vulnerable function (created in IDA Pro)")).
    As I said before, the user-controlled wide-character data is stored in this new
    buffer as a character string with a maximum length of 256 bytes. [Example 5-3](ch05.html#disassembly_of_the_vulnerable
    "Example 5-3. Disassembly of the vulnerable function sub_1000B37D (created in
    IDA Pro)") shows that the `sprintf()` function at address `.text:1000B39D` copies
    the user-controlled data pointed to by `cbData` into a stack buffer called `SubKey`
    (see `.text:1000B387` and `.text:1000B39C`).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub_1000B37D`的第一个参数，称为`cbData`，包含指向存储在新字符缓冲区中的用户控制数据的指针（参见[图5-8](ch05.html#code_path_to_reach_the_vulnerable_functi
    "图5-8. 达到受害函数的代码路径（在IDA Pro中创建)")描述中的`new_buffer`）。正如我之前所说的，用户控制的宽字符数据以最大长度为256字节的字符串形式存储在这个新缓冲区中。[示例5-3](ch05.html#disassembly_of_the_vulnerable
    "示例5-3. 受害函数sub_1000B37D的汇编代码")显示，地址`.text:1000B39D`处的`sprintf()`函数将`cbData`指向的用户控制数据复制到名为`SubKey`的堆栈缓冲区（参见`.text:1000B387`和`.text:1000B39C`）。'
- en: Next, I tried to retrieve the size of this `SubKey` stack buffer. I opened IDA
    Pro’s default stack frame displays by pressing ctrl-k. As shown in [Figure 5-9](ch05.html#determining_the_size_of_the_subkey_stack
    "Figure 5-9. Determining the size of the SubKey stack buffer using IDA Pro’s default
    stack frame displays"), the stack buffer `SubKey` has a fixed size of 260 bytes.
    If the information from the disassembly shown in [Example 5-3](ch05.html#disassembly_of_the_vulnerable
    "Example 5-3. Disassembly of the vulnerable function sub_1000B37D (created in
    IDA Pro)") is combined with the information on the stack layout of the vulnerable
    function, the call to `sprintf()` can be expressed with the C code in [Example 5-4](ch05.html#pseudo_c_code_of_the_vulnerable_call
    "Example 5-4. Pseudo C code of the vulnerable call to sprintf()").
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我尝试检索这个`SubKey`堆栈缓冲区的大小。通过按ctrl-k键，我打开了IDA Pro的默认堆栈帧显示。如图[图5-9](ch05.html#determining_the_size_of_the_subkey_stack
    "图5-9. 使用IDA Pro的默认堆栈帧显示确定SubKey堆栈缓冲区的大小")所示，`SubKey`堆栈缓冲区具有固定的260字节大小。如果将[示例5-3](ch05.html#disassembly_of_the_vulnerable
    "示例5-3. 受害函数sub_1000B37D的汇编代码")中显示的汇编信息与受害函数的堆栈布局信息相结合，则`sprintf()`的调用可以用[示例5-4](ch05.html#pseudo_c_code_of_the_vulnerable_call
    "示例5-4. 受害调用sprintf()的伪C代码")中的C代码表示。
- en: '![Determining the size of the SubKey stack buffer using IDA Pro’s default stack
    frame displays](httpatomoreillycomsourcenostarchimages939297.png.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![使用IDA Pro的默认堆栈帧显示确定SubKey堆栈缓冲区的大小](httpatomoreillycomsourcenostarchimages939297.png.jpg)'
- en: Figure 5-9. Determining the size of the `SubKey` stack buffer using IDA Pro’s
    default stack frame displays
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-9. 使用IDA Pro的默认堆栈帧显示确定`SubKey`堆栈缓冲区的大小
- en: Example 5-4. Pseudo C code of the vulnerable call to `sprintf()`
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5-4. 受害调用`sprintf()`的伪C代码
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `sprintf()` library function copies the user-controlled data from `cbData`
    as well as the string “`Authoring`” (9 bytes) and the format string (39 bytes)
    into `SubKey`. If `cbData` is filled with the maximum amount of user-controlled
    data (256 bytes), a total of 304 bytes of data will be copied into the stack buffer.
    `SubKey` can only hold up to 260 bytes, and `sprintf()` doesn’t perform any length
    check. Therefore, as shown in [Figure 5-10](ch05.html#diagram_of_the_stack_buffer_overflow_tha
    "Figure 5-10. Diagram of the stack buffer overflow that occurs when an overly
    long string is passed to NewObject()"), it’s possible to write user-controlled
    data out of the bounds of `SubKey`, which leads to a stack buffer overflow (see
    Section A.1).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`sprintf()`库函数将`cbData`中的用户控制数据以及字符串“`Authoring`”（9字节）和格式字符串（39字节）复制到`SubKey`中。如果`cbData`填充了最大量的用户控制数据（256字节），则总共将复制304字节的数据到堆栈缓冲区。`SubKey`只能容纳最多260字节，且`sprintf()`不执行任何长度检查。因此，如图[图5-10](ch05.html#diagram_of_the_stack_buffer_overflow_tha
    "图5-10. 将过长的字符串传递给NewObject()时发生的堆栈缓冲区溢出图")所示，有可能将用户控制数据写入`SubKey`的边界之外，从而导致堆栈缓冲区溢出（参见附录A.1）。'
- en: '![Diagram of the stack buffer overflow that occurs when an overly long string
    is passed to NewObject()](httpatomoreillycomsourcenostarchimages939299.png.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![将过长的字符串传递给NewObject()时发生的堆栈缓冲区溢出图](httpatomoreillycomsourcenostarchimages939299.png.jpg)'
- en: Figure 5-10. Diagram of the stack buffer overflow that occurs when an overly
    long string is passed to `NewObject()`
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-10. 将过长的字符串传递给`NewObject()`时发生的堆栈缓冲区溢出图
- en: 5.2 Exploitation
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.2 利用
- en: After I found the vulnerability, exploitation was easy. All I had to do was
    tweak the length of the string argument supplied to `NewObject()` to overflow
    the stack buffer and gain control of the return address of the current stack frame.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 找到漏洞后，利用起来很简单。我只需要调整传递给 `NewObject()` 的字符串参数的长度，以溢出栈缓冲区并控制当前栈帧的返回地址。
- en: 'As illustrated in [Figure 5-9](ch05.html#determining_the_size_of_the_subkey_stack
    "Figure 5-9. Determining the size of the SubKey stack buffer using IDA Pro’s default
    stack frame displays"), the distance from the `SubKey` buffer to the saved return
    address on the stack is 272 bytes (the offset of the saved return address (`+00000004`)
    minus the offset of `SubKey` (`−0000010C`): `0x4 - −0x10c = 0x110` (272)). I also
    had to account for the fact that the string “`Authoring`” and part of the format
    string will be copied into `SubKey` right before the user-controlled data (see
    [Figure 5-10](ch05.html#diagram_of_the_stack_buffer_overflow_tha "Figure 5-10. Diagram
    of the stack buffer overflow that occurs when an overly long string is passed
    to NewObject()")). All in all I had to subtract 40 bytes (“`SOFTWARE\Webex\UCF\Components\Authoring\`”)
    from the distance between `SubKey` and the saved return address (272 – 40 = 232).
    So I had to provide 232 bytes of dummy data to fill the stack and reach the saved
    return address. The following 4 bytes of the user-controlled data should then
    overwrite the value of the saved return address on the stack.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '如 [图 5-9](ch05.html#determining_the_size_of_the_subkey_stack "图 5-9. 使用 IDA
    Pro 的默认栈帧显示确定 SubKey 栈缓冲区的大小") 所示，`SubKey` 缓冲区到栈上保存的返回地址的距离是 272 字节（保存的返回地址的偏移量
    (`+00000004`) 减去 `SubKey` 的偏移量 (`−0000010C`): `0x4 - −0x10c = 0x110` (272))。我还必须考虑到字符串
    “`Authoring`” 和部分格式字符串将在用户控制数据之前被复制到 `SubKey` 中（参见 [图 5-10](ch05.html#diagram_of_the_stack_buffer_overflow_tha
    "图 5-10. 当传递给 NewObject() 的字符串过长时发生的栈缓冲区溢出示意图")）。总的来说，我必须从 `SubKey` 和保存的返回地址之间的距离中减去
    40 字节（“`SOFTWARE\Webex\UCF\Components\Authoring\`”）。所以，我必须提供 232 字节（272 - 40 =
    232）的虚拟数据来填充栈并达到保存的返回地址。然后，用户控制数据的接下来的 4 个字节应该覆盖栈上保存的返回地址的值。'
- en: 'So I changed the number of supplied characters in line 6 of *webex_poc1.html*
    and named the new file *webex_poc2.html* (see [Example 5-5](ch05s02.html#html_file_that_passes_an_overly
    "Example 5-5. HTML file that passes an overly long string to the NewObject() method
    (webex_poc2.html)")):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我更改了 *webex_poc1.html* 第 6 行提供的字符数，并将新文件命名为 *webex_poc2.html*（参见 [示例 5-5](ch05s02.html#html_file_that_passes_an_overly
    "示例 5-5. 传递给 NewObject() 方法的过长字符串的 HTML 文件 (webex_poc2.html)"))：
- en: Example 5-5. HTML file that passes an overly long string to the `NewObject()`
    method (*webex_poc2.html*)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-5. 传递给 `NewObject()` 方法的过长字符串的 HTML 文件 (*webex_poc2.html*)
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, I adjusted the little Python web server to serve the new HTML file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我将小型的 Python 网络服务器调整为服务新的 HTML 文件。
- en: 'The original *wwwserv.py*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '原始的 *wwwserv.py*:'
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The adjusted *wwwserv.py*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '调整后的 *wwwserv.py*:'
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I restarted the web server, loaded Internet Explorer in WinDbg, and navigated
    to [http://www.webex.com/](http://www.webex.com/) again.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我重新启动了网络服务器，在 WinDbg 中加载了 Internet Explorer，并再次导航到 [http://www.webex.com/](http://www.webex.com/)。
- en: As illustrated in [Figure 5-11](ch05s02.html#eip_control_of_internet_explorer
    "Figure 5-11. EIP control of Internet Explorer"), I now had full control over
    `EIP`. The bug could be easily exploited for arbitrary code execution using the
    well-known heap spraying technique.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 5-11](ch05s02.html#eip_control_of_internet_explorer "图 5-11. Internet Explorer
    的 EIP 控制") 所示，我现在完全控制了 `EIP`。该漏洞可以很容易地通过已知的堆喷射技术被用于任意代码执行。
- en: '![EIP control of Internet Explorer](httpatomoreillycomsourcenostarchimages939301.png.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Internet Explorer 的 EIP 控制](httpatomoreillycomsourcenostarchimages939301.png.jpg)'
- en: Figure 5-11. `EIP` control of Internet Explorer
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-11. Internet Explorer 的 `EIP` 控制
- en: As usual, German laws prevent me from providing a full working exploit, but
    if you’re interested, you can watch a short video I recorded that shows the exploit
    in action on the book’s website.^([[53](ch05s05.html#ftn.CHP-5-FN-9)])
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如往常一样，德国法律阻止我提供完整的有效利用代码，但如果你感兴趣，你可以在本书网站上观看我录制的一段简短视频，展示了利用代码在书网站上的实际操作.^([[53](ch05s05.html#ftn.CHP-5-FN-9)])
- en: As I mentioned before, I could have found the bug much faster if I had fuzzed
    the ActiveX control with COMRaider instead of reading the assembly. But hey, fuzzing
    is not as cool as reading assembly, right?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，如果我用 COMRaider 对 ActiveX 控件进行模糊测试而不是阅读汇编代码，我就能更快地找到这个漏洞。但嘿，模糊测试并不像阅读汇编代码那样酷，对吧？
- en: 5.3 Vulnerability Remediation
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 漏洞修复
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Thursday, August 14, 2008*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*星期四，2008 年 8 月 14 日*'
- en: In [Chapter 2](ch02.html "Chapter 2. Back to the ’90s"), [Chapter 3](ch03.html
    "Chapter 3. Escape from the WWW Zone"), and [Chapter 4](ch04.html "Chapter 4. NULL
    Pointer FTW"), I disclosed the security bugs directly to the vendor of the compromised
    software and helped it to create a patch. I chose another disclosure process for
    this bug. This time I didn’t notify the vendor directly but rather sold the bug
    to a vulnerability broker (Verisign’s iDefense Lab Vulnerability Contributor Program
    [VCP]) and let it coordinate with Cisco (see Section 2.3).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "Chapter 2. Back to the ’90s")、[第3章](ch03.html "Chapter 3. Escape
    from the WWW Zone")和[第4章](ch04.html "Chapter 4. NULL Pointer FTW")中，我直接向受损害软件的供应商披露了安全漏洞，并帮助其创建补丁。这次我并没有直接通知供应商，而是将漏洞出售给了漏洞经纪人（Verisign的iDefense
    Lab Vulnerability Contributor Program [VCP]），并让它与思科协调（见第2.3节）。
- en: I contacted iDefense on April 8, 2008\. It accepted my submission and informed
    Cisco of the issue. While Cisco was working on a new version of the ActiveX control,
    another security researcher named Elazar Broad rediscovered the bug in June 2008\.
    He also informed Cisco but then disclosed the bug publicly in the process known
    as *full disclosure*.^([[54](ch05s05.html#ftn.CHP-5-FN-10)]) Cisco released a
    fixed version of WebEx Meeting Manager, as well as a security advisory, on August
    14, 2008\. All in all it was a great mess, but in the end Elazar and I made the
    Web a safer place.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我于2008年4月8日联系了iDefense。它接受了我的提交，并向思科报告了这个问题。当思科正在开发ActiveX控件的新版本时，另一位安全研究员Elazar
    Broad于2008年6月重新发现了这个漏洞。他也通知了思科，但在一个被称为*完全披露*的过程中公开了漏洞。^([[54](ch05s05.html#ftn.CHP-5-FN-10)])
    思科于2008年8月14日发布了修复后的WebEx会议管理器版本以及安全公告。总的来说，这是一场大混乱，但最终Elazar和我使网络变得更加安全。
- en: 5.4 Lessons Learned
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.4 经验教训
- en: There are still obvious, easily exploitable bugs in widely deployed (enterprise)
    software products.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在广泛部署（企业）软件产品中仍然存在明显的、容易利用的漏洞。
- en: Cross-site scripting breaks ActiveX domain restrictions. This is also true for
    Microsoft’s SiteLock.^([[55](ch05s05.html#ftn.CHP-5-FN-11)])
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨站脚本攻击打破了ActiveX域限制。这对于微软的SiteLock也是如此。^([[55](ch05s05.html#ftn.CHP-5-FN-11)])
- en: From a bug hunter’s perspective, ActiveX controls are promising and valuable
    targets.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从漏洞猎手的视角来看，ActiveX控件是很有潜力和价值的攻击目标。
- en: Vulnerability rediscovery happens (way too often).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 漏洞的重发现（过于频繁）发生了。
- en: 5.5 Addendum
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.5 补遗
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Wednesday, September 17, 2008*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*2008年9月17日，星期三*'
- en: The vulnerability is fixed and a new version of WebEx Meeting Manager is available,
    so I released a detailed security advisory on my website today.^([[56](ch05s05.html#ftn.CHP-5-FN-12)])
    The bug was assigned CVE-2008-3558\. [Figure 5-12](ch05s05.html#timeline_from_discovery_of_the_webex_mee
    "Figure 5-12. Timeline from discovery of the WebEx Meeting Manager vulnerability
    until the release of the security advisory") shows the timeline of the vulnerability
    fix.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞已修复，并发布了WebEx会议管理器的新版本，因此我今天在我的网站上发布了详细的安全公告。^([[56](ch05s05.html#ftn.CHP-5-FN-12)])
    该漏洞被分配了CVE-2008-3558。图5-12([Figure 5-12. Timeline from discovery of the WebEx
    Meeting Manager vulnerability until the release of the security advisory](ch05s05.html#timeline_from_discovery_of_the_webex_mee))显示了漏洞修复的时间线。
- en: '![Timeline from discovery of the WebEx Meeting Manager vulnerability until
    the release of the security advisory](httpatomoreillycomsourcenostarchimages939303.png.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![从发现WebEx会议管理器漏洞到发布安全公告的时间线](httpatomoreillycomsourcenostarchimages939303.png.jpg)'
- en: Figure 5-12. Timeline from discovery of the WebEx Meeting Manager vulnerability
    until the release of the security advisory
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-12. 从发现WebEx会议管理器漏洞到发布安全公告的时间线
- en: Notes
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备注
- en: ^([[45](#ftn.CHP-5-FN-1)])
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[45](#ftn.CHP-5-FN-1)])
- en: ^([[46](#ftn.CHP-5-FN-2)])
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[46](#ftn.CHP-5-FN-2)])
- en: ^([[47](#ftn.CHP-5-FN-3)])
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[47](#ftn.CHP-5-FN-3)])
- en: ^([[48](#ftn.CHP-5-FN-4)])
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[48](#ftn.CHP-5-FN-4)])
- en: ^([[49](#ftn.CHP-5-FN-5)])
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[49](#ftn.CHP-5-FN-5)])
- en: ^([[50](#ftn.CHP-5-FN-6)])
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[50](#ftn.CHP-5-FN-6)])
- en: ^([[51](#ftn.CHP-5-FN-7)])
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[51](#ftn.CHP-5-FN-7)])
- en: ^([[52](#ftn.CHP-5-FN-8)])
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[52](#ftn.CHP-5-FN-8)])
- en: ^([[53](#ftn.CHP-5-FN-9)])
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[53](#ftn.CHP-5-FN-9)])
- en: ^([[54](#ftn.CHP-5-FN-10)])
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[54](#ftn.CHP-5-FN-10)])
- en: ^([[55](#ftn.CHP-5-FN-11)])
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[55](#ftn.CHP-5-FN-11)])
- en: ^([[56](#ftn.CHP-5-FN-12)])
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[56](#ftn.CHP-5-FN-12)])
- en: '* * *'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[45](#CHP-5-FN-1)]) COMRaider from iDefense is a great tool to enumerate
    and fuzz COM object interfaces. See [http://labs.idefense.com/software/download/?downloadID=23](http://labs.idefense.com/software/download/?downloadID=23).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[45](#CHP-5-FN-1)]) iDefense的COMRaider是一个很好的工具，可以枚举和模糊COM对象接口。请参阅[http://labs.idefense.com/software/download/?downloadID=23](http://labs.idefense.com/software/download/?downloadID=23)。
- en: ^([[46](#CHP-5-FN-2)]) For more information, consult “Safe Initialization and
    Scripting for ActiveX Controls” at [http://msdn.microsoft.com/en-us/library/aa751977(VS.85).aspx](http://msdn.microsoft.com/en-us/library/aa751977(VS.85).aspx).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[46](#CHP-5-FN-2)]) 如需更多信息，请查阅“ActiveX 控件的安全初始化和脚本编写”相关内容，链接为 [http://msdn.microsoft.com/en-us/library/aa751977(VS.85).aspx](http://msdn.microsoft.com/en-us/library/aa751977(VS.85).aspx)。
- en: ^([[47](#CHP-5-FN-3)]) See “Not safe = not dangerous? How to tell if ActiveX
    vulnerabilities are exploitable in Internet Explorer” at [http://blogs.technet.com/srd/archive/2008/02/03/activex-controls.aspx](http://blogs.technet.com/srd/archive/2008/02/03/activex-controls.aspx).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[47](#CHP-5-FN-3)]) 请参阅“不安全等于不危险？如何在 Internet Explorer 中判断 ActiveX 漏洞是否可利用”的相关内容，链接为
    [http://blogs.technet.com/srd/archive/2008/02/03/activex-controls.aspx](http://blogs.technet.com/srd/archive/2008/02/03/activex-controls.aspx)。
- en: ^([[48](#CHP-5-FN-4)]) For more information on cross-site scripting, refer to
    [https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[48](#CHP-5-FN-4)]) 关于跨站脚本攻击的更多信息，请参考 [https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS))。
- en: '^([[49](#CHP-5-FN-5)]) See “MindshaRE: Finding ActiveX Methods Dynamically”
    at [http://dvlabs.tippingpoint.com/blog/2009/06/01/mindshare-finding-activex-methods-dynamically/](http://dvlabs.tippingpoint.com/blog/2009/06/01/mindshare-finding-activex-methods-dynamically/).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[49](#CHP-5-FN-5)]) 请参阅“MindshaRE：动态查找 ActiveX 方法”的相关内容，链接为 [http://dvlabs.tippingpoint.com/blog/2009/06/01/mindshare-finding-activex-methods-dynamically/](http://dvlabs.tippingpoint.com/blog/2009/06/01/mindshare-finding-activex-methods-dynamically/)。
- en: ^([[50](#CHP-5-FN-6)]) See [http://msdn.microsoft.com/en-us/library/9a16d4e4-a03d-459d-a2ec-3258499f6932(VS.85)](http://msdn.microsoft.com/en-us/library/9a16d4e4-a03d-459d-a2ec-3258499f6932(VS.85)).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[50](#CHP-5-FN-6)]) 请参阅 [http://msdn.microsoft.com/en-us/library/9a16d4e4-a03d-459d-a2ec-3258499f6932(VS.85)](http://msdn.microsoft.com/en-us/library/9a16d4e4-a03d-459d-a2ec-3258499f6932(VS.85))。
- en: ^([[51](#CHP-5-FN-7)]) WinDbg is the “official” Windows Debugger from Microsoft
    and is distributed as part of the free “Debugging Tools for Windows” suite, available
    at [http://www.microsoft.com/whdc/DevTools/Debugging/default.mspx](http://www.microsoft.com/whdc/DevTools/Debugging/default.mspx).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[51](#CHP-5-FN-7)]) WinDbg 是微软的“官方”Windows 调试器，作为免费“Windows 调试工具”套件的一部分进行分发，可在
    [http://www.microsoft.com/whdc/DevTools/Debugging/default.mspx](http://www.microsoft.com/whdc/DevTools/Debugging/default.mspx)
    获取。
- en: ^([[52](#CHP-5-FN-8)]) See [http://www.hex-rays.com/idapro/](http://www.hex-rays.com/idapro/).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[52](#CHP-5-FN-8)]) 请参阅 [http://www.hex-rays.com/idapro/](http://www.hex-rays.com/idapro/)。
- en: ^([[53](#CHP-5-FN-9)]) See [http://www.trapkit.de/books/bhd/](http://www.trapkit.de/books/bhd/).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[53](#CHP-5-FN-9)]) 请参阅 [http://www.trapkit.de/books/bhd/](http://www.trapkit.de/books/bhd/)。
- en: ^([[54](#CHP-5-FN-10)]) See [http://seclists.org/fulldisclosure/2008/Aug/83](http://seclists.org/fulldisclosure/2008/Aug/83).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[54](#CHP-5-FN-10)]) 请参阅 [http://seclists.org/fulldisclosure/2008/Aug/83](http://seclists.org/fulldisclosure/2008/Aug/83)。
- en: ^([[55](#CHP-5-FN-11)]) For more information on Microsoft’s SiteLock, see [http://msdn.microsoft.com/en-us/library/bb250471%28VS.85%29.aspx](http://msdn.microsoft.com/en-us/library/bb250471%28VS.85%29.aspx).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[55](#CHP-5-FN-11)]) 如需了解微软的 SiteLock 的更多信息，请参阅 [http://msdn.microsoft.com/en-us/library/bb250471%28VS.85%29.aspx](http://msdn.microsoft.com/en-us/library/bb250471%28VS.85%29.aspx)。
- en: ^([[56](#CHP-5-FN-12)]) My security advisory that describes the details of the
    WebEx Meeting Manager vulnerability can be found at [http://www.trapkit.de/advisories/TKADV2008-009.txt](http://www.trapkit.de/advisories/TKADV2008-009.txt).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[56](#CHP-5-FN-12)]) 描述 WebEx 会议管理器漏洞详细信息的我的安全公告可在 [http://www.trapkit.de/advisories/TKADV2008-009.txt](http://www.trapkit.de/advisories/TKADV2008-009.txt)
    找到。
