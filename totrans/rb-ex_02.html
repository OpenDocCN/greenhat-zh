<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Amusements and Simple Utilities"><div class="titlepage"><div><div><h1 class="title"><a id="amusements_and_simple_utilities"/>Chapter 2. Amusements and Simple Utilities</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e1490"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages686190.png.jpg"/></div></div><p>From the previous chapter, you should now be relatively comfortable with irb and how <a class="indexterm" id="idx-CHP-2-0086"/>Ruby deals with various expressions. Now we’ll try some Ruby programs that are stored in separate files and executed outside of irb. You can download all of these programs at <a class="ulink" href="http://www.nostarch.com/ruby.htm">http://www.nostarch.com/ruby.htm</a>.</p><p>We’ll run our programs with the <code class="literal">ruby</code> command, so when we want to run a script called <code class="literal">check_payday.rb</code>, we’ll type <code class="literal">ruby check_payday.rb</code> either at the shell in a Unix-like system or at the command prompt in Windows. We’ll also generally use the <code class="literal">-w</code> option, which means <span class="emphasis"><em>turn warnings on</em></span>, making our example above become <code class="literal">ruby -w check_payday.rb</code>. It’s just a safer way to operate, and it is especially useful when learning a new language. We’ll also occasionally see <a class="indexterm" id="idx-CHP-2-0087"/>Ruby Documentation (<a class="indexterm" id="idx-CHP-2-0088"/>RDoc), which allows us to put relatively complex comments directly into our source code. We’ll discuss that in relation to the <code class="literal">99bottles.rb</code> example, where we first use it.<a class="indexterm" id="idx-CHP-2-0089"/><a class="indexterm" id="idx-CHP-2-0090"/></p><div class="sect1" title="#1 Is It Payday? (check_payday.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp1_is_it_payday_check_paydayrb"/>#1 Is It Payday? (check_payday.rb)</h1></div></div></div><p>This script is a simple utility that I use to remind myself when a payday is approaching. It is very much in the quick-and-dirty style, and intentionally so.<a class="indexterm" id="idx-CHP-2-0091"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code"/>The Code</h2></div></div></div><a id="I_programlisting2_d1e1552"/><pre class="programlisting">❶ #!/usr/bin/env ruby
❷ # check_payday.rb<a class="indexterm" id="idx-CHP-2-0092"/>

❸ DAYS_IN_PAY_PERIOD  = 14    <em class="lineannotation"><span class="lineannotation"><a class="indexterm" id="idx-CHP-2-0093"/>CONSTANTS</span></em>
  SECONDS_IN_A_DAY    = 60 * 60 * 24

❹ matching_date = Time.local(0, 0, 0, 22, 9, 2006, 5, 265, true, "EDT")    <em class="lineannotation"><span class="lineannotation">Variables</span></em>
❺ current_date = Time.new()

  difference_in_seconds = (current_date - matching_date)
❻ difference_in_days    = (difference_in_seconds / SECONDS_IN_A_DAY).to_i
❼ days_to_wait          = (
    DAYS_IN_PAY_PERIOD - difference_in_days
  ) % DAYS_IN_A_PAY_PERIOD

  if (days_to_wait.zero?)
❽    puts 'Payday today.'
  else
    print 'Payday in ' + days_to_wait.to_s + ' day'
    puts days_to_wait == 1 ? '.' : 's.'
  end</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works"/>How It Works</h2></div></div></div><p>Line ❶ is a hint to the computer that this program is in Ruby. The line at ❷ is a comment meant for human readers that tells the name of the program. In Ruby, <a class="indexterm" id="idx-CHP-2-0094"/>comments start with the <code class="literal">#</code> character and last until the end of the line.</p><div class="sect3" title="Defining Constants"><div class="titlepage"><div><div><h3 class="title"><a id="defining_constants"/>Defining Constants</h3></div></div></div><p>We define two constants at ❸. While constants only need to <span class="emphasis"><em>start</em></span> with a capital letter, I like to use all caps to make them stand out. (This is a common convention in many languages and a good habit to get into.)<a class="indexterm" id="idx-CHP-2-0095"/></p><p>The names of the constants <code class="literal">DAYS_IN_PAY_PERIOD</code> and <code class="literal">SECONDS_IN_A_DAY</code> should give you a good sense of what they mean—specifically, the number of days in a pay period and the number of seconds in a day. I get paid every two weeks, which is the same as every 14 days.</p><p>The definition for <code class="literal">SECONDS_IN_A_DAY</code> uses multiplication (<code class="literal">60 * 60 * 24</code>), which is acceptable Ruby syntax, as you know from your experiments in irb. Representing these specific numbers as the result of multiplication instead of as one big final result is also more human readable, because a person reading this code will see and understand the relationship among 60 seconds in a minute, 60 minutes in an hour, and 24 hours in a day.</p><p>Why bother to define constants with more characters than the values they hold? While it doesn’t make a huge difference in this program, it’s a good habit to get into for larger programs.</p><div class="note" title="Note"><h3 class="title"><a id="note-13"/>Note</h3><p><span class="emphasis"><em>Constants are a very good idea. They allow you to avoid one of the sins of programming called</em></span> <a class="indexterm" id="idx-CHP-2-0096"/>magic numbers, <span class="emphasis"><em>which are examples of one of two programming sins: a literal value used repeatedly, or a literal value whose use is not obvious, even if it’s only used once. Defining such a value once with a meaningful name makes your code more readable to both other programmers and yourself, after you’ve forgotten everything about your program. Again, constants are a very good idea</em></span>.<a class="indexterm" id="idx-CHP-2-0097"/><a class="indexterm" id="idx-CHP-2-0098"/></p></div></div><div class="sect3" title="Defining Variables"><div class="titlepage"><div><div><h3 class="title"><a id="defining_variables"/>Defining Variables</h3></div></div></div><p>Having defined our constants, we define a variable at ❹ called <code class="literal">matching_date</code> using Ruby’s built-in <code class="literal">Time.local</code> method. This method takes 10 items as arguments, in order: seconds, minutes, hours, day of the month, month, year, day of the week, day number within the year (1 through 366), whether the date is within daylight saving time, and a three-letter code for the time zone. The values used here are for September 22, 2006, which is a day that happened to be a payday for me. The day number within a year has a maximum of 366 instead of 365, because leap years have 366 days.<a class="indexterm" id="idx-CHP-2-0099"/><a class="indexterm" id="idx-CHP-2-0100"/></p><p>At ❺, we get the <code class="literal">current_date</code> using Ruby’s built-in <code class="literal">Time.new</code> method, and then subtract <code class="literal">matching_date</code> from it to get the difference, in seconds. Because we are much more interested in the difference in days rather than the difference in seconds, we divide the <code class="literal">difference_in_seconds</code> by the number of <code class="literal">SECONDS_IN_A_DAY</code> to get the difference in days, and then we round down by converting that result into an Integer with the <code class="literal">to_i</code> method. That gives us a useful value for our <code class="literal">difference_in_days</code> variable.<a class="indexterm" id="idx-CHP-2-0101"/></p><p>The <code class="literal">difference_in_days</code> variable tells us the number of days since the last payday. However, because we really want our cash, we are more interested in how long we have to wait until the next payday. To find out, at ❻ we subtract the number of days since our last payday (the <code class="literal">difference_in_days</code> variable) from the number of <code class="literal">DAYS_IN_A_PAY_PERIOD</code> to get a new variable at ❼ called <code class="literal">days_to_wait</code>.</p><p>If <code class="literal">days_to_wait</code> has a value of zero, today must be payday, so at ❽ we output that information using Ruby’s built-in method <code class="literal">puts</code>. The <code class="literal">puts</code> method, which stands for <span class="emphasis"><em>put string</em></span>, prints its String argument (<code class="literal">‘Payday today.’</code>, in our <a class="indexterm" id="idx-CHP-2-0102"/>script) followed by an automatic <a class="indexterm" id="idx-CHP-2-0103"/>carriage return, also called a <span class="emphasis"><em>newline</em></span>. If <code class="literal">days_to_wait</code> is not zero, we use <code class="literal">puts</code> again to tell how many days we have to wait for payday, and as a convenience, we add the letter s to the word <code class="literal">day</code> if the number of days is plural.<a class="indexterm" id="idx-CHP-2-0104"/><a class="indexterm" id="idx-CHP-2-0105"/></p><div class="note" title="Note"><h3 class="title"><a id="note-14"/>Note</h3><p><span class="emphasis"><em>We call both <em class="replaceable"><code>print</code></em> and <em class="replaceable"><code>puts</code></em> without parentheses enclosing the argument(s). This is perfectly legal, unless there would be some ambiguity about either the boundaries of an expression or the specific arguments to a method</em></span>.<a class="indexterm" id="idx-CHP-2-0106"/><a class="indexterm" id="I_indexterm2_d1e1755"/></p></div><p>That’s the whole program. There are more elegant ways to accomplish some of the tasks that this program does, but it introduces some new concepts, such as Constants, the <code class="literal">puts</code> method, and Dates. You can run it yourself and compare what it outputs to what your own actual pay schedule is, altering the <code class="literal">matching_day</code> variable accordingly.</p><div class="note" title="Note"><h3 class="title"><a id="note-15"/>Note</h3><p><span class="emphasis"><em>Readers familiar with crontab may find it interesting that I run this on my machine with the following crontab entry: <em class="replaceable"><code>ruby ~/scripts/check_payday.rb | mutt -s “payday” kbaird</code></em></em></span>.<a class="indexterm" id="idx-CHP-2-0107"/></p></div></div></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results"/>The Results</h2></div></div></div><p>Your result should be a message along the lines of <span class="emphasis"><em>Payday in 10 days</em></span>, depending on the day you run the program.</p></div></div></div>
<div class="sect1" title="#2 Random Signature Generator (random_sig.rb and random_sig-windows.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp2_random_signature_generator_random"/>#2 Random Signature Generator (random_sig.rb and random_sig-windows.rb)</h1></div></div></div><p>The next script generates dynamic content for <a class="indexterm" id="idx-CHP-2-0108"/>email signatures, adding standard information, like a name and email address, to a random quotation drawn from a known file. The Unix and Windows versions need to be slightly different, so they have been separated into two distinct files. I’ll talk about the Unix version first, but will include the source code for both files. In this example, we’ll also see how Ruby handles complex assignments. That’s a lot of information to cover.<a class="indexterm" id="idx-CHP-2-0109"/><a class="indexterm" id="idx-CHP-2-0110"/><a class="indexterm" id="idx-CHP-2-0111"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id001"/>The Code</h2></div></div></div><a id="I_programlisting2_d1e1811"/><pre class="programlisting">  #!/usr/bin/env ruby
  # random_sig.rb

❶ filename = <a class="indexterm" id="idx-CHP-2-0112"/>ARGV[0] || (ENV['HOME'] + '/scripts/sig_quotes.txt')    <em class="lineannotation"><span class="lineannotation">Environment Variables; The File Object</span></em>
❷ quotation_file = File.new(filename, 'r')
  file_lines = quotation_file.readlines()
❸ quotation_file.close()
❹ quotations     = file_lines.to_s.split("\n\n")    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> split</code></strong> Method</span></em>
❺ random_index   = rand(quotations.size)
❻ quotation      = quotations[random_index]
  sig_file_name  = ENV['HOME'] + '/.signature'
❼ signature_file = File.new(sig_file_name, 'w')
❽ signature_file.puts 'Kevin Baird | kcbaird@world.oberlin.edu | http://
  kevinbaird.net/'
  signature_file.puts quotation
  signature_file.close()</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id001"/>How It Works</h2></div></div></div><p>At ❶, we assign a value to a variable called <code class="literal">filename</code>, but the value that goes into it is somewhat more complex than a single straightforward number or String. <code class="literal">ARGV</code> is an example of an environment variable. Environment variables are described in <a class="xref" href="ch01.html" title="Chapter 1. Interactive Ruby and the Ruby Environment">Chapter 1</a>. For historical reasons, <code class="literal">ARGV</code> stands for <span class="emphasis"><em>Argument Vector</em></span> and is an Array of the command-line arguments to any program when it is run.<a class="indexterm" id="idx-CHP-2-0113"/><a class="indexterm" id="I_indexterm2_d1e1851"/><a class="indexterm" id="I_indexterm2_d1e1854"/><a class="indexterm" id="I_indexterm2_d1e1859"/></p><p>That’s not the whole line, though. Just as the equals sign is an operator that puts a value into something, the double-bar (<code class="literal">||</code>) is an operator that means <span class="emphasis"><em>or</em></span>. Let’s use irb to see how it works.<a class="indexterm" id="idx-CHP-2-0114"/><a class="indexterm" id="idx-CHP-2-0115"/></p><a id="I_programlisting2_d1e1878"/><pre class="programlisting">irb(main):001:0&gt; 0 || false    <em class="lineannotation"><span class="lineannotation"><strong class="userinput"><code>||</code></strong> operator</span></em>
=&gt; 0
irb(main):002:0&gt; false || 0
=&gt; 0
irb(main):003:0&gt; nil || true
=&gt; true
irb(main):004:0&gt; nil || false
=&gt; false
irb(main):005:0&gt; false || nil
=&gt; nil</pre><p>An expression with the <code class="literal">||</code> operator evaluates whatever is to the left of it. If it is true, the whole expression has that value, whatever possible true value it happens to be. If the left side is false, the whole expression has the value on the right of the <code class="literal">||</code>, whatever that value is—<code class="literal">true, false, nil</code>, whatever. Missing arguments are <code class="literal">nil</code>, and <code class="literal">nil</code> evaluates to <code class="literal">false</code> when tested by <code class="literal">||</code>. The elements of <code class="literal">ARGV</code> start counting with zero, just like all Arrays in Ruby (and many other languages). Our <code class="literal">filename</code> variable is either the first argument to this program, <a class="indexterm" id="idx-CHP-2-0116"/>or if there is no argument, it’s set to all of that business within the parentheses: <code class="literal">(ENV[‘HOME’] + ‘/scripts/sig_quotes.txt’)</code>.<a class="indexterm" id="idx-CHP-2-0117"/></p><div class="note" title="Note"><h3 class="title"><a id="note-16"/>Note</h3><p><span class="emphasis"><em>Windows users will need to use <em class="replaceable"><code>(ENV[‘HOMEDRIVE’] + ENV[‘HOMEPATH’])</code></em> instead of <em class="replaceable"><code>ENV[‘HOME’]</code></em>. We’ll talk more about that in the Windows version of the script</em></span>.<a class="indexterm" id="idx-CHP-2-0118"/></p></div><p><code class="literal">ENV</code> is an environment variable, as the abbreviation suggests, and the parentheses indicate expression boundaries, just as in a math expression, like <code class="literal">(5 + 2) * 2 = 14</code>. <code class="literal">ENV[‘HOME’]</code> is simply a way for you to get to the directory that belongs to a specific user. For my username, <span class="emphasis"><em>kbaird</em></span>, this would be something like <code class="literal">/home/kbaird</code>, or <code class="literal">/Users/kbaird</code> under Mac OS X. The home directory is analogous to the My Documents folder in Windows.</p><p><code class="literal">ENV[‘HOME’]</code> is a String, and in our expression, we add it to the String <code class="literal">‘/scripts/sig_quotes.txt’</code>. All this means is that our filename has a default value of <code class="literal">sig_quotes.txt</code>, within the <code class="literal">scripts</code> directory, within the user’s home directory. Now we know the name of the <a class="indexterm" id="idx-CHP-2-0119"/>file to read <a class="indexterm" id="idx-CHP-2-0120"/>quotations from, so let’s use it.</p><p>Ruby creates <a class="indexterm" id="idx-CHP-2-0121"/>new external <a class="indexterm" id="idx-CHP-2-0122"/>File objects with <code class="literal">File.new()</code>, which takes two arguments: the name of the file and the manner in which you want to use that file. In this case, we want to read from the file, so at ❷ we give it a second argument of <code class="literal">‘r’</code>, which naturally stands for <span class="emphasis"><em>read</em></span>. We call this file <code class="literal">quotations_file</code> and read its lines into a variable called <code class="literal">file_lines</code>. Since we’re now done with the file, we can close it, which we do at ❸.</p><p>The new variable <code class="literal">file_lines</code> is an Array with each line of the quotations file as a single element. What do we do when we want longer quotations? We’ve taken care of that at ❹ by combining those lines into a String with our old friend the <code class="literal">to_s</code> method, and turning it back into an Array with a method called <code class="literal">split</code>, which takes a breakpoint argument to break a String into chunks. Let’s see it in action.<a class="indexterm" id="idx-CHP-2-0123"/></p><a id="I_programlisting2_d1e2028"/><pre class="programlisting">irb(main):001:0&gt; 'break at each space'.<a class="indexterm" id="idx-CHP-2-0124"/>split(' ')
=&gt; ["break", "at", "each", "space"]
irb(main):002:0&gt; 'abacab'.split('a')
=&gt; ["", "b", "c", "b"]</pre><p>In our program, we’re breaking on a double <a class="indexterm" id="idx-CHP-2-0125"/>line break, which is represented in Ruby, as in many other languages, with <code class="literal">\n\n</code>. We now have a variable called <code class="literal">quotations</code>, which is an <a class="indexterm" id="idx-CHP-2-0126"/>Array, each member of which is a quotation from our external file.</p><p>We want to choose a <a class="indexterm" id="idx-CHP-2-0127"/>random quotation, and elements of Arrays are conveniently stored with indices, so a very appropriate way to choose a random element from an Array is to generate a random number within the range of the Array’s indices, and then read the element out of the Array at that index. That’s precisely what we do at ❺ with the <code class="literal">rand</code> method, into which we pass the <code class="literal">size</code> of the quotations Array. We place the specific quotation chosen into a variable at ❻ with the apt name <code class="literal">quotation</code>.<a class="indexterm" id="idx-CHP-2-0128"/></p><p>Now that we have a quotation, what can we do with it? We want to write it out to our signature file. We usually print things with <code class="literal">puts</code>, which we used in <a class="xref" href="ch02.html#sharp1_is_it_payday_check_paydayrb" title="#1 Is It Payday? (check_payday.rb)">#1 Is It Payday? (check_payday.rb)</a> on page 14. Let’s try it out in a new irb session.</p><a id="I_programlisting2_d1e2078"/><pre class="programlisting">irb(main):001:0&gt; <a class="indexterm" id="idx-CHP-2-0129"/>puts 'Hello, World!'
Hello, World!
=&gt; nil</pre><p>You’ll notice that <code class="literal">puts</code> outputs whatever argument you give it, but the value it <span class="emphasis"><em>returns</em></span> is <code class="literal">nil</code>. It’s important to keep that distinction in mind. If you use <code class="literal">puts</code> on a file, it will print its argument to that file instead of printing to the screen. We already know that we can read from external files with a second argument of <code class="literal">‘r’</code>. Similarly, we can write to an external file with a second argument of <code class="literal">‘w’</code>, which is the way we open <code class="literal">signature_file</code> at ❼. Let’s take a look at the way <code class="literal">puts</code> behaves in irb.<a class="indexterm" id="idx-CHP-2-0130"/></p><a id="I_programlisting2_d1e2118"/><pre class="programlisting">irb(main):002:0&gt; t = File.new(ENV['HOME'] + '/test_file.txt', 'w')
=&gt; #&lt;File:0xaca10&gt;
irb(main):003:0&gt; t.puts 'Write some content'    <em class="lineannotation"><span class="lineannotation"><span class="emphasis"><em>some_file</em></span>.puts</span></em>
=&gt; nil
irb(main):004:0&gt; t.close
=&gt; nil</pre><p>The <code class="literal">puts</code> method continues to return <code class="literal">nil</code>, but take a look at a new file called <code class="literal">test_file</code> inside your home directory. It should now contain the text <span class="emphasis"><em>Write some content</em></span>, proving that <code class="literal">puts</code> can easily print to a file, as well. Note that we use a filename that means <span class="emphasis"><em>The file called .signature within the user’s home directory</em></span>, which is the traditional location for <a class="indexterm" id="idx-CHP-2-0131"/>email signature files. All that’s left is to write a standard header at ❽, add the randomly-chosen quotation, and then close the signature file.</p><p>If you use a Unix-like operating system, you can put a call to this program in a <a class="indexterm" id="idx-CHP-2-0132"/>crontab,<sup>[<a class="footnote" href="#ftn.CHP-2-FNOTE-1" id="CHP-2-FNOTE-1">8</a>]</sup> as I do on my Debian machine. Windows users can modify the script to write a signature file with whatever name they choose, and then change the settings of their <a class="indexterm" id="idx-CHP-2-0133"/>email program to use that signature file.</p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script"/>Running the Script</h2></div></div></div><p>This is run with <code class="literal">ruby -w random_sig.rb</code> (to assume the default <code class="literal">sig_quotes.txt</code> file), or <code class="literal">ruby -w random_sig.rb</code> <em class="replaceable"><code>some_file</code></em>, replacing <em class="replaceable"><code>some_file</code></em> with the name of your preferred version of <code class="literal">sig_quotes.txt</code>.<a class="indexterm" id="idx-CHP-2-0134"/><a class="indexterm" id="idx-CHP-2-0135"/></p></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id001"/>The Results</h2></div></div></div><p>Here are my results. The <code class="literal">$</code> denotes a <a class="indexterm" id="idx-CHP-2-0136"/>bash prompt on my GNU/Linux system. I add an additional <code class="literal">cat ~/.signature</code> (which just shows the contents of <code class="literal">~/.signature</code>) to show the results, since the script writes to that file instead of printing to the screen.</p><a id="I_programlisting2_d1e2217"/><pre class="programlisting">$ ruby -w random_sig.rb extras/sig_quotes.txt ; cat ~/.signature
Kevin Baird | kcbaird@world.oberlin.edu | http://kevinbaird.net/
Those who do not understand Unix are condemned to reinvent it, poorly.
$ ruby -w random_sig.rb extras/sig_quotes.txt ; cat ~/.signature
Kevin Baird | kcbaird@world.oberlin.edu | http://kevinbaird.net/
"You cannot fight against the future. Time is on our side."
- William Ewart Gladstone</pre></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script"/>Hacking the Script</h2></div></div></div><p>Take a look at the Windows source code below, and try to figure out the changes before continuing on to my explanation.</p><a id="I_programlisting2_d1e2224"/><pre class="programlisting">  #!/usr/bin/env ruby
  # <a class="indexterm" id="idx-CHP-2-0137"/>random_sig-windows.rb

❶ home = "#{ENV['HOMEDRIVE']}" + "#{ENV['HOMEPATH']}"
❷ filename = ARGV[0] || (home + '\\scripts\\sig_quotes.txt')
  quotations_file = File.new(filename, 'r')
  file_lines = quotations_file.readlines()
  quotations_file.close()
  quotations      = file_lines.to_s.split("\n\n")
  random_index    = rand(quotations.size)
  quotation       = quotations[random_index]
❸ sig_file_name   = home + '\.signature'
  signature_file  = File.new(sig_file_name, 'w')
  signature_file.puts 'Kevin Baird |   kcbaird@world.oberlin.edu |   http://
  kevinbaird.net/'
  signature_file.puts quotation
  signature_file.close()</pre><p>The only significant differences relate to the filesystem, which is how the operating system and programs access your machine’s <a class="indexterm" id="idx-CHP-2-0138"/>hard drive, <a class="indexterm" id="idx-CHP-2-0139"/>CD-ROM drive, and so on. Windows uses a separate drive letter, which is represented by <code class="literal">ENV[‘HOMEDRIVE’]</code>, and a path within that drive letter, which is represented by <code class="literal">ENV[‘HOMEPATH’]</code>. Because of the greater complexity of the Windows definition of <span class="emphasis"><em>home</em></span>, we have put it into a variable in this version of the <a class="indexterm" id="idx-CHP-2-0140"/>script at ❶. The only other differences are the use of backslashes rather than forward slashes at ❷ and ❸.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-2-FNOTE-1" id="ftn.CHP-2-FNOTE-1">8</a>] </sup>A crontab is just a way for Unix machines to schedule operations. If you use a Unix-like operating system, just execute <code class="literal">man crontab</code> at the shell. If you use Windows, you can use Windows Scheduler with a batch file.</p></div></div></div>
<div class="sect1" title="#3 The 99 Bottles of Beer Song (99bottles.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp3_the_99_bottles_of_beer_song_99bot"/>#3 The 99 Bottles of Beer Song (99bottles.rb)</h1></div></div></div><p>This script demonstrates basic Object Orientation by singing (okay, printing) the “99 Bottles of Beer” song. The content of the example may be a bit contrived, but the program itself reveals a great deal about naming conventions in Ruby. We’ll be <a class="indexterm" id="idx-CHP-2-0141"/>defining a Wall, on which there are bottles, the number of which repeatedly drops by one.</p><p>Here’s the code. Classes are the basic building blocks in Ruby, so it’s worthwhile for anyone curious about the language to understand them in some depth. We’ve already seen some built-in classes (String, Integer, and Array), so they’re not a fundamentally new concept for you at this point. What is new is the ability to define completely novel classes of your own, as we do below.<a class="indexterm" id="I_indexterm2_d1e2269"/><a class="indexterm" id="I_indexterm2_d1e2272"/><a class="indexterm" id="I_indexterm2_d1e2277"/></p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id002"/>The Code</h2></div></div></div><a id="I_programlisting2_d1e2285"/><pre class="programlisting">  #<a class="indexterm" id="idx-CHP-2-0142"/>!/usr/bin/env ruby
  # 99 bottles problem in Ruby

❶ class Wall    <em class="lineannotation"><span class="lineannotation">Classes</span></em>

❷   def initialize(num_of_bottles)    <em class="lineannotation"><span class="lineannotation">Instance Variables</span></em>
      @bottles = num_of_bottles
❸   end

  =begin rdoc
  Predicate, ends in a question mark, returns &lt;b&gt;Boolean&lt;/b&gt;.
  =end
❹   def empty?()    <em class="lineannotation"><span class="lineannotation">Predicate Methods</span></em>
      @bottles.zero?
    end

❺   def sing_one_verse!()    <em class="lineannotation"><span class="lineannotation">Destructive Methods</span></em>
      puts sing(' on the wall, ') + sing("\n") + take_one_down! + sing(" on the
  wall.\n\n")
    end

❻   private    <em class="lineannotation"><span class="lineannotation">Private Methods</span></em>

    <a class="indexterm" id="idx-CHP-2-0143"/>def sing(extra='')
❼     "#{(@bottles &gt; 0) ? @bottles : 'no more'} #{(@bottles == 1) ? 'bottle' :
  'bottles'} of beer" + extra
    end

  =begin rdoc
  Destructive method named with a bang because it decrements @bottles.
  Returns a &lt;b&gt;String&lt;/b&gt;.
  =end
❽   def take_one_down!()
      @bottles -= 1
      'take one down, pass it around, '
    end

  end</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id002"/>How It Works</h2></div></div></div><p>We define <a class="indexterm" id="idx-CHP-2-0144"/>classes using the <a class="indexterm" id="idx-CHP-2-0145"/>keyword <span class="emphasis"><em>class</em></span> followed by whatever <a class="indexterm" id="idx-CHP-2-0146"/>name we choose, which we do at ❶ for the class <code class="literal">Wall</code>. Classes must start with an uppercase letter, and it is traditional to use mixed case, as in <span class="emphasis"><em>MultiWordClassName</em></span>. Our class is called <span class="emphasis"><em>Wall</em></span>, which conjures up a real-world object in a reader’s mind. This is the wall in the song on which the bottles sit.<a class="indexterm" id="idx-CHP-2-0147"/><a class="indexterm" id="idx-CHP-2-0148"/></p><p>It is also traditional to define a class in a file with the same name by using all lowercase letters and underscores between the words, if the name consists of multiple words (i.e., <code class="literal">multi_word_class_name.rb</code>). This is just a convention, but it is a widely followed one, and if you decide to use Rails, using this convention will make your life much easier.</p><p>If our wall just sat there and did nothing, there would be little point in <a class="indexterm" id="idx-CHP-2-0149"/>creating it. We want our wall to be able to take some sort of action. These actions are methods, just like those we’ve already encountered. We’ve already defined functions with the <code class="literal">def</code> keyword. Now we’ll do so within a class—this attaches the function we’re <a class="indexterm" id="idx-CHP-2-0150"/>defining to that class, making it a <span class="emphasis"><em>method</em></span> of that class.</p><p>Every class should have a method called <code class="literal">initialize</code>, which is what that class uses when it creates itself. From the outside, we call the method <code class="literal">new</code>, but the class itself uses the name <code class="literal">initialize</code>. (We’ll talk about why that distinction exists shortly.) Our wall’s <code class="literal">initialize</code> method, defined at ❷, takes one argument called <code class="literal">num_of_bottles</code>. It then sets the value of a variable called <code class="literal">@bottles</code> equal to whatever <code class="literal">num_of_bottles</code> is. Why does <code class="literal">@bottles</code> have the <a class="indexterm" id="idx-CHP-2-0151"/>@ sign in front of it? The @ sign is how Ruby indicates that something is what’s called an <span class="emphasis"><em>instance variable</em></span>.<a class="indexterm" id="I_indexterm2_d1e2418"/></p><p>An <span class="emphasis"><em>instance variable</em></span> is just a characteristic of some thing. If we have a class called Person, each person could have characteristics like a name, an age, a gender, and so on. These characteristics are all good examples of instance variables, because they could (and do) differ from person to person. Just as a Person has an age, a Wall has a certain number of bottles on it. Our wall happens to have 99 bottles on it, because we’ve told it to have that many. Let’s try a different number of bottles in irb. You can bring <a class="indexterm" id="idx-CHP-2-0152"/>external content into an irb session with the <code class="literal">-r</code> command-line flag, which stands for <span class="emphasis"><em>require</em></span>.<a class="indexterm" id="idx-CHP-2-0153"/></p><a id="I_programlisting2_d1e2441"/><pre class="programlisting">$ irb -r 99bottles.rb
irb(main):001:0&gt; other_wall = Wall.new(10)
=&gt; #&lt;Wall:0xb2708 @bottles=10&gt;</pre><p>We can see from the returned value that <code class="literal">@bottles</code> is set to 10 in the case of our new variable, <code class="literal">other_wall</code>. Both <code class="literal">wall</code> and <code class="literal">other_wall</code> are examples (or instances) of the class Wall. They differ in key ways, such as the number of bottles they hold.</p><p>All we want to do when we create a new wall is set its number of bottles, so at ❸ we declare the end of the method after setting the value of <code class="literal">@bottles</code>. After we’ve created our wall, we’ll ask the wall if it has any bottles left. We will implement this with a method called <code class="literal">empty?</code>, which we define at ❹. Note the <a class="indexterm" id="idx-CHP-2-0154"/>question mark, which is a perfectly legitimate part of the method’s name. Ruby has inherited a tradition from its ancestor <a class="indexterm" id="idx-CHP-2-0155"/>Lisp of naming methods with a <a class="indexterm" id="idx-CHP-2-0156"/>question mark when they return either <span class="emphasis"><em>true</em></span> or <span class="emphasis"><em>false</em></span>. Such methods that only return a <a class="indexterm" id="idx-CHP-2-0157"/>Boolean are called <span class="emphasis"><em>predicates</em></span>. It should be clear that a wall is either empty or not empty, so the <code class="literal">empty?</code> method is a <a class="indexterm" id="idx-CHP-2-0158"/>predicate, since it will return either <code class="literal">true</code> or <code class="literal">false</code>.<a class="indexterm" id="idx-CHP-2-0159"/><a class="indexterm" id="idx-CHP-2-0160"/></p><p>We also include some RDoc at ❹, before the definition of the <code class="literal">empty?</code> method. The way to indicate RDoc <a class="indexterm" id="idx-CHP-2-0161"/><a class="indexterm" id="idx-CHP-2-0162"/>comments is to have the text <code class="literal">=begin rdoc</code> flush left, with no whitespace before it. Ruby will consider everything after <code class="literal">=begin rdoc</code> and before <code class="literal">=end</code>, also flush left with no preceding whitespace, to be a comment meant to be read by a human, not something to be executed. RDoc allows HTML-like tagging, as shown in the boldfaced <code class="literal">Boolean</code> in our <a class="indexterm" id="idx-CHP-2-0163"/>script. RDoc also allows a variety of other markup options, which we’ll discuss in greater detail later.<a class="indexterm" id="idx-CHP-2-0164"/><a class="indexterm" id="idx-CHP-2-0165"/></p><p>The instance variable <code class="literal">@bottles</code> is a number, represented as an instance of Integer in Ruby. Integers have a built-in method called <code class="literal">zero?</code>, which simply tells us whether or not that Integer is zero. This is an example of a predicate that was already there for us to use, and it follows the question mark naming convention. Our definition of <code class="literal">empty?</code> for the class Wall also uses <a class="indexterm" id="idx-CHP-2-0166"/>parentheses to show that it doesn’t accept any arguments. It’s often a good idea to refer to methods using <a class="indexterm" id="idx-CHP-2-0167"/>parentheses, even in cases like this where there are no arguments involved. The main reason for doing so is to make it clear that you’re dealing with a method and not a variable. Since you can define both methods and variables, and both are made of lowercase letters, the parentheses help Ruby distinguish between the two.<a class="indexterm" id="idx-CHP-2-0168"/><a class="indexterm" id="I_indexterm2_d1e2581"/></p><p>A song is made to be sung, so we want to tell the Wall how to do so. We’ll define a method at ❺ called <code class="literal">sing_one_verse!</code>. Just as <code class="literal">empty?</code> uses a question mark, <code class="literal">sing_one_verse!</code> ends with an <a class="indexterm" id="idx-CHP-2-0169"/>exclamation point (also called a <span class="emphasis"><em>bang</em></span>), which indicates that the method is destructive. <span class="emphasis"><em>Destructive</em></span> methods change the state of their object, which means that they perform some action on their object that persists after the method has been called.<a class="indexterm" id="idx-CHP-2-0170"/></p><p>The verse that <code class="literal">sing_one_verse!</code> has the responsibility to output has some internal repetition, so it only makes sense to break up that repetition and abstract it. We do this with the <code class="literal">sing</code> method, which takes an optional String argument called <code class="literal">extra</code>. This optional argument represents any additions to some boilerplate about the number of bottles remaining. The one-line <a class="indexterm" id="idx-CHP-2-0171"/>expression at ❼, inside the <code class="literal">sing</code> method, has some things we haven’t seen before.<a class="indexterm" id="idx-CHP-2-0172"/></p><p>Sometimes we want to have the <a class="indexterm" id="idx-CHP-2-0173"/>value of an expression appear inside a String. This process is called <span class="emphasis"><em>interpolation</em></span>, and Ruby does it, as we’ll show here in irb:<a class="indexterm" id="idx-CHP-2-0174"/></p><a id="I_programlisting2_d1e2650"/><pre class="programlisting">irb(main):001:0&gt; my_var = 'I am the value of my_var'    <em class="lineannotation"><span class="lineannotation">Interpolation</span></em>
=&gt; "I am the value of my_var"
irb(main):002:0&gt; "my_var = my_var"
=&gt; "my_var = my_var"
irb(main):003:0&gt; "my_var = #{my_var}"
=&gt; "my_var = I am the value of my_var"
irb(main):004:0&gt; 'my_var = #{my_var}'
=&gt; "my_var = \#{my_var}"</pre><p>When we use <a class="indexterm" id="idx-CHP-2-0175"/>double quotation marks and wrap an expression within <code class="literal">#{}</code>, the expression is evaluated before it is inserted into the String. When we use single quotation marks or omit the <code class="literal">#{}</code> wrapper, all the text simply appears literally, even if that text happens to be a valid expression, such as the name of a variable. The combination of double quotation marks and the <code class="literal">#{}</code> wrapper is a way to tell Ruby that you want interpolation to occur.<a class="indexterm" id="idx-CHP-2-0176"/></p><div class="note" title="Note"><h3 class="title"><a id="note-17"/>Note</h3><p><span class="emphasis"><em>If you want to have double quotation marks within a String that uses interpolation, you can use %Q, like this: <em class="replaceable"><code>%Q[I am an interpolating String. Call me “#{ ‘Ishmael’ }”.]</code></em>. Note that the delimiter does not have to be a bracket and could be conceivably any character. Common choices are</em></span> <em class="replaceable"><code>[</code></em>, {‘, and <em class="replaceable"><code>!</code></em><a class="indexterm" id="idx-CHP-2-0177"/>.<a class="indexterm" id="idx-CHP-2-0178"/></p></div><p>The <code class="literal">sing</code> method also does some testing based on the number of bottles left. This determines the specific output that it returns. Critical to this is the fact that we can interpolate any expression, not just variables. The first expression within the interpolation at ❼ is a test that checks if the value of <code class="literal">@bottles</code> is greater than zero. If it is, that first expression evaluates to <code class="literal">@bottles</code>, otherwise it evaluates to the String <code class="literal">‘no more’</code>. We do this with what we call the <span class="emphasis"><em>ternary operator</em></span>. Let’s look at the ternary operator a bit in irb as well.<a class="indexterm" id="idx-CHP-2-0179"/></p><a id="I_programlisting2_d1e2714"/><pre class="programlisting">irb(main):001:0&gt; true ? 'I am true' : 'I am false'    <em class="lineannotation"><span class="lineannotation">Ternary Operator</span></em>
=&gt; "I am true"
irb(main):002:0&gt; false ? 'I am true' : 'I am false'
=&gt; "I am false"</pre><p>The ternary operator examines whatever is to the left of the question mark; it evaluates to whatever immediately follows the question mark if the examined expression is true, and evaluates to whatever follows the colon otherwise. You can think of it as another way to implement flow control that is sometimes more convenient than an <code class="literal">if</code> test. The next expression at ❼ that uses a ternary evaluates to either the word <span class="emphasis"><em>bottle</em></span> or the word <span class="emphasis"><em>bottles</em></span>, as appropriate in English for the number of bottles the wall currently has. We then concatenate information that says that these are bottles of beer, rather than some other liquid, and add the <code class="literal">extra</code> argument. Since the argument defaults to the empty string, and concatenating the empty string onto something has no visible effect, we’re safe when there is no argument.</p><div class="note" title="Note"><h3 class="title"><a id="note-18"/>Note</h3><p><span class="emphasis"><em>Actually, this is just</em></span> a <span class="emphasis"><em>ternary operator. It just happens to be the most common one, and therefore, it often gets special naming treatment. It is the only built-in ternary operator in Ruby</em></span>.<a class="indexterm" id="idx-CHP-2-0180"/></p></div><p>After singing a verse, we take a bottle of beer down with <code class="literal">take_one_down!</code>, the method defined at ❽, again named with a bang. We’ve grouped together the actions of taking a bottle away and reporting that fact, which seems to make sense, conceptually. Since Ruby methods return the last expression evaluated, this method returns the String <code class="literal">‘take one down, pass it around, ’</code>, which gets incorporated into the entire verse inside <code class="literal">sing_one_verse!</code>.</p><p>We finish all of these <a class="indexterm" id="idx-CHP-2-0181"/>method definitions with the <code class="literal">end</code> keyword, and use <code class="literal">end</code> again to finish the class definition. So we’re done—except for the word <span class="emphasis"><em>private</em></span>, which we define at ❻. To see how this works, let’s open up irb again and instantiate a <a class="indexterm" id="idx-CHP-2-0182"/>new Wall.<a class="indexterm" id="idx-CHP-2-0183"/></p><a id="I_programlisting2_d1e2783"/><pre class="programlisting">$ irb -r 99bottles.rb
irb(main):001:0&gt; wall = Wall.new(99)
=&gt; #&lt;Wall:0xb7d2e628 @bottles=99&gt;
irb(main):002:0&gt; wall.sing
<a class="indexterm" id="idx-CHP-2-0184"/>NoMethodError: private method 'sing' called for #&lt;Wall:0xb7d2e628 @bottles=99&gt;
        from (irb):2
        from :0
irb(main):003:0&gt; wall.take_one_down!
<a class="indexterm" id="idx-CHP-2-0185"/>NoMethodError: private method 'take_one_down!' called for #&lt;Wall:0xb7d2e628 @bottles=99&gt;
        from (irb):3
        from :0
irb(main):004:0&gt; wall.empty?
=&gt; false</pre><p>The only class that can access methods that we’ve defined after the appearance of the word <span class="emphasis"><em>private</em></span> is the class itself. The other methods that can be accessed from the outside are called <span class="emphasis"><em>public</em></span> methods. Why the distinction? It allows us to define an interface for an <a class="indexterm" id="idx-CHP-2-0186"/>object that doesn’t change. We can mess around under the hood and change everything about how the class actually accomplishes its responsibilities, while no one outside the class has any idea that anything has changed.<a class="indexterm" id="I_indexterm2_d1e2809"/></p><p>Using classes in this way is especially useful when working on larger projects with other programmers. You can define your class, complete with <a class="indexterm" id="idx-CHP-2-0187"/>public methods that your other team members know about, and write little stub versions of those methods that return legal values with some temporary hard-coded approach. This allows your colleagues to start work on their classes, which might depend on the output of your class’ methods, even before you have written the real versions of those methods. This is very convenient.</p><p>By the way, the <code class="literal">new</code> versus <code class="literal">initialize</code> distinction we saw earlier is a <a class="indexterm" id="idx-CHP-2-0188"/>public versus private distinction. The <code class="literal">initialize</code> method is automatically private, and the (public) <code class="literal">new</code> method of any <a class="indexterm" id="idx-CHP-2-0189"/>object automatically calls the (private) <code class="literal">initialize</code> method of that same object. That’s why we create an <code class="literal">initialize</code> method when we write completely new classes.<a class="indexterm" id="idx-CHP-2-0190"/></p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id001"/>Running the Script</h2></div></div></div><p>Let’s try this one out in irb with <code class="literal">irb -r 99bottles.rb</code>. Note that this will output all 99 verses of this song, so don’t be surprised when you see it happen.<a class="indexterm" id="idx-CHP-2-0191"/></p></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id002"/>The Results</h2></div></div></div><a id="I_programlisting2_d1e2868"/><pre class="programlisting">$ irb -r 99bottles.rb
irb(main):001:0&gt; wall = Wall.new(99)
=&gt; #&lt;Wall:0xb3040 @bottles=99&gt;
irb(main):002:0&gt; wall.sing_one_verse! until wall.empty?</pre><p>Here’s a brief section of the output:</p><a id="I_programlisting2_d1e2872"/><pre class="programlisting">99 bottles of beer on the wall, 99 bottles of beer
take one down, pass it around, 98 bottles of beer on the wall.

98 bottles of beer on the wall, 98 bottles of beer
take one down, pass it around, 97 bottles of beer on the wall.

97 bottles of beer on the wall, 97 bottles of beer
take one down, pass it around, 96 bottles of beer on the wall.
...
2 bottles of beer on the wall, 2 bottles of beer
take one down, pass it around, 1 bottle of beer on the wall.

1 bottle of beer on the wall, 1 bottle of beer
take one down, pass it around, no more bottles of beer on the wall.

=&gt; nil</pre></div></div>
<div class="sect1" title="#4 Sound File Player (shuffle_play.rb)"><div class="titlepage"><div><div><h1 class="title"><a id="sharp4_sound_file_player_shuffle_playrb"/>#4 Sound File Player (shuffle_play.rb)</h1></div></div></div><p>In this script, we’ll make a program that plays <a class="indexterm" id="idx-CHP-2-0192"/>music files in a shuffled order. We explored classes in the previous example, and we’ll learn more about them here. What happens when we want to have a class that is very similar to an existing class? We have several options.<a class="indexterm" id="idx-CHP-2-0193"/><a class="indexterm" id="idx-CHP-2-0194"/></p><div class="note" title="Note"><h3 class="title"><a id="note-19"/>Note</h3><p><span class="emphasis"><em>This version is fairly Unix-centric. You can download a Windows version that uses the Winamp player at</em></span> <a class="ulink" href="http://www.nostarch.com/ruby.htm">http://www.nostarch.com/ruby.htm</a>.<a class="indexterm" id="idx-CHP-2-0195"/><a class="indexterm" id="I_indexterm2_d1e2899"/><a class="indexterm" id="I_indexterm2_d1e2902"/></p></div><p>In Ruby, we know that everything is an object, which is just another way of saying that it’s a member (or instance) of a class. We know about well-defined classes like Arrays, Strings, Integers, and so on. All of these are what we call <span class="emphasis"><em>open classes</em></span>, meaning that we can add code to existing classes. For example, we could change all of the Arrays in our programs so that they have a new method, and that change would affect any and all Arrays. We don’t have to create a new special type of Array to add this hypothetical new method.<a class="indexterm" id="idx-CHP-2-0196"/></p><div class="note" title="Note"><h3 class="title"><a id="note-20"/>Note</h3><p><span class="emphasis"><em>Old hands at Object Orientation will recognize the creation of a new type of class that is otherwise similar to an existing class as using</em></span> <a class="indexterm" id="idx-CHP-2-0197"/>inheritance. <span class="emphasis"><em>We’ll address inheritance in Ruby in a later chapter</em></span>.</p></div><p>Our shuffle player will need to deal with a list of <a class="indexterm" id="idx-CHP-2-0198"/>files. The built-in class Array is very well-suited to acting as a list of items, so we’ll base our player around an Array of files. In doing so, we’ll also add some behavior to all Arrays that will make it easier to deal with the <a class="indexterm" id="idx-CHP-2-0199"/>shuffled playback we want to implement.</p><div class="sect2" title="The Code"><div class="titlepage"><div><div><h2 class="title"><a id="the_code-id003"/>The Code</h2></div></div></div><a id="I_programlisting2_d1e2940"/><pre class="programlisting">  #!/usr/bin/env ruby
  # shuffle_play

  class Array    <em class="lineannotation"><span class="lineannotation">Open Classes</span></em>

  =begin rdoc
  Non-destructive; returns a copy of self, re-ordered randomly.
  =end
❶   def shuffle()
  sort_by { rand }    <em class="lineannotation"><span class="lineannotation">Blocks; The<strong class="userinput"><code> sort_by</code></strong> Method</span></em>
    end

  =begin rdoc
  Destructive; re-orders self randomly.
  =end
❷   def shuffle!()
      replace(shuffle)    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> replace</code></strong> Method</span></em>
    end

  =begin rdoc
  While we're here, we might as well offer a method
  for pulling out a random member of the &lt;b&gt;Array&lt;/b&gt;.
  =end
❸   def random_element()
      shuffle[0]
    end

  end # Array

  ###

  class ShufflePlayer

❹   def initialize(files)
      @files = files
    end

  =begin rdoc
  Plays a shuffled version of self with the <a class="indexterm" id="idx-CHP-2-0200"/>play_file method.
  =end
❺   def play()
      <a class="indexterm" id="idx-CHP-2-0201"/>@files.<a class="indexterm" id="idx-CHP-2-0202"/>shuffle.each do |file|    <em class="lineannotation"><span class="lineannotation">The<strong class="userinput"><code> each</code></strong> Method</span></em>
        play_file(file)
      end
    end

❻   private

  =begin rdoc
  Uses ogg123, assumes presence and appropriateness.
  =end
    def play_file(file)
❼     system("ogg123 #{file}")    <em class="lineannotation"><span class="lineannotation">The <strong class="userinput"><code>system</code></strong> Method</span></em>
    end

  end # <a class="indexterm" id="idx-CHP-2-0203"/>ShufflePlayer

  ###

❽ sp = ShufflePlayer.new(ARGV)
  sp.play()</pre></div><div class="sect2" title="How It Works"><div class="titlepage"><div><div><h2 class="title"><a id="how_it_works-id003"/>How It Works</h2></div></div></div><p>We use two different class definitions in this example: one in which we open the <a class="indexterm" id="idx-CHP-2-0204"/>Array class to add behavior to it, and another in which we create a completely novel class called <code class="literal">ShufflePlayer</code>. One key method that we add to the Array class at ❶ is <code class="literal">shuffle</code>. Arrays already have two methods that are very handy: <code class="literal">sort_by</code> and <code class="literal">rand</code>. You’ll notice that <code class="literal">sort_by</code> is followed by the opening brace character (<code class="literal">{</code>), then the <code class="literal">rand</code> method, then the closing brace (<code class="literal">}</code>). This content between the opening and closing braces is a <span class="emphasis"><em>block</em></span>, which is central to how Ruby transforms or iterates over collections of data, like Arrays (among other things). The <code class="literal">sort_by</code> method is a sorting operation that takes a block argument, which determines the manner in which the sorting should occur. By calling the <code class="literal">rand</code> method within our block, we ask our Array to sort its elements randomly, which is how Arrays accomplish the <code class="literal">shuffle</code> method after Ruby reads this method definition.<a class="indexterm" id="idx-CHP-2-0205"/></p><div class="note" title="Note"><h3 class="title"><a id="note-21"/>Note</h3><p><span class="emphasis"><em>Perlers (or JAPHs) might be interested to know that <em class="replaceable"><code>sort_by</code></em> uses a Schwartzian Transform under the hood. Also, the numbers generated by <em class="replaceable"><code>random</code></em> are technically</em></span> <a class="indexterm" id="idx-CHP-2-0206"/>pseudo-random, <span class="emphasis"><em>not truly random. The difference isn’t critical for the purposes of this script</em></span>.<a class="indexterm" id="idx-CHP-2-0207"/><a class="indexterm" id="idx-CHP-2-0208"/></p></div><p>All Arrays can now shuffle themselves in our code. This is all we need for our Array, but since this book is about informing people about Ruby as much as it is about accomplishing tasks like playing shuffled audio files, we’ll continue the discussion. Our Arrays will also be able to shuffle themselves with a method defined at ❷ called <code class="literal">shuffle!</code>, similar to but distinct from the method called <code class="literal">shuffle</code> (without the bang). You recently learned that methods with an ending bang are destructive, meaning that they change state in the calling object. We accomplish this change of state by using the <code class="literal">replace</code> method, which transforms the calling object into whatever argument it receives. The <code class="literal">shuffle</code> method returns a shuffled version of the calling Array. Since we pass that shuffled Array into the <code class="literal">replace</code> method, it is a very simple way to create a destructive method called <code class="literal">shuffle!</code>, which is precisely what we’ve done.<a class="indexterm" id="idx-CHP-2-0209"/><a class="indexterm" id="idx-CHP-2-0210"/><a class="indexterm" id="idx-CHP-2-0211"/></p><p>It’s very easy to add the <code class="literal">random_element</code> method, as well, which we <a class="indexterm" id="idx-CHP-2-0212"/>do at ❸. Since a shuffled version of an Array is in a random order (by definition), returning any member out of that shuffled Array will produce a random element. Here we return the first element, but we could return the last element, or any other element. Returning the first element is a good choice, though, because an Array with any members at all will definitely have a first member.<a class="indexterm" id="idx-CHP-2-0213"/></p><p>With a few short methods, we’ve dramatically added to the capabilities of all Arrays. We’ll make use of those capabilities within our new <code class="literal">ShufflePlayer</code> class. Since <code class="literal">ShufflePlayer</code> is a completely new class, we need to define its <code class="literal">initialize</code> method (❹), which takes an argument called <code class="literal">files</code> and assigns it into an instance variable called <code class="literal">@files</code>. If you look at ❽, near the end of the program, you see that we instantiate a new <code class="literal">ShufflePlayer</code> with <code class="literal">ARGV</code> as the files argument.<a class="indexterm" id="idx-CHP-2-0214"/><a class="indexterm" id="idx-CHP-2-0215"/></p><p>Once a <code class="literal">ShufflePlayer</code> exists, we want it to <a class="indexterm" id="idx-CHP-2-0216"/>play files in shuffled order. We <a class="indexterm" id="idx-CHP-2-0217"/>do so with the <code class="literal">play</code> method, defined at ❺. Within <code class="literal">ShufflePlayer, @files</code> is an Array of filenames. We opened up the Array class, adding the <code class="literal">shuffle</code> method to all Arrays. Therefore, <code class="literal">@files</code> can call the method <code class="literal">shuffle</code> on itself. Since it’s a public method, other objects can call <code class="literal">shuffle</code> on Arrays, as well. That’s what <code class="literal">ShufflePlayer</code> does in our example. Since the return value of the <code class="literal">shuffle</code> method is also an Array, it can also call all of the methods of an Array, including <code class="literal">shuffle</code> again. Instead of reshuffling, however, we’ll call a method called <code class="literal">each</code>, which takes a block describing what to do to or with each element of the Array.</p><p>We delimit <a class="indexterm" id="idx-CHP-2-0218"/>blocks with braces, right? Sometimes. We could have implemented our <code class="literal">play</code> method like this:</p><a id="I_programlisting2_d1e3190"/><pre class="programlisting">def play()
  @files.shuffle.each { |<a class="indexterm" id="idx-CHP-2-0219"/>file| play_file(file) }
end</pre><p>However, I chose to do it as I did to demonstrate the different ways you can use blocks in your code. Blocks can either start with <code class="literal">{</code> and end with <code class="literal">}</code>, or start with <code class="literal">do</code> and end with <code class="literal">end</code>. Different Ruby coders have different ideas about how best to notate blocks, but the convention seems to be that the brace delimiters are more appropriate for one-line blocks, and the <code class="literal">do</code> and <code class="literal">end</code> delimiters are more appropriate for multi-line blocks. This is the convention I will use in this book, and the one I use in my personal code. Ruby itself, however, doesn’t really care.</p><div class="note" title="Note"><h3 class="title"><a id="note-22"/>Note</h3><p><span class="emphasis"><em>The different ways of delineating blocks have different precedences, for those who are curious. This means that Ruby will evaluate blocks delineated with <em class="replaceable"><code>{</code></em> and <em class="replaceable"><code>}</code></em> before evaluating blocks delineated with <em class="replaceable"><code>do</code></em> and <em class="replaceable"><code>end</code></em>. This fits well with how they are commonly used</em></span>.<a class="indexterm" id="I_indexterm2_d1e3234"/></p></div><p>Note that when we call <code class="literal">each</code>, we have the word <span class="emphasis"><em>file</em></span> within two pipe characters. Ruby coders who like American football sometimes call this the <span class="emphasis"><em>goalpost</em></span>. The <span class="emphasis"><em>goalpost</em></span> just tells the code within the <code class="literal">each</code> method what each element should be called within the block. Conceptually, it resembles an argument to a method, and later in the book, we’ll blur that distinction even more. In this case, we’re asking the <code class="literal">ShufflePlayer</code> to loop through each element of <code class="literal">@files</code>, call that element <code class="literal">file</code>, and call some method called <code class="literal">play_file</code>, taking <code class="literal">file</code> as an argument.<a class="indexterm" id="idx-CHP-2-0220"/></p><p>Since we never need to call <code class="literal">play_file</code> from the outside, we can make it a private method, as shown at ❻. All <code class="literal">play_file</code> does is take an argument called <code class="literal">file</code> and use a method called <code class="literal">system</code> at ❼ in order to play that file argument using the <code class="literal">ogg123</code> program. As you might guess, <code class="literal">system</code> goes outside of Ruby and asks the operating system to do something—like play an audio file.</p><div class="note" title="Note"><h3 class="title"><a id="note-23"/>Note</h3><p><span class="emphasis"><em>I have a large number of files in Ogg Vorbis audio format, so I use the ogg123 program to play them. You can certainly replace ogg123 with mpg321 or any other command-line audio player</em></span>.<a class="indexterm" id="idx-CHP-2-0221"/></p></div><p>The <code class="literal">play_file</code> method makes several assumptions, of course. It assumes that every file it’s asked to play will be playable with <code class="literal">ogg123</code>. It assumes that a command like <code class="literal">ogg123</code> <em class="replaceable"><code>some_file_name</code></em> will be understandable by the operating system. Most glaringly, it assumes that there is a program called <code class="literal">ogg123</code> on the computer that runs this program. I wrote this program to play audio files on my computer at work, where it was safe for me to make these assumptions. This allowed the program to be much shorter, because it didn’t have to worry about checking for the existence of <code class="literal">ogg123</code>, and so on.</p></div><div class="sect2" title="Running the Script"><div class="titlepage"><div><div><h2 class="title"><a id="running_the_script-id002"/>Running the Script</h2></div></div></div><p>You run this script as either <code class="literal">ruby -w shuffle_play.rb</code> <em class="replaceable"><code>some_ogg_files</code></em> or <code class="literal">./shuffle_play.rb</code> <em class="replaceable"><code>some_ogg_files</code></em>.<a class="indexterm" id="idx-CHP-2-0222"/><a class="indexterm" id="idx-CHP-2-0223"/></p></div><div class="sect2" title="The Results"><div class="titlepage"><div><div><h2 class="title"><a id="the_results-id003"/>The Results</h2></div></div></div><p>Now that I have explained our script, let’s try it out. These examples are within a bash shell in Linux, and use the long-winded version of <code class="literal">shuffle_play.rb</code>. The specific output you’ll see will depend heavily on the files you choose to play (represented by <em class="replaceable"><code>some_ogg_files</code></em> in <a class="xref" href="ch02s04.html#running_the_script-id002" title="Running the Script">Running the Script</a> above). Since the shuffling is pseudo-random, successive runs will also probably be different, even on the same set of files.</p><a id="I_programlisting2_d1e3362"/><pre class="programlisting">$ ./shuffle_play.rb ~/Documents/Audio/<a class="indexterm" id="idx-CHP-2-0224"/>Music/Rock/<a class="indexterm" id="idx-CHP-2-0225"/>King_Crimson/Discipline/*.ogg

Audio Device: OSS audio driver output

Playing: /home/kevinb/Documents/Audio/Music/Rock/King_Crimson/Discipline/03-Matte_Kudasai.ogg
Ogg Vorbis stream: 2 channel, 44100 Hz
Title: Matte Kudasai
Artist: <a class="indexterm" id="idx-CHP-2-0226"/>King Crimson
Album: Discipline
Date: 1981
Track number: 03
Tracktotal: 07
Genre: Prog Rock
Comment: Belew, Fripp, Levin, Bruford
Comment: Belew, Fripp, Levin, Bruford
Copyright 1981 EG Records, Ltd.
Musicbrainz_albumid:
Musicbrainz_albumartistid:
Musicbrainz_artistid:
Musicbrainz_trackid:
Time: 00:05.74 [03:43.52] of 03:49.25 (164.5 kbps) Output Buffer 96.9%</pre><p>Or on another directory:</p><a id="I_programlisting2_d1e3378"/><pre class="programlisting">$ ./<a class="indexterm" id="idx-CHP-2-0227"/>shuffle_play.rb ~/Documents/Audio/<a class="indexterm" id="idx-CHP-2-0228"/>Music/Jazz/The_Respect_Sextet/
The_Full_Respect/*.ogg

Audio Device: OSS audio driver output

Playing: /home/kevinb/Documents/Audio/Music/Jazz/The_Respect_Sextet/
The_Full_Respect/08-Carrion_Luggage.ogg
Ogg Vorbis stream: 2 channel, 44100 Hz
Title: Carrion Luggage
Artist: The <a class="indexterm" id="idx-CHP-2-0229"/>Respect Sextet
Album: The Full Respect
Date: 2003
Track number: 08
Tracktotal: 18
Genre: Jazz
Composer: Red Wierenga
Copyright 2003 Roister Records
License: http://respectsextet.com/
Time: 00:20.64 [05:15.00] of 05:35.64 (151.4 kbps) Output Buffer 96.9%</pre><p>In these examples, the bash shell expands the filenames from *.ogg before it ever gets to Ruby. All of those files are the arguments to our <code class="literal">ShufflePlayer</code>, which then plays them all in shuffled order, meaning that once it’s done with one <a class="indexterm" id="idx-CHP-2-0230"/>file, it continues on to all the others without repeating any files. We’ll look at another approach to shuffled playback of audio files in two programs designed for radio station use later in the book.</p></div><div class="sect2" title="Hacking the Script"><div class="titlepage"><div><div><h2 class="title"><a id="hacking_the_script-id001"/>Hacking the Script</h2></div></div></div><p>Incidentally, if you’re interested in shorter programs, this entire program could be replaced by these two lines:</p><a id="I_programlisting2_d1e3406"/><pre class="programlisting">#!/usr/bin/env ruby
ARGV.sort_by { rand }.each { |f| system("ogg123 #{f}") }</pre><p>You could just have the second line if you always called the program as an argument to the Ruby interpreter, like</p><a id="I_programlisting2_d1e3410"/><pre class="programlisting">ruby short_shuffle.rb<em class="replaceable"><code> some_file.ogg</code></em><a class="indexterm" id="idx-CHP-2-0231"/></pre><p>I don’t think that extreme brevity at the expense of clarity is a goal to strive for, however, and I won’t be coding toward that end in this book. Brevity is particularly inappropriate for a book that means to teach people about programming, except to demonstrate alternative formats for the same functionality, as done here.</p></div></div>
<div class="sect1" title="Chapter Recap"><div class="titlepage"><div><div><h1 class="title"><a id="chapter_recap"/>Chapter Recap</h1></div></div></div><p>What was new in this chapter?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Dates</p></li><li class="listitem"><p>Constants versus magic numbers</p></li><li class="listitem"><p>Expressions with the <code class="literal">||</code> operator</p></li><li class="listitem"><p><code class="literal">ENV[‘HOME’]</code></p></li><li class="listitem"><p>External file access, both reading and writing, using <code class="literal">File.new</code></p></li><li class="listitem"><p>Splitting Strings into Arrays</p></li><li class="listitem"><p>Printing with <code class="literal">puts</code></p></li><li class="listitem"><p>Generating (pseudo-)random numbers</p></li><li class="listitem"><p>Running Ruby programs at the command line</p></li><li class="listitem"><p>Defining and instantiating new Classes</p></li><li class="listitem"><p>Instance variables: <code class="literal">@i_am_an_instance_variable</code></p></li><li class="listitem"><p>Ruby method naming conventions: predicate?, destructive!</p></li><li class="listitem"><p>Introduction to RDoc</p></li><li class="listitem"><p>Expression interpolation within Strings: <code class="literal">“#{interpolate_me}”</code></p></li><li class="listitem"><p>Ternary operator: (<code class="literal">expression ? if_true : if_false</code>)</p></li><li class="listitem"><p>Access control</p></li><li class="listitem"><p>Open classes</p></li><li class="listitem"><p>Using <code class="literal">ARGV</code></p></li><li class="listitem"><p>Using the <code class="literal">each</code> method with blocks</p></li><li class="listitem"><p>The <code class="literal">system</code> method<a class="indexterm" id="I_indexterm2_d1e3509"/><a class="indexterm" id="I_indexterm2_d1e3512"/></p></li></ul></div><p>That’s a great deal of non-trivial information. If you’re relatively new to programming, have made it this far, and feel fairly comfortable with the content up to this point, you’ve accomplished something significant and praiseworthy. Congratulations. If you’re an old hand, hopefully this chapter has given you a good idea of how Ruby does some things you’ve already done in other languages.</p></div></body></html>