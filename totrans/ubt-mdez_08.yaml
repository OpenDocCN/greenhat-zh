- en: Chapter 8. Simple Kitten Ways
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting to Know the Linux Terminal and Command Line . . . and the Cool Things
    It Can Do
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1263416.png.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Many people shy away from Linux because they envision it as a system for compu-geeks,
    an environment in which you do everything the hard way—by command line. In this
    era of graphical interfaces, the idea of typing commands to get things done seems
    like a dreadful throwback to the days of DOS, and that puts many people off, especially
    those who remember the “old days.”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: This reaction is fair enough, but it is not an accurate reflection of the reality
    of the Linux world. After all, most Linux users today utilize some sort of graphical
    interface. They can, and often do, achieve all that they hope to achieve through
    drop-down menus and mouse clicks alone. Many are able to survive quite happily
    without ever once opening their Terminal. The same could be true of you.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Be that as it may, there is still much to be said for the power and convenience
    of the command line. The fact that the command line can now be utilized within
    a graphical environment also makes it much less forbidding. The Terminal is just
    a tiny text-based island in a sea of graphical bodies (see [Figure 8-1](ch08.html#putting_the_terminal_into_perspective
    "Figure 8-1. Putting the Terminal into perspective")). Using the command line
    can be as pain-free as anything else you do on your system, and it can actually
    provide you with a little fun if you are willing to give it a try.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting the Terminal into perspective](httpatomoreillycomsourcenostarchimages1263624.png.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1. Putting the Terminal into perspective
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, many guides to using the command line are written by hard-core
    command-line junkies, whose enthusiasm for what they see as a really good thing
    inadvertently makes what they write seem even more off-putting to the recent Linux
    immigrant or wannabe.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: For your sake, I will try not to gush with enthusiasm so as not to scare you
    right back to [Chapter 6](ch06.html "Chapter 6. Rounding Out the Bird") and the
    more comfortable world of the Ubuntu Software Center. I will also try to help
    you keep things in perspective by teaching you, whenever possible, to use the
    command line as a complement or alternative to the various graphical tools that
    you have at your disposal, rather than presenting it as the sole way of going
    about things. Of course, I am not going to cover every possible angle in this
    regard—just enough to give you some exposure and experience and, ideally, make
    you feel at least a little more at ease with the command line. Who knows? You
    might actually come to think of using the command line as . . . fun? Well, I won’t
    get too carried away.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Meet the Terminal
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can run the Linux command-line Terminal application in your Ubuntu system
    by going to the Dash, typing **`terminal`**, and pressing enter. When the Terminal
    opens, it will, in all its simplicity, look much like [Figure 8-2](ch08.html#the_terminal_application
    "Figure 8-2. The Terminal application").
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![The Terminal application](httpatomoreillycomsourcenostarchimages1263626.png.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2. The Terminal application
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, all it says is `rg@mydesktop:˜$`. In this case, `rg` is my
    username, `mydesktop` is the name I gave my computer during installation, and
    the tilde (`˜`) signifies that I am in my Home folder. If it were to say `˜/Music`,
    for example, it would mean that I am currently in the *Music* folder within my
    Home folder. Of course, all this will be different in your case, because your
    username and computer name will be different. If your username is *frog* and your
    computer’s name is *wetrock*, for example, the command line will say `frog@wetrock:˜$`.
    If all this is sounding rather obtuse to you, just think of it this way: *`username`*`@`**computer_name**`:˜$`
    in the Terminal is the equivalent of your Home folder in Nautilus.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Typing in the Terminal is straightforward enough; you just type as you usually
    do. You can also delete and insert letters or phrases by using the delete and
    backspace keys and the arrow keys. For practice, try the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Type **`I like strawberries so very much`**.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change `strawberries` to `cherries`. (You’ve changed your mind!) Start by using
    your left arrow key to move the cursor in front of the first s in `strawberries`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap your delete key as many times as necessary to erase the word `strawberries`
    (that would be 12 times, methinks).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **`cherries`** and then use your right arrow key to move the cursor back
    to the end of this meaningful sentence.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that you’ve completed this fascinating bit of typing practice, press the
    enter key. As you will almost immediately see, the Terminal’s response to your
    efforts thus far is merely a dismissive `I: command not found`. Although you’ve
    typed a string of text that has meaning to you, it means absolutely nothing to
    your system. In fact, the system was so shortsighted that it could see nothing
    other than the first word you typed in the Terminal (`I`), and because `I` is
    not a valid command, the system had no idea what do to with it.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Some Goofy yet Useful Fun with the Command Terminal
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A rather cool thing about typing in the command Terminal is that it has what
    you might call *short-term memory*. Try it by typing the word **`cherry`** and
    then pressing enter. Ignoring the command-not-found message, go on and type **`vanilla`**
    and press enter. Now type **`gelato`** and press enter. So far, so dumb, right?
    Well, not really. Let’s type everything we’ve typed thus far again, but this time
    let’s do it with only one key.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Huh?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Yes, just press the up arrow key once, and what do you see? That’s right—the
    last command you typed appears, which in this case would be gelato. Press the
    up arrow key again, and the command that you typed before that will appear—`vanilla`.
    One more time? Yes, `cherry`. And one more time for the grand finale . . . `I
    like cherries so very much`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering what we have thus far, this may all seem a bit silly, but imagine
    that you’re not typing goofy little words and instead have to deal with considerably
    longer strings, such as a simple copy command (which you’ll learn about later
    in this chapter) like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By typing that string, you are copying an image called *onthebeach1_27.jpg*
    from the *coastal* folder to another folder called *stpierre*. If you wanted to
    copy another photo in the *coastal* folder, *onthebeach1_16.jpg*, for instance,
    you could simply press the up arrow key once, use the left arrow key and delete
    key to move over to and delete the `27`, and replace it with **`16`**. All in
    all, it would be much simpler and much faster. It would also help you avoid mistakes
    in typing. Not so dumb anymore, eh?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Nontoxic Commands
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you now know, all of this typing is easy enough, but to actually do something
    useful with your Terminal, you need to type commands—and there are more of them
    than you could ever hope or need to know. To get you started, we will begin with
    some commands that are easy to understand, nontoxic, and completely kitten friendly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: $ whoami
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no command as easy, safe, or even as seemingly useless as `whoami`.
    Rather than help those with multiple personality disorders discover who they are
    at any given moment, the `whoami` command simply tells you which user is currently
    logged in. Try it by typing **`whoami`** after the `$` and then pressing the enter
    key. Remember that commands are case sensitive.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The Terminal will now tell you the username of the person currently logged in.
    If you are logged in as *frog*, you should get `frog` as the answer to your command.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: $ pwd
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you know who you are but aren’t exactly sure where you are, `pwd` (print
    working directory) should come in handy. The `pwd` command tells you exactly where
    the Terminal is in your directory tree.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say, for example, that my Terminal is in my personal home directory (which
    is called *rg*) in the system’s home directory (which is called *home* and which
    is where all the user account directories are located). When I use the `pwd` command,
    I would get `/home/rg` printed to my Terminal. You should get similar results
    if you try it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The word *print*, in this case, has nothing to do with your printer; it merely
    means that the response will be printed to, or displayed in, the Terminal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: $ df
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another safe and easy, but much more useful, command is `df` (disk filesystem).
    The `df` command tells you how much disk space you have used, as well as how much
    space you still have available, on each of the partitions on your various mounted
    disks. Try it by typing **`df`** and then pressing enter. Your output should look
    something like that shown in [Figure 8-3](ch08.html#output_from_the_df_command
    "Figure 8-3. Output from the df command") (depending, of course, on the size of
    your mounted disks and how they are set up.)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Output from the df command](httpatomoreillycomsourcenostarchimages1263628.png.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3. Output from the `df` command
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: As you will notice, the sizes are given in kilobytes (KB) rather than the gigabytes
    (GB) and megabytes (MB) you are probably more used to, but there is a way around
    this. Many commands accept a *flag*, or *option*, to further fine-tune how the
    command performs. You type flags directly after the main command and precede them
    with a space and a hyphen.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you can try using the -h (human readable) flag to have your figures
    come out in the way you are most familiar with. Try this by typing **`df -h`**
    on the command line and pressing enter. The output should now appear in a more
    familiar format (see [Figure 8-4](ch08.html#output_from_the_df_command_with_the_-h_f
    "Figure 8-4. Output from the df command with the -h flag")).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Output from the df command with the -h flag](httpatomoreillycomsourcenostarchimages1263630.png.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4. Output from the `df` command with the `-h` flag
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: $ ls
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another harmless but handy command is `ls` (list directory contents). The `ls`
    command shows you what is in your current directory. This is the nongraphical
    equivalent of double-clicking a folder in Nautilus to see what is inside. Try
    it by typing **`ls`** and then pressing the enter key.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve been following *my* commands so far, your results should list all
    of the folders in your home directory. You can also use the `-R` flag to show
    not only the list of files in the folder but also what is within the subfolders.
    Of course, you might not have created any subfolders yet, so you can hold off
    experimenting with this for a while. Instead, try typing **`ls -a`** to see your
    invisible, or *hidden*, files.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: $ calendar
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ll let you experiment with this one on your own. Just type **`calendar`**
    and press enter to see the somewhat interesting results.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: $ exit
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `exit` command is a simple one that allows you to exit the Terminal. Just
    type **`exit`** and press enter. The Terminal window will close.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Commands with Some Teeth
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simple commands you have tried so far are all of the safe-and-sane, fire
    marshal-approved variety; they merely print information to your Terminal. Now
    you are going to try to get some tangible results from commands. These commands
    are also essentially safe and sane if you follow my instructions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: $ mkdir
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have already learned how to create folders by means of menus and your mouse,
    but you can also do this using the command line. The command is `mkdir` (make
    directory), and it is easy as pie to use (though I’ve never been quite sure how
    pie is easy).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: To see how this command works and to work with the commands that follow, use
    the `mkdir` command now to create a folder called *command_exp* (for command experiments).
    All you have to do is type **`mkdir command_exp`** in a new Terminal window and
    press enter. The new folder should appear in your Home folder, so go ahead and
    check to see whether it is there by clicking the home icon on your desktop.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Okay, good, *bra*, *bueno*! Now let’s create another new folder within that
    new folder—a *subfolder*, if you will. We’ll call this one *sub*. So, just type
    **`mkdir command_exp/sub`** and press enter. If you like, take a peek and see
    whether the *sub* folder has appeared within the *command_exp* folder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: $ mv
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next command is the `mv` (move) command, but before you experiment with
    it, you need to create a dummy file—you need something to move, after all. You
    can do this by using another command—`touch`. To make the file—let’s call it *expfile.txt*—go
    to the Terminal, type **`touch expfile.txt`**, and press enter. The new file will
    appear in your Home folder.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: To move the file that you’ve just created, you will use the `mv` command, of
    course. Just type **`mv expfile.txt command_exp/sub`** (this tells the system
    which file to move and where to move it to) and press enter. The file will now
    be in your *sub* folder.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: $ cd
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, you have been using the command line from your Home folder. With
    the `cd` command, you can change your Terminal’s location to another folder. You’ll
    be using this very handy command quite a lot when doing the projects in this book.
    To take it out for a spin, let’s get inside the *command_exp* folder by typing
    **`cd command_exp`** and pressing enter. If you’ve done this correctly, the prompt
    in your Terminal will now read *`username`*`@`*`computer_name`*`:˜/command_exp$`.
    If so, you can pat yourself on the back.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: While you are there, you might as well try the `ls` command with the `R` (recursive)
    flag to see how that works. Just type **`ls -R`** and press enter. Your Terminal
    should show that you have a subfolder here called *sub* and a file inside that
    subfolder called *expfile.txt*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: That is all you really want to do in there for now, so to get back to your home
    directory, just type **`cd`** and press enter, which will take you back home,
    so to speak.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: For future reference, it is worth noting a couple of other `cd` command shortcuts.
    If you are within a subfolder of a subfolder and want to move back a step (from
    */home/rg/peas/pudding* to */home/rg/peas*, for example), you can do so by typing
    **`cd ..`** (with a space between `cd` and `..`) and pressing enter. You can also
    type **`cd -`** (with a space between `cd` and `-`) in order to get back to the
    directory where you were previously (from */home/rg* to */home/rg/peas/pudding*,
    for example).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: $ cp
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might decide that not only do you want your *expfile.txt* file in the subfolder
    but you also want a copy in your home directory, where it was in the first place.
    To copy *expfile.txt*, you can use the `cp` (copy) command.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'The command needs to know where the file you want to copy is, what it is called,
    and where you want to copy it, which in this case is to your Home folder. Normally
    you would type `cp command_exp/sub/expfile.txt /home/`*`username`* to do this,
    but if you recall, you can abbreviate the `/home/`*`username`* portion of the
    command string to `˜/`, which means the same thing. (This is an important tip
    to remember, because the tilde is frequently used in online instructions.) Because
    reducing wear and tear on the fingers is always a desirable goal, type the following
    command and then press enter:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Be sure to put a space between the name of the file you are copying and its
    destination (in this case, between `expfile.txt` and `˜/`).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve done this, you should have two copies of *expfile.txt*, one in your
    Home folder and one in your *sub* folder. Go take a look to see the fruit of your
    endeavors.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: $ rm
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you were a kid, you may well have experienced the joy of building a castle
    out of LEGO bricks and then the even greater joy of tearing the whole thing down
    (preferably by hurling D cell batteries at it). You will now embark on a similar
    move. The first tool in this nostalgic endeavor is the `rm` (remove) command,
    with which you can trash files.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The `rm` command, albeit very useful and easy to use, should be handled with
    caution. Once you remove a file with this command, there is no going back. The
    file will not be placed in the Trash—it is gone for good.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: To play it safe, let’s try the rm command by getting rid of that new copy of
    *expfile.txt* that we just created in the Home folder. The basic `rm` command
    structure consists of the command itself, `rm`, followed by the name of the file
    you want to remove. In this case, you want to remove the file called *expfile.txt*
    located in your Home folder. Assuming your Terminal shows you to be home, remove
    the file by typing **`rm expfile.txt`** followed by a tap on the ol’ enter key.
    The file will then be gone, and gone for good.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Now, double your pleasure by getting rid of the version of *expfile.txt* that
    is located in the subfolder sub. In this case, you need to specify where the file
    is because it isn’t in the folder that the Terminal is in. Just type **`rm command_exp/sub/expfile.txt`**
    and then press enter. Oooh, very cool. Brings ya back, doesn’t it?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: $ rmdir
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will now continue the fun with the `rmdir` (remove directory) command, which
    is a bigger and more powerful version of the `rm` command.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: You should use the `rmdir` command, like the `rm` command, with caution. There
    are no do-overs with `rmdir`. Once you remove a directory or folder with this
    command, it is gone for good.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'To try this command, you can get rid of that *sub* folder you created. Type
    **`rmdir command_exp/sub`** and press enter. The *sub* folder should now be gone.
    Finally, to round out the fun, use the `rmdir` command once more to get rid of
    the *command_exp* folder you created earlier. You know the drill: Type **`rmdir
    command_exp`** and press enter.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: $ chmod
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 7](ch07.html "Chapter 7. A Tidy Nest"), you learned how to change
    file permissions via the Nautilus interface. This is without a doubt an easy way
    to go about such things, but sometimes it may be easier to use the command-line
    approach.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'The command for changing file permissions is `chmod` (change mode). To use
    it, just type the command followed by the permissions you want to extend to a
    file and then the location of the file itself. For example, let’s say you copied
    a JPEG file, *mybirthday.jpg*, from a CD to the *personal* subfolder within the
    *Photos* folder on your hard disk and the file is write protected. To change the
    file so that you have write permissions (meaning that you can alter the file),
    you would type the following and then press enter:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To change the permissions of all the files and subfolders (and all the files
    within those subfolders) in one fell swoop, you can add the `-R` (recursive) flag
    to the `chmod` command. The command would thus be as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The number `744`, by the way, extends read and write and execute (run) permissions
    to you, the owner, but gives read-only rights to everyone else. This is a pretty
    safe choice when in doubt. If you want to figure out permission numbers for yourself,
    it’s pretty easy. You are basically dealing with three number positions, each
    of which has eight numerical possibilities (`0`-`7`). The left slot represents
    permissions for the owner, the center slot represents permissions for the group,
    and the third slot represents permissions for others. The meanings of the numbers
    themselves are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '`7`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Read, write, and execute permissions
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '`6`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Read and write permissions
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '`5`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Read and execute permissions
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '`4`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Read-only permissions
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '`3`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Write and execute permissions
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '`2`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Write-only permissions
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '`1`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Execute-only permissions
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '`0`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: No permissions
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-5](ch08.html#the_meaning_of_permission_numbers "Figure 8-5. The meaning
    of permission numbers") points out the meaning of each of these numbers and what
    each number slot represents. In fact, if you don’t mind a bit of simple addition,
    things are even easier to understand. To start with, remember that 1 = execute,
    2 = write, and 4 = read. Add any of those numbers together, and you get the other
    permission combos. For example, 1 (execute) + 4 (read) = 5 (read and execute).
    As you can see, permissions aren’t all that complicated.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![The meaning of permission numbers](httpatomoreillycomsourcenostarchimages1263632.png.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5. The meaning of permission numbers
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Now if you’re more of a letters than numbers sort of person, you’ll be happy
    to know that there is another way to change permissions that is probably even
    easier. With this approach, you only have to deal with two groups of letters and
    the symbols `+` and `−`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'The first group consists of the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`u`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: User (owner of the file)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '`g`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Group (specified group of users)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '`o`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Others (anyone who is not the user or a member of the group)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '`a`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: All (all of the above)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'The second group consists of the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '`r`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Read
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '`w`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Write
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '`x`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Execute
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: You might already be able to figure out how this is all going to work, but I’ll
    spell it out just in case your intuition is worn out for the day. Let’s say you
    want to change the permissions of a file (*butterhaters.txt*, for example) so
    that all users on your machine can read and write to it. After opening a Terminal
    window, you can make the change by typing **`chmod a+rw butterhaters.txt`** and
    pressing enter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Oops! Just remembered that you don’t want anyone changing the content of the
    file, eh? Well, to take back the write permissions for that file, you just need
    to type **`chmod a-w butterhaters.txt`** and press enter. As you can see, the
    `+` gives permissions, while the `−` taketh away.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: That’s much simpler, you’ve got to admit.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you tried to install software from the Ubuntu Software Center in [Chapter 6](ch06.html
    "Chapter 6. Rounding Out the Bird"), you were asked to input your password. The
    reason for this, as I mentioned then, is that the Ubuntu Software Center installs
    the files it downloads in various folders throughout your system, almost all of
    which are write protected. By supplying your password, you are telling your system
    that you, as holder of the password, have the right to allow the Ubuntu Software
    Center to do that.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The command-line version of that same password-giving process is the `sudo`
    command. To perform an operation in a folder that is write protected, you would
    first type **`sudo`** and then the command you want to perform. For example, if
    you wanted to copy an icon image—let’s call it *myicon.png*—to the globally located
    and write-protected *pixmaps* folder (*/usr/share/pixmaps*), you would type **`sudo
    cp myicon.png /usr/share/pixmaps`**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: After typing a command preceded by the `sudo` command and pressing enter, you
    will be prompted for your password. Once you type your password and press enter
    again, the command will be executed. I should mention that once you input your
    password, it will stay in memory for about five minutes, so you won’t be prompted
    for your password again when using the `sudo` command within that time frame.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: $ locate
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you are familiar with the `sudo` command, let’s take it out for a
    spin by working with the `locate` command. The `locate` command is essentially
    a command-line alternative to the graphical Search tool found in the Places menu.
    Using the command is quite easy: Simply type the command followed by a space and
    the name of the file you want to find.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Before you can use this command, though, you should update the database of filenames
    that `locate` uses. This is where using the `sudo` command, along with yet another
    command, `updatedb`, comes into play. Just type **`sudo updatedb`** and press
    enter. Type your password when asked to do so—and then it will seem as though
    nothing is happening. But don’t worry. As long as the cursor in your Terminal
    is blinking, progress is being made, and when your user prompt returns, you will
    have successfully created the database file. After that, you can use the `locate`
    command.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Oh, and in the future if you think that the process seems to be taking longer
    and longer, don’t worry—it is. The more files and applications you add to your
    system, the longer it will take your system to catalog them all.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'To take this new command for a test drive, let’s look for the LibreOffice Writer
    icon, *libreoffice-writer.png*. Just type the following and press enter:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Your results should look like those in [Figure 8-6](ch08.html#the_results_of_a_locate_search
    "Figure 8-6. The results of a locate search").
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![The results of a locate search](httpatomoreillycomsourcenostarchimages1263634.png.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6. The results of a `locate` search
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: $ apt-get
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s move on to a command that might seem a bit familiar: `apt-get`. Yes,
    this command is indeed a means of controlling the powerful package download and
    installation tool, APT, which I covered in [Chapter 6](ch06.html "Chapter 6. Rounding
    Out the Bird"). Although it might not be as pleasing to use APT via the command
    line as it is via the Ubuntu Software Center, doing so can come in handy. I’ll
    cover the basics for you here.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Just for fun and to get a bit of nontoxic practice with apt-get, open a Terminal
    window, type **`apt-get moo`**, and press enter. The result of this endeavor,
    as you will see, is an example of an Easter egg ([Figure 8-7](ch08.html#discovering_an_easter_egg_via_apt-get
    "Figure 8-7. Discovering an Easter egg via apt-get")), those little snippets of
    code that programmers seem to enjoy throwing into their work for just for fun.
    They’re useless, yes, but they’re also harmless, and this one is a safe first
    step in working with `apt-get`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![Discovering an Easter egg via apt-get](httpatomoreillycomsourcenostarchimages1263636.png.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Figure 8-7. Discovering an Easter egg via `apt-get`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: To actually put the `apt-get` command to use, start by making sure to close
    any APT frontends you might have open, such as the Ubuntu Software Center. As
    I mentioned in [Chapter 6](ch06.html "Chapter 6. Rounding Out the Bird"), you
    can run only one APT tool at a time. Once the coast is clear, you should always
    start out any operations involving `apt-get` with an update of the APT database
    so that you will be downloading the newest stuff. To do this, just type the command
    **`sudo apt-get update`**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: If you want to install a single package without heading over to the Ubuntu Software
    Center, you can do so by typing **`sudo apt-get install`** **``*`package-name`*``**.
    For example, if you want to download and install the Shufflepuck game clone, Tuxpuck,
    you would type **`sudo apt-get install tuxpuck`**. If you eventually get annoyed
    with Tuxpuck after having lost one too many times, you can uninstall it by typing
    **`sudo apt-get remove tuxpuck`**.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Finally, bearing in mind all the warnings offered in [Chapter 6](ch06.html "Chapter 6. Rounding
    Out the Bird"), if you want to upgrade your entire system via the command line,
    you can do so by typing **`sudo apt-get dist-upgrade`** (but only after doing
    a **`sudo apt-get update`** first).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: $ finger
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you enjoyed discovering who you are with the `whoami` command earlier in
    this chapter, then you might enjoy finding out even more about yourself using
    the `finger` command. You can use the `finger` command in a number of ways, but
    a very simple one is finding out about a particular user. In order to try it out
    yourself, you have to install finger first, since it is no longer bundled with
    Ubuntu.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: This is an excellent chance to get some more practice with the `apt-get` command
    you just learned. Open a Terminal window, type **`sudo apt-get install finger`**,
    and press enter. Once you’ve typed your password and the installation is complete,
    you will see your Terminal prompt again and be ready to try finger out. Just type
    **`finger`** and then your username. In my case, that would be `finger rg`. Once
    you’ve typed the command, press enter and see what you get. You can see my results
    in [Figure 8-8](ch08.html#output_from_the_finger_command "Figure 8-8. Output from
    the finger command").
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![Output from the finger command](httpatomoreillycomsourcenostarchimages1263638.png.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: Figure 8-8. Output from the `finger` command
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, my login name is *rg*, my real name is Rickford Grant, my home
    directory is */home/rg*, and I am using the Bash shell for typing my commands.
    I have been logged on since Wednesday, March 21, at 10:44 Eastern Daylight Time
    (EDT), and I have no mail or plan. It doesn’t tell you my Social Security number
    or my mother’s maiden name, but it is pretty cool, don’t you think?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Shell?
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you noticed, I mentioned that the results of the `finger` command showed
    I was using the Bash shell, so you may well be wondering just what Bash is. Well,
    *Bash (Bourne Again Shell)* is one of the many shells that are used in Linux systems,
    and it’s the one that happens to come with your Ubuntu distro (and most others,
    for that matter). A *shell* is a program that interprets the commands you type
    into the Terminal and delivers them, so to speak, to your system so that it can
    act upon them. I like to think of it as a command-handling subsystem, for which
    the Terminal acts as a graphical frontend.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Plan?
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I also mentioned that the results said I had no plan, so you may also be wondering
    what that is all about. A *.plan* file is a small file kept in your Home folder
    that other users see when they use the `finger` command on you. Traditionally,
    a *.plan* file contained information about where you were going to be or what
    you were working on. These days, however, most people use them to leave odd little
    messages, quotations, or whatever, much as they do in email signatures. Take a
    look at [Figure 8-9](ch08.html#output_from_the_finger_command_with_a_pl "Figure 8-9. Output
    from the finger command with a plan") to see what happens after I add a *.plan*
    file to my Home folder.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Output from the finger command with a plan](httpatomoreillycomsourcenostarchimages1263640.png.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: Figure 8-9. Output from the `finger` command with a plan
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now see my plan, which is a quotation from Kurt Vonnegut’s *The Sirens
    of Titan* (or Al Stewart’s song by the same name, for that matter). Of course,
    you can put anything you want in your own. You will get the chance to create your
    own plan file in [Project 8A: Creating a Plan](ch08.html#project_8a_colon_creating_a_plan
    "Project 8A: Creating a Plan") in [Compressing and Extracting Compressed Single
    Files](ch08.html#compressing_and_extracting_compressed_si "Compressing and Extracting
    Compressed Single Files"), so if this seems fun to you, more fun is in store.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Other Uses of the finger Command
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before moving on, I should mention that you can also use the `finger` command
    to do a little domestic espionage of sorts. Let’s say your child, Chris, has a
    user account on your machine. Chris, who wants your permission to go to the movies,
    claims to have been hard at work on the computer all day writing a report for
    school. Having your doubts, you could type **`finger chris`** to see what the
    facts actually are. It may be a bit underhanded and rotten, but it works. It also
    works both ways; others can check up on you as well. You can try it out if you
    create a new user account in [Chapter 9](ch09.html "Chapter 9. Dressing Up the
    Bird"). Just type **`finger`**, the name of the account you’re not currently in,
    and then press enter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: You can even use the `finger` command to find out facts about people on other
    systems, providing their network’s finger service is active and you know their
    email address. Typing something like **`finger`** **``*`username@hostname.com`*``**
    would do the trick. It’s kind of cool but also kind of spooky, I suppose.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: A Couple of Other Commands You’ll Be Using Soon
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is as good a place as any to introduce two more commands that you will
    be called upon to use in this chapter and elsewhere in the book: `ln` and `tar`.
    You needn’t practice with these yet, because you will be using them very soon,
    but you might as well know what they are all about.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: $ ln
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You use the `ln` (link) command to create a link file that launches or activates
    another file located in a separate folder. This is very useful when you want to
    activate a file that is buried deep in the subfolder of a subfolder of a subfolder
    somewhere on your hard disk. The command is often used with the `-s` (symbolic)
    flag, which provides essentially the same thing as the shortcut you’ve come to
    know in Windows, or the alias on the Mac.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to use the `ln` command is to first use the `cd` command to
    change the Terminal’s location to the folder where you want to place the link.
    Then you can type the **`ln`** command on the command line, followed by the path
    of the file to which you want to link. For example, let’s say you want to put
    a link in your Home folder for a LibreOffice Writer file of your autobiography
    called *myLife.odt*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'The file is pretty well buried in a nest of subfolders deep within your Home
    folder: */home/<username>/Documents/personal/self/autobiography/myLife.odt*. To
    create the link, you would open a new Terminal window, type the following command
    string, and then press enter:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once you are finished, the link will appear in your Home folder as an icon matching
    the original file in appearance, albeit sporting an arrow to signify that it is
    a link.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: $ tar
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 7](ch07.html "Chapter 7. A Tidy Nest") you learned to create and
    extract archives, or *tarballs*, but did you know that you can also create and
    extract tarballs using the command line? The `tar` command is your key to doing
    this.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an archive, you would simply type **`tar -cvf`**, followed by the
    name the final tarball will be and then the name of the folder or file you are
    trying to archive. For example, let’s say you want to create an archive of your
    photos folder and you want to call it *pics4pals*. In this case, you would type
    the following command and then press enter:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you no doubt noticed, there are some flags after the `tar` command in that
    string. The `c` tells the tar program to *create* a new archive. The `v` tells
    the program to be *verbose* or, in other words, to tell you what it is doing in
    the Terminal as it is doing it. Finally, the `f` tells the program that what follows
    is the *file information*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: If, after creating the archive, you suddenly remember that there is one more
    file you want to add to the mix, you can use the `-r` flag to append the archive.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to add a file called *cranky.png* to the archive, you would type
    the following and then press enter:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Of course, chances are that you will be doing more tarball extracting than
    creating, so you no doubt want to know how to do that. Fortunately, the process
    is pretty similar to what you do when creating the tarball. The main difference
    is in the first flag. Rather than using the `tar` command with the `-c` flag,
    you would use it with the `-x` flag, which tells the tar program to *extract*
    the specified archive. So if you want to extract a tarball called *spicyfood.tar*,
    type the following command and press enter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What you have been doing thus far is creating and extracting archives, which
    are basically just collections of files. They are not, however, compressed. In
    fact, most tarballs you find will be compressed, and you can tell by the ending
    *tar.gz*. That *gz* means that the archive was compressed using the gzip program.
    Extracting a compressed tarball is just as easy as extracting a straight tar archive;
    all you have to do is add the `-z` flag, which tells your system to use the gzip
    program to decompress the archive. For example, if you want to extract a compressed
    tarball called *goosedown.tar.gz*, type the following command and press enter:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Well, now that you know how to decompress and extract a gzipped tarball, you
    probably want to know how to create one. This is, again, little different than
    creating the tar archive itself; you would just add the `-z` tag to tell the program
    to use gzip to compress the folder. For example, to create a compressed version
    of your *Pictures* folder, which we’ll call *tightpics.tar.gz*, you would type
    the following and press enter:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s worth mentioning at this point that you may also come across some files
    compressed with the bzip program. Such files are recognizable by some variation
    on the *.bz* or .*bz2* file extension. Dealing with these files should pose no
    problem, because the commands are almost identical to those for gzip. Just substitute
    `-j` for `-z` in the command string.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Compressing and Extracting Compressed Single Files
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to compress or decompress a single file, you don’t really need to
    use the tar program at all, since its purpose is to create archives consisting
    of several files. You can instead use the `gzip` and `gunzip` commands directly.
    For example, to compress a file called *matilda.jpg*, you would type **`gzip matilda.jpg`**
    and press enter. The *matilda.jpg* file would then become *matilda.jpg.gz*. To
    decompress the file, you would type **`gunzip matilda.jpg.gz`** and press enter,
    after which the *matilda.jpg* file would be back to normal.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: So, can you compress an archive you’ve already created with the `tar` command?
    Sure. For example, to compress the spicyfood.tar archive mentioned earlier, you
    would type **`gzip spicyfood.tar`**, and voilá—you’ve got yourself a compressed
    *spicyfood.tar.gz* archive. Pretty cool, don’t you think?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 8A: Creating a Plan'
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a bit of command experience, it’s time to get some practice
    and put all those commands to good use. In this project, you’ll create a *.plan*
    file, like the one mentioned earlier in [$ finger](ch08.html#dollar_finger "$
    finger") in [$ finger](ch08.html#dollar_finger "$ finger").
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The actual *.plan* file is a hidden file (as you can see by the dot before its
    name) and contains the plan or message that you add to it. That message will appear
    in the output of someone’s Terminal when he uses the `finger` command to find
    out more about you. You may not need such a *.plan* file, but it’s an easy enough
    way to work a bit more with commands and the Terminal itself, so let’s give it
    a try.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: To start out, you will open the Terminal-based Nano editor to create the *.plan*
    file. To do this, open a Terminal window, type **`nano .plan`** (being sure to
    put a space between `nano` and `.plan`), and press enter. Your Terminal should
    now look a bit different, as shown in [Figure 8-10](ch08.html#the_gnu_nano_editor
    "Figure 8-10. The GNU Nano editor").
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![The GNU Nano editor](httpatomoreillycomsourcenostarchimages1263642.png.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: Figure 8-10. The GNU Nano editor
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: You will now be looking at your new, and totally empty, *.plan* file within
    the Nano editor. All you have to do is type your plan or message. Once you’ve
    done that, press ctrl-X to exit the Nano editor, and it will ask you whether you
    want to save your work. You do, so type y, after which you will be presented with
    a set of save options. You have already named the file *.plan*, as you can see
    near the bottom of the screen, so all you have to do is press enter. You will
    be back at your now-familiar user prompt in the Terminal window.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: To wrap things up, change the permissions of the new *.plan* file by typing
    **`chmod 644 .plan`** in the Terminal window and then pressing enter. The *.plan*
    file should now be in your Home folder and readable (see note below) by all, so
    go on and test your work by typing **`finge`** **``*`username`*``** and pressing
    enter. The message you entered in your *.plan* file should now appear in the results
    in place of the `No Plan` you found there earlier. If you want to change the contents
    of your *.plan* file later, just follow the same steps and change the text when
    the *.plan* appears in the Nano editor.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name of the *.plan* file is preceded by a dot, which means that it is a
    hidden file. Thus, if you take a look in your Home folder, you will not be able
    to see the file unless you have checked the Show hidden and backup files box in
    the File Management Preferences window.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 8B: More Command Practice with pyWings'
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let’s get some more experience with the Terminal by installing a simple,
    and admittedly kind of silly, oracle program called pyWings (see [Figure 8-11](ch08.html#seeking_wisdom_from_pywings
    "Figure 8-11. Seeking wisdom from pyWings")). pyWings will give you cryptic guidance
    in response to whatever questions you may ask it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Seeking wisdom from pyWings](httpatomoreillycomsourcenostarchimages1263644.png.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Figure 8-11. Seeking wisdom from pyWings
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: To use pyWings, type whatever your confusion or dilemma is in the input box,
    click one of the concern icons on the left (self, another, world), click one of
    the realm icons on the right (love, work, truth), and hit the big button that
    looks like half an eye. The oracle will then tell you what it has to say. As an
    example, I asked the oracle if I would ever master barre chords on the guitar,
    and I picked *self* as my concern and *work* as the realm. [Figure 8-12](ch08.html#pywings_bestows_its_wisdom
    "Figure 8-12. pyWings bestows its wisdom.") shows the wisdom that was bestowed
    upon me.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![pyWings bestows its wisdom.](httpatomoreillycomsourcenostarchimages1263646.png.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Figure 8-12. pyWings bestows its wisdom.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the oracle told me, “The largest passion can fit in the smallest
    place,” which I will interpret as . . . well, I’m not sure how to interpret it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Hmm. I guess that’s encouraging.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: pyWings was written in a programming language called Python, which actually
    creates scripts rather than conventional programs. You will learn a little more
    about this distinction later in the chapter, but one of the differences I can
    mention right off the bat is that you don’t actually have to install pyWings;
    you are simply going to put it on your hard drive in your Home folder and run
    it from there, more or less as is.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '8B-1: Getting Ready for pyWings (Installing Tkinter)'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I mentioned, one difference between pyWings and most of the other applications
    you use is that pyWings is a Python script. To create a graphical interface for
    itself, pyWings uses a toolbox known as Tkinter, which is the de facto standard
    (though not the only) GUI toolbox for Python. Tkinter, however, no longer comes
    bundled with Ubuntu, so you will need to download and install it yourself. Fortunately,
    this is quite easily done.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Although it is possible to whip open the Ubuntu Software Center and install
    Tkinter by the simple means learned in [Chapter 6](ch06.html "Chapter 6. Rounding
    Out the Bird"), it seems more appropriate in this command line-oriented chapter
    to . . . yeah, you got it, use the command line. That said, open a Terminal window,
    type **`sudo apt-get install python-tk`**, and then press enter. When asked for
    your password, type it and then press enter. APT will search the online repositories
    and find your file, along with anything else it requires to function properly.
    Once it is ready, it will ask you whether you want to continue. You do, so type
    **`y`** and then press enter. When your username prompt reappears, you’ll know
    the job is done, and you can go on to the next step.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '8B-2: Getting pyWings'
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are just about ready to “install” pyWings, but before you do, you need to
    get it from [http://sourceforge.net/projects/pywings/](http://sourceforge.net/projects/pywings/).
    Once there, click the **Download** button, which will download the file pywings-1.1.tar.gz.
    When prompted, choose **Save File** and click **OK**. The file will be downloaded
    to your *Downloads* folder.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '8B-3: Creating a LocalApps Folder for pyWings'
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I mentioned earlier, you will be installing the pyWings program locally in
    your Home folder. Installing a program *locally* means that you are installing
    the program and all its support and data files in your Home folder. This makes
    things a bit easier, but it also means that the program will not be available
    to other users. It also means that if you’re not careful, you might inadvertently
    delete it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: To make things a bit easier and safer, you are going to create a folder in your
    Home folder in which to place pyWings and all other applications that you may
    install locally on your machine in the future. You will, logically enough, call
    the folder *LocalApps*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make the folder using a command in order to get some more practice. Go
    to the Terminal, make sure you are in your Home folder, type the following command,
    and then press enter:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '8B-4: Extracting the pyWings Tarball'
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it is time to extract the tarball. You could do this by the double-click
    method you learned in [Chapter 7](ch07.html "Chapter 7. A Tidy Nest"), but since
    you’re working with the command line here, let’s use that instead.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, you’re going to place the tarball in the same folder into which you
    extract its files. Usually this isn’t necessary because the contents of most tarballs
    are already packaged in a folder of their own. By double-clicking the tarball
    to open it in File Roller, you can see whether things are packed in a folder or
    simply as a group of files. In the case of pyWings, it is the latter, so follow
    these steps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Create a *pywings* folder by typing **`mkdir pywings`** and pressing enter.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the pyWings tarball into that folder by typing **`mv Downloads/pywings*.gz
    pywings`** and pressing enter.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see that in this step you used an asterisk (`*`) to save some wear and
    tear on your fingers. The asterisk is a wildcard character, which in this case
    told your system to move any file beginning with *`pywings`* and ending in *`.gz`*.
    Fortunately you had only one item matching those criteria.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Move to the new *pywings* folder by typing **`cd pywings`** and pressing enter.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you get down to extracting the tarball itself using the `tar` command. To
    do this, type **`tar -xzvf pywings*.gz`** and press enter.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, notice that you used the asterisk to save yourself some keystrokes, though
    you could just as well have typed **`−1.1.tar`**.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, type **`cd`** and press enter to bring the Terminal back to your Home
    folder.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '8B-5: Moving the pyWings Folder to Your LocalApps Folder'
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The extraction process is now complete. Before going on to run pyWings, however,
    let’s move it to the new *LocalApps* folder you created in [8B-3: Creating a LocalApps
    Folder for pyWings](ch08.html#b-3_colon_creating_a_localapps_folder_fo "8B-3:
    Creating a LocalApps Folder for pyWings") in [8B-2: Getting pyWings](ch08.html#b-2_colon_getting_pywings
    "8B-2: Getting pyWings"). To do this, type the following command and press enter:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '8B-6: Running pyWings'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have pyWings in place and ready for action, let’s start up the
    great oracle right now so that you can get a better perspective on how to deal
    with the aspects of life that trouble you.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Terminal, make sure you are in your home directory, type the following
    command string, and then press enter:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since *pywings.py* is a Python script, rather than an application, you are calling
    Python’s attention to that fact so that Python will know it needs to deal with
    that script. If all has gone according to plan, pyWings will soon be making you
    a wiser person.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '8B-7: Creating a Launchable Link for pyWings'
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The method of running pyWings that you’ve just used works well enough. However,
    it’s a pain to open your Terminal and type that somewhat lengthy string every
    time you want to find out what fate has in store for you. Let’s find a way to
    make things easier in the future.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: To run an application from the Terminal, you generally type the name of that
    application or, to put it more precisely, the name of that program’s executable
    file; the application’s name thus acts as a sort of command. For your system to
    recognize that command, however, the command (the executable file or a link to
    it) must be in a location where the system can find it. Whenever you run a command
    of any sort, your system checks a series of locations (most of which are *bin
    folders*, where executable files are located) to find that command.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily find out where these locations are by typing **`echo $PATH`**
    in a new Terminal window and then pressing enter. As you will see, on your Ubuntu
    system, these locations are as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '| */* |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| */usr/lib/lightdm/lightdm* |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| */usr/local/sbin* |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| */usr/local/bin* |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| */usr/sbin* |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| */usr/bin* |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| */sbin* |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| */bin* |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| */usr/games* |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: The results of the `echo $PATH` command will not appear as they do in the (easier
    to read) chart shown here but, rather, in a single line divided by colons. The
    actual output shown in the Terminal is `/usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: If the command you typed is in one of those locations, the program or script
    will run. As you no doubt know, however, pyWings is not in any of those locations.
    It is in */home/*username*/LocalApps/pyWings* and is thus, in a sense, out of
    your system’s sight.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: To remedy this situation, you could add the path of your pyWings script to the
    list of paths that the system checks for run commands so as to make the system
    aware of your new application’s existence. However, let’s try another method that
    I think is easier. What you will do is create a link to pyWings, a sort of launchable
    alias, in one of the locations your system does check for commands.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this link, you will use three commands: cd (to change directories),
    `sudo` (to give yourself write access to the destination folder), and `ln -s`
    (to create the link).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: In the Terminal, type **`cd /usr/games`** and press enter. This puts you in
    one of the folders your system searches when you enter commands.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **`sudo ln -s /home/`****``*`username`*``****`/LocalApps/pywings/pywings.py
    pywings`** and press enter. (Note that there is a space between the terms `pywings.py`
    and `pywings` at the end of that command string.)
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `pywings` at the end of that command string is the name that you are giving
    the link; the name of the link thus becomes the command you will use to run the
    application. If you type nothing, the link will be called *pywings.py*, which
    would mean three more keystrokes for you every time you wanted to start the program.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type your password when prompted to do so and then press enter.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now make your new launcher executable by changing its permissions: Type **`sudo
    chmod +x pywings`** and press enter.'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **`cd`** and press enter to return the Terminal to your Home folder.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '8B-8: Running pyWings Again'
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have created the link, you should be able to run the pyWings program
    much more easily. To try it out, quit pyWings (if it is still running), type **`pywings`**
    in the Terminal window, and press enter. Your personal pyWings oracle should appear
    again.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: You’ve managed to cut down on the number of keystrokes required to run pyWings
    from the Terminal. However, if you are really into this pyWings thing and want
    to use it often, it will probably be handiest to add a launcher to your panel,
    a drawer, or the Applications menu.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 8C: Command Practice Review with Briscola'
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to reinforce the skills you’ve put to use in the previous project,
    why not go a bit Continental and try Briscola? Briscola is a simple, yet very
    traditional, Italian card game (see [Figure 8-13](ch08.html#briscola "Figure 8-13. Briscola")),
    which is also widely played in the Adriatic areas of Croatia and Herzegovina under
    the name briškula, as well as in Spain and Mexico, where it is known as briscas.
    Unlike pyWings, which is a Python script, Briscola is a script of a different
    flavor. It’s written in a scripting language called Tcl, which uses Tk to create
    its graphical interface—the same Tk used for the pyWings interface.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Briscola](httpatomoreillycomsourcenostarchimages1263648.png.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: Figure 8-13. Briscola
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '8C-1: Getting Briscola'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are just about ready to begin “installing” Briscola, but before you do
    so, you must get it. You can get Briscola by going to the project’s home page
    at [http://www.rigacci.org/wiki/doku.php/tecnica/download/local_software](http://www.rigacci.org/wiki/doku.php/tecnica/download/local_software)
    and downloading it in the traditional manner, but since we’re working with commands,
    let’s instead get Briscola by using a new command: `wget`.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, just open a Terminal window, type the following command string,
    and press enter:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In your Terminal window, you will see `wget` in action as it connects to the
    site where Briscola is stored and then downloads the file. When it’s done, you
    will find the Briscola tarball in your Home folder.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '8C-2: Extracting the Briscola Tarball and Renaming the Briscola Folder'
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extracting the Briscola tarball is essentially the same process as that for
    pyWings. The only difference is that Briscola is already packaged within its own
    folder, so you won’t have to create a special folder for it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'You know what to do: Just open a Terminal window, type the following command,
    and press enter:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A new folder, *Briscola-4.1*, will appear in your Home folder with all the Briscola
    files in it. To make things easier to deal with in the future, let’s shorten the
    name of the folder to simply *briscola*. You already know how to do this via the
    right-click method, but this time around let’s to do it via the command line.
    You use, perhaps surprisingly, the `mv` command followed by the name of the file
    whose name you are going to change, followed by the new name of the file.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Give it a go by typing the following command and pressing enter:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '8C-3: Preparing the Briscola Script'
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most applications that come in tarball form include a README file, which includes
    information on what you need to do to install and use the application. If you
    double-click the **README** file in the *briscola* folder in the file manager,
    you will see that the “HOW TO START” section tells you to adjust the first line
    of the *briscola.tk* script to point it to your Tk shell and to adjust the second
    line of the script to point to the directory where the various Briscola files
    are located.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the adjustments as instructed in the README file, just follow these
    steps:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the Tk shell, called *Wish*, by typing **`locate wish`** in the Terminal
    window and pressing enter. Note the location on a piece of paper. You may get
    a number of locations in your search results, but the one you want is `/usr/bin/wish`.
    If you don’t see it, it’s probably because you haven’t updated the database since
    doing [Project 8B: More Command Practice with pyWings](ch08.html#project_8b_colon_more_command_practice
    "Project 8B: More Command Practice with pyWings") in [Project 8B: More Command
    Practice with pyWings](ch08.html#project_8b_colon_more_command_practice "Project
    8B: More Command Practice with pyWings"), so type **`sudo updatedb`**, press enter,
    and then try locating Wish again.'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Direct the Terminal to the *briscola* folder by typing **`cd briscola`** and
    pressing enter.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the GNU Nano editor, which we used in [Project 8A: Creating a Plan](ch08.html#project_8a_colon_creating_a_plan
    "Project 8A: Creating a Plan") in [Compressing and Extracting Compressed Single
    Files](ch08.html#compressing_and_extracting_compressed_si "Compressing and Extracting
    Compressed Single Files"), to edit the *briscola.tk* file by typing **`nano briscola.tk`**
    and pressing enter. The *briscola.tk* file will appear in the Nano editor in your
    Terminal window.'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the very first line of the *briscola.tk* file from `#!/usr/local/bin/wish`
    to **`#!/usr/bin/wish`**.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the second line, change `/usr/local/games/briscola` to **`/usr/share/games/briscola`**,
    which is where you will place Briscola in just a bit. Your editor window should
    now look like [Figure 8-14](ch08.html#configuring_briscola_with_the_gnu_nano_e
    "Figure 8-14. Configuring Briscola with the GNU Nano editor").
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Configuring Briscola with the GNU Nano editor](httpatomoreillycomsourcenostarchimages1263650.png.jpg)'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 8-14. Configuring Briscola with the GNU Nano editor
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press ctrl-X on your keyboard.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **`y`** and press enter to save your changes.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **`cd`** and press enter to return the Terminal to your Home folder.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '8C-4: Moving the Briscola Folder to a Global Location'
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You could move the *briscola* folder to the *LocalApps* folder and play the
    game from there, as you did with pyWings. But this time around, let’s do things
    a bit differently by moving the whole thing to global territory. This not only
    keeps it safe from any obsessive housekeeping tendencies you might have but also
    allows all users on the same computer to play the game. You will need to use the
    `sudo` command to do this so that you can have write access in those protected
    folders.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Just type the following command in the Terminal window and press enter:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When you are prompted for your password, type it and press enter.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '8C-5: Creating a Launchable Link for Briscola'
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though you’ve moved Briscola to a global location, you still can’t run
    it with a simple one-word command because the *briscola.tk* file is not in the
    system’s command search path. Just as you did for pyWings, you will now create
    a launchable link for Briscola to solve that problem. Here are the steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: In the Terminal, type **`cd /usr/games`** and press enter.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now create the link by typing **`sudo ln -s /usr/share/games/briscola/briscola.tk
    briscola`** and pressing enter.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **`cd`** and press enter to return the Terminal to your Home folder.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now easily run Briscola by typing **`briscola`** in the Terminal and
    pressing enter.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Can You Do the Same Thing with pyWings?
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sure. If you want to move pyWings to a global location, just follow the same
    procedure for moving the *pywings* folder and creating the link as you did for
    Briscola, making the necessary substitutions, of course. You will have to remove
    the previously created pyWings link, though, by typing the following command and
    pressing enter:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After that, move the *pywings* folder to global territory by typing **`sudo
    mv ˜/LocalApps/pywings/usr/share/games/pywings`** and pressing enter. When prompted
    for your password, type it and press enter. You can then create the launchable
    link by typing **`cd /usr/games`**, pressing enter, typing **`sudo ln -s /usr/share/games/pywings/pywings.py
    pywings`**, and pressing enter once more.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Playing Briscola
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I already mentioned, Briscola is easy—about as easy a card game as there
    is. It is a trick-taking game, which means that you put out a card and then your
    opponent puts out a card, and the one who puts out the higher point-value card
    wins the hand, or *trick*. Points are awarded on the basis of the cards involved
    in that trick. The winner of the trick then goes on to *lead* the next trick,
    meaning that the winner puts out his or her card first the next time around. When
    all the cards are played, the points for each player are tallied, and the player
    with the higher points wins. It’s even much simpler to do than it is to describe.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: If you would like a more detailed set of rules for playing Briscola (and just
    about any other card game in the world), check out [http://www.pagat.com/](http://www.pagat.com/).
    There are also great video guides out there on YouTube, including my favorite
    at [http://www.youtube.com/watch?v=jpXpMNBPN8c](http://www.youtube.com/watch?v=jpXpMNBPN8c).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 8D: Compiling and Installing Programs from Source—Xmahjongg'
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though it was far more common in earlier days, *compiling programs from source*
    seems to be a phrase you still hear more in the Linux world than in any other.
    For the beginner, just the mention of compiling a program from source seems off-putting.
    The words *compile* and *source* seem to instill a sense of foreboding in the
    heart of the new user. That certainly was the case for me, anyway.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: You can live long and prosper without ever bothering to compile anything on
    your system. You can move along quite happily with your system as is, or you can
    just install programs by means of the much more convenient Ubuntu Software Center.
    Still, once in the Linux world, you are likely to come across this installation
    method and may well become curious, especially if you move into the geekier side
    of the community.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: What Is Source?
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, it is probably a good idea to understand what *source* is so
    as to understand a bit about how a program actually metamorphoses from its primitive
    state on the programmer’s computer into an up-and-running application on your
    machine. First the programmer writes a program in a programming language. You
    have probably heard of programming languages such as BASIC or C, and there are
    many others. What the programmer actually writes with such a language is a set
    of instructions called the *source code*, or *source*. Your computer, however,
    cannot actually understand any of that source on its own. It is as if the computer
    speaks ancient Greek and the source code is all written in French.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: The various languages that programmers use are called *high-level* languages
    — they are relatively easy for programmers to read. The computer, on the other
    hand, understands only *low-level languages*, which are quite difficult for most
    mere mortal programmers to deal with. To convert the high-level language instructions
    into a low-level language, the computer needs some other program to translate.
    To put it another way, the computer needs an interpreter.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: If this translation process takes place while a program is running, the translator
    program is actually called an *interpreter*. Applications that run using an interpreter
    are usually called *scripts*. The pyWings and Briscola applications earlier in
    this chapter are examples of such script applications.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: The problem with such scripts is that they can be slower than most of the applications
    you’re familiar with—the computer must run an interpreter, interpret the source
    code, and run the application all at the same time. This is like having a French
    book translated into Greek by a live interpreter; it’s very slow indeed.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative, most programs use a compiler instead of an interpreter. A
    *compiler* translates the high-level source code into low-level *machine code*,
    or *object code*, that the computer can understand before the application is run.
    Once this translation is done, the computer never has to bother with the high-level
    instructions again; it can merely read the translated version each time it runs
    the program. This is like having a translated version of a foreign book that you
    can read any time you want. Because computers can run compiled programs without
    simultaneously using an interpreter, compiled programs run faster than scripts.
    Most applications for all operating systems are, therefore, compiled.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: The Basics
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process of compiling an application from source and then installing it
    is straightforward—a truly “one, two, three” bit of presto change-o. Basically,
    after extracting the source code from an archived file (usually in the form of
    a tarball), you would use the following commands to accomplish the task:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '**`./configure`**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: To configure a *makefile*, which provides instructions for the `make` command
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '**`make`**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: To translate the source code into object code that the computer can understand
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '**`sudo make install`**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: To give yourself write privileges in protected folders and then install the
    application
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '**`make clean`**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: To tidy up the leftovers once the process is complete (to clean up the mess)
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: I know that sounds like a lot of commands, but as I always say, just doing it
    is easier than reading it on the page, so fear not.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '8D-1: Installing the Tools You Need'
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before doing anything else, you have to get your system ready to do what you’re
    about to ask of it. Because Ubuntu is designed with the average computer user
    in mind, it does not come with the various applications and libraries you need
    to compile applications from source. Fortunately, however, everything you need
    to get the job done is available via the Ubuntu Software Center. To get ready
    for the work at hand in this chapter (and many other jobs you are likely to do
    on your own in the future), perform searches for and install the following packages:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: build-essential
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: libgtk2.0-dev
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '8D-2: Downloading and Extracting the Xmahjongg File'
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get some hands-on experience with compiling a program from source, you will
    be working with a game called Xmahjongg, which you can see in [Figure 8-15](ch08.html#the_xmahjongg_game
    "Figure 8-15. The Xmahjongg game"). If you’ve tried the version of Mahjongg that
    comes with your Ubuntu distribution, you will notice that this one is much easier
    on your eyes and is a bit more colorful (check out the project site at [http://www.lcdf.org/xmahjongg/](http://www.lcdf.org/xmahjongg/)
    to catch a glimpse of it in its full-color glory).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![The Xmahjongg game](httpatomoreillycomsourcenostarchimages1263652.png.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
- en: Figure 8-15. The Xmahjongg game
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Xmahjongg is available via the Ubuntu Software Center, so it’s not absolutely
    necessary to install it in the way you are about to, but doing so provides a perfect
    opportunity to learn how to compile a program from source. The amount of source
    code isn’t all that great, so compiling won’t take too much time, and it requires
    no tinkering.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: To get started, you will have to download the Xmahjongg source code. You can
    get this from the Xmahjongg project page at [http://www.lcdf.org/xmahjongg/](http://www.lcdf.org/xmahjongg/).
    Download the tarball *xmahjongg-3.7.tar.gz* or a newer version if there is one.
    Do not download any of the other file types available on that page.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer, you can instead download the Xmahjongg tarball by using the
    `wget` command that you learned in [8C-1: Getting Briscola](ch08.html#c-1_colon_getting_briscola
    "8C-1: Getting Briscola") in [8C-1: Getting Briscola](ch08.html#c-1_colon_getting_briscola
    "8C-1: Getting Briscola"). Just open a Terminal window, type the following command,
    and then press enter:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once you have the file on your hard disk, untar the *xmahjongg-3.7.tar.gz* file.
    You can do this either by using the command line, as you learned to do earlier
    in the chapter, or by double-clicking the file and dragging its contents into
    the appropriate folder. To make it easier for you to follow along with the directions
    I’ll be giving you, be sure to place the untarred Xmahjongg folder in your Home
    folder. Then you will be ready to roll.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Normally at this point, you would look through the folder to find some instructions
    for dealing with the package, just as you did earlier in the chapter for Briscola.
    In most source code packages, this information is included in an INSTALL file,
    like the one in the *xmahjongg-3.7* folder ([Figure 8-16](ch08.html#identifying_a_packageas_install_file
    "Figure 8-16. Identifying a package’s INSTALL file")). To read the INSTALL file,
    just double-click it, and it will open in Text Editor.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying a package’s INSTALL file](httpatomoreillycomsourcenostarchimages1263654.png.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
- en: Figure 8-16. Identifying a package’s INSTALL file
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you can simply close the INSTALL file, because it prescribes the
    same steps I list next. However, in the future, when you install other programs
    from source, you will need to follow the instructions in the INSTALL files that
    come with the source files. Fortunately, the instructions in most INSTALL files
    will match the process I am about to describe.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it may well happen that you take a look at the contents of the INSTALL
    file and start wondering what alien tongue it is written in. In cases when you
    have no idea what the INSTALL file is going on about, just look for a *configure*
    file in the package folder. If you find one, you should be able to follow the
    instructions in this project.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '8D-3: Running configure and make for Xmahjongg'
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have downloaded and untarred the Xmahjongg tarball, installation
    is pretty standard. Here’s what you need to do:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Open a Terminal window and then move into the new folder by typing **`cd xmahjongg*`**
    and pressing enter.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is sort of a setup phase that runs the configure script in the
    *xmahjongg-3.7* folder. The configure script checks what files, compilers, and
    other things it needs, and then it searches your computer to see whether those
    things are there and, if so, where. Based on this information, it writes a file
    called a *makefile*, which is a set of instructions that will tell the `make`
    command in the subsequent step how to set things up specifically for your system
    configuration.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Configure the program by typing **`./configure`** and pressing enter.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While you are running `configure`, you will see lots of odd and mysterious things
    flowing through your Terminal window; this is essentially a running account of
    what is going on, every step of the way. This can take a bit of time, but don’t
    worry. As long as the mysterious text keeps flowing and you don’t get an error
    message at the very end of the whole process, all will be well.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once `configure` has done its thing, you will see your prompt again, and you
    can go on to the translation, or *compilation*, step. The `make` command reads
    the makefile created by `configure` to see how things need to be set up on your
    machine. Then it proceeds to call on the compiler to translate the high-level
    source code into low-level, machine-readable files that can be installed in the
    subsequent step.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To perform this translation, type **`make`** and press enter.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, you will be treated to even more mysterious text flowing through the
    window and a short wait, usually a tad longer than for the `configure` process.
    Once `make` has done its job and you see your prompt again, you are ready to install
    the program.
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Up to this point, you have not changed your system in any way. All the changes
    thus far have taken place in the *xmahjongg-3.7* folder only—your system is still
    as pure as the day you started. Of course, all that is going to end right now
    when you perform the final installation step.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '8D-4: Installing and Running Xmahjongg'
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you’ve come to the last step in this part of the process, `make install`.
    Here you are telling your system to install what you have created, or *compiled*,
    in the `make` step. Note that because installation takes place in permissions-protected
    parts of your system, you will need to add `sudo` to the command string to give
    yourself administrative privileges.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: To perform the installation, type **`sudo make install`** and press enter. You
    will be prompted for your password. After you type it and press enter, the installation
    process will take place. Once your Terminal brings you back to your user prompt,
    Xmahjongg will be installed and ready to run from the Terminal. Just type **`xmahjongg`**
    and press enter.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '8D-5: Cleaning Up and/or Uninstalling Xmahjongg'
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you are done and everything seems to be working as it should, you would
    normally tidy things up in the Xmahjongg folder by getting rid of any unnecessary
    files. You can do this via the Terminal by using the cd command to go back into
    the Xmahjongg folder, typing **`make clean`**, and then pressing enter.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: If you want to uninstall Xmahjongg, open a Terminal window, go back to the Xmahjongg
    folder by using the `cd` command, type **`sudo make uninstall`**, and finally
    press enter. The routine is essentially the same for any applications installed
    in this way, though as you might imagine, uninstallation isn’t always as smooth
    a process as what I’ve just described (and it’s definitely not as easy as it is
    via the Ubuntu Software Center).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: The main reason for the uninstallation process being less than cooperative is
    that the `make uninstall` routine requires you to have kept the original project
    folder, which means you have to keep a bit of clutter you normally wouldn’t need
    to bother with. On top of this, some projects do not provide a `make uninstall`
    routine at all. This means that you have to keep track of where everything has
    been installed in your system and then remove each item using a series of `sudo
    rm` commands.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: All that aside, go ahead, have some fun, and put your command-line skills to
    the test. You’ll have something to tell your grandkids about in the future.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Terminal
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Terminal is a very simple application in terms of looks, though you can
    spice things up a bit if you’re so inclined. Not only can you change the background
    and text colors in the Terminal, but you can even display one of your favorite
    photos as a background (as shown in [Figure 8-17](ch08.html#a_terminal_window_with_customized_backgr
    "Figure 8-17. A Terminal window with customized background and font colors"))
    or make the background transparent.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '![A Terminal window with customized background and font colors](httpatomoreillycomsourcenostarchimages1263656.png.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
- en: Figure 8-17. A Terminal window with customized background and font colors
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: To change the Terminal background, right-click anywhere in the Terminal and
    select **Profiles** ▸ **Profile** Preferences. When the Editing Profile window
    appears, click the tab for the part of the profile you want to edit. For example,
    to add a background image, click the **Background** tab, select **Background image**
    ([Figure 8-18](ch08.html#customizing_the_terminal_window "Figure 8-18. Customizing
    the Terminal window")), and then navigate to the photo you want to use as your
    background by clicking the **Menu** button next to the words Image file and finding
    the file in the Select Background Image window. Once you’ve found the photo of
    your choice, click **Open**. Depending on the image you use for your background,
    you may find it rather difficult to see text once your image appears in the Terminal.
    If so, try moving the slider under the words *Shade trans*parent or image background
    in the Editing Profile window. If that still doesn’t do the trick, click the **Colors**
    tab, deselect **Use colors from system theme**, and then try some of the preset
    Foreground and Background combinations from the menu button next to the words
    *Built-in schemes*.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing the Terminal window](httpatomoreillycomsourcenostarchimages1263658.png.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
- en: Figure 8-18. Customizing the Terminal window
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: If you just want to make the background transparent, go back to the **Background**
    tab, select **Transparent background**, and drag the slider to the right. You
    can also use the slider to adjust the shading of your background image if you
    choose to go that route.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the colors in your background image or in your desktop wallpaper
    (if you’ve gone the transparent route), you may also want to change the font color
    for your Terminal to make things easier to see. To do this, click the **Colors**
    tab, deselect **Use colors from system theme**, and then make the appropriate
    font color selection.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的背景图片或桌面壁纸中的颜色（如果您选择了透明模式），您可能还希望更改终端的字体颜色以便更容易看到。为此，点击**颜色**标签，取消选择**使用系统主题颜色**，然后进行适当的字体颜色选择。
- en: Tabbed Shell Sessions in the Terminal
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终端中的标签式 shell 会话
- en: 'To wrap things up in this chapter, I thought I’d mention one particularly convenient
    feature of the GNOME Terminal: tabs. Just as you can view multiple web pages in
    one Firefox web browser window through the use of tabs, tabs in the Terminal application
    allow you to have more than one shell session running at the same time without
    having more Terminal windows open (see [Figure 8-19](ch08.html#running_multiple_shell_sessions_in_tabs
    "Figure 8-19. Running multiple shell sessions in tabs within the Terminal")).
    This reduces the amount of desktop clutter and generally makes things easier to
    deal with. You can open a new Terminal tab by clicking anywhere in the Terminal
    and selecting **Open Tab** in the pop-up menu.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章内容，我想提及 GNOME 终端的一个特别方便的功能：标签。就像您可以通过使用标签在单个 Firefox 网络浏览器窗口中查看多个网页一样，终端应用程序中的标签允许您同时运行多个
    shell 会话，而无需打开更多的终端窗口（参见[图 8-19](ch08.html#running_multiple_shell_sessions_in_tabs
    "图 8-19. 在终端中通过标签运行多个 shell 会话")). 这减少了桌面上的杂乱，通常也使得处理事情变得更加容易。您可以通过在终端中点击任何位置并选择弹出菜单中的**打开标签**来打开一个新的终端标签。
- en: '![Running multiple shell sessions in tabs within the Terminal](httpatomoreillycomsourcenostarchimages1263660.png.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![在终端中通过标签运行多个 shell 会话](httpatomoreillycomsourcenostarchimages1263660.png.jpg)'
- en: Figure 8-19. Running multiple shell sessions in tabs within the Terminal
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-19. 在终端中通过标签运行多个 shell 会话
