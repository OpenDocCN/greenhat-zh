- en: Chapter 8. Simple Kitten Ways
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 简单的小猫方式
- en: Getting to Know the Linux Terminal and Command Line . . . and the Cool Things
    It Can Do
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解Linux终端和命令行……以及它能做的酷事
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1263416.png.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1263416.png.jpg)'
- en: Many people shy away from Linux because they envision it as a system for compu-geeks,
    an environment in which you do everything the hard way—by command line. In this
    era of graphical interfaces, the idea of typing commands to get things done seems
    like a dreadful throwback to the days of DOS, and that puts many people off, especially
    those who remember the “old days.”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人避开Linux，因为他们将其视为一个为电脑极客设计的系统，一个你必须通过命令行以艰难方式做所有事情的环境。在这个图形界面的时代，通过输入命令来完成事情的想法似乎是对DOS时代的可怕回归，这让许多人望而却步，尤其是那些记得“旧日子”的人。
- en: This reaction is fair enough, but it is not an accurate reflection of the reality
    of the Linux world. After all, most Linux users today utilize some sort of graphical
    interface. They can, and often do, achieve all that they hope to achieve through
    drop-down menus and mouse clicks alone. Many are able to survive quite happily
    without ever once opening their Terminal. The same could be true of you.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个反应还算公平，但它并不能准确反映Linux世界的现实。毕竟，如今的大多数Linux用户都在使用某种图形界面。他们可以，而且经常只通过下拉菜单和鼠标点击就能实现他们希望实现的一切。许多人能够非常快乐地生活，从未打开过他们的终端。对你来说可能也是如此。
- en: Be that as it may, there is still much to be said for the power and convenience
    of the command line. The fact that the command line can now be utilized within
    a graphical environment also makes it much less forbidding. The Terminal is just
    a tiny text-based island in a sea of graphical bodies (see [Figure 8-1](ch08.html#putting_the_terminal_into_perspective
    "Figure 8-1. Putting the Terminal into perspective")). Using the command line
    can be as pain-free as anything else you do on your system, and it can actually
    provide you with a little fun if you are willing to give it a try.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，命令行的强大和便利性仍有可说。命令行现在可以在图形环境中使用，这也使得它不那么令人畏惧。终端只是图形海洋中的一个微小的基于文本的岛屿（参见[图8-1](ch08.html#putting_the_terminal_into_perspective
    "图8-1. 将终端置于正确的视角")）。使用命令行可以像你在系统上做的任何其他事情一样不痛苦，而且如果你愿意尝试，它实际上可以给你带来一些乐趣。
- en: '![Putting the Terminal into perspective](httpatomoreillycomsourcenostarchimages1263624.png.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![将终端置于正确的视角](httpatomoreillycomsourcenostarchimages1263624.png.jpg)'
- en: Figure 8-1. Putting the Terminal into perspective
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-1. 将终端置于正确的视角
- en: Unfortunately, many guides to using the command line are written by hard-core
    command-line junkies, whose enthusiasm for what they see as a really good thing
    inadvertently makes what they write seem even more off-putting to the recent Linux
    immigrant or wannabe.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多关于使用命令行的指南都是由那些狂热的命令行爱好者所写，他们对他们认为的好事的热情无意中使得他们所写的内容对最近加入Linux的新手或想成为Linux用户的人来说更加令人望而却步。
- en: For your sake, I will try not to gush with enthusiasm so as not to scare you
    right back to [Chapter 6](ch06.html "Chapter 6. Rounding Out the Bird") and the
    more comfortable world of the Ubuntu Software Center. I will also try to help
    you keep things in perspective by teaching you, whenever possible, to use the
    command line as a complement or alternative to the various graphical tools that
    you have at your disposal, rather than presenting it as the sole way of going
    about things. Of course, I am not going to cover every possible angle in this
    regard—just enough to give you some exposure and experience and, ideally, make
    you feel at least a little more at ease with the command line. Who knows? You
    might actually come to think of using the command line as . . . fun? Well, I won’t
    get too carried away.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了你的利益，我会尽量不表现出过度的热情，以免让你再次退缩到[第6章](ch06.html "第6章. 完善鸟类")和更舒适的Ubuntu软件中心的世界。我还会尽量通过尽可能教你使用命令行作为你拥有的各种图形工具的补充或替代品，而不是将其作为做事的唯一方式。当然，我并不会涵盖这个方面的每一个可能的角度——只是足够让你有所接触和经验，并理想情况下让你对命令行至少感到稍微自在一些。谁知道呢？你可能会真的开始认为使用命令行是……有趣的？好吧，我不会太过分。
- en: Meet the Terminal
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认识终端
- en: You can run the Linux command-line Terminal application in your Ubuntu system
    by going to the Dash, typing **`terminal`**, and pressing enter. When the Terminal
    opens, it will, in all its simplicity, look much like [Figure 8-2](ch08.html#the_terminal_application
    "Figure 8-2. The Terminal application").
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过前往 Dash，输入 **`terminal`** 并按回车键，在您的 Ubuntu 系统中运行 Linux 命令行终端应用程序。当终端打开时，它将以其简洁的方式，看起来与
    [图8-2](ch08.html#the_terminal_application "图8-2. 终端应用程序") 非常相似。
- en: '![The Terminal application](httpatomoreillycomsourcenostarchimages1263626.png.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![终端应用程序](httpatomoreillycomsourcenostarchimages1263626.png.jpg)'
- en: Figure 8-2. The Terminal application
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-2. 终端应用程序
- en: 'As you can see, all it says is `rg@mydesktop:˜$`. In this case, `rg` is my
    username, `mydesktop` is the name I gave my computer during installation, and
    the tilde (`˜`) signifies that I am in my Home folder. If it were to say `˜/Music`,
    for example, it would mean that I am currently in the *Music* folder within my
    Home folder. Of course, all this will be different in your case, because your
    username and computer name will be different. If your username is *frog* and your
    computer’s name is *wetrock*, for example, the command line will say `frog@wetrock:˜$`.
    If all this is sounding rather obtuse to you, just think of it this way: *`username`*`@`**computer_name**`:˜$`
    in the Terminal is the equivalent of your Home folder in Nautilus.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它只显示 `rg@mydesktop:˜$`。在这种情况下，`rg` 是我的用户名，`mydesktop` 是我在安装时给我的电脑起的名字，波浪号
    (`˜`) 表示我正在我的主文件夹中。如果它显示 `˜/Music`，例如，这意味着我目前在我的主文件夹中的 *Music* 文件夹中。当然，所有这些都将因人而异，因为您的用户名和电脑名将不同。例如，如果您的用户名是
    *frog*，而您的电脑名是 *wetrock*，那么命令行将显示 `frog@wetrock:˜$`。如果这一切听起来相当晦涩难懂，就想想这样：在终端中的
    `*username*``@`**computer_name**`:˜$` 等同于在 Nautilus 中的您的 Home 文件夹。
- en: 'Typing in the Terminal is straightforward enough; you just type as you usually
    do. You can also delete and insert letters or phrases by using the delete and
    backspace keys and the arrow keys. For practice, try the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中打字很简单；您只需像平时一样打字。您还可以通过使用删除键、退格键和箭头键来删除和插入字母或短语。为了练习，请尝试以下操作：
- en: Type **`I like strawberries so very much`**.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 **`I like strawberries so very much`**。
- en: Change `strawberries` to `cherries`. (You’ve changed your mind!) Start by using
    your left arrow key to move the cursor in front of the first s in `strawberries`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `strawberries` 改为 `cherries`。（您改变了主意！）首先，使用您的左箭头键将光标移到 `strawberries` 中第一个
    s 前面。
- en: Tap your delete key as many times as necessary to erase the word `strawberries`
    (that would be 12 times, methinks).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下删除键，直到删除单词 `strawberries`（我想应该是12次）。
- en: Type **`cherries`** and then use your right arrow key to move the cursor back
    to the end of this meaningful sentence.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 **`cherries`**，然后使用您的右箭头键将光标移回这个有意义的句子的末尾。
- en: 'Now that you’ve completed this fascinating bit of typing practice, press the
    enter key. As you will almost immediately see, the Terminal’s response to your
    efforts thus far is merely a dismissive `I: command not found`. Although you’ve
    typed a string of text that has meaning to you, it means absolutely nothing to
    your system. In fact, the system was so shortsighted that it could see nothing
    other than the first word you typed in the Terminal (`I`), and because `I` is
    not a valid command, the system had no idea what do to with it.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '现在您已经完成了这个有趣的打字练习，请按回车键。您几乎会立即看到，终端对您迄今为止所做努力的回应只是一个轻蔑的 `I: 命令未找到`。尽管您输入了一串对您有意义的文本，但对您的系统来说，这毫无意义。事实上，系统如此短视，以至于它只能看到您在终端中输入的第一个单词（`I`），因为
    `I` 不是一个有效的命令，所以系统不知道该如何处理它。'
- en: Some Goofy yet Useful Fun with the Command Terminal
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些关于命令终端的有趣而实用的乐趣
- en: A rather cool thing about typing in the command Terminal is that it has what
    you might call *short-term memory*. Try it by typing the word **`cherry`** and
    then pressing enter. Ignoring the command-not-found message, go on and type **`vanilla`**
    and press enter. Now type **`gelato`** and press enter. So far, so dumb, right?
    Well, not really. Let’s type everything we’ve typed thus far again, but this time
    let’s do it with only one key.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令终端中打字的一个相当酷的事情是它有您可能称之为 *短期记忆* 的功能。通过输入单词 **`cherry`** 并按回车键来尝试它。忽略命令未找到的消息，继续输入
    **`vanilla`** 并按回车键。现在输入 **`gelato`** 并按回车键。到目前为止，这一切看起来都很愚蠢，对吧？但实际上并非如此。让我们再次输入我们迄今为止输入的所有内容，但这次我们只使用一个键。
- en: Huh?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 哎？
- en: Yes, just press the up arrow key once, and what do you see? That’s right—the
    last command you typed appears, which in this case would be gelato. Press the
    up arrow key again, and the command that you typed before that will appear—`vanilla`.
    One more time? Yes, `cherry`. And one more time for the grand finale . . . `I
    like cherries so very much`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，只需按一次上箭头键，你看到了什么？没错——你最后输入的命令出现了，在这个例子中就是gelato。再按一次上箭头键，就会出现你之前输入的命令——`vanilla`。再来一次？是的，`cherry`。再来一次，作为压轴戏……`I
    like cherries so very much`。
- en: 'Considering what we have thus far, this may all seem a bit silly, but imagine
    that you’re not typing goofy little words and instead have to deal with considerably
    longer strings, such as a simple copy command (which you’ll learn about later
    in this chapter) like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到目前为止我们所学的，这一切可能看起来有点愚蠢，但想象一下，你不是在输入这些古怪的小词，而是必须处理相当长的字符串，比如一个简单的复制命令（你将在本章后面学到）如下：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By typing that string, you are copying an image called *onthebeach1_27.jpg*
    from the *coastal* folder to another folder called *stpierre*. If you wanted to
    copy another photo in the *coastal* folder, *onthebeach1_16.jpg*, for instance,
    you could simply press the up arrow key once, use the left arrow key and delete
    key to move over to and delete the `27`, and replace it with **`16`**. All in
    all, it would be much simpler and much faster. It would also help you avoid mistakes
    in typing. Not so dumb anymore, eh?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入那个字符串，你正在将名为*onthebeach1_27.jpg*的图片从*coastal*文件夹复制到另一个名为*stpierre*的文件夹中。如果你想复制*coastal*文件夹中的另一张照片，比如*onthebeach1_16.jpg*，你只需简单地按一次上箭头键，使用左箭头键和删除键移动到并删除`27`，然后替换为**`16`**。总的来说，这将简单得多，也快得多。这也有助于你避免输入错误。不再那么笨拙，对吧？
- en: Nontoxic Commands
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无毒命令
- en: As you now know, all of this typing is easy enough, but to actually do something
    useful with your Terminal, you need to type commands—and there are more of them
    than you could ever hope or need to know. To get you started, we will begin with
    some commands that are easy to understand, nontoxic, and completely kitten friendly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，所有这些输入都足够简单，但为了真正在终端中做些有用的事情，你需要输入命令——而且命令的数量比你希望或需要知道的要多。为了让你开始，我们将从一些容易理解、无毒且完全适合猫咪友好的命令开始。
- en: $ whoami
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$ whoami`'
- en: There is no command as easy, safe, or even as seemingly useless as `whoami`.
    Rather than help those with multiple personality disorders discover who they are
    at any given moment, the `whoami` command simply tells you which user is currently
    logged in. Try it by typing **`whoami`** after the `$` and then pressing the enter
    key. Remember that commands are case sensitive.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何命令比`whoami`更容易、更安全，甚至看起来更无用的了。`whoami`命令并不是帮助那些有多重人格障碍的人在任何时刻发现自己是谁，它只是简单地告诉你当前登录的用户是谁。尝试在`$`之后输入**`whoami`**并按回车键。记住，命令是区分大小写的。
- en: The Terminal will now tell you the username of the person currently logged in.
    If you are logged in as *frog*, you should get `frog` as the answer to your command.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 终端现在会告诉你当前登录的人的用户名。如果你以*frog*登录，你应该得到`frog`作为你命令的答案。
- en: $ pwd
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$ pwd`'
- en: If you know who you are but aren’t exactly sure where you are, `pwd` (print
    working directory) should come in handy. The `pwd` command tells you exactly where
    the Terminal is in your directory tree.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你是谁，但不确定你在哪里，`pwd`（打印工作目录）应该会很有用。`pwd`命令会告诉你终端在你的目录树中的确切位置。
- en: Let’s say, for example, that my Terminal is in my personal home directory (which
    is called *rg*) in the system’s home directory (which is called *home* and which
    is where all the user account directories are located). When I use the `pwd` command,
    I would get `/home/rg` printed to my Terminal. You should get similar results
    if you try it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，我的终端在我的个人主目录（称为*rg*）中，在系统的主目录（称为*home*，所有用户账户目录都位于此处）。当我使用`pwd`命令时，我会在终端上打印出`/home/rg`。如果你尝试它，你应该得到类似的结果。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The word *print*, in this case, has nothing to do with your printer; it merely
    means that the response will be printed to, or displayed in, the Terminal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，单词*print*与你的打印机无关；它仅仅意味着响应将被打印到，或在终端中显示。
- en: $ df
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$ df`'
- en: Another safe and easy, but much more useful, command is `df` (disk filesystem).
    The `df` command tells you how much disk space you have used, as well as how much
    space you still have available, on each of the partitions on your various mounted
    disks. Try it by typing **`df`** and then pressing enter. Your output should look
    something like that shown in [Figure 8-3](ch08.html#output_from_the_df_command
    "Figure 8-3. Output from the df command") (depending, of course, on the size of
    your mounted disks and how they are set up.)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个安全且简单，但非常有用的命令是 `df`（磁盘文件系统）。`df` 命令会告诉你你在各个挂载的磁盘分区上使用了多少磁盘空间，以及你还剩下多少可用空间。尝试键入
    **`df`** 并按回车键。你的输出应该看起来像 [图 8-3](ch08.html#output_from_the_df_command "图 8-3.
    `df` 命令的输出") 中所示的那样（当然，这取决于你挂载的磁盘大小和它们的设置。）
- en: '![Output from the df command](httpatomoreillycomsourcenostarchimages1263628.png.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![使用 `-h` 标志的 `df` 命令输出](httpatomoreillycomsourcenostarchimages1263628.png.jpg)'
- en: Figure 8-3. Output from the `df` command
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3. `df` 命令的输出
- en: As you will notice, the sizes are given in kilobytes (KB) rather than the gigabytes
    (GB) and megabytes (MB) you are probably more used to, but there is a way around
    this. Many commands accept a *flag*, or *option*, to further fine-tune how the
    command performs. You type flags directly after the main command and precede them
    with a space and a hyphen.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，大小是以千字节（KB）而不是你更熟悉的千兆字节（GB）和兆字节（MB）来表示的，但有一个解决办法。许多命令接受一个 *标志* 或 *选项*
    来进一步微调命令的执行方式。你直接在主命令后键入标志，并在它们前面加上一个空格和一个连字符。
- en: In this case, you can try using the -h (human readable) flag to have your figures
    come out in the way you are most familiar with. Try this by typing **`df -h`**
    on the command line and pressing enter. The output should now appear in a more
    familiar format (see [Figure 8-4](ch08.html#output_from_the_df_command_with_the_-h_f
    "Figure 8-4. Output from the df command with the -h flag")).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以尝试使用 `-h`（人类可读）标志，让你的数字以你最熟悉的方式显示。尝试在命令行中键入 **`df -h`** 并按回车键。现在输出应该以更熟悉的形式出现（见
    [图 8-4](ch08.html#output_from_the_df_command_with_the_-h_f "图 8-4. 使用 `-h` 标志的
    `df` 命令输出")）。
- en: '![Output from the df command with the -h flag](httpatomoreillycomsourcenostarchimages1263630.png.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![使用 `-h` 标志的 `df` 命令输出](httpatomoreillycomsourcenostarchimages1263630.png.jpg)'
- en: Figure 8-4. Output from the `df` command with the `-h` flag
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-4. 使用 `-h` 标志的 `df` 命令输出
- en: $ ls
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ ls
- en: Another harmless but handy command is `ls` (list directory contents). The `ls`
    command shows you what is in your current directory. This is the nongraphical
    equivalent of double-clicking a folder in Nautilus to see what is inside. Try
    it by typing **`ls`** and then pressing the enter key.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个无害但实用的命令是 `ls`（列出目录内容）。`ls` 命令显示你当前目录中的内容。这是在 Nautilus 中双击文件夹以查看其内容的非图形等效操作。尝试键入
    **`ls`** 并按回车键。
- en: If you’ve been following *my* commands so far, your results should list all
    of the folders in your home directory. You can also use the `-R` flag to show
    not only the list of files in the folder but also what is within the subfolders.
    Of course, you might not have created any subfolders yet, so you can hold off
    experimenting with this for a while. Instead, try typing **`ls -a`** to see your
    invisible, or *hidden*, files.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直按照 *我的* 命令操作，你的结果应该会列出你主目录中的所有文件夹。你也可以使用 `-R` 标志来显示文件夹中的文件列表，以及子文件夹中的内容。当然，你可能还没有创建任何子文件夹，所以你可以暂时不尝试这个命令。相反，尝试键入
    **`ls -a`** 来查看你的不可见或 *隐藏* 文件。
- en: $ calendar
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ calendar
- en: I’ll let you experiment with this one on your own. Just type **`calendar`**
    and press enter to see the somewhat interesting results.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我会让你自己尝试这个命令。只需键入 **`calendar`** 并按回车键，就可以看到一些有趣的结果。
- en: $ exit
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ exit
- en: The `exit` command is a simple one that allows you to exit the Terminal. Just
    type **`exit`** and press enter. The Terminal window will close.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit` 命令是一个简单的命令，允许你退出终端。只需键入 **`exit`** 并按回车键。终端窗口将关闭。'
- en: Commands with Some Teeth
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有“牙齿”的命令
- en: The simple commands you have tried so far are all of the safe-and-sane, fire
    marshal-approved variety; they merely print information to your Terminal. Now
    you are going to try to get some tangible results from commands. These commands
    are also essentially safe and sane if you follow my instructions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止尝试的简单命令都是安全且理智的，消防队长批准的类型；它们只是将信息打印到你的终端。现在你将尝试从命令中获得一些有形的结果。如果你遵循我的指示，这些命令基本上也是安全且理智的。
- en: $ mkdir
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ mkdir
- en: You have already learned how to create folders by means of menus and your mouse,
    but you can also do this using the command line. The command is `mkdir` (make
    directory), and it is easy as pie to use (though I’ve never been quite sure how
    pie is easy).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何通过菜单和鼠标创建文件夹，但你也可以使用命令行来完成这项操作。命令是 `mkdir`（创建目录），使用起来就像吃派一样简单（尽管我从未完全明白派为什么会这么简单）。
- en: To see how this command works and to work with the commands that follow, use
    the `mkdir` command now to create a folder called *command_exp* (for command experiments).
    All you have to do is type **`mkdir command_exp`** in a new Terminal window and
    press enter. The new folder should appear in your Home folder, so go ahead and
    check to see whether it is there by clicking the home icon on your desktop.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这个命令的工作原理以及与后续命令一起工作，现在使用 `mkdir` 命令创建一个名为 *command_exp* 的文件夹（用于命令实验）。你只需要在一个新的终端窗口中输入
    **`mkdir command_exp`** 然后按回车键。新文件夹应该出现在你的主文件夹中，所以你可以点击桌面上的主图标来检查它是否在那里。
- en: Okay, good, *bra*, *bueno*! Now let’s create another new folder within that
    new folder—a *subfolder*, if you will. We’ll call this one *sub*. So, just type
    **`mkdir command_exp/sub`** and press enter. If you like, take a peek and see
    whether the *sub* folder has appeared within the *command_exp* folder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，很好，*bra*，*bueno*！现在让我们在那个新文件夹内创建另一个新的文件夹——一个 *subfolder*，如果你愿意。我们将称这个为 *sub*。所以，只需输入
    **`mkdir command_exp/sub`** 然后按回车键。如果你愿意，可以查看 *sub* 文件夹是否已经出现在 *command_exp* 文件夹中。
- en: $ mv
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ mv
- en: The next command is the `mv` (move) command, but before you experiment with
    it, you need to create a dummy file—you need something to move, after all. You
    can do this by using another command—`touch`. To make the file—let’s call it *expfile.txt*—go
    to the Terminal, type **`touch expfile.txt`**, and press enter. The new file will
    appear in your Home folder.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令是 `mv`（移动）命令，但在你尝试它之前，你需要创建一个虚拟文件——毕竟你需要一些东西来移动。你可以通过使用另一个命令——`touch` 来做到这一点。为了创建文件——让我们称它为
    *expfile.txt*——转到终端，输入 **`touch expfile.txt`**，然后按回车键。新文件将出现在你的主文件夹中。
- en: To move the file that you’ve just created, you will use the `mv` command, of
    course. Just type **`mv expfile.txt command_exp/sub`** (this tells the system
    which file to move and where to move it to) and press enter. The file will now
    be in your *sub* folder.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动你刚刚创建的文件，你将使用 `mv` 命令，当然。只需输入 **`mv expfile.txt command_exp/sub`**（这告诉系统要移动哪个文件以及移动到哪个位置）然后按回车键。现在文件将位于你的
    *sub* 文件夹中。
- en: $ cd
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ cd
- en: Until now, you have been using the command line from your Home folder. With
    the `cd` command, you can change your Terminal’s location to another folder. You’ll
    be using this very handy command quite a lot when doing the projects in this book.
    To take it out for a spin, let’s get inside the *command_exp* folder by typing
    **`cd command_exp`** and pressing enter. If you’ve done this correctly, the prompt
    in your Terminal will now read *`username`*`@`*`computer_name`*`:˜/command_exp$`.
    If so, you can pat yourself on the back.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直都在使用主文件夹中的命令行。使用 `cd` 命令，你可以将终端的位置更改为另一个文件夹。在本书的项目中，你将非常频繁地使用这个非常实用的命令。为了试一试，让我们通过输入
    **`cd command_exp`** 并按回车键进入 *command_exp* 文件夹。如果你操作正确，你的终端提示符现在应该显示为 *`username`*`@`*`computer_name`*`:˜/command_exp$`。如果是这样，你可以给自己鼓掌。
- en: While you are there, you might as well try the `ls` command with the `R` (recursive)
    flag to see how that works. Just type **`ls -R`** and press enter. Your Terminal
    should show that you have a subfolder here called *sub* and a file inside that
    subfolder called *expfile.txt*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在那里时，不妨尝试使用带有 `R`（递归）标志的 `ls` 命令来看看它是如何工作的。只需输入 **`ls -R`** 并按回车键。你的终端应该显示你这里有一个名为
    *sub* 的子文件夹，以及该子文件夹中的一个名为 *expfile.txt* 的文件。
- en: That is all you really want to do in there for now, so to get back to your home
    directory, just type **`cd`** and press enter, which will take you back home,
    so to speak.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你真正想要做的就这么多，所以为了回到你的主目录，只需输入 **`cd`** 并按回车键，这样你就可以“回家”了。
- en: For future reference, it is worth noting a couple of other `cd` command shortcuts.
    If you are within a subfolder of a subfolder and want to move back a step (from
    */home/rg/peas/pudding* to */home/rg/peas*, for example), you can do so by typing
    **`cd ..`** (with a space between `cd` and `..`) and pressing enter. You can also
    type **`cd -`** (with a space between `cd` and `-`) in order to get back to the
    directory where you were previously (from */home/rg* to */home/rg/peas/pudding*,
    for example).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将来参考，值得注意几个其他的 `cd` 命令快捷方式。如果你在一个子文件夹的子文件夹中，并且想要退回一步（例如，从 */home/rg/peas/pudding*
    退回到 */home/rg/peas*），你可以通过输入 **`cd ..`**（在 `cd` 和 `..` 之间有一个空格）并按回车键来实现。你也可以输入
    **`cd -`**（在 `cd` 和 `-` 之间有一个空格）来回到你之前所在的目录（例如，从 */home/rg* 回到 */home/rg/peas/pudding*）。
- en: $ cp
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ cp
- en: You might decide that not only do you want your *expfile.txt* file in the subfolder
    but you also want a copy in your home directory, where it was in the first place.
    To copy *expfile.txt*, you can use the `cp` (copy) command.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会决定，不仅要在子文件夹中保留你的 *expfile.txt* 文件，还希望在家目录中有一个副本，那里原本就是它的位置。要复制 *expfile.txt*，你可以使用
    `cp`（复制）命令。
- en: 'The command needs to know where the file you want to copy is, what it is called,
    and where you want to copy it, which in this case is to your Home folder. Normally
    you would type `cp command_exp/sub/expfile.txt /home/`*`username`* to do this,
    but if you recall, you can abbreviate the `/home/`*`username`* portion of the
    command string to `˜/`, which means the same thing. (This is an important tip
    to remember, because the tilde is frequently used in online instructions.) Because
    reducing wear and tear on the fingers is always a desirable goal, type the following
    command and then press enter:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 命令需要知道你想要复制的文件的位置、文件名以及你想要复制到的位置，在这个例子中是复制到你的家文件夹。通常你会输入 `cp command_exp/sub/expfile.txt
    /home/`*`username`* 来完成这个操作，但如果你还记得，你可以将命令字符串中的 `/home/`*`username`* 部分缩写为 `˜/`，这表示相同的意思。（这是一个需要记住的重要提示，因为波浪号在在线说明中经常被使用。）因为减少手指磨损总是个值得追求的目标，输入以下命令然后按回车键：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Be sure to put a space between the name of the file you are copying and its
    destination (in this case, between `expfile.txt` and `˜/`).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在你要复制的文件名和目标位置之间留一个空格（在这个例子中，在 `expfile.txt` 和 `˜/` 之间）。
- en: Once you’ve done this, you should have two copies of *expfile.txt*, one in your
    Home folder and one in your *sub* folder. Go take a look to see the fruit of your
    endeavors.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，你应该会有两个 *expfile.txt* 的副本，一个在你的家文件夹中，一个在你的 *sub* 文件夹中。去看看你努力的成果吧。
- en: $ rm
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ rm
- en: When you were a kid, you may well have experienced the joy of building a castle
    out of LEGO bricks and then the even greater joy of tearing the whole thing down
    (preferably by hurling D cell batteries at it). You will now embark on a similar
    move. The first tool in this nostalgic endeavor is the `rm` (remove) command,
    with which you can trash files.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你还是一个孩子的时候，你可能已经体验过用乐高积木建造城堡的乐趣，然后是拆掉整个城堡的更大乐趣（最好是朝它扔去D型电池）。现在你将开始类似的操作。在这个怀旧任务中的第一个工具是
    `rm`（删除）命令，你可以用它来删除文件。
- en: The `rm` command, albeit very useful and easy to use, should be handled with
    caution. Once you remove a file with this command, there is no going back. The
    file will not be placed in the Trash—it is gone for good.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `rm` 命令非常实用且易于使用，但应该谨慎处理。一旦你使用这个命令删除了一个文件，就无法回头。文件不会被放入回收站——它永远消失了。
- en: To play it safe, let’s try the rm command by getting rid of that new copy of
    *expfile.txt* that we just created in the Home folder. The basic `rm` command
    structure consists of the command itself, `rm`, followed by the name of the file
    you want to remove. In this case, you want to remove the file called *expfile.txt*
    located in your Home folder. Assuming your Terminal shows you to be home, remove
    the file by typing **`rm expfile.txt`** followed by a tap on the ol’ enter key.
    The file will then be gone, and gone for good.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，让我们尝试使用 `rm` 命令来删除我们刚刚在家文件夹中创建的新副本 *expfile.txt*。基本的 `rm` 命令结构包括命令本身
    `rm`，后面跟着你想要删除的文件名。在这个例子中，你想要删除位于你家文件夹中的名为 *expfile.txt* 的文件。假设你的终端显示你处于家目录，通过输入
    **`rm expfile.txt`** 然后按老式的回车键来删除文件。文件将会消失，并且永远消失。
- en: Now, double your pleasure by getting rid of the version of *expfile.txt* that
    is located in the subfolder sub. In this case, you need to specify where the file
    is because it isn’t in the folder that the Terminal is in. Just type **`rm command_exp/sub/expfile.txt`**
    and then press enter. Oooh, very cool. Brings ya back, doesn’t it?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过删除位于子文件夹sub中的*expfile.txt*版本来加倍你的乐趣。在这种情况下，你需要指定文件的位置，因为它不在终端所在的文件夹中。只需键入**`rm
    command_exp/sub/expfile.txt`**然后按回车。哇，非常酷。这让你想起了什么吗？
- en: $ rmdir
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$ rmdir`'
- en: You will now continue the fun with the `rmdir` (remove directory) command, which
    is a bigger and more powerful version of the `rm` command.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将继续使用`rmdir`（删除目录）命令的乐趣，这是`rm`命令的一个更大、更强大的版本。
- en: You should use the `rmdir` command, like the `rm` command, with caution. There
    are no do-overs with `rmdir`. Once you remove a directory or folder with this
    command, it is gone for good.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该像使用`rm`命令一样小心地使用`rmdir`命令。使用`rmdir`没有重做的机会。一旦使用此命令删除了目录或文件夹，它就永远消失了。
- en: 'To try this command, you can get rid of that *sub* folder you created. Type
    **`rmdir command_exp/sub`** and press enter. The *sub* folder should now be gone.
    Finally, to round out the fun, use the `rmdir` command once more to get rid of
    the *command_exp* folder you created earlier. You know the drill: Type **`rmdir
    command_exp`** and press enter.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试此命令，你可以删除你创建的*sub*文件夹。键入**`rmdir command_exp/sub`**然后按回车。*sub*文件夹现在应该消失了。最后，为了圆满结束这个乐趣，再次使用`rmdir`命令来删除你之前创建的*command_exp*文件夹。你知道该怎么做：键入**`rmdir
    command_exp`**然后按回车。
- en: $ chmod
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$ chmod`'
- en: In [Chapter 7](ch07.html "Chapter 7. A Tidy Nest"), you learned how to change
    file permissions via the Nautilus interface. This is without a doubt an easy way
    to go about such things, but sometimes it may be easier to use the command-line
    approach.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。一个整洁的巢穴")中，你学习了如何通过Nautilus界面更改文件权限。毫无疑问，这是一个处理此类事情的好方法，但有时可能更倾向于使用命令行方法。
- en: 'The command for changing file permissions is `chmod` (change mode). To use
    it, just type the command followed by the permissions you want to extend to a
    file and then the location of the file itself. For example, let’s say you copied
    a JPEG file, *mybirthday.jpg*, from a CD to the *personal* subfolder within the
    *Photos* folder on your hard disk and the file is write protected. To change the
    file so that you have write permissions (meaning that you can alter the file),
    you would type the following and then press enter:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 更改文件权限的命令是`chmod`（更改模式）。要使用它，只需键入命令，然后是想要扩展到文件的权限，然后是文件本身的路径。例如，假设你从CD复制了一个JPEG文件，*mybirthday.jpg*，到硬盘上*Photos*文件夹内的*personal*子文件夹中，并且文件是写保护的。要更改文件以便你有写权限（这意味着你可以更改文件），你会键入以下内容然后按回车：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To change the permissions of all the files and subfolders (and all the files
    within those subfolders) in one fell swoop, you can add the `-R` (recursive) flag
    to the `chmod` command. The command would thus be as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次性更改所有文件和子文件夹（以及这些子文件夹中的所有文件）的权限，你可以在`chmod`命令中添加`-R`（递归）标志。因此，命令如下所示：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The number `744`, by the way, extends read and write and execute (run) permissions
    to you, the owner, but gives read-only rights to everyone else. This is a pretty
    safe choice when in doubt. If you want to figure out permission numbers for yourself,
    it’s pretty easy. You are basically dealing with three number positions, each
    of which has eight numerical possibilities (`0`-`7`). The left slot represents
    permissions for the owner, the center slot represents permissions for the group,
    and the third slot represents permissions for others. The meanings of the numbers
    themselves are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，数字`744`将读、写和执行（运行）权限扩展到所有者，但其他人只有只读权限。这是一个相当安全的选项，当不确定时。如果你想自己找出权限数字，这相当简单。你基本上在处理三个数字位置，每个位置都有八个数字可能性（`0`-`7`）。最左边的槽位代表所有者的权限，中间的槽位代表组的权限，第三个槽位代表其他人的权限。这些数字本身的意义如下：
- en: '`7`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`7`'
- en: Read, write, and execute permissions
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 读写和执行权限
- en: '`6`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`6`'
- en: Read and write permissions
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 读写权限
- en: '`5`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`5`'
- en: Read and execute permissions
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 读写执行权限
- en: '`4`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`4`'
- en: Read-only permissions
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 只读权限
- en: '`3`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`3`'
- en: Write and execute permissions
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 写和执行权限
- en: '`2`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`2`'
- en: Write-only permissions
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 只写权限
- en: '`1`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`1`'
- en: Execute-only permissions
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 只执行权限
- en: '`0`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`'
- en: No permissions
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 没有权限
- en: '[Figure 8-5](ch08.html#the_meaning_of_permission_numbers "Figure 8-5. The meaning
    of permission numbers") points out the meaning of each of these numbers and what
    each number slot represents. In fact, if you don’t mind a bit of simple addition,
    things are even easier to understand. To start with, remember that 1 = execute,
    2 = write, and 4 = read. Add any of those numbers together, and you get the other
    permission combos. For example, 1 (execute) + 4 (read) = 5 (read and execute).
    As you can see, permissions aren’t all that complicated.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-5](ch08.html#the_meaning_of_permission_numbers "图8-5. 权限数字的含义")指出了这些数字的含义以及每个数字槽位代表什么。实际上，如果你不介意一点简单的加法，事情甚至更容易理解。首先，记住1
    = 执行，2 = 写入，4 = 读取。将这些数字相加，你就可以得到其他的权限组合。例如，1（执行）+ 4（读取）= 5（读取和执行）。正如你所看到的，权限并不那么复杂。'
- en: '![The meaning of permission numbers](httpatomoreillycomsourcenostarchimages1263632.png.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![权限数字的含义](httpatomoreillycomsourcenostarchimages1263632.png.jpg)'
- en: Figure 8-5. The meaning of permission numbers
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-5. 权限数字的含义
- en: Now if you’re more of a letters than numbers sort of person, you’ll be happy
    to know that there is another way to change permissions that is probably even
    easier. With this approach, you only have to deal with two groups of letters and
    the symbols `+` and `−`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更倾向于字母而不是数字，你可能会很高兴地知道还有另一种更改权限的方法，这可能更容易。使用这种方法，你只需要处理两组字母和符号`+`和`-`。
- en: 'The first group consists of the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组包括以下内容：
- en: '`u`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`u`'
- en: User (owner of the file)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 用户（文件所有者）
- en: '`g`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`g`'
- en: Group (specified group of users)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 组（指定用户组）
- en: '`o`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`o`'
- en: Others (anyone who is not the user or a member of the group)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 其他（任何不是用户或组成员的人）
- en: '`a`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`'
- en: All (all of the above)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所有（上述所有）
- en: 'The second group consists of the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组包括以下内容：
- en: '`r`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`r`'
- en: Read
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 读取
- en: '`w`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`w`'
- en: Write
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 写入
- en: '`x`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`'
- en: Execute
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 执行
- en: You might already be able to figure out how this is all going to work, but I’ll
    spell it out just in case your intuition is worn out for the day. Let’s say you
    want to change the permissions of a file (*butterhaters.txt*, for example) so
    that all users on your machine can read and write to it. After opening a Terminal
    window, you can make the change by typing **`chmod a+rw butterhaters.txt`** and
    pressing enter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经能够猜出这一切是如何工作的，但我还是把它写出来以防万一你的直觉今天已经用完了。假设你想改变一个文件（例如*butterhaters.txt*）的权限，以便所有机器上的用户都可以读取和写入它。在打开一个终端窗口后，你可以通过输入**`chmod
    a+rw butterhaters.txt`**并按回车键来做出更改。
- en: Oops! Just remembered that you don’t want anyone changing the content of the
    file, eh? Well, to take back the write permissions for that file, you just need
    to type **`chmod a-w butterhaters.txt`** and press enter. As you can see, the
    `+` gives permissions, while the `−` taketh away.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 哦！刚刚想起你不想让任何人更改文件的内容，对吧？好吧，要收回该文件的写权限，你只需要输入**`chmod a-w butterhaters.txt`**并按回车键。正如你所看到的，`+`赋予权限，而`-`则取消权限。
- en: That’s much simpler, you’ve got to admit.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这要简单得多，你必须承认。
- en: $ sudo
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ sudo
- en: When you tried to install software from the Ubuntu Software Center in [Chapter 6](ch06.html
    "Chapter 6. Rounding Out the Bird"), you were asked to input your password. The
    reason for this, as I mentioned then, is that the Ubuntu Software Center installs
    the files it downloads in various folders throughout your system, almost all of
    which are write protected. By supplying your password, you are telling your system
    that you, as holder of the password, have the right to allow the Ubuntu Software
    Center to do that.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在[第6章](ch06.html "第6章。完善鸟的形状")中尝试从Ubuntu软件中心安装软件时，你被要求输入密码。正如我那时提到的，这样做的原因是Ubuntu软件中心会将下载的文件安装到系统中的各个文件夹中，几乎所有的文件夹都是只读保护的。通过提供密码，你是在告诉你的系统，作为密码的持有者，你有权允许Ubuntu软件中心这样做。
- en: The command-line version of that same password-giving process is the `sudo`
    command. To perform an operation in a folder that is write protected, you would
    first type **`sudo`** and then the command you want to perform. For example, if
    you wanted to copy an icon image—let’s call it *myicon.png*—to the globally located
    and write-protected *pixmaps* folder (*/usr/share/pixmaps*), you would type **`sudo
    cp myicon.png /usr/share/pixmaps`**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 那个密码提供过程的命令行版本是`sudo`命令。要在受写保护的文件夹中执行操作，你首先输入**`sudo`**，然后输入你想要执行的命令。例如，如果你想复制一个图标图像——让我们称它为*myicon.png*——到全局位置和受写保护的*pixmaps*文件夹（*/usr/share/pixmaps*），你将输入**`sudo
    cp myicon.png /usr/share/pixmaps`**。
- en: After typing a command preceded by the `sudo` command and pressing enter, you
    will be prompted for your password. Once you type your password and press enter
    again, the command will be executed. I should mention that once you input your
    password, it will stay in memory for about five minutes, so you won’t be prompted
    for your password again when using the `sudo` command within that time frame.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入以`sudo`命令开头的命令并按回车键后，你将需要输入密码。一旦你输入密码并再次按回车键，命令将被执行。我应该提到，一旦你输入了密码，它将在大约五分钟内保留在内存中，所以在这段时间内使用`sudo`命令时，你不需要再次输入密码。
- en: $ locate
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ locate
- en: 'Now that you are familiar with the `sudo` command, let’s take it out for a
    spin by working with the `locate` command. The `locate` command is essentially
    a command-line alternative to the graphical Search tool found in the Places menu.
    Using the command is quite easy: Simply type the command followed by a space and
    the name of the file you want to find.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了`sudo`命令，让我们通过使用`locate`命令来试一试。`locate`命令本质上是一个图形搜索工具的命令行替代品，该工具位于“位置”菜单中。使用这个命令相当简单：只需输入命令，然后输入空格和你要查找的文件名。
- en: Before you can use this command, though, you should update the database of filenames
    that `locate` uses. This is where using the `sudo` command, along with yet another
    command, `updatedb`, comes into play. Just type **`sudo updatedb`** and press
    enter. Type your password when asked to do so—and then it will seem as though
    nothing is happening. But don’t worry. As long as the cursor in your Terminal
    is blinking, progress is being made, and when your user prompt returns, you will
    have successfully created the database file. After that, you can use the `locate`
    command.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用这个命令之前，你应该更新`locate`使用的文件名数据库。这就是使用`sudo`命令以及另一个命令`updatedb`发挥作用的地方。只需输入**`sudo
    updatedb`**并按回车键。当被要求时输入你的密码——然后似乎什么都没有发生。但不要担心。只要你的终端光标在闪烁，进度就在进行中，当你的用户提示符返回时，你就已经成功创建了数据库文件。之后，你就可以使用`locate`命令了。
- en: Oh, and in the future if you think that the process seems to be taking longer
    and longer, don’t worry—it is. The more files and applications you add to your
    system, the longer it will take your system to catalog them all.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，而且在未来，如果你觉得这个过程似乎越来越慢，不要担心——它确实是。你添加到系统中的文件和应用程序越多，你的系统整理这些文件所需的时间就越长。
- en: 'To take this new command for a test drive, let’s look for the LibreOffice Writer
    icon, *libreoffice-writer.png*. Just type the following and press enter:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个新命令，让我们查找LibreOffice Writer图标，*libreoffice-writer.png*。只需输入以下内容并按回车键：
- en: '[PRE4]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Your results should look like those in [Figure 8-6](ch08.html#the_results_of_a_locate_search
    "Figure 8-6. The results of a locate search").
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果应该看起来像[图8-6](ch08.html#the_results_of_a_locate_search "图8-6. locate搜索的结果")中的那样。
- en: '![The results of a locate search](httpatomoreillycomsourcenostarchimages1263634.png.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![locate搜索的结果](httpatomoreillycomsourcenostarchimages1263634.png.jpg)'
- en: Figure 8-6. The results of a `locate` search
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-6. `locate`搜索的结果
- en: $ apt-get
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ apt-get
- en: 'Let’s move on to a command that might seem a bit familiar: `apt-get`. Yes,
    this command is indeed a means of controlling the powerful package download and
    installation tool, APT, which I covered in [Chapter 6](ch06.html "Chapter 6. Rounding
    Out the Bird"). Although it might not be as pleasing to use APT via the command
    line as it is via the Ubuntu Software Center, doing so can come in handy. I’ll
    cover the basics for you here.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一个可能有点熟悉的命令：`apt-get`。是的，这个命令确实是控制强大的包下载和安装工具APT（我在[第6章](ch06.html
    "第6章。完善鸟")中介绍过）的一种方式。虽然通过命令行使用APT可能不如通过Ubuntu软件中心那样令人愉悦，但这样做有时会很有用。在这里，我会为你介绍这个命令的基础知识。
- en: Just for fun and to get a bit of nontoxic practice with apt-get, open a Terminal
    window, type **`apt-get moo`**, and press enter. The result of this endeavor,
    as you will see, is an example of an Easter egg ([Figure 8-7](ch08.html#discovering_an_easter_egg_via_apt-get
    "Figure 8-7. Discovering an Easter egg via apt-get")), those little snippets of
    code that programmers seem to enjoy throwing into their work for just for fun.
    They’re useless, yes, but they’re also harmless, and this one is a safe first
    step in working with `apt-get`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，并且为了练习一下`apt-get`的使用，打开一个终端窗口，输入**`apt-get moo`**并按回车键。正如你将看到的，这个尝试的结果是一个复活节彩蛋（[图8-7](ch08.html#discovering_an_easter_egg_via_apt-get
    "图8-7. 通过apt-get发现复活节彩蛋"))，那些程序员似乎喜欢在他们的工作中加入的只是为了乐趣的小段代码。它们可能没有用，但它们是无害的，而且这是使用`apt-get`的一个安全的第一步。
- en: '![Discovering an Easter egg via apt-get](httpatomoreillycomsourcenostarchimages1263636.png.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![通过 apt-get 发现彩蛋](httpatomoreillycomsourcenostarchimages1263636.png.jpg)'
- en: Figure 8-7. Discovering an Easter egg via `apt-get`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-7. 通过 `apt-get` 发现彩蛋
- en: To actually put the `apt-get` command to use, start by making sure to close
    any APT frontends you might have open, such as the Ubuntu Software Center. As
    I mentioned in [Chapter 6](ch06.html "Chapter 6. Rounding Out the Bird"), you
    can run only one APT tool at a time. Once the coast is clear, you should always
    start out any operations involving `apt-get` with an update of the APT database
    so that you will be downloading the newest stuff. To do this, just type the command
    **`sudo apt-get update`**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际使用 `apt-get` 命令，首先确保关闭你可能打开的任何 APT 前端，例如 Ubuntu 软件中心。正如我在 [第 6 章](ch06.html
    "第 6 章. 完善鸟儿") 中提到的，你一次只能运行一个 APT 工具。一旦情况明朗，你应该始终以更新 APT 数据库开始涉及 `apt-get` 的任何操作，这样你将下载最新内容。为此，只需输入命令
    **`sudo apt-get update`**。
- en: If you want to install a single package without heading over to the Ubuntu Software
    Center, you can do so by typing **`sudo apt-get install`** **``*`package-name`*``**.
    For example, if you want to download and install the Shufflepuck game clone, Tuxpuck,
    you would type **`sudo apt-get install tuxpuck`**. If you eventually get annoyed
    with Tuxpuck after having lost one too many times, you can uninstall it by typing
    **`sudo apt-get remove tuxpuck`**.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在不前往 Ubuntu 软件中心的情况下安装单个软件包，你可以通过输入 **`sudo apt-get install`** **``*`package-name`*``**
    来实现。例如，如果你想下载并安装 Shufflepuck 游戏克隆版 Tuxpuck，你将输入 **`sudo apt-get install tuxpuck`**。如果你在
    Tuxpuck 中输得太多，最终感到厌烦，你可以通过输入 **`sudo apt-get remove tuxpuck`** 来卸载它。
- en: Finally, bearing in mind all the warnings offered in [Chapter 6](ch06.html "Chapter 6. Rounding
    Out the Bird"), if you want to upgrade your entire system via the command line,
    you can do so by typing **`sudo apt-get dist-upgrade`** (but only after doing
    a **`sudo apt-get update`** first).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑到 [第 6 章](ch06.html "第 6 章. 完善鸟儿") 中提供的所有警告，如果你想通过命令行升级整个系统，你可以通过输入 **`sudo
    apt-get dist-upgrade`**（但首先必须先执行 **`sudo apt-get update`**）来实现。
- en: $ finger
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ finger
- en: If you enjoyed discovering who you are with the `whoami` command earlier in
    this chapter, then you might enjoy finding out even more about yourself using
    the `finger` command. You can use the `finger` command in a number of ways, but
    a very simple one is finding out about a particular user. In order to try it out
    yourself, you have to install finger first, since it is no longer bundled with
    Ubuntu.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前在本章中通过 `whoami` 命令发现你是谁感到很有趣，那么你可能喜欢使用 `finger` 命令来了解更多关于自己的信息。你可以用多种方式使用
    `finger` 命令，但一个非常简单的方式是了解某个特定用户的信息。为了亲自尝试，你必须首先安装 finger，因为它不再与 Ubuntu 一起打包。
- en: This is an excellent chance to get some more practice with the `apt-get` command
    you just learned. Open a Terminal window, type **`sudo apt-get install finger`**,
    and press enter. Once you’ve typed your password and the installation is complete,
    you will see your Terminal prompt again and be ready to try finger out. Just type
    **`finger`** and then your username. In my case, that would be `finger rg`. Once
    you’ve typed the command, press enter and see what you get. You can see my results
    in [Figure 8-8](ch08.html#output_from_the_finger_command "Figure 8-8. Output from
    the finger command").
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的机会来练习你刚刚学到的 `apt-get` 命令。打开一个终端窗口，输入 **`sudo apt-get install finger`**
    并按回车。一旦你输入了密码并且安装完成，你将再次看到终端提示符，并准备好尝试使用 finger。只需输入 **`finger`** 然后是你的用户名。在我的例子中，那就是
    `finger rg`。一旦你输入了命令，按回车键，看看你得到了什么。你可以看到我的结果在 [图 8-8](ch08.html#output_from_the_finger_command
    "图 8-8. finger 命令的输出")。
- en: '![Output from the finger command](httpatomoreillycomsourcenostarchimages1263638.png.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![finger 命令的输出](httpatomoreillycomsourcenostarchimages1263638.png.jpg)'
- en: Figure 8-8. Output from the `finger` command
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-8. `finger` 命令的输出
- en: As you can see, my login name is *rg*, my real name is Rickford Grant, my home
    directory is */home/rg*, and I am using the Bash shell for typing my commands.
    I have been logged on since Wednesday, March 21, at 10:44 Eastern Daylight Time
    (EDT), and I have no mail or plan. It doesn’t tell you my Social Security number
    or my mother’s maiden name, but it is pretty cool, don’t you think?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我的登录名是 *rg*，我的真实姓名是 Rickford Grant，我的家目录是 */home/rg*，我正在使用 Bash shell
    来输入我的命令。我从 3 月 21 日星期三的 10:44 美国东部夏令时（EDT）开始登录，我没有邮件或计划。它不会告诉你我的社会保险号码或我母亲的婚前名字，但确实很酷，不是吗？
- en: What Is a Shell?
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是 Shell？
- en: As you noticed, I mentioned that the results of the `finger` command showed
    I was using the Bash shell, so you may well be wondering just what Bash is. Well,
    *Bash (Bourne Again Shell)* is one of the many shells that are used in Linux systems,
    and it’s the one that happens to come with your Ubuntu distro (and most others,
    for that matter). A *shell* is a program that interprets the commands you type
    into the Terminal and delivers them, so to speak, to your system so that it can
    act upon them. I like to think of it as a command-handling subsystem, for which
    the Terminal acts as a graphical frontend.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，我提到`finger`命令的结果显示我正在使用Bash shell，所以你可能很好奇Bash究竟是什么。好吧，*Bash（Bourne
    Again Shell）*是Linux系统中使用的许多shell之一，它恰好包含在你的Ubuntu发行版（以及大多数其他发行版）中。*shell*是一个程序，它解释你在终端中输入的命令，并将它们“传递”给你的系统，以便它可以对其执行操作。我倾向于将其视为一个命令处理子系统，而终端则充当图形前端。
- en: What Is a Plan?
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是计划？
- en: I also mentioned that the results said I had no plan, so you may also be wondering
    what that is all about. A *.plan* file is a small file kept in your Home folder
    that other users see when they use the `finger` command on you. Traditionally,
    a *.plan* file contained information about where you were going to be or what
    you were working on. These days, however, most people use them to leave odd little
    messages, quotations, or whatever, much as they do in email signatures. Take a
    look at [Figure 8-9](ch08.html#output_from_the_finger_command_with_a_pl "Figure 8-9. Output
    from the finger command with a plan") to see what happens after I add a *.plan*
    file to my Home folder.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我还提到结果显示我没有计划，所以你可能也在想这是怎么回事。*.plan*文件是一个保存在你的主目录中的小文件，当其他用户使用`finger`命令查看你时，他们会看到这个文件。传统上，*.plan*文件包含有关你将去哪里或你在做什么的信息。然而，如今，大多数人使用它们来留下奇怪的小信息、引用或其他内容，就像他们在电子邮件签名中做的那样。看看[图8-9](ch08.html#output_from_the_finger_command_with_a_pl
    "图8-9. `finger`命令的输出计划")，看看我在主目录中添加*.plan*文件后会发生什么。
- en: '![Output from the finger command with a plan](httpatomoreillycomsourcenostarchimages1263640.png.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![`finger`命令的输出计划](httpatomoreillycomsourcenostarchimages1263640.png.jpg)'
- en: Figure 8-9. Output from the `finger` command with a plan
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-9. `finger`命令的输出计划
- en: 'You can now see my plan, which is a quotation from Kurt Vonnegut’s *The Sirens
    of Titan* (or Al Stewart’s song by the same name, for that matter). Of course,
    you can put anything you want in your own. You will get the chance to create your
    own plan file in [Project 8A: Creating a Plan](ch08.html#project_8a_colon_creating_a_plan
    "Project 8A: Creating a Plan") in [Compressing and Extracting Compressed Single
    Files](ch08.html#compressing_and_extracting_compressed_si "Compressing and Extracting
    Compressed Single Files"), so if this seems fun to you, more fun is in store.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以看到我的计划，这是一句来自库尔特·冯内古特《泰坦的号角》（或者说是阿尔·斯图尔特同名歌曲）的引用。当然，你可以根据自己的意愿放入任何内容。你将在[项目8A：创建计划](ch08.html#project_8a_colon_creating_a_plan
    "项目8A：创建计划")中创建自己的计划文件，在[压缩和解压缩单个文件](ch08.html#compressing_and_extracting_compressed_si
    "压缩和解压缩单个文件")中，所以如果你觉得这很有趣，还有更多的乐趣在等着你。
- en: Other Uses of the finger Command
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`finger`命令的其他用途'
- en: Before moving on, I should mention that you can also use the `finger` command
    to do a little domestic espionage of sorts. Let’s say your child, Chris, has a
    user account on your machine. Chris, who wants your permission to go to the movies,
    claims to have been hard at work on the computer all day writing a report for
    school. Having your doubts, you could type **`finger chris`** to see what the
    facts actually are. It may be a bit underhanded and rotten, but it works. It also
    works both ways; others can check up on you as well. You can try it out if you
    create a new user account in [Chapter 9](ch09.html "Chapter 9. Dressing Up the
    Bird"). Just type **`finger`**, the name of the account you’re not currently in,
    and then press enter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我应该提到你也可以使用`finger`命令进行一些类似间谍活动的小操作。比如说，你的孩子Chris在你的机器上有一个用户账户。Chris想要得到你去看电影的许可，声称他整天都在电脑上努力写学校的报告。如果你对此有所怀疑，你可以输入**`finger
    chris`**来查看事实的真相。这可能有点不光彩和卑鄙，但它有效。它也可以双向进行；其他人也可以检查你。如果你在[第9章](ch09.html "第9章。装扮小鸟")中创建一个新的用户账户，你可以试试这个。只需输入**`finger`**，你当前不在的账户名称，然后按回车键。
- en: You can even use the `finger` command to find out facts about people on other
    systems, providing their network’s finger service is active and you know their
    email address. Typing something like **`finger`** **``*`username@hostname.com`*``**
    would do the trick. It’s kind of cool but also kind of spooky, I suppose.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以使用 `finger` 命令来了解其他系统上的人的信息，前提是他们的网络 finger 服务是激活的，并且您知道他们的电子邮件地址。输入类似
    **`finger`** **``*`username@hostname.com`*``** 这样的命令就可以做到这一点。这有点酷，但也有一点令人毛骨悚然，我想。
- en: A Couple of Other Commands You’ll Be Using Soon
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您很快就会使用的一些其他命令
- en: 'This is as good a place as any to introduce two more commands that you will
    be called upon to use in this chapter and elsewhere in the book: `ln` and `tar`.
    You needn’t practice with these yet, because you will be using them very soon,
    but you might as well know what they are all about.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个介绍两个您将在本章和本书的其他地方需要使用的命令的好地方：`ln` 和 `tar`。您现在不需要练习这些命令，因为您很快就会使用它们，但您最好了解一下它们是什么。
- en: $ ln
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ ln
- en: You use the `ln` (link) command to create a link file that launches or activates
    another file located in a separate folder. This is very useful when you want to
    activate a file that is buried deep in the subfolder of a subfolder of a subfolder
    somewhere on your hard disk. The command is often used with the `-s` (symbolic)
    flag, which provides essentially the same thing as the shortcut you’ve come to
    know in Windows, or the alias on the Mac.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `ln`（链接）命令创建一个链接文件，该文件可以启动或激活位于单独文件夹中的另一个文件。当您想激活位于硬盘深处某个子文件夹的子文件夹中的文件时，这非常有用。该命令通常与
    `-s`（符号）标志一起使用，它基本上与您在 Windows 中所熟知的快捷方式或 Mac 上的别名相同。
- en: The easiest way to use the `ln` command is to first use the `cd` command to
    change the Terminal’s location to the folder where you want to place the link.
    Then you can type the **`ln`** command on the command line, followed by the path
    of the file to which you want to link. For example, let’s say you want to put
    a link in your Home folder for a LibreOffice Writer file of your autobiography
    called *myLife.odt*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ln` 命令的最简单方法是首先使用 `cd` 命令将终端的位置更改为您想要放置链接的文件夹。然后您可以在命令行上输入 **`ln`** 命令，后面跟您想要链接的文件的路径。例如，假设您想在您的家目录中创建一个指向您的自传
    LibreOffice Writer 文件 *myLife.odt* 的链接。
- en: 'The file is pretty well buried in a nest of subfolders deep within your Home
    folder: */home/<username>/Documents/personal/self/autobiography/myLife.odt*. To
    create the link, you would open a new Terminal window, type the following command
    string, and then press enter:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件深深埋藏在家目录中一个子文件夹的巢穴中：*/home/<username>/Documents/personal/self/autobiography/myLife.odt*。要创建链接，您需要打开一个新的终端窗口，输入以下命令字符串，然后按回车键：
- en: '[PRE5]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once you are finished, the link will appear in your Home folder as an icon matching
    the original file in appearance, albeit sporting an arrow to signify that it is
    a link.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，链接将以与原始文件外观相匹配的图标形式出现在您的家目录中，尽管它有一个箭头表示这是一个链接。
- en: $ tar
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ tar
- en: In [Chapter 7](ch07.html "Chapter 7. A Tidy Nest") you learned to create and
    extract archives, or *tarballs*, but did you know that you can also create and
    extract tarballs using the command line? The `tar` command is your key to doing
    this.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](ch07.html "第 7 章。整洁的巢穴") 中，您学习了如何创建和提取存档，或称 *tarballs*，但您知道您还可以使用命令行创建和提取
    tarballs 吗？`tar` 命令是您实现这一点的关键。
- en: 'To create an archive, you would simply type **`tar -cvf`**, followed by the
    name the final tarball will be and then the name of the folder or file you are
    trying to archive. For example, let’s say you want to create an archive of your
    photos folder and you want to call it *pics4pals*. In this case, you would type
    the following command and then press enter:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建存档，您只需输入 **`tar -cvf`**，然后是最终 tarball 的名称，然后是您想要存档的文件夹或文件的名称。例如，假设您想创建一个名为
    *pics4pals* 的照片文件夹存档。在这种情况下，您需要输入以下命令并按回车键：
- en: '[PRE6]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you no doubt noticed, there are some flags after the `tar` command in that
    string. The `c` tells the tar program to *create* a new archive. The `v` tells
    the program to be *verbose* or, in other words, to tell you what it is doing in
    the Terminal as it is doing it. Finally, the `f` tells the program that what follows
    is the *file information*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您无疑已经注意到，在那个字符串中 `tar` 命令后面有一些标志。`c` 告诉 tar 程序 *创建* 一个新的存档。`v` 告诉程序要 *详细* 或换句话说，在它执行时在终端中告诉您它在做什么。最后，`f`
    告诉程序接下来的是 *文件信息*。
- en: If, after creating the archive, you suddenly remember that there is one more
    file you want to add to the mix, you can use the `-r` flag to append the archive.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在创建存档后，你突然想起还有另一个文件想要添加进去，你可以使用 `-r` 标志来追加存档。
- en: 'For example, to add a file called *cranky.png* to the archive, you would type
    the following and then press enter:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将名为 *cranky.png* 的文件添加到存档中，你需要输入以下内容并按回车键：
- en: '[PRE7]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Of course, chances are that you will be doing more tarball extracting than
    creating, so you no doubt want to know how to do that. Fortunately, the process
    is pretty similar to what you do when creating the tarball. The main difference
    is in the first flag. Rather than using the `tar` command with the `-c` flag,
    you would use it with the `-x` flag, which tells the tar program to *extract*
    the specified archive. So if you want to extract a tarball called *spicyfood.tar*,
    type the following command and press enter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能会做更多解压缩 tarball 的工作而不是创建，因此你无疑想知道如何进行。幸运的是，这个过程与创建 tarball 的过程非常相似。主要区别在于第一个标志。你不会使用带有
    `-c` 标志的 `tar` 命令，而是使用带有 `-x` 标志的命令，这告诉 tar 程序 *提取* 指定的存档。所以如果你想提取名为 *spicyfood.tar*
    的 tarball，请输入以下命令并按回车键：
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What you have been doing thus far is creating and extracting archives, which
    are basically just collections of files. They are not, however, compressed. In
    fact, most tarballs you find will be compressed, and you can tell by the ending
    *tar.gz*. That *gz* means that the archive was compressed using the gzip program.
    Extracting a compressed tarball is just as easy as extracting a straight tar archive;
    all you have to do is add the `-z` flag, which tells your system to use the gzip
    program to decompress the archive. For example, if you want to extract a compressed
    tarball called *goosedown.tar.gz*, type the following command and press enter:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止你所做的是创建和提取存档，这些存档基本上只是文件的集合。然而，它们并不是压缩的。实际上，你找到的大多数 tarball 都是压缩的，你可以通过文件扩展名
    *tar.gz* 来判断。那个 *gz* 表示存档是用 gzip 程序压缩的。解压缩压缩的 tarball 与解压缩普通的 tar 存档一样简单；你只需要添加
    `-z` 标志，告诉你的系统使用 gzip 程序解压缩存档。例如，如果你想解压缩名为 *goosedown.tar.gz* 的压缩 tarball，请输入以下命令并按回车键：
- en: '[PRE9]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Well, now that you know how to decompress and extract a gzipped tarball, you
    probably want to know how to create one. This is, again, little different than
    creating the tar archive itself; you would just add the `-z` tag to tell the program
    to use gzip to compress the folder. For example, to create a compressed version
    of your *Pictures* folder, which we’ll call *tightpics.tar.gz*, you would type
    the following and press enter:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在你已经知道了如何解压缩和提取 gzipped tarball，你可能想知道如何创建一个。这又与创建 tar 存档本身几乎没有什么区别；你只需要添加
    `-z` 标签来告诉程序使用 gzip 压缩文件夹。例如，要创建名为 *tightpics.tar.gz* 的 *Pictures* 文件夹的压缩版本，请输入以下内容并按回车键：
- en: '[PRE10]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s worth mentioning at this point that you may also come across some files
    compressed with the bzip program. Such files are recognizable by some variation
    on the *.bz* or .*bz2* file extension. Dealing with these files should pose no
    problem, because the commands are almost identical to those for gzip. Just substitute
    `-j` for `-z` in the command string.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上值得提到的是，你也可能会遇到一些用 bzip 程序压缩的文件。这些文件可以通过 *.bz* 或 .*bz2* 文件扩展名的某种变体来识别。处理这些文件应该不会引起任何问题，因为命令几乎与
    gzip 的命令相同。只需在命令字符串中将 `-z` 替换为 `-j` 即可。
- en: Compressing and Extracting Compressed Single Files
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩和解压缩单个压缩文件
- en: If you want to compress or decompress a single file, you don’t really need to
    use the tar program at all, since its purpose is to create archives consisting
    of several files. You can instead use the `gzip` and `gunzip` commands directly.
    For example, to compress a file called *matilda.jpg*, you would type **`gzip matilda.jpg`**
    and press enter. The *matilda.jpg* file would then become *matilda.jpg.gz*. To
    decompress the file, you would type **`gunzip matilda.jpg.gz`** and press enter,
    after which the *matilda.jpg* file would be back to normal.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要压缩或解压缩单个文件，实际上并不需要使用 tar 程序，因为它的目的是创建包含多个文件的存档。你可以直接使用 `gzip` 和 `gunzip`
    命令。例如，要压缩名为 *matilda.jpg* 的文件，你需要输入 **`gzip matilda.jpg`** 并按回车键。*matilda.jpg*
    文件随后将变为 *matilda.jpg.gz*。要解压缩该文件，你需要输入 **`gunzip matilda.jpg.gz`** 并按回车键，之后 *matilda.jpg*
    文件将恢复到正常状态。
- en: So, can you compress an archive you’ve already created with the `tar` command?
    Sure. For example, to compress the spicyfood.tar archive mentioned earlier, you
    would type **`gzip spicyfood.tar`**, and voilá—you’ve got yourself a compressed
    *spicyfood.tar.gz* archive. Pretty cool, don’t you think?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您能否使用 `tar` 命令压缩您已经创建的存档？当然可以。例如，要压缩前面提到的 spicyfood.tar 存档，您将输入 **`gzip spicyfood.tar`**，然后
    voilá——您就得到了一个压缩的 *spicyfood.tar.gz* 存档。相当酷，不是吗？
- en: 'Project 8A: Creating a Plan'
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 8A：创建计划
- en: Now that you have a bit of command experience, it’s time to get some practice
    and put all those commands to good use. In this project, you’ll create a *.plan*
    file, like the one mentioned earlier in [$ finger](ch08.html#dollar_finger "$
    finger") in [$ finger](ch08.html#dollar_finger "$ finger").
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有一些命令经验了，是时候进行一些练习，并充分利用所有这些命令了。在这个项目中，您将创建一个 *.plan* 文件，就像在 [$ finger](ch08.html#dollar_finger
    "$ finger") 中提到的 [$ finger](ch08.html#dollar_finger "$ finger") 一样。
- en: The actual *.plan* file is a hidden file (as you can see by the dot before its
    name) and contains the plan or message that you add to it. That message will appear
    in the output of someone’s Terminal when he uses the `finger` command to find
    out more about you. You may not need such a *.plan* file, but it’s an easy enough
    way to work a bit more with commands and the Terminal itself, so let’s give it
    a try.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 *.plan* 文件是一个隐藏文件（您可以通过其名称前的点来看到），它包含您添加的计划或信息。当某人使用 `finger` 命令来了解更多关于您的情况时，这条信息将出现在他的终端输出中。您可能不需要这样的
    *.plan* 文件，但它是一个很好的方法来更多地使用命令和终端本身，所以让我们试试看。
- en: To start out, you will open the Terminal-based Nano editor to create the *.plan*
    file. To do this, open a Terminal window, type **`nano .plan`** (being sure to
    put a space between `nano` and `.plan`), and press enter. Your Terminal should
    now look a bit different, as shown in [Figure 8-10](ch08.html#the_gnu_nano_editor
    "Figure 8-10. The GNU Nano editor").
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将打开基于终端的 Nano 编辑器来创建 *.plan* 文件。为此，打开一个终端窗口，输入 **`nano .plan`**（确保在 `nano`
    和 `.plan` 之间有一个空格），然后按回车键。现在您的终端看起来会有点不同，如图 [图 8-10](ch08.html#the_gnu_nano_editor
    "图 8-10. The GNU Nano editor") 所示。
- en: '![The GNU Nano editor](httpatomoreillycomsourcenostarchimages1263642.png.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![The GNU Nano editor](httpatomoreillycomsourcenostarchimages1263642.png.jpg)'
- en: Figure 8-10. The GNU Nano editor
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [图 8-10](ch08.html#the_gnu_nano_editor "图 8-10. The GNU Nano editor")
- en: You will now be looking at your new, and totally empty, *.plan* file within
    the Nano editor. All you have to do is type your plan or message. Once you’ve
    done that, press ctrl-X to exit the Nano editor, and it will ask you whether you
    want to save your work. You do, so type y, after which you will be presented with
    a set of save options. You have already named the file *.plan*, as you can see
    near the bottom of the screen, so all you have to do is press enter. You will
    be back at your now-familiar user prompt in the Terminal window.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将在 Nano 编辑器中查看您的新、完全空的 *.plan* 文件。您只需输入您的计划或信息。完成之后，按 ctrl-X 退出 Nano 编辑器，它将询问您是否要保存您的作品。您需要保存，所以输入
    y，之后您将看到一个保存选项集。您已经将文件命名为 *.plan*，如屏幕底部所示，所以您只需按回车键。您将回到现在熟悉的终端窗口的用户提示符。
- en: To wrap things up, change the permissions of the new *.plan* file by typing
    **`chmod 644 .plan`** in the Terminal window and then pressing enter. The *.plan*
    file should now be in your Home folder and readable (see note below) by all, so
    go on and test your work by typing **`finge`** **``*`username`*``** and pressing
    enter. The message you entered in your *.plan* file should now appear in the results
    in place of the `No Plan` you found there earlier. If you want to change the contents
    of your *.plan* file later, just follow the same steps and change the text when
    the *.plan* appears in the Nano editor.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这个话题，在终端窗口中输入 **`chmod 644 .plan`** 来更改新 *.plan* 文件的权限，然后按回车键。现在 *.plan*
    文件应该在您的家目录中，并且对所有用户都是可读的（见下文说明），所以继续测试您的作品，输入 **`finge`** **``*`username`*``**
    并按回车键。您在 *.plan* 文件中输入的信息现在应该出现在结果中，而不是您之前找到的 `No Plan`。如果您以后想更改 *.plan* 文件的内容，只需遵循相同的步骤，并在
    *.plan* 出现在 Nano 编辑器中时更改文本。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The name of the *.plan* file is preceded by a dot, which means that it is a
    hidden file. Thus, if you take a look in your Home folder, you will not be able
    to see the file unless you have checked the Show hidden and backup files box in
    the File Management Preferences window.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*.plan* 文件的名称前面有一个点，这意味着它是一个隐藏文件。因此，如果您查看您的家目录，除非您在文件管理首选项窗口中勾选了显示隐藏和备份文件选项，否则您将看不到该文件。'
- en: 'Project 8B: More Command Practice with pyWings'
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 8B：使用 pyWings 进行更多命令练习
- en: Now let’s get some more experience with the Terminal by installing a simple,
    and admittedly kind of silly, oracle program called pyWings (see [Figure 8-11](ch08.html#seeking_wisdom_from_pywings
    "Figure 8-11. Seeking wisdom from pyWings")). pyWings will give you cryptic guidance
    in response to whatever questions you may ask it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过安装一个简单且诚然有点愚蠢的占卜程序pyWings（见图8-11）来获得更多关于终端的经验。[图8-11](ch08.html#seeking_wisdom_from_pywings
    "图8-11. 从pyWings寻求智慧")。pyWings会根据你提出的任何问题给出神秘的指导。
- en: '![Seeking wisdom from pyWings](httpatomoreillycomsourcenostarchimages1263644.png.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![从pyWings寻求智慧](httpatomoreillycomsourcenostarchimages1263644.png.jpg)'
- en: Figure 8-11. Seeking wisdom from pyWings
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-11. 从pyWings寻求智慧
- en: To use pyWings, type whatever your confusion or dilemma is in the input box,
    click one of the concern icons on the left (self, another, world), click one of
    the realm icons on the right (love, work, truth), and hit the big button that
    looks like half an eye. The oracle will then tell you what it has to say. As an
    example, I asked the oracle if I would ever master barre chords on the guitar,
    and I picked *self* as my concern and *work* as the realm. [Figure 8-12](ch08.html#pywings_bestows_its_wisdom
    "Figure 8-12. pyWings bestows its wisdom.") shows the wisdom that was bestowed
    upon me.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用pyWings，请在输入框中输入你的困惑或困境，点击左侧的其中一个关注图标（自我、他人、世界），点击右侧的其中一个领域图标（爱情、工作、真理），然后点击那个看起来像半个眼睛的大按钮。随后，占卜师会告诉你它想说的话。例如，我向占卜师询问我是否能够掌握吉他的扫弦技巧，我将“自我”作为我的关注点，将“工作”作为领域。[图8-12](ch08.html#pywings_bestows_its_wisdom
    "图8-12. pyWings赐予智慧。")展示了赋予我的智慧。
- en: '![pyWings bestows its wisdom.](httpatomoreillycomsourcenostarchimages1263646.png.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![pyWings赐予智慧。](httpatomoreillycomsourcenostarchimages1263646.png.jpg)'
- en: Figure 8-12. pyWings bestows its wisdom.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-12. pyWings赐予智慧。
- en: As you can see, the oracle told me, “The largest passion can fit in the smallest
    place,” which I will interpret as . . . well, I’m not sure how to interpret it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，占卜师告诉我，“最大的激情可以容纳在最小的空间里”，我将它解读为……嗯，我不确定如何解读。
- en: Hmm. I guess that’s encouraging.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯。我想这很鼓舞人心。
- en: pyWings was written in a programming language called Python, which actually
    creates scripts rather than conventional programs. You will learn a little more
    about this distinction later in the chapter, but one of the differences I can
    mention right off the bat is that you don’t actually have to install pyWings;
    you are simply going to put it on your hard drive in your Home folder and run
    it from there, more or less as is.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: pyWings是用一种名为Python的编程语言编写的，它实际上创建的是脚本而不是传统的程序。你将在本章后面学到更多关于这种区别的知识，但我可以立即提到的不同之处在于，你实际上不需要安装pyWings；你只需将其放在你的Home文件夹的硬盘上，然后从那里运行它，基本上就是这样。
- en: '8B-1: Getting Ready for pyWings (Installing Tkinter)'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8B-1: 为pyWings做准备（安装Tkinter）'
- en: As I mentioned, one difference between pyWings and most of the other applications
    you use is that pyWings is a Python script. To create a graphical interface for
    itself, pyWings uses a toolbox known as Tkinter, which is the de facto standard
    (though not the only) GUI toolbox for Python. Tkinter, however, no longer comes
    bundled with Ubuntu, so you will need to download and install it yourself. Fortunately,
    this is quite easily done.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，pyWings与大多数你使用的其他应用程序之间的一个区别是，pyWings是一个Python脚本。为了为自己创建图形界面，pyWings使用一个名为Tkinter的工具箱，它是Python的事实上的标准（尽管不是唯一）GUI工具箱。然而，Tkinter不再随Ubuntu捆绑提供，因此你需要自己下载并安装它。幸运的是，这相当容易完成。
- en: Although it is possible to whip open the Ubuntu Software Center and install
    Tkinter by the simple means learned in [Chapter 6](ch06.html "Chapter 6. Rounding
    Out the Bird"), it seems more appropriate in this command line-oriented chapter
    to . . . yeah, you got it, use the command line. That said, open a Terminal window,
    type **`sudo apt-get install python-tk`**, and then press enter. When asked for
    your password, type it and then press enter. APT will search the online repositories
    and find your file, along with anything else it requires to function properly.
    Once it is ready, it will ask you whether you want to continue. You do, so type
    **`y`** and then press enter. When your username prompt reappears, you’ll know
    the job is done, and you can go on to the next step.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以打开 Ubuntu 软件中心并通过在 [第 6 章](ch06.html "第 6 章。完善鸟儿") 中学到的简单方法安装 Tkinter，但在这个以命令行为导向的章节中似乎更合适的是……是的，你猜对了，使用命令行。话虽如此，打开一个终端窗口，输入
    **`sudo apt-get install python-tk`** 并按回车键。当被要求输入密码时，输入它并按回车键。APT 将搜索在线仓库并找到你的文件，以及它正常运行所需的所有其他文件。一旦准备就绪，它将询问你是否想继续。你会，所以输入
    **`y`** 并按回车键。当你的用户名提示符再次出现时，你就知道工作完成了，你可以继续下一步。
- en: '8B-2: Getting pyWings'
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8B-2: 获取 pyWings'
- en: You are just about ready to “install” pyWings, but before you do, you need to
    get it from [http://sourceforge.net/projects/pywings/](http://sourceforge.net/projects/pywings/).
    Once there, click the **Download** button, which will download the file pywings-1.1.tar.gz.
    When prompted, choose **Save File** and click **OK**. The file will be downloaded
    to your *Downloads* folder.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你差不多准备好“安装”pyWings了，但在你这样做之前，你需要从 [http://sourceforge.net/projects/pywings/](http://sourceforge.net/projects/pywings/)
    获取它。一旦到达那里，点击 **下载** 按钮，这将下载文件 pywings-1.1.tar.gz。当提示时，选择 **保存文件** 并点击 **确定**。文件将被下载到你的
    *下载* 文件夹中。
- en: '8B-3: Creating a LocalApps Folder for pyWings'
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8B-3: 为 pyWings 创建一个 LocalApps 文件夹'
- en: As I mentioned earlier, you will be installing the pyWings program locally in
    your Home folder. Installing a program *locally* means that you are installing
    the program and all its support and data files in your Home folder. This makes
    things a bit easier, but it also means that the program will not be available
    to other users. It also means that if you’re not careful, you might inadvertently
    delete it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，你将在你的 Home 文件夹中本地安装 pyWings 程序。本地安装一个程序意味着你将程序及其所有支持和数据文件安装在你的 Home 文件夹中。这使得事情变得稍微容易一些，但也意味着程序将不可供其他用户使用。这也意味着如果你不小心，你可能会意外地删除它。
- en: To make things a bit easier and safer, you are going to create a folder in your
    Home folder in which to place pyWings and all other applications that you may
    install locally on your machine in the future. You will, logically enough, call
    the folder *LocalApps*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情变得更容易、更安全，你将在你的 Home 文件夹中创建一个文件夹，用于放置 pyWings 以及你将来可能在本机上本地安装的所有其他应用程序。你将足够逻辑地称这个文件夹为
    *LocalApps*。
- en: 'Let’s make the folder using a command in order to get some more practice. Go
    to the Terminal, make sure you are in your Home folder, type the following command,
    and then press enter:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用命令来创建文件夹，以便获得更多的实践。转到终端，确保你在你的 Home 文件夹中，输入以下命令，然后按回车键：
- en: '[PRE11]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '8B-4: Extracting the pyWings Tarball'
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8B-4: 解压 pyWings Tarball'
- en: Now it is time to extract the tarball. You could do this by the double-click
    method you learned in [Chapter 7](ch07.html "Chapter 7. A Tidy Nest"), but since
    you’re working with the command line here, let’s use that instead.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解压 tarball 文件了。你可以通过在 [第 7 章](ch07.html "第 7 章。一个整洁的巢") 中学到的双击方法来做这件事，但由于你在这里使用的是命令行，让我们使用命令行吧。
- en: 'To start, you’re going to place the tarball in the same folder into which you
    extract its files. Usually this isn’t necessary because the contents of most tarballs
    are already packaged in a folder of their own. By double-clicking the tarball
    to open it in File Roller, you can see whether things are packed in a folder or
    simply as a group of files. In the case of pyWings, it is the latter, so follow
    these steps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将把 tarball 文件放在你提取文件的同个文件夹中。通常这并不是必要的，因为大多数 tarball 的内容已经打包在自己的文件夹中。通过双击
    tarball 在 File Roller 中打开它，你可以看到东西是打包在文件夹中还是简单地作为一组文件。在 pyWings 的情况下，后者是正确的，所以按照以下步骤操作：
- en: Create a *pywings* folder by typing **`mkdir pywings`** and pressing enter.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入 **`mkdir pywings`** 并按回车键创建一个 *pywings* 文件夹。
- en: Move the pyWings tarball into that folder by typing **`mv Downloads/pywings*.gz
    pywings`** and pressing enter.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入 **`mv Downloads/pywings*.gz pywings`** 并按回车键，将 pyWings tarball 移动到该文件夹中。
- en: You can see that in this step you used an asterisk (`*`) to save some wear and
    tear on your fingers. The asterisk is a wildcard character, which in this case
    told your system to move any file beginning with *`pywings`* and ending in *`.gz`*.
    Fortunately you had only one item matching those criteria.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以看到，在这个步骤中，你使用了星号 (`*`) 来节省一些手指的磨损。星号是一个通配符，在这种情况下，它告诉你的系统移动任何以 *`pywings`*
    开头并以 *`.gz`* 结尾的文件。幸运的是，你只有一个符合这些条件的项目。
- en: Move to the new *pywings* folder by typing **`cd pywings`** and pressing enter.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入 **`cd pywings`** 并按回车键，移动到新的 *pywings* 文件夹。
- en: Now you get down to extracting the tarball itself using the `tar` command. To
    do this, type **`tar -xzvf pywings*.gz`** and press enter.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你开始使用 `tar` 命令提取 tar 包本身。为此，输入 **`tar -xzvf pywings*.gz`** 并按回车键。
- en: Again, notice that you used the asterisk to save yourself some keystrokes, though
    you could just as well have typed **`−1.1.tar`**.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次注意，你使用了星号来节省一些按键，尽管你也可以直接输入 **`−1.1.tar`**。
- en: Finally, type **`cd`** and press enter to bring the Terminal back to your Home
    folder.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，输入 **`cd`** 并按回车键，将终端返回到你的家目录。
- en: '8B-5: Moving the pyWings Folder to Your LocalApps Folder'
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8B-5: 将 pyWings 文件夹移动到您的 LocalApps 文件夹'
- en: 'The extraction process is now complete. Before going on to run pyWings, however,
    let’s move it to the new *LocalApps* folder you created in [8B-3: Creating a LocalApps
    Folder for pyWings](ch08.html#b-3_colon_creating_a_localapps_folder_fo "8B-3:
    Creating a LocalApps Folder for pyWings") in [8B-2: Getting pyWings](ch08.html#b-2_colon_getting_pywings
    "8B-2: Getting pyWings"). To do this, type the following command and press enter:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '提取过程现在已完成。然而，在运行 pyWings 之前，让我们将其移动到你在 [8B-3: 为 pyWings 创建 LocalApps 文件夹](ch08.html#b-3_colon_creating_a_localapps_folder_fo
    "8B-3: 为 pyWings 创建 LocalApps 文件夹") 中创建的新 *LocalApps* 文件夹，该文件夹位于 [8B-2: 获取 pyWings](ch08.html#b-2_colon_getting_pywings
    "8B-2: 获取 pyWings")。为此，输入以下命令并按回车键：'
- en: '[PRE12]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '8B-6: Running pyWings'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8B-6: 运行 pyWings'
- en: Now that you have pyWings in place and ready for action, let’s start up the
    great oracle right now so that you can get a better perspective on how to deal
    with the aspects of life that trouble you.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装好并准备好使用 pyWings，让我们立即启动这个伟大的预言家，以便你能更好地了解如何处理生活中困扰你的方面。
- en: 'In the Terminal, make sure you are in your home directory, type the following
    command string, and then press enter:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，确保你处于你的家目录，输入以下命令字符串，然后按回车键：
- en: '[PRE13]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since *pywings.py* is a Python script, rather than an application, you are calling
    Python’s attention to that fact so that Python will know it needs to deal with
    that script. If all has gone according to plan, pyWings will soon be making you
    a wiser person.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *pywings.py* 是一个 Python 脚本，而不是一个应用程序，你需要让 Python 注意到这一点，以便 Python 知道它需要处理该脚本。如果一切按计划进行，pyWings
    将很快使你成为一个更明智的人。
- en: '8B-7: Creating a Launchable Link for pyWings'
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8B-7: 为 pyWings 创建可启动链接'
- en: The method of running pyWings that you’ve just used works well enough. However,
    it’s a pain to open your Terminal and type that somewhat lengthy string every
    time you want to find out what fate has in store for you. Let’s find a way to
    make things easier in the future.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才使用的运行 pyWings 的方法足够好。然而，每次你想知道你将面临什么样的命运时，打开终端并输入那个相对较长的字符串都是一件麻烦事。让我们找到一种方法，让未来更容易一些。
- en: To run an application from the Terminal, you generally type the name of that
    application or, to put it more precisely, the name of that program’s executable
    file; the application’s name thus acts as a sort of command. For your system to
    recognize that command, however, the command (the executable file or a link to
    it) must be in a location where the system can find it. Whenever you run a command
    of any sort, your system checks a series of locations (most of which are *bin
    folders*, where executable files are located) to find that command.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要从终端运行应用程序，你通常输入该应用程序的名称，或者更准确地说，该程序的可执行文件名称；因此，应用程序的名称充当了一种命令。然而，为了让你的系统识别该命令，该命令（可执行文件或指向它的链接）必须位于系统可以找到的位置。每次你运行任何类型的命令时，你的系统都会检查一系列位置（其中大多数是
    *bin 文件夹*，可执行文件位于其中）以找到该命令。
- en: 'You can easily find out where these locations are by typing **`echo $PATH`**
    in a new Terminal window and then pressing enter. As you will see, on your Ubuntu
    system, these locations are as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在新的终端窗口中输入 **`echo $PATH`** 来轻松地找出这些位置，然后按回车键。正如你所看到的，在你的 Ubuntu 系统中，这些位置如下：
- en: '| */* |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| */* |'
- en: '| */usr/lib/lightdm/lightdm* |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| */usr/lib/lightdm/lightdm* |'
- en: '| */usr/local/sbin* |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| */usr/local/sbin* |'
- en: '| */usr/local/bin* |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| */usr/local/bin* |'
- en: '| */usr/sbin* |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| */usr/sbin* |'
- en: '| */usr/bin* |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| */usr/bin* |'
- en: '| */sbin* |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| */sbin* |'
- en: '| */bin* |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| */bin* |'
- en: '| */usr/games* |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| */usr/games* |'
- en: The results of the `echo $PATH` command will not appear as they do in the (easier
    to read) chart shown here but, rather, in a single line divided by colons. The
    actual output shown in the Terminal is `/usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo $PATH` 命令的结果不会像这里显示的（更容易阅读）图表那样出现，而是一个由冒号分隔的单行。实际在终端中显示的输出是 `/usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games`。'
- en: If the command you typed is in one of those locations, the program or script
    will run. As you no doubt know, however, pyWings is not in any of those locations.
    It is in */home/*username*/LocalApps/pyWings* and is thus, in a sense, out of
    your system’s sight.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入的命令位于这些位置之一，程序或脚本将运行。然而，如你所知，pyWings 并不在这些位置之一。它在 */home/*username*/LocalApps/pyWings*
    中，因此在某种程度上，它超出了你系统的视线。
- en: To remedy this situation, you could add the path of your pyWings script to the
    list of paths that the system checks for run commands so as to make the system
    aware of your new application’s existence. However, let’s try another method that
    I think is easier. What you will do is create a link to pyWings, a sort of launchable
    alias, in one of the locations your system does check for commands.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以将你的 pyWings 脚本路径添加到系统检查运行命令的路径列表中，以便让系统知道你的新应用程序的存在。但是，让我们尝试另一种我认为更简单的方法。你将要做的是在系统检查命令的一个位置创建一个指向
    pyWings 的链接，一种可启动的别名。
- en: 'To create this link, you will use three commands: cd (to change directories),
    `sudo` (to give yourself write access to the destination folder), and `ln -s`
    (to create the link).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此链接，你将使用三个命令：cd（更改目录）、`sudo`（给自己提供对目标文件夹的写入访问权限）和 `ln -s`（创建链接）。
- en: In the Terminal, type **`cd /usr/games`** and press enter. This puts you in
    one of the folders your system searches when you enter commands.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中输入 **`cd /usr/games`** 并按回车键。这将使你进入系统在输入命令时搜索的文件夹之一。
- en: Type **`sudo ln -s /home/`****``*`username`*``****`/LocalApps/pywings/pywings.py
    pywings`** and press enter. (Note that there is a space between the terms `pywings.py`
    and `pywings` at the end of that command string.)
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 **`sudo ln -s /home/`****``*`username`*``****`/LocalApps/pywings/pywings.py
    pywings`** 并按回车键。（注意，在命令字符串的末尾，`pywings.py` 和 `pywings` 之间有一个空格。）
- en: The `pywings` at the end of that command string is the name that you are giving
    the link; the name of the link thus becomes the command you will use to run the
    application. If you type nothing, the link will be called *pywings.py*, which
    would mean three more keystrokes for you every time you wanted to start the program.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`pywings` 在该命令字符串的末尾是你为链接指定的名称；因此，链接的名称变成了你将用于运行应用程序的命令。如果你不输入任何内容，链接将被命名为
    *pywings.py*，这意味着每次你想启动程序时都需要多按三个键。'
- en: Type your password when prompted to do so and then press enter.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示输入密码时，输入你的密码然后按回车键。
- en: 'Now make your new launcher executable by changing its permissions: Type **`sudo
    chmod +x pywings`** and press enter.'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过更改权限使你的新启动器可执行：输入 **`sudo chmod +x pywings`** 并按回车键。
- en: Type **`cd`** and press enter to return the Terminal to your Home folder.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 **`cd`** 并按回车键，将终端返回到你的主文件夹。
- en: '8B-8: Running pyWings Again'
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8B-8：再次运行 pyWings
- en: Now that you have created the link, you should be able to run the pyWings program
    much more easily. To try it out, quit pyWings (if it is still running), type **`pywings`**
    in the Terminal window, and press enter. Your personal pyWings oracle should appear
    again.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了链接，应该能够更容易地运行 pyWings 程序。为了尝试它，退出 pyWings（如果它仍在运行），在终端窗口中输入 **`pywings`**，然后按回车键。你的个人
    pyWings 占卜师应该再次出现。
- en: You’ve managed to cut down on the number of keystrokes required to run pyWings
    from the Terminal. However, if you are really into this pyWings thing and want
    to use it often, it will probably be handiest to add a launcher to your panel,
    a drawer, or the Applications menu.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功减少了在终端运行 pyWings 所需的按键次数。然而，如果你真的喜欢 pyWings 并经常使用它，那么在面板、抽屉或应用程序菜单中添加一个启动器可能更方便。
- en: 'Project 8C: Command Practice Review with Briscola'
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 8C：使用 Briscola 的命令练习回顾
- en: If you want to reinforce the skills you’ve put to use in the previous project,
    why not go a bit Continental and try Briscola? Briscola is a simple, yet very
    traditional, Italian card game (see [Figure 8-13](ch08.html#briscola "Figure 8-13. Briscola")),
    which is also widely played in the Adriatic areas of Croatia and Herzegovina under
    the name briškula, as well as in Spain and Mexico, where it is known as briscas.
    Unlike pyWings, which is a Python script, Briscola is a script of a different
    flavor. It’s written in a scripting language called Tcl, which uses Tk to create
    its graphical interface—the same Tk used for the pyWings interface.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要加强你在上一个项目中使用的技能，为什么不尝试一下大陆风格的 Briscola 呢？Briscola 是一种简单而又非常传统的意大利纸牌游戏（见图
    8-13），在克罗地亚和黑塞哥维那的亚得里亚海地区也广泛流行，称为 briškula，在西班牙和墨西哥也流行，称为 briscas。与 Python 脚本
    pyWings 不同，Briscola 是一种不同口味的脚本。它使用一种名为 Tcl 的脚本语言编写，该语言使用 Tk 创建其图形界面——与 pyWings
    界面使用的相同的 Tk。
- en: '![Briscola](httpatomoreillycomsourcenostarchimages1263648.png.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![Briscola](httpatomoreillycomsourcenostarchimages1263648.png.jpg)'
- en: Figure 8-13. Briscola
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-13. Briscola
- en: '8C-1: Getting Briscola'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8C-1：获取 Briscola
- en: 'You are just about ready to begin “installing” Briscola, but before you do
    so, you must get it. You can get Briscola by going to the project’s home page
    at [http://www.rigacci.org/wiki/doku.php/tecnica/download/local_software](http://www.rigacci.org/wiki/doku.php/tecnica/download/local_software)
    and downloading it in the traditional manner, but since we’re working with commands,
    let’s instead get Briscola by using a new command: `wget`.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你差不多准备好开始“安装”Briscola 了，但在这样做之前，你必须先获取它。你可以通过访问项目的首页 [http://www.rigacci.org/wiki/doku.php/tecnica/download/local_software](http://www.rigacci.org/wiki/doku.php/tecnica/download/local_software)
    并以传统方式下载它来获取 Briscola，但由于我们正在使用命令，让我们使用一个新的命令：`wget` 来获取 Briscola。
- en: 'To do this, just open a Terminal window, type the following command string,
    and press enter:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，只需打开一个终端窗口，输入以下命令字符串，然后按回车键：
- en: '[PRE14]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In your Terminal window, you will see `wget` in action as it connects to the
    site where Briscola is stored and then downloads the file. When it’s done, you
    will find the Briscola tarball in your Home folder.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端窗口中，你会看到 `wget` 正在连接到存储 Briscola 的网站并下载文件。完成后，你将在主文件夹中找到 Briscola tarball。
- en: '8C-2: Extracting the Briscola Tarball and Renaming the Briscola Folder'
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8C-2：解压 Briscola Tarball 并重命名 Briscola 文件夹
- en: Extracting the Briscola tarball is essentially the same process as that for
    pyWings. The only difference is that Briscola is already packaged within its own
    folder, so you won’t have to create a special folder for it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 解压 Briscola tarball 的过程基本上与 pyWings 的过程相同。唯一的区别是 Briscola 已经打包在其自己的文件夹中，因此你不需要为它创建一个特殊的文件夹。
- en: 'You know what to do: Just open a Terminal window, type the following command,
    and press enter:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道该怎么做：只需打开一个终端窗口，输入以下命令，然后按回车键：
- en: '[PRE15]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A new folder, *Briscola-4.1*, will appear in your Home folder with all the Briscola
    files in it. To make things easier to deal with in the future, let’s shorten the
    name of the folder to simply *briscola*. You already know how to do this via the
    right-click method, but this time around let’s to do it via the command line.
    You use, perhaps surprisingly, the `mv` command followed by the name of the file
    whose name you are going to change, followed by the new name of the file.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 *Briscola-4.1* 的新文件夹将出现在你的主文件夹中，其中包含所有 Briscola 文件。为了使未来的处理更加方便，让我们将文件夹的名称缩短为简单的
    *briscola*。你已经知道如何通过右键点击方法来完成这个操作，但这次我们通过命令行来完成。你使用，可能令人惊讶的是，`mv` 命令后跟你要更改名称的文件名，然后是文件的新名称。
- en: 'Give it a go by typing the following command and pressing enter:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令并按回车键来尝试一下：
- en: '[PRE16]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '8C-3: Preparing the Briscola Script'
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8C-3：准备 Briscola 脚本
- en: Most applications that come in tarball form include a README file, which includes
    information on what you need to do to install and use the application. If you
    double-click the **README** file in the *briscola* folder in the file manager,
    you will see that the “HOW TO START” section tells you to adjust the first line
    of the *briscola.tk* script to point it to your Tk shell and to adjust the second
    line of the script to point to the directory where the various Briscola files
    are located.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数以 tarball 形式提供的应用程序都包含一个 README 文件，其中包含了关于如何安装和使用该应用程序所需的信息。如果你在文件管理器中的 *briscola*
    文件夹中双击 **README** 文件，你会看到“如何开始”部分告诉你需要调整 *briscola.tk* 脚本的第一行，使其指向你的 Tk shell，并调整脚本的第二行，使其指向存放各种
    Briscola 文件所在的目录。
- en: 'To perform the adjustments as instructed in the README file, just follow these
    steps:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 按照README文件中的说明进行调整，只需遵循以下步骤：
- en: 'Find the Tk shell, called *Wish*, by typing **`locate wish`** in the Terminal
    window and pressing enter. Note the location on a piece of paper. You may get
    a number of locations in your search results, but the one you want is `/usr/bin/wish`.
    If you don’t see it, it’s probably because you haven’t updated the database since
    doing [Project 8B: More Command Practice with pyWings](ch08.html#project_8b_colon_more_command_practice
    "Project 8B: More Command Practice with pyWings") in [Project 8B: More Command
    Practice with pyWings](ch08.html#project_8b_colon_more_command_practice "Project
    8B: More Command Practice with pyWings"), so type **`sudo updatedb`**, press enter,
    and then try locating Wish again.'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端窗口中输入**`locate wish`**并按回车键来查找名为*Wish*的Tk外壳。在一张纸上记下位置。您可能会在搜索结果中获得多个位置，但您想要的是`/usr/bin/wish`。如果您看不到它，那可能是因为您自从在[项目8B：pyWings的更多命令练习](ch08.html#project_8b_colon_more_command_practice
    "项目8B：pyWings的更多命令练习")中执行以来没有更新数据库，所以输入**`sudo updatedb`**，按回车键，然后再次尝试定位Wish。
- en: Direct the Terminal to the *briscola* folder by typing **`cd briscola`** and
    pressing enter.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端窗口中输入**`cd briscola`**并按回车键，将终端指向*briscola*文件夹。
- en: 'Use the GNU Nano editor, which we used in [Project 8A: Creating a Plan](ch08.html#project_8a_colon_creating_a_plan
    "Project 8A: Creating a Plan") in [Compressing and Extracting Compressed Single
    Files](ch08.html#compressing_and_extracting_compressed_si "Compressing and Extracting
    Compressed Single Files"), to edit the *briscola.tk* file by typing **`nano briscola.tk`**
    and pressing enter. The *briscola.tk* file will appear in the Nano editor in your
    Terminal window.'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们在[项目8A：制定计划](ch08.html#project_8a_colon_creating_a_plan "项目8A：制定计划")中使用的GNU
    Nano编辑器，通过输入**`nano briscola.tk`**并按回车键来编辑*briscola.tk*文件。*briscola.tk*文件将出现在您的终端窗口中的Nano编辑器中。
- en: Change the very first line of the *briscola.tk* file from `#!/usr/local/bin/wish`
    to **`#!/usr/bin/wish`**.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*briscola.tk*文件的第一行从`#!/usr/local/bin/wish`更改为**`#!/usr/bin/wish`**。
- en: In the second line, change `/usr/local/games/briscola` to **`/usr/share/games/briscola`**,
    which is where you will place Briscola in just a bit. Your editor window should
    now look like [Figure 8-14](ch08.html#configuring_briscola_with_the_gnu_nano_e
    "Figure 8-14. Configuring Briscola with the GNU Nano editor").
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二行，将`/usr/local/games/briscola`更改为**`/usr/share/games/briscola`**，这是您稍后将放置Briscola的位置。此时，您的编辑器窗口应类似于[图8-14](ch08.html#configuring_briscola_with_the_gnu_nano_e
    "图8-14. 使用GNU Nano编辑器配置Briscola")。
- en: '![Configuring Briscola with the GNU Nano editor](httpatomoreillycomsourcenostarchimages1263650.png.jpg)'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用GNU Nano编辑器配置Briscola](httpatomoreillycomsourcenostarchimages1263650.png.jpg)'
- en: Figure 8-14. Configuring Briscola with the GNU Nano editor
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8-14. 使用GNU Nano编辑器配置Briscola
- en: Press ctrl-X on your keyboard.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下键盘上的ctrl-X键。
- en: Type **`y`** and press enter to save your changes.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**`y`**并按回车键以保存您的更改。
- en: Type **`cd`** and press enter to return the Terminal to your Home folder.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**`cd`**并按回车键，将终端返回到您的家目录。
- en: '8C-4: Moving the Briscola Folder to a Global Location'
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8C-4：将Briscola文件夹移动到全局位置
- en: You could move the *briscola* folder to the *LocalApps* folder and play the
    game from there, as you did with pyWings. But this time around, let’s do things
    a bit differently by moving the whole thing to global territory. This not only
    keeps it safe from any obsessive housekeeping tendencies you might have but also
    allows all users on the same computer to play the game. You will need to use the
    `sudo` command to do this so that you can have write access in those protected
    folders.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将*briscola*文件夹移动到*LocalApps*文件夹，并从那里玩游戏，就像您使用pyWings时做的那样。但这次，让我们通过将整个文件夹移动到全局区域来做一些不同的事情。这不仅使它免受您可能有的任何强迫性的整理倾向的影响，而且允许同一台电脑上的所有用户玩游戏。您需要使用`sudo`命令来完成此操作，以便您可以在受保护的文件夹中获得写入权限。
- en: 'Just type the following command in the Terminal window and press enter:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在终端窗口中输入以下命令并按回车键：
- en: '[PRE17]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When you are prompted for your password, type it and press enter.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当您被提示输入密码时，输入它并按回车键。
- en: '8C-5: Creating a Launchable Link for Briscola'
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8C-5：为Briscola创建可启动链接
- en: 'Even though you’ve moved Briscola to a global location, you still can’t run
    it with a simple one-word command because the *briscola.tk* file is not in the
    system’s command search path. Just as you did for pyWings, you will now create
    a launchable link for Briscola to solve that problem. Here are the steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你已经将Briscola移动到全局位置，但你仍然不能通过简单的单字命令来运行它，因为*briscola.tk*文件不在系统的命令搜索路径中。就像你为pyWings所做的那样，你现在将创建一个可启动的链接来解决该问题。以下是步骤：
- en: In the Terminal, type **`cd /usr/games`** and press enter.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，输入**`cd /usr/games`**并按回车键。
- en: Now create the link by typing **`sudo ln -s /usr/share/games/briscola/briscola.tk
    briscola`** and pressing enter.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过输入**`sudo ln -s /usr/share/games/briscola/briscola.tk briscola`**并按回车键来创建链接。
- en: Type **`cd`** and press enter to return the Terminal to your Home folder.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**`cd`**并按回车键将终端返回到你的主文件夹。
- en: You can now easily run Briscola by typing **`briscola`** in the Terminal and
    pressing enter.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在终端中通过输入**`briscola`**并按回车键轻松运行Briscola。
- en: Can You Do the Same Thing with pyWings?
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能用pyWings做同样的事情吗？
- en: 'Sure. If you want to move pyWings to a global location, just follow the same
    procedure for moving the *pywings* folder and creating the link as you did for
    Briscola, making the necessary substitutions, of course. You will have to remove
    the previously created pyWings link, though, by typing the following command and
    pressing enter:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当然。如果你想将pyWings移动到全局位置，只需按照移动*pywings*文件夹和创建链接的相同程序进行，就像你为Briscola所做的那样，当然需要做必要的替换。不过，你必须通过输入以下命令并按回车键来删除之前创建的pyWings链接：
- en: '[PRE18]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After that, move the *pywings* folder to global territory by typing **`sudo
    mv ˜/LocalApps/pywings/usr/share/games/pywings`** and pressing enter. When prompted
    for your password, type it and press enter. You can then create the launchable
    link by typing **`cd /usr/games`**, pressing enter, typing **`sudo ln -s /usr/share/games/pywings/pywings.py
    pywings`**, and pressing enter once more.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，通过输入**`sudo mv ~ /LocalApps/pywings/usr/share/games/pywings`**并按回车键将*pywings*文件夹移动到全局区域。当提示输入密码时，输入密码并按回车键。然后，你可以通过输入**`cd
    /usr/games`**，按回车键，输入**`sudo ln -s /usr/share/games/pywings/pywings.py pywings`**，再按一次回车键来创建可启动的链接。
- en: Playing Briscola
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩Briscola
- en: As I already mentioned, Briscola is easy—about as easy a card game as there
    is. It is a trick-taking game, which means that you put out a card and then your
    opponent puts out a card, and the one who puts out the higher point-value card
    wins the hand, or *trick*. Points are awarded on the basis of the cards involved
    in that trick. The winner of the trick then goes on to *lead* the next trick,
    meaning that the winner puts out his or her card first the next time around. When
    all the cards are played, the points for each player are tallied, and the player
    with the higher points wins. It’s even much simpler to do than it is to describe.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，Briscola很简单——几乎和任何纸牌游戏一样简单。它是一种技巧牌游戏，这意味着你先出一张牌，然后你的对手出一张牌，出点数更高的牌的人赢得这一轮，或者称为*技巧*。根据那一轮中涉及的牌来计算分数。赢得那一轮的人接着*领先*下一轮，这意味着赢家将首先出牌。当所有牌都出完时，计算每位玩家的分数，分数更高的玩家获胜。这甚至比描述的要简单得多。
- en: If you would like a more detailed set of rules for playing Briscola (and just
    about any other card game in the world), check out [http://www.pagat.com/](http://www.pagat.com/).
    There are also great video guides out there on YouTube, including my favorite
    at [http://www.youtube.com/watch?v=jpXpMNBPN8c](http://www.youtube.com/watch?v=jpXpMNBPN8c).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更详细的Briscola（以及世界上几乎任何其他纸牌游戏）的规则，请查看[http://www.pagat.com/](http://www.pagat.com/)。YouTube上也有许多优秀的视频指南，包括我最喜欢的[http://www.youtube.com/watch?v=jpXpMNBPN8c](http://www.youtube.com/watch?v=jpXpMNBPN8c)。
- en: 'Project 8D: Compiling and Installing Programs from Source—Xmahjongg'
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目8D：从源代码编译和安装程序——Xmahjongg
- en: Though it was far more common in earlier days, *compiling programs from source*
    seems to be a phrase you still hear more in the Linux world than in any other.
    For the beginner, just the mention of compiling a program from source seems off-putting.
    The words *compile* and *source* seem to instill a sense of foreboding in the
    heart of the new user. That certainly was the case for me, anyway.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在早期更为常见，但*从源代码编译程序*似乎是一个在Linux世界中比在其他任何地方都更常听到的短语。对于初学者来说，仅仅提到从源代码编译程序似乎就让人望而却步。*编译*和*源代码*这两个词似乎在新用户心中灌输了一种不安的感觉。至少对我来说是这样的。
- en: You can live long and prosper without ever bothering to compile anything on
    your system. You can move along quite happily with your system as is, or you can
    just install programs by means of the much more convenient Ubuntu Software Center.
    Still, once in the Linux world, you are likely to come across this installation
    method and may well become curious, especially if you move into the geekier side
    of the community.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不费心在你的系统上编译任何东西的情况下长寿并繁荣。你可以带着你的系统继续快乐地前进，或者你可以通过更方便的Ubuntu软件中心安装程序。尽管如此，一旦进入Linux世界，你很可能会遇到这种安装方法，并且可能会对此产生好奇心，尤其是如果你转向社区的更技术的一面。
- en: What Is Source?
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是源代码？
- en: To get started, it is probably a good idea to understand what *source* is so
    as to understand a bit about how a program actually metamorphoses from its primitive
    state on the programmer’s computer into an up-and-running application on your
    machine. First the programmer writes a program in a programming language. You
    have probably heard of programming languages such as BASIC or C, and there are
    many others. What the programmer actually writes with such a language is a set
    of instructions called the *source code*, or *source*. Your computer, however,
    cannot actually understand any of that source on its own. It is as if the computer
    speaks ancient Greek and the source code is all written in French.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始学习，可能先了解什么是*源代码*是个不错的主意，这样你就能对程序是如何从程序员电脑上的原始状态转变为在你的机器上运行的应用程序有一个大致的了解。首先，程序员用一种编程语言编写程序。你可能听说过像BASIC或C这样的编程语言，还有很多其他的语言。程序员实际上用这种语言编写的是一组被称为*源代码*或*源*的指令。然而，你的电脑实际上并不能理解这些源代码中的任何一部分。这就像电脑说的是古希腊语，而源代码全部是用法语写的。
- en: The various languages that programmers use are called *high-level* languages
    — they are relatively easy for programmers to read. The computer, on the other
    hand, understands only *low-level languages*, which are quite difficult for most
    mere mortal programmers to deal with. To convert the high-level language instructions
    into a low-level language, the computer needs some other program to translate.
    To put it another way, the computer needs an interpreter.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员使用的各种语言被称为*高级语言*——它们相对容易阅读。另一方面，电脑只理解*低级语言*，这对大多数普通程序员来说处理起来相当困难。要将高级语言指令转换为低级语言，电脑需要另一个程序来翻译。换句话说，电脑需要一个解释器。
- en: If this translation process takes place while a program is running, the translator
    program is actually called an *interpreter*. Applications that run using an interpreter
    are usually called *scripts*. The pyWings and Briscola applications earlier in
    this chapter are examples of such script applications.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个翻译过程在程序运行时进行，那么这个翻译程序实际上被称为*解释器*。使用解释器运行的应用程序通常被称为*脚本*。本章前面提到的pyWings和Briscola应用程序就是这类脚本应用程序的例子。
- en: The problem with such scripts is that they can be slower than most of the applications
    you’re familiar with—the computer must run an interpreter, interpret the source
    code, and run the application all at the same time. This is like having a French
    book translated into Greek by a live interpreter; it’s very slow indeed.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这种脚本的问题在于，它们可能比你所熟悉的多数应用程序运行得慢——电脑必须运行解释器，解释源代码，然后运行应用程序。这就像有一本法语书由一个现场翻译员翻译成希腊语；确实非常慢。
- en: As an alternative, most programs use a compiler instead of an interpreter. A
    *compiler* translates the high-level source code into low-level *machine code*,
    or *object code*, that the computer can understand before the application is run.
    Once this translation is done, the computer never has to bother with the high-level
    instructions again; it can merely read the translated version each time it runs
    the program. This is like having a translated version of a foreign book that you
    can read any time you want. Because computers can run compiled programs without
    simultaneously using an interpreter, compiled programs run faster than scripts.
    Most applications for all operating systems are, therefore, compiled.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代，大多数程序使用编译器而不是解释器。*编译器*在应用程序运行之前将高级源代码转换为电脑可以理解的低级*机器代码*或*目标代码*。一旦完成这种转换，电脑就再也不必担心这些高级指令了；每次运行程序时，它只需读取翻译后的版本即可。这就像有一本你可以随时阅读的外国书的翻译版本。因为电脑可以在不同时使用解释器的情况下运行编译程序，所以编译程序比脚本运行得更快。因此，所有操作系统的应用程序大多数都是编译的。
- en: The Basics
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础知识
- en: 'The process of compiling an application from source and then installing it
    is straightforward—a truly “one, two, three” bit of presto change-o. Basically,
    after extracting the source code from an archived file (usually in the form of
    a tarball), you would use the following commands to accomplish the task:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码编译应用程序然后安装的过程很简单——一个真正的“一、二、三”的魔术变化。基本上，在从归档文件（通常是 tarball 形式）中提取源代码后，你会使用以下命令来完成这项任务：
- en: '**`./configure`**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**`./configure`**'
- en: To configure a *makefile*, which provides instructions for the `make` command
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置一个**makefile**，它为 `make` 命令提供指令
- en: '**`make`**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**`make`**'
- en: To translate the source code into object code that the computer can understand
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 将源代码翻译成计算机可以理解的目标代码
- en: '**`sudo make install`**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**`sudo make install`**'
- en: To give yourself write privileges in protected folders and then install the
    application
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在受保护的文件夹中获得写入权限然后安装应用程序
- en: '**`make clean`**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**`make clean`**'
- en: To tidy up the leftovers once the process is complete (to clean up the mess)
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程完成后整理残留物（清理混乱）
- en: I know that sounds like a lot of commands, but as I always say, just doing it
    is easier than reading it on the page, so fear not.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这听起来像很多命令，但正如我经常说的，实际操作比在页面上阅读它要容易得多，所以不要害怕。
- en: '8D-1: Installing the Tools You Need'
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8D-1：安装所需的工具
- en: 'Before doing anything else, you have to get your system ready to do what you’re
    about to ask of it. Because Ubuntu is designed with the average computer user
    in mind, it does not come with the various applications and libraries you need
    to compile applications from source. Fortunately, however, everything you need
    to get the job done is available via the Ubuntu Software Center. To get ready
    for the work at hand in this chapter (and many other jobs you are likely to do
    on your own in the future), perform searches for and install the following packages:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何事情之前，你必须让你的系统准备好执行你即将要求它做的事情。因为 Ubuntu 是为普通计算机用户设计的，它没有包含你编译源代码所需的各种应用程序和库。然而，幸运的是，你需要的所有东西都可以通过
    Ubuntu 软件中心获得。为了准备本章的工作（以及你未来可能自己做的许多其他工作），请搜索并安装以下软件包：
- en: build-essential
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: build-essential
- en: libgtk2.0-dev
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libgtk2.0-dev
- en: '8D-2: Downloading and Extracting the Xmahjongg File'
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8D-2：下载和提取 Xmahjongg 文件
- en: To get some hands-on experience with compiling a program from source, you will
    be working with a game called Xmahjongg, which you can see in [Figure 8-15](ch08.html#the_xmahjongg_game
    "Figure 8-15. The Xmahjongg game"). If you’ve tried the version of Mahjongg that
    comes with your Ubuntu distribution, you will notice that this one is much easier
    on your eyes and is a bit more colorful (check out the project site at [http://www.lcdf.org/xmahjongg/](http://www.lcdf.org/xmahjongg/)
    to catch a glimpse of it in its full-color glory).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得从源代码编译程序的实际操作经验，你将使用一个名为 Xmahjongg 的游戏，你可以在[图 8-15](ch08.html#the_xmahjongg_game
    "图 8-15. Xmahjongg 游戏")中看到它。如果你尝试过随 Ubuntu 发行版一起提供的 Mahjongg 版本，你会注意到这个版本对眼睛更友好，颜色也更加丰富（查看项目网站
    [http://www.lcdf.org/xmahjongg/](http://www.lcdf.org/xmahjongg/)，以一睹其全彩风采）。
- en: '![The Xmahjongg game](httpatomoreillycomsourcenostarchimages1263652.png.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![Xmahjongg 游戏](httpatomoreillycomsourcenostarchimages1263652.png.jpg)'
- en: Figure 8-15. The Xmahjongg game
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-15. Xmahjongg 游戏
- en: Xmahjongg is available via the Ubuntu Software Center, so it’s not absolutely
    necessary to install it in the way you are about to, but doing so provides a perfect
    opportunity to learn how to compile a program from source. The amount of source
    code isn’t all that great, so compiling won’t take too much time, and it requires
    no tinkering.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Xmahjongg 可通过 Ubuntu 软件中心获得，所以按照你即将要做的方式安装它并不是绝对必要的，但这样做提供了一个学习如何从源代码编译程序的理想机会。源代码的数量并不多，编译不会花费太多时间，也不需要调整。
- en: To get started, you will have to download the Xmahjongg source code. You can
    get this from the Xmahjongg project page at [http://www.lcdf.org/xmahjongg/](http://www.lcdf.org/xmahjongg/).
    Download the tarball *xmahjongg-3.7.tar.gz* or a newer version if there is one.
    Do not download any of the other file types available on that page.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你必须下载 Xmahjongg 源代码。你可以从 Xmahjongg 项目页面 [http://www.lcdf.org/xmahjongg/](http://www.lcdf.org/xmahjongg/)
    获取。下载 *xmahjongg-3.7.tar.gz* 或更新的版本（如果有的话）。不要下载该页面上提供的其他文件类型。
- en: 'If you prefer, you can instead download the Xmahjongg tarball by using the
    `wget` command that you learned in [8C-1: Getting Briscola](ch08.html#c-1_colon_getting_briscola
    "8C-1: Getting Briscola") in [8C-1: Getting Briscola](ch08.html#c-1_colon_getting_briscola
    "8C-1: Getting Briscola"). Just open a Terminal window, type the following command,
    and then press enter:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢，你可以使用你在 [8C-1：获取 Briscola](ch08.html#c-1_colon_getting_briscola "8C-1：获取
    Briscola") 中学到的 `wget` 命令来下载 Xmahjongg 的 tar 文件。只需打开一个终端窗口，输入以下命令，然后按回车键：
- en: '[PRE19]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once you have the file on your hard disk, untar the *xmahjongg-3.7.tar.gz* file.
    You can do this either by using the command line, as you learned to do earlier
    in the chapter, or by double-clicking the file and dragging its contents into
    the appropriate folder. To make it easier for you to follow along with the directions
    I’ll be giving you, be sure to place the untarred Xmahjongg folder in your Home
    folder. Then you will be ready to roll.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在硬盘上有了这个文件，解压 *xmahjongg-3.7.tar.gz* 文件。你可以通过使用命令行来完成，就像你在本章前面学到的，或者通过双击文件并将内容拖动到适当的文件夹中。为了让你更容易跟随我将给出的指示，请确保将解压后的
    Xmahjongg 文件夹放在你的主文件夹中。然后你就可以开始操作了。
- en: Normally at this point, you would look through the folder to find some instructions
    for dealing with the package, just as you did earlier in the chapter for Briscola.
    In most source code packages, this information is included in an INSTALL file,
    like the one in the *xmahjongg-3.7* folder ([Figure 8-16](ch08.html#identifying_a_packageas_install_file
    "Figure 8-16. Identifying a package’s INSTALL file")). To read the INSTALL file,
    just double-click it, and it will open in Text Editor.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在这个时候，你会浏览文件夹以找到处理该软件包的一些说明，就像你在本章前面为 Briscola 做的那样。在大多数源代码软件包中，这些信息包含在一个名为
    INSTALL 的文件中，就像 *xmahjongg-3.7* 文件夹中的那样（[图 8-16](ch08.html#identifying_a_packageas_install_file
    "图 8-16. 识别软件包的 INSTALL 文件")）。要阅读 INSTALL 文件，只需双击它，它将在文本编辑器中打开。
- en: '![Identifying a package’s INSTALL file](httpatomoreillycomsourcenostarchimages1263654.png.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![识别软件包的 INSTALL 文件](httpatomoreillycomsourcenostarchimages1263654.png.jpg)'
- en: Figure 8-16. Identifying a package’s INSTALL file
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-16. 识别软件包的 INSTALL 文件
- en: In this case, you can simply close the INSTALL file, because it prescribes the
    same steps I list next. However, in the future, when you install other programs
    from source, you will need to follow the instructions in the INSTALL files that
    come with the source files. Fortunately, the instructions in most INSTALL files
    will match the process I am about to describe.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以简单地关闭 INSTALL 文件，因为它规定了我接下来要列出的相同步骤。然而，在将来，当你从源代码安装其他程序时，你需要遵循源代码文件中包含的
    INSTALL 文件中的说明。幸运的是，大多数 INSTALL 文件中的说明将与我将要描述的过程相匹配。
- en: Of course, it may well happen that you take a look at the contents of the INSTALL
    file and start wondering what alien tongue it is written in. In cases when you
    have no idea what the INSTALL file is going on about, just look for a *configure*
    file in the package folder. If you find one, you should be able to follow the
    instructions in this project.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能会查看 INSTALL 文件的内容，并开始怀疑它使用的是哪种外星语言。在你对 INSTALL 文件的内容一无所知的情况下，只需在软件包文件夹中寻找一个
    *configure* 文件。如果你找到了，你应该能够遵循这个项目中的说明。
- en: '8D-3: Running configure and make for Xmahjongg'
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8D-3：为 Xmahjongg 运行配置和 make
- en: 'Now that you have downloaded and untarred the Xmahjongg tarball, installation
    is pretty standard. Here’s what you need to do:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经下载并解压了 Xmahjongg 的 tar 文件，安装过程相当标准。以下是你需要做的：
- en: Open a Terminal window and then move into the new folder by typing **`cd xmahjongg*`**
    and pressing enter.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，然后通过输入 **`cd xmahjongg`** 并按回车键进入新文件夹。
- en: The next step is sort of a setup phase that runs the configure script in the
    *xmahjongg-3.7* folder. The configure script checks what files, compilers, and
    other things it needs, and then it searches your computer to see whether those
    things are there and, if so, where. Based on this information, it writes a file
    called a *makefile*, which is a set of instructions that will tell the `make`
    command in the subsequent step how to set things up specifically for your system
    configuration.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一步是一个设置阶段，在这个阶段中，会在 *xmahjongg-3.7* 文件夹中运行配置脚本。配置脚本会检查它需要哪些文件、编译器和其他东西，然后它会搜索你的电脑以查看这些东西是否存在，以及如果存在，它们在哪里。基于这些信息，它会写一个名为
    *makefile* 的文件，这是一个指令集，它将在后续步骤中告诉 `make` 命令如何针对你的系统配置具体设置东西。
- en: Configure the program by typing **`./configure`** and pressing enter.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入 **`./configure`** 并按回车键来配置程序。
- en: While you are running `configure`, you will see lots of odd and mysterious things
    flowing through your Terminal window; this is essentially a running account of
    what is going on, every step of the way. This can take a bit of time, but don’t
    worry. As long as the mysterious text keeps flowing and you don’t get an error
    message at the very end of the whole process, all will be well.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您运行 `configure` 时，您将在终端窗口中看到很多奇怪和神秘的事物；这基本上是对整个过程每一步正在发生的事情的记录。这可能需要一些时间，但请放心。只要神秘的文字继续流动，并且在整个过程的最后没有错误信息，一切都会顺利。
- en: Once `configure` has done its thing, you will see your prompt again, and you
    can go on to the translation, or *compilation*, step. The `make` command reads
    the makefile created by `configure` to see how things need to be set up on your
    machine. Then it proceeds to call on the compiler to translate the high-level
    source code into low-level, machine-readable files that can be installed in the
    subsequent step.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦 `configure` 完成其工作，您将再次看到提示符，然后可以继续进行翻译，或*编译*步骤。`make` 命令读取 `configure` 创建的
    makefile，以查看需要在您的机器上如何设置。然后它调用编译器将高级源代码转换为低级、机器可读的文件，这些文件可以在后续步骤中安装。
- en: To perform this translation, type **`make`** and press enter.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行此翻译，请输入**`make`**并按回车键。
- en: Again, you will be treated to even more mysterious text flowing through the
    window and a short wait, usually a tad longer than for the `configure` process.
    Once `make` has done its job and you see your prompt again, you are ready to install
    the program.
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，您将看到更多神秘的文字在窗口中流动，以及一段短暂的等待，通常比 `configure` 过程稍长一些。一旦 `make` 完成其工作，您再次看到提示符，您就准备好安装程序了。
- en: Up to this point, you have not changed your system in any way. All the changes
    thus far have taken place in the *xmahjongg-3.7* folder only—your system is still
    as pure as the day you started. Of course, all that is going to end right now
    when you perform the final installation step.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您以任何方式都没有更改您的系统。到目前为止的所有更改都只发生在 *xmahjongg-3.7* 文件夹中——您的系统仍然像您开始时那样纯净。当然，所有这些都将随着您执行最终安装步骤而结束。
- en: '8D-4: Installing and Running Xmahjongg'
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8D-4：安装和运行 Xmahjongg
- en: Now you’ve come to the last step in this part of the process, `make install`.
    Here you are telling your system to install what you have created, or *compiled*,
    in the `make` step. Note that because installation takes place in permissions-protected
    parts of your system, you will need to add `sudo` to the command string to give
    yourself administrative privileges.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经到达了这个过程这一部分的最后一步，`make install`。在这里，您正在告诉系统安装您在 `make` 步骤中创建的或*编译*的内容。请注意，由于安装发生在系统权限受保护的区域，您需要在命令字符串中添加
    `sudo` 以获得管理员权限。
- en: To perform the installation, type **`sudo make install`** and press enter. You
    will be prompted for your password. After you type it and press enter, the installation
    process will take place. Once your Terminal brings you back to your user prompt,
    Xmahjongg will be installed and ready to run from the Terminal. Just type **`xmahjongg`**
    and press enter.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行安装，请输入**`sudo make install`**并按回车键。系统将提示您输入密码。输入密码并按回车后，安装过程将开始。一旦您的终端返回到用户提示符，Xmahjongg
    将安装完毕，并可以从终端运行。只需输入**`xmahjongg`**并按回车键即可。
- en: '8D-5: Cleaning Up and/or Uninstalling Xmahjongg'
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8D-5：清理和/或卸载 Xmahjongg
- en: Once you are done and everything seems to be working as it should, you would
    normally tidy things up in the Xmahjongg folder by getting rid of any unnecessary
    files. You can do this via the Terminal by using the cd command to go back into
    the Xmahjongg folder, typing **`make clean`**, and then pressing enter.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成，并且一切似乎都按预期工作，您通常会通过终端清理 Xmahjongg 文件夹，删除任何不必要的文件。您可以通过使用 cd 命令回到 Xmahjongg
    文件夹，输入**`make clean`**，然后按回车键来完成此操作。
- en: If you want to uninstall Xmahjongg, open a Terminal window, go back to the Xmahjongg
    folder by using the `cd` command, type **`sudo make uninstall`**, and finally
    press enter. The routine is essentially the same for any applications installed
    in this way, though as you might imagine, uninstallation isn’t always as smooth
    a process as what I’ve just described (and it’s definitely not as easy as it is
    via the Ubuntu Software Center).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想卸载 Xmahjongg，打开一个终端窗口，使用 `cd` 命令回到 Xmahjongg 文件夹，输入**`sudo make uninstall`**，然后按回车键。对于以这种方式安装的任何应用程序，这个过程基本上是相同的，尽管如您所想象的那样，卸载过程并不总是像我所描述的那样顺利（而且肯定没有通过
    Ubuntu 软件中心那么简单）。
- en: The main reason for the uninstallation process being less than cooperative is
    that the `make uninstall` routine requires you to have kept the original project
    folder, which means you have to keep a bit of clutter you normally wouldn’t need
    to bother with. On top of this, some projects do not provide a `make uninstall`
    routine at all. This means that you have to keep track of where everything has
    been installed in your system and then remove each item using a series of `sudo
    rm` commands.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程不合作的主要原因在于`make uninstall`程序要求你保留原始项目文件夹，这意味着你必须保留一些你通常不需要麻烦的杂乱东西。除此之外，一些项目甚至根本不提供`make
    uninstall`程序。这意味着你必须跟踪系统中所有内容的安装位置，然后使用一系列`sudo rm`命令逐个删除每个项目。
- en: All that aside, go ahead, have some fun, and put your command-line skills to
    the test. You’ll have something to tell your grandkids about in the future.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，尽情享受，测试你的命令行技能。将来你会有一些可以告诉孙子辈的故事。
- en: Customizing the Terminal
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制终端
- en: The Terminal is a very simple application in terms of looks, though you can
    spice things up a bit if you’re so inclined. Not only can you change the background
    and text colors in the Terminal, but you can even display one of your favorite
    photos as a background (as shown in [Figure 8-17](ch08.html#a_terminal_window_with_customized_backgr
    "Figure 8-17. A Terminal window with customized background and font colors"))
    or make the background transparent.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 从外观上看，终端是一个非常简单的应用程序，尽管如果你愿意，你可以稍微装饰一下。你不仅可以在终端中更改背景和文本颜色，甚至还可以显示你最喜欢的一张照片作为背景（如图8-17所示）或使背景透明。
- en: '![A Terminal window with customized background and font colors](httpatomoreillycomsourcenostarchimages1263656.png.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![带有定制背景和字体颜色的终端窗口](httpatomoreillycomsourcenostarchimages1263656.png.jpg)'
- en: Figure 8-17. A Terminal window with customized background and font colors
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-17. 带有定制背景和字体颜色的终端窗口
- en: To change the Terminal background, right-click anywhere in the Terminal and
    select **Profiles** ▸ **Profile** Preferences. When the Editing Profile window
    appears, click the tab for the part of the profile you want to edit. For example,
    to add a background image, click the **Background** tab, select **Background image**
    ([Figure 8-18](ch08.html#customizing_the_terminal_window "Figure 8-18. Customizing
    the Terminal window")), and then navigate to the photo you want to use as your
    background by clicking the **Menu** button next to the words Image file and finding
    the file in the Select Background Image window. Once you’ve found the photo of
    your choice, click **Open**. Depending on the image you use for your background,
    you may find it rather difficult to see text once your image appears in the Terminal.
    If so, try moving the slider under the words *Shade trans*parent or image background
    in the Editing Profile window. If that still doesn’t do the trick, click the **Colors**
    tab, deselect **Use colors from system theme**, and then try some of the preset
    Foreground and Background combinations from the menu button next to the words
    *Built-in schemes*.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改终端背景，在终端的任何位置右键单击并选择**配置文件** ▸ **配置文件**首选项。当出现编辑配置文件窗口时，点击你想要编辑的配置文件部分的标签页。例如，要添加背景图片，点击**背景**标签页，选择**背景图片**
    ([图8-18](ch08.html#customizing_the_terminal_window "图8-18. 定制终端窗口"))，然后通过点击旁边文字“图片文件”旁边的**菜单**按钮并找到你想要用作背景的图片。一旦找到你选择的图片，点击**打开**。根据你用作背景的图片，你可能会发现一旦图片出现在终端中，你很难看到文本。如果是这样，尝试在编辑配置文件窗口中移动“*阴影透明度*”或“图像背景”下的滑块。如果这仍然不起作用，点击**颜色**标签页，取消选择**使用系统主题颜色**，然后尝试一些预设的前景和背景组合，这些组合位于“*内置方案*”旁边的菜单按钮。
- en: '![Customizing the Terminal window](httpatomoreillycomsourcenostarchimages1263658.png.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![定制终端窗口](httpatomoreillycomsourcenostarchimages1263658.png.jpg)'
- en: Figure 8-18. Customizing the Terminal window
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-18. 定制终端窗口
- en: If you just want to make the background transparent, go back to the **Background**
    tab, select **Transparent background**, and drag the slider to the right. You
    can also use the slider to adjust the shading of your background image if you
    choose to go that route.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想使背景透明，回到**背景**标签页，选择**透明背景**，并将滑块拖到右边。如果你选择这样做，你也可以使用滑块来调整背景图像的阴影。
- en: Depending on the colors in your background image or in your desktop wallpaper
    (if you’ve gone the transparent route), you may also want to change the font color
    for your Terminal to make things easier to see. To do this, click the **Colors**
    tab, deselect **Use colors from system theme**, and then make the appropriate
    font color selection.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的背景图片或桌面壁纸中的颜色（如果您选择了透明模式），您可能还希望更改终端的字体颜色以便更容易看到。为此，点击**颜色**标签，取消选择**使用系统主题颜色**，然后进行适当的字体颜色选择。
- en: Tabbed Shell Sessions in the Terminal
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终端中的标签式 shell 会话
- en: 'To wrap things up in this chapter, I thought I’d mention one particularly convenient
    feature of the GNOME Terminal: tabs. Just as you can view multiple web pages in
    one Firefox web browser window through the use of tabs, tabs in the Terminal application
    allow you to have more than one shell session running at the same time without
    having more Terminal windows open (see [Figure 8-19](ch08.html#running_multiple_shell_sessions_in_tabs
    "Figure 8-19. Running multiple shell sessions in tabs within the Terminal")).
    This reduces the amount of desktop clutter and generally makes things easier to
    deal with. You can open a new Terminal tab by clicking anywhere in the Terminal
    and selecting **Open Tab** in the pop-up menu.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章内容，我想提及 GNOME 终端的一个特别方便的功能：标签。就像您可以通过使用标签在单个 Firefox 网络浏览器窗口中查看多个网页一样，终端应用程序中的标签允许您同时运行多个
    shell 会话，而无需打开更多的终端窗口（参见[图 8-19](ch08.html#running_multiple_shell_sessions_in_tabs
    "图 8-19. 在终端中通过标签运行多个 shell 会话")). 这减少了桌面上的杂乱，通常也使得处理事情变得更加容易。您可以通过在终端中点击任何位置并选择弹出菜单中的**打开标签**来打开一个新的终端标签。
- en: '![Running multiple shell sessions in tabs within the Terminal](httpatomoreillycomsourcenostarchimages1263660.png.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![在终端中通过标签运行多个 shell 会话](httpatomoreillycomsourcenostarchimages1263660.png.jpg)'
- en: Figure 8-19. Running multiple shell sessions in tabs within the Terminal
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-19. 在终端中通过标签运行多个 shell 会话
