<html><head></head><body><section class="chapter" epub:type="chapter" id="disks_and_filesystems" title="Chapter&#xA0;8.&#xA0;Disks and Filesystems"><div class="titlepage"><div><div><h2 class="title">Chapter 8. Disks and Filesystems</h2></div></div></div><div class="epigraph" epub:type="epigraph"><div class="literallayout"><p><span class="emphasis"><em>Oh, my head hurts bad.</em></span><br/>
<span class="emphasis"><em>Rings of ones and zeros, ouch!</em></span><br/>
<span class="emphasis"><em>Filesystems hide them.</em></span></p></div></div><p><span class="inlinemediaobject"><a id="inline_id00009"/><img alt="" src="httpatomoreillycomsourcenostarchimages1616079.png"/></span> Proper data management is perhaps a systems administrator’s most vital duty. You can replace almost every computer component, but the data on your disk is irreplaceable. Perhaps that data isn’t important or it’s backed up, but losing files will ruin your day. As a sysadmin, you must protect important data by carefully managing your disks and filesystems.</p><p>We covered the basics of disklabels and MBR partitions in <a class="xref" href="ch02.html" title="Chapter 2. Installation Preparations">Chapter 2</a>, but OpenBSD lets you use and abuse disks and filesystems in any number of ways. You’ll learn how in this chapter.</p><div class="sect1" title="Device Nodes"><div class="titlepage"><div><div><h2 class="title" id="device_nodes" style="clear: both">Device Nodes</h2></div></div></div><p><a class="indexterm" id="idx0145"/><a class="indexterm" id="idx0295"/><a class="indexterm" id="idx0438"/><a class="indexterm" id="idx1430"/>A <span class="emphasis"><em>device node</em></span> is a file that provides a logical interface to a piece of hardware. By reading from a device node, sending data to it, or using a command on it, you’re telling the operating system to perform an action on a piece of hardware or, in some cases, a logical device.</p><p>Different devices behave differently when data is sent to them. For example, writing to the console makes text appear on the screen or terminal, while writing to a disk device puts data on that disk. (OpenBSD puts device nodes in <span class="emphasis"><em>/dev</em></span> and disallows device nodes on other filesystems.)</p><p>Many disk management programs expect to be given a device name as an argument. Unfortunately, device node names are frequently cryptic and vary widely among operating systems—even on closely related operating systems that run on the same hardware. To simplify your life just a bit, <a class="xref" href="ch08.html#common_disk_device_node_names" title="Table 8-1. Table 8-1: Common Disk Device Node Names">Table 8-1</a> lists the device node names for common OpenBSD disk devices.</p><div class="table"><a id="common_disk_device_node_names"/><div class="table-title">Table 8-1. Table 8-1: Common Disk Device Node Names</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Device Node</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Description</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>/dev/fd*</em></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Floppy disk (block)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>/dev/rfd*</em></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Floppy disk (raw)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>/dev/wd*</em></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>IDE and some SATA disks (block)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>/dev/rwd*</em></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>IDE and some SATA disks (raw)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>/dev/sd*</em></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>SCSI/SAS/SATA/USB/RAID/non-IDE disk (block)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><span class="emphasis"><em>/dev/rsd*</em></span></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>SCSI/SAS/SATA/USB/RAID/non-IDE disk (raw)</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><span class="emphasis"><em>/dev/cd*</em></span></p></td><td style="vertical-align: top; "><p>CD/DVD drive (block)</p></td></tr></tbody></table></div></div><p>Device names also have a number that tells you which instance of that device it refers to. The numbering starts at 0. The first IDE hard drive is <span class="emphasis"><em>/dev/wd0</em></span>, <span class="emphasis"><em>/dev/wd1</em></span> is the second, and <span class="emphasis"><em>/dev/cd1</em></span> is the second CD drive.</p><p>Every partition is assigned a letter. For example, the root partition is <span class="emphasis"><em>a</em></span>, the swap area is <span class="emphasis"><em>b</em></span>, the whole disk is <span class="emphasis"><em>c</em></span>, and so on. Each partition also has a separate device node, the result of appending the partition letter to your disk device name. For example, if you install to a single IDE drive, your root partition is <span class="emphasis"><em>/dev/wd0a</em></span>.</p><div class="sect2" title="Raw and Block Devices"><div class="titlepage"><div><div><h3 class="title" id="raw_and_block_devices">Raw and Block Devices</h3></div></div></div><p>Notice in <a class="xref" href="ch08.html#common_disk_device_node_names" title="Table 8-1. Table 8-1: Common Disk Device Node Names">Table 8-1</a> that devices are listed in either block or raw (character) mode. This refers to how the devices are accessed.</p><div class="sect3" title="Block Devices"><div class="titlepage"><div><div><h4 class="title" id="block_devices">Block Devices</h4></div></div></div><p>Hard disks are usually accessed using a block device node (sometimes called a <span class="emphasis"><em>cooked</em></span> device node). When accessing a device as a block, data transmitted to or from the device is <span class="emphasis"><em>buffered</em></span>, or collected until there is sufficient data to make accessing the device worth the trouble. Block devices are generally considered more efficient than raw devices.</p><p><a class="indexterm" id="idx0242"/><a class="indexterm" id="idx0435"/><a class="indexterm" id="idx1922"/>The device nodes for block devices are named after the device driver; for example, <span class="emphasis"><em>/dev/wd3</em></span>.</p></div><div class="sect3" title="Raw Devices"><div class="titlepage"><div><div><h4 class="title" id="raw_devices">Raw Devices</h4></div></div></div><p>Raw devices are sometimes called <span class="emphasis"><em>character</em></span> devices, because they access a device one character at a time. If you need to control exactly how data appears on a disk (for example, when creating a filesystem) use a raw device. Raw device nodes have an <span class="emphasis"><em>r</em></span> in front of their name, as in <span class="emphasis"><em>/dev/rwd3</em></span>.</p><p>Raw devices do no buffering. When you tell your system to write to a raw device, the data is transmitted immediately. Raw mode works best with software that provides its own buffering or that wants to arrange data in a specific way.</p><p>Here’s an easy way to remember the difference between block and raw throughput: Say you spill a bottle of aspirin. If you pick up each aspirin individually and deposit it directly in the bottle, you’re doing an unbuffered, or raw, transfer. If you pick up the aspirin with your right hand and collect them in your left, then dump a bunch into the bottle at once (along with all of the dirt from your floor), you’re doing a buffered transfer.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id483068" id="id483068">17</a>]</sup></p></div><div class="sect3" title="Choosing Your Mode"><div class="titlepage"><div><div><h4 class="title" id="choosing_your_mode">Choosing Your Mode</h4></div></div></div><p>Address disks (and many other devices) as raw or block by choosing the corresponding device node. Some programs expect to access raw devices, while others expect block devices. If a program opens <span class="emphasis"><em>/dev/sd1a</em></span>, it’s accessing partition <span class="emphasis"><em>a</em></span> on disk <span class="emphasis"><em>sd1</em></span> as a block device. If it opens <span class="emphasis"><em>/dev/rsd1a</em></span>, it’s accessing the exact same partition as a character device.</p><p>Regardless of the mode, the underlying hardware remains the same; the only thing that changes is how you exchange information with the device.</p></div></div><div class="sect2" title="Device Attachment vs. Device Name"><div class="titlepage"><div><div><h3 class="title" id="device_attachment_vs_device_name">Device Attachment vs. Device Name</h3></div></div></div><p>Not long ago, most disks were permanently affixed to a single physical location on the system. If your computer had two IDE buses, each with two hard drives, the operating system knew exactly where to find them, usually at <span class="emphasis"><em>/wd1</em></span> and <span class="emphasis"><em>/wd2</em></span>. A SCSI disk had a SCSI ID and a logical unit number (LUN), and changing them required rebooting the computer. Traditionally, you could use the disk’s location in the system to identify the disk. For example, a booting i386 computer would find the root partition by looking for the hard drive attached to the first port on the first IDE controller, finding the <span class="emphasis"><em>a</em></span> partition on that disk, and reading the filesystem table from that disk. You could go into the BIOS to tell the computer to look for the root partition on a different disk, but the computer still identified the disk by where it was physically attached to the computer.</p><p><a class="indexterm" id="idx0470"/><a class="indexterm" id="idx0522"/><a class="indexterm" id="idx0523"/><a class="indexterm" id="idx0609"/><a class="indexterm" id="idx1322"/><a class="indexterm" id="idx1390"/><a class="indexterm" id="idx1542"/><a class="indexterm" id="idx1546"/><a class="indexterm" id="idx1552"/><a class="indexterm" id="idx1722"/><a class="indexterm" id="idx1928"/><a class="indexterm" id="idx1932"/><a class="indexterm" id="idx1978"/><a class="indexterm" id="idx2010"/><a class="indexterm" id="idx2283"/>Today, disks can appear and disappear from multiple locations on the system. For example, you might attach and remove several flash drives as needed, or hot swap Serial Attached SCSI (SAS) or Serial ATA (SATA) drives from bus to bus. Physical location is no longer a safe way to identify a disk. While <span class="emphasis"><em>/dev/sd0</em></span> is the device node for the first SCSI disk, you cannot assume that the disk currently attached to the first SCSI port is the same disk that was plugged in there the last time the system booted. OpenBSD labels actual disks with unique IDs, as discussed in the next section.</p></div></div><div class="sect1" title="DUIDs and /etc/fstab"><div class="titlepage"><div><div><h2 class="title" id="duids_and_etc_fstab" style="clear: both">DUIDs and /etc/fstab</h2></div></div></div><p>All OpenBSD platforms use the disklabel to identify partitions and other information about a disk. When you label a disk (as we did in <a class="xref" href="ch03.html" title="Chapter 3. Installation Walk-Through">Chapter 3</a> and will do by hand later this chapter), <code class="literal">disklabel</code> adds a <span class="emphasis"><em>disklabel unique identifier</em></span>, or DUID, to the disk label. The DUID is a unique hexadecimal number that lets OpenBSD identify a specific disk.</p><p>To find a disk’s DUID, pass the device name to <code class="literal">disklabel</code> and look for the <code class="literal">duid</code> entry:</p><a id="I_programlisting8_id447035"/><pre class="programlisting"># <span class="strong"><strong>disklabel sd0</strong></span>
…
duid: 55128c3700af5491
…</pre><p>The disk currently attached as <code class="literal">sd0</code> has a DUID of <code class="literal">55128c3700af5491</code>. Even if you physically move the disk so that it becomes <code class="literal">sd9</code> or <code class="literal">sd18</code>, OpenBSD can use the DUID to uniquely identify this disk.</p><p>OpenBSD uses the filesystem table <span class="emphasis"><em>/etc/fstab</em></span> to map filesystems on a disk to mount points using either the disk location or the DUID. Each filesystem appears on its own line in <span class="emphasis"><em>/etc/fstab</em></span>, as shown here:</p><a id="I_programlisting8_id447076"/><pre class="programlisting"><span class="strong"><strong>1</strong></span> 55128c3700af5491.b <span class="strong"><strong>2</strong></span>none <span class="strong"><strong>3</strong></span>swap <span class="strong"><strong>4</strong></span>sw
55128c3700af5491.a / ffs rw 1 1
55128c3700af5491.k /home ffs rw,nodev,nosuid 1 2
55128c3700af5491.d /tmp ffs rw,nodev,nosuid 1 2
…</pre><p>We’ll focus on the first entry to explore what’s going on here. The first field, <code class="literal">55128c3700af5491.b</code> <span class="strong"><strong>1</strong></span>, is the location of the partition. Whereas older systems used the disk device name and the partition letter (such as <span class="emphasis"><em>/dev/sd0a</em></span>), newer systems can use the DUID, a period, and the partition letter (as in <code class="literal">55128c3700af5491.a</code>). By using DUIDs in the filesystem table, OpenBSD can always mount the same disk at the same location, no matter how it’s attached.</p><p>The second field, <code class="literal">none</code> <span class="strong"><strong>2</strong></span>, lists the <span class="emphasis"><em>mount point</em></span>, which is the directory where the filesystem is attached to the directory tree. Every partition you can write files to is attached to a mount point (such as <span class="emphasis"><em>/usr</em></span>, <span class="emphasis"><em>/var</em></span>, and so on), with one partition being the root partition (<span class="emphasis"><em>/</em></span>). Swap space uses a mount point of <code class="literal">none</code>.</p><p><a class="indexterm" id="idx0821"/><a class="indexterm" id="idx1337"/><a class="indexterm" id="idx1711"/>Next, <code class="literal">swap</code> <span class="strong"><strong>3</strong></span>, is the filesystem type. The standard OpenBSD partition uses type <code class="literal">ffs</code>, the UNIX Fast File System. Other options include, but are not limited to, <code class="literal">msdos</code> (Microsoft-style FAT partitions), <code class="literal">mfs</code> (Memory File System), and <code class="literal">cd9660</code> (CD).</p><p>The fourth field, <code class="literal">sw</code> <span class="strong"><strong>4</strong></span>, shows the mount options used for this filesystem. I’ll cover mount options in more detail in <a class="xref" href="ch08.html#ffs_mount_options" title="FFS Mount Options">FFS Mount Options</a>, but here are a few that frequently appear in <span class="emphasis"><em>/etc/fstab</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><p title="ro"><span class="title"><strong><span class="strong"><strong><code class="literal">ro</code></strong></span></strong></span>. The filesystem is mounted read-only. Not even root can write to it.</p></li><li class="listitem" style="list-style-type: none"><p title="rw"><span class="title"><strong><span class="strong"><strong><code class="literal">rw</code></strong></span></strong></span>. The filesystem is mounted read-write.</p></li><li class="listitem" style="list-style-type: none"><p title="nodev"><span class="title"><strong><span class="strong"><strong><code class="literal">nodev</code></strong></span></strong></span>. Device nodes are not interpreted.</p></li><li class="listitem" style="list-style-type: none"><p title="nosuid"><span class="title"><strong><span class="strong"><strong><code class="literal">nosuid</code></strong></span></strong></span>. <code class="literal">setuid</code> files are forbidden.</p></li><li class="listitem" style="list-style-type: none"><p title="noauto"><span class="title"><strong><span class="strong"><strong><code class="literal">noauto</code></strong></span></strong></span>. OpenBSD won’t automatically mount the filesystem at boot or when running <code class="literal">mount -a</code>. This option is useful for removable media drives that might not have media in them, such as CD and USB flash drives.</p></li></ul></div><p>The fifth field indicates whether <code class="literal">dump(8)</code> should back up this filesystem. If this field is 0 (or absent), <code class="literal">dump</code> doesn’t routinely back up the filesystem. Otherwise, the number given is the minimum dump level needed to back up the filesystem.</p><p>The last field is the <span class="emphasis"><em>pass number.</em></span> It tells <code class="literal">fsck</code> when to check the filesystem during boot. Filesystems with a pass number of 1 are checked first, filesystems with a pass number of 2 are checked second, and so on. A pass number of 0 tells <code class="literal">fsck</code> to not check the filesystem during boot. If a filesystem doesn’t have a pass number, it’s equivalent to 0.</p><p>I strongly recommend using DUIDs in <span class="emphasis"><em>/etc/fstab</em></span> and anywhere else, rather than using device node names. While a device node name might change, a DUID will not.</p></div><div class="sect1" title="MBR Partitions and fdisk(8)"><div class="titlepage"><div><div><h2 class="title" id="mbr_partitions_and_fdisk8" style="clear: both">MBR Partitions and fdisk(8)</h2></div></div></div><p>Some hardware platforms have specific ideas about disk partitioning that differ from what OpenBSD expects. For example, the i386 and amd64 platforms expect to find MBR partitions on hard drives, and OpenBSD accommodates this quirk by putting its own disklabel partitions inside MBR partitions. We briefly touched on creating partitions during the installation process, but if you add hard drives to an existing system, you’ll need to edit the MBR partition table by hand using <code class="literal">fdisk(8)</code>.</p><p>My particular test system has two hard drives: <span class="emphasis"><em>wd0</em></span> and <span class="emphasis"><em>wd1</em></span>. I think that <span class="emphasis"><em>wd1</em></span> is completely blank but before I can use this drive, I need to verify that it is empty, and then create MBR partitions. While <code class="literal">fdisk</code> has all sorts of commands to edit disks, I find the simplest way is to use the interactive disk editor. Run <code class="literal">fdisk -e</code> and give it the device node for the new disk.</p><a id="I_programlisting8_id447408"/><pre class="programlisting"># <span class="strong"><strong>fdisk -e wd1</strong></span>
Enter 'help' for information
fdisk: 1&gt;</pre><p><a class="indexterm" id="idx1335"/><a class="indexterm" id="idx1339"/><a class="indexterm" id="idx1709"/><a class="indexterm" id="idx1712"/><a class="indexterm" id="idx1863"/>The editor is minimal, but lets you view, add, remove, and edit MBR partitions. If you forget the commands at any time, entering <code class="literal">help</code> will print out all the commands <code class="literal">fdisk</code> supports.</p><div class="sect2" title="Viewing MBR Partitions"><div class="titlepage"><div><div><h3 class="title" id="viewing_mbr_partitions">Viewing MBR Partitions</h3></div></div></div><p>To see the MBR partitions on the current disk, enter <span class="strong"><strong><code class="literal">print</code></strong></span> or <span class="strong"><strong><code class="literal">p</code></strong></span>. Here’s an example:</p><a id="I_programlisting8_id447505"/><pre class="programlisting">fdisk: 1&gt; <span class="strong"><strong>print</strong></span>
Disk: wd1       geometry: 2088/255/63 [33554304 Sectors]
Offset: 0       Signature: 0x0
            Starting         Ending         LBA Info:
 #: id      C   H   S -      C   H   S [       start:        size ]
------------------------------------------------------------------------------
 0: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused</pre><p>The first line shows the disk geometry (as discussed in <a class="xref" href="ch02.html" title="Chapter 2. Installation Preparations">Chapter 2</a>). Every value in this disk’s MBR table is set to 0, meaning that it has no configured partitions.</p></div><div class="sect2" title="Adding and Removing Partitions"><div class="titlepage"><div><div><h3 class="title" id="adding_and_removing_partitions">Adding and Removing Partitions</h3></div></div></div><p>Say we want to create an MBR partition on this disk. I habitually use partition 0, but the OpenBSD installer usually uses partition 3. The specific number you pick doesn’t matter unless you want multiple MBR partitions on the disk.</p><p>To edit a partition, enter <span class="strong"><strong><code class="literal">edit</code></strong></span> or <span class="strong"><strong><code class="literal">e</code></strong></span> followed by the partition number. For example, to edit partition 0, enter the following:</p><a id="I_programlisting8_id447567"/><pre class="programlisting">  fdisk: 1&gt; <span class="strong"><strong>e 0</strong></span>
            Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
------------------------------------------------------------------------------
   0: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
<span class="strong"><strong>1</strong></span> Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <span class="strong"><strong>a6</strong></span>
   Do you wish to edit in CHS mode? [n]
<span class="strong"><strong>2</strong></span> offset: [0]
<span class="strong"><strong>3</strong></span> size: [0] <span class="strong"><strong>*</strong></span></pre><div class="warning" epub:type="warning" title="Warning"><h3 class="title"><a id="ch08note01"/>Warning</h3><p>Conveniently, <span class="emphasis"><em><code class="literal">fdisk</code></em></span> prints the current information on this MBR partition. Make sure it’s the partition you think it is before you muck it up.</p></div><p>First, at <span class="strong"><strong>1</strong></span>, set a partition ID. This is a label indicating what kind of filesystem will be on the disk. OpenBSD uses partition ID <code class="literal">a6</code>, so enter that.</p><p><a class="indexterm" id="idx0019"/><a class="indexterm" id="idx0025"/><a class="indexterm" id="idx0186"/><a class="indexterm" id="idx0799"/><a class="indexterm" id="idx0820"/><a class="indexterm" id="idx0869"/><a class="indexterm" id="idx1697"/><a class="indexterm" id="idx1718"/><a class="indexterm" id="idx1910"/>The offset at <span class="strong"><strong>2</strong></span> is the number of sectors from the beginning of the disk to the start of the partition. We want to use this entire disk for OpenBSD, so set it to <code class="literal">0</code>.</p><p>Finally, the size at <span class="strong"><strong>3</strong></span> is the number of sectors the MBR partition fills. There is no need to copy the number of sectors in the disk here; OpenBSD <code class="literal">fdisk</code> uses <code class="literal">*</code> to mean “all free space.”</p><p>Now print the MBR table again to check your work.</p><a id="I_programlisting8_id447761"/><pre class="programlisting">fdisk:*1&gt; <span class="strong"><strong>p</strong></span>
Disk: wd1       geometry: 2088/255/63 [33554304 Sectors]
Offset: 0       Signature: 0x0
            Starting         Ending         LBA Info:
 #: id      C   H   S -      C   H   S [       start:        size ]
------------------------------------------------------------------------------
 0: A6      0   0   1 -   2088 167  63 [           0:    33554304 ] OpenBSD
 1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused</pre><p>Notice that the entry for partition 0 is type A6 and extends from cylinder 0, head 0, sector 1, to cylinder 2088, head 167, sector 63. It fills 33,554,304 sectors—the same as the number of sectors in the disk. This MBR partition fills the entire disk.</p><p>If you had recycled this disk from another operating system, it would probably have a partition already on it. To remove a partition, edit the partition and set its partition ID to 0.</p></div><div class="sect2" title="Making a Partition Bootable"><div class="titlepage"><div><div><h3 class="title" id="making_a_partition_bootable">Making a Partition Bootable</h3></div></div></div><p>In order to boot from a hard drive, you’ll need to mark a partition as active. Use the <code class="literal">flag</code> command and a partition number to do this.</p><a id="I_programlisting8_id447803"/><pre class="programlisting">fdisk: 1&gt; <span class="strong"><strong>flag 0</strong></span>
Partition 0 marked active.</pre><p>Include this hard drive in your BIOS boot order, and the computer should try to boot from it. Simply marking a partition as active doesn’t mean that the computer <span class="emphasis"><em>can</em></span> boot from it; however, you will still need a kernel, boot loader, and all the other things that go into bootstrapping a computer.</p><p>To mark a partition as no longer active, delete and re-create it. (There is no <code class="literal">unflag</code> command.)</p></div><div class="sect2" title="Exiting fdisk"><div class="titlepage"><div><div><h3 class="title" id="exiting_fdisk">Exiting fdisk</h3></div></div></div><p>Once you’re satisfied with your work, enter <span class="strong"><strong><code class="literal">quit</code></strong></span> or <span class="strong"><strong><code class="literal">q</code></strong></span>, and <code class="literal">fdisk</code> should write the new MBR table to disk and exit. If you changed your mind, and don’t want to make any changes, enter <span class="strong"><strong><code class="literal">abort</code></strong></span> or <span class="strong"><strong><code class="literal">exit</code></strong></span>, and <code class="literal">fdisk</code> should exit without saving changes to the MBR partition table.</p></div></div><div class="sect1" title="Labeling Disks"><div class="titlepage"><div><div><h2 class="title" id="labeling_disks" style="clear: both">Labeling Disks</h2></div></div></div><p><a class="indexterm" id="idx0467"/><a class="indexterm" id="idx0483"/>OpenBSD uses <code class="literal">disklabel</code> to set up partitions on all hardware platforms. We used <code class="literal">disklabel(8)</code> as part of the installation process, but you need to partition new disks before you can use them. (You can also use <code class="literal">disklabel</code> to back up, restore, and duplicate partition tables.)</p><div class="sect2" title="Viewing Labels"><div class="titlepage"><div><div><h3 class="title" id="viewing_labels">Viewing Labels</h3></div></div></div><p>To view the current disklabel, just give the disk name as an argument. Here’s how to see the disklabel of the empty disk from the previous section:</p><a id="I_programlisting8_id447938"/><pre class="programlisting">  # <span class="strong"><strong>disklabel wd1</strong></span>
<span class="strong"><strong>1</strong></span> # /dev/rwd1c:
  …
<span class="strong"><strong>2</strong></span> duid: 0000000000000000
  …
  16 partitions:
  #                size           offset  fstype [fsize bsize  cpg]
<span class="strong"><strong>3</strong></span>  c:         33554304                0  unused</pre><p>This looks much like the disklabel we saw in <a class="xref" href="ch02.html" title="Chapter 2. Installation Preparations">Chapter 2</a>, with a few critical differences.</p><p>First, note the device at <span class="strong"><strong>1</strong></span>. The <code class="literal">disklabel</code> command accesses the raw device, but you should use the block device at the command line.</p><p>This label at <span class="strong"><strong>2</strong></span> has no DUID. This is the default empty disklabel. We will generate a DUID later.</p><p>At <span class="strong"><strong>3</strong></span>, we see that this disk has only one partition, <span class="emphasis"><em>c</em></span>, which represents the entire disk. You could create and use a filesystem on partition <span class="emphasis"><em>c</em></span>, but it’s not standard practice to do so.</p></div><div class="sect2" title="Creating Disklabel Partitions"><div class="titlepage"><div><div><h3 class="title" id="creating_disklabel_partitions-id00002">Creating Disklabel Partitions</h3></div></div></div><p>The simplest way to create partitions is to use the same interactive disklabel editor that we used to install OpenBSD. Give the disklabel editor the <code class="literal">-E</code> flag and the disk name:</p><a id="I_programlisting8_id448036"/><pre class="programlisting"># <span class="strong"><strong>disklabel -E wd1</strong></span>
Label editor (enter '?' for help at any prompt)
&gt;</pre><p>Now you can add, remove, and edit partitions, just as in <a class="xref" href="ch03.html" title="Chapter 3. Installation Walk-Through">Chapter 3</a>.</p><p>Throughout the rest of the book, we’ll edit disklabels as needed to change partition and filesystem characteristics.</p></div><div class="sect2" title="Backing Up and Restoring Disklabels"><div class="titlepage"><div><div><h3 class="title" id="backing_up_and_restoring_disklabels">Backing Up and Restoring Disklabels</h3></div></div></div><p><a class="indexterm" id="idx0048"/><a class="indexterm" id="idx0477"/><a class="indexterm" id="idx0812"/><a class="indexterm" id="idx0817"/><a class="indexterm" id="idx0998"/><a class="indexterm" id="idx1523"/><a class="indexterm" id="idx2476"/><a class="indexterm" id="idx2493"/>Before messing with a disk, back up its disklabel so that you can fall back to the old label if you screw up. You can back up the disklabel with this command:</p><a id="I_programlisting8_id448133"/><pre class="programlisting"># <span class="strong"><strong>disklabel wd1 &gt; wd1.disklabel.saved</strong></span></pre><p>To apply a saved disklabel to a disk, give <code class="literal">disklabel</code> the <code class="literal">-R</code> flag, the disk device, and the label file:</p><a id="I_programlisting8_id448153"/><pre class="programlisting"># <span class="strong"><strong>disklabel -R wd1 wd1.disklabel.saved</strong></span></pre><p>This writes the saved label to the disk. You can use saved disklabels to duplicate partitioning across identical disks.</p><p>Now that you have partitions, let’s put a filesystem on them.</p></div></div><div class="sect1" title="The Fast File System"><div class="titlepage"><div><div><h2 class="title" id="the_fast_file_system" style="clear: both">The Fast File System</h2></div></div></div><p>OpenBSD’s filesystem, FFS, is an improved version of the filesystem shipped with BSD 4.4. FFS is sometimes called UFS (for Unix File System), and many system utilities still use UFS.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id416360" id="id416360">18</a>]</sup></p><p>FFS is designed to be fast, reliable, and able to handle the most common situations effectively while still supporting weird configurations. By default, OpenBSD tunes FFS for general use, but you can optimize it to fit your needs—whether you need to hold trillions of tiny files or a half dozen 30GB files. You don’t need to know much about FFS internals, but you should at least understand blocks, fragments, and inodes.</p><div class="sect2" title="FFS Versions"><div class="titlepage"><div><div><h3 class="title" id="ffs_versions">FFS Versions</h3></div></div></div><p>The original FFS was written in the 1980s and included hard-coded limits that were ample for the day. Filesystems could have up to 231-1 blocks, or just under a terabyte (TB). In 1983, a 1TB filesystem was unthinkable. In 2013, 1TB drives are cheap.</p><p>For larger file systems, we have FFS version 2. FFS2 can support filesystems up to 8 zettabytes—unthinkable by 2013 standards. (FFS2 is likely to reach other limits before hitting the filesystem size limit, mind you.) OpenBSD supports both FFS and FFS2.</p><p>The i386 and amd64 boot floppies support only FFS, not FFS2. The installation CD, however, supports both. Most machines that need to boot from floppy don’t need FFS2, and probably don’t have a BIOS that can support 2TB drives anyway. The filesystem creation program <code class="literal">newfs(1)</code> is smart enough to use FFS2 on filesystems large enough to need it, so for most installations, you don’t need to worry about the difference between FFS and FFS2.</p><div class="note" title="Note"><h3 class="title"><a id="ch08note02"/>Note</h3><p><a class="indexterm" id="idx0147"/><a class="indexterm" id="idx0813"/><a class="indexterm" id="idx0814"/><a class="indexterm" id="idx0884"/><a class="indexterm" id="idx1026"/><a class="indexterm" id="idx1033"/><a class="indexterm" id="idx1361"/><a class="indexterm" id="idx1524"/><a class="indexterm" id="idx2279"/>In the exceedingly unlikely event that you actually require FFS2 on a machine that must be installed via floppy, be sure to format the critical system partitions of root (<code class="literal">/</code>), <code class="literal">/var</code>, and <code class="literal">/usr</code> as FFS, not FFS2. Use FFS2 only for partitions that are not critical to the system. Otherwise, you won’t be able to use the installation disk for upgrades or emergency repairs.</p></div></div><div class="sect2" title="Blocks, Fragments, and Inodes"><div class="titlepage"><div><div><h3 class="title" id="blocks_fragments_and_inodes">Blocks, Fragments, and Inodes</h3></div></div></div><p>Both FFS and FFS2 are managed through blocks, fragments, and inodes. This arrangement isn’t unique to FFS and FFS2; filesystems such as NTFS use data blocks and index nodes, too. The indexing system used by each filesystem is largely unique, however.</p><div class="sect3" title="Blocks"><div class="titlepage"><div><div><h4 class="title" id="blocks">Blocks</h4></div></div></div><p><span class="emphasis"><em>Blocks</em></span> are sections of disk that contain data. Files are placed in one or more blocks. OpenBSD’s FFS uses a default block size of 16KB, or eight times the fragment size, whichever is smaller. Not all files are even multiples of 16KB, so leftover bits go in <span class="emphasis"><em>fragments</em></span>. A fragment is one-eighth of the block size, or 2KB by default. A 20KB file fills one block and two fragments.</p></div><div class="sect3" title="Inodes"><div class="titlepage"><div><div><h4 class="title" id="inodes">Inodes</h4></div></div></div><p><span class="emphasis"><em>Inodes</em></span>, or index nodes, contain basic data about files, such as the file’s size, permissions, and the list of blocks that contain the file. Collectively, the data in an inode is known as <span class="emphasis"><em>metadata</em></span>, or data about data.</p></div><div class="sect3" title="Superblocks"><div class="titlepage"><div><div><h4 class="title" id="superblocks">Superblocks</h4></div></div></div><p>You’ll also see references to <span class="emphasis"><em>superblocks</em></span>, which are blocks that contain vital information about the filesystem’s size and specifications. Superblocks are so important that FFS makes many backup copies of them. If you need to meddle with superblocks, you’ve probably done something wrong or your filesystem is FUBAR.</p></div></div><div class="sect2" title="Creating FFS Filesystems"><div class="titlepage"><div><div><h3 class="title" id="creating_ffs_filesystems">Creating FFS Filesystems</h3></div></div></div><p>Use <code class="literal">newfs(8)</code> to create FFS and FFS2 filesystems and make sure that the disk has a disklabel. The <code class="literal">newfs</code> command takes one argument: the partition device node.</p><a id="I_programlisting8_id448416"/><pre class="programlisting"># <span class="strong"><strong>newfs wd1a</strong></span>
/dev/rwd1a: 16383.9MB in 33554304 sectors of 512 bytes
81 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
super-block backups (for fsck -b #) at:
 32, 414688, 829344, 1244000, 1658656, 2073312, 2487968, 2902624, 3317280, 3731936,
 …</pre><p><a class="indexterm" id="idx0604"/><a class="indexterm" id="idx0816"/><a class="indexterm" id="idx1398"/><a class="indexterm" id="idx1929"/>You’ll see details about the filesystem size, how many blocks it includes, and so on. The location of each superblock backup is printed as <code class="literal">newfs</code> proceeds. (When computers and disks were much slower, this told the operator that the computer was actually doing something and hadn’t seized up.)</p><p>The partition size determines which filesystem <code class="literal">newfs</code> uses. Partitions smaller than 1TB are formatted with FFS; larger partitions with FFS2. If you want to specify a particular filesystem format (yes, you can even specify the old-fashioned 4.3BSD format if you like), use the <code class="literal">-O</code> flag. It makes no sense to demand an FFS filesystem on a large partition, but you might have a reason to use FFS2 on a small partition.</p><a id="I_programlisting8_id448487"/><pre class="programlisting"># <span class="strong"><strong>newfs -O 2 wd1a</strong></span></pre><p>If you think you need to specify which filesystem format to use on a new filesystem, you’re probably wrong.</p></div><div class="sect2" title="FFS Mount Options"><div class="titlepage"><div><div><h3 class="title" id="ffs_mount_options">FFS Mount Options</h3></div></div></div><p>OpenBSD can handle FFS partitions in several special ways, controlling what sorts of changes the filesystem supports and what sorts of files may exist. These are called <span class="emphasis"><em>mount options</em></span>. You can specify mount options either when you mount partitions on the command line, as we’ll discuss in <a class="xref" href="ch08.html#mounting_and_unmounting_partitions" title="Mounting and Unmounting Partitions">Mounting and Unmounting Partitions</a>, or in <span class="emphasis"><em>/etc/fstab</em></span>.</p><div class="sect3" title="Mount Options and /etc/fstab"><div class="titlepage"><div><div><h4 class="title" id="mount_options_and_etc_fstab">Mount Options and /etc/fstab</h4></div></div></div><p>Specify a filesystem’s mount options in a comma-separated list in the fourth field of the filesystem’s <span class="emphasis"><em>/etc/fstab</em></span> entry. For example, here’s an <span class="emphasis"><em>/etc/fstab</em></span> entry for the partition that contains my <span class="emphasis"><em>/home</em></span> directory:</p><a id="I_programlisting8_id448554"/><pre class="programlisting">244f6d3acd6374ad.k /home ffs rw,nodev,nosuid,softdep 1 2</pre><p>I’ve specified the options <code class="literal">rw</code> (read-write), <code class="literal">nodev</code> (device nodes forbidden), <code class="literal">nosuid</code> (<code class="literal">setuid</code> programs forbidden), and <code class="literal">softdep</code> (soft updates). I’ll cover these and other common mount options, and explain why you might want to use them.</p></div><div class="sect3" title="Read-Only Mounts"><div class="titlepage"><div><div><h4 class="title" id="read-only_mounts-id00001">Read-Only Mounts</h4></div></div></div><p>If you only want to read the contents of a partition, and never write to it, you can mount the partition as <span class="emphasis"><em>read-only</em></span>. In most cases, this is the safest way to mount a disk because you cannot alter the data on the disk or write any new data. If a filesystem should never change, mounting it read-only might make sense.</p><p>Read-only mounts are especially valuable when a particular filesystem is damaged. While OpenBSD won’t let you perform a standard read-write mount on a damaged or dirty filesystem, it can often mount those filesystems read-only. This gives you a chance to recover some data from the partition. (Not a large chance, but a chance.)</p><p><a class="indexterm" id="idx0078"/><a class="indexterm" id="idx0366"/><a class="indexterm" id="idx1933"/><a class="indexterm" id="idx2293"/><a class="indexterm" id="idx2661"/>To mount a filesystem read-only, use the option <code class="literal">rdonly</code> or <code class="literal">ro</code>.</p></div><div class="sect3" title="Read-Write Mounts"><div class="titlepage"><div><div><h4 class="title" id="read-write_mounts">Read-Write Mounts</h4></div></div></div><p>If you want to both read from and write to the disk, you’ll want to mount the partition as <span class="emphasis"><em>read-write</em></span>. By default, OpenBSD mounts all partitions as read-write.</p><p>Use the option <code class="literal">rw</code> to explicitly configure read-write mounts.</p><p>On modern hardware, I recommend using soft updates in conjunction with read-write mounts.</p></div><div class="sect3" title="Synchronous Mounts"><div class="titlepage"><div><div><h4 class="title" id="synchronous_mounts">Synchronous Mounts</h4></div></div></div><p>Using a synchronous mount is the safest way to mount a filesystem. OpenBSD can read data from a synchronous-mounted partition as fast as the hardware permits. Whenever you write to the disk, however, the kernel feeds a chunk of data to the disk, waits to receive confirmation that the disk has accepted the data and written it to disk, and then tells the program that requested the write that the data is now on disk.</p><p>You should know that even if you’re using a synchronous mount, most hard drives lie about whether they have actually written the data to disk. These drives perform <span class="emphasis"><em>write caching</em></span>, where writes are cached in a small flash or RAM buffer on the disk itself before the drive actually writes the data. This raises the question: Is a synchronous mount really synchronous? Hard drive vendors usually claim that in the event of a power failure, these disks retain just enough power to write the cache to disk.</p><p>Although they provide the greatest data integrity in the case of a crash, synchronous mounts are slow. You might use synchronous mounts when data integrity is crucial, but in most cases, it’s overkill and you have little ability to verify that the mount is truly synchronous.</p><p>Activate synchronous mounts with the <code class="literal">sync</code> keyword.</p></div><div class="sect3" title="Asynchronous Mounts"><div class="titlepage"><div><div><h4 class="title" id="asynchronous_mounts">Asynchronous Mounts</h4></div></div></div><p>To write data quickly, but with a higher risk of data loss, mount partitions asynchronously. When using asynchronous mounts, the kernel informs software that all disk writes are successful before the disk confirms that the data was written. This is fast, but a system failure can leave inconsistent data on your disk.</p><p>Asynchronous mounts are useful when restoring a filesystem from backup, because if you get a power failure halfway through the restore procedure, you’ll need to start over anyway. Don’t use asynchronous mounts in production if you care about your data or would object to re-creating the filesystem.</p><p>Activate asynchronous mounts with the <code class="literal">async</code> keyword.</p></div><div class="sect3" title="Soft Update Mounts"><div class="titlepage"><div><div><h4 class="title" id="soft_update_mounts">Soft Update Mounts</h4></div></div></div><p><a class="indexterm" id="idx0518"/><a class="indexterm" id="idx0797"/><a class="indexterm" id="idx1422"/><a class="indexterm" id="idx1541"/><a class="indexterm" id="idx1547"/><a class="indexterm" id="idx1549"/><a class="indexterm" id="idx2169"/>Soft update mounts organize and arrange disk writes so that filesystem metadata remains consistent at all times. This gives performance similar to that of an asynchronous mount with the reliability of a synchronous mount. While that doesn’t mean that all data will be written to disk—a power failure at the wrong moment will result in lost data—using soft updates prevents a lot of filesystem integrity problems caused by that lost data. It’s not the default because some older, smaller hardware doesn’t have enough memory to support it, but if you’re using modern i386 and amd64 hardware, I recommend enabling soft updates for all FFS partitions.</p><p>To mount a filesystem with soft updates, use the <code class="literal">softdep</code> option.</p></div><div class="sect3" title="“Don’t Track Access Time” Mounts"><div class="titlepage"><div><div><h4 class="title" id="dont_track_access_time_mounts">“Don’t Track Access Time” Mounts</h4></div></div></div><p>FFS records the last time a file was read, executed, or otherwise viewed. Updating these access times consumes a small but measurable amount of disk I/O and performance. You can use the <code class="literal">noatime</code> mount option to tell OpenBSD to not update the access time on any file.</p><p>Using <code class="literal">noatime</code> makes sense on laptops, where minimizing power usage is critical. If you’re tempted to use this option on your server to squeeze out a little extra performance, you should buy a faster disk instead. Some software, such as the Mutt mail client, will break if run on filesystems mounted <code class="literal">noatime</code>.</p></div><div class="sect3" title="No Device Nodes Permitted Mount"><div class="titlepage"><div><div><h4 class="title" id="no_device_nodes_permitted_mount">No Device Nodes Permitted Mount</h4></div></div></div><p>By using the <code class="literal">nodev</code> mount option, you can tell OpenBSD to not interpret any device nodes on any given filesystem. Intruders can try to create “rogue” device nodes and use them to write files or attack the network, but if the kernel won’t recognize those device nodes, it cuts off this whole category of attacks.</p><p>This type of mount is also useful if you have hard drives from multiple operating systems on your computer. For example, if you dual-boot OpenBSD and Linux on your computer, but you don’t want to accidentally access a Linux device node when using OpenBSD, the <code class="literal">nodev</code> option will prevent you from doing so. (You might think you would notice that you had typed <span class="emphasis"><em>/linux/dev/hda</em></span> rather than <span class="emphasis"><em>/dev/wd1</em></span>, but never underestimate your ability to screw up.) In most cases, the partition containing <span class="emphasis"><em>/dev</em></span> is the only one that should contain device nodes.</p></div><div class="sect3" title="Execution Forbidden Mounts"><div class="titlepage"><div><div><h4 class="title" id="execution_forbidden_mounts">Execution Forbidden Mounts</h4></div></div></div><p>The <code class="literal">noexec</code> mount option prevents any binaries on the partition from being executed. Mounting <span class="emphasis"><em>/home</em></span> with the <code class="literal">noexec</code> option helps prevent users from installing and running their own programs, but for it to be effective, you’ll need to make sure users can’t install binaries in any shared areas, such as <span class="emphasis"><em>/tmp</em></span> and <span class="emphasis"><em>/var/tmp</em></span>.</p><p><a class="indexterm" id="idx0256"/><a class="indexterm" id="idx0262"/><a class="indexterm" id="idx0454"/><a class="indexterm" id="idx0815"/><a class="indexterm" id="idx0839"/><a class="indexterm" id="idx0848"/><a class="indexterm" id="idx0891"/><a class="indexterm" id="idx0894"/><a class="indexterm" id="idx1543"/><a class="indexterm" id="idx1719"/><a class="indexterm" id="idx1859"/><a class="indexterm" id="idx2106"/>Note that forbidding execution of binaries doesn’t prevent users from running interpreted scripts from that partition. Maybe the users can’t run a compiled C program, but if they can run <code class="literal">perl $HOME/rootkit.pl</code>, then <code class="literal">noexec</code> won’t slow them down very much.</p></div><div class="sect3" title="setuid Forbidden"><div class="titlepage"><div><div><h4 class="title" id="setuid_forbidden">setuid Forbidden</h4></div></div></div><p>The <code class="literal">nosuid</code> option disallows <code class="literal">setuid</code> behavior from programs on this filesystem. Many partitions should not have <code class="literal">setuid</code> files, and setting this is an easy way to disrupt them. OpenBSD sets this on partitions such as <span class="emphasis"><em>/home</em></span> and <span class="emphasis"><em>/tmp</em></span> by default. You must carefully place this option on all user-writable filesystems for it to prevent undesired behavior.</p></div><div class="sect3" title="Do Not Automatically Mount This Filesystem"><div class="titlepage"><div><div><h4 class="title" id="do_not_automatically_mount_this_filesyst">Do Not Automatically Mount This Filesystem</h4></div></div></div><p><code class="literal">noauto</code> isn’t actually a mount option, but rather a way of telling OpenBSD to not mount a given partition listed in <span class="emphasis"><em>/etc/fstab</em></span> at boot. I frequently make <span class="emphasis"><em>/etc/fstab</em></span> entries for removable media drives, but the system should not try to mount these at boot. The boot will hang if a partition required by <span class="emphasis"><em>/etc/fstab</em></span> is not available, and I don’t want my computer to refuse to boot just because I unplugged a flash drive.</p></div></div><div class="sect2" title="Filesystem Integrity"><div class="titlepage"><div><div><h3 class="title" id="filesystem_integrity">Filesystem Integrity</h3></div></div></div><p>Both versions of FFS go to a great deal of trouble to ensure that the data on disk is correct and intact. The blocks that contain a file should be recorded in an inode, the inodes should all be referenced by directory entries, and so on. When you remove a file, all references to that file should be removed.</p><p>After a system failure, however, data might not be consistent. Metadata might reference blocks that were previously erased; a file might be in a different location than the inode record specifies; and the filesystem might have all kinds of references pointing to things that have moved, changed, or disappeared. These inconsistent, or <span class="emphasis"><em>dirty</em></span>, filesystems cannot be trusted and must be rationalized, or <span class="emphasis"><em>cleaned</em></span>, before you can mount them read-write. If you mount a dirty filesystem read-only, it might only panic your system, but if you force OpenBSD to mount a dirty filesystem read-write, you will damage the dirty filesystem even more.</p><p>At boot, OpenBSD performs a minimal inspection and cleaning, or <span class="emphasis"><em>preening</em></span>, of the filesystems and will automatically correct any minor problems found. If preening cannot fully clean the filesystem, the boot will hang until you intervene.</p><p>When confronted with a dirty filesystem, you have a few options: use the filesystem checking tool <code class="literal">fsck(8)</code>, debug the filesystem with <code class="literal">fsdb(8)</code> and <code class="literal">clri(8)</code>, or throw the filesystem away and run <code class="literal">newfs(8)</code>. Most of the time, you’ll attempt to repair the filesystem with <code class="literal">fsck</code>. Using <code class="literal">fsdb</code> successfully requires more knowledge about FFS innards than I possess, so I recommend it to only those who really want to develop an in-depth knowledge of FFS and have a whole bunch of time to devote to it. Rebuilding the filesystem with <code class="literal">newfs</code> destroys everything on the filesystem, but it’s a decent choice for partitions that contain only ephemeral data, such as <span class="emphasis"><em>/usr/obj</em></span>.</p><p><a class="indexterm" id="idx0364"/><a class="indexterm" id="idx0524"/><a class="indexterm" id="idx0856"/><a class="indexterm" id="idx0892"/><a class="indexterm" id="idx0893"/><a class="indexterm" id="idx1245"/><a class="indexterm" id="idx1525"/><a class="indexterm" id="idx2460"/>You can use <code class="literal">dump(8)</code> to copy the damaged filesystem before trying any of the repairs. This gives you the option to fall back to the current state if attempts at repairing the disk fail. (If you have to do this, though, you should probably reevaluate your backup strategy.)</p><div class="sect3" title="Running fsck"><div class="titlepage"><div><div><h4 class="title" id="running_fsck">Running fsck</h4></div></div></div><p>If you try to mount a dirty filesystem either at boot time or during routine operation, you’ll see a message that looks like this:</p><a id="I_programlisting8_id449288"/><pre class="programlisting">/dev/rwd1a: UNEXPECTED INCONSISTENCY; RUN fsck_ffs MANUALLY</pre><p>The <code class="literal">fsck(8)</code> program is a frontend for several filesystem-specific integrity-checking programs. When you run it, <code class="literal">fsck</code> identifies the type of filesystem and calls the correct integrity checker for you. Run <code class="literal">fsck</code> by giving it the device name of the filesystem you want to check:</p><a id="I_programlisting8_id449308"/><pre class="programlisting"># <span class="strong"><strong>fsck /dev/wd1a</strong></span></pre><p>You can use either the raw or cooked device name; <code class="literal">fsck</code> is smart enough to use the raw node even if you give the cooked device name.</p><p>Examining the filesystem can take quite a while, so be patient.</p><p>When run on a dirty filesystem, <code class="literal">fsck</code> will probably find a number of problems: blocks that have become disassociated from their inodes, inodes that reference empty blocks, and so on. It can often make a good guess as to how everything fits together.</p><p>When <code class="literal">fsck</code> finds a problem that it isn’t absolutely sure about, it will suggest a fix and ask if you want to make the change. If you answer <code class="literal">y</code>, <code class="literal">fsck</code> makes the change. If you answer <code class="literal">n</code>, <code class="literal">fsck</code> leaves the filesystem unchanged. If you tell <code class="literal">fsck</code> not to make the change it suggests, the filesystem will still be dirty, and you’ll need to fire up <code class="literal">fsdb</code> or <code class="literal">clri</code> and make the change you think more appropriate.</p><p>Sometimes, <code class="literal">fsck</code> can’t identify the name or directory of a file recovered from a damaged filesystem. These files go into the partition’s <span class="emphasis"><em>lost+found</em></span> directory (for example, <span class="emphasis"><em>/usr/lost+found</em></span>). You’ll need to use programs such as <code class="literal">grep</code> and <code class="literal">strings</code> to try to identify these files by their contents.</p></div><div class="sect3" title="Blindly Trusting fsck"><div class="titlepage"><div><div><h4 class="title" id="blindly_trusting_fsck">Blindly Trusting fsck</h4></div></div></div><p>Those of us who lack the skills to debug a filesystem find ourselves in a difficult situation, where we can either accept that <code class="literal">fsck(8)</code> knows what’s best or just restore from backup. If your filesystem was performing a lot of disk I/O just before system failure, <code class="literal">fsck</code> might need to make dozens or hundreds of changes. You could spend an hour sitting at the console pressing <code class="literal">y</code> repeatedly.</p><p><a class="indexterm" id="idx1392"/><a class="indexterm" id="idx1396"/><a class="indexterm" id="idx1405"/><a class="indexterm" id="idx1716"/><a class="indexterm" id="idx2146"/>If you decide to trust <code class="literal">fsck</code> and hope it’s right, run <code class="literal">fsck -y</code>. This means “answer <code class="literal">y</code> to every question.” You might wind up with the entire contents of the filesystem in the <span class="emphasis"><em>lost+found</em></span> directory, or you might lose every file on the filesystem. But unless you’re intimately familiar with the innards of FFS, you would need to restore from backup anyway.</p><p>If you run <code class="literal">fsck</code> and realize partway through that you would like to answer <code class="literal">y</code> to all the questions that follow, enter <code class="literal">F</code>. That tells <code class="literal">fsck</code> to answer <code class="literal">y</code> to all remaining questions.</p><p>At the end of the procedure, you’ve either recovered your system or need to restore from backup.</p></div></div></div><div class="sect1" title="What’s Currently Mounted?"><div class="titlepage"><div><div><h2 class="title" id="whats_currently_mounted" style="clear: both">What’s Currently Mounted?</h2></div></div></div><p>While performing routine work, inevitably you’ll need to check which disks are currently mounted and which are not. To see a list of all mounted filesystems and their mount options, run <code class="literal">mount(8)</code> without any options:</p><a id="I_programlisting8_id449529"/><pre class="programlisting">$ <span class="strong"><strong>mount</strong></span>
/dev/wd0a on / type ffs (local)
/dev/wd0k on /home type ffs (local, nodev, nosuid)
/dev/wd0d on /tmp type ffs (local, nodev, nosuid)
/dev/wd0f on /usr type ffs (local, nodev)
/dev/wd0g on /usr/X11R6 type ffs (local, nodev)
/dev/wd0h on /usr/local type ffs (local, nodev)
/dev/wd0j on /usr/obj type ffs (local, nodev, nosuid)
/dev/wd0i on /usr/src type ffs (local, nodev, nosuid)
/dev/wd0e on /var type ffs (local, nodev, nosuid)</pre><p>Both FFS and FFS2 partitions show up as <code class="literal">type ffs</code>. The word <code class="literal">local</code> means that the partition is on a physical drive attached to this machine. We covered the various mount options (<code class="literal">nodev</code>, <code class="literal">nosuid</code>, and so on) earlier in this chapter.</p><p>Note that <code class="literal">mount</code> displays the device node mounted at each partition, not the DUID. If you want to see the DUID of a disk, check the disklabel.</p></div><div class="sect1" title="Mounting and Unmounting Partitions"><div class="titlepage"><div><div><h2 class="title" id="mounting_and_unmounting_partitions" style="clear: both">Mounting and Unmounting Partitions</h2></div></div></div><p>To attach filesystems to your directory tree, or <span class="emphasis"><em>mount</em></span> them, use <code class="literal">mount(8)</code>. If you’ve never manually mounted filesystems before, boot your OpenBSD machine into single-user mode (see <a class="xref" href="ch05.html" title="Chapter 5. The Boot Process">Chapter 5</a>) and follow along.</p><p>In single-user mode, OpenBSD mounts only one partition: the root partition, which it mounts read-only. The root partition contains just enough of the system to perform basic setup, establish core services, and find the other filesystems.</p><p>Because filesystems other than the root are not mounted, their content is not accessible. Look in, say, <span class="emphasis"><em>/usr</em></span> on a system in single-user mode, and you’ll find that it’s empty. OpenBSD hasn’t lost the files; it just hasn’t mounted the partition containing those files.</p><p>To get any real work done in single-user mode, you probably need to mount other filesystems.</p><div class="sect2" title="Mounting Standard Filesystems"><div class="titlepage"><div><div><h3 class="title" id="mounting_standard_filesystems">Mounting Standard Filesystems</h3></div></div></div><p><a class="indexterm" id="idx0850"/><a class="indexterm" id="idx0854"/><a class="indexterm" id="idx1402"/><a class="indexterm" id="idx1406"/><a class="indexterm" id="idx1720"/><a class="indexterm" id="idx2482"/><a class="indexterm" id="idx2498"/>To manually mount a single filesystem listed in <span class="emphasis"><em>/etc/fstab</em></span>, give <code class="literal">mount(8)</code> the name of the filesystem you want to mount. Here, we’ll mount our <span class="emphasis"><em>/usr</em></span> partition:</p><a id="I_programlisting8_id449697"/><pre class="programlisting"># <span class="strong"><strong>mount /usr</strong></span></pre><p>This mounts the partition exactly as described in <span class="emphasis"><em>/etc/fstab</em></span>, with all the options specified therein.</p><p>To mount all of the partitions listed in <span class="emphasis"><em>/etc/fstab</em></span>, give <code class="literal">mount</code> the <code class="literal">-a</code> flag:</p><a id="I_programlisting8_id449728"/><pre class="programlisting"># <span class="strong"><strong>mount -a</strong></span></pre><p>All of your filesystems (except those not listed in <span class="emphasis"><em>/etc/fstab</em></span> and those with the <code class="literal">noauto</code> option) should now be mounted.</p></div><div class="sect2" title="Mounting at Nonstandard Locations"><div class="titlepage"><div><div><h3 class="title" id="mounting_at_nonstandard_locations">Mounting at Nonstandard Locations</h3></div></div></div><p>Perhaps you must mount a filesystem at a location not specified in <span class="emphasis"><em>/etc/fstab</em></span>. I do this most commonly when adding a disk to a machine. To mount a partition at a location other than that specified in <span class="emphasis"><em>/etc/fstab</em></span>, or to mount a partition without an <span class="emphasis"><em>/etc/fstab</em></span> entry, give the partition device name and the mount point.</p><a id="I_programlisting8_id449774"/><pre class="programlisting"># <span class="strong"><strong>mount /dev/sd0d /mnt</strong></span></pre><p>You must use the full path for the device node, not just the brief device node name.</p><p>Instead of the path to the device node, you could use the DUID, a period, and the partition letter, but on the command line, that’s more painful than using the path to the device node.</p></div><div class="sect2" title="Unmounting Partitions"><div class="titlepage"><div><div><h3 class="title" id="unmounting_partitions">Unmounting Partitions</h3></div></div></div><p>To disconnect a filesystem from the directory tree, use <code class="literal">umount(8)</code> on a mount point. (Note that there is only one <code class="literal">n</code> in this command.) Here, we’ll use <code class="literal">umount</code> to unmount our <span class="emphasis"><em>/usr</em></span> partition:</p><a id="I_programlisting8_id449820"/><pre class="programlisting"># <span class="strong"><strong>umount /usr</strong></span></pre><p>You cannot unmount filesystems that are in use by any program. Even a command prompt in the mounted directory will prevent you from unmounting the partition.</p><p>To unmount all partitions except the root partition, pass <code class="literal">umount</code> the <code class="literal">-a</code> flag:</p><a id="I_programlisting8_id449845"/><pre class="programlisting"># <span class="strong"><strong>umount -a</strong></span></pre><p><a class="indexterm" id="idx0439"/><a class="indexterm" id="idx1404"/><a class="indexterm" id="idx1706"/>As programs almost certainly have files open on every partition, this probably works only in single-user mode. Note that you don’t need to unmount all partitions to leave single-user mode.</p></div><div class="sect2" title="Mounting with Options"><div class="titlepage"><div><div><h3 class="title" id="mounting_with_options">Mounting with Options</h3></div></div></div><p>Suppose you pull a disk from a decommissioned OpenBSD machine and you need to retrieve some files from it. You want to mount the disk read-only so that you don’t change any of the files on the disk. To manually mount a partition with options not specified in <span class="emphasis"><em>/etc/fstab</em></span>, use the <code class="literal">-o</code> flag.</p><p>For example, if the disk shows up as <span class="emphasis"><em>/dev/sd0</em></span> and you want to mount partition <span class="emphasis"><em>a</em></span>, run this command:</p><a id="I_programlisting8_id449918"/><pre class="programlisting"># <span class="strong"><strong>mount -o ro /dev/sd0a /mnt</strong></span></pre><p>To prevent old software from running on your newer system, it might be a good idea to use some of the options we covered earlier, such as <code class="literal">noexec</code>, <code class="literal">nodev</code>, and <code class="literal">nosuid</code>.</p></div></div><div class="sect1" title="How Full Is That Partition?"><div class="titlepage"><div><div><h2 class="title" id="how_full_is_that_partition" style="clear: both">How Full Is That Partition?</h2></div></div></div><p>To get an idea how much free space remains on your partitions, use <code class="literal">df(1)</code>. This program displays the total number of filesystem blocks on each partition, how many blocks are in use, and how many blocks are free. It also gives you the percent in use.</p><p>One annoying thing about <code class="literal">df</code> is that it offers this information in 512-byte blocks by default. This was fine when disks were much smaller, but today, it’s like measuring the distance of an airplane flight in yards. Some people have done this for so long that they automatically perform block transformations in the back of their mind.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id425288" id="id425288">19</a>]</sup> For the rest of us, the <code class="literal">-h</code> flag tells <code class="literal">df</code> to provide human-readable output, such as megabytes or gigabytes, giving us something like this:</p><a id="I_programlisting8_id449985"/><pre class="programlisting"># <span class="strong"><strong>df -h</strong></span>
Filesystem     Size    Used   Avail Capacity  Mounted on
/dev/sd0a     1005M   39.1M    916M     4%    /
/dev/sd0k     26.9G   27.0G   -104M    -1%    /home
/dev/sd0d      3.5G   12.0K    3.3G     0%    /tmp
…</pre><p>You might wonder why the <span class="emphasis"><em>/home</em></span> partition in this example has negative free space. How is that possible? By default, FFS reserves 5 percent of each partition for moving files and reducing fragmentation. When you exceed 100 percent disk utilization, you begin tapping into this reserved space.</p><p>FFS performance degrades quickly when the partition is overfull. It’s best to keep some free space on your disk so that FFS can defragment itself.</p><p><a class="indexterm" id="idx0148"/><a class="indexterm" id="idx0149"/><a class="indexterm" id="idx0452"/><a class="indexterm" id="idx0519"/><a class="indexterm" id="idx2191"/>You can reduce the amount of space FFS reserves, but doing so will impact performance. See <code class="literal">tunefs(8)</code> for instructions on how to shoot yourself in the foot.</p><div class="sect2" title="What’s All That Stuff?"><div class="titlepage"><div><div><h3 class="title" id="whats_all_that_stuff">What’s All That Stuff?</h3></div></div></div><p>When you see a partition is full, the obvious question is “What’s filling up my disk?” Every hard drive I’ve ever owned has gradually filled up for no apparent reason. You can identify individual large files with <code class="literal">ls -l</code>, but recursively examining every directory in the filesystem is impractical and tedious (not to mention annoying).</p><p>To check the number of filesystem blocks used within each directory below the current directory, use <code class="literal">du(1)</code>.</p><a id="I_programlisting8_id450089"/><pre class="programlisting">$ <span class="strong"><strong>du</strong></span>
164     ./.ssh
2       ./old
6       ./.mozilla/firefox/bcpuv16e.default/chrome
80      ./.mozilla/firefox/bcpuv16e.default/Cache/0/B0
354     ./.mozilla/firefox/bcpuv16e.default/Cache/0/31
28      ./.mozilla/firefox/bcpuv16e.default/Cache/0/7A
…</pre><p>When I run <code class="literal">du</code> in my home directory, I get 700 entries; of those, 563 are related to some Mozilla tool. This kind of list intimidates the new sysadmin and makes the experienced sysadmin work too hard. Rather than cull through this list manually, tell <code class="literal">du</code> to show only the total for directories in the current directory, and then sort the output so that the largest directories appear first.</p><a id="I_programlisting8_id450115"/><pre class="programlisting">$ <span class="strong"><strong>du -s * | sort -rnk 1</strong></span>
25224805  Dark_Shadows_Complete_Series
141104    mibs
14948     tarballs
4668      work
1864      pix
…</pre><p>I now know why my <span class="emphasis"><em>/home</em></span> partition is full.</p><p>You can tell <code class="literal">du</code> to display human-readable values with the <code class="literal">-h</code> flag, but doing so will show values in a mix of gigabytes, megabytes, and kilobytes, making <code class="literal">sort</code> far less useful.</p></div><div class="sect2" title="Setting $BLOCKSIZE"><div class="titlepage"><div><div><h3 class="title" id="setting_blocksize">Setting $BLOCKSIZE</h3></div></div></div><p>Many disk tools—including, but not limited to, <code class="literal">du(1)</code> and <code class="literal">df(1)</code>—display information in 512-byte blocks. If you’re accustomed to working in blocks, you probably won’t mind seeing them. If you’re not used to working in blocks, however, they’ll probably make you want to tear out your hair.</p><p><a class="indexterm" id="idx0478"/><a class="indexterm" id="idx0822"/><a class="indexterm" id="idx0940"/><a class="indexterm" id="idx1336"/><a class="indexterm" id="idx1710"/>The environment variable <code class="literal">BLOCKSIZE</code> tells these programs to display information using blocks of a different size. If you set <code class="literal">BLOCKSIZE</code> to <code class="literal">K</code>, <code class="literal">df</code> and <code class="literal">du</code> will display totals in kilobytes. If you set it to <code class="literal">M</code>, these tools will show megabytes instead. Check your shell manual page or the dotfiles in your home directory for examples of setting environment variables.</p></div></div><div class="sect1" title="Adding New Hard Disks"><div class="titlepage"><div><div><h2 class="title" id="adding_new_hard_disks" style="clear: both">Adding New Hard Disks</h2></div></div></div><p>The OpenBSD installer walks you through formatting and partitioning your initial hard disks. If you need to add a disk to an existing system, however, you must run these commands yourself. The good news is that if you can install OpenBSD, you already know how to use the commands, and the only hard part is learning which commands to run.</p><p>I’ll show you how to move <span class="emphasis"><em>/home</em></span> to a new disk as an example. You could create a new partition on your existing disk if you have some empty space, but that would eliminate the need for this example, so I’m going to pretend I never gave you that advice. (Also, moving partitions to a separate disk controller channel will improve performance.)</p><div class="warning" epub:type="warning" title="Warning"><h3 class="title"><a id="ch08note03"/>Warning</h3><p>Before touching anything involving disk partitioning or filesystems, back up your system. Verify that backup before starting. You have been warned.</p></div><div class="sect2" title="Creating an MBR Partition"><div class="titlepage"><div><div><h3 class="title" id="creating_an_mbr_partition">Creating an MBR Partition</h3></div></div></div><p>The i386 and amd64 platforms require disks to have MBR partitions as well as OpenBSD partitions. A standard new disk needs a single OpenBSD MBR partition covering the entire disk. Passing the <code class="literal">-i</code> argument to <code class="literal">fdisk</code> does exactly this. Let’s create a new MBR partition on <code class="literal">wd1</code>, our new disk:</p><a id="I_programlisting8_id450307"/><pre class="programlisting"># <span class="strong"><strong>fdisk -i wd1</strong></span>
Do you wish to write new MBR and partition table? [n] <span class="strong"><strong>y</strong></span>
Writing MBR at offset 0.</pre><p>Once you have an MBR partition on your disk, you can create disklabel partitions.</p></div><div class="sect2" title="Creating a Disklabel"><div class="titlepage"><div><div><h3 class="title" id="creating_a_disklabel">Creating a Disklabel</h3></div></div></div><p>All OpenBSD platforms use disklabel partitions. To activate the same disklabel editor we used during the install process, give <code class="literal">disklabel</code> the <code class="literal">-E</code> flag and the disk name:</p><a id="I_programlisting8_id450350"/><pre class="programlisting"># <span class="strong"><strong>disklabel -E wd1</strong></span></pre><p><a class="indexterm" id="idx0305"/><a class="indexterm" id="idx0306"/><a class="indexterm" id="idx0527"/><a class="indexterm" id="idx1412"/><a class="indexterm" id="idx1423"/><a class="indexterm" id="idx1526"/><a class="indexterm" id="idx1966"/><a class="indexterm" id="idx2368"/>This should look familiar from earlier in this chapter. Use the interactive disklabel editor to create your new partitions. For a single <span class="emphasis"><em>/home</em></span> directory, we’ll use one large partition, <span class="emphasis"><em>wd1a</em></span>. The new label should look like this:</p><a id="I_programlisting8_id450437"/><pre class="programlisting">#                size           offset  fstype [fsize bsize  cpg]
  a:         33543648               64  4.2BSD   2048 16384    1
  c:         33554304                0  unused</pre><p>When you’ve finished editing partitions, check your work by printing the disklabel. This should also give you the DUID of the new disk.</p><p>When you’re satisfied with the partitioning, use <code class="literal">newfs</code> to create a filesystem on the new partition:</p><a id="I_programlisting8_id450454"/><pre class="programlisting"># <span class="strong"><strong>newfs wd1a</strong></span></pre><p>You’re now ready to add the filesystem to your computer.</p></div><div class="sect2" title="Moving Partitions"><div class="titlepage"><div><div><h3 class="title" id="moving_partitions">Moving Partitions</h3></div></div></div><p>Moving data from one disk to another is slightly more complex than adding new partitions. You must first mount the new drive in a temporary location, copy files to that location, remove them from the old location, and mount the new drive in its previous home.</p><p>Our new <span class="emphasis"><em>/home</em></span> filesystem is on disk partition <span class="emphasis"><em>wd1a</em></span>. The default “temporary mount” location is <span class="emphasis"><em>/mnt</em></span>, so mount it there. This is strictly temporary, so there’s no need to mount it via the DUID or make an <span class="emphasis"><em>/etc/fstab</em></span> entry for this.</p><a id="I_programlisting8_id450502"/><pre class="programlisting"># <span class="strong"><strong>mount wd1a /mnt</strong></span></pre><p>You can then use <code class="literal">tar(1)</code>, <code class="literal">cpio(1)</code>, or <code class="literal">dump(8)</code> and <code class="literal">restore(8)</code> to copy the files to the temporary location. Here, we copy everything in <span class="emphasis"><em>/home</em></span> to <span class="emphasis"><em>/mnt</em></span>.</p><a id="I_programlisting8_id450537"/><pre class="programlisting"># <span class="strong"><strong>(cd /home &amp;&amp; tar cf - . ) | (cd /mnt &amp;&amp; tar xpf - )</strong></span></pre><p>You could also use <code class="literal">cp(1)</code> or <code class="literal">mv(1)</code> for this, but these commands don’t guarantee that file permissions and ownership will copy intact. OpenBSD’s versions of these programs have never given me errors when I copy or move files, but I’ve learned from other Unix-like operating systems that <code class="literal">tar</code> and <code class="literal">cpio</code> are both more reliable when moving entire file hierarchies. If you’re using file flags for security (see <a class="xref" href="ch10.html" title="Chapter 10. Securing Your System">Chapter 10</a>), you must use <code class="literal">dump(8)</code> and <code class="literal">restore(8)</code> to retain those flags.</p><p>Using <code class="literal">tar</code> or <code class="literal">cpio</code> does not delete files from their original location. This means that if a user changes files in his home directory after you copy them but before you change the mount point, he will lose his changes as you shuffle disks around.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.id369420" id="id369420">20</a>]</sup></p><p>Now update <span class="emphasis"><em>/etc/fstab</em></span> to reflect your new disk.</p></div><div class="sect2" title="Adding New Filesystems"><div class="titlepage"><div><div><h3 class="title" id="adding_new_filesystems">Adding New Filesystems</h3></div></div></div><p><a class="indexterm" id="idx0838"/><a class="indexterm" id="idx1410"/><a class="indexterm" id="idx2147"/><a class="indexterm" id="idx2226"/>Look at the disklabel for the new disk and get the disk’s DUID. This new disk has a DUID of <code class="literal">fea9194ee78362d8</code>. Use the DUID and the partition letter to make an <span class="emphasis"><em>/etc/fstab</em></span> entry for your new partitions.</p><a id="I_programlisting8_id450659"/><pre class="programlisting">fea9194ee78362d8.a /home ffs rw,nodev,nosuid,softdep 1 2</pre><p>You might want to keep the old partition available at a new location, such as <span class="emphasis"><em>/oldhome</em></span>.</p><p>If you’re not sure about the mount options to use for your new partitions, the options <code class="literal">nodev</code>, <code class="literal">nosuid</code>, and <code class="literal">softdep</code> are generally safe. You probably want the partition mounted read-write (<code class="literal">rw</code>) as well.</p><p>Now unmount the old and mount the new.</p><a id="I_programlisting8_id450693"/><pre class="programlisting"># <span class="strong"><strong>umount /home</strong></span>
# <span class="strong"><strong>mount /oldhome</strong></span>
# <span class="strong"><strong>mount /home</strong></span></pre><p>When you unmount a partition, <code class="literal">umount</code> doesn’t check <span class="emphasis"><em>/etc/fstab</em></span>. You tell it to unmount a partition, and it unmounts that partition.</p></div><div class="sect2" title="Stackable Mounts"><div class="titlepage"><div><div><h3 class="title" id="stackable_mounts">Stackable Mounts</h3></div></div></div><p>OpenBSD filesystems are <span class="emphasis"><em>stackable</em></span>, which means that you can mount one partition over another. The partition on top hides any files in the filesystem below.</p><p>Look at your system in single-user mode. By default, only the root partition is mounted. You can go look in the <span class="emphasis"><em>/home</em></span> directory, and it will be empty. There’s no reason you can’t put files in the <span class="emphasis"><em>/home</em></span> directory, even when <span class="emphasis"><em>/home</em></span> isn’t mounted. Suppose you copy a couple of core files into <span class="emphasis"><em>/home</em></span> while in single-user mode, and then go into multiuser mode. All the usual partitions are mounted. If you then look in <span class="emphasis"><em>/home</em></span>, you won’t find your core files.</p><p>What happened? Where did those files go?</p><p>The files are in the directory <span class="emphasis"><em>/home</em></span>, but on the root partition. The <span class="emphasis"><em>/home</em></span> partition is mounted above that directory, so the <span class="emphasis"><em>/home</em></span> partition obscures the files in the <span class="emphasis"><em>/home</em></span> directory on the root partition. To access those hidden files, you must unmount the <span class="emphasis"><em>/home</em></span> partition. Those hidden files continue to take up space on the root partition, however.</p><p>This happens more commonly when splitting a partition. For example, if you find that your <span class="emphasis"><em>/var</em></span> partition is too small, you might move <span class="emphasis"><em>/var/www</em></span> into its own partition on a separate disk. To free up space on the original <span class="emphasis"><em>/var</em></span>, delete the files you copied to <span class="emphasis"><em>/var/www</em></span>.</p><p>With the basics of filesystem management under your belt, you’re now ready to look at some of OpenBSD’s more interesting filesystem tricks.</p></div></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.id483068"><p><sup>[<a class="para" href="#id483068">17</a>] </sup>If it’s buffered aspirin, then you’re doing buffered buffered aspirin transfers. But let’s not go there.</p></div><div class="footnote" epub:type="footnote" id="ftn.id416360"><p><sup>[<a class="para" href="#id416360">18</a>] </sup>OpenBSD is not the only operating system that still uses the BSD 4.4 filesystem or a descendant thereof. If a Unix vendor doesn’t specifically tout its “improved and advanced” filesystem, it’s almost certainly running a derivative of FFS.</p></div><div class="footnote" epub:type="footnote" id="ftn.id425288"><p><sup>[<a class="para" href="#id425288">19</a>] </sup>Hi, Henning!</p></div><div class="footnote" epub:type="footnote" id="ftn.id369420"><p><sup>[<a class="para" href="#id369420">20</a>] </sup>Presumably you warn your users before doing maintenance. Or at least <span class="emphasis"><em>during</em></span> maintenance. Or … maybe afterward.</p></div></div></section></body></html>