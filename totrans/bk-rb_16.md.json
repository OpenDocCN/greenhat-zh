["```\np( /abc/ =˜ 'abc' )                 #=> 0\n```", "```\np( /abc/ =˜ 'xyzabcxyzabc' )        #=> 3\np( /abc/ =˜ 'xycab' )               #=> nil\n```", "```\np( /[abc]/ =˜ 'xycba' )             #=> 2\n```", "```\nregex1 = Regexp.new('^[a-z]*$')\nregex2 = /^[a-z]*$/\nregex3 = %r{^[a-z]*$}\n```", "```\ndef test( aStr, aRegEx )\n    if aRegEx =˜ aStr then\n        puts( \"All lowercase\" )\n    else\n        puts( \"Not all lowercase\" )\n    end\nend\n\ntest( \"hello\", regex1 )             #=> matches: \"All lowercase\"\ntest( \"hello\", regex2 )             #=> matches: \"All lowercase\"\ntest( \"Hello\", regex3 )             #=> no match: \"Not all lowercase\"\n```", "```\nif /def/ =˜ 'abcdef'\n```", "```\nRegEx = /def/\nStr1  = 'abcdef'\nStr2  = 'ghijkl'\n\nif RegEx =˜ Str1 then\n    puts( 'true' )\nelse\n    puts( 'false' )\nend                          #=> displays: true\n\nif RegEx =˜ Str2 then\n    puts( 'true' )\nelse\n    puts( 'false' )\nend                          #=> displays: false\n```", "```\nputs( /^a/ =˜ 'abc' )        #=> 0\nputs( /^b/ =˜ 'abc' )        #=> nil\nputs( /c$/ =˜ 'abc' )        #=> 2\nputs( /b$/ =˜ 'abc' )        #=> nil\n```", "```\np( /^[a-z 0-9]*$/ =˜ 'well hello 123' )\n```", "```\nputs( /^[a-z 0-9]*$/ =˜ 'well hello 123' ) # match at 0\nputs( /^[a-z 0-9]*$/ =˜ 'Well hello 123' ) # no match due to ^ and upcase W\n```", "```\nputs( /^[a-z 0-9]*$/ =˜ '' )        # this matches!\n```", "```\nputs( /^[a-z 0-9]+$/ =˜ '' )        # no match\n```", "```\naStr = \"HELLO WORLD\"\n\ncase aStr\n    when /^[a-z 0-9]*$/\n        puts( \"Lowercase\" )\n    when /^[A-Z 0-9]*$/\n        puts( \"Uppercase\" )\n    else\n        puts( \"Mixed case\\n\" )\nend\n```", "```\n# displays all the full-line comments in a Ruby file\nFile.foreach( 'regex1.rb' ){ |line|\n    if line =˜ /^\\s*#/ then\n        puts( line )\n    end\n}\n```", "```\n/(hi).*(h...o)/ =˜ \"The word 'hi' is short for 'hello'.\"\n```", "```\nprint( $1, \" \", $2, \"\\n\" )        #=> hi hello\n```", "```\n/(.)(.)(.)/ =˜ \"abcdef\"\nprint( $1, \" \", $3, \"\\n\" )        #=> a c\n```", "```\nFile.foreach( 'regex1.rb' ){ |line|\n    if line =˜ /^\\s*#(.*)/ then\n        puts( $1 )\n    end\n}\n```", "```\nFile.foreach( 'regex1.rb' ){ |line|\n   line = line.sub(/(^\\s*)#(.*)/, '\\1//\\2')\n      puts( line )\n}\n```", "```\n# aStr = \"hello world\"\n# aStr = \"Hello World\"\n```", "```\n// aStr = \"hello world\"\n// aStr = \"Hello World\"\n```", "```\nputs( /cde/ =˜ 'abcdefg' )        #=> 2\nputs( /cde/.match('abcdefg') )    #=> cde\n```", "```\np( /cde/.match('abcdefg') )       #=> #<MatchData: \"cde\" >\n```", "```\nx = /(^.*)(#)(.*)/.match( 'def myMethod # This is a very nice method' )\nx.captures.each{ |item| puts( item ) }\n```", "```\ndef myMethod\n#\n This is a very nice method\n```", "```\nx.captures    #=>[\"def myMethod \",\"#\",\" This is a very nice method\"]\n```", "```\nx.to_a    #=>[\"def myMethod # This is a very nice method\",\"def myMethod\n\",\"#\",\" This is a very nice method\"]\n```", "```\nx = /#/.match( 'def myMethod # This is a very nice method' )\nputs( x.pre_match )        #=> def myMethod\nputs( x.post_match )       #=>  This is a very nice method\n```", "```\nx = /#/.match( 'def myMethod # This is a very nice method' )\nputs( $` )                 #=> def myMethod\nputs( $' )                 #=>  This is a very nice method\n```", "```\nputs( /(.)(.)(.)/.match(\"abc\")[2] )                 #=> \"b\"\n```", "```\nputs( $˜[0], $˜[1], $˜[3] )\n```", "```\nputs( $˜.sort )               # this doesn't work!\nputs( $˜.captures.sort )      # this does\n```", "```\nputs( /.*at/.match('The cat sat on the mat!') )  #=> The cat sat on the mat\nputs( /.*?at/.match('The cat sat on the mat!') ) #=> The cat\n```", "```\nputs( /.+\\\\/.match('C:\\mydirectory\\myfolder\\myfile.txt') )\n    #=> C:\\mydirectory\\myfolder\\\nputs( /.+?\\\\/.match('C:\\mydirectory\\myfolder\\myfile.txt') )\n    #=> C:\\\n```", "```\nTESTSTR = \"abc is not cba\"\nputs( \"\\n--match--\" )\nb = /[abc]/.match( TESTSTR )        #=> \"a\" (MatchData)\nputs( \"--scan--\" )\na = TESTSTR.scan(/[abc]/)           #=> [\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]\n```", "```\na = TESTSTR.scan(/[abc]/){|c| print( c.upcase ) }     #=> ABCCBA\n```", "```\ns = \"def myMethod # a comment \"\n\nputs( s.slice( /m.*d/ ) )      #=> myMethod\nputs( s )                      #=> def myMethod # a comment\nputs( s.slice!( /m.*d/ ) )     #=> myMethod\nputs( s )                      #=> def  # a comment\n```", "```\ns = \"def myMethod # a comment\"\n\np( s.split( /m.*d/ ) )   #=> [\"def \", \" # a comment\"]\np( s.split( /\\s/ ) )     #=> [\"def\", \"myMethod\", \"#\", \"a\", \"comment\"]\n```", "```\np( s.split( // ) )\n```", "```\n[\"d\", \"e\", \"f\", \" \", \"m\", \"y\", \"M\", \"e\", \"t\", \"h\", \"o\", \"d\", \" \", \"#\", \" \",\n\"a\", \" \", \"c\", \"o\", \"m\", \"m\", \"e\", \"n\", \"t\"]\n```", "```\ns = \"def myMethod # a comment\"\ns2 = \"The cat sat on the mat\"\np( s.sub( /m.*d/, \"yourFunction\" ) )  #=> \"def yourFunction # a comment\"\np( s2.sub( /at/, \"aterpillar\" ) )     #=> \"The caterpillar sat on the mat\"\n```", "```\np( s2.gsub( /at/, \"aterpillar\" ) )\n        #=> \"The caterpillar saterpillar on the materpillar\"\n```", "```\ncount = 0\nFile.foreach( 'regex1.rb' ){ |line|\n    count += line.scan( /[a-z0-9A-Z]+/ ).size\n}\nputs( \"There are #{count} words in this file.\" )\n```", "```\nFile.foreach( 'regex1.rb' ){ |line|\n    line.scan( /[a-z0-9A-Z]+/ ).each{ |word|\n        count +=1\n        print( \"[#{count}] #{word}\\n\" )\n    }\n}\n```", "```\nFile.open( 'testfile1.txt', 'w' ){ |f|\n    File.foreach( 'regex1.rb' ){ |line|\n        f.puts( line.sub(/(^\\s*)#(.*)/, '\\1//\\2')  )\n    }\n}\n```", "```\nfile_out1 = File.open( 'comments.txt', 'w' )\nfile_out2 = File.open( 'nocomments.txt', 'w' )\n\nFile.foreach( 'regex1.rb' ){ |line|\n    if line =˜ /^\\s*#/ then\n        file_out1.puts( line )\n    else\n        file_out2.puts( line )\n    end\n}\n\nfile_out1.close\nfile_out2.close\n```", "```\n# match chars...\nputs( 'abcdefgh'.match( /cdefg/ ) )       # literal chars\n        #=> cdefg\nputs( 'abcdefgh'.match( /cd..g/ ) )       # dot matches any char\n        #=> cdefg\n\n# list of chars in square brackets...\nputs( 'cat'.match( /[fc]at/ )\n        #=> cat\nputs( \"batman's father's cat\".match( /[fc]at/ ) )\n        #=> fat\np( 'bat'.match( /[fc]at/ ) )\n        #=> nil\n\n# match char in a range...\nputs( 'ABC100x3Z'.match( /[A-Z][0-9][A-Z0-9]/ ) )\n        #=> C10\nputs( 'ABC100x3Z'.match( /[a-z][0-9][A-Z0-9]/ ) )\n        #=> x3Z\n\n# escape 'special' chars with \\\nputs( 'ask who?/what?'.match( /who\\?\\/w..t\\?/ ) )\n        #=> who?/what?\nputs( 'ABC 100x3Z'.match( /\\s\\S\\d\\d\\D/ ) )\n        #=>  100x (note the leading space)\n\n# scan for all occurrences of pattern 'abc' with at least 2 and\n# no more than 3 occurrences of the letter 'c'\np( 'abcabccabcccabccccabccccccabcccccccc'.scan( /abc{2,3}/ ) )\n        #=> [\"abcc\", \"abccc\", \"abccc\", \"abccc\", \"abccc\"]\n\n# match either of two patterns\nputs( 'my cat and my dog'.match( /cat|dog/ ) )             #=> cat\n\nputs( 'my hamster and my dog'.match( /cat|dog/ ) )     #=> dog\n```", "```\np( :abcdefgh.match( /cdefg/ ) )                   #=> 2\np( :abcdefgh.match( /cd..g/ ) )                   #=> 2\np( :cat.match( /[fc]at/ ) )                       #=> 0\np( :cat.match( /[xy]at/ ) )                       #=> nil\np( :ABC100x3Z.match( /[A-Z][0-9][A-Z0-9]/ ) )     #=> 2\np( :ABC100x3Z.match( /[a-z][0-9][A-Z0-9]/ ) )     #=> 6\n```"]