- en: Chapter 7. USER LOCATION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a location-based website requires a starting point. Sometimes this
    point comes as data from your database or from your site's focus on a small geographic
    area. Even in these cases, you can benefit from knowing a user's location.
  prefs: []
  type: TYPE_NORMAL
- en: You can retrieve this information in a number of ways, which I'll cover in this
    chapter. The methods vary in complexity and accuracy. In some cases, you'll need
    to make a simple call in JavaScript. In others, you'll install a database so your
    server can determine the location.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a user's location also depends on how much permission you need from
    him or her. An IP address, for example, is something every Internet user has.
    You can find a city-level location for most users without them even knowing you
    looked. For methods where the browser accesses another data source, you'll need
    the user's permission. In all cases, of course, you should do your part to ensure
    user privacy.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with perhaps the simplest method of determining a user's location,
    something that has been around as long as the Web itself.
  prefs: []
  type: TYPE_NORMAL
- en: '#47: Ask Users Where They Are'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Does this seem obvious? Asking users where they are may not be a flashy method
    of determining their location, but this method is bound to produce results the
    user expects. Plus, it has the built-in benefit of being only as specific as the
    user wants. In other words, the user can provide a full address, postal code,
    or simply a city name. If you're counting on knowing your users' whereabouts,
    at least include this project as a fallback when you cannot otherwise determine
    their location.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, what you want is latitude and longitude coordinates. Our maps expect
    those coordinates, and that's how so much geographic data is stored. We can't
    ask for latitude and longitude directly (go ahead and try that on your friends
    and see how many know their current geocodes); instead, we ask for the text representation
    of those coordinates. Once users give you this information, you'll probably need
    to feed it to a geocoder. This section won't cover that part, but you can learn
    all about it in [Chapter 3](ch03.html "Chapter 3. GEOCODING"). In this project,
    I'll show how to get the input into variables in both JavaScript and PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Get Input Using JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we rely upon JavaScript to accept input, you can use the data without having
    to reload the entire page. Also because mapping providers work with JavaScript,
    you only need one programming language, which simplifies things a bit.
  prefs: []
  type: TYPE_NORMAL
- en: To accept user input, we'll incorporate an HTML form into the site. The form
    will have a simple text input box and a Submit button, as shown in [Figure 7-1](ch07.html#request_location_or_other_input_with_jav
    "Figure 7-1. Request location or other input with JavaScript.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Request location or other input with JavaScript.](httpatomoreillycomsourcenostarchimages672075.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1. Request location or other input with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to a new HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When the page is loaded, the `prepare` function is called ❶. This method is
    similar to the `create_map` function in other mapping projects. The name of this
    function can be whatever you want, as long as it matches the name you use to call
    it.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to attach a submission event to the form ❷. You want to stop
    the form from submitting to the server, however, and instead use the data within
    JavaScript. In this example, I've used an inline, anonymous function instead of
    a named function for submitting the form. Otherwise, the `prepare` function would
    be a single line.
  prefs: []
  type: TYPE_NORMAL
- en: Also, I'm referencing the form by its index, which, in this case, is zero. It
    is the first and only form on this page. If other forms were on the page, it might
    be the second and its index would be one (because JavaScript array indexers start
    at zero). You could also give the form a name or ID and access it that way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the user input, I refer to the text input field by name from the
    form object ❸. Including the `.value` portion is important, as that retrieves
    the text the user typed, as opposed to the input field object. Once you have the
    text, what you do with it is your decision; for instance, you might display it
    on the site or determine its coordinates using [#12: Geocode with JavaScript](ch03s03.html
    "#12: Geocode with JavaScript") in [#12: Geocode with JavaScript](ch03s03.html
    "#12: Geocode with JavaScript").'
  prefs: []
  type: TYPE_NORMAL
- en: The final line ❹ of the submission function is also important. This line stops
    the browser from sending the form's input to the server, which is what we *want*
    to happen in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Get Input Using PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s be clear: Users type their input inside a browser. The difference between
    using JavaScript to get input and using PHP (or any server-side language) is that
    we allow the data to be submitted to the server. The original intention of an
    HTML form is to send data to a server-side script that then replies with additional
    HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because most of the notable stuff happens within a PHP script, the HTML for
    getting input is fairly simple. Add the following lines to a new HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code is essentially the same HTML as in the JavaScript example, but the
    JavaScript has been removed. The major difference is that the `<form>` tag receives
    a few more attributes.
  prefs: []
  type: TYPE_NORMAL
- en: I've declared a method ❶, which tells the browser how to send the input to the
    server. The two major options here are `GET`, which sends input inside the URL
    as a query string. I chose `POST`, which passes the data in the body of the HTTP
    message, so the user doesn't see it.
  prefs: []
  type: TYPE_NORMAL
- en: Another important attribute is the form's action ❷. This action is the destination
    URL for the form data. If the action is omitted, the current page will be assumed.
    If you're sending from a regular HTML file, this result is definitely not what
    you want because the server-side language will be unable to parse the data. I've
    used a PHP file in this case, as that's how I'll be reading in the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to make that PHP code, so add the following code to a new file
    named *input.php* (or to match your action attribute):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Pretty simple, right? All you need to do is pass the name of the input box to
    the `$_POST` variable, which is an associative array. PHP does the hard work of
    deciphering the header text and deciphering the encoded text.
  prefs: []
  type: TYPE_NORMAL
- en: If you're going to use the value within a database, make sure you verify the
    data is good. If you expecting a postal code, make sure the data is in the correct
    format. If you have an address, watch out for strange characters that don't belong
    in addresses—semicolons come to mind. You don't want to be the victim of a SQL
    injection attack, where user input is co-opted to create a hazardous query.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re going to use the input elsewhere, such as in [#13: Geocode with
    an HTTP Web Service](ch03s04.html "#13: Geocode with an HTTP Web Service") in
    [#13: Geocode with an HTTP Web Service](ch03s04.html "#13: Geocode with an HTTP
    Web Service"), you might be able to rely on its security. But most of the time,
    do as much as you can on your side to ensure data integrity.'
  prefs: []
  type: TYPE_NORMAL
- en: '#48: Get Location Using JavaScript'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many web browsers can now report your user's location with a lot more precision
    than you get with an IP address. Using the coordinates, you can save users the
    hassle of having to tell you their location, and you could, for example, automatically
    search nearby.
  prefs: []
  type: TYPE_NORMAL
- en: The Worldwide Web Consortium, often called the W3C, is an organization working
    for standards on the Web. In these examples, I will use the W3C's recommended
    syntax. Whether using a desktop, laptop, or mobile phone, the code that you will
    use is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s get to it. From anywhere in your JavaScript code, add the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function begins the geolocation process. The browser will request the user's
    permission to share his or her location with you. When the user approves, the
    browser will call a callback function, which is the first argument passed to `getCurrentPosition`.
    A second callback function is available when the location cannot be determined
    or the user rejects your request.
  prefs: []
  type: TYPE_NORMAL
- en: I made up the names of those functions, and you can use whatever name you want.
    Whatever you call them, however, you'll then need to write the functions, so the
    browser has something to reference. If you prefer anonymous, inline functions,
    you can use those in place of the named functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file that you used to make the location request, let''s add those
    two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first function, which is called when the browser is able to find a location
    and the user approves sharing it, is passed a position object ❶. We can use this
    to get at the latitude ❷, longitude, and some other data (more on that later).
    Once we have snagged both coordinates, we create a JavaScript alert, showing the
    location ❸. This alert is not especially useful, but we're just proving it works
    right now.
  prefs: []
  type: TYPE_NORMAL
- en: If no location can be found (or if the user doesn't want to share his or her
    location), we create a JavaScript alert that says so ❹. In a full application,
    you might choose to do nothing in this case. Or depending on how your site is
    designed, you could create an option to enter the location manually when it can't
    be determined.
  prefs: []
  type: TYPE_NORMAL
- en: Before we do something a little more interesting, let's talk about how an ordinary
    browser can even access your location.
  prefs: []
  type: TYPE_NORMAL
- en: Where Does the Data Come From?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The source and accuracy of the location data varies by source. A cutting-edge
    smart phone is certainly fitted with global positioning satellite (GPS), so the
    browser has a pretty good idea where you are if that's the source. What about
    on a laptop or desktop though?
  prefs: []
  type: TYPE_NORMAL
- en: Most computers do not have GPS. Instead, they rely on Wi-Fi to find your location.
    A handful of companies have driven around the world's largest cities (and some
    small ones, too!) and "sniffed" for wireless Internet. Whenever they find a signal,
    they add its unique ID to their database, along with the latitude and longitude.
  prefs: []
  type: TYPE_NORMAL
- en: Then, when a browser requests a location, it sniffs the available Wi-Fi. Armed
    with an ID, it asks a server to reply back with coordinates. Are you skeptical?
    In urban areas, this method is extremely accurate in finding a location because
    so many Wi-Fi access points are available. Also, wireless is only supposed to
    go a few hundred feet, so for most uses it's still fairly accurate. And in many
    cases, Wi-Fi is more reliable than GPS, which has a difficult time accessing signals
    indoors. You can see the accuracy of different methods in [Table 7-1](ch07s02.html#accuracy_of_geolocation_methods
    "Table 7-1. Accuracy of Geolocation Methods").
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1. Accuracy of Geolocation Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Accuracy |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GPS | Within feet |'
  prefs: []
  type: TYPE_TB
- en: '| WiFi | Within a block |'
  prefs: []
  type: TYPE_TB
- en: '| Cell towers | Within a few miles |'
  prefs: []
  type: TYPE_TB
- en: '| IP address | ZIP- or city-level |'
  prefs: []
  type: TYPE_TB
- en: When neither of these options is available, you need a fallback plan. A mobile
    device can sometimes use cell tower triangulation. A standard web browser, on
    the other hand, will always have an IP address. Whether the fallback is used depends
    on the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that varies with the device being used and the way the browser
    implements the location code is what additional data is available.
  prefs: []
  type: TYPE_NORMAL
- en: What Other Data Can We Get?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The W3C created a standard that could work in all situations. As you've seen,
    a number of data sources and devices can be used to determine a location. Mobile
    phones, especially, can provide some interesting data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, I described how to grab a location''s coordinates using JavaScript.
    Here are some other values you may be able to access:'
  prefs: []
  type: TYPE_NORMAL
- en: Time the location was acquired
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accuracy of the location, in meters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altitude of the location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accuracy of the altitude, if it exists, in meters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speed, in meters per second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heading, the direction in degrees relative to true north
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not every device will be able to provide all this information. For example,
    if the user is on a laptop, latitude and longitude may be all that is available.
    If the data comes from GPS, however, you may be able to access all these fields.
  prefs: []
  type: TYPE_NORMAL
- en: Use the Location on the Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you can get the user's location, you probably want to *do something*
    with it. The easiest example is to use it as the center of your new map. You could
    also add a marker at that spot. Heck, why don't we do both?
  prefs: []
  type: TYPE_NORMAL
- en: 'This example will be slightly different than the others in that the map won''t
    be created until we know that we have a location. Because of this, let''s start
    with a fresh HTML file, instead of the basic map. Add these lines to your new
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Because we only want to call the `create_map` function when we have a location,
    nothing is called when the page loads. Instead the call to `getCurrentPosition`
    happens within bare JavaScript, and then the map initialization function is used
    as a callback ❶. If no location is found, we don't want to do anything, so we
    create an empty inline function ❷. In the future, you might want to do something,
    so this leaves a template to remind you that something can go here.
  prefs: []
  type: TYPE_NORMAL
- en: When the `create_map` function does get called, the position ❸ the browser found
    is passed to it. The first thing we'll do with that position, which is an object
    in the W3C format, is convert it to Mapstraction's object for describing a point
    ❹. Then centering the map and creating the marker is as easy as the examples shown
    in the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: For a little extra fun, we give the marker a message box that says "You Are
    Here." After adding the marker to the map, we automatically display the message
    ❺. When I ran this in my hometown of Portland, I got the result shown in [Figure 7-2](ch07s02.html#location_coordinates_plotted_on_a_map
    "Figure 7-2. Location coordinates plotted on a map").
  prefs: []
  type: TYPE_NORMAL
- en: From here, you could plot local results on a map or get driving questions using
    the found location as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Receive Continual Updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your application will be used on a mobile device, then a user's location
    may change as he or she moves around. Depending on what you're doing with the
    data, receiving an initial location may not be enough—you may want updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The W3C has accounted for this need with a second function to access the user''s
    location. Rather than `getCurrentPosition`, you can use this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The two function references passed as arguments are used just as they are with
    a single location request. The difference here is the browser will periodically
    call your functions without the code performing another request. Frequency is
    determined by the browser and may be every minute or so. Mobile browsers will
    likely send updates more often.
  prefs: []
  type: TYPE_NORMAL
- en: '![Location coordinates plotted on a map](httpatomoreillycomsourcenostarchimages672077.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2. Location coordinates plotted on a map
  prefs: []
  type: TYPE_NORMAL
- en: You could implement this yourself by calling the single request every so often.
    The browser might prompt the user with every request, however; the `watchPosition`
    function's permission lasts until the user reloads the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the application to stop tracking the user''s location, you can
    clear it with this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note the function accepts one argument. This variable is an identifier output
    by the `watchPosition` function. In order to stop watching, store this identifier
    in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Geolocation Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two functions mentioned in the previous sections accept a third argument
    that I haven't covered yet. You can set additional options, such as how old a
    location can be and whether you want the highest accuracy possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example geolocation call that includes options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I created a variable to hold the location options, which are stored as a JavaScript
    object. The options can be entered in any order, and you don't have to include
    them all. In this case, I've used all three potential options.
  prefs: []
  type: TYPE_NORMAL
- en: First, `enableHighAccuracy` is a boolean that expects either `true` or `false`
    as a value. When set to `true`, the browser will provide the most accurate location
    it can, even if more time is required to do so (for example, a lock on additional
    GPS satellites). In previous examples where we did not use the options parameter,
    high accuracy was *not* enabled for efficiency reasons.
  prefs: []
  type: TYPE_NORMAL
- en: We can also give the browser a time limit for the location lookup using the
    `timeout` option. This option is set in milliseconds. Because there are 1000 milliseconds
    in 1 second, the example shows a 5-second timeout.
  prefs: []
  type: TYPE_NORMAL
- en: The final option, `maximumAge`, provides the browser with instructions for sending
    cached locations. Depending on your needs, you may want a very recent location,
    or you may not care as much. Like the timeout, this value is passed in milliseconds.
    In this example, I've shown a `maximumAge` of 60,000 milliseconds, or 1 minute.
  prefs: []
  type: TYPE_NORMAL
- en: The options object can be passed as the third argument to either `getCurrentPosition`
    or `watchPosition`. If you use the latter requesting continual updates, the options
    will be followed *every* time the browser returns a location.
  prefs: []
  type: TYPE_NORMAL
- en: '#49: Use Fire Eagle to Get Location'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can retrieve your user's location in several ways, some of them with very
    precise output. Many services that ask and store a user's current whereabouts
    are also available. Fire Eagle, a product from Yahoo!, is a broker for those services.
    When you write a Fire Eagle application, you can set or receive the user's current
    location, which then makes it available to all other Fire Eagle applications,
    as long as the user gives permission.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, I'll show how you can gain access to your user's location using
    Fire Eagle. And once a user has approved your application for access, you'll be
    able to get the user's latest location at any time, even when he or she isn't
    online.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, some application has to set the location for it to be accurate. Remember
    all those sites I mentioned that help users share their location? We'll let them
    worry about setting the location in Fire Eagle, so let's dive into using Fire
    Eagle to retrieve a location. The application we write will use PHP, which I cover
    in more depth in [Chapter 9](ch09.html "Chapter 9. GO SERVER-SIDE").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many other services for sharing location. By the time you read this,
    there are probably more. See a list and links to tutorials at [http://mapscripting.com/location-apis](http://mapscripting.com/location-apis).
  prefs: []
  type: TYPE_NORMAL
- en: Get the Fire Eagle Essentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yahoo! has some tools that make writing Fire Eagle applications much easier.
    Before you can use them, you'll want to register your application with Fire Eagle,
    so you get the codes that will make your program work. One is an API key, much
    like other services use; the other is a "secret code." If it helps, you can think
    of it as joining a secret club. Really, you're just filling out a form.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll need a Yahoo! account. Once you have that, head over to this page to
    register your app: [https://fireeagle.yahoo.net/developer/create](https://fireeagle.yahoo.net/developer/create).'
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry about being perfect. You can edit this application later. Plus,
    Fire Eagle lets you register multiple applications, so let this one be a dress
    rehearsal for the one you'll write later.
  prefs: []
  type: TYPE_NORMAL
- en: Fire Eagle has two important settings to pay attention to as you create your
    application. First, you're going to use **Auth for Web-based Services** for authentication.
    Next, you'll need to set a callback URL. The URL can be named anything you want,
    but for this simple example, let's use **`callback.php`**. Fire Eagle wants to
    know a full URL, so you'll insert something like [http://yoursite.com/fireeagle/callback.php](http://yoursite.com/fireeagle/callback.php).
    For testing purposes, you can even use your local machine instead of your server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you register your application, Fire Eagle will show you some special keys,
    the API, and the secret code I mentioned earlier. You can get back to them any
    time by visiting this page: [http://fireeagle.yahoo.net/developer/manage](http://fireeagle.yahoo.net/developer/manage).'
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing before you can leave the site for a little while: You need the
    API kit. Fire Eagle has prepackaged code for various web programming languages
    that makes coding applications much easier. Download the PHP kit from this page:
    [http://fireeagle.yahoo.net/developer/code/php](http://fireeagle.yahoo.net/developer/code/php).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You absolutely need two files from this package: *fireeagle.php* and *OAuth.php*.
    Store these inside a directory called *lib* (which stands for library) because
    we''ll be accessing them soon.'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticate the User
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name of one of these files suggests, Fire Eagle uses OAuth to authenticate
    users. If you haven't used OAuth before, it might seem a little strange, but I've
    come to appreciate its simplicity and security.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process to authenticate a user begins by requesting a *token* from Fire
    Eagle. This token actually comes in two pieces: *public* and *private*. We redirect
    the user to Fire Eagle, along with the public token. Then, when the user approves
    us for access, we can use the public and private tokens together to prove to Fire
    Eagle that we''re the approved application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it looks in code. Create a new file called *authorize.php* and
    add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To start, we use the key and secret code to create a new Fire Eagle object ❶.
    The key and secret code are different from the tokens I described. The key and
    secret code identify your application itself and will never change. The tokens
    are different for each user.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Fire Eagle object we created, now we request the public and private
    tokens ❷. We store these as session variables, which is how PHP maintains data
    for a user from one page to the next. Then we create another session variable
    that tells us the user has not signed in yet ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, using the public token, we redirect the user to a Fire Eagle URL ❹.
    This page is where the user will approve our application.
  prefs: []
  type: TYPE_NORMAL
- en: Answer the Call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the user agrees to give us access, Fire Eagle will redirect back to our
    callback URL. Remember that from the settings? When the user comes to this page,
    chances are pretty good he or she has authorized our application.
  prefs: []
  type: TYPE_NORMAL
- en: The callback page is where the user will officially log in. How you set this
    up will vary depending on what type of application you are creating. For example,
    if users have accounts stored in a database, you might maintain their Fire Eagle
    tokens there. Here we will simply update the session variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your *callback.php* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We create a Fire Eagle object ❶ again using the PHP kit that Yahoo! provided.
    This time we include the user's public and private tokens, in addition to our
    application's key and secret. Remember, this information proves we're the same
    application the user just approved.
  prefs: []
  type: TYPE_NORMAL
- en: If all these keys and tokens are confusing, get ready. One more pair is coming.
    Once a user approves an application, the public and private tokens aren't needed.
    Instead, they're replaced by *access tokens* ❷. We overwrite our previous session
    variables with new ones. And because the user has now successfully signed in,
    we can set that session variable appropriately ❸.
  prefs: []
  type: TYPE_NORMAL
- en: This process may seem like a long one to follow to access a user's location,
    but keep in mind it only needs to happen once. And the steps are all required
    in the name of security, which users appreciate. Plus, this callback page will
    appear instantly to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The final line redirects the user to the page we'll use to retrieve his or her
    location ❹. That's what this whole thing is really about, after all. So let's
    get down to it.
  prefs: []
  type: TYPE_NORMAL
- en: Get the User's Location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The user has given us access to his or her location. We can even check the session
    variable that we set to make sure. Now we're going to retrieve the user's location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the *getloc.php* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The code starts much like other pages have, by including the PHP API kit and
    declaring our application's key and secret code. Then we check our session variable
    to make sure the user really has given us permission ❶. If the signed-in variable
    is still 0, we could redirect to the authentication page, or show an error.
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous section, we create a Fire Eagle object using the application
    keys and the access tokens. Because we're pretty sure we can access the user's
    location at this point, we then ask Fire Eagle for the location object ❷. From
    there, we can retrieve its best guess for the user's location ❸, the most granular
    level of data the user is willing to share.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have access to several pieces of data, including the latitude ❹ and longitude.
    We can also get an idea of how long ago the user shared that location ❺. To improve
    legibility, I used the PHP `date` function to format the time stamp.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the HTML, we output the data ❻ we retrieved from Fire Eagle. Of
    course, this is just an example, not a great Fire Eagle application. The great
    one is the one you'll write. Right?
  prefs: []
  type: TYPE_NORMAL
- en: '#50: Get Location by IP'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All users on the Internet can be identified with a number that stays the same
    for at least a single online session and can be static—never changing. This number,
    called an *IP address*, is owned by the Internet provider, who usually has an
    entire block (or more) of similar numbers. With a database of these numbers tied
    to locations, you can usually determine at least the city your user is located
    in, if not the postal code.
  prefs: []
  type: TYPE_NORMAL
- en: I'll demonstrate other projects in this chapter that get at more granular data,
    determining a user's precise location. But knowing a geographic area is generally
    enough to do some interesting things. Plus, you can geolocate most of your users
    by using IPs, and you don't have to ask their permission.
  prefs: []
  type: TYPE_NORMAL
- en: What is an IP address? An IP address is a series of four numbers, each from
    one to three digits. For example, it might be *208.54.34.3*. Each computer connected
    to the Internet has its own IP address, though sometimes an address is shared
    across a local area network.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we'll look at two services that provide geographic coordinates
    based on the user's IP address. One must be used on the server, whereas the other
    runs in the browser using JavaScript. Which you choose depends on how you want
    to use the data. For example, if you store the result to a database, you will
    likely want the server-side version. But if you just want to center your map on
    the user's location, the JavaScript version will do just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Use the HostIP Web Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, I'll use the hostip.info API. A number of web services provide
    IP-based geolocation, including a commercial service called MaxMind. I picked
    HostIP, however, because it is easy to use, and the database is maintained by
    a community of developers and users.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using PHP to call the API, including some concepts described in [Chapter 8](ch08.html
    "Chapter 8. DATA FORMATS") and [Chapter 9](ch09.html "Chapter 9. GO SERVER-SIDE").
    I'll do my best to make understanding them easy, but you may want to flip ahead
    if something looks strange.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can start our PHP code, we need to get a feel for how we are going
    to get the data back from HostIP. Luckily, the site makes trying out the API within
    your browser easy. Try loading this URL into your address bar: [http://api.hostip.info/?ip=12.215.42.19](http://api.hostip.info/?ip=12.215.42.19).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your results should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Right in the middle of it all, shown in bold, are the latitude and longitude
    coordinates we want (note that here longitude comes first). Getting at those numbers
    means parsing the result and extracting the numbers. This process is shown in
    detail in [#52: Use XML](ch08.html#number_symble_52_colon_use_xml "#52: Use XML")
    in [#52: Use XML](ch08.html#number_symble_52_colon_use_xml "#52: Use XML"). Let''s
    put the latitude and longitude into two variables using PHP. Create a new file
    and add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Before we can make a call to HostIP, we need to determine the user's IP. Luckily,
    the IP is made available to PHP via a server variable, which we place into a local
    variable ❶.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code is relatively spartan, despite all that it does, mainly
    because it counts on other functions to do the heavy lifting. For example, we
    load the XML text in a one-line call ❷, passing the HostIP URL, which includes
    the user's IP address. To turn the text into an object we can use, we call the
    `SimpleXML` parsing function ❸ that converts the XML. Now that we have an easy-to-access
    object, we use the `xpath` function to return all `<coordinates>` tags ❹. We only
    have one, so we then pass it off to a string-splitting function to insert it into
    our two variables ❺.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of these functions rely on internal PHP, but one of them ❻ I wrote myself.
    You can see this entire function in [#61: Retrieve a Web Page](ch09s03.html "#61:
    Retrieve a Web Page") in [#61: Retrieve a Web Page](ch09s03.html "#61: Retrieve
    a Web Page").'
  prefs: []
  type: TYPE_NORMAL
- en: Use Google's ClientLocation JavaScript Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don't need the user's location on the server, you can easily get it if
    you use Google's Ajax Loader. This is an alternate way to load Google's JavaScript
    APIs, including Maps and Search. The `ClientLocation` object is available even
    without loading a specific API, which makes for minimal overhead considering the
    data it provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the standard Google Maps API, you need to include the call to Google''s
    JavaScript within the header of your HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then, anywhere within your JavaScript code, you can access `google.loader.ClientLocation.latitude`
    and `google.loader.ClientLocation.longitude` (in addition to a few other data
    items, such as the city name).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At press time the Ajax Loader only supports Google Maps version 2\. To use this
    example, you will need a Google Maps API key. You can find that, as well as updated
    information about the Ajax Loader at [http://code.google.com/apis/ajax/documentation/](http://code.google.com/apis/ajax/documentation/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Seeing it on a map is always easier, so let''s create a new Mapstraction map
    using Google as the mapping provider. Instead of the standard Google Maps, we''ll
    use the Ajax loader. Add the following code to a new HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The JavaScript's very first line tells the Google Ajax Loader to load in the
    Maps API ❶. Then, once it—and the rest of the page—has loaded, the `create_map`
    function gets called.
  prefs: []
  type: TYPE_NORMAL
- en: To access the location, we copy the `ClientLocation` object into a local variable
    ❷, making accessing it easier. Then we create a point ❸ using the latitude and
    longitude from the new object. From there, the code is much like previous JavaScript
    examples, where we use this point as the center of the map and create a marker.
  prefs: []
  type: TYPE_NORMAL
- en: '#51: Roll Your Own IP Database'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Are you the type who would refuse help if you took a spill in a public place?
    Then you're probably also the type who wants to host your *own* IP database, rather
    than depend on someone else's service. Of course, you might simply be someone
    who cares about performance or doesn't want to worry about network latency. Whatever
    the case, this project will help you geolocate users by IP using your own server.
  prefs: []
  type: TYPE_NORMAL
- en: Where does the data come from? We'll use a free service called IPInfoDB, which
    updates a streamlined MySQL database dump every month. Download the latest database
    at [http://ipinfodb.com/ip_database.php](http://ipinfodb.com/ip_database.php).
  prefs: []
  type: TYPE_NORMAL
- en: You have a number of choices for database types. For this example, we'll use
    the small, city-level database with a single table. The table should contain about
    1.4 million records, which will result in a database file a little over 100MB.
    (The file will be much smaller when you download the compressed version.)
  prefs: []
  type: TYPE_NORMAL
- en: Import IP Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have downloaded the SQL file, you need to import it. The file will
    be far too big to use phpMyAdmin, so you will need to use the command interpreter,
    which you can usually get to via the `mysql` command on a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be able to ask your system administrator to help you get to your MySQL
    database''s command interpreter. Or, if you are using MAMP, you can run `Library/bin/mysql
    -u root -p` within the MAMP directory (the password is also `root`). On WAMP,
    the location may vary, but it can commonly be found at `C:\wamp\bin\mysql\mysql`*version*`\bin\mysql`.
    In either case, you will need to access the interpreter via the command line:
    Terminal (on Mac) or CMD (on Windows).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the command interpreter and select your database, or create a new one
    (see [#63: Store Locations to a Database](ch09s05.html "#63: Store Locations to
    a Database") in [Install MySQL Yourself](ch09s04.html#install_mysql_yourself "Install
    MySQL Yourself")). To begin the process of importing your data, type the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you include the full path to the SQL file you downloaded. As it imports,
    you''ll see messages like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When the messages end, you can leave the command interpreter and return to phpMyAdmin,
    if you wish. Now that we've added the data, let's access it.
  prefs: []
  type: TYPE_NORMAL
- en: Find an IP's Location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What information is available with the IP database, and how is it stored? From
    phpMyAdmin, click through to your database and then to the `ip_group_city` table
    that you've just imported. Click the Browse tab and you'll see the first 30 records
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Among the interesting fields available are city, latitude, and longitude. You'll
    also see the IP address itself, stored as a very large number, which is different
    than the period-separated version you're used to seeing. The difference is because
    you need to do a little preprocessing, which makes the lookup process much more
    efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Where the IP is `A.B.C.D`, the number can be expressed as `((A*256+B)*256+C)*256`.
    So *71.59.208.255* would become *1195102208*. As would anything in the *71.59.208.X*
    block. Notice the formula does not have a D; that's because IPs come in blocks,
    so everything in the range will likely have the same location.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process of converting an IP to a number is fairly standardized. In fact,
    MySQL has a helper function, `INET_ATON`, which makes it super easy. Click the
    SQL tab in phpMyAdmin, or use the command interpreter, and add the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Remember to replace the IP address I used with one of your own. Here, I've requested
    all the fields for the closest IP address in the database. In order to keep from
    getting all 1.4 million records back in order, I limit the results to one row—the
    one I want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll connect it to a PHP script, something covered in [#65: Use MySQL
    from PHP](ch09s07.html "#65: Use MySQL from PHP") in [#65: Use MySQL from PHP](ch09s07.html
    "#65: Use MySQL from PHP").'
  prefs: []
  type: TYPE_NORMAL
