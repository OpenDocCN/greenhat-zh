- en: Chapter 7. USER LOCATION
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。用户位置
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
- en: Creating a location-based website requires a starting point. Sometimes this
    point comes as data from your database or from your site's focus on a small geographic
    area. Even in these cases, you can benefit from knowing a user's location.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个基于位置网站需要一个起点。有时这个点来自您的数据库数据，或者来自您网站对一个小地理区域的关注。即使在这些情况下，了解用户的位置也能给您带来好处。
- en: You can retrieve this information in a number of ways, which I'll cover in this
    chapter. The methods vary in complexity and accuracy. In some cases, you'll need
    to make a simple call in JavaScript. In others, you'll install a database so your
    server can determine the location.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过多种方式检索这些信息，我将在本章中介绍。这些方法在复杂性和准确性方面有所不同。在某些情况下，您可能需要在JavaScript中做一个简单的调用。在其他情况下，您将安装一个数据库，以便您的服务器可以确定位置。
- en: Finding a user's location also depends on how much permission you need from
    him or her. An IP address, for example, is something every Internet user has.
    You can find a city-level location for most users without them even knowing you
    looked. For methods where the browser accesses another data source, you'll need
    the user's permission. In all cases, of course, you should do your part to ensure
    user privacy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 找到用户的位置也取决于您需要从他们那里获得多少权限。例如，IP地址是每个互联网用户都有的东西。您可以在用户甚至不知道您在查找的情况下，为大多数用户找到城市级别的位置。对于浏览器访问其他数据源的方法，您将需要用户的权限。当然，在所有情况下，您都应该尽自己的一份力来确保用户隐私。
- en: We'll start with perhaps the simplest method of determining a user's location,
    something that has been around as long as the Web itself.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从可能最简单的方法开始，确定用户的位置，这种方法与互联网本身一样历史悠久。
- en: '#47: Ask Users Where They Are'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#47: 询问用户他们在哪里'
- en: Does this seem obvious? Asking users where they are may not be a flashy method
    of determining their location, but this method is bound to produce results the
    user expects. Plus, it has the built-in benefit of being only as specific as the
    user wants. In other words, the user can provide a full address, postal code,
    or simply a city name. If you're counting on knowing your users' whereabouts,
    at least include this project as a fallback when you cannot otherwise determine
    their location.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来明显吗？询问用户他们在哪里可能不是确定他们位置的一种引人注目的方法，但这种方法肯定会产生用户期望的结果。此外，它具有内置的好处，即只具体到用户想要的程度。换句话说，用户可以提供一个完整的地址、邮政编码，或者只是一个城市名称。如果您依赖于知道用户的所在地，至少在您无法确定他们的位置时，将此项目作为备选方案。
- en: Of course, what you want is latitude and longitude coordinates. Our maps expect
    those coordinates, and that's how so much geographic data is stored. We can't
    ask for latitude and longitude directly (go ahead and try that on your friends
    and see how many know their current geocodes); instead, we ask for the text representation
    of those coordinates. Once users give you this information, you'll probably need
    to feed it to a geocoder. This section won't cover that part, but you can learn
    all about it in [Chapter 3](ch03.html "Chapter 3. GEOCODING"). In this project,
    I'll show how to get the input into variables in both JavaScript and PHP.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您想要的是纬度和经度坐标。我们的地图需要这些坐标，这也是大量地理数据存储的方式。我们无法直接请求纬度和经度（您可以尝试在您的朋友身上这样做，看看有多少人知道他们当前的地理编码）；相反，我们请求这些坐标的文本表示。一旦用户提供了这些信息，您可能需要将其输入到地理编码器中。本节不会涵盖这部分内容，但您可以在[第3章](ch03.html
    "第3章。地理编码")中了解所有相关信息。在这个项目中，我将展示如何使用JavaScript和PHP将输入放入变量中。
- en: Get Input Using JavaScript
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JavaScript获取输入
- en: When we rely upon JavaScript to accept input, you can use the data without having
    to reload the entire page. Also because mapping providers work with JavaScript,
    you only need one programming language, which simplifies things a bit.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们依赖JavaScript来接受输入时，您可以在不重新加载整个页面的情况下使用这些数据。此外，由于地图服务提供商与JavaScript一起工作，您只需要一种编程语言，这简化了一些事情。
- en: To accept user input, we'll incorporate an HTML form into the site. The form
    will have a simple text input box and a Submit button, as shown in [Figure 7-1](ch07.html#request_location_or_other_input_with_jav
    "Figure 7-1. Request location or other input with JavaScript.").
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接受用户输入，我们将把一个HTML表单集成到网站上。该表单将包含一个简单的文本输入框和一个提交按钮，如图[图7-1](ch07.html#request_location_or_other_input_with_jav
    "图7-1. 使用JavaScript请求位置或其他输入。")所示。
- en: '![Request location or other input with JavaScript.](httpatomoreillycomsourcenostarchimages672075.png.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![使用JavaScript请求位置或其他输入。](httpatomoreillycomsourcenostarchimages672075.png.jpg)'
- en: Figure 7-1. Request location or other input with JavaScript.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1. 使用 JavaScript 请求位置或其他输入。
- en: 'Add the following code to a new HTML page:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到一个新的 HTML 页面中：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When the page is loaded, the `prepare` function is called ❶. This method is
    similar to the `create_map` function in other mapping projects. The name of this
    function can be whatever you want, as long as it matches the name you use to call
    it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载时，会调用 `prepare` 函数 ❶。这种方法与其他地图项目中的 `create_map` 函数类似。这个函数的名字可以是任何你想要的，只要它与你用来调用它的名字匹配即可。
- en: First, you need to attach a submission event to the form ❷. You want to stop
    the form from submitting to the server, however, and instead use the data within
    JavaScript. In this example, I've used an inline, anonymous function instead of
    a named function for submitting the form. Otherwise, the `prepare` function would
    be a single line.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将提交事件附加到表单 ❷。你想要阻止表单提交到服务器，而是使用 JavaScript 中的数据。在这个例子中，我使用了一个内联的匿名函数来提交表单，而不是命名函数。否则，`prepare`
    函数将只有一行。
- en: Also, I'm referencing the form by its index, which, in this case, is zero. It
    is the first and only form on this page. If other forms were on the page, it might
    be the second and its index would be one (because JavaScript array indexers start
    at zero). You could also give the form a name or ID and access it that way.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我通过索引引用表单，在这个例子中，索引是零。这是页面上的第一个也是唯一一个表单。如果页面上有其他表单，它可能是第二个，其索引将是 1（因为 JavaScript
    数组索引从零开始）。你也可以给表单一个名字或 ID，然后通过这种方式访问它。
- en: 'To obtain the user input, I refer to the text input field by name from the
    form object ❸. Including the `.value` portion is important, as that retrieves
    the text the user typed, as opposed to the input field object. Once you have the
    text, what you do with it is your decision; for instance, you might display it
    on the site or determine its coordinates using [#12: Geocode with JavaScript](ch03s03.html
    "#12: Geocode with JavaScript") in [#12: Geocode with JavaScript](ch03s03.html
    "#12: Geocode with JavaScript").'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '要获取用户输入，我通过表单对象中的名称来引用文本输入字段 ❸。包含 `.value` 部分很重要，因为它可以检索用户输入的文本，而不是输入字段对象。一旦你有了文本，你可以决定如何使用它；例如，你可以在网站上显示它或使用
    [#12: 使用 JavaScript 进行地理编码](ch03s03.html "#12: 使用 JavaScript 进行地理编码") 来确定其坐标 [#12:
    使用 JavaScript 进行地理编码](ch03s03.html "#12: 使用 JavaScript 进行地理编码")。'
- en: The final line ❹ of the submission function is also important. This line stops
    the browser from sending the form's input to the server, which is what we *want*
    to happen in the next section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 提交函数的最后一行 ❹ 也同样重要。这一行阻止浏览器将表单的输入发送到服务器，这是我们 *希望* 在下一节发生的事情。
- en: Get Input Using PHP
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PHP 获取输入
- en: 'Let''s be clear: Users type their input inside a browser. The difference between
    using JavaScript to get input and using PHP (or any server-side language) is that
    we allow the data to be submitted to the server. The original intention of an
    HTML form is to send data to a server-side script that then replies with additional
    HTML.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们明确一下：用户在浏览器中输入他们的输入。使用 JavaScript 获取输入和使用 PHP（或任何服务器端语言）之间的区别在于，我们允许数据提交到服务器。HTML
    表单的原始目的是将数据发送到服务器端的脚本，然后以额外的 HTML 进行回复。
- en: 'Because most of the notable stuff happens within a PHP script, the HTML for
    getting input is fairly simple. Add the following lines to a new HTML file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大部分显著的操作都在 PHP 脚本中完成，因此获取输入的 HTML 代码相当简单。将以下行添加到一个新的 HTML 文件中：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code is essentially the same HTML as in the JavaScript example, but the
    JavaScript has been removed. The major difference is that the `<form>` tag receives
    a few more attributes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码基本上与 JavaScript 示例中的 HTML 相同，但移除了 JavaScript。主要区别是 `<form>` 标签接收了几个额外的属性。
- en: I've declared a method ❶, which tells the browser how to send the input to the
    server. The two major options here are `GET`, which sends input inside the URL
    as a query string. I chose `POST`, which passes the data in the body of the HTTP
    message, so the user doesn't see it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我声明了一个方法 ❶，它告诉浏览器如何将输入发送到服务器。这里有两个主要选项：`GET`，它将输入作为查询字符串放在 URL 中。我选择了 `POST`，它将数据放在
    HTTP 消息的主体中，这样用户就看不到它。
- en: Another important attribute is the form's action ❷. This action is the destination
    URL for the form data. If the action is omitted, the current page will be assumed.
    If you're sending from a regular HTML file, this result is definitely not what
    you want because the server-side language will be unable to parse the data. I've
    used a PHP file in this case, as that's how I'll be reading in the input.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的属性是表单的action ❷。这个action是表单数据的目标URL。如果省略了action，则默认为当前页面。如果你从一个普通的HTML文件发送，这个结果肯定不是你想要的，因为服务器端语言将无法解析数据。在这种情况下，我使用了PHP文件，因为这就是我将如何读取输入的。
- en: 'Now we need to make that PHP code, so add the following code to a new file
    named *input.php* (or to match your action attribute):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要编写PHP代码，因此将以下代码添加到名为*input.php*的新文件中（或与你的action属性匹配）：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Pretty simple, right? All you need to do is pass the name of the input box to
    the `$_POST` variable, which is an associative array. PHP does the hard work of
    deciphering the header text and deciphering the encoded text.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？你只需要将输入框的名称传递给`$_POST`变量，它是一个关联数组。PHP会做艰难的工作，解析头部文本和解码文本。
- en: If you're going to use the value within a database, make sure you verify the
    data is good. If you expecting a postal code, make sure the data is in the correct
    format. If you have an address, watch out for strange characters that don't belong
    in addresses—semicolons come to mind. You don't want to be the victim of a SQL
    injection attack, where user input is co-opted to create a hazardous query.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在数据库中使用该值，请确保验证数据是好的。如果你期望邮政编码，请确保数据格式正确。如果你有一个地址，要注意地址中不属于地址的奇怪字符——分号就是其中之一。你不想成为SQL注入攻击的受害者，其中用户输入被用来创建有害的查询。
- en: 'If you''re going to use the input elsewhere, such as in [#13: Geocode with
    an HTTP Web Service](ch03s04.html "#13: Geocode with an HTTP Web Service") in
    [#13: Geocode with an HTTP Web Service](ch03s04.html "#13: Geocode with an HTTP
    Web Service"), you might be able to rely on its security. But most of the time,
    do as much as you can on your side to ensure data integrity.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你打算在其他地方使用输入，比如在[#13: 使用HTTP网络服务进行地理编码](ch03s04.html "#13: 使用HTTP网络服务进行地理编码")中，你可能会依赖它的安全性。但大多数时候，尽可能在你的端上做更多的工作，以确保数据完整性。'
- en: '#48: Get Location Using JavaScript'
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#48: 使用JavaScript获取位置'
- en: Many web browsers can now report your user's location with a lot more precision
    than you get with an IP address. Using the coordinates, you can save users the
    hassle of having to tell you their location, and you could, for example, automatically
    search nearby.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网络浏览器现在可以比使用IP地址提供更精确的用户位置信息。使用坐标，你可以省去用户告诉你他们位置的需要，例如，可以自动搜索附近的地点。
- en: The Worldwide Web Consortium, often called the W3C, is an organization working
    for standards on the Web. In these examples, I will use the W3C's recommended
    syntax. Whether using a desktop, laptop, or mobile phone, the code that you will
    use is the same.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网联盟，通常被称为W3C，是一个致力于制定网络标准的组织。在这些示例中，我将使用W3C推荐的语法。无论使用台式机、笔记本电脑还是移动电话，你将使用的代码都是相同的。
- en: 'So, let''s get to it. From anywhere in your JavaScript code, add the following
    line:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。从你的JavaScript代码的任何地方，添加以下行：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function begins the geolocation process. The browser will request the user's
    permission to share his or her location with you. When the user approves, the
    browser will call a callback function, which is the first argument passed to `getCurrentPosition`.
    A second callback function is available when the location cannot be determined
    or the user rejects your request.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数开始地理位置过程。浏览器将请求用户的许可，以便与你共享他的或她的位置。当用户批准时，浏览器将调用一个回调函数，这是传递给`getCurrentPosition`的第一个参数。当无法确定位置或用户拒绝你的请求时，还有一个可用的第二个回调函数。
- en: I made up the names of those functions, and you can use whatever name you want.
    Whatever you call them, however, you'll then need to write the functions, so the
    browser has something to reference. If you prefer anonymous, inline functions,
    you can use those in place of the named functions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我自己想出了那些函数的名字，你可以使用任何你想要的名称。然而，无论你叫它们什么，你都需要编写这些函数，这样浏览器就有东西可以引用。如果你更喜欢匿名内联函数，你可以用它们来代替命名函数。
- en: 'In the same file that you used to make the location request, let''s add those
    two functions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在你用于发出位置请求的同一文件中，让我们添加这两个函数：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first function, which is called when the browser is able to find a location
    and the user approves sharing it, is passed a position object ❶. We can use this
    to get at the latitude ❷, longitude, and some other data (more on that later).
    Once we have snagged both coordinates, we create a JavaScript alert, showing the
    location ❸. This alert is not especially useful, but we're just proving it works
    right now.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数，当浏览器能够找到位置并且用户同意共享时会被调用，它接收一个位置对象 ❶。我们可以利用这个对象获取纬度 ❷、经度以及一些其他数据（关于这一点稍后详述）。一旦我们获取了这两个坐标，我们就会创建一个JavaScript警告框，显示位置
    ❸。这个警告框并不特别有用，但我们现在只是证明它能够正常工作。
- en: If no location can be found (or if the user doesn't want to share his or her
    location), we create a JavaScript alert that says so ❹. In a full application,
    you might choose to do nothing in this case. Or depending on how your site is
    designed, you could create an option to enter the location manually when it can't
    be determined.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到位置（或者如果用户不想分享他的或她的位置），我们会创建一个JavaScript警告框，说明这一点 ❹。在一个完整的应用程序中，在这种情况下，您可能选择不采取任何行动。或者根据您网站的设计，您可以在无法确定位置时创建一个手动输入位置的选项。
- en: Before we do something a little more interesting, let's talk about how an ordinary
    browser can even access your location.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行一些更有趣的操作之前，让我们谈谈一个普通的浏览器是如何访问您的位置的。
- en: Where Does the Data Come From?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据来自哪里？
- en: The source and accuracy of the location data varies by source. A cutting-edge
    smart phone is certainly fitted with global positioning satellite (GPS), so the
    browser has a pretty good idea where you are if that's the source. What about
    on a laptop or desktop though?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 位置数据的来源和准确性因来源而异。一款前沿的智能手机当然配备了全球定位卫星（GPS），因此如果这是数据来源，浏览器就能相当准确地知道您在哪里。那么在笔记本电脑或台式机上呢？
- en: Most computers do not have GPS. Instead, they rely on Wi-Fi to find your location.
    A handful of companies have driven around the world's largest cities (and some
    small ones, too!) and "sniffed" for wireless Internet. Whenever they find a signal,
    they add its unique ID to their database, along with the latitude and longitude.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机没有GPS。相反，它们依赖Wi-Fi来找到您的位置。一些公司已经在全球最大的城市（以及一些小城市）周围开车，并“嗅探”无线互联网。每当他们发现信号时，他们就会将其唯一的ID添加到他们的数据库中，包括纬度和经度。
- en: Then, when a browser requests a location, it sniffs the available Wi-Fi. Armed
    with an ID, it asks a server to reply back with coordinates. Are you skeptical?
    In urban areas, this method is extremely accurate in finding a location because
    so many Wi-Fi access points are available. Also, wireless is only supposed to
    go a few hundred feet, so for most uses it's still fairly accurate. And in many
    cases, Wi-Fi is more reliable than GPS, which has a difficult time accessing signals
    indoors. You can see the accuracy of different methods in [Table 7-1](ch07s02.html#accuracy_of_geolocation_methods
    "Table 7-1. Accuracy of Geolocation Methods").
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当浏览器请求位置时，它会检测可用的Wi-Fi。有了ID，它会请求服务器回复坐标。您怀疑吗？在市区，这种方法在定位位置方面非常准确，因为有很多Wi-Fi接入点可用。此外，无线信号只应该传播几百英尺，所以对于大多数用途来说，它仍然相当准确。而且在很多情况下，Wi-Fi比GPS更可靠，GPS在室内获取信号比较困难。您可以在[表
    7-1](ch07s02.html#accuracy_of_geolocation_methods "表 7-1. 地理定位方法的准确性")中看到不同方法的准确性。
- en: Table 7-1. Accuracy of Geolocation Methods
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1. 地理定位方法的准确性
- en: '| Method | Accuracy |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 准确性 |'
- en: '| --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GPS | Within feet |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| GPS | 在几英尺范围内 |'
- en: '| WiFi | Within a block |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| WiFi | 在一个街区范围内 |'
- en: '| Cell towers | Within a few miles |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 蜂窝基站 | 在几英里范围内 |'
- en: '| IP address | ZIP- or city-level |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| IP地址 | ZIP码或城市级别 |'
- en: When neither of these options is available, you need a fallback plan. A mobile
    device can sometimes use cell tower triangulation. A standard web browser, on
    the other hand, will always have an IP address. Whether the fallback is used depends
    on the implementation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当这两种选项都不可用时，您需要有一个后备计划。移动设备有时可以使用蜂窝基站三角测量。另一方面，标准网络浏览器始终有一个IP地址。是否使用后备计划取决于实现方式。
- en: Another thing that varies with the device being used and the way the browser
    implements the location code is what additional data is available.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个随着使用的设备和浏览器实现位置代码的方式而变化的是，可用的附加数据。
- en: What Other Data Can We Get?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们可以获得哪些其他数据？
- en: The W3C created a standard that could work in all situations. As you've seen,
    a number of data sources and devices can be used to determine a location. Mobile
    phones, especially, can provide some interesting data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: W3C创建了一个可以在所有情况下工作的标准。正如您所看到的，可以使用多种数据源和设备来确定位置。特别是，移动电话可以提供一些有趣的数据。
- en: 'Previously, I described how to grab a location''s coordinates using JavaScript.
    Here are some other values you may be able to access:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我描述了如何使用JavaScript获取位置坐标。这里有一些你可能能够访问的其他值：
- en: Time the location was acquired
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取位置的时间
- en: Accuracy of the location, in meters
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置的精度，以米为单位
- en: Altitude of the location
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置的海拔高度
- en: Accuracy of the altitude, if it exists, in meters
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在，海拔精度的米
- en: Speed, in meters per second
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度，以米/秒为单位
- en: Heading, the direction in degrees relative to true north
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 航向，相对于真北的方向，以度为单位
- en: Not every device will be able to provide all this information. For example,
    if the user is on a laptop, latitude and longitude may be all that is available.
    If the data comes from GPS, however, you may be able to access all these fields.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个设备都能提供所有这些信息。例如，如果用户在使用笔记本电脑，可能只有纬度和经度是可用的。然而，如果数据来自GPS，你可能能够访问所有这些字段。
- en: Use the Location on the Map
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在地图上使用位置
- en: Now that you can get the user's location, you probably want to *do something*
    with it. The easiest example is to use it as the center of your new map. You could
    also add a marker at that spot. Heck, why don't we do both?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以获取用户的位置，你可能想对它*做一些事情*。最简单的例子是将它用作新地图的中心。你还可以在那个位置添加一个标记。嘿，为什么不两者都做呢？
- en: 'This example will be slightly different than the others in that the map won''t
    be created until we know that we have a location. Because of this, let''s start
    with a fresh HTML file, instead of the basic map. Add these lines to your new
    file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将与其他例子略有不同，因为地图将在我们知道有位置信息时才创建。因此，让我们从一个新的HTML文件开始，而不是基本地图。将以下行添加到你的新文件中：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Because we only want to call the `create_map` function when we have a location,
    nothing is called when the page loads. Instead the call to `getCurrentPosition`
    happens within bare JavaScript, and then the map initialization function is used
    as a callback ❶. If no location is found, we don't want to do anything, so we
    create an empty inline function ❷. In the future, you might want to do something,
    so this leaves a template to remind you that something can go here.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们只想在拥有位置信息时调用`create_map`函数，所以在页面加载时不会调用任何东西。相反，`getCurrentPosition`的调用发生在裸JavaScript中，然后使用地图初始化函数作为回调❶。如果没有找到位置，我们不想做任何事情，因此我们创建了一个空的内联函数❷。将来，你可能想做一些事情，所以这留下了一个模板来提醒你这里可以放置某些内容。
- en: When the `create_map` function does get called, the position ❸ the browser found
    is passed to it. The first thing we'll do with that position, which is an object
    in the W3C format, is convert it to Mapstraction's object for describing a point
    ❹. Then centering the map and creating the marker is as easy as the examples shown
    in the first two chapters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当`create_map`函数被调用时，浏览器找到的位置❸会被传递给它。我们将首先使用这个位置，它是一个W3C格式的对象，将其转换为Mapstraction描述点的对象❹。然后，将地图居中并创建标记就像第一、第二章中展示的例子一样简单。
- en: For a little extra fun, we give the marker a message box that says "You Are
    Here." After adding the marker to the map, we automatically display the message
    ❺. When I ran this in my hometown of Portland, I got the result shown in [Figure 7-2](ch07s02.html#location_coordinates_plotted_on_a_map
    "Figure 7-2. Location coordinates plotted on a map").
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加一些乐趣，我们给标记添加了一个消息框，上面写着“您在这里”。在将标记添加到地图后，我们会自动显示消息❺。当我在我家乡波特兰运行这个程序时，我得到了[图7-2](ch07s02.html#location_coordinates_plotted_on_a_map
    "图7-2. 地图上绘制的位置坐标")中所示的结果。
- en: From here, you could plot local results on a map or get driving questions using
    the found location as a starting point.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以在地图上绘制本地结果或使用找到的位置作为起点获取驾驶问题。
- en: Receive Continual Updates
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接收持续更新
- en: If your application will be used on a mobile device, then a user's location
    may change as he or she moves around. Depending on what you're doing with the
    data, receiving an initial location may not be enough—you may want updates.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序将在移动设备上使用，那么用户的位置可能会随着他们的移动而改变。根据你对数据的处理方式，接收一个初始位置可能不够——你可能需要更新。
- en: 'The W3C has accounted for this need with a second function to access the user''s
    location. Rather than `getCurrentPosition`, you can use this line:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: W3C通过第二个函数来满足这一需求，以访问用户的位置。而不是使用`getCurrentPosition`，你可以使用以下这行代码：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The two function references passed as arguments are used just as they are with
    a single location request. The difference here is the browser will periodically
    call your functions without the code performing another request. Frequency is
    determined by the browser and may be every minute or so. Mobile browsers will
    likely send updates more often.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参数传递的两个函数引用的使用方式与单个位置请求相同。这里的区别是，浏览器将定期调用您的函数，而无需代码执行另一个请求。频率由浏览器决定，可能是每分钟或更频繁。移动浏览器可能会更频繁地发送更新。
- en: '![Location coordinates plotted on a map](httpatomoreillycomsourcenostarchimages672077.png.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![在地图上绘制的位置坐标](httpatomoreillycomsourcenostarchimages672077.png.jpg)'
- en: Figure 7-2. Location coordinates plotted on a map
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-2. 在地图上绘制的位置坐标
- en: You could implement this yourself by calling the single request every so often.
    The browser might prompt the user with every request, however; the `watchPosition`
    function's permission lasts until the user reloads the page.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过每隔一段时间调用单个请求来实现这一点。然而，浏览器可能会在每次请求时提示用户；`watchPosition`函数的权限将持续到用户重新加载页面。
- en: 'If you want the application to stop tracking the user''s location, you can
    clear it with this function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想停止跟踪用户的地理位置，可以使用此函数清除：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note the function accepts one argument. This variable is an identifier output
    by the `watchPosition` function. In order to stop watching, store this identifier
    in a variable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意该函数接受一个参数。这个变量是`watchPosition`函数输出的标识符。为了停止监视，请将此标识符存储在变量中。
- en: Additional Geolocation Options
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他地理位置选项
- en: The two functions mentioned in the previous sections accept a third argument
    that I haven't covered yet. You can set additional options, such as how old a
    location can be and whether you want the highest accuracy possible.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中提到的两个函数接受一个尚未覆盖的第三个参数。您可以设置额外的选项，例如位置可以有多旧，以及您是否想要尽可能高的精度。
- en: 'Here is an example geolocation call that includes options:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个包含选项的地理位置调用示例：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I created a variable to hold the location options, which are stored as a JavaScript
    object. The options can be entered in any order, and you don't have to include
    them all. In this case, I've used all three potential options.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个变量来保存位置选项，这些选项存储为JavaScript对象。选项可以按任何顺序输入，并且不必包含所有选项。在这种情况下，我使用了所有三个潜在选项。
- en: First, `enableHighAccuracy` is a boolean that expects either `true` or `false`
    as a value. When set to `true`, the browser will provide the most accurate location
    it can, even if more time is required to do so (for example, a lock on additional
    GPS satellites). In previous examples where we did not use the options parameter,
    high accuracy was *not* enabled for efficiency reasons.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`enableHighAccuracy`是一个布尔值，期望的值是`true`或`false`。当设置为`true`时，浏览器将提供它能够提供的最准确的位置，即使这样做需要更多的时间（例如，锁定额外的GPS卫星）。在之前的例子中，我们没有使用选项参数，出于效率原因，高精度并未启用。
- en: We can also give the browser a time limit for the location lookup using the
    `timeout` option. This option is set in milliseconds. Because there are 1000 milliseconds
    in 1 second, the example shows a 5-second timeout.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`timeout`选项为位置查找设置一个时间限制。此选项以毫秒为单位设置。因为1秒钟有1000毫秒，所以示例显示了5秒的超时。
- en: The final option, `maximumAge`, provides the browser with instructions for sending
    cached locations. Depending on your needs, you may want a very recent location,
    or you may not care as much. Like the timeout, this value is passed in milliseconds.
    In this example, I've shown a `maximumAge` of 60,000 milliseconds, or 1 minute.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项，`maximumAge`，为浏览器提供了发送缓存位置的指令。根据您的需求，您可能需要一个非常近的位置，或者您可能不太关心。就像超时一样，这个值以毫秒为单位传递。在这个例子中，我展示了`maximumAge`为60,000毫秒，即1分钟。
- en: The options object can be passed as the third argument to either `getCurrentPosition`
    or `watchPosition`. If you use the latter requesting continual updates, the options
    will be followed *every* time the browser returns a location.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 选项对象可以作为第三个参数传递给`getCurrentPosition`或`watchPosition`。如果您使用后者请求持续更新，则每次浏览器返回位置时都会跟随这些选项。
- en: '#49: Use Fire Eagle to Get Location'
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#49：使用Fire Eagle获取位置'
- en: You can retrieve your user's location in several ways, some of them with very
    precise output. Many services that ask and store a user's current whereabouts
    are also available. Fire Eagle, a product from Yahoo!, is a broker for those services.
    When you write a Fire Eagle application, you can set or receive the user's current
    location, which then makes it available to all other Fire Eagle applications,
    as long as the user gives permission.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过多种方式检索用户的位置，其中一些方式可以提供非常精确的输出。许多询问并存储用户当前位置的服务也都可以使用。雅虎的Fire Eagle就是这些服务的经纪人。当您编写Fire
    Eagle应用程序时，您可以设置或接收用户的当前位置，只要用户给予权限，这个位置信息就会对所有其他Fire Eagle应用程序可用。
- en: In this project, I'll show how you can gain access to your user's location using
    Fire Eagle. And once a user has approved your application for access, you'll be
    able to get the user's latest location at any time, even when he or she isn't
    online.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我将展示如何使用Fire Eagle获取用户的位置。一旦用户批准了您的应用程序访问权限，您将能够随时获取用户的最新位置，即使他或她不在线。
- en: Of course, some application has to set the location for it to be accurate. Remember
    all those sites I mentioned that help users share their location? We'll let them
    worry about setting the location in Fire Eagle, so let's dive into using Fire
    Eagle to retrieve a location. The application we write will use PHP, which I cover
    in more depth in [Chapter 9](ch09.html "Chapter 9. GO SERVER-SIDE").
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，某些应用程序必须设置位置才能准确。还记得我提到的那些帮助用户分享位置网站吗？我们将让他们在Fire Eagle中设置位置，让我们深入探讨如何使用Fire
    Eagle来检索位置。我们编写的应用程序将使用PHP，我在第9章（[第9章](ch09.html "第9章。GO SERVER-SIDE")）中对其进行了更深入的介绍。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are many other services for sharing location. By the time you read this,
    there are probably more. See a list and links to tutorials at [http://mapscripting.com/location-apis](http://mapscripting.com/location-apis).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他用于分享位置的服务。当您阅读此内容时，可能还有更多。请参阅[http://mapscripting.com/location-apis](http://mapscripting.com/location-apis)中的列表和教程链接。
- en: Get the Fire Eagle Essentials
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取Fire Eagle基础知识
- en: Yahoo! has some tools that make writing Fire Eagle applications much easier.
    Before you can use them, you'll want to register your application with Fire Eagle,
    so you get the codes that will make your program work. One is an API key, much
    like other services use; the other is a "secret code." If it helps, you can think
    of it as joining a secret club. Really, you're just filling out a form.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 雅虎有一些工具可以使编写Fire Eagle应用程序变得容易得多。在您可以使用它们之前，您需要将应用程序注册到Fire Eagle，这样您就可以获得使程序工作的代码。一个是API密钥，类似于其他服务使用的；另一个是“秘密代码”。如果您觉得有帮助，您可以将其视为加入一个秘密俱乐部。实际上，您只是在填写一个表格。
- en: 'You''ll need a Yahoo! account. Once you have that, head over to this page to
    register your app: [https://fireeagle.yahoo.net/developer/create](https://fireeagle.yahoo.net/developer/create).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个雅虎账户。一旦您有了它，请转到此页面以注册您的应用程序：[https://fireeagle.yahoo.net/developer/create](https://fireeagle.yahoo.net/developer/create)。
- en: Don't worry about being perfect. You can edit this application later. Plus,
    Fire Eagle lets you register multiple applications, so let this one be a dress
    rehearsal for the one you'll write later.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心完美。您稍后可以编辑此应用程序。此外，Fire Eagle允许您注册多个应用程序，所以让这个成为您稍后编写的应用程序的彩排。
- en: Fire Eagle has two important settings to pay attention to as you create your
    application. First, you're going to use **Auth for Web-based Services** for authentication.
    Next, you'll need to set a callback URL. The URL can be named anything you want,
    but for this simple example, let's use **`callback.php`**. Fire Eagle wants to
    know a full URL, so you'll insert something like [http://yoursite.com/fireeagle/callback.php](http://yoursite.com/fireeagle/callback.php).
    For testing purposes, you can even use your local machine instead of your server.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建您的应用程序时，Fire Eagle有两个重要的设置需要注意。首先，您将使用**基于Web服务的认证**进行身份验证。接下来，您需要设置一个回调URL。URL可以命名为您想要的任何名称，但在这个简单的示例中，让我们使用**`callback.php`**。Fire
    Eagle需要知道一个完整的URL，所以您将插入类似[http://yoursite.com/fireeagle/callback.php](http://yoursite.com/fireeagle/callback.php)的内容。出于测试目的，您甚至可以使用您的本地机器而不是服务器。
- en: 'Once you register your application, Fire Eagle will show you some special keys,
    the API, and the secret code I mentioned earlier. You can get back to them any
    time by visiting this page: [http://fireeagle.yahoo.net/developer/manage](http://fireeagle.yahoo.net/developer/manage).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您注册了您的应用程序，Fire Eagle将向您展示一些特殊的密钥，API以及我之前提到的秘密代码。您可以通过访问此页面随时返回它们：[http://fireeagle.yahoo.net/developer/manage](http://fireeagle.yahoo.net/developer/manage)。
- en: 'One last thing before you can leave the site for a little while: You need the
    API kit. Fire Eagle has prepackaged code for various web programming languages
    that makes coding applications much easier. Download the PHP kit from this page:
    [http://fireeagle.yahoo.net/developer/code/php](http://fireeagle.yahoo.net/developer/code/php).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在您离开网站一段时间之前，还有最后一件事：您需要API工具包。Fire Eagle为各种网络编程语言提供了预包装的代码，这使得编写应用程序变得容易得多。从以下页面下载PHP工具包：[http://fireeagle.yahoo.net/developer/code/php](http://fireeagle.yahoo.net/developer/code/php)。
- en: 'You absolutely need two files from this package: *fireeagle.php* and *OAuth.php*.
    Store these inside a directory called *lib* (which stands for library) because
    we''ll be accessing them soon.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您绝对需要从这个包中获取两个文件：*fireeagle.php* 和 *OAuth.php*。将这些文件存储在名为 *lib*（代表库）的目录中，因为我们很快就会访问它们。
- en: Authenticate the User
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证用户
- en: As the name of one of these files suggests, Fire Eagle uses OAuth to authenticate
    users. If you haven't used OAuth before, it might seem a little strange, but I've
    come to appreciate its simplicity and security.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其中一个文件的名字所暗示的，Fire Eagle使用OAuth来验证用户。如果您之前没有使用过OAuth，它可能看起来有点奇怪，但我已经学会了欣赏它的简单性和安全性。
- en: 'The process to authenticate a user begins by requesting a *token* from Fire
    Eagle. This token actually comes in two pieces: *public* and *private*. We redirect
    the user to Fire Eagle, along with the public token. Then, when the user approves
    us for access, we can use the public and private tokens together to prove to Fire
    Eagle that we''re the approved application.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 验证用户的过程是从向Fire Eagle请求一个 *令牌* 开始的。这个令牌实际上由两部分组成：*公开* 和 *私有*。我们将用户和公开令牌一起重定向到Fire
    Eagle。然后，当用户批准我们访问时，我们可以使用公开和私有令牌一起向Fire Eagle证明我们是批准的应用程序。
- en: 'Let''s see how it looks in code. Create a new file called *authorize.php* and
    add the following lines:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码中的样子。创建一个名为 *authorize.php* 的新文件，并添加以下行：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To start, we use the key and secret code to create a new Fire Eagle object ❶.
    The key and secret code are different from the tokens I described. The key and
    secret code identify your application itself and will never change. The tokens
    are different for each user.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用密钥和密钥代码创建一个新的Fire Eagle对象❶。密钥和密钥代码与我所描述的令牌不同。密钥和密钥代码标识您的应用程序本身，并且永远不会改变。令牌对每个用户都是不同的。
- en: Using the Fire Eagle object we created, now we request the public and private
    tokens ❷. We store these as session variables, which is how PHP maintains data
    for a user from one page to the next. Then we create another session variable
    that tells us the user has not signed in yet ❸.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们创建的Fire Eagle对象，我们现在请求公开和私有令牌❷。我们将这些存储为会话变量，这是PHP在页面之间维护用户数据的方式。然后我们创建另一个会话变量，告诉我们用户尚未登录❸。
- en: Finally, using the public token, we redirect the user to a Fire Eagle URL ❹.
    This page is where the user will approve our application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用公开令牌，我们将用户重定向到Fire Eagle URL❹。这个页面是用户将批准我们的应用程序的地方。
- en: Answer the Call
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回应召唤
- en: Once the user agrees to give us access, Fire Eagle will redirect back to our
    callback URL. Remember that from the settings? When the user comes to this page,
    chances are pretty good he or she has authorized our application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户同意给我们访问权限，Fire Eagle将重定向回我们的回调URL。记住那些设置吗？当用户来到这个页面时，他或她很可能已经授权了我们的应用程序。
- en: The callback page is where the user will officially log in. How you set this
    up will vary depending on what type of application you are creating. For example,
    if users have accounts stored in a database, you might maintain their Fire Eagle
    tokens there. Here we will simply update the session variables.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 回调页面是用户正式登录的地方。您如何设置这取决于您正在创建的应用程序类型。例如，如果用户在数据库中存储了账户，您可能会在那里维护他们的Fire Eagle令牌。在这里，我们将简单地更新会话变量。
- en: 'Add the following code to your *callback.php* file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到您的 *callback.php* 文件中：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We create a Fire Eagle object ❶ again using the PHP kit that Yahoo! provided.
    This time we include the user's public and private tokens, in addition to our
    application's key and secret. Remember, this information proves we're the same
    application the user just approved.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用Yahoo!提供的PHP工具包创建一个Fire Eagle对象❶。这次我们包括了用户的公开和私有令牌，以及我们应用程序的密钥和密钥。记住，这些信息证明了我们是用户刚刚批准的同一应用程序。
- en: If all these keys and tokens are confusing, get ready. One more pair is coming.
    Once a user approves an application, the public and private tokens aren't needed.
    Instead, they're replaced by *access tokens* ❷. We overwrite our previous session
    variables with new ones. And because the user has now successfully signed in,
    we can set that session variable appropriately ❸.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些密钥和令牌都让人困惑，请做好准备。还有一对即将到来。一旦用户批准了一个应用程序，就不需要公共和私有令牌了。相反，它们被*访问令牌*❷所取代。我们用新的会话变量覆盖之前的会话变量。而且因为用户现在已经成功登录，我们可以适当地设置那个会话变量❸。
- en: This process may seem like a long one to follow to access a user's location,
    but keep in mind it only needs to happen once. And the steps are all required
    in the name of security, which users appreciate. Plus, this callback page will
    appear instantly to the user.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可能看起来很繁琐，需要遵循以访问用户的位置，但请记住，这只需要发生一次。而且，所有这些步骤都是为了安全起见，这是用户所欣赏的。此外，这个回调页面将立即显示给用户。
- en: The final line redirects the user to the page we'll use to retrieve his or her
    location ❹. That's what this whole thing is really about, after all. So let's
    get down to it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行将用户重定向到我们将用于检索其位置的页面❹。毕竟，这就是整个事情的核心所在。所以，让我们开始吧。
- en: Get the User's Location
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取用户的位置
- en: The user has given us access to his or her location. We can even check the session
    variable that we set to make sure. Now we're going to retrieve the user's location.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 用户已经给了我们访问其位置的权利。我们甚至可以检查我们设置的会话变量来确保。现在，我们将检索用户的位置。
- en: 'Add the following code to the *getloc.php* file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到*getloc.php*文件中：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code starts much like other pages have, by including the PHP API kit and
    declaring our application's key and secret code. Then we check our session variable
    to make sure the user really has given us permission ❶. If the signed-in variable
    is still 0, we could redirect to the authentication page, or show an error.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的起始部分与其他页面类似，包括PHP API套件并声明我们的应用程序密钥和秘密代码。然后我们检查我们的会话变量以确保用户确实已经给了我们许可❶。如果已登录变量仍然是0，我们可以重定向到认证页面，或者显示错误。
- en: As in the previous section, we create a Fire Eagle object using the application
    keys and the access tokens. Because we're pretty sure we can access the user's
    location at this point, we then ask Fire Eagle for the location object ❷. From
    there, we can retrieve its best guess for the user's location ❸, the most granular
    level of data the user is willing to share.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一节一样，我们使用应用程序密钥和访问令牌创建一个Fire Eagle对象。因为我们相当确信我们现在可以访问用户的位置，所以我们向Fire Eagle请求位置对象❷。从那里，我们可以获取其对用户位置的最好猜测❸，这是用户愿意分享的最细粒度数据。
- en: Now we have access to several pieces of data, including the latitude ❹ and longitude.
    We can also get an idea of how long ago the user shared that location ❺. To improve
    legibility, I used the PHP `date` function to format the time stamp.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以访问包括纬度❹和经度在内的几份数据。我们还可以了解用户分享该位置的时间有多久了❺。为了提高可读性，我使用了PHP `date`函数来格式化时间戳。
- en: Finally, in the HTML, we output the data ❻ we retrieved from Fire Eagle. Of
    course, this is just an example, not a great Fire Eagle application. The great
    one is the one you'll write. Right?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在HTML中，我们输出从Fire Eagle检索到的数据❻。当然，这只是一个例子，不是一个伟大的Fire Eagle应用程序。真正伟大的是您将编写的那个。对吧？
- en: '#50: Get Location by IP'
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#50：通过IP获取位置'
- en: All users on the Internet can be identified with a number that stays the same
    for at least a single online session and can be static—never changing. This number,
    called an *IP address*, is owned by the Internet provider, who usually has an
    entire block (or more) of similar numbers. With a database of these numbers tied
    to locations, you can usually determine at least the city your user is located
    in, if not the postal code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上的所有用户都可以用一个在至少一个在线会话中保持不变的数字来识别，这个数字是静态的——永远不会改变。这个数字，称为*IP地址*，属于互联网服务提供商，他们通常拥有一个（或更多）类似的数字块。通过将这些数字与位置相关的数据库绑定，您通常可以确定用户所在的城市，如果不是邮政编码的话。
- en: I'll demonstrate other projects in this chapter that get at more granular data,
    determining a user's precise location. But knowing a geographic area is generally
    enough to do some interesting things. Plus, you can geolocate most of your users
    by using IPs, and you don't have to ask their permission.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章演示其他项目，这些项目可以获取更细粒度的数据，确定用户的精确位置。但了解一个地理区域通常就足够做一些有趣的事情。此外，您可以通过使用IP地址来定位大多数用户，而且您不必请求他们的许可。
- en: What is an IP address? An IP address is a series of four numbers, each from
    one to three digits. For example, it might be *208.54.34.3*. Each computer connected
    to the Internet has its own IP address, though sometimes an address is shared
    across a local area network.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是IP地址？IP地址是一系列四个数字，每个数字从一到三位。例如，它可能是 *208.54.34.3*。每个连接到互联网的计算机都有自己的IP地址，尽管有时一个地址会在局域网中共享。
- en: For this project, we'll look at two services that provide geographic coordinates
    based on the user's IP address. One must be used on the server, whereas the other
    runs in the browser using JavaScript. Which you choose depends on how you want
    to use the data. For example, if you store the result to a database, you will
    likely want the server-side version. But if you just want to center your map on
    the user's location, the JavaScript version will do just fine.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将查看两个基于用户IP地址提供地理坐标的服务。一个必须在服务器上使用，而另一个则通过JavaScript在浏览器中运行。你选择哪个取决于你如何使用这些数据。例如，如果你将结果存储到数据库中，你可能会想要使用服务器端版本。但如果你只是想将地图中心定位在用户的位置，JavaScript版本就足够了。
- en: Use the HostIP Web Service
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HostIP网络服务
- en: For this example, I'll use the hostip.info API. A number of web services provide
    IP-based geolocation, including a commercial service called MaxMind. I picked
    HostIP, however, because it is easy to use, and the database is maintained by
    a community of developers and users.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我将使用hostip.info API。许多网络服务提供基于IP的地理位置服务，包括一个名为MaxMind的商业服务。然而，我选择了HostIP，因为它易于使用，并且数据库由一群开发者和用户维护。
- en: We'll be using PHP to call the API, including some concepts described in [Chapter 8](ch08.html
    "Chapter 8. DATA FORMATS") and [Chapter 9](ch09.html "Chapter 9. GO SERVER-SIDE").
    I'll do my best to make understanding them easy, but you may want to flip ahead
    if something looks strange.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用PHP调用API，包括在第8章（[Chapter 8](ch08.html "Chapter 8. DATA FORMATS")）和第9章（[Chapter 9](ch09.html
    "Chapter 9. GO SERVER-SIDE")）中描述的一些概念。我会尽力使它们易于理解，但如果你发现某些内容看起来很奇怪，你可能需要提前翻阅。
- en: 'Before we can start our PHP code, we need to get a feel for how we are going
    to get the data back from HostIP. Luckily, the site makes trying out the API within
    your browser easy. Try loading this URL into your address bar: [http://api.hostip.info/?ip=12.215.42.19](http://api.hostip.info/?ip=12.215.42.19).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写PHP代码之前，我们需要了解如何从HostIP获取数据。幸运的是，该网站使得在浏览器中尝试API变得非常简单。尝试将以下URL加载到地址栏中：[http://api.hostip.info/?ip=12.215.42.19](http://api.hostip.info/?ip=12.215.42.19)。
- en: 'Your results should look something like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果应该看起来像这样：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Right in the middle of it all, shown in bold, are the latitude and longitude
    coordinates we want (note that here longitude comes first). Getting at those numbers
    means parsing the result and extracting the numbers. This process is shown in
    detail in [#52: Use XML](ch08.html#number_symble_52_colon_use_xml "#52: Use XML")
    in [#52: Use XML](ch08.html#number_symble_52_colon_use_xml "#52: Use XML"). Let''s
    put the latitude and longitude into two variables using PHP. Create a new file
    and add the following lines of code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '在所有这些中间，以粗体显示的是我们想要的纬度和经度坐标（注意在这里经度在前）。获取这些数字意味着解析结果并提取数字。这个过程在 [#52: 使用XML](ch08.html#number_symble_52_colon_use_xml
    "#52: Use XML") 中有详细说明。让我们使用PHP将纬度和经度放入两个变量中。创建一个新文件并添加以下代码行：'
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Before we can make a call to HostIP, we need to determine the user's IP. Luckily,
    the IP is made available to PHP via a server variable, which we place into a local
    variable ❶.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够调用HostIP之前，我们需要确定用户的IP。幸运的是，IP通过服务器变量提供给PHP，我们将它放入一个局部变量中 ❶。
- en: The rest of the code is relatively spartan, despite all that it does, mainly
    because it counts on other functions to do the heavy lifting. For example, we
    load the XML text in a one-line call ❷, passing the HostIP URL, which includes
    the user's IP address. To turn the text into an object we can use, we call the
    `SimpleXML` parsing function ❸ that converts the XML. Now that we have an easy-to-access
    object, we use the `xpath` function to return all `<coordinates>` tags ❹. We only
    have one, so we then pass it off to a string-splitting function to insert it into
    our two variables ❺.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码做了很多工作，但其余代码相对简洁，主要是因为它依赖于其他函数来完成繁重的工作。例如，我们通过一行调用加载XML文本 ❷，传递包含用户IP地址的HostIP
    URL。为了将文本转换为可用的对象，我们调用`SimpleXML`解析函数 ❸，该函数将XML转换为对象。现在我们有一个易于访问的对象，我们使用`xpath`函数返回所有`<coordinates>`标签
    ❹。我们只有一个，所以我们将其传递给字符串分割函数，将其插入到我们的两个变量中 ❺。
- en: 'Most of these functions rely on internal PHP, but one of them ❻ I wrote myself.
    You can see this entire function in [#61: Retrieve a Web Page](ch09s03.html "#61:
    Retrieve a Web Page") in [#61: Retrieve a Web Page](ch09s03.html "#61: Retrieve
    a Web Page").'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '这些函数中的大多数依赖于内部 PHP，但其中之一 ❻ 是我自己编写的。你可以在 [#61: 获取网页](ch09s03.html "#61: 获取网页")
    中找到这个函数的完整内容。'
- en: Use Google's ClientLocation JavaScript Object
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Google 的 ClientLocation JavaScript 对象
- en: If you don't need the user's location on the server, you can easily get it if
    you use Google's Ajax Loader. This is an alternate way to load Google's JavaScript
    APIs, including Maps and Search. The `ClientLocation` object is available even
    without loading a specific API, which makes for minimal overhead considering the
    data it provides.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要在服务器上获取用户的地理位置，如果你使用 Google 的 Ajax Loader，你可以轻松地获取它。这是加载 Google 的 JavaScript
    API 的另一种方式，包括 Maps 和 Search。即使没有加载特定的 API，`ClientLocation` 对象也是可用的，考虑到它提供的数据，这可以最小化开销。
- en: 'As with the standard Google Maps API, you need to include the call to Google''s
    JavaScript within the header of your HTML file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准的 Google Maps API 一样，你需要在 HTML 文件的头部包含对 Google 的 JavaScript 的调用：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, anywhere within your JavaScript code, you can access `google.loader.ClientLocation.latitude`
    and `google.loader.ClientLocation.longitude` (in addition to a few other data
    items, such as the city name).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的 JavaScript 代码中的任何地方，你都可以访问 `google.loader.ClientLocation.latitude` 和
    `google.loader.ClientLocation.longitude`（以及一些其他数据项，如城市名称）。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At press time the Ajax Loader only supports Google Maps version 2\. To use this
    example, you will need a Google Maps API key. You can find that, as well as updated
    information about the Ajax Loader at [http://code.google.com/apis/ajax/documentation/](http://code.google.com/apis/ajax/documentation/).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在出版时，Ajax Loader 只支持 Google Maps 版本 2。要使用此示例，你需要一个 Google Maps API 密钥。你可以在 [http://code.google.com/apis/ajax/documentation/](http://code.google.com/apis/ajax/documentation/)
    找到它，以及有关 Ajax Loader 的更新信息。
- en: 'Seeing it on a map is always easier, so let''s create a new Mapstraction map
    using Google as the mapping provider. Instead of the standard Google Maps, we''ll
    use the Ajax loader. Add the following code to a new HTML file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图上看到它总是更容易，所以让我们创建一个新的 Mapstraction 地图，使用 Google 作为映射提供者。我们将使用 Ajax loader
    而不是标准的 Google Maps。将以下代码添加到一个新的 HTML 文件中：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The JavaScript's very first line tells the Google Ajax Loader to load in the
    Maps API ❶. Then, once it—and the rest of the page—has loaded, the `create_map`
    function gets called.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的第一行代码告诉 Google Ajax Loader 加载 Maps API ❶。然后，一旦它以及页面的其余部分加载完成，就会调用
    `create_map` 函数。
- en: To access the location, we copy the `ClientLocation` object into a local variable
    ❷, making accessing it easier. Then we create a point ❸ using the latitude and
    longitude from the new object. From there, the code is much like previous JavaScript
    examples, where we use this point as the center of the map and create a marker.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问位置，我们将 `ClientLocation` 对象复制到一个局部变量 ❷ 中，这使得访问它更加容易。然后我们使用新对象中的纬度和经度创建一个点
    ❸。从那里开始，代码与之前的 JavaScript 示例非常相似，我们使用这个点作为地图的中心并创建一个标记。
- en: '#51: Roll Your Own IP Database'
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#51: 创建自己的 IP 数据库'
- en: Are you the type who would refuse help if you took a spill in a public place?
    Then you're probably also the type who wants to host your *own* IP database, rather
    than depend on someone else's service. Of course, you might simply be someone
    who cares about performance or doesn't want to worry about network latency. Whatever
    the case, this project will help you geolocate users by IP using your own server.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在公共场所摔倒，你会拒绝帮助吗？那么你可能也是那种想要托管自己的 *IP* 数据库，而不是依赖他人服务的人。当然，你可能只是那种关心性能或不想担心网络延迟的人。无论哪种情况，这个项目将帮助你通过自己的服务器使用
    IP 定位用户。
- en: Where does the data come from? We'll use a free service called IPInfoDB, which
    updates a streamlined MySQL database dump every month. Download the latest database
    at [http://ipinfodb.com/ip_database.php](http://ipinfodb.com/ip_database.php).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 数据从哪里来？我们将使用一个名为 IPInfoDB 的免费服务，该服务每月更新一个精简的 MySQL 数据库转储。在 [http://ipinfodb.com/ip_database.php](http://ipinfodb.com/ip_database.php)
    下载最新的数据库。
- en: You have a number of choices for database types. For this example, we'll use
    the small, city-level database with a single table. The table should contain about
    1.4 million records, which will result in a database file a little over 100MB.
    (The file will be much smaller when you download the compressed version.)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你有几种数据库类型可供选择。在这个例子中，我们将使用包含单个表的较小、城市级别的数据库。该表应包含大约 140 万条记录，这将导致数据库文件略大于 100MB。（当你下载压缩版本时，文件将小得多。）
- en: Import IP Data
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入 IP 数据
- en: Now that you have downloaded the SQL file, you need to import it. The file will
    be far too big to use phpMyAdmin, so you will need to use the command interpreter,
    which you can usually get to via the `mysql` command on a server.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经下载了 SQL 文件，你需要导入它。这个文件太大，无法使用 phpMyAdmin，所以你需要使用命令解释器，你通常可以通过服务器上的 `mysql`
    命令访问它。
- en: 'You may be able to ask your system administrator to help you get to your MySQL
    database''s command interpreter. Or, if you are using MAMP, you can run `Library/bin/mysql
    -u root -p` within the MAMP directory (the password is also `root`). On WAMP,
    the location may vary, but it can commonly be found at `C:\wamp\bin\mysql\mysql`*version*`\bin\mysql`.
    In either case, you will need to access the interpreter via the command line:
    Terminal (on Mac) or CMD (on Windows).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能可以向你的系统管理员寻求帮助，以便访问你的 MySQL 数据库的命令解释器。或者，如果你使用的是 MAMP，你可以在 MAMP 目录中运行 `Library/bin/mysql
    -u root -p`（密码也是 `root`）。在 WAMP 上，位置可能有所不同，但通常可以在 `C:\wamp\bin\mysql\mysql`*版本*`\bin\mysql`
    找到。在两种情况下，你都需要通过命令行：终端（在 Mac 上）或 CMD（在 Windows 上）来访问解释器。
- en: 'Open the command interpreter and select your database, or create a new one
    (see [#63: Store Locations to a Database](ch09s05.html "#63: Store Locations to
    a Database") in [Install MySQL Yourself](ch09s04.html#install_mysql_yourself "Install
    MySQL Yourself")). To begin the process of importing your data, type the following
    command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '打开命令解释器并选择你的数据库，或者创建一个新的数据库（参见 [第 63 节：将位置存储到数据库中](ch09s05.html "#63: Store
    Locations to a Database") 在 [自己安装 MySQL](ch09s04.html#install_mysql_yourself "自己安装
    MySQL")）。要开始导入数据的过程，请输入以下命令：'
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Make sure you include the full path to the SQL file you downloaded. As it imports,
    you''ll see messages like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 确保包含你下载的 SQL 文件的完整路径。在导入过程中，你会看到类似这样的消息：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the messages end, you can leave the command interpreter and return to phpMyAdmin,
    if you wish. Now that we've added the data, let's access it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息结束时，你可以离开命令解释器并返回 phpMyAdmin，如果你愿意的话。现在我们已经添加了数据，让我们来访问它。
- en: Find an IP's Location
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找 IP 的位置
- en: What information is available with the IP database, and how is it stored? From
    phpMyAdmin, click through to your database and then to the `ip_group_city` table
    that you've just imported. Click the Browse tab and you'll see the first 30 records
    in the database.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: IP 数据库中有什么信息可用，以及它是如何存储的？从 phpMyAdmin 点击到你的数据库，然后到你刚刚导入的 `ip_group_city` 表。点击浏览选项卡，你将看到数据库中的前
    30 条记录。
- en: Among the interesting fields available are city, latitude, and longitude. You'll
    also see the IP address itself, stored as a very large number, which is different
    than the period-separated version you're used to seeing. The difference is because
    you need to do a little preprocessing, which makes the lookup process much more
    efficient.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的有趣字段包括城市、纬度和经度。你还会看到存储为非常大的数字的 IP 地址本身，这与你习惯看到的点分隔版本不同。这种差异是因为你需要进行一些预处理，这使得查找过程更加高效。
- en: Where the IP is `A.B.C.D`, the number can be expressed as `((A*256+B)*256+C)*256`.
    So *71.59.208.255* would become *1195102208*. As would anything in the *71.59.208.X*
    block. Notice the formula does not have a D; that's because IPs come in blocks,
    so everything in the range will likely have the same location.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当 IP 地址为 `A.B.C.D` 时，该数字可以表示为 `((A*256+B)*256+C)*256`。所以 *71.59.208.255* 会变成
    *1195102208*。同样，*71.59.208.X* 块中的任何内容也会如此。注意公式中没有 D；这是因为 IP 地址以块的形式出现，所以该范围内的所有内容可能具有相同的地理位置。
- en: 'This process of converting an IP to a number is fairly standardized. In fact,
    MySQL has a helper function, `INET_ATON`, which makes it super easy. Click the
    SQL tab in phpMyAdmin, or use the command interpreter, and add the following query:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将 IP 转换为数字的过程相当标准化。实际上，MySQL 有一个辅助函数，`INET_ATON`，这使得它变得非常简单。在 phpMyAdmin 中点击
    SQL 选项卡，或者使用命令解释器，并添加以下查询：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Remember to replace the IP address I used with one of your own. Here, I've requested
    all the fields for the closest IP address in the database. In order to keep from
    getting all 1.4 million records back in order, I limit the results to one row—the
    one I want.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将我使用的 IP 地址替换为你自己的。在这里，我请求了数据库中最近 IP 地址的所有字段。为了防止返回所有 1.4 百万条记录，我限制结果只返回一行——就是我想要的。
- en: 'Now we''ll connect it to a PHP script, something covered in [#65: Use MySQL
    from PHP](ch09s07.html "#65: Use MySQL from PHP") in [#65: Use MySQL from PHP](ch09s07.html
    "#65: Use MySQL from PHP").'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们将把它连接到一个 PHP 脚本，这在 [第 65 节：从 PHP 使用 MySQL](ch09s07.html "#65: 从 PHP 使用
    MySQL") 中有介绍。'
