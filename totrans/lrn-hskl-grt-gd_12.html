<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Monoids"><div class="titlepage"><div><div><h1 class="title"><a id="monoids"/>Chapter 12. Monoids</h1></div></div></div><p>This chapter features another useful and fun type class: <code class="literal">Monoid</code>. This type class is for types whose values can be combined together with a binary operation. We’ll cover exactly what monoids are and what their laws state. Then we’ll take a look at some monoids in Haskell and how they can be of use.<a id="IDX-CHP-12-0001" class="indexterm"/><a id="IDX-CHP-12-0002" class="indexterm"/><a id="IDX-CHP-12-0003" class="indexterm"/><a id="IDX-CHP-12-0004" class="indexterm"/><a id="IDX-CHP-12-0005" class="indexterm"/></p><p>First, let’s take a look at the <code class="literal">newtype</code> keyword, because we’ll be using it a lot when we delve into the wonderful world of monoids.</p><div class="sect1" title="Wrapping an Existing Type into a New Type"><div class="titlepage"><div><div><h1 class="title"><a id="wrapping_an_existing_type_into_a_new_typ"/>Wrapping an Existing Type into a New Type</h1></div></div></div><p>So far, you’ve learned how to make your own algebraic data types by using the <code class="literal">data</code> keyword. You’ve also seen how to give existing types synonyms with the <code class="literal">type</code> keyword. In this section, we’ll look at how to make new types out of existing data types by using the <code class="literal">newtype</code> keyword. We’ll also talk about why we would want to do that in the first place.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject12_d1e21741"/><img src="httpatomoreillycomsourcenostarchimages802658.png.jpg" alt="image with no caption"/></div></div><p>In <a class="xref" href="ch11.html" title="Chapter 11. Applicative Functors">Chapter 11</a>, you saw a couple of ways for the list type to be an applicative functor. One way is to have <code class="literal">&lt;*&gt;</code> take every function out of the list that is its left parameter and apply that to every value in the list that is on the right, resulting in every possible combination of applying a function from the left list to a value in the right list:<a id="IDX-CHP-12-0006" class="indexterm"/><a id="IDX-CHP-12-0007" class="indexterm"/><a id="IDX-CHP-12-0008" class="indexterm"/><a id="IDX-CHP-12-0009" class="indexterm"/></p><a id="I_programlisting12_d1e21771"/><pre class="programlisting">ghci&gt; [(+1),(*100),(*5)] &lt;*&gt; [1,2,3]
[2,3,4,100,200,300,5,10,15]</pre><p>The second way is to take the first function on the left side of <code class="literal">&lt;*&gt;</code> and apply it to the first value on the right, then take the second function from the list on the left side and apply it to the second value on the right, and so on. Ultimately, it’s kind of like zipping the two lists together.</p><p>But lists are already an instance of <code class="literal">Applicative</code>, so how do we also make lists an instance of <code class="literal">Applicative</code> in this second way? As you learned, the <code class="literal">ZipList a</code> type was introduced for this reason. This type has one value constructor, <code class="literal">ZipList</code>, which has just one field. We put the list that we’re wrapping in that field. Then <code class="literal">ZipList</code> is made an instance of <code class="literal">Applicative</code>, so that when we want to use lists as applicatives in the zipping manner, we just wrap them with the <code class="literal">ZipList</code> constructor. Once we’re finished, we unwrap them with <code class="literal">getZipList</code>:</p><a id="I_programlisting12_d1e21805"/><pre class="programlisting">ghci&gt; getZipList $ ZipList [(+1),(*100),(*5)] &lt;*&gt; ZipList [1,2,3] $
[2,200,15]</pre><p>So, what does this have to do with this <code class="literal">newtype</code> keyword? Well, think about how we might write the data declaration for our <code class="literal">ZipList a</code> type. Here’s one way:</p><a id="I_programlisting12_d1e21815"/><pre class="programlisting">data ZipList a = ZipList [a]</pre><p>This is a type that has just one value constructor, and that value constructor has just one field that is a list of things. We might also want to use record syntax so that we automatically get a function that extracts a list from a <code class="literal">ZipList</code>:</p><a id="I_programlisting12_d1e21823"/><pre class="programlisting">data ZipList a = ZipList { getZipList :: [a] }</pre><p>This looks fine and would actually work pretty well. We had two ways of making an existing type an instance of a type class, so we used the <code class="literal">data</code> keyword to just wrap that type into another type and made the other type an instance in the second way.</p><p>The <code class="literal">newtype</code> keyword in Haskell is made exactly for cases when we want to just take one type and wrap it in something to present it as another type. In the actual libraries, <code class="literal">ZipList a</code> is defined like this:</p><a id="I_programlisting12_d1e21838"/><pre class="programlisting">newtype ZipList a = ZipList { getZipList :: [a] }</pre><p>Instead of the <code class="literal">data</code> keyword, the <code class="literal">newtype</code> keyword is used. Now why is that? Well for one, <code class="literal">newtype</code> is faster. If you use the <code class="literal">data</code> keyword to wrap a type, there’s some overhead to all that wrapping and unwrapping when your program is running. But if you use <code class="literal">newtype</code>, Haskell knows that you’re just using it to wrap an existing type into a new type (hence the name), because you want it to be the same internally but have a different type. With that in mind, Haskell can get rid of the wrapping and unwrapping once it resolves which value is of which type.<a id="IDX-CHP-12-0010" class="indexterm"/><a id="IDX-CHP-12-0011" class="indexterm"/></p><p>So why not just use <code class="literal">newtype</code> instead of <code class="literal">data</code> all the time? When you make a new type from an existing type by using the <code class="literal">newtype</code> keyword, you can have only one value constructor, and that value constructor can have only one field. But with <code class="literal">data</code>, you can make data types that have several value constructors, and each constructor can have zero or more fields:</p><a id="I_programlisting12_d1e21878"/><pre class="programlisting">data Profession = Fighter | Archer | Accountant

data Race = Human | Elf | Orc | Goblin

data PlayerCharacter = PlayerCharacter Race Profession</pre><p>We can also use the <code class="literal">deriving</code> keyword with <code class="literal">newtype</code> just as we would with <code class="literal">data</code>. We can derive instances for <code class="literal">Eq</code>, <code class="literal">Ord</code>, <code class="literal">Enum</code>, <code class="literal">Bounded</code>, <code class="literal">Show</code>, and <code class="literal">Read</code>. If we derive the instance for a type class, the type that we’re wrapping must already be in that type class. It makes sense, because <code class="literal">newtype</code> just wraps an existing type. So now if we do the following, we can print and equate values of our new type:</p><a id="I_programlisting12_d1e21913"/><pre class="programlisting">newtype CharList = CharList { getCharList :: [Char] } deriving (Eq, Show)</pre><p>Let’s give that a go:</p><a id="I_programlisting12_d1e21917"/><pre class="programlisting">ghci&gt; CharList "this will be shown!"
CharList {getCharList = "this will be shown!"}
ghci&gt; CharList "benny" == CharList "benny"
True
ghci&gt; CharList "benny" == CharList "oisters"
False</pre><p>In this particular <code class="literal">newtype</code>, the value constructor has the following type:</p><a id="I_programlisting12_d1e21925"/><pre class="programlisting">CharList :: [Char] -&gt; CharList</pre><p>It takes a <code class="literal">[Char]</code> value, such as <code class="literal">"my sharona"</code> and returns a <code class="literal">CharList</code> value. From the preceding examples where we used the <code class="literal">CharList</code> value constructor, we see that really is the case. Conversely, the <code class="literal">getCharList</code> function, which was generated for us because we used record syntax in our <code class="literal">newtype</code>, has this type:</p><a id="I_programlisting12_d1e21948"/><pre class="programlisting">getCharList :: CharList -&gt; [Char]</pre><p>It takes a <code class="literal">CharList</code> value and converts it to a <code class="literal">[Char]</code> value. You can think of this as wrapping and unwrapping, but you can also think of it as converting values from one type to the other.<a id="IDX-CHP-12-0012" class="indexterm"/><a id="IDX-CHP-12-0013" class="indexterm"/><a id="IDX-CHP-12-0014" class="indexterm"/></p><div class="sect2" title="Using newtype to Make Type Class Instances"><div class="titlepage"><div><div><h2 class="title"><a id="using_newtype_to_make_type_class_instanc"/>Using newtype to Make Type Class Instances</h2></div></div></div><p>Many times, we want to make our types instances of certain type classes, but the type parameters just don’t match up for what we want to do. It’s easy to make <code class="literal">Maybe</code> an instance of <code class="literal">Functor</code>, because the <code class="literal">Functor</code> type class is defined like this:</p><a id="I_programlisting12_d1e21985"/><pre class="programlisting">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</pre><p>So we just start out with this:</p><a id="I_programlisting12_d1e21989"/><pre class="programlisting">instance Functor Maybe where</pre><p>Then we implement <code class="literal">fmap</code>.</p><p>All the type parameters add up because <code class="literal">Maybe</code> takes the place of <code class="literal">f</code> in the definition of the <code class="literal">Functor</code> type class. Looking at <code class="literal">fmap</code> as if it worked on only <code class="literal">Maybe</code>, it ends up behaving like this:</p><a id="I_programlisting12_d1e22013"/><pre class="programlisting">fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</pre><p>Isn’t that just peachy? Now what if we wanted to make the tuple an instance of <code class="literal">Functor</code> in such a way that when we <code class="literal">fmap</code> a function over a tuple, it is applied to the first component of the tuple? That way, doing <code class="literal">fmap (+3) (1, 1)</code> would result in <code class="literal">(4, 1)</code>. It turns out that writing the instance for that is kind of hard. With <code class="literal">Maybe</code>, we just say <code class="literal">instance Functor Maybe where</code> because only type constructors that take exactly one parameter can be made an instance of <code class="literal">Functor</code>. But it seems like there’s no way to do something like that with <code class="literal">(a, b)</code> so that the type parameter <code class="literal">a</code> ends up being the one that changes when we use <code class="literal">fmap</code>. To get around this, we can <code class="literal">newtype</code> our tuple in such a way that the second type parameter represents the type of the first component in the tuple:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject12_d1e22052"/><img src="httpatomoreillycomsourcenostarchimages802660.png.jpg" alt="image with no caption"/></div></div><a id="I_programlisting12_d1e22057"/><pre class="programlisting">newtype Pair b a = Pair { getPair :: (a, b) }</pre><p>And now we can make it an instance of <code class="literal">Functor</code> so that the function is mapped over the first component:<a id="IDX-CHP-12-0015" class="indexterm"/><a id="IDX-CHP-12-0016" class="indexterm"/><a id="IDX-CHP-12-0017" class="indexterm"/><a id="IDX-CHP-12-0018" class="indexterm"/><a id="IDX-CHP-12-0019" class="indexterm"/><a id="IDX-CHP-12-0020" class="indexterm"/></p><a id="I_programlisting12_d1e22089"/><pre class="programlisting">instance Functor (Pair c) where
    fmap f (Pair (x, y)) = Pair (f x, y)</pre><p>As you can see, we can pattern match on types defined with <code class="literal">newtype</code>. We pattern match to get the underlying tuple, apply the function <code class="literal">f</code> to the first component in the tuple, and then use the <code class="literal">Pair</code> value constructor to convert the tuple back to our <code class="literal">Pair b a</code>. If we imagine what the type <code class="literal">fmap</code> would be if it worked only on our new pairs, it would look like this:</p><a id="I_programlisting12_d1e22108"/><pre class="programlisting">fmap :: (a -&gt; b) -&gt; Pair c a -&gt; Pair c b</pre><p>Again, we said <code class="literal">instance Functor (Pair c) where</code>, and so <code class="literal">Pair c</code> took the place of the <code class="literal">f</code> in the type class definition for <code class="literal">Functor</code>:</p><a id="I_programlisting12_d1e22124"/><pre class="programlisting">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</pre><p>Now if we convert a tuple into a <code class="literal">Pair b a</code>, we can use <code class="literal">fmap</code> over it, and the function will be mapped over the first component:</p><a id="I_programlisting12_d1e22134"/><pre class="programlisting">ghci&gt; getPair $ fmap (*100) (Pair (2, 3))
(200,3)
ghci&gt; getPair $ fmap reverse (Pair ("london calling", 3))
("gnillac nodnol",3)</pre></div><div class="sect2" title="On newtype Laziness"><div class="titlepage"><div><div><h2 class="title"><a id="on_newtype_laziness"/>On newtype Laziness</h2></div></div></div><p>The only thing that can be done with <code class="literal">newtype</code> is turning an existing type into a new type, so internally, Haskell can represent the values of types defined with <code class="literal">newtype</code> just like the original ones, while knowing that their types are now distinct. This means that not only is <code class="literal">newtype</code> usually faster than <code class="literal">data</code>, its pattern-matching mechanism is lazier. Let’s take a look at what this means.<a id="IDX-CHP-12-0021" class="indexterm"/></p><p>As you know, Haskell is lazy by default, which means that only when we try to actually print the results of our functions will any computation take place. Furthemore, only those computations that are necessary for our function to tell us the result will be carried out. The <code class="literal">undefined</code> value in Haskell represents an erroneous computation. If we try to evaluate it (that is, force Haskell to actually compute it) by printing it to the terminal, Haskell will throw a hissy fit (technically referred to as an exception):</p><a id="I_programlisting12_d1e22161"/><pre class="programlisting">ghci&gt; undefined
*** Exception: Prelude.undefined</pre><p>However, if we make a list that has some <code class="literal">undefined</code> values in it but request only the head of the list, which is not <code class="literal">undefined</code>, everything will go smoothly. This is because Haskell doesn’t need to evaluate any other elements in a list if we want to see only the first element. Here’s an example:<a id="IDX-CHP-12-0022" class="indexterm"/><a id="IDX-CHP-12-0023" class="indexterm"/></p><a id="I_programlisting12_d1e22181"/><pre class="programlisting">ghci&gt; head [3,4,5,undefined,2,undefined]
3</pre><p>Now consider the following type:</p><a id="I_programlisting12_d1e22185"/><pre class="programlisting">data CoolBool = CoolBool { getCoolBool :: Bool }</pre><p>It’s your run-of-the-mill algebraic data type that was defined with the <code class="literal">data</code> keyword. It has one value constructor, which has one field whose type is <code class="literal">Bool</code>. Let’s make a function that pattern matches on a <code class="literal">CoolBool</code> and returns the value <code class="literal">"hello"</code>, regardless of whether the <code class="literal">Bool</code> inside the <code class="literal">CoolBool</code> was <code class="literal">True</code> or <code class="literal">False</code>:</p><a id="I_programlisting12_d1e22214"/><pre class="programlisting">helloMe :: CoolBool -&gt; String
helloMe (CoolBool _) = "hello"</pre><p>Instead of applying this function to a normal <code class="literal">CoolBool</code>, let’s throw it a curveball and apply it to <code class="literal">undefined</code>!</p><a id="I_programlisting12_d1e22225"/><pre class="programlisting">ghci&gt; helloMe undefined
"*** Exception: Prelude.undefined</pre><p>Yikes! An exception! Why did this exception happen? Types defined with the <code class="literal">data</code> keyword can have multiple value constructors (even though <code class="literal">CoolBool</code> has only one). So in order to see if the value given to our function conforms to the <code class="literal">(CoolBool _)</code> pattern, Haskell must evaluate the value just enough to see which value constructor was used when we made the value. And when we try to evaluate an <code class="literal">undefined</code> value, even a little, an exception is thrown.</p><p>Instead of using the <code class="literal">data</code> keyword for <code class="literal">CoolBool</code>, let’s try using <code class="literal">newtype</code>:</p><a id="I_programlisting12_d1e22252"/><pre class="programlisting">newtype CoolBool = CoolBool { getCoolBool :: Bool }</pre><p>We don’t need to change our <code class="literal">helloMe</code> function, because the pattern-matching syntax is the same whether you use <code class="literal">newtype</code> or <code class="literal">data</code> to define your type. Let’s do the same thing here and apply <code class="literal">helloMe</code> to an <code class="literal">undefined</code> value:</p><a id="I_programlisting12_d1e22271"/><pre class="programlisting">ghci&gt; helloMe undefined
"hello"</pre><p>It worked! Hmmm, why is that? Well, as you’ve learned, when you use <code class="literal">newtype</code>, Haskell can internally represent the values of the new type in the same way as the original values. It doesn’t need to add another box around them; it just must be aware of the values being of different types. And because Haskell knows that types made with the <code class="literal">newtype</code> keyword can have only one constructor, it doesn’t need to evaluate the value passed to the function to make sure that the value conforms to the <code class="literal">(CoolBool _)</code> pattern, because <code class="literal">newtype</code> types can have only one possible value constructor and one field!<a id="IDX-CHP-12-0024" class="indexterm"/><a id="IDX-CHP-12-0025" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject12_d1e22294"/><img src="httpatomoreillycomsourcenostarchimages802662.png.jpg" alt="image with no caption"/></div></div><p>This difference in behavior may seem trivial, but it’s actually pretty important. It shows that even though types defined with <code class="literal">data</code> and <code class="literal">newtype</code> behave similarly from the programmer’s point of view (because they both have value constructors and fields), they are actually two different mechanisms. Whereas <code class="literal">data</code> can be used to make your own types from scratch, <code class="literal">newtype</code> is just for making a completely new type out of an existing type. Pattern matching on <code class="literal">newtype</code> values isn’t like taking something out of a box (as it is with <code class="literal">data</code>), but more about making a direct conversion from one type to another.</p></div><div class="sect2" title="type vs. newtype vs. data"><div class="titlepage"><div><div><h2 class="title"><a id="type_vs._newtype_vs._data"/>type vs. newtype vs. data</h2></div></div></div><p>At this point, you may be a bit confused about the differences between <code class="literal">type</code>, <code class="literal">data</code>, and <code class="literal">newtype</code>, so let’s review their uses.</p><p>The <code class="literal">type</code> keyword is for making type synonyms. We just give another name to an already existing type so that the type is easier to refer to. Say we did the following:<a id="IDX-CHP-12-0026" class="indexterm"/></p><a id="I_programlisting12_d1e22342"/><pre class="programlisting">type IntList = [Int]</pre><p>All this does is allow us to refer to the <code class="literal">[Int]</code> type as <code class="literal">IntList</code>. They can be used interchangeably. We don’t get an <code class="literal">IntList</code> value constructor or anything like that. Because <code class="literal">[Int]</code> and <code class="literal">IntList</code> are only two ways to refer to the same type, it doesn’t matter which name we use in our type annotations:</p><a id="I_programlisting12_d1e22361"/><pre class="programlisting">ghci&gt; ([1,2,3] :: IntList) ++ ([1,2,3] :: [Int])
[1,2,3,1,2,3]</pre><p>We use type synonyms when we want to make our type signatures more descriptive. We give types names that tell us something about their purpose in the context of the functions where they’re being used. For instance, when we used an association list of type <code class="literal">[(String, String)]</code> to represent a phone book in <a class="xref" href="ch07.html" title="Chapter 7. Making Our Own Types and Type Classes">Chapter 7</a>, we gave it the type synonym of <code class="literal">PhoneBook</code> so that the type signatures of our functions were easier to read.</p><p>The <code class="literal">newtype</code> keyword is for taking existing types and wrapping them in new types, mostly so it’s easier to make them instances of certain type classes. When we use <code class="literal">newtype</code> to wrap an existing type, the type that we get is separate from the original type. Suppose we make the following <code class="literal">newtype</code>:</p><a id="I_programlisting12_d1e22384"/><pre class="programlisting">newtype CharList = CharList { getCharList :: [Char] }</pre><p>We can’t use <code class="literal">++</code> to put together a <code class="literal">CharList</code> and a list of type <code class="literal">[Char]</code>. We can’t even use <code class="literal">++</code> to put together two <code class="literal">CharList</code> lists, because <code class="literal">++</code> works only on lists, and the <code class="literal">CharList</code> type isn’t a list, even though it could be said that <code class="literal">CharList</code> contains a list. We can, however, convert two <code class="literal">CharList</code>s to lists, <code class="literal">++</code> them, and then convert that back to a <code class="literal">CharList</code>.<a id="IDX-CHP-12-0027" class="indexterm"/><a id="IDX-CHP-12-0028" class="indexterm"/><a id="IDX-CHP-12-0029" class="indexterm"/><a id="IDX-CHP-12-0030" class="indexterm"/><a id="IDX-CHP-12-0031" class="indexterm"/><a id="IDX-CHP-12-0032" class="indexterm"/><a id="IDX-CHP-12-0033" class="indexterm"/></p><p>When we use record syntax in our <code class="literal">newtype</code> declarations, we get functions for converting between the new type and the original type—namely the value constructor of our <code class="literal">newtype</code> and the function for extracting the value in its field. The new type also isn’t automatically made an instance of the type classes that the original type belongs to, so we need to derive or manually write it.</p><p>In practice, you can think of <code class="literal">newtype</code> declarations as <code class="literal">data</code> declarations that can have only one constructor and one field. If you catch yourself writing such a <code class="literal">data</code> declaration, consider using <code class="literal">newtype</code>.<a id="IDX-CHP-12-0034" class="indexterm"/></p><p>The <code class="literal">data</code> keyword is for making your own data types. You can go hog wild with them. They can have as many constructors and fields as you wish and can be used to implement any algebraic data type—everything from lists and <code class="literal">Maybe</code>-like types to trees.<a id="IDX-CHP-12-0035" class="indexterm"/></p><p>In summary, use the keywords as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If you just want your type signatures to look cleaner and be more descriptive, you probably want type synonyms.</p></li><li class="listitem"><p>If you want to take an existing type and wrap it in a new type in order to make it an instance of a type class, chances are you’re looking for a <code class="literal">newtype</code>.</p></li><li class="listitem"><p>If you want to make something completely new, odds are good that you’re looking for the <code class="literal">data</code> keyword.</p></li></ul></div></div></div></div>
<div class="sect1" title="About Those Monoids"><div class="titlepage"><div><div><h1 class="title"><a id="about_those_monoids"/>About Those Monoids</h1></div></div></div><p>Type classes in Haskell are used to present an interface for types that have some behavior in common. We started out with simple type classes like <code class="literal">Eq</code>, which is for types whose values can be equated, and <code class="literal">Ord</code>, which is for things that can be put in an order. Then we moved on to more interesting type classes, like <code class="literal">Functor</code> and <code class="literal">Applicative</code>.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject12_d1e22525"/><img src="httpatomoreillycomsourcenostarchimages802664.png.jpg" alt="image with no caption"/></div></div><p>When we make a type, we think about which behaviors it supports (what it can act like) and then decide which type classes to make it an instance of based on the behavior we want. If it makes sense for values of our type to be equated, we make our type an instance of the <code class="literal">Eq</code> type class. If we see that our type is some kind of functor, we make it an instance of <code class="literal">Functor</code>, and so on.</p><p>Now consider the following: <code class="literal">*</code> is a function that takes two numbers and multiplies them. If we multiply some number with a <code class="literal">1</code>, the result is always equal to that number. It doesn’t matter if we do <code class="literal">1 * x</code> or <code class="literal">x * 1</code>— the result is always <code class="literal">x</code>. Similarly, <code class="literal">++</code> is a function that takes two things and returns a third. But instead of multiplying numbers, it takes two lists and concatenates them. And much like <code class="literal">*</code>, it also has a certain value that doesn’t change the other one when used with <code class="literal">++</code>. That value is the empty list: <code class="literal">[]</code>.<a id="IDX-CHP-12-0036" class="indexterm"/><a id="IDX-CHP-12-0037" class="indexterm"/><a id="IDX-CHP-12-0038" class="indexterm"/></p><a id="I_programlisting12_d1e22581"/><pre class="programlisting">ghci&gt; 4 * 1
4
ghci&gt; 1 * 9
9
ghci&gt; [1,2,3] ++ []
[1,2,3]
ghci&gt; [] ++ [0.5, 2.5]
[0.5,2.5]</pre><p>It seems that <code class="literal">*</code> together with <code class="literal">1</code> and <code class="literal">++</code> along with <code class="literal">[]</code> share some common properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The function takes two parameters.</p></li><li class="listitem"><p>The parameters and the returned value have the same type.</p></li><li class="listitem"><p>There exists such a value that doesn’t change other values when used with the binary function.</p></li></ul></div><p>There’s another thing that these two operations have in common that may not be as obvious as our previous observations: When we have three or more values and we want to use the binary function to reduce them to a single result, the order in which we apply the binary function to the values doesn’t matter. For example, whether we use <code class="literal">(3 * 4) * 5</code> or <code class="literal">3 * (4 * 5)</code>, the result is <code class="literal">60</code>. The same goes for <code class="literal">++</code>:</p><a id="I_programlisting12_d1e22621"/><pre class="programlisting">ghci&gt; (3 * 2) * (8 * 5)
240
ghci&gt; 3 * (2 * (8 * 5))
240
ghci&gt; "la" ++ ("di" ++ "da")
"ladida"
ghci&gt; ("la" ++ "di") ++ "da"
"ladida"</pre><p>We call this property <span class="emphasis"><em>associativity</em></span>. <code class="literal">*</code> is associative, and so is <code class="literal">++</code>. However, <code class="literal">-</code>, for example, is not associative; the expressions <code class="literal">(5 - 3) - 4</code> and <code class="literal">5 - (3 - 4)</code> result in different numbers.<a id="IDX-CHP-12-0039" class="indexterm"/></p><p>By being aware of these properties, we have chanced upon monoids!</p><div class="sect2" title="The Monoid Type Class"><div class="titlepage"><div><div><h2 class="title"><a id="the_monoid_type_class"/>The Monoid Type Class</h2></div></div></div><p>A <span class="emphasis"><em>monoid</em></span> is made up of an associative binary function and a value that acts as an identity with respect to that function. When something acts as an identity with respect to a function, it means that when called with that function and some other value, the result is always equal to that other value. <code class="literal">1</code> is the identity with respect to <code class="literal">*</code>, and <code class="literal">[]</code> is the identity with respect to <code class="literal">++</code>. There are a lot of other monoids to be found in the world of Haskell, which is why the <code class="literal">Monoid</code> type class exists. It’s for types that can act like monoids. Let’s see how the type class is defined:<a id="IDX-CHP-12-0040" class="indexterm"/><a id="IDX-CHP-12-0041" class="indexterm"/><a id="IDX-CHP-12-0042" class="indexterm"/><a id="IDX-CHP-12-0043" class="indexterm"/><a id="IDX-CHP-12-0044" class="indexterm"/><a id="IDX-CHP-12-0045" class="indexterm"/><a id="IDX-CHP-12-0046" class="indexterm"/><a id="IDX-CHP-12-0047" class="indexterm"/><a id="IDX-CHP-12-0048" class="indexterm"/><a id="IDX-CHP-12-0049" class="indexterm"/><a id="IDX-CHP-12-0050" class="indexterm"/><a id="IDX-CHP-12-0051" class="indexterm"/></p><a id="I_programlisting12_d1e22729"/><pre class="programlisting">class Monoid m where
    mempty :: m
    mappend :: m -&gt; m -&gt; m
    mconcat :: [m] -&gt; m
    mconcat = foldr mappend mempty</pre><p>The <code class="literal">Monoid</code> type class is defined in <code class="literal">import Data.Monoid</code>. Let’s take some time to get properly acquainted with it.</p><p>First, we see that only concrete types can be made instances of <code class="literal">Monoid</code>, because the <code class="literal">m</code> in the type class definition doesn’t take any type parameters. This is different from <code class="literal">Functor</code> and <code class="literal">Applicative</code>, which require their instances to be type constructors that take one parameter.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject12_d1e22754"/><img src="httpatomoreillycomsourcenostarchimages802666.png.jpg" alt="image with no caption"/></div></div><p>The first function is <code class="literal">mempty</code>. It’s not really a function, since it doesn’t take parameters. It’s a polymorphic constant, kind of like <code class="literal">minBound</code> from <code class="literal">Bounded</code>. <code class="literal">mempty</code> represents the identity value for a particular monoid.</p><p>Next up, we have <code class="literal">mappend</code>, which, as you’ve probably guessed, is the binary function. It takes two values of the same type and returns another value of that same type. The decision to call it <code class="literal">mappend</code> was kind of unfortunate, because it implies that we’re appending two things in some way. While <code class="literal">++</code> does take two lists and append one to the other, <code class="literal">*</code> doesn’t really do any appending; it just multiplies two numbers together. When you meet other instances of <code class="literal">Monoid</code>, you’ll see that most of them don’t append values either. So avoid thinking in terms of appending and just think in terms of <code class="literal">mappend</code> being a binary function that takes two monoid values and returns a third.</p><p>The last function in this type class definition is <code class="literal">mconcat</code>. It takes a list of monoid values and reduces them to a single value by using <code class="literal">mappend</code> between the list’s elements. It has a default implementation, which just takes <code class="literal">mempty</code> as a starting value and folds the list from the right with <code class="literal">mappend</code>. Because the default implementation is fine for most instances, we won’t concern ourselves with <code class="literal">mconcat</code> too much. When making a type an instance of <code class="literal">Monoid</code>, it suffices to just implement <code class="literal">mempty</code> and <code class="literal">mappend</code>. Although for some instances, there might be a more efficient way to implement <code class="literal">mconcat</code>, the default implementation is just fine for most cases.<a id="IDX-CHP-12-0052" class="indexterm"/><a id="IDX-CHP-12-0053" class="indexterm"/></p></div><div class="sect2" title="The Monoid Laws"><div class="titlepage"><div><div><h2 class="title"><a id="the_monoid_laws"/>The Monoid Laws</h2></div></div></div><p>Before moving on to specific instances of <code class="literal">Monoid</code>, let’s take a brief look at the monoid laws.<a id="IDX-CHP-12-0054" class="indexterm"/></p><p>You’ve learned that there must be a value that acts as the identity with respect to the binary function and that the binary function must be associative. It’s possible to make instances of <code class="literal">Monoid</code> that don’t follow these rules, but such instances are of no use to anyone because when using the <code class="literal">Monoid</code> type class, we rely on its instances acting like monoids. Otherwise, what’s the point? That’s why when making monoid instances, we need to make sure they follow these laws:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">mempty `mappend` x = x</code></p></li><li class="listitem"><p><code class="literal">x `mappend` mempty = x</code></p></li><li class="listitem"><p><code class="literal">(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)</code></p></li></ul></div><p>The first two laws state that <code class="literal">mempty</code> must act as the identity with respect to <code class="literal">mappend</code>, and the third says that <code class="literal">mappend</code> must be associative (the order in which we use <code class="literal">mappend</code> to reduce several monoid values into one doesn’t matter). Haskell doesn’t enforce these laws, so we need to be careful that our instances do indeed obey them.</p></div></div>
<div class="sect1" title="Meet Some Monoids"><div class="titlepage"><div><div><h1 class="title"><a id="meet_some_monoids"/>Meet Some Monoids</h1></div></div></div><p>Now that you know what monoids are about, let’s look at some Haskell types that are monoids, what their <code class="literal">Monoid</code> instances look like, and their uses.</p><div class="sect2" title="Lists Are Monoids"><div class="titlepage"><div><div><h2 class="title"><a id="lists_are_monoids"/>Lists Are Monoids</h2></div></div></div><p>Yes, lists are monoids! As you’ve seen, the <code class="literal">++</code> function and the empty list <code class="literal">[]</code> form a monoid. The instance is very simple:</p><a id="I_programlisting12_d1e22901"/><pre class="programlisting">instance Monoid [a] where
    mempty = []
    mappend = (++)</pre><p>Lists are an instance of the <code class="literal">Monoid</code> type class, regardless of the type of the elements they hold. Notice that we wrote <code class="literal">instance Monoid [a]</code> and not <code class="literal">instance Monoid []</code>, because <code class="literal">Monoid</code> requires a concrete type for an instance.</p><p>Giving this a test run, we encounter no surprises:</p><a id="I_programlisting12_d1e22919"/><pre class="programlisting">ghci&gt; [1,2,3] `mappend` [4,5,6]
[1,2,3,4,5,6]
ghci&gt; ("one" `mappend` "two") `mappend` "tree"
"onetwotree"
ghci&gt; "one" `mappend` ("two" `mappend` "tree")
"onetwotree"
ghci&gt; "one" `mappend` "two" `mappend` "tree"
"onetwotree"
ghci&gt; "pang" `mappend` mempty
"pang"
ghci&gt; mconcat [[1,2],[3,6],[9]]
[1,2,3,6,9]
ghci&gt; mempty :: [a]
[]</pre><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject12_d1e22922"/><img src="httpatomoreillycomsourcenostarchimages802668.png.jpg" alt="image with no caption"/></div></div><p>Notice that in the last line, we wrote an explicit type annotation. If we just wrote <code class="literal">mempty</code>, GHCi wouldn’t know which instance to use, so we needed to say we want the list instance. We were able to use the general type of <code class="literal">[a]</code> (as opposed to specifying <code class="literal">[Int]</code> or <code class="literal">[String]</code>) because the empty list can act as if it contains any type.<a id="IDX-CHP-12-0055" class="indexterm"/><a id="IDX-CHP-12-0056" class="indexterm"/><a id="IDX-CHP-12-0057" class="indexterm"/><a id="IDX-CHP-12-0058" class="indexterm"/><a id="IDX-CHP-12-0059" class="indexterm"/><a id="IDX-CHP-12-0060" class="indexterm"/><a id="IDX-CHP-12-0061" class="indexterm"/></p><p>Because <code class="literal">mconcat</code> has a default implementation, we get it for free when we make something an instance of <code class="literal">Monoid</code>. In the case of the list, <code class="literal">mconcat</code> turns out to be just <code class="literal">concat</code>. It takes a list of lists and flattens it, because that’s the equivalent of doing <code class="literal">++</code> between all the adjacent lists in a list.</p><p>The monoid laws do indeed hold for the list instance. When we have several lists and we <code class="literal">mappend</code> (or <code class="literal">++</code>) them together, it doesn’t matter which ones we do first, because they’re just joined at the ends anyway. Also, the empty list acts as the identity, so all is well.</p><p>Notice that monoids don’t require that <code class="literal">a `mappend` b</code> be equal to <code class="literal">b `mappend` a</code>. In the case of the list, they clearly aren’t:</p><a id="I_programlisting12_d1e23009"/><pre class="programlisting">ghci&gt; "one" `mappend` "two"
"onetwo"
ghci&gt; "two" `mappend` "one"
"twoone"</pre><p>And that’s okay. The fact that for multiplication <code class="literal">3 * 5</code> and <code class="literal">5 * 3</code> are the same is just a property of multiplication, but it doesn’t hold for all (and indeed, most) monoids.</p></div><div class="sect2" title="Product and Sum"><div class="titlepage"><div><div><h2 class="title"><a id="product_and_sum"/>Product and Sum</h2></div></div></div><p>We already examined one way for numbers to be considered monoids: Just let the binary function be <code class="literal">*</code> and the identity value be <code class="literal">1</code>. Another way for numbers to be monoids is to have the binary function be <code class="literal">+</code> and the identity value be <code class="literal">0</code>:<a id="IDX-CHP-12-0062" class="indexterm"/><a id="IDX-CHP-12-0063" class="indexterm"/><a id="IDX-CHP-12-0064" class="indexterm"/><a id="IDX-CHP-12-0065" class="indexterm"/><a id="IDX-CHP-12-0066" class="indexterm"/><a id="IDX-CHP-12-0067" class="indexterm"/><a id="IDX-CHP-12-0068" class="indexterm"/></p><a id="I_programlisting12_d1e23066"/><pre class="programlisting">ghci&gt; 0 + 4
4
ghci&gt; 5 + 0
5
ghci&gt; (1 + 3) + 5
9
ghci&gt; 1 + (3 + 5)
9</pre><p>The monoid laws hold, because if you add 0 to any number, the result is that number. And addition is also associative, so we have no problems there.<a id="IDX-CHP-12-0069" class="indexterm"/></p><p>With two equally valid ways for numbers to be monoids, which way do we choose? Well, we don’t have to pick. Remember that when there are several ways for some type to be an instance of the same type class, we can wrap that type in a <code class="literal">newtype</code> and then make the new type an instance of the type class in a different way. We can have our cake and eat it too.</p><p>The <code class="literal">Data.Monoid</code> module exports two types for this: <code class="literal">Product</code> and <code class="literal">Sum</code>. <code class="literal">Product</code> is defined like this:</p><a id="I_programlisting12_d1e23094"/><pre class="programlisting">newtype Product a =  Product { getProduct :: a }
    deriving (Eq, Ord, Read, Show, Bounded)</pre><p>It’s simple—just a <code class="literal">newtype</code> wrapper with one type parameter along with some derived instances. Its instance for <code class="literal">Monoid</code> goes something like this:</p><a id="I_programlisting12_d1e23104"/><pre class="programlisting">instance Num a =&gt; Monoid (Product a) where
    mempty = Product 1
    Product x `mappend` Product y = Product (x * y)</pre><p><code class="literal">mempty</code> is just <code class="literal">1</code> wrapped in a <code class="literal">Product</code> constructor. <code class="literal">mappend</code> pattern matches on the <code class="literal">Product</code> constructor, multiplies the two numbers, and then wraps the resulting number. As you can see, there’s a <code class="literal">Num a</code> class constraint. This means that <code class="literal">Product a</code> is an instance of <code class="literal">Monoid</code> for all <code class="literal">a</code> values that are already an instance of <code class="literal">Num</code>. To use <code class="literal">Product a</code> as a monoid, we need to do some <code class="literal">newtype</code> wrapping and unwrapping:</p><a id="I_programlisting12_d1e23144"/><pre class="programlisting">ghci&gt; getProduct $ Product 3 `mappend` Product 9
27
ghci&gt; getProduct $ Product 3 `mappend` mempty
3
ghci&gt; getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2
24
ghci&gt; getProduct . mconcat . map Product $ [3,4,2]
24</pre><p><code class="literal">Sum</code> is defined along the same lines as <code class="literal">Product</code>, and the instance is similar as well. We use it in the same way:<a id="IDX-CHP-12-0070" class="indexterm"/><a id="IDX-CHP-12-0071" class="indexterm"/><a id="IDX-CHP-12-0072" class="indexterm"/><a id="IDX-CHP-12-0073" class="indexterm"/><a id="IDX-CHP-12-0074" class="indexterm"/><a id="IDX-CHP-12-0075" class="indexterm"/></p><a id="I_programlisting12_d1e23176"/><pre class="programlisting">ghci&gt; getSum $ Sum 2 `mappend` Sum 9
11
ghci&gt; getSum $ mempty `mappend` Sum 3
3
ghci&gt; getSum . mconcat . map Sum $ [1,2,3]
6</pre></div><div class="sect2" title="Any and All"><div class="titlepage"><div><div><h2 class="title"><a id="any_and_all"/>Any and All</h2></div></div></div><p>Another type that can act like a monoid in two distinct but equally valid ways is <code class="literal">Bool</code>. The first way is to have the function <code class="literal">||</code>, which represents a logical OR, act as the binary function along with <code class="literal">False</code> as the identity value. With the logical OR, if any of the two parameters is <code class="literal">True</code>, it returns <code class="literal">True</code>; otherwise, it returns <code class="literal">False</code>. So if we use <code class="literal">False</code> as the identity value, OR will return <code class="literal">False</code> when used with <code class="literal">False</code> and <code class="literal">True</code> when used with <code class="literal">True</code>. The <code class="literal">Any newtype</code> constructor is an instance of <code class="literal">Monoid</code> in this fashion. It’s defined like this:</p><a id="I_programlisting12_d1e23224"/><pre class="programlisting">newtype Any = Any { getAny :: Bool }
    deriving (Eq, Ord, Read, Show, Bounded)</pre><p>Its instance looks like this:</p><a id="I_programlisting12_d1e23228"/><pre class="programlisting">instance Monoid Any where
        mempty = Any False
        Any x `mappend` Any y = Any (x || y)</pre><p>It’s called <code class="literal">Any</code> because <code class="literal">x `mappend` y</code> will be <code class="literal">True</code> if <span class="emphasis"><em>any</em></span> one of those two is <code class="literal">True</code>. Even if three or more <code class="literal">Any</code> wrapped <code class="literal">Bool</code> values are <code class="literal">mappend</code>ed together, the result will hold <code class="literal">True</code> if any of them are <code class="literal">True</code>:</p><a id="I_programlisting12_d1e23263"/><pre class="programlisting">ghci&gt; getAny $ Any True `mappend` Any False
True
ghci&gt; getAny $ mempty `mappend` Any True
True
ghci&gt; getAny . mconcat . map Any $ [False, False, False, True]
True
ghci&gt; getAny $ mempty `mappend` mempty
False</pre><p>The other way for <code class="literal">Bool</code> to be an instance of <code class="literal">Monoid</code> is to kind of do the opposite: Have <code class="literal">&amp;&amp;</code> be the binary function and then make <code class="literal">True</code> the identity value. Logical AND will return <code class="literal">True</code> only if both of its parameters are <code class="literal">True</code>.</p><p>This is the <code class="literal">newtype</code> declaration:<a id="IDX-CHP-12-0076" class="indexterm"/><a id="IDX-CHP-12-0077" class="indexterm"/><a id="IDX-CHP-12-0078" class="indexterm"/><a id="IDX-CHP-12-0079" class="indexterm"/><a id="IDX-CHP-12-0080" class="indexterm"/></p><a id="I_programlisting12_d1e23310"/><pre class="programlisting">newtype All = All { getAll :: Bool }
        deriving (Eq, Ord, Read, Show, Bounded)</pre><p>And this is the instance:</p><a id="I_programlisting12_d1e23315"/><pre class="programlisting">instance Monoid All where
        mempty = All True
        All x `mappend` All y = All (x &amp;&amp; y)</pre><p>When we <code class="literal">mappend</code> values of the <code class="literal">All</code> type, the result will be <code class="literal">True</code> only if <span class="emphasis"><em>all</em></span> the values used in the <code class="literal">mappend</code> operations are <code class="literal">True</code>:</p><a id="I_programlisting12_d1e23338"/><pre class="programlisting">ghci&gt; getAll $ mempty `mappend` All True
True
ghci&gt; getAll $ mempty `mappend` All False
False
ghci&gt; getAll . mconcat . map All $ [True, True, True]
True
ghci&gt; getAll . mconcat . map All $ [True, True, False]
False</pre><p>Just as with multiplication and addition, we usually explicitly state the binary functions instead of wrapping them in <code class="literal">newtype</code>s and then using <code class="literal">mappend</code> and <code class="literal">mempty</code>. <code class="literal">mconcat</code> seems useful for <code class="literal">Any</code> and <code class="literal">All</code>, but usually it’s easier to use the <code class="literal">or</code> and <code class="literal">and</code> functions. <code class="literal">or</code> takes lists of <code class="literal">Bool</code> values and returns <code class="literal">True</code> if any of them are <code class="literal">True</code>. <code class="literal">and</code> takes the same values and returns <code class="literal">True</code> if all of them are <code class="literal">True</code>.</p></div><div class="sect2" title="The Ordering Monoid"><div class="titlepage"><div><div><h2 class="title"><a id="the_ordering_monoid"/>The Ordering Monoid</h2></div></div></div><p>Remember the <code class="literal">Ordering</code> type? It’s used as the result when comparing things, and it can have three values: <code class="literal">LT</code>, <code class="literal">EQ</code>, and <code class="literal">GT</code>, which stand for less than, equal, and greater than, respectively.</p><a id="I_programlisting12_d1e23406"/><pre class="programlisting">ghci&gt; 1 `compare` 2
LT
ghci&gt; 2 `compare` 2
EQ
ghci&gt; 3 `compare` 2
GT</pre><p>With lists, numbers, and Boolean values, finding monoids was just a matter of looking at already existing commonly used functions and seeing if they exhibited some sort of monoid behavior. With <code class="literal">Ordering</code>, we need to look a bit harder to recognize a monoid. It turns out that the ordering <code class="literal">Monoid</code> instance is just as intuitive as the ones we’ve met so far, and it’s also quite useful:<a id="IDX-CHP-12-0081" class="indexterm"/><a id="IDX-CHP-12-0082" class="indexterm"/><a id="IDX-CHP-12-0083" class="indexterm"/></p><a id="I_programlisting12_d1e23431"/><pre class="programlisting">instance Monoid Ordering where
    mempty = EQ
    LT `mappend` _ = LT
    EQ `mappend` y = y
    GT `mappend` _ = GT</pre><p>The instance is set up like this: When we <code class="literal">mappend</code> two <code class="literal">Ordering</code> values, the one on the left is kept, unless the value on the left is <code class="literal">EQ</code>. If the value on the left is <code class="literal">EQ</code>, the right one is the result. The identity is <code class="literal">EQ</code>. At first, this may seem kind of arbitrary, but it actually resembles the way we alphabetically compare words. We look at the first two letters, and if they differ, we can already decide which word would go first in a dictionary. However, if the first two letters are equal, then we move on to comparing the next pair of letters and repeat the process.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject12_d1e23451"/><img src="httpatomoreillycomsourcenostarchimages802670.png.jpg" alt="image with no caption"/></div></div><p>For instance, when we alphabetically compare the words <span class="emphasis"><em>ox</em></span> and <span class="emphasis"><em>on</em></span>, we see that the first letter of each word is equal and then move on to comparing the second letter. Since <span class="emphasis"><em>x</em></span> is alphabetically greater than <span class="emphasis"><em>n</em></span>, we know how the words compare. To gain some understanding of <code class="literal">EQ</code> being the identity, note that if we were to cram the same letter in the same position in both words, it wouldn’t change their alphabetical ordering; for example, <span class="emphasis"><em>oix</em></span> is still alphabetically greater than <span class="emphasis"><em>oin</em></span>.</p><p>It’s important to note that in the <code class="literal">Monoid</code> instance for <code class="literal">Ordering</code>, <code class="literal">x `mappend` y</code> doesn’t equal <code class="literal">y `mappend` x</code>. Because the first parameter is kept unless it’s <code class="literal">EQ</code>, <code class="literal">LT `mappend` GT</code> will result in <code class="literal">LT</code>, whereas <code class="literal">GT `mappend` LT</code> will result in <code class="literal">GT</code>:</p><a id="I_programlisting12_d1e23510"/><pre class="programlisting">ghci&gt; LT `mappend` GT
LT
ghci&gt; GT `mappend` LT
GT
ghci&gt; mempty `mappend` LT
LT
ghci&gt; mempty `mappend` GT
GT</pre><p>Okay, so how is this monoid useful? Let’s say we are writing a function that takes two strings, compares their lengths, and returns an <code class="literal">Ordering</code>. But if the strings are of the same length, instead of returning <code class="literal">EQ</code> right away, we want to compare them alphabetically.</p><p>Here’s one way to write this:<a id="IDX-CHP-12-0084" class="indexterm"/></p><a id="I_programlisting12_d1e23528"/><pre class="programlisting">lengthCompare :: String -&gt; String -&gt; Ordering
lengthCompare x y = let a = length x `compare` length y
                        b = x `compare` y
                    in  if a == EQ then b else a</pre><p>We name the result of comparing the lengths <code class="literal">a</code> and the result of the alphabetical comparison <code class="literal">b</code>, and then if the lengths are equal, we return their alphabetical ordering.</p><p>But by employing our understanding of how <code class="literal">Ordering</code> is a monoid, we can rewrite this function in a much simpler manner:</p><a id="I_programlisting12_d1e23543"/><pre class="programlisting">import Data.Monoid

lengthCompare :: String -&gt; String -&gt; Ordering
lengthCompare x y = (length x `compare` length y) `mappend`
                    (x `compare` y)</pre><p>Let’s try this out:</p><a id="I_programlisting12_d1e23547"/><pre class="programlisting">ghci&gt; lengthCompare "zen" "ants"
LT
ghci&gt; lengthCompare "zen" "ant"
GT</pre><p>Remember that when we use <code class="literal">mappend</code>, its left parameter is kept unless it’s <code class="literal">EQ</code>; if it’s <code class="literal">EQ</code>, the right one is kept. That’s why we put the comparison that we consider to be the first, more important, criterion as the first parameter. Now suppose that we want to expand this function to also compare for the number of vowels and set this to be the second most important criterion for comparison. We modify it like this:</p><a id="I_programlisting12_d1e23560"/><pre class="programlisting">import Data.Monoid

lengthCompare :: String -&gt; String -&gt; Ordering
lengthCompare x y = (length x `compare` length y) `mappend`
                    (vowels x `compare` vowels y) `mappend`
                    (x `compare` y)
    where vowels = length . filter (`elem` "aeiou")</pre><p>We made a helper function, which takes a string and tells us how many vowels it has by first filtering it for only letters that are in the string <code class="literal">"aeiou"</code> and then applying <code class="literal">length</code> to that.</p><a id="I_programlisting12_d1e23570"/><pre class="programlisting">ghci&gt; lengthCompare "zen" "anna"
LT
ghci&gt; lengthCompare "zen" "ana"
LT
ghci&gt; lengthCompare "zen" "ann"
GT</pre><p>In the first example, the lengths are found to be different, and so <code class="literal">LT</code> is returned, because the length of <code class="literal">"zen"</code> is less than the length of <code class="literal">"anna"</code>. In the second example, the lengths are the same, but the second string has more vowels, so <code class="literal">LT</code> is returned again. In the third example, they both have the same length and the same number of vowels, so they’re compared alphabetically, and <code class="literal">"zen"</code> wins.<a id="IDX-CHP-12-0085" class="indexterm"/><a id="IDX-CHP-12-0086" class="indexterm"/></p><p>The <code class="literal">Ordering</code> monoid is very useful because it allows us to easily compare things by many different criteria and put those criteria in an order themselves, ranging from the most important to the least important.</p></div><div class="sect2" title="Maybe the Monoid"><div class="titlepage"><div><div><h2 class="title"><a id="maybe_the_monoid"/>Maybe the Monoid</h2></div></div></div><p>Let’s take a look at the various ways that <code class="literal">Maybe a</code> can be made an instance of <code class="literal">Monoid</code> and how those instances are useful.</p><p>One way is to treat <code class="literal">Maybe a</code> as a monoid only if its type parameter <code class="literal">a</code> is a monoid as well and then implement <code class="literal">mappend</code> in such a way that it uses the <code class="literal">mappend</code> operation of the values that are wrapped with <code class="literal">Just</code>. We use <code class="literal">Nothing</code> as the identity, and so if one of the two values that we’re <code class="literal">mappend</code>ing is <code class="literal">Nothing</code>, we keep the other value. Here’s the instance declaration:</p><a id="I_programlisting12_d1e23644"/><pre class="programlisting">instance Monoid a =&gt; Monoid (Maybe a) where
    mempty = Nothing
    Nothing `mappend` m = m
    m `mappend` Nothing = m
    Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)</pre><p>Notice the class constraint. It says that <code class="literal">Maybe a</code> is an instance of <code class="literal">Monoid</code> only if <code class="literal">a</code> is an instance of <code class="literal">Monoid</code>. If we <code class="literal">mappend</code> something with a <code class="literal">Nothing</code>, the result is that something. If we <code class="literal">mappend</code> two <code class="literal">Just</code> values, the contents of the <code class="literal">Just</code>s are <code class="literal">mappend</code>ed and then wrapped back in a <code class="literal">Just</code>. We can do this because the class constraint ensures that the type of what’s inside the <code class="literal">Just</code> is an instance of <code class="literal">Monoid</code>.</p><a id="I_programlisting12_d1e23689"/><pre class="programlisting">ghci&gt; Nothing `mappend` Just "andy"
Just "andy"
ghci&gt; Just LT `mappend` Nothing
Just LT
ghci&gt; Just (Sum 3) `mappend` Just (Sum 4)
Just (Sum {getSum = 7})</pre><p>This is useful when we’re dealing with monoids as results of computations that may have failed. Because of this instance, we don’t need to check if the computations have failed by seeing if they’re a <code class="literal">Nothing</code> or <code class="literal">Just</code> value; we can just continue to treat them as normal monoids.<a id="IDX-CHP-12-0087" class="indexterm"/><a id="IDX-CHP-12-0088" class="indexterm"/><a id="IDX-CHP-12-0089" class="indexterm"/><a id="IDX-CHP-12-0090" class="indexterm"/></p><p>But what if the type of the contents of the <code class="literal">Maybe</code> is not an instance of <code class="literal">Monoid</code>? Notice that in the previous instance declaration, the only case where we must rely on the contents being monoids is when both parameters of <code class="literal">mappend</code> are <code class="literal">Just</code> values. When we don’t know if the contents are monoids, we can’t use <code class="literal">mappend</code> between them, so what are we to do? Well, one thing we can do is discard the second value and keep the first one. For this purpose, the <code class="literal">First a</code> type exists. Here’s its definition:</p><a id="I_programlisting12_d1e23738"/><pre class="programlisting">newtype First a = First { getFirst :: Maybe a }
    deriving (Eq, Ord, Read, Show)</pre><p>We take a <code class="literal">Maybe a</code> and wrap it with a <code class="literal">newtype</code>. The <code class="literal">Monoid</code> instance is as follows:</p><a id="I_programlisting12_d1e23751"/><pre class="programlisting">instance Monoid (First a) where
    mempty = First Nothing
    First (Just x) `mappend` _ = First (Just x)
    First Nothing `mappend` x = x</pre><p><code class="literal">mempty</code> is just a <code class="literal">Nothing</code> wrapped with the <code class="literal">First newtype</code> constructor. If <code class="literal">mappend</code>’s first parameter is a <code class="literal">Just</code> value, we ignore the second one. If the first one is a <code class="literal">Nothing</code>, then we present the second parameter as a result, regardless of whether it’s a <code class="literal">Just</code> or a <code class="literal">Nothing</code>:</p><a id="I_programlisting12_d1e23780"/><pre class="programlisting">ghci&gt; getFirst $ First (Just 'a') `mappend` First (Just 'b')
Just 'a'
ghci&gt; getFirst $ First Nothing `mappend` First (Just 'b')
Just 'b'
ghci&gt; getFirst $ First (Just 'a') `mappend` First Nothing
Just 'a'</pre><p><code class="literal">First</code> is useful when we have a bunch of <code class="literal">Maybe</code> values and we just want to know if any of them is a <code class="literal">Just</code>. The <code class="literal">mconcat</code> function comes in handy:</p><a id="I_programlisting12_d1e23795"/><pre class="programlisting">ghci&gt; getFirst . mconcat . map First $ [Nothing, Just 9, Just 10]
Just 9</pre><p>If we want a monoid on <code class="literal">Maybe a</code> such that the second parameter is kept if both parameters of <code class="literal">mappend</code> are <code class="literal">Just</code> values, <code class="literal">Data.Monoid</code> provides the <code class="literal">Last a</code> type, which works like <code class="literal">First a</code>, but the last non-<code class="literal">Nothing</code> value is kept when <code class="literal">mappend</code>ing and using <code class="literal">mconcat</code>:</p><a id="I_programlisting12_d1e23827"/><pre class="programlisting">ghci&gt; getLast . mconcat . map Last $ [Nothing, Just 9, Just 10]
Just 10
ghci&gt; getLast $ Last (Just "one") `mappend` Last (Just "two")
Just "two"</pre></div></div>
<div class="sect1" title="Folding with Monoids"><div class="titlepage"><div><div><h1 class="title"><a id="folding_with_monoids"/>Folding with Monoids</h1></div></div></div><p>One of the more interesting ways to put monoids to work is to have them help us define folds over various data structures. So far, we’ve done folds over lists, but lists aren’t the only data structure that can be folded over. We can define folds over almost any data structure. Trees especially lend themselves well to folding.<a id="IDX-CHP-12-0091" class="indexterm"/><a id="IDX-CHP-12-0092" class="indexterm"/><a id="IDX-CHP-12-0093" class="indexterm"/><a id="IDX-CHP-12-0094" class="indexterm"/></p><p>Because there are so many data structures that work nicely with folds, the <code class="literal">Foldable</code> type class was introduced. Much like <code class="literal">Functor</code> is for things that can be mapped over, <code class="literal">Foldable</code> is for things that can be folded up! It can be found in <code class="literal">Data.Foldable</code>, and because it exports functions whose names clash with the ones from the <code class="literal">Prelude</code>, it’s best imported qualified (and served with basil):</p><a id="I_programlisting12_d1e23869"/><pre class="programlisting">import qualified Data.Foldable as F</pre><p>To save ourselves precious keystrokes, we’ve imported it qualified as <code class="literal">F</code>.</p><p>So what are some of the functions that this type class defines? Well, among them are <code class="literal">foldr</code>, <code class="literal">foldl</code>, <code class="literal">foldr1</code>, and <code class="literal">foldl1</code>. Huh? We already know these functions. What’s so new about this? Let’s compare the types of <code class="literal">Foldable</code>’s <code class="literal">foldr</code> and <code class="literal">foldr</code> from <code class="literal">Prelude</code> to see how they differ:</p><a id="I_programlisting12_d1e23903"/><pre class="programlisting">ghci&gt; :t foldr
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
ghci&gt; :t F.foldr
F.foldr :: (F.Foldable t) =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</pre><p>Ah! So whereas <code class="literal">foldr</code> takes a list and folds it up, the <code class="literal">foldr</code> from <code class="literal">Data.Foldable</code> accepts any type that can be folded up, not just lists! As expected, both <code class="literal">foldr</code> functions do the same for lists:</p><a id="I_programlisting12_d1e23919"/><pre class="programlisting">ghci&gt; foldr (*) 1 [1,2,3]
6
ghci&gt; F.foldr (*) 1 [1,2,3]
6</pre><p>Another data structures that support folds is the <code class="literal">Maybe</code> we all know and love!</p><a id="I_programlisting12_d1e23926"/><pre class="programlisting">ghci&gt; F.foldl (+) 2 (Just 9)
11
ghci&gt; F.foldr (||) False (Just True)
True</pre><p>But folding over a <code class="literal">Maybe</code> value isn’t terribly interesting. It just acts like a list with one element if it’s a <code class="literal">Just</code> value and like an empty list if it’s <code class="literal">Nothing</code>. Let’s examine a data structure that’s a little more complex.</p><p>Remember the tree data structure from <a class="xref" href="ch07.html" title="Chapter 7. Making Our Own Types and Type Classes">Chapter 7</a>? We defined it like this:<a id="IDX-CHP-12-0095" class="indexterm"/><a id="IDX-CHP-12-0096" class="indexterm"/><a id="IDX-CHP-12-0097" class="indexterm"/><a id="IDX-CHP-12-0098" class="indexterm"/></p><a id="I_programlisting12_d1e23962"/><pre class="programlisting">data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show)</pre><p>You learned that a tree is either an empty tree that doesn’t hold any values or it’s a node that holds one value and also two other trees. After defining it, we made it an instance of <code class="literal">Functor</code>, and with that we gained the ability to <code class="literal">fmap</code> functions over it. Now we’re going to make it an instance of <code class="literal">Foldable</code> so we get the ability to fold it up.</p><p>One way to make a type constructor an instance of <code class="literal">Foldable</code> is to just directly implement <code class="literal">foldr</code> for it. But another, often much easier way, is to implement the <code class="literal">foldMap</code> function, which is also a part of the <code class="literal">Foldable</code> type class. The <code class="literal">foldMap</code> function has the following type:</p><a id="I_programlisting12_d1e23992"/><pre class="programlisting">foldMap :: (Monoid m, Foldable t) =&gt; (a -&gt; m) -&gt; t a -&gt; m</pre><p>Its first parameter is a function that takes a value of the type that our foldable structure contains (denoted here with <code class="literal">a</code>) and returns a monoid value. Its second parameter is a foldable structure that contains values of type <code class="literal">a</code>. It maps that function over the foldable structure, thus producing a foldable structure that contains monoid values. Then, by doing <code class="literal">mappend</code> between those monoid values, it joins them all into a single monoid value. This function may sound kind of odd at the moment, but you’ll see that it’s very easy to implement. And implementing this function is all it takes for our type to be made an instance of <code class="literal">Foldable</code>! So if we just implement <code class="literal">foldMap</code> for some type, we get <code class="literal">foldr</code> and <code class="literal">foldl</code> on that type for free.</p><p>This is how we make <code class="literal">Tree</code> an instance of <code class="literal">Foldable</code>:</p><a id="I_programlisting12_d1e24026"/><pre class="programlisting">instance F.Foldable Tree where
    foldMap f EmptyTree = mempty
    foldMap f (Node x l r) = F.foldMap f l `mappend`
                             f x           `mappend`
                             F.foldMap f r</pre><p>If we are provided with a function that takes an element of our tree and returns a monoid value, how do we reduce our whole tree down to one single monoid value? When we were using <code class="literal">fmap</code> over our tree, we applied the function that we were mapping to a node, and then we recursively mapped the function over the left subtree as well as the right one. Here, we’re tasked with not only mapping a function, but also with joining up the results into a single monoid value by using <code class="literal">mappend</code>. First, we consider the case of the empty tree—a sad, sad, lonely tree that has no values or subtrees. It doesn’t hold any value that we can give to our monoid-making function, so we just say that if our tree is empty, the monoid value it becomes is <code class="literal">mempty</code>.<a id="IDX-CHP-12-0099" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject12_d1e24045"/><img src="httpatomoreillycomsourcenostarchimages802672.png.jpg" alt="image with no caption"/></div></div><p>The case of a nonempty node is a bit more interesting. It contains two subtrees as well as a value. In this case, we recursively <code class="literal">foldMap</code> the same function <code class="literal">f</code> over the left and right subtrees. Remember that our <code class="literal">foldMap</code> results in a single monoid value. We also apply our function <code class="literal">f</code> to the value in the node. Now we have three monoid values (two from our subtrees and one from applying <code class="literal">f</code> to the value in the node), and we just need to bang them together into a single value. For this purpose, we use <code class="literal">mappend</code>, and naturally the left subtree comes first, then the node value, followed by the right subtree.</p><p>Notice that we didn’t need to provide the function that takes a value and returns a monoid value. We receive that function as a parameter to <code class="literal">foldMap</code>, and all we need to decide is where to apply that function and how to join the resulting monoids from it.</p><p>Now that we have a <code class="literal">Foldable</code> instance for our tree type, we get <code class="literal">foldr</code> and <code class="literal">foldl</code> for free! Consider this tree:</p><a id="I_programlisting12_d1e24088"/><pre class="programlisting">testTree = Node 5
            (Node 3
                (Node 1 EmptyTree EmptyTree)
                (Node 6 EmptyTree EmptyTree)
            )
            (Node 9
                (Node 8 EmptyTree EmptyTree)
                (Node 10 EmptyTree EmptyTree)
            )</pre><p>It has <code class="literal">5</code> at its root, and then its left node has <code class="literal">3</code> with <code class="literal">1</code> on the left and <code class="literal">6</code> on the right. The root’s right node has a <code class="literal">9</code> and then <code class="literal">8</code> to its left and <code class="literal">10</code> on the far right side. With a <code class="literal">Foldable</code> instance, we can do all of the folds that we can do on lists:</p><a id="I_programlisting12_d1e24117"/><pre class="programlisting">ghci&gt; F.foldl (+) 0 testTree
42
ghci&gt; F.foldl (*) 1 testTree
64800</pre><p><code class="literal">foldMap</code> isn’t useful only for making new instances of <code class="literal">Foldable</code>. It also comes in handy for reducing our structure to a single monoid value. For instance, if we want to know if any number in our tree is equal to <code class="literal">3</code>, we can do this:</p><a id="I_programlisting12_d1e24129"/><pre class="programlisting">ghci&gt; getAny $ F.foldMap (\x -&gt; Any $ x == 3) testTree
True</pre><p>Here, <code class="literal">\x -&gt; Any $ x == 3</code> is a function that takes a number and returns a monoid value: a <code class="literal">Bool</code> wrapped in <code class="literal">Any</code>. <code class="literal">foldMap</code> applies this function to every element in our tree and then reduces the resulting monoids into a single monoid with <code class="literal">mappend</code>. Suppose we do this:<a id="IDX-CHP-12-0100" class="indexterm"/><a id="IDX-CHP-12-0101" class="indexterm"/><a id="IDX-CHP-12-0102" class="indexterm"/></p><a id="I_programlisting12_d1e24164"/><pre class="programlisting">ghci&gt; getAny $ F.foldMap (\x -&gt; Any $ x &gt; 15) testTree
False</pre><p>All of the nodes in our tree will hold the value <code class="literal">Any False</code> after having the function in the lambda applied to them. But to end up <code class="literal">True</code>, <code class="literal">mappend</code> for <code class="literal">Any</code> must have at least one <code class="literal">True</code> value as a parameter. That’s why the final result is <code class="literal">False</code>, which makes sense because no value in our tree is greater than <code class="literal">15</code>.</p><p>We can also easily turn our tree into a list by doing a <code class="literal">foldMap</code> with the <code class="literal">\x -&gt; [x]</code> function. By first projecting that function onto our tree, each element becomes a singleton list. The <code class="literal">mappend</code> action that takes place between all those singleton lists results in a single list that holds all of the elements that are in our tree:</p><a id="I_programlisting12_d1e24202"/><pre class="programlisting">ghci&gt; F.foldMap (\x -&gt; [x]) testTree
[1,3,6,5,8,9,10]</pre><p>What’s cool is that all of these tricks aren’t limited to trees. They work on any instance of <code class="literal">Foldable</code>!</p></div></body></html>