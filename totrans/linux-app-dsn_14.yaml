- en: '![](../images/267-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[**DESIGNING AN SNMP MIB**](toc.html#chapter14)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/as.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you read the previous chapter, you already have some idea of why you may
    need an SNMP interface and how it can be useful. In this chapter and the next,
    you’ll see how the information specific to an appliance can be added to this interface.
    Like the web, LCD, and CLI interfaces, the SNMP interface will also be based on
    the information available from RTA tables within the Laddie application itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is concerned primarily with the design of the MIB and creation
    of a valid MIB file. The topics covered here are:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying for an enterprise number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the MIB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the MIB file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating the MIB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will learn how to implement the agent in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Our Goal**](toc.html#chapter14.1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Chapter 5 you saw several of the Laddie application’s user interfaces to
    the ZONE structure: framebuffer, CLI, and web. Here’s the ZONE struct from the
    Laddie source:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/268-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-1 shows how this looked in the RTA table editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/268-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: The ZONE struct in the RTA table editor*'
  prefs: []
  type: TYPE_NORMAL
- en: Jumping ahead a bit, this is how the same information will look in our SNMP
    interface when we’re done designing and implementing our MIB.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/268-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our task in this chapter and the next is to show you how to go from the ZONE
    struct to the above SNMP interface, step by step. When we are done, you should
    understand how to do the same thing in your own application, doing a fair amount
    of cutting and pasting from this MIB.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we did not include the *id*, *edge*, and *input* columns
    in our SNMP view of this table. This was not an oversight. It is up to the MIB
    designer (or any interface designer, for that matter) to decide what makes sense
    in light of the intended use of the interface. In our case, we decided that the
    *edge* and *input* information was too hardware specific to be necessary in this
    interface. The *id* column is not returned by our SNMP agent, but will be used
    as an index into the alarm table whenever access to a specific row is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Your Enterprise Number**](toc.html#chapter14.2)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that your interest is piqued, we’ll build suspense by taking a little detour
    for those of you actually in the process of starting a small company to sell your
    appliance. You may remember the brief discussion about enterprise numbers in the
    last chapter when we were identifying a printer using SNMP. Every MIB needs to
    be anchored to the overall namespace, and if you are designing a private MIB,
    you need an enterprise number of your own. These are assigned by IANA (Internet
    Assigned Numbers Authority). Each company or organization only needs one enterprise
    number because IANA grants you the authority to manage the tree beneath your number.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining an enterprise number from IANA may take awhile, so you should get
    the ball rolling early. Once you apply, IANA will tell you to expect the process
    to take about a month. You can design and implement your MIB while IANA is processing
    your request.
  prefs: []
  type: TYPE_NORMAL
- en: The process itself is pretty easy. Just use your favorite web browser to navigate
    to the IANA website ([http://www.iana.org](http://www.iana.org/)) and click **Application
    Forms** in the menu. On the next page, select **Private Enterprise Numbers (SNMP)**.
    You’ll be presented with an online form to fill out.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the web page, there’s a link to the current list of registered
    numbers. You might want to check it out just to see who’s on the list. You’ll
    notice some pretty recognizable names near the beginning; these companies have
    been in the SNMP game since the beginning. IBM’s number is 2\. Cisco has 9\. Hewlett
    Packard has 11\. You can scroll down to the bottom to see what the current high
    number is. You might also recognize the entry at number 23528\. It is the start
    of the subtree where we will anchor the Laddie MIB we will develop in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you start your application, you will be asked to provide the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: Your company or organization name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The company’s address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The company’s phone number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the contact person
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contact person’s address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contact person’s phone number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contact person’s email address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fax number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you may have noticed when looking at the current list, only the enterprise
    number, company name, contact person’s name, and contact’s email address are listed
    online. It’s a good idea to use something other than your general email address
    here, since it’s likely that spambots will harvest it. It’s handy to have a separate
    address for this purpose, something generic you can forward to whomever is responsible
    for your SNMP work in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Just enter your information in the form and click the **Submit Application**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: '[**The MIB Files**](toc.html#chapter14.3)'
  prefs: []
  type: TYPE_NORMAL
- en: IANA grants you the authority to manage your own subtree, but it’s up to you
    to do a good job of it. Plan for success and don’t think of this appliance as
    the end of the line—leave room for expansion. You might want to define your enterprise
    number in a separate file where you can put information common to all your MIBs.
    (By the way, reading other people’s MIBs is a very good idea. You’ll find out
    what is common usage and you may pick up styles you find attractive along the
    way.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the two files we’ll be creating in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LADDIE-GROUP-SMI.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: This is the file where we’ll define the Laddie Group enterprise number and our
    product identification OIDs.¹
  prefs: []
  type: TYPE_NORMAL
- en: '**LAD-MIB.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: This file will hold the Laddie product MIB. This MIB will be anchored under
    an OID defined in the LADDIE-GROUP-SMI.txt file.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll run these files through a utility supplied by Net-SNMP to produce skeleton
    code for our MIB implementation. You’ll also want these files on any system that
    will be running the management applications (snmpget, snmpset, snmpwalk, and so
    on) or interpreting traps and informs.
  prefs: []
  type: TYPE_NORMAL
- en: The network management system you are using will define where you place these
    files. The Net-SNMP management applications tend to want them in the directory
    /usr/local/share/snmp/mibs, though you can modify this, and it’s subject to the
    preferences of the OS distribution you are using. For our appliance we will place
    them in /opt/snmp/share/snmp/mibs.
  prefs: []
  type: TYPE_NORMAL
- en: '[**LADDIE-GROUP-SMI**](toc.html#chapter14.4)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the file that describes the top-level structure we will be using to
    organize our Laddie enterprise subtree. It holds our enterprise number and product
    identification OID. This file is small, so let’s look at the whole thing and then
    discuss its structure. (The address, phone number, and fax number are bogus to
    protect Bob’s privacy, but you’ll get the general idea.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/271-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now let’s go through this file again in more detail. We’ll show you a section
    of the MIB file first and then discuss it. The best way to read this is to scan
    the MIB text briefly, then read the description while referring to the MIB text.
  prefs: []
  type: TYPE_NORMAL
- en: LADDIE-GROUP-SMI DEFINITIONS ::= BEGIN
  prefs: []
  type: TYPE_NORMAL
- en: This line gives the MIB a name and tells the reader (human or program) that
    this is the beginning of our definitions for this MIB. Look for a matching END
    at the bottom of the file to tell the reader when all definitions are complete.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/272-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The IMPORTS section is like the #include section in a C program—it tells where
    to find the terms used in this MIB but not defined here. We included ![](../images/1.jpg)
    the MODULE-IDENTITY macro and ![](../images/2.jpg) the enterprises for use below.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we defined the laddieGroup module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/272-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The funny-looking string in the LAST-UPDATED and REVISION lines is a time stamp
    specifying the year, month, day, hour, and minute of the last change or revision.
    The *Z* stands for GMT (Greenwich Mean Time), sometimes called *Zulu Time.* The
    hours and minutes are generally zeros, because no one really cares what hour and
    minute a revision was made. The ![](../images/1.jpg) number “200702220000Z” means
    February 22, 2007\. With separators, it would look like this: 2007-02-22 00:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/272-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is where we’ll anchor the LAD-MIB we’ll be defining in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '-- Products are registered here:'
  prefs: []
  type: TYPE_NORMAL
- en: laddieProducts OBJECT IDENTIFIER ::= { laddieGroup 2 }
  prefs: []
  type: TYPE_NORMAL
- en: laddieAppliance OBJECT IDENTIFIER ::= { laddieProducts 1 }
  prefs: []
  type: TYPE_NORMAL
- en: The laddieProducts section is where we defined the OIDs that identify our products
    (or entire product lines, if you’re thinking really big). We have defined an OID
    for our Laddie appliance here, and we’ll be setting sysObjectID in MIB-2² to this
    value on our appliances. This will allow someone polling the box with an SNMP
    utility like snmpget to determine that this box is a Laddie appliance. Large corporations
    may put the OIDs that identify all their products into a single file. Cisco, for
    example, has a CISCO-PRODUCTS file where it gathers all these OIDs. For now, Laddie
    only has a single product OID, so we won’t go to this trouble.
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: Here’s that END we were looking for. This is the end of the LADDIE-SMI-MIB.txt
    file and wraps up our discussion of it.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Creating the LAD-MIB**](toc.html#chapter14.5)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll create our appliance MIB. Refer to the illustration of
    the LAD-MIB structure in Figure 14-2 for a better idea of how the MIB components
    interrelate. It may be helpful to refer to this picture as you follow along with
    the development of the MIB file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The LAD-MIB is divided into three main sections:'
  prefs: []
  type: TYPE_NORMAL
- en: ladTraps, containing definitions of traps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ladTrapInfo, containing definitions of information objects sent in traps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ladSystem, containing definitions of pollable objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start the detailed walk-through. Again, we’ll be showing one or more lines
    followed by a discussion of what we’ve shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with the BEGIN statement and the definition of our MIB name:'
  prefs: []
  type: TYPE_NORMAL
- en: LAD-MIB DEFINITIONS ::= BEGIN
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully this looks familiar. If not, take another look at the beginning of
    the LADDIE-GROUP-SMI.txt file. The BEGIN line says we are starting the definition
    of the LAD-MIB, which is the name we gave the MIB for our appliance.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/274-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: LAD-MIB Structure*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll import the externally defined types and macros that we will be
    using from other files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/274-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first set comes from ![](../images/1.jpg) SNMPv2-SMI just like in the LADDIE-GROUP-SMI.txt
    file we covered in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The next set comes from ![](../images/2.jpg) SNMPv2-TC. The letters *TC* stand
    for *textual conventions.* SNMPv2-TC is basically a file that defines new, commonly
    used object types.
  prefs: []
  type: TYPE_NORMAL
- en: The ![](../images/3.jpg) laddieMgmt OID from the LADDIE-GROUP-SMI.txt file will
    be our starting point in the overall namespace for our appliance MIB. We’ll use
    laddieMgmt as our link to the overall namespace by defining the module in this
    group below laddieMgmt in the code portion of the “Module Definition” section
    next.
  prefs: []
  type: TYPE_NORMAL
- en: The SNMPv2-SMI and SNMPv2-TC MIB definitions are supplied with the Net-SNMP
    package. When you installed Net-SNMP on your system in the Chapter 13, these files
    were probably put into either /usr/share/snmp/mibs or /usr/local/share/snmp/mibs.
    Look for the files SNMPv2-SMI.txt and SNMPv2-TC.txt there.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Module Definition***](toc.html#chapter14.6)'
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a module, ladProject, to contain our appliance MIB. This
    is where we put the copyright, revision history, contact information, and a general
    description of what the module contains.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/275-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The MODULE-IDENTITY section is like one long sentence. The first and last lines,
    taken together, say that ladProject is a module defined directly below ![](../images/3.jpg)
    laddieMgmt in the namespace and that its OID is laddieMgmt.1\. Here’s the OID
    in numeric form:'
  prefs: []
  type: TYPE_NORMAL
- en: .1.3.6.1.4.1.3382.1
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the MODULE-IDENTITY section should be fairly clear after our discussion
    of the LADDIE-SMI in the previous section. You may notice that we have two REVISION
    clauses listed at lines ![](../images/1.jpg) and ![](../images/2.jpg). If you
    make changes to your MIB in the future, you will need to add revision clauses
    to explain what you did. The convention is to keep revision clauses in reverse-chronological
    order (that is, the most recent change appears at the top). This does not mean
    you should feel free to make any changes you want to your MIB; you will just be
    creating confusion for your customers if you change anything (names, OIDs, and
    so on) that is already defined in your MIB. You may, however, find it necessary
    to enhance your MIB with new information required by customer demand or to help
    manage new features you’ll be adding to your appliance. You may add new structure,
    but do not change existing structure!
  prefs: []
  type: TYPE_NORMAL
- en: Clearly your LAST-UPDATED time stamp will match that of your most recent revision
    clause, as ours does above.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next set of lines defines the sections we will be fleshing out later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/276-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Putting all of the section heading OIDs together at the top, as we have done
    here, is a stylistic choice we feel can help communicate the structure of the
    rest of the MIB. We’re making it clear that there will be a section for defining
    traps, one for system information (where we will be putting our Alarm Table),
    and another section for the non-pollable information we will only send along with
    traps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Numbering in SNMP usually begins with 1, not zero, but you may have noticed
    that we gave ![](../images/1.jpg) the ladTraps section above the OID of ladProject.0\.
    Our reason for doing this dates back to the early days of SNMPv2 (SNMP version
    2), when compatibility with SNMPv1 (SNMP version 1) was being crafted. For more
    details, you may want to read *RFC 1908: Coexistence between Version 1 and Version
    2 of the Internet-Standard Network Management Framework.*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll continue our review of our MIB with the ladSystem section and leave the
    traps for later. That will allow us to immediately follow our discussion of the
    trap with the ladTrapInfo section.
  prefs: []
  type: TYPE_NORMAL
- en: -- LAD System Information
  prefs: []
  type: TYPE_NORMAL
- en: ladSystemScalars OBJECT IDENTIFIER ::= { ladSystem 1 }
  prefs: []
  type: TYPE_NORMAL
- en: ladSystemTables OBJECT IDENTIFIER ::= { ladSystem 2 }
  prefs: []
  type: TYPE_NORMAL
- en: Here we further subdivide the ladSystem section into a section for scalars and
    another for tables. *Scalars* are just objects that are not columns in tables.
    Experience has taught us to keep scalars and tables separate to avoid having scalars
    sprinkled around between tables as the MIB evolves over time.
  prefs: []
  type: TYPE_NORMAL
- en: '[***Version and Number of Zones***](toc.html#chapter14.7)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll define some scalars in our ladSystemScalars section.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/277-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we have defined two objects (note the OBJECT-TYPE keyword): ladVersion
    and ladNumberOfZones. The SYNTAX clause tells us that ladVersion is a DisplayString,
    meaning it is represented as a string of displayable (printable) characters, and
    ladNumberOfZones is a 32-bit integer with values ranging from 1 through 128\.
    If you refer back to our IMPORT section at the start of this MIB, you will see
    that both of these syntaxes were imported from SNMPv2-TC, the textual conventions
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: The MAX-ACCESS clause tells us that each of these objects is read-only. Some
    objects we will encounter later in this MIB will have read-write, not-accessible,
    or accessible-for-notify access. *Read-write* just means you can read the object’s
    value as well as write a new value. You can’t read or write objects defined as
    *not-accessible*, but you might use one as an index into a table. *Accessible-for-notify*
    is how we define information sent with a trap but that otherwise is not pollable.
  prefs: []
  type: TYPE_NORMAL
- en: One point to keep in mind here is that the MAX-ACCESS clause defines *maximum*
    access, not *actual* access. You will never be able to write an object that has
    max-access read-only, but you may not be able to write to an object whose max-access
    is read-write, either. The ability to write to the object may be restricted by
    other factors. For example, in Net-SNMP, you may not write to any object that
    has a value set in the snmpd.conf file, regardless of what the MAX-ACCESS clause
    indicates in the MIB file.
  prefs: []
  type: TYPE_NORMAL
- en: The STATUS clause indicates that both objects are current, that is, they are
    are valid objects in this version of the MIB. To remove an object from a MIB,
    you would make its status deprecated. This is a brand new MIB, so nothing is deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: The DESCRIPTION clause is intended specifically for the human reader of the
    MIB, rather than a computer program. It should contain a brief description of
    the object. It might also contain possible uses of the value and any caveats the
    reader may need to know.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line of each section defines the OID. The ::= means *is defined as.*
    Each OID is described as appending to a previous OID. The ladNumberOfZones object’s
    OID is the same as ladSystemScalars with a *2* appended to the end. Its whole
    numeric OID looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: .1.3.6.1.4.1.23528.1.1.1.1.2
  prefs: []
  type: TYPE_NORMAL
- en: 'The first six numbers in this string are from standard MIBs and can be read
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: .iso(1).org(3).dod(6).internet(1).private(4).enterprises(1)
  prefs: []
  type: TYPE_NORMAL
- en: The next number is where IANA gave us our own enterprise number, 23528\. So
    after enterprises, the rest of the OID continues
  prefs: []
  type: TYPE_NORMAL
- en: laddieGroup.laddieMgmt.ladProject.ladSystem.ladSystemScalars.ladNumberOfZones
  prefs: []
  type: TYPE_NORMAL
- en: See Figure 14-3 for the correspondence between each number in the OID and its
    descriptive name.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/278-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: OID for ladNumberOfZones*'
  prefs: []
  type: TYPE_NORMAL
- en: '[***The Alarm Table***](toc.html#chapter14.8)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the core of our MIB: the Alarm Table. This is the table we displayed
    at the beginning of this chapter, showing the zones and alarm states. Here is
    how we define this table in our MIB:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/279-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that we have three blocks of definition above: ladAlarmTable, ladAlarmEntry,
    and LadAlarmEntry. SNMP requires that all object names begin with a lowercase
    letter (hence, ladAlarmTable, ladAlarmEntry). However, LadAlarmEntry is not an
    object, but rather a definition of the syntax of the table entry. It is common
    practice to define the *syntax* of a table with the same name as the table entry,
    but starting with an uppercase letter (*l*adAlarmEntry versus *L*adAlarmEntry).
    The syntax of ladAlarmTableEntry is a sequence (list or array) of other object
    types which are the columns in the table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the definition of the table entry syntax, we’ll list the detailed definitions
    of each of the columns listed in the SEQUENCE clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/279-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../images/280-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The MAX-ACCESS clause in each of these objects defines how it may be used. We
    have made ladAlarmZoneId not-accessible because we will only be using it to index
    into the table to read or write the other values. Notice that ladAlarmEnable,
    ladAlarmLatching, and ladAlarmState are read-write, but ladAlarmZoneName is read-only.
    We wanted to be able to use SNMP commands to enable or disable alarms, change
    whether or not they latch, and clear alarms by setting their state to false. We
    felt, however, that changing the name of a zone is a static configuration that
    should be done through another interface, like the web interface or the CLI. The
    ladAlarmCount is a history of the number of times the alarm has triggered, so
    we have made this read-only.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing mandatory about the MAX-ACCESS choices we have made here. You
    might well disagree with some of these choices and design your MIB differently.
    Look at the SNMP display of the Zone structure in the section “Our Goal” on page
    244\. Had we defined our ladAlarmZoneId as readable, you would see the row number
    at the start of each row right before the zone name. We also could have defined
    the count field as writable so you could reset it to zero periodically; this would
    allow you to see how many times the alarm has triggered over a period without
    having to save the old value and subtract it from the new one. These choices belong
    to the designer.
  prefs: []
  type: TYPE_NORMAL
- en: '[***The Traps***](toc.html#chapter14.9)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s leave the Alarm Table and move on to our traps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/281-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have included two traps: one to raise a red flag when an intrusion has been
    detected and the other to let you know when everything has returned to normal.
    These look a lot like the OBJECT-TYPE definitions above, but we use NOTIFICATION-TYPE
    for traps.'
  prefs: []
  type: TYPE_NORMAL
- en: The OBJECTS clause in the ladAlarm trap definition tells what other information
    will accompany the trap. This is often called the varbind list, for *var*iable
    *bind*ings. These variables, which explain why the trap was sent, are bound to
    the trap when it is sent.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/282-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These are the definitions of the objects in our varbind list. The MAX-ACCESS
    of these is set to accessible-for-notify, meaning they cannot be polled; they
    merely define the objects for the benefit of the trap receiver. These objects
    only have meaning when attached to a trap.
  prefs: []
  type: TYPE_NORMAL
- en: Early SNMP documents (RFCs) were created with concern for keeping SNMP traffic
    to a minimum to prevent burdening networks with extra traffic. Traps were intended
    just to draw attention to a possible problem; you were supposed to poll the device
    for specifics about what was wrong. Today, however, some network administrators
    use trap logs as a history of what’s been happening on the device. They want all
    pertinent information sent with the trap and logged by the trap-receiving software.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also want to take care that your device doesn’t become too chatty with
    its traps. Laddie is unlikely to have this problem, but if you are building an
    appliance intended to sit on a major corporate, ISP, or carrier network, you had
    better consider this. If you check for error conditions every minute and generate
    a trap each time some measure is over an acceptable threshold, an appliance that
    notices an error on Friday night will be able to send about 3,500 traps by Monday
    morning, all reporting the same problem. Any other problem from a different device
    will be lost in the jabber. You may want to just report the problem once when
    it is first noticed, then send another trap to indicate when the problem is corrected.
  prefs: []
  type: TYPE_NORMAL
- en: The argument in favor of sending lots of traps is that SNMP is unreliable by
    design. It uses UDP packets to report problems with the assumption that any problem
    of importance will be noticed more than once, so the loss of a single trap will
    not be a problem. If you can’t be sure your trap was received, you had better
    keep sending it until someone notices, right? Well, that’s one approach. Another
    is just to use informs instead of traps. *Informs* became available with SNMPv2
    and are essentially traps with some built-in reliability. Informs expect a confirmation
    message from the receiver and will retry some number of times if they don’t see
    the confirm. If this isn’t good enough for you, then you might want to consider
    some reduced frequency schedule for resending your trap if your device has not
    received some attention.
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, there’s the END marker that signals the end of the MIB.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Validating Your MIB**](toc.html#chapter14.10)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the MIB has been written, we need to test it for validity. The MIB
    must be not only human-readable, but machine parse-able. The syntax of a MIB must
    be as correct as the syntax of a computer program, or the applications using the
    MIB will be unable to interpret it. Lucky for us, multiple free MIB validators
    are available online. All you need is a browser and your MIB files. There’s always
    the risk that any online resources discussed here may be unavailable by the time
    you read this book, but the one we will be using here is on the SimpleWeb website,
    shown in Figure 14-4\. You can find it at [http://wwwsnmp.cs.utwente.nl/ietf/mibs/validate](http://wwwsnmp.cs.utwente.nl/ietf/mibs/validate).
    It has been around since 1997 and is run by the Universiteit Twente in the Netherlands.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/283-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: The SimpleWeb MIB validator*'
  prefs: []
  type: TYPE_NORMAL
- en: Another free validator we have used is the one provided by Muonics at [http://www.muonics.com/Tools/smicheck.php](http://www.muonics.com/Tools/smicheck.php).
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you do not skip the validation step! If you don’t get the syntax of
    your MIB exactly right, nothing will work for you from here on.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Summary**](toc.html#chapter14.11)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you have seen how to apply for an enterprise number, develop
    an MIB, and validate that MIB. The hard part is trying to design the MIB structure
    to accommodate future changes. Our task for Laddie has been fairly simple because
    our whole MIB revolves around a simple RTA table, and the MIB is unlikely to evolve
    much over time. A designer working on a MIB for a real appliance doesn’t have
    it so easy. We suggest thinking about the basic types of information you may need
    to have, regardless of what direction your product takes in the future. For example,
    you may have:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Historical information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miscellaneous run-time states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance measures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service or resource saturation levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may guide you in structuring your MIB to make your life easier as future
    demands are made on you and your MIB.
  prefs: []
  type: TYPE_NORMAL
- en: __________________
  prefs: []
  type: TYPE_NORMAL
- en: ¹ OIDs used to identify products are returned as the value of sysObjectId in
    MIB-2.
  prefs: []
  type: TYPE_NORMAL
- en: ² You can find sysObjectID defined in the SNMPv2-MIB.txt file, which is included
    with the Net-SNMP package.
  prefs: []
  type: TYPE_NORMAL
