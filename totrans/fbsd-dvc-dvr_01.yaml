- en: Chapter 1. Building and Running Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 构建和运行模块
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
- en: This chapter provides an introduction to FreeBSD device drivers. We’ll start
    by describing the four different types of UNIX device drivers and how they are
    represented in FreeBSD. We’ll then describe the basics of building and running
    loadable kernel modules, and we’ll finish this chapter with an introduction to
    character drivers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 FreeBSD 设备驱动程序。我们将从描述四种不同的 UNIX 设备驱动程序及其在 FreeBSD 中的表示开始。然后，我们将描述构建和运行可加载内核模块的基本知识，并以字符驱动程序的介绍结束本章。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t understand some of the terms used above, don’t worry; we’ll define
    them all in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不理解上述术语中的一些，不要担心；我们将在本章中定义它们所有。
- en: Types of Device Drivers
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备驱动程序类型
- en: 'In FreeBSD, a *device* is any hardware-related item that belongs to the system;
    this includes disk drives, printers, video cards, and so on. A *device driver*
    is a computer program that controls or “drives” a device (or sometimes numerous
    devices). In UNIX and pre-4.0 FreeBSD, there are four different types of device
    drivers:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FreeBSD 中，*设备* 是属于系统的任何与硬件相关的项目；这包括磁盘驱动器、打印机、显卡等。*设备驱动程序* 是一个控制或“驱动”设备（有时是多个设备）的计算机程序。在
    UNIX 和 4.0 以前的 FreeBSD 中，有四种不同类型的设备驱动程序：
- en: Character drivers, which control character devices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符驱动程序，用于控制字符设备
- en: Block drivers, which control block devices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块驱动程序，用于控制块设备
- en: Network drivers, which control network devices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络驱动程序，用于控制网络设备
- en: Pseudo-device drivers, which control pseudo-devices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟设备驱动程序，用于控制模拟设备
- en: '*Character devices* provide either a character-stream-oriented I/O interface
    or, alternatively, an unstructured (raw) interface (McKusick and Neville-Neil,
    2005).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符设备* 提供基于字符流的 I/O 接口，或者，也可以提供非结构化（原始）接口（McKusick 和 Neville-Neil，2005）。'
- en: '*Block devices* transfer randomly accessible data in fixed-size blocks (Corbet
    et al., 2005). In FreeBSD 4.0 and later, block drivers are gone (for more information
    on this, See [Block Drivers Are Gone](ch01s07.html "Block Drivers Are Gone") in
    [DEV_MODULE Macro](ch01s06.html#dev_underscore_module_macro "DEV_MODULE Macro")).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*块设备* 以固定大小的块随机访问数据（Corbet 等，2005）。在 FreeBSD 4.0 及以后的版本中，块驱动程序已不存在（有关更多信息，请参阅[块驱动程序已消失](ch01s07.html
    "块驱动程序已消失")中的[DEV_MODULE 宏](ch01s06.html#dev_underscore_module_macro "DEV_MODULE
    宏")）。'
- en: '*Network devices* transmit and receive data packets that are driven by the
    network subsystem (Corbet et al., 2005).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*网络设备* 通过网络子系统传输和接收由网络子系统驱动的数据包（Corbet 等，2005）。'
- en: Finally, a *pseudo-device* is a computer program that emulates the behavior
    of a device using only software (that is, without any underlying hardware).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*模拟设备* 是一个仅使用软件（即没有任何底层硬件）模拟设备行为的计算机程序。
- en: Loadable Kernel Modules
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可加载内核模块
- en: A device driver can be either statically compiled into the system or dynamically
    loaded using a loadable kernel module (KLD).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序可以是静态编译到系统中，也可以是使用可加载内核模块（KLD）动态加载的。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most operating systems call a loadable kernel module an *LKM*—FreeBSD just had
    to be different.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统将可加载内核模块称为 *LKM*——FreeBSD 只能有所不同。
- en: A *KLD* is a kernel subsystem that can be loaded, unloaded, started, and stopped
    after bootup. In other words, a KLD can add functionality to the kernel and later
    remove said functionality while the system is running. Needless to say, our “functionality”
    will be device drivers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*KLD* 是一个可以在系统启动后加载、卸载、启动和停止的内核子系统。换句话说，KLD 可以在系统运行时向内核添加功能，并在之后移除这些功能。不用说，我们的“功能”将是设备驱动程序。'
- en: 'In general, two components are common to all KLDs:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有 KLD 都有两个共同组件：
- en: A module event handler
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块事件处理器
- en: A `DECLARE_MODULE` macro call
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DECLARE_MODULE` 宏调用'
- en: Module Event Handler
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块事件处理器
- en: 'A *module event handler* is the function that handles the initialization and
    shutdown of a KLD. This function is executed when a KLD is loaded into the kernel
    or unloaded from the kernel, or when the system is shut down. Its function prototype
    is defined in the `<sys/module.h>` header as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块事件处理器* 是处理 KLD 初始化和关闭的函数。当 KLD 被加载到内核或从内核卸载，或者系统关闭时，该函数会被执行。其函数原型在 `<sys/module.h>`
    头文件中定义如下：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `modeventtype_t`
    is defined in the `<sys/module.h>` header like so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`modeventtype_t` 在 `<sys/module.h>` 头文件中定义如下：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, `modeventtype_t` labels whether the KLD is being ![](httpatomoreillycomsourcenostarchimages1137499.png)
    loaded into the kernel or ![](httpatomoreillycomsourcenostarchimages1137501.png)
    unloaded from the kernel, or whether the system is about to ![](httpatomoreillycomsourcenostarchimages1137503.png)
    shut down. (For now, ignore the value at ![](httpatomoreillycomsourcenostarchimages1137505.png);
    we’ll discuss it in [Chapter 4](ch04.html "Chapter 4. Thread Synchronization").)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，`modeventtype_t`标签表示KLD正在被加载到内核中，或从内核卸载，或者系统即将关闭。（现在忽略该值；我们将在[第4章](ch04.html
    "第4章。线程同步")中讨论。） '
- en: 'Generally, you’d use the `modeventtype_t` argument in a `switch` statement
    to set up different code blocks for each situation. Some example code should help
    clarify what I mean:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会在`switch`语句中使用`modeventtype_t`参数来为每种情况设置不同的代码块。一些示例代码可以帮助阐明我的意思：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice how the ![](httpatomoreillycomsourcenostarchimages1137499.png) second
    argument is the ![](httpatomoreillycomsourcenostarchimages1137501.png) expression
    for the `switch` statement. Thus, this module event handler prints “Hello, world!”
    when the KLD is ![](httpatomoreillycomsourcenostarchimages1137503.png) loaded
    into the kernel, prints “Good-bye, cruel world!” when the KLD is ![](httpatomoreillycomsourcenostarchimages1137505.png)
    unloaded from the kernel, and returns `EOPNOTSUPP` (which stands for *error: operation
    not supported*) prior to ![](httpatomoreillycomsourcenostarchimages1137507.png)
    system shutdown.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第二个参数是如何作为`switch`语句的表达式。因此，当KLD被加载到内核中时，此模块事件处理器会打印“Hello, world!”；当KLD从内核卸载时，会打印“Good-bye,
    cruel world!”；在系统关闭之前返回`EOPNOTSUPP`（代表错误：不支持的操作）。
- en: DECLARE_MODULE Macro
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DECLARE_MODULE 宏
- en: 'The `DECLARE_MODULE` macro registers a KLD and its module event handler with
    the system. Here is its function prototype:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`DECLARE_MODULE`宏将KLD及其模块事件处理器注册到系统中。以下是它的函数原型：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The arguments expected by this macro are as follows.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏期望的参数如下。
- en: name
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: name
- en: The `name` argument is the module name, which is used to identify the KLD.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`参数是模块名称，用于标识KLD。'
- en: data
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: data
- en: 'The `data` argument expects a filled-out `moduledata_t` structure, which is
    defined in the `<sys/module.h>` header as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`参数期望一个填充好的`moduledata_t`结构，该结构在`<sys/module.h>`头文件中定义如下：'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `name` is the official
    module name, ![](httpatomoreillycomsourcenostarchimages1137501.png) `evhand` is
    the KLD’s module event handler, and ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `priv` is a pointer to private data (if any exists).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`name`是官方模块名称，`evhand`是KLD的模块事件处理器，`priv`是指向私有数据（如果存在）的指针。
- en: sub
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sub
- en: The `sub` argument specifies the kernel subsystem that the KLD belongs in. Valid
    values for this argument are defined in the `sysinit_sub_id` enumeration, found
    in `<sys/kernel.h>`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub`参数指定了KLD所属的内核子系统。此参数的有效值在`sysinit_sub_id`枚举中定义，该枚举位于`<sys/kernel.h>`头文件中。'
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For obvious reasons, we’ll almost always set `sub` to ![](httpatomoreillycomsourcenostarchimages1137499.png)
    `SI_SUB_DRIVERS`, which is the device driver subsystem.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于显而易见的原因，我们几乎总是将`sub`设置为`SI_SUB_DRIVERS`，这是设备驱动程序子系统。
- en: order
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: order
- en: The `order` argument specifies the KLD’s order of initialization within the
    `sub` subsystem. Valid values for this argument are defined in the `sysinit_elem_order`
    enumeration, found in `<sys/kernel.h>`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`order`参数指定了KLD在`sub`子系统中的初始化顺序。此参数的有效值在`sysinit_elem_order`枚举中定义，该枚举位于`<sys/kernel.h>`头文件中。'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In general, we’ll always set `order` to ![](httpatomoreillycomsourcenostarchimages1137499.png)
    `SI_ORDER_MIDDLE`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们都会将`order`设置为`SI_ORDER_MIDDLE`。
- en: Hello, world!
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello, world!
- en: You now know enough to write your first KLD. [Example 1-1](ch01s03.html#hello.c
    "Example 1-1. hello.c") is the complete skeleton code for a KLD.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经足够了解如何编写你的第一个KLD。[示例1-1](ch01s03.html#hello.c "示例1-1. hello.c")是KLD的完整骨架代码。
- en: Example 1-1. hello.c
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-1. hello.c
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code contains a ![](httpatomoreillycomsourcenostarchimages1137499.png)
    module event handler—it’s identical to the one described in [Module Event Handler](ch01s02.html#module_event_handler
    "Module Event Handler") in [Loadable Kernel Modules](ch01s02.html "Loadable Kernel
    Modules")—and a filled-out ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `moduledata_t` structure, which is passed as the ![](httpatomoreillycomsourcenostarchimages1137505.png)
    second argument to the ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `DECLARE_MODULE` macro.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含一个![模块](httpatomoreillycomsourcenostarchimages1137499.png)模块事件处理程序——它与[模块事件处理程序](ch01s02.html#module_event_handler
    "模块事件处理程序")中描述的相同——以及一个填充好的![结构体](httpatomoreillycomsourcenostarchimages1137501.png)
    `moduledata_t`结构，该结构作为![参数](httpatomoreillycomsourcenostarchimages1137505.png)第二个参数传递给![宏](httpatomoreillycomsourcenostarchimages1137503.png)
    `DECLARE_MODULE`。
- en: In short, this KLD is just a module event handler and a `DECLARE_MODULE` call.
    Simple, eh?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这个KLD只是一个模块事件处理程序和一个`DECLARE_MODULE`调用。简单，对吧？
- en: Compiling and Loading
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和加载
- en: 'To compile a KLD, you can use the `<bsd.kmod.mk>` Makefile. Here is the complete
    Makefile for [Example 1-1](ch01s03.html#hello.c "Example 1-1. hello.c"):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译KLD，你可以使用`<bsd.kmod.mk>` Makefile。以下是[示例1-1](ch01s03.html#hello.c "示例1-1.
    hello.c")的完整Makefile：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `KMOD` is the KLD’s
    name and ![](httpatomoreillycomsourcenostarchimages1137501.png) `SRCS` is the
    KLD’s source files. Incidentally, I’ll adapt this Makefile to compile every KLD.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![模块](httpatomoreillycomsourcenostarchimages1137499.png) `KMOD`是KLD的名称，![源文件](httpatomoreillycomsourcenostarchimages1137501.png)
    `SRCS`是KLD的源文件。顺便提一下，我将调整这个Makefile来编译每个KLD。
- en: 'Now, assuming [Example 1-1](ch01s03.html#hello.c "Example 1-1. hello.c") and
    its Makefile are in the same directory, simply type `make`, and the compilation
    should proceed (very verbosely) and produce an executable named *hello.ko*, as
    shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设[示例1-1](ch01s03.html#hello.c "示例1-1. hello.c")及其Makefile位于同一目录中，只需输入`make`，编译过程（非常详细）将产生一个名为*hello.ko*的可执行文件，如下所示：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can then load and unload *hello.ko* with `kldload(8)` and `kldunload(8)`,
    respectively:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用`kldload(8)`和`kldunload(8)`分别加载和卸载*hello.ko*：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As an aside, with a Makefile that includes `<bsd.kmod.mk>`, you can use `make
    load` and `make unload` instead of `kldload(8)` and `kldunload(8)`, as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁白，如果你在Makefile中包含了`<bsd.kmod.mk>`，你可以使用`make load`和`make unload`来代替`kldload(8)`和`kldunload(8)`，如下所示：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Congratulations! You’ve now successfully loaded code into a live kernel. Before
    moving on, one additional point is also worth mentioning. You can display the
    status of any file dynamically linked into the kernel using `kldstat(8)`, like
    so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经成功将代码加载到运行中的内核中。在继续之前，还有一个额外的要点需要提及。你可以使用`kldstat(8)`动态显示任何链接到内核的文件的状态，如下所示：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the output is pretty self-explanatory. Now, let’s do something
    more interesting.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，输出相当直观。现在，让我们做一些更有趣的事情。
- en: Character Drivers
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符驱动程序
- en: '*Character drivers* are basically KLDs that create character devices. As mentioned
    previously, character devices provide either a character-stream-oriented I/O interface
    or, alternatively, an unstructured (raw) interface. These (*character-device*)
    *interfaces* establish the conventions for accessing a device, which include the
    set of procedures that can be called to do I/O operations (McKusick and Neville-Neil,
    2005). In short, character drivers produce character devices, which provide device
    access. For example, the `lpt(4)` driver creates the `/dev/lpt0` character device,
    which is used to access the parallel port printer. In FreeBSD 4.0 and later, most
    devices have a character-device interface.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符驱动*基本上是创建字符设备的KLD。如前所述，字符设备提供基于字符流的I/O接口，或者，作为替代，提供一个非结构化（原始）接口。这些（*字符设备*）*接口*建立了访问设备的规范，包括可以调用来执行I/O操作的程序集（McKusick和Neville-Neil，2005）。简而言之，字符驱动程序产生字符设备，提供设备访问。例如，`lpt(4)`驱动程序创建了`/dev/lpt0`字符设备，用于访问并行端口打印机。在FreeBSD
    4.0及以后的版本中，大多数设备都有一个字符设备接口。'
- en: 'In general, three components are common to all character drivers:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有字符驱动程序都有三个共同组件：
- en: The `d_foo` functions
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d_foo`函数'
- en: A character device switch table
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符设备交换表
- en: A `make_dev` and `destroy_dev` function call
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make_dev`和`destroy_dev`函数调用'
- en: d_foo Functions
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: d_foo 函数
- en: The `d_foo` functions, whose function prototypes are defined in the `<sys/conf.h>`
    header, are the I/O operations that a process can execute on a device. These I/O
    operations are mostly associated with the file I/O system calls and are accordingly
    named `d_open`, `d_read`, and so on. A character driver’s `d_foo` function is
    called when “foo” is done on its device. For example, `d_read` is called when
    a process reads from a device.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`d_foo` 函数，其函数原型在 `<sys/conf.h>` 头文件中定义，是进程可以在设备上执行 I/O 操作。这些 I/O 操作大多与文件 I/O
    系统调用相关联，因此命名为 `d_open`、`d_read` 等。当对字符设备的“foo”操作完成时，会调用字符驱动程序的 `d_foo` 函数。例如，当进程从设备读取时，会调用
    `d_read`。'
- en: '[Table 1-1](ch01s05.html#d_underscore_foo_functions-id1 "Table 1-1. d_foo Functions")
    provides a brief description of each `d_foo` function.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-1](ch01s05.html#d_underscore_foo_functions-id1 "表 1-1. d_foo 函数") 提供了每个
    `d_foo` 函数的简要描述。'
- en: Table 1-1. d_foo Functions
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-1. d_foo 函数
- en: '| Function | Description |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `d_open` | Called to open the device in preparation for I/O operations |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `d_open` | 调用来打开设备以准备 I/O 操作 |'
- en: '| `d_close` | Called to close the device |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `d_close` | 调用来关闭设备 |'
- en: '| `d_read` | Called to read data from the device |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `d_read` | 调用来从设备读取数据 |'
- en: '| `d_write` | Called to write data to the device |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `d_write` | 调用来向设备写入数据 |'
- en: '| `d_ioctl` | Called to perform an operation other than a read or a write |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `d_ioctl` | 调用来执行除读取或写入之外的操作 |'
- en: '| `d_poll` | Called to check the device to see whether data is available for
    reading or space is available for writing |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `d_poll` | 调用来检查设备以查看是否可读取数据或是否有空间写入数据 |'
- en: '| `d_mmap` | Called to map a device offset into a memory address |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `d_mmap` | 调用来将设备偏移量映射到内存地址 |'
- en: '| `d_kqfilter` | Called to register the device with a kernel event list |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `d_kqfilter` | 调用来将设备注册到内核事件列表中 |'
- en: '| `d_strategy` | Called to start a read or write operation and then immediately
    return |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `d_strategy` | 调用来启动读取或写入操作然后立即返回 |'
- en: '| `d_dump` | Called to write all physical memory to the device |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `d_dump` | 调用来将所有物理内存写入设备 |'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t understand some of these operations, don’t worry; we’ll describe
    them in detail later when we implement them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不理解这些操作中的某些，请不要担心；我们将在实现它们时详细描述。
- en: Character Device Switch Table
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符设备切换表
- en: 'A character device switch table, `struct cdevsw`, specifies which `d_foo` functions
    a character driver implements. It is defined in the `<sys/conf.h>` header as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 字符设备切换表，`struct cdevsw`，指定了字符驱动程序实现了哪些 `d_foo` 函数。它在 `<sys/conf.h>` 头文件中定义如下：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is an example character device switch table for a read/write device:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个读写设备的示例字符设备切换表：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, not every `d_foo` function or attribute needs to be defined.
    If a `d_foo` function is undefined, the corresponding operation is unsupported
    (for example, a character device switch table for a read-only device would not
    define `d_write`).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，并非每个 `d_foo` 函数或属性都需要定义。如果一个 `d_foo` 函数未定义，相应的操作将不受支持（例如，只读设备的字符设备切换表不会定义
    `d_write`）。
- en: Unsurprisingly, `d_version` (which denotes the version of FreeBSD this driver
    supports) and `d_name` (which is the driver’s name) must be defined. Generally,
    `d_version` is set to `D_VERSION`, which is a macro substitution for whichever
    version of FreeBSD it’s compiled on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，`d_version`（表示该驱动程序支持的 FreeBSD 版本）和 `d_name`（即驱动程序的名字）必须定义。通常，`d_version`
    被设置为 `D_VERSION`，这是一个宏替换，用于编译时使用的 FreeBSD 版本。
- en: make_dev and destroy_dev Functions
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: make_dev 和 destroy_dev 函数
- en: 'The `make_dev` function takes a character device switch table and creates a
    character device node under */dev*. Here is its function prototype:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_dev` 函数接受一个字符设备切换表，并在 */dev* 下创建一个字符设备节点。以下是它的函数原型：'
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Conversely, the `destroy_dev` function takes the ![](httpatomoreillycomsourcenostarchimages1137499.png)
    `cdev` structure returned by `make_dev` and destroys the character device node.
    Here is its function prototype:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`destroy_dev` 函数接受由 `make_dev` 返回的 `cdev` 结构，并销毁字符设备节点。以下是它的函数原型：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Mostly Harmless
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大部分无害
- en: '[Example 1-2](ch01s06.html#echo.c "Example 1-2. echo.c") is a complete character
    driver (based on code written by Murray Stokely and Søren Straarup) that manipulates
    a memory area as though it were a device. This pseudo (or memory) device lets
    you write and read a single character string to and from it.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-2](ch01s06.html#echo.c "示例 1-2. echo.c") 是一个完整的字符驱动程序（基于 Murray Stokely
    和 Søren Straarup 编写的代码），它将内存区域操作得像设备一样。这个伪（或内存）设备允许您向其写入和从其读取单个字符字符串。'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Take a quick look at this code and try to discern some of its structure. If
    you don’t understand all of it, don’t worry; an explanation follows.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 快速看一下这段代码，并尝试辨别其结构。如果你不理解所有内容，不要担心；解释随后到来。
- en: Example 1-2. echo.c
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-2. echo.c
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This driver starts by ![](httpatomoreillycomsourcenostarchimages1137499.png)
    defining a character device switch table, which contains four `d_foo` functions
    named `echo_foo`, where `foo` equals to `open`, `close`, `read`, and `write`.
    Consequently, the ensuing character device will support only these four I/O operations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此驱动程序首先定义一个字符设备开关表，其中包含四个名为`echo_foo`的`d_foo`函数，其中`foo`等于`open`、`close`、`read`和`write`。因此，接下来的字符设备将仅支持这四种I/O操作。
- en: 'Next, there are two variable declarations: an `echo` structure pointer named
    ![](httpatomoreillycomsourcenostarchimages1137505.png) `echo_message` (which will
    contain a ![](httpatomoreillycomsourcenostarchimages1137501.png) character string
    and its ![](httpatomoreillycomsourcenostarchimages1137503.png) length) and a `cdev`
    structure pointer named ![](httpatomoreillycomsourcenostarchimages1137507.png)
    `echo_dev` (which will maintain the `cdev` returned by the ![](httpatomoreillycomsourcenostarchimages1137513.png)
    `make_dev` call).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有两个变量声明：一个名为`echo_message`的`echo`结构指针（它将包含一个字符字符串及其长度）和一个名为`echo_dev`的`cdev`结构指针（它将维护由`make_dev`调用返回的`cdev`）。
- en: Then, the `d_foo` functions ![](httpatomoreillycomsourcenostarchimages1137509.png)
    `echo_open` and ![](httpatomoreillycomsourcenostarchimages1137511.png) `echo_close`
    are defined—each just prints a debug message. Generally, the `d_open` function
    prepares a device for I/O, while `d_close` breaks apart those preparations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义了`d_foo`函数`echo_open`和`echo_close`——每个函数只是打印一个调试信息。通常，`d_open`函数为I/O准备设备，而`d_close`则取消这些准备。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a difference between “preparing a device for I/O” and “preparing (or
    initializing) a device.” For pseudo-devices like [Example 1-2](ch01s06.html#echo.c
    "Example 1-2. echo.c"), device initialization is done in the module event handler.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: “为I/O准备设备”与“准备（或初始化）设备”之间有区别。对于像[示例1-2](ch01s06.html#echo.c "示例1-2. echo.c")这样的伪设备，设备初始化是在模块事件处理程序中完成的。
- en: The remaining bits—`echo_write`, `echo_read`, `echo_modevent`, and `DEV_MODULE`—require
    a more in-depth explanation and are therefore described in their own sections.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的位——`echo_write`、`echo_read`、`echo_modevent`和`DEV_MODULE`——需要更深入的说明，因此将在各自的章节中描述。
- en: echo_write Function
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: echo_write 函数
- en: 'The `echo_write` function acquires a character string from user space and stores
    it. Here is its function definition (again):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo_write`函数从用户空间获取一个字符字符串并将其存储。以下是它的函数定义（再次）：'
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `struct uio` describes
    a character string in motion—the variables ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `iov_base` and ![](httpatomoreillycomsourcenostarchimages1137507.png) `iov_len`
    specify the character string’s base address and length, respectively.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`struct uio`描述了一个正在运动的字符字符串——变量`iov_base`和`iov_len`分别指定字符字符串的基址和长度。
- en: So, this function starts by ![](httpatomoreillycomsourcenostarchimages1137501.png)
    copying a character string from ![](httpatomoreillycomsourcenostarchimages1137503.png)
    user space to ![](httpatomoreillycomsourcenostarchimages1137505.png) kernel space.
    At most, ![](httpatomoreillycomsourcenostarchimages1137509.png) `'BUFFER_SIZE
    - 1'` bytes of data are copied. Once this is done, the character string is ![](httpatomoreillycomsourcenostarchimages1137511.png)
    null-terminated, and its length (minus the null terminator) is ![](httpatomoreillycomsourcenostarchimages1137513.png)
    recorded.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个函数首先将字符字符串从用户空间复制到内核空间。最多复制`'BUFFER_SIZE - 1'`个字节的数据。一旦完成，字符字符串被null终止，并且记录其长度（减去null终止符）。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This isn’t the proper way to copy data from user space to kernel space. I should’ve
    used `uiomove` instead of `copyin`. However, `copyin` is easier to understand,
    and at this point, I just want to cover the basic structure of a character driver.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是从用户空间复制数据到内核空间的正确方法。我应该使用`uiomove`而不是`copyin`。然而，`copyin`更容易理解，而且到目前为止，我只是想介绍字符驱动程序的基本结构。
- en: echo_read Function
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: echo_read 函数
- en: 'The `echo_read` function returns the stored character string to user space.
    Here is its function definition (again):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo_read`函数将存储的字符字符串返回到用户空间。以下是它的函数定义（再次）：'
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the variables ![](httpatomoreillycomsourcenostarchimages1137501.png) `uio_resid`
    and ![](httpatomoreillycomsourcenostarchimages1137505.png) `uio_offset` specify
    the amount of data remaining to be transferred and an offset into the character
    string, respectively.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，变量`uio_resid`和`uio_offset`分别指定剩余要传输的数据量和字符字符串中的偏移量。
- en: So, this function first ![](httpatomoreillycomsourcenostarchimages1137499.png)
    determines the number of characters to return—either the ![](httpatomoreillycomsourcenostarchimages1137501.png)
    amount the user requests or ![](httpatomoreillycomsourcenostarchimages1137503.png)
    all of it. Then `echo_read` ![](httpatomoreillycomsourcenostarchimages1137507.png)
    transfers that ![](httpatomoreillycomsourcenostarchimages1137511.png) number from
    ![](httpatomoreillycomsourcenostarchimages1137509.png) kernel space to ![](httpatomoreillycomsourcenostarchimages1137513.png)
    user space.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个函数首先确定要返回的字符数——要么是用户请求的量，要么是全部。然后`echo_read`将这个数量从内核空间传输到用户空间。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more on copying data between user and kernel space, see the `copy(9)` and
    `uio(9)` manual pages. I’d also recommend the OpenBSD `uiomove(9)` manual page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在用户空间和内核空间之间复制数据的更多信息，请参阅`copy(9)`和`uio(9)`手册页。我还推荐阅读OpenBSD的`uiomove(9)`手册页。
- en: echo_modevent Function
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: echo_modevent 函数
- en: 'The `echo_modevent` function is the module event handler for this character
    driver. Here is its function definition (again):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo_modevent`函数是此字符驱动程序的模块事件处理程序。以下是它的函数定义（再次）：'
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On module load, this function first calls ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `malloc` to allocate `sizeof(echo_t)` bytes of memory. Then it calls ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `make_dev` to create a character device node named ![](httpatomoreillycomsourcenostarchimages1137505.png)
    `echo` under */dev*. Note that when `make_dev` returns, the character device is
    “live” and its `d_foo` functions can be executed. Consequently, if I had called
    `make_dev` ahead of `malloc`, `echo_write` or `echo_read` could be executed before
    ![](httpatomoreillycomsourcenostarchimages1137499.png) `echo_message` points to
    valid memory, which would be disastrous. The point is: Unless your driver is completely
    ready, don’t call `make_dev`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块加载时，这个函数首先调用`malloc`来分配`sizeof(echo_t)`字节的内存。然后它调用`make_dev`来在`/dev`下创建一个名为`echo`的字符设备节点。请注意，当`make_dev`返回时，字符设备是“活跃”的，并且其`d_foo`函数可以执行。因此，如果我在`malloc`之前调用`make_dev`，`echo_write`或`echo_read`可能会在`echo_message`指向有效内存之前执行，这将是非常危险的。重点是：除非你的驱动程序完全就绪，否则不要调用`make_dev`。
- en: On module unload, this function first calls ![](httpatomoreillycomsourcenostarchimages1137507.png)
    `destroy_dev` to destroy the `echo` device node. Then it calls ![](httpatomoreillycomsourcenostarchimages1137509.png)
    `free` to release the allocated memory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块卸载时，这个函数首先调用`destroy_dev`来销毁`echo`设备节点。然后它调用`free`来释放分配的内存。
- en: DEV_MODULE Macro
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DEV_MODULE 宏
- en: 'The `DEV_MODULE` macro is defined in the `<sys/conf.h>` header as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEV_MODULE`宏在`<sys/conf.h>`头文件中定义如下：'
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, `DEV_MODULE` merely wraps ![](httpatomoreillycomsourcenostarchimages1137499.png)
    `DECLARE_MODULE`. So [Example 1-2](ch01s06.html#echo.c "Example 1-2. echo.c")
    could have called `DECLARE_MODULE`, but `DEV_MODULE` is cleaner (and it saves
    you some keystrokes).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`DEV_MODULE`仅仅是对`DECLARE_MODULE`的封装。因此，[示例1-2](ch01s06.html#echo.c "示例1-2.
    echo.c")可以调用`DECLARE_MODULE`，但`DEV_MODULE`更简洁（并且可以节省一些按键操作）。
- en: Don’t Panic
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要慌张
- en: 'Now that we’ve walked through [Example 1-2](ch01s06.html#echo.c "Example 1-2. echo.c"),
    let’s give it a try:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经走过了[示例 1-2](ch01s06.html#echo.c "示例 1-2. echo.c")，让我们试一试：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Unsurprisingly, it works. Before this chapter is concluded, a crucial topic
    bears mentioning.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，它确实有效。在本章结束之前，有一个关键主题需要提及。
- en: Block Drivers Are Gone
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块设备驱动程序已消失
- en: As mentioned previously, block devices transfer randomly accessible data in
    fixed-size blocks; for example, disk drives. Naturally, *block drivers* provide
    access to block devices. Block drivers are characterized by the fact that all
    I/O is cached within the kernel’s buffer cache, which makes block drivers unreliable,
    for two reasons. First, because caching can reorder a sequence of write operations,
    it deprives the writing process of the ability to identify the exact disk contents
    at any moment in time. This makes reliable crash recovery of on-disk data structures
    (for example, filesystems) impossible. Second, caching can delay write operations.
    So if an error occurs, the kernel cannot report to the process that did the write
    which particular operation failed. For these reasons, every serious application
    that accesses block devices specifies that a character-device interface always
    be used. Consequently, FreeBSD dropped support for block drivers during the modernization
    of the disk I/O infrastructure.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，块设备以固定大小的块传输可随机访问的数据；例如，磁盘驱动器。自然地，*块设备驱动程序*提供了对块设备的访问。块设备驱动程序的特点是所有 I/O
    都在内核的缓冲区缓存中进行缓存，这使得块设备不可靠，有两个原因。首先，因为缓存可以重新排序写操作序列，它剥夺了写进程在任何时刻识别确切磁盘内容的能力。这使得可靠的磁盘数据结构（例如，文件系统）的崩溃恢复成为不可能。其次，缓存可以延迟写操作。所以如果发生错误，内核无法向执行写操作的过程报告哪个特定操作失败了。由于这些原因，每个访问块设备的严肃应用程序都指定始终使用字符设备接口。因此，FreeBSD
    在磁盘 I/O 基础设施现代化过程中放弃了块设备驱动程序的支持。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Obviously, FreeBSD still supports block devices. For more on this, see [Chapter 13](ch13.html
    "Chapter 13. Storage Drivers").
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，FreeBSD 仍然支持块设备。有关更多信息，请参阅[第 13 章](ch13.html "第 13 章。存储驱动程序")。
- en: Conclusion
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: This chapter introduced you to the basics of FreeBSD device driver development.
    In the following chapters, we’ll build upon the concepts described here to complete
    your driver toolkit. As an aside, because most FreeBSD device drivers are character
    drivers, don’t think of them as a primary driver class—they’re more like a tool
    used to create character device nodes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了 FreeBSD 设备驱动程序开发的基础。在接下来的章节中，我们将基于这里描述的概念来完善您的驱动程序工具包。顺便提一下，由于大多数 FreeBSD
    设备驱动程序是字符驱动程序，不要将它们视为主要的驱动程序类——它们更像是一种用于创建字符设备节点的工具。
