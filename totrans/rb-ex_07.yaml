- en: Chapter 7. Using, Optimizing, and Testing Functional Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter shows some recursive and other functional solutions to simple problems,
    as well as some ways we can test and improve these solutions. Two very common
    programming topics that demonstrate functional programming are the factorial and
    Fibonacci mathematical series—largely because they’re so easily described using
    recursive means.^([[20](#ftn.CHP-7-FNOTE-1)])
  prefs: []
  type: TYPE_NORMAL
- en: 'The *factorial* of a given positive number is the product of all the integers
    from 1 to that number, so factorial(3) = 3 x 2 x 1, factorial(5) = 5 x 4 x 3 x
    2 x 1, and so on. This can be expressed generally as:'
  prefs: []
  type: TYPE_NORMAL
- en: factorial(*x*) = *x* x (*x* – 1) x (*x* – 2) … 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The Fibonacci series is infinite, but you can look at a slice of it. The *Fibonacci*
    value for 0 is 0, and the value for 1 is 1\. Subsequent values are calculated,
    rather than preset. The number in the Fibonacci series at a given index is the
    sum of the previous two numbers. Therefore, the Fibonacci series starts like this:
    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, and so on. The formula for Fibonacci values for
    numbers greater than one can be expressed generally as Fibonacci(*x*) = Fibonacci(*x*-1)
    + Fibonacci(*x*-2).'
  prefs: []
  type: TYPE_NORMAL
- en: If you think that the general definitions of both factorials and Fibonaccis
    look recursive, you’re right. We’ll look at Ruby code that generates both types
    of numbers using recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '#26 Basic Factorials and Fibonaccis (factorial1.rb through fibonacci5.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most common criticism of recursion and other functional techniques is that
    they are resource intensive. Each new version of these factorial or Fibonacci
    scripts adds some feature intended to *optimize* the code, or produce a speed
    improvement. In some cases, these features result in a very dramatic improvement,
    but in other cases, they either fail to improve the code or sometimes even make
    it worse. The places where these attempts fail to improve speed are often as interesting
    as where they succeed. There’s an old adage among programmers: *Premature optimization
    is the root of all evil*.^([[21](#ftn.CHP-7-FNOTE-2)]) Keep that in mind while
    reading these examples.'
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this chapter, we’ll be looking at some short scripts in pairs. Here’s `factorial1.rb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s `fibonacci1.rb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For `factorial1.rb` and `fibonacci1.rb`, we add a new method to all Integers:
    either `fact` or `fib`, respectively. In both cases, we have our exit conditions
    that `return` either zero or one. For factorials, we `return 1` when `self` is
    either `0` or `1`, testing for `0` with the predicate `zero?` (❶). For the Fibonacci
    series, we `return` either zero or one at ❸. At either ❷ or ❹, we `return` the
    appropriate calculated value: `self` times the factorial of one lower than `self`
    (❷), or the sum of the previous two Fibonaccis (❹), matching the definitions I
    gave for factorials and Fibonaccis, respectively. Both of these scripts are simple,
    accurate ways to produce the mathematical procedures we want. Let’s look at the
    results using irb. Note that we can require more than one library file with multiple
    `-r` flags.^([[22](#ftn.CHP-7-FNOTE-3)])'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The factorial of 3 is 3 x 2 x 1, which is 6, so that’s fine. 6 x 4 is 24, and
    24 x 5 is 120\. So our fact method seems to work well. On to the fibonacci series.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first seven values in the Fibonacci series are 0, 1, 1, 2, 3, 5, and 8\.
    The *zeroth* number (the number at the 0 index) is 0, the first is 1, the second
    is also 1, the third is 2, the fourth is 3, and the fifth is 5\. Our `fib` method
    also seems to work well.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How could we improve the speed of this script? We have several options. I’ll
    outline each of them in turn and discuss the possible motivations for each change,
    but we’ll wait to test them (and therefore, to see the results of our assumptions)
    until the end.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Modifying a computer program to improve it without changing its external behavior
    is called* refactoring. *That’s what we’re doing with these scripts, because we’re
    not changing the factorial or Fibonacci values for a given input—we’re just changing
    how (and possibly how quickly) we return the same value. Refactoring is a fascinating
    topic; you can read more about it at [http://refactoring.com](http://refactoring.com)
    or in Martin Fowler’s* Refactoring: Improving the Design of Existing Code *(Addison-Wesley
    Professional, 1999). Unit testing, which we’ll describe later in this chapter,
    is a critical tool to use when refactoring, as I’ll explain in that section*.'
  prefs: []
  type: TYPE_NORMAL
- en: Using include? (factorial2.rb and fibonacci2.rb)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s a variant that decides what to `return` via the `include?` method, which
    eliminates the need to run two separate tests to find out whether `self` is either
    zero or one. The motivation is that it could be faster to do a single test instead
    of two separate tests. Again, I’ll show the alterations for both the factorial
    and Fibonacci scripts. Notice how both ❺ lines differ from either ❶ or ❸ in the
    initial scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the Fibonacci script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Passing the returns1 or returns_self Array as an Argument (factorial3.rb and
    fibonacci3.rb)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In these variants we have an Array called either `returns1` or `returns_self`
    that defines the return values for either a factorial or Fibonacci test. The Array
    is `[0, 1]` in both cases, because zero and one are the values we use in our rules
    to calculate other values in both tests. The motivation for this variant is the
    thought that it might be faster to create a data structure (such as `returns1`)
    once and pass it around, rather than re-creating our `[0, 1]` Array every time
    we make a new recursive call to either `fact()` or `fib()`. Notice how we define
    `returns1` or `returns_self` as an argument to each of our methods at ❻ in each
    script and then use it subsequently for both our exit conditions testing and as
    an explicit argument to the recursive calls (❼).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the Fibonacci version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Making RETURNS1 or RETURNS_SELF a Class Constant (factorial4.rb and fibonacci4.rb)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Making `returns1` or `returns_self` an argument seems silly for one reason:
    It’s always the same value, `[0, 1]`. Things that don’t change are ideal constants,
    so let’s try that for both scripts. We’ll define a constant with an appropriate
    name at ❽ in each script and then use it in our method’s tests. Note that there
    is no longer any need to pass the constant as an argument to the recursive method
    calls, as we did in the previous variant at ❼.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the Fibonacci version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Memoization of Results (factorial5.rb and fibonacci5.rb)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One unexamined flaw in our scripts so far is that they’re stupid. It sounds
    harsh, but it’s fair.^([[23](#ftn.CHP-7-FNOTE-4)]) They keep repeating the same
    calculations over and over again. For the sake of example, let’s assume that we’ve
    called the `fib()` method on the Integer `5`, and `fib()` is as defined in `fibonacci4.rb`,
    our most recent Fibonacci script variant. What happens?
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing of interest is that whenever our `5` is instantiated, it has
    a class constant called `RETURNS_SELF`, defined as an Array: `[0, 1]`. Next we
    call `fib()` on our `5\. RETURNS_SELF` does not `include? 5`, so we then call
    `fib()` on the expression `(5-1)`, which is of course the Integer `4`, and add
    its returned value to the result of calling `fib()` on the value `(5-2)`, also
    known as the Integer `3`. We then find that `RETURNS_SELF` does not `include?
    4`, either, so we then call `fib()` on the expressions `(4-1)`, which is the Integer
    `3`, and add its returned value to the result of calling `fib()` on the value
    `(4-2)`, also known as the Integer `2`. We keep doing this recursively until we
    get a value of `self` that is found within the `RETURNS_SELF` Array.'
  prefs: []
  type: TYPE_NORMAL
- en: The main problem with doing this is that we keep re-calculating methods like
    `3.fib()`. We had to calculate it in the guise of `(self-2).fib()` in our initial
    call to `5.fib()`, and we had to calculate it in the guise of `(self-1).fib()`
    when our value for `self` was `4`. The reason all this recalculation is a problem
    is that `3.fib()` gives the same result, whether it is called as `(5-2).fib()`
    or as `(4-1).fib()`—it’s the same thing under the hood. Wouldn’t it be great if
    there were a way to call something like `3.fib()` once and then remember its value
    for subsequent calls?
  prefs: []
  type: TYPE_NORMAL
- en: There is such a technique. It’s called *memoization*, and it’s a critical way
    to make recursive programs use processor time more efficiently. Take a look at
    our new script variants, which take advantage of memoization. In both variants,
    we define an appropriately named Array at ❾ that holds the memoized results so
    far. We already have starting results for both `0` and `1`, which we defined in
    the `returns1` Array in our earlier examples. We then use that memoized results
    Array (either `@@factorial_results` or `@@fibonacci_results`) at ❿, using the
    `||=` operator to set a value for the `self` index within the Array, if there
    isn’t a value already. Since Ruby methods always return the last evaluated expression,
    we don’t need separate setting and returning operations. Now, whenever we need
    the `fact` or `fib` value for a lower `self`, we can just read it out. The `||=`
    operator at ❿ evaluates the element from the Array as `true` and simply returns
    it without making a new assignment.^([[24](#ftn.CHP-7-FNOTE-5)])
  prefs: []
  type: TYPE_NORMAL
- en: A complement to memoization is lazy evaluation. Few languages implement this
    by default, Haskell being the most widely known exception. Most languages use
    *eager evaluation*, in which expressions are evaluated as early as possible, certainly
    on entry into a method or function. *Lazy evaluation* lets expressions be passed
    around unevaluated until their value is needed. The benefit for factorial and
    Fibonacci operations is that the operations on higher numbers can wait until the
    operations on lower numbers are already done, which speeds up the whole process.
    There’s a library for lazy evaluation in Ruby at [http://moonbase.rydia.net/software/lazy.rb](http://moonbase.rydia.net/software/lazy.rb).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The Fibonacci version is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That should be enough variants to test. Note that this last factorial script
    also includes a method called `show_mems` that you can use to inspect the state
    of the memoization. If you’d like, you can add your own equivalent to `fibonacci5.rb`.
    On to the testing.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[20](#CHP-7-FNOTE-1)]) This is as good a place as any to mention tail recursion.
    A function or method is *tail recursive* if it can be easily converted from recursion
    (which is friendly to human readers at a high level of abstraction) to iteration
    (which is friendlier to computer hardware). The Ruby interpreter does not currently
    do such conversion. I mention this because we’ll be doing a lot of recursing in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[21](#CHP-7-FNOTE-2)]) Commonly attributed to Donald Knuth, a computer programming
    genius if there ever was one.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[22](#CHP-7-FNOTE-3)]) The integers resulting from factorial and Fibonacci
    operations can become rather large. Luckily, Ruby allows you to just treat them
    all as Integers, transparently doing whatever operations are needed with Bignums
    and Fixnums without making you worry about such things.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[23](#CHP-7-FNOTE-4)]) Maybe the criticism is more fair when directed at
    the author than the scripts. After all, the scripts only do what I tell them to.
    In fairness to me, I wrote them to demonstrate failed optimization attempts.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[24](#CHP-7-FNOTE-5)]) Our Perl friends do something similar to our use of
    `||=` here that they call the *Orcish Maneuver*. Look it up at [http://perl.plover.com/TPC/1998/Hardware-notes.html](http://perl.plover.com/TPC/1998/Hardware-notes.html)
    if you’re curious. The name comes from both a pun and the prevalence of *The Lord
    of the Rings* fandom in the Perl community.
  prefs: []
  type: TYPE_NORMAL
- en: '#27 Benchmarking and Profiling (tests/test_opts.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we’ll talk about two distinct ways to test the execution speed of code.
    *Benchmarking* measures the overall speed of the code, while *profiling* gives
    more detailed information about how long different parts of the code take to execute,
    relative to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous variants all showed ways to modify the base code in the hopes of
    making it faster. Here’s where we test our assumptions and find out what really
    makes a difference. I store it in a directory called `tests`, meaning that I run
    it with `ruby -w tests/test_opts.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, I `require` a file called `‘benchmark’` (❶); the `include` command that
    immediately follows it mixes in a Module called Benchmark. This is the workhorse
    of our script. It provides a facility for testing how long specific operations
    take within a program. In order to do those tests, we need to set up a few Constants,
    which we do at ❷. The `FUNC_OF_FILE` constant contains the name of the method
    (or function) we want to call in each file, and `UPPER_OF_FILE` determines the
    largest Integer on which to call that function (the upper limit, in other words).
  prefs: []
  type: TYPE_NORMAL
- en: At ❸, we loop through each `file`, and at ❹, we loop through each `num`, which
    is the filename suffix. Then we require a specific, dynamically generated filename
    at ❺. Note that this will override any previous definitions of methods with the
    same name. (This is why we will run this script without warnings, as the RDoc
    at the beginning of the file indicates.) We then set the value of the `upper`
    local variable. At ❻, we call the method `bm`, provided by the Benchmark module.
    It takes a block whose local variable is the `test` to be run. That `test` has
    a method called `report`, which (as the name suggests) generates a report of the
    test’s findings. The `report` method also takes a block that contains the code
    comprising the test. That block consists of only one line at ❽. We haven’t seen
    the `send` method yet, but calling `some_object.send( some_func_name, some_arg
    )` is the same as calling `some_object.some_func_name( some_arg )`. I’ll describe
    `send` in greater detail in the `to_lang.rb` script in [Chapter 10](ch10.html
    "Chapter 10. More Complex Utilities and Tricks, Part II"). For now, just understand
    that it calls the desired method (either `fact` or `fib`) for each file.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll want to run this with the command `ruby tests/test_opts.rb`. Notice that
    we eschew the `-w` flag in this particular case. The reason is that we are redefining
    methods, which triggers a warning. Since we are doing this intentionally and are
    aware of the situation, the warning is merely an annoyance in this particular
    case.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are my results. Your results may vary considerably, depending on how fast
    your machine is.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The benchmarking output shows seconds used from the perspective of the user,
    system, total, and real labels. You can read more about the specific meanings
    of these labels via the command `man time` on a Unix-like system. For now, keep
    in mind that they are useful for measuring the time one process takes, relative
    to another process. I’ll be referring to the `real` time in my discussion. You
    can see that there is very little variation among the factorial scripts. The main
    reason for this is that the factorial operation is comparatively simple, since
    it is a single, recursive multiplication. We see more striking data for the Fibonacci
    scripts because each recursive Fibonacci operation spawns two additional Fibonacci
    operations, unless it uses memoization. This double spawning is why I set the
    upper limit of Fibonacci operations at the much lower value of 30, compared with
    the factorial’s upper limit of 200.
  prefs: []
  type: TYPE_NORMAL
- en: Our tests showed that the simple `fibonacci1.rb` took about 6.20 seconds to
    run 30 consecutive operations of calling `fib` on the numbers from one to five.
    Things actually get worse when we try the `include?` optimization in `fibonacci2.rb`
    (it takes about 8.56 seconds), and improve only slightly for the argument optimization
    in `fibonacci3.rb` (which takes about 6.81 seconds). The run time doesn’t significantly
    change until we introduce memoization in `fibonacci5.rb`, where the time spent
    drops so much that it’s no longer significant.
  prefs: []
  type: TYPE_NORMAL
- en: The moral of the story is twofold. First, we’ve learned that it’s better to
    base code optimization for speed on tests, rather than intuitions. By trying to
    squeeze some faster performance out of a piece of code, you can waste time in
    an area that isn’t even your speed bottleneck, and it will only make your code
    harder to read. The second moral is that memoization (as used in `factorial5.rb`
    and `fibonacci5.rb`) is a crucial addition to any recursive operations that are
    likely to be repeated.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, benchmarking is only part of the story. If you’re worried about the
    speed of your code, knowing only the total time it takes to run is not especially
    useful. What’s more useful is the information provided by *profiling*, which breaks
    down the parts of your code and gives speed reports at a finer level of detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby has a profiling library called `profile`. It can be `require` d, just
    like benchmark, but it doesn’t demand specific testing code like the `bm` method
    and its block. The library can be automatically applied to an execution of code
    simply by including `profile` via the `-r` flag. Let’s do so with a command-line
    execution of the first script we wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how all we have to do is require `profile` with the `-r` flag; our `-e`
    flag contains code to be executed that works just like the irb session we used
    with `99bottles.rb` when we wrote it in [Chapter 2](ch02.html "Chapter 2. Amusements
    and Simple Utilities"). Here is an extremely truncated version of its results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This report provides a great deal of interesting information, including the
    percentage of total time that a given method takes, the raw seconds used by that
    method call, the number of calls to each method, and the number of milliseconds
    taken per call. This data gives you something to use when you’re trying to improve
    execution speed. If the number of calls to a given method is high, perhaps the
    method is being called multiple times in a loop. You can increase speed by pre-running
    that method only once and passing its value into the loop for use. You can also
    try different ways of implementing the same operation to see which way runs faster,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several variations you could try with these scripts. The simplest
    code modifications involve changing the upper limit values in `upper_of_file`
    for each `file`. You can also try operations other than factorial or Fibonacci
    ones. You can also run any of the scripts in this book with `-r profile`. When
    writing them, I focused on pedagogy rather than speed, so you can probably make
    some speed improvements to these stock scripts. Now let’s move on to a practical
    application of functional programming that should remind you of some earlier scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '#28 Converting Temperatures (temperature_converter.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this example, we’ll write a converter script. This time, instead of converting
    currencies, we’ll convert units for other real-world factors like length, mass,
    temperature, and so on. The version that I show here only handles temperatures,
    but you can download `units_converter.rb` at this book’s companion website; it
    is a more comprehensive script that also handles length, volume, and mass. We’ll
    concentrate on converting to and from English and metric units, but we’ll also
    support kelvins. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This script uses a few functional techniques that we haven’t covered yet. Let’s
    step through the code. At ❶, we define a `BASE_UNIT_OF` Hash that holds the base
    unit. Note that *temperature* and *temp* are both acceptable, and that the script
    uses kelvins, the scientific unit of absolute temperature, as its internal temperature
    unit. Next, we define some helpful conversion constants. I’ve broken these up
    into paragraphs: The first paragraph of definitions (❷) holds simple addition
    and multiplication constants, while the second paragraph (❸) uses `lambda` to
    define Procs that will use the values from the first paragraph. Temperature conversion
    is a bit more complicated than conversion of length or mass.'
  prefs: []
  type: TYPE_NORMAL
- en: Most unit conversions consist of a simple multiplication operation. If you have
    100 pounds and you want to know how many kilograms that is, you simply multiply
    100 by 0.45\. But to convert temperature between Fahrenheit and Celsius, you must
    multiply *and* add. The general formula is F = ( C x 9/5 ) + 32\. Conversely,
    C = ( F – 32 ) x 5/9\. Note also that one degree Celsius and one kelvin are the
    same size (meaning there is no multiplication needed to convert between them),
    but they are offset by 273.15, so 0 degrees Celsius = 273.15 kelvins, and 0 kelvins
    (absolute zero) = -273.15 degrees Celsius. That’s cold.
  prefs: []
  type: TYPE_NORMAL
- en: At ❸, we define constants with three-character names that suggest the type of
    temperature conversion they do; for example, the `K2C` conversion Proc accepts
    kelvins and returns the Celsius equivalent. Most of these are pretty straightforward
    and implement the temperature relationships I described in the paragraph of declarations
    (❷).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the `F2K` and `K2F` Procs are more interesting. They use previously
    defined Procs inside themselves and then use the `call` method successively to
    perform two-stage conversions. `F2K` accepts some Fahrenheit value `f`, converts
    that to Celsius via `F2C.call(f)`, and then uses that Celsius value as the argument
    to `C2F.call()`. This general operation of performing successive function calls
    is called *composition*. `F2K` composes `C2K` and `F2C`, and `K2F` composes `C2F`
    and `K2C`. This has the same benefits as breaking operations up into functions
    or methods: You only need to have a single, definitive place where any given operation
    is defined, and you can just call that operation as you build more complicated
    operations that depend on earlier definitions.'
  prefs: []
  type: TYPE_NORMAL
- en: We have some useful constants, including temperature-related Procs. Next is
    our `CONVERSIONS` Hash at ❹. This is a doubly nested Hash, and the outermost keys
    are the units we have. Each of those keys points to yet another Hash, with a key
    representing the units we want to convert to and a value that is the necessary
    conversion Proc. If we have degrees Celsius and we want kelvins, our conversion
    operation is `CONVERSIONS[‘C’][‘K’]`, which is the `C2K` Proc constant.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The purpose of the *`CONVERSIONS`* Hash is to pass in some identifier(s) and
    get something useful out, specifically the Proc needed to do the requested unit
    conversion. This is very similar to a* Factory *in object orientation, which is
    an object that creates other objects based on the parameters it receives. Our
    *`CONVERSIONS`* Hash is an example of the same concept applied to Procs*.'
  prefs: []
  type: TYPE_NORMAL
- en: The first paragraph of data in `CONVERSIONS` converts to our base unit for each
    factor—kelvins, in our case. But what if someone asks for a final output that
    isn’t our base unit? We need to be able to convert from the base unit to all the
    other units, which is what the next paragraph of code at ❺ is for. It’s still
    part of the `CONVERSIONS` Hash, and it still follows the same structure of `{
    have => { want => some_conversion_proc } }`, but it has two conversion targets
    instead of one. We close the constants with `OUTPUT_FORMAT`, which restricts our
    reported values to two decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ❻ we define our main method, called `convert`. It takes a mandatory argument
    called `params` and defines a local variable called `conversion_proc` that has
    the value of either `CONVERSIONS[params[:have_unit]][params[:want_unit]]` or,
    failing that, the output of `get_proc_via_base_unit(params)`. We already know
    that the value of `CONVERSIONS[‘C’][‘K’]` is the Celsius-to-kelvins Proc. Let’s
    verify that in irb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There is another key to `params` here other than `:have_units` and `:want_units`,
    but it should be fairly clear. We also need to tell the converter how many units
    we have, which is what `:have_num` does. These results look good; they are examples
    in which there is a value available for `CONVERSIONS[params[:have_unit]][params[:want_unit]]`
    inside the `convert` method, meaning that it doesn’t need to use `get_proc_via_base_unit(params)`.
    After it’s got the `conversion_proc`, it returns the output you already saw in
    irb, which shows the number and unit already known, and what it converts into.
  prefs: []
  type: TYPE_NORMAL
- en: This is straightforward enough. But what happens when there isn’t a value for
    `CONVERSIONS[params[:have_unit]][params[:want_unit]]` available? This would be
    true in cases such as converting degrees Celsius to degrees Fahrenheit. There
    is no Proc at `CONVERIONS[‘C’][‘F’]`. Does this mean that our base unit needs
    to be either the known or desired value? Yes and no. Yes in only the most pedantic
    sense. No in any practical sense, because we can use the `get_proc_via_base_unit`
    method to create our own `conversion_proc` by composing two other known `conversion_procs`,
    just like the ones we hard-coded into the temperature converters.
  prefs: []
  type: TYPE_NORMAL
- en: If the unit our `params` asks for doesn’t have a built-in conversion Proc, we
    can use `get_proc_via_base_unit`, as noted. Inside `get_proc_via_base_unit`, we
    first get the `base_unit` (❼). We then create the `have_to_base_proc` by getting
    the Proc out of `CONVERIONS` that would be used to convert from the known unit
    to the `base_unit` (❽). Then we get the `base_to_want_proc` by getting the Proc
    out of `CONVERIONS` that would be used to convert from the `base_unit` to the
    unit we want (❾). Then at ❿, we compose `base_to_want_proc` and `have_to_base_proc`,
    just as we did in the ❸ section for `F2K` and `K2F`. We could have called our
    new Proc `have_to_want_proc`, but we just `return` it, and it becomes `conversion_proc`
    inside the `convert` method at ❻.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s try it out in irb. It was 65 degrees Fahrenheit in Buffalo, New York in
    November today (yes, really), and I was talking with a Canadian coworker about
    this temperature conversion script. Let’s start with that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These examples should give you an idea of this program’s interface. You can
    also call it with other conversions that are of interest to you.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I already noted, there is a more complex version of this script available
    for download at the book’s website. If you find that you want to convert to or
    from units that I don’t have built in, just create a key/value pair in `CONVERSIONS`
    that converts from your new unit to the appropriate base unit and another that
    converts from the base unit to your new unit. That should give you the ability
    to convert to and from any unit relative to your new unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also use implicit composition in `temperature_converter.rb`—at ❸ for definition
    and at ❿ for use. You could modify the script to have an explicit `compose` method
    that takes two Procs and returns a new Proc that performs each operation in order.
    Here’s an example in irb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Line 8 gives us `2`, because `(1 ** 1) + 1 = 2`. Line 9 gives us `5`, because
    `(2 ** 2) + 1 = 5`. Line 10 gives us `9`, because `(2 + 1) ** 2 = 9`. Once you
    have this `compose` method, you can even use it on Procs that are the returned
    value from a previous call to `compose`, allowing you to stack successive operations
    as much as you like.
  prefs: []
  type: TYPE_NORMAL
- en: '#29 Testing temperature_converter.rb (tests/test_temp_converter.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, our testing scripts have been relatively primitive, and
    to a very large degree, we have rolled our own testing solutions. It’s silly to
    do that repeatedly, especially in computer programs, because good programming
    languages allow you to express abstract concepts abstractly, as well as to adapt
    general-purpose tools in code libraries to your specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby has a general-purpose testing library called `Test::Unit`. Here is code
    that allows you to use its power to test the script `temperature_converter.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s run it and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All four of our assertions passed with no failures or errors. That’s wonderful
    news. Now let’s look at what it means.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*One term you may hear in reference to testing is* code coverage, *which is
    the degree to which the tests adequately examine the pertinent code. This can
    be defined in terms of the percentage of total code lines that are tested, the
    percentage of Boolean evaluations that are tested, and other similar metrics*.'
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, I mentioned refactoring, the practice of cleaning up
    code implementation while leaving its behavior unchanged. Unit testing is very
    useful when refactoring, especially if you use tests that have high *entry/exit
    coverage*, meaning they try to ensure that all outputs from functions stay the
    same as long as those functions get the same inputs. This type of testing keeps
    your refactoring honest.
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we need access to the code that we’ll be testing. Luckily, we’ve followed
    good design practice and defined our code in a library called `temperature_converter.rb`,
    so we `require` both it and the `test/unit` library at ❶. Then we define a new
    class called `Tester;` as you can see at ❷, this class is a child of `Test::Unit::TestCase`,
    meaning that it inherits all of the methods and characteristics of `Test::Unit::TestCase`.
  prefs: []
  type: TYPE_NORMAL
- en: We then define a testing method called `test_temps`. It’s just a wrapper for
    a multi-level Hash called `tests`, defined at ❸ inside `test_temps`. You’ll notice
    that each key of `tests` is a String that looks like the output of `Units_Converter.convert`;
    that key’s value is a Hash that you use as the argument into `Units_Converter.convert`
    in order to get output that matches that key. Inside `test_temps`, we then pass
    `tests` as an argument into a private method called `general_tester`, which we
    define at ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The `general_tester` method loops through `each_pair` in the `tests` Hash at
    ❺, calling the expected result `result` and the argument Hash needed to produce
    that `result, test_args`. For each of those pairs, we assert that `result` and
    `@converter.convert( test_args )` are equal, using the appropriately named `assert_equal`
    method (❻). That’s all there is to it.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try making a change in one of the `tests` Hashes. If you either change only
    the key (which becomes `result` in `general_tester`) or only the value (which
    becomes `test_args` in `general_tester`), the call to `assert_equal` will fail,
    because the two items passed as arguments to be compared will no longer be equal.
    You can also add entirely new elements to the `tests` Hash, with new values you
    want to verify.
  prefs: []
  type: TYPE_NORMAL
- en: This script only scratches the surface of how to use `Test::Unit`. Type `ri
    Test::Unit` at the command line for more information. You can also browse to [http://www.ruby-doc.org/stdlib/libdoc/test/unit/rdoc](http://www.ruby-doc.org/stdlib/libdoc/test/unit/rdoc)
    within the Ruby Standard Library Documentation site. Note that the HTML generated
    for that documentation came from RDoc.
  prefs: []
  type: TYPE_NORMAL
- en: I already mentioned that testing can be useful during refactoring. A good place
    to start with testing is what I’ve done here, pre-figuring expected values from
    a method based on a set of known input parameters. The `assert_equal` method is
    very useful for such testing. There are other methods available, which you can
    read about by typing `ri Test::Unit::Assertions` at the command line. Notables
    include `assert_instance_of`, which checks whether its argument belongs to a specified
    class; `assert_nil`, which checks whether its argument is `nil`; `assert_raise`,
    which you can use to intentionally raise an Exception (i.e., break something);
    and `assert_respond_to`, which checks whether a given argument knows how to respond
    to a given specified method.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What was new in this chapter?
  prefs: []
  type: TYPE_NORMAL
- en: Recursive factorials and Fibonaccis as good profiling candidates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with Benchmark
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting temperatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashes with Proc values as Proc Factories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition of Procs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with `Test::Unit`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, that’s a lot to take in. This list is deceptively short, because some
    of these concepts require more contemplation than those we’ve considered in previous
    chapters. Let’s move on to the next chapter, in which we’ll write some tools for
    processing HTML and XML.
  prefs: []
  type: TYPE_NORMAL
