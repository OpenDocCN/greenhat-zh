<html><head></head><body><div class="part" title="Part&#xA0;II.&#xA0;Browser Security Features"><div class="titlepage"><div><div><h1 class="title"><a id="browser_security_features"/>Part II. Browser Security Features</h1></div></div></div><div class="partintro" id="id2706523" title="Browser Security Features"><div/><p>Having reviewed the basic building blocks of the Web, we can now comfortably examine all the security features that keep rogue web applications at bay. <a class="xref" href="pt02.html" title="Part II. Browser Security Features">Part II</a> of this book takes a look at everything from the well-known but often misunderstood same-origin policy to the obscure and proprietary zone settings of Internet Explorer. It explains what these mechanisms can do for you—and when they tend to fall apart.</p></div></div>
<div class="chapter" title="Chapter&#xA0;9.&#xA0;Content Isolation Logic"><div class="titlepage"><div><div><h1 class="title"><a id="content_isolation_logic"/>Chapter 9. Content Isolation Logic</h1></div></div></div><p>Most of the security assurances provided by web browsers are meant to isolate documents based on their origin. The premise is simple: Two pages from different sources should not be allowed to interfere with each other. Actual practice can be more complicated, however, as no universal agreement exists about where a single document begins and ends or what constitutes a single origin. The result is a sometimes unpredictable patchwork of contradictory policies that don’t quite work well together but that can’t be tweaked without profoundly affecting all current legitimate uses of the Web.<a class="indexterm" id="IDX-CHP-9-0001"/><a class="indexterm" id="IDX-CHP-9-0002"/></p><p>These problems aside, there is also little clarity about what actions should be subject to security checks in the first place. It seems clear that some interactions, such as following a link, should be permitted without special restrictions as they are essential to the health of the entire ecosystem, and that others, such as modifying the contents of a page loaded in a separate window, should require a security check. But a large gray area exists between these extremes, and that middle ground often feels as if it’s governed more by a roll of the dice than by any unified plan. In these murky waters, vulnerabilities such as cross-site request forgery (see <a class="xref" href="ch04.html" title="Chapter 4. Hypertext Markup Language">Chapter 4</a>) abound.</p><p>It’s time to start exploring. Let’s roll a die of our own and kick off the journey with JavaScript.<a class="indexterm" id="IDX-CHP-9-0003"/><a class="indexterm" id="IDX-CHP-9-0004"/><a class="indexterm" id="IDX-CHP-9-0005"/><a class="indexterm" id="IDX-CHP-9-0006"/></p><div class="sect1" title="Same-Origin Policy for the Document Object Model"><div class="titlepage"><div><div><h1 class="title"><a id="same-origin_policy_for_the_document_obje"/>Same-Origin Policy for the Document Object Model</h1></div></div></div><p>The <span class="emphasis"><em>same-origin policy</em></span> (<span class="emphasis"><em>SOP</em></span>) is a concept introduced by Netscape in 1995 alongside JavaScript and the Document Object Model (DOM), just one year after the creation of HTTP cookies. The basic rule behind this policy is straightforward: Given any two separate JavaScript execution contexts, one should be able to access the DOM of the other only if the protocols, DNS names,<sup>[<a class="footnote" href="#ftn.CHP-9-FN-1" id="CHP-9-FN-1">43</a>]</sup> and port numbers associated with their host documents match exactly. All other cross-document JavaScript DOM access should fail.<a class="indexterm" id="IDX-CHP-9-0007"/><a class="indexterm" id="IDX-CHP-9-0008"/><a class="indexterm" id="IDX-CHP-9-0009"/></p><p>The protocol-host-port tuple introduced by this algorithm is commonly referred to as <span class="emphasis"><em>origin</em></span>. As a basis for a security policy, this is pretty robust: SOP is implemented across all modern browsers with a good degree of consistency and with only occasional bugs.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-2" id="CHP-9-FN-2">44</a>]</sup> In fact, only Internet Explorer stands out, as it ignores the port number for the purpose of origin checks. This practice is somewhat less secure, particularly given the risk of having non-HTTP services running on a remote host for HTTP/0.9 web servers (see <a class="xref" href="ch03.html" title="Chapter 3. Hypertext Transfer Protocol">Chapter 3</a>). But usually it makes no appreciable difference.<a class="indexterm" id="IDX-CHP-9-0010"/><a class="indexterm" id="IDX-CHP-9-0011"/></p><p><a class="xref" href="ch09.html#outcomes_of_sop_checks" title="Table 9-1. Outcomes of SOP Checks">Table 9-1</a> illustrates the outcome of SOP checks in a variety of situations.</p><div class="table"><a id="outcomes_of_sop_checks"/><p class="title">Table 9-1. Outcomes of SOP Checks</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Outcomes of SOP Checks"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Originating document</p></th><th style="text-align: left" valign="bottom"><p>Accessed document</p></th><th style="text-align: left" valign="bottom"><p>Non-IE browser</p></th><th style="text-align: left" valign="bottom"><p>Internet Explorer</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><a class="ulink" href="http://example.com/a/">http://example.com/a/</a></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://example.com/b/">http://example.com/b/</a></p></td><td style="text-align: left" valign="top"><p>Access okay</p></td><td style="text-align: left" valign="top"><p>Access okay</p></td></tr><tr><td style="text-align: left" valign="top"><p><a class="ulink" href="http://example.com/">http://example.com/</a></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://www.example.com/">http://www.example.com/</a></p></td><td style="text-align: left" valign="top"><p>Host mismatch</p></td><td style="text-align: left" valign="top"><p>Host mismatch</p></td></tr><tr><td style="text-align: left" valign="top"><p><a class="ulink" href="http://example.com/">http://example.com/</a></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="https://example.com/">https://example.com/</a></p></td><td style="text-align: left" valign="top"><p>Protocol mismatch</p></td><td style="text-align: left" valign="top"><p>Protocol mismatch</p></td></tr><tr><td style="text-align: left" valign="top"><p><a class="ulink" href="http://example.com:81/">http://example.com:81/</a></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://example.com/">http://example.com/</a></p></td><td style="text-align: left" valign="top"><p>Port mismatch</p></td><td style="text-align: left" valign="top"><p>Access okay</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>This same-origin policy was originally meant to govern access only to the DOM ; that is, the methods and properties related to the contents of the actual displayed document. The policy has been gradually extended to protect other obviously sensitive areas of the root JavaScript object, but it is not all-inclusive. For example, non-same-origin scripts can usually still call <span class="emphasis"><em>location.assign()</em></span> or <span class="emphasis"><em>location.replace(...)</em></span> on an arbitrary window or a frame. The extent and the consequences of these exemptions are the subject of <a class="xref" href="ch11.html" title="Chapter 11. Life Outside Same-Origin Rules">Chapter 11</a>.</p></div><p>The simplicity of SOP is both a blessing and a curse. The mechanism is fairly easy to understand and not too hard to implement correctly, but its inflexibility can be a burden to web developers. In some contexts, the policy is too broad, making it impossible to, say, isolate home pages belonging to separate users (short of giving each a separate domain). In other cases, the opposite is true: The policy makes it difficult for legitimately cooperating sites (say, <span class="emphasis"><em>login.example.com</em></span> and <span class="emphasis"><em>payments.example.com</em></span>) to seamlessly exchange data.<a class="indexterm" id="IDX-CHP-9-0012"/><a class="indexterm" id="IDX-CHP-9-0013"/><a class="indexterm" id="IDX-CHP-9-0014"/></p><p>Attempts to fix the first problem—to narrow down the concept of an origin—are usually bound to fail because of interactions with other explicit and hidden security controls in the browser. Attempts to broaden origins or facilitate cross-domain interactions are more common. The two broadly supported ways of achieving these goals are <span class="emphasis"><em>document.domain</em></span> and <span class="emphasis"><em>postMessage(...)</em></span>, as discussed below.<a class="indexterm" id="IDX-CHP-9-0015"/></p><div class="sect2" title="document.domain"><div class="titlepage"><div><div><h2 class="title"><a id="document.domain"/>document.domain</h2></div></div></div><p>This JavaScript property permits any two cooperating websites that share a common top-level domain (such as <span class="emphasis"><em>example.com</em></span>, or even just <span class="emphasis"><em>.com</em></span>) to agree that for the purpose of future same-origin checks, they want to be considered equivalent. For example, both <span class="emphasis"><em>login.example.com</em></span> and <span class="emphasis"><em>payments.example.com</em></span> may perform the following assignment:</p><a id="I_programlisting1_d1e10686"/><pre class="programlisting">document.domain = "example.com"</pre><p>Setting this property overrides the usual hostname matching logic during same-origin policy checks. The protocols and port numbers still have to match, though; if they don’t, tweaking <span class="emphasis"><em>document.domain</em></span> will not have the desired effect.</p><p>Both parties must explicitly opt in for this feature. Simply because <span class="emphasis"><em>login.example.com</em></span> has set its <span class="emphasis"><em>document.domain</em></span> to <span class="emphasis"><em>example.com</em></span> does not mean that it will be allowed to access content originating from the website hosted at <a class="ulink" href="http://example.com/">http://example.com/</a>. That website needs to perform such an assignment, too, even if common sense would indicate that it is a no-op. This effect is symmetrical. Just as a page that sets <span class="emphasis"><em>document.domain</em></span> will not be able to access pages that did not, the action of setting the property also renders the caller mostly (but not fully!)<sup>[<a class="footnote" href="#ftn.CHP-9-FN-3" id="CHP-9-FN-3">45</a>]</sup> out of reach of normal documents that previously would have been considered same-origin with it. <a class="xref" href="ch09.html#outcomes_of_document.domain_checks" title="Table 9-2. Outcomes of document.domain Checks">Table 9-2</a> shows the effects of various values of <span class="emphasis"><em>document.domain</em></span>.</p><p>Despite displaying a degree of complexity that hints at some special sort of cleverness, <span class="emphasis"><em>document.domain</em></span> is not particularly safe. Its most significant weakness is that it invites unwelcome guests. After two parties mutually set this property to <span class="emphasis"><em>example.com</em></span>, it is not simply the case that <span class="emphasis"><em>login.example.com</em></span> and <span class="emphasis"><em>payments.example.com</em></span> will be able to communicate; <span class="emphasis"><em>funny-cat-videos.example.com</em></span> will be able to jump on the bandwagon as well. And because of the degree of access permitted between the pages, the integrity of any of the participating JavaScript contexts simply cannot be guaranteed to any realistic extent. In other words, touching <span class="emphasis"><em>document.domain</em></span> inevitably entails tying the security of your page to the security of the weakest link in the entire domain. An extreme case of setting the value to <span class="emphasis"><em>*.com</em></span> is essentially equivalent to assisted suicide.<a class="indexterm" id="IDX-CHP-9-0016"/><a class="indexterm" id="IDX-CHP-9-0017"/><a class="indexterm" id="IDX-CHP-9-0018"/></p><div class="table"><a id="outcomes_of_document.domain_checks"/><p class="title">Table 9-2. Outcomes of <span class="emphasis"><em>document.domain</em></span> Checks</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Outcomes of document.domain Checks"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th colspan="2" style="text-align: left" valign="bottom"><p>Originating document</p></th><th colspan="2" style="text-align: left" valign="bottom"><p>Accessed document</p></th><th style="text-align: left" valign="bottom"><p>Outcome</p></th></tr><tr><th style="text-align: left" valign="bottom"><p>URL</p></th><th style="text-align: left" valign="bottom"><p>document.domain</p></th><th style="text-align: left" valign="bottom"><p>URL</p></th><th style="text-align: left" valign="bottom"><p>document.domain</p></th><th style="border-bottom: 0.5pt solid ; "> </th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><a class="ulink" href="http://www.example.com/">http://www.example.com/</a></p></td><td style="text-align: left" valign="top"><p><span class="emphasis"><em>example.com</em></span></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://payments.example.com/">http://payments.example.com/</a></p></td><td style="text-align: left" valign="top"><p><span class="emphasis"><em>example.com</em></span></p></td><td style="text-align: left" valign="top"><p>Access okay</p></td></tr><tr><td style="text-align: left" valign="top"><p><a class="ulink" href="http://www.example.com/">http://www.example.com/</a></p></td><td style="text-align: left" valign="top"><p><span class="emphasis"><em>example.com</em></span></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="https://payments.example.com/">https://payments.example.com/</a></p></td><td style="text-align: left" valign="top"><p><span class="emphasis"><em>example.com</em></span></p></td><td style="text-align: left" valign="top"><p>Protocol mismatch</p></td></tr><tr><td style="text-align: left" valign="top"><p><a class="ulink" href="http://payments.example.com/">http://payments.example.com/</a></p></td><td style="text-align: left" valign="top"><p><span class="emphasis"><em>example.com</em></span></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://example.com/">http://example.com/</a></p></td><td style="text-align: left" valign="top"><p><span class="strong"><strong>(not set)</strong></span></p></td><td style="text-align: left" valign="top"><p>Access denied</p></td></tr><tr><td style="text-align: left" valign="top"><p><a class="ulink" href="http://www.example.com/">http://www.example.com/</a></p></td><td style="text-align: left" valign="top"><p><span class="strong"><strong>(not set)</strong></span></p></td><td style="text-align: left" valign="top"><p><a class="ulink" href="http://www.example.com/">http://www.example.com/</a></p></td><td style="text-align: left" valign="top"><p><span class="emphasis"><em>example.com</em></span></p></td><td style="text-align: left" valign="top"><p>Access denied</p></td></tr></tbody></table></div></div></div><div class="sect2" title="postMessage(...)"><div class="titlepage"><div><div><h2 class="title"><a id="postmessage_open_parenthesis_..._close_p"/>postMessage(...)</h2></div></div></div><p>The <span class="emphasis"><em>postMessage(...)</em></span> API is an HTML5 extension that permits slightly less convenient but remarkably more secure communications between non-same-origin sites without automatically giving up the integrity of any of the parties involved. Today it is supported in all up-to-date browsers, although because it is fairly new, it is not found in Internet Explorer 6 or 7.</p><p>The mechanism permits a text message of any length to be sent to any window for which the sender holds a valid JavaScript handle (see <a class="xref" href="ch06.html" title="Chapter 6. Browser-Side Scripts">Chapter 6</a>). Although the same-origin policy has a number of gaps that permit similar functionality to be implemented by other means,<sup>[<a class="footnote" href="#ftn.CHP-9-FN-4" id="CHP-9-FN-4">46</a>]</sup> this one is actually safe to use. It allows the sender to specify what origins are permitted to receive the message in the first place (in case the URL of the target window has changed), and it provides the recipient with the identity of the sender so that the integrity of the channel can be ascertained easily. In contrast, legacy methods that rely on SOP loopholes usually don’t come with such assurances; if a particular action is permitted without robust security checks, it can usually also be triggered by a rogue third party and not just by the intended participants.</p><p>To illustrate the proper use of <span class="emphasis"><em>postMessage(...)</em></span>, consider a case in which a top-level document located at <span class="emphasis"><em>payments.example.com</em></span> needs to obtain user login information for display purposes. To accomplish this, it loads a frame pointing to <span class="emphasis"><em>login.example.com</em></span>. This frame can simply issue the following command:</p><a id="I_programlisting1_d1e10908"/><pre class="programlisting">parent.postMessage("user=bob", "https://payments.example.com");</pre><p>The browser will deliver the message only if the embedding site indeed matches the specified, trusted origin. In order to securely process this response, the top-level document needs to use the following code:<a class="indexterm" id="IDX-CHP-9-0019"/><a class="indexterm" id="IDX-CHP-9-0020"/><a class="indexterm" id="IDX-CHP-9-0021"/></p><a id="I_programlisting1_d1e10927"/><pre class="programlisting">// Register the intent to process incoming messages:
addEventListener("message", user_info, false);

// Handle actual data when it arrives:
function user_info(msg) {
  if (msg.origin == "https://login.example.com") {
    // Use msg.data as planned
  }
}</pre><p><span class="emphasis"><em>PostMessage(...)</em></span> is a very robust mechanism that offers significant benefits over <span class="emphasis"><em>document.domain</em></span> and over virtually all other guerrilla approaches that predate it; therefore, it should be used as often as possible. That said, it can still be misused. Consider the following check that looks for a substring in the domain name:</p><a id="I_programlisting1_d1e10936"/><pre class="programlisting">if (msg.origin.indexOf(".example.com") != −1) { ... }</pre><p>As should be evident, this comparison will not only match sites within <span class="emphasis"><em>example.com</em></span> but will also happily accept messages from <a class="ulink" href="http://www.example.com.bunnyoutlet.com">www.example.com.bunnyoutlet.com</a>. In all likelihood, you will stumble upon code like this more than once in your journeys. Such is life!</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Recent tweaks to HTML5 extended the <span class="emphasis"><em>postMessage(...)</em></span> API to incorporate somewhat overengineered “ports” and “channels,” which are meant to facilitate stream-oriented communications between websites. Browser support for these features is currently very limited and their practical utility is unclear, but from the security standpoint, they do not appear to be of any special concern.</p></div></div><div class="sect2" title="Interactions with Browser Credentials"><div class="titlepage"><div><div><h2 class="title"><a id="interactions_with_browser_credentials"/>Interactions with Browser Credentials</h2></div></div></div><p>As we are wrapping up the overview of the DOM-based same-origin policy, it is important to note that it is in no way synchronized with ambient credentials, SSL state, network context, or many other potentially security-relevant parameters tracked by the browser. Any two windows or frames opened in a browser will remain same-origin with each other even if the user logs out from one account and logs into another, if the page switches from using a good HTTPS certificate to a bad one, and so on.</p><p>This lack of synchronization can contribute to the exploitability of other security bugs. For example, several sites do not protect their login forms against cross-site request forgery, permitting any third-party site to simply submit a username and a password and log the user into an attacker-controlled account. This may seem harmless at first, but when the content loaded in the browser before and after this operation is considered same-origin, the impact of normally ignored “self-inflicted” cross-site scripting vulnerabilities (i.e., ones where the owner of a particular account can target only himself) is suddenly much greater than it would previously appear. In the most basic scenario, the attacker may first open and keep a frame pointing to a sensitive page on the targeted site (e.g., <a class="ulink" href="http://www.fuzzybunnies.com/address_book.php">http://www.fuzzybunnies.com/address_book.php</a>) and then log the victim into the attacker-controlled account to execute self-XSS in an unrelated component of <a class="ulink" href="http://fuzzybunnies.com">fuzzybunnies.com</a>. Despite the change of HTTP credentials, the code injected in that latter step will have unconstrained access to the previously loaded frame, permitting data theft.<a class="indexterm" id="IDX-CHP-9-0022"/><a class="indexterm" id="IDX-CHP-9-0023"/><a class="indexterm" id="IDX-CHP-9-0024"/><a class="indexterm" id="IDX-CHP-9-0025"/></p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-1" id="ftn.CHP-9-FN-1">43</a>] </sup>This and most other browser security mechanisms are based on DNS labels, not on examining the underlying IP addresses. This has a curious consequence: If the IP of a particular host changes, the attacker may be able to talk to the new destination through the user’s browser, possibly engaging in abusive behaviors while hiding the true origin of the attack (unfortunate, not very interesting) or interacting with the victim's internal network, which normally would not be accessible due to the presence of a firewall (a much more problematic case). Intentional change of an IP for this purpose is known as <span class="emphasis"><em>DNS rebinding</em></span>. Browsers try to mitigate DNS rebinding to some extent by, for example, caching DNS lookup results for a certain time (<span class="emphasis"><em>DNS pinning</em></span>), but these defenses are imperfect.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-2" id="ftn.CHP-9-FN-2">44</a>] </sup>One significant source of same-origin policy bugs is having several separate URL-parsing routines in the browser code. If the parsing approach used in the HTTP stack differs from that used for determining JavaScript origins, problems may arise. Safari, in particular, combated a significant number of SOP bypass flaws caused by pathological URLs, including many of the inputs discussed in <a class="xref" href="ch02.html" title="Chapter 2. It Starts with a URL">Chapter 2</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-3" id="ftn.CHP-9-FN-3">45</a>] </sup>For example, in Internet Explorer, it will still be possible for one page to navigate any other documents that were nominally same-origin but that became “isolated” after setting <span class="emphasis"><em>document.domain</em></span>, to <span class="emphasis"><em>javascript:</em></span> URLs. Doing so permits any JavaScript to execute in the context of such as a pseudo-isolated domain. On top of this, obviously nothing stops the originating page from simply setting its own <span class="emphasis"><em>document.domain</em></span> to a value identical with that of the target in order to eliminate the boundary. In other words, the ability to make a document non-same-origin with other pages through <span class="emphasis"><em>document.domain</em></span> should not be relied upon for anything even remotely serious or security relevant.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-4" id="ftn.CHP-9-FN-4">46</a>] </sup>More about this in <a class="xref" href="ch11.html" title="Chapter 11. Life Outside Same-Origin Rules">Chapter 11</a>, but the most notable example is that of encoding data in URL fragment identifiers. This is possible because navigating frames to a new URL is not subject to security restrictions in most cases, and navigation to a URL where only the fragment identifier changes does not actually trigger a page reload. Framed JavaScipt can simply poll <span class="emphasis"><em>location.hash</em></span> and detect incoming messages this way.</p></div></div></div>
<div class="sect1" title="Same-Origin Policy for XMLHttpRequest"><div class="titlepage"><div><div><h1 class="title"><a id="same-origin_policy_for_xmlhttprequest"/>Same-Origin Policy for XMLHttpRequest</h1></div></div></div><p>The <span class="emphasis"><em>XMLHttpRequest</em></span> API, mentioned in this book on several prior occasions, gives JavaScript programs the ability to issue almost unconstrained HTTP requests to the server from which the host document originated, and read back response headers and the document body. The ability to do so would not be particularly significant were it not for the fact that the mechanism leverages the existing browser HTTP stack and its amenities, including ambient credentials, caching mechanisms, keep-alive sessions, and so on.</p><p>A simple and fairly self-explanatory use of a synchronous <span class="emphasis"><em>XMLHttpRequest</em></span> could be as follows:</p><a id="I_programlisting1_d1e10993"/><pre class="programlisting">var x = new XMLHttpRequest();
x.open("POST", "/some_script.cgi", false);
x.setRequestHeader("X-Random-Header", "Hi mom!");
x.send("...POST payload here...");
alert(x.responseText);</pre><p>Asynchronous requests are very similar but are executed without blocking the JavaScript engine or the browser. The request is issued in the background, and an event handler is called upon completion instead.</p><p>As originally envisioned, the ability to issue HTTP requests via this API and to read back the data is governed by a near-verbatim copy of the same-origin policy with two minor and seemingly random tweaks. First, the <span class="emphasis"><em>document.domain</em></span> setting has no effect on this mechanism, and the destination URL specified for <span class="emphasis"><em>XMLHttpRequest.open(...)</em></span> must always match the true origin of the document. Second, in this context, port number is taken into account in Internet Explorer versions prior to 9, even though this browser ignores it elsewhere.</p><p>The fact that <span class="emphasis"><em>XMLHttpRequest</em></span> gives the user an unprecedented level of control over the HTTP headers in a request can actually be advantageous to security. For example, inserting a custom HTTP header, such as <span class="emphasis"><em>X-Coming-From: same-origin</em></span>, is a very simple way to verify that a particular request is not coming from a third-party domain, because no other site should be able to insert a custom header into a browser-issued request. This assurance is not very strong, because no specification says that the implicit restriction on cross-domain headers can’t change;<sup>[<a class="footnote" href="#ftn.CHP-9-FN-5" id="CHP-9-FN-5">47</a>]</sup> nevertheless, when it comes to web security, such assumptions are often just something you have to learn to live with.</p><p>Control over the structure of an HTTP request can also be a burden, though, because inserting certain types of headers may change the meaning of a request to the destination server, or to the proxies, without the browser realizing it. For example, specifying an incorrect <span class="emphasis"><em>Content-Length</em></span> value may allow an attacker to smuggle a second request into a keep-alive HTTP session maintained by the browser, as shown here.<a class="indexterm" id="IDX-CHP-9-0026"/><a class="indexterm" id="IDX-CHP-9-0027"/><a class="indexterm" id="IDX-CHP-9-0028"/></p><a id="I_programlisting1_d1e11035"/><pre class="programlisting">var x = new XMLHttpRequest();
x.open("POST", "http://www.example.com/", false);

// This overrides the browser-computed Content-Length header:
x.setRequestHeader(<strong class="userinput"><code>"Content-Length", "7"</code></strong>);

// The server will assume that this payload ends after the first
// seven characters, and that the remaining part is a separate
// HTTP request.
x.send(
  "Gotcha!\n" +
  <strong class="userinput"><code>"GET /evil_response.html HTTP/1.1\n" +</code></strong>
  <strong class="userinput"><code>"Host: www.bunnyoutlet.com\n\n"</code></strong>
);</pre><p>If this happens, the response to that second, injected request may be misinterpreted by the browser later, possibly poisoning the cache or injecting content into another website. This problem is especially pronounced if an HTTP proxy is in use and all HTTP requests are sent through a shared channel.</p><p>Because of this risk, and following a lot of trial and error, modern browsers blacklist a selection of HTTP headers and request methods. This is done with relatively little consistency: While <span class="emphasis"><em>Referer</em></span>, <span class="emphasis"><em>Content-Length</em></span>, and <span class="emphasis"><em>Host</em></span> are universally banned, the handling of headers such as <span class="emphasis"><em>User-Agent</em></span>, <span class="emphasis"><em>Cookie</em></span>, <span class="emphasis"><em>Origin</em></span>, or <span class="emphasis"><em>If-Modified-Since</em></span> varies from one browser to another. Similarly, the TRACE method is blocked everywhere, because of the unanticipated risk it posed to <span class="emphasis"><em>httponly</em></span> cookies—but the CONNECT method is permitted in Firefox, despite carrying a vague risk of messing with HTTP proxies.</p><p>Naturally, implementing these blacklists has proven to be an entertaining exercise on its own. Strictly for your amusement, consider the following cases that worked in some browsers as little as three years ago:<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-1">176</a>]</sup><a class="indexterm" id="IDX-CHP-9-0029"/></p><a id="I_programlisting1_d1e11082"/><pre class="programlisting">XMLHttpRequest.setRequestHeader("X-Harmless", "1\n<strong class="userinput"><code>Owned: Gotcha</code></strong>");</pre><p>or</p><a id="I_programlisting1_d1e11089"/><pre class="programlisting">XMLHttpRequest.setRequestHeader("<strong class="userinput"><code>Content-Length: 123</code></strong> ", "");</pre><p>or simply</p><a id="I_programlisting1_d1e11096"/><pre class="programlisting">XMLHttpRequest.open("<strong class="userinput"><code>GET\thttp://evil.com\tHTTP/1.0\n\n</code></strong>", "/", false);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p><span class="emphasis"><em>Cross-Origin Resource Sharing</em></span><sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-2">177</a>]</sup> <span class="emphasis"><em>(CORS)</em></span> is a proposed extension to <span class="emphasis"><em>XMLHttpRequest</em></span> that permits HTTP requests to be issued across domains and then read back if a particular response header appears in the returned data. The mechanism changes the semantics of the API discussed in this session by allowing certain “vanilla” cross-domain requests, meant to be no different from regular navigation, to be issued via <span class="emphasis"><em>XMLHttpRequest.open(...)</em></span> with no additional checks; more elaborate requests require an OPTIONS-based preflight request first. CORS is already available in some browsers, but it is opposed by Microsoft engineers, who pursued a competing <span class="emphasis"><em>XDomainRequest</em></span> approach in Internet Explorer 8 and 9. Because the outcome of this conflict is unclear, a detailed discussion of CORS is reserved for <a class="xref" href="ch16.html" title="Chapter 16. New and Upcoming Security Features">Chapter 16</a>, which provides a more systematic overview of upcoming and experimental mechanisms.<a class="indexterm" id="IDX-CHP-9-0030"/><a class="indexterm" id="IDX-CHP-9-0031"/><a class="indexterm" id="IDX-CHP-9-0032"/><a class="indexterm" id="IDX-CHP-9-0033"/><a class="indexterm" id="IDX-CHP-9-0034"/><a class="indexterm" id="IDX-CHP-9-0035"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-5" id="ftn.CHP-9-FN-5">47</a>] </sup>In fact, many plug-ins had problems in this area in the past. Most notably, Adobe Flash permitted arbitrary cross-domain HTTP headers until 2008, at which point its security model underwent a substantial overhaul. Until 2011, the same plug-in suffered from a long-lived implementation bug that caused it to resend any custom headers to an unrelated server following an attacker-supplied HTTP 307 redirect code. Both of these problems are fixed now, but discovery-to-patch time proved troubling.</p></div></div></div>
<div class="sect1" title="Same-Origin Policy for Web Storage"><div class="titlepage"><div><div><h1 class="title"><a id="same-origin_policy_for_web_storage"/>Same-Origin Policy for Web Storage</h1></div></div></div><p>Web storage is a simple database solution first implemented by Mozilla engineers in Firefox 1.5 and eventually embraced by the HTML5 specification.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-3">178</a>]</sup> It is available in all current browsers but not in Internet Explorer 6 or 7.</p><p>Following several dubious iterations, the current design relies on two simple JavaScript objects: <span class="emphasis"><em>localStorage</em></span> and <span class="emphasis"><em>sessionStorage</em></span>. Both objects offer an identical, simple API for creating, retrieving, and deleting name-value pairs in a browser-managed database. For example:</p><a id="I_programlisting1_d1e11159"/><pre class="programlisting">localStorage.setItem("message", "Hi mom!");
alert(localStorage.getItem("message"));
localstorage.removeItem("message");</pre><p>The <span class="emphasis"><em>localStorage</em></span> object implements a persistent, origin-specific storage that survives browser shutdowns, while <span class="emphasis"><em>sessionStorage</em></span> is expected to be bound to the current browser window and provide a temporary caching mechanism that is destroyed at the end of a browsing session. While the specification says that both <span class="emphasis"><em>localStorage</em></span> and <span class="emphasis"><em>sessionStorage</em></span> should be associated with an SOP-like origin (the protocol-host-port tuple), implementations in some browsers do not follow this advice, introducing potential security bugs. Most notably, in Internet Explorer 8, the protocol is not taken into account when computing the origin, putting HTTP and HTTPS pages within a shared context. This design makes it very unsafe for HTTPS sites to store or read back sensitive data through this API. (This problem is corrected in Internet Explorer 9, but there appears to be no plan to backport the fix.)</p><p>In Firefox, on the other hand, the <span class="emphasis"><em>localStorage</em></span> behaves correctly, but the <span class="emphasis"><em>sessionStorage</em></span> interface does not. HTTP and HTTPS use a shared storage context, and although a check is implemented to prevent HTTP content from reading keys created by HTTPS scripts, there is a serious loophole: Any key first created over HTTP, and then updated over HTTPS, will remain visible to nonencrypted pages. This bug, originally reported in 2009,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-4">179</a>]</sup> will eventually be resolved, but when is not clear.</p></div>
<div class="sect1" title="Security Policy for Cookies"><div class="titlepage"><div><div><h1 class="title"><a id="security_policy_for_cookies"/>Security Policy for Cookies</h1></div></div></div><p>We discussed the semantics of HTTP cookies in <a class="xref" href="ch03.html" title="Chapter 3. Hypertext Transfer Protocol">Chapter 3</a>, but that discussion left out one important detail: the security rules that must be implemented to protect cookies belonging to one site from being tampered with by unrelated pages. This topic is particularly interesting because the approach taken here predates the same-origin policy and interacts with it in a number of unexpected ways.<a class="indexterm" id="IDX-CHP-9-0036"/><a class="indexterm" id="IDX-CHP-9-0037"/><a class="indexterm" id="IDX-CHP-9-0038"/></p><p>Cookies are meant to be scoped to domains, and they can’t be limited easily to just a single hostname value. The <span class="emphasis"><em>domain</em></span> parameter provided with a cookie may simply match the current hostname (such as <span class="emphasis"><em>foo.example.com</em></span>), but this will not prevent the cookie from being sent to any eventual subdomains, such as <span class="emphasis"><em>bar.foo.example.com</em></span>. A qualified right-hand fragment of the hostname, such as <span class="emphasis"><em>example.com</em></span>, can be specified to request a broader scope, however.</p><p>Amusingly, the original RFCs imply that Netscape engineers wanted to allow exact host-scoped cookies, but they did not follow their own advice. The syntax devised for this purpose was not recognized by the descendants of Netscape Navigator (or by any other implementation for that matter). To a limited extent, setting host-scoped cookies is possible in some browsers by completely omitting the <span class="emphasis"><em>domain</em></span> parameter, but this method will have no effect in Internet Explorer.</p><p><a class="xref" href="ch09s04.html#a_sample_of_cookie-setting_behaviors" title="Table 9-3. A Sample of Cookie-Setting Behaviors">Table 9-3</a> illustrates cookie-setting behavior in some distinctive cases.</p><div class="table"><a id="a_sample_of_cookie-setting_behaviors"/><p class="title">Table 9-3. A Sample of Cookie-Setting Behaviors</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="A Sample of Cookie-Setting Behaviors"><colgroup><col/><col/><col/></colgroup><thead><tr><th rowspan="2" style="text-align: center" valign="bottom"><p>Cookie set at <span class="emphasis"><em>foo.example.com</em></span>, <span class="emphasis"><em>domain</em></span> parameter is:</p></th><th colspan="2" style="text-align: left" valign="bottom"><p>Scope of the resulting cookie</p></th></tr><tr><th style="text-align: left" valign="bottom"><p>Non-IE browsers</p></th><th style="text-align: left" valign="bottom"><p>Internet Explorer</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>(value omitted)</p></td><td style="text-align: left" valign="top"><p><span class="emphasis"><em>foo.example.com</em></span> (exact)</p></td><td style="text-align: left" valign="top"><p><span class="emphasis"><em>*.foo.example.com</em></span></p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="emphasis"><em>bar.foo.example.com</em></span></p></td><td colspan="2" style="text-align: left" valign="top"><p>Cookie not set: domain more specific than origin</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="emphasis"><em>foo.example.com</em></span></p></td><td colspan="2" style="text-align: left" valign="top"><p><span class="emphasis"><em>*.foo.example.com</em></span></p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="emphasis"><em>baz.example.com</em></span></p></td><td colspan="2" style="text-align: left" valign="top"><p>Cookie not set: domain mismatch</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="emphasis"><em>example.com</em></span></p></td><td colspan="2" style="text-align: left" valign="top"><p><span class="emphasis"><em>*.example.com</em></span></p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="emphasis"><em>ample.com</em></span></p></td><td colspan="2" style="text-align: left" valign="top"><p>Cookie not set: domain mismatch</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="emphasis"><em>.com</em></span></p></td><td colspan="2" style="text-align: left" valign="top"><p>Cookie not set: domain too broad, security risk</p></td></tr></tbody></table></div></div><p>The only other true cookie-scoping parameter is the path prefix: Any cookie can be set with a specified <span class="emphasis"><em>path</em></span> value. This instructs the browser to send the cookie back only on requests to matching directories; a cookie scoped to <span class="emphasis"><em>domain</em></span> of <span class="emphasis"><em>example.com</em></span> and <span class="emphasis"><em>path</em></span> of <span class="emphasis"><em>/some/path/</em></span> will be included on a request to</p><a id="I_programlisting1_d1e11336"/><pre class="programlisting">http://foo<strong class="userinput"><code>.example.com/some/path/</code></strong>subdirectory/hello_world.txt</pre><p>This mechanism can be deceptive. URL paths are not taken into account during same-origin policy checks and, therefore, do not form a useful security boundary. Regardless of how cookies work, JavaScript code can simply hop between any URLs on a single host at will and inject malicious payloads into such targets, abusing any functionality protected with path-bound cookies. (Several security books and white papers recommend path scoping as a security measure to this day. In most cases, this advice is dead wrong.)<a class="indexterm" id="IDX-CHP-9-0039"/><a class="indexterm" id="IDX-CHP-9-0040"/><a class="indexterm" id="IDX-CHP-9-0041"/><a class="indexterm" id="IDX-CHP-9-0042"/><a class="indexterm" id="IDX-CHP-9-0043"/></p><p>Other than the true scoping features (which, along with cookie name, constitute a tuple that uniquely identifies every cookie), web servers can also output cookies with two special, independently operated flags: <span class="emphasis"><em>httponly</em></span> and <span class="emphasis"><em>secure</em></span>. The first, <span class="emphasis"><em>httponly</em></span>, prevents access to the cookie via the <span class="emphasis"><em>document.cookie</em></span> API in the hope of making it more difficult to simply copy a user’s credentials after successfully injecting a malicious script on a page. The second, <span class="emphasis"><em>secure</em></span>, stops the cookie from being submitted on requests over unencrypted protocols, which makes it possible to build HTTPS services that are resistant to active attacks.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-6" id="CHP-9-FN-6">48</a>]</sup></p><p>The pitfall of these mechanisms is that they protect data only against reading and not against overwriting. For example, it is still possible for JavaScript code delivered over HTTP to simply overflow the per-domain cookie jar and then set a new cookie without the <span class="emphasis"><em>secure</em></span> flag.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-7" id="CHP-9-FN-7">49</a>]</sup> Because the <span class="emphasis"><em>Cookie</em></span> header sent by the browser provides no metadata about the origin of a particular cookie or its scope, such a trick is very difficult to detect. A prominent consequence of this behavior is that the common “stateless” way of preventing cross-site request forgery vulnerabilities by simultaneously storing a secret token in a client-side cookie and in a hidden form field, and then comparing the two, is not particularly safe for HTTPS websites. See if you can figure out why!</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Speaking of destructive interference, until 2010, <span class="emphasis"><em>httponly</em></span> cookies also clashed with <span class="emphasis"><em>XMLHttpRequest</em></span>. The authors of that API simply have not given any special thought to whether the <span class="emphasis"><em>XMLHttpRequest.getResponseHeader(...)</em></span> function should be able to inspect server-supplied <span class="emphasis"><em>Set-Cookie</em></span> values flagged as <span class="emphasis"><em>httponly</em></span>—with predictable results.</p></div><div class="sect2" title="Impact of Cookies on the Same-Origin Policy"><div class="titlepage"><div><div><h2 class="title"><a id="impact_of_cookies_on_the_same-origin_pol"/>Impact of Cookies on the Same-Origin Policy</h2></div></div></div><p>The same-origin policy has some undesirable impact on the security of cookies (specifically, on the path-scoping mechanism), but the opposite interaction is more common and more problematic. The difficulty is that HTTP cookies often function as credentials, and in such cases, the ability to obtain them is roughly equivalent to finding a way to bypass SOP. Quite simply, with the right set of cookies, an attacker could use her own browser to interact with the target site on behalf of the victim; same-origin policy is taken out of the picture, and all bets are off.</p><p>Because of this property, any discrepancies between the two security mechanisms can lead to trouble for the more restrictive one. For example, the relatively promiscuous domain-scoping rules used by HTTP cookies mean that it is not possible to isolate fully the sensitive content hosted on <span class="emphasis"><em>webmail.example.com</em></span> from the less trusted HTML present on <span class="emphasis"><em>blog.example.com</em></span>. Even if the owners of the webmail application scope their cookies tightly (usually at the expense of complicating the sign-on process), any attacker who finds a script injection vulnerability on the blogging site can simply overflow the per-domain cookie jar, drop the current credentials, and set his own <span class="emphasis"><em>*.example.com</em></span> cookies. These injected cookies will be sent to <span class="emphasis"><em>webmail.example.com</em></span> on all subsequent requests and will be largely indistinguishable from the real ones.<a class="indexterm" id="IDX-CHP-9-0044"/></p><p>This trick may seem harmless until you realize that such an action may effectively log the victim into a bogus account and that, as a result, certain actions (such as sending email) may be unintentionally recorded within that account and leaked to the attacker before any foul play is noticed. If webmail sounds too exotic, consider doing the same on Amazon or Netflix: Your casual product searches may be revealed to the attacker before you notice anything unusual about the site. (On top of this, many websites are simply not prepared to handle malicious payloads in injected cookies, and unexpected inputs may lead to XSS or similar bugs.)</p><p>The antics of HTTP cookies also make it very difficult to secure encrypted traffic against network-level attackers. A <span class="emphasis"><em>secure</em></span> cookie set by <a class="ulink" href="https://webmail.example.com/">https://webmail.example.com/</a> can still be clobbered and replaced by a made-up value set by a spoofed page at <a class="ulink" href="http://webmail.example.com/">http://webmail.example.com/</a>, even if there is no actual web service listening on port 80 on the target host.</p></div><div class="sect2" title="Problems with Domain Restrictions"><div class="titlepage"><div><div><h2 class="title"><a id="problems_with_domain_restrictions"/>Problems with Domain Restrictions</h2></div></div></div><p>The misguided notion of allowing domain-level cookies also poses problems for browser vendors and is a continuing source of misery. The key question is how to reliably prevent <span class="emphasis"><em>example.com</em></span> from setting a cookie for <span class="emphasis"><em>*.com</em></span> and avoid having this cookie unexpectedly sent to every other destination on the Internet.</p><p>Several simple solutions come to mind, but they fall apart when you have to account for country-level TLDs: <span class="emphasis"><em>example.com.pl</em></span> must be prevented from setting a <span class="emphasis"><em>*.com.pl</em></span> cookie, too. Realizing this, the original Netscape cookie specification provided the following advice:<a class="indexterm" id="IDX-CHP-9-0045"/><a class="indexterm" id="IDX-CHP-9-0046"/></p><div class="blockquote"><blockquote class="blockquote"><p>Only hosts within the specified domain can set a cookie for a domain and domains must have at least two (2) or three (3) periods in them to prevent domains of the form: “.com”, “.edu”, and “va.us”.</p><p>Any domain that fails within one of the seven special top level domains listed below only requires two periods. Any other domain requires at least three. The seven special top level domains are: “COM”, “EDU”, “NET”, “ORG”, “GOV”, “MIL”, and “INT”.</p></blockquote></div><p>Alas, the three-period rule makes sense only for country-level registrars that mirror the top-level hierarchy (<span class="emphasis"><em>example.co.uk</em></span>) but not for the just as populous group of countries that accept direct registrations (<span class="emphasis"><em>example.fr</em></span>). In fact, there are places where both approaches are allowed; for example, both <span class="emphasis"><em>example.jp</em></span> and <span class="emphasis"><em>example.co.jp</em></span> are perfectly fine.</p><p>Because of the out-of-touch nature of this advice, most browsers disregarded it and instead implemented a patchwork of conditional expressions that only led to more trouble. (In one case, for over a decade, you could actually set cookies for <span class="emphasis"><em>*.com.pl</em></span>.) Comprehensive fixes to country-code top-level domain handling have shipped in all modern browsers in the past four years, but as of this writing they have not been backported to Internet Explorer 6 and 7, and they probably never will be.<a class="indexterm" id="IDX-CHP-9-0047"/><a class="indexterm" id="IDX-CHP-9-0048"/><a class="indexterm" id="IDX-CHP-9-0049"/><a class="indexterm" id="IDX-CHP-9-0050"/><a class="indexterm" id="IDX-CHP-9-0051"/><a class="indexterm" id="IDX-CHP-9-0052"/><a class="indexterm" id="IDX-CHP-9-0053"/><a class="indexterm" id="IDX-CHP-9-0054"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>To add insult to injury, the Internet Assigned Numbers Authority added a fair number of top-level domains in recent years (for example, <span class="emphasis"><em>.int</em></span> and <span class="emphasis"><em>.biz</em></span>), and it is contemplating a proposal to allow arbitrary generic top-level domain registrations. If it comes to this, cookies will probably have to be redesigned from scratch.<a class="indexterm" id="IDX-CHP-9-0055"/></p></div></div><div class="sect2" title="The Unusual Danger of “localhost”"><div class="titlepage"><div><div><h2 class="title"><a id="the_unusual_danger_of_llocalhostr"/>The Unusual Danger of “localhost”</h2></div></div></div><p>One immediately evident consequence of the existence of domain-level scoping of cookies is that it is fairly unsafe to delegate any hostnames within a sensitive domain to any untrusted (or simply vulnerable) party; doing so may affect the confidentiality, and invariably the integrity, of any cookie-stored credentials—and, consequently, of any other information handled by the targeted application.</p><p>So much is obvious, but in 2008, Tavis Ormandy spotted something far less intuitive and far more hilarious:<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-5">180</a>]</sup> that because of the port-agnostic behavior of HTTP cookies, an additional danger lies in the fairly popular and convenient administrative practice of adding a “localhost” entry to a domain and having it point to 127.0.0.1.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-8" id="CHP-9-FN-8">50</a>]</sup> When Ormandy first published his advisory, he asserted that this practice is widespread—not a controversial claim to make—and included the following resolver tool output to illustrate his point:<a class="indexterm" id="IDX-CHP-9-0056"/></p><a id="I_programlisting1_d1e11567"/><pre class="programlisting">localhost.microsoft.com has address 127.0.0.1
localhost.ebay.com has address 127.0.0.1
localhost.yahoo.com has address 127.0.0.1
localhost.fbi.gov has address 127.0.0.1
localhost.citibank.com has address 127.0.0.1
localhost.cisco.com has address 127.0.0.1</pre><p>Why would this be a security risk? Quite simply, it puts the HTTP services on the user’s own machine within the same domain as the remainder of the site, and more importantly, it puts all the services that only <span class="emphasis"><em>look</em></span> like HTTP in the very same bucket. These services are typically not exposed to the Internet, so there is no perceived need to design them carefully or keep them up-to-date. Tavis’s case in point is a printer-management service provided by CUPS (Common UNIX Printing System), which would execute attacker-supplied JavaScript in the context of <span class="emphasis"><em>example.com</em></span> if invoked in the following way:<a class="indexterm" id="IDX-CHP-9-0057"/></p><a id="I_programlisting1_d1e11580"/><pre class="programlisting">http://localhost.example.com:631/jobs/?[...]
  &amp;job_printer_uri=<strong class="userinput"><code>javascript:alert("Hi mom!")</code></strong></pre><p>The vulnerability in CUPS can be fixed, but there are likely many other dodgy local services on all operating systems—everything from disk management tools to antivirus status dashboards. Introducing entries pointing back to 127.0.0.1, or any other destinations you have no control over, ties the security of cookies within your domain to the security of random third-party software. That is a good thing to avoid.<a class="indexterm" id="IDX-CHP-9-0058"/><a class="indexterm" id="IDX-CHP-9-0059"/><a class="indexterm" id="IDX-CHP-9-0060"/><a class="indexterm" id="IDX-CHP-9-0061"/><a class="indexterm" id="IDX-CHP-9-0062"/><a class="indexterm" id="IDX-CHP-9-0063"/></p></div><div class="sect2" title="Cookies and “Legitimate” DNS Hijacking"><div class="titlepage"><div><div><h2 class="title"><a id="cookies_and_llegitimater_dns_hijacking"/>Cookies and “Legitimate” DNS Hijacking</h2></div></div></div><p>The perils of the domain-scoping policy for cookies don’t end with <span class="emphasis"><em>localhost</em></span>. Another unintended interaction is related to the common, widely criticized practice of some ISPs and other DNS service providers of hijacking domain lookups for nonexistent (typically mistyped) hosts. In this scheme, instead of returning the standard-mandated NXDOMAIN response from an upstream name server (which would subsequently trigger an error message in the browser or other networked application), the provider will falsify a record to imply that this name resolves to its site. Its site, in turn, will examine the <span class="emphasis"><em>Host</em></span> header supplied by the browser and provide the user with unsolicited, paid contextual advertising that appears to be vaguely related to her browsing interests. The usual justification offered for this practice is that of offering a more user-friendly browsing experience; the real incentive, of course, is to make more money.</p><p>Internet service providers that have relied on this practice include Cablevision, Charter, Earthlink, Time Warner, Verizon, and many more. Unfortunately, their approach is not only morally questionable, but it also creates a substantial security risk. If the advertising site contains any script-injection vulnerabilities, the attacker can exploit them in the context of any other domain simply by accessing the vulnerable functionality through an address such as <span class="emphasis"><em>nonexistent.example.com</em></span>. When coupled with the design of HTTP cookies, this practice undermines the security of any arbitrarily targeted services on the Internet.<a class="indexterm" id="IDX-CHP-9-0064"/><a class="indexterm" id="IDX-CHP-9-0065"/></p><p>Predictably, script-injection vulnerabilities can be found in such hastily designed advertising traps without much effort. For example, in 2008, Dan Kaminsky spotted and publicized a cross-site scripting vulnerability on the pages operated by Earthlink.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-6">181</a>]</sup></p><p>All right, all right: It’s time to stop obsessing over cookies and move on.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-6" id="ftn.CHP-9-FN-6">48</a>] </sup>It does not matter that <span class="emphasis"><em>https://webmail.example.com/</em></span> is offered only over HTTPS. If it uses a cookie that is not locked to encrypted protocols, the attacker may simply wait until the victim navigates to <a class="ulink" href="http://www.fuzzybunnies.com/">http://www.fuzzybunnies.com/</a>, silently inject a frame pointing to <a class="ulink" href="http://webmail.example.com/">http://webmail.example.com/</a> on that page, and then intercept the resulting TCP handshake. The browser will then send all the <span class="emphasis"><em>webmail.example.com</em></span> cookies over an unencrypted channel, and at this point the game is essentially over.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-7" id="ftn.CHP-9-FN-7">49</a>] </sup>Even if this possibility is prevented by separating the jars for <span class="emphasis"><em>httponly</em></span> and normal cookies, multiple identically named but differently scoped cookies must be allowed to coexist, and they will be sent together on any matching requests. They will be not accompanied by any useful metadata, and their ordering will be undefined and browser specific.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-8" id="ftn.CHP-9-FN-8">50</a>] </sup>This IP address is reserved for loopback interfaces; any attempt to connect to it will route you back to the services running on your own machine.</p></div></div></div>
<div class="sect1" title="Plug-in Security Rules"><div class="titlepage"><div><div><h1 class="title"><a id="plug-in_security_rules"/>Plug-in Security Rules</h1></div></div></div><p>Browsers do not provide plug-in developers with a uniform and extensible API for enforcing security policies; instead, each plug-in decides what rules should be applied to executed content and how to put them into action. Consequently, even though plug-in security models are to some extent inspired by the same-origin policy, they diverge from it in a number of ways.</p><p>This disconnect can be dangerous. In <a class="xref" href="ch06.html" title="Chapter 6. Browser-Side Scripts">Chapter 6</a>, we discussed the tendency for plug-ins to rely on inspecting the JavaScript <span class="emphasis"><em>location</em></span> object to determine the origin of their hosting page. This misguided practice forced browser developers to restrict the ability of JavaScript programs to tamper with some portions of their runtime environment to save the day. Another related, common source of incompatibilities is the interpretation of URLs. For example, in the middle of 2010, one researcher discovered that Adobe Flash had trouble with the following URL:<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-7">182</a>]</sup><a class="indexterm" id="IDX-CHP-9-0066"/><a class="indexterm" id="IDX-CHP-9-0067"/></p><a id="I_programlisting1_d1e11656"/><pre class="programlisting">http://example.com:80@bunnyoutlet.com/</pre><p>The plug-in decided that the origin of any code retrieved through this URL should be set to <span class="emphasis"><em>example.com</em></span>, but the browser, when presented with such a URL, would naturally retrieve the data from <a class="ulink" href="http://bunnyoutlet.com">bunnyoutlet.com</a> instead and then hand it over to the confused plug-in for execution.</p><p>While this particular bug is now fixed, other vulnerabilities of this type can probably be expected in the future. Replicating some of the URL-parsing quirks discussed in <a class="xref" href="ch02.html" title="Chapter 2. It Starts with a URL">Chapter 2</a> and <a class="xref" href="ch03.html" title="Chapter 3. Hypertext Transfer Protocol">Chapter 3</a> can be a fool’s errand and, ideally, should not be attempted at all.</p><p>It would not be polite to end this chapter on such a gloomy note! Systemic problems aside, let’s see how some of the most popular plug-ins approach the job of security policy enforcement.</p><div class="sect2" title="Adobe Flash"><div class="titlepage"><div><div><h2 class="title"><a id="adobe_flash-id1"/>Adobe Flash</h2></div></div></div><p>The Flash security model underwent a major overhaul in 2008,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-8">183</a>]</sup> and since then, it has been reasonably robust. Every loaded Flash applet is now assigned an SOP-like origin derived from its originating URL<sup>[<a class="footnote" href="#ftn.CHP-9-FN-9" id="CHP-9-FN-9">51</a>]</sup> and is granted nominal origin-related permissions roughly comparable to those of JavaScript. In particular, each applet can load cookie-authenticated content from its originating site, load some constrained datatypes from other origins, and make same-origin <span class="emphasis"><em>XMLHttpRequest</em></span>-like HTTP calls through the <span class="emphasis"><em>URLRequest</em></span> API. The set of permissible methods and request headers for this last API is managed fairly reasonably and, as of this writing, is more restrictive than most of the browser-level blacklists for <span class="emphasis"><em>XMLHttpRequest</em></span> itself.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-9">184</a>]</sup></p><p>On top of this sensible baseline, three flexible but easily misused mechanisms permit this behavior to be modified to some extent, as discussed next.</p><div class="sect3" title="Markup-Level Security Controls"><div class="titlepage"><div><div><h3 class="title"><a id="markup-level_security_controls"/>Markup-Level Security Controls</h3></div></div></div><p>The embedding page can specify three special parameters provided through <span class="emphasis"><em>&lt;embed&gt;</em></span> or <span class="emphasis"><em>&lt;object&gt;</em></span> tags to control how an applet will interact with its host page and the browser itself:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="bolditalic">AllowScriptAccess</span> <span class="strong"><strong>parameter</strong></span> This setting controls an applet’s ability to use the JavaScript <span class="emphasis"><em>ExternalInterface.call(...)</em></span> bridge (see <a class="xref" href="ch08.html" title="Chapter 8. Content Rendering with Browser Plug-ins">Chapter 8</a>) to execute JavaScript statements in the context of the embedding site. Possible values are <span class="emphasis"><em>always</em></span>, <span class="emphasis"><em>never</em></span>, and <span class="emphasis"><em>sameorigin</em></span>; the last setting gives access to the page only if the page is same-origin with the applet itself. (Prior to the 2008 security overhaul, the plug-in defaulted to <span class="emphasis"><em>always</em></span>; the current default is the much safer <span class="emphasis"><em>sameorigin</em></span>.)</p></li><li class="listitem"><p><span class="bolditalic">AllowNetworking</span> <span class="strong"><strong>parameter</strong></span> This poorly named setting restricts an applet’s permission to open or navigate browser windows and to make HTTP requests to its originating server. When set to <span class="emphasis"><em>all</em></span> (the default), the applet can interfere with the browser; when set to <span class="emphasis"><em>internal</em></span>, it can perform only nondisruptive, internal communications through the Flash plug-in. Setting this parameter to <span class="emphasis"><em>none</em></span> disables most network-related APIs altogether.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-10" id="CHP-9-FN-10">52</a>]</sup> (Prior to recent security improvements, <span class="emphasis"><em>allowNetworking=all</em></span> opened up several ways to bypass <span class="emphasis"><em>allowScriptAccess=none</em></span>, for example, by calling <span class="emphasis"><em>getURL(...)</em></span> on a <span class="emphasis"><em>javascript:</em></span> URL. As of this writing, however, all scripting URLs should be blacklisted in this scenario.)<a class="indexterm" id="IDX-CHP-9-0068"/><a class="indexterm" id="IDX-CHP-9-0069"/><a class="indexterm" id="IDX-CHP-9-0070"/><a class="indexterm" id="IDX-CHP-9-0071"/><a class="indexterm" id="IDX-CHP-9-0072"/><a class="indexterm" id="IDX-CHP-9-0073"/></p></li><li class="listitem"><p><span class="bolditalic">AllowFullScreen</span> <span class="strong"><strong>parameter</strong></span> This parameter controls whether an applet should be permitted to go into full-screen rendering mode. The possible values are <span class="emphasis"><em>true</em></span> and <span class="emphasis"><em>false</em></span>, with <span class="emphasis"><em>false</em></span> being the default. As noted in <a class="xref" href="ch08.html" title="Chapter 8. Content Rendering with Browser Plug-ins">Chapter 8</a>, the decision to give this capability to Flash applets is problematic due to UI spoofing risks; it should be not enabled unless genuinely necessary.</p></li></ul></div></div><div class="sect3" title="Security.allowDomain(...)"><div class="titlepage"><div><div><h3 class="title"><a id="security.allowdomain_open_parenthesis"/>Security.allowDomain(...)</h3></div></div></div><p>The <span class="emphasis"><em>Security.allowDomain(...)</em></span> method<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-10">185</a>]</sup> allows Flash applets to grant access to their variables and functions to any JavaScript code or to other applets coming from a different origin. Buyer beware: Once such access is granted, there is no reliable way to maintain the integrity of the original Flash execution context. The decision to grant such permissions should not be taken lightly, and the practice of calling <span class="emphasis"><em>allowDomain("*")</em></span> should usually be punished severely.</p><p>Note that a weirdly named <span class="emphasis"><em>allowInsecureDomain(...)</em></span> method is also available. The existence of this method does not indicate that <span class="emphasis"><em>allowDomain(...)</em></span> is particularly secure; rather, the “insecure” variant is provided for compatibility with ancient, pre-2003 semantics that completely ignored the HTTP/HTTPS divide.</p></div><div class="sect3" title="Cross-Domain Policy Files"><div class="titlepage"><div><div><h3 class="title"><a id="cross-domain_policy_files"/>Cross-Domain Policy Files</h3></div></div></div><p>Through the use of <span class="emphasis"><em>loadPolicyFile(...)</em></span>, any Flash applet can instruct its runtime environment to retrieve a security policy file from an almost arbitrary URL. This XML-based document, usually named <span class="emphasis"><em>crossdomain.xml</em></span>, will be interpreted as an expression of consent to cross-domain, server-level access to the origin determined by examining the policy URL.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-11">186</a>]</sup> The syntax of a policy file is fairly self-explanatory and may look like this:</p><a id="I_programlisting1_d1e11845"/><pre class="programlisting">&lt;cross-domain-policy&gt;
  &lt;allow-access-from domain="foo.example.com"/&gt;
  &lt;allow-http-request-headers-from domain="*.example.com"
     headers="X-Some-Header" /&gt;
&lt;/cross-domain-policy&gt;</pre><p>The policy may permit actions such as loading cross-origin resources or issuing arbitrary <span class="emphasis"><em>URLRequest</em></span> calls with whitelisted headers, through the browser HTTP stack. Flash developers do attempt to enforce a degree of path separation: A policy loaded from a particular subdirectory can in principle permit access only to files within that path. In practice, however, the interactions with SOP and with various path-mapping semantics of modern browsers and web application frameworks make it unwise to depend on this boundary.<a class="indexterm" id="IDX-CHP-9-0074"/><a class="indexterm" id="IDX-CHP-9-0075"/><a class="indexterm" id="IDX-CHP-9-0076"/><a class="indexterm" id="IDX-CHP-9-0077"/><a class="indexterm" id="IDX-CHP-9-0078"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Making raw TCP connections via <span class="emphasis"><em>XMLSocket</em></span> is also possible and controlled by an XML policy, but following Flash’s 2008 overhaul, <span class="emphasis"><em>XMLSocket</em></span> requires that a separate policy file be delivered on TCP port 843 of the destination server. This is fairly safe, because no other common services run on this port and, on many operating systems, only privileged users can launch services on any port below 1024. Because of the interactions with certain firewall-level mechanisms, such as FTP protocol helpers, this design may still cause some network-level interference,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-12">187</a>]</sup> but this topic is firmly beyond the scope of this book</p></div><p>As expected, poorly configured <span class="emphasis"><em>crossdomain.xml</em></span> policies are an appreciable security risk. In particular, it is a very bad idea to specify <span class="emphasis"><em>allow-access-from</em></span> rules that point to any domain you do not have full confidence in. Further, specifying “<code class="literal">*</code>” as a value for this parameter is roughly equivalent to executing <span class="emphasis"><em>document.domain = “com”</em></span>. That is, it’s a death wish.</p></div><div class="sect3" title="Policy File Spoofing Risks"><div class="titlepage"><div><div><h3 class="title"><a id="policy_file_spoofing_risks"/>Policy File Spoofing Risks</h3></div></div></div><p>Other than the possibility of configuration mistakes, another security risk with Adobe’s policy-based security model is that random user-controlled documents may be interpreted as cross-domain policies, contrary to the site owner’s intent.</p><p>Prior to 2008, Flash used a notoriously lax policy parser, which when processing <span class="emphasis"><em>loadPolicyFile(...)</em></span> files would skip arbitrary leading garbage in search of the opening <span class="emphasis"><em>&lt;cross-domain-policy&gt;</em></span> tag. It would simply ignore the MIME type returned by the server when downloading the resource, too. As a result, merely hosting a valid, user-supplied JPEG image could become a grave security risk. The plug-in also skipped over any HTTP redirects, making it dangerous to do something as simple as issuing an HTTP redirect to a location you did not control (an otherwise harmless act).</p><p>Following the much-needed revamp of the <span class="emphasis"><em>loadPolicyFile</em></span> behavior, many of the gross mistakes have been corrected, but the defaults are still not perfect. On the one hand, redirects now work intuitively, and the file must be a well-formed XML document. On the other, permissible MIME types include <span class="emphasis"><em>text/*</em></span>, <span class="emphasis"><em>application/xml</em></span>, and <span class="emphasis"><em>application/xhtml+xml</em></span>, which feels a bit too broad. <span class="emphasis"><em>text/plain</em></span> or <span class="emphasis"><em>text/csv</em></span> may be misinterpreted as a policy file, and that should not be the case.<a class="indexterm" id="IDX-CHP-9-0079"/></p><p>Thankfully, to mitigate the problem, Adobe engineers decided to roll out <span class="emphasis"><em>meta-policies</em></span>, policies that are hosted at a predefined, top-level location (<span class="emphasis"><em>/crossdomain.xml</em></span>) that the attacker can’t override. A meta-policy can specify sitewide restrictions for all the remaining policies loaded from attacker-supplied URLs. The most important of these restrictions is <span class="emphasis"><em>&lt;site-control permitted-cross-domain-policies="..."&gt;</em></span>. This parameter, when set to <span class="emphasis"><em>master-only</em></span>, simply instructs the plug-in to disregard subpolicies altogether. Another, less radical value, <span class="emphasis"><em>by-content-type</em></span>, permits additional policies to be loaded but requires them to have a nonambiguous <span class="emphasis"><em>Content-Type</em></span> header set to <span class="emphasis"><em>text/x-cross-domain-policy</em></span>.<a class="indexterm" id="IDX-CHP-9-0080"/><a class="indexterm" id="IDX-CHP-9-0081"/><a class="indexterm" id="IDX-CHP-9-0082"/><a class="indexterm" id="IDX-CHP-9-0083"/><a class="indexterm" id="IDX-CHP-9-0084"/></p><p>Needless to say, it’s highly advisable to use a meta-policy that specifies one of these two directives.</p></div></div><div class="sect2" title="Microsoft Silverlight"><div class="titlepage"><div><div><h2 class="title"><a id="microsoft_silverlight-id1"/>Microsoft Silverlight</h2></div></div></div><p>If the transition from Flash to Silverlight seems abrupt, it’s because the two are easy to confuse. The Silverlight plug-in borrows from Flash with remarkable zeal; in fact, it is safe to say that most of the differences between their security models are due solely to nomenclature. Microsoft’s platform uses the same-origin-determination approach, substitutes <span class="emphasis"><em>allowScriptAccess</em></span> with <span class="emphasis"><em>enableHtmlAccess</em></span>, replaces <span class="emphasis"><em>crossdomain.xml</em></span> with the slightly different <span class="emphasis"><em>clientaccesspolicy.xml</em></span> syntax, provides a <span class="emphasis"><em>System.Net.Sockets</em></span> API instead of <span class="emphasis"><em>XMLSocket</em></span>, uses <span class="emphasis"><em>HttpWebRequest</em></span> in place of <span class="emphasis"><em>URLRequest</em></span>, rearranges the flowers, and changes the curtains in the living room.</p><p>The similarities are striking, down to the list of blocked request headers for the <span class="emphasis"><em>HttpWebRequest</em></span> API, which even includes <span class="emphasis"><em>X-Flash-Version</em></span> from the Adobe spec.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-13">188</a>]</sup> Such consistency is not a problem, though: In fact, it is preferable to having a brand-new security model to take into account. Plus, to its credit, Microsoft did make a couple of welcome improvements, including ditching the insecure <span class="emphasis"><em>allowDomain</em></span> logic in favor of <span class="emphasis"><em>RegisterScriptableObject</em></span>, an approach that allows only explicitly specified callbacks to be exposed to third-party domains.</p></div><div class="sect2" title="Java"><div class="titlepage"><div><div><h2 class="title"><a id="java"/>Java</h2></div></div></div><p>Sun’s Java (now officially belonging to Oracle) is a very curious case. Java is a plug-in that has fallen into disuse, and its security architecture has not received much scrutiny in the past decade or so. Yet, because of its large installed base, it is difficult to simply ignore it and move on.<a class="indexterm" id="IDX-CHP-9-0085"/></p><p>Unfortunately, the closer you look, the more evident it is that the ideas embraced by Java tend to be incompatible with the modern Web. For example, a class called <span class="emphasis"><em>java.net.HttpURLConnection</em></span><sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-14">189</a>]</sup> permits credential-bearing HTTP requests to be made to an applet’s originating website, but the “originating website” is understood as <span class="emphasis"><em>any</em></span> website hosted at a particular IP address, as sanctioned by the <span class="emphasis"><em>java.net.URL.equals(...)</em></span> check. This model essentially undoes any isolation between HTTP/1.1 virtual hosts—an isolation strongly enforced by the same-origin policy, HTTP cookies, and virtually all other browser security mechanisms in use today.</p><p>Further along these lines, the <span class="emphasis"><em>java.net.URLConnection</em></span> class<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-15">190</a>]</sup> allows arbitrary request headers, including <span class="emphasis"><em>Host</em></span>, to be set by the applet, and another class, <span class="emphasis"><em>Socket</em></span>,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-16">191</a>]</sup> permits unconstrained TCP connections to arbitrary ports on the originating server. All of these behaviors are frowned upon in the browser and in any other contemporary plug-in.</p><p>Origin-agnostic access from the applet to the embedding page is provided through the <span class="emphasis"><em>JSObject</em></span> mechanism and is expected to be controlled by the embedding party through the <span class="emphasis"><em>mayscript</em></span> attribute specified in the <span class="emphasis"><em>&lt;applet&gt;</em></span>, <span class="emphasis"><em>&lt;embed&gt;</em></span>, or <span class="emphasis"><em>&lt;object&gt;</em></span> tags.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-17">192</a>]</sup> The documentation suggests that this is a security feature:<a class="indexterm" id="IDX-CHP-9-0086"/><a class="indexterm" id="IDX-CHP-9-0087"/><a class="indexterm" id="IDX-CHP-9-0088"/><a class="indexterm" id="IDX-CHP-9-0089"/><a class="indexterm" id="IDX-CHP-9-0090"/></p><div class="blockquote"><blockquote class="blockquote"><p>Due to security reasons, JSObject support is not enabled in Java Plug-in by default. To enable JSObject support in Java Plug-in, a new attribute called MAYSCRIPT needs to be present in the EMBED/OBJECT tag.</p></blockquote></div><p>Unfortunately, the documentation neglects to mention that another closely related mechanism, <span class="emphasis"><em>DOMService</em></span>,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-18">193</a>]</sup> ignores this setting and gives applets largely unconstrained access to the embedding page. While <span class="emphasis"><em>DOMService</em></span> is not supported in Firefox and Opera, it is available in other browsers, which makes any attempt to load third-party Java content equivalent to granting full access to the embedding site.</p><p>Whoops.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Interesting fact: Recent versions of Java attempt to copy the <span class="emphasis"><em>crossdomain.xml</em></span> support available in Flash.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-9" id="ftn.CHP-9-FN-9">51</a>] </sup>In some contexts, Flash may implicitly permit access from HTTPS origins to HTTP ones but not the other way round. This is usually harmless, and as such, it is not given special attention throughout the remainder of this section.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-10" id="ftn.CHP-9-FN-10">52</a>] </sup>It should not be assumed that this setting prevents any sensitive data available to a rogue applet from being relayed to third parties. There are many side channels that any Flash applet could leverage to leak information to a cooperating party without directly issuing network requests. In the simplest and most universal case, CPU loads can be manipulated to send out individual bits of information to any simultaneously loaded applet that continuously samples the responsiveness of its runtime environment.</p></div></div></div>
<div class="sect1" title="Coping with Ambiguous or Unexpected Origins"><div class="titlepage"><div><div><h1 class="title"><a id="coping_with_ambiguous_or_unexpected_orig"/>Coping with Ambiguous or Unexpected Origins</h1></div></div></div><p>This concludes our overview of the basic security policies and consent isolation mechanisms. If there is one observation to be made, it’s that most of these mechanisms depend on the availability of a well-formed, canonical hostname from which to derive the context for all the subsequent operations. But what if this information is not available or is not presented in the expected form?</p><p>Well, that’s when things get funny. Let’s have a look at some of the common corner cases, even if just for fleeting amusement.</p><div class="sect2" title="IP Addresses"><div class="titlepage"><div><div><h2 class="title"><a id="ip_addresses"/>IP Addresses</h2></div></div></div><p>Due to the failure to account for IP addresses when designing HTTP cookies and the same-origin policy, almost all browsers have historically permitted documents loaded from, say, <span class="emphasis"><em>http://1.2.3.4/</em></span> to set cookies for a “domain” named <span class="emphasis"><em>*.3.4</em></span>. Adjusting <span class="emphasis"><em>document.domain</em></span> in a similar manner would work as well. In fact, some of these behaviors are still present in older versions of Internet Explorer.</p><p>This behavior is unlikely to have an impact on mainstream web applications, because such applications are not meant to be accessed through an IP-based URL and will often simply fail to function properly. But a handful of systems, used primarily by technical staff, are meant to be accessed by their IP addresses; these systems may simply not have DNS records configured at all. In these cases, the ability for <span class="emphasis"><em>http://1.2.3.4/</em></span> to inject cookies for <span class="emphasis"><em>http://123.234.3.4/</em></span> may be an issue. The IP-reachable administrative interfaces of home routers are of some interest, too.</p></div><div class="sect2" title="Hostnames with Extra Periods"><div class="titlepage"><div><div><h2 class="title"><a id="hostnames_with_extra_periods"/>Hostnames with Extra Periods</h2></div></div></div><p>At their core, cookie-setting algorithms still depend on counting the number of periods in a URL to determine whether a particular <span class="emphasis"><em>domain</em></span> parameter is acceptable. In order to make the call, the count is typically correlated with a list of several hundred entries on the vendor-maintained Public Suffix List (<a class="ulink" href="http://publicsuffix.org/">http://publicsuffix.org/</a>).<a class="indexterm" id="IDX-CHP-9-0091"/><a class="indexterm" id="IDX-CHP-9-0092"/><a class="indexterm" id="IDX-CHP-9-0093"/><a class="indexterm" id="IDX-CHP-9-0094"/><a class="indexterm" id="IDX-CHP-9-0095"/><a class="indexterm" id="IDX-CHP-9-0096"/><a class="indexterm" id="IDX-CHP-9-0097"/><a class="indexterm" id="IDX-CHP-9-0098"/><a class="indexterm" id="IDX-CHP-9-0099"/></p><p>Unfortunately for this algorithm, it is often possible to put extra periods in a hostname and still have it resolve correctly. Noncanonical hostname representations with excess periods are usually honored by OS-level resolvers and, if honored, will confuse the browser. Although said browser would not automatically consider a domain such as <a class="ulink" href="http://www.example.com.pl">www.example.com.pl</a>. (with an extra trailing period) to be the same as the real <a class="ulink" href="http://www.example.com.pl">www.example.com.pl</a>, the subtle and seemingly harmless difference in the URL could escape even the most attentive users.</p><p>In such a case, interacting with the URL with trailing period can be unsafe, as other documents sharing the <span class="emphasis"><em>*.com.pl</em></span>. domain may be able to inject cross-domain cookies with relative ease.</p><p>This period-counting problem was first noticed around 1998.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-19">194</a>]</sup> About a decade later, many browser vendors decided to roll out basic mitigations by adding a yet another special case to the relevant code; as of this writing, Opera is still susceptible to this trick.</p></div><div class="sect2" title="Non-Fully Qualified Hostnames"><div class="titlepage"><div><div><h2 class="title"><a id="non-fully_qualified_hostnames"/>Non-Fully Qualified Hostnames</h2></div></div></div><p>Many users browse the Web with their DNS resolvers configured to append local suffixes to all found hostnames, often without knowing. Such settings are usually sanctioned by ISPs or employers through automatic network configuration data (Dynamic Host Configuration Protocol, DHCP).</p><p>For any user browsing with such a setting, the resolution of DNS labels is ambiguous. For example, if the DNS search path includes <span class="emphasis"><em>coredump.cx</em></span>, then <a class="ulink" href="http://www.example.com">www.example.com</a> may resolve to the real <a class="ulink" href="http://www.example.com">www.example.com</a> website or to <a class="ulink" href="http://www.example.com.coredump.cx">www.example.com.coredump.cx</a> if such a record exists. The outcomes are partly controlled by configuration settings and, to some extent, can be influenced by an attacker.</p><p>To the browser, both locations appear to be the same, which may have some interesting side effects. Consider one particularly perverse case: Should <span class="emphasis"><em>http://com</em></span>, which actually resolves to <a class="ulink" href="http://com.coredump.cx/">http://com.coredump.cx/</a>, be able to set <span class="emphasis"><em>*.com</em></span> cookies by simply omitting the <span class="emphasis"><em>domain</em></span> parameter?</p></div><div class="sect2" title="Local Files"><div class="titlepage"><div><div><h2 class="title"><a id="local_files"/>Local Files</h2></div></div></div><p>Because local resources loaded through the <span class="emphasis"><em>file:</em></span> protocol do not have an explicit hostname associated with them, it’s impossible for the browser to compute a normal origin. For a very long time, the vendors simply decided that the best course of action in such a case would be to simply ditch the same-origin policy. Thus, any HTML document saved to disk would automatically be granted access to any other local files via <span class="emphasis"><em>XMLHttpRequest</em></span> or DOM and, even more inexplicably, would be able to access any Internet-originating content in the same way.<a class="indexterm" id="IDX-CHP-9-0100"/><a class="indexterm" id="IDX-CHP-9-0101"/><a class="indexterm" id="IDX-CHP-9-0102"/><a class="indexterm" id="IDX-CHP-9-0103"/></p><p>This proved to be a horrible design decision. No one expected that the mere act of downloading an HTML document would put all of the user’s local files, and his online credentials, in jeopardy. After all, accessing that same document over the Web would be perfectly safe.</p><p>Many browsers have tried to close this loophole in recent years, with varying degrees of success:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Chrome (and, by extension, other WebKit browsers)</strong></span></span></dt><dd><p>The Chrome browser completely disallows any cross-document DOM or <span class="emphasis"><em>XMLHttpRequest</em></span> access from <span class="emphasis"><em>file:</em></span> origins, and it ignores <span class="emphasis"><em>document.cookie</em></span> calls or <span class="emphasis"><em>&lt;meta http-equiv="Set-Cookie" ...&gt;</em></span> directives in this setting. Access to a <span class="emphasis"><em>localStorage</em></span> container shared by all <span class="emphasis"><em>file:</em></span> documents is permitted, but this may change soon.</p></dd><dt><span class="term"><span class="strong"><strong>Firefox</strong></span></span></dt><dd><p>Mozilla’s browser permits access only to files within the directory of the original document, as well as nearby subdirectories. This policy is pretty good, but it still poses some risk to documents stored or previously downloaded to that location. Access to cookies via <span class="emphasis"><em>document.cookie</em></span> or <span class="emphasis"><em>&lt;meta http-equiv="Set-Cookie" ...&gt;</em></span> is possible, and all <span class="emphasis"><em>file:</em></span> cookies are visible to any other local JavaScript code.<sup>[<a class="footnote" href="#ftn.CHP-9-FN-11" id="CHP-9-FN-11">53</a>]</sup> The same holds true for access to storage mechanisms.</p></dd><dt><span class="term"><span class="strong"><strong>Internet Explorer 7 and above</strong></span></span></dt><dd><p>Unconstrained access to local and Internet content from <span class="emphasis"><em>file:</em></span> origins is permitted, but it requires the user to click through a nonspecific warning to execute JavaScript first. The consequences of this action are not explained clearly (the help subsystem cryptically states that <span class="emphasis"><em>“Internet Explorer restricts this content because occasionally these programs can malfunction or give you content you don’t want”</em></span>), and many users may well be tricked into clicking through the prompt.</p><p>Internet Explorer’s cookie semantics are similar to those of Firefox. Web storage is not supported in this origin, however.</p></dd><dt><span class="term"><span class="strong"><strong>Opera</strong></span> and <span class="strong"><strong>Internet Explorer 6</strong></span></span></dt><dd><p>Both of these browsers permit unconstrained DOM or <span class="emphasis"><em>XMLHttpRequest</em></span> access without further checks. Noncompartmentalized <span class="emphasis"><em>file:</em></span> cookies are permitted, too.</p></dd></dl></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Plug-ins live by their own rules in <span class="emphasis"><em>file:</em></span> land: Flash uses a <span class="emphasis"><em>local-with-filesystem</em></span> sandbox model,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-9-FT-20">195</a>]</sup> which gives largely unconstrained access to the local filesystem, regardless of the policy enforced by the browser itself, while executing Java or Windows Presentation Framework applets from the local filesystem may in some cases be roughly equivalent to running an untrusted binary.</p></div></div><div class="sect2" title="Pseudo-URLs"><div class="titlepage"><div><div><h2 class="title"><a id="pseudo-urls"/>Pseudo-URLs</h2></div></div></div><p>The behavior of pseudo-URLs such as <span class="emphasis"><em>about:</em></span>, <span class="emphasis"><em>data:</em></span>, or <span class="emphasis"><em>javascript:</em></span> originally constituted a significant loophole in the implementations of the same-origin policy. All such URLs would be considered same-origin and would permit unconstrained cross-domain access from any other resource loaded over the same scheme. The current behavior, which is very different, will be the topic of the next chapter of this book; in a nutshell, the status quo reflects several rounds of hastily implemented improvements and is a complex mix of browser-specific special cases and origin-inheritance rules.<a class="indexterm" id="IDX-CHP-9-0104"/><a class="indexterm" id="IDX-CHP-9-0105"/><a class="indexterm" id="IDX-CHP-9-0106"/><a class="indexterm" id="IDX-CHP-9-0107"/><a class="indexterm" id="IDX-CHP-9-0108"/><a class="indexterm" id="IDX-CHP-9-0109"/><a class="indexterm" id="IDX-CHP-9-0110"/></p></div><div class="sect2" title="Browser Extensions and UI"><div class="titlepage"><div><div><h2 class="title"><a id="browser_extensions_and_ui"/>Browser Extensions and UI</h2></div></div></div><p>Several browsers permit JavaScript-based UI elements or certain user-installed browser extensions to run with elevated privileges. These privileges may entail circumventing specific SOP checks or calling normally unavailable APIs in order to write files, modify configuration settings, and so on.</p><p>Privileged JavaScript is a prominent feature of Firefox, where it is used with XUL to build large portions of the browser user interface. Chrome also relies on privileged JavaScript to a smaller but still notable degree.</p><p>The same-origin policy does not support privileged contexts in any specific way. The actual mechanism by which extra privileges are granted may involve loading the document over a special and normally unreachable URL scheme, such as <span class="emphasis"><em>chrome:</em></span> or <span class="emphasis"><em>res:</em></span>, and then adding special cases for that scheme in other portions of the browser code. Another option is simply to toggle a binary flag for a JavaScript context, regardless of its actual origin, and examine that flag later. In all cases, the behavior of standard APIs such as <span class="emphasis"><em>localStorage</em></span>, <span class="emphasis"><em>document.domain</em></span>, or <span class="emphasis"><em>document.cookie</em></span> may be difficult to predict and should not be relied upon: Some browsers attempt to maintain isolation between the contexts belonging to different extensions, but most don’t.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Whenever writing browser extensions, any interaction with nonprivileged contexts must be performed with extreme caution. Examining untrusted contexts can be difficult, and the use of mechanisms such as <span class="emphasis"><em>eval(...)</em></span> or <span class="emphasis"><em>innerHMTL</em></span> may open up privilege-escalation paths.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-9-FN-11" id="ftn.CHP-9-FN-11">53</a>] </sup>Because there is no compartmentalization between <span class="emphasis"><em>file:</em></span> cookies, it is unsafe to rely on them for legitimate purposes. Some locally installed HTML applications ignore this advice, and consequently, their cookies can be easily tampered with by any downloaded, possibly malicious, HTML document viewed by the user.</p></div></div></div>
<div class="sect1" title="Other Uses of Origins"><div class="titlepage"><div><div><h1 class="title"><a id="other_uses_of_origins"/>Other Uses of Origins</h1></div></div></div><p>Well, that’s all to be said about browser-level content isolation logic for now. It is perhaps worth noting that the concept of origins and host- or domain-based security mechanisms is not limited to that particular task and makes many other appearances in the browser world. Other quasi-origin-based privacy or security features include preferences and cached information related to per-site cookie handling, pop-up blocking, geolocation sharing, password management, camera and microphone access (in Flash), and much, much more. These features tend to interact with the security features described in this chapter at least to some extent; we explore this topic in more detail soon.</p><div class="sidebar"><a id="security_engineering_cheat_sheet-id7"/><p class="title">Security Engineering Cheat Sheet</p><p><span class="bolditalic">Good Security Policy Hygiene for All Websites</span><a class="indexterm" id="IDX-CHP-9-0111"/><a class="indexterm" id="IDX-CHP-9-0112"/><a class="indexterm" id="IDX-CHP-9-0113"/><a class="indexterm" id="IDX-CHP-9-0114"/></p><p>To protect your users, include a top-level <span class="emphasis"><em>crossdomain.xml</em></span> file with the <span class="emphasis"><em>permitted-cross-domain-policies</em></span> parameter set to <span class="emphasis"><em>master-only</em></span> or <span class="emphasis"><em>by-content-type</em></span>, even if you do not use Flash anywhere on your site. Doing so will prevent unrelated attacker-controlled content from being misinterpreted as a secondary <span class="emphasis"><em>crossdomain.xml</em></span> file, effectively undermining the assurances of the same-origin policy in Flash-enabled browsers.</p><p><span class="bolditalic">When Relying on HTTP Cookies for Authentication</span><a class="indexterm" id="IDX-CHP-9-0115"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Use the <span class="emphasis"><em>httponly</em></span> flag; design the application so that there is no need for JavaScript to access authentication cookies directly. Sensitive cookies should be scoped as tightly as possible, preferably by not specifying <span class="emphasis"><em>domain</em></span> at all.</p></li><li class="listitem"><p>If the application is meant to be HTTPS only, cookies must be marked as <span class="emphasis"><em>secure</em></span>, and you must be prepared to handle cookie injection gracefully. (HTTP contexts may overwrite <span class="emphasis"><em>secure</em></span> cookies, even though they can’t read them.) Cryptographic cookie signing may help protect against unconstrained modification, but it does not defend against replacing a victim’s cookies with another set of legitimately obtained credentials.</p></li></ul></div><p><span class="bolditalic">When Arranging Cross-Domain Communications in JavaScript</span><a class="indexterm" id="IDX-CHP-9-0116"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Do not use <span class="emphasis"><em>document.domain</em></span>. Rely on <span class="emphasis"><em>postMessage(...)</em></span> where possible and be sure to specify the destination origin correctly; then verify the sender’s origin when receiving the data on the other end. Beware of naïve substring matches for domain names: <span class="emphasis"><em>msg.origin.indexOf(".example.com")</em></span> is very insecure.</p></li><li class="listitem"><p>Note that various pre-<span class="emphasis"><em>postMessage</em></span> SOP bypass tricks, such as relying on <span class="emphasis"><em>window.name</em></span>, are not tamper-proof and should not be used for exchanging sensitive data.</p></li></ul></div><p><span class="bolditalic">When Embedding Plug-in-Handled Active Content from Third Parties</span><a class="indexterm" id="IDX-CHP-9-0117"/></p><p>Consult the cheat sheet in <a class="xref" href="ch08.html" title="Chapter 8. Content Rendering with Browser Plug-ins">Chapter 8</a> first for general advice.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Flash:</strong></span> Do not specify <span class="emphasis"><em>allowScriptAccess=always</em></span> unless you fully trust the owner of the originating domain and the security of its site. Do not use this setting when embedding HTTP applets on HTTPS pages. Also, consider restricting <span class="emphasis"><em>allowFullScreen</em></span> and <span class="emphasis"><em>allowNetworking</em></span> as appropriate.</p></li><li class="listitem"><p><span class="strong"><strong>Silverlight:</strong></span> Do not specify <span class="emphasis"><em>enableHtmlAccess=true</em></span> unless you trust the originating domain, as above.</p></li><li class="listitem"><p><span class="strong"><strong>Java:</strong></span> Java applets can’t be safely embedded from untrusted sources. Omitting <span class="emphasis"><em>mayscript</em></span> does not fully prevent access to the embedding page, so do not attempt to do so.</p></li></ul></div><p><span class="bolditalic">When Hosting Your Own Plug-in-Executed Content</span><a class="indexterm" id="IDX-CHP-9-0118"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Note that many cross-domain communication mechanisms provided by browser plug-ins may have unintended consequences. In particular, avoid <span class="emphasis"><em>crossdomain.xml</em></span>, <span class="emphasis"><em>clientaccesspolicy.xml</em></span>, or <span class="emphasis"><em>allowDomain(...)</em></span> rules that point to domains you do not fully trust.</p></li></ul></div><p><span class="bolditalic">When Writing Browser Extensions</span><a class="indexterm" id="IDX-CHP-9-0119"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Avoid relying on <span class="emphasis"><em>innerHTML</em></span>, <span class="emphasis"><em>document.write(...)</em></span>, <span class="emphasis"><em>eval(...)</em></span>, and other error-prone coding patterns, which can cause code injection on third-party pages or in a privileged JavaScript context.</p></li><li class="listitem"><p>Do not make security-critical decisions by inspecting untrusted JavaScript security contexts, as their behavior can be deceptive.</p></li></ul></div></div></div>
<div class="chapter" title="Chapter&#xA0;10.&#xA0;Origin Inheritance"><div class="titlepage"><div><div><h1 class="title"><a id="origin_inheritance"/>Chapter 10. Origin Inheritance</h1></div></div></div><p>Some web applications rely on pseudo-URLs such as <span class="emphasis"><em>about:</em></span>, <span class="emphasis"><em>javascript:</em></span>, or <span class="emphasis"><em>data:</em></span> to create HTML documents that do not contain any server-supplied content and that are instead populated with the data constructed entirely on the client side. This approach eliminates the delay associated with the usual HTTP requests to the server and results in far more responsive user interfaces.<a class="indexterm" id="IDX-CHP-10-0001"/><a class="indexterm" id="IDX-CHP-10-0002"/><a class="indexterm" id="IDX-CHP-10-0003"/><a class="indexterm" id="IDX-CHP-10-0004"/></p><p>Unfortunately, the original vision of the same-origin policy did not account for such a use case. Specifically, a literal application of the protocol-, host-, and port-matching rules discussed in <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a> would cause every <span class="emphasis"><em>about:blank</em></span> document created on the client side to have a different origin from its parent page, preventing it from being meaningfully manipulated. Further, all <span class="emphasis"><em>about:blank</em></span> windows created by completely unrelated websites would belong to the same origin and, under the right circumstances, would be able to interfere with each other with no supervision at all.</p><p>To address this incompatibility of client-side documents with the same-origin policy, browsers gradually developed incompatible and sometimes counterintuitive approaches to computing a synthetic origin and access permissions for pseudo-URLs. An understanding of these rules is important on its own merit, and it will lay the groundwork for the discussion of certain other SOP exceptions in <a class="xref" href="ch11.html" title="Chapter 11. Life Outside Same-Origin Rules">Chapter 11</a>.<a class="indexterm" id="IDX-CHP-10-0005"/><a class="indexterm" id="IDX-CHP-10-0006"/><a class="indexterm" id="IDX-CHP-10-0007"/><a class="indexterm" id="IDX-CHP-10-0008"/></p><div class="sect1" title="Origin Inheritance for about:blank"><div class="titlepage"><div><div><h1 class="title"><a id="origin_inheritance_for_about_colon_blank"/>Origin Inheritance for about:blank</h1></div></div></div><p>The <span class="emphasis"><em>about:</em></span> scheme is used in modern browsers for a variety of purposes, most of which are not directly visible to normal web pages. The <span class="emphasis"><em>about:blank</em></span> document is an interesting special case, however: This URL can be used to create a minimal DOM hierarchy (essentially a valid but empty document) to which the parent document may write arbitrary data later on.</p><p>Here is an example of a typical use of this scheme:</p><a id="I_programlisting2_d1e12706"/><pre class="programlisting">&lt;iframe src="<strong class="userinput"><code>about:blank</code></strong>" name="test"&gt;&lt;/iframe&gt;

&lt;script&gt;
  ...
  frames["test"].document.body.innerHTML = "<strong class="userinput"><code>&lt;h1&gt;Hi mom!&lt;/h1&gt;</code></strong>";
  ...
&lt;/script&gt;</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>In the HTML markup provided in this example, and when creating new windows or frames in general, <span class="emphasis"><em>about:blank</em></span> can be omitted. The value is defaulted to when no other URL is specified by the creator of the parent document.</p></div><p>In every browser, most types of navigation to <span class="emphasis"><em>about:blank</em></span> result in the creation of a new document that inherits its SOP origin from the page that initiated the navigation. The inherited origin is reflected in the <span class="emphasis"><em>document.domain</em></span> property of the new JavaScript execution context, and DOM access to or from any other origins is not permitted.</p><p>This simple formula holds true for navigation actions such as clicking a link, submitting a form, creating a new frame or a window from a script, or programmatically navigating an existing document. That said, there are exceptions, the most notable of which are several special, user-controlled navigation methods. These include manually entering <span class="emphasis"><em>about:blank</em></span> in the address bar, following a bookmark, or performing a gesture reserved for opening a link in a new window or a tab.<sup>[<a class="footnote" href="#ftn.CHP-10-FN-1" id="CHP-10-FN-1">54</a>]</sup> These actions will result in a document that occupies a unique synthetic origin and that can’t be accessed by any other page.</p><p>Another special case is the loading of a normal server-supplied document that subsequently redirects to <span class="emphasis"><em>about:blank</em></span> using <span class="emphasis"><em>Location</em></span> or <span class="emphasis"><em>Refresh</em></span>. In Firefox and WebKit-based browsers, such redirection results in a unique, nonaccessible origin, similar to the scenario outlined in the previous paragraph. In Internet Explorer, on the other hand, the resulting document will be accessible by the parent page if the redirection occurs inside an <span class="emphasis"><em>&lt;iframe&gt;</em></span> but not if it took place in a separate window. Opera’s behavior is the most difficult to understand: <span class="emphasis"><em>Refresh</em></span> results in a document that can be accessed by the parent page, but the <span class="emphasis"><em>Location</em></span> redirect will give the resulting page the origin of the site that performed the redirect.<a class="indexterm" id="IDX-CHP-10-0009"/><a class="indexterm" id="IDX-CHP-10-0010"/></p><p>Further, it is possible for a parent document to navigate an existing document frame to an <span class="emphasis"><em>about:blank</em></span> URL, even if the existing document shown in that container has a different origin than the caller.<sup>[<a class="footnote" href="#ftn.CHP-10-FN-2" id="CHP-10-FN-2">55</a>]</sup> The newly created blank document will inherit the origin from the caller in all browsers other than Internet Explorer. In the case of Internet Explorer, such navigation will succeed but will result in an inaccessible document. (This behavior is most likely not intentional.)</p><p>If this description makes your head spin, the handling of <span class="emphasis"><em>about:blank</em></span> documents is summarized in <a class="xref" href="ch10.html#origin_inheritance_for_about_colon" title="Table 10-1. Origin Inheritance for about:blank URLs">Table 10-1</a>.</p><div class="table"><a id="origin_inheritance_for_about_colon"/><p class="title">Table 10-1. Origin Inheritance for <span class="emphasis"><em>about:blank</em></span> URLs</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Origin Inheritance for about:blank URLs"><colgroup><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th rowspan="2" style="border-right: 0.5pt solid ; "> </th><th colspan="5" style="text-align: center" valign="bottom"><p>Type of navigation</p></th></tr><tr><th style="text-align: left" valign="bottom"><p>New page</p></th><th style="text-align: left" valign="bottom"><p>Existing non-same-origin page</p></th><th style="text-align: left" valign="bottom"><p><span class="emphasis"><em>Location</em></span> redirect</p></th><th style="text-align: left" valign="bottom"><p><span class="emphasis"><em>Refresh</em></span> redirect</p></th><th style="text-align: left" valign="bottom"><p>URL entry or gesture</p></th></tr></thead><tbody><tr><td rowspan="2" style="text-align: left" valign="top"><p><span class="strong"><strong>Internet Explorer</strong></span></p></td><td rowspan="2" style="text-align: left" valign="top"><p>Inherited from caller</p></td><td rowspan="2" style="text-align: left" valign="top"><p>Unique origin</p></td><td rowspan="2" style="text-align: left" valign="top"><p>(Denied)</p></td><td style="text-align: left" valign="top"><p><span class="strong"><strong>Frame</strong></span>: Inherited from parent</p></td><td rowspan="5" style="text-align: left" valign="top"><p>Unique origin</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Window</strong></span>: Unique origin</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Firefox</strong></span></p></td><td colspan="2" style="text-align: left" valign="top"><p>Inherited from caller</p></td><td colspan="2" style="text-align: left" valign="top"><p>Unique origin</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>All WebKit</strong></span></p></td><td colspan="2" style="text-align: left" valign="top"><p>Inherited from caller</p></td><td style="text-align: left" valign="top"><p>(Denied)</p></td><td style="text-align: left" valign="top"><p>Unique origin</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Opera</strong></span></p></td><td colspan="2" style="text-align: left" valign="top"><p>Inherited from caller</p></td><td style="text-align: left" valign="top"><p>Inherited from redirecting party</p></td><td style="text-align: left" valign="top"><p>Inherited from parent</p></td></tr></tbody></table></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-1" id="ftn.CHP-10-FN-1">54</a>] </sup>This is usually accomplished by holding ctrl or shift while clicking on a link, or by right-clicking the mouse to access a contextual menu, and then selecting the appropriate option.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-10-FN-2" id="ftn.CHP-10-FN-2">55</a>] </sup>The exact circumstances that make this possible will be the focus of <a class="xref" href="ch11.html" title="Chapter 11. Life Outside Same-Origin Rules">Chapter 11</a>. For now, suffice it to say that this can be accomplished in many settings in a browser-specific way. For example, in Firefox, you call <span class="emphasis"><em>window.open(..., 'target')</em></span>, while in Internet Explorer, calling <span class="emphasis"><em>target.location.assign(...)</em></span> is the way to go.</p></div></div></div>
<div class="sect1" title="Inheritance for data: URLs"><div class="titlepage"><div><div><h1 class="title"><a id="inheritance_for_data_colon_urls"/>Inheritance for data: URLs</h1></div></div></div><p>The <span class="emphasis"><em>data:</em></span> scheme,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-10-FT-1">196</a>]</sup> first outlined in <a class="xref" href="ch02.html" title="Chapter 2. It Starts with a URL">Chapter 2</a>, was designed to permit small documents, such as icons, to be conveniently encoded and then directly inlined in an HTML document, saving time on HTTP round-trips. For example:</p><a id="I_programlisting2_d1e12909"/><pre class="programlisting">&lt;img src="data:image/jpeg;base64,<strong class="userinput"><code>/9j/4AAQSkZJRgABAQEBLAEsAAD</code></strong>..."&gt;</pre><p>When the <span class="emphasis"><em>data:</em></span> scheme is used in conjunction with type-specific subresources, the only unusual security consideration is that it poses a challenge for plug-ins that wish to derive permissions for an applet from its originating URL. The origin can’t be computed by looking at the URL alone, and the behavior is somewhat unpredictable and highly plug-in specific (for example, Adobe Flash currently rejects any attempts to use <span class="emphasis"><em>data:</em></span> documents).<a class="indexterm" id="IDX-CHP-10-0011"/><a class="indexterm" id="IDX-CHP-10-0012"/><a class="indexterm" id="IDX-CHP-10-0013"/><a class="indexterm" id="IDX-CHP-10-0014"/></p><p>More important than the case of type-specific content is the use of <span class="emphasis"><em>data:</em></span> as a destination for windows and frames. In all browsers but Internet Explorer, the scheme can be used as an improved variant of <span class="emphasis"><em>about:blank</em></span>, as in this example:</p><a id="I_programlisting2_d1e12950"/><pre class="programlisting">&lt;iframe src="data:text/html;charset=utf-8,<strong class="userinput"><code>&lt;h1&gt;Hi mom!&lt;/h1&gt;</code></strong>"&gt;
&lt;/iframe&gt;</pre><p>In this scenario, there is no compelling reason for a <span class="emphasis"><em>data:</em></span> URL to behave differently than <span class="emphasis"><em>about:blank</em></span>. In reality, however, it will behave differently in some browsers and therefore must be used with care.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>WebKit browsers</strong></span> In Chrome and Safari, all <span class="emphasis"><em>data:</em></span> documents are given a unique, nonaccessible origin and do not inherit from the parent at all.</p></li><li class="listitem"><p><span class="strong"><strong>Firefox</strong></span> In Firefox, the origin for <span class="emphasis"><em>data:</em></span> documents is inherited from the navigating context, similar to <span class="emphasis"><em>about:blank</em></span>. However, unlike with <span class="emphasis"><em>about:blank</em></span>, manually entering <span class="emphasis"><em>data:</em></span> URLs or opening bookmarked ones results in the new document inheriting origin from the page on which the navigation occurred.</p></li><li class="listitem"><p><span class="strong"><strong>Opera</strong></span> As of this writing, a shared “empty” origin is used for all <span class="emphasis"><em>data:</em></span> URLs, which is accessible by the parent document. This approach is unsafe, as it may allow cross-domain access to frames created by unrelated pages, as shown in <a class="xref" href="ch10s02.html#access_between_data_colon_urls_in_opera" title="Figure 10-1. Access between data: URLs in Opera">Figure 10-1</a>. (I reported this behavior to Opera, and it likely will be amended soon.)</p></li><li class="listitem"><p><span class="strong"><strong>Internet Explorer</strong></span> <span class="emphasis"><em>data:</em></span> URLs are not supported in Internet Explorer versions prior to 8. The scheme is supported only for select types of subresources in Internet Explorer 8 and 9 and can’t be used for navigation.</p></li></ul></div><p><a class="xref" href="ch10s02.html#origin_inheritance_for_data_colon_urls" title="Table 10-2. Origin Inheritance for data: URLs">Table 10-2</a> summarizes the current behavior of <span class="emphasis"><em>data:</em></span> URLs.</p><div class="table"><a id="origin_inheritance_for_data_colon_urls"/><p class="title">Table 10-2. Origin Inheritance for <span class="emphasis"><em>data:</em></span> URLs</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Origin Inheritance for data: URLs"><colgroup><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th rowspan="2" style="border-right: 0.5pt solid ; "> </th><th colspan="5" style="text-align: center" valign="bottom"><p>Type of navigation</p></th></tr><tr><th style="text-align: left" valign="bottom"><p>New page</p></th><th style="text-align: left" valign="bottom"><p>Existing non-same-origin page</p></th><th style="text-align: left" valign="bottom"><p><span class="emphasis"><em>Location</em></span> redirect</p></th><th style="text-align: left" valign="bottom"><p><span class="emphasis"><em>Refresh</em></span> redirect</p></th><th style="text-align: left" valign="bottom"><p>URL entry or gesture</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Internet Explorer 6/7</strong></span></p></td><td colspan="5" style="text-align: left" valign="top"><p>(Not supported)</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Internet Explorer 8/9</strong></span></p></td><td colspan="5" style="text-align: left" valign="top"><p>(Not supported for navigation)</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Firefox</strong></span></p></td><td colspan="2" style="text-align: left" valign="top"><p>Inherited from caller</p></td><td colspan="2" style="text-align: left" valign="top"><p>Unique origin</p></td><td style="text-align: left" valign="top"><p>Inherited from previous page</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>All WebKit</strong></span></p></td><td colspan="2" style="text-align: left" valign="top"><p>Unique origin</p></td><td style="text-align: left" valign="top"><p>(Denied)</p></td><td style="text-align: left" valign="top"><p>Unique origin</p></td><td rowspan="2" style="text-align: left" valign="top"><p>Unique origin</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Opera</strong></span></p></td><td colspan="2" style="text-align: left" valign="top"><p>Shared origin (This is a bug!)</p></td><td style="text-align: left" valign="top"><p>(Denied)</p></td><td style="text-align: left" valign="top"><p>Inherited from parent<a class="indexterm" id="IDX-CHP-10-0015"/><a class="indexterm" id="IDX-CHP-10-0016"/><a class="indexterm" id="IDX-CHP-10-0017"/><a class="indexterm" id="IDX-CHP-10-0018"/><a class="indexterm" id="IDX-CHP-10-0019"/></p></td></tr></tbody></table></div></div><div class="figure"><a id="access_between_data_colon_urls_in_opera"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e13139"/><img alt="Access between data: URLs in Opera" src="httpatomoreillycomsourcenostarchimages950021.png.jpg"/></div></div><p class="title">Figure 10-1. Access between <span class="emphasis"><em>data:</em></span> URLs in Opera</p></div></div>
<div class="sect1" title="Inheritance for javascript: and vbscript: URLs"><div class="titlepage"><div><div><h1 class="title"><a id="inheritance_for_javascript_colon_and_vbs"/>Inheritance for javascript: and vbscript: URLs</h1></div></div></div><p>Scripting-related pseudo-URLs, such as <span class="emphasis"><em>javscript:</em></span>, are a very curious mechanism. Using them to load some types of subresources will lead to code execution in the context of the document that attempts to load such an operation (subject to some inconsistent restrictions, as discussed in <a class="xref" href="ch04.html" title="Chapter 4. Hypertext Markup Language">Chapter 4</a>). An example of this may be</p><a id="I_programlisting2_d1e13154"/><pre class="programlisting">&lt;iframe src="javascript:<strong class="userinput"><code>alert('Hi mom!')</code></strong>"&gt;&lt;/iframe&gt;</pre><p>More interestingly (and far less obviously) than the creation of new subresources, navigating existing windows or frames to <span class="emphasis"><em>javascript:</em></span> URLs will cause the inlined JavaScript code to execute in the context of the navigated page (and not the navigating document!)—even if the URL is entered manually or loaded from a bookmark.</p><p>Given this behavior, it is obviously very unsafe to allow one document to navigate any other non-same-origin context to a <span class="emphasis"><em>javascript:</em></span> URL, as it would enable the circumvention of all other content-isolation mechanisms: Just load <a class="ulink" href="http://fuzzybunnies.com">fuzzybunnies.com</a> in a frame, and then navigate that frame to <span class="emphasis"><em>javascript:do_evil_stuff()</em></span> and call it a day. Consequently, such navigation is prohibited in all browsers except for Firefox. Firefox appears to permit it for some reason, but it changes the semantics in a sneaky way. When the origin of the caller and the navigation target do not match, it executes the <span class="emphasis"><em>javascript:</em></span> payload in a special null origin, which lacks its own DOM or any of the browser-supplied I/O functions registered (thus permitting only purely algorithmic operations to occur).</p><p>The cross-origin case is dangerous, but its same-origin equivalent is not: Within a single origin, any content is free to navigate itself or its peers to <span class="emphasis"><em>javascript:</em></span> URLs on its own volition. In this case, the <span class="emphasis"><em>javascript:</em></span> scheme is honored when following links, submitting forms, calling <span class="emphasis"><em>location.assign(...)</em></span>, and so on. In WebKit and Opera, <span class="emphasis"><em>Refresh</em></span> redirection to <span class="emphasis"><em>javascript:</em></span> will work as well; other browsers reject such navigation due to vague and probably misplaced script-injection concerns.<a class="indexterm" id="IDX-CHP-10-0020"/><a class="indexterm" id="IDX-CHP-10-0021"/><a class="indexterm" id="IDX-CHP-10-0022"/></p><p>The handling of scripting URLs is outlined in <a class="xref" href="ch10s03.html#origin_inheritance_for_data_colon" title="Table 10-3. Origin Inheritance for Scripting URLs">Table 10-3</a>.</p><div class="table"><a id="origin_inheritance_for_data_colon"/><p class="title">Table 10-3. Origin Inheritance for Scripting URLs</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Origin Inheritance for Scripting URLs"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th rowspan="2" style="border-right: 0.5pt solid ; "> </th><th colspan="6" style="text-align: center" valign="bottom"><p>Type of navigation</p></th></tr><tr><th style="text-align: left" valign="bottom"><p>New page</p></th><th style="text-align: left" valign="bottom"><p>Existing same-origin page</p></th><th style="text-align: left" valign="bottom"><p>Existing non-same-origin page</p></th><th style="text-align: left" valign="bottom"><p><span class="emphasis"><em>Location</em></span> redirect</p></th><th style="text-align: left" valign="bottom"><p><span class="emphasis"><em>Refresh</em></span> redirect</p></th><th style="text-align: left" valign="bottom"><p>URL entry or gesture</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Internet Explorer</strong></span></p></td><td rowspan="5" style="text-align: left" valign="top"><p>Inherited from caller</p></td><td rowspan="5" style="text-align: left" valign="top"><p>Inherited from navigated page</p></td><td style="text-align: left" valign="top"><p>(Denied)</p></td><td rowspan="5" style="text-align: left" valign="top"><p>(Denied)</p></td><td style="text-align: left" valign="top"><p>(Denied)</p></td><td rowspan="5" style="text-align: left" valign="top"><p>Inherited from navigated page</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Firefox</strong></span></p></td><td style="text-align: left" valign="top"><p>Null context</p></td><td style="text-align: left" valign="top"><p>(Denied)</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>All WebKit</strong></span></p></td><td style="text-align: left" valign="top"><p>(Denied)</p></td><td style="text-align: left" valign="top"><p>Inherited from navigated page</p></td></tr><tr><td style="text-align: left" valign="top"><p><span class="strong"><strong>Opera</strong></span></p></td><td style="text-align: left" valign="top"><p>(Denied)</p></td><td style="text-align: left" valign="top"><p>Inherited from navigated page</p></td></tr></tbody></table></div></div><p>On top of these fascinating semantics, there is a yet another twist unique to the <span class="emphasis"><em>javascript:</em></span> scheme: In some cases, the handling of such script-containing URLs involves a second step. Specifically, if the supplied code evaluates properly, and the value of the last statement is nonvoid and can be converted to a string, this string will be interpreted as an HTML document and will replace the navigated page (inheriting origin from the caller). The logic governing this curious behavior is very similar to that influencing the behavior of <span class="emphasis"><em>data:</em></span> URLs. An example of such a document-replacing expression is this:</p><a id="I_programlisting2_d1e13320"/><pre class="programlisting">javascript:"&lt;b&gt;2 + 2 = " + (2+2) + "&lt;/b&gt;"</pre></div>
<div class="sect1" title="A Note on Restricted Pseudo-URLs"><div class="titlepage"><div><div><h1 class="title"><a id="a_note_on_restricted_pseudo-urls"/>A Note on Restricted Pseudo-URLs</h1></div></div></div><p>The somewhat quirky behavior of the three aforementioned classes of URLs—<span class="emphasis"><em>about:blank</em></span>, <span class="emphasis"><em>javascript:</em></span>, and <span class="emphasis"><em>data:</em></span>—are all that most websites need to be concerned with. Nevertheless, browsers use a range of other documents with no inherent, clearly defined origin (e.g., <span class="emphasis"><em>about:config</em></span> in Firefox, a privileged JavaScript page that can be used to tweak the browser’s various under-the-hood settings, or <span class="emphasis"><em>chrome://downloads</em></span> in Chrome, which lists the recently downloaded documents with links to open any of them). These documents are a continued source of security problems, even if they are not reachable directly from the Internet.</p><p>Because of the incompatibility of these URLs with the boundaries controlled by the same-origin policy, special care must be taken to make sure that these URLs are sufficiently isolated from other content whenever they are loaded in the browser as a result of user action or some other indirect browser-level process. An interesting case illustrating the risk is a 2010 bug in the way Firefox handled <span class="emphasis"><em>about:neterror</em></span>.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-10-FT-2">197</a>]</sup> Whenever Firefox can’t correctly retrieve a document from a remote server (a condition that is usually easy to trigger with a carefully crafted link), it puts the destination URL in the address bar but loads <span class="emphasis"><em>about:neterror</em></span> in place of the document body. Unfortunately, due to a minor oversight, this special error page would be same-origin with any <span class="emphasis"><em>about:blank</em></span> document opened by any Internet-originating content, thereby permitting the attacker to inject arbitrary content into the <span class="emphasis"><em>about:neterror</em></span> window while preserving the displayed destination URL.</p><p>The moral of this story? Avoid the urge to gamble with the same-origin policy; instead, play along with it. Note that making <span class="emphasis"><em>about:neterror</em></span> a hierarchical URL, instead of trying to keep track of synthetic origins, would have prevented the bug.</p><div class="sidebar"><a id="security_engineering_cheat_sheet-id8"/><p class="title">Security Engineering Cheat Sheet</p><p>Because of their incompatibility with the same-origin policy, <span class="emphasis"><em>data:</em></span>, <span class="emphasis"><em>javascript:</em></span>, and implicit or explicit <span class="emphasis"><em>about:blank</em></span> URLs should be used with care. When performance is not critical, it is preferable to seed new frames and windows by pointing them to a server-supplied blank document with a definite origin first.<a class="indexterm" id="IDX-CHP-10-0023"/></p><p>Keep in mind that <span class="emphasis"><em>data:</em></span> and <span class="emphasis"><em>javascript:</em></span> URLs are not a drop-in replacement for <span class="emphasis"><em>about:blank</em></span>, and they should be used only when absolutely necessary. In particular, it is currently unsafe to assume that <span class="emphasis"><em>data:</em></span> windows can’t be accessed across domains.</p></div></div>
<div class="chapter" title="Chapter&#xA0;11.&#xA0;Life Outside Same-Origin Rules"><div class="titlepage"><div><div><h1 class="title"><a id="life_outside_same-origin_rules"/>Chapter 11. Life Outside Same-Origin Rules</h1></div></div></div><p>The same-origin policy is the most important mechanism we have to keep hostile web applications at bay, but it’s also an imperfect one. Although it is meant to offer a robust degree of separation between any two different and clearly identifiable content sources, it often fails at this task.<a class="indexterm" id="IDX-CHP-11-0001"/><a class="indexterm" id="IDX-CHP-11-0002"/></p><p>To understand this disconnect, recall that contrary to what common sense may imply, the same-origin policy was never meant to be all-inclusive. Its initial focus, the DOM hierarchy (that is, just the <span class="emphasis"><em>document</em></span> object exposed to JavaScript code) left many of the peripheral JavaScript features completely exposed to cross-domain manipulation, necessitating ad hoc fixes. For example, a few years after the inception of SOP, vendors realized that allowing third-party documents to tweak the <span class="emphasis"><em>location.host</em></span> property of an unrelated window is a bad idea and that such an operation could send potentially sensitive data present in other URL segments to an attacker-specified site. The policy has subsequently been extended to at least partly protect this and a couple of other sensitive objects, but in some less clear-cut cases, awkward loopholes remain.<a class="indexterm" id="IDX-CHP-11-0003"/><a class="indexterm" id="IDX-CHP-11-0004"/><a class="indexterm" id="IDX-CHP-11-0005"/><a class="indexterm" id="IDX-CHP-11-0006"/><a class="indexterm" id="IDX-CHP-11-0007"/><a class="indexterm" id="IDX-CHP-11-0008"/><a class="indexterm" id="IDX-CHP-11-0009"/></p><p>The other problem is that many cross-domain interactions happen completely outside of JavaScript and its object hierarchy. Actions such as loading third-party images or stylesheets are deeply rooted in the design of HTML and do not depend on scripting in any meaningful way. (In principle, it would be possible to retrofit them with origin-based security controls, but doing so would interfere with existing websites. Plus, some think that such a decision would go against the design principles that made the Web what it is; they believe that the ability to freely cross-reference content should not be infringed upon.)</p><p>In light of this, it seems prudent to explore the boundaries of the same-origin policy and learn about the rich life that web applications can lead outside its confines. We begin with document navigation—a mechanism that at first seems strikingly simple but that is really anything but.</p><div class="sect1" title="Window and Frame Interactions"><div class="titlepage"><div><div><h1 class="title"><a id="window_and_frame_interactions"/>Window and Frame Interactions</h1></div></div></div><p>On the Web, the ability to steer the browser from one website to another is taken for granted. Some of the common methods of achieving such navigation are discussed throughout <a class="xref" href="pt01.html" title="Part I. Anatomy of the Web">Part I</a> of this book; the most notable of these are HTML links, forms, and frames; HTTP redirects; and JavaScript <span class="emphasis"><em>window.open(...)</em></span> and <span class="emphasis"><em>location.*</em></span> calls.</p><p>Actions such as pointing a newly opened window to an off-domain URL or specifying the <span class="emphasis"><em>src</em></span> parameter of a frame are intuitive and require no further review. But when we look at the ability of one page to navigate another, existing document—well, the reign of intuition comes to a sudden end.</p><div class="sect2" title="Changing the Location of Existing Documents"><div class="titlepage"><div><div><h2 class="title"><a id="changing_the_location_of_existing_docume"/>Changing the Location of Existing Documents</h2></div></div></div><p>In the simple days before the advent of HTML frames, only one document could occupy a given browser window, and only that single window would be under the document’s control. Frames changed this paradigm, however, permitting several different and completely separate documents to be spliced into a single logical view, coexisting within a common region of the screen. The introduction of the mechanism also necessitated another step: To sanely implement certain frame-based websites, any of the component documents displayed in a window needed the ability to navigate its neighboring frames or perhaps the top-level document itself. (For example, imagine a two-frame page with a table of contents on the left and the actual chapter on the right. Clicking a chapter name in the left pane should navigate the chapter in the right pane, and nothing else.)<a class="indexterm" id="IDX-CHP-11-0010"/></p><p>The mechanism devised for this last purpose is fairly simple: One can specify the <span class="emphasis"><em>target</em></span> parameter on <span class="emphasis"><em>&lt;a href=...&gt;</em></span> links or forms, or provide the name of a window to the JavaScript method known as <span class="emphasis"><em>window.open(...)</em></span>, in order to navigate any other, previously named document view. In the mid-1990s, when this functionality first debuted, there seemed to be no need to incorporate any particular security checks into this logic; any page could navigate any other named window or a frame displayed by the browser to a new location at will.<a class="indexterm" id="IDX-CHP-11-0011"/><a class="indexterm" id="IDX-CHP-11-0012"/><a class="indexterm" id="IDX-CHP-11-0013"/><a class="indexterm" id="IDX-CHP-11-0014"/></p><p>To understand the consequences of this design, it is important to pause for a moment and examine the circumstances under which a particular document may obtain a name to begin with. For frames, the story is simple: In order to reference a frame easily on the embedding page, virtually all frames have a <span class="emphasis"><em>name</em></span> attribute (and some browsers, such as Chrome, also look at <span class="emphasis"><em>id</em></span>). Browser windows, on the other hand, are typically anonymous (that is, their <span class="emphasis"><em>window.name</em></span> property is an empty string), unless created programmatically; in the latter case, the name is specified by whoever creates the view. Anonymous windows do not necessarily stay anonymous, however. If a rogue application is displayed in such a window even briefly, it may set the <span class="emphasis"><em>window.name</em></span> property to any value, and this effect will persist.<a class="indexterm" id="IDX-CHP-11-0015"/><a class="indexterm" id="IDX-CHP-11-0016"/><a class="indexterm" id="IDX-CHP-11-0017"/></p><p>The aforementioned ability to target windows and frames by name is not the only way to navigate them; JavaScript programs that hold window handles pointing to other documents may directly invoke certain DOM methods without knowing the name of their target at all. Attacker-supplied code will not normally hold handles to completely unrelated windows, but it can traverse properties such as <span class="emphasis"><em>opener</em></span>, <span class="emphasis"><em>top</em></span>, <span class="emphasis"><em>parent</em></span>, or <span class="emphasis"><em>frames[]</em></span> in order to locate even distant relatives within the same navigation flow. An example of such a far-reaching lookup (and subsequently, navigation) is<a class="indexterm" id="IDX-CHP-11-0018"/></p><a id="I_programlisting3_d1e13547"/><pre class="programlisting">opener.opener.frames[2].location.assign("http://www.bunnyoutlet.com/");</pre><p>These two lookup techniques are not mutually exclusive: JavaScript programs can first obtain the handle of an unrelated but named window through <span class="emphasis"><em>window.open(...)</em></span> and then traverse the <span class="emphasis"><em>opener</em></span> or <span class="emphasis"><em>frames[]</em></span> properties of that context in order to reach its interesting relatives nearby.</p><p>Once a suitable handle is looked up in any fashion, the originating context can leverage one of several DOM methods and properties in order to change the address of the document displayed in that view. In every contemporary browser, calling the <span class="emphasis"><em>&lt;handle&gt;.location.replace(...)</em></span> method, or assigning a value to <span class="emphasis"><em>&lt;handle&gt;.location</em></span> or <span class="emphasis"><em>&lt;handle&gt;.location.href</em></span> properties, should do the trick. Amusingly, due to random implementation quirks, other theoretically equivalent approaches (such as invoking <span class="emphasis"><em>&lt;handle&gt;.location.assign(...)</em></span> or <span class="emphasis"><em>&lt;handle&gt;.window.open(..., "_self")</em></span>) may be hit-and-miss.</p><p>Okay, so it may be possible to navigate unrelated documents to new locations—but let’s see what could possibly go wrong.</p><div class="sect3" title="Frame Hijacking Risks"><div class="titlepage"><div><div><h3 class="title"><a id="frame_hijacking_risks"/>Frame Hijacking Risks</h3></div></div></div><p>The ability for one domain to navigate windows created by other sites, or ones that are simply no longer same-origin with their creator, is usually not a grave concern. This laid-back design may be an annoyance and may pose some minor, speculative phishing risk,<sup>[<a class="footnote" href="#ftn.CHP-11-FN-1" id="CHP-11-FN-1">56</a>]</sup> but in the grand scheme of things, it is neither a very pronounced issue nor a particularly distinctive one. This is, perhaps, the reason why the original authors of the relevant APIs have not given the entire mechanism too much thought.<a class="indexterm" id="IDX-CHP-11-0019"/><a class="indexterm" id="IDX-CHP-11-0020"/><a class="indexterm" id="IDX-CHP-11-0021"/><a class="indexterm" id="IDX-CHP-11-0022"/><a class="indexterm" id="IDX-CHP-11-0023"/><a class="indexterm" id="IDX-CHP-11-0024"/></p><p>Alas, the concept of HTML frames alters the picture profoundly: Any application that relies on frames to build a trusted user interface is at an obvious risk if an unrelated site is permitted to hijack such UI elements without leaving any trace of the attack in the address bar! <a class="xref" href="ch11.html#a_historically_permitted_comma_dangerous" title="Figure 11-1. A historically permitted, dangerous frame navigation scenario: The window on the right is opened at the same time as a banking website and is actively subverting it.">Figure 11-1</a> shows one such plausible attack scenario.</p><div class="figure"><a id="a_historically_permitted_comma_dangerous"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e13617"/><img alt="A historically permitted, dangerous frame navigation scenario: The window on the right is opened at the same time as a banking website and is actively subverting it." src="httpatomoreillycomsourcenostarchimages950023.png.jpg"/></div></div><p class="title">Figure 11-1. A historically permitted, dangerous frame navigation scenario: The window on the right is opened at the same time as a banking website and is actively subverting it.</p></div><p>Georgi Guninski, one of the pioneering browser security researchers, realized as early as 1999 that by permitting unconstrained frame navigation, we were headed for some serious trouble. Following his reports, vendors attempted to roll out frame navigation restrictions mid-2000.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-1">198</a>]</sup> Their implementation constrained all cross-frame navigation to the scope of a single window, preventing malicious web pages from interfering with any other simultaneously opened browser sessions.</p><p>Surprisingly, even this simple policy proved difficult to implement correctly. It was only in 2008 that Firefox eliminated this class of problems,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-2">199</a>]</sup> while Microsoft essentially ignored the problem until 2006. Still, these setbacks aside, we should be fine—right?</p></div><div class="sect3" title="Frame Descendant Policy and Cross-Domain Communications"><div class="titlepage"><div><div><h3 class="title"><a id="frame_descendant_policy_and_cross-domain"/>Frame Descendant Policy and Cross-Domain Communications</h3></div></div></div><p>The simple security restriction discussed in the previous session was not, in fact, enough. The reason was a new class of web applications, sometimes known as <span class="emphasis"><em>mashups</em></span>, that combined data from various sources to enable users to personalize their working environment and process data in innovative ways. Unfortunately for browser vendors, such web applications frequently relied on third-party gadgets loaded through <span class="emphasis"><em>&lt;iframe&gt;</em></span> tags, and their developers could not reasonably expect that loading a single frame from a rogue source would put all other frames on the page at risk. Yet, the simple and elegant window-level navigation policy amounted to permitting exactly that.<a class="indexterm" id="IDX-CHP-11-0025"/><a class="indexterm" id="IDX-CHP-11-0026"/><a class="indexterm" id="IDX-CHP-11-0027"/><a class="indexterm" id="IDX-CHP-11-0028"/><a class="indexterm" id="IDX-CHP-11-0029"/><a class="indexterm" id="IDX-CHP-11-0030"/></p><p>Around 2006, Microsoft agreed that the current approach was not sustainable and developed a more secure <span class="emphasis"><em>descendant policy</em></span> for frame navigation in Internet Explorer 7. Under this policy, navigation of non-same-origin frames is permitted only if the party requesting the navigation shares the origin with one of the ancestors of the targeted view. <a class="xref" href="ch11.html#a_complex_but_permissible_navigation_bet" title="Figure 11-2. A complex but permissible navigation between non-same-origin frames. This attempt succeeds only because the originating frame has the same origin as one of the ancestors of the targeted document—here, it’s the top-level page itself.">Figure 11-2</a> shows the navigation scenario permitted by this new policy.</p><div class="figure"><a id="a_complex_but_permissible_navigation_bet"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e13674"/><img alt="A complex but permissible navigation between non-same-origin frames. This attempt succeeds only because the originating frame has the same origin as one of the ancestors of the targeted document—here, it’s the top-level page itself." src="httpatomoreillycomsourcenostarchimages950025.png.jpg"/></div></div><p class="title">Figure 11-2. <a class="ulink" href="http://www.robotroom.com/DebouncedCounter/Figure713.gif">A complex but permissible navigation between non-same-origin frames. This attempt succeeds only because the originating frame has the same origin as one of the ancestors of the targeted document—here, it’s the top-level page itself.</a></p></div><p><a class="ulink" href="http://www.fuzzybunnies.com/"><a class="ulink" href="http://www.bunnyoutlet.com/">As with many other security improvements, Microsoft never backported this policy to the still popular Internet Explorer 6, and it never convincingly pressured users to abandon the older and increasingly insecure (but still superficially supported) version of its browser. On a more positive note, by 2009, three security researchers (Adam Barth, Collin Jackson, and John C. Mitchell) convinced Mozilla, Opera, and WebKit to roll out a similar policy in their browsers,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-3">200</a>]</sup> finally closing the mashup loophole for a good majority of the users of the Internet.</a></a></p><p>Well, <span class="emphasis"><em>almost</em></span> closing it. Even the new, robust policy has a subtle flaw. Notice in <a class="xref" href="ch11.html#a_complex_but_permissible_navigation_bet" title="Figure 11-2. A complex but permissible navigation between non-same-origin frames. This attempt succeeds only because the originating frame has the same origin as one of the ancestors of the targeted document—here, it’s the top-level page itself.">Figure 11-2</a> that a rogue site, <a class="ulink" href="http://bunnyoutlet.com/">http://bunnyoutlet.com/</a>, can interfere with a private frame that <a class="ulink" href="http://fuzzybunnies.com/">http://fuzzybunnies.com/</a> has created for its own use. At first glance, there is no harm here: The attacker’s domain is shown in the address bar, so the victim, in theory, should not be fooled into interacting with the subverted UI of <a class="ulink" href="http://fuzzybunnies.com/">http://fuzzybunnies.com/</a> in any meaningful way. Sadly, there is a catch: Some web applications have learned to use frames not to create user interfaces but to relay programmatic messages between origins. For applications that need to support Internet Explorer 6 and 7, where <span class="emphasis"><em>postMessage(...)</em></span> is not available, the tricks similar to the approach shown in <a class="xref" href="ch11.html#a_potential_cross-domain_communication_s" title="Figure 11-3. A potential cross-domain communication scheme, where the top-level page encodes messages addressed to the embedded gadget in the fragment identifier of the gadget frame and the gadget responds by navigating a subframe that is same-origin with the top-level document. If this application is framed on a rogue site, the top-level document controlled by the attacker will be able to inject messages between the two parties by freely navigating send_to_parent and send_to_child.">Figure 11-3</a> are commonplace.<a class="indexterm" id="IDX-CHP-11-0031"/></p><div class="figure"><a id="a_potential_cross-domain_communication_s"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e13718"/><img alt="A potential cross-domain communication scheme, where the top-level page encodes messages addressed to the embedded gadget in the fragment identifier of the gadget frame and the gadget responds by navigating a subframe that is same-origin with the top-level document. If this application is framed on a rogue site, the top-level document controlled by the attacker will be able to inject messages between the two parties by freely navigating send_to_parent and send_to_child." src="httpatomoreillycomsourcenostarchimages950027.png.jpg"/></div></div><p class="title">Figure 11-3. A potential cross-domain communication scheme, where the top-level page encodes messages addressed to the embedded gadget in the fragment identifier of the gadget frame and the gadget responds by navigating a subframe that is same-origin with the top-level document. If this application is framed on a rogue site, the top-level document controlled by the attacker will be able to inject messages between the two parties by freely navigating <span class="emphasis"><em>send_to_parent</em></span> and <span class="emphasis"><em>send_to_child</em></span>.</p></div><p>If an application that relies on a similar hack is embedded by a rogue site, the integrity of the communication frames may be compromised, and the attacker will be able to inject messages into the stream. Even the uses of <span class="emphasis"><em>postMessage(...)</em></span> may be at risk: If the party sending the message does not specify a destination origin or if the recipient does not examine the originating location, hijacking a frame will benefit the attacker in exactly the same way.</p></div></div><div class="sect2" title="Unsolicited Framing"><div class="titlepage"><div><div><h2 class="title"><a id="unsolicited_framing"/>Unsolicited Framing</h2></div></div></div><p>The previous discussion of cross-frame navigation highlights one of the more interesting weaknesses in the browser security model, as well as the disconnect between the design goals of HTML and the aim of the same-origin policy. But that’s not all: The concept of cross-domain framing is, by itself, fairly risky. Why? Well, any malicious page may embed a third-party application without a user’s knowledge, let alone consent. Further, it may obfuscate this fact by overlaying other visual elements on top of the frame, leaving visible just a small chunk of the original site, such as a button that performs a state-changing action. In such a setting, any user logged into the targeted application with ambient credentials may be easily tricked into interacting with the disguised UI control and performing an undesirable and unintended action, such as changing sharing settings for a social network profile or deleting data.<a class="indexterm" id="IDX-CHP-11-0032"/><a class="indexterm" id="IDX-CHP-11-0033"/><a class="indexterm" id="IDX-CHP-11-0034"/><a class="indexterm" id="IDX-CHP-11-0035"/><a class="indexterm" id="IDX-CHP-11-0036"/></p><p>This attack can be improved by the rogue site leveraging a CSS2 property called <span class="emphasis"><em>opacity</em></span> to make the targeted frame completely invisible without affecting its actual behavior. Any click in the area occupied by such a see-through frame will be delivered to the UI controls contained therein (see <a class="xref" href="ch11.html#a_simplified_example_of_a_ui-splicing_at" title="Figure 11-4. A simplified example of a UI-splicing attack that uses CSS opacity to hide the document the user will actually interact with">Figure 11-4</a>). Too, by combining CSS opacity with JavaScript code to make the frame follow the mouse pointer, it is possible to carry out the attack fairly reliably in almost any setting: Convincing the user to click anywhere in the document window is not particularly hard.</p><div class="figure"><a id="a_simplified_example_of_a_ui-splicing_at"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e13760"/><img alt="A simplified example of a UI-splicing attack that uses CSS opacity to hide the document the user will actually interact with" src="httpatomoreillycomsourcenostarchimages950029.png.jpg"/></div></div><p class="title">Figure 11-4. A simplified example of a UI-splicing attack that uses CSS opacity to hide the document the user will actually interact with</p></div><p>Researchers have recognized the possibility of such trickery to some extent since the early 2000s, but a sufficiently convincing attack wasn’t demonstrated until 2008, when Robert Hansen and Jeremiah Grossman publicized the issue broadly.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-4">201</a>]</sup> Thus, the term <span class="emphasis"><em>clickjacking</em></span> was born.<a class="indexterm" id="IDX-CHP-11-0037"/></p><p>The high profile of Hansen and Grossman’s report, and their interesting proof-of-concept example, piqued vendors’ interest. This interest proved to be short-lived, however, and there appears to be no easy way to solve this problem without taking some serious risks. The only even remotely plausible way to mitigate the impact would be to add renderer-level heuristics to disallow event delivery to cross-domain frames that are partly obstructed or that have not been displayed long enough. But this solution is complicated and hairy enough to be unpopular.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-5">202</a>]</sup> Instead, the problem has been slapped with a Band-Aid. A new HTTP header, <span class="emphasis"><em>X-Frame-Options</em></span>, permits concerned sites to opt out of being framed altogether (<span class="emphasis"><em>X-Frame-Options: deny</em></span>) or consent only to framing within a single origin (<span class="emphasis"><em>X-Frame-Options: same-origin</em></span>).<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-6">203</a>]</sup> This header is supported in all modern browsers (in Internet Explorer, beginning with version 8),<sup>[<a class="footnote" href="#ftn.CHP-11-FN-2" id="CHP-11-FN-2">57</a>]</sup> but it actually does little to address the vulnerability.<a class="indexterm" id="IDX-CHP-11-0038"/><a class="indexterm" id="IDX-CHP-11-0039"/><a class="indexterm" id="IDX-CHP-11-0040"/><a class="indexterm" id="IDX-CHP-11-0041"/></p><p>Firstly, the opt-in nature of the defense means that most websites will not adopt it or will not adopt it soon enough; in fact, a 2011 survey of the top 10,000 destinations on the Internet found that barely 0.5 percent used this feature.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-7">204</a>]</sup></p><p>To add insult to injury, the proposed mechanism is useless for applications that want to be embedded on third-party sites but that wish to preserve the integrity of their UIs. Various mashups and gadgets, those syndicated “like” buttons provided by social networking sites, and managed online discussion interfaces are all at risk.</p><div class="sect3" title="Beyond the Threat of a Single Click"><div class="titlepage"><div><div><h3 class="title"><a id="beyond_the_threat_of_a_single_click"/>Beyond the Threat of a Single Click</h3></div></div></div><p>As the name implies, the clickjacking attack outlined by Grossman and Hansen targets simple, single-click UI actions. In reality, however, the problem with deceptive framing is more complicated than the early reporting would imply. One example of a more complex interaction is the act of selecting, dragging, and dropping a snippet of text. In 2010, Paul Stone proposed a number of ways in which such an action could be disguised as a plausible interaction with an attacker’s site,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-8">205</a>]</sup> the most notable of which is the similarity between drag-and-drop and the use of a humble document-level scrollbar. The same click-drag-release action may be used to interact with a legitimate UI control or to unwittingly drag a portion of preselected text out of a sensitive document and drop it into an attacker-controlled frame. (Cross-domain drag-and-drop is no longer permitted in WebKit, but as of this writing other browser vendors are still debating the right way to address this risk.)<a class="indexterm" id="IDX-CHP-11-0042"/><a class="indexterm" id="IDX-CHP-11-0043"/><a class="indexterm" id="IDX-CHP-11-0044"/><a class="indexterm" id="IDX-CHP-11-0045"/></p><p>An even more challenging problem is keystroke redirection. Sometime in 2010, I noticed that it was possible to selectively redirect keystrokes across domains by examining the code of a pressed key using the <span class="emphasis"><em>onkeydown</em></span> event in JavaScript. If the pressed key matched what a rogue site wanted to enter into a targeted application, HTML element focus could be changed momentarily to a hidden <span class="emphasis"><em>&lt;iframe&gt;</em></span>, thereby ensuring the delivery of the actual keystrokes to the targeted web application rather than the harmless text field the user seems to be interacting with.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-9">206</a>]</sup> Using this method, an attacker can synthesize arbitrarily complex text in another domain on the user’s behalf—for example, inviting the attacker as an administrator of the victim’s blog.<a class="indexterm" id="IDX-CHP-11-0046"/></p><p>Browser vendors addressed the selective keystroke redirection issue by disallowing element focus changes in the middle of a keypress, but doing so did not close the loophole completely. After all, in some cases, an attacker can predict what key will be pressed next and roughly at what time, thereby permitting a preemptive, blindly executed focus switch. The two most obvious cases are a web-based action game or a typing-speed test, since both typically involve rapid pressing of attacker-influenced keys.</p><p>In fact, it gets better: Even if a malicious application only relies on free-form text entry—for example, by offering the user a comment-submission form—it’s often possible to guess which character will be pressed next based on the previous few keystrokes alone. English text (and text in most other human languages) is highly redundant, and in many cases, a considerable amount of input can be predicted ahead of time: You can bet that <span class="emphasis"><em>a-a-r-d-v</em></span> will be followed by <span class="emphasis"><em>a-r-k</em></span>, and almost always you will be right.<a class="indexterm" id="IDX-CHP-11-0047"/><a class="indexterm" id="IDX-CHP-11-0048"/><a class="indexterm" id="IDX-CHP-11-0049"/><a class="indexterm" id="IDX-CHP-11-0050"/><a class="indexterm" id="IDX-CHP-11-0051"/><a class="indexterm" id="IDX-CHP-11-0052"/><a class="indexterm" id="IDX-CHP-11-0053"/></p></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-1" id="ftn.CHP-11-FN-1">56</a>] </sup>One potential attack is this: Open a legitimate website (say, <a class="ulink" href="http://trusted-bank.com/">http://trusted-bank.com/</a>) in a new window, wait for the user to inspect the address bar, and then quickly change the location to an attacker-controlled but similarly named site (e.g., <a class="ulink" href="http://trustea-bank.com/">http://trustea-bank.com/</a>). The likelihood of successfully phishing the victim may be higher than when the user is navigating to the bad URL right away.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-2" id="ftn.CHP-11-FN-2">57</a>] </sup>In older versions of Internet Explorer, web application developers sometimes resort to JavaScript in an attempt to determine whether the <span class="emphasis"><em>window</em></span> object is the same as <span class="emphasis"><em>parent</em></span>, a condition that should be satisfied if no higher-level frame is present. Unfortunately, due to the flexibility of JavaScript DOM, such checks, as well as many types of possible corrective actions, are notoriously unreliable.</p></div></div></div>
<div class="sect1" title="Cross-Domain Content Inclusion"><div class="titlepage"><div><div><h1 class="title"><a id="cross-domain_content_inclusion"/>Cross-Domain Content Inclusion</h1></div></div></div><p>Framing and navigation are a distinct source of trouble, but these mechanisms aside, HTML supports a number of other ways to interact with non-same-origin data. The usual design pattern for these features is simple and seemingly safe: A constrained data format that will affect the appearance of the document is retrieved and parsed without being directly shown to the origin that referenced it. Examples of mechanisms that follow this rule include markup such as <span class="emphasis"><em>&lt;script src=...&gt;</em></span>, <span class="emphasis"><em>&lt;link rel=stylesheet href=...&gt;</em></span>, <span class="emphasis"><em>&lt;img src=...&gt;</em></span>, and several related cases discussed throughout <a class="xref" href="pt01.html" title="Part I. Anatomy of the Web">Part I</a> of this book.</p><p>Regrettably, the devil is in the details. When these mechanisms were first proposed, nobody asked several extremely pressing questions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Should these subresources be requested with ambient credentials associated with their origin? If so, there is a danger that the response may contain sensitive data not intended for the requesting party. It would probably be better to require some explicit form of authentication or to notify the server about the origin of the requesting page.</p></li><li class="listitem"><p>Should the relevant parsers be designed to minimize the risk of mistaking one document type for another? And should the servers have control over how their responses are interpreted (for example through the <span class="emphasis"><em>Content-Type</em></span> header)? If not, what are the consequences of, say, interpreting a user’s private JPEG image as a script?</p></li><li class="listitem"><p>Should the requesting page have no way to infer anything about the contents of the retrieved payloads? If yes, then this goal needs to be taken into account with utmost care when designing all the associated APIs. (If such separation is not a goal, the importance of the previous questions is even more pronounced.)</p></li></ul></div><p>The developers acted with conflicting assumptions about these topics, or perhaps had not given them any thought at all, leading to a number of profound security risks. For example, in most browsers, it used to be possible to read arbitrary, cookie-authenticated text by registering an <span class="emphasis"><em>onerror</em></span> handler on cross-domain <span class="emphasis"><em>&lt;script&gt;</em></span> loads: The verbose “syntax error” message generated by the browser would include a snippet of the retrieved file. Still, no problem in this category is more interesting than a glitch discovered by Chris Evans in 2009.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-10">207</a>]</sup> He noticed that the hallmark fault tolerance of CSS parsers (which, as you may recall, recover from syntax errors by attempting to resynchronize at the nearest curly bracket) is also a fatal security flaw.</p><p>In order to understand the issue, consider the following simple HTML document. This document contains two occurrences of an attacker-controlled string, and—sandwiched in between—a sensitive, user-specific value (in this case, a user’s name):<a class="indexterm" id="IDX-CHP-11-0054"/><a class="indexterm" id="IDX-CHP-11-0055"/></p><a id="I_programlisting3_d1e13937"/><pre class="programlisting">&lt;head&gt;
  &lt;title&gt;Page not found: ');<strong class="userinput"><code>} gotcha { background-image: url('/</code></strong>&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  ...
  &lt;span class="header"&gt;You are logged in as: John Doe&lt;/span&gt;
  ...
  &lt;div class="error_message"&gt;
  Page not found: ');<strong class="userinput"><code>} gotcha { background-image: url('/</code></strong>
  &lt;/div&gt;
  ...
&lt;/body&gt;</pre><p>Let’s assume that the attacker lured the victim to his own page and, on this page, used <span class="emphasis"><em>&lt;link rel=stylesheet&gt;</em></span> to load the aforementioned cross-domain HTML document in place of a stylesheet. The victim’s browser will happily comply: It will request the document using the victim’s cookies, will ignore <span class="emphasis"><em>Content-Type</em></span> on the subsequent response, and will hand the retrieved content over to the CSS parser. The parser will cheerfully ignore all syntax errors leading up to what appears to be a CSS rule named <span class="emphasis"><em>gotcha</em></span>. It will then process the <span class="emphasis"><em>url('...</em></span> pseudo-function, consuming all subsequent HTML (including the secret user name!), until it reaches a matching quote and a closing parenthesis. When this faux stylesheet is later applied to a <span class="emphasis"><em>class=gotcha</em></span> element on the attacker’s website, the browser will attempt to load the resulting URL and will leak the secret value to the attacker’s server in the process.</p><p>Astute readers may note that the CSS standard does not support multiline string literals, and as such, this trick would not work as specified. That’s partly true: In most browsers, the attempt will succeed only if the critical segment of the page contains no stray newlines. Some web applications are optimized to avoid unnecessary whitespaces and therefore will be vulnerable, but most web developers use newlines liberally, thwarting the attack. Alas, as noted in <a class="xref" href="ch05.html" title="Chapter 5. Cascading Style Sheets">Chapter 5</a>, one browser behaves differently: Internet Explorer accepts multiline strings in stylesheets and many other egregious syntax violations, accidentally amplifying the impact of this flaw.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Since identifying this problem, Chris Evans has pushed for fixes in all mainstream browsers, and as of this writing, most implementations reject cross-domain stylesheets that don’t begin right away with a valid CSS rule or that are served with an incompatible <span class="emphasis"><em>Content-Type</em></span> header (same-origin stylesheets are treated less restrictively). The only vendor to resist was Microsoft, which changed its mind only after a demonstration of a successful proof-of-concept attack against Twitter.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-11">208</a>]</sup> Following this revelation, Microsoft agreed not only to address the problem in Internet Explorer 8 but also—uncharacteristically—to backport this particular fix to Internet Explorer 6 and 7 as well.</p></div><p>Thanks to Chris’s efforts, stylesheets are a solved problem, but similar problems are bound to recur for other types of cross-domain subresources. In such cases, not all transgressions can be blamed on the sins of the old. For example, when browser vendors rolled out <span class="emphasis"><em>&lt;canvas&gt;</em></span>, a simple HTML5 mechanism that enables JavaScript to create vector and bitmap graphics,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-12">209</a>]</sup> many implementations put no restrictions on loading cross-domain images onto the canvas and then reading them back pixel by pixel. As of this writing, this issue, too, has been resolved: A canvas once touched by a cross-domain image becomes “tainted” and can only be written to, not read. But when we need to fix each such case individually, something is very wrong.<a class="indexterm" id="IDX-CHP-11-0056"/><a class="indexterm" id="IDX-CHP-11-0057"/><a class="indexterm" id="IDX-CHP-11-0058"/><a class="indexterm" id="IDX-CHP-11-0059"/><a class="indexterm" id="IDX-CHP-11-0060"/></p><div class="sect2" title="A Note on Cross-Origin Subresources"><div class="titlepage"><div><div><h2 class="title"><a id="a_note_on_cross-origin_subresources"/>A Note on Cross-Origin Subresources</h2></div></div></div><p>So far, we have focused on the risks of malicious websites navigating or including content that belongs to trusted parties. That said, the ability to load certain types of subresources from other origins has significant consequences, even if not actively subverted by a third-party site.<a class="indexterm" id="IDX-CHP-11-0061"/></p><p>In <a class="xref" href="pt01.html" title="Part I. Anatomy of the Web">Part I</a> of the book, we hinted that loading a script or a stylesheet from another origin effectively equates the security of the document that performs the load to the security of the origin of the loaded subresource; in particular, loading an HTTP script on an HTTPS page undoes most of the benefits of encryption. Similarly, loading a script from a provider whose infrastructure is vulnerable to attack can be nearly as problematic as not properly maintaining your own servers.</p><p>In addition to scripts and stylesheets, other content types that may lead to serious trouble include remote fonts (a recent addition to CSS) and plug-ins with access to the embedding page (such as <span class="emphasis"><em>allowScriptAccess=always</em></span> for Flash). It is also somewhat dangerous to load images, icons, cursors, or HTML frames from untrusted sources, although the impact of doing so is contained to some extent and will be use specific.</p><p>Contemporary browsers attempt to detect cases where HTTPS documents load HTTP resources—a condition known as <span class="emphasis"><em>mixed content</em></span>. They do so fairly inconsistently, however: Internet Explorer is the only browser that blocks most types of mixed content by default (and Chrome is expected to follow suit), but neither Internet Explorer nor Firefox nor Opera consistently detects mixed content on <span class="emphasis"><em>&lt;embed&gt;</em></span>, <span class="emphasis"><em>&lt;object&gt;</em></span>, or <span class="emphasis"><em>&lt;applet&gt;</em></span> tags. In browsers other than Internet Explorer, the default action is a subtle warning (for example, an exclamation mark next to the lock icon) or a cryptic dialog, which does very little to protect the user but which may alert a sufficiently attentive web developer.<a class="indexterm" id="IDX-CHP-11-0062"/><a class="indexterm" id="IDX-CHP-11-0063"/><a class="indexterm" id="IDX-CHP-11-0064"/><a class="indexterm" id="IDX-CHP-11-0065"/></p><p>As to the other flavor of mixed content—loading subresources across domains that offer different levels of trust—browsers have no way to detect this. The decision to include content from dubious sources is often made too lightly and such mistakes can be difficult to spot until too late.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Another interesting problem with cross-domain subresources is that they may request certain additional permissions or credentials from the browser. The associated browser security prompts are usually not designed with such scenarios with mind, and they do not always make sufficiently clear which origin is requesting the permission and based on what sort of relationship with the top-level site. We discussed one such problem in <a class="xref" href="ch03.html" title="Chapter 3. Hypertext Transfer Protocol">Chapter 3</a>: the authentication prompt shown in response to HTTP code 401. Several other, related cases will appear in <a class="xref" href="ch15.html" title="Chapter 15. Extrinsic Site Privileges">Chapter 15</a>.</p></div></div></div>
<div class="sect1" title="Privacy-Related Side Channels"><div class="titlepage"><div><div><h1 class="title"><a id="privacy-related_side_channels"/>Privacy-Related Side Channels</h1></div></div></div><p>Another unfortunate and noteworthy consequence of the gaps in the same-origin policy is the ability to collect information about a user’s interaction with unrelated sites. Some of the most rudimentary examples, most of them known for well over a decade,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-13">210</a>]</sup> include the following:<a class="indexterm" id="IDX-CHP-11-0066"/><a class="indexterm" id="IDX-CHP-11-0067"/><a class="indexterm" id="IDX-CHP-11-0068"/><a class="indexterm" id="IDX-CHP-11-0069"/><a class="indexterm" id="IDX-CHP-11-0070"/><a class="indexterm" id="IDX-CHP-11-0071"/><a class="indexterm" id="IDX-CHP-11-0072"/><a class="indexterm" id="IDX-CHP-11-0073"/><a class="indexterm" id="IDX-CHP-11-0074"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Using <span class="emphasis"><em>onload</em></span> handlers to measure the time it takes to load certain documents, an indication of whether they have been previously visited and cached by the browser or not.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-14">211</a>]</sup></p></li><li class="listitem"><p>Using <span class="emphasis"><em>onload</em></span> and <span class="emphasis"><em>onerror</em></span> on <span class="emphasis"><em>&lt;img&gt;</em></span> tags to see if an authentication-requiring image on a third-party site can be loaded, thus disclosing whether the user is logged into that site or not. (Bonus: Sometimes, the error message disclosed to the <span class="emphasis"><em>onerror</em></span> handler will include snippets of the targeted page, too.)</p></li><li class="listitem"><p>Loading an unrelated web application in a hidden frame and examining properties such as the number and names of subframes created on that page (available through the <span class="emphasis"><em>&lt;handle&gt;.frames[]</em></span> array) or the set of global variables (sometimes leaked through the semantics of the <span class="emphasis"><em>delete</em></span> operator) in order to detect the same. Naturally, the set of sites the user visits or is logged into can be fairly sensitive.</p></li></ul></div><p>In addition to these tricks, a particularly frightening class of privacy problems is associated with two APIs created several years ago to help websites understand the style applied to any document element (the sum of browser-specific defaults, CSS rules, and any runtime tweaks made automatically by the browser or performed via JavaScript). The two APIs in question are <span class="emphasis"><em>getComputedStyle</em></span>, mandated by CSS Level 2,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-15">212</a>]</sup> and <span class="emphasis"><em>currentStyle</em></span>, proprietary to Internet Explorer.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-16">213</a>]</sup> Their functionality, together with the ability to assign distinctive styling to visited links (using the <span class="emphasis"><em>:visited</em></span> pseudo-class), means that any rogue JavaScript can rapidly display and examine thousands of URLs to see which ones are shaded differently (due to being present in a user’s browsing history), thereby building a reliable, extensive, and possibly incriminating overview of a user’s online habits with unprecedented efficiency and reliability.</p><p>This problem has been known since at least since 2002, when Andrew Clover posted a brief note about it to the popular BUGTRAQ mailing list.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-17">214</a>]</sup> The issue received little scrutiny in the following years, until a series of layperson-targeted demonstrations and a subsequent public outcry around 2006. A few years later, Firefox and WebKit browsers rolled out security improvements to limit the extent of styling possible in <span class="emphasis"><em>:visited</em></span> selectors and to limit the ability to inspect the resulting composite CSS data.</p><p>That said, such fixes will never be perfect. Even though they make automated data collection impossible, smaller quantities of data can be obtained with a user’s help. Case in point: Collin Jackson and several other researchers proposed a simple scheme that involved presenting a faux CAPTCHA<sup>[<a class="footnote" href="#ftn.CHP-11-FN-3" id="CHP-11-FN-3">58</a>]</sup> consisting of seven-segment, LCD-like digits.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-11-FT-18">215</a>]</sup> Rather than being an actual, working challenge, the number the user would see depended on the <span class="emphasis"><em>:visited</em></span>-based styling applied to superimposed links (see <a class="xref" href="ch11s03.html#a_fake_seven-segment_display_can_be_used" title="Figure 11-5. A fake seven-segment display can be used to read back link styling when the displayed number is entered into the browser in an attempt to solve a CAPTCHA. The user will see 5, 6, 9, or 8, depending on prior browsing history.">Figure 11-5</a>); by typing that number back onto the page, the user would unwittingly tell the author of the site what exact styling had been applied and, therefore, what sites appeared in the victim’s browsing history.<a class="indexterm" id="IDX-CHP-11-0075"/><a class="indexterm" id="IDX-CHP-11-0076"/><a class="indexterm" id="IDX-CHP-11-0077"/><a class="indexterm" id="IDX-CHP-11-0078"/></p><div class="figure"><a id="a_fake_seven-segment_display_can_be_used"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e14184"/><img alt="A fake seven-segment display can be used to read back link styling when the displayed number is entered into the browser in an attempt to solve a CAPTCHA. The user will see 5, 6, 9, or 8, depending on prior browsing history." src="httpatomoreillycomsourcenostarchimages950031.png.jpg"/></div></div><p class="title">Figure 11-5. A fake seven-segment display can be used to read back link styling when the displayed number is entered into the browser in an attempt to solve a CAPTCHA. The user will see 5, 6, 9, or 8, depending on prior browsing history.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-11-FN-3" id="ftn.CHP-11-FN-3">58</a>] </sup>CAPTCHA (sometimes expanded as Completely Automated Public Turing test to tell Computers and Humans Apart) is a term for a security challenge that is believed to be difficult to solve using computer algorithms but that should be easy for a human being. It is usually implemented by showing an image of several randomly selected, heavily distorted characters and asking the user to type them back. CAPTCHA may be used to discourage the automation of certain tasks, such as opening new accounts or sending significant volumes of email. (Needless to say, due to advances in computer image processing, robust CAPTCHAs are increasingly difficult for humans to solve, too.)</p></div></div></div>
<div class="sect1" title="Other SOP Loopholes and Their Uses"><div class="titlepage"><div><div><h1 class="title"><a id="other_sop_loopholes_and_their_uses"/>Other SOP Loopholes and Their Uses</h1></div></div></div><p>Although this chapter has focused on areas where the limitations of the same-origin policy have a clear, negative impact on the security or privacy of online browsing, there are several accidental gaps in the scheme that in most cases seem to be of no special consequence. For example, in many versions of Internet Explorer, it was possible to manipulate the value of <span class="emphasis"><em>window.opener</em></span> or <span class="emphasis"><em>window.name</em></span> of an unrelated window. Meanwhile in Firefox, there are currently no constraints on setting <span class="emphasis"><em>location.hash</em></span> across domains, even though all other partial location properties are restricted.</p><p>The primary significance of these mechanisms is that they are often repurposed to build cross-domain communication channels in browsers that do not support the <span class="emphasis"><em>postMessage(...)</em></span> API. Such mechanisms are often built on shaky ground: The lack of SOP enforcement is typically uniform and means that any website, not just the “authorized” parties, will be able to interfere with the data. The ability for rogue parties to navigate nested frames, as discussed in <a class="xref" href="ch11.html#frame_hijacking_risks" title="Frame Hijacking Risks">Frame Hijacking Risks</a> in <a class="xref" href="ch11.html#frame_hijacking_risks" title="Frame Hijacking Risks">Frame Hijacking Risks</a>, further complicates the picture.</p><div class="sidebar"><a id="security_engineering_cheat_sheet-id9"/><p class="title">Security Engineering Cheat Sheet</p><p><span class="bolditalic">Good Security Hygiene for All Websites</span><a class="indexterm" id="IDX-CHP-11-0079"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Serve all content for your site with <span class="emphasis"><em>X-Frame-Options: sameorigin</em></span>. Make case-by-case exceptions only for specific, well-understood locations that require cross-domain embedding. Try not to depend on JavaScript “framebusting” code to prevent framing because it’s very tricky to get that code right.</p></li><li class="listitem"><p>Return user-specific, sensitive data that is not meant to be loaded across domains using well-constrained formats that are unlikely to be misinterpreted as standalone scripts, stylesheets, and so on. Always use the right <span class="emphasis"><em>Content-Type</em></span>.</p></li></ul></div><p><span class="bolditalic">When Including Cross-Domain Resources</span><a class="indexterm" id="IDX-CHP-11-0080"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>In many scenarios (especially when dealing with scripts, stylesheets, fonts, and certain types of plug-in-handled content), you are linking the security of your site to the originating domain of the subresource. When in doubt, make a local copy of the data instead. On HTTPS sites, require all subresources to be served over HTTPS.</p></li></ul></div><p><span class="bolditalic">When Arranging Cross-Domain Communications in JavaScript</span><a class="indexterm" id="IDX-CHP-11-0081"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Consult the cheat sheet in <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a>. Do not use cross-frame communication schemes based on <span class="emphasis"><em>location.hash</em></span>, <span class="emphasis"><em>window.name</em></span>, <span class="emphasis"><em>frameElements</em></span>, and similar ephemeral hacks, unless you are prepared to deal with injected content.</p></li><li class="listitem"><p>Do not expect subframes on your page to sit still, especially if you are not using <span class="emphasis"><em>X-Frame-Options</em></span> to limit the ability of other sites to frame your application. In certain cases, an attacker may be able to navigate such frames to a different location without your knowledge or consent.</p></li></ul></div></div></div>
<div class="chapter" title="Chapter&#xA0;12.&#xA0;Other Security Boundaries"><div class="titlepage"><div><div><h1 class="title"><a id="other_security_boundaries"/>Chapter 12. Other Security Boundaries</h1></div></div></div><p>All previously described origin-level content-isolation policies, and the accompanying context inheritance and document navigation logic, work hand in hand to form the bulk of the browser security model. Impenetrable and fragile, that model is also incomplete: A handful of interesting corner cases completely escape any origin-based frameworks.</p><p>The security risks associated with these corner cases can’t be addressed simply by fine-tuning the mechanisms discussed earlier in this book. Instead, additional, sometimes hopelessly imperfect security boundaries need to be created from scratch. These new boundaries may, for example, further restrict the ability of rogue web pages to navigate to certain URLs.</p><p>This chapter offers a quick look at some of the most significant examples of the loopholes in the origin-based model and the ways that vendors have dealt with them.</p><div class="sect1" title="Navigation to Sensitive Schemes"><div class="titlepage"><div><div><h1 class="title"><a id="navigation_to_sensitive_schemes"/>Navigation to Sensitive Schemes</h1></div></div></div><p>In the past, browser vendors reasoned that there was no harm in allowing any page on the Internet to navigate to a document stored on a user’s hard drive using the <span class="emphasis"><em>file:</em></span> protocol or to open a new window pointing to a privileged resource, such as the <span class="emphasis"><em>about:config</em></span> page in Firefox. After all, they thought, the originating document and the destination would not be same-origin, and, therefore, any direct access to the sensitive data would be prevented.<a class="indexterm" id="IDX-CHP-12-0001"/><a class="indexterm" id="IDX-CHP-12-0002"/><a class="indexterm" id="IDX-CHP-12-0003"/><a class="indexterm" id="IDX-CHP-12-0004"/><a class="indexterm" id="IDX-CHP-12-0005"/><a class="indexterm" id="IDX-CHP-12-0006"/><a class="indexterm" id="IDX-CHP-12-0007"/><a class="indexterm" id="IDX-CHP-12-0008"/><a class="indexterm" id="IDX-CHP-12-0009"/></p><p>For many years, based on this rationale, browsers permitted such navigation to take place. Alas, this decision proved to be not only extremely confusing<sup>[<a class="footnote" href="#ftn.CHP-12-FN-1" id="CHP-12-FN-1">59</a>]</sup> but also dangerous. The danger comes from the fact that many programs, browsers included, tend to store various types of Internet-originating content in the filesystem; temporary files and cached documents are a common example. In many cases, an attacker could have some control over the creation and contents of such files, and, if the resources are created at a predictable location, subsequent navigation to the right <span class="emphasis"><em>file:</em></span> URL could allow the attacker to execute his own payload in this coveted origin, with access to any other file on the disk and, perhaps, any other website on the Internet.</p><p>Comparably disastrous consequences have been observed with a variety of privileged, internally handled URLs. The ability to navigate directly to locations such as <span class="emphasis"><em>about:config</em></span> (Firefox) not only made it possible to exploit potential vulnerabilities in the privileged scripts (a transgression to which browser vendors are not immune) but also led to system compromise if, through a literal application of the same-origin policy, the browser naïvely deemed <span class="emphasis"><em>about:config</em></span> and <span class="emphasis"><em>about:blank</em></span> to come from the same origin.</p><p>Having learned from a history of painful mishaps, modern browsers typically police navigation based on three tiers of URL schemes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Unrestricted</strong></span> This category includes virtually all true network protocols, such as HTTP, HTTPS, FTP; most encapsulating pseudo-protocols such as <span class="emphasis"><em>mhtml:</em></span> or <span class="emphasis"><em>jar:</em></span>; and all schemes registered to plug-ins and external applications. Navigation to these URLs is not constrained in any specific way.</p></li><li class="listitem"><p><span class="strong"><strong>Partly restricted</strong></span> This category includes several security-sensitive schemes such as <span class="emphasis"><em>file:</em></span> and special pseudo-URLs such as <span class="emphasis"><em>javascript:</em></span> or <span class="emphasis"><em>vbscript:</em></span>. Navigation to them is not completely denied, but it is subject to additional, scheme-specific security checks. For example, access to <span class="emphasis"><em>file:</em></span> is usually permitted only from other <span class="emphasis"><em>file:</em></span> documents, requiring the first one to be opened manually. (The rules for navigation to <span class="emphasis"><em>javascript:</em></span> URLs were discussed in <a class="xref" href="ch10.html" title="Chapter 10. Origin Inheritance">Chapter 10</a>.)</p></li><li class="listitem"><p><span class="strong"><strong>Fully restricted</strong></span> This category includes privileged pages in <span class="emphasis"><em>about:</em></span>, <span class="emphasis"><em>res:</em></span>, <span class="emphasis"><em>chrome:</em></span>, and similar browser-specific namespaces. Normal, unprivileged HTML documents are not permitted to navigate to them under any circumstance.</p></li></ul></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-1" id="ftn.CHP-12-FN-1">59</a>] </sup>For example, on Windows systems, a common prank was to use a seamlessly embedded <span class="emphasis"><em>&lt;iframe&gt;</em></span> pointing to <span class="emphasis"><em>file:///c:/</em></span> in order to display the contents of a victim’s hard drive, leading some users to believe that the page doing so has somehow gained access to their files.</p></div></div></div>
<div class="sect1" title="Access to Internal Networks"><div class="titlepage"><div><div><h1 class="title"><a id="access_to_internal_networks"/>Access to Internal Networks</h1></div></div></div><p>The trouble with accessing sensitive protocols is merely a prelude to a far more serious issue that somehow escaped the creators of the same-origin policy. The problem is that DNS-derived origins may have nothing to do with actual network-level boundaries—or with how these boundaries change over time. A malicious script may be granted same-origin access to intranet sites on the victim’s local network, even if a firewall prevents the attacker from interacting with these destinations directly.<a class="indexterm" id="IDX-CHP-12-0010"/><a class="indexterm" id="IDX-CHP-12-0011"/></p><p>There are at least three distinctive venues for such attacks.</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Origin Infiltration</strong></span></span></dt><dd><p>When a user visits a rogue network—such as an open wireless network at an airport or in a café—an attacker on that network may trick the victim’s browser into opening a URL such as <a class="ulink" href="http://us-payroll/">http://us-payroll/</a>. When this happens, the attacker may provide his own, spoofed content for that site. Frighteningly, if the user then brings the same browser to a corporate network, the previously injected content will have same-origin access to the real version of <a class="ulink" href="http://us-payroll/">http://us-payroll/</a>, complete with the user’s ambient credentials.</p><p>The persistence of injected content may be achieved in a couple of ways. The most basic method is for an attacker simply to inject a hidden <a class="ulink" href="http://us-payroll/">http://us-payroll/</a>frame onto every visited page in the hope that the user will suspend a portable computer with the browser still running and then take it to another network. Another technique is <span class="emphasis"><em>cache poisoning</em></span>: creating long-lived, cached objects that the browser will use instead of retrieving a fresh copy from the destination site. Several other, more obscure approaches also exist.<a class="indexterm" id="IDX-CHP-12-0012"/></p></dd><dt><span class="term"><span class="strong"><strong>DNS Rebinding</strong></span></span></dt><dd><p>This arguably less serious but more easily exploitable problem was mentioned in footnote 1 in <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a>. In short, since the same-origin policy looks just at the DNS name of a host, not at the IP address, an attacker who owns <a class="ulink" href="http://bunnyoutlet.com">bunnyoutlet.com</a> is free to respond initially to a DNS lookup from a user with a public IP such as <span class="emphasis"><em>213.134.128.25</em></span> and then switch to an address reserved for private networks, such as <span class="emphasis"><em>10.0.0.1</em></span>. Documents loaded from both sources will be considered same-origin, giving the attacker the ability to interact with the victim’s internal network.</p><p>The mitigating factor is that this interaction will not involve proper ambient credentials that the victim normally has for the targeted site: As far as the browser is concerned, it is still talking to <a class="ulink" href="http://bunnyoutlet.com">bunnyoutlet.com</a> and not to, say, the aforementioned <span class="emphasis"><em>us-payroll</em></span> site. Still, the prospect of the attacker examining the internal network and perhaps trying to brute-force the appropriate credentials or identify vulnerabilities is disconcerting.</p></dd><dt><span class="term"><span class="strong"><strong>Simple Exploitation of XSS or XSRF Flaws</strong></span></span></dt><dd><p>Even outside the realm of the same-origin policy, the mere possibility of navigating to intranet URLs means that the attacker may attempt to (blindly) target known or suspected vulnerabilities in locally running software. Because internal applications are thought to be protected from malicious users, they are often not engineered or maintained to the same standards as externally facing code.<a class="indexterm" id="IDX-CHP-12-0013"/><a class="indexterm" id="IDX-CHP-12-0014"/><a class="indexterm" id="IDX-CHP-12-0015"/><a class="indexterm" id="IDX-CHP-12-0016"/><a class="indexterm" id="IDX-CHP-12-0017"/><a class="indexterm" id="IDX-CHP-12-0018"/><a class="indexterm" id="IDX-CHP-12-0019"/><a class="indexterm" id="IDX-CHP-12-0020"/><a class="indexterm" id="IDX-CHP-12-0021"/><a class="indexterm" id="IDX-CHP-12-0022"/><a class="indexterm" id="IDX-CHP-12-0023"/><a class="indexterm" id="IDX-CHP-12-0024"/><a class="indexterm" id="IDX-CHP-12-0025"/></p><p>One striking example of this problem is the dozens of vulnerabilities discovered over the years in internal-only web management interfaces of home network routers manufactured by companies such as Linksys (Cisco), Netgear, D-Link, Motorola, and Siemens. Cross-site request forgery vulnerabilities in these applications can, in extreme cases, permit attackers to access the device and intercept or modify all network traffic going to or through it.</p></dd></dl></div><p>So far, the disconnect between browser security mechanisms and network segmentation remains an unsolved problem in browser engineering. Several browsers try to limit the impact of DNS rebinding by caching DNS responses for a predefined time—a practice known as <span class="emphasis"><em>DNS pinning</em></span>—but the defense is imperfect, and the remaining attack vectors still remain.<a class="indexterm" id="IDX-CHP-12-0026"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Unusually, Internet Explorer takes the lead on this front, offering an optional way to mitigate the risk. Microsoft’s users are protected to some extent if they flip a cryptic zone setting named “websites in less privileged web content zone can navigate into this zone” to “disable” in the configuration options for local intranet. Unfortunately, the zone model in Internet Explorer comes with some unexpected pitfalls, as we’ll discuss in <a class="xref" href="ch15.html" title="Chapter 15. Extrinsic Site Privileges">Chapter 15</a>.</p></div></div>
<div class="sect1" title="Prohibited Ports"><div class="titlepage"><div><div><h1 class="title"><a id="prohibited_ports"/>Prohibited Ports</h1></div></div></div><p>Security researchers have cautioned that the ability of browsers to submit largely unconstrained cross-origin request bodies, for example with &lt;<span class="emphasis"><em>form method="POST" enctype="text/plain"&gt;</em></span>, may interfere with certain other fault-tolerant but non-HTTP network services. For example, consider SMTP, the dominant mail transfer protocol: When interacting with an unsuspecting browser, most servers that speak SMTP will patiently ignore the first few incomprehensible lines associated with HTTP headers and then honor any SMTP commands that appear in the request body. In effect, the browser could be used as a proxy for relaying spam.</p><p>A related but less well-explored concern, discussed in <a class="xref" href="ch03.html" title="Chapter 3. Hypertext Transfer Protocol">Chapter 3</a>, is the risk of an attacker talking to non-HTTP services running in the same domain as the targeted web application and tricking the browser into misinterpreting the returned, possibly partly attacker-controlled data as HTML delivered over HTTP/0.9. This behavior could expose cookies or other credentials associated with the targeted site.</p><p>The design of HTTP makes it impossible to solve these problems in a particularly robust way. Instead, browser vendors have responded in a rather unconvincing manner: by shipping a list of prohibited TCP ports to which requests cannot be sent. For Internet Explorer versions 6 and 7, the list consists of the following port numbers:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p>19</p></td><td style="text-align: left" valign="top"><p>chargen</p></td></tr><tr><td style="text-align: left" valign="top"><p>21</p></td><td style="text-align: left" valign="top"><p>ftp</p></td></tr><tr><td style="text-align: left" valign="top"><p>25</p></td><td style="text-align: left" valign="top"><p>smtp</p></td></tr><tr><td style="text-align: left" valign="top"><p>110</p></td><td style="text-align: left" valign="top"><p>pop3</p></td></tr><tr><td style="text-align: left" valign="top"><p>119</p></td><td style="text-align: left" valign="top"><p>nntp</p></td></tr><tr><td style="text-align: left" valign="top"><p>143</p></td><td style="text-align: left" valign="top"><p>imap2</p></td></tr></tbody></table></div><p>Versions 8 and 9 of Internet Explorer further prohibit ports 220 (imap3) and 993 (ssl imap3).</p><p>All other browsers discussed in this book use a different, common list:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p>1</p></td><td style="text-align: left" valign="top"><p>tcpmux</p></td><td style="text-align: left" valign="top"><p>115</p></td><td style="text-align: left" valign="top"><p>sftp</p></td></tr><tr><td style="text-align: left" valign="top"><p>7</p></td><td style="text-align: left" valign="top"><p>echo</p></td><td style="text-align: left" valign="top"><p>117</p></td><td style="text-align: left" valign="top"><p>uccp-path</p></td></tr><tr><td style="text-align: left" valign="top"><p>9</p></td><td style="text-align: left" valign="top"><p>discard</p></td><td style="text-align: left" valign="top"><p>119</p></td><td style="text-align: left" valign="top"><p>nntp</p></td></tr><tr><td style="text-align: left" valign="top"><p>11</p></td><td style="text-align: left" valign="top"><p>systat</p></td><td style="text-align: left" valign="top"><p>123</p></td><td style="text-align: left" valign="top"><p>ntp</p></td></tr><tr><td style="text-align: left" valign="top"><p>13</p></td><td style="text-align: left" valign="top"><p>daytime</p></td><td style="text-align: left" valign="top"><p>135</p></td><td style="text-align: left" valign="top"><p>loc-srv</p></td></tr><tr><td style="text-align: left" valign="top"><p>15</p></td><td style="text-align: left" valign="top"><p>netstat</p></td><td style="text-align: left" valign="top"><p>139</p></td><td style="text-align: left" valign="top"><p>netbios</p></td></tr><tr><td style="text-align: left" valign="top"><p>17</p></td><td style="text-align: left" valign="top"><p>qotd</p></td><td style="text-align: left" valign="top"><p>143</p></td><td style="text-align: left" valign="top"><p>imap2</p></td></tr><tr><td style="text-align: left" valign="top"><p>19</p></td><td style="text-align: left" valign="top"><p>chargen</p></td><td style="text-align: left" valign="top"><p>179</p></td><td style="text-align: left" valign="top"><p>bgp</p></td></tr><tr><td style="text-align: left" valign="top"><p>20</p></td><td style="text-align: left" valign="top"><p>ftp-data</p></td><td style="text-align: left" valign="top"><p>389</p></td><td style="text-align: left" valign="top"><p>ldap</p></td></tr><tr><td style="text-align: left" valign="top"><p>21</p></td><td style="text-align: left" valign="top"><p>ftp</p></td><td style="text-align: left" valign="top"><p>465</p></td><td style="text-align: left" valign="top"><p>ssl smtp</p></td></tr><tr><td style="text-align: left" valign="top"><p>22</p></td><td style="text-align: left" valign="top"><p>ssh</p></td><td style="text-align: left" valign="top"><p>512</p></td><td style="text-align: left" valign="top"><p>exec</p></td></tr><tr><td style="text-align: left" valign="top"><p>23</p></td><td style="text-align: left" valign="top"><p>telnet</p></td><td style="text-align: left" valign="top"><p>513</p></td><td style="text-align: left" valign="top"><p>login</p></td></tr><tr><td style="text-align: left" valign="top"><p>25</p></td><td style="text-align: left" valign="top"><p>smtp</p></td><td style="text-align: left" valign="top"><p>514</p></td><td style="text-align: left" valign="top"><p>shell</p></td></tr><tr><td style="text-align: left" valign="top"><p>37</p></td><td style="text-align: left" valign="top"><p>time</p></td><td style="text-align: left" valign="top"><p>515</p></td><td style="text-align: left" valign="top"><p>printer</p></td></tr><tr><td style="text-align: left" valign="top"><p>42</p></td><td style="text-align: left" valign="top"><p>name</p></td><td style="text-align: left" valign="top"><p>526</p></td><td style="text-align: left" valign="top"><p>tempo</p></td></tr><tr><td style="text-align: left" valign="top"><p>43</p></td><td style="text-align: left" valign="top"><p>nicname</p></td><td style="text-align: left" valign="top"><p>530</p></td><td style="text-align: left" valign="top"><p>courier</p></td></tr><tr><td style="text-align: left" valign="top"><p>53</p></td><td style="text-align: left" valign="top"><p>domain</p></td><td style="text-align: left" valign="top"><p>531</p></td><td style="text-align: left" valign="top"><p>chat</p></td></tr><tr><td style="text-align: left" valign="top"><p>77</p></td><td style="text-align: left" valign="top"><p>priv-rjs</p></td><td style="text-align: left" valign="top"><p>532</p></td><td style="text-align: left" valign="top"><p>netnews</p></td></tr><tr><td style="text-align: left" valign="top"><p>79</p></td><td style="text-align: left" valign="top"><p>finger</p></td><td style="text-align: left" valign="top"><p>540</p></td><td style="text-align: left" valign="top"><p>uucp</p></td></tr><tr><td style="text-align: left" valign="top"><p>87</p></td><td style="text-align: left" valign="top"><p>ttylink</p></td><td style="text-align: left" valign="top"><p>556</p></td><td style="text-align: left" valign="top"><p>remotefs</p></td></tr><tr><td style="text-align: left" valign="top"><p>95</p></td><td style="text-align: left" valign="top"><p>supdup</p></td><td style="text-align: left" valign="top"><p>563</p></td><td style="text-align: left" valign="top"><p>ssl nntp</p></td></tr><tr><td style="text-align: left" valign="top"><p>101</p></td><td style="text-align: left" valign="top"><p>hostriame</p></td><td style="text-align: left" valign="top"><p>587</p></td><td style="text-align: left" valign="top"><p>smtp submission</p></td></tr><tr><td style="text-align: left" valign="top"><p>102</p></td><td style="text-align: left" valign="top"><p>iso-tsap</p></td><td style="text-align: left" valign="top"><p>601</p></td><td style="text-align: left" valign="top"><p>syslog</p></td></tr><tr><td style="text-align: left" valign="top"><p>103</p></td><td style="text-align: left" valign="top"><p>gppitnp</p></td><td style="text-align: left" valign="top"><p>636</p></td><td style="text-align: left" valign="top"><p>ssl ldap</p></td></tr><tr><td style="text-align: left" valign="top"><p>104</p></td><td style="text-align: left" valign="top"><p>acr-nema</p></td><td style="text-align: left" valign="top"><p>993</p></td><td style="text-align: left" valign="top"><p>ssl imap</p></td></tr><tr><td style="text-align: left" valign="top"><p>109</p></td><td style="text-align: left" valign="top"><p>pop2</p></td><td style="text-align: left" valign="top"><p>995</p></td><td style="text-align: left" valign="top"><p>ssl pop3</p></td></tr><tr><td style="text-align: left" valign="top"><p>110</p></td><td style="text-align: left" valign="top"><p>pop3</p></td><td style="text-align: left" valign="top"><p>2049</p></td><td style="text-align: left" valign="top"><p>nfs</p></td></tr><tr><td style="text-align: left" valign="top"><p>111</p></td><td style="text-align: left" valign="top"><p>sunrpc</p></td><td style="text-align: left" valign="top"><p>4045</p></td><td style="text-align: left" valign="top"><p>lockd</p></td></tr><tr><td style="text-align: left" valign="top"><p>113</p></td><td style="text-align: left" valign="top"><p>auth</p></td><td style="text-align: left" valign="top"><p>6000</p></td><td style="text-align: left" valign="top"><p>X11</p></td></tr></tbody></table></div><p>There are, of course, various protocol-specific exceptions to these rules. For example, <span class="emphasis"><em>ftp:</em></span> URLs are obviously permitted to access port 21, normally associated with that protocol.<a class="indexterm" id="IDX-CHP-12-0027"/><a class="indexterm" id="IDX-CHP-12-0028"/><a class="indexterm" id="IDX-CHP-12-0029"/></p><p>The current solution is flawed in several ways, the most important of which may be that both lists have numerous glaring omissions and, given the number of network protocols devised to date, simply have no chance of ever being exhaustive. For example, no rule would prevent the browser from talking to Internet Relay Chat (IRC) servers, which use a fault-tolerant, text-based protocol not entirely unlike SMTP.</p><p>The lists are also not regularly updated to reflect the demise of nearly extinct network protocols or the introduction of new ones. Lastly, they can unfairly and unexpectedly penalize system administrators for picking nonstandard ports for certain services they want to hide from public view: Doing so means opting out of this browser-level protection mechanism.</p></div>
<div class="sect1" title="Limitations on Third-Party Cookies"><div class="titlepage"><div><div><h1 class="title"><a id="limitations_on_third-party_cookies"/>Limitations on Third-Party Cookies</h1></div></div></div><p>Since their inception, HTTP cookies have been misunderstood as the tool that enabled online advertisers to violate users’ privacy to an unprecedented and previously unattainable extent. This sentiment has been echoed by the mainstream press in the years since. For example, in 2001, the <span class="emphasis"><em>New York Times</em></span> published a lengthy exposé on the allegedly unique risks of HTTP cookies and even quoted Lawrence Lessig, a noted legal expert and a political activist:<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-12-FT-1">216</a>]</sup><a class="indexterm" id="IDX-CHP-12-0030"/></p><div class="blockquote"><blockquote class="blockquote"><p>Before cookies, the Web was essentially private. After cookies, the Web becomes a space capable of extraordinary monitoring.</p></blockquote></div><p>The high-profile assault on a single HTTP header continued over the course of a decade, gradually shifting its focus toward third-party cookies in particular. Third-party cookies are the cookies set by domains other than the domain of the top-level document, and they are usually associated with the process of loading images, frames, or applets from third-party sites. The reason they have attracted attention is that operators of advertising networks have embraced such cookies as a convenient way to tag a user who sees their ad embedded on <a class="ulink" href="http://fuzzybunnies.com">fuzzybunnies.com</a> and then recognize that user through a similar embedded ad served on <a class="ulink" href="http://playboy.com">playboy.com</a>.</p><p>Because the clearly undesirable possibility of performing this type of cross-domain tracking has been erroneously conflated with the existence of third-party cookies, the pressure on browser vendors has continued to mount. In one instance, the <span class="emphasis"><em>Wall Street Journal</em></span> flat out accused Microsoft of being in bed with advertisers for not eliminating third-party cookies in the company’s product.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-12-FT-2">217</a>]</sup></p><p>Naturally, the readers of this book will recognize that the fixation on HTTP cookies is deeply misguided. There is no doubt that some parties use the mechanism for vaguely sinister purposes, but nothing makes it uniquely suited for this task; there are many other equivalent ways to store unique identifiers on visitors’ computers (such as cache-based tags, previously discussed in <a class="xref" href="ch03.html" title="Chapter 3. Hypertext Transfer Protocol">Chapter 3</a>). Besides, it is simply impossible to prevent cooperating sites from using existing unique fingerprints of every browser (exposed through the JavaScript object model or plug-ins such as Flash) to correlate and mine cross-domain browsing patterns at will. The sites that embed advertisements for profit are quite willing to cooperate with the parties who pay their bills.<a class="indexterm" id="IDX-CHP-12-0031"/><a class="indexterm" id="IDX-CHP-12-0032"/><a class="indexterm" id="IDX-CHP-12-0033"/><a class="indexterm" id="IDX-CHP-12-0034"/><a class="indexterm" id="IDX-CHP-12-0035"/><a class="indexterm" id="IDX-CHP-12-0036"/><a class="indexterm" id="IDX-CHP-12-0037"/><a class="indexterm" id="IDX-CHP-12-0038"/></p><p>In fact, the common reliance on HTTP cookies offers a distinctive advantage to users: Unlike many of the easily embraced alternatives, this mechanism is purpose built and coupled with reasonably well-designed and fine-grained privacy controls. Breaking cookies will not hinder tracking but will remove any pretense of transparency from the end user. Another noted privacy and security activist, Ed Felten, once said: “If you’re going to track me, please use cookies.”<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-12-FT-3">218</a>]</sup></p><p>Unscrupulous online tracking is a significant social issue, and new technical mechanisms may be needed so that users can communicate their privacy preferences to well-behaved sites (such as the recently added <span class="emphasis"><em>DNT</em></span> request header<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-12-FT-4">219</a>]</sup> rolled out in Firefox 4). In order to deal with the ill-behaved ones, a regulatory framework may be required, too. In the absence of such a framework, in Internet Explorer 9, Microsoft is experimenting with a managed blacklist of known bad sources of tracking cookies—but the odds that this would discourage sleazy business practices are slim.</p><p>In any case, despite having little or no merit, the continued public outcry against third-party cookies eventually resulted in several browser vendors shipping half-baked and easily circumvented solutions that let them claim they had done <span class="emphasis"><em>something</em></span>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>In Internet Explorer, setting and reading third-party cookies is blocked by default, except for session cookies accompanied by a satisfactory P3P header. <span class="emphasis"><em>P3P</em></span> (<span class="emphasis"><em>Platform for Privacy Preferences</em></span>)<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-12-FT-5">220</a>]</sup> is a method to construct machine-readable, legally binding summaries of a site’s privacy policy, be it as an XML file or as a <span class="emphasis"><em>compact policy</em></span> in an HTTP header. For example, the keyword TEL in an HTTP header means that the site uses the collected information for telemarketing purposes. (No technical measure will prevent a site from lying in a P3P header, but the potential legal consequences are meant to discourage that.)</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The incredibly ambitious, 111-page P3P specification caused the solution to crumble under its own weight. Large businesses are usually very hesitant to embrace P3P as a solution to technical problems because of the legal footprint of the spec, while small businesses and individual site owners copy over P3P header recipes with little or no understanding of what they are supposed to convey.</p></div></li><li class="listitem"><p>In Safari, the task of setting third-party cookies is blocked by default, but previously issued cookies can be read freely. However, this behavior can be overridden if the user interacts with the cookie-setting document first. Such an interaction could be intentional but may very well not be: The clickjacking-related tricks outlined in <a class="xref" href="ch11.html" title="Chapter 11. Life Outside Same-Origin Rules">Chapter 11</a> apply to this scenario as well.</p></li><li class="listitem"><p>In other browsers, third-party cookies are permitted by default, but a configuration option is provided to change the behavior. Enabling this option limits the ability to set third-party cookies, but reading existing ones is not limited in any way.</p></li></ul></div><p>For the purpose of these checks, a cookie is considered to be coming from a third party if it’s loaded from a completely unrelated domain. For example, a frame pointing to <a class="ulink" href="http://bunnyoutlet.com">bunnyoutlet.com</a> loaded on <a class="ulink" href="http://fuzzybunnies.com">fuzzybunnies.com</a> meets this criterion, but <a class="ulink" href="http://www1.fuzzybunnies.com">www1.fuzzybunnies.com</a> and <a class="ulink" href="http://www2.fuzzybunnies.com">www2.fuzzybunnies.com</a> are considered to be in a first-party relationship. The logic used to make this determination is fragile, and it suffers from the same problems that cookie <span class="emphasis"><em>domain</em></span> scoping would. In Internet Explorer 6 and 7, for example, the comparisons in certain country-level domains are performed incorrectly.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The crusade against third-party cookies could be seen as a harmless exercise, but it has had negative consequences, too. Browsers that reject third-party cookies make it very difficult to build cookie-based authentication for embeddable gadgets and other types of mashups, and they make it difficult to use “sandbox” domains to isolate untrusted but private content from the main application to limit the impact of script-injection flaws.</p></div><div class="sidebar"><a id="security_engineering_cheat_sheet-id10"/><p class="title">Security Engineering Cheat Sheet</p><p><span class="bolditalic">When Building Web Applications on Internal Networks</span><a class="indexterm" id="IDX-CHP-12-0039"/><a class="indexterm" id="IDX-CHP-12-0040"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Assume that determined attackers will be able to interact with those applications through a victim’s browser, regardless of any network-level security controls. Ensure that proper engineering standards are met and require HTTPS with <span class="emphasis"><em>secure</em></span> cookies for all sensitive applications in order to minimize the risk of origin infiltration attacks.</p></li></ul></div><p><span class="bolditalic">When Launching Non-HTTP Services, Particularly on Nonstandard Ports</span><a class="indexterm" id="IDX-CHP-12-0041"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Evaluate the impact of browsers unintentionally issuing HTTP requests to the service and the impact of having the response interpreted as HTTP/0.9. For vulnerable protocols, consider dropping the connection immediately if the received data begins with “GET” or “POST” as one possible precaution.</p></li></ul></div><p><span class="bolditalic">When Using Third-Party Cookies for Gadgets or Sandboxed Content</span><a class="indexterm" id="IDX-CHP-12-0042"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If you need to support Internet Explorer, be prepared to use P3P policies (and evaluate their legal significance). If you need to support Safari, you may have to resort to an alternative credential storage mechanism (such as HTML5 <span class="emphasis"><em>localStorage</em></span>).</p></li></ul></div></div></div>
<div class="chapter" title="Chapter&#xA0;13.&#xA0;Content Recognition Mechanisms"><div class="titlepage"><div><div><h1 class="title"><a id="content_recognition_mechanisms"/>Chapter 13. Content Recognition Mechanisms</h1></div></div></div><p>So far, we have looked at a fair number of well-intentioned browser features that, as the technology matured, proved to be short-sighted and outright dangerous. But now, brace for something special: In the history of the Web, nothing has proven to be as misguided as <span class="emphasis"><em>content sniffing</em></span>.<a class="indexterm" id="IDX-CHP-13-0001"/><a class="indexterm" id="IDX-CHP-13-0002"/></p><p>The original premise behind content sniffing was simple: Browser vendors assumed that in some cases, it would be appropriate—even desirable—to ignore the normally authoritative metadata received from the server, such as the <span class="emphasis"><em>Content-Type</em></span> header. Instead of honoring the developer’s declared intent, implementations that support content sniffing may attempt to second-guess the appropriate course of action by applying proprietary heuristics to the returned payload in order to compensate for possible mistakes. (Recall from <a class="xref" href="ch01.html" title="Chapter 1. Security in the World of Web Applications">Chapter 1</a> that during the First Browser Wars, vendors turned fault-tolerance compatibility into an ill-conceived competitive advantage.)</p><p>It didn’t take long for content-sniffing features to emerge as a substantial and detrimental aspect of the overall browser security landscape. To their horror and disbelief, web developers soon noticed that they couldn’t safely host certain nominally harmless document types like <span class="emphasis"><em>text/plain</em></span> or <span class="emphasis"><em>text/csv</em></span> on behalf of their users; any attempt to do so would inevitably create a risk that such content could be misinterpreted as HTML.<a class="indexterm" id="IDX-CHP-13-0003"/><a class="indexterm" id="IDX-CHP-13-0004"/><a class="indexterm" id="IDX-CHP-13-0005"/><a class="indexterm" id="IDX-CHP-13-0006"/><a class="indexterm" id="IDX-CHP-13-0007"/><a class="indexterm" id="IDX-CHP-13-0008"/></p><p>Perhaps partly in response to these concerns, in 1999 the practice of unsolicited content sniffing was explicitly forbidden in HTTP/1.1:</p><div class="blockquote"><blockquote class="blockquote"><p>If and <span class="bolditalic">only</span> if the media type is not given by a <span class="emphasis"><em>Content-Type</em></span> field, the recipient may attempt to guess the media type via inspection of its content and/or the name extension(s) of the URI used to identify the resource.</p></blockquote></div><p>Alas, this uncharacteristically clear requirement arrived a bit too late. Most browsers were already violating this rule to some extent, and absent a convenient way to gauge the potential consequences, their authors hesitated to simply ditch the offending code. Although several of the most egregious mistakes were cautiously reverted in the past decade, two companies—Microsoft and Apple—largely resisted the effort. They decided that interoperability with broken web applications should trump the obvious security problems. To pacify any detractors, they implemented a couple of imperfect, secondary security mechanisms intended to mitigate the risk.</p><p>Today, the patchwork of content-handling policies and the subsequently deployed restrictions cast a long shadow on the online world, making it nearly impossible to build certain types of web services without resorting to contrived and sometimes expensive tricks. To understand these limitations, let’s begin by outlining several scenarios where a nominally passive document may be misidentified as HTML or something like it.</p><div class="sect1" title="Document Type Detection Logic"><div class="titlepage"><div><div><h1 class="title"><a id="document_type_detection_logic"/>Document Type Detection Logic</h1></div></div></div><p>The simplest and the least controversial type of document detection heuristics, and the one implemented by all modern browsers, is the logic implemented to handle the absence of the <span class="emphasis"><em>Content-Type</em></span> header. This situation, which is encountered very rarely, may be caused by the developer accidentally omitting or mistyping the header name or the document being loaded over a non-HTTP transport mechanism such as <span class="emphasis"><em>ftp:</em></span> or <span class="emphasis"><em>file:</em></span>.</p><p>For HTTP specifically, the original RFCs explicitly permit the browser to examine the payload for clues when the <span class="emphasis"><em>Content-Type</em></span> value is not available. For other protocols, the same approach is usually followed, often as a natural consequence of the design of the underlying code.</p><p>The heuristics employed to determine the type of a document typically amount to checking for static signatures associated with several dozen known file formats (such as images and common plug-in-handled files). The response will also be scanned for known substrings in order to detect signatureless formats such as HTML (in which case, the browser will look for familiar tags—<span class="emphasis"><em>&lt;body&gt;</em></span>, <span class="emphasis"><em>&lt;font&gt;</em></span>, etc). In many browsers, noncontent signals, such as trailing <span class="emphasis"><em>.html</em></span> or <span class="emphasis"><em>.swf</em></span> strings in the path segment of the URL, are taken into account as well.</p><p>The specifics of content-sniffing logic vary wildly from one browser to another and are not well documented or standardized. To illustrate, consider the handling of Adobe Flash (SWF) files served without <span class="emphasis"><em>Content-Type</em></span>: In Opera, they are recognized unconditionally based on a content signature check; in Firefox and Safari, an explicit <span class="emphasis"><em>.swf</em></span> suffix in the URL is required; and Internet Explorer and Chrome will not autorecognize SWF at all.<a class="indexterm" id="IDX-CHP-13-0009"/><a class="indexterm" id="IDX-CHP-13-0010"/><a class="indexterm" id="IDX-CHP-13-0011"/><a class="indexterm" id="IDX-CHP-13-0012"/><a class="indexterm" id="IDX-CHP-13-0013"/><a class="indexterm" id="IDX-CHP-13-0014"/><a class="indexterm" id="IDX-CHP-13-0015"/><a class="indexterm" id="IDX-CHP-13-0016"/></p><p>Rest assured, the SWF file format is not an exceptional case. For example, when dealing with HTML files, Chrome and Firefox will autodetect the document only if one of several predefined HTML tags appears at the very beginning of the file; while Firefox will be eager to “detect” HTML based solely on the presence of an <span class="emphasis"><em>.html</em></span> extension in the URL, even if no recognizable markup is seen. Internet Explorer, on the other hand, will simply always default to HTML in the absence of <span class="emphasis"><em>Content-Type</em></span>, and Opera will scan for known HTML tags within the first 1000 bytes of the returned payload.</p><p>The assumption behind all this madness is that the absence of <span class="emphasis"><em>Content-Type</em></span> is an expression of an intentional wish by the publisher of the page—but that assumption is not always accurate and has caused a fair number of security bugs. That said, most web servers actively enforce the presence of a <span class="emphasis"><em>Content-Type</em></span> header and will insert a default value if one is not explicitly generated by the server-side scripts that handle user requests. So perhaps there is no need to worry? Well, unfortunately, this is not where the story of content sniffing ends.</p><div class="sect2" title="Malformed MIME Types"><div class="titlepage"><div><div><h2 class="title"><a id="malformed_mime_types"/>Malformed MIME Types</h2></div></div></div><p>The HTTP RFC permits content sniffing only in the absence of <span class="emphasis"><em>Content-Type</em></span> data; the browser is openly prohibited from second-guessing the intent of the webmaster if the header is present in any shape or form. In practice, however, this advice is not taken seriously. The next small step taken off the cliff was the decision to engage heuristics if the server-returned MIME type was deemed invalid in any way.</p><p>According to the RFC, the <span class="emphasis"><em>Content-Type</em></span> header should consist of two slash-delimited alphanumeric tokens (<span class="emphasis"><em>type/subtype</em></span>), potentially followed by other semicolon-delimited parameters. These tokens may contain any non-whitespace, seven-bit ASCII characters other than a couple of special “separators” (a generic set that includes characters such as “@”, “?”, and the slash itself). Most browsers attempt to enforce this syntax but do so inconsistently; the absence of a slash is seen almost universally as an invitation to content sniffing, and so is the inclusion of whitespaces and certain (but not all) control characters in the first portion of the identifier (the <span class="emphasis"><em>type</em></span> token). On the other hand, the technically illegal use of high-bit characters or separators affects the validity of this field only in Opera.</p><p>The reasons for this design are difficult to understand, but to be fair, the security impact is still fairly limited. As far as web application developers are concerned, care must be exercised not to make typos in <span class="emphasis"><em>Content-Type</em></span> values and not to allow users to specify arbitrary, user-controlled MIME types (merely validated against a blacklist of known bad options). These requirements may be unexpected, but usually they do not matter a lot. So, what are we ultimately getting at?</p></div><div class="sect2" title="Special Content-Type Values"><div class="titlepage"><div><div><h2 class="title"><a id="special_content-type_values"/>Special Content-Type Values</h2></div></div></div><p>The first clear signal that content sniffing was becoming truly dangerous was the handling of a seemingly unremarkable MIME type known as <span class="emphasis"><em>application/octet-stream</em></span>. This specific value is not mentioned at all in the HTTP specification but is given a special (if vague) role deep in the bowels of RFC 2046:<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-13-FT-1">221</a>]</sup><a class="indexterm" id="IDX-CHP-13-0017"/><a class="indexterm" id="IDX-CHP-13-0018"/><a class="indexterm" id="IDX-CHP-13-0019"/><a class="indexterm" id="IDX-CHP-13-0020"/><a class="indexterm" id="IDX-CHP-13-0021"/><a class="indexterm" id="IDX-CHP-13-0022"/><a class="indexterm" id="IDX-CHP-13-0023"/></p><div class="blockquote"><blockquote class="blockquote"><p>The recommended action for an implementation that receives an <span class="emphasis"><em>application/octet-stream</em></span> entity is to simply offer to put the data in a file, with any <span class="emphasis"><em>Content-Transfer-Encoding</em></span> undone, or perhaps to use it as input to a user-specified process.</p></blockquote></div><p>The original intent of this MIME type may not be crystal clear from the quoted passage alone, but it is commonly interpreted as a way for web servers to indicate that the returned file has no special meaning to the server and that it should not have one to the client. Consequently, most web servers default to <span class="emphasis"><em>application/octet-stream</em></span> on all types of opaque, nonweb files, such as downloadable executables or archives, if no better <span class="emphasis"><em>Content-Type</em></span> match can be found. However, in rare cases of administrator errors (for example, due to deletion of the essential <span class="emphasis"><em>AddType</em></span> directives in Apache configuration files), web servers may also fall back to this MIME type on documents meant for in-browser consumption. This configuration error is, of course, very easy to detect and fix, but Microsoft, Opera, and Apple nevertheless chose to compensate for it. The browsers from these vendors eagerly engage in content sniffing whenever <span class="emphasis"><em>application/octet-stream</em></span> is seen.<sup>[<a class="footnote" href="#ftn.CHP-13-FN-1" id="CHP-13-FN-1">60</a>]</sup></p><p>This particular design decision has suddenly made it more difficult for web applications to host binary files on behalf of the user. For example, any code-hosting platform must exercise caution when returning executables or source archives as <span class="emphasis"><em>application/octet-stream</em></span>, because there is a risk they may be misinterpreted as HTML and displayed inline. That’s a major issue for any software hosting or webmail system and for many other types of web apps. (It’s slightly safer for them to use any other generic-sounding MIME type, such as <span class="emphasis"><em>application/binary</em></span>, because there is no special case for it in the browser code.)</p><p>In addition to the special treatment given to <span class="emphasis"><em>application/octet-stream</em></span>, a second, far more damaging exception exists for <span class="emphasis"><em>text/plain</em></span>. This decision, unique to Internet Explorer and Safari, traces back to RFC 2046. In that document, <span class="emphasis"><em>text/plain</em></span> is given a dual function: first, to transmit plaintext documents (ones that <span class="emphasis"><em>“do not provide for or allow formatting commands, font attribute specifications, processing instructions, interpretation directives, or content markup”</em></span>) and, second, to provide a fallback value for any text-based documents not otherwise recognized by the sender.<a class="indexterm" id="IDX-CHP-13-0024"/></p><p>The distinction between <span class="emphasis"><em>application/octet-stream</em></span> and <span class="emphasis"><em>text/plain</em></span> fallback made perfect sense for email messages, a topic that this RFC originally dealt with, but proved to be much less relevant to the Web. Nevertheless, some web servers adopted <span class="emphasis"><em>text/plain</em></span> as the fallback value for certain types of responses (most notably, the output of CGI scripts).</p><p>The <span class="emphasis"><em>text/plain</em></span> logic subsequently implemented in Internet Explorer and Safari in order to detect HTML in such a case is really bad news: It robs web developers of the ability to safely use this MIME type to generate user-specific plaintext documents and offers no alternatives. This has resulted in a substantial number of web application vulnerabilities, but to this day, Internet Explorer developers seem to have no regrets and have not changed the default behavior of their code.</p><p>Safari developers, on the other hand, recognized and tried to mitigate the risk while keeping the functionality in place—but they failed to appreciate the complexity of the Web. The solution implemented in their browser is to rely on a secondary signal in addition to the presence of a plausible-looking HTML markup in the document body. The presence of an extension such as <span class="emphasis"><em>.html</em></span> or <span class="emphasis"><em>.xml</em></span> at the end of the URL path is interpreted by their implementation as a sign that content sniffing can be performed safely. After all, the owner of the site wouldn’t name the file this way otherwise, right?</p><p>Alas, the signal they embraced is next to worthless. As it turns out, almost all web frameworks support at least one of several methods for encoding parameters in the path segment of the URL instead of in the more traditionally used query part. For example, in Apache, one such mechanism is known as PATH_INFO, and it happens to be enabled by default. By leveraging such a parameter-passing scheme, the attacker can usually append nonfunctional garbage to the path, thereby confusing the browser without affecting how the server will respond to the submitted request itself.<a class="indexterm" id="IDX-CHP-13-0025"/></p><p>To illustrate, the following two URLs will likely have the same effect for websites running on Apache or IIS:</p><a id="I_programlisting5_d1e15514"/><pre class="programlisting">http://www.fuzzybunnies.com/get_file.php?id=1234</pre><p>and</p><a id="I_programlisting5_d1e15518"/><pre class="programlisting">http://www.fuzzybunnies.com/get_file.php<strong class="userinput"><code>/evil.html</code></strong>?id=1234</pre><p>In some less-common web frameworks, the following approach may also work:</p><a id="I_programlisting5_d1e15525"/><pre class="programlisting">http://www.fuzzybunnies.com/get_file.php<strong class="userinput"><code>;evil.html</code></strong>?id=1234</pre></div><div class="sect2" title="Unrecognized Content Type"><div class="titlepage"><div><div><h2 class="title"><a id="unrecognized_content_type"/>Unrecognized Content Type</h2></div></div></div><p>Despite the evident trouble with <span class="emphasis"><em>text/plain</em></span>, the engineers working on Internet Explorer decided to take their browser’s heuristics even further. Internet Explorer applies both content sniffing and extension matching<sup>[<a class="footnote" href="#ftn.CHP-13-FN-2" id="CHP-13-FN-2">61</a>]</sup> not only to a handful of generic MIME types but also to any document type not immediately recognized by the browser. This broad category may include everything from JSON (<span class="emphasis"><em>application/json</em></span>) to multimedia formats such as Ogg Vorbis (<span class="emphasis"><em>audio/ogg</em></span>).<a class="indexterm" id="IDX-CHP-13-0026"/><a class="indexterm" id="IDX-CHP-13-0027"/><a class="indexterm" id="IDX-CHP-13-0028"/><a class="indexterm" id="IDX-CHP-13-0029"/><a class="indexterm" id="IDX-CHP-13-0030"/><a class="indexterm" id="IDX-CHP-13-0031"/><a class="indexterm" id="IDX-CHP-13-0032"/><a class="indexterm" id="IDX-CHP-13-0033"/></p><p>Such a design is, naturally, problematic and causes serious problems when hosting any user-controlled document formats other than a small list of universally supported MIME types registered internally in the browser or when routed to a handful of commonly installed external applications.</p><p>Nor do the content-sniffing habits of Internet Explorer finally end there: The browser will also resort to payload inspection when dealing with internally recognized document formats that, for any reason, can’t be parsed cleanly. In Internet Explorer versions prior to 8, serving a user-supplied but nonvalidated file claiming to be an JPEG image can lead to the response being treated as HTML. And it gets even more hilarious: Even a subtle mistake, such as serving a valid GIF file with <span class="emphasis"><em>Content-Type: image/jpeg</em></span>, triggers the same code path. Heck, several years ago, Internet Explorer even detected HTML on any valid, properly served PNG file. Thankfully, this logic has since been disabled—but the remaining quirks are still a minefield.<a class="indexterm" id="IDX-CHP-13-0034"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In order to fully appreciate the risk of content sniffing on valid images, note that it is not particularly difficult to construct images that validate correctly but that carry attacker-selected ASCII strings—such as HTML markup—in the raw image data. In fact, it is relatively easy to construct images that, when scrubbed, rescaled, and recompressed using a known, deterministic algorithm, will have a nearly arbitrary string appear out of the blue in the resulting binary stream.<a class="indexterm" id="IDX-CHP-13-0035"/></p></div><p>To its credit, in Internet Explorer 8 and beyond, Microsoft decided to disallow most types of gratuitous content sniffing on known MIME types in the <span class="emphasis"><em>image/*</em></span> category. It also disallowed HTML detection (but not XML detection) on image formats not recognized by the browser, such as <span class="emphasis"><em>image/jp2</em></span> (JPEG2000).</p><p>This single tweak aside, Microsoft has proven rather unwilling to make meaningful changes to its content-sniffing logic, and its engineers have publicly defended the need to maintain compatibility with broken websites.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-13-FT-2">222</a>]</sup> Microsoft probably wants to avoid the wrath of large institutional customers, many of whom rely on ancient and poorly designed intranet apps and depend on the quirks of the Internet Explorer-based monoculture on the client end.</p><p>In any case, due to the backlash that Internet Explorer faced over its <span class="emphasis"><em>text/plain</em></span> handling logic, newer versions offer a partial workaround: an optional HTTP header, <span class="emphasis"><em>X-Content-Type-Options: nosniff</em></span>, which allows website owners to opt out of most of the controversial content heuristics. The use of this header is highly recommended; unfortunately, the support for it has not been backported to versions 6 and 7 of the browser and has only a limited support in other browsers. In other words, it cannot be depended on as a sole defense against content sniffing.<a class="indexterm" id="IDX-CHP-13-0036"/><a class="indexterm" id="IDX-CHP-13-0037"/><a class="indexterm" id="IDX-CHP-13-0038"/><a class="indexterm" id="IDX-CHP-13-0039"/><a class="indexterm" id="IDX-CHP-13-0040"/><a class="indexterm" id="IDX-CHP-13-0041"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Food for thought: According to the data collected in a 2011 survey by SHODAN and Chris John Riley,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-13-FT-3">223</a>]</sup> only about 0.6 percent of the 10,000 most popular websites on the Internet used this header on a site-wide level.<a class="indexterm" id="IDX-CHP-13-0042"/></p></div></div><div class="sect2" title="Defensive Uses of Content-Disposition"><div class="titlepage"><div><div><h2 class="title"><a id="defensive_uses_of_content-disposition"/>Defensive Uses of Content-Disposition</h2></div></div></div><p>The <span class="emphasis"><em>Content-Disposition</em></span> header, mentioned several times in <a class="xref" href="pt01.html" title="Part I. Anatomy of the Web">Part I</a> of this book, may be considered a defense against content sniffing in some use cases. The function of this header is not explained satisfactorily in the HTTP/1.1 specification. Instead, it is documented only in RFC 2183,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-13-FT-4">224</a>]</sup> where its role is explained only as it relates to mail applications:</p><div class="blockquote"><blockquote class="blockquote"><p>Bodyparts can be designated “attachment” to indicate that they are separate from the main body of the mail message, and that their display should not be automatic, but contingent upon some further action of the user. The MUA<sup>[<a class="footnote" href="#ftn.CHP-13-FN-3" id="CHP-13-FN-3">62</a>]</sup> might instead present the user of a bitmap terminal with an iconic representation of the attachments, or, on character terminals, with a list of attachments from which the user could select for viewing or storage.</p></blockquote></div><p>The HTTP RFC acknowledges the use of <span class="emphasis"><em>Content-Disposition: attachment</em></span> in the web domain but does not elaborate on its intended function. In practice, upon seeing this header during a normal document load, most browsers will display a file download dialog, usually with three buttons: “open,” “save,” and “cancel.” The browser will not attempt to interpret the document any further unless the “open” option is selected or the document is saved to disk and then opened manually. For the “save” option, an optional <span class="emphasis"><em>filename</em></span> parameter included in the header is used to suggest the name of the download, too. If this field is absent, the filename will be derived from the notoriously unreliable URL path data.</p><p>Because the header prevents most browsers from immediately interpreting and displaying the returned payload, it is particularly well suited for safely hosting opaque, downloadable files such as the aforementioned case of archives or executables. Furthermore, because it is ignored on type-specific subresource loads (such as <span class="emphasis"><em>&lt;img&gt;</em></span> or <span class="emphasis"><em>&lt;script&gt;</em></span>), it may also be employed to protect user-controlled JSON responses, images, and so on against content sniffing risks. (The reason why all implementations ignore <span class="emphasis"><em>Content-Disposition</em></span> for these types of navigation is not particularly clear, but given the benefits, it’s best not to question the logic now.)</p><p>One example of a reasonably robust use of <span class="emphasis"><em>Content-Disposition</em></span> and other HTTP headers to discourage content sniffing on a JSON response may be<a class="indexterm" id="IDX-CHP-13-0043"/><a class="indexterm" id="IDX-CHP-13-0044"/><a class="indexterm" id="IDX-CHP-13-0045"/><a class="indexterm" id="IDX-CHP-13-0046"/><a class="indexterm" id="IDX-CHP-13-0047"/><a class="indexterm" id="IDX-CHP-13-0048"/></p><a id="I_programlisting5_d1e15719"/><pre class="programlisting">Content-Type: application/json; charset=utf-8
X-Content-Type-Options: nosniff
Content-Disposition: attachment; filename="json_response.txt"

{ "search_term": "&lt;html&gt;&lt;script&gt;alert('Hi mom!')&lt;/script&gt;", ... }</pre><p>The defensive use of <span class="emphasis"><em>Content-Disposition</em></span> is highly recommended where possible, but it is important to recognize that the mechanism is neither mandated for all user agents nor well documented. In less popular browsers, such as Safari Mobile, the header may have no effect; in mainstream browsers, such as Internet Explorer 6, Opera, and Safari, a series of <span class="emphasis"><em>Content-Disposition</em></span> bugs have at one point or another rendered the header ineffective in attacker-controlled cases.</p><p>Another problem with the reliance on <span class="emphasis"><em>Content-Disposition</em></span> is that the user may still be inclined to click “open.” Casual users can’t be expected to be wary of viewing Flash applets or HTML documents just because a download prompt gets in the way. In most browsers, selecting “open” puts the document in a <span class="emphasis"><em>file:</em></span> origin, which may be problematic on its own (the recent improvements in Chrome certainly help), and in Opera, the document will be displayed in the context of the originating domain. Arguably, Internet Explorer makes the best choice: HTML documents are placed in a special sandbox using a <span class="emphasis"><em>mark-of-the-web</em></span> mechanism (outlined in more detail in <a class="xref" href="ch15.html" title="Chapter 15. Extrinsic Site Privileges">Chapter 15</a>), but even in that browser, Java or Flash applets will not benefit from this feature.</p></div><div class="sect2" title="Content Directives on Subresources"><div class="titlepage"><div><div><h2 class="title"><a id="content_directives_on_subresources"/>Content Directives on Subresources</h2></div></div></div><p>Most content-related HTTP headers, such as <span class="emphasis"><em>Content-Type</em></span>, <span class="emphasis"><em>Content-Disposition</em></span>, and <span class="emphasis"><em>X-Content-Type-Options</em></span>, have largely no effect on type-specific subresource loads, such as <span class="emphasis"><em>&lt;img&gt;</em></span>, <span class="emphasis"><em>&lt;script&gt;</em></span>, or <span class="emphasis"><em>&lt;embed&gt;</em></span>. In these cases, the embedding party has nearly complete control over how the response will be interpreted by the browser.</p><p><span class="emphasis"><em>Content-Type</em></span> and <span class="emphasis"><em>Content-Disposition</em></span> may also not be given much attention when handling requests initiated from within plug-in-executed code. For example, recall from <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a> that any <span class="emphasis"><em>text/plain</em></span> or <span class="emphasis"><em>text/csv</em></span> documents may be interpreted by Adobe Flash as security-sensitive <span class="emphasis"><em>crossdomain.xml</em></span> policies unless an appropriate site-wide metapolicy is present in the root directory on the destination server. Whether you wish to call it “content sniffing” or just “content-type blindness,” the problem is still very real.<a class="indexterm" id="IDX-CHP-13-0049"/></p><p>Consequently, even when all previously discussed HTTP headers are used religiously, it is important to always consider the possibility that a third-party page may trick the browser into interpreting that page as one of several problematic document types; applets and applet-related content, PDFs, stylesheets, and scripts are usually of particular concern. To minimize the risk of mishaps, you should carefully constrain the structure and character set of any served payloads or use “sandbox” domains to isolate any document types that can’t be constrained particularly well.</p></div><div class="sect2" title="Downloaded Files and Other Non-HTTP Content"><div class="titlepage"><div><div><h2 class="title"><a id="downloaded_files_and_other_non-http_cont"/>Downloaded Files and Other Non-HTTP Content</h2></div></div></div><p>The behavior of HTTP headers such as <span class="emphasis"><em>Content-Type</em></span>, <span class="emphasis"><em>Content-Disposition</em></span>, and <span class="emphasis"><em>X-Content-Type-Options</em></span> may be convoluted and exception ridden, but at the very least, they add up to a reasonably consistent whole. Still, it is easy to forget that in many real-world cases, the metadata contained in these headers is simply not available—and in that case, all bets are off. For example, the handling of documents retrieved over <span class="emphasis"><em>ftp:</em></span>, or saved to disk and opened over the <span class="emphasis"><em>file:</em></span> protocol, is highly browser- and protocol-specific and often surprises even the most seasoned security experts.<a class="indexterm" id="IDX-CHP-13-0050"/><a class="indexterm" id="IDX-CHP-13-0051"/><a class="indexterm" id="IDX-CHP-13-0052"/><a class="indexterm" id="IDX-CHP-13-0053"/><a class="indexterm" id="IDX-CHP-13-0054"/><a class="indexterm" id="IDX-CHP-13-0055"/><a class="indexterm" id="IDX-CHP-13-0056"/><a class="indexterm" id="IDX-CHP-13-0057"/><a class="indexterm" id="IDX-CHP-13-0058"/></p><p>When opening local files, browsers usually give precedence to file extension data, and if the extension is one of the hardcoded values known to the browser, such as <span class="emphasis"><em>.txt</em></span> or <span class="emphasis"><em>.html</em></span>, most browsers will take this information at face value. Chrome is the exception; it will attempt to autodetect certain “passive” document types, such as JPEG, even inside <span class="emphasis"><em>.txt</em></span> documents. (HTML, however, is strictly off-limits.)<a class="indexterm" id="IDX-CHP-13-0059"/></p><p>When it comes to other extensions registered to external programs, the behavior is a bit less predictable. Internet Explorer will usually invoke the external application, but most other browsers will resort to content sniffing, behaving as though they loaded the document over HTTP with no <span class="emphasis"><em>Content-Type</em></span> set. All browsers will also fall back to content sniffing if the extension is not known (say, <span class="emphasis"><em>.foo</em></span>).<a class="indexterm" id="IDX-CHP-13-0060"/></p><p>The heavy reliance on file extension data and content sniffing for <span class="emphasis"><em>file:</em></span> documents creates an interesting contrast with the normal handling of Internet-originating resources. On the Web, <span class="emphasis"><em>Content-Type</em></span> is by and large the authoritative descriptor of document type. File extension information is ignored most of the time, and it is perfectly legal to host a functional JPEG file at a location such as <a class="ulink" href="http://fuzzybunnies.com/gotcha.txt">http://fuzzybunnies.com/gotcha.txt</a>. But what happens when this document is downloaded to disk? Well, in such case, the effective meaning of the resource will unexpectedly change: When accessing it over the <span class="emphasis"><em>file:</em></span> protocol, the browser may insist on rendering it as a text file, based strictly on the extension data.</p><p>The example above is fairly harmless, but other content promotion vectors, such as an image becoming an executable, may be more troubling. To that effect, Opera and Internet Explorer will attempt to modify the extension to match the MIME type for a handful of known <span class="emphasis"><em>Content-Type</em></span> values. Other browsers do not offer this degree of protection, however, and may even be thoroughly confused by the situation they find themselves in. <a class="xref" href="ch13.html#prompt_displayed_by_firefox_when_saving" title="Figure 13-1. Prompt displayed by Firefox when saving a Content-Type: image/jpeg document served with Content-Disposition: attachment. The “hello.exe” filename is derived by the browser from a nonfunctional PATH_INFO suffix appended by the attacker at the end of the URL. The prompt incorrectly claims that the .exe file is a “JPEG Image.” In fact, when saved to disk, it will be an executable.">Figure 13-1</a> captures Firefox in one such embarrassing moment.</p><div class="figure"><a id="prompt_displayed_by_firefox_when_saving"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e15895"/><img alt="Prompt displayed by Firefox when saving a Content-Type: image/jpeg document served with Content-Disposition: attachment. The “hello.exe” filename is derived by the browser from a nonfunctional PATH_INFO suffix appended by the attacker at the end of the URL. The prompt incorrectly claims that the .exe file is a “JPEG Image.” In fact, when saved to disk, it will be an executable." src="httpatomoreillycomsourcenostarchimages950033.png.jpg"/></div></div><p class="title">Figure 13-1. Prompt displayed by Firefox when saving a Content-Type: image/jpeg document served with Content-Disposition: attachment. The “hello.exe” filename is derived by the browser from a nonfunctional PATH_INFO suffix appended by the attacker at the end of the URL. The prompt incorrectly claims that the .exe file is a “JPEG Image.” In fact, when saved to disk, it will be an executable.</p></div><p>This problem underscores the importance of returning an explicit, harmless <span class="emphasis"><em>filename</em></span> value whenever using a <span class="emphasis"><em>Content-Disposition</em></span> attachment, to prevent the victim from being tricked into downloading a document format that the site owner never intended to host.<a class="indexterm" id="IDX-CHP-13-0061"/><a class="indexterm" id="IDX-CHP-13-0062"/><a class="indexterm" id="IDX-CHP-13-0063"/><a class="indexterm" id="IDX-CHP-13-0064"/></p><p>Given the complex logic used for <span class="emphasis"><em>file:</em></span> URLs, the simplicity of <span class="emphasis"><em>ftp:</em></span> handling may come as a shock. When accessing documents over FTP, most browsers pay no special attention to file extensions and will simply indulge in rampant content sniffing. One exception is Opera, where extension data still takes precedence. From the engineering point of view, the prevalent approach to FTP may seem logical: The protocol can be considered roughly equivalent to HTTP/0.9. Nevertheless, the design also violates the principle of least astonishment. Server owners would not expect that by allowing users to upload <span class="emphasis"><em>.txt</em></span> documents to an FTP site, they are automatically consenting to host active HTML content within their domain.<a class="indexterm" id="IDX-CHP-13-0065"/></p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-13-FN-1" id="ftn.CHP-13-FN-1">60</a>] </sup>In Internet Explorer, this implemented logic differs subtly from a scenario where no <span class="emphasis"><em>Content-Type</em></span> is present. Instead of always assuming HTML, the browser will scan the first 256 bytes for popular HTML tags and other predefined content signatures. From the security standpoint, however, it’s not a very significant difference.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-13-FN-2" id="ftn.CHP-13-FN-2">61</a>] </sup>Naturally, path-based extension matching is essentially worthless for the reasons discussed in the previous section; but in the case of Internet Explorer 6, it gets even worse. In this browser, the extension can appear in the query portion of the URL. Nothing stops the attacker from simply appending <span class="emphasis"><em>?foo=bar.html</em></span> to the requested URL, effectively ensuring that this check is always satisfied.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-13-FN-3" id="ftn.CHP-13-FN-3">62</a>] </sup>MUA stands for “mail user agent,” that is, a client application used to retrieve, display, and compose mail messages.</p></div></div></div>
<div class="sect1" title="Character Set Handling"><div class="titlepage"><div><div><h1 class="title"><a id="character_set_handling"/>Character Set Handling</h1></div></div></div><p>Document type detection is one of the more important pieces of the content-processing puzzle, but it is certainly not the only one. For all types of text-based files rendered in the browser, one more determination needs to be made: The appropriate character set transformation must be identified and applied to the input stream. The output encoding sought by the browser is typically UTF-8 or UTF-16; the input, on the other hand, is up to the author of the page.</p><p>In the simplest scenario, the appropriate encoding method will be provided by the server in a <span class="emphasis"><em>charset</em></span> parameter of the <span class="emphasis"><em>Content-Type</em></span> header. In the case of HTML documents, the same information may also be conveyed to some extent through the <span class="emphasis"><em>&lt;meta&gt;</em></span> directive. (The browser will attempt to speculatively extract and interpret this directive before actually parsing the document.)</p><p>Unfortunately, the dangerous qualities of certain character encodings, as well as the actions taken by the browser when the <span class="emphasis"><em>charset</em></span> parameter is not present or is not recognized, once again make life a lot more interesting than the aforementioned simple rule would imply. To understand what can go wrong, we first need to recognize three special classes of character sets that may alter the semantics of HTML or XML documents:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Character sets that permit noncanonical representations of standard 7-bit ASCII codes</strong></span>. Such noncanonical sequences could be used to cleverly encode HTML syntax elements, such as angle brackets or quotes, in a manner that survives a simple server-side check. For example, the famously problematic UTF-7 encoding permits the “&lt;” character to be encoded as a five-character sequence of “+ADw-”, a string that most server-side filters will happily permit as is. In a similar vein, UTF-8 specification formally prohibits, but technically permits, “&lt;” to be represented by unnecessarily verbose 2- to 5-byte sequences, from 0xC0 0xBC to 0xFC 0x80 0x80 0x80 0x80 0xBC.<sup>[<a class="footnote" href="#ftn.CHP-13-FN-4" id="CHP-13-FN-4">63</a>]</sup></p></li><li class="listitem"><p><span class="strong"><strong>Variable length encodings that give special meaning to one or more bytes that follow a special prefix</strong></span>. Such logic may result in legitimate HTML syntax elements being “consumed” as part of an unintentional multibyte literal. For example, the Shift JIS prefix code 0xE0 can cause the subsequent angle bracket or a quote to be consumed in Internet Explorer, Firefox, and Opera (but not in Chrome), possibly severely altering the meaning of the inline markup.</p><p>The opposite problem may also occur: The server may be convinced that it is outputting a multibyte literal, but this literal may be rejected by the browser and interpreted as several individual characters. In EUC-KR, the 0x8E prefix is honored only if the subsequent character has an ASCII code of 0x41 or higher. Any less and it will not have the expected effect, but not all server-side implementations may notice.</p></li><li class="listitem"><p><span class="strong"><strong>Encodings that are completely incompatible with 8-bit ASCII</strong></span>. These cases will simply lead to a very different view of document structure between the client and the server. Common examples include UTF-16 or UTF-32.</p></li></ul></div><p>The bottom line is that unless the server has a perfect command of the character set it is generating and unless it is certain that the client will not apply an unexpected transformation to the payload, serious complications may arise. For example, consider a web application that removes angle brackets from the highlighted user-controlled string in the following piece of HTML:</p><a id="I_programlisting5_d1e15982"/><pre class="programlisting">You are currently viewing:
&lt;span class="blog_title"&gt;
 <strong class="userinput"><code>+ADw-script+AD4-alert("Hi mom!")+ADw-/script+AD4-</code></strong>
&lt;/span&gt;</pre><p>If that document is interpreted as UTF-7 by the receiving party, the actual parsed markup will look as follows:</p><a id="I_programlisting5_d1e15989"/><pre class="programlisting">You are currently viewing:
&lt;span class="blog_title"&gt;
 <strong class="userinput"><code>&lt;script&gt;alert("Hi mom!")&lt;/script&gt;</code></strong>
&lt;/span&gt;</pre><p>A similar problem, this time related to byte consumption in Shift JIS encoding, is illustrated below. A multibyte prefix is permitted to consume a closing quote, and as a result, the associated HTML tag is not terminated as expected, enabling the attacker to inject an extra <span class="emphasis"><em>onerror</em></span> handler into the markup:</p><a id="I_programlisting5_d1e15999"/><pre class="programlisting">&lt;img src="http://fuzzybunnies.com/<strong class="userinput"><code>[0xE0]</code></strong>"&gt;
 <strong class="userinput"><code>...this is still a part of the markup...</code></strong>
  <strong class="userinput"><code>...but the server doesn't know...</code></strong>
  <strong class="userinput"><code>" onerror="alert('This will execute!')"</code></strong>
&lt;div&gt;
  ...page content continues...
&lt;/div&gt;</pre><p>It is simply imperative to prevent character set autodetection for all text-based documents that contain any type of user-controlled data. Most browsers will engage in character set detection if the <span class="emphasis"><em>charset</em></span> parameter is not found in the <span class="emphasis"><em>Content-Type</em></span> header or in the <span class="emphasis"><em>&lt;meta&gt;</em></span> tag. Some marked differences exist between the implementations (for example, only Internet Explorer is keen to detect UTF-7), but you should never assume that the outcome of character set sniffing will be safe.<a class="indexterm" id="IDX-CHP-13-0066"/><a class="indexterm" id="IDX-CHP-13-0067"/><a class="indexterm" id="IDX-CHP-13-0068"/><a class="indexterm" id="IDX-CHP-13-0069"/><a class="indexterm" id="IDX-CHP-13-0070"/><a class="indexterm" id="IDX-CHP-13-0071"/><a class="indexterm" id="IDX-CHP-13-0072"/></p><p>Character set autodetection will also be attempted if the character set is not recognized or is mistyped; this problem is compounded by the fact that charset naming can be ambiguous and that web browsers are inconsistent in how much tolerance they have for common name variations. As a single data point, consider the fact that Internet Explorer recognizes both ISO-8859-2 and ISO8859-2 (with no dash after the ISO part) as valid character set identifiers in the <span class="emphasis"><em>Content-Type</em></span> header but fails to recognize UTF8 as an alias for UTF-8. The wrong choice can cause some serious pain.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Fun fact: The <span class="emphasis"><em>X-Content-Type-Options</em></span> header has no effect on character-sniffing logic.</p></div><div class="sect2" title="Byte Order Marks"><div class="titlepage"><div><div><h2 class="title"><a id="byte_order_marks"/>Byte Order Marks</h2></div></div></div><p>We are not done with character set detection just yet! Internet Explorer needs to be singled out for yet another dramatically misguided content-handling practice: the tendency to give precedence to the so-called <span class="emphasis"><em>byte order mark (BOM)</em></span>, a sequence of bytes that can be placed at the beginning of a file to identify its encoding, over the explicitly provided <span class="emphasis"><em>charset</em></span> data. When such a marker is detected in the input file, the declared character set is ignored.</p><p><a class="xref" href="ch13s02.html#common_byte_order_markers_open_parenthes" title="Table 13-1. Common Byte Order Markers (BOMs)">Table 13-1</a> shows several common markers. Of these, the printable UTF-7 BOM is particularly sneaky.</p><div class="table"><a id="common_byte_order_markers_open_parenthes"/><p class="title">Table 13-1. Common Byte Order Markers (BOMs)</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Common Byte Order Markers (BOMs)"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Encoding name</p></th><th style="text-align: left" valign="bottom"><p>Byte order mark sequence</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>UTF-7</p></td><td style="text-align: left" valign="top"><p>“+/v” followed by “8”, “9”, “+”, or “/”</p></td></tr><tr><td style="text-align: left" valign="top"><p>UTF-8</p></td><td style="text-align: left" valign="top"><p>0xEF 0xBB 0xBF</p></td></tr><tr><td style="text-align: left" valign="top"><p>UTF-16 little endian</p></td><td style="text-align: left" valign="top"><p>0xFF 0xFE</p></td></tr><tr><td style="text-align: left" valign="top"><p>UTF-16 big endian</p></td><td style="text-align: left" valign="top"><p>0xFE 0xFF</p></td></tr><tr><td style="text-align: left" valign="top"><p>UTF-32 little endian</p></td><td style="text-align: left" valign="top"><p>0xFF 0xFE 0x00 0x00</p></td></tr><tr><td style="text-align: left" valign="top"><p>UTF-32 big endian</p></td><td style="text-align: left" valign="top"><p>0x00 0x00 0xFE 0xFF</p></td></tr><tr><td style="text-align: left" valign="top"><p>GB −18030</p></td><td style="text-align: left" valign="top"><p>0x84 0x31 0x95 0x33</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Microsoft engineers acknowledge the problem with this design and, as of this writing, say that the logic may be revised, depending on the outcome of compatibility tests. If the problem is resolved by the time this book hits the shelves, kudos to them. Until then, allowing the attacker to control the first few bytes of an HTTP response that is not otherwise protected by <span class="emphasis"><em>Content-Disposition</em></span> may be a bad idea—and other than padding the response, there is no way to work around this glitch.</p></div></div><div class="sect2" title="Character Set Inheritance and Override"><div class="titlepage"><div><div><h2 class="title"><a id="character_set_inheritance_and_override"/>Character Set Inheritance and Override</h2></div></div></div><p>Two additional, little-known mechanisms should be taken into account when evaluating the potential impact on character set handling strategies in contemporary web browsers. Both of these features may permit an attacker to force undesirable character encoding upon another page, without relying on character sniffing.<a class="indexterm" id="IDX-CHP-13-0073"/><a class="indexterm" id="IDX-CHP-13-0074"/><a class="indexterm" id="IDX-CHP-13-0075"/><a class="indexterm" id="IDX-CHP-13-0076"/><a class="indexterm" id="IDX-CHP-13-0077"/><a class="indexterm" id="IDX-CHP-13-0078"/><a class="indexterm" id="IDX-CHP-13-0079"/><a class="indexterm" id="IDX-CHP-13-0080"/><a class="indexterm" id="IDX-CHP-13-0081"/><a class="indexterm" id="IDX-CHP-13-0082"/></p><p>The first apparatus in question, supported by all but Internet Explorer, is known as <span class="emphasis"><em>character set inheritance</em></span>. Under this policy, any encoding defined for the top-level frame may be automatically applied to any framed documents that do not have their own, valid <span class="emphasis"><em>charset</em></span> value set. Initially, such inheritance is extended to all framing scenarios, even across completely unrelated websites. However, when Stefan Esser, Abhishek Arya, and several other researchers demonstrated a number of plausible attacks that leveraged this feature to force UTF-7 parsing on unsuspecting targets, Firefox and WebKit developers decided to limit the behavior to same-origin frames. (Opera still permits cross-domain inheritance. Although it does not support UTF-7, other problematic encodings, such as Shift JIS, are fair game.)<a class="indexterm" id="IDX-CHP-13-0083"/><a class="indexterm" id="IDX-CHP-13-0084"/></p><p>The other mechanism that deserves mention is the ability to manually override the currently used character set. This feature is available through the <span class="emphasis"><em>View &gt; Encoding</em></span> menu or similar in most browsers. Using this menu to change the character set causes the page and all its subframes (including cross-domain ones!) to be reparsed using the selected encoding, regardless of any <span class="emphasis"><em>charset</em></span> directives encountered earlier for that content.</p><p>Because users may be easily duped into selecting an alternative encoding for an attacker-controlled page (simply in order to view it correctly), this design should make you somewhat uncomfortable. Casual users can’t be expected to realize that their election will also apply to hidden <span class="emphasis"><em>&lt;iframe&gt;</em></span> tags and that such a seemingly innocuous action may enable cross-site scripting attacks against unrelated web properties. In fact, let’s be real: Most of them will not know—and should not have to know—what an <span class="emphasis"><em>&lt;iframe&gt;</em></span> is.</p></div><div class="sect2" title="Markup-Controlled Charset on Subresources"><div class="titlepage"><div><div><h2 class="title"><a id="markup-controlled_charset_on_subresource"/>Markup-Controlled Charset on Subresources</h2></div></div></div><p>We are nearing the end of the epic journey through the web of content-handling quirks, but we are not quite done yet. Astute readers may recall that in <a class="xref" href="ch04s05.html#type-specific_content_inclusion" title="Type-Specific Content Inclusion">Type-Specific Content Inclusion</a> in <a class="xref" href="ch04s05.html#frames" title="Frames">Frames</a>, I mentioned that on certain types of subresources (namely, stylesheets and scripts), the embedding page can specify its own <span class="emphasis"><em>charset</em></span> value in order to apply a specific transformation to the retrieved document, for example,</p><a id="I_programlisting5_d1e16239"/><pre class="programlisting">&lt;script src="http://fuzzybunnies.com/get_js_data.php" charset="EUC-JP"&gt;</pre><p>This parameter is honored by all browsers except for Opera. Where it is supported, it typically does not take precedence over <span class="emphasis"><em>charset</em></span> in <span class="emphasis"><em>Content-Type</em></span>, unless that second parameter is missing or unrecognized. But to every rule, there is an exception, and all too often, the name of this exception is Internet Explorer 6. In that still-popular browser, the encoding specified by the markup overrides HTTP data.</p><p>Does this behavior matter in practice? To fully grasp the consequences, let’s also quickly return to <a class="xref" href="ch06.html" title="Chapter 6. Browser-Side Scripts">Chapter 6</a>, where we debated the topic of securing server-generated, user-specific, JSON-like code against cross-domain inclusion. One example of an application that needs such a defense is a searchable address book in a webmail application: The search term is provided in the URL, and a JavaScript serialization of the matching contacts is returned to the browser but must be shielded from inclusion on unrelated sites.<a class="indexterm" id="IDX-CHP-13-0085"/><a class="indexterm" id="IDX-CHP-13-0086"/><a class="indexterm" id="IDX-CHP-13-0087"/><a class="indexterm" id="IDX-CHP-13-0088"/><a class="indexterm" id="IDX-CHP-13-0089"/></p><p>Now, let’s assume that the developer came up with a simple trick to prevent third-party web pages from loading this data through <span class="emphasis"><em>&lt;script src=...&gt;</em></span>: A single “//” prefix is used to turn the entire response into a comment. Same-origin callers that use the <span class="emphasis"><em>XMLHttpRequest</em></span> API can simply examine the response, strip the prefix, and pass the data to <span class="emphasis"><em>eval(...)</em></span>—but remote callers, trying to abuse the <span class="emphasis"><em>&lt;script src=...&gt;</em></span> syntax, will be out of luck.</p><p>In this design, a request to <span class="emphasis"><em>/contact_search.php?q=smith</em></span> may yield the following response:</p><a id="I_programlisting5_d1e16291"/><pre class="programlisting">// var result  = { "q": "<strong class="userinput"><code>smith</code></strong>", "r": [ "j.smith@example.com" ] };</pre><p>As long as the search term is properly escaped or filtered, this scheme appears safe. But when we realize that the attacker may force the response to be interpreted as UTF-7, the picture changes dramatically. A seemingly benign search term that, as far as the server is concerned, contains no illegal characters could still unexpectedly decode to</p><a id="I_programlisting5_d1e16298"/><pre class="programlisting">// var result = { "q": "<strong class="userinput"><code>smith[CR][LF]</code></strong>
<strong class="userinput"><code>var gotcha</code></strong> <span class="strong"><strong>= { "</strong></span>", "r": [ "j.smith@example.com" ] };</pre><p>This response, when loaded via <span class="emphasis"><em>&lt;script src=... charset=utf-7&gt;</em></span> inside the victim’s browser, gives the attacker access to a portion of the user’s address book.</p><p>This is not just a thought exercise: The “//” approach is fairly common on the Web, and Masato Kinugawa, a noted researcher, found several popular web applications affected by this bug. And a more contrived variant of the same attack is also possible against other execution-preventing prefixes, such as <span class="emphasis"><em>while (1);</em></span>. In the end, the problems with cross-domain <span class="emphasis"><em>charset</em></span> override on <span class="emphasis"><em>&lt;script&gt;</em></span> tags is one of the reasons why in <a class="xref" href="ch06.html" title="Chapter 6. Browser-Side Scripts">Chapter 6</a>, we strongly recommend using a robust parser-stopping prefix to prevent the interpreter from ever looking at any attacker-controlled bits. Oh—and if you factor in the support for E4X, the picture becomes even more interesting,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-13-FT-5">225</a>]</sup> but let’s leave it at that.</p></div><div class="sect2" title="Detection for Non-HTTP Files"><div class="titlepage"><div><div><h2 class="title"><a id="detection_for_non-http_files"/>Detection for Non-HTTP Files</h2></div></div></div><p>To wrap up this chapter, let’s look at the last missing detail: character set encoding detection for documents delivered over non-HTTP protocols. As can be expected, documents saved to disk and subsequently opened over the <span class="emphasis"><em>file:</em></span> protocol, or loaded by other means where the usual <span class="emphasis"><em>Content-Type</em></span> metadata is absent, will usually be subjected to character set detection logic. However, unlike with document determination heuristics, there is no substantial difference among all the possible delivery methods: In all cases, the sniffing behavior is roughly the same.</p><p>There is no clean and portable way to address this problem for all text-based documents, but for HTML specifically, the impact of character set sniffing can be mitigated by embedding a <span class="emphasis"><em>&lt;meta&gt;</em></span> directive inside the document body:</p><a id="I_programlisting5_d1e16346"/><pre class="programlisting">&lt;meta http-equiv="Content-Type" content="text/html;charset=..."&gt;</pre><p>You should not ditch <span class="emphasis"><em>Content-Type</em></span> in favor of this indicator. Unlike <span class="emphasis"><em>&lt;meta&gt;</em></span>, the header works for non-HTML content, and it is easier to enforce and audit on a site-wide level. That said, documents that are likely to be saved to disk and that contain attacker-controlled tidbits will benefit from a redundant <span class="emphasis"><em>&lt;meta&gt;</em></span> tag. (Just make sure that this value actually matches <span class="emphasis"><em>Content-Type</em></span>.)</p><div class="sidebar"><a id="security_engineering_cheat_sheet-id11"/><p class="title">Security Engineering Cheat Sheet</p><p><span class="bolditalic">Good Security Practices for All Websites</span><a class="indexterm" id="IDX-CHP-13-0090"/><a class="indexterm" id="IDX-CHP-13-0091"/><a class="indexterm" id="IDX-CHP-13-0092"/><a class="indexterm" id="IDX-CHP-13-0093"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Instruct the web server to append the <span class="emphasis"><em>X-Content-Options: nosniff</em></span> header to all HTTP responses.</p></li><li class="listitem"><p>Consult the cheat sheet in <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a> to set up an appropriate <span class="emphasis"><em>/crossdomain.xml</em></span> meta-policy.</p></li><li class="listitem"><p>Configure the server to append default <span class="emphasis"><em>charset</em></span> and <span class="emphasis"><em>Content-Type</em></span> values on all responses that would otherwise not have one.</p></li><li class="listitem"><p>If you are not using path-based parameter passing (such as PATH_INFO), consider disabling this feature.</p></li></ul></div><p><span class="bolditalic">When Generating Documents with Partly Attacker-Controlled Contents</span><a class="indexterm" id="IDX-CHP-13-0094"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Always return an explicit, valid, well-known <span class="emphasis"><em>Content-Type</em></span> value. Do not use <span class="emphasis"><em>text/plain</em></span> or <span class="emphasis"><em>application/octet-stream</em></span>.<a class="indexterm" id="IDX-CHP-13-0095"/></p></li><li class="listitem"><p>For any text-based documents, return a explicit, valid, well-known <span class="emphasis"><em>charset</em></span> value in the <span class="emphasis"><em>Content-Type</em></span> header; UTF-8 is preferable to any other variable-width encodings. Do not assume that <span class="emphasis"><em>application/xml+svg</em></span>, <span class="emphasis"><em>text/csv</em></span>, and other non-HTML documents do not need a specified character set. For HTML, consider a redundant <span class="emphasis"><em>&lt;meta&gt;</em></span> directive if it’s conceivable that the file may be downloaded by the user. Beware of typos—UTF8 is not a valid alias for UTF-8.</p></li><li class="listitem"><p>Use <span class="emphasis"><em>Content-Disposition: attachment</em></span> and an appropriate, explicit <span class="emphasis"><em>filename</em></span> value for responses that do not need to be viewed directly—including JSON data.</p></li><li class="listitem"><p>Do not allow the user to control the first few bytes of the file. Constrain the response as much as possible. Do not pass through NULs, control characters, or high-bit values unless absolutely necessary.</p></li><li class="listitem"><p>When performing server-side encoding conversions, be sure that your converters reject all unexpected or invalid inputs (e.g., overlong UTF-8).</p></li></ul></div><p><span class="bolditalic">When Hosting User-Generated Files</span><a class="indexterm" id="IDX-CHP-13-0096"/></p><p>Consider using a sandbox domain if possible. If you intend to host unconstrained or unknown file formats, a sandbox domain is a necessity. Otherwise, at the very minimum, do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Use <span class="emphasis"><em>Content-Disposition: attachment</em></span> and an appropriate, explicit <span class="emphasis"><em>filename</em></span> value that matches the <span class="emphasis"><em>Content-Type</em></span> parameter.</p></li><li class="listitem"><p>Carefully validate the input data and always use the appropriate, commonly recognized MIME type. Serving JPEG as <span class="emphasis"><em>image/gif</em></span> may lead to trouble. Refrain from hosting MIME types that are unlikely to be supported by popular browsers.</p></li><li class="listitem"><p>Refrain from using <span class="emphasis"><em>Content-Type: application/octet-stream</em></span> and use <span class="emphasis"><em>application/binary</em></span> instead, especially for unknown document types. Refrain from returning <span class="emphasis"><em>Content-Type: text/plain</em></span>. Do not permit user-specified <span class="emphasis"><em>Content-Type</em></span> headers.<a class="indexterm" id="IDX-CHP-13-0097"/><a class="indexterm" id="IDX-CHP-13-0098"/></p></li></ul></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-13-FN-4" id="ftn.CHP-13-FN-4">63</a>] </sup>Today, this problem is mitigated by most browsers: Their parsers now have additional checks to reject overlong UTF-8 encodings as a matter of principle. The same cannot be said of all possible server-side UTF-8 libraries, however.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;14.&#xA0;Dealing with Rogue Scripts"><div class="titlepage"><div><div><h1 class="title"><a id="dealing_with_rogue_scripts"/>Chapter 14. Dealing with Rogue Scripts</h1></div></div></div><p>In the previous five chapters, we examined a fairly broad range of browser security mechanisms—and looking back at them, it is fair to say that almost all share a common goal: to stop rogue content from improperly interfering with any other, legitimate web pages displayed in a browser. This is an important pursuit but also a fairly narrow one; subverting the boundaries between unrelated websites is a large part of every attacker’s repertoire but certainly not the only trick in the book.<a class="indexterm" id="IDX-CHP-14-0001"/></p><p>The other significant design-level security challenge that all browsers have to face is that attackers may abuse well-intentioned scripting capabilities in order to disrupt or impersonate third-party sites without actually interacting with the targeted content. For example, if JavaScript code controlled by an attacker is permitted to create arbitrary undecorated windows on a screen, the attacker may find that, rather than look for a way to inject a malicious payload into the content served at <a class="ulink" href="http://fuzzybunnies.com">fuzzybunnies.com</a>, it may be easier to just open a window with a believable replica of the address bar, thus convincing the user that the content displayed is from a trusted site.</p><p>Unfortunately for victims, in the early days of the Web, no real attention was given to the susceptibility of JavaScript APIs to attacks meant to disrupt or confuse users, and, unlike cross-domain content isolation issues, this class of problems is still not taken very seriously. The situation is unlikely to change anytime soon: Vendor resources are stretched thin between addressing comparatively more serious implementation-level flaws in the notoriously buggy browser codebases and rolling out new, shiny security features that appease web application developers, users, and the mainstream press alike.<a class="indexterm" id="IDX-CHP-14-0002"/><a class="indexterm" id="IDX-CHP-14-0003"/></p><div class="sect1" title="Denial-of-Service Attacks"><div class="titlepage"><div><div><h1 class="title"><a id="denial-of-service_attacks"/>Denial-of-Service Attacks</h1></div></div></div><p>The possibility of an attacker crashing a browser or otherwise rendering it inoperable is one of the most common, obvious, and least appreciated issues affecting the modern Web. In the era of gadgets and mashups, it can have unexpectedly unpleasant consequences, too.</p><p>The most prominent reason why most browsers are susceptible to <span class="emphasis"><em>denial-of-service (DoS)</em></span> attacks is due simply to a lack of planning: Neither the underlying document formats nor the capabilities exposed through scripting languages were designed to have a sensible, constrained worst-case CPU or memory footprint. In other words, any sufficiently complex HTML file or an endless JavaScript loop could bring the underlying operating system to its knees. Worse, the attempts to mandate resource limits or to give users a way to resume control of a runaway browser following a visit to a rogue page meet with resistance. For example, the authors of many of the recently proposed HTML5 APIs provide no advice on preventing resource exhaustion attacks, nor do they even acknowledge this need, because they think that any limits imposed today will likely hinder the growth of the Web 5 or 10 years from now. Browser developers, in turn, refuse to take any action absent any standards-level guidance.<a class="indexterm" id="IDX-CHP-14-0004"/></p><p>A common utilitarian argument against any proposed DoS defenses is that they are pointless—that the browser is hopelessly easy to crash in a multitude of ways, so why take special measures to address a specific vector today? It’s hard to argue with this view, but it’s also important to note that it acts as a self-fulfilling prophecy: The steady increase in the number of DoS vectors is making it more and more unlikely that the situation will be comprehensively addressed any time soon.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>To be fair, the computational complexity of certain operations is not the only reason why browsers are easy to crash. Vendors are also constrained by the need to maintain a significant degree of synchronicity during page-rendering and script-execution steps (see <a class="xref" href="ch06.html" title="Chapter 6. Browser-Side Scripts">Chapter 6</a>). This design eliminates the need for website developers to write reentrant and thread-safe code and has substantial code complexity and security benefits. Unfortunately, it also makes it much easier for one document to lock up the entire browser, or at least a good portion thereof.</p></div><p>Regardless of all these considerations, and even if browser vendors refuse to acknowledge DoS risks as a specific flaw, the impact of such attacks is difficult to ignore. For one, whenever a browser is brought down, there is a substantial risk of data loss (in the browser itself or in any applications indirectly affected by the attack). Also, on some social-networking sites, an attacker may be able to lock out the victim from the site simply by sharing a rogue gadget, or perhaps even a well-selected image, with the victim, preventing that person from ever using that service again.<a class="indexterm" id="IDX-CHP-14-0005"/><a class="indexterm" id="IDX-CHP-14-0006"/><a class="indexterm" id="IDX-CHP-14-0007"/><a class="indexterm" id="IDX-CHP-14-0008"/><a class="indexterm" id="IDX-CHP-14-0009"/><a class="indexterm" id="IDX-CHP-14-0010"/><a class="indexterm" id="IDX-CHP-14-0011"/></p><p>Some of the common tricks used to take a browser out of service include loading complex XHTML or SVG documents, opening a very large number of windows, running an endless JavaScript loop that allocates memory, queuing a significant number of <span class="emphasis"><em>postMessage(...)</em></span> calls, and so on. While these examples are implementation-specific, every browser offers a fair number of ways to achieve this goal. Even in Chrome, which uses separate renderer processes to isolate unrelated pages, it’s not difficult to bring down the entire browser: The top-level process mediates a variety of script-accessible and sometimes memory- or CPU-intensive tasks.</p><p>Given the above, it’s no surprise that despite generally dismissive attitudes, the major browsers nevertheless implement several DoS countermeasures. They do not add up to a coherent strategy, and have they have been rolled out only in response to the widespread abuse of specific APIs or to mitigate nonmalicious but common programming errors. Nevertheless, let’s look at them briefly.</p><div class="sect2" title="Execution Time and Memory Use Restrictions"><div class="titlepage"><div><div><h2 class="title"><a id="execution_time_and_memory_use_restrictio"/>Execution Time and Memory Use Restrictions</h2></div></div></div><p>Because of the aforementioned need to enforce a degree of synchronicity for many types of JavaScript operations, most browser vendors err on the side of caution and execute scripts synchronously with most of the remaining browser code. This design has an obvious downside: A good portion of the browser may become completely unresponsive as the JavaScript engine is, say, trying to evaluate a bogus <span class="emphasis"><em>while (1)</em></span> loop. In Opera and Chrome, the top-level user interface will still be largely responsive, if sluggish, but in most other browsers, it won’t even be possible to close the browser window using the normal UI.</p><p>Because endless loops are fairly easy to create by accident, in order to aid developers, Internet Explorer, Firefox, Chrome, and Safari enforce a modest time limit on any continuously or nearly continuously executing scripts. If the script is making the browser unresponsive for longer than a couple of seconds, the user will be shown a dialog and given the option to abort execution. Picking this option will have a result similar to encountering an unhandled exception, that is, of abandoning the current execution flow.<a class="indexterm" id="IDX-CHP-14-0012"/></p><p>Regrettably, such a limit is not a particularly robust defense against malicious scripts. For example, regardless of the user’s choice, it is still possible to resume execution through timers or event handlers, and it’s easy to avoid triggering the prompt in the first place by periodically returning the CPU briefly to an idle state in order to reset the counter. Too, as noted previously, there are ways to hog CPU resources without resorting to busy loops: Rendering complex XHTML, SVG, or XSLT documents can be just as disruptive and is not subject to any checks.</p><p>Execution time aside, there have been attempts to control the memory footprint of executed scripts. The size of the call stack is limited to a browser-specific value between 500 and 65535, and attempting a deeper recursion will result in an unconditional stop. Script heap size, on the other hand, is typically not restricted in a meaningful way; pages can allocate and use up gigabytes of memory. In fact, most of the previously implemented restrictions (such as the 16MB cap in Internet Explorer 6) have been removed in more recent releases.<a class="indexterm" id="IDX-CHP-14-0013"/><a class="indexterm" id="IDX-CHP-14-0014"/><a class="indexterm" id="IDX-CHP-14-0015"/><a class="indexterm" id="IDX-CHP-14-0016"/><a class="indexterm" id="IDX-CHP-14-0017"/></p></div><div class="sect2" title="Connection Limits"><div class="titlepage"><div><div><h2 class="title"><a id="connection_limits"/>Connection Limits</h2></div></div></div><p>In many web applications, each web page consists not only of the proper HTML document retrieved from the URL visible in the address bar but also as many as several dozen other, separately loaded subresources, such as images, stylesheets, and scripts. Because requesting all of these elements through individually established HTTP connections can be slow, the reader may recall from <a class="xref" href="ch03.html" title="Chapter 3. Hypertext Transfer Protocol">Chapter 3</a> that the protocol has been extended to offer keep-alive sessions and request pipelining. But even with these improvements, one stubborn problem remains. The inherent limitation of the protocol is that the server must always send responses in the same order that it received the requests, so if any of the subresources (no matter how inconsequential) takes a bit longer to generate, the loading of all subsequent ones will be delayed.</p><p>To work around this problem, and to optimize performance when keep-alive requests or pipelining can’t be used, all browsers permit the opening of several simultaneous HTTP connections to the destination server. This way, the browser can issue multiple requests in parallel.</p><p>Unfortunately, the parallel connection design can be expensive for the destination website, especially if the server relies on the traditional <span class="emphasis"><em>fork()</em></span>-based connection-handling architecture.<sup>[<a class="footnote" href="#ftn.CHP-14-FN-1" id="CHP-14-FN-1">64</a>]</sup> Therefore, in order to limit the risk of accidentally or intentionally launching a distributed DoS attack, the number of parallel connections needs to be limited to a modest per-host value, typically between 4 and 16. Furthermore, to prevent attackers from overloading the browser itself (or affecting the performance of the nearby networking equipment), the total number of simultaneous connections to all destinations is also constrained to a low multiple of the per-host cap.<a class="indexterm" id="IDX-CHP-14-0018"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>In many implementations, the per-host connection limit is enforced by looking at DNS labels, not at IP addresses. Therefore, an attacker may still be able to point several bogus DNS entries in his own domains to any unrelated target IP and circumvent the first restriction. The global connection limit will be still in effect, though.<a class="indexterm" id="IDX-CHP-14-0019"/></p></div><p>Although the number of concurrent HTTP sessions is limited, there are no practical restrictions on how long an active session may be kept alive (that is, as long as no kernel-level TCP/IP timeouts are encountered). This design may make it possible for attackers to simply exhaust the global connection limit by talking to a couple of intentionally slow destinations, preventing the user from doing anything useful in the meantime.<a class="indexterm" id="IDX-CHP-14-0020"/><a class="indexterm" id="IDX-CHP-14-0021"/><a class="indexterm" id="IDX-CHP-14-0022"/><a class="indexterm" id="IDX-CHP-14-0023"/><a class="indexterm" id="IDX-CHP-14-0024"/><a class="indexterm" id="IDX-CHP-14-0025"/><a class="indexterm" id="IDX-CHP-14-0026"/><a class="indexterm" id="IDX-CHP-14-0027"/><a class="indexterm" id="IDX-CHP-14-0028"/><a class="indexterm" id="IDX-CHP-14-0029"/><a class="indexterm" id="IDX-CHP-14-0030"/></p></div><div class="sect2" title="Pop-Up Filtering"><div class="titlepage"><div><div><h2 class="title"><a id="pop-up_filtering"/>Pop-Up Filtering</h2></div></div></div><p>The <span class="emphasis"><em>window.open(...)</em></span> and <span class="emphasis"><em>window.showModalDialog(...)</em></span><sup>[<a class="footnote" href="#ftn.CHP-14-FN-2" id="CHP-14-FN-2">65</a>]</sup> APIs permit web pages to create new browser windows, pointing them to any otherwise permitted URLs. In both cases, the browser may be instructed not to show certain window decorations for the newly loaded document or to position the window on the screen in a specific way. A simple use of <span class="emphasis"><em>window.open(...)</em></span> might look like this:</p><a id="I_programlisting6_d1e16734"/><pre class="programlisting">window.open("/hello.html", "_blank", "menubar=no,left=50,top=50");</pre><p>In addition to these two JavaScript methods, new windows may also be opened indirectly by programatically interacting with certain HTML elements. For example, it is possible to call the <span class="emphasis"><em>click()</em></span> method on an HTML link or to invoke the <span class="emphasis"><em>submit()</em></span> method on a form. If the relevant markup includes a <span class="emphasis"><em>target</em></span> parameter, the resulting navigation will take place in a new window of a specified name.</p><p>As could be expected, the ability for random web pages to open new browser windows soon proved to be problematic. In the late 1990s, many players in the then-young online advertising industry decided they needed to attract attention to their ads at any cost, even at the expense of profoundly annoying and alienating their audiences. Automatically spawning windows solely to show a flashy advertisement seemed like a great way to do business and make new friends.</p><p>Pop-up and pop-under<sup>[<a class="footnote" href="#ftn.CHP-14-FN-3" id="CHP-14-FN-3">66</a>]</sup> advertisements have quickly emerged as one of the best-known and most reviled aspects of the Web. For good reason, too: Especially with pop-unders, it would not be unusual to amass a dozen of them after two to three hours of casual browsing.<a class="indexterm" id="IDX-CHP-14-0031"/><a class="indexterm" id="IDX-CHP-14-0032"/></p><p>Due to widespread complaints, browser vendors stepped in and implemented a simple restriction: Spurious attempts by non-whitelisted pages to create new windows would be silently ignored.<sup>[<a class="footnote" href="#ftn.CHP-14-FN-4" id="CHP-14-FN-4">67</a>]</sup> Exceptions were made for attempts made immediately after a mouse click or a similar user action. For example, in the case of JavaScript, the ability to call <span class="emphasis"><em>window.open(...)</em></span> would be granted to code executed in response to an <span class="emphasis"><em>onclick</em></span> event and revoked shortly thereafter. (In Internet Explorer and WebKit, this permission expires the moment the event handler is exited. Other browsers may recognize a short grace period of one second or so.)<a class="indexterm" id="IDX-CHP-14-0033"/><a class="indexterm" id="IDX-CHP-14-0034"/><a class="indexterm" id="IDX-CHP-14-0035"/><a class="indexterm" id="IDX-CHP-14-0036"/><a class="indexterm" id="IDX-CHP-14-0037"/><a class="indexterm" id="IDX-CHP-14-0038"/><a class="indexterm" id="IDX-CHP-14-0039"/><a class="indexterm" id="IDX-CHP-14-0040"/><a class="indexterm" id="IDX-CHP-14-0041"/><a class="indexterm" id="IDX-CHP-14-0042"/></p><p>The pop-up blocking feature initially curtailed pop-up advertising but, ultimately, proved to be fairly ineffective: Many websites would simply wait for the user to click anywhere on the page (in order to follow a link or even scroll the document) and spawn new windows in response. Others simply moved on to even more disruptive practices such as interstitials—full-page advertisements you need to click through to get to the content you actually want to read.<a class="indexterm" id="IDX-CHP-14-0043"/></p><p>The advertising arms race aside, the war on <span class="emphasis"><em>window.open(...)</em></span> is also interesting from the DoS perspective. Creating hundreds of thousands of windows, thereby exhausting OS-enforced limits on the number of UI handles, is a sure way to crash the browser and to disrupt other applications as well. Any mechanism that limits this capability would be, at least in theory, a valuable defense. No such luck: Unbelievably, only Internet Explorer and Chrome sensibly limit the actual number of times <span class="emphasis"><em>window.open(...)</em></span> can be called in response to a single click. In other browsers, once the temporary permission to open windows is granted, the attacker can go completely nuts and open as many windows as she desires.</p></div><div class="sect2" title="Dialog Use Restrictions"><div class="titlepage"><div><div><h2 class="title"><a id="dialog_use_restrictions"/>Dialog Use Restrictions</h2></div></div></div><p>Window-related woes aside, all web-originating scripts can open certain browser- or OS-handled dialogs. The usefulness of these dialogs to modern web applications is minimal, but they still constitute another interesting part of the browser security landscape. Dialog-initiating APIs include <span class="emphasis"><em>window.alert(...)</em></span>, used to display simple text messages; <span class="emphasis"><em>window.prompt(...)</em></span> and <span class="emphasis"><em>window.confirm(...)</em></span>, used to request basic user input; and <span class="emphasis"><em>window.print(...)</em></span>, which brings up the OS-level printing dialog. A couple of obscure vendor extensions, such as Mozilla’s <span class="emphasis"><em>window.sidebar.addPanel(...)</em></span> and <span class="emphasis"><em>window.sidebar.addSearchEngine(...)</em></span> (to create bookmarks and register new search providers, respectively), are also on this list.</p><p>The aforementioned JavaScript methods aside, several types of dialogs can be spawned indirectly. For example, it is possible to invoke the <span class="emphasis"><em>click()</em></span> method on a file upload button or to navigate to a downloadable file, which usually brings up the OS-supplied file selection dialog. Navigating to a URL that requires HTTP authentication will also typically bring up a browser-level prompt.</p><p>So, what makes dialogs so interesting? The challenge with these prompts is quite different from that of programmatically created windows. Unlike the largely asynchronous <span class="emphasis"><em>window.open(...)</em></span> API, dialogs pause the execution of JavaScript and defer many other actions (such as navigation or event delivery), effectively preventing dialogs from being created in large numbers to exhaust resources and crash the application. But their modal behavior is also their curse: They prevent any interaction with some portion of the browser until the user dismisses the dialog itself.</p><p>This creates an interesting loophole. If a new dialog is opened immediately after the old one is closed, the victim may be locked out of a vital portion of the browser UI, often even losing the ability to close the window or navigate away from the offending page. Malware authors sometimes abuse that quirk to force casual, panicked users to perform a dangerous action (such as downloading and executing an untrusted executable) just to be permitted to continue their work: Making any other choice in the script-initiated security prompt will only make the same dialog reappear over and over again.<a class="indexterm" id="IDX-CHP-14-0044"/><a class="indexterm" id="IDX-CHP-14-0045"/><a class="indexterm" id="IDX-CHP-14-0046"/><a class="indexterm" id="IDX-CHP-14-0047"/><a class="indexterm" id="IDX-CHP-14-0048"/><a class="indexterm" id="IDX-CHP-14-0049"/><a class="indexterm" id="IDX-CHP-14-0050"/></p><p>Probably because of this malware-related tangent, browser vendors have begun experimenting with less disruptive prompting methods. In Chrome, for example, some of the most common modal dialogs have a checkbox that allows the user to suppress future attempts by the page to use the offending API (until the next reload, that is). In Opera, it is possible to stop the execution of scripts on the page. And in both Opera and recent versions of Firefox, many common dialogs are modal only in relation to the document-controlled area of the window, still allowing the tab to be closed or a different URL to be entered in the address bar. Nevertheless, the coverage of such improvements is limited.</p><div class="figure"><a id="firefox_generated_a_profoundly_confusing"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e16918"/><img alt="Firefox generated a profoundly confusing and vague prompt following the execution of an onbeforeunload handler on a web page. The handler gives page authors a chance to explain the consequences of navigating away from their page (such as losing any unsaved data) and requests a final decision from the user.For usability reasons, random pages on the Internet are no longer permitted to abort pending navigation by means other than this specific onbeforeunload dialog. (Surprisingly, the by-design ability to trap the user on a rogue page forever and cancel any navigation attempts wasn’t received well.) In this screenshot, the first and the last line come from the browser itself; the middle two lines are an “explanation” supplied by an (unnamed!) rogue website instead. The security impact of this particular dialog is minimal, but it is a remarkable example of poor UI design. Sadly, a nearly identical dialog is also used by Internet Explorer, and most other browser dialogs are not much better." src="httpatomoreillycomsourcenostarchimages950035.png.jpg"/></div></div><p class="title">Figure 14-1. Firefox generated a profoundly confusing and vague prompt following the execution of an onbeforeunload handler on a web page. The handler gives page authors a chance to explain the consequences of navigating away from their page (such as losing any unsaved data) and requests a final decision from the user.<sup>[<a class="footnote" href="#ftn.CHP-14-FN-5" id="CHP-14-FN-5">68</a>]</sup> In this screenshot, the first and the last line come from the browser itself; the middle two lines are an “explanation” supplied by an (unnamed!) rogue website instead. The security impact of this particular dialog is minimal, but it is a remarkable example of poor UI design. Sadly, a nearly identical dialog is also used by Internet Explorer, and most other browser dialogs are not much better.</p></div><div class="note" title="Note"><h3 class="title">Note</h3><p>Many browser-level dialogs do a poor job of explaining where the prompt originated and its intended purpose. In some cases, such as the Firefox dialog shown in <a class="xref" href="ch14.html#firefox_generated_a_profoundly_confusing" title="Figure 14-1. Firefox generated a profoundly confusing and vague prompt following the execution of an onbeforeunload handler on a web page. The handler gives page authors a chance to explain the consequences of navigating away from their page (such as losing any unsaved data) and requests a final decision from the user. In this screenshot, the first and the last line come from the browser itself; the middle two lines are an “explanation” supplied by an (unnamed!) rogue website instead. The security impact of this particular dialog is minimal, but it is a remarkable example of poor UI design. Sadly, a nearly identical dialog is also used by Internet Explorer, and most other browser dialogs are not much better.">Figure 14-1</a>, the result can be comical—and there is a more sinister side to such goofiness, too. Spawning authoritative-sounding dialogs that claim to be coming from the operating system itself is a common trick used by malware authors to confuse less experienced users. It’s not hard to imagine why that works.</p></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-14-FN-1" id="ftn.CHP-14-FN-1">64</a>] </sup>The traditional design of most Unix services is to have a master “listener” process, and then create a new process for handling every accepted connection. For the developer, this model is remarkable in its simplicity; but it comes with many significant hidden costs for the operating system, which sometimes finds handling more than several hundred simultaneous connections at once challenging.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-14-FN-2" id="ftn.CHP-14-FN-2">65</a>] </sup>The little-known <span class="emphasis"><em>showModalDialog(...)</em></span> method is a bit of a misnomer. It is essentially equivalent to <span class="emphasis"><em>window.open(...)</em></span>, but it is supposed to vaguely emulate the behavior of a modal dialog by blocking the scripts in the calling context until such a “dialog” window is dismissed. The exact behavior of this API varies randomly from one browser to another. For example, it is sometimes possible for other pages to navigate the underlying window or execute new scripts while the original JS code that called <span class="emphasis"><em>showModalDialog(...)</em></span> is in progress.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-14-FN-3" id="ftn.CHP-14-FN-3">66</a>] </sup>A “pop-under” is a pop-up window that, immediately after its creation, is moved to the back of the window stack with the help of <span class="emphasis"><em>opener.window.focus()</em></span> or <span class="emphasis"><em>window.blur()</em></span>. Pop-unders are arguably slightly less distracting than pop-ups, because the user does not have to take immediate action to go back to the original document. They are no less despised, however.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-14-FN-4" id="ftn.CHP-14-FN-4">67</a>] </sup>For example, a call to <span class="emphasis"><em>window.open(...)</em></span> would not generate an exception. The return value in such a case is not standardized, however, making it difficult to detect a blocked pop-up reliably. In Internet Explorer and Firefox, the function will return <span class="emphasis"><em>null</em></span>; in Safari, it will return another special value, <span class="emphasis"><em>undefined</em></span>; in Opera, a dummy window handle will be supplied; and in Chrome, the returned window handle will even have a quasi-functional DOM.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-14-FN-5" id="ftn.CHP-14-FN-5">68</a>] </sup>For usability reasons, random pages on the Internet are no longer permitted to abort pending navigation by means other than this specific <span class="emphasis"><em>onbeforeunload</em></span> dialog. (Surprisingly, the by-design ability to trap the user on a rogue page forever and cancel any navigation attempts wasn’t received well.)</p></div></div></div>
<div class="sect1" title="Window-Positioning and Appearance Problems"><div class="titlepage"><div><div><h1 class="title"><a id="window-positioning_and_appearance_proble"/>Window-Positioning and Appearance Problems</h1></div></div></div><p>All right, all right—let’s move beyond the arguably uninspiring and unpopular topic of DoS flaws. There is a lot more to the various UI-related APIs—and <span class="emphasis"><em>window.open(...)</em></span> is a particularly curious case. Recall from the discussion earlier in this chapter that this humble function permits web applications not only to create new windows but also to position them in a specific spot on the screen. Several other methods, such as <span class="emphasis"><em>window.moveTo(...)</em></span>, <span class="emphasis"><em>window.resizeTo(...)</em></span>, <span class="emphasis"><em>window.focus()</em></span>, or <span class="emphasis"><em>window.blur()</em></span>, further permit such a window to be moved around the screen, scaled, or stacked in a particular way. Finally, <span class="emphasis"><em>window.close()</em></span> allows it to be discreetly disposed of when the script no longer needs it.<a class="indexterm" id="IDX-CHP-14-0051"/><a class="indexterm" id="IDX-CHP-14-0052"/><a class="indexterm" id="IDX-CHP-14-0053"/><a class="indexterm" id="IDX-CHP-14-0054"/><a class="indexterm" id="IDX-CHP-14-0055"/></p><p>As with most other UI-manipulation features, these APIs soon proved to be a source of pain. Following a series of amusing hacks that involved creating “hidden” windows by placing them partly or completely off-screen or by making them really tiny, these functions now require newly created windows to have certain minimal dimensions and to stay entirely within the visible desktop area. (It is still possible to create a window that constantly hops around the screen and evades all mouse-driven attempts to close it, but given what you’ve read so far, this deserves nothing but a heavy sigh.)</p><p>The restrictions on window size do not mean that the entire contents of the address bar have to be visible to the user, however. An undersized window could be leveraged to mislead the user as to the origin of a document simply by carefully truncating the hostname, as shown in <a class="xref" href="ch14s02.html#a_window_carefully_sized_by_a_script_so" title="Figure 14-2. A window carefully sized by a script so that the real origin of the displayed content is elided in a confusing way. The actual URL of this cat-themed page is , not .">Figure 14-2</a>. Browser vendors have been aware of this problem since at least my report in 2010,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-14-FT-1">226</a>]</sup> but as of this writing, only Internet Explorer uses a somewhat convincing if subtle mitigation: It appends “...” at the end of any elided hostnames in the address bar.</p><p>Another interesting issue with script-controlled window positioning is the prospect of creating several cleverly aligned, overlapping windows to form what appears to be a single document window with an address bar that doesn’t correspond to portions of the document displayed. This attack, which I like to call <span class="emphasis"><em>window splicing</em></span>, is perhaps best illustrated in <a class="xref" href="ch14s02.html#a_window-splicing_attack_in_chrome._what" title="Figure 14-3. A window-splicing attack in Chrome. What may appear as a single document is actually a composite of two overlapping, aligned windows. The user is led to believe that the file upload button comes from the domain shown in the address bar of the top window, but it does not. Certain visual cues indicate foul play (for example, part of the window border has a slightly different hue), but they are too subtle to be easily noticed by the user.">Figure 14-3</a>.<a class="indexterm" id="IDX-CHP-14-0056"/></p><div class="figure"><a id="a_window_carefully_sized_by_a_script_so"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e16992"/><img alt="A window carefully sized by a script so that the real origin of the displayed content is elided in a confusing way. The actual URL of this cat-themed page is , not ." src="httpatomoreillycomsourcenostarchimages950037.png.jpg"/></div></div><p class="title">Figure 14-2. A window carefully sized by a script so that the real origin of the displayed content is elided in a confusing way. The actual URL of this cat-themed page is <a class="ulink" href="http://www.example.com.coredump.cx/">http://www.example.com.coredump.cx/</a>, not <a class="ulink" href="http://www.example.com/">http://www.example.com/</a>.</p></div><p>Window positioning offers some interesting if far-fetched attack scenarios, but manipulating the contents of a programmatically created window is also of some relevance to browser security. We have already mentioned that one of the features of the <span class="emphasis"><em>window.open(...)</em></span> API is its ability to hide certain elements of the browser chrome (scrollbars, menus, and so on) in the newly opened window. An example of such a UI-restricting call is</p><a id="I_programlisting6_d1e17002"/><pre class="programlisting">window.open("http://example.com/", "_blank", "location=no,menubar=no");</pre><div class="figure"><a id="a_window-splicing_attack_in_chrome._what"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e17007"/><img alt="A window-splicing attack in Chrome. What may appear as a single document is actually a composite of two overlapping, aligned windows. The user is led to believe that the file upload button comes from the domain shown in the address bar of the top window, but it does not. Certain visual cues indicate foul play (for example, part of the window border has a slightly different hue), but they are too subtle to be easily noticed by the user." src="httpatomoreillycomsourcenostarchimages950039.png.jpg"/></div></div><p class="title">Figure 14-3. A window-splicing attack in Chrome. What may appear as a single document is actually a composite of two overlapping, aligned windows. The user is led to believe that the file upload button comes from the domain shown in the address bar of the top window, but it does not. Certain visual cues indicate foul play (for example, part of the window border has a slightly different hue), but they are too subtle to be easily noticed by the user.</p></div><p>One of these settings, <code class="literal">location=no</code>, was meant to hide the address bar. This is, of course, a horrible idea: It enables the attacker not only to hide the actual address bar but also to load a page that simply provides a pixel-perfect image of the address bar showing a completely unrelated URL. Heck, with some minimal effort, that fake address bar may even be fully interactive.<a class="indexterm" id="IDX-CHP-14-0057"/><a class="indexterm" id="IDX-CHP-14-0058"/></p><p>Realizing the dangers of this design, most browsers eventually began displaying a minimalistic, read-only address bar in any windows opened with <code class="literal">location=no</code>; Apple, however, sees no harm in allowing this setting to work as originally envisioned in the 1990s. Too bad: <a class="xref" href="ch14s02.html#allowing_websites_to_hide_the_address_ba" title="Figure 14-4. Allowing websites to hide the address bar in Safari is a bad idea. The displayed document is not retrieved from . Instead, the page simply displays a screenshot of a real address bar in a window created by window.open(&quot;...&quot;, &quot;location=no&quot;).">Figure 14-4</a> shows a simple attack on its UI. (I contacted Apple about this attack sometime in 2010 but have yet to hear back.)</p><div class="figure"><a id="allowing_websites_to_hide_the_address_ba"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e17046"/><img alt="Allowing websites to hide the address bar in Safari is a bad idea. The displayed document is not retrieved from . Instead, the page simply displays a screenshot of a real address bar in a window created by window.open(&quot;...&quot;, &quot;location=no&quot;)." src="httpatomoreillycomsourcenostarchimages950041.png.jpg"/></div></div><p class="title">Figure 14-4. Allowing websites to hide the address bar in Safari is a bad idea. The displayed document is not retrieved from <a class="ulink" href="http://www.example.com/">http://www.example.com/</a>. Instead, the page simply displays a screenshot of a real address bar in a window created by <span class="emphasis"><em>window.open("</em></span><a class="ulink" href="http://coredump.cx/">http://coredump.cx/</a><span class="emphasis"><em>...", "location=no")</em></span>.</p></div><p>Microsoft has not fared much better: Although they patched up <span class="emphasis"><em>window.open(...)</em></span>, they forgot about <span class="emphasis"><em>window.createPopup(...)</em></span>, an ancient and obscure API still not subject to the necessary checks.<a class="indexterm" id="IDX-CHP-14-0059"/><a class="indexterm" id="IDX-CHP-14-0060"/><a class="indexterm" id="IDX-CHP-14-0061"/><a class="indexterm" id="IDX-CHP-14-0062"/><a class="indexterm" id="IDX-CHP-14-0063"/><a class="indexterm" id="IDX-CHP-14-0064"/></p></div>
<div class="sect1" title="Timing Attacks on User Interfaces"><div class="titlepage"><div><div><h1 class="title"><a id="timing_attacks_on_user_interfaces"/>Timing Attacks on User Interfaces</h1></div></div></div><p>The problems we’ve discussed so far in this chapter may be hard to fix, but at least in principle, the solutions are not out of reach. Still, here’s a preposterous question: Could the current model of web scripting be fundamentally incompatible with the way human beings work? By that, I do not mean merely the dangers of web-delivered social engineering that targets the inattentive and the easily confused; rather, I’m asking if it’s possible for scripts to consistently outsmart alert and knowledgeable victims simply due to the inherent limitations of human cognition?</p><p>The question is outlandish enough not to be asked often, yet the answer may be yes. Consider that in a typical, attentive human subject, the usual latency between a visual stimulus and a voluntary motor response is between 100 and 300 milliseconds.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-14-FT-2">227</a>]</sup> Humans do not pause for that long to assess the situation after every minute muscle movement; instead, we subconsciously schedule a series of learned motor actions well in advance and process any sensory feedback as it arrives later on. For a split second, we cannot abort a premeditated action, even if something goes horribly wrong.</p><p>Alas, on today’s personal computers, a lot can happen in as little as one-tenth of that interval. In particular, scripts can open new windows, move them around, or close any existing ones; they can also initiate or abort system-level prompts. In such a setting, designing security-sensitive UIs is not nearly as simple as it seems, and some types of attacks may be simply impossible to defend against without a major paradigm shift in how we design software.</p><p>To illustrate the issue, consider a page that attempts to start an unsolicited download of a dangerous file type. The download will typically initiate a browser-level dialog with three options: “open,” “save,” and “cancel.” Sane users will make that last choice—but not if the attacker robs them of a chance to do so.</p><p>Let’s assume that just milliseconds after the dialog is opened, and perhaps before the user even registers its presence, a new window is created on top that hides it from view. In that window, the attacker plants a carefully positioned button or link that the user is likely to click, for example, a button to dismiss an annoying interstitial advertisement. As the user attempts to perform this perfectly reasonable action, the rogue page may use <span class="emphasis"><em>onmousemove</em></span> events to monitor the position and velocity of the mouse pointer and fairly accurately predict the timing of an upcoming click. Closing the overlay window several milliseconds before that click, only to reveal the “open” button in the same position, will lead the user inevitably to make that choice in the security prompt. There is simply nothing the user can do. (I demonstrated a practical attack on Firefox along these lines in 2007.)<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-14-FT-3">228</a>]</sup></p><p>In response to the attacks on security dialogs, a variety of security delays have been implemented in the past few years, requiring anywhere from 500 milliseconds to 5 seconds between the dialog coming into focus and any dangerous buttons being enabled for user input. But such delays do not sit well with browser UI designers: They hate them, feeling that the product should be as responsive as possible and that annoying the user with nonclickable buttons or countdowns is a significant usability issue. Some have even pushed to remove existing timeouts from legacy UIs.<sup>[<a class="footnote" href="#ftn.CHP-14-FN-6" id="CHP-14-FN-6">69</a>]</sup> HTML5 geolocation-sharing prompts are impacted by this view. Many browsers are not protected against the attack on this UI in any significant way.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-14-FT-4">229</a>]</sup><a class="indexterm" id="IDX-CHP-14-0065"/></p><p>To further complicate the picture, browser-level user interfaces are not the only concern for UI-timing attacks. The security- or privacy-sensitive functionality of many trusted websites can also be attacked, and fixing that problem is a lot harder than adding delay timers on a handful of known dangerous system-level UIs.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Millisecond-level click or keypress hijacking aside, it has been repeatedly demonstrated that with minimal and seemingly innocuous conditioning, healthy and focused test subjects can be reliably tricked into ignoring even very prominent and unusual visual stimuli. The infamous Invisible Gorilla experiment,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-14-FT-5">230</a>]</sup> shown in <a class="xref" href="ch14s03.html#a_single_frame_from_the_invisible_gorill" title="Figure 14-5. A single frame from the Invisible Gorilla experiment, courtesy of Daniel Simons (). When asked to view this video and count the number of times the players pass the basketball, most viewers fail to notice a person in a gorilla suit casually strolling across the room halfway through the clip. Really! Go to and try it on a friend.">Figure 14-5</a>, is a particularly well-known example of this. Almost all viewers watching a clip prepared by the researchers fail to notice a plainly visible gorilla in a crowd. The corollary is that even savvy users can be conditioned to ignore cues such as changes to the address bar or to SSL indicators in the browser—a very disconcerting thought. The only reason why we are not trying to solve this problem today is that few exploit writers are behavioral scientists. But if you are a high-profile target, this seems like a risky bet.<a class="indexterm" id="IDX-CHP-14-0066"/></p></div><div class="figure"><a id="a_single_frame_from_the_invisible_gorill"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e17129"/><img alt="A single frame from the Invisible Gorilla experiment, courtesy of Daniel Simons (). When asked to view this video and count the number of times the players pass the basketball, most viewers fail to notice a person in a gorilla suit casually strolling across the room halfway through the clip. Really! Go to and try it on a friend." src="httpatomoreillycomsourcenostarchimages950043.png.jpg"/></div></div><p class="title">Figure 14-5. A single frame from the Invisible Gorilla experiment, courtesy of Daniel Simons<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-14-FT-6">231</a>]</sup> (<a class="ulink" href="http://dansimons.com/">http://dansimons.com/</a>). When asked to view this video and count the number of times the players pass the basketball, most viewers fail to notice a person in a gorilla suit casually strolling across the room halfway through the clip. Really! Go to <a class="ulink" href="http://theinvisiblegorilla.com/videos.html">http://theinvisiblegorilla.com/videos.html</a> and try it on a friend.</p></div><div class="sidebar"><a id="security_engineering_cheat_sheet-id12"/><p class="title">Security Engineering Cheat Sheet</p><p><span class="bolditalic">When Permitting User-Created &lt;iframe&gt; Gadgets on Your Site</span><a class="indexterm" id="IDX-CHP-14-0067"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Don’t do so unless you are prepared to live with the consequences. You can’t reliably prevent a malicious gadget from launching DoS attacks on your users. Any such gadget will also be able to bring up various obscure dialogs that, as a rule, will not distinguish between your top-level page and the domain the gadget is hosted in.</p></li></ul></div><p><span class="bolditalic">When Building Security-Sensitive UIs</span><a class="indexterm" id="IDX-CHP-14-0068"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Because of the risk of UI race conditions, avoid situations where a vital setting can be changed with a single keypress or a single click. Require at least two operations (such as selecting a checkbox and then clicking Save). If single-click actions are unavoidable, consider examining other signals. For example, was the mouse pointer in the current window 500 milliseconds ago?</p></li></ul></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-14-FN-6" id="ftn.CHP-14-FN-6">69</a>] </sup>See, for example, Mozilla bug 561177, where one of the Firefox UI engineers proposed the removal of a security delay from the plug-in installation prompt.</p></div></div></div>
<div class="chapter" title="Chapter&#xA0;15.&#xA0;Extrinsic Site Privileges"><div class="titlepage"><div><div><h1 class="title"><a id="extrinsic_site_privileges"/>Chapter 15. Extrinsic Site Privileges</h1></div></div></div><p>To wrap up the discussion of all the noteworthy browser security features, we’ll look at a handful of mechanisms that grant special privileges to sites hand-picked by the user or hardcoded by the authors of the browser itself. The approach taken in these cases is in stark contrast to the schemes we have discussed previously, all of which rely on a fairly sensible examination of intrinsic properties of the displayed content. Normally, the implementation would have us look at the source of the document, the context it is displayed in, or the nature of the operation that the document is attempting to perform, but barring the outcome of these checks, the browser would never give preferential treatment to a single otherwise unremarkable origin.<a class="indexterm" id="IDX-CHP-15-0001"/><a class="indexterm" id="IDX-CHP-15-0002"/></p><p>Per-site privileges violate this principle of impartiality in a fairly brutal way, for reasons ranging from questionable to—more commonly—just utilitarian. There are compelling usability reasons to bring certain inherently dangerous features to the browser world, but there is no good way to programmatically decide which web applications are trustworthy enough to be given access to them. Delegating this task to a human being may be the best thing we can do.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-1" id="CHP-15-FN-1">70</a>]</sup><a class="indexterm" id="IDX-CHP-15-0003"/><a class="indexterm" id="IDX-CHP-15-0004"/><a class="indexterm" id="IDX-CHP-15-0005"/><a class="indexterm" id="IDX-CHP-15-0006"/><a class="indexterm" id="IDX-CHP-15-0007"/></p><p>Naturally, the creation of a caste of privileged applications can be very problematic because the boundaries between any two web applications are not particularly well defined to begin with, making it difficult to contain the permissions precisely. And because the already imperfect boundaries apply only to certain cross-site interactions, vulnerabilities such as XSS or XSRF may further contribute to the misery. In the end, a significant disconnect may develop between the intent of a per-site permission and the actual consequences of such a grant.</p><div class="sect1" title="Browser- and Plug-in-Managed Site Permissions"><div class="titlepage"><div><div><h1 class="title"><a id="browser-_and_plug-in-managed_site_permis"/>Browser- and Plug-in-Managed Site Permissions</h1></div></div></div><p>When balancing security, privacy, and usability, browser vendors sometimes find themselves between a rock and a hard place. Some proposed features seem essential to the continued growth of the Web but are simply too dangerous to be made available to every website on the Internet. Examples of such problematic mechanisms include giving access to video camera or microphone feeds,<sup>[<a class="footnote" href="#ftn.CHP-15-FN-2" id="CHP-15-FN-2">71</a>]</sup> allowing websites to query for user geolocation data,<sup>[<a class="footnote" href="#ftn.CHP-15-FN-3" id="CHP-15-FN-3">72</a>]</sup> installing browser extensions or themes, or opening desktop notifications.<a class="indexterm" id="IDX-CHP-15-0008"/><a class="indexterm" id="IDX-CHP-15-0009"/></p><p>As a work-around for this problem, vendors require the user to approve the application’s request in order for it to be allowed to access a privileged API. On the first attempt to use restricted functionality, the user is typically provided with a visual cue (ranging from an icon to a modal prompt) and given three choices: ignore the request, permit it once, or permanently authorize the requesting site to access the API. Of these choices, the last one is the most interesting: If selected, all future access from a matching host will be automatically approved, sometimes without any further visual indication.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Most whitelists look only at the hostname, and not at the protocol or port. Any entry on these lists will therefore match more than one SOP origin. In particular, authorizing <a class="ulink" href="https://fuzzybunnies.com/">https://fuzzybunnies.com/</a> to access your camera may also authorize the nonencrypted site at <a class="ulink" href="http://fuzzybunnies.com/">http://fuzzybunnies.com/</a> to do the same.<a class="indexterm" id="IDX-CHP-15-0010"/></p></div><p>Granting websites access to privacy- or security-sensitive features should be done with care, because, as noted earlier, the implications of doing so extend beyond merely trusting the authors of the whitelisted application. Permission is granted to any content executed in the matching origin, regardless of how the payload got there, greatly amplifying the impact of simple (and, in the long run, inevitable) implementation bugs. A script injection vulnerability in a privileged origin no longer merely exposes the data stored within the application but may also leak client-originating sensitive data feeds.<a class="indexterm" id="IDX-CHP-15-0011"/><a class="indexterm" id="IDX-CHP-15-0012"/><a class="indexterm" id="IDX-CHP-15-0013"/><a class="indexterm" id="IDX-CHP-15-0014"/></p><div class="sect2" title="Hardcoded Domains"><div class="titlepage"><div><div><h2 class="title"><a id="hardcoded_domains"/>Hardcoded Domains</h2></div></div></div><p>In addition to the list of user-authorized privileged domains, some browsers or browser plug-ins come with a list of vendor-selected sites or SOP origins that are given substantial privileges to reconfigure or update portions of the browser or the operating system. Some of the most prominent examples of this trend include <a class="ulink" href="http://update.microsoft.com">update.microsoft.com</a>, which is recognized by ActiveX controls that ship with Microsoft Windows and is allowed to install software updates; <a class="ulink" href="http://addons.mozilla.org">addons.mozilla.org</a> and <a class="ulink" href="http://chrome.google.com">chrome.google.com</a>, recognized by their corresponding browsers and given special privileges to install extensions or themes; or <a class="ulink" href="http://www.macromedia.com">www.macromedia.com</a>, which is allowed to reconfigure Adobe Flash.<a class="indexterm" id="IDX-CHP-15-0015"/></p><p>The designs of these mechanisms vary and, as a rule, are not documented in a satisfactory way. Some features require second-level verification, such as a cryptographic signature or user consent, but others do not. Broadly speaking, the proliferation of such privileged domains is troubling, because it is clear that they will not be immune to the usual security problems that plague the rest of the modern Web. Case in point: <a class="ulink" href="http://xssed.com/">http://xssed.com/</a> lists six publicly reported XSS vulnerabilities in <a class="ulink" href="http://addons.mozilla.org">addons.mozilla.org</a>.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-15-FT-1">232</a>]</sup></p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-1" id="ftn.CHP-15-FN-1">70</a>] </sup>It is fair to complain that browsers do not do much to equip users with affirmative signals about the trustworthiness of a visited site, even though many robust indicators may plausibly be arrived at in an automated way. Blacklist-driven attempts to block known malicious sites exist, but given the negligible cost of registering a new domain (or compromising a random existing one), these approaches are arguably of less value.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-2" id="ftn.CHP-15-FN-2">71</a>] </sup>This functionality is currently supported only by plug-ins, such as Adobe Flash, but on track to become a part of HTML5.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-3" id="ftn.CHP-15-FN-3">72</a>] </sup>This API derives user location from parameters such as the current IP address, the list of nearby wireless networks or cell towers, or the data supplied by a hardware GPS receiver. With the exception of GPS data, it may be necessary to consult an external service provider to map these inputs to physical coordinates.</p></div></div></div>
<div class="sect1" title="Form-Based Password Managers"><div class="titlepage"><div><div><h1 class="title"><a id="form-based_password_managers"/>Form-Based Password Managers</h1></div></div></div><p>Surprised? Don’t be. Mentioning password managers may seem out of place, but it is very useful to consider this technology as an indirect form of a site-bound privilege. Before we explain, let’s briefly review why password management is implemented in modern browsers to begin with and how it actually operates.</p><p>The answer to the first question is fairly simple: Today, almost every major website requires, or at least strongly encourages, all visitors to open an account. Logging in is typically necessary in order to customize the appearance of the site and is a prerequisite for interacting with other registered users. Unfortunately, these site-specific authentication systems are not synchronized (save for several limited-scale “federated login” experiments, such as OpenID),<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-15-FT-2">233</a>]</sup> and they effectively force the general population to create and memorize several dozen robust passwords, one for every destination frequented. This approach is difficult to sustain and leads to rampant and dangerous password reuse; that’s where browser vendors decided to step in.</p><p>Form-based password managers are an inelegant but pragmatic solution to the problem of coping with the proliferation of per-site credentials. They apply simple heuristics to detect the submission of normal-looking login forms (the browser looks for an <span class="emphasis"><em>&lt;input type=password&gt;</em></span> field and then perhaps examines the names of form fields for strings such as <span class="emphasis"><em>user</em></span> and <span class="emphasis"><em>pass</em></span>). When a suitable form is detected, the browser will offer to save the associated login information in a persistent store on the hard drive,<sup>[<a class="footnote" href="#ftn.CHP-15-FN-4" id="CHP-15-FN-4">73</a>]</sup> and if the user consents, it will then automatically retrieve and paste this data into matching forms encountered later on. In Firefox, Chrome, and Safari, the process of retrieving a stored password is automatic; in Internet Explorer and Opera, an additional user gesture may be required to confirm the intent.<a class="indexterm" id="IDX-CHP-15-0016"/><a class="indexterm" id="IDX-CHP-15-0017"/><a class="indexterm" id="IDX-CHP-15-0018"/><a class="indexterm" id="IDX-CHP-15-0019"/><a class="indexterm" id="IDX-CHP-15-0020"/><a class="indexterm" id="IDX-CHP-15-0021"/><a class="indexterm" id="IDX-CHP-15-0022"/><a class="indexterm" id="IDX-CHP-15-0023"/></p><p>The design of password managers is fragile but has one clear benefit: It works right away even without official support (or, for that matter, informed consent) from any websites. Web applications that are unhappy about this feature may opt out by appending a poorly named <span class="emphasis"><em>autocomplete=off</em></span> parameter to the offending password field,<sup>[<a class="footnote" href="#ftn.CHP-15-FN-5" id="CHP-15-FN-5">74</a>]</sup> but beyond that, the process is almost completely seamless.</p><p>The primary way that every in-browser password manager protects stored data is by tying the credentials to the SOP origin where they were originally entered—paying close attention to the hostname, protocol, and port. Some browsers also consider secondary indicators, such as the ordering or naming of form fields, the URL path to the form, or the address to which the credentials are sent. (As we know from <a class="xref" href="ch09.html" title="Chapter 9. Content Isolation Logic">Chapter 9</a>, such scoping measures are not particularly useful from the security standpoint due to the operation of the same-origin policy.)</p><p>In browsers that autocomplete login forms without the need for human interaction, it is sensible to look at the mechanism as a form of a privileged API: Any content executing in the appropriate origin will be able to request browser-stored credentials by constructing a believable-looking form and then waiting for it to be automatically populated with login data. In order to read back this information, the script merely needs to examine the <span class="emphasis"><em>value</em></span> property of the DOM element associated with the password field.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Removing the ability to inspect values of password fields may seem like a simple way to improve the scheme, but it is not a very good one. The data could still be stolen by, say, waiting for password autocompletion, changing the data submission method from POST to GET, and then calling <span class="emphasis"><em>submit()</em></span> on the login form. These steps would result in navigation to a page that has the password plainly visible in the <span class="emphasis"><em>location.search</em></span> string. (Plus, many web applications have legitimate uses for reading back these fields on the client side, for example, to advise on password strength.)</p></div><p>As should be clear, the most serious risk associated with password managers is the amplification of XSS bugs. In web applications that use <span class="emphasis"><em>httponly</em></span> cookies, a successful exploitation of an XSS flaw may give the attacker only transient access to a user’s account, but if the same vulnerability can be leveraged to steal a user’s password, the consequences are more dire and longer-lived.<sup>[<a class="footnote" href="#ftn.CHP-15-FN-6" id="CHP-15-FN-6">75</a>]</sup> More obscure side effects are possible, too. For example, any application that allows users to construct custom form-based surveys must carefully restrict the layout of the generated forms or risk doubling as a password-harvesting tool.<a class="indexterm" id="IDX-CHP-15-0024"/><a class="indexterm" id="IDX-CHP-15-0025"/><a class="indexterm" id="IDX-CHP-15-0026"/><a class="indexterm" id="IDX-CHP-15-0027"/><a class="indexterm" id="IDX-CHP-15-0028"/><a class="indexterm" id="IDX-CHP-15-0029"/><a class="indexterm" id="IDX-CHP-15-0030"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-4" id="ftn.CHP-15-FN-4">73</a>] </sup>This data may be stored on disk as a plaintext representation, a naïvely obfuscated string, or a properly encrypted value protected with a “master” password that needs to be entered beforehand. All three methods are comparably vulnerable to determined attackers with access to the local system, but the plaintext approach is sometimes frowned upon, as it is more exposed to nosy but nontechnical users.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-5" id="ftn.CHP-15-FN-5">74</a>] </sup>Despite the name, this stops the browser from recording the password and not just from autocompleting it.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-6" id="ftn.CHP-15-FN-6">75</a>] </sup>Such consequences may extend beyond the affected application: Even with password managers in place, password reuse is a common, unfortunate trend.</p></div></div></div>
<div class="sect1" title="Internet Explorer&#x2019;s Zone Model"><div class="titlepage"><div><div><h1 class="title"><a id="internet_exploreras_zone_model"/>Internet Explorer’s Zone Model</h1></div></div></div><p>Internet Explorer’s zone model<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-15-FT-3">234</a>]</sup> is a proprietary attempt to reconcile the different security requirements that users (or system administrators) may have for different types of web applications, for example, a banking page and an online game. Microsoft’s approach is to establish several predefined classes of websites—known as <span class="emphasis"><em>zones</em></span>—each with its own set of configurable security permissions. The five supported zones are these:<a class="indexterm" id="IDX-CHP-15-0031"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>My computer (aka local machine)</strong></span> This hidden zone is used for all local <span class="emphasis"><em>file:</em></span> resources (with one exception—more about it soon). The user cannot add or remove any elements from this set and cannot change its security settings through the normal user interface. Administrators and developers can modify the registry or use <span class="emphasis"><em>urlmon.dll</em></span> hooks to override settings, however.</p></li><li class="listitem"><p><span class="strong"><strong>Local intranet</strong></span> This zone is meant to include trusted applications on a user’s local network. By default, <span class="emphasis"><em>local intranet</em></span> enjoys many problematic privileges, such as unrestricted access to the system clipboard, the ability to open windows without an address bar, or the ability to bypass the usual frame navigation security checks (the descendant policy, outlined in <a class="xref" href="ch11.html" title="Chapter 11. Life Outside Same-Origin Rules">Chapter 11</a>). Members of this set are detected automatically using several configurable heuristics, and they may include destinations with non-fully qualified hostnames, addresses on the HTTP proxy exemption list,<sup>[<a class="footnote" href="#ftn.CHP-15-FN-7" id="CHP-15-FN-7">76</a>]</sup> or remote <span class="emphasis"><em>file:</em></span> URLs accessed over SMB. Manual inclusion of sites in this zone is also possible (in addition to or instead of the built-in heuristics).</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The <span class="emphasis"><em>local intranet</em></span> zone makes an implicit connection between a local network and a trusted environment. This connection is often dubious in the modern-day environment, especially given the prevalence of public Internet access over unencrypted Wi-Fi: Other uses of the network are not any more trustworthy than a random website hosted across the globe.</p></div></li><li class="listitem"><p><span class="strong"><strong>Trusted sites</strong></span> These are nominally empty zones roughly equivalent to <span class="emphasis"><em>local intranet</em></span> in terms of their security settings but managed solely by the user. Autodetection heuristics are unavailable, and all entries have to be created by hand.</p></li><li class="listitem"><p><span class="strong"><strong>Restricted sites</strong></span> In these nominally empty zones, the user may add “untrusted” destinations. The default settings for these zones remove many rudimentary and generally harmless capabilities from the loaded content (for example, <span class="emphasis"><em>Refresh</em></span> headers will not work) while offering limited security benefits.</p><p>The practicality of this zone seems unclear. Because of the need to whitelist every untrusted site, the zone obviously can’t be relied upon as an alternative to browsing the Internet with sensible default settings for previously unseen destinations.<a class="indexterm" id="IDX-CHP-15-0032"/><a class="indexterm" id="IDX-CHP-15-0033"/><a class="indexterm" id="IDX-CHP-15-0034"/></p></li><li class="listitem"><p><span class="strong"><strong>Internet</strong></span> This is a default zone for sites not included in any of the remaining categories. Its default settings match the general browser security model baseline discussed previously in this book.</p></li></ul></div><p>The concept of zones, coupled with some of their security controls, seems to be a step in the right direction. For example, it allows system administrators to fine-tune the permissions for <span class="emphasis"><em>file:</em></span> documents without affecting the security or convenience of normal browsing—or to prohibit Internet sites from navigating to local, corporate systems (using the setting named “Websites in less privileged web content zone can navigate into this zone”). Unfortunately, the actual implementation of the zone model is muddied by a lack of focus, and in practice, it is misused more often than it is genuinely benefited from.</p><p>The first problem evident to anyone trying to master the zone mechanism is its obtuse terminology and the almost-comical complexity of many of the settings. Every zone comes with over 100 checkboxes; some of these will alter the browser security model profoundly, while others have no security consequences whatsoever. (The aforementioned <span class="emphasis"><em>Refresh</em></span> setting is one example of a security no-op; the ability to disable form submission is another.) These two classes of settings are not distinguished in any clear way, and many are nearly impossible to comprehend at a glance. For example, the option “Binary and script behaviors” can be set to “enable” or “disable,” but the help subsystem offers no information about what either setting will actually do. The only explanation is provided in the official developer documentation posted on Microsoft’s site—but even this document can confuse.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-15-FT-4">235</a>]</sup> See for yourself:</p><div class="blockquote"><blockquote class="blockquote"><p>Internet Explorer contains dynamic binary behaviors: components that encapsulate specific functionality for HTML elements to which they were attached. These binary behaviors are not controlled by any Internet Explorer security setting, allowing them to work on Web pages in the Restricted Sites zone. In Windows Server 2003 Service Pack 1, there is a new Internet Explorer security setting for binary behaviors. This new setting disables binary behaviors in the Restricted Sites zone by default. In combination with the Local Machine Lockdown security feature, it also requires administrative approval for binary behaviors to run in the Local Machine zone by default. This new binary behaviors security setting provides a general mitigation to vulnerabilities in Internet Explorer binary behaviors.</p></blockquote></div><p>There are many similar cases of settings that require a substantial effort to understand. For example, it is unlikely that even the most seasoned administrators will understand the implications of tweaking settings named “Access data sources across domains” or “Navigate windows and frames across different domains”. All this confusion has an interesting consequence: Trusted parties unintentionally dispense dubious advice. For example, Charles Schwab, a prominent investment bank, tells customers to disable the frame navigation descendant model,<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-15-FT-5">236</a>]</sup> essentially making HTML frames unsafe to use not only for Charles Schwab but also for any other website. One of the sites maintained by the Internal Revenue Service provides the same, extremely inconsiderate tip.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-15-FT-6">237</a>]</sup><a class="indexterm" id="IDX-CHP-15-0035"/><a class="indexterm" id="IDX-CHP-15-0036"/><a class="indexterm" id="IDX-CHP-15-0037"/><a class="indexterm" id="IDX-CHP-15-0038"/><a class="indexterm" id="IDX-CHP-15-0039"/></p><p>The complexity and poor documentation of Internet Explorer’s zone settings aside, the other problem with the zone model is the clustering of unrelated permissions. The settings for <span class="emphasis"><em>local intranet</em></span> and <span class="emphasis"><em>trusted sites</em></span> containers enable a random collection of features that may be required by some trusted sites—but none of the trusted sites could possibly require <span class="emphasis"><em>all</em></span> of the permissions the zone entails. Because of this design, adding sites to privileged zones can once more have unexpectedly far-ranging consequences in the case of, say, a trivial XSS flaw.</p><div class="sect2" title="Mark of the Web and Zone.Identifier"><div class="titlepage"><div><div><h2 class="title"><a id="mark_of_the_web_and_zone.identifier"/>Mark of the Web and Zone.Identifier</h2></div></div></div><p>To maintain the integrity of the zone model on downloaded files, Internet Explorer further utilizes two overlapping mechanisms to track the original zone information for any externally retrieved document:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="strong"><strong>Mark of the Web (MotW)</strong></span> This simple pseudo-HTML tag is inserted at the beginning of HTML documents downloaded via Internet Explorer to indicate their initial source.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-15-FT-7">238</a>]</sup> One example of a MotW tag may be <span class="emphasis"><em>&lt;!-- saved from url=(0024)</em></span><a class="ulink" href="http://fuzzybunnies.com/">http://fuzzybunnies.com/</a> <span class="emphasis"><em>--&gt;</em></span>. The URL recorded in this tag is mapped to an appropriate zone; the document is then opened in a unique origin in that zone. The most important consesequence is that the downloaded content is isolated from other <span class="emphasis"><em>file:</em></span> URLs.<a class="indexterm" id="IDX-CHP-15-0040"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>The inline nature of MotW is one of its flaws. Faux tags can be pre-inserted by rogue parties into HTML documents downloaded through non-Internet Explorer browsers, saved from email clients, or downloaded by Internet Explorer with a non-HTML extension (and then subjected to content sniffing). Though, to be fair, the privileges of <span class="emphasis"><em>file:</em></span> documents saved without any MotW tags are significant enough to keep attackers relatively uninterested in hopping from the <span class="emphasis"><em>My Computer</em></span> zone to, say, <span class="emphasis"><em>Local Intranet</em></span>.</p></div></li><li class="listitem"><p><span class="strong"><strong>Alternate Data Stream (ADS) Zone Identifier</strong></span> This is a piece of NTFS metadata attached by Internet Explorer (and Chrome) to every downloaded file, indicating the numerical code of the zone the file was retrieved from.<sup>[<a class="footnoteref" href="pr03.html#ftn.CHP-15-FT-8">239</a>]</sup> The <span class="emphasis"><em>Zone.Identifier</em></span> mechanism is less portable than MotW, and the information is lost when files are saved to non-NTFS filesystems. However, it is also more versatile, as it can be applied to non-HTML documents.<a class="indexterm" id="IDX-CHP-15-0041"/></p><p><span class="emphasis"><em>Zone.Identifier</em></span> metadata is recognized by Internet Explorer itself, by the Windows GUI shell, and by some other Microsoft products, but third-party software almost universally ignores it. Where it is supported, it may result in a more restrictive security policy being applied to the document; more commonly, it just pops up a security warning about the unspecified risks of opening Internet-originating data.</p></li></ul></div><div class="sidebar"><a id="security_engineering_cheat_sheet-id13"/><p class="title">Security Engineering Cheat Sheet</p><p><span class="bolditalic">When Requesting Elevated Permissions from Within a Web Application</span><a class="indexterm" id="IDX-CHP-15-0042"/><a class="indexterm" id="IDX-CHP-15-0043"/></p><p>Keep in mind that requesting access to geolocation data, video or microphone feeds, and other privileged APIs comes with responsibility. If your site is prone to XSS vulnerabilities, you are gambling not only with the data stored in the application but with the privacy of your users. Plan accordingly and compartmentalize the privileged functionality well. Never ask your users to lower their Internet Explorer security settings to accommodate your application, and do not blindly follow this advice when given by others—no matter who they are.</p><p><span class="bolditalic">When Writing Plug-ins or Extensions That Recognize Privileged Origins</span></p><p>You are putting your users at elevated risk due to inevitable web application security bugs. Design APIs robustly and try to use secondary security measures, such as cryptography, to further secure communications with your server. Do not whitelist nonencrypted origins, as they are prone to spoofing on open wireless networks.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-15-FN-7" id="ftn.CHP-15-FN-7">76</a>] </sup>In configurations where a proxy is required to access protected internal systems but not required to access the Internet, these may have the unintended and scary effect of classifying the entire Web as a local network.</p></div></div></div></body></html>