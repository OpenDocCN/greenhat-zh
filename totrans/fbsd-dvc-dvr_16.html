<html><head></head><body><div class="chapter" title="Chapter&#xA0;16.&#xA0;Network Drivers, Part 1: Data Structures"><div class="titlepage"><div><div><h1 class="title"><a id="network_drivers_comma_part_1_colon_data"/>Chapter 16. Network Drivers, Part 1: Data Structures</h1></div></div></div><div class="informalfigure"><a id="image_no_caption-id16"/><div class="mediaobject"><a id="I_mediaobject16_d1e29356"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1137497.png.jpg"/></div></div><p><span class="emphasis"><em>Network devices</em></span>, or <span class="emphasis"><em>interfaces</em></span>, transmit and receive data packets that are driven by the network subsystem (Corbet et al., 2005). In this chapter, we’ll examine the data structures used to manage these devices: <code class="literal">ifnet</code>, <code class="literal">ifmedia</code>, and <code class="literal">mbuf</code>. You’ll then learn about Message Signaled Interrupts, which are an alternative to traditional interrupts and are commonly used by network devices.<a class="indexterm" id="IDX-CHP-16-0001"/><a class="indexterm" id="IDX-CHP-16-0002"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>To keep things simple, we’ll examine only Ethernet drivers. Also, I won’t provide a discussion on general networking concepts.</p></div><div class="sect1" title="Network Interface Structures"><div class="titlepage"><div><div><h1 class="title"><a id="network_interface_structures"/>Network Interface Structures</h1></div></div></div><p>An <code class="literal">ifnet</code> structure is the kernel’s representation of an individual network interface. It is defined in the <code class="literal">&lt;net/if_var.h&gt;</code> header as follows:</p><a id="I_programlisting16_d1e29398"/><pre class="programlisting">struct ifnet {
        void    *if_softc;              /* Driver private data.         */
        void    *if_l2com;              /* Protocol bits.               */
        struct  vnet *if_vnet;          /* Network stack instance.      */
        TAILQ_ENTRY(ifnet) if_link;     /* ifnet linkage.               */
        char    if_xname[IFNAMSIZ];     /* External name.               */
        const char *if_dname;           /* Driver name.                 */
        int     if_dunit;       /* Unit number or IF_DUNIT_NONE.        */
        u_int   if_refcount;            /* Reference count.             */

        /*
         * Linked list containing every address associated with
         * this interface.
         */
        struct  ifaddrhead if_addrhead;

        int     if_pcount;      /* Number of promiscuous listeners.     */
        struct  carp_if *if_carp;       /* CARP interface.              */
        struct  bpf_if *if_bpf;         /* Packet filter.               */
        u_short if_index;       /* Numeric abbreviation for interface.  */
        short   if_timer;       /* Time until if_watchdog is called.    */
        struct  ifvlantrunk *if_vlantrunk; /* 802.1Q data.              */
        int     if_flags;       /* Flags (e.g., up, down, broadcast).   */
        int     if_capabilities;/* Interface features and capabilities. */
        int     if_capenable;   /* Enabled features and capabilities.   */
        void    *if_linkmib;            /* Link specific MIB data.      */
        size_t  if_linkmiblen;          /* Length of above.             */
        struct  if_data if_data;        /* Interface information.       */
        struct  ifmultihead if_multiaddrs; /* Multicast addresses.      */
        int     if_amcount;     /* Number of multicast requests.        */

        /* Interface methods.                                           */
        int     (<img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>*if_output)
                (struct ifnet *, struct mbuf *, struct sockaddr *,
                    struct route *);
        void    (<img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>*if_input)
                (struct ifnet *, struct mbuf *);
        void    (<img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>*if_start)
                (struct ifnet *);
        int     (<img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>*if_ioctl)
                (struct ifnet *, u_long, caddr_t);
        void    (*if_watchdog)
                (struct ifnet *);
        void    (<img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>*if_init)
                (void *);
        int     (<img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>*if_resolvemulti)
                (struct ifnet *, struct sockaddr **, struct sockaddr *);
        void    (<img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>*if_qflush)
                (struct ifnet *);
        int     (<img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>*if_transmit)
                (struct ifnet *, struct mbuf *);
        void    (<img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>*if_reassign)
                (struct ifnet *, struct vnet *, char *);

        struct  vnet *if_home_vnet;     /* Where we originate from.     */
        struct  ifaddr *if_addr;        /* Link level address.          */
        void    *if_llsoftc;            /* Link level softc.            */
        int     if_drv_flags;           /* Driver managed status flags. */
        struct  ifaltq <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>if_snd;        /* Output queue, includes altq. */
        const u_int8_t *if_broadcastaddr; /* Link level broadcast addr. */
        void    *if_bridge;             /* Bridge glue.                 */
        struct  label *if_label;        /* Interface MAC label.         */

        /* Only used by IPv6.                                           */
        struct  ifprefixhead if_prefixhead;
        void    *if_afdata[AF_MAX];
        int     if_afdata_initialized;
        struct  rwlock if_afdata_lock;
        struct  task if_linktask;
        struct  mtx if_addr_mtx;

        LIST_ENTRY(ifnet) if_clones;    /* Clone interfaces.            */
        TAILQ_HEAD(, ifg_list) if_groups; /* Linked list of groups.     */
        void    *if_pf_kif;             /* pf(4) glue.                  */
        void    *if_lagg;               /* lagg(4) glue.                */
        u_char  if_alloctype;           /* Type (e.g., Ethernet).       */

        /* Spare fields.                                                */
        char    if_cspare[3];           /* Spare characters.            */
        char    *if_description;        /* Interface description.       */
        void    *if_pspare[7];          /* Spare pointers.              */
        int     if_ispare[4];           /* Spare integers.              */
};</pre><p>I’ll demonstrate how <code class="literal">struct ifnet</code> is used in <a class="xref" href="ch16s05.html" title="Hello, world!">Hello, world!</a> in <a class="xref" href="ch16s05.html" title="Hello, world!">Hello, world!</a>. For now, let’s look at its method fields.<a class="indexterm" id="IDX-CHP-16-0003"/><a class="indexterm" id="IDX-CHP-16-0004"/><a class="indexterm" id="IDX-CHP-16-0005"/><a class="indexterm" id="IDX-CHP-16-0006"/><a class="indexterm" id="IDX-CHP-16-0007"/><a class="indexterm" id="IDX-CHP-16-0008"/><a class="indexterm" id="IDX-CHP-16-0009"/></p><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29494"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">if_init</code> field identifies the interface’s init routine. <span class="emphasis"><em>Init routines</em></span> are called to initialize their interface.<a class="indexterm" id="IDX-CHP-16-0010"/></p><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29511"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">if_ioctl</code> field identifies the interface’s ioctl routine. Characteristically, ioctl routines are used to configure their interface (for example, for setting the maximum transmission unit).</p><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29522"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">if_input</code> field identifies the interface’s input routine. An interface sends an interrupt whenever it receives a packet. Its driver-defined interrupt handler then calls its <span class="emphasis"><em>input routine</em></span> to process the packet. Note that this is a departure from the norm. Input routines are called by a driver, while the other routines are called by the network stack. The <code class="literal">if_input</code> field generally points to a link layer routine (for example, <code class="literal">ether_input</code>) rather than a driver-defined routine.<a class="indexterm" id="IDX-CHP-16-0011"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Obviously, link layer routines are kernel defined. Method fields that expect a link layer routine should be defined by an <code class="literal">*ifattach</code> function (such as <code class="literal">ether_ifattach</code>), not directly by a driver. <code class="literal">*ifattach</code> functions are described in <a class="xref" href="ch16s02.html" title="Network Interface Structure Management Routines">Network Interface Structure Management Routines</a> in <a class="xref" href="ch16s02.html" title="Network Interface Structure Management Routines">Network Interface Structure Management Routines</a>.</p></div><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29562"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">if_output</code> field identifies the interface’s output routine. <span class="emphasis"><em>Output routines</em></span> are called by the network stack to prepare an upper-layer packet for transmission. Every output routine ends by calling its interface’s <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29574"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> transmit routine. If an interface lacks a transmit routine, its <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29580"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> start routine is called instead. Typically, when a network driver defines a transmit routine, its start routine is undefined, and vice versa. The <code class="literal">if_output</code> field generally points to a link layer routine (for example, <code class="literal">ether_output</code>) rather than a driver-defined routine.<a class="indexterm" id="IDX-CHP-16-0012"/><a class="indexterm" id="IDX-CHP-16-0013"/><a class="indexterm" id="IDX-CHP-16-0014"/><a class="indexterm" id="IDX-CHP-16-0015"/><a class="indexterm" id="IDX-CHP-16-0016"/><a class="indexterm" id="IDX-CHP-16-0017"/><a class="indexterm" id="IDX-CHP-16-0018"/><a class="indexterm" id="IDX-CHP-16-0019"/><a class="indexterm" id="IDX-CHP-16-0020"/><a class="indexterm" id="IDX-CHP-16-0021"/><a class="indexterm" id="IDX-CHP-16-0022"/></p><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29637"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">if_start</code> field identifies the interface’s start routine. Before I describe start routines, it’s important to discuss <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29646"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> send queues. Send queues are filled by output routines. <span class="emphasis"><em>Start routines</em></span> remove one packet from their send queue and deposit it in their interface’s transmit ring. They repeat this process until the send queue is empty or the transmit ring is full. Transmit rings are simply ring buffers used for transmission. Network interfaces use ring buffers for transmission and reception.<a class="indexterm" id="IDX-CHP-16-0023"/></p><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29660"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">if_transmit</code> field identifies the interface’s transmit routine. Transmit <span class="emphasis"><em>routines</em></span> are an alternative to start routines. Transmit routines maintain their own send queues. That is, they forego the <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29672"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> predefined send queue, and output routines push packets directly to them. Transmit routines can maintain multiple send queues, which makes them ideal for interfaces with multiple transmit rings.<a class="indexterm" id="IDX-CHP-16-0024"/></p><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29684"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">if_qflush</code> field identifies the interface’s qflush routine. <span class="emphasis"><em>Qflush routines</em></span> are called to flush the send queues of transmit routines. Every transmit routine must have a corresponding qflush routine.<a class="indexterm" id="IDX-CHP-16-0025"/></p><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29701"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">if_resolvemulti</code> field identifies the interface’s resolvemulti routine. <span class="emphasis"><em>Resolvemulti routines</em></span> are called to resolve a network layer address into a link layer address when registering a multicast address with their interface. The <code class="literal">if_resolvemulti</code> field generally points to a link layer routine (for example, <code class="literal">ether_resolvemulti</code>) rather than a driver-defined routine.<a class="indexterm" id="IDX-CHP-16-0026"/></p><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29725"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> <code class="literal">if_reassign</code> field identifies the interface’s reassign routine. Reassign <span class="emphasis"><em>routines</em></span> are called before their interface is moved to another virtual network stack (vnet). They perform any tasks necessary before the move. The <code class="literal">if_reassign</code> field generally points to a link layer routine (for example, <code class="literal">ether_reassign</code>) rather than a driver-defined routine.</p><p>The <code class="literal">if_watchdog</code> field is deprecated and must <span class="emphasis"><em>not</em></span> be defined. In FreeBSD version 9, <code class="literal">if_watchdog</code> will be removed.</p></div></div>
<div class="sect1" title="Network Interface Structure Management Routines"><div class="titlepage"><div><div><h1 class="title"><a id="network_interface_structure_management"/>Network Interface Structure Management Routines</h1></div></div></div><p>The FreeBSD kernel provides the following functions for working with <code class="literal">ifnet</code> structures:</p><a id="I_programlisting16_d1e29762"/><pre class="programlisting">#include &lt;net/if.h&gt;
#include &lt;net/if_types.h&gt;
#include &lt;net/if_var.h&gt;

struct ifnet *
if_alloc(u_char <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>type);

void
if_initname(struct ifnet <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>*ifp, const char <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>*name, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>unit);

void
if_attach(struct ifnet *ifp);

void
if_detach(struct ifnet *ifp);

void
if_free(struct ifnet *ifp);</pre><p>An <code class="literal">ifnet</code> structure is a dynamically allocated structure that’s owned by the kernel. That is, you cannot allocate a <code class="literal">struct ifnet</code> on your own. Instead, you must call <code class="literal">if_alloc</code>. The <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29799"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> type argument is the interface type (for example, Ethernet devices are <code class="literal">IFT_ETHER</code>). Symbolic constants for every interface type can be found in the <code class="literal">&lt;net/if_types.h&gt;</code> header.<a class="indexterm" id="IDX-CHP-16-0027"/><a class="indexterm" id="IDX-CHP-16-0028"/><a class="indexterm" id="IDX-CHP-16-0029"/><a class="indexterm" id="IDX-CHP-16-0030"/><a class="indexterm" id="IDX-CHP-16-0031"/><a class="indexterm" id="IDX-CHP-16-0032"/></p><p>Allocating an <code class="literal">ifnet</code> structure does not make the interface available to the system. To do that, you must initialize the structure (by defining the necessary fields) and then call <code class="literal">if_attach</code>.</p><p>The <code class="literal">if_initname</code> function is a convenient function for setting an <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29851"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> interface’s <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29857"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> name and <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29863"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> unit number. (Needless to say, this function is used before <code class="literal">if_attach</code>.)</p><p>When an <code class="literal">ifnet</code> structure is no longer needed, it should be deactivated with <code class="literal">if_detach</code>, after which it can be freed with <code class="literal">if_free</code>.</p><div class="sect2" title="ether_ifattach Function"><div class="titlepage"><div><div><h2 class="title"><a id="ether_underscore_ifattach_function"/>ether_ifattach Function</h2></div></div></div><p>The <code class="literal">ether_ifattach</code> function is a variant of <code class="literal">if_attach</code> that’s used for Ethernet devices.</p><a id="I_programlisting16_d1e29894"/><pre class="programlisting">#include &lt;net/if.h&gt;
#include &lt;net/if_types.h&gt;
#include &lt;net/if_var.h&gt;
#include &lt;net/ethernet.h&gt;

void
ether_ifattach(struct ifnet *ifp, const u_int8_t *lla);</pre><p>This function is defined in the <span class="emphasis"><em>/sys/net/if_ethersubr.c</em></span> source file as follows:</p><a id="I_programlisting16_d1e29901"/><pre class="programlisting">void
ether_ifattach(struct ifnet <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>*ifp, const u_int8_t <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>*lla)
{
        struct ifaddr *ifa;
        struct sockaddr_dl *sdl;
        int i;

        ifp-&gt;if_addrlen = ETHER_ADDR_LEN;
        ifp-&gt;if_hdrlen = ETHER_HDR_LEN;
        if_attach(ifp);
        ifp-&gt;if_mtu = ETHERMTU;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>ifp-&gt;if_output = ether_output;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>ifp-&gt;if_input = ether_input;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>ifp-&gt;if_resolvemulti = ether_resolvemulti;
#ifdef VIMAGE
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>ifp-&gt;if_reassign = ether_reassign;
#endif
        if (ifp-&gt;if_baudrate == 0)
                ifp-&gt;if_baudrate = IF_Mbps(10);
        ifp-&gt;if_broadcastaddr = etherbroadcastaddr;

        ifa = ifp-&gt;if_addr;
        KASSERT(ifa != NULL, ("%s: no lladdr!\n", __func__));
        sdl = (struct sockaddr_dl *)ifa-&gt;ifa_addr;
        sdl-&gt;sdl_type = IFT_ETHER;
        sdl-&gt;sdl_alen = ifp-&gt;if_addrlen;
        bcopy(lla, LLADDR(sdl), ifp-&gt;if_addrlen);

        bpfattach(ifp, DLT_EN10MB, ETHER_HDR_LEN);
        if (ng_ether_attach_p != NULL)
                (*ng_ether_attach_p)(ifp);

        /* Print Ethernet MAC address (if lla is nonzero). */
        for (i = 0; i &lt; ifp-&gt;if_addrlen; i++)
                if (lla[i] != 0)
                        break;
        if (i != ifp-&gt;if_addrlen)
                if_printf(ifp, "Ethernet address: %6D\n", lla, ":");
}</pre><p>This function takes an ifnet structure, <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29942"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> ifp, and a link layer address, <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29948"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> lla, and sets up <code class="literal">ifp</code> for an Ethernet device.<a class="indexterm" id="IDX-CHP-16-0033"/><a class="indexterm" id="IDX-CHP-16-0034"/><a class="indexterm" id="IDX-CHP-16-0035"/></p><p>As you can see, it assigns certain values to <code class="literal">ifp</code>, including assigning the appropriate link layer routine to <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29977"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">if_output</code>, <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29986"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">if_input</code>, <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e29996"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">if_resolvemulti</code>, and <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30005"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">if_reassign</code>.</p></div><div class="sect2" title="ether_ifdetach Function"><div class="titlepage"><div><div><h2 class="title"><a id="ether_underscore_ifdetach_function"/>ether_ifdetach Function</h2></div></div></div><p>The <code class="literal">ether_ifdetach</code> function is a variant of <code class="literal">if_detach</code> that’s used for Ethernet devices.</p><a id="I_programlisting16_d1e30025"/><pre class="programlisting">#include &lt;net/if.h&gt;
#include &lt;net/if_types.h&gt;
#include &lt;net/if_var.h&gt;
#include &lt;net/ethernet.h&gt;

void
ether_ifdetach(struct ifnet *ifp);</pre><p>This function is used to deactivate an <code class="literal">ifnet</code> structure set up by <code class="literal">ether_ifattach</code>.</p></div></div>
<div class="sect1" title="Network Interface Media Structures"><div class="titlepage"><div><div><h1 class="title"><a id="network_interface_media_structures"/>Network Interface Media Structures</h1></div></div></div><p>An <code class="literal">ifmedia</code> structure catalogs every media type that is supported by a network interface (for example, 100BASE-TX, 1000BASE-SX, and so on). It is defined in the <code class="literal">&lt;net/if_media.h&gt;</code> header as follows:<a class="indexterm" id="IDX-CHP-16-0036"/><a class="indexterm" id="IDX-CHP-16-0037"/><a class="indexterm" id="IDX-CHP-16-0038"/><a class="indexterm" id="IDX-CHP-16-0039"/></p><a id="I_programlisting16_d1e30062"/><pre class="programlisting">struct ifmedia {
        int     ifm_mask;               /* Mask of bits to ignore.      */
        int     ifm_media;              /* User-set media word.         */
        struct ifmedia_entry *ifm_cur;  /* Currently selected media.    */

        /*
         * Linked list containing every media type supported by
         * an interface.
         */
        LIST_HEAD(, ifmedia_entry) ifm_list;

        ifm_change_cb_t ifm_change;     /* Media change callback.       */
        ifm_stat_cb_t   ifm_status;     /* Media status callback.       */
};</pre></div>
<div class="sect1" title="Network Interface Media Structure Management Routines"><div class="titlepage"><div><div><h1 class="title"><a id="network_interface_media_structure_manage"/>Network Interface Media Structure Management Routines</h1></div></div></div><p>The FreeBSD kernel provides the following functions for working with ifmedia structures:<a class="indexterm" id="IDX-CHP-16-0040"/></p><a id="I_programlisting16_d1e30072"/><pre class="programlisting">#include &lt;net/if.h&gt;
#include &lt;net/if_media.h&gt;

void
ifmedia_init(struct ifmedia *ifm, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>dontcare_mask,
    ifm_change_cb_t <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>change_callback, ifm_stat_cb_t <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>status_callback);

void
ifmedia_add(struct ifmedia <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>*ifm, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>mword, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>data, void
 <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>*aux);

void
ifmedia_set(struct ifmedia <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>*ifm, int <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>mword);

void
ifmedia_removeall(struct ifmedia <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>*ifm);</pre><p>An <code class="literal">ifmedia</code> structure is a statically allocated structure that’s owned by a network driver. To initialize an <code class="literal">ifmedia</code> structure, you must call <code class="literal">ifmedia_init</code>.</p><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30148"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">dontcare_mask</code> argument marks the bits in <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30157"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30163"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> <code class="literal">mword</code> that can be ignored. Usually, <code class="literal">dontcare_mask</code> is set to <code class="literal">0</code>.</p><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30181"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> <code class="literal">change_callback</code> argument denotes a callback function. This function is executed to change the media type or media options. Here is its function prototype:<a class="indexterm" id="IDX-CHP-16-0041"/><a class="indexterm" id="IDX-CHP-16-0042"/><a class="indexterm" id="IDX-CHP-16-0043"/><a class="indexterm" id="IDX-CHP-16-0044"/></p><a id="I_programlisting16_d1e30202"/><pre class="programlisting">typedef int (*ifm_change_cb_t)(struct ifnet *ifp);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Users can change an interface’s media type or media options with <code class="literal">ifconfig(8)</code>.</p></div><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30212"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> <code class="literal">status_callback</code> argument denotes a callback function. This function is executed to return the media status. Here is its function prototype:</p><a id="I_programlisting16_d1e30221"/><pre class="programlisting">typedef void (*ifm_stat_cb_t)(struct ifnet *ifp, struct ifmediareq *req);</pre><div class="note" title="Note"><h3 class="title">Note</h3><p>Users can query an interface’s media status with <code class="literal">ifconfig(8)</code>.</p></div><p>The <code class="literal">ifmedia_add</code> function adds a media type to <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30235"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">ifm</code>. The <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30244"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <code class="literal">mword</code> argument is a 32-bit “word” that identifies the media type. Valid values for <code class="literal">mword</code> are defined in <code class="literal">&lt;net/if_media.h&gt;</code>.</p><p>Here are the <code class="literal">mword</code> values for Ethernet devices:</p><a id="I_programlisting16_d1e30265"/><pre class="programlisting">#define IFM_ETHER       0x00000020
#define IFM_10_T        3               /* 10BASE-T, RJ45.              */
#define IFM_10_2        4               /* 10BASE2, thin Ethernet.      */
#define IFM_10_5        5               /* 10BASE5, thick Ethernet.     */
#define IFM_100_TX      6               /* 100BASE-TX, RJ45.            */
#define IFM_100_FX      7               /* 100BASE-FX, fiber.           */
#define IFM_100_T4      8               /* 100BASE-T4.                  */
#define IFM_100_VG      9               /* 100VG-AnyLAN.                */
#define IFM_100_T2      10              /* 100BASE-T2.                  */
#define IFM_1000_SX     11      /* 1000BASE-SX, multimode fiber.        */
#define IFM_10_STP      12      /* 10BASE-T, shielded twisted-pair.     */
#define IFM_10_FL       13              /* 10BASE-FL, fiber.            */
#define IFM_1000_LX     14      /* 1000BASE-LX, single-mode fiber.      */
#define IFM_1000_CX     15      /* 1000BASE-CX, shielded twisted-pair.  */
#define IFM_1000_T      16              /* 1000BASE-T.                  */
#define IFM_HPNA_1      17              /* HomePNA 1.0 (1Mb/s).         */
#define IFM_10G_LR      18      /* 10GBASE-LR, single-mode fiber.       */
#define IFM_10G_SR      19      /* 10GBASE-SR, multimode fiber.         */
#define IFM_10G_CX4     20              /* 10GBASE-CX4.                 */
#define IFM_2500_SX     21      /* 2500BASE-SX, multimode fiber.        */
#define IFM_10G_TWINAX  22              /* 10GBASE, Twinax.             */
#define IFM_10G_TWINAX_LONG     23      /* 10GBASE, Twinax long.        */
#define IFM_10G_LRM     24      /* 10GBASE-LRM, multimode fiber.        */
#define IFM_UNKNOWN     25              /* Undefined.                   */
#define IFM_10G_T       26              /* 10GBASE-T, RJ45.             */

#define IFM_AUTO        0               /* Automatically select media.  */
#define IFM_MANUAL      1               /* Manually select media.       */
#define IFM_NONE        2               /* Unselect all media.          */

/* Shared options.                                                      */
#define IFM_FDX         0x00100000      /* Force full-duplex.           */
#define IFM_HDX         0x00200000      /* Force half-duplex.           */
#define IFM_FLOW        0x00400000      /* Enable hardware flow control.*/
#define IFM_FLAG0       0x01000000      /* Driver-defined flag.         */
#define IFM_FLAG1       0x02000000      /* Driver-defined flag.         */
#define IFM_FLAG2       0x04000000      /* Driver-defined flag.         */
#define IFM_LOOP        0x08000000      /* Put hardware in loopback.    */</pre><p>As an example, the <code class="literal">mword</code> value for 100BASE-TX is the following:<a class="indexterm" id="IDX-CHP-16-0045"/><a class="indexterm" id="IDX-CHP-16-0046"/><a class="indexterm" id="IDX-CHP-16-0047"/><a class="indexterm" id="IDX-CHP-16-0048"/><a class="indexterm" id="IDX-CHP-16-0049"/><a class="indexterm" id="IDX-CHP-16-0050"/><a class="indexterm" id="IDX-CHP-16-0051"/><a class="indexterm" id="IDX-CHP-16-0052"/><a class="indexterm" id="IDX-CHP-16-0053"/><a class="indexterm" id="IDX-CHP-16-0054"/><a class="indexterm" id="IDX-CHP-16-0055"/><a class="indexterm" id="IDX-CHP-16-0056"/><a class="indexterm" id="IDX-CHP-16-0057"/><a class="indexterm" id="IDX-CHP-16-0058"/><a class="indexterm" id="IDX-CHP-16-0059"/><a class="indexterm" id="IDX-CHP-16-0060"/><a class="indexterm" id="IDX-CHP-16-0061"/><a class="indexterm" id="IDX-CHP-16-0062"/><a class="indexterm" id="IDX-CHP-16-0063"/><a class="indexterm" id="IDX-CHP-16-0064"/></p><a id="I_programlisting16_d1e30336"/><pre class="programlisting">IFM_ETHER | IFM_100_TX</pre><p><a class="xref" href="ch16s04.html#bit-by-bit_breakdown_of_mword" title="Table 16-1. Bit-by-Bit Breakdown of mword">Table 16-1</a> describes how each bit in <code class="literal">mword</code> is used. It also displays the bitmasks that can be passed to <code class="literal">dontcare_mask</code> to ignore those bits.</p><div class="table"><a id="bit-by-bit_breakdown_of_mword"/><p class="title">Table 16-1. Bit-by-Bit Breakdown of <code class="literal">mword</code></p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Bit-by-Bit Breakdown of mword"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Bits</p></th><th style="text-align: left" valign="bottom"><p>Purpose of Bits</p></th><th style="text-align: left" valign="bottom"><p>Mask to Ignore Bits</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>00–04</p></td><td style="text-align: left" valign="top"><p>Denotes the media type variant (for example, 100BASE-TX)</p></td><td style="text-align: left" valign="top"><p><code class="literal">IFM_TMASK</code></p></td></tr><tr><td style="text-align: left" valign="top"><p>05–07</p></td><td style="text-align: left" valign="top"><p>Denotes the media type (for example, Ethernet)</p></td><td style="text-align: left" valign="top"><p><code class="literal">IFM_NMASK</code></p></td></tr><tr><td style="text-align: left" valign="top"><p>08–15</p></td><td style="text-align: left" valign="top"><p>Denotes the media type specific options</p></td><td style="text-align: left" valign="top"><p><code class="literal">IFM_OMASK</code></p></td></tr><tr><td style="text-align: left" valign="top"><p>16–18</p></td><td style="text-align: left" valign="top"><p>Denotes the media type mode (for multimode media only)</p></td><td style="text-align: left" valign="top"><p><code class="literal">IFM_MMASK</code></p></td></tr><tr><td style="text-align: left" valign="top"><p>19</p></td><td style="text-align: left" valign="top"><p>Reserved for future use</p></td><td style="text-align: left" valign="top"><p>n/a</p></td></tr><tr><td style="text-align: left" valign="top"><p>20–27</p></td><td style="text-align: left" valign="top"><p>Denotes the shared options (for example, force full-duplex)</p></td><td style="text-align: left" valign="top"><p><code class="literal">IFM_GMASK</code></p></td></tr><tr><td style="text-align: left" valign="top"><p>28–31</p></td><td style="text-align: left" valign="top"><p>Denotes the <code class="literal">mword</code> instance</p></td><td style="text-align: left" valign="top"><p><code class="literal">IFM_IMASK</code></p></td></tr></tbody></table></div></div><p>The <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30449"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> <code class="literal">data</code> and <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30458"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> <code class="literal">aux</code> arguments allow drivers to provide metadata about <code class="literal">mword</code>. Because drivers typically have no metadata to provide, <code class="literal">data</code> and <code class="literal">aux</code> are frequently set to <code class="literal">0</code> and <code class="literal">NULL</code>, respectively.</p><p>The <code class="literal">ifmedia_set</code> function sets the default <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30488"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> media type for <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30494"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> <code class="literal">ifm</code>. This function is used only during device initialization.</p><p>The <code class="literal">ifmedia_removeall</code> function takes an <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30508"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> <code class="literal">ifmedia</code> structure and removes every media type from it.</p></div>
<div class="sect1" title="Hello, world!"><div class="titlepage"><div><div><h1 class="title"><a id="hello_comma_world_exclamation-id1"/>Hello, world!</h1></div></div></div><p>Now that you’re familiar with the if* structures and their management routines, let’s go through an example. The following function, named <code class="literal">em_setup_interface</code> and defined in <span class="emphasis"><em>/sys/dev/e1000/if_em.c</em></span>, sets up <code class="literal">em(4)</code>’s <code class="literal">ifnet</code> and <code class="literal">ifmedia</code> structures. (The <code class="literal">em(4)</code> driver is for Intel’s PCI Gigabit Ethernet adapters.)<a class="indexterm" id="IDX-CHP-16-0065"/></p><a id="I_programlisting16_d1e30544"/><pre class="programlisting">static int
em_setup_interface(device_t dev, struct adapter *adapter)
{
        struct ifnet *ifp;

        ifp = <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>adapter-&gt;ifp = <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>if_alloc(<img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>IFT_ETHER);
        if (ifp == NULL) {
                device_printf(dev, "cannot allocate ifnet structure\n");
                return (-1);
        }

        if_initname(ifp, device_get_name(dev), device_get_unit(dev));
        ifp-&gt;if_mtu = ETHERMTU;
        ifp-&gt;if_init = em_init;
        ifp-&gt;if_softc = adapter;
        ifp-&gt;if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
        ifp-&gt;if_ioctl = em_ioctl;
        ifp-&gt;if_start = em_start;
        IFQ_SET_MAXLEN(&amp;ifp-&gt;if_snd, adapter-&gt;num_tx_desc - 1);
        ifp-&gt;if_snd.ifq_drv_maxlen = adapter-&gt;num_tx_desc - 1;
        IFQ_SET_READY(&amp;ifp-&gt;if_snd);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>ether_ifattach(ifp, adapter-&gt;hw.mac.addr);

        ifp-&gt;if_capabilities = ifp-&gt;if_capenable = 0;

        /* Enable checksum offload. */
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>ifp-&gt;if_capabilities |= IFCAP_HWCSUM | IFCAP_VLAN_HWCSUM;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>ifp-&gt;if_capenable |= IFCAP_HWCSUM | IFCAP_VLAN_HWCSUM;

        /* Enable TCP segmentation offload. */
        ifp-&gt;if_capabilities |= IFCAP_TSO4;
        ifp-&gt;if_capenable |= IFCAP_TSO4;

        /* Enable VLAN support. */
        ifp-&gt;if_data.ifi_hdrlen = sizeof(struct ether_vlan_header);
        ifp-&gt;if_capabilities |= IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU;
        ifp-&gt;if_capenable |= IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU;

        /* Interface can filter VLAN tags. */
        ifp-&gt;if_capabilities |= IFCAP_VLAN_HWFILTER;

#ifdef DEVICE_POLLING
        ifp-&gt;if_capabilities |= IFCAP_POLLING;
#endif

        /* Enable Wake-on-LAN (WOL) via magic packet? */
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/>if (adapter-&gt;wol) {
                ifp-&gt;if_capabilities |= IFCAP_WOL;
                ifp-&gt;if_capenable |= IFCAP_WOL_MAGIC;
        }

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/>ifmedia_init(&amp;adapter-&gt;media, IFM_IMASK, em_media_change,
            em_media_status);

      <img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/>if ((adapter-&gt;hw.phy.media_type == e1000_media_type_fiber) ||
            (adapter-&gt;hw.phy.media_type == e1000_media_type_internal_serdes))
        {
                u_char fiber_type = IFM_1000_SX;

                ifmedia_add(&amp;adapter-&gt;media,
                    IFM_ETHER | fiber_type, 0, NULL);
                ifmedia_add(&amp;adapter-&gt;media,
                    IFM_ETHER | fiber_type | IFM_FDX, 0, NULL);
        } else {
                ifmedia_add(&amp;adapter-&gt;media,
                    IFM_ETHER | IFM_10_T, 0, NULL);
                ifmedia_add(&amp;adapter-&gt;media,
                    IFM_ETHER | IFM_10_T | IFM_FDX, 0, NULL);
                ifmedia_add(&amp;adapter-&gt;media,
                    IFM_ETHER | IFM_100_TX, 0, NULL);
                ifmedia_add(&amp;adapter-&gt;media,
                    IFM_ETHER | IFM_100_TX | IFM_FDX, 0, NULL);

                if (adapter-&gt;hw.phy.type != e1000_phy_ife) {
                        ifmedia_add(&amp;adapter-&gt;media,
                            IFM_ETHER | IFM_1000_T, 0, NULL);
                        ifmedia_add(&amp;adapter-&gt;media,
                            IFM_ETHER | IFM_1000_T | IFM_FDX, 0, NULL);
                }
        }

        ifmedia_add(&amp;adapter-&gt;media, IFM_ETHER | IFM_AUTO, 0, NULL);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/>ifmedia_set(&amp;adapter-&gt;media, IFM_ETHER | IFM_AUTO);

        return (0);
}</pre><p>This function can be split into three parts. The first <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30609"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> allocates an <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30615"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> Ethernet-specific <code class="literal">ifnet</code> structure and stores it in <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30624"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <code class="literal">adapter-&gt;ifp</code>. Then <code class="literal">adapter-&gt;ifp</code> is defined and <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30637"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> activated. (Here, adapter is the name for em(4)’s softc structure.)<a class="indexterm" id="IDX-CHP-16-0066"/><a class="indexterm" id="IDX-CHP-16-0067"/><a class="indexterm" id="IDX-CHP-16-0068"/></p><p>The second part <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30656"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> outlines and <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30662"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> enables the interface’s features, such as <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30668"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137511.png"/></span> Wake-on-LAN (WOL). (<span class="emphasis"><em>WOL</em></span> is an Ethernet standard that allows a computer to be turned on, or woken up, by a network message.)<a class="indexterm" id="IDX-CHP-16-0069"/></p><p>The third part <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30682"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137513.png"/></span> initializes an <code class="literal">ifmedia</code> structure, <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30691"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137515.png"/></span> adds the interface’s supported media to it, and <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30697"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137517.png"/></span> defines the default media type as <span class="emphasis"><em>automatically select the best media</em></span>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Of course, <code class="literal">em_setup_interface</code> is called during <code class="literal">em(4)</code>’s <code class="literal">device_attach</code> routine.</p></div></div>
<div class="sect1" title="mbuf Structures"><div class="titlepage"><div><div><h1 class="title"><a id="mbuf_structures"/>mbuf Structures</h1></div></div></div><p>An <code class="literal">mbuf</code> structure is a memory buffer for network data. Commonly, this data spans multiple <code class="literal">mbuf</code> structures, which are arranged into a linked list known as an <span class="emphasis"><em>mbuf chain</em></span>.<a class="indexterm" id="IDX-CHP-16-0070"/></p><p><code class="literal">struct mbuf</code> is defined in the <code class="literal">&lt;sys/mbuf.h&gt;</code> header as follows:</p><a id="I_programlisting16_d1e30742"/><pre class="programlisting">struct mbuf {
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>struct m_hdr m_hdr;
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>union {
                struct {
                        struct pkthdr MH_pkthdr;
                        union {
                                struct m_ext MH_ext;
                                char MH_databuf[MHLEN];
                        } MH_dat;
                } MH;
                char M_databuf[MLEN];
        } M_dat;
};</pre><p>Every <code class="literal">mbuf</code> structure contains a <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30761"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> buffer for data and a <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30767"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> header, which looks like this:<a class="indexterm" id="IDX-CHP-16-0071"/><a class="indexterm" id="IDX-CHP-16-0072"/><a class="indexterm" id="IDX-CHP-16-0073"/><a class="indexterm" id="IDX-CHP-16-0074"/><a class="indexterm" id="IDX-CHP-16-0075"/><a class="indexterm" id="IDX-CHP-16-0076"/><a class="indexterm" id="IDX-CHP-16-0077"/><a class="indexterm" id="IDX-CHP-16-0078"/><a class="indexterm" id="IDX-CHP-16-0079"/></p><a id="I_programlisting16_d1e30811"/><pre class="programlisting">struct m_hdr {
        struct mbuf     *mh_next;         /* Next mbuf in chain.          */
        struct mbuf     *mh_nextpkt;      /* Next chain in queue/record.  */
        caddr_t          mh_data;         /* Location of data.            */
        int              mh_len;          /* Data length.                 */
        int              mh_flags;        /* Flags.                       */
        short            mh_type;         /* Data type.                   */
        uint8_t          pad[M_HDR_PAD];  /* Padding for word alignment.  */
};</pre><p>We’ll walk through an example that uses mbufs in <a class="xref" href="ch17.html" title="Chapter 17. Network Drivers, Part 2: Packet Reception and Transmission">Chapter 17</a>. For more on mbufs, see the <code class="literal">mbuf(9)</code> manual page.</p></div>
<div class="sect1" title="Message Signaled Interrupts"><div class="titlepage"><div><div><h1 class="title"><a id="message_signaled_interrupts"/>Message Signaled Interrupts</h1></div></div></div><p>Message Signaled Interrupts (MSI) and Extended Message Signaled Interrupts (MSI-X) are alternative ways to send interrupts. Traditionally, devices include an interrupt pin that they assert in order to generate an interrupt, but MSI- and MSI-X-enabled devices send some data, known as an <span class="emphasis"><em>MSI message</em></span> or <span class="emphasis"><em>MSI-X message</em></span>, to a particular memory address in order to generate an interrupt. MSI- and MSI-X-enabled devices can define multiple unique messages. Subsequently, drivers can define multiple unique interrupt handlers. In other words, MSI- and MSI-X-enabled devices can issue different interrupts, with each interrupt specifying a different condition or task. MSI- and MSI-X-enabled devices can define up to 32 and 2,048 unique messages, respectively. (MSI and MSI-X are not exclusive to network devices. They are, however, exclusive to PCI and PCIe devices.)<a class="indexterm" id="IDX-CHP-16-0080"/><a class="indexterm" id="IDX-CHP-16-0081"/><a class="indexterm" id="IDX-CHP-16-0082"/><a class="indexterm" id="IDX-CHP-16-0083"/></p></div>
<div class="sect1" title="Implementing MSI"><div class="titlepage"><div><div><h1 class="title"><a id="implementing_msi"/>Implementing MSI</h1></div></div></div><p>Unlike with previous topics, I’m going to take a holistic approach here. Namely, I’m going to show an example first, and then I’ll describe the MSI family of functions.</p><p>The following function, named <code class="literal">ciss_setup_msix</code> and defined in <span class="emphasis"><em>/sys/dev/ciss/ciss.c</em></span>, sets up MSI for the <code class="literal">ciss(4)</code> driver.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>This function was chosen solely because it’s simple. The fact that it’s from <code class="literal">ciss(4)</code> is irrelevant.</p></div><a id="I_programlisting16_d1e30866"/><pre class="programlisting">static int
ciss_setup_msix(struct ciss_softc *sc)
{
        int i, count, error;

        i = ciss_lookup(sc-&gt;ciss_dev);
      <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>if (ciss_vendor_data[i].flags &amp; CISS_BOARD_NOMSI)
                return (EINVAL);

        count = <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>pci_msix_count(sc-&gt;ciss_dev);
        if (count &lt; CISS_MSI_COUNT) {
                count = <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>pci_msi_count(sc-&gt;ciss_dev);
                if (count &lt; CISS_MSI_COUNT)
                        return (EINVAL);
        }

        count = MIN(count, CISS_MSI_COUNT);
        error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>pci_alloc_msix(sc-&gt;ciss_dev, &amp;count);
        if (error) {
                error = <img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/>pci_alloc_msi(sc-&gt;ciss_dev, &amp;count);
                if (error)
                        return (EINVAL);
        }

        sc-&gt;ciss_msi = count;
        for (i = 0; i &lt; count; i++)
              <img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/>sc-&gt;ciss_irq_rid[i] = i + 1;

        return (0);
}</pre><p>This function is composed of four parts. The first <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30907"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> ensures that the device actually supports MSI.</p><p>The second part determines the number of unique <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30915"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> MSI-X or <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30921"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> MSI messages the device maintains, and stores the answer in <code class="literal">count</code>.</p><p>The third part allocates <code class="literal">count</code> <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30935"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <span class="emphasis"><em>MSI-X</em></span> or <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30944"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137507.png"/></span> <span class="emphasis"><em>MSI vectors</em></span>, which connect each message to a <code class="literal">SYS_RES_IRQ</code> resource with a rid of 1 through count. Thus, in order to assign an interrupt handler to the eighth message, you’d call <code class="literal">bus_alloc_resource_any</code> (to allocate a <code class="literal">SYS_RES_IRQ</code> resource) and pass 8 as the <code class="literal">rid</code> argument. Then you’d call <code class="literal">bus_setup_intr</code> as usual.</p><p>Lastly, the fourth part <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e30971"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137509.png"/></span> saves the <code class="literal">rid</code> of each MSI-X or MSI message in the <code class="literal">ciss_irq_rid</code> array.</p><p>Naturally, this function is called during <code class="literal">ciss(4)</code>’s <code class="literal">device_attach</code> routine, like so:</p><a id="I_programlisting16_d1e30991"/><pre class="programlisting">...
        /*
         * Use MSI/MSI-X?
         */
        sc-&gt;ciss_irq_rid[0] = 0;
        if (method == CISS_TRANSPORT_METHOD_PERF) {
                ciss_printf(sc, "Performant Transport\n");

                if (ciss_force_interrupt != 1 &amp;&amp; <img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/>ciss_setup_msix(sc) == 0)
                        intr = ciss_perf_msi_intr;
                else
                        intr = ciss_perf_intr;

                sc-&gt;ciss_interrupt_mask =
                    CISS_TL_PERF_INTR_OPQ | CISS_TL_PERF_INTR_MSI;
        } else {
                ciss_printf(sc, "Simple Transport\n");

                if (ciss_force_interrupt == 2)
                      <img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/>ciss_setup_msix(sc);

                sc-&gt;ciss_perf = NULL;
                intr = ciss_intr;
                sc-&gt;ciss_interrupt_mask = sqmask;
        }

        /*
         * Disable interrupts.
         */
        CISS_TL_SIMPLE_DISABLE_INTERRUPTS(sc);

        /*
         * Set up the interrupt handler.
         */
        sc-&gt;ciss_irq_resource = <img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/>bus_alloc_resource_any(sc-&gt;ciss_dev,
            SYS_RES_IRQ, <img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/>&amp;sc-&gt;ciss_irq_rid[0], RF_ACTIVE | RF_SHAREABLE);
        if (sc-&gt;ciss_irq_resource == NULL) {
                ciss_printf(sc, "cannot allocate interrupt resource\n");
                return (ENXIO);
        }

        error = bus_setup_intr(sc-&gt;ciss_dev, sc-&gt;ciss_irq_resource,
            INTR_TYPE_CAM | INTR_MPSAFE, NULL, intr, sc, &amp;sc-&gt;ciss_intr);
        if (error) {
                ciss_printf(sc, "cannot set up interrupt\n");
                return (ENXIO);
        }
...</pre><p>Notice how MSI is <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e31020"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137499.png"/></span> <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e31026"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137501.png"/></span> set up before <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e31032"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137503.png"/></span> acquiring an IRQ. Additionally, notice how the <span class="inlinemediaobject"><a id="I_inlinemediaobject16_d1e31038"/><img alt="" src="httpatomoreillycomsourcenostarchimages1137505.png"/></span> <code class="literal">rid</code> argument is <code class="literal">ciss_irq_rid</code>.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>As of this writing, <code class="literal">ciss(4)</code> supports only the first MSI-X or MSI message.</p></div></div>
<div class="sect1" title="MSI Management Routines"><div class="titlepage"><div><div><h1 class="title"><a id="msi_management_routines"/>MSI Management Routines</h1></div></div></div><p>The FreeBSD kernel provides the following functions for working with MSI:<a class="indexterm" id="IDX-CHP-16-0084"/><a class="indexterm" id="IDX-CHP-16-0085"/><a class="indexterm" id="IDX-CHP-16-0086"/><a class="indexterm" id="IDX-CHP-16-0087"/><a class="indexterm" id="IDX-CHP-16-0088"/><a class="indexterm" id="IDX-CHP-16-0089"/><a class="indexterm" id="IDX-CHP-16-0090"/><a class="indexterm" id="IDX-CHP-16-0091"/><a class="indexterm" id="IDX-CHP-16-0092"/></p><a id="I_programlisting16_d1e31099"/><pre class="programlisting">#include &lt;dev/pci/pcivar.h&gt;

int
pci_msix_count(device_t dev);

int
pci_msi_count(device_t dev);

int
pci_alloc_msix(device_t dev, int *count);

int
pci_alloc_msi(device_t dev, int *count);

int
pci_release_msi(device_t dev);</pre><p>The <code class="literal">pci_msix_count</code> and <code class="literal">pci_msi_count</code> functions return the number of unique MSI-X or MSI messages maintained by the device <code class="literal">dev</code>.</p><p>The <code class="literal">pci_alloc_msix</code> and <code class="literal">pci_alloc_msi</code> functions allocate <code class="literal">count</code> MSI-X or MSI vectors based on <code class="literal">dev</code>. If there are not enough free vectors, fewer than <code class="literal">count</code> vectors will be allocated. Upon a successful return, count will contain the number of vectors allocated. (MSI-X and MSI vectors were described in <a class="xref" href="ch16s08.html" title="Implementing MSI">Implementing MSI</a> in <a class="xref" href="ch16s07.html" title="Message Signaled Interrupts">Message Signaled Interrupts</a>.)</p><p>The <code class="literal">pci_release_msi</code> function releases the MSI-X or MSI vectors that were allocated by <code class="literal">pci_alloc_msix</code> or <code class="literal">pci_alloc_msi</code>.</p></div>
<div class="sect1" title="Conclusion"><div class="titlepage"><div><div><h1 class="title"><a id="conclusion-id15"/>Conclusion</h1></div></div></div><p>This chapter examined <code class="literal">ifnet</code>, <code class="literal">ifmedia</code>, and <code class="literal">mbuf</code> structures, as well as MSI and MSI-X. In <a class="xref" href="ch17.html" title="Chapter 17. Network Drivers, Part 2: Packet Reception and Transmission">Chapter 17</a>, you’ll use this information to analyze a network driver.</p></div></body></html>