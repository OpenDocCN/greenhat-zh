- en: Chapter 3. Programmer Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter is primarily geared toward tools that reveal more about Ruby, making
    the programmer’s job both easier and more interesting. We’ll revisit a few topics
    we broached in a cursory fashion earlier in the book, this time giving them more
    attention.
  prefs: []
  type: TYPE_NORMAL
- en: '#5 What Is Truth? (boolean_golf.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [Chapter 1](ch01.html "Chapter 1. Interactive Ruby and the Ruby Environment"),
    we talked about how various languages convert data from one type to another. You’ll
    remember that this process is called *casting*, and Ruby generally requires programmers
    to do this explicitly, while some other languages provide shortcuts that implicitly
    cast data.
  prefs: []
  type: TYPE_NORMAL
- en: The one major exception to this policy in Ruby is the *Boolean* type, which
    is either true or false. However, we noted earlier that you can also use a `to_b`
    method, making data conversion in Ruby completely consistent, in that it is always
    explicit. We’ll be doing a variation on the notion of the `to_b` method in the
    program below, which we call `boolean_golf.rb`. The name is inspired by a practice
    in the Perl community in which programmers try to accomplish a given task with
    as few keystrokes as possible—they score it like golf. This script accomplishes
    its task as succinctly as possible, without being illegibly terse.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This program takes advantage of Ruby’s support for open classes and adds new
    behavior to the Object class. Object is what old hands at Object Orientation call
    a superclass. *Superclasses* are ancestors of other classes. In Ruby, Object happens
    to be the ultimate superclass, because it’s the ancestor of every other class
    in Ruby. This status means that methods you add to Object will be available to
    every single variable of any kind, at any time afterwards. This is extremely powerful,
    as you might expect.
  prefs: []
  type: TYPE_NORMAL
- en: The methods we’re adding are the explicit casting to Boolean methods already
    discussed. When we introduced the concept, we called our hypothetical method `to_b`.
    The program above has that method, but gets to it in a roundabout way. The first
    method defined in the program (at ❶) is `false?`. Remember that a method that
    returns a Boolean is a *predicate*, and Ruby follows the Lisp tradition of naming
    predicates so that they end in question marks. The `false?` method uses Ruby’s
    implicit Boolean casting inside itself—it just forces its calling object into
    an implicit Boolean test with the `not` operator, which also reverses the Boolean
    value. Therefore, `false?` is the opposite of `to_b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s show that in irb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see that `to_b` reports whether its calling object is considered `true`
    by Ruby. The `false?` method does the opposite—it returns `false` when Ruby considers
    the calling object `true`, and `true` when Ruby considers the calling object `false`.
    You can also try calling these methods on other objects, as well as calling the
    `true?` method (❷) on these and any other values. You’ll find that `true?` returns
    the same values as the `to_b` method. This program defines `true?` in a similar
    manner to `false?`, except instead of reversing `self`, it reverses the output
    of `false?`.
  prefs: []
  type: TYPE_NORMAL
- en: The methods `true?` and `false?` look familiar because they’ve been defined
    in the usual way. At ❸, we define `to_b` in a different way. Ruby gives us a the
    option of doing what’s called *metaprogramming*, which allows us to manipulate
    our objects while we’re still in the process of defining them. In this case, we’re
    defining `to_b` as an alias to the method `true?` that we just created. The code
    is quite readable, isn’t it? You might be curious about why we precede the names
    of the methods with a colon. In this use of `alias, :true?` and `:to_b` are instances
    of the Symbol class, which are preceded with a colon. We’ll talk about Symbol
    in later chapters. At the moment, just remember that we define aliases with the
    keyword `alias`, the Symbol version of the new name (with an initial colon), and
    the Symbol version of the old name (with an initial colon), in that order. We’ll
    show that in our existing irb session.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Metaprogramming *is a general term for writing programs that create or manipulate
    other programs. In our case, we write a program that manipulates itself, which
    is perhaps a little conceptually weird. It’s very powerful, however, and is used
    extensively in Rails. Technically, a compiler or interpreter is an example of
    metaprogramming, because it allows you to write a short program in a high-level
    language (like Ruby), which creates a program in a lower-level language (usually
    C) under the hood, which is then executed. Another example of a different sort
    of metaprogramming in this book is a script called* *`methinks_meta.rb`*, *which
    we’ll see in [#35 Mutating Strings into Weasels (methinks.rb)](ch09s02.html "#35
    Mutating Strings into Weasels (methinks.rb)") on page 168*.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this irb session, we just make a not-terribly-useful alias for `to_i` with
    the cumbersome name `make_me_into_an_integer`. However, it does nicely demonstrate
    how to define aliases. We have accomplished several tasks. We added new methods
    to every single object in Ruby. These methods allow us to be completely pedantic
    about Boolean casting—in other words, we now have methods for explicit casting
    into Boolean values. While doing so, we refreshed our knowledge of method naming
    conventions and also learned a bit about both aliases and metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to run this is with irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This library file only returns either `true` or `false`, as demonstrated above.
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Making a List (array_join.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous script, we added new methods to allow explicit Boolean casting
    to every Object in all of Ruby. In this example, we create a new method that is
    a slight variation on a method that already exists. In this case, we’re altering
    the way that Arrays can represent themselves as Strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we talk about lists in natural speaking, we often separate the last item
    from the item before it with the word *and*. This is not how Ruby handles Arrays
    by default. Let’s verify that in irb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We’re creating a variant of the method `join`, which is available to all Arrays
    and whose behavior we see above in the irb session. It takes the items of the
    Array, concatenating them together into a String, with the argument to the `join`
    method between each item, but not before the first item or after the last item.
    That’s the behavior of `join`. How can we make our own `join` that adds the String
    `and` before the last item? Here’s how.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our open class modification of Array, we define a new method at ❶ called
    `my_join` that takes two separator arguments. It calls another method, `modified_join`,
    with whatever our two separator arguments are.
  prefs: []
  type: TYPE_NORMAL
- en: The `modified_join` method hasn’t been defined yet and doesn’t need to be called
    except within the `my_join` method. You might think that it can be a `private`
    method, and so would expect to see the word *private* before the method definition.
    Instead, at ❷ you see the word *protected*. Why couldn’t it just have been *private*?
    We’ll find out very shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `modified_join` method is defined at ❹ simply as calling the new destructive
    method `modified_join!` on a duplicate of the calling object. We get a duplicate
    of the calling object simply by using the `dup` method. We define the destructive
    method `modified_join!` at ❸. It takes two separator arguments, just like all
    of our new methods in this program. It defines a new local variable called `last_one`,
    which is the value of the object calling the method `pop` on itself. Pop is a
    standard term in many languages for the operation of removing the last item from
    an Array. Here’s an example of popping in action, continuing our existing irb
    session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the Array called `a` is modified whenever it calls the method
    `pop` on itself. Why, you might ask, isn’t this method called `pop!`, since it’s
    destructive? That’s a good question. The answer is convention—*pop* is an established
    term for this operation from languages that precede Ruby. If this convention bothers
    you, just remember that Ruby has ancestors, just like a real human spoken language
    does. Think about the spelling rules in English. They make little sense after
    the fact, but make perfect sense when you realize that English is the product
    of Norman soldiers trying to pick up Saxon barmaids a thousand years ago.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby depends on its ancestors similarly to how a spoken language does, and given
    the choice between breaking either the convention of naming destructive methods
    with exclamation marks or of agreeing with precedent from other languages, Matz
    has decided to make Ruby play nicely with others.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have our last item in a separate variable called `last_one`, and since
    `pop` is destructive, that item has been removed from the calling Array after
    `pop` has occurred. We’re satisfied with the way the original version of `join`
    works on all items before the last one, so we can just call the plain old `join`
    on those items. We add our second separator, and then add our last item that we
    popped off, making sure that it is a String (and therefore willing to be concatenated)
    by calling the `to_s` method on it.
  prefs: []
  type: TYPE_NORMAL
- en: So what was all that business about using `protected` instead of `private`?
    The reason we used `protected` is that inside the (non-destructive) `modified_join`
    method, our Array doesn’t call the (destructive) `modified_join!` method on itself.
    Instead, it calls `modified_join!` on a duplicate of itself. It’s no longer the
    same object, and the duplicate won’t allow another instance to call one of its
    `private` methods. So what do we do? Should there be a way for an Array to call
    a method on another Array that isn’t available to an Integer, a String, or a Symbol?
    There is, and that’s exactly what the `protected` access control keyword is for.
    Below is some irb action showing how the program works.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve tried that and are comfortable with it, change `protected` to `private`
    and try to run it again. It should fail on you, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That `private` method error is the reason we want our non-`public` methods
    in this program to be `protected`, rather than `private`. That should give you
    basic understanding of Ruby’s access control: `public, private`, and `protected`.'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Command-Line Interface (uses_cli.rb and simple_cli.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The program `uses_cli.rb` understands command-line options, which are configuration
    options that you can use to make the script behave in different ways, depending
    on the specific values chosen. It uses specific options that have become somewhat
    standard, such as `-h` or `--help`. Options in the form with a single hyphen and
    a single letter are *short options*, while those with a double hyphen and a full
    word are (unsurprisingly) called *long options*. Let’s look at the code for `uses_cli.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*I think there is enough pedagogical value to rolling your own command-line
    parser to make it worthwhile, especially in a book like this. However, I should
    note that there are two fine built-in CLI parsers in Ruby: GetOptLong (Motoyuki
    Kasahara*, [http://www.sra.co.jp/people/m-kasahr/ruby/getoptlong](http://www.sra.co.jp/people/m-kasahr/ruby/getoptlong))
    *and OptionParser (Nobu Nakada*, [http://optionparser.rubyforge.org](http://optionparser.rubyforge.org)).
    *I only include the URLs for information purposes; they are built in to the Ruby
    Standard Library, so you don’t need to download them*.'
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There isn’t a whole lot here, and the script gives us almost no information,
    except at ❷, where it suggests that we need to look inside the `SimpleCLI` class
    for documentation. Why the redirection? For an example this straightforward, it’s
    a fair question. The Holy Grail of computer programming is the notion of reusable
    code. There are many ways to accomplish that end, but one of the most enduringly
    successful ways is to have external libraries of functions that are reasonably
    abstract, which is the role played by the `simple_cli.rb` file in our example.
    Some other specific file can then use that library file, as we do at ❶ in `uses_cli.rb`
    with the *require* keyword, which takes a String argument that is the name of
    an external file without the .rb extension. This makes the code in that external
    file available to the file doing the requiring—it’s analogous to running irb with
    the `-r` flag. Therefore, at ❷ we can easily instantiate an instance of `SimpleCLI`
    that we call `cli`, to which we pass all of the command-line options used by `uses_cli.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to understand how `SimpleCLI` works, we’ll have to look at its code.
    Note that some of the methods in `SimpleCLI` are *stubs*, meaning that they don’t
    do anything worthy of real production code, but they demonstrate that the options
    are being parsed appropriately. If you find this example useful as a scaffold
    or guide for your own code that you want to take command-line options, you simply
    replace both the types of options and their specific implementations as your needs
    dictate. These are only examples. Here, we instantiate `SimpleCLI` and then call
    its `parse_opts` method with every command-line option used in `uses_cli.rb`.
    Let’s see what that method does by looking at `simple_cli.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The *`help`* and *`version`* command-line options have become fairly standardized,
    and their inclusion is generally appreciated*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This file, `simple_cli.rb`, is a basic definition of a class called `SimpleCLI`,
    of course, with RDoc before the class definition and some useful constants right
    away at ❶. We’ve seen constants before, but we declare these constants inside
    of a class definition. This is actually the preferred way to use constants in
    Ruby. You often want to encapsulate methods inside an object, and the same is
    true for constants. Your code for some physics calculation cares about the speed
    of light, whereas your payday notification program cares about the number of days
    in a pay period. In our case, the command-line parser cares about what `OPTIONS`
    it can understand and the `USAGE` message it should report.
  prefs: []
  type: TYPE_NORMAL
- en: The `OPTIONS` constant is a new type of data structure called a Hash. *Hashes*
    are lookup tables, and are very similar to functions, in a way. You pass something
    into a Hash, and you receive one thing from it. That one thing never changes unless
    you either change what you pass into the Hash, or you change the internals of
    the Hash. As you can see, you declare a Hash with braces. The items to the left
    of the `=>` are the *keys* of the Hash, while the items to the right of the `=>`
    are the *values* of the Hash. If you pass in one of the keys, the Hash will return
    the matching value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Note that the one thing you receive could be a composite data type. For example,
    in our *`OPTIONS`* Hash, the values you receive are Arrays. The point is that
    you’ll always receive the same Array for a given input value*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s demonstrate in irb. The way to refer to a constant within a class is
    with the syntax `Class::CONSTANT`, so let’s do that. Keep in mind that the Array
    `[“-v”, “--version”]` is the value of `SimpleCLI:: OPTIONS` class associated with
    the key `:version`. That means that if you pass in the Symbol `:version`, you
    receive the Array `[“-v”, “--version”]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It works. If you compare our results in irb with the declaration of the Hash
    in the code, you shouldn’t be surprised by what we got. Hashes are critically
    important data structures. I am particularly fond of defining them as constants
    within a class, so you’ll see this practice repeated many times in the course
    of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*There are several reasons why I often have Constants within a class that are
    Hashes. They’re within a class because they need to be accessible within that
    class, but not outside it. The reason they’re often Hashes is that I often find
    (for whatever reason) that simple lookup tables are useful data structures to
    have. After you’ve read some of the functional programming information, you may
    find it interesting to define both lambdas and Procs as class constants as well.
    I find myself often doing so*.'
  prefs: []
  type: TYPE_NORMAL
- en: The declaration of the `USAGE` constant at ❷ looks a bit odd, with the equals
    sign followed by two left arrows. However, this is a very useful tool for multi-line
    text called a `here doc`. With a `here doc` declaration, the programmer can say
    that an expression should continue across multiple lines until a specific marker
    is reached—`END_OF_USAGE`, in this case. This is very handy for large amounts
    of verbatim text that you would otherwise have to build using multiple `print`
    or `puts` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Next is a more straightforward constant called `VERSION`, which is a regular
    String. Its definition uses double-quote characters, because we want a newline
    character (notated by `\n`) at the end. The following two statements would print
    the same thing; the `\n` is just the way to include the newline within the String.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have our constants, so let’s move on to our methods. The main one (and in
    fact, the only public one) is `parse_opts`, defined at ❸. It parses options, and
    its implementation should be fairly readable at this point. It returns the result
    of calling the `option_by_args` method if it understands the `args`, and otherwise
    passes its own `USAGE` message into the `display` method. I like method names
    that tell you what they’re supposed to do. If you care about the details, you
    can look inside to learn more, but the name should give you the basic information
    you need up front.
  prefs: []
  type: TYPE_NORMAL
- en: All of our methods, other than `parse_opts`, are `private` (❹), because they
    only need to be called by a `SimpleCLI` instance on itself. The `display, do_default`,
    and `reset` methods starting at ❺ should be pretty straightforward to you. These
    are the methods that you would change to do something more useful in real production
    code. The major logic of the class occurs in the remaining methods `option_by_arg`
    (❻) and `understand_args?` (❼). We know `understand_args?` is a predicate by the
    question mark at the end of its name, so it will be returning either `true` or
    `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The `option_by_args` method checks each key of the `OPTIONS` constant, and if
    it finds a match, returns with the appropriate behavior. This means that it will
    not continue checking keys after it finds a match, so the order of the keys is
    important. It checks for matches using an Array predicate method called `include?`,
    which simply returns `true` if the argument is found in the Array and `false`
    if it is not. This makes it very easy to have command-line aliases like `-v` and
    `--version` which mean the same thing, because either one will cause `include?`
    to return `true`. If `option_by_args` gets no matches, it performs its default
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key to all of this is whether or not the instance of `SimpleCLI` understands
    it arguments. In Ruby1.8, which this book assumes you’re using, it’s easy to determine
    that question using another predicate method called `any?`. It takes a block and
    returns `true` if the contents of that block evaluate to `true` for any of the
    elements of the calling object, which is usually an Array. Let’s demonstrate in
    irb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we’re checking if it’s true that the Array value returned from
    the `OPTIONS` Hash includes the first argument to the `understand_args?` method
    for any of the keys of the `OPTIONS` Hash. As you can see, Hashes have a method
    called `keys` that returns all of their keys as a single Array. If our `any?`
    test returns `true`, that means that `SimpleCLI` knows how to react to the argument
    it received. The nice thing about this setup is that to make `SimpleCLI` understand
    more options, we just add more data to the `OPTIONS` Hash. The `understand_args?`
    method never has to change, only its input does. Programmers call this *data-driven
    programming*, and generally think highly of the practice.
  prefs: []
  type: TYPE_NORMAL
- en: That’s our command-line parsing example. Let’s run this using the options shown.
    Just like in irb, I’ll show the output.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I mentioned Ruby1.8, which provides the `any?` method. One of the machines I
    used while writing this book only has Ruby1.6\. I’ve included some alternative
    code inside a modified RDoc section at ❽ to show just how convenient it is to
    have `any?` available to us. As you can see, RDoc can be useful for things other
    than final comments.
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Palindromes (palindrome.rb and palindrome2.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’m rounding out this chapter with a few shorter examples pertaining to palindromes,
    which are bits of text that are the same when reversed as they are when read normally.
    Usually, we allow cheating to ignore spaces, capitalization differences, and punctuation,
    so *A man, a plan, a canal, Panama* qualifies as a palindrome under those conditions.
    While working on this book, I was reading another programming book that contained
    a discussion about palindromes. “Great!” I thought. “I’ll add a `palindrome?`
    predicate method to all Strings. It’ll be a nice simple bit to have in the chapter
    in which I talk about text.” So I started thinking about breaking Strings into
    individual characters, writing a method that would compare characters an equal
    distance from each end of the String, and all the other things you’d need to do
    in some other languages. Then I realized how easy it is to implement this method
    in Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That’s it. Such an easy solution was staring me in the face the whole time.
    Strings can `reverse` themselves, and the definition of a palindromic String is
    that it is the same as itself reversed. This is when I realized that this example
    belongs in this chapter, because of the incredible relative ease of this task
    and what it implies about programmers being able to roll their own libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Easy as it was to do, this version of a palindrome isn’t entirely satisfactory.
    For one thing, it doesn’t work for our example sentence. We need a version of
    the `palindrome?` predicate that is a bit more complex. Here it is. I’m placing
    the [Hacking the Script](ch03s03.html#hacking_the_script-id004 "Hacking the Script")
    subsection earlier in this section because I use it to demonstrate some ideas
    in the [Running the Script](ch03s04.html#running_the_script-id006 "Running the
    Script") and [The Results](ch03s04.html#the_results-id005 "The Results") subsections,
    as I hope will become clear.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The file `palindrome2.rb` is a bit more complex, as you’ll see. But given what
    it does, it’s still pretty simple in Ruby, compared to some other languages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This file has the shebang telling us that it should be run in Ruby, even though
    it is a library file, rather than a file that will be directly executed. Why is
    that? The main reason is that it would otherwise start with RDoc, which we wouldn’t
    want bash to try to interpret. With the shebang, this will automatically be run
    by Ruby if it is accidentally executed at the command line. If you’re extra paranoid,
    you could add the first line to `palindrome.rb`, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shebang *is the standard Unix geek pronunciation of* *`#!`*, *which one often
    finds at the beginning of scripts*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this program, we want to be able to test palindromes such that we ignore
    all non-letters and also have the ability to ignore case if we choose to. This
    is easy enough to do. Our new String has a private method called `letters_only`
    that does what you expect it to: It compiles a new String consisting only of those
    characters that pass `DUAL_CASE_ALPHABET.include?`, where `DUAL_CASE_ALPHABET`
    (❶) is an Array of all letters, both upper- and lowercase. If it receives a `case_matters`
    argument that is `true`, it returns those letters as they are, otherwise it returns
    an all-lowercase version of those letters, which we accomplish with the `downcase`
    method. The `split` method breaks a String into chunks (each character, in this
    case), and the `join` method sews them back together with a delimiter, which in
    this case is the empty String.'
  prefs: []
  type: TYPE_NORMAL
- en: The `letters_only` method at ❸ is handy enough that in our `palindrome?` predicate
    (❷), all we need to do is compare its output to the reverse of its output, and
    we have our more flexible palindrome detector. Let’s see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have written a test program called `test_palidrome.rb` that I keep in a separate
    directory called `tests/`. Here is the file, followed by a bash session in which
    I run it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I started thinking about musical groups that both start and end with the letter
    *A*. I didn’t get very far—but far enough to demonstrate the program, anyway.
    Note that we `require palindrome2.rb` at the command line, rather than with an
    explicit require keyword inside `test_palindrome.rb`. We can also do testing in
    irb, of course.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We see that Japanese grilled squid (Ika Yaki) is either properly recognized
    as a palindrome or not, depending on the parameters we tell the `palindrome?`
    predicate to use. These String-related operations should get us properly prepped
    for the next chapter, which deals with text manipulation in greater detail. Before,
    that, however, we should review what was new in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*If you try* *`ruby -r palindrome.rb tests/test_palindrome.rb`*, *the test
    script will fail. Can you figure out why? The reason has to do with arguments*.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What was new in this chapter?
  prefs: []
  type: TYPE_NORMAL
- en: Making new predicates for explicit Boolean casting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Superclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Symbol class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays and the `join` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `protected` level of access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dup` and `pop` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making command-line interface flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Library files for reusable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Hash class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash keys and values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `here doc` declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Newline characters within Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Array.include?` to test for membership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `any?` predicate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Hash.keys` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bit on Ruby1.8 vs. Ruby1.6 and the `any?` predicate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Palindromes and reversing Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting the letters from Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the case of Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s even more than the last chapter, which was hardly holding your hand.
    Congratulations again. Let’s move on to some more complex treatment of Strings
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
