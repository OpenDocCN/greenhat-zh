- en: Chapter 3. Programmer Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 程序员工具
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
- en: This chapter is primarily geared toward tools that reveal more about Ruby, making
    the programmer’s job both easier and more interesting. We’ll revisit a few topics
    we broached in a cursory fashion earlier in the book, this time giving them more
    attention.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要介绍一些揭示Ruby更多特性的工具，使程序员的工作既容易又有趣。我们将回顾本书早期简要提到的几个主题，这次将给予它们更多的关注。
- en: '#5 What Is Truth? (boolean_golf.rb)'
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#5 什么是真理？（boolean_golf.rb）'
- en: Back in [Chapter 1](ch01.html "Chapter 1. Interactive Ruby and the Ruby Environment"),
    we talked about how various languages convert data from one type to another. You’ll
    remember that this process is called *casting*, and Ruby generally requires programmers
    to do this explicitly, while some other languages provide shortcuts that implicitly
    cast data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 交互式Ruby和Ruby环境")中，我们讨论了各种语言如何将数据从一种类型转换为另一种类型。你可能还记得这个过程被称为*类型转换*，Ruby通常要求程序员显式地进行这种转换，而一些其他语言提供了简化的方法来实现隐式类型转换。
- en: The one major exception to this policy in Ruby is the *Boolean* type, which
    is either true or false. However, we noted earlier that you can also use a `to_b`
    method, making data conversion in Ruby completely consistent, in that it is always
    explicit. We’ll be doing a variation on the notion of the `to_b` method in the
    program below, which we call `boolean_golf.rb`. The name is inspired by a practice
    in the Perl community in which programmers try to accomplish a given task with
    as few keystrokes as possible—they score it like golf. This script accomplishes
    its task as succinctly as possible, without being illegibly terse.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby中，这一政策的唯一一个主要例外是*布尔*类型，它要么为真，要么为假。然而，我们之前提到，你也可以使用`to_b`方法，这使得Ruby中的数据转换完全一致，因为它总是显式的。下面程序中的`to_b`方法的概念将会有所变化，我们将其称为`boolean_golf.rb`。这个名字受到了Perl社区中一种实践的启发，即程序员尝试用尽可能少的按键完成给定的任务——就像打高尔夫一样评分。这个脚本尽可能地简洁地完成其任务，而不至于过于简略。
- en: The Code
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How It Works
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: This program takes advantage of Ruby’s support for open classes and adds new
    behavior to the Object class. Object is what old hands at Object Orientation call
    a superclass. *Superclasses* are ancestors of other classes. In Ruby, Object happens
    to be the ultimate superclass, because it’s the ancestor of every other class
    in Ruby. This status means that methods you add to Object will be available to
    every single variable of any kind, at any time afterwards. This is extremely powerful,
    as you might expect.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序利用了Ruby对开放类的支持，并为Object类添加了新的行为。Object是那些熟悉面向对象的老手所称呼的超类。*超类*是其他类的祖先。在Ruby中，Object恰好是终极超类，因为它是一切其他Ruby类祖先。这种地位意味着你添加到Object中的方法将在之后的任何时间对任何类型的变量都可用。这非常强大，正如你所期望的。
- en: The methods we’re adding are the explicit casting to Boolean methods already
    discussed. When we introduced the concept, we called our hypothetical method `to_b`.
    The program above has that method, but gets to it in a roundabout way. The first
    method defined in the program (at ❶) is `false?`. Remember that a method that
    returns a Boolean is a *predicate*, and Ruby follows the Lisp tradition of naming
    predicates so that they end in question marks. The `false?` method uses Ruby’s
    implicit Boolean casting inside itself—it just forces its calling object into
    an implicit Boolean test with the `not` operator, which also reverses the Boolean
    value. Therefore, `false?` is the opposite of `to_b`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的方法是之前已经讨论过的显式转换为布尔类型的方法。当我们引入这个概念时，我们假设的方法叫做`to_b`。上面的程序中包含了这个方法，但通过迂回的方式访问它。程序中定义的第一个方法（在❶处）是`false?`。记住，返回布尔值的方法被称为*谓词*，Ruby遵循Lisp的传统，将谓词的名称以问号结尾。`false?`方法在Ruby内部使用隐式布尔转换——它只是使用`not`运算符强制调用对象进行隐式布尔测试，这也会反转布尔值。因此，`false?`是`to_b`的反义词。
- en: 'Let’s show that in irb:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在irb中展示这一点：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see that `to_b` reports whether its calling object is considered `true`
    by Ruby. The `false?` method does the opposite—it returns `false` when Ruby considers
    the calling object `true`, and `true` when Ruby considers the calling object `false`.
    You can also try calling these methods on other objects, as well as calling the
    `true?` method (❷) on these and any other values. You’ll find that `true?` returns
    the same values as the `to_b` method. This program defines `true?` in a similar
    manner to `false?`, except instead of reversing `self`, it reverses the output
    of `false?`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`to_b`方法报告其调用对象是否被Ruby认为是`true`。`false?`方法做相反的操作——当Ruby认为调用对象是`true`时返回`false`，当Ruby认为调用对象是`false`时返回`true`。你也可以尝试在其他对象上调用这些方法，以及在这些值和任何其他值上调用`true?`方法（❷）。你会发现`true?`返回与`to_b`方法相同的值。这个程序以与`false?`类似的方式定义了`true?`，除了不反转`self`，它反转了`false?`的输出。
- en: The methods `true?` and `false?` look familiar because they’ve been defined
    in the usual way. At ❸, we define `to_b` in a different way. Ruby gives us a the
    option of doing what’s called *metaprogramming*, which allows us to manipulate
    our objects while we’re still in the process of defining them. In this case, we’re
    defining `to_b` as an alias to the method `true?` that we just created. The code
    is quite readable, isn’t it? You might be curious about why we precede the names
    of the methods with a colon. In this use of `alias, :true?` and `:to_b` are instances
    of the Symbol class, which are preceded with a colon. We’ll talk about Symbol
    in later chapters. At the moment, just remember that we define aliases with the
    keyword `alias`, the Symbol version of the new name (with an initial colon), and
    the Symbol version of the old name (with an initial colon), in that order. We’ll
    show that in our existing irb session.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`true?`和`false?`方法看起来很熟悉，因为它们是以通常的方式定义的。在❸处，我们以不同的方式定义了`to_b`。Ruby给我们提供了进行所谓的*元编程*的选项，这允许我们在定义对象的过程中操纵它们。在这种情况下，我们将`to_b`定义为刚刚创建的`true?`方法的别名。代码相当易于阅读，不是吗？你可能好奇为什么我们在方法名前加冒号。在这个用法中，`alias,
    :true?`和`:to_b`是Symbol类的实例，它们前面有冒号。我们将在后面的章节中讨论Symbol。目前，只需记住我们使用关键字`alias`，新名称的Symbol版本（以冒号开头），以及旧名称的Symbol版本（以冒号开头），按此顺序定义别名。我们将在现有的irb会话中展示这一点。'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Metaprogramming *is a general term for writing programs that create or manipulate
    other programs. In our case, we write a program that manipulates itself, which
    is perhaps a little conceptually weird. It’s very powerful, however, and is used
    extensively in Rails. Technically, a compiler or interpreter is an example of
    metaprogramming, because it allows you to write a short program in a high-level
    language (like Ruby), which creates a program in a lower-level language (usually
    C) under the hood, which is then executed. Another example of a different sort
    of metaprogramming in this book is a script called* *`methinks_meta.rb`*, *which
    we’ll see in [#35 Mutating Strings into Weasels (methinks.rb)](ch09s02.html "#35
    Mutating Strings into Weasels (methinks.rb)") on page 168*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程*是编写创建或操作其他程序的通用术语。在我们的情况下，我们编写了一个操作自己的程序，这在概念上可能有点奇怪。然而，它非常强大，并且在Rails中被广泛使用。技术上，编译器或解释器是元编程的一个例子，因为它允许你用高级语言（如Ruby）编写简短的程序，在底层（通常是C语言）创建程序，然后执行。本书中另一种不同类型的元编程的例子是一个名为*`methinks_meta.rb`*的脚本，我们将在第168页的[第35章
    将字符串变为狐狸（methinks.rb）](ch09s02.html "#35 Mutating Strings into Weasels (methinks.rb)")中看到。
- en: Hacking the Script
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: In this irb session, we just make a not-terribly-useful alias for `to_i` with
    the cumbersome name `make_me_into_an_integer`. However, it does nicely demonstrate
    how to define aliases. We have accomplished several tasks. We added new methods
    to every single object in Ruby. These methods allow us to be completely pedantic
    about Boolean casting—in other words, we now have methods for explicit casting
    into Boolean values. While doing so, we refreshed our knowledge of method naming
    conventions and also learned a bit about both aliases and metaprogramming.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个irb会话中，我们只是用繁琐的名称`make_me_into_an_integer`为`to_i`创建了一个不太有用的别名。然而，它很好地展示了如何定义别名。我们完成了几个任务。我们向Ruby中的每一个对象添加了新方法。这些方法允许我们对布尔类型转换进行完全的严谨处理——换句话说，我们现在有了将值显式转换为布尔值的方法。在这样做的同时，我们刷新了我们对方法命名约定的知识，也了解了一些关于别名和元编程的知识。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Running the Script
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: The easiest way to run this is with irb.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用irb。
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Results
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: This library file only returns either `true` or `false`, as demonstrated above.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库文件只返回 `true` 或 `false`，如上所示。
- en: '#6 Making a List (array_join.rb)'
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#6 创建列表（array_join.rb）'
- en: In the previous script, we added new methods to allow explicit Boolean casting
    to every Object in all of Ruby. In this example, we create a new method that is
    a slight variation on a method that already exists. In this case, we’re altering
    the way that Arrays can represent themselves as Strings.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的脚本中，我们添加了新方法，允许在 Ruby 中的每个对象上进行显式的布尔类型转换。在这个例子中，我们创建了一个新方法，它是现有方法的一个微小变化。在这种情况下，我们正在改变数组表示自身为字符串的方式。
- en: 'When we talk about lists in natural speaking, we often separate the last item
    from the item before it with the word *and*. This is not how Ruby handles Arrays
    by default. Let’s verify that in irb:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用自然语言谈论列表时，我们经常用单词 *and* 将最后一个项与它前面的项分开。这不是 Ruby 默认处理数组的方式。让我们在 irb 中验证这一点：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’re creating a variant of the method `join`, which is available to all Arrays
    and whose behavior we see above in the irb session. It takes the items of the
    Array, concatenating them together into a String, with the argument to the `join`
    method between each item, but not before the first item or after the last item.
    That’s the behavior of `join`. How can we make our own `join` that adds the String
    `and` before the last item? Here’s how.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建 `join` 方法的变体，这个方法对所有数组都可用，我们在 irb 会话中看到了它的行为。它将数组的项连接起来形成一个字符串，每个项之间用
    `join` 方法的参数分隔，但不在第一个项之前或最后一个项之后。这就是 `join` 的行为。我们如何创建自己的 `join` 方法，在最后一个项之前添加字符串
    `and`？下面是如何做的。
- en: The Code
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How It Works
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: In our open class modification of Array, we define a new method at ❶ called
    `my_join` that takes two separator arguments. It calls another method, `modified_join`,
    with whatever our two separator arguments are.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对 Array 的公开类修改中，我们在❶处定义了一个名为 `my_join` 的新方法，它接受两个分隔符参数。它调用另一个名为 `modified_join`
    的方法，无论我们的两个分隔符参数是什么。
- en: The `modified_join` method hasn’t been defined yet and doesn’t need to be called
    except within the `my_join` method. You might think that it can be a `private`
    method, and so would expect to see the word *private* before the method definition.
    Instead, at ❷ you see the word *protected*. Why couldn’t it just have been *private*?
    We’ll find out very shortly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`modified_join` 方法还没有被定义，并且不需要在 `my_join` 方法之外被调用。你可能认为它可以是 `private` 方法，因此你可能会期望在方法定义之前看到单词
    *private*。相反，在❷处，你看到的是单词 *protected*。为什么它不能只是 `private` 呢？我们很快就会找到答案。'
- en: 'The `modified_join` method is defined at ❹ simply as calling the new destructive
    method `modified_join!` on a duplicate of the calling object. We get a duplicate
    of the calling object simply by using the `dup` method. We define the destructive
    method `modified_join!` at ❸. It takes two separator arguments, just like all
    of our new methods in this program. It defines a new local variable called `last_one`,
    which is the value of the object calling the method `pop` on itself. Pop is a
    standard term in many languages for the operation of removing the last item from
    an Array. Here’s an example of popping in action, continuing our existing irb
    session:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`modified_join` 方法在❹处简单地定义为在调用对象的副本上调用新的破坏性方法 `modified_join!`。我们通过使用 `dup`
    方法简单地获取调用对象的副本。我们在❸处定义了破坏性方法 `modified_join!`。它接受两个分隔符参数，就像我们在这个程序中的所有新方法一样。它定义了一个新的局部变量
    `last_one`，它是调用自身 `pop` 方法的对象的值。Pop 是许多语言中从数组中移除最后一个项目的标准术语。以下是一个 pop 操作的示例，继续我们现有的
    irb 会话：'
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can see that the Array called `a` is modified whenever it calls the method
    `pop` on itself. Why, you might ask, isn’t this method called `pop!`, since it’s
    destructive? That’s a good question. The answer is convention—*pop* is an established
    term for this operation from languages that precede Ruby. If this convention bothers
    you, just remember that Ruby has ancestors, just like a real human spoken language
    does. Think about the spelling rules in English. They make little sense after
    the fact, but make perfect sense when you realize that English is the product
    of Norman soldiers trying to pick up Saxon barmaids a thousand years ago.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当数组 `a` 调用自身的 `pop` 方法时，它会被修改。你可能会问，为什么这个方法不叫 `pop!`，因为它具有破坏性？这是一个好问题。答案是惯例——*pop*
    是从先于 Ruby 的语言中继承来的这个操作的既定术语。如果你觉得这个惯例让你感到困扰，只需记住 Ruby 有祖先，就像真正的人类语言一样。想想英语的拼写规则。在事后看来，它们几乎没有意义，但当你意识到英语是一千年前的诺曼士兵试图勾搭撒克逊酒吧女招待的产物时，它们就变得完全合理了。
- en: Ruby depends on its ancestors similarly to how a spoken language does, and given
    the choice between breaking either the convention of naming destructive methods
    with exclamation marks or of agreeing with precedent from other languages, Matz
    has decided to make Ruby play nicely with others.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 依赖于其祖先，类似于一种口语语言，考虑到破坏性方法使用感叹号命名的惯例与其他语言的先例之间的选择，Matz 决定让 Ruby 与其他语言友好相处。
- en: Now we have our last item in a separate variable called `last_one`, and since
    `pop` is destructive, that item has been removed from the calling Array after
    `pop` has occurred. We’re satisfied with the way the original version of `join`
    works on all items before the last one, so we can just call the plain old `join`
    on those items. We add our second separator, and then add our last item that we
    popped off, making sure that it is a String (and therefore willing to be concatenated)
    by calling the `to_s` method on it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将最后一个项目存储在一个名为 `last_one` 的单独变量中，由于 `pop` 是破坏性的，该项目在 `pop` 发生后已经从调用 Array
    中移除。我们对原始版本 `join` 在最后一个项目之前所有项目的处理方式感到满意，因此我们可以直接对这些项目调用普通的 `join`。我们添加第二个分隔符，然后添加我们弹出并移除的最后一个项目，确保它是一个
    String（因此愿意被连接），通过在它上面调用 `to_s` 方法来实现。
- en: So what was all that business about using `protected` instead of `private`?
    The reason we used `protected` is that inside the (non-destructive) `modified_join`
    method, our Array doesn’t call the (destructive) `modified_join!` method on itself.
    Instead, it calls `modified_join!` on a duplicate of itself. It’s no longer the
    same object, and the duplicate won’t allow another instance to call one of its
    `private` methods. So what do we do? Should there be a way for an Array to call
    a method on another Array that isn’t available to an Integer, a String, or a Symbol?
    There is, and that’s exactly what the `protected` access control keyword is for.
    Below is some irb action showing how the program works.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么使用 `protected` 而不是 `private` 的所有这些讨论都是关于什么的呢？我们使用 `protected` 的原因是在（非破坏性的）`modified_join`
    方法内部，我们的 Array 对象不会对自己调用（破坏性的）`modified_join!` 方法。相反，它会对自己的副本调用 `modified_join!`。它不再是同一个对象，并且副本不会允许另一个实例调用其
    `private` 方法。那么我们该怎么办呢？是否应该有一种方式让 Array 能够调用一个对 Integer、String 或 Symbol 不可用的方法？确实存在这样的方式，这正是
    `protected` 访问控制关键字的作用。下面是一些 irb 操作示例，展示了程序是如何工作的。
- en: Running the Script
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Hacking the Script
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: Once you’ve tried that and are comfortable with it, change `protected` to `private`
    and try to run it again. It should fail on you, as shown here.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你尝试过并且对此感到舒适，将 `protected` 改为 `private` 并再次尝试运行。它应该会失败，如下所示。
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That `private` method error is the reason we want our non-`public` methods
    in this program to be `protected`, rather than `private`. That should give you
    basic understanding of Ruby’s access control: `public, private`, and `protected`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `private` 方法错误是我们想要在这个程序中将非 `public` 方法设置为 `protected` 而不是 `private` 的原因。这应该给你一个基本的
    Ruby 访问控制理解：`public, private` 和 `protected`。
- en: '#7 Command-Line Interface (uses_cli.rb and simple_cli.rb)'
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#7 命令行界面（uses_cli.rb 和 simple_cli.rb）'
- en: The program `uses_cli.rb` understands command-line options, which are configuration
    options that you can use to make the script behave in different ways, depending
    on the specific values chosen. It uses specific options that have become somewhat
    standard, such as `-h` or `--help`. Options in the form with a single hyphen and
    a single letter are *short options*, while those with a double hyphen and a full
    word are (unsurprisingly) called *long options*. Let’s look at the code for `uses_cli.rb`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 程序 `uses_cli.rb` 理解命令行选项，这些是配置选项，您可以使用它们根据所选的具体值使脚本以不同的方式运行。它使用了一些已经变得相当标准的特定选项，例如
    `-h` 或 `--help`。形式为单个连字符和一个字母的选项是 *短选项*，而形式为双连字符和完整单词的选项（不出所料）被称为 *长选项*。让我们看看
    `uses_cli.rb` 的代码。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*I think there is enough pedagogical value to rolling your own command-line
    parser to make it worthwhile, especially in a book like this. However, I should
    note that there are two fine built-in CLI parsers in Ruby: GetOptLong (Motoyuki
    Kasahara*, [http://www.sra.co.jp/people/m-kasahr/ruby/getoptlong](http://www.sra.co.jp/people/m-kasahr/ruby/getoptlong))
    *and OptionParser (Nobu Nakada*, [http://optionparser.rubyforge.org](http://optionparser.rubyforge.org)).
    *I only include the URLs for information purposes; they are built in to the Ruby
    Standard Library, so you don’t need to download them*.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*我认为自己编写命令行解析器的教学价值足够高，使其变得值得，尤其是在像这样的书中。然而，我应该指出，Ruby 中有两个优秀的内置 CLI 解析器：GetOptLong（由
    Motoyuki Kasahara 开发，[http://www.sra.co.jp/people/m-kasahr/ruby/getoptlong](http://www.sra.co.jp/people/m-kasahr/ruby/getoptlong)）*和
    OptionParser（由 Nobu Nakada 开发，[http://optionparser.rubyforge.org](http://optionparser.rubyforge.org)）。*我仅提供这些网址作为信息参考；它们是
    Ruby 标准库的一部分，因此您不需要下载它们*。'
- en: The Code
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There isn’t a whole lot here, and the script gives us almost no information,
    except at ❷, where it suggests that we need to look inside the `SimpleCLI` class
    for documentation. Why the redirection? For an example this straightforward, it’s
    a fair question. The Holy Grail of computer programming is the notion of reusable
    code. There are many ways to accomplish that end, but one of the most enduringly
    successful ways is to have external libraries of functions that are reasonably
    abstract, which is the role played by the `simple_cli.rb` file in our example.
    Some other specific file can then use that library file, as we do at ❶ in `uses_cli.rb`
    with the *require* keyword, which takes a String argument that is the name of
    an external file without the .rb extension. This makes the code in that external
    file available to the file doing the requiring—it’s analogous to running irb with
    the `-r` flag. Therefore, at ❷ we can easily instantiate an instance of `SimpleCLI`
    that we call `cli`, to which we pass all of the command-line options used by `uses_cli.rb`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多内容，脚本几乎没有提供任何信息，除了在❷处，它建议我们需要查看 `SimpleCLI` 类内部的文档。为什么会有重定向？对于这样一个直接的例子，这是一个合理的问题。计算机编程的圣杯是可重用代码的概念。有许多方法可以实现这一目标，但最持久成功的方法之一是拥有合理抽象的外部函数库，这就是我们例子中
    `simple_cli.rb` 文件所扮演的角色。其他一些特定的文件可以使用这个库文件，就像我们在 `uses_cli.rb` 中的❶处使用 *require*
    关键字一样，它接受一个 String 参数，该参数是外部文件的名字，不带 .rb 扩展名。这使得外部文件中的代码对需要它的文件可用——这类似于使用 `-r`
    标志运行 irb。因此，在❷处，我们可以轻松实例化一个名为 `cli` 的 `SimpleCLI` 实例，并将 `uses_cli.rb` 中使用的所有命令行选项传递给它。
- en: If we want to understand how `SimpleCLI` works, we’ll have to look at its code.
    Note that some of the methods in `SimpleCLI` are *stubs*, meaning that they don’t
    do anything worthy of real production code, but they demonstrate that the options
    are being parsed appropriately. If you find this example useful as a scaffold
    or guide for your own code that you want to take command-line options, you simply
    replace both the types of options and their specific implementations as your needs
    dictate. These are only examples. Here, we instantiate `SimpleCLI` and then call
    its `parse_opts` method with every command-line option used in `uses_cli.rb`.
    Let’s see what that method does by looking at `simple_cli.rb`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要了解 `SimpleCLI` 的工作原理，我们就必须查看其代码。注意，`SimpleCLI` 中的一些方法是 *占位符*，这意味着它们不做任何值得在生产代码中实现的事情，但它们展示了选项被适当地解析。如果您发现这个例子对您自己的代码作为脚手架或指南有用，您只需根据您的需求替换两种类型的选项及其具体实现即可。这些只是示例。在这里，我们实例化
    `SimpleCLI`，然后使用 `uses_cli.rb` 中使用的每个命令行选项调用其 `parse_opts` 方法。让我们通过查看 `simple_cli.rb`
    来看看这个方法做了什么。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The *`help`* and *`version`* command-line options have become fairly standardized,
    and their inclusion is generally appreciated*.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*`help`* 和 *`version`* 命令行选项已经相当标准化了，并且它们的包含通常受到欢迎*。'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How It Works
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: This file, `simple_cli.rb`, is a basic definition of a class called `SimpleCLI`,
    of course, with RDoc before the class definition and some useful constants right
    away at ❶. We’ve seen constants before, but we declare these constants inside
    of a class definition. This is actually the preferred way to use constants in
    Ruby. You often want to encapsulate methods inside an object, and the same is
    true for constants. Your code for some physics calculation cares about the speed
    of light, whereas your payday notification program cares about the number of days
    in a pay period. In our case, the command-line parser cares about what `OPTIONS`
    it can understand and the `USAGE` message it should report.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件，`simple_cli.rb`，是`SimpleCLI`类的基本定义，当然，在类定义之前有RDoc，以及一些有用的常量立即在❶处。我们之前见过常量，但我们是在类定义内部声明这些常量的。这实际上是Ruby中使用常量的首选方式。你经常想要在对象内部封装方法，常量也是如此。你用于某些物理计算的代码关心光速，而你的工资通知程序关心支付周期中的天数。在我们的情况下，命令行解析器关心它可以理解哪些`OPTIONS`以及它应该报告的`USAGE`消息。
- en: The `OPTIONS` constant is a new type of data structure called a Hash. *Hashes*
    are lookup tables, and are very similar to functions, in a way. You pass something
    into a Hash, and you receive one thing from it. That one thing never changes unless
    you either change what you pass into the Hash, or you change the internals of
    the Hash. As you can see, you declare a Hash with braces. The items to the left
    of the `=>` are the *keys* of the Hash, while the items to the right of the `=>`
    are the *values* of the Hash. If you pass in one of the keys, the Hash will return
    the matching value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`OPTIONS`常量是一种新的数据结构，称为哈希表。*哈希表*是查找表，在某种程度上与函数相似。你将某个东西传递给哈希表，然后从它那里得到一个东西。除非你改变传递给哈希表的内容，或者改变哈希表的内部结构，否则这个东西永远不会改变。正如你所看到的，你用大括号声明哈希表。`=>`左侧的项目是哈希表的*键*，而`=>`右侧的项目是哈希表的*值*。如果你传递一个键，哈希表将返回匹配的值。'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Note that the one thing you receive could be a composite data type. For example,
    in our *`OPTIONS`* Hash, the values you receive are Arrays. The point is that
    you’ll always receive the same Array for a given input value*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，你收到的可能是一个复合数据类型。例如，在我们的`OPTIONS`哈希中，你收到的值是数组。关键是，对于给定的输入值，你总是会收到相同的数组*。'
- en: 'Let’s demonstrate in irb. The way to refer to a constant within a class is
    with the syntax `Class::CONSTANT`, so let’s do that. Keep in mind that the Array
    `[“-v”, “--version”]` is the value of `SimpleCLI:: OPTIONS` class associated with
    the key `:version`. That means that if you pass in the Symbol `:version`, you
    receive the Array `[“-v”, “--version”]`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在irb中演示一下。在类中引用常量的语法是`Class::CONSTANT`，所以我们就这么做。记住，数组`[“-v”, “--version”]`是`SimpleCLI::OPTIONS`类与键`:version`关联的值。这意味着如果你传入符号`:version`，你会收到数组`[“-v”,
    “--version”]`。
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It works. If you compare our results in irb with the declaration of the Hash
    in the code, you shouldn’t be surprised by what we got. Hashes are critically
    important data structures. I am particularly fond of defining them as constants
    within a class, so you’ll see this practice repeated many times in the course
    of the book.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它是有效的。如果你在irb中比较我们的结果与代码中哈希表的声明，你不应该对我们得到的结果感到惊讶。哈希表是至关重要的数据结构。我特别喜欢将它们定义为类中的常量，所以你会在本书的整个过程中看到这种做法被反复使用。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*There are several reasons why I often have Constants within a class that are
    Hashes. They’re within a class because they need to be accessible within that
    class, but not outside it. The reason they’re often Hashes is that I often find
    (for whatever reason) that simple lookup tables are useful data structures to
    have. After you’ve read some of the functional programming information, you may
    find it interesting to define both lambdas and Procs as class constants as well.
    I find myself often doing so*.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*我经常在类中定义常量，这些常量是哈希表，有几个原因。它们在类中，因为它们需要在该类内部可访问，但不能在外部访问。它们通常是哈希表的原因是，我经常发现（无论什么原因）简单的查找表是有用的数据结构。在你阅读了一些函数式编程信息之后，你可能会发现将lambda和Proc定义为类常量也很有趣。我发现我经常这么做*。'
- en: The declaration of the `USAGE` constant at ❷ looks a bit odd, with the equals
    sign followed by two left arrows. However, this is a very useful tool for multi-line
    text called a `here doc`. With a `here doc` declaration, the programmer can say
    that an expression should continue across multiple lines until a specific marker
    is reached—`END_OF_USAGE`, in this case. This is very handy for large amounts
    of verbatim text that you would otherwise have to build using multiple `print`
    or `puts` statements.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在第❷处声明的`USAGE`常量看起来有点奇怪，等号后面跟着两个左箭头。然而，这是一个非常有用的多行文本工具，称为`here doc`。使用`here
    doc`声明，程序员可以说一个表达式应该跨越多行，直到达到一个特定的标记——在这种情况下是`END_OF_USAGE`。这对于大量需要使用多个`print`或`puts`语句构建的逐字文本来说非常方便。
- en: Next is a more straightforward constant called `VERSION`, which is a regular
    String. Its definition uses double-quote characters, because we want a newline
    character (notated by `\n`) at the end. The following two statements would print
    the same thing; the `\n` is just the way to include the newline within the String.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个更直接的常量，称为`VERSION`，它是一个常规的字符串。它的定义使用双引号字符，因为我们想在末尾有一个换行符（由`\n`表示）。接下来的两个语句会打印相同的内容；`\n`只是将换行符包含在字符串中的方式。
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have our constants, so let’s move on to our methods. The main one (and in
    fact, the only public one) is `parse_opts`, defined at ❸. It parses options, and
    its implementation should be fairly readable at this point. It returns the result
    of calling the `option_by_args` method if it understands the `args`, and otherwise
    passes its own `USAGE` message into the `display` method. I like method names
    that tell you what they’re supposed to do. If you care about the details, you
    can look inside to learn more, but the name should give you the basic information
    you need up front.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了常量，那么让我们继续到我们的方法。主要的方法（实际上，唯一公开的方法）是`parse_opts`，它在❸处定义。它解析选项，并且在这个点上它的实现应该是相当易读的。如果它理解`args`，它将返回调用`option_by_args`方法的结果，否则将把它的`USAGE`消息传递给`display`方法。我喜欢那些告诉你它们应该做什么的方法名。如果你关心细节，你可以查看内部以了解更多信息，但名称应该提供你所需的基本信息。
- en: All of our methods, other than `parse_opts`, are `private` (❹), because they
    only need to be called by a `SimpleCLI` instance on itself. The `display, do_default`,
    and `reset` methods starting at ❺ should be pretty straightforward to you. These
    are the methods that you would change to do something more useful in real production
    code. The major logic of the class occurs in the remaining methods `option_by_arg`
    (❻) and `understand_args?` (❼). We know `understand_args?` is a predicate by the
    question mark at the end of its name, so it will be returning either `true` or
    `false`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`parse_opts`方法之外，我们所有的方法都是`private`（❹），因为它们只需要由`SimpleCLI`实例在其自身上调用。从❺开始的`display,
    do_default`和`reset`方法应该对你来说相当直观。这些是你会在实际生产代码中更改以执行更有用操作的方法。类的主要逻辑发生在剩余的方法`option_by_arg`（❻）和`understand_args?`（❼）中。我们知道`understand_args?`是一个谓词，因为它名字的结尾有一个问号，所以它将返回`true`或`false`。
- en: The `option_by_args` method checks each key of the `OPTIONS` constant, and if
    it finds a match, returns with the appropriate behavior. This means that it will
    not continue checking keys after it finds a match, so the order of the keys is
    important. It checks for matches using an Array predicate method called `include?`,
    which simply returns `true` if the argument is found in the Array and `false`
    if it is not. This makes it very easy to have command-line aliases like `-v` and
    `--version` which mean the same thing, because either one will cause `include?`
    to return `true`. If `option_by_args` gets no matches, it performs its default
    behavior.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`option_by_args`方法检查`OPTIONS`常量的每个键，如果找到匹配项，则返回适当的操作。这意味着它找到匹配项后不会继续检查键，因此键的顺序很重要。它使用一个名为`include?`的数组谓词方法来检查匹配项，该方法如果数组中找到参数则返回`true`，如果没有则返回`false`。这使得拥有像`-v`和`--version`这样的命令行别名变得非常容易，因为它们都会导致`include?`返回`true`。如果`option_by_args`没有找到匹配项，它将执行其默认行为。'
- en: 'Key to all of this is whether or not the instance of `SimpleCLI` understands
    it arguments. In Ruby1.8, which this book assumes you’re using, it’s easy to determine
    that question using another predicate method called `any?`. It takes a block and
    returns `true` if the contents of that block evaluate to `true` for any of the
    elements of the calling object, which is usually an Array. Let’s demonstrate in
    irb:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切的关键在于`SimpleCLI`的实例是否理解它的参数。在Ruby1.8中，这本书假设你正在使用，你可以使用另一个名为`any?`的谓词方法来轻松确定这个问题。它接受一个块，如果调用对象（通常是数组）的任何元素满足该块中的内容为`true`，则返回`true`。让我们在irb中演示一下：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In our case, we’re checking if it’s true that the Array value returned from
    the `OPTIONS` Hash includes the first argument to the `understand_args?` method
    for any of the keys of the `OPTIONS` Hash. As you can see, Hashes have a method
    called `keys` that returns all of their keys as a single Array. If our `any?`
    test returns `true`, that means that `SimpleCLI` knows how to react to the argument
    it received. The nice thing about this setup is that to make `SimpleCLI` understand
    more options, we just add more data to the `OPTIONS` Hash. The `understand_args?`
    method never has to change, only its input does. Programmers call this *data-driven
    programming*, and generally think highly of the practice.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们检查从`OPTIONS`哈希返回的数组值是否包含`understand_args?`方法的第一个参数，对于`OPTIONS`哈希的任何键。正如你所看到的，哈希有一个名为`keys`的方法，它返回所有键作为一个单一的数组。如果我们的`any?`测试返回`true`，这意味着`SimpleCLI`知道如何对其收到的参数做出反应。这个设置的好处是，为了使`SimpleCLI`理解更多的选项，我们只需向`OPTIONS`哈希中添加更多数据。`understand_args?`方法不需要改变，只需改变它的输入。程序员称之为*数据驱动编程*，并且通常对这种做法评价很高。
- en: That’s our command-line parsing example. Let’s run this using the options shown.
    Just like in irb, I’ll show the output.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们的命令行解析示例。让我们使用显示的选项运行它。就像在irb中一样，我会显示输出。
- en: Running the Script
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Hacking the Script
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: I mentioned Ruby1.8, which provides the `any?` method. One of the machines I
    used while writing this book only has Ruby1.6\. I’ve included some alternative
    code inside a modified RDoc section at ❽ to show just how convenient it is to
    have `any?` available to us. As you can see, RDoc can be useful for things other
    than final comments.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到了Ruby1.8，它提供了`any?`方法。我在编写这本书的时候使用的一台机器只有Ruby1.6。我在修改后的RDoc部分中包含了一些替代代码，以展示`any?`对我们来说是多么方便。正如你所看到的，RDoc可以用于其他事情，而不仅仅是最终注释。
- en: '#8 Palindromes (palindrome.rb and palindrome2.rb)'
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#8 回文（palindrome.rb 和 palindrome2.rb）'
- en: I’m rounding out this chapter with a few shorter examples pertaining to palindromes,
    which are bits of text that are the same when reversed as they are when read normally.
    Usually, we allow cheating to ignore spaces, capitalization differences, and punctuation,
    so *A man, a plan, a canal, Panama* qualifies as a palindrome under those conditions.
    While working on this book, I was reading another programming book that contained
    a discussion about palindromes. “Great!” I thought. “I’ll add a `palindrome?`
    predicate method to all Strings. It’ll be a nice simple bit to have in the chapter
    in which I talk about text.” So I started thinking about breaking Strings into
    individual characters, writing a method that would compare characters an equal
    distance from each end of the String, and all the other things you’d need to do
    in some other languages. Then I realized how easy it is to implement this method
    in Ruby.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我用几个关于回文的简短例子来结束这一章，回文是指当文字反转时与正常阅读时相同的文本片段。通常，我们允许作弊，忽略空格、大小写差异和标点符号，所以 *A
    man, a plan, a canal, Panama* 在这些条件下可以算作一个回文。在撰写这本书的过程中，我读到了另一本关于回文的编程书。“太好了！”我想。“我将为所有字符串添加一个`palindrome?`谓词方法。这将是一个很好的简单内容，可以放在我讨论文本的章节中。”所以我开始思考如何将字符串分解成单个字符，编写一个方法来比较字符串两端等距离的字符，以及在其他语言中需要做的所有其他事情。然后我意识到在Ruby中实现这个方法是多么容易。
- en: The Code
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How It Works
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: That’s it. Such an easy solution was staring me in the face the whole time.
    Strings can `reverse` themselves, and the definition of a palindromic String is
    that it is the same as itself reversed. This is when I realized that this example
    belongs in this chapter, because of the incredible relative ease of this task
    and what it implies about programmers being able to roll their own libraries.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这样一个简单的解决方案一直就在我面前。字符串可以`reverse`自己，回文字符串的定义就是它反转后与自身相同。这就是我意识到这个例子应该放在这一章的原因，因为这个任务的相对简单性和它对程序员能够自己编写库的启示。
- en: Easy as it was to do, this version of a palindrome isn’t entirely satisfactory.
    For one thing, it doesn’t work for our example sentence. We need a version of
    the `palindrome?` predicate that is a bit more complex. Here it is. I’m placing
    the [Hacking the Script](ch03s03.html#hacking_the_script-id004 "Hacking the Script")
    subsection earlier in this section because I use it to demonstrate some ideas
    in the [Running the Script](ch03s04.html#running_the_script-id006 "Running the
    Script") and [The Results](ch03s04.html#the_results-id005 "The Results") subsections,
    as I hope will become clear.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然做起来很简单，但这种回文的版本并不完全令人满意。一方面，它不适用于我们的示例句子。我们需要一个更复杂的 `palindrome?` 断言版本。这里就是它。我将
    [操纵脚本](ch03s03.html#hacking_the_script-id004 "操纵脚本") 子节提前放在本节中，因为我用它来演示 [运行脚本](ch03s04.html#running_the_script-id006
    "运行脚本") 和 [结果](ch03s04.html#the_results-id005 "结果") 子节中的某些想法，希望这会变得清晰。
- en: Hacking the Script
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: The file `palindrome2.rb` is a bit more complex, as you’ll see. But given what
    it does, it’s still pretty simple in Ruby, compared to some other languages.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`palindrome2.rb` 文件稍微复杂一些，但正如你所见，与一些其他语言相比，它在Ruby中仍然相当简单。'
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This file has the shebang telling us that it should be run in Ruby, even though
    it is a library file, rather than a file that will be directly executed. Why is
    that? The main reason is that it would otherwise start with RDoc, which we wouldn’t
    want bash to try to interpret. With the shebang, this will automatically be run
    by Ruby if it is accidentally executed at the command line. If you’re extra paranoid,
    you could add the first line to `palindrome.rb`, as well.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件有shebang，告诉我们它应该在Ruby中运行，即使它是一个库文件，而不是一个将被直接执行的文件。为什么是这样？主要原因是我们不希望bash尝试解释RDoc。有了shebang，如果它意外地在命令行中执行，它将自动由Ruby运行。如果你特别偏执，你还可以将第一行添加到
    `palindrome.rb` 中。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Shebang *is the standard Unix geek pronunciation of* *`#!`*, *which one often
    finds at the beginning of scripts*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Shebang *是Unix极客对* *`#!`* *的标准发音，通常在脚本的开始处可以看到*。
- en: 'In this program, we want to be able to test palindromes such that we ignore
    all non-letters and also have the ability to ignore case if we choose to. This
    is easy enough to do. Our new String has a private method called `letters_only`
    that does what you expect it to: It compiles a new String consisting only of those
    characters that pass `DUAL_CASE_ALPHABET.include?`, where `DUAL_CASE_ALPHABET`
    (❶) is an Array of all letters, both upper- and lowercase. If it receives a `case_matters`
    argument that is `true`, it returns those letters as they are, otherwise it returns
    an all-lowercase version of those letters, which we accomplish with the `downcase`
    method. The `split` method breaks a String into chunks (each character, in this
    case), and the `join` method sews them back together with a delimiter, which in
    this case is the empty String.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们希望能够测试回文，这样我们就可以忽略所有非字母字符，并且如果我们选择的话，还有能力忽略大小写。这很容易做到。我们新的String有一个名为
    `letters_only` 的私有方法，它做你期望它做的事情：它编译出一个新的String，只包含那些通过 `DUAL_CASE_ALPHABET.include?`
    的字符，其中 `DUAL_CASE_ALPHABET` (❶) 是一个包含所有字母（大小写）的数组。如果它接收一个 `case_matters` 参数，其值为
    `true`，则返回这些字母的原样，否则返回这些字母的全小写版本，我们通过 `downcase` 方法实现这一点。`split` 方法将一个String分割成块（在这种情况下，每个字符），而
    `join` 方法则用分隔符将它们重新组合起来，在这个例子中，分隔符是空字符串。
- en: The `letters_only` method at ❸ is handy enough that in our `palindrome?` predicate
    (❷), all we need to do is compare its output to the reverse of its output, and
    we have our more flexible palindrome detector. Let’s see it in action.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在❸处的 `letters_only` 方法足够方便，以至于在我们的 `palindrome?` 断言（❷）中，我们只需要比较其输出与输出的反转，我们就有了更灵活的回文检测器。让我们看看它是如何工作的。
- en: Running the Script
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: I have written a test program called `test_palidrome.rb` that I keep in a separate
    directory called `tests/`. Here is the file, followed by a bash session in which
    I run it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了一个名为 `test_palidrome.rb` 的测试程序，它存放在一个名为 `tests/` 的单独目录中。以下是该文件内容，以及我运行它的bash会话。
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Results
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I started thinking about musical groups that both start and end with the letter
    *A*. I didn’t get very far—but far enough to demonstrate the program, anyway.
    Note that we `require palindrome2.rb` at the command line, rather than with an
    explicit require keyword inside `test_palindrome.rb`. We can also do testing in
    irb, of course.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我开始思考那些既以字母 *A* 开头又以字母 *A* 结尾的音乐团体。我没有走得很远——但足以演示程序。请注意，我们在命令行中 `require palindrome2.rb`，而不是在
    `test_palindrome.rb` 内部使用显式的 require 关键字。当然，我们也可以在 irb 中进行测试。
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We see that Japanese grilled squid (Ika Yaki) is either properly recognized
    as a palindrome or not, depending on the parameters we tell the `palindrome?`
    predicate to use. These String-related operations should get us properly prepped
    for the next chapter, which deals with text manipulation in greater detail. Before,
    that, however, we should review what was new in this chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，根据我们告诉 `palindrome?` 断言使用的参数，日本烤鱿鱼（Ika Yaki）要么被正确地识别为回文，要么不是。这些与字符串相关的操作应该能让我们为下一章更详细地处理文本做好准备。在此之前，我们应该回顾一下本章的新内容。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you try* *`ruby -r palindrome.rb tests/test_palindrome.rb`*, *the test
    script will fail. Can you figure out why? The reason has to do with arguments*.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你尝试* *`ruby -r palindrome.rb tests/test_palindrome.rb`*，*测试脚本将会失败。你能找出原因吗？原因与参数有关*。'
- en: Chapter Recap
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节摘要
- en: What was new in this chapter?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有什么新内容？
- en: Making new predicates for explicit Boolean casting
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的断言以进行显式的布尔转换
- en: Method aliases
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法别名
- en: Superclasses
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超类
- en: Metaprogramming
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元编程
- en: The Symbol class
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号类
- en: Arrays and the `join` method
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和 `join` 方法
- en: The `protected` level of access control
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制中的 `protected` 级别
- en: The `dup` and `pop` methods
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dup` 和 `pop` 方法'
- en: Making command-line interface flags
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建命令行界面标志
- en: Library files for reusable code
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用代码的库文件
- en: Class constants
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类常量
- en: The Hash class
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希类
- en: Hash keys and values
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希键和值
- en: The `here doc` declaration
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`here doc` 声明'
- en: Newline characters within Strings
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串中的换行符
- en: Using `Array.include?` to test for membership
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Array.include?` 来测试成员资格
- en: The `any?` predicate
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any?` 断言'
- en: The `Hash.keys` method
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hash.keys` 方法'
- en: A bit on Ruby1.8 vs. Ruby1.6 and the `any?` predicate
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby1.8 与 Ruby1.6 以及 `any?` 断言的比较
- en: Palindromes and reversing Strings
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回文和反转字符串
- en: Extracting the letters from Strings
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符串中提取字母
- en: Changing the case of Strings
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变字符串的大小写
- en: That’s even more than the last chapter, which was hardly holding your hand.
    Congratulations again. Let’s move on to some more complex treatment of Strings
    in the next chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至比上一章还要复杂，上一章几乎是在手把手地教你。再次恭喜。让我们继续进入下一章对字符串的更复杂处理。
