- en: Chapter 6. STRING UTILITIES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 字符串工具
- en: '![STRING UTILITIES](../Images/00001.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![字符串工具](../Images/00001.jpg)'
- en: Manipulating text with Ruby is easy; you have probably already seen Ruby's string
    methods like `capitalize`, `upcase`, `downcase`, and `swapcase`. In this chapter
    we will expand on those methods, creating an even more powerful toolset for text-processing
    tasks like searching, manipulating, and creating documents.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ruby操作文本非常简单；你可能已经见过Ruby的字符串方法，如`capitalize`、`upcase`、`downcase`和`swapcase`。在本章中，我们将扩展这些方法，为文本处理任务（如搜索、操作和创建文档）创建一个更强大的工具集。
- en: PDF Generator
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PDF生成器
- en: PDF Generator
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PDF生成器
- en: pdfGen.rb
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pdfGen.rb
- en: PDFs provide an excellent way to present data. Some advantages of using PDF
    *(Portable Document Format)* files include platform independence, viewing consistency,
    and a wide selection of free reader software. PDF files have become a standard
    for information exchange on the Internet; I even converted my resume to a PDF
    so potential employers would see exactly what I wanted them to see. This script
    will show you how to create your own PDF files without the need for expensive
    software.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: PDF文件提供了一种出色的数据展示方式。使用PDF *(便携式文档格式)* 文件的一些优点包括平台独立性、查看一致性以及丰富的免费阅读软件选择。PDF文件已成为互联网上信息交换的标准；我甚至将我的简历转换成了PDF格式，以便潜在雇主能够看到我希望他们看到的内容。此脚本将向您展示如何创建自己的PDF文件，而无需昂贵的软件。
- en: The Code
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) require ''pdf/writer''  require ''pdf/simpletable''  ![](../Images/00003.jpg) pdf
    = PDF::Writer.new  pdf.select_font("Times-Roman")  pdf.text("Review: Wicked Cool
    Ruby Scripts\n\n", :font_size => 25, :justification  => :center)  ![](../Images/00004.jpg) PDF::SimpleTable.new
    do |table|      table.column_order = %w(question response)       table.columns["question"]
    = PDF::SimpleTable::Column.new("question") do |col|          col.heading = "Question"
             col.width = 100      end      table.columns["response"] = PDF::SimpleTable::Column.new("response")
    do |col|          col.heading = "Response"      end       table.show_lines    =
    :all      table.show_headings = false      table.shade_rows    = :none      table.orientation
      = :center      table.position      = :center      table.width         = 400  ![](../Images/00005.jpg)  
      data = [          {"question" => "Reviewer:"},          {"question" => "Title:",
    "response" => "Wicked Cool Ruby Scripts"},          {"question" => "Author:",
    "response" => "Steve Pugh"},          {"question" => "Publisher & Year:", "response"
    => "No Starch Press, 2009"},          {"question" => "ISBN:"},          {"question"
    => "Genre Category:", "response" => "Programming Languages:  Ruby"},         
    ]      table.data.replace data      table.render_on(pdf)  end  ![](../Images/00006.jpg)
     pdf.text("\n\n1\.  Did this book teach you anything about scripting in Ruby (circle
     one)?" , :font_size => 14)  pdf.text("\n    Yes   No     Why or why not?____________________________")
     pdf.text("\n2\.  Are the example scripts appropriate and are they explained well?")
     pdf.text("\n    Yes   No     Why or why not?____________________________")  pdf.text("\n3\.
     Would you recommend this book to another person?  Why or why not?")  pdf.text("
       ________________________________________________________________")  pdf.text("
       ________________________________________________________________")  pdf.text("\n4\.
     List three adjectives that describe this book:")  pdf.text("    a._______________
     b._______________ c._______________")  pdf.text("\n5\.  Write any additional
    information you would like to share here:")  pdf.text("    ________________________________________________________________")
     pdf.text("    ________________________________________________________________")
     pdf.text("    ________________________________________________________________")
     pdf.text("    ________________________________________________________________")
     pdf.text("    ________________________________________________________________")
     pdf.text("\n6\.  Overall rating: Check one (0=Horrible, 5=Wicked Cool):")  pdf.text("
             0          1          2          3          4          5") ![](../Images/00007.jpg) pdf.circle_at(66,
    pdf.y+5, 5).stroke  pdf.circle_at(121, pdf.y+5, 5).stroke  pdf.circle_at(170,
    pdf.y+5, 5).stroke  pdf.circle_at(219, pdf.y+5, 5).stroke  pdf.circle_at(268,
    pdf.y+5, 5).stroke  pdf.circle_at(316, pdf.y+5, 5).stroke  ![](../Images/00008.jpg) pdf.save_as(''book_review.pdf'')`'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'To run this script, type:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，请输入：
- en: '``**`ruby pdfGen.rb`**``'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby pdfGen.rb`**``'
- en: The Results
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: After executing the script, look for a PDF file called *book_review.pdf*. The
    file's contents will look like the form shown in [Figure 6-1](#filepos493098).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 执行脚本后，寻找一个名为 *book_review.pdf* 的 PDF 文件。该文件的格式将类似于 [图 6-1](#filepos493098) 中所示的形式。
- en: '![The contents of book_review.pdf](../Images/00016.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![book_review.pdf 的内容](../Images/00016.jpg)'
- en: Figure 6-1. The contents of book_review.pdf
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1. book_review.pdf 的内容
- en: How It Works
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: For this script, we rely on the PDF:Writer library to turn regular text into
    a PDF. This is available as a gem, so you can easily install it using the command
    `gem install pdf-writer`. To begin the script, we include `pdf/writer`, to later
    create the PDF file, and `pdf/simpletable`, because we will be adding a table
    to the document ![](../Images/00002.jpg). Next, the `PDF` object is created and
    saved to a variable called `pdf` ![](../Images/00003.jpg).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，我们依赖于 PDF:Writer 库将普通文本转换为 PDF。这个库作为一个 gem 提供，因此你可以使用命令 `gem install
    pdf-writer` 轻松安装它。为了开始脚本，我们包含了 `pdf/writer`，以便稍后创建 PDF 文件，以及 `pdf/simpletable`，因为我们将在文档中添加一个表格！[](../Images/00002.jpg)。接下来，创建一个名为
    `PDF` 的对象并将其保存到一个名为 `pdf` 的变量中！[](../Images/00003.jpg)。
- en: We are creating a form that will be used to retrieve valuable customer feedback
    information about this book. The default text font for the PDF:Writer library
    is Times New Roman, and I've explicitly coded the font as a reminder that the
    fonts can be changed. You can change this to `Courier`, `Helvetica`, or `Times-Roman`.
    We add a title to the PDF document and set the font to 25-point, so that it will
    be distinguishable from the rest of the text. The next area of the PDF file will
    be a table that contains information specific to the book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个表单，该表单将被用来收集关于这本书的宝贵客户反馈信息。PDF:Writer 库的默认文本字体是 Times New Roman，我明确地编写了字体代码作为提醒，即字体可以被更改。你可以将其更改为
    `Courier`、`Helvetica` 或 `Times-Roman`。我们在 PDF 文档中添加了一个标题，并将其字体设置为 25 点，以便它可以从其他文本中区分出来。PDF
    文件的下一段区域将是一个包含特定于书籍信息的表格。
- en: We create a `SimpleTable` object followed by a code block that will populate
    the table with data ![](../Images/00004.jpg). While a table can have as many columns
    and rows as needed, we will be using two columns, titled *Question* and *Response*.
    In order to make the table more aesthetically appealing and to give customers
    more room to respond to each question, I've set the `question` width (the minimum
    character width needed to frame each question without wasting space in the question
    column) to `100`. The rest of the table will be used for customer responses. Six
    table attributes are customized, and thanks to Ruby's easily unambiguous naming
    convention, the customizations are matched with the method names. The attributes
    will determine how the finalized table will look. The section of code following
    the table attributes is where the questions are initialized in the table ![](../Images/00005.jpg).
    The last step in the table creation is to render it. The table is rendered into
    the `pdf` variable using the `render_on` method.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 `SimpleTable` 对象，随后是一个代码块，该代码块将数据填充到表格中！[](../Images/00004.jpg)。虽然表格可以有任意多的列和行，但我们将使用两列，标题为
    *问题* 和 *回答*。为了使表格更具美观性，并为顾客提供更多回答每个问题的空间，我将 `问题` 的宽度（即填充每个问题所需的最小字符宽度，以避免在问题列中浪费空间）设置为
    `100`。表格的其余部分将用于顾客的回答。我们自定义了六个表格属性，并且得益于 Ruby 的易于理解的命名约定，自定义与方法名称匹配。这些属性将决定最终表格的外观。在表格属性之后的代码部分是初始化表格中的问题的地方！[](../Images/00005.jpg)。表格创建的最后一步是将它渲染出来。使用
    `render_on` 方法将表格渲染到 `pdf` 变量中。
- en: Now that the table has been created, the script begins asking several questions,
    all with different expected types of answers ![](../Images/00006.jpg). One noteworthy
    aspect of the question section is the circles that are created using the `circle_at`
    method ![](../Images/00007.jpg). The method requires three arguments. The first
    two are the starting coordinates in the (*x*, *y*) format. The third argument
    is the radius of the circle. The drawing pointer is at the end of the document
    when the first `circle_at` is called. To get the circles to move higher by one
    line, the y-coordinate is set to `pdf.y+5`. The x-coordinate is increased to match
    the corresponding numbers *0* through *5*. To save all the hard work we—I mean
    Ruby—has done, we call the `save_as` method, which does exactly what it claims
    ![](../Images/00008.jpg). The document is saved as *book_review.pdf*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表格已经创建，脚本开始提出几个问题，这些问题都有不同的预期答案类型！[](../Images/00006.jpg)。问题部分的一个值得注意的方面是使用
    `circle_at` 方法创建的圆圈！[](../Images/00007.jpg)。该方法需要三个参数。前两个参数是以 (*x*, *y*) 格式的起始坐标。第三个参数是圆的半径。当第一次调用
    `circle_at` 时，绘图指针位于文档的末尾。为了使圆圈向上移动一行，y坐标设置为 `pdf.y+5`。x坐标增加以匹配相应的数字 *0* 到 *5*。为了保存Ruby——我是指Ruby——所做的大量工作，我们调用
    `save_as` 方法，它确实做到了它所说的！[](../Images/00008.jpg)。文档被保存为 *book_review.pdf*。
- en: Word Frequency
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单词频率
- en: Word Frequency
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单词频率
- en: wordFreq.rb
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: wordFreq.rb
- en: This script will scan a text file and count the number of times each word appears
    in the document. There are several reasons to extract word counts, or word frequencies,
    from a document. One example is for the cryptographic analysis of a cipher text
    that has been encrypted with a shift cipher. I find word frequency to be interesting
    in my own writing, too. Running this script shows me which words I use most often
    and, with a few tweaks, can show those that are not part of my daily vocabulary.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将扫描文本文件并计算文档中每个单词出现的次数。从文档中提取单词计数或单词频率有几个原因。一个例子是用于对使用移位密码加密的密文进行密码分析。我发现单词频率在我的写作中也很有趣。运行此脚本可以显示我使用最频繁的单词，经过一些调整，可以显示那些不是我的日常词汇的单词。
- en: The Code
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) unless ARGV[0]      puts "\nYou need to include a
    file to test."      puts "Usage: ruby wordFreq.rb file_to_test.txt"      exit
     end  ![](../Images/00003.jpg) unless File.exist?(ARGV[0])      puts "\nThe file
    could not be found, check the path."      puts "Usage: ruby wordFreq.rb file_to_test.txt"
         exit  end   file = ARGV[0]  words = Hash.new(0) ![](../Images/00004.jpg) File.open(file,
    "r").each_line do |line| ![](../Images/00005.jpg)     line.scan(/\b\w+\b/) {|i|
    words[i] += 1}  end  ![](../Images/00006.jpg) sorted = words.sort_by {|a| a[1]
    }   temp = sorted.length  ![](../Images/00007.jpg) 10.times do      temp -= 1
         puts "\"#{sorted[temp][0]}\" has #{sorted[temp][1]} occurrences"  end`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) unless ARGV[0]      puts "\n你需要包含一个文件进行测试。"     
    puts "用法：ruby wordFreq.rb file_to_test.txt"      exit  end  ![](../Images/00003.jpg) unless
    File.exist?(ARGV[0])      puts "\n文件未找到，请检查路径。"      puts "用法：ruby wordFreq.rb
    file_to_test.txt"      exit  end   file = ARGV[0]  words = Hash.new(0) ![](../Images/00004.jpg) File.open(file,
    "r").each_line do |line| ![](../Images/00005.jpg)     line.scan(/\b\w+\b/) {|i|
    words[i] += 1}  end  ![](../Images/00006.jpg) sorted = words.sort_by {|a| a[1]
    }   temp = sorted.length  ![](../Images/00007.jpg) 10.times do      temp -= 1
         puts "\"#{sorted[temp][0]}\" 出现了 #{sorted[temp][1]} 次"  end`'
- en: Running the Code
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'Execute this script by typing:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过键入以下命令执行此脚本：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I ran this script against the first chapter of this book just to see what would
    happen. I thought *Ruby* might be one of the top hits, but aside from the usual
    suspects (e.g., *the*, *to*, and *is*), the word *script* managed to sneak onto
    the list of top 10 words used. Who would have known?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我运行了这个脚本，针对本书的第一章，看看会发生什么。我以为 *Ruby* 可能是前十大热门词汇之一，但除了常见的嫌疑人（例如，*the*，*to* 和
    *is*）之外，单词 *script* 竟然悄悄地出现在了使用最频繁的10个单词列表中。谁能想到呢？
- en: The Results
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'The results are output to $stdout, but you could just as easily have them output
    to a text file or a PDF:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出到 $stdout，但也可以轻松地将它们输出到文本文件或PDF文件：
- en: '`"the" has 513 occurrences "to" has 156 occurrences "is" has 128 occurrences
    "script" has 126 occurrences "a" has 118 occurrences "file" has 107 occurrences
    "and" has 94 occurrences "you" has 87 occurrences "of" has 81 occurrences "in"
    has 70 occurrences`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`"the" 出现了 513 次 "to" 出现了 156 次 "is" 出现了 128 次 "script" 出现了 126 次 "a" 出现了 118
    次 "file" 出现了 107 次 "and" 出现了 94 次 "you" 出现了 87 次 "of" 出现了 81 次 "in" 出现了 70 次`'
- en: How It Works
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The script begins with a check to make sure the user has entered a filename
    for word frequency analysis ![](../Images/00002.jpg). Next, the script checks
    to ensure the filename that was passed actually is a file and also that the file
    is reachable ![](../Images/00003.jpg). After creating a `file` object from the
    first argument and initializing a hash called `words`, the file is opened and
    each line is read into a block ![](../Images/00004.jpg). Although there is only
    one line in the block, there are many different actions taking place within that
    single line. The wicked cool part about the multiple actions taking place is that
    they have been condensed to one line, yet they are still easily readable by humans
    ![](../Images/00005.jpg). For each line in the file, the contents are *parsed*,
    or scanned, using the `scan` method. Since the script is tracking the occurrences
    of each word, this method allows the script to isolate individual words. This
    method will pass each word that matches the regular expression to another block
    (also located on the same line). Interestingly enough, the matches can simply
    be put into an array if no block was needed. But, since we needed to do some more
    manipulation, we tacked a block onto the end of the line.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本开始于一个检查，以确保用户已经输入了一个用于单词频率分析的文件名 ![图片](../Images/00002.jpg)。接下来，脚本会检查传入的文件名确实是一个文件，并且该文件是可访问的
    ![图片](../Images/00003.jpg)。从第一个参数创建一个 `file` 对象并初始化一个名为 `words` 的哈希后，文件被打开，每一行都被读入一个块
    ![图片](../Images/00004.jpg)。尽管块中只有一行，但那一行中正在进行许多不同的操作。关于这些多个操作的一个非常酷的部分是，它们被压缩成了一行，但仍然对人类来说很容易阅读
    ![图片](../Images/00005.jpg)。对于文件中的每一行，内容都使用 `scan` 方法进行解析，或扫描。由于脚本正在跟踪每个单词的出现次数，这种方法允许脚本隔离单个单词。这个方法将匹配正则表达式的每个单词传递到另一个块（也位于同一行）。有趣的是，如果不需要块，可以直接将匹配项放入数组。但是，由于我们需要进行一些额外的操作，我们在行尾添加了一个块。
- en: For each word passed to the block, the `words` hash is referenced, and the key
    is incremented by one if the word exists. If the word has not been encountered
    before, then the value is initialized and the key set to a count of one. Populating
    a hash table, in one line of code, based on the occurrences of every single word
    in a file is slick. Perhaps you've come across the term *histogram* in a math
    or statistics class? Well this script makes a simple histogram that shows the
    proportion of words used in a given file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传递给块的每个单词，都会引用 `words` 哈希，如果单词存在，则键值增加一。如果单词之前没有遇到过，则初始化值并将键设置为计数一。在一行代码中根据文件中每个单词的出现次数填充哈希表是相当酷的。也许你在数学或统计学课程中遇到过
    *直方图* 这个术语？这个脚本创建了一个简单的直方图，显示了给定文件中使用的单词比例。
- en: At this point, the `words` hash is completely populated, and all that's left
    to do is output the significant information. The script orders the values in `words`
    based on the keys using a nice little method called `sort_by`, which is part of
    the Enumerable library. The `sort_by` method will sort the respective hash and
    return a multidimensional array with arrays containing the key and value for each
    element in the original hash ![](../Images/00006.jpg). The final block prints
    the last 10 arrays of the multidimensional array; this corresponds to the 10 words
    that occur most often in the text file ![](../Images/00007.jpg).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`words` 哈希已经完全填充，剩下要做的就是输出重要信息。脚本使用名为 `sort_by` 的方法（它是 Enumerable 库的一部分）根据键对
    `words` 中的值进行排序。`sort_by` 方法将排序相应的哈希，并返回一个多维数组，其中包含原始哈希中每个元素的键和值 ![图片](../Images/00006.jpg)。最后的块打印多维数组中的最后
    10 个数组；这对应于文本文件中出现频率最高的 10 个单词 ![图片](../Images/00007.jpg)。
- en: Hacking the Script
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑客脚本
- en: The simplest hack would be to convert the script to analyze letters in the text
    file. Letter frequency is also used for cryptographic analysis. A simple search
    on Google will reveal that the most widely used letter in English is *e*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的黑客攻击方法是将脚本转换为分析文本文件中的字母。字母频率也用于密码分析。在谷歌上简单搜索一下，会发现英语中最常用的字母是 *e*。
- en: A slightly different approach would be the addition of *stop words*. Stop words
    are words that are removed prior to displaying the results. You could remove common
    terms like *the*, *to*, *is*, *of*, *as*, and so on. Also, this script could be
    the simple beginnings of a Bayesian spam filter. Bayesian spam filters are powerful
    because they identify words that occur in spam and build a profile from these.
    I'm sure you can think of one or two words that are common in spam messages …
    something to do with enlarging this or free that. Profiling spam is one tool for
    helping users get legitimate email.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一种稍微不同的方法可能是添加*停用词*。停用词是指在显示结果之前被移除的词。你可以移除像*the*、*to*、*is*、*of*、*as*等常见术语。此外，这个脚本可能是贝叶斯垃圾邮件过滤器的一个简单起点。贝叶斯垃圾邮件过滤器之所以强大，是因为它们可以识别垃圾邮件中出现的单词，并从这些单词中构建一个档案。我相信你可以想到一两个在垃圾邮件中常见的单词……比如与扩大这个或免费那个有关的内容。对垃圾邮件进行档案化是帮助用户获取合法电子邮件的一个工具。
- en: Comma-Separated Value Parser
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逗号分隔值解析器
- en: Comma-Separated Value Parser
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逗号分隔值解析器
- en: csv.rb
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: csv.rb
- en: Comma-separated value (CSV) files are very prevalent in our digital world. They
    are used everywhere, and many programs have functions to input or output information
    in the CSV format. Even Microsoft supports CSV in the majority of its products!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数字世界中，逗号分隔值（CSV）文件非常普遍。它们被用于各个地方，许多程序都有在CSV格式中输入或输出信息的函数。甚至微软的大多数产品都支持CSV格式！
- en: 'This script will show you how to customize data output once it has been delimited
    by commas in a CSV file. This will lead to more meaningful interpretation of the
    data. Two libraries can help you work with CSV files: The first is the old standard
    Ruby CSV library, and the second is a library called FasterCSV. I will show you
    how to use FasterCSV and seamlessly integrate it into your scripts. Just note
    that when you upgrade past 1.8, FasterCSV will be incorporated into the standard
    library. The usage is very similar between both libraries; if you ever find yourself
    needing to upgrade or read old Ruby CSV code, you shouldn''t worry at all.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将向你展示如何在CSV文件中用逗号分隔数据后自定义数据输出。这将导致对数据的更有意义的解释。有两个库可以帮助你处理CSV文件：第一个是旧的Ruby
    CSV库标准，第二个是一个名为FasterCSV的库。我将向你展示如何使用FasterCSV并将其无缝集成到你的脚本中。只需注意，当你升级到1.8以上时，FasterCSV将被纳入标准库。这两个库的使用方法非常相似；如果你需要升级或阅读旧的Ruby
    CSV代码，你根本不必担心。
- en: 'We could have hacked our own CSV library using the `split` method; but since
    you''ve seen other scripts with `split`, we''ll introduce something new and more
    efficient. To put this script in perspective, suppose you have a financial CSV
    file output by some hyper-state-of-the-art financial analysis software, like Excel
    or QuickBooks. You''ve got to figure out what to do with the data, so your first
    thought is to consult Ruby! Here''s what *easy* looks like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`split`方法来修改我们自己的CSV库；但既然你已经看到了其他使用`split`的脚本，我们将介绍一些新且更高效的方法。为了使这个脚本更具体，假设你有一个由某些超先进金融分析软件（如Excel或QuickBooks）输出的金融CSV文件。你必须弄清楚如何处理这些数据，所以你的第一个想法是咨询Ruby！这就是*简单*的样子：
- en: The Code
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` require ''faster_csv''  ![](../Images/00002.jpg) unless ARGV[0]      puts
    "Usage: ruby csv.rb <filename.ext>"      puts "Example: ruby csv.rb comma.separated"
         exit  end   unless File.exist?(ARGV[0])      puts "\nThe file could not be
    found, check the path."      puts "Usage: ruby csv.rb comma.separated"      exit
     end  ![](../Images/00003.jpg) file = FasterCSV.open(ARGV[0], "r")   print "Does
    the file include header information (y/n)? " ![](../Images/00004.jpg) h = $stdin.gets.chomp   if
    h.downcase == ''y'' ![](../Images/00005.jpg)     header = file.shift      print
    header.join("\t")  ![](../Images/00006.jpg)     file.each do |line|          puts
             print line.join("\t")      end  else ![](../Images/00007.jpg)     print
    "Enter header information (separated by commas): "      header = $stdin.gets.strip
         header = header.split(",") ![](../Images/00008.jpg)     header.each do |h|
             print h + "\t"      end       file.each do |line|          puts     
        line.each do |element|              print element + "\t"          end     
    end  end`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`require ''faster_csv'' ![图片](../Images/00002.jpg) unless ARGV[0] puts "用法：ruby
    csv.rb <文件名.ext>" puts "示例：ruby csv.rb comma.separated" exit unless File.exist?(ARGV[0])
    puts "\n文件未找到，请检查路径。" puts "用法：ruby csv.rb comma.separated" exit ![图片](../Images/00003.jpg)
    file = FasterCSV.open(ARGV[0], "r") print "文件是否包含标题信息（y/n）？ ![图片](../Images/00004.jpg)"
    h = $stdin.gets.chomp if h.downcase == ''y'' ![图片](../Images/00005.jpg) header
    = file.shift print header.join("\t") ![图片](../Images/00006.jpg) file.each do |line|
    puts print line.join("\t") end else ![图片](../Images/00007.jpg) print "输入标题信息（以逗号分隔）："
    header = $stdin.gets.strip header = header.split(",") ![图片](../Images/00008.jpg)
    header.each do |h| print h + "\t" end file.each do |line| puts line.each do |element|
    print element + "\t" end end end`'
- en: Running the Code
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'Run the script by typing:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令运行脚本：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Results
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: To test this script, I downloaded a CSV file from a financial reporting website
    that contained information about Google. The results display the first few days
    in 2004 that Google was publicly traded. The company has become immensely profitable
    since then, but this shows the value of Google when it started.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个脚本，我从一家财务报告网站上下载了一个包含关于谷歌信息的CSV文件。结果显示了2004年谷歌公开交易的前几天。自那时起，公司已经变得极其盈利，但这显示了谷歌刚开始时的价值。
- en: '`Date        Open       High       Low        Close      Volume 2004-09-01
     102.70     102.97     99.67      100.25     4573700 2004-08-31  102.30     103.71
        102.16     102.37     2461400 2004-08-30  105.28     105.49     102.01    
    102.01     2601000 2004-08-27  108.10     108.62     105.69     106.15     3109000
    2004-08-26  104.95     107.95     104.66     107.91     3551000 2004-08-25  104.96
        108.00     103.88     106.00     4598900 2004-08-24  111.24     111.60    
    103.57     104.87     7631300 2004-08-23  110.75     113.48     109.05     109.40
        9137200 2004-08-20  101.01     109.08     100.50     108.31     11428600 2004-08-19
     100.00     104.06     95.96      100.34     22351900`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`日期       开盘价      最高价      最低价      收盘价      成交量 2004-09-01 102.70     102.97    
    99.67      100.25     4573700 2004-08-31 102.30     103.71     102.16     102.37    
    2461400 2004-08-30 105.28     105.49     102.01     102.01     2601000 2004-08-27
    108.10     108.62     105.69     106.15     3109000 2004-08-26 104.95     107.95    
    104.66     107.91     3551000 2004-08-25 104.96     108.00     103.88     106.00    
    4598900 2004-08-24 111.24     111.60     103.57     104.87     7631300 2004-08-23
    110.75     113.48     109.05     109.40     9137200 2004-08-20 101.01     109.08    
    100.50     108.31     11428600 2004-08-19 100.00     104.06     95.96      100.34    
    22351900`'
- en: How It Works
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The script is written with two types of CSV files in mind: a file with the
    header on the first line and a file with pure data. The script takes a CSV file
    as the only argument, and the file''s existence is first checked to ensure proper
    execution ![](../Images/00002.jpg). Next, the script opens the file using the
    faster_csv library ![](../Images/00003.jpg). After the file has been opened, the
    script asks the user about header info in order to determine which section of
    code to follow ![](../Images/00004.jpg). If the file does contain header information,
    the first part of the `if` statement is executed. Assuming the CSV file contains
    a header, the first task is to remove the header so that faster_csv can work its
    magic. The header is removed with the `shift` method, and the value is stored
    in the variable `header` ![](../Images/00005.jpg).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本是为两种类型的 CSV 文件编写的：第一行有表头的文件和纯数据的文件。脚本将 CSV 文件作为唯一参数，首先检查文件是否存在以确保正确执行 ![图片
    00002](../Images/00002.jpg)。接下来，脚本使用 faster_csv 库打开文件 ![图片 00003](../Images/00003.jpg)。文件打开后，脚本会询问用户关于表头信息，以便确定要遵循的代码部分
    ![图片 00004](../Images/00004.jpg)。如果文件确实包含表头信息，则执行 `if` 语句的第一部分。假设 CSV 文件包含表头，第一项任务是删除表头，以便
    faster_csv 可以施展其魔法。表头通过 `shift` 方法删除，并将值存储在变量 `header` 中 ![图片 00005](../Images/00005.jpg)。
- en: After the header has been parsed, the script moves on to the meat of the CSV
    file. If you recall from before, we initialized the variable `file` as a FasterCSV
    object that reads in the CSV file to be parsed. Getting back to basics for a moment,
    each line contains data that may or may not have every field populated. The FasterCSV
    library's syntax is great because the code is so similar to every other file manipulation
    script. A block of code that outputs a line break for every line within the CSV
    file is declared. Then, for each element in the line, the output ends with a tab
    for a clean display ![](../Images/00006.jpg). Not too complicated. The FasterCSV
    library makes handling CSV files a breeze, and that ends the first path.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 解析表头后，脚本继续处理 CSV 文件的核心部分。如果您还记得之前的内容，我们初始化变量 `file` 为一个 FasterCSV 对象，该对象读取要解析的
    CSV 文件。暂时回到基础，每一行包含可能或可能没有填充每个字段的数据。FasterCSV 库的语法很棒，因为代码与其他文件操作脚本非常相似。声明了一个代码块，为
    CSV 文件中的每一行输出一个换行符。然后，对于每一行的每个元素，输出以制表符结束，以实现清晰的显示 ![图片 00006](../Images/00006.jpg)。并不复杂。FasterCSV
    库使得处理 CSV 文件变得轻而易举，这也结束了第一个路径。
- en: If you have a raw CSV file without any headers, perhaps you want to add your
    own headers for ease of use or readability. If that is the case, then you would
    answer **`no`** to the question asking about headers. Then the script knows to
    ask for the header names rather than trying to read them off the CSV file ![](../Images/00007.jpg).
    The user then enters each header separated by a comma. After the headers are created,
    the rest of the script runs, just like the previous path ![](../Images/00008.jpg).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个没有表头的原始 CSV 文件，可能您想添加自己的表头以方便使用或提高可读性。如果是这样，那么您会对询问表头的提问回答 **`no`**。然后脚本就知道要询问表头名称而不是尝试从
    CSV 文件中读取它们 ![图片 00007](../Images/00007.jpg)。用户然后输入每个表头，用逗号分隔。表头创建后，脚本的其余部分运行，就像之前的路径
    ![图片 00008](../Images/00008.jpg)。
- en: Hacking the Script
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: There aren't many hacks to this script because of its simplicity, but there
    are two things that would be a good exercise in Ruby coding. The first is condensing
    the script while still maintaining readability. The first place to look would
    be where the header is parsed. Another equally beneficial exercise would be to
    format the output to handle a variety of cases. As it stands now, with tabs, the
    information could be out of alignment if some of the element fields are too wide.
    Additionally, you could use the CSV file to output to another file for many other
    uses. I have the script outputting the data directly because my data sets weren't
    too large and were easy to read in a terminal window. Check out the next few sections,
    which build on this basic idea of parsing CSV files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个脚本的简单性，没有太多技巧，但在 Ruby 编码中，有两件事可以作为很好的练习。第一是压缩脚本同时保持可读性。首先应该查看的地方是解析表头的地方。另一个同样有益的练习是对输出进行格式化以处理各种情况。目前，由于使用了制表符，如果某些元素字段太宽，信息可能会错位。此外，您还可以使用
    CSV 文件将输出到另一个文件，用于许多其他用途。我让脚本直接输出数据，因为我的数据集不是很大，并且很容易在终端窗口中阅读。查看接下来的几节，它们基于解析
    CSV 文件的基本思想。
- en: CSV to XML
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSV 转换为 XML
- en: CSV to XML
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSV 转换为 XML
- en: csvToXML.rb
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: csvToXML.rb
- en: If you want to populate information to the Web, *Extensible Markup Language
    (XML)* is a good format to use. The reason XML is so cool is because the format
    enables different systems to share data using a common format that the developer
    can design. This script will take the information stored in a CSV file and, instead
    of just outputting the comments to the user's terminal, will produce an XML file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将信息填充到网络上，*可扩展标记语言 (XML)* 是一个很好的格式。XML之所以如此酷，是因为该格式允许不同的系统使用开发者设计的通用格式来共享数据。此脚本将读取CSV文件中存储的信息，而不是仅仅将注释输出到用户的终端，而是生成一个XML文件。
- en: The Code
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) require ''faster_csv''  ![](../Images/00003.jpg) print
    "CSV file to read: "  infile = gets.strip   print "What do you want to call each
    element: "  record_name = gets.strip   print "What do you want to title the XML
    document: "  title = gets.strip   print "What do you want to call the set of elements:
    "  set = gets.strip ![](../Images/00004.jpg) file = FasterCSV.open(infile, "rb")  ![](../Images/00005.jpg) header
    = file.shift  ![](../Images/00006.jpg) File.open(File.basename(infile, ".*") +
    ".xml", ''wb'') do |ofile| ![](../Images/00007.jpg)     ofile.puts ''<?xml version="1.0"?>''
         ofile.puts "<#{set}>"      ofile.puts "\t<name>#{title}</name>" ![](../Images/00008.jpg)  
      file.each do |record|        ofile.puts "\t<#{record_name}>" ![](../Images/00009.jpg)  
        for i in 0..(header.size - 1)          ofile.puts "\t\t<#{header[i]}>#{record[i]}</#{header[i]}>"
           end        ofile.puts "\t</#{record_name}>"      end      ofile.puts "</#{set}>"
     end`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`![图片](../Images/00002.jpg)require ''faster_csv'' ![图片](../Images/00003.jpg)print
    "CSV file to read: " infile = gets.strip ![图片](../Images/00004.jpg)print "What
    do you want to call each element: " record_name = gets.strip ![图片](../Images/00005.jpg)print
    "What do you want to title the XML document: " title = gets.strip ![图片](../Images/00006.jpg)print
    "What do you want to call the set of elements: " set = gets.strip ![图片](../Images/00007.jpg)file
    = FasterCSV.open(infile, "rb") ![图片](../Images/00008.jpg)header = file.shift ![图片](../Images/00009.jpg)File.open(File.basename(infile,
    ".*") + ".xml", ''wb'') do |ofile| ![图片](../Images/00010.jpg)   ofile.puts ''<?xml
    version="1.0"?>''   ofile.puts "<#{set}>"   ofile.puts "\t<name>#{title}</name>"
    ![图片](../Images/00011.jpg)   file.each do |record|       ofile.puts "\t<#{record_name}>"  
        for i in 0..(header.size - 1)           ofile.puts "\t\t<#{header[i]}>#{record[i]}</#{header[i]}>"  
        end       ofile.puts "\t</#{record_name}>"     end     ofile.puts "</#{set}>"
    end`'
- en: Running the Code
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'To run this script, type:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，请输入：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Results
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'The following is what you would find in the resulting XML file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将在生成的XML文件中找到的内容：
- en: '`<?xml version="1.0"?> <people>     <name>Employees at Wicked Cool Ruby</name>
        <names>         <first>Steve</first>         <last>Pugh</last>     </names>
        <names>         <first>John</first>         <last>Doe</last>     </names>
    </people>`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`<?xml version="1.0"?> <people>    <name>Employees at Wicked Cool Ruby</name>  
     <names>        <first>Steve</first>        <last>Pugh</last>    </names>    <names>  
         <first>John</first>        <last>Doe</last>    </names> </people>`'
- en: How It Works
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Changing gears a little bit on this script, we aren't going to pass any information
    into the script from the command line. Like some of the other scripts, this one
    will prompt the user for each piece of data needed to make a flawless conversion
    of the CSV file to an XML file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本上稍微改变一下方向，我们不会从命令行传递任何信息到脚本中。像其他一些脚本一样，这个脚本将提示用户输入每个需要的数据，以完美地将CSV文件转换为XML文件。
- en: Once again, the script is going to be utilizing the faster_csv library ![](../Images/00002.jpg).
    (If you need a refresher on the operations of faster_csv, see "#38 Comma-Separated
    Value Parser" on [Comma-Separated Value Parser](../Text/dummy_split_263.html#filepos510117).)
    Before the script even touches the CSV file, a few pieces of information need
    to be specified. To understand the reason for each variable, knowing the structure
    of an XML document helps. I'll direct you to research XML documents on your own
    ([http://www.w3.org/XML/Core/#Publications/](http://www.w3.org/XML/Core/#Publications/)).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，脚本将使用更快的_csv库 ![图片](../Images/00002.jpg)。 (如果你需要关于faster_csv操作的复习，请参阅[Comma-Separated
    Value Parser](../Text/dummy_split_263.html#filepos510117)中的“#38 Comma-Separated
    Value Parser”。) 在脚本接触CSV文件之前，需要指定一些信息。为了理解每个变量的原因，了解XML文档的结构很有帮助。我会指导你自行研究XML文档
    ([http://www.w3.org/XML/Core/#Publications/](http://www.w3.org/XML/Core/#Publications/))。
- en: The first user prompt will get the CSV file's name and store it in `infile`
    ![](../Images/00003.jpg). Next, `record_name` will hold the value of the element
    types. The XML file will also need a title, which is stored in the variable `title`.
    Finally, each element needs a set name, which will be stored in `set`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个用户提示将获取CSV文件的名称并存储在`infile` ![图片](../Images/00003.jpg)。接下来，`record_name`将保存元素类型的值。XML文件还需要一个标题，它存储在变量`title`中。最后，每个元素需要一个集合名称，它将存储在`set`中。
- en: Now, the script is ready to begin parsing the CSV file and creating the XML
    document from scratch. The first operation is to open the CSV file and store the
    `faster_csv` object in `file` ![](../Images/00004.jpg). The script assumes the
    header information is contained within the CSV file, so the header is popped off
    using the `shift` method and is stored in `header` ![](../Images/00005.jpg). Next,
    the XML file is created by using the base filename of the CSV file and appending
    the *.xml* extension. Using the typical XML version tag, the script begins creating
    the document ![](../Images/00006.jpg).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，脚本准备开始解析CSV文件并从头开始创建XML文档。第一个操作是打开CSV文件并将`faster_csv`对象存储在`file`中！![图片](../Images/00004.jpg)。脚本假设标题信息包含在CSV文件中，因此使用`shift`方法移除标题并存储在`header`中！![图片](../Images/00005.jpg)。接下来，通过使用CSV文件的基文件名并附加*.xml*扩展名来创建XML文件。使用典型的XML版本标签，脚本开始创建文档！![图片](../Images/00006.jpg)。
- en: Each element in the XML document will have an opening and a closing tag, so
    it is important for the script to close every tag that it opens. The `version`
    statement, set name, and document title are all output to the XML file, called
    `ofile` ![](../Images/00007.jpg). Next, each record is created ![](../Images/00008.jpg).
    Every line in the CSV file will be a record, and the header will determine how
    many elements are contained in each record. After the record tag is started, each
    element is tagged with the corresponding header name ![](../Images/00009.jpg).
    This process is repeated for every line in the CSV file. Once the CSV file has
    been completely processed, the script begins finalizing the closing tags. When
    the script exits, the XML will be fully formed and ready for incorporation into
    whatever you had in mind.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: XML文档中的每个元素都将有一个开标签和一个闭标签，因此脚本关闭它打开的每个标签是很重要的。`version`语句、设置名称和文档标题都将输出到名为`ofile`的XML文件中！![图片](../Images/00007.jpg)。接下来，每个记录将被创建！![图片](../Images/00008.jpg)。CSV文件中的每一行都是一个记录，并且标题将决定每个记录包含多少个元素。在开始记录标签之后，每个元素都会用相应的标题名称进行标记！![图片](../Images/00009.jpg)。这个过程会重复应用于CSV文件中的每一行。一旦CSV文件被完全处理，脚本开始最终化关闭标签。当脚本退出时，XML文件将完全形成，并准备好被整合到您所设想的内容中。
- en: Hacking the Script
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: The possibilities are endless when using an XML file. The first thing that comes
    to my mind is editing the script to deal with files that do not contain headers.
    See the previous CSV script for a head start. Another hack would be integration
    with a website using the XML file paired with a cascading style sheet (CSS) to
    format the output. You could set up a website to dynamically update based on the
    output of this little script. The result would be an XML file that, when combined
    with CSS and HTML, would produce a nice web page on the fly. Combine this script
    with "#30 Flash Cards" on [Flash Cards](../Text/dummy_split_210.html#filepos423382)
    for XML-style web-based flash cards.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用XML文件时，可能性是无限的。首先想到的是编辑脚本以处理不包含标题的文件。参见之前的CSV脚本以获得起点。另一个技巧是与网站集成，使用XML文件与层叠样式表（CSS）一起格式化输出。您可以设置一个网站，根据这个小脚本的输出动态更新。结果将是一个XML文件，当与CSS和HTML结合时，可以即时生成一个漂亮的网页。将此脚本与"#30
    Flash Cards"结合使用，在[Flash Cards](../Text/dummy_split_210.html#filepos423382)上创建基于XML风格的网页式闪卡。
- en: Ruby Grep
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby Grep
- en: Ruby Grep
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ruby Grep
- en: rubyGrep.rb
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rubyGrep.rb
- en: 'Imagine this scenario: You have hundreds of files in multiple directories stored
    on your hard drive—all of which are important and contain information related
    to a research project. As you''re consolidating your final report, you remember
    reading a figure from one of the papers, but you''re not sure which paper, much
    less which folder, it is in. What to do? Read through the files again? Yeah, right!
    The first thing to do is not worry! The second thing to do is get a copy of this
    script and run it. This script will allow you to automatically open files and
    read the contents, pinpointing the information you need with lightning speed.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这个场景：您在硬盘上的多个目录中存储了数百个文件——所有这些文件都很重要，并且包含与一个研究项目相关的信息。当您正在整合最终的报告时，您记得阅读了一篇论文中的一个图表，但您不确定它在哪篇论文中，更不用说它在哪个文件夹中了。怎么办？再次阅读文件？是的，没错！首先要做的是不要担心！第二件事是获取这个脚本的副本并运行它。这个脚本将允许您自动打开文件并读取内容，以闪电般的速度定位您所需的信息。
- en: The Code
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` require ''English'' ![](../Images/00002.jpg) unless ARGV[0]      puts "\nYou
    need to include a value to search for."      puts "Usage: ruby rubyGrep.rb \"value_to_search\"
    ''**/*''"      exit  end   pattern = ARGV[0]  glob = ARGV[1]  ![](../Images/00003.jpg) Dir[glob].each
    do |file|      next unless File.file?(file)![](../Images/00004.jpg)         File.open(file,
    "rb") do |f| ![](../Images/00005.jpg)             f.each_line do |line| ![](../Images/00006.jpg)
                     puts "#{File.expand_path(file)}: #{$INPUT_LINE_NUMBER}:  #{line}"
    if line.include?(pattern)          end      end  end`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '` require ''English'' ![](../Images/00002.jpg) unless ARGV[0]      puts "\nYou
    need to include a value to search for."      puts "Usage: ruby rubyGrep.rb \"value_to_search\"
    ''**/*''"      exit  end   pattern = ARGV[0]  glob = ARGV[1]  ![](../Images/00003.jpg) Dir[glob].each
    do |file|      next unless File.file?(file)![](../Images/00004.jpg)         File.open(file,
    "rb") do |f| ![](../Images/00005.jpg)             f.each_line do |line| ![](../Images/00006.jpg)
                     puts "#{File.expand_path(file)}: #{$INPUT_LINE_NUMBER}:  #{line}"
    if line.include?(pattern)          end      end  end`'
- en: Running the Code
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'To run this script, type:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，请输入：
- en: '``**`ruby rubyGrep.rb`** *`value_to_search where_to_search`* **`ruby rubyGrep.rb
    entropy ''*''`**``'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby rubyGrep.rb`** *`value_to_search where_to_search`* **`ruby rubyGrep.rb
    entropy ''*''`**``'
- en: The Results
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'For the purpose of this example, I searched a directory of Ruby scripts to
    find out which ones referred to the word *entropy*, which I used in the password
    strength testing script. I only had one script that contained any reference to
    *entropy*, and the search worked perfectly. The results are shown below:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本例的目的，我在Ruby脚本目录中搜索，以找出哪些脚本提到了单词*熵*，我在密码强度测试脚本中使用了这个单词。我只找到一个包含任何*熵*引用的脚本，搜索工作得非常完美。结果如下所示：
- en: '`C:/Steven.Pugh/Scripts/complete/password.rb: 22: entropy =  -1 * letters.keys.inject(0.to_f)
    do |sum, k| C:/Steven.Pugh/Scripts/complete/password.rb: 32: puts "\nThe entropy
    value is: #{entropy}"`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`C:/Steven.Pugh/Scripts/complete/password.rb: 22: entropy =  -1 * letters.keys.inject(0.to_f)
    do |sum, k| C:/Steven.Pugh/Scripts/complete/password.rb: 32: puts "\nThe entropy
    value is: #{entropy}"`'
- en: How It Works
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The elegance of this script is in its simplicity. Only one library is used,
    called English, and it supports the file output of line numbers. The script will
    run without the library, but the line numbers won't be included. The script first
    checks to ensure that both a search string and a location to search have been
    indicated ![](../Images/00002.jpg). Of course, if you search for nothing, you
    will find it every time, so ensure you include a meaningful search pattern.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的优雅之处在于其简洁性。它只使用了一个名为English的库，并且支持输出行号。即使没有这个库，脚本也可以运行，但不会包含行号。脚本首先检查是否已经指定了搜索字符串和搜索位置！[](../Images/00002.jpg)。当然，如果你什么也不搜索，你每次都会找到，所以请确保包含一个有意义的搜索模式。
- en: To begin searching through the directories, the library Dir is used to iterate
    through each file within the directory identified at `ARGV[1]` and saved in the
    `glob` variable ![](../Images/00003.jpg). The notation `'**/*'` is used to tell
    the `Dir` method that we want to recursively search through the current directory
    and every sub-directory, scanning for the pattern as we go. If you only wanted
    to search the current directory and not the subdirectories, you could supply `'*'`
    to the `Dir` method. The `each` method is referring to each file we find in the
    specified directory. Of course, if you wanted to narrow your search to HTML files,
    you could add an extension to the glob, such as `'*.html'`. This simple statement
    allows the script to manipulate every single file matching a specific criterion.
    Very powerful.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始搜索目录，使用库Dir遍历在`ARGV[1]`中指定的目录内的每个文件，并将其保存在`glob`变量中！[](../Images/00003.jpg)。使用`'**/*'`表示法告诉`Dir`方法，我们想要递归地搜索当前目录及其所有子目录，并在搜索过程中扫描模式。如果你只想搜索当前目录而不搜索子目录，你可以向`Dir`方法提供`'*'`。`each`方法指的是我们在指定目录中找到的每个文件。当然，如果你只想搜索HTML文件，你可以在glob中添加一个扩展名，例如`'*.html'`。这个简单的语句允许脚本操作符合特定标准的每个单个文件。非常强大。
- en: The script's next move is to decide what action to perform on each file. We
    already know we want to search for a specific string, so the script will need
    to open each file. The next block opens each file as read-only and passes the
    binary contents to the variable `f` ![](../Images/00004.jpg). The `each_line`
    method is then used to search the lines individually. The variable `line` holds
    the lines of data ![](../Images/00005.jpg). Then a lengthy line pulls all of the
    relevant data for display to the user ![](../Images/00006.jpg). We'll go through
    this line a bit more carefully. To read the line, we have to start with order
    of precedence, which is the last `if` statement in the line [`if line.include?(pattern)`].
    One important note is that if the `if` statement evaluates to `false`, meaning
    the pattern was not found, then the entire line is skipped. If the line includes
    the specified pattern, then the rest of this line of code is evaluated. To do
    so, we jump back to the beginning of the line, where the script expands the file
    path and displays the line number where the occurrence was found.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的下一步是决定对每个文件执行什么操作。我们已经知道我们想要搜索特定的字符串，因此脚本需要打开每个文件。接下来的代码块将每个文件以只读方式打开，并将二进制内容传递给变量
    `f` ![图片](../Images/00004.jpg)。然后使用 `each_line` 方法逐行搜索。变量 `line` 保存数据行 ![图片](../Images/00005.jpg)。然后一条长行会拉取所有相关数据以供用户显示
    ![图片](../Images/00006.jpg)。我们将更仔细地分析这条线。为了读取该行，我们必须从优先级顺序开始，即该行的最后一个 `if` 语句 [`if
    line.include?(pattern)`]。一个重要的注意事项是，如果 `if` 语句评估为 `false`，意味着没有找到模式，则整行将被跳过。如果该行包含指定的模式，则评估该行的其余代码。为了做到这一点，我们需要回到行的开头，脚本会扩展文件路径并显示找到发生的位置的行号。
- en: Keep in mind when running this script that the search can be as creative as
    you want it to be. If the files you're searching for happen to be in a higher
    directory or part of another branch, you'll need to take this into account when
    launching the script.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此脚本时请记住，搜索可以是多么有创意，只要你想。如果你要搜索的文件恰好位于更高的目录或另一个分支的一部分，你需要在启动脚本时考虑到这一点。
- en: Hacking the Script
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞脚本
- en: I've already mentioned a few places where you could hack this script as far
    as searching other file types and the placement of the script. This script can
    also be easily incorporated into other scripts or simply used by itself.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到了几个你可以修改此脚本的地方，比如搜索其他文件类型和脚本的位置。此脚本也可以轻松地集成到其他脚本中，或者单独使用。
- en: Password Check
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码检查
- en: Password Check
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码检查
- en: password.rb
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: password.rb
- en: Do you think your password is secure? Muahahaha!!! I'm just kidding; I don't
    know if your password is secure or not, but this script will give you a pretty
    good idea. It is based on mathematical proofs—and the numbers don't lie! Give
    this script a shot, making sure nobody is looking over your shoulder when you
    run it since your password won't be masked. Note that dictionary-based attacks
    aren't incorporated in the output; only entropy and brute force are addressed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为你的密码安全吗？哈哈哈！！！我只是在开玩笑；我不知道你的密码是否安全，但这个脚本会给你一个相当不错的想法。它基于数学证明——数字不会说谎！试试这个脚本，确保在运行时没有人从你身后偷看，因为你的密码不会被隐藏。请注意，输出中没有包含基于字典的攻击；只考虑了熵和暴力破解。
- en: The Code
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) unless ARGV[0]      puts "You need to include a password
    to test."      puts "Usage: ruby password.rb mySuperSecretPassword"      exit
     end  ![](../Images/00003.jpg) password = ARGV[0] ![](../Images/00004.jpg) word
    = password.split(//) ![](../Images/00005.jpg) letters = Hash.new(0.0) ![](../Images/00006.jpg) set_size
    = 96  ![](../Images/00007.jpg) word.each do |i|      letters[i] += 1.0  end  ![](../Images/00008.jpg) letters.keys.each
    do |j|      letters[j] /= word.length  end  ![](../Images/00009.jpg) entropy =
     -1 * letters.keys.inject(0.to_f) do |sum, k|      sum + (letters[k] * (Math.log(letters[k])/Math.log(2.to_f)))
     end  ![](../Images/00011.jpg) combinations = 96 ** password.length   days = combinations.to_f
    / (10000000 * 86400)   years = days / 365   puts "\nThe entropy value is: #{entropy}"
    ![](../Images/00012.jpg)  puts "\nAnd it will take ~ #{days <365 ? "#{days.to_i
    } days" : "#{years.to_i}  years"} to brute force the password"`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`![图片](../Images/00002.jpg) 除非 ARGV[0] puts "您需要包含一个密码进行测试。" puts "用法: ruby
    password.rb mySuperSecretPassword" exit  end ![图片](../Images/00003.jpg) password
    = ARGV[0] ![图片](../Images/00004.jpg) word = password.split(//) ![图片](../Images/00005.jpg) letters
    = Hash.new(0.0) ![图片](../Images/00006.jpg) set_size = 96 ![图片](../Images/00007.jpg) word.each
    do |i|     letters[i] += 1.0 end ![图片](../Images/00008.jpg) letters.keys.each
    do |j|     letters[j] /= word.length end ![图片](../Images/00009.jpg) entropy =
    -1 * letters.keys.inject(0.to_f) do |sum, k|     sum + (letters[k] * (Math.log(letters[k])/Math.log(2.to_f)))
    end ![图片](../Images/00011.jpg) combinations = 96 ** password.length   days = combinations.to_f
    / (10000000 * 86400)   years = days / 365   puts "\n熵值是：#{entropy}" ![图片](../Images/00012.jpg)  
    puts "\n并且需要大约 ~ #{days < 365 ? "#{days.to_i} 天" : "#{years.to_i} 年"} 来暴力破解密码"`'
- en: Running the Code
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'To run this script, type:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，请输入：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Results
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'I actually ran this script on the password *RubyScr1pt5*, and the results weren''t
    bad:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我实际上运行了这个脚本，密码是 *RubyScr1pt5*，结果还不错：
- en: '`The entropy value is: 3.4594316186373 And it will take ~ 20238436 years to
    brute force the password`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`熵值是：3.4594316186373 并且需要大约 ~ 20238436 年来暴力破解密码`'
- en: How It Works
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: This password script is really two concepts rolled together for one wicked cool
    script. The first is an entropy calculation, based on *Shannon entropy*. This
    script will calculate the measure of uncertainty in your password. If you don't
    like Greek letters or natural logarithms, you will be pleased to know I'm not
    going to prove the entropy calculation. If you really want to see the equation,
    it's below, but we'll presume the calculation is solid.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个密码脚本实际上是将两个概念结合在一起的一个非常酷的脚本。第一个是基于香农熵的熵计算。这个脚本将计算你密码的不确定性度量。如果你不喜欢希腊字母或自然对数，你会很高兴地知道我不会证明熵计算。如果你真的想看方程式，它下面有，但我们假设计算是可靠的。
- en: The second part of the script is based on how long a computer would need in
    order to brute force, or guess, your password. Several assumptions are made in
    the calculation; to ensure the script matches reality, you should review the math.
    I'll point out the places where you should focus your attention.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的第二部分基于计算机需要多长时间才能暴力破解或猜测你的密码。在计算中做了几个假设；为了确保脚本符合现实，你应该检查数学计算。我会指出你应该关注的地方。
- en: To begin, the script is run with a password as the first argument. As long as
    some password is included, the script will continue to analyze the password ![](../Images/00002.jpg).
    The first step is to initialize some variables used later on. The variable `password`
    will, naturally, contain the user's password ![](../Images/00003.jpg). The next
    variable, `word`, will contain an array of characters that make up the user's
    password ![](../Images/00004.jpg). This is accomplished using the ever-so-helpful
    method `split`. Since the Shannon entropy calculation deals with probabilities
    of each letter occurring, a hash is created that will hold one instance of every
    letter as the key and the corresponding probability that the letter will be chosen
    next as the value. This hash is called `letters` ![](../Images/00005.jpg). Note
    that this is very similar to "#37 Word Frequency" on [Word Frequency](../Text/dummy_split_256.html#filepos498947).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，脚本以密码作为第一个参数运行。只要包含密码，脚本就会继续分析密码 ![图片](../Images/00002.jpg)。第一步是初始化一些稍后使用的变量。变量
    `password` 将自然地包含用户的密码 ![图片](../Images/00003.jpg)。下一个变量 `word` 将包含构成用户密码的字符数组
    ![图片](../Images/00004.jpg)。这是通过非常有用的方法 `split` 实现的。由于香农熵的计算涉及每个字母出现的概率，因此创建了一个哈希，其中将包含每个字母的一个实例作为键，以及下一个字母被选中的相应概率作为值。这个哈希称为
    `letters` ![图片](../Images/00005.jpg)。请注意，这与[单词频率](../Text/dummy_split_256.html#filepos498947)中的“#37
    单词频率”非常相似。
- en: The final initialized variable is `set_size` ![](../Images/00006.jpg). The size
    of the set is important because it determines the length of time required to guess
    the user's password. I have the default set size at 96, which corresponds to a
    set of mixed uppercase and lowercase letters, numbers, and all of the common symbols
    on an American keyboard. You can use a set size of 62 for alphanumeric, 26 for
    only lowercase or only uppercase letters, and 10 for digits. Your set size is
    predetermined by your password policy.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后初始化的变量是`set_size` ![图片](../Images/00006.jpg)。集合的大小很重要，因为它决定了猜测用户密码所需的时间长度。我默认的集合大小是96，这对应于一个包含混合大小写字母、数字以及美国键盘上所有常见符号的集合。你可以使用62的集合大小用于字母数字，26用于仅包含小写或大写字母，10用于数字。你的集合大小由你的密码策略预先确定。
- en: To begin calculating the Shannon entropy, the hash `letters` is populated by
    counting each instance of a specific character ![](../Images/00007.jpg). Next,
    the values in each element of the hash are divided by the password length to calculate
    the probability that the letter will occur next ![](../Images/00008.jpg). The
    script now has all the information needed to calculate the measure of chaos in
    the password. Remember, the higher the chaos, the harder it is to guess the password.
    Also note that a password of *n* length consisting of the same symbol repeated
    over and over will have an entropy of 0\. In plain English, the Shannon entropy
    calculation is (negative one) multiplied by (the summation of each hash element's
    probability) multiplied by (the total of the natural logarithm of the hash element's
    probability) divided by (the natural logarithm of two) ![](../Images/00009.jpg).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始计算香农熵，通过计算每个特定字符的实例来填充哈希`letters` ![图片](../Images/00007.jpg)。接下来，将哈希中每个元素的值除以密码长度，以计算该字母出现的概率
    ![图片](../Images/00008.jpg)。现在脚本已经有了计算密码混乱程度的所需所有信息。记住，混乱程度越高，猜测密码就越困难。还要注意，由相同符号重复组成的长度为*n*的密码将具有0的熵。用简单的话说，香农熵的计算是（负一）乘以（每个哈希元素的概率之和）乘以（哈希元素概率的自然对数之和）除以（2的自然对数）
    ![图片](../Images/00009.jpg)。
- en: The reason the natural logarithm of the hash element's probability is divided
    by the natural logarithm of two is to account for the natural unit of information
    entropy. This division will calculate `log2` from another log base. Are you still
    with me? The calculation should have a number approximately between two and four
    stored in `entropy`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将哈希元素的概率的自然对数除以2的自然对数的原因是为了考虑信息熵的自然单位。这种除法将从一个对数底数计算出`log2`。你还在吗？计算结果应该在两到四之间，存储在`entropy`中。
- en: Now that the Shannon entropy of the user's password has been calculated, all
    that's left is to determine how long it would take to guess that password. The
    way to calculate this is to know how many guesses you will be making per second,
    then calculate how many possible combinations there are in the set size. In this
    script, given a password of a fixed size, say eight characters, then raise that
    to the power of the number of characters in the set. In this example, you would
    raise 96 to the power of 8, and the result will be stored in `combinations` ![](../Images/00011.jpg).
    Next, you need to multiply how many guesses the computer will be making per second
    by the number of seconds in a day (86,400 seconds in one day).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经计算出了用户密码的香农熵，剩下要确定的是猜测这个密码需要多长时间。计算这个值的方法是知道你每秒将进行多少次猜测，然后计算在集合大小中的可能组合数。在这个脚本中，给定一个固定大小的密码，比如说八个字符，然后将这个数字提高到集合中字符数的幂。在这个例子中，你会将96提高到8的幂，结果将存储在`combinations`中
    ![图片](../Images/00011.jpg)。接下来，你需要将计算机每秒将进行的猜测次数乘以一天中的秒数（一天有86,400秒）。
- en: '`combinations = 96 ** password.length  days = combinations.to_f / (10000000
    * 86400)  years = days / 365`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`combinations = 96 ** password.length  days = combinations.to_f / (10000000
    * 86400)  years = days / 365`'
- en: I assumed 10,000,000 tries per second, which would use a high-speed dual core
    processor. If you use any *field-programmable gate arrays (FPGAs)* like those
    found at [http://www.picocomputing.com/](http://www.picocomputing.com/), then
    the number of tries per second will be significantly increased.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设每秒10,000,000次尝试，这将使用高速双核处理器。如果你使用任何像[http://www.picocomputing.com/](http://www.picocomputing.com/)上找到的*现场可编程门阵列（FPGA）*，那么每秒的尝试次数将显著增加。
- en: Dividing the combinations by the number of guesses per day will result in the
    number of days needed to guess the user's password, which is stored in the variable
    `days`. You can then take the number of days and divide it by the number of days
    in a year (365) to get how many years it will take to guess the user's password;
    the output is stored in `years`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将组合数除以每天猜测的次数，将得到猜测用户密码所需的天数，该密码存储在变量 `days` 中。然后，你可以将天数除以一年中的天数（365），以得到猜测用户密码所需的时间（年数）；输出结果存储在
    `years` 中。
- en: The final output will be the entropy calculation and the length of time it would
    take to guess the user's password. For a more efficient output and because some
    passwords will be guessed in a matter of days, I used the ternary notation that
    says if the days are less than 365, then output the time in days; else output
    the time in years ![](../Images/00012.jpg). It's an elegant way to conditionally
    display the time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最终输出将是熵的计算和猜测用户密码所需的时间长度。为了更有效的输出，并且因为一些密码可能在几天内就被猜出，我使用了三元表示法，即如果天数少于365，则输出天数；否则输出年数
    ![图片](../Images/00012.jpg)。这是一种优雅的条件显示时间的方法。
- en: Hacking the Script
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: You can hack this script by obscuring the password and by incorporating the
    script into your password policy. An important aside is that password cracking
    is not limited to the techniques discussed above. Another major attack is a dictionary-based
    one. While the math works in our favor for strong passwords with a significant
    length, an attacker can use human predictability to gain some advantages when
    cracking passwords—choosing *password* as a password would be extremely easy for
    a dictionary attack to crack. Passwords are a big deal for security, so knowing
    how to measure the strength has many applications.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过隐藏密码并将脚本纳入你的密码策略来破解此脚本。一个重要的补充是，密码破解不仅限于上述讨论的技术。另一种主要攻击是基于字典的攻击。虽然对于具有显著长度的强密码，数学运算对我们有利，但攻击者可以利用人类可预测性在破解密码时获得一些优势——选择
    `password` 作为密码将非常容易受到字典攻击的破解。密码对于安全来说非常重要，因此了解如何衡量其强度有许多应用。
