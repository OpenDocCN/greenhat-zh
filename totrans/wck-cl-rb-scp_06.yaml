- en: Chapter 6. STRING UTILITIES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![STRING UTILITIES](../Images/00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Manipulating text with Ruby is easy; you have probably already seen Ruby's string
    methods like `capitalize`, `upcase`, `downcase`, and `swapcase`. In this chapter
    we will expand on those methods, creating an even more powerful toolset for text-processing
    tasks like searching, manipulating, and creating documents.
  prefs: []
  type: TYPE_NORMAL
- en: PDF Generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PDF Generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: pdfGen.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PDFs provide an excellent way to present data. Some advantages of using PDF
    *(Portable Document Format)* files include platform independence, viewing consistency,
    and a wide selection of free reader software. PDF files have become a standard
    for information exchange on the Internet; I even converted my resume to a PDF
    so potential employers would see exactly what I wanted them to see. This script
    will show you how to create your own PDF files without the need for expensive
    software.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) require ''pdf/writer''  require ''pdf/simpletable''  ![](../Images/00003.jpg) pdf
    = PDF::Writer.new  pdf.select_font("Times-Roman")  pdf.text("Review: Wicked Cool
    Ruby Scripts\n\n", :font_size => 25, :justification  => :center)  ![](../Images/00004.jpg) PDF::SimpleTable.new
    do |table|      table.column_order = %w(question response)       table.columns["question"]
    = PDF::SimpleTable::Column.new("question") do |col|          col.heading = "Question"
             col.width = 100      end      table.columns["response"] = PDF::SimpleTable::Column.new("response")
    do |col|          col.heading = "Response"      end       table.show_lines    =
    :all      table.show_headings = false      table.shade_rows    = :none      table.orientation
      = :center      table.position      = :center      table.width         = 400  ![](../Images/00005.jpg)  
      data = [          {"question" => "Reviewer:"},          {"question" => "Title:",
    "response" => "Wicked Cool Ruby Scripts"},          {"question" => "Author:",
    "response" => "Steve Pugh"},          {"question" => "Publisher & Year:", "response"
    => "No Starch Press, 2009"},          {"question" => "ISBN:"},          {"question"
    => "Genre Category:", "response" => "Programming Languages:  Ruby"},         
    ]      table.data.replace data      table.render_on(pdf)  end  ![](../Images/00006.jpg)
     pdf.text("\n\n1\.  Did this book teach you anything about scripting in Ruby (circle
     one)?" , :font_size => 14)  pdf.text("\n    Yes   No     Why or why not?____________________________")
     pdf.text("\n2\.  Are the example scripts appropriate and are they explained well?")
     pdf.text("\n    Yes   No     Why or why not?____________________________")  pdf.text("\n3\.
     Would you recommend this book to another person?  Why or why not?")  pdf.text("
       ________________________________________________________________")  pdf.text("
       ________________________________________________________________")  pdf.text("\n4\.
     List three adjectives that describe this book:")  pdf.text("    a._______________
     b._______________ c._______________")  pdf.text("\n5\.  Write any additional
    information you would like to share here:")  pdf.text("    ________________________________________________________________")
     pdf.text("    ________________________________________________________________")
     pdf.text("    ________________________________________________________________")
     pdf.text("    ________________________________________________________________")
     pdf.text("    ________________________________________________________________")
     pdf.text("\n6\.  Overall rating: Check one (0=Horrible, 5=Wicked Cool):")  pdf.text("
             0          1          2          3          4          5") ![](../Images/00007.jpg) pdf.circle_at(66,
    pdf.y+5, 5).stroke  pdf.circle_at(121, pdf.y+5, 5).stroke  pdf.circle_at(170,
    pdf.y+5, 5).stroke  pdf.circle_at(219, pdf.y+5, 5).stroke  pdf.circle_at(268,
    pdf.y+5, 5).stroke  pdf.circle_at(316, pdf.y+5, 5).stroke  ![](../Images/00008.jpg) pdf.save_as(''book_review.pdf'')`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run this script, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby pdfGen.rb`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After executing the script, look for a PDF file called *book_review.pdf*. The
    file's contents will look like the form shown in [Figure 6-1](#filepos493098).
  prefs: []
  type: TYPE_NORMAL
- en: '![The contents of book_review.pdf](../Images/00016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1. The contents of book_review.pdf
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this script, we rely on the PDF:Writer library to turn regular text into
    a PDF. This is available as a gem, so you can easily install it using the command
    `gem install pdf-writer`. To begin the script, we include `pdf/writer`, to later
    create the PDF file, and `pdf/simpletable`, because we will be adding a table
    to the document ![](../Images/00002.jpg). Next, the `PDF` object is created and
    saved to a variable called `pdf` ![](../Images/00003.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: We are creating a form that will be used to retrieve valuable customer feedback
    information about this book. The default text font for the PDF:Writer library
    is Times New Roman, and I've explicitly coded the font as a reminder that the
    fonts can be changed. You can change this to `Courier`, `Helvetica`, or `Times-Roman`.
    We add a title to the PDF document and set the font to 25-point, so that it will
    be distinguishable from the rest of the text. The next area of the PDF file will
    be a table that contains information specific to the book.
  prefs: []
  type: TYPE_NORMAL
- en: We create a `SimpleTable` object followed by a code block that will populate
    the table with data ![](../Images/00004.jpg). While a table can have as many columns
    and rows as needed, we will be using two columns, titled *Question* and *Response*.
    In order to make the table more aesthetically appealing and to give customers
    more room to respond to each question, I've set the `question` width (the minimum
    character width needed to frame each question without wasting space in the question
    column) to `100`. The rest of the table will be used for customer responses. Six
    table attributes are customized, and thanks to Ruby's easily unambiguous naming
    convention, the customizations are matched with the method names. The attributes
    will determine how the finalized table will look. The section of code following
    the table attributes is where the questions are initialized in the table ![](../Images/00005.jpg).
    The last step in the table creation is to render it. The table is rendered into
    the `pdf` variable using the `render_on` method.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the table has been created, the script begins asking several questions,
    all with different expected types of answers ![](../Images/00006.jpg). One noteworthy
    aspect of the question section is the circles that are created using the `circle_at`
    method ![](../Images/00007.jpg). The method requires three arguments. The first
    two are the starting coordinates in the (*x*, *y*) format. The third argument
    is the radius of the circle. The drawing pointer is at the end of the document
    when the first `circle_at` is called. To get the circles to move higher by one
    line, the y-coordinate is set to `pdf.y+5`. The x-coordinate is increased to match
    the corresponding numbers *0* through *5*. To save all the hard work we—I mean
    Ruby—has done, we call the `save_as` method, which does exactly what it claims
    ![](../Images/00008.jpg). The document is saved as *book_review.pdf*.
  prefs: []
  type: TYPE_NORMAL
- en: Word Frequency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Word Frequency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: wordFreq.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This script will scan a text file and count the number of times each word appears
    in the document. There are several reasons to extract word counts, or word frequencies,
    from a document. One example is for the cryptographic analysis of a cipher text
    that has been encrypted with a shift cipher. I find word frequency to be interesting
    in my own writing, too. Running this script shows me which words I use most often
    and, with a few tweaks, can show those that are not part of my daily vocabulary.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) unless ARGV[0]      puts "\nYou need to include a
    file to test."      puts "Usage: ruby wordFreq.rb file_to_test.txt"      exit
     end  ![](../Images/00003.jpg) unless File.exist?(ARGV[0])      puts "\nThe file
    could not be found, check the path."      puts "Usage: ruby wordFreq.rb file_to_test.txt"
         exit  end   file = ARGV[0]  words = Hash.new(0) ![](../Images/00004.jpg) File.open(file,
    "r").each_line do |line| ![](../Images/00005.jpg)     line.scan(/\b\w+\b/) {|i|
    words[i] += 1}  end  ![](../Images/00006.jpg) sorted = words.sort_by {|a| a[1]
    }   temp = sorted.length  ![](../Images/00007.jpg) 10.times do      temp -= 1
         puts "\"#{sorted[temp][0]}\" has #{sorted[temp][1]} occurrences"  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute this script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I ran this script against the first chapter of this book just to see what would
    happen. I thought *Ruby* might be one of the top hits, but aside from the usual
    suspects (e.g., *the*, *to*, and *is*), the word *script* managed to sneak onto
    the list of top 10 words used. Who would have known?
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The results are output to $stdout, but you could just as easily have them output
    to a text file or a PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"the" has 513 occurrences "to" has 156 occurrences "is" has 128 occurrences
    "script" has 126 occurrences "a" has 118 occurrences "file" has 107 occurrences
    "and" has 94 occurrences "you" has 87 occurrences "of" has 81 occurrences "in"
    has 70 occurrences`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script begins with a check to make sure the user has entered a filename
    for word frequency analysis ![](../Images/00002.jpg). Next, the script checks
    to ensure the filename that was passed actually is a file and also that the file
    is reachable ![](../Images/00003.jpg). After creating a `file` object from the
    first argument and initializing a hash called `words`, the file is opened and
    each line is read into a block ![](../Images/00004.jpg). Although there is only
    one line in the block, there are many different actions taking place within that
    single line. The wicked cool part about the multiple actions taking place is that
    they have been condensed to one line, yet they are still easily readable by humans
    ![](../Images/00005.jpg). For each line in the file, the contents are *parsed*,
    or scanned, using the `scan` method. Since the script is tracking the occurrences
    of each word, this method allows the script to isolate individual words. This
    method will pass each word that matches the regular expression to another block
    (also located on the same line). Interestingly enough, the matches can simply
    be put into an array if no block was needed. But, since we needed to do some more
    manipulation, we tacked a block onto the end of the line.
  prefs: []
  type: TYPE_NORMAL
- en: For each word passed to the block, the `words` hash is referenced, and the key
    is incremented by one if the word exists. If the word has not been encountered
    before, then the value is initialized and the key set to a count of one. Populating
    a hash table, in one line of code, based on the occurrences of every single word
    in a file is slick. Perhaps you've come across the term *histogram* in a math
    or statistics class? Well this script makes a simple histogram that shows the
    proportion of words used in a given file.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the `words` hash is completely populated, and all that's left
    to do is output the significant information. The script orders the values in `words`
    based on the keys using a nice little method called `sort_by`, which is part of
    the Enumerable library. The `sort_by` method will sort the respective hash and
    return a multidimensional array with arrays containing the key and value for each
    element in the original hash ![](../Images/00006.jpg). The final block prints
    the last 10 arrays of the multidimensional array; this corresponds to the 10 words
    that occur most often in the text file ![](../Images/00007.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest hack would be to convert the script to analyze letters in the text
    file. Letter frequency is also used for cryptographic analysis. A simple search
    on Google will reveal that the most widely used letter in English is *e*.
  prefs: []
  type: TYPE_NORMAL
- en: A slightly different approach would be the addition of *stop words*. Stop words
    are words that are removed prior to displaying the results. You could remove common
    terms like *the*, *to*, *is*, *of*, *as*, and so on. Also, this script could be
    the simple beginnings of a Bayesian spam filter. Bayesian spam filters are powerful
    because they identify words that occur in spam and build a profile from these.
    I'm sure you can think of one or two words that are common in spam messages …
    something to do with enlarging this or free that. Profiling spam is one tool for
    helping users get legitimate email.
  prefs: []
  type: TYPE_NORMAL
- en: Comma-Separated Value Parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comma-Separated Value Parser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: csv.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comma-separated value (CSV) files are very prevalent in our digital world. They
    are used everywhere, and many programs have functions to input or output information
    in the CSV format. Even Microsoft supports CSV in the majority of its products!
  prefs: []
  type: TYPE_NORMAL
- en: 'This script will show you how to customize data output once it has been delimited
    by commas in a CSV file. This will lead to more meaningful interpretation of the
    data. Two libraries can help you work with CSV files: The first is the old standard
    Ruby CSV library, and the second is a library called FasterCSV. I will show you
    how to use FasterCSV and seamlessly integrate it into your scripts. Just note
    that when you upgrade past 1.8, FasterCSV will be incorporated into the standard
    library. The usage is very similar between both libraries; if you ever find yourself
    needing to upgrade or read old Ruby CSV code, you shouldn''t worry at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have hacked our own CSV library using the `split` method; but since
    you''ve seen other scripts with `split`, we''ll introduce something new and more
    efficient. To put this script in perspective, suppose you have a financial CSV
    file output by some hyper-state-of-the-art financial analysis software, like Excel
    or QuickBooks. You''ve got to figure out what to do with the data, so your first
    thought is to consult Ruby! Here''s what *easy* looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require ''faster_csv''  ![](../Images/00002.jpg) unless ARGV[0]      puts
    "Usage: ruby csv.rb <filename.ext>"      puts "Example: ruby csv.rb comma.separated"
         exit  end   unless File.exist?(ARGV[0])      puts "\nThe file could not be
    found, check the path."      puts "Usage: ruby csv.rb comma.separated"      exit
     end  ![](../Images/00003.jpg) file = FasterCSV.open(ARGV[0], "r")   print "Does
    the file include header information (y/n)? " ![](../Images/00004.jpg) h = $stdin.gets.chomp   if
    h.downcase == ''y'' ![](../Images/00005.jpg)     header = file.shift      print
    header.join("\t")  ![](../Images/00006.jpg)     file.each do |line|          puts
             print line.join("\t")      end  else ![](../Images/00007.jpg)     print
    "Enter header information (separated by commas): "      header = $stdin.gets.strip
         header = header.split(",") ![](../Images/00008.jpg)     header.each do |h|
             print h + "\t"      end       file.each do |line|          puts     
        line.each do |element|              print element + "\t"          end     
    end  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the script by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test this script, I downloaded a CSV file from a financial reporting website
    that contained information about Google. The results display the first few days
    in 2004 that Google was publicly traded. The company has become immensely profitable
    since then, but this shows the value of Google when it started.
  prefs: []
  type: TYPE_NORMAL
- en: '`Date        Open       High       Low        Close      Volume 2004-09-01
     102.70     102.97     99.67      100.25     4573700 2004-08-31  102.30     103.71
        102.16     102.37     2461400 2004-08-30  105.28     105.49     102.01    
    102.01     2601000 2004-08-27  108.10     108.62     105.69     106.15     3109000
    2004-08-26  104.95     107.95     104.66     107.91     3551000 2004-08-25  104.96
        108.00     103.88     106.00     4598900 2004-08-24  111.24     111.60    
    103.57     104.87     7631300 2004-08-23  110.75     113.48     109.05     109.40
        9137200 2004-08-20  101.01     109.08     100.50     108.31     11428600 2004-08-19
     100.00     104.06     95.96      100.34     22351900`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script is written with two types of CSV files in mind: a file with the
    header on the first line and a file with pure data. The script takes a CSV file
    as the only argument, and the file''s existence is first checked to ensure proper
    execution ![](../Images/00002.jpg). Next, the script opens the file using the
    faster_csv library ![](../Images/00003.jpg). After the file has been opened, the
    script asks the user about header info in order to determine which section of
    code to follow ![](../Images/00004.jpg). If the file does contain header information,
    the first part of the `if` statement is executed. Assuming the CSV file contains
    a header, the first task is to remove the header so that faster_csv can work its
    magic. The header is removed with the `shift` method, and the value is stored
    in the variable `header` ![](../Images/00005.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: After the header has been parsed, the script moves on to the meat of the CSV
    file. If you recall from before, we initialized the variable `file` as a FasterCSV
    object that reads in the CSV file to be parsed. Getting back to basics for a moment,
    each line contains data that may or may not have every field populated. The FasterCSV
    library's syntax is great because the code is so similar to every other file manipulation
    script. A block of code that outputs a line break for every line within the CSV
    file is declared. Then, for each element in the line, the output ends with a tab
    for a clean display ![](../Images/00006.jpg). Not too complicated. The FasterCSV
    library makes handling CSV files a breeze, and that ends the first path.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a raw CSV file without any headers, perhaps you want to add your
    own headers for ease of use or readability. If that is the case, then you would
    answer **`no`** to the question asking about headers. Then the script knows to
    ask for the header names rather than trying to read them off the CSV file ![](../Images/00007.jpg).
    The user then enters each header separated by a comma. After the headers are created,
    the rest of the script runs, just like the previous path ![](../Images/00008.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There aren't many hacks to this script because of its simplicity, but there
    are two things that would be a good exercise in Ruby coding. The first is condensing
    the script while still maintaining readability. The first place to look would
    be where the header is parsed. Another equally beneficial exercise would be to
    format the output to handle a variety of cases. As it stands now, with tabs, the
    information could be out of alignment if some of the element fields are too wide.
    Additionally, you could use the CSV file to output to another file for many other
    uses. I have the script outputting the data directly because my data sets weren't
    too large and were easy to read in a terminal window. Check out the next few sections,
    which build on this basic idea of parsing CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: CSV to XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSV to XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: csvToXML.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to populate information to the Web, *Extensible Markup Language
    (XML)* is a good format to use. The reason XML is so cool is because the format
    enables different systems to share data using a common format that the developer
    can design. This script will take the information stored in a CSV file and, instead
    of just outputting the comments to the user's terminal, will produce an XML file.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) require ''faster_csv''  ![](../Images/00003.jpg) print
    "CSV file to read: "  infile = gets.strip   print "What do you want to call each
    element: "  record_name = gets.strip   print "What do you want to title the XML
    document: "  title = gets.strip   print "What do you want to call the set of elements:
    "  set = gets.strip ![](../Images/00004.jpg) file = FasterCSV.open(infile, "rb")  ![](../Images/00005.jpg) header
    = file.shift  ![](../Images/00006.jpg) File.open(File.basename(infile, ".*") +
    ".xml", ''wb'') do |ofile| ![](../Images/00007.jpg)     ofile.puts ''<?xml version="1.0"?>''
         ofile.puts "<#{set}>"      ofile.puts "\t<name>#{title}</name>" ![](../Images/00008.jpg)  
      file.each do |record|        ofile.puts "\t<#{record_name}>" ![](../Images/00009.jpg)  
        for i in 0..(header.size - 1)          ofile.puts "\t\t<#{header[i]}>#{record[i]}</#{header[i]}>"
           end        ofile.puts "\t</#{record_name}>"      end      ofile.puts "</#{set}>"
     end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run this script, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is what you would find in the resulting XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<?xml version="1.0"?> <people>     <name>Employees at Wicked Cool Ruby</name>
        <names>         <first>Steve</first>         <last>Pugh</last>     </names>
        <names>         <first>John</first>         <last>Doe</last>     </names>
    </people>`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Changing gears a little bit on this script, we aren't going to pass any information
    into the script from the command line. Like some of the other scripts, this one
    will prompt the user for each piece of data needed to make a flawless conversion
    of the CSV file to an XML file.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the script is going to be utilizing the faster_csv library ![](../Images/00002.jpg).
    (If you need a refresher on the operations of faster_csv, see "#38 Comma-Separated
    Value Parser" on [Comma-Separated Value Parser](../Text/dummy_split_263.html#filepos510117).)
    Before the script even touches the CSV file, a few pieces of information need
    to be specified. To understand the reason for each variable, knowing the structure
    of an XML document helps. I'll direct you to research XML documents on your own
    ([http://www.w3.org/XML/Core/#Publications/](http://www.w3.org/XML/Core/#Publications/)).
  prefs: []
  type: TYPE_NORMAL
- en: The first user prompt will get the CSV file's name and store it in `infile`
    ![](../Images/00003.jpg). Next, `record_name` will hold the value of the element
    types. The XML file will also need a title, which is stored in the variable `title`.
    Finally, each element needs a set name, which will be stored in `set`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the script is ready to begin parsing the CSV file and creating the XML
    document from scratch. The first operation is to open the CSV file and store the
    `faster_csv` object in `file` ![](../Images/00004.jpg). The script assumes the
    header information is contained within the CSV file, so the header is popped off
    using the `shift` method and is stored in `header` ![](../Images/00005.jpg). Next,
    the XML file is created by using the base filename of the CSV file and appending
    the *.xml* extension. Using the typical XML version tag, the script begins creating
    the document ![](../Images/00006.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Each element in the XML document will have an opening and a closing tag, so
    it is important for the script to close every tag that it opens. The `version`
    statement, set name, and document title are all output to the XML file, called
    `ofile` ![](../Images/00007.jpg). Next, each record is created ![](../Images/00008.jpg).
    Every line in the CSV file will be a record, and the header will determine how
    many elements are contained in each record. After the record tag is started, each
    element is tagged with the corresponding header name ![](../Images/00009.jpg).
    This process is repeated for every line in the CSV file. Once the CSV file has
    been completely processed, the script begins finalizing the closing tags. When
    the script exits, the XML will be fully formed and ready for incorporation into
    whatever you had in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The possibilities are endless when using an XML file. The first thing that comes
    to my mind is editing the script to deal with files that do not contain headers.
    See the previous CSV script for a head start. Another hack would be integration
    with a website using the XML file paired with a cascading style sheet (CSS) to
    format the output. You could set up a website to dynamically update based on the
    output of this little script. The result would be an XML file that, when combined
    with CSS and HTML, would produce a nice web page on the fly. Combine this script
    with "#30 Flash Cards" on [Flash Cards](../Text/dummy_split_210.html#filepos423382)
    for XML-style web-based flash cards.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby Grep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ruby Grep
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: rubyGrep.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine this scenario: You have hundreds of files in multiple directories stored
    on your hard drive—all of which are important and contain information related
    to a research project. As you''re consolidating your final report, you remember
    reading a figure from one of the papers, but you''re not sure which paper, much
    less which folder, it is in. What to do? Read through the files again? Yeah, right!
    The first thing to do is not worry! The second thing to do is get a copy of this
    script and run it. This script will allow you to automatically open files and
    read the contents, pinpointing the information you need with lightning speed.'
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '` require ''English'' ![](../Images/00002.jpg) unless ARGV[0]      puts "\nYou
    need to include a value to search for."      puts "Usage: ruby rubyGrep.rb \"value_to_search\"
    ''**/*''"      exit  end   pattern = ARGV[0]  glob = ARGV[1]  ![](../Images/00003.jpg) Dir[glob].each
    do |file|      next unless File.file?(file)![](../Images/00004.jpg)         File.open(file,
    "rb") do |f| ![](../Images/00005.jpg)             f.each_line do |line| ![](../Images/00006.jpg)
                     puts "#{File.expand_path(file)}: #{$INPUT_LINE_NUMBER}:  #{line}"
    if line.include?(pattern)          end      end  end`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run this script, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**`ruby rubyGrep.rb`** *`value_to_search where_to_search`* **`ruby rubyGrep.rb
    entropy ''*''`**``'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the purpose of this example, I searched a directory of Ruby scripts to
    find out which ones referred to the word *entropy*, which I used in the password
    strength testing script. I only had one script that contained any reference to
    *entropy*, and the search worked perfectly. The results are shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '`C:/Steven.Pugh/Scripts/complete/password.rb: 22: entropy =  -1 * letters.keys.inject(0.to_f)
    do |sum, k| C:/Steven.Pugh/Scripts/complete/password.rb: 32: puts "\nThe entropy
    value is: #{entropy}"`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The elegance of this script is in its simplicity. Only one library is used,
    called English, and it supports the file output of line numbers. The script will
    run without the library, but the line numbers won't be included. The script first
    checks to ensure that both a search string and a location to search have been
    indicated ![](../Images/00002.jpg). Of course, if you search for nothing, you
    will find it every time, so ensure you include a meaningful search pattern.
  prefs: []
  type: TYPE_NORMAL
- en: To begin searching through the directories, the library Dir is used to iterate
    through each file within the directory identified at `ARGV[1]` and saved in the
    `glob` variable ![](../Images/00003.jpg). The notation `'**/*'` is used to tell
    the `Dir` method that we want to recursively search through the current directory
    and every sub-directory, scanning for the pattern as we go. If you only wanted
    to search the current directory and not the subdirectories, you could supply `'*'`
    to the `Dir` method. The `each` method is referring to each file we find in the
    specified directory. Of course, if you wanted to narrow your search to HTML files,
    you could add an extension to the glob, such as `'*.html'`. This simple statement
    allows the script to manipulate every single file matching a specific criterion.
    Very powerful.
  prefs: []
  type: TYPE_NORMAL
- en: The script's next move is to decide what action to perform on each file. We
    already know we want to search for a specific string, so the script will need
    to open each file. The next block opens each file as read-only and passes the
    binary contents to the variable `f` ![](../Images/00004.jpg). The `each_line`
    method is then used to search the lines individually. The variable `line` holds
    the lines of data ![](../Images/00005.jpg). Then a lengthy line pulls all of the
    relevant data for display to the user ![](../Images/00006.jpg). We'll go through
    this line a bit more carefully. To read the line, we have to start with order
    of precedence, which is the last `if` statement in the line [`if line.include?(pattern)`].
    One important note is that if the `if` statement evaluates to `false`, meaning
    the pattern was not found, then the entire line is skipped. If the line includes
    the specified pattern, then the rest of this line of code is evaluated. To do
    so, we jump back to the beginning of the line, where the script expands the file
    path and displays the line number where the occurrence was found.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind when running this script that the search can be as creative as
    you want it to be. If the files you're searching for happen to be in a higher
    directory or part of another branch, you'll need to take this into account when
    launching the script.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I've already mentioned a few places where you could hack this script as far
    as searching other file types and the placement of the script. This script can
    also be easily incorporated into other scripts or simply used by itself.
  prefs: []
  type: TYPE_NORMAL
- en: Password Check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Password Check
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: password.rb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do you think your password is secure? Muahahaha!!! I'm just kidding; I don't
    know if your password is secure or not, but this script will give you a pretty
    good idea. It is based on mathematical proofs—and the numbers don't lie! Give
    this script a shot, making sure nobody is looking over your shoulder when you
    run it since your password won't be masked. Note that dictionary-based attacks
    aren't incorporated in the output; only entropy and brute force are addressed.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`![](../Images/00002.jpg) unless ARGV[0]      puts "You need to include a password
    to test."      puts "Usage: ruby password.rb mySuperSecretPassword"      exit
     end  ![](../Images/00003.jpg) password = ARGV[0] ![](../Images/00004.jpg) word
    = password.split(//) ![](../Images/00005.jpg) letters = Hash.new(0.0) ![](../Images/00006.jpg) set_size
    = 96  ![](../Images/00007.jpg) word.each do |i|      letters[i] += 1.0  end  ![](../Images/00008.jpg) letters.keys.each
    do |j|      letters[j] /= word.length  end  ![](../Images/00009.jpg) entropy =
     -1 * letters.keys.inject(0.to_f) do |sum, k|      sum + (letters[k] * (Math.log(letters[k])/Math.log(2.to_f)))
     end  ![](../Images/00011.jpg) combinations = 96 ** password.length   days = combinations.to_f
    / (10000000 * 86400)   years = days / 365   puts "\nThe entropy value is: #{entropy}"
    ![](../Images/00012.jpg)  puts "\nAnd it will take ~ #{days <365 ? "#{days.to_i
    } days" : "#{years.to_i}  years"} to brute force the password"`'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run this script, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I actually ran this script on the password *RubyScr1pt5*, and the results weren''t
    bad:'
  prefs: []
  type: TYPE_NORMAL
- en: '`The entropy value is: 3.4594316186373 And it will take ~ 20238436 years to
    brute force the password`'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This password script is really two concepts rolled together for one wicked cool
    script. The first is an entropy calculation, based on *Shannon entropy*. This
    script will calculate the measure of uncertainty in your password. If you don't
    like Greek letters or natural logarithms, you will be pleased to know I'm not
    going to prove the entropy calculation. If you really want to see the equation,
    it's below, but we'll presume the calculation is solid.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the script is based on how long a computer would need in
    order to brute force, or guess, your password. Several assumptions are made in
    the calculation; to ensure the script matches reality, you should review the math.
    I'll point out the places where you should focus your attention.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, the script is run with a password as the first argument. As long as
    some password is included, the script will continue to analyze the password ![](../Images/00002.jpg).
    The first step is to initialize some variables used later on. The variable `password`
    will, naturally, contain the user's password ![](../Images/00003.jpg). The next
    variable, `word`, will contain an array of characters that make up the user's
    password ![](../Images/00004.jpg). This is accomplished using the ever-so-helpful
    method `split`. Since the Shannon entropy calculation deals with probabilities
    of each letter occurring, a hash is created that will hold one instance of every
    letter as the key and the corresponding probability that the letter will be chosen
    next as the value. This hash is called `letters` ![](../Images/00005.jpg). Note
    that this is very similar to "#37 Word Frequency" on [Word Frequency](../Text/dummy_split_256.html#filepos498947).
  prefs: []
  type: TYPE_NORMAL
- en: The final initialized variable is `set_size` ![](../Images/00006.jpg). The size
    of the set is important because it determines the length of time required to guess
    the user's password. I have the default set size at 96, which corresponds to a
    set of mixed uppercase and lowercase letters, numbers, and all of the common symbols
    on an American keyboard. You can use a set size of 62 for alphanumeric, 26 for
    only lowercase or only uppercase letters, and 10 for digits. Your set size is
    predetermined by your password policy.
  prefs: []
  type: TYPE_NORMAL
- en: To begin calculating the Shannon entropy, the hash `letters` is populated by
    counting each instance of a specific character ![](../Images/00007.jpg). Next,
    the values in each element of the hash are divided by the password length to calculate
    the probability that the letter will occur next ![](../Images/00008.jpg). The
    script now has all the information needed to calculate the measure of chaos in
    the password. Remember, the higher the chaos, the harder it is to guess the password.
    Also note that a password of *n* length consisting of the same symbol repeated
    over and over will have an entropy of 0\. In plain English, the Shannon entropy
    calculation is (negative one) multiplied by (the summation of each hash element's
    probability) multiplied by (the total of the natural logarithm of the hash element's
    probability) divided by (the natural logarithm of two) ![](../Images/00009.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: The reason the natural logarithm of the hash element's probability is divided
    by the natural logarithm of two is to account for the natural unit of information
    entropy. This division will calculate `log2` from another log base. Are you still
    with me? The calculation should have a number approximately between two and four
    stored in `entropy`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Shannon entropy of the user's password has been calculated, all
    that's left is to determine how long it would take to guess that password. The
    way to calculate this is to know how many guesses you will be making per second,
    then calculate how many possible combinations there are in the set size. In this
    script, given a password of a fixed size, say eight characters, then raise that
    to the power of the number of characters in the set. In this example, you would
    raise 96 to the power of 8, and the result will be stored in `combinations` ![](../Images/00011.jpg).
    Next, you need to multiply how many guesses the computer will be making per second
    by the number of seconds in a day (86,400 seconds in one day).
  prefs: []
  type: TYPE_NORMAL
- en: '`combinations = 96 ** password.length  days = combinations.to_f / (10000000
    * 86400)  years = days / 365`'
  prefs: []
  type: TYPE_NORMAL
- en: I assumed 10,000,000 tries per second, which would use a high-speed dual core
    processor. If you use any *field-programmable gate arrays (FPGAs)* like those
    found at [http://www.picocomputing.com/](http://www.picocomputing.com/), then
    the number of tries per second will be significantly increased.
  prefs: []
  type: TYPE_NORMAL
- en: Dividing the combinations by the number of guesses per day will result in the
    number of days needed to guess the user's password, which is stored in the variable
    `days`. You can then take the number of days and divide it by the number of days
    in a year (365) to get how many years it will take to guess the user's password;
    the output is stored in `years`.
  prefs: []
  type: TYPE_NORMAL
- en: The final output will be the entropy calculation and the length of time it would
    take to guess the user's password. For a more efficient output and because some
    passwords will be guessed in a matter of days, I used the ternary notation that
    says if the days are less than 365, then output the time in days; else output
    the time in years ![](../Images/00012.jpg). It's an elegant way to conditionally
    display the time.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can hack this script by obscuring the password and by incorporating the
    script into your password policy. An important aside is that password cracking
    is not limited to the techniques discussed above. Another major attack is a dictionary-based
    one. While the math works in our favor for strong passwords with a significant
    length, an attacker can use human predictability to gain some advantages when
    cracking passwords—choosing *password* as a password would be extremely easy for
    a dictionary attack to crack. Passwords are a big deal for security, so knowing
    how to measure the strength has many applications.
  prefs: []
  type: TYPE_NORMAL
