- en: Part II-6. IP SUPPORT PROTOCOLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 31](ch31.html "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 32](ch32.html "Chapter 32. ICMPV4 ERROR MESSAGE TYPES AND FORMATS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 33](ch33.html "Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND
    FORMATS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 34](ch34.html "Chapter 34. ICMPV6 ERROR MESSAGE TYPES AND FORMATS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 35](ch35.html "Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND
    FORMATS")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 36](ch36.html "Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL")'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Internet Protocol (IP) is the key network layer protocol that implements
    the TCP/IP protocol suite. Since IP is the protocol that provides the mechanism
    for delivering datagrams between devices, it is designed to be relatively basic.
    For example, it lacks provisions for some way to allow errors to be reported back
    to a transmitting device, and for tests and special tasks to be accomplished.
    These auxiliary capabilities are necessary for the operation of an internetwork,
    however, so TCP/IP includes *support protocols* that help IP perform these tasks.
    This part examines the two main IP support protocols: the *Internet Control Message
    Protocol (ICMP)* and the *Neighbor Discovery (ND)* protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of this part thoroughly describes ICMP, which was initially developed
    to be a companion to the original IP version 4 (IPv4). With the creation of IP
    version 6 (IPv6), a new version of ICMP, called ICMP version 6 (ICMPv6), was created
    as well. The original ICMP is now sometimes called *ICMPv4* to differentiate it,
    just as the original IP is now often called IPv4.
  prefs: []
  type: TYPE_NORMAL
- en: The two versions of ICMP have some differences in their specifics, but they
    are very similar in overall operation. For this reason, I have integrated the
    general operation description of both versions of ICMP in the first chapter of
    this part. The area where ICMPv4 and ICMPv6 most differ is in specific message
    types and formats, so these have been described separately in the second through
    fifth chapters. These chapters describe the error messages and informational messages
    in each version.
  prefs: []
  type: TYPE_NORMAL
- en: The final chapter describes ND, which was created specifically to assist in
    the operation of IPv6 and is closely related to ICMPv6.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the close relationship between ICMP and IP, this part assumes that you
    are familiar with basic IP concepts, including IP addressing, the general format
    of IP datagrams, and how they are routed (covered in [Part II-3](pt06.html "Part II-3. INTERNET
    PROTOCOL VERSION 4 (IP/IPV4)")). To better understand ICMPv6 details, you may
    also want to reference the IPv6 addressing and datagram encapsulation information
    (covered in [Part II-4](pt07.html "Part II-4. INTERNET PROTOCOL VERSION 6 (IPV6)")).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Internet Control Message Protocol (ICMP) is one of the underappreciated
    "worker bees" of the networking world. Everyone knows how important key protocols
    such as the Internet Protocol (IP) are to TCP/IP, but few realize that the suite
    as a whole relies on many functions that ICMP provides. Originally created to
    allow the reporting of a small set of error conditions, ICMP messages are now
    used to implement a wide range of error-reporting, feedback, and testing capabilities.
    While each message type is unique, they are all implemented using a common message
    format, sent, and then received based on relatively simple protocol rules. This
    makes ICMP one of the easiest TCP/IP protocols to understand. (Yes, I actually
    said something in this book was easy!)
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I provide a general description of ICMP. I begin with an overview
    of ICMP, discussing its purpose, history, and the versions and standards that
    define it. I describe the general method by which ICMP operates and discuss the
    rules that govern how and when ICMP messages are created and processed. I then
    outline the common format used for ICMP messages in versions 4 and 6 of the protocol
    (ICMPv4 and ICMPv6), and how data is encapsulated in them in general terms. I
    conclude with a discussion of ICMP message classifications and a summary of different
    message types and codes for both ICMPv4 and ICMPv6.
  prefs: []
  type: TYPE_NORMAL
- en: ICMP Overview, History, Versions, and Standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IP is the foundation of the TCP/IP protocol suite, because it is the mechanism
    responsible for delivering datagrams. Three of the main characteristics that describe
    IP's datagram delivery method are *connectionless*, *unreliable*, and *unacknowledged*.
    This means that datagrams are just sent over the internetwork with no prior connection
    established, no assurance they will show up, and no acknowledgment sent back to
    the sender that they arrived. On the surface, this seems like it would result
    in a protocol that is difficult to use and impossible to rely on, and thus would
    be a poor choice for designing a protocol suite. However, even though IP makes
    no guarantees, it works very well because most of the time, IP internetworks are
    sufficiently robust that messages get where they need to go.
  prefs: []
  type: TYPE_NORMAL
- en: Even the best-designed system still encounters problems, of course. Incorrect
    packets are occasionally sent, hardware devices have problems, routes are found
    to be invalid, and so forth. IP devices also often need to share specific information
    in order to guide them in their operation, and they need to perform tests and
    diagnostics. However, IP itself includes no provision that allows devices to exchange
    low-level control messages. Instead, these features are provided in the form of
    a companion protocol to IP called the *Internet Control Message Protocol (ICMP)*.
  prefs: []
  type: TYPE_NORMAL
- en: A good analogy for the relationship between IP and ICMP is to consider the one
    between a high-powered executive and her experienced administrative assistant.
    The executive is busy and her time is very expensive. She is paid to do a specific
    job and to do it well, and not to spend time on administrative tasks. However,
    without someone doing those tasks, the executive could not do her job properly.
    The administrative assistant does the important support jobs that make it possible
    for the executive to focus on her work. The working relationship between them
    is very important; a good pair will work together like a cohesive team, even anticipating
    each other's needs.
  prefs: []
  type: TYPE_NORMAL
- en: In TCP/IP, IP is the executive, and ICMP is its administrative assistant. IP
    focuses on its core activities, such as addressing, datagram packaging, and routing.
    ICMP provides critical support to IP in the form of *ICMP messages* that allow
    different types of communication to occur between IP devices. These messages use
    a common general format and are encapsulated in IP datagrams for transmission.
    They are divided into different categories, and each type has a specific use and
    internal field format.
  prefs: []
  type: TYPE_NORMAL
- en: Just as an administrative assistant often has a special location in an organization
    chart, and usually connects with a dotted line directly to the executive she assists,
    ICMP occupies a unique place in the TCP/IP protocol architecture (see [Chapter 8](ch08.html
    "Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE")). Technically, you might
    consider ICMP to belong to layer 4, because it creates messages that are encapsulated
    in IP datagrams and sent using IP at layer 3\. However, in the standard that first
    defined it, ICMP is specifically declared to be not only part of the network layer,
    but also, as stated in RFC 792, is "actually an integral part of IP, [that] must
    be implemented by every IP module." This was the initial defining standard for
    ICMP, titled simply "Internet Control Message Protocol." It was published at the
    same time as the standard for IP, which was RFC 791\. This is further indication
    that IP and ICMP really are a team of sorts.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the close relationship between the two, when the new version 6 of the
    Internet Protocol (IPv6) was developed in the mid-1990s, it was necessary to define
    a new version of ICMP as well. This was of course called the "Internet Control
    Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification."
    It was first published as RFC 1885 in 1995, and revised in RFC 2463 in 1998\.
    Just as the original IP is now often called IPv4 to differentiate it from IPv6,
    the original ICMP is now also called *ICMPv4*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** In TCP/IP, diagnostic, test, and error-reporting functions
    at the internetwork layer are performed by the *Internet Control Message Protocol
    (ICMP)*, which is like IP''s "administrative assistant." The original version,
    now called ICMPv4, is used with IPv4, and the newer ICMPv6 is used with IPv6.'
  prefs: []
  type: TYPE_NORMAL
- en: These two RFCs, 792 and 2463, define the basic operation of ICMPv4 and ICMPv6,
    respectively, and also describe some of the ICMP message types supported by each
    version of the protocol. ICMPv4 and ICMPv6 are very similar in most respects,
    although they have some differences, most of which are a direct result of the
    changes made to IP itself. Another document, RFC 1122, "Requirements for Internet
    Hosts—Communication Layers," contains rules for how ICMPv4 is used, as you will
    see soon in the section on ICMP message creation and processing conventions later
    in this chapter. RFC 1812, "Requirements for IP Version 4 Routers," is also relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Both versions of the protocol define a general messaging system that was designed
    to be expandable. This means that in addition to the messages defined in the ICMP
    standards themselves, other protocols may also define message types used in ICMP.
    Some of the more important of these are shown in [Table 31-1](ch31.html#non-icmp_internet_standards_that_define_
    "Table 31-1. Non-ICMP Internet Standards That Define ICMP Messages").
  prefs: []
  type: TYPE_NORMAL
- en: Table 31-1. Non-ICMP Internet Standards That Define ICMP Messages
  prefs: []
  type: TYPE_NORMAL
- en: '| ICMP Version of Message Types Defined | RFC Number | Name | ICMP Message
    Types Defined |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|   | 950 | Internet Standard Subnetting Procedure | Address Mask Request,
    Address Mask Reply |'
  prefs: []
  type: TYPE_TB
- en: '|   | 1256 | ICMP Router Discovery Messages | Router Advertisement, Router
    Solicitation |'
  prefs: []
  type: TYPE_TB
- en: '| ICMPv4 | 1393 | Traceroute Using an IP Option | Traceroute |'
  prefs: []
  type: TYPE_TB
- en: '|   | 1812 | Requirements for IP Version 4 Routers | Defines three new codes
    (subtypes) for the Destination Unreachable message. |'
  prefs: []
  type: TYPE_TB
- en: '| ICMPv6 | 2461 | Neighbor Discovery for IP Version 6 (IPv6) | Router Advertisement,
    Router Solicitation, Neighbor Advertisement, Neighbor Solicitation, Redirect |'
  prefs: []
  type: TYPE_TB
- en: '|   | 2894 | Router Renumbering for IPv6 | Router Renumbering |'
  prefs: []
  type: TYPE_TB
- en: This chapter includes a full list of the ICMPv4 and ICMPv6 message types covered
    in this book and the standards that define each one.
  prefs: []
  type: TYPE_NORMAL
- en: ICMP General Operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ICMP is one of the simplest protocols in the TCP/IP protocol suite. Most protocols
    implement a particular type of functionality to either facilitate basic operation
    of a part of the network stack or an application. To this end, they include many
    specific algorithms and tasks that define the protocol, which is where most of
    the complexity lies. ICMP, in contrast, is exactly what its name suggests: a protocol
    that defines control messages. As such, pretty much all of what ICMP is about
    is providing a mechanism for any IP device to send control messages to another
    device.'
  prefs: []
  type: TYPE_NORMAL
- en: The ICMP Message-Passing Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Various message types are defined in ICMP that allow different types of information
    to be exchanged. These are usually either generated for the purpose of reporting
    errors or for exchanging important information of different sorts that is needed
    to keep IP operating smoothly. ICMP itself doesn't define how all the different
    ICMP messages are used; this is done by the protocols that use the messages. In
    this manner, ICMP describes a simple message-passing service to other protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** ICMP is not like most other TCP/IP protocols in that it does
    not perform a specific task. It defines a mechanism by which various control messages
    can be transmitted and received to implement a variety of functions.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the preceding section, ICMP is considered an integral part of
    IP, even though it uses IP to send its messages. Typically, the operation of ICMP
    involves some portion of the TCP/IP protocol software on a machine detecting a
    condition that causes it to generate an ICMP message. This is often the IP layer
    itself, though it may be some other part of the software. The message is then
    encapsulated and transmitted like any other TCP/IP message, and is given no special
    treatment compared to other IP datagrams. The message is sent over the internetwork
    to the IP layer at the receiving device, as shown in [Figure 31-1](ch31s02.html#icmp_general_operation_a_typical_use_of_
    "Figure 31-1. ICMP general operation A typical use of ICMP is to provide a feedback
    mechanism when an IP message is sent. In this example, Device A is trying to send
    an IP datagram to Device B. However, when it gets to Router R3, a problem of some
    sort is detected that causes the datagram to be dropped. Router R3 sends an ICMP
    message back to Device A to tell it that something happened, hopefully with enough
    information to let Device A correct the problem, if possible. Router R3 can only
    send the ICMP message back to Device A, not to Router R2 or R1.").
  prefs: []
  type: TYPE_NORMAL
- en: Again, since many of the ICMP messages are actually intended to convey information
    to a device's IP software, the IP layer itself may be the ultimate destination
    of an ICMP message once a recipient gets it. In other cases, the ultimate destination
    may be some other part of the TCP/IP protocol software, which is determined by
    the type of message received. ICMP does not use ports like the User Datagram Protocol
    (UDP) or Transmission Control Protocol (TCP) to direct its messages to different
    applications on a host. The software recognizes the message type and directs it
    accordingly within the software.
  prefs: []
  type: TYPE_NORMAL
- en: ICMP was originally designed with the idea that most messages would be sent
    by routers, but they can be sent by both routers and by regular hosts as well,
    depending on the message type. Some are obviously sent only by routers, such as
    Redirect messages; others may be sent by either routers or hosts. Many of the
    ICMP messages are used in matched pairs, especially in various kinds of Request
    and Reply messages, and Advertisement and Solicitation messages.
  prefs: []
  type: TYPE_NORMAL
- en: '![ICMP general operation A typical use of ICMP is to provide a feedback mechanism
    when an IP message is sent. In this example, Device A is trying to send an IP
    datagram to Device B. However, when it gets to Router R3, a problem of some sort
    is detected that causes the datagram to be dropped. Router R3 sends an ICMP message
    back to Device A to tell it that something happened, hopefully with enough information
    to let Device A correct the problem, if possible. Router R3 can only send the
    ICMP message back to Device A, not to Router R2 or R1.](httpatomoreillycomsourcenostarchimages287959.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 31-1. ICMP general operation A typical use of ICMP is to provide a feedback
    mechanism when an IP message is sent. In this example, Device A is trying to send
    an IP datagram to Device B. However, when it gets to Router R3, a problem of some
    sort is detected that causes the datagram to be dropped. Router R3 sends an ICMP
    message back to Device A to tell it that something happened, hopefully with enough
    information to let Device A correct the problem, if possible. Router R3 can only
    send the ICMP message back to Device A, not to Router R2 or R1.
  prefs: []
  type: TYPE_NORMAL
- en: ICMP Error Reporting Limited to the Datagram Source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One interesting general characteristic of ICMP's operation is that when errors
    are detected, they can be reported using ICMP, but only back to the original source
    of a datagram. This is actually a big drawback in how ICMP works. Refer back to
    [Figure 31-1](ch31s02.html#icmp_general_operation_a_typical_use_of_ "Figure 31-1. ICMP
    general operation A typical use of ICMP is to provide a feedback mechanism when
    an IP message is sent. In this example, Device A is trying to send an IP datagram
    to Device B. However, when it gets to Router R3, a problem of some sort is detected
    that causes the datagram to be dropped. Router R3 sends an ICMP message back to
    Device A to tell it that something happened, hopefully with enough information
    to let Device A correct the problem, if possible. Router R3 can only send the
    ICMP message back to Device A, not to Router R2 or R1.") and consider again client
    Host A sending a message to server Host B, with a problem detected in the datagram
    by Router R3\. Even if Router R3 suspects that the problem was caused by one of
    the preceding routers that handled the message, such as Router R2, it *cannot*
    send a problem report to Router R2\. It can send an ICMP message only back to
    Host A.
  prefs: []
  type: TYPE_NORMAL
- en: This limitation is an artifact of how IP works. You may recall from looking
    at the IP datagram format that the only address fields are for the original source
    and ultimate destination of the datagram. (The only exception is if the IP Record
    Route option is used, but devices cannot count on this.) When Router R3 receives
    a datagram from Router R2 that Router R2 in turn received from Router R1 (and
    prior to that, from Device A), it is only Device A's address in the datagram.
    Thus, Router R3 *must* send a problem report back to Device A, and Device A must
    decide what to do with it. Device A may decide to change the route it uses or
    to generate an error report that an administrator can use to troubleshoot Router
    R2.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this basic limitation, several special rules and conventions
    have been put in place to govern the circumstances under which ICMP messages are
    generated, sent, and processed. I'll discuss these later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** ICMP error-reporting messages sent in response to a problem
    seen in an IP datagram can be sent back only to the originating device. Intermediate
    devices cannot be the recipients of an ICMP message because their addresses are
    normally not carried in the IP datagram''s header.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMP Message Classes, Types, and Codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ICMP messages are used to allow the communication of different types of information
    between IP devices on an internetwork. The messages themselves are used for a
    wide variety of purposes, and they are organized into general categories as well
    as numerous specific types and subtypes.
  prefs: []
  type: TYPE_NORMAL
- en: ICMP Message Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the highest level, ICMP messages are divided into two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error Messages** These messages are used to provide feedback to a source
    device about an error that has occurred. They are typically generated specifically
    in response to some sort of action, usually the transmission of a datagram, as
    shown in the example in [Figure 31-1](ch31s02.html#icmp_general_operation_a_typical_use_of_
    "Figure 31-1. ICMP general operation A typical use of ICMP is to provide a feedback
    mechanism when an IP message is sent. In this example, Device A is trying to send
    an IP datagram to Device B. However, when it gets to Router R3, a problem of some
    sort is detected that causes the datagram to be dropped. Router R3 sends an ICMP
    message back to Device A to tell it that something happened, hopefully with enough
    information to let Device A correct the problem, if possible. Router R3 can only
    send the ICMP message back to Device A, not to Router R2 or R1."). Errors are
    usually related to the structure or content of a datagram or to problem situations
    on the internetwork encountered during datagram routing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Informational (or Query) Messages** These are messages that are used to let
    devices exchange information, implement certain IP-related features, and perform
    testing. They do not indicate errors and are typically not sent in response to
    a regular datagram transmission. They are generated either when directed by an
    application or on a regular basis to provide information to other devices. An
    informational ICMP message may also be sent in reply to another informational
    ICMP message, since they often occur in request/reply or solicitation/advertisement
    functional pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** ICMP messages are divided into two general categories: *error
    messages* that are used to report problem conditions, and *informational messages*
    that are used for diagnostics, testing, and other purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMP Message Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each individual kind of message in ICMP is given its own unique Type value,
    which is put into the field of that name in the ICMP common message format. This
    field is 8 bits wide, so a theoretical maximum of 256 message types can be defined.
    A separate set of Type values is maintained for each of ICMPv4 and ICMPv6.
  prefs: []
  type: TYPE_NORMAL
- en: In ICMPv4, Type values were assigned sequentially to both error and informational
    messages on a first-come, first-served basis (sort of), so we cannot tell just
    by the Type value what type of message each is. One minor improvement made in
    ICMPv6 was that the message types were separated. In IPv6, error messages have
    Type values from 0 to 127, and informational messages have values from 128 to
    255\. Only some of the Type values are currently defined.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** A total of 256 different possible message types can be defined
    for each of ICMPv4 and ICMPv6\. The Type field that appears in the header of each
    message specifies the kind of ICMP message. In ICMPv4, there is no relationship
    between Type value and message type. In ICMPv6, error messages have a Type value
    of 0 to 127, and informational messages have a Type value of 128 to 255.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMP Message Codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The message type indicates the general purpose of each kind of ICMP message.
    ICMP also provides an additional level of detail within each message type in the
    form of a Code field, which is also 8 bits. You can consider this field as a message
    subtype. Thus, each message type can have up to 256 subtypes that are more detailed
    subdivisions of the message's overall functionality. A good example is the Destination
    Unreachable message, which is generated when a datagram cannot be delivered. In
    this message type, the Code value provides more information on exactly why the
    delivery was not possible.
  prefs: []
  type: TYPE_NORMAL
- en: ICMP Message Class and Type Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next four chapters of the book describe all of the major ICMP message types
    for both ICMPv4 and ICMPv6\. For convenience, I have summarized all these message
    types in [Table 31-2](ch31s03.html#icmp_message_classes_types_and_cod-id001 "Table 31-2. ICMP
    Message Classes, Types, and Codes"), which shows each of the Type values for the
    messages covered in this book, the name of each message, a very brief summary
    of its purpose, and the RFC that defines it. (To keep the table from being egregiously
    large, I have not shown each of the Code values for each Type value; these can
    be found in the individual message type descriptions.) The table is organized
    into sections that correspond to the four chapters that describe ICMP message
    types, except this table is sorted by ascending Type value within each category
    for easier reference.
  prefs: []
  type: TYPE_NORMAL
- en: Table 31-2. ICMP Message Classes, Types, and Codes
  prefs: []
  type: TYPE_NORMAL
- en: '| Message Class | Type Value | Message Name | Summary Description of Message
    Type | Defining RFC Number |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|   | 3 | Destination Unreachable | Indicates that a datagram could not be
    delivered to its destination. The Code value provides more information on the
    nature of the error. | 792 |'
  prefs: []
  type: TYPE_TB
- en: '| ICMPv4 Error Messages | 4 | Source Quench | Lets a congested IP device tell
    a device that is sending it datagrams to slow down the rate at which it is sending
    them. | 792 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 5 | Redirect | Allows a router to inform a host of a better route to
    use for sending datagrams. | 792 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 11 | Time Exceeded | Sent when a datagram has been discarded prior to
    delivery due to expiration of its Time to Live field. | 792 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 12 | Parameter Problem | Indicates a miscellaneous problem (specified
    by the Code value) in delivering a datagram. | 792 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 0 | Echo Reply | Sent in reply to an Echo (Request) message; used for
    testing connectivity. | 792 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 8 | Echo (Request) | Sent by a device to test connectivity to another
    device on the internetwork. The word *Request* sometimes appears in the message
    name. | 792 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 9 | Router Advertisement | Used by routers to tell hosts of their existence
    and capabilities. | 1256 |'
  prefs: []
  type: TYPE_TB
- en: '| ICMPv4 Informational Messages (part 1 of 2) | 10 | Router Solicitation |
    Used by hosts to prompt any listening routers to send a Router Advertisement.
    | 1256 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 13 | Timestamp (Request) | Sent by a device to request that another send
    it a timestamp value for propagation time calculation and clock synchronization.
    The word *Request* sometimes appears in the message name. | 792 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 14 | Timestamp Reply | Sent in response to a Timestamp (Request) to provide
    time calculation and clock synchronization information. | 792 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 15 | Information Request | Originally used to request configuration information
    from another device. Now obsolete. | 792 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 16 | Information Reply | Originally used to provide configuration information
    in response to an Information Request message. Now obsolete. | 792 |'
  prefs: []
  type: TYPE_TB
- en: '| ICMPv4 Informational Messages (part 2 of 2) | 17 | Address Mask Request |
    Used to request that a device send a subnet mask. | 950 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 18 | Address Mask Reply | Contains a subnet mask sent in reply to an
    Address Mask Request. | 950 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 30 | Traceroute | Used to implement the experimental enhanced traceroute
    utility. | 1393 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 1 | Destination Unreachable | Indicates that a datagram could not be
    delivered to its destination. *Code* value provides more information on the nature
    of the error. | 2463 |'
  prefs: []
  type: TYPE_TB
- en: '| ICMPv6 Error Messages | 2 | Packet Too Big | Sent when a datagram cannot
    be forwarded because it is too big for the maximum transmission unit (MTU) of
    the next hop in the route. This message is needed in IPv6 and not IPv4 because
    in IPv4, routers can fragment oversized messages, but in IPv6 they cannot. | 2463
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | 3 | Time Exceeded | Sent when a datagram has been discarded prior to
    delivery due to the Hop Limit field being reduced to zero. | 2463 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 4 | Parameter Problem | Indicates a miscellaneous problem (specified
    by the *Code* value) in delivering a datagram. | 2463 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 128 | Echo Request | Sent by a device to test connectivity to another
    device on the internetwork. | 2463 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 129 | Echo Reply | Sent in reply to an Echo (Request) message; used for
    testing connectivity. | 2463 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 133 | Router Solicitation | Prompts a router to send a Router Advertisement.
    | 2461 |'
  prefs: []
  type: TYPE_TB
- en: '| ICMPv6 Informational Messages | 134 | Router Advertisement | Sent by routers
    to tell hosts on the local network that the router exists. It also describes its
    capabilities. | 2461 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 135 | Neighbor Solicitation | Sent by a device to request the layer 2
    address of another device while providing its own as well. | 2461 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 136 | Neighbor Advertisement | Provides information about a host to other
    devices on the network. | 2461 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 137 | Redirect | Redirects transmissions from a host to either an immediate
    neighbor on the network or a router. | 2461 |'
  prefs: []
  type: TYPE_TB
- en: '|   | 138 | Router Renumbering | Conveys renumbering information for router
    renumbering. | 2894 |'
  prefs: []
  type: TYPE_TB
- en: You can see that several of the message types are quite similar in ICMPv4 and
    ICMPv6, but there are some slight differences. An obvious one is that Redirect
    is considered an error message in ICMPv4, but it's an informational message in
    ICMPv6\. Messages are often used differently as well. In IPv6, the use of many
    of the ICMP informational messages is described in the Neighbor Discovery (ND)
    protocol, which is new to IPv6 (see [Chapter 36](ch36.html "Chapter 36. IPV6 NEIGHBOR
    DISCOVERY (ND) PROTOCOL")).
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Information Request and Information Reply messages were originally
    created to allow devices to determine an IP address and possibly other configuration
    information. This function was later implemented using host configuration protocols
    such as the Reverse Address Resolution Protocol (RARP; see [Chapter 14](ch14.html
    "Chapter 14. REVERSE ADDRESS RESOLUTION AND THE TCP/IP REVERSE ADDRESS RESOLUTION
    PROTOCOL (RARP)")), Boot Protocol (BOOTP; see [Chapter 60](ch60.html "Chapter 60. TCP/IP
    BOOTSTRAP PROTOCOL (BOOTP)")), and Dynamic Host Configuration Protocol (DHCP,
    discussed in Chapters [Chapter 61](ch61.html "Chapter 61. DHCP OVERVIEW AND ADDRESS
    ALLOCATION CONCEPTS") through [Chapter 64](ch64.html "Chapter 64. DHCP CLIENT/SERVER
    IMPLEMENTATION, FEATURES, AND IPV6 SUPPORT")). These message types are now obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: ICMP Message Creation and Processing Conventions and Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the overview of ICMP earlier in this chapter, I compared the relationship
    between IP and ICMP to that between an executive and an administrative assistant.
    One of the characteristics that many executives value in a good assistant is that
    the assistant does his work independently, without causing unnecessary disruption.
    A good assistant should save the executive time, not cost her time.
  prefs: []
  type: TYPE_NORMAL
- en: As the assistant to IP, ICMP must similarly help IP function without taking
    up too much of its resources. Here, the resource being conserved is not so much
    time as bandwidth. ICMP messages are important, but must be considered part of
    the overhead of running a network. They carry no user data, so each one represents
    a small loss of overall end-user bandwidth on the network. For this reason, we
    want to send them only when necessary, and to carefully control the circumstances
    under which they are generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Administrative assistants have some serious advantages over networking protocols:
    common sense and experience. They usually know where the line is drawn between
    help and hindrance; computers don''t. To partially compensate, ICMP''s operation
    is guided by a set of *conventions* or *rules* for how messages are created and
    processed. For ICMPv4, these conventions are described in part in the defining
    RFC 792, but much more in RFC 1122, "Requirements for Internet Hosts—Communication
    Layers," which provides specific information on implementing TCP/IP in host devices.
    In ICMPv6, the information related to ICMP implementation that appears in RFC
    1122 has been largely incorporated into the main document that defines ICMPv6,
    RFC 2463.'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the issues related to message generation have to do with error messages,
    not informational messages. The latter class of messages usually doesn't cause
    problems because they are generated based on specific rules already established
    in the protocols that use them. For example, routers send Router Advertisement
    messages on a regular basis, and the routers make sure this is infrequent. They
    are also sent in response to Router Solicitation messages sent on occasion by
    hosts, and as long as a host doesn't go haywire and start sending tons of Solicitations,
    there won't be a problem. Even then, you can give a router enough smarts not to
    send Router Advertisements too often.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations on ICMP Message Responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem comes up with error messages specifically because they are sent
    *in response* to so many situations. Potentially, they may even be sent in response
    to each other. Without special care, loops or cascading message generation might
    occur. For example, consider a situation in which Device A encounters an error
    and sends an error report to Device B. Device B finds an error in Device A's message
    and sends an error report back to Device A. This could result in billions of messages
    being sent back and forth, thereby clogging the network, until a human figures
    out what is wrong and fixes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent such problems, an ICMP error message *must not* be generated in
    response to any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An ICMP Error Message** This prevents loops of the type just mentioned. Note,
    however, that an ICMP error message *can* be generated in response to an ICMP
    informational message.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Broadcast or Multicast Datagram** What would happen if a datagram were
    broadcast to 5,000 hosts, and each of them found an error in it and tried to send
    a report back to the source? Something unpleasant!'
  prefs: []
  type: TYPE_NORMAL
- en: '**IP Datagram Fragments Except the First** In many cases, the same situation
    that might cause a device to generate an error for one fragment would also apply
    to each successive one, causing unnecessary ICMP traffic. For this reason, when
    a datagram is fragmented, a device may send an error message only in response
    to a problem in the first fragment.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Datagrams with Non-Unicast Source Address** If a datagram''s source address
    doesn''t define a unique, unicast device address, an error message cannot be sent
    back to that source. This prevents ICMP messages from being broadcast, unicast,
    or sent to nonroutable special addresses such as the loopback address.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** In order to prevent excessive numbers of ICMP messages from
    being sent on a network, a special set of rules governs when and how they may
    be created. Most of these are designed to eliminate situations in which very large
    numbers of ICMP error messages would be generated in response to certain occurrences.'
  prefs: []
  type: TYPE_NORMAL
- en: These rules apply to both ICMPv4 and ICMPv6, but in ICMPv6 there are a couple
    of special cases. In certain circumstances, an ICMPv6 Packet Too Big message may
    be sent to a multicast address, as this is required for Path MTU Discovery (described
    in [Chapter 27](ch27.html "Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY,
    AND ROUTING")) to work. Certain Parameter Problem messages may also be sent to
    multicast or broadcast addresses. Finally, in addition to the rules just mentioned,
    IPv6 implementations are specifically directed to limit the rate at which they
    send ICMPv6 messages overall.
  prefs: []
  type: TYPE_NORMAL
- en: ICMP Message Processing Conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Message processing generally takes place as described earlier in the section
    on ICMP general operation, with the ICMP message delivered either to the IP software
    or other protocol software implementation as required. What is done with the message
    usually depends on its type. Some messages are destined for only the IP software
    itself, but many are intended for the higher-layer protocol that generated the
    datagram that led to the error. In the next section, you will see that ICMP error
    messages include information that allows the upper-layer protocol to be extracted
    for the purpose of passing the message to the appropriate software layer.
  prefs: []
  type: TYPE_NORMAL
- en: In IPv6, the class of message (error or informational) can be determined from
    the Type value. This knowledge can then be used to guide processing of ICMP messages
    with unknown Type values. The rule is that ICMP error messages with unknown Type
    values must be passed to the appropriate upper-layer protocol. Informational messages
    with unknown Type values are discarded without taking action.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these general rules, there are specific rules put into place
    to guide the processing of some of the message types. I describe some of these
    conventions in the chapters that discuss individual ICMP messages.
  prefs: []
  type: TYPE_NORMAL
- en: An important final point is that ICMP messages, especially error messages, are
    not considered binding on the device that processes them. To stick with the office
    analogy, they have the equivalent status in an office of only of an FYI memo,
    not an assignment. It is often the case that a device *should* take action upon
    processing an ICMP message, but the device is not required to. The exception,
    again, is when informational messages are used for specific purposes. For example,
    most of the messages that come in pairs are designed so that a Request results
    in the matching Reply and a Solicitation yields an Advertisement.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** A device receiving an ICMP message is not required to take
    action unless a protocol using a message type dictates a specific response to
    a particular message type. In particular, devices are not mandated to perform
    any specific task when receiving an ICMP error message.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMP Common Message Format and Data Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have seen so far in this chapter, ICMP is not so much a protocol that
    performs a specific function as a framework for the exchange of error reports
    and information. Since each of the message types is used for a different purpose,
    they differ in the types of information they contain. This means each ICMP message
    has a slightly different format. At the same time, however, ICMP message types
    also have a degree of commonality—a portion of each message is common between
    message types.
  prefs: []
  type: TYPE_NORMAL
- en: ICMP Common Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can think of the structure of an ICMP message as having a *common part*
    and a *unique part*. The common part consists of three fields that have the same
    size and same meaning in all ICMP messages (although the values in the fields
    aren't the same for each ICMP message type). The unique part contains fields that
    are specific to each type of message.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the common message format is basically the same for ICMPv4 and
    ICMPv6\. It is described in [Table 31-3](ch31s05.html#icmp_common_message_format-id001
    "Table 31-3. ICMP Common Message Format") and illustrated in [Figure 31-2](ch31s05.html#icmp_common_message_format_this_overall_
    "Figure 31-2. ICMP common message format This overall, generic message format
    is used for both ICMPv4 and ICMPv6 message types.").
  prefs: []
  type: TYPE_NORMAL
- en: Table 31-3. ICMP Common Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMP message type. For ICMPv6, values from 0 to
    127 are error messages, and values 128 to 255 are informational messages. Common
    values for this field are given in [Table 31-2](ch31s03.html#icmp_message_classes_types_and_cod-id001
    "Table 31-2. ICMP Message Classes, Types, and Codes"). |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Identifies the subtype of message within each ICMP message Type
    value. Thus, up to 256 subtypes can be defined for each message type. Values for
    this field are shown in the following chapters on individual ICMP message types.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field that is calculated in a manner similar
    to the IP header checksum in IPv4\. It provides error-detection coverage for the
    entire ICMP message. Note that in ICMPv6, a pseudo header of IPv6 header fields
    is prepended for checksum calculation; this is similar to the way this is done
    in TCP. |'
  prefs: []
  type: TYPE_TB
- en: '| Message Body/Data | Variable | Contains the specific fields used to implement
    each message type. This is the unique part of the message. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMP common message format This overall, generic message format is used for
    both ICMPv4 and ICMPv6 message types.](httpatomoreillycomsourcenostarchimages287961.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 31-2. ICMP common message format This overall, generic message format
    is used for both ICMPv4 and ICMPv6 message types.
  prefs: []
  type: TYPE_NORMAL
- en: Original Datagram Inclusion in ICMP Error Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The message body typically contains one or several fields that carry information
    of relevance to each specific type of ICMP message. All ICMP error messages include
    a portion of the original IP datagram that led to the ICMP error message. This
    aids in diagnosing the problem that caused the ICMP message to be generated, by
    allowing the error to be communicated to higher layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inclusion of original IP datagram information is done differently for the
    two ICMP versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ICMPv4 Error Messages** Each error message includes the full IP header and
    the first 8 bytes of the payload. Since the beginning of the payload will contain
    the encapsulated higher-layer header, the ICMP message also carries either the
    full UDP header or the first 8 bytes of the TCP header. In both cases, the source
    and destination port numbers are part of what is included. If the original header
    was a standard IP header with no options, the Message Body will therefore have
    a length of 28 bytes; if options are present, it will be larger.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ICMPv6 Error Messages** Each error message includes as much of the IPv6 datagram
    as will fit without causing the size of the ICMPv6 error message (including its
    IP header encapsulation) to exceed the minimum IPv6 maximum transmission unit
    size, which is 1280 bytes. This provides additional information for diagnostic
    purposes when compared to ICMPv4, while ensuring that no ICMPv6 error messages
    will be too large for any physical network segment. The larger size of the included
    data allows the IPv6 extension headers to be included in the error message, since
    the error could be in one of those extension headers.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Remember that in IPv6, routers cannot fragment IP datagrams; any datagram
    that is oversized for an underlying physical network is dropped. ICMPv6 is thus
    designed to ensure that this does not happen by not creating ICMPv6 datagrams
    over the universal IPv6 MTU size of 1280*.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Each kind of ICMP message contains data unique to that message
    type, but all messages are structured according to a common ICMP message format.
    ICMP error messages always include in their message body field some portion of
    the original IP datagram that resulted in the error being generated.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMP Data Encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After an ICMP message is formatted, it is encapsulated in an IP datagram like
    any other IP message. This is why some people believe ICMP is architecturally
    a higher layer than IP, though as I discussed earlier, it is really more of a
    special case. You can also see that when an ICMP error message is generated, we
    end up with the original IP header and part or all of the payload, encapsulated
    in the ICMP message, which in turn is encapsulated within a new IP header that
    will be sent back as an error report, usually to the device that sent the original
    IP message.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 32. ICMPV4 ERROR MESSAGE TYPES AND FORMATS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Routers and hosts use Internet Control Message Protocol (ICMP) error messages
    to tell a device that sent a datagram about problems that were encountered during
    delivery. The original ICMP version 4 (ICMPv4) defined five different error messages,
    which are all described in the original ICMP standard, RFC 792\. These are some
    of the most important ICMP messages. They provide critical feedback about error
    conditions and may help a transmitting device take corrective action to ensure
    reliable and efficient datagram delivery.
  prefs: []
  type: TYPE_NORMAL
- en: In this first of four chapters on specific ICMP types, I look at the ICMPv4
    error messages. I begin with Destination Unreachable messages, which are sent
    due to datagram delivery failures, and Source Quench messages, which are used
    to tell a device to slow down the rate at which it sends datagrams. Next, I describe
    Time Exceeded messages, which are sent when a datagram has been traveling the
    network too long or takes too long to be reassembled from fragments, and Redirect
    messages, which let a router provide feedback about better routes to a host. Finally,
    I discuss Parameter Problem messages, which are generic messages used for problems
    not covered by other ICMP error messages.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Destination Unreachable Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the Internet Protocol (IP) is an unreliable protocol, there are no guarantees
    that a datagram sent by one device to another will ever actually get there. The
    internetwork of hosts and routers will make a best effort to deliver the datagram,
    but it may not get where it needs to for any number of reasons. Devices on an
    IP network understand that and are designed accordingly. IP software never assumes
    its datagrams will always be received, and higher-layer protocols like the Transmission
    Control Protocol (TCP) take care of providing reliability and acknowledgments
    of received data for applications that need these features.
  prefs: []
  type: TYPE_NORMAL
- en: This setup, with higher layers handling failed deliveries, is sufficient in
    some cases. For example, suppose Device A tries to send to Device B, but a router
    near Device B is overloaded, so it drops the datagram. In this case, the problem
    is likely intermittent, so Device A can retransmit and eventually reach Device
    B. But what about a situation where a device is trying to send to an IP address
    that doesn't exist, or a problem with routing that isn't easily corrected? Having
    the source just continually retry in this case would be inefficient, to say the
    least.
  prefs: []
  type: TYPE_NORMAL
- en: IP is designed to allow IP datagram deliveries to fail, and we should take any
    such failures seriously. What we really need is a feedback mechanism that can
    tell a source device that something improper is happening and why. In IP version
    4 (IPv4), this service is provided through the transmission of *Destination Unreachable*
    ICMP messages. When a source node receives one of these messages, it knows there
    was a problem sending a datagram, and can then decide what action, if any, it
    wants to take. Like all ICMP error messages, Destination Unreachable messages
    include a portion of the datagram that could not be delivered, which helps the
    recipient of the error figure out what the problem is.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Destination Unreachable Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 32-1](ch32.html#icmpv_destination_unreachable_message_fo "Table 32-1. ICMPv4
    Destination Unreachable Message Format") and [Figure 32-1](ch32.html#icmpv4_destination_unreachable_mes-id001
    "Figure 32-1. ICMPv4 Destination Unreachable message format") show the specific
    format for ICMPv4 Destination Unreachable messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 32-1. ICMPv4 Destination Unreachable Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMP message type; for Destination Unreachable
    messages, this is set to 3. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Identifies the subtype of unreachable error being communicated.
    See [Table 34-2](ch34.html#icmpv_destination_unreachable_mess-id002 "Table 34-2. ICMPv6
    Destination Unreachable Message Subtypes") for a full list of codes and what they
    mean. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Unused | 4 | The 4 bytes that are left blank and not used. |'
  prefs: []
  type: TYPE_TB
- en: '| Original Datagram Portion | Variable | The full IP header and the first 8
    bytes of the payload of the datagram that prompted this error message to be sent.
    |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv4 Destination Unreachable message format](httpatomoreillycomsourcenostarchimages287963.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 32-1. ICMPv4 Destination Unreachable message format
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Destination Unreachable Message Subtypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many different reasons why it may not be possible for a datagram to
    reach its destination. Some of these may be due to erroneous parameters (like
    the invalid IP address example mentioned earlier). A router might have a problem
    reaching a particular network for whatever reason. There can also be other more
    esoteric reasons related to why a datagram cannot be delivered.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, the ICMPv4 Destination Unreachable message type can be considered
    as a class of related error messages. The receipt of a Destination Unreachable
    message tells a device that the datagram it sent couldn't be delivered, and the
    Code field in the ICMP header indicates the reason for the nondelivery. [Table 32-2](ch32.html#icmpv_destination_unreachable_message_su
    "Table 32-2. ICMPv4 Destination Unreachable Message Subtypes") shows the different
    Code values, corresponding message subtypes, and a brief explanation of each.
  prefs: []
  type: TYPE_NORMAL
- en: Table 32-2. ICMPv4 Destination Unreachable Message Subtypes
  prefs: []
  type: TYPE_NORMAL
- en: '| Code Value | Message Subtype | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Network Unreachable | The datagram could not be delivered to the network
    specified in the network ID portion of the IP address. This usually means a problem
    with routing but could also be caused by a bad address. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Host Unreachable | The datagram was delivered to the network specified
    in the network ID portion of the IP address but could not be sent to the specific
    host indicated in the address. Again, this usually implies a routing issue. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Protocol Unreachable | The protocol specified in the Protocol field was
    invalid for the host to which the datagram was delivered. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Port Unreachable | The destination port specified in the UDP or TCP header
    was invalid. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Fragmentation Needed and DF Set | This is one of those esoteric codes.
    Normally, an IPv4 router will automatically fragment a datagram that it receives
    if it is too large for the maximum transmission unit (MTU) of the next physical
    network link the datagram needs to traverse. However, if the DF (Don''t Fragment)
    flag is set in the IP header, this means the sender of the datagram does not *want*
    the datagram ever to be fragmented. This puts the router between the proverbial
    rock and a hard place, and it will be forced to drop the datagram and send an
    error message with this code. This message type is most often used in a clever
    way by intentionally sending messages of increasing size to discover the MTU size
    that a link can handle. This process is called Path MTU Discovery (described in
    [Chapter 27](ch27.html "Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY,
    AND ROUTING")). |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Source Route Failed | Generated if a source route was specified for the
    datagram in an option but a router could not forward the datagram to the next
    step in the route. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Destination Network Unknown | Not used; code 0 is used instead. |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Destination Host Unknown | The host specified is not known. This is usually
    generated by a router local to the destination host and usually means a bad address.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Source Host Isolated | Obsolete, no longer used. |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Communication with Destination Network Is Administratively Prohibited
    | The source device is not allowed to send to the network where the destination
    device is located. |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Communication with Destination Host Is Administratively Prohibited |
    The source device is allowed to send to the network where the destination device
    is located, but not that particular device. |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | Destination Network Unreachable for Type of Service | The network specified
    in the IP address cannot be reached due to the inability to provide service specified
    in the Type of Service field of the datagram header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | Destination Host Unreachable for Type of Service | The destination host
    specified in the IP address cannot be reached due to the inability to provide
    service specified in the datagram''s Type of Service field. |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | Communication Administratively Prohibited | The datagram could not be
    forwarded due to filtering that blocks the message based on its contents. |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | Host Precedence Violation | Sent by a first-hop router (the first router
    to handle a sent datagram) when the Precedence value in the Type of Service field
    is not permitted. |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | Precedence Cutoff in Effect | Sent by a router when receiving a datagram
    whose Precedence value (priority) is lower than the minimum allowed for the network
    at that time. |'
  prefs: []
  type: TYPE_TB
- en: As you can see in [Table 32-2](ch32.html#icmpv_destination_unreachable_message_su
    "Table 32-2. ICMPv4 Destination Unreachable Message Subtypes"), not all of these
    codes are actively used at this time. For example, code 8 is obsolete and code
    0 is used instead of 6\. Also, some of the higher numbers related to the Type
    of Service field aren't actively used because Type of Service isn't actively used.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** ICMPv4 *Destination Unreachable* messages are used to inform
    a sending device of a failure to deliver an IP datagram. The message''s Code field
    provides information about the nature of the delivery problem.'
  prefs: []
  type: TYPE_NORMAL
- en: Interpretation of Destination Unreachable Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's important to remember that just as IP is a best effort, the reporting of
    unreachable destinations using ICMP is also a best effort. Realize that these
    ICMP messages are themselves carried in IP datagrams. More than that, however,
    remember that there may be problems that prevent a router from detecting failure
    of delivery of an ICMP message, such as a low-level hardware problem. A router
    could, theoretically, also be precluded from sending an ICMP message even when
    failure of delivery *is* detected for whatever reason.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, the sending of Destination Unreachable messages should be considered
    supplemental. There is no guarantee that every problem sending a datagram will
    result in a corresponding ICMP message. No device should count on receiving an
    ICMP Destination Unreachable for a failed delivery any more than it counts on
    the delivery in the first place. This is why the higher-layer mechanisms mentioned
    at the start of this discussion are still important.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Source Quench Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a source device sends out a datagram, it will travel across the internetwork
    and eventually arrive at its intended destination (at least, that's what we hope
    will happen). At that point, it is up to the destination device to process the
    datagram by examining it and determining which higher-layer software process to
    hand the datagram.
  prefs: []
  type: TYPE_NORMAL
- en: If a destination device is receiving datagrams at a relatively slow rate, it
    may be able to process each datagram on the fly as it is received. However, datagram
    receipt in a typical internetwork can tend to be uneven or bursty, with alternating
    higher and lower rates of traffic. To allow for times when datagrams are arriving
    faster than they can be processed, each device has a *buffer* where it can temporarily
    hold datagrams it has received until it has a chance to deal with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this buffer is itself limited in size. Assuming the device has been
    properly designed, the buffer may be sufficient to smooth out high-traffic and
    low-traffic periods most of the time. Certain situations can still arise in which
    traffic is received so rapidly that the buffer fills up entirely. Some examples
    of scenarios in which this might happen include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A single destination is overwhelmed by datagrams from many sources, such as
    a popular website being swamped by HTTP requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device A and Device B are exchanging information, but Device A is a much faster
    computer than Device B, and can generate outgoing and process incoming datagrams
    much faster than Device B can.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A router receives a large number of datagrams over a high-speed link that it
    needs to forward over a low-speed link; they start to pile up while waiting to
    be sent over the slow link.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hardware failure or other situation causes datagrams to sit at a device unprocessed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A device that continues to receive datagrams when it has no more buffer space
    is forced to discard them and is said to be *congested*. A source that has its
    datagram discarded due to congestion won't have any way of knowing this, since
    IP itself is unreliable and unacknowledged. Therefore, while it is possible to
    simply allow higher-layer protocols to detect the dropped datagrams and generate
    replacements, it makes a lot more sense to have the congested device provide feedback
    to the sources by telling them that it is overloaded.
  prefs: []
  type: TYPE_NORMAL
- en: In IPv4, a device that is forced to drop datagrams due to congestion provides
    feedback to the sources that overwhelmed it by sending them ICMPv4 *Source Quench*
    messages. Just as you use water to quench a fire, a Source Quench message is a
    signal that attempts to quench a source device that is sending too fast. In other
    words, it's a polite way for one IP device to tell another, "Slow down!" When
    a device receives one of these messages, it knows it needs to reduce the speed
    at which it is sending datagrams to the device that sent it.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Source Quench Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 32-3](ch32s02.html#icmpv_source_quench_message_format "Table 32-3. ICMPv4
    Source Quench Message Format") and [Figure 32-2](ch32s02.html#icmpv4_source_quench_message_forma-id001
    "Figure 32-2. ICMPv4 Source Quench message format") show the specific format for
    ICMPv4 Source Quench messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 32-3. ICMPv4 Source Quench Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMP message type; for Source Quench messages,
    this is set to 4. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Identifies the subtype of error being communicated. For Source
    Quench messages, this is not used, and the field is set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Unused | 4 | The 4 bytes that are left blank and not used. |'
  prefs: []
  type: TYPE_TB
- en: '| Original Datagram Portion | Variable | The full IP header and the first 8
    bytes of the payload of the datagram that was dropped due to congestion. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv4 Source Quench message format](httpatomoreillycomsourcenostarchimages287965.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 32-2. ICMPv4 Source Quench message format
  prefs: []
  type: TYPE_NORMAL
- en: Problems with Source Quench Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What's interesting about the Source Quench format is that it is basically a
    null message. It tells the source that the destination is congested but provides
    no specific information about that situation, nor does it specify what exactly
    the destination wants the source to do other than cut back on its transmission
    rate in some way. There is also no method for the destination to signal a source
    that it is no longer congested, and that the source should resume its prior sending
    rate. This means the response to a Source Quench message is left up to the device
    that receives it. Usually, a device will cut back its transmission rate until
    it no longer receives the messages, and then it may try to slowly increase the
    rate again.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar manner, there are no rules about when and how a device generates
    Source Quench messages in the first place. A common convention is that one message
    is generated for each dropped datagram. However, more intelligent algorithms may
    be employed, especially on higher-end routers, to predict when the device's buffer
    will be filled and preemptively quench certain sources that are sending too quickly.
    Devices may also decide whether to quench all sources when they become busy, or
    only certain ones. As with other ICMP error messages, a device cannot count on
    a Source Quench message being sent when a busy device discards one of its datagrams.
  prefs: []
  type: TYPE_NORMAL
- en: The lack of information communicated in Source Quench messages makes them a
    rather crude tool for managing congestion. In general terms, the process of regulating
    the sending of messages between two devices is called *flow control*, and this
    is usually a function of the transport layer. TCP actually has a flow control
    mechanism (discussed in [Chapter 49](ch49.html "Chapter 49. TCP RELIABILITY AND
    FLOW CONTROL FEATURES")) that is far superior to the use of ICMP Source Quench
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue with Source Quench messages is that they can be abused. Transmission
    of these messages by a malicious user can cause a host to be slowed down when
    there is no valid reason. This security issue, combined with the superiority of
    the TCP method for flow control, has caused the use of Source Quench messages
    to largely fall out of favor.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** ICMPv4 *Source Quench* messages are sent by a device to request
    that another reduce the rate at which it is sending datagrams. The messages are
    a rather crude method of flow control compared to more capable mechanisms such
    as those provided by TCP.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Time Exceeded Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Large IP internetworks can have thousands of interconnected routers that pass
    datagrams between devices on various networks. In large internetworks, the topology
    of connections between routes can become complex, which makes routing more difficult.
    Routing protocols will normally allow routers to find the best routes between
    networks, but in some situations, an inefficient route might be selected for a
    datagram. In the worst case, a *router loop* may occur. An example of this situation
    is where Router A thinks datagrams intended for Network X should next go to Router
    B, which thinks they should go to Router C, which thinks they need to go to Router
    A. (See the ICMPv6 Time Exceeded Message description in [Chapter 34](ch34.html
    "Chapter 34. ICMPV6 ERROR MESSAGE TYPES AND FORMATS") for an illustration of a
    router loop.)
  prefs: []
  type: TYPE_NORMAL
- en: If a loop like this occurred, datagrams for Network X that were entering this
    part of the internetwork would circle forever, chewing up bandwidth and eventually
    leading to the network being unusable. As insurance against this occurrence, each
    IP datagram includes in its header a Time to Live (TTL) field. This field was
    originally intended to limit the maximum time (in seconds) that a datagram could
    be on the internetwork, but now limits the life of a datagram by limiting the
    number of times the datagram can be passed from one device to the next. The TTL
    is set to a value by the source that represents the maximum number of hops it
    wants for the datagram. Each router decrements the value; if it ever reaches zero,
    the datagram is said to have *expired* and is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: When a datagram is dropped due to expiration of the TTL field, the device that
    dropped the datagram will inform the source of this occurrence by sending it an
    ICMPv4 *Time Exceeded* message, as shown in [Figure 32-3](ch32s03.html#expiration_of_an_ip_datagram_and_time_ex
    "Figure 32-3. Expiration of an IP datagram and Time Exceeded message generation
    In this example, Device A sends an IP datagram to Device B, which has a Time to
    Live (TTL) field value of only 4 (perhaps not realizing that Device B is seven
    hops away). On the fourth, hop the datagram reaches Router R4, which decrements
    its TTL field to 0 and then drops it as it expires. Router R4 then sends an ICMP
    Time Exceeded message back to Device A."). Receipt of this message indicates to
    the original sending device that there is a routing problem when sending to that
    particular destination, or that it set the TTL field value too low in the first
    place. As with all ICMP messages, the device receiving it must decide whether
    and how to respond to receipt of the message. For example, it may first try to
    resend the datagram with a higher TTL value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Expiration of an IP datagram and Time Exceeded message generation In this
    example, Device A sends an IP datagram to Device B, which has a Time to Live (TTL)
    field value of only 4 (perhaps not realizing that Device B is seven hops away).
    On the fourth, hop the datagram reaches Router R4, which decrements its TTL field
    to 0 and then drops it as it expires. Router R4 then sends an ICMP Time Exceeded
    message back to Device A.](httpatomoreillycomsourcenostarchimages287967.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 32-3. Expiration of an IP datagram and Time Exceeded message generation
    In this example, Device A sends an IP datagram to Device B, which has a Time to
    Live (TTL) field value of only 4 (perhaps not realizing that Device B is seven
    hops away). On the fourth, hop the datagram reaches Router R4, which decrements
    its TTL field to 0 and then drops it as it expires. Router R4 then sends an ICMP
    Time Exceeded message back to Device A.
  prefs: []
  type: TYPE_NORMAL
- en: There is another time expiration situation where ICMP Time Exceeded messages
    are used. When an IP message is broken into fragments, the destination device
    is charged with reassembling them into the original message. One or more fragments
    may not make it to the destination, so to prevent the device from waiting forever,
    it sets a timer when the first fragment arrives. If this timer expires before
    the others are received, the device gives up on this message. The fragments are
    discarded, and a Time Exceeded message is generated.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Time Exceeded Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 32-4](ch32s03.html#icmpv_time_exceeded_message_format "Table 32-4. ICMPv4
    Time Exceeded Message Format") and [Figure 32-4](ch32s03.html#icmpv4_time_exceeded_message_forma-id001
    "Figure 32-4. ICMPv4 Time Exceeded message format") show the specific format for
    ICMPv4 Time Exceeded messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 32-4. ICMPv4 Time Exceeded Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMP message type; for Time Exceeded messages,
    this is set to 11. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Identifies the subtype of error being communicated. A value of
    0 indicates expiration of the IP TTL field; a value of 1 indicates that the fragment
    reassembly time has been exceeded. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Unused | 4 | The 4 bytes that are left blank and not used. |'
  prefs: []
  type: TYPE_TB
- en: '| Original Datagram Portion | Variable | The full IP header and the first 8
    bytes of the payload of the datagram that was dropped due to expiration of the
    TTL field or reassembly timer. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv4 Time Exceeded message format](httpatomoreillycomsourcenostarchimages287969.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 32-4. ICMPv4 Time Exceeded message format
  prefs: []
  type: TYPE_NORMAL
- en: Applications of Time Exceeded Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ICMP Time Exceeded messages are usually sent in response to the two conditions
    described in [Table 32-4](ch32s03.html#icmpv_time_exceeded_message_format "Table 32-4. ICMPv4
    Time Exceeded Message Format"): TTL or reassembly timer expiration. Generally,
    routers generate TTL expiration messages as they try to route a datagram, while
    end hosts indicate reassembly violations. However, there is actually a very clever
    application of these messages that has nothing to do with reporting errors at
    all.'
  prefs: []
  type: TYPE_NORMAL
- en: The TCP/IP *traceroute* (or *tracert*) utility is used to show the sequence
    of devices over which a datagram is passed on a particular route between a source
    and destination. The traceroute utility also shows the amount of time it takes
    for a datagram to reach each hop in that route. This utility was originally implemented
    using Time Exceeded messages by sending datagrams with successively higher TTL
    values.
  prefs: []
  type: TYPE_NORMAL
- en: First, a dummy datagram is sent with a TTL value of 1, causing the first hop
    in the route to discard the datagram and send back an ICMP Time Exceeded message;
    the time elapsed for this could then be measured. Then, a second datagram is sent
    with a TTL value of 2\. This causes the second device in the route to report back
    a Time Exceeded message, and so on. By continuing to increase the TTL value you
    can get reports back from each hop in the route. See [Chapter 88](ch88.html "Chapter 88. TCP/IP
    ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS") for more details
    on traceroute's operation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** ICMPv4 *Time Exceeded* messages are sent in two different time-related
    circumstances. The first is if a datagram''s Time to Live (TTL) field is reduced
    to zero, causing it to expire and the datagram to be dropped. The second is when
    all the pieces of a fragmented message are not received before the expiration
    of the recipient''s reassembly timer.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Redirect Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every device on an internetwork needs to be able to send to every other device.
    If hosts were responsible for determining the routes to each possible destination,
    each host would need to maintain an extensive set of routing information. Since
    there are so many hosts on an internetwork, this would be a very time-consuming
    and maintenance-intensive situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, IP internetworks are designed around a fundamental design decision:
    Routers are responsible for determining routes and maintaining routing information.
    Hosts determine only when they need a datagram routed, and then hand the datagram
    off to a local router to be sent where it needs to go. I discuss this in more
    detail in my overview of IP routing concepts (see [Chapter 23](ch23.html "Chapter 23. IP
    ROUTING AND MULTICASTING")).'
  prefs: []
  type: TYPE_NORMAL
- en: Since most hosts do not maintain routing information, they must rely on routers
    to know about routes and where to send datagrams intended for different destinations.
    Typically, a host on an IP network will start out with a routing table that basically
    tells it to send everything not on the local network to a single *default router*,
    which will then figure out what to do with it. Obviously, if there is only one
    router on the network, the host will use that as the default router for all nonlocal
    traffic. However, if there are two or more routers, sending all datagrams to just
    one router may not make sense. It is possible that a host could be manually configured
    to know which router to use for which destinations, but another mechanism in IP
    can allow a host to learn this automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a Network N1 that contains a number of hosts (H1, H2, and so on) and
    two routers, R1 and R2\. Host H1 has been configured to send all datagrams to
    Router R1, as its default router. Suppose it wants to send a datagram to a device
    on Network N2\. However, Network N2 is most directly connected to Network N1 using
    Router R2, not R1\. The datagram will first be sent to Router R1, which will look
    in its routing table and see that datagrams for Network N2 need to be sent through
    Router R2\. "But wait," R1 says. "R2 is on the local network, and H1 is on the
    local network—so why am I needed as a middleman? H1 should just send datagrams
    for N2 directly to R2 and leave me out of it."
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, Router R1 will send an ICMPv4 *Redirect* message back to
    Host H1, telling it that in the future, it should send this type of datagram directly
    to Router R2\. This situation is shown in [Figure 32-5](ch32s04.html#host_redirection_using_an_icmp_redirect_
    "Figure 32-5. Host redirection using an ICMP Redirect message In this example,
    Host H1 sends to Router R1 a datagram destined for Network N2\. However, Router
    R1 notices that Router R2 is on the same network and is a more direct route to
    Network N2\. It forwards the datagram on to Router R2, but also sends an ICMP
    Redirect message back to Host H1 to tell it to use Router R2 next time."). Router
    R1 will also forward the datagram to Router R2 for delivery, since there is no
    reason to drop the datagram. Thus, despite usually being grouped along with true
    ICMP error messages, Redirect messages are really arguably not error messages
    at all. They represent a situation in which only inefficiency exists, not outright
    error. (In fact, in ICMPv6, they have been reclassified.)
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Redirect Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 32-5](ch32s04.html#icmpv_redirect_message_format "Table 32-5. ICMPv4
    Redirect Message Format") and [Figure 32-6](ch32s04.html#icmpv4_redirect_message_format-id001
    "Figure 32-6. ICMPv4 Redirect message format") show the specific format for ICMPv4
    Redirect messages.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Host redirection using an ICMP Redirect message In this example, Host H1
    sends to Router R1 a datagram destined for Network N2\. However, Router R1 notices
    that Router R2 is on the same network and is a more direct route to Network N2\.
    It forwards the datagram on to Router R2, but also sends an ICMP Redirect message
    back to Host H1 to tell it to use Router R2 next time.](httpatomoreillycomsourcenostarchimages287971.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 32-5. Host redirection using an ICMP Redirect message In this example,
    Host H1 sends to Router R1 a datagram destined for Network N2\. However, Router
    R1 notices that Router R2 is on the same network and is a more direct route to
    Network N2\. It forwards the datagram on to Router R2, but also sends an ICMP
    Redirect message back to Host H1 to tell it to use Router R2 next time.
  prefs: []
  type: TYPE_NORMAL
- en: Table 32-5. ICMPv4 Redirect Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMP message type; for Redirect messages, this
    value is 5. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Identifies the meaning or scope of the Redirect message. See [Table 32-6](ch32s04.html#icmp_redirect_message_interpretation_cod
    "Table 32-6. ICMP Redirect Message Interpretation Codes") for an explanation of
    how this field is used in Redirect messages. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Internet Address | 4 | The address of the router to which future datagrams
    sent to the original destination should be sent. |'
  prefs: []
  type: TYPE_TB
- en: '| Original Datagram Portion | Variable | The full IP header and the first 8
    bytes of the payload of the datagram that led to the creation of the Redirect.
    |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv4 Redirect message format](httpatomoreillycomsourcenostarchimages287973.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 32-6. ICMPv4 Redirect message format
  prefs: []
  type: TYPE_NORMAL
- en: Redirect Message Interpretation Codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a Redirect message is received back by a device, it inspects the included
    portion of the original datagram. Since this contains the original destination
    address of the redirected target device, this tells the original sender which
    addresses should be redirected in the future. The Internet Address field tells
    it which router it should use for subsequent datagrams. The Code field tells the
    sender how broadly to interpret the redirection. There are four different Code
    values, as shown in [Table 32-6](ch32s04.html#icmp_redirect_message_interpretation_cod
    "Table 32-6. ICMP Redirect Message Interpretation Codes").
  prefs: []
  type: TYPE_NORMAL
- en: Table 32-6. ICMP Redirect Message Interpretation Codes
  prefs: []
  type: TYPE_NORMAL
- en: '| Code Value | Message Subtype | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Redirect Datagrams for the Network (or Subnet) | Redirect all future
    datagrams sent not only to the device whose address caused this Redirect, but
    also to all other devices on the network (or subnet) where that device is located.
    (This code is now obsolete; see the note that follows this table.) |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Redirect Datagrams for the Host | Redirect all future datagrams only
    for the address of the specific device to which the original datagram was sent.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Redirect Datagrams for the Type of Service (TOS) and Network (or Subnet)
    | Same as for Code value 0, but only for future datagrams that have the same TOS
    value as the original datagram. (This code is now obsolete; see the note that
    follows this table.) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Redirect Datagrams for the TOS and Host | As for Code value 1, but only
    for future datagrams that have the same TOS value as the original datagram. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*One problem with* Redirects *for whole networks is that the network specification
    may be ambiguous in an environment where subnetting or classless addressing is
    used. For this reason, the use of Code values 0 and 2 was prohibited by RFC 1812;
    the values are considered obsolete on the modern Internet*.'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, routers usually generate Redirect messages and send them to hosts;
    hosts do not normally create them. The specific rules for when Redirect messages
    are created can be fairly complex, as a number of conditions may exist that preclude
    these messages from being sent. In particular, special rules exist for when a
    router may redirect an entire network (or subnet) instead of just a single host.
    Also, remember that the TOS field is optional and often not used, so Redirects
    with Code values of 2 or 3 are less common than those with values of 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of Redirect Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep in mind that ICMP Redirect messages are *not* a mechanism by which the
    general routing process in IP is implemented; they are only a support function.
    They are a convenient way for hosts to be given information about routes by local
    routers, but are not used to communicate route information between routers.
  prefs: []
  type: TYPE_NORMAL
- en: This means that a Redirect message can tell a host to use a more efficient first-hop
    router, but cannot tell a router to use a more efficient second-hop router. In
    the previous example (illustrated in [Figure 32-5](ch32s04.html#host_redirection_using_an_icmp_redirect_
    "Figure 32-5. Host redirection using an ICMP Redirect message In this example,
    Host H1 sends to Router R1 a datagram destined for Network N2\. However, Router
    R1 notices that Router R2 is on the same network and is a more direct route to
    Network N2\. It forwards the datagram on to Router R2, but also sends an ICMP
    Redirect message back to Host H1 to tell it to use Router R2 next time.")), suppose
    that in addition to the connections mentioned, Router R2 is connected to Router
    R3 and Router R4\. Router R2 sends the datagram in question to Router R3, which
    realizes it needs to send to Router R4, a router already directly connected to
    Router R2\. Router R3 *cannot* send a Redirect message to Router R2 telling it
    to use Router R4 next time. The messages are simply not designed for this purpose—remember
    that ICMP messages always go back to the source of the original datagram, which
    would not be Router R2 in this case. Such inefficiencies must be resolved using
    routing protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** A router uses ICMPv4 *Redirect* messages to inform a host of
    a preferred router that will be used for future datagrams that are sent to a particular
    host or network. They are not used to alter routes between routers.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Parameter Problem Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous sections in this chapter describe four specific ICMPv4 message
    types that allow a device to report various error conditions to the original sender
    of a datagram. However, other error situations may arise that don't correspond
    to any of these four specific message types. Typically, the problem results when
    a device attempts to process the header fields of an IP datagram and finds something
    in it that doesn't make sense.
  prefs: []
  type: TYPE_NORMAL
- en: If a device finds a problem with any of the parameters in an IP datagram header
    that is serious enough that it cannot complete processing the header, it must
    discard the datagram. As in other cases where a datagram must be tossed out, this
    is serious enough to warrant communication of the problem back to the device that
    sent the original datagram. This is accomplished in ICMPv4 using the *Parameter
    Problem* message type.
  prefs: []
  type: TYPE_NORMAL
- en: This is a catchall type of message that can be used to indicate an error in
    any header field of an IP datagram. The message type does not contain any specific
    fields or coding to indicate what the problem is. This was done intentionally
    to keep the Parameter Problem message generic and ensure that it could indicate
    any sort of error. Instead of special error codes, most Parameter Problem messages
    tell the original source which parameter caused the problem by including a special
    pointer that indicates which field in the original datagram header caused the
    problem. Both hosts and routers can generate Parameter Problem messages.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Parameter Problem Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 32-7](ch32s05.html#icmpv_parameter_problem_message_format "Table 32-7. ICMPv4
    Parameter Problem Message Format") and [Figure 32-7](ch32s05.html#icmpv4_parameter_problem_message_f-id001
    "Figure 32-7. ICMPv4 Parameter Problem message format") show the specific format
    for ICMPv4 Parameter Problem messages.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ICMPv4 Parameter Problem message format](httpatomoreillycomsourcenostarchimages287975.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 32-7. ICMPv4 Parameter Problem message format
  prefs: []
  type: TYPE_NORMAL
- en: Table 32-7. ICMPv4 Parameter Problem Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMP message type; for Parameter Problem messages,
    this value is 12. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Identifies the subtype of the problem being communicated. See
    [Table 32-8](ch32s05.html#icmpv_parameter_problem_message_interpre "Table 32-8. ICMPv4
    Parameter Problem Message Interpretation Codes") for more information about this
    field as it relates to Parameter Problem messages. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Pointer | 1 | An offset that points to the byte location in the datagram
    that caused the Parameter Problem message to be generated. The device receiving
    the ICMP message can use this value to get an idea of which field in the original
    message had the problem. This field is used only when the Code value is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Unused | 3 | 3 bytes that are left blank and not used. |'
  prefs: []
  type: TYPE_TB
- en: '| Original Datagram Portion | Variable | The full IP header and the first 8
    bytes of the payload of the datagram that prompted this error message to be sent.
    |'
  prefs: []
  type: TYPE_TB
- en: Parameter Problem Message Interpretation Codes and the Pointer Field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a Parameter Problem message is generated due to a specific bad field in
    the original message, the Pointer field is used to show the location of the problem.
    This meaning of the Parameter Problem message is the one that was defined in the
    original ICMP standard, RFC 792, and is associated with Code value 0\. There are
    some cases of a parameter problem in which a pointer to a specific field in the
    original message really wouldn't make sense, so other standards have defined two
    new Code field values for Parameter Problem messages. [Table 32-8](ch32s05.html#icmpv_parameter_problem_message_interpre
    "Table 32-8. ICMPv4 Parameter Problem Message Interpretation Codes") shows the
    three Code values and provides a brief explanation of each one.
  prefs: []
  type: TYPE_NORMAL
- en: Table 32-8. ICMPv4 Parameter Problem Message Interpretation Codes
  prefs: []
  type: TYPE_NORMAL
- en: '| Code Value | Message Subtype | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Pointer Indicates the Error | This is the normal use of the Parameter
    Problem message. When this Code value is used, the Pointer field indicates the
    location of the problem. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Missing a Required Option | The IP datagram needed to have an option
    in it that was missing. Since the option was missing, there is no way to point
    to it. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Bad Length | The length of the datagram overall was incorrect, indicating
    a general problem with the message as a whole. Again, the Pointer field makes
    no sense here. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The ICMPv4 *Parameter Problem* message is a generic catchall
    that can be used to convey an error of any type in an IP datagram. A special Pointer
    field is normally used to indicate to the message''s recipient where the problem
    was in the original datagram.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Pointer field is only eight bits wide, but since this allows for
    values of up to 256, it is sufficient for allowing it to point to any location
    within the IP header. It is possible for the Pointer field to point to a field
    within an IP option.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The five Internet Control Message Protocol (ICMP) error message types we examined
    in the previous chapter communicate important information about error or problem
    conditions encountered during the operation of an Internet Protocol (IP) internetwork.
    In contrast, the other class of ICMP messages contains those messages that are
    *informational*. They are not sent in response to some issue with a regular IP
    datagram, but are used on their own to implement various support functions for
    IP. Informational messages are used for testing and diagnostic purposes, as well
    as for allowing devices to share critical information that they need to function
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I describe nine different ICMP version 4 (ICMPv4) informational
    messages. Because many of these messages are used in functional sets, pairs of
    related messages are described together. I begin with a discussion of the Echo
    (Request) and Echo Reply messages used for network testing, and Timestamp (Request)
    and Timestamp Reply messages used for clock synchronization. I explain the use
    and format of Router Advertisement and Router Solicitation messages, which allow
    hosts to discover the identity of local routers and learn important information
    about them. I also describe the Address Mask Request and Address Mask Reply messages
    that communicate subnet mask information. I conclude with a look at the Traceroute
    message, which implements a more sophisticated version of the traceroute utility.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The original ICMP standard also defined two more informational message types:
    Information Request and Information Reply. These were intended to allow devices
    to determine an IP address and possibly other configuration information. This
    function was later implemented using host configuration protocols such as the
    Reverse Address Resolution Protocol (RARP), Boot Protocol (BOOTP), and Dynamic
    Host Configuration Protocol (DHCP). These message types are now obsolete; therefore,
    they are not discussed in this chapter*.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Echo (Request) and Echo Reply Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main purposes of ICMP informational messages is to enable testing
    and diagnostics in order to help identify and correct problems on an internetwork.
    The most basic test that can be conducted between two devices is simply checking
    if they are capable of sending datagrams to each other. The usual way that this
    is done is to have one device send a test message to a second device, which receives
    the message and replies back to tell the first device it received the message.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 includes a pair of messages specifically for connection testing. Suppose
    Device A wants to see if it can reach Device B. Device A begins the test process
    by sending an ICMPv4 *Echo* message to Device B. Device B, when it receives the
    Echo, responds back to Device A with an *Echo* Reply message. When Device A receives
    this message, it knows that it is able to communicate (both send and receive)
    successfully with Device B.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The name of the first message in this pair is often given as Echo Request.
    While this does convey the paired nature of the Echo and Echo Reply messages,
    the formal name used in the standards is simply an Echo message*.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Echo and Echo Reply Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 33-1](ch33.html#icmpv_echo_and_echo_reply_message_format "Table 33-1. ICMPv4
    Echo and Echo Reply Message Format") and [Figure 33-1](ch33.html#icmpv4_echo_and_echo_reply_message-id001
    "Figure 33-1. ICMPv4 Echo and Echo Reply message format Two special fields are
    used within the format of these messages. They allow devices to match Echo and
    Echo Reply messages together, and exchange a sequence of messages. The Identifier
    field was envisioned as being used as a higher-level label, like a session identifier,
    while the Sequence Number was seen as something to identify individual test messages
    within a series. However, the use of these fields is up to the particular implementation.
    In some cases, the Identifier field is filled in with the process number of the
    application that is using the Echo or Echo Reply message to allow several users
    to use utilities like ping without interference.") show the format for both ICMPv4
    Echo and Echo Reply messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 33-1. ICMPv4 Echo and Echo Reply Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMP message type. For Echo messages, the value
    is 8; for Echo Reply messages, the value is 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Not used for Echo and Echo Reply messages; set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Identifier | 2 | An identification field that can be used to help in matching
    Echo and Echo Reply messages. |'
  prefs: []
  type: TYPE_TB
- en: '| Sequence Number | 2 | A sequence number to help in matching Echo and Echo
    Reply messages. |'
  prefs: []
  type: TYPE_TB
- en: '| Optional Data | Variable | Additional data to be sent along with the message
    (not specified). |'
  prefs: []
  type: TYPE_TB
- en: It is possible that a source device may want to send more than one Echo message
    to either a single destination or multiple destinations. Conversely, a single
    destination might receive Echo messages from more than one source. It is essential
    that a device receiving an Echo Reply message knows which Echo message prompted
    it to be sent.
  prefs: []
  type: TYPE_NORMAL
- en: '![ICMPv4 Echo and Echo Reply message format Two special fields are used within
    the format of these messages. They allow devices to match Echo and Echo Reply
    messages together, and exchange a sequence of messages. The Identifier field was
    envisioned as being used as a higher-level label, like a session identifier, while
    the Sequence Number was seen as something to identify individual test messages
    within a series. However, the use of these fields is up to the particular implementation.
    In some cases, the Identifier field is filled in with the process number of the
    application that is using the Echo or Echo Reply message to allow several users
    to use utilities like ping without interference.](httpatomoreillycomsourcenostarchimages287977.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 33-1. ICMPv4 Echo and Echo Reply message format Two special fields are
    used within the format of these messages. They allow devices to match Echo and
    Echo Reply messages together, and exchange a sequence of messages. The Identifier
    field was envisioned as being used as a higher-level label, like a session identifier,
    while the Sequence Number was seen as something to identify individual test messages
    within a series. However, the use of these fields is up to the particular implementation.
    In some cases, the Identifier field is filled in with the process number of the
    application that is using the Echo or Echo Reply message to allow several users
    to use utilities like ping without interference.
  prefs: []
  type: TYPE_NORMAL
- en: Application of Echo and Echo Reply Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common way that you may use the Echo and Echo Reply messages is through
    the popular utility *ping*, which is used to test host reachability. While the
    basic test simply consists of sending an Echo message and waiting for an Echo
    Reply message, modern versions of ping are quite sophisticated. They allow the
    user to specify many parameters, including the number of Echo messages sent, how
    often they are sent, the size of message transmitted, and more. They also provide
    a great deal of information about the connection, including the number of Echo
    Reply messages received, the time elapsed for the pair of messages to be exchanged,
    and a lot more. See the description of ping in [Chapter 88](ch88.html "Chapter 88. TCP/IP
    ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS") for a full explanation
    of the utility.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** ICMPv4 *Echo (Request)* and *Echo Reply* messages are used
    to facilitate network reachability testing. A device can test its ability to perform
    basic communication with another one by sending an Echo message and waiting for
    an Echo Reply message to be returned by the other device. The ping utility, a
    widely used diagnostic tool in TCP/IP internetworks, makes use of these messages.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Timestamp (Request) and Timestamp Reply Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the hosts and routers on an internetwork operate independently of each
    other. One aspect of this autonomy is that each device maintains a separate system
    clock. There''s a problem, however: Even highly accurate clocks have slight differences
    in both how accurately they keep time and the time with which they were initialized
    at startup. This means that under normal circumstances, no two devices on an internetwork
    are guaranteed to have exactly the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: The creators of TCP/IP recognized that certain applications might not work properly
    if there were too much differential between the system clocks of a pair of devices.
    To support this requirement, they created a pair of ICMP messages that allow devices
    to exchange system time information. The initiating device creates a Timestamp
    message and sends it to the device with which it wishes to synchronize. That device
    responds with a Timestamp Reply message. Timestamp fields in these messages are
    used to mark the times that these messages are sent and received to allow the
    devices' clocks to be synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*As with the Echo message (described in the previous section), the Timestamp
    message is sometimes seen as Timestamp Request, though the word* Request *doesn''t
    appear in its formal name*.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Timestamp and Timestamp Reply Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ICMPv4 *Timestamp* and *Timestamp Reply* messages have the same format.
    The originating device fills in some of the fields, and the replying device fills
    in others. The format is as shown in [Table 33-2](ch33s02.html#icmpv_timestamp_and_timestamp_reply_mess
    "Table 33-2. ICMPv4 Timestamp and Timestamp Reply Message Format") and [Figure 33-2](ch33s02.html#icmpv4_timestamp_and_timestamp_rep-id001
    "Figure 33-2. ICMPv4 Timestamp and Timestamp Reply message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 33-2. ICMPv4 Timestamp and Timestamp Reply Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMP message type. For Timestamp messages, the
    value is 13; for Timestamp Reply messages, the value is 14. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Not used for Timestamp and Timestamp Reply messages; set to 0.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Identifier | 2 | An identification field that can be used to help in matching
    Timestamp and Timestamp Reply messages. |'
  prefs: []
  type: TYPE_TB
- en: '| Sequence Number | 2 | A sequence number to help in matching Timestamp and
    Timestamp Reply messages. |'
  prefs: []
  type: TYPE_TB
- en: '| Originate Timestamp | 4 | A time value filled in by the originating device
    just before sending the Timestamp message. |'
  prefs: []
  type: TYPE_TB
- en: '| Receive Timestamp | 4 | A time value filled in by the responding device just
    as it receives the Timestamp message. |'
  prefs: []
  type: TYPE_TB
- en: '| Transmit Timestamp | 4 | A time value filled in by the responding device
    just before sending back the Timestamp Reply message. |'
  prefs: []
  type: TYPE_TB
- en: The Identifier and Sequence Number fields are used to match Timestamp and Timestamp
    Reply messages, exactly as they are used for Echo and Echo Reply messages. The
    Identifier field is intended as a higher-level label, like a session identifier,
    while the Sequence Number is often used to identify individual messages within
    a series. However, the use of these fields is up to the particular implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '![ICMPv4 Timestamp and Timestamp Reply message format](httpatomoreillycomsourcenostarchimages287979.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 33-2. ICMPv4 Timestamp and Timestamp Reply message format
  prefs: []
  type: TYPE_NORMAL
- en: All three timestamps are represented as the number of milliseconds since midnight,
    *Universal Time* (*UT*, also called *Greenwich mean time* or *GMT* ). The reason
    there are three timestamps instead of the two you might ordinarily expect is that
    the responding device records a separate timestamp when it receives the Timestamp
    message and when it generates the Timestamp Reply. When the Reply message is received
    back by the originating device, it then has the times that both the Timestamp
    and the Timestamp Reply messages were sent. This allows the originating device
    to differentiate between the time required for transmitting datagrams over the
    network and the time for the other device to process the Timestamp message and
    turn it into a Timestamp Reply message.
  prefs: []
  type: TYPE_NORMAL
- en: Issues Using Timestamp and Timestamp Reply Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In practice, even with these three timestamp fields, it is difficult to coordinate
    system clocks over an internetwork, especially a large one like the Internet.
    The main problem is that the amount of time it takes to send a datagram between
    any pair of devices varies from one datagram to the next. And again, since IP
    is unreliable, it's possible that the time for a datagram to be received could
    be infinite. In fact, it might be lost or dropped by a router.
  prefs: []
  type: TYPE_NORMAL
- en: This means that a simple exchange of Timestamp and Timestamp Reply messages
    is simply not a method that's reliable enough to ensure that two devices are synchronized
    on a typical IP internetwork. For this reason, modern devices often use a more
    sophisticated method for time synchronization, such as the Network Time Protocol
    (NTP).
  prefs: []
  type: TYPE_NORMAL
- en: Note that unlike many of the other ICMP message types, support for Timestamp
    and Timestamp Reply messages is optional, for both hosts and routers.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Router Advertisement and Router Solicitation Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 23](ch23.html "Chapter 23. IP ROUTING AND MULTICASTING"), which
    described IP routing fundamentals, I discussed a critical aspect of IP internetwork
    design: the difference between the roles of a router and the roles of a host with
    regard to routing. Routers are charged with the job of routing datagrams, and
    therefore, of knowing routes and exchanging route information. Hosts generally
    do not know a great deal about routes; they rely on routers to convey datagrams
    intended for destinations outside the local network.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This dependence means that before a host can really participate on an internetwork,
    it needs to know the identity of at least one router on the local network. One
    way to ensure that this is the case is to just manually configure each host with
    the address of a local router as its default router. This method is simple, but
    has the typical drawbacks associated with manual processes: It is time-consuming
    to set up, difficult to maintain, and inflexible.'
  prefs: []
  type: TYPE_NORMAL
- en: The Router Discovery Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It would be better if there were some method whereby a host could automatically
    discover the identity of local routers and learn important information about them.
    In IP, this process is called *Router Discovery* and was first defined in RFC
    1256, "ICMP Router Discovery Messages." The messages referenced in the RFC title
    are the ICMP Router Advertisement message and the Router Solicitation message.
    They were added to the ICMP message types that were defined in earlier standards
    such as RFC 792.
  prefs: []
  type: TYPE_NORMAL
- en: Routers are responsible for sending *Router Advertisement* messages. These messages
    tell listening devices that the router exists, and they provide important information
    about the router such as its address (or addresses, if it has more than one) and
    how long the host should retain information about the router. Routine Router Advertisement
    messages are sent on a regular basis, and an administrator can configure the time
    between messages (usually between seven and ten minutes). Hosts listen for these
    messages; when an advertisement is received, the host processes it and adds the
    information about the router to its routing table.
  prefs: []
  type: TYPE_NORMAL
- en: A host that does not have any manually configured routing information will have
    no knowledge of routers when it first powers on. Having it sit for many minutes
    while it looks for a routine Router Advertisement message is inefficient. Instead
    of waiting, the host may send a *Router Solicitation* message on its local network(s).
    This will prompt any router that hears it to immediately send out an extra Router
    Advertisement message directly to that host.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Router Advertisement Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ICMPv4 Router Advertisement message format is shown in [Table 33-3](ch33s03.html#icmpv_router_advertisement_message_forma
    "Table 33-3. ICMPv4 Router Advertisement Message Format") and [Figure 33-3](ch33s03.html#icmpv4_router_advertisement_messag-id001
    "Figure 33-3. ICMPv4 Router Advertisement Message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 33-3. ICMPv4 Router Advertisement Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMP message type. For Router Advertisement messages,
    the value is 9. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Normally set to 0\. When a Mobile IP agent is sending a Router
    Advertisement with an Agent Advertisement extension, it may set the value to 16
    only if the device is a mobile agent and doesn''t intend to handle normal traffic.
    See the discussion of Mobile IP agent discovery for details ([Chapter 30](ch30.html
    "Chapter 30. INTERNET PROTOCOL MOBILITY SUPPORT (MOBILE IP)")). |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Num Addrs | 1 | The number of addresses associated with this router that
    are included in this advertisement. |'
  prefs: []
  type: TYPE_TB
- en: '| Addr Entry Size | 1 | The address entry size—number of 32-bit words of information
    included with each address. Since in this message format each router address has
    a 32-bit address and a 32-bit preference level, this value is fixed at 2. |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime | 2 | The number of seconds that a host should consider the information
    in this message valid. |'
  prefs: []
  type: TYPE_TB
- en: '| Router Address Entries | Value of Num Addrs field * 8 | A number of router
    address entries equal to the value of the Num Addrs field. Each is 8 bytes and
    has two subfields, each 4 bytes in size. The Router Address subfield is a valid
    address for an interface to the router sending this message. The Preference Level
    subfield is the preference level of this address. When more than one address is
    included in an advertisement, this field indicates which address the router would
    prefer hosts to use. Higher values mean greater preference. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv4 Router Advertisement Message format](httpatomoreillycomsourcenostarchimages287981.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 33-3. ICMPv4 Router Advertisement Message format
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Router Solicitation Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ICMPv4 Router Solicitation messages are much simpler, because they need to
    convey only the following single piece of information: "If you are a router and
    can hear this, please send a Router Advertisement to me." The format is therefore
    just the trivial set of fields shown in [Table 33-4](ch33s03.html#icmpv_router_solicitation_message_format
    "Table 33-4. ICMPv4 Router Solicitation Message Format") and illustrated in [Figure 33-4](ch33s03.html#icmpv4_router_solicitation_message-id001
    "Figure 33-4. ICMPv4 Router Solicitation Message format").'
  prefs: []
  type: TYPE_NORMAL
- en: Table 33-4. ICMPv4 Router Solicitation Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMP message type. For Router Solicitation messages,
    the value is 10. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Not used; value set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 4 | The 4 reserved bytes sent as 0. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv4 Router Solicitation Message format](httpatomoreillycomsourcenostarchimages287983.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 33-4. ICMPv4 Router Solicitation Message format
  prefs: []
  type: TYPE_NORMAL
- en: Addressing and Use of Router Advertisement and Router Solicitation Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If possible, both Router Advertisement and Router Solicitation messages are
    sent out as multicast for efficiency. Router Advertisements use the "all devices"
    multicast address (224.0.0.1), because they are intended for hosts to hear. *Router
    Solicitation* messages use the "all routers" multicast address (224.0.0.2). If
    the local network does not support multicast, messages are instead sent out by
    broadcast (to address 255.255.255.255).
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that just like ICMP Redirect messages, Router Advertisement
    messages are not a generalized method for exchanging routing information. They
    are a support mechanism only, used to inform hosts about the existence of routers.
    Detailed information about routes is communicated between routers using routing
    protocols, like the Routing Information Protocol (RIP) and Open Shortest Path
    First (OSPF).
  prefs: []
  type: TYPE_NORMAL
- en: Although Router Discovery is one alternative to manual configuration of a host's
    default router, there are other alternatives as well. For example, a host configuration
    protocol like the Dynamic Host Configuration Protocol (DHCP) can allow a host
    to learn the address of a default router on the local network.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that when Mobile IP is implemented, Router Advertisement messages
    are used as the basis for Mobile IP–aware routers to send Agent Advertisements.
    One or more special extensions are added to the regular Router Advertisement format
    to create an Agent Advertisement. This is discussed extensively in the section
    on Mobile IP Agent Discovery in [Chapter 31](ch31.html "Chapter 31. ICMP CONCEPTS
    AND GENERAL OPERATION").
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** ICMP *Router Advertisement* messages are sent regularly by
    IP routers to inform hosts of their presence and characteristics. This way, hosts
    know to use them for delivery of datagrams to distant hosts. A host that is new
    to a network and wants to find out immediately what routers are present may send
    a *Router Solicitation* message, which will prompt listening routers to send out
    Router Advertisement messages.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Address Mask Request and Reply Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When IP was first developed, IP addresses were based on a simple two-level structure,
    with a network identifier (network ID) and host identifier (host ID). To provide
    more flexibility, a technique called *subnetting* was soon developed. Subnetting
    expands the addressing scheme into a three-level structure, with each address
    containing a network ID, subnet identifier, and host ID. The *subnet mask* is
    a 32-bit number that tells devices (and users) which bits are part of the subnet
    identifier, as compared to the host ID. All of this is described in considerable
    detail in the part on IP addressing ([Part II-3](pt06.html "Part II-3. INTERNET
    PROTOCOL VERSION 4 (IP/IPV4)")).
  prefs: []
  type: TYPE_NORMAL
- en: To function properly in a subnetting environment, each host must know the subnet
    mask that corresponds to each address it is assigned. Without the mask, it cannot
    properly interpret IP addresses. Just as in determining the identity of a local
    router, a host can be informed of the local network's subnet mask either manually
    or automatically. The manual method is to simply manually assign the subnet mask
    to each host. The automatic method makes use of a pair of ICMP messages designed
    for subnet mask determination, which were defined in RFC 950, the same standard
    that defined subnetting itself.
  prefs: []
  type: TYPE_NORMAL
- en: To use this method, a host sends an *Address Mask Request* message on the local
    network, usually to get a response from a router. If it knows the address of a
    local router, it may send the request directly (unicast); otherwise, the host
    will broadcast the request to any listening router. A local router (or other device)
    will receive this message and respond back with an *Address Mask Reply* message
    that contains the subnet mask for the local network. This process is somewhat
    similar to the mechanism used by a host to solicit a router to respond with a
    Router Advertisement message, except that routers do not routinely send subnet
    mask information—that information must be requested.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Address Mask Request and Address Mask Reply Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Address Mask Request and Address Mask Reply, like some other request and
    reply pairs, have the same basic format. The host creates the request with all
    fields filled in except for the subnet mask value itself, and the router supplies
    the mask and sends the reply back to the host. The format is described in [Table 33-5](ch33s04.html#icmpv_address_mask_request_and_address_m
    "Table 33-5. ICMPv4 Address Mask Request and Address Mask Reply Message Format")
    and illustrated in [Figure 33-5](ch33s04.html#icmpv4_address_mask_request_and_ad-id001
    "Figure 33-5. ICMPv4 Address Mask Request and Address Mask Reply message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 33-5. ICMPv4 Address Mask Request and Address Mask Reply Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMP message type. For Address Mask Request messages,
    the value is 17; for Address Mask Reply messages, it is 18. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Not used for either message type; set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Identifier | 2 | An identification field that can be used to help in matching
    Address Mask Request and Address Mask Reply messages. |'
  prefs: []
  type: TYPE_TB
- en: '| Sequence Number | 2 | A sequence number to help in matching Address Mask
    Request and Address Mask Reply messages. |'
  prefs: []
  type: TYPE_TB
- en: '| Address Mask | 4 | The subnet mask for the local network, filled in by the
    router in the Address Mask Reply message. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv4 Address Mask Request and Address Mask Reply message format](httpatomoreillycomsourcenostarchimages287985.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 33-5. ICMPv4 Address Mask Request and Address Mask Reply message format
  prefs: []
  type: TYPE_NORMAL
- en: The Identifier and Sequence Number fields can be used to match up requests and
    replies, as they are for Echo and Echo Reply messages. However, a host won't normally
    send multiple requests for subnet masks the way it might send Echo messages for
    testing. For this reason, the Identifier and Sequence Number fields may be ignored
    by some implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Use of Address Mask Request and Address Mask Reply Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that the use of Address Mask Request and Address Mask Reply messages is
    optional, just as the Router Discovery described in the previous section is. Other
    methods besides these messages or manual configuration may be used to tell a host
    what subnet mask to use. Again, a common alternative to ICMP for this is to use
    a host configuration protocol like DHCP. Routers do need to be able to respond
    to Address Mask Requests for hosts that choose to send them.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Traceroute Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Echo and Echo Reply messages you saw earlier in this chapter are used for
    the most basic type of test that can be conducted between two devices: checking
    if they can communicate. A more sophisticated test can also be performed in order
    to see not only if the devices are able to talk, but also to discover the exact
    sequence of routers used to move datagrams between them. In TCP/IP, this diagnostic
    is performed using the traceroute (or tracert) utility.'
  prefs: []
  type: TYPE_NORMAL
- en: The first implementation of *traceroute* used a clever application of Time Exceeded
    error messages, as described in the previous chapter. By sending a test message
    to a destination first with a Time to Live (TTL) value of 1, then 2, then 3, and
    so on, each router in the path between the source and destination would successively
    discard the test messages and send back a Time Exceeded message. Each router would
    then display the sequence of routers between the two hosts. This bit of trickery
    works well enough in general terms, but is suboptimal in a couple of respects.
    For example, it requires the source device to send one test message for each router
    in the path, instead of just a single test message. It also doesn't take into
    account the possibility that the path between two devices may change during the
    test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recognizing these limitations, a new experimental standard was developed in
    1993 that defined a more efficient way to conduct a traceroute: RFC 1393, "Traceroute
    Using an IP Option." As the title suggests, this method of doing a traceroute
    works by having the source device send a single datagram to the destination that
    contains a special Traceroute IP option. Each router that sees that option while
    the test message is conducted along the route responds back to the original source
    with an ICMP Traceroute message, which is also defined in RFC 1393.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv4 Traceroute Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the *Traceroute* message was specifically designed for the traceroute
    utility, it was possible to incorporate extra information in it that a host tracing
    a route could use. The message format is as shown in [Table 33-6](ch33s05.html#icmpv_traceroute_message_format
    "Table 33-6. ICMPv4 Traceroute Message Format") and [Figure 33-6](ch33s05.html#icmpv4_traceroute_message_format-id001
    "Figure 33-6. ICMPv4 Traceroute message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 33-6. ICMPv4 Traceroute Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMP message type; in this case, 30. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Set to the value 0 if the datagram the source device sent was
    successfully sent to the next router, or 1 to indicate that the datagram was dropped
    (meaning the traceroute failed). |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| ID Number | 2 | An identification field used to match up this Traceroute
    message to the original message sent by the source (the one containing the Traceroute
    IP option). |'
  prefs: []
  type: TYPE_TB
- en: '| Unused | 2 | Not used, set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Outbound Hop Count | 2 | The number of routers the original message has already
    passed through. |'
  prefs: []
  type: TYPE_TB
- en: '| Return Hop Count | 2 | The number of routers the return message has passed
    through. |'
  prefs: []
  type: TYPE_TB
- en: '| Output Link Speed | 4 | The speed of the link over which the Traceroute message
    is being sent, in bytes per second. |'
  prefs: []
  type: TYPE_TB
- en: '| Output Link MTU | 4 | The maximum transmission unit (MTU) of the link over
    which the Traceroute message is being sent, in bytes. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv4 Traceroute message format](httpatomoreillycomsourcenostarchimages287987.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 33-6. ICMPv4 Traceroute message format
  prefs: []
  type: TYPE_NORMAL
- en: Use of Traceroute Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although this method of implementing traceroute has advantages over the older
    Time Exceeded messages method, it has one critical flaw as well: It requires changes
    to both hosts and routers to support the new IP option and the Traceroute ICMP
    message. People aren''t big on change, especially when it comes to the basic operation
    of IP. For this reason, RFC 1393 never moved beyond experimental status, and most
    IP devices still use the older method of implementing traceroute. It is possible
    that you may encounter ICMP Traceroute messages, however, so it''s good that you
    know they exist.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** ICMP *Traceroute* messages were designed to provide a more
    capable way of implementing the traceroute (tracert) utility. However, most TCP/IP
    implementations still use ICMP Time Exceeded messages for this task.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 34. ICMPV6 ERROR MESSAGE TYPES AND FORMATS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The original Internet Control Message Protocol (ICMP) defined for version 4
    of the Internet Protocol (IPv4) has a number of error messages that allow for
    the communication of problems on an internetwork. When IP version 6 (IPv6) was
    developed, the differences between IPv4 and IPv6 were significant enough that
    a new version of ICMP was also required: version 6 *(ICMPv6)*, which is currently
    specified in RFC 2463\. Like ICMPv4, ICMPv6 defines several error messages for
    informing a source that something has gone wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I describe the four ICMPv6 error messages defined in RFC 2463\.
    I first discuss ICMPv6 Destination Unreachable messages, which are used to tell
    a device that the datagram it sent could not be delivered for a variety of reasons.
    I describe Packet Too Big error messages, which are sent when a datagram can't
    be sent due to being too large for an underlying network it needs to traverse.
    I explain the use of Time Exceeded messages, which indicate that too much time
    was taken to accomplish a transmission. I conclude with a look at Parameter Problem
    messages, which provide a generalized way of reporting errors that are not described
    by any of the preceding ICMPv6 error message types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Three of the four ICMPv6 error messages (all except Packet Too Big) are equivalent
    to the ICMPv4 error messages that have the same names. However, to allow this
    chapter to stand on its own, I describe each one fully, in addition to pointing
    out any significant differences between the ICMPv4 and ICMPv6 version of the message*.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Destination Unreachable Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IPv6 includes some important enhancements over the older version 4, but the
    basic operation of the two protocols is still fundamentally the same. Like IPv4,
    IPv6 is an unreliable network protocol that makes a best effort to deliver datagrams,
    but offers no guarantees that they will always get there. Just as they did in
    IPv4, devices on an IPv6 network must not assume that datagrams sent to a destination
    will always be received.
  prefs: []
  type: TYPE_NORMAL
- en: When a datagram cannot be delivered, recovery from this condition normally falls
    to higher-layer protocols like the Transmission Control Protocol (TCP), which
    will detect the miscommunication and resend the lost datagrams. In some situations,
    such as a datagram that was dropped due to the congestion of a router, this is
    sufficient, but in other cases, a datagram may not be delivered due to an inherent
    problem with how it is being sent. For example, the source may have specified
    an invalid destination address, which means that even if it were resent many times,
    the datagram would never get to its intended recipient.
  prefs: []
  type: TYPE_NORMAL
- en: In general, having the source just resend undelivered datagrams while having
    no idea why they were lost is inefficient. It is better to have a feedback mechanism
    that can tell a source device about undeliverable datagrams and provide some information
    about why the datagram delivery failed. As in ICMPv4, in ICMPv6 this is done with
    *Destination Unreachable* messages. Each message includes a code that indicates
    the basic nature of the problem that caused the datagram not to be delivered,
    as well as all or part of the datagram that was undelivered in order to help the
    source device diagnose the problem.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Destination Unreachable Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 34-1](ch34.html#icmpv_destination_unreachable_mess-id001 "Table 34-1. ICMPv6
    Destination Unreachable Message Format") and [Figure 34-1](ch34.html#icmpv6_destination_unreachable_mes-id001
    "Figure 34-1. ICMPv6 Destination Unreachable message format") show the specific
    format for ICMPv6 Destination Unreachable messages.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ICMPv6 Destination Unreachable message format](httpatomoreillycomsourcenostarchimages287989.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 34-1. ICMPv6 Destination Unreachable message format
  prefs: []
  type: TYPE_NORMAL
- en: Table 34-1. ICMPv6 Destination Unreachable Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Destination Unreachable
    messages, this is set to 1. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Identifies the subtype of unreachable errors that are being communicated.
    See [Table 32-2](ch32.html#icmpv_destination_unreachable_message_su "Table 32-2. ICMPv4
    Destination Unreachable Message Subtypes") for a full list of codes and what they
    mean. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Unused | 4 | The 4 bytes that are left blank and not used. |'
  prefs: []
  type: TYPE_TB
- en: '| Original Datagram Portion | Variable | As much of the IPv6 datagram as will
    fit without causing the size of the ICMPv6 error message (including its own IP
    header) to exceed the minimum IPv6 maximum transmission unit (MTU) of 1280 bytes.
    |'
  prefs: []
  type: TYPE_TB
- en: ICMPv6 Destination Unreachable Message Subtypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of different reasons why a destination may be unreachable.
    To provide additional information about the nature of the problem to the device
    that originally tried to send the datagram, a value is placed in the message's
    Code field. One interesting difference between ICMPv4 and ICMPv6 Destination Unreachable
    messages is that there are many fewer Code values for ICMPv6\. The ICMPv6 Code
    values were streamlined, mainly because several of the ICMPv4 codes were related
    to relatively obscure features that aren't applicable to ICMPv6.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 34-2](ch34.html#icmpv_destination_unreachable_mess-id002 "Table 34-2. ICMPv6
    Destination Unreachable Message Subtypes") shows the different Code values, corresponding
    message subtypes, and a brief explanation of each.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 34-2. ICMPv6 Destination Unreachable Message Subtypes
  prefs: []
  type: TYPE_NORMAL
- en: '| Code Value | Message Subtype | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | No Route to Destination | The datagram was not delivered because it could
    not be routed to the destination. Since this means that the datagram could not
    be sent to the destination device''s local network, this is basically equivalent
    to the Network Unreachable message subtype in ICMPv4. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Communication with Destination Administratively Prohibited | The datagram
    could not be forwarded due to filtering that blocks the message based on its contents.
    Equivalent to the message subtype with the same name (and *Code* value 13) in
    ICMPv4. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Address Unreachable | There was a problem attempting to deliver the datagram
    to the host specified in the destination address. This code is equivalent to the
    ICMPv4 Host Unreachable code and usually means that the destination address was
    bad or that there was a problem with resolving it into a layer 2 address. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Port Unreachable | The destination port specified in the UDP or TCP header
    was invalid or does not exist on the destination host. |'
  prefs: []
  type: TYPE_TB
- en: Note that Code value 2 is not used. Also, Destination Unreachable messages are
    sent only when there is a fundamental problem with delivering a particular datagram;
    they are not sent when a datagram is dropped simply due to congestion of a router.
  prefs: []
  type: TYPE_NORMAL
- en: Processing of Destination Unreachable Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is up to the recipient of an ICMPv6 Destination Unreachable message to decide
    what to do with it. However, just as the original datagram may not reach its destination,
    the Destination Unreachable message may do the same. Therefore, a device cannot
    rely on the receipt of one of these error messages to inform it of every delivery
    problem. This is especially true given that it is possible that some unreachable
    destination problems may not be detectable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** ICMPv6 *Destination Unreachable* messages are used in the same
    manner as the ICMPv4 Destination Unreachable messages: to inform a sending device
    of a failure to deliver an IP datagram. The message''s Code field provides information
    about the nature of the delivery problem (though the Code values are different
    from those in ICMPv4).'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Packet Too Big Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most interesting changes made to the operation of IP in version 6
    is related to the process of datagram fragmentation and reassembly. In IPv4, a
    host can send a datagram of any size that's allowed by the IP specification out
    onto the internetwork. If a router needs to send the datagram over a physical
    link that has a maximum transmission unit (MTU) size that is too small for the
    size of the datagram, it will automatically fragment the datagram and send the
    fragments individually so they will fit. The destination device will receive the
    fragments and reassemble them. I explain the basics behind this in [Chapter 22](ch22.html
    "Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY").
  prefs: []
  type: TYPE_NORMAL
- en: Even though it is convenient for hosts to be able to rely on routers to automatically
    fragment messages as needed, it is inefficient for routers to spend time doing
    this. For this reason, in IPv6 developers made the decision to not allow routers
    to fragment datagrams. This puts the responsibility on each host to ensure that
    the datagrams they send out are small enough to fit over every physical network
    between itself and any destination. This is done either by using the IPv6 default
    minimum MTU of 1280, which every physical link must support, or a special Path
    MTU Discovery process for determining the minimum MTU between a pair of devices.
    Again, the full details are in [Chapter 22](ch22.html "Chapter 22. IP DATAGRAM
    SIZE, FRAGMENTATION, AND REASSEMBLY").
  prefs: []
  type: TYPE_NORMAL
- en: If an IPv6 router is not allowed to fragment an IPv6 datagram that is too large
    to fit on the next physical link over which it must be forwarded, what should
    the router do with it? The datagram can't be forwarded, so the router has no choice
    but to discard it. When this happens, the router is required to report this occurrence
    back to the device that initially sent the datagram, using an ICMPv6 *Packet Too
    Big* message. The source device will know that it needs to fragment the datagram
    in order to have it successfully reach its destination.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Recall that packet is a synonym for datagram, so you can think of this as
    the "Datagram Too Big" message*.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Packet Too Big Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 34-3](ch34s02.html#icmpv_packet_too_big_message_format "Table 34-3. ICMPv6
    Packet Too Big Message Format") and [Figure 34-2](ch34s02.html#icmpv6_packet_too_big_message_form-id001
    "Figure 34-2. ICMPv6 Packet Too Big message format") show the format for ICMPv6
    Packet Too Big messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 34-3. ICMPv6 Packet Too Big Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Packet Too Big messages,
    this is set to 2. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Not used for this message type; set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| MTU | 4 | The MTU size, in bytes, of the physical link over which the router
    wanted to send the datagram, but was not able to do so due to the datagram''s
    size. Including this value in the Packet Too Big message tells the source device
    the size it needs to use for its next transmission to this destination in order
    to avoid this problem in the future (at least for this particular link). |'
  prefs: []
  type: TYPE_TB
- en: '| Original Datagram Portion | Variable | As much of the IPv6 datagram as will
    fit without causing the size of the ICMPv6 message (including its own IP header)
    to exceed the minimum IPv6 MTU of 1280 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv6 Packet Too Big message format](httpatomoreillycomsourcenostarchimages287991.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 34-2. ICMPv6 Packet Too Big message format
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** In IPv6, routers are not allowed to fragment datagrams that
    are too large to send over a physical link to which they are connected. An oversized
    datagram is dropped, and an ICMPv6 *Packet Too Big* message is sent back to the
    datagram''s originator to inform it of this occurrence.'
  prefs: []
  type: TYPE_NORMAL
- en: Applications of Packet Too Big Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While Packet Too Big is obviously an error message, it also has another use:
    the implementation of Path MTU Discovery. This process, described in RFC 1981,
    defines a way for a device to determine the minimum MTU for a path to a destination.
    To perform Path MTU Discovery, the source device sends a series of test messages,
    decreasing the size of the datagram until it no longer receives Packet Too Big
    messages back in response to its tests. See [Chapter 27](ch27.html "Chapter 27. IPV6
    DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING") for a bit more detail
    on this.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The Packet Too Big message is new to ICMPv6\. However, its use is somewhat
    similar to the use of the Fragmentation Needed and DF Set version of the ICMP4
    Destination Unreachable message type, which is used as part of IPv4''s Path MTU
    Discovery feature*.'
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, Packet Too Big is an exception to the rule that ICMP messages
    are sent only in response to unicast datagrams; it may be sent in reply to an
    oversized multicast datagram. If this occurs, it is important to realize that
    some of the intended targets of the multicast may still have received it, if the
    path the multicast took to them did not go through the link with the small MTU
    that caused the error.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Time Exceeded Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The engineers who first designed IP recognized that due to the nature of how
    routing works on an internetwork, there was always a danger that a datagram might
    get lost in the system and spend too much time being passed from one router to
    another. They included in IPv4 datagrams a field called *Time to Live (TTL)*,
    which was intended to be set to a time value by the device sending the datagram
    and used as a timer to cause the datagram to be discarded if it took too long
    to get to its destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, the meaning of this field was changed, so it represented not a
    time in seconds but the number of hops the datagram was allowed to traverse. In
    IPv6, the new meaning of this field was formalized when it was renamed *Hop Limit*.
    Regardless of its name, the field still has the same basic purpose: It restricts
    how long a datagram can exist on an internetwork by limiting the number of times
    routers can forward it. This is particularly designed to provide protection against
    router loops that may occur in large or improperly configured internetworks. An
    example of this situation is where Router A thinks datagrams intended for Network
    X should next go to Router B, which thinks they should go to Router C, which thinks
    they need to go to Router A. Without a Hop Limit, such datagrams would circle
    forever, clogging networks and never accomplishing anything useful. [Figure 34-3](ch34s03.html#an_example_of_a_router_loop_this_diagram
    "Figure 34-3. An example of a router loop This diagram shows a simple internetwork
    consisting of four networks, each of which is served by a router. It is an adaptation
    of Figure 23-3 from Chapter 23, but in this case, the routing tables have been
    set up incorrectly. Router R1 thinks that it needs to route any traffic intended
    for Network N4 to Router R3, which thinks it goes to Router R2, which thinks it
    goes back to Router R1\. This means that when any device tries to send to Network
    N4, the datagram will circle this triangle until its Hop Limit is reached, at
    which point an ICMPv6 Time Exceeded message will be generated.") illustrates the
    router loop problem.'
  prefs: []
  type: TYPE_NORMAL
- en: Each time a router passes an IPv6 datagram, it decreases the Hop Limit field.
    If the value ever reaches zero, the datagram expires and is discarded. When this
    happens, the router that dropped the datagram sends an ICMPv6 Time Exceeded message
    back to the datagram's originator to inform it that the datagram was dropped.
    This is basically the same as the ICMPv4 *Time Exceeded* message. As in the ICMPv4
    case, the device receiving the message must decide whether and how to respond
    to receipt of the message. For example, since a device using a Hop Limit that
    was too low can cause the error, the device may try to resend the datagram with
    a higher value before concluding that there is a routing problem and giving up.
    ([Chapter 32](ch32.html "Chapter 32. ICMPV4 ERROR MESSAGE TYPES AND FORMATS")
    for an illustration of how TTL expiration works.)
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the ICMPv4 equivalent, there is also another time expiration situation
    in which ICMPv6 Time Exceeded messages are used. When an IP message is broken
    into fragments that are sent independently, the destination device is charged
    with reassembling the fragments into the original message. One or more fragments
    may not make it to the destination, however. To prevent the device from waiting
    forever, it sets a timer when the first fragment arrives. If this timer expires
    before all of the other fragments are also received, the device gives up on this
    message. The fragments are tossed out, and a Time Exceeded message is generated.
  prefs: []
  type: TYPE_NORMAL
- en: '![An example of a router loop This diagram shows a simple internetwork consisting
    of four networks, each of which is served by a router. It is an adaptation of
    from , but in this case, the routing tables have been set up incorrectly. Router
    R1 thinks that it needs to route any traffic intended for Network N4 to Router
    R3, which thinks it goes to Router R2, which thinks it goes back to Router R1\.
    This means that when any device tries to send to Network N4, the datagram will
    circle this triangle until its Hop Limit is reached, at which point an ICMPv6
    Time Exceeded message will be generated.](httpatomoreillycomsourcenostarchimages287993.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 34-3. An example of a router loop This diagram shows a simple internetwork
    consisting of four networks, each of which is served by a router. It is an adaptation
    of [Figure 23-3](ch23s03.html#ip_routing_and_routing_tables_this_diagr "Figure 23-3. IP
    routing and routing tables This diagram shows a small, simple internetwork consisting
    of four LANs each served by a router. The routing table for each lists the router
    to which datagrams for each destination network should be sent. Notice that due
    to the triangle, R1, R2, and R3 can send to each other. However, R2 and R3 must
    send through R1 to deliver to R4, and R4 must use R1 to reach either of the others.")
    from [Chapter 23](ch23.html "Chapter 23. IP ROUTING AND MULTICASTING"), but in
    this case, the routing tables have been set up incorrectly. Router R1 thinks that
    it needs to route any traffic intended for Network N4 to Router R3, which thinks
    it goes to Router R2, which thinks it goes back to Router R1\. This means that
    when any device tries to send to Network N4, the datagram will circle this triangle
    until its Hop Limit is reached, at which point an ICMPv6 Time Exceeded message
    will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Time Exceeded Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 32-4](ch32s03.html#icmpv_time_exceeded_message_format "Table 32-4. ICMPv4
    Time Exceeded Message Format") and [Figure 34-4](ch34s03.html#icmpv6_time_exceeded_message_forma-id001
    "Figure 34-4. ICMPv6 Time Exceeded message format") show the format for ICMPv6
    Time Exceeded messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 34-4. ICMPv6 Time Exceeded Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Time Exceeded messages,
    this is set to 3. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Identifies the subtype of time error that''s being communicated.
    A value of 0 indicates expiration of the Hop Limit field; a value of 1 indicates
    that the fragment reassembly time has been exceeded. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Unused | 4 | The 4 bytes left blank and not used. |'
  prefs: []
  type: TYPE_TB
- en: '| Original Datagram Portion | Variable | As much of the IPv6 datagram as will
    fit without causing the size of the ICMPv6 error message (including its own IP
    header) to exceed the minimum IPv6 MTU of 1280 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv6 Time Exceeded message format](httpatomoreillycomsourcenostarchimages287995.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 34-4. ICMPv6 Time Exceeded message format
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** Like their ICMPv4 namesakes, ICMPv6 *Time Exceeded* messages
    are sent in two different time-related circumstances. The first is if a datagram''s
    *Hop Limit* field is reduced to zero, thereby causing it to expire and the datagram
    to be dropped. The second is when all the pieces of a fragmented message are not
    received before the recipient''s reassembly timer expires.'
  prefs: []
  type: TYPE_NORMAL
- en: Applications of Time Exceeded Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In IPv4, ICMP Time Exceeded messages are used both as an error message and in
    a clever application to implement the TCP/IP traceroute command. This is done
    by first sending a dummy datagram with a TTL value of 1, thereby causing the first
    hop in the route to discard the datagram and send back an ICMP Time Exceeded message.
    Then a second datagram is sent to the same destination with a TTL value of 2,
    thus causing the second device in the route to report back a Time Exceeded message,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There is an IPv6 version of traceroute that is sometimes called *traceroute6*.
    Due to the fact that IPv6 and its protocols and applications are still in development,
    I have not been able to confirm definitively that traceroute6 is implemented using
    ICMPv6 Time Exceeded messages in the manner described earlier, but I believe this
    is the case (and it certainly would make sense). See [Chapter 88](ch88.html "Chapter 88. TCP/IP
    ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS") for more information
    about traceroute.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Parameter Problem Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ICMPv6 Destination Unreachable, Packet Too Big, and Time Exceeded messages
    described in the previous sections are used to indicate specific error conditions
    to the original sender of a datagram. Recognizing that a router or host may encounter
    some other problem in processing a datagram that is not covered by any of these
    message types, ICMPv6 includes a generic error message type, just as ICMPv4 did.
    This is called the ICMPv6 *Parameter Problem* message.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, a Parameter Problem message indicates that a device found
    a problem with a parameter (another name for a datagram field) while attempting
    to work its way through the header (or headers) in an IPv6 datagram. This message
    is generated only when the error encountered is serious enough that the device
    could not make sense of the datagram and had to discard it. So, if an error is
    found that a device is able to recover from (does not need to drop the datagram),
    no Parameter Problem message is created.
  prefs: []
  type: TYPE_NORMAL
- en: As was the case for the ICMPv4 version of this message, the ICMPv6 message was
    designed to be generic, so it can indicate an error in basically any field in
    the original datagram. A special Pointer field is used that points to the place
    in that datagram where the error was encountered. By looking at the structure
    of the original message (which, as you may recall, is included up to a certain
    size in the ICMP message format), the original device can tell which field contained
    the problem. The Code value is also used to communicate additional general information
    about the nature of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Parameter Problem Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 34-5](ch34s04.html#icmpv_parameter_problem_message_fo-id001 "Table 34-5. ICMPv6
    Parameter Problem Message Format") and [Figure 34-5](ch34s04.html#icmpv6_parameter_problem_message_f-id001
    "Figure 34-5. ICMPv6 Parameter Problem message format") show the format for ICMPv6
    Parameter Problem messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 34-5. ICMPv6 Parameter Problem Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Parameter Problem messages,
    this is set to 4. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Identifies the general class of the parameter problem. See [Table 34-6](ch34s04.html#icmpv_parameter_problem_message_in-id001
    "Table 34-6. ICMPv6 Parameter Problem Message Interpretation Codes") for more
    information. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Pointer | 4 | An offset that points to the byte location in the original
    datagram that caused the Parameter Problem message to be generated. The device
    receiving the ICMP message can use this value to get an idea of which field in
    the original message had the problem. |'
  prefs: []
  type: TYPE_TB
- en: '| Original Datagram Portion | Variable | As much of the IPv6 datagram as will
    fit without causing the size of the ICMPv6 error message (including its own IP
    header) to exceed the minimum IPv6 MTU of 1280 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv6 Parameter Problem message format](httpatomoreillycomsourcenostarchimages287997.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 34-5. ICMPv6 Parameter Problem message format
  prefs: []
  type: TYPE_NORMAL
- en: Parameter Problem Message Interpretation Codes and the Pointer Field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Pointer field, which was only 8 bits wide in ICMPv4, has been widened to
    32 bits in ICMPv6 in order to provide more flexibility in isolating the error.
    The Code value is also used somewhat differently in ICMPv6 than it was in the
    ICMPv4 version of this message type. In ICMPv4, the Pointer was used only when
    the Code field was 0, and other code values indicated other problem categories
    for which the Pointer field did not make sense. In ICMPv6, the Pointer field is
    used with all Code types to indicate the general nature of what the problem is.
    This means the Pointer field tells the recipient of the Parameter Problem message
    where the problem happened in the message, and the Code field tells it what the
    nature of the problem is. [Table 34-6](ch34s04.html#icmpv_parameter_problem_message_in-id001
    "Table 34-6. ICMPv6 Parameter Problem Message Interpretation Codes") shows the
    three Code values and provides a brief explanation of each.
  prefs: []
  type: TYPE_NORMAL
- en: Table 34-6. ICMPv6 Parameter Problem Message Interpretation Codes
  prefs: []
  type: TYPE_NORMAL
- en: '| Code Value | Message Subtype | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Erroneous Header Field Encountered | The Pointer field points to a header
    that contains an error or otherwise could not be processed. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Unrecognized Next Header Type Encountered | As explained in [Chapter 26](ch26.html
    "Chapter 26. IPV6 DATAGRAM ENCAPSULATION AND FORMATTING"), in IPv6, a datagram
    can have multiple headers, each of which contains a Next Header field that points
    to the next header in the datagram. This code indicates that the Pointer field
    points to a Next Header field containing an unrecognized value. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Unrecognized IPv6 Option Encountered | The Pointer field points to an
    IPv6 option that was not recognized by the processing device. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The ICMPv6 *Parameter Problem* message is a generic error message
    that can be used to convey an error of any type in an IP datagram. The Pointer
    field is used to indicate where the problem was in the original datagram to the
    recipient of the message.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous chapter, we explored a number of Internet Control Message Protocol
    version 6 (ICMPv6) error messages. These are sent back to the originator of an
    Internet Protocol version 6 (IPv6) datagram when the originator detects an error
    it, thereby making it impossible for the error to be delivered. Like the original
    version of ICMP (ICMPv4), ICMPv6 also defines another message class: *informational*
    messages. These ICMPv6 messages are used not to report errors, but to allow the
    sharing of information required to implement various test, diagnostic, and support
    functions critical to the operation of IPv6.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I describe eight different ICMPv6 informational messages in
    five topics (six of these messages are used in matching pairs, and the pairs are
    described together). I begin by describing ICMPv6 Echo Request and Echo Reply
    messages, which are used for network connectivity testing. I explain the format
    of Router Advertisement and Router Solicitation messages, which are used to let
    hosts discover local routers and learn necessary parameters from them. I then
    describe ICMPv6 Neighbor Advertisement and Neighbor Solicitation messages, which
    are used for various communications between hosts on a local network, including
    IPv6 address resolution. I discuss IPv6 Redirect messages, which let routers inform
    hosts of better first-hop routers, and IPv6 Router Renumbering messages.
  prefs: []
  type: TYPE_NORMAL
- en: Several of the ICMPv6 informational messages include additional information
    that is either optional, recommended, or mandatory, depending on the circumstances
    under which the message is generated. Some of these are shared between message
    types, so they are described in a separate topic at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In IPv4, the use of many of the ICMP informational messages was described in
    a variety of different standards. In IPv6, many of the functions using informational
    messages have been gathered together and formalized in the IPv6 *Neighbor Discovery
    (ND) protocol*. The solicitation and advertisement of local routers and neighboring
    hosts, as well as the communication of redirection information are both examples
    of activities for which ND is responsible. In fact, five of the ICMP messages
    described in this chapter are actually defined in the ND standard, RFC 2461.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**RELATED INFORMATION** *Neighbor Discovery (ND) and ICMPv6 are obviously closely
    related, given that ND describes the use of several of the ICMP messages: Router
    Advertisement, Router Solicitation, Neighbor Advertisement, Neighbor Solicitation,
    and Redirect. Thus, just as ICMPv4 is an important assistant to IPv4, both ICMPv6
    and ND are important helpers for IPv6\. In this book, I provide most of the description
    of how these messages are used in the next chapter, which discusses ND. In this
    chapter, I provide only a brief summary of their use, while focusing primarily
    on message format and the meaning of each of the fields in that format*.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Echo Request and Echo Reply Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IP is a relatively simple protocol that does not include any method for performing
    tests between devices to help in diagnosing internetwork problems. This means
    that this job, like other support tasks, falls to ICMP. The simplest test performed
    when there is a problem using TCP/IP is usually a check that a pair of devices
    is able to send datagrams to each other. This is most often done by an initiating
    device that sends a test message to a second device, which receives it and replies
    back to tell the first device it received the message.
  prefs: []
  type: TYPE_NORMAL
- en: Like ICMPv4, ICMPv6 includes a pair of messages specifically for connection
    testing. To use them, Device A begins the test process by sending an ICMPv4 *Echo
    Request* message to Device B, which responds back to Device A with an *Echo Reply*
    message. When Device A receives this message, it knows that it is able to communicate
    (both send and receive) successfully with Device B.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*In ICMPv4 the first message type was named just* Echo *but was often called*
    Echo Request. *In ICMPv6*, Request *is part of the formal message name—a modest
    but useful improvement from a clarity standpoint*.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Echo and Echo Reply Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The format for ICMPv6 Echo Request and Echo Reply messages is very similar to
    that of the ICMPv4 version, as shown in [Table 35-1](ch35.html#icmpv_echo_request_and_echo_reply_messag
    "Table 35-1. ICMPv6 Echo Request and Echo Reply Message Format") and [Figure 35-1](ch35.html#icmpv6_echo_request_and_echo_reply-id001
    "Figure 35-1. ICMPv6 Echo Request and Echo Reply message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-1. ICMPv6 Echo Request and Echo Reply Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Echo Request messages,
    the value is 128, and for Echo Reply messages, it''s 129\. (In ICMPv6, informational
    messages always have a Type value of 128 or higher.) |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Not used; set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Identifier | 2 | An optional identification field that can be used to help
    in matching Echo Request and Echo Reply messages. |'
  prefs: []
  type: TYPE_TB
- en: '| Sequence Number | 2 | A sequence number to help in matching Echo Request
    and Echo Reply messages. |'
  prefs: []
  type: TYPE_TB
- en: '| Optional Data | Variable | Additional optional data to be sent along with
    the message. If this is sent in the Echo Request, it is copied into the Echo Reply
    to be sent back to the source. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv6 Echo Request and Echo Reply message format](httpatomoreillycomsourcenostarchimages287999.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-1. ICMPv6 Echo Request and Echo Reply message format
  prefs: []
  type: TYPE_NORMAL
- en: It is often necessary to match an Echo Reply message with the Echo Request message
    that led to it being generated. Two special fields are used within the format
    of these messages to allow Echo Request and Echo Reply messages to be matched
    together, and to allow a sequence of messages to be exchanged. The Identifier
    field is provided so that a particular test session can be identified, and the
    Sequence Number field allows a series of tests in a session to be numbered. The
    use of both fields is optional.
  prefs: []
  type: TYPE_NORMAL
- en: Application of Echo and Echo Reply Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ICMPv6 Echo Request and Echo Reply messages are used via the IPv6 version of
    the IP ping utility, which is commonly called *ping6*. Like its IPv4 predecessor,
    this utility allows an administrator to configure a number of test options to
    perform either a simple or rigorous test of the connection between a pair of devices.
    See [Chapter 88](ch88.html "Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING
    UTILITIES AND PROTOCOLS") for a full explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** ICMPv6 *Echo Request* and *Echo Reply* messages are used to
    facilitate network reachability testing. A device tests its ability to communicate
    with another by sending it an Echo Request message and waiting for an Echo Reply
    in response. The *ping* utility, a widely used diagnostic tool in TCP/IP internetworks,
    makes use of these messages.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Router Advertisement and Router Solicitation Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the highest level, we can separate IP devices into two groups: hosts and
    routers. Both participate in the use of the internetwork, but they have different
    roles. An important IP principle related to this division is that routers take
    care of routing—moving data between networks—while hosts generally don''t need
    to worry about this job. Hosts rely on the routers on their local networks to
    facilitate communication to all other hosts except those on the local network.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implications of this are clear: A host cannot really use an internetwork
    until it knows the identity of at least one local router and the method by which
    that router is to be used. In IPv4, a technique known as *Router Discovery* was
    invented, which provides a means by which a host can locate a router and learn
    important parameters related to the operation of the local network. Router Discovery
    in IPv6 works in a very similar manner by having routers send *Router Advertisement*
    messages both on a regular basis and in response to hosts prompting for them using
    *Router Solicitation* messages. The Router Discovery function has been incorporated
    into the ND protocol, where it is part of a larger class of tools that I call
    *host–Router Discovery* functions.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Router Advertisement Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ICMPv6 Router Advertisement and Router Solicitation messages are fairly
    similar to their counterparts in ICMPv4\. The main differences are in the parameters
    that are communicated. Since routers are responsible for a few more functions
    in IPv6 than they are in IPv4, the Router Advertisement message in ICMPv6 has
    a few more fields than the older version.
  prefs: []
  type: TYPE_NORMAL
- en: The format of an ICMPv6 Router Advertisement message is described in [Table 35-2](ch35s02.html#icmpv_router_advertisement_message-id001
    "Table 35-2. ICMPv6 Router Advertisement Message Format") and shown in [Figure 35-2](ch35s02.html#icmpv6_router_advertisement_messag-id001
    "Figure 35-2. ICMPv6 Router Advertisement message format").
  prefs: []
  type: TYPE_NORMAL
- en: '![ICMPv6 Router Advertisement message format](httpatomoreillycomsourcenostarchimages288001.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-2. ICMPv6 Router Advertisement message format
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-2. ICMPv6 Router Advertisement Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Router Advertisement messages,
    the value is 134. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Not used; set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Cur Hop Limit | 1 | Current Hop Limit: This is a default number that the
    router recommends that hosts on the local network use as a value in the Hop Limit
    field of datagrams they send. If 0, the router is not recommending a Hop Limit
    value in this Router Advertisement. |'
  prefs: []
  type: TYPE_TB
- en: '| Autoconfig Flags | 1 | Two flags that let the router tell the host how autoconfiguration
    is performed on the local network, as described in [Table 35-3](ch35s02.html#icmpv_router_advertisement_message_autoc
    "Table 35-3. ICMPv6 Router Advertisement Message Autoconfiguration Flags"). (See
    [Chapter 25](ch25.html "Chapter 25. IPV6 ADDRESSING") for details on IPv6 autoconfiguration.)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Router Lifetime | 2 | Tells the host receiving this message how long, in
    seconds, this router should be used as a default router. If 0, it tells the host
    this router should not be used as a default router. Note that this is an expiration
    interval only for the status of the router as a default, not for other information
    in the Router Advertisement message. |'
  prefs: []
  type: TYPE_TB
- en: '| Reachable Time | 4 | Tells hosts how long, in milliseconds, they should consider
    a neighbor to be reachable after they have received reachability confirmation.
    (See [Chapter 36](ch36.html "Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL")
    for more information.) |'
  prefs: []
  type: TYPE_TB
- en: '| Retrans Timer | 4 | Retransmission Timer: The amount of time, in milliseconds,
    that a host should wait before retransmitting Neighbor Solicitation messages.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Options | Variable | Router Advertisement messages may contain three possible
    options (see the "ICMPv6 Informational Message Options" section later in this
    chapter for more on ICMPv6 options):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source Link-Layer Address: Included when the router sending the Advertisement
    knows its link-layer (layer 2) address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MTU: Used to tell local hosts the MTU of the local network when hosts on the
    network may not know this information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prefix Information: Tells local hosts what prefix or prefixes to use for the
    local network. (You''ll recall that the "prefix" indicates which bits of an IPv6
    address are the network identifier when compared to the host identifier; it is
    thus analogous to an IPv4 subnet mask.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-3. ICMPv6 Router Advertisement Message Autoconfiguration Flags
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| M | 1/8 (1 bit) | Managed Address Configuration Flag: When set, this flag
    tells hosts to use an administered or stateful method for address autoconfiguration,
    such as the Dynamic Host Configuration Protocol (DHCP). |'
  prefs: []
  type: TYPE_TB
- en: '| O | 1/8 (1 bit) | Other Stateful Configuration Flag: When set, this tells
    hosts to use an administered or stateful autoconfiguration method for information
    other than addresses. |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 6/8 (6 bits) | Reserved for future use; sent as zeros. |'
  prefs: []
  type: TYPE_TB
- en: ICMPv6 Router Solicitation Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The format of an ICMPv6 Router Solicitation message is shown in [Table 35-4](ch35s02.html#icmpv_router_solicitation_message_-id001
    "Table 35-4. ICMPv6 Router Solicitation Message Format") and [Figure 35-3](ch35s02.html#icmpv6_router_solicitation_message-id001
    "Figure 35-3. ICMPv6 Router Solicitation message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-4. ICMPv6 Router Solicitation Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Router Solicitation messages,
    the value is 133. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Not used; set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 4 | The 4 reserved bytes set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Options | Variable | If the device sending the Router Solicitation knows
    its layer 2 address, it should be included in a Source Link-Layer Address option.
    Option formats are described in the "ICMPv6 Informational Message Options" section
    later in this chapter. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv6 Router Solicitation message format](httpatomoreillycomsourcenostarchimages288003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-3. ICMPv6 Router Solicitation message format
  prefs: []
  type: TYPE_NORMAL
- en: Addressing of Router Advertisement and Router Solicitation Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Router Solicitation messages are normally sent to the IPv6 "all routers" multicast
    address; this is the most efficient method, because routers are required to subscribe
    to this multicast address while hosts will ignore it. A routine (unsolicited)
    Router Advertisement message is sent to all devices using the "all nodes" multicast
    address for the local network. A Router Advertisement message that is sent in
    response to a Router Solicitation message goes in unicast back to the device that
    sent the solicitation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** ICMPv6 *Router Advertisement* messages are sent regularly by
    IPv6 routers to inform hosts of their presence and characteristics, and to provide
    hosts with parameters that they need to function properly on the local network.
    A host that wants to find out immediately which routers are present may send a
    *Router Solicitation* message, which will prompt listening routers to send out
    Router Advertisements.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Neighbor Advertisement and Neighbor Solicitation Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section described the Router Advertisement and Router Solicitation
    messages, which are used to facilitate host–Router Discovery functions as part
    of the IPv6 ND protocol. The other main group of tasks for which ND is responsible
    relates to the exchange of information between neighboring hosts on the same network.
    I call these *host-host communication* or *host-host discovery* functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arguably, the most important additions to the ND protocol are the functions
    that formalize the exchange of parameters and the methods that determine the existence
    of neighboring hosts. These tasks include the new method of address resolution
    in IPv6 as well as the processes of next-hop determination and neighbor unreachability
    detection. They require the use of two ICMPv6 messages: the *Neighbor Solicitation
    message* and the *Neighbor Advertisement message*.'
  prefs: []
  type: TYPE_NORMAL
- en: The Neighbor Solicitation message allows a device to check that a neighbor exists
    and is reachable, and lets a device initiate address resolution. The Neighbor
    Advertisement message confirms the existence of a host or router, and also provides
    layer 2 address information when needed. As you can see, these two messages are
    comparable to the Router Advertisement and Router Solicitation messages, but they
    are used differently and include different parameters.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Neighbor Advertisement Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The format for the Neighbor Advertisement message is shown in [Table 35-5](ch35s03.html#icmpv_neighbor_advertisement_message_for
    "Table 35-5. ICMPv6 Neighbor Advertisement Message Format") and [Figure 35-4](ch35s03.html#icmpv6_neighbor_advertisement_mess-id001
    "Figure 35-4. ICMPv6 Neighbor Advertisement message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-5. ICMPv6 Neighbor Advertisement Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Neighbor Advertisement
    messages, the value is 136. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Not used; set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Flags | 4 | Three flags that convey information about the message (and a
    lot of empty space for future use), as described in [Table 35-6](ch35s03.html#icmpv_neighbor_advertisement_message_fla
    "Table 35-6. ICMPv6 Neighbor Advertisement Message Flags"). |'
  prefs: []
  type: TYPE_TB
- en: '| Target Address | 16 | If the Neighbor Advertisement is being sent in response
    to a Neighbor Solicitation, this is the same value as in the Target Address field
    of the Solicitation. This field will commonly contain the IPv6 address of the
    device, thereby sending the Neighbor Advertisement, but not in all cases. For
    example, if a device responds as a proxy for the target of the Neighbor Solicitation,
    the Target Address field contains the address of the target, not the device sending
    the response. (See [Chapter 13](ch13.html "Chapter 13. ADDRESS RESOLUTION AND
    THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)") for details on address resolution
    proxying.) If the Neighbor Advertisement is being sent unsolicited, then this
    is the IPv6 address of the device sending it. |'
  prefs: []
  type: TYPE_TB
- en: '| Options | Variable | When sent in response to a multicast Neighbor Solicitation,
    a Neighbor Advertisement message must contain a Target Link-Layer Address option,
    which carries the link-layer address of the device sending the message. This is
    a good example of an option that''s not really "optional." When the Neighbor Advertisement
    is sent in response to a unicast Neighbor Solicitation, this option is technically
    not required (since the sender of the Solicitation must already have the target''s
    link-layer address to have sent it unicast). Despite this, it is still normally
    included to ensure that the link-layer address of the target is refreshed in the
    cache of the device that sent the Neighbor Solicitation. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv6 Neighbor Advertisement message format](httpatomoreillycomsourcenostarchimages288005.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-4. ICMPv6 Neighbor Advertisement message format
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-6. ICMPv6 Neighbor Advertisement Message Flags
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| R | 1/8 (1 bit) | Router Flag: Set when a router sends a Neighbor Advertisement,
    and cleared when a host sends one. This identifies the type of device that sent
    the datagram, and is also used as part of neighbor unreachability detection to
    detect when a device changes from acting as a router to functioning as a regular
    host. |'
  prefs: []
  type: TYPE_TB
- en: '| S | 1/8 (1 bit) | Solicited Flag: When set, indicates that this message was
    sent in response to a Neighbor Solicitation message. Cleared for unsolicited Neighbor
    Advertisements. |'
  prefs: []
  type: TYPE_TB
- en: '| O | 1/8 (1 bit) | Override Flag: When set, tells the recipient that the information
    in this message should override any existing cached entry for the link-layer address
    of this device. This bit is normally set in unsolicited Neighbor Advertisements,
    since these are sent when a host needs to force a change of information in the
    caches of its neighbors. |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 3 5/8 (29 bits) | A big set of reserved bits. |'
  prefs: []
  type: TYPE_TB
- en: ICMPv6 Neighbor Solicitation Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Neighbor Solicitation message format is much simpler, as shown in [Table 35-7](ch35s03.html#icmpv_neighbor_solicitation_message_form
    "Table 35-7. ICMPv6 Neighbor Solicitation Message Format") and [Figure 35-5](ch35s03.html#icmpv6_neighbor_solicitation_messa-id001
    "Figure 35-5. ICMPv6 Neighbor Solicitation message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-7. ICMPv6 Neighbor Solicitation Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Neighbor Solicitation
    messages, the value is 135. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Not used; set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 4 | The 4 reserved bytes set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Target Address | 16 | The IPv6 address of the target of the solicitation.
    For IPv6 address resolution, this is the actual unicast IP address of the device
    whose layer 2 (link-layer) address we are trying to resolve. |'
  prefs: []
  type: TYPE_TB
- en: '| Options | Variable | If the device sending the Neighbor Solicitation knows
    both its own IP address and layer 2 address, it should include the layer 2 address
    in a Source Link-Layer Address option. The inclusion of this option will allow
    the destination of the Neighbor Solicitation to enter the layer 2 and layer 3
    addresses of the source of this message into its own address cache. (See the discussion
    of IPv6 address resolution in [Chapter 25](ch25.html "Chapter 25. IPV6 ADDRESSING").)
    |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv6 Neighbor Solicitation message format](httpatomoreillycomsourcenostarchimages288007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-5. ICMPv6 Neighbor Solicitation message format
  prefs: []
  type: TYPE_NORMAL
- en: Addressing of Neighbor Advertisement and Neighbor Solicitation Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Neighbor Solicitation messages are sent either unicast to the address of the
    target device or to the solicited-node multicast address of the target. This latter
    address is a special type that's used to allow a device to send a multicast that
    will be heard by the target whose address it is trying to resolve, but won't be
    heard by most other devices; it is explained in [Chapter 25](ch25.html "Chapter 25. IPV6
    ADDRESSING"), which describes IPv6 address resolution.
  prefs: []
  type: TYPE_NORMAL
- en: When a Neighbor Advertisement message is generated in response to a Neighbor
    Solicitation message, it is sent unicast back to the device that sent the Solicitation
    message, unless that message was sent from the unspecified address, in which case
    it is multicast to the "all nodes" multicast address. If the Neighbor Advertisement
    message is sent unsolicited (for example, by a device that wishes to inform others
    of a change in link-layer address), it is sent to the "all nodes" multicast address.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** ICMPv6 *Neighbor Advertisement* and *Neighbor Solicitation*
    messages are similar in many ways to the Router Advertisement and Router Solicitation
    messages. However, rather than being used to communicate parameters from routers
    to hosts, they are used for various types of communication between hosts on a
    physical network, such as address resolution, next-hop determination, and neighbor
    unreachability detection.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Redirect Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because of the different roles of routers and hosts in an IPv6 internetwork,
    hosts don't need to know very much about routes. They send datagrams intended
    for destinations on the local network directly, while they send those for other
    networks to their local routers and let them "do the driving," so to speak.
  prefs: []
  type: TYPE_NORMAL
- en: If a local network has only a single router, it will send all such nonlocal
    traffic to that router. If it has more than one local router, the host then must
    decide which router to use for which traffic. In general terms, a host will not
    know the most efficient choice of router for every type of datagram it may need
    to send. In fact, many nodes start out with a limited routing table that says
    to send *everything* to a single default router, even if there are several routers
    on the network.
  prefs: []
  type: TYPE_NORMAL
- en: When a router receives datagrams destined for certain networks, it may realize
    that it would be more efficient if a host to a different router on the local network
    sent such traffic. If so, it will invoke the Redirect function by sending an ICMPv6
    *Redirect* message to the device that sent the original datagram. This is the
    last of the functions that is performed in IPv6 by the ND protocol and is explained
    in [Chapter 36](ch36.html "Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*In ICMPv6, the Redirect message is informational and no longer considered
    an error message as it was in ICMPv4*.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Redirect Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The format of ICMPv6 Redirect messages is shown in [Table 35-8](ch35s04.html#icmpv_redirect_message_format-id001
    "Table 35-8. ICMPv6 Redirect Message Format") and [Figure 35-6](ch35s04.html#icmpv6_redirect_message_format-id001
    "Figure 35-6. ICMPv6 Redirect message format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-8. ICMPv6 Redirect Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Redirect messages, the
    value is 137. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Not used; set to 0. |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 4 | The 4 bytes sent as zeros. |'
  prefs: []
  type: TYPE_TB
- en: '| Target Address | 16 | The address of the router that the router creating
    the Redirect is telling the recipient of the Redirect to use as a first hop for
    future transmissions to the destination. For example, if Router R2 generated a
    Redirect telling Host A that, in the future, transmissions to Host B should be
    sent first to Router R1, then Router R1''s IPv6 address would be in this field.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Destination Address | 16 | The address of the device whose future transmissions
    are being redirected; this is the destination of the datagram that originally
    led to the Redirect being generated. Repeating the previous example: If Router
    R2 generated a Redirect telling Host A that, in the future, transmissions to Host
    B should be sent first to Router R1, then Host B''s IPv6 address would be in this
    field. |'
  prefs: []
  type: TYPE_TB
- en: '| Options | Variable | Redirect messages normally include two ICMPv6 option
    fields (see the "ICMPv6 Informational Message Options" section later in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Target Link-Layer Address: The layer 2 address of the Target Address, if known.
    This saves the recipient of the Redirect message from needing to perform an address
    resolution on the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redirected Header: As much of the IPv6 datagram that spawned this Redirect
    as will fit without causing the size of the ICMPv6 error message (including its
    own IP header) to exceed the minimum IPv6 MTU of 1280 bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '![ICMPv6 Redirect message format](httpatomoreillycomsourcenostarchimages288009.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-6. ICMPv6 Redirect message format
  prefs: []
  type: TYPE_NORMAL
- en: Redirect messages are always sent in unicast to the address of the device that
    originally sent the datagram that originally created the Redirect message.
  prefs: []
  type: TYPE_NORMAL
- en: Application of Redirect Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Redirect message has always been somewhat of an oddball. In ICMPv4, it is
    considered an error message, but this makes it different from other error messages.
    For one thing, it's not really an error, since it doesn't represent a failure
    to deliver, only an inefficiency in doing so. For this reason, in ICMPv6 it was
    moved into the set of informational message types. Here, too, it doesn't really
    fit in with the others, since it is sent in reaction to a regular IP message,
    and it also includes a copy of (part of) the datagram that spawned it, as error
    messages do.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** ICMPv6 *Redirect* messages are used by a router to inform a
    host of a better router to use for future datagrams that were sent to a particular
    host or network. They are not used to alter routes between routers, however.'
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Router Renumbering Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the more interesting decisions made in IPv6 was the selection of a very
    large 128-bit address size. This provides an address space far larger than what
    humans are ever likely to need, and probably larger than needed for IPv6, strictly
    speaking. What this wealth of bits provides is the flexibility to assign meaning
    to different bits in the address structure. This, in turn, serves as the basis
    for important features such as the autoconfiguration and automated renumbering
    of IPv6 addresses.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 Router Renumbering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The renumbering feature in IPv6 is of particular interest to network administrators,
    since it has the potential to make large network migrations and merges much simpler.
    In August 2000, the IETF published RFC 2894, "Router Renumbering for IPv6," which
    describes a similar technique that allows routers in an autonomous system to be
    renumbered by giving them new prefixes (network identifiers).
  prefs: []
  type: TYPE_NORMAL
- en: Router renumbering is actually a fairly simple process, especially if we avoid
    the gory details, which is exactly what I intend to do. A network administrator
    uses a device on the internetwork to generate one or more *Router Renumbering
    Command* messages. These messages provide a list of prefixes of routers that are
    to be renumbered. Each router processes these messages to see if the addresses
    on any of their interfaces match the specified prefixes. If so, they change the
    matched prefixes to the new ones specified in the message. Additional information
    is also included in the Router Renumbering Command message to control how and
    when the renumbering is done.
  prefs: []
  type: TYPE_NORMAL
- en: If requested, each router processing a Command message will respond with a *Router
    Renumbering Result* message. This serves as feedback to the originator of the
    Command message, indicating whether the renumbering was successful, and what changes,
    if any, were made.
  prefs: []
  type: TYPE_NORMAL
- en: The router renumbering standard also defines a few important management features.
    Many of these reflect the great power of something that can mass-renumber routers,
    and hence, they represent the potential for such power to be abused. Command messages
    may be sent in a test mode, in which they are processed but the renumbering is
    not actually done. Messages include a sequence number to guard against replay
    attacks, and a special *Sequence Number Reset* message can be used to reset the
    sequence number information that was previously sent. For added security, the
    standard specifies that messages be authenticated and have their identity checked.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Router Renumbering Message Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The format of Router Renumbering messages is shown in [Table 35-9](ch35s05.html#icmpv_router_renumbering_message_format
    "Table 35-9. ICMPv6 Router Renumbering Message Format") and [Figure 35-7](ch35s05.html#icmpv6_router_renumbering_message_-id001
    "Figure 35-7. ICMPv6 Router Renumbering message format").
  prefs: []
  type: TYPE_NORMAL
- en: '![ICMPv6 Router Renumbering message format](httpatomoreillycomsourcenostarchimages288011.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-7. ICMPv6 Router Renumbering message format
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-9. ICMPv6 Router Renumbering Message Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Router Renumbering messages,
    the value is 138. |'
  prefs: []
  type: TYPE_TB
- en: '| Code | 1 | Indicates the subtype of Router Renumbering message:0 = Router
    Renumbering Command1 = Router Renumbering Result255 = Sequence Number Reset |'
  prefs: []
  type: TYPE_TB
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  prefs: []
  type: TYPE_TB
- en: '| Sequence Number | 4 | A 32-bit number that guards against replay attacks
    by letting a recipient detect stale, duplicate, or out-of-order commands. |'
  prefs: []
  type: TYPE_TB
- en: '| Segment Number | 1 | Differentiates between valid Router Renumbering messages
    within the same Sequence Number. |'
  prefs: []
  type: TYPE_TB
- en: '| Flags | 1 | Five flags used to control the renumbering process, as described
    in [Table 35-10](ch35s05.html#icmpv_router_renumbering_message_flags "Table 35-10. ICMPv6
    Router Renumbering Message Flags"). |'
  prefs: []
  type: TYPE_TB
- en: '| Max Delay | 2 | Tells a router receiving a message the maximum amount of
    time (in milliseconds) it is allowed to delay before sending a reply. |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 4 | The 4 reserved bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| Message Body | Variable | For a Router Renumbering Command, the message body
    contains two sets of information. The first is a Match-Prefix Part for the prefix
    being renumbered. The second is one or more Use-Prefix Parts that describe the
    new prefix for each match. A router receiving a Command checks its own interface
    addresses, and if they match the Match-Prefix-Part, they use Use-Prefix Parts
    data to accomplish the renumbering.For a Router Renumbering Result, the message
    body contains zero or more Match Results entries that describe each prefix that
    a router has matched from a Router Renumbering Command. Each entry provides information
    about whether renumbering for a prefix was successful. |'
  prefs: []
  type: TYPE_TB
- en: '[Table 35-10](ch35s05.html#icmpv_router_renumbering_message_flags "Table 35-10. ICMPv6
    Router Renumbering Message Flags") shows the Router Renumbering Message flags.
    The first four flags (T, R, A, and S) control the operation of Command messages.
    They are just copied verbatim in a Result message from the Command message that
    led to the Result message being created. The P flag is used only in Result messages
    (0 in Command messages).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-10. ICMPv6 Router Renumbering Message Flags
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| T | 1/8 (1 bit) | Test Command Flag: When set to 1, this flags this Command
    messageas being a test message. This tells the recipient to only simulate processing
    of the renumbering, not to actually do it. |'
  prefs: []
  type: TYPE_TB
- en: '| R | 1/8 (1 bit) | Result Requested Flag: When set to 1, requests that a Result
    message be sent after processing the Command message. When set to 0, says not
    to send one. |'
  prefs: []
  type: TYPE_TB
- en: '| A | 1/8 (1 bit) | All Interfaces Flag: When this flag is clear (0), the Command
    message is not applied to any router interfaces that have been administratively
    shut down. When 1, it is applied to all interfaces. |'
  prefs: []
  type: TYPE_TB
- en: '| S | 1/8 (1 bit) | Site-Specific Flag: This flag has meaning only when a router
    treats its interfaces as belonging to different sites. If so, a value of 1 tells
    it to apply the Command message only to interfaces on the same site as the interface
    for which the Command message was received. A value of 0 applies it to all interfaces
    regardless of site. |'
  prefs: []
  type: TYPE_TB
- en: '| P | 1/8 (1 bit) | Processed Previously Flag: This flag is normally 0, meaning
    the Command message was not previously seen and the Result message contains the
    report of processing it. When 1, this indicates that the recipient of the Command
    message believes it has seen it before and is not processing it. (Test commands
    are not included in the assessment of whether a Command message has been seen
    before.) |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 3/8 (3 bits) | Three bits reserved for future flags. |'
  prefs: []
  type: TYPE_TB
- en: Addressing of Router Renumbering Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Router Renumbering messages are intended for all routers on a site, they
    are normally sent to the "all routers" multicast address, using either link-local
    or site-local scope. They may also be sent to local unicast addresses.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Informational Message Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each of the five ICMPv6 informational message types defined and used by the
    protocol has an Options field into which one or more options may be inserted.
    This probably isn't the best name for these sets of data, since they are only
    optional in certain cases. In fact, in some cases the option is actually the entire
    point of the message. For example, a Neighbor Advertisement message containing
    a link-layer address for address resolution carries it in an Options field, but
    the message wouldn't be of much use without it!
  prefs: []
  type: TYPE_NORMAL
- en: Each option has its own structure of subfields based on the classic type, length,
    and value triplet used in many message formats. The Type subfield indicates the
    option type, and the Length field indicates its length, so that the device processing
    the option can determine where it ends. The value may be contained in one or more
    fields, which hold the actual information for which the option is being used.
  prefs: []
  type: TYPE_NORMAL
- en: Some options are used for only one kind of ICMPv6 message; others are used for
    more than one variety. So, they are best thought of as modular components used
    in different types of messages as needed. I describe the format of each of these
    five options in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Source Link-Layer Address Option Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Source Link-Layer Address Option carries the link-layer address of a device
    sending an ICMPv6 message, as shown in [Table 35-11](ch35s06.html#icmpv_source_link-layer_address_option_f
    "Table 35-11. ICMPv6 Source Link-Layer Address Option Format") and [Figure 35-8](ch35s06.html#icmpv6_source_link-layer_address_option_
    "Figure 35-8. ICMPv6 Source Link-Layer Address option format"). It's used in Router
    Advertisement, Router Solicitation, and Neighbor Solicitation messages.
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-11. ICMPv6 Source Link-Layer Address Option Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 option type. For the Source Link-Layer Address
    option, the value is 1. |'
  prefs: []
  type: TYPE_TB
- en: '| Length | 1 | The length of the entire option (including the Type and Length
    fields), expressed in units of 8 octets (64 bits). |'
  prefs: []
  type: TYPE_TB
- en: '| Source Link-Layer Address | Variable | The link-layer (layer 2) address of
    the device sending the ICMPv6 message. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv6 Source Link-Layer Address option format](httpatomoreillycomsourcenostarchimages288013.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-8. ICMPv6 Source Link-Layer Address option format
  prefs: []
  type: TYPE_NORMAL
- en: Target Link-Layer Address Option Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Target Link-Layer Address option carries the link-layer address corresponding
    to the Target Address field in Neighbor Advertisement and Redirect messages. Its
    format is shown in [Table 35-12](ch35s06.html#icmpv_target_link-layer_address_option_f
    "Table 35-12. ICMPv6 Target Link-Layer Address Option Format") and [Figure 35-9](ch35s06.html#icmpv6_target_link-layer_address_option_
    "Figure 35-9. ICMPv6 Target Link-Layer Address option format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-12. ICMPv6 Target Link-Layer Address Option Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 option type. For the Target Link-Layer Address
    option, the value is 2. |'
  prefs: []
  type: TYPE_TB
- en: '| Length | 1 | The length of the entire option (including the Type and Length
    fields), expressed in units of 8 octets (64 bits). |'
  prefs: []
  type: TYPE_TB
- en: '| Target Link-Layer Address | Variable | The link-layer (layer 2) address of
    the target device. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv6 Target Link-Layer Address option format](httpatomoreillycomsourcenostarchimages288015.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-9. ICMPv6 Target Link-Layer Address option format
  prefs: []
  type: TYPE_NORMAL
- en: Prefix Information Option Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Prefix Information* option provides a prefix and related information in
    Router Advertisement messages. This is the longest and most complex of the options,
    as you can see in [Table 35-13](ch35s06.html#icmpv_prefix_information_option_format
    "Table 35-13. ICMPv6 Prefix Information Option Format") and [Figure 35-10](ch35s06.html#icmpv6_prefix_information_option_format
    "Figure 35-10. ICMPv6 Prefix Information option format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-13. ICMPv6 Prefix Information Option Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 option type. For the Prefix Information
    option, the value is 3. |'
  prefs: []
  type: TYPE_TB
- en: '| Length | 1 | The length of the entire option (including the Type and Length
    fields), expressed in units of 8 octets (64 bits). The Prefix Information option
    is fixed in size at 32 bytes, so the value of the Length field is 4. |'
  prefs: []
  type: TYPE_TB
- en: '| Prefix Length | 1 | The number of bits in the Prefix field that are considered
    part of the network identifier (the remainder are used for the host identifier
    and ignored). See [Chapter 25](ch25.html "Chapter 25. IPV6 ADDRESSING") for details
    on prefix lengths. |'
  prefs: []
  type: TYPE_TB
- en: '| Flags | 1 | A pair of flags that convey information about the prefix, as
    described in [Table 35-14](ch35s06.html#icmpv_prefix_information_option_flags
    "Table 35-14. ICMPv6 Prefix Information Option Flags"). |'
  prefs: []
  type: TYPE_TB
- en: '| Valid Lifetime | 4 | The amount of time, in seconds, that the recipient of
    the message containing this option should consider the prefix valid for purposes
    of on-link determination (see the description of the L flag in [Table 35-14](ch35s06.html#icmpv_prefix_information_option_flags
    "Table 35-14. ICMPv6 Prefix Information Option Flags")). A value of all 1s means
    infinity (forever). |'
  prefs: []
  type: TYPE_TB
- en: '| Preferred Lifetime | 4 | When the recipient of this prefix uses it to automatically
    generate addresses using address autoconfiguration, this specifies the amount
    of time, in seconds, that such addresses remain preferred (meaning, valid and
    freely usable). A value of all 1s means infinity (forever). |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 4 | The 4 unused bytes sent as zeros. |'
  prefs: []
  type: TYPE_TB
- en: '| Prefix | 16 | The prefix being communicated from the router to the host in
    the Router Advertisement message. The Prefix Length field indicates how many of
    the 128 bits in this field are significant (part of the network ID). Only these
    bits are placed in the Prefix field; the remaining bits are cleared to zero. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv6 Prefix Information option format](httpatomoreillycomsourcenostarchimages288017.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-10. ICMPv6 Prefix Information option format
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-14. ICMPv6 Prefix Information Option Flags
  prefs: []
  type: TYPE_NORMAL
- en: '| Subfield Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| L | 1/8 (1 bit) | On-Link Flag: When set to 1, tells the recipient of the
    option that this prefix can be used for on-link determination. This means the
    prefix can be used for deciding whether or not an address is *on-link* (on the
    recipient''s local network). When 0, the sender is making no statement regarding
    whether the prefix can be used for this or not. |'
  prefs: []
  type: TYPE_TB
- en: '| A | 1/8 (1 bit) | Autonomous Address-Configuration Flag: When set to 1, specifies
    that this prefix can be used for IPv6 address autoconfiguration. (See [Chapter 25](ch25.html
    "Chapter 25. IPV6 ADDRESSING") for details on IPv6 autoconfiguration.) |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 6/8 (6 bits) | 6 leftover bits reserved and sent as zeros. |'
  prefs: []
  type: TYPE_TB
- en: Redirected Header Option Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a Redirect message, the *Redirected Header* option provides a copy of the
    original message (or a portion of it) that led to the Redirect message being generated.
    This option's format is shown in [Table 35-15](ch35s06.html#icmpv_redirected_header_option_format
    "Table 35-15. ICMPv6 Redirected Header Option Format") and [Figure 35-11](ch35s06.html#icmpv6_redirected_header_option_format
    "Figure 35-11. ICMPv6 Redirected Header option format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-15. ICMPv6 Redirected Header Option Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 option type. For the Redirected Header option,
    the value is 4. |'
  prefs: []
  type: TYPE_TB
- en: '| Length | 1 | The length of the entire option (including the Type and Length
    fields), expressed in units of 8 octets (64 bits). |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 6 | The 6 reserved bytes sent as zeros. |'
  prefs: []
  type: TYPE_TB
- en: '| IP Header + Data | Variable | As much of the original IPv6 datagram as will
    fit without causing the size of the ICMPv6 error message (including its own IP
    header) to exceed the minimum IPv6 MTU of 1280 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv6 Redirected Header option format](httpatomoreillycomsourcenostarchimages288019.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-11. ICMPv6 Redirected Header option format
  prefs: []
  type: TYPE_NORMAL
- en: MTU Option Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *MTU* option lets a router convey a recommended MTU value in Router Advertisement
    messages. Its format is shown in [Table 35-16](ch35s06.html#icmpv_mtu_option_format
    "Table 35-16. ICMPv6 MTU Option Format") and [Figure 35-12](ch35s06.html#icmpv6_mtu_option_format
    "Figure 35-12. ICMPv6 MTU option format").
  prefs: []
  type: TYPE_NORMAL
- en: Table 35-16. ICMPv6 MTU Option Format
  prefs: []
  type: TYPE_NORMAL
- en: '| Field Name | Size (Bytes) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Type | 1 | Identifies the ICMPv6 option type. For the MTU option, the value
    is 5. |'
  prefs: []
  type: TYPE_TB
- en: '| Length | 1 | The length of the entire option (including the Type and Length
    fields), expressed in units of 8 octets (64 bits). The MTU option is fixed in
    length at 8 bytes, so the value of this field is 1. |'
  prefs: []
  type: TYPE_TB
- en: '| Reserved | 2 | The 2 reserved bytes sent as zeros. |'
  prefs: []
  type: TYPE_TB
- en: '| MTU | 4 | The MTU value, in bytes, that the router is recommending for use
    on the local link. |'
  prefs: []
  type: TYPE_TB
- en: '![ICMPv6 MTU option format](httpatomoreillycomsourcenostarchimages288021.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-12. ICMPv6 MTU option format
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The new Internet Protocol version 6 (IPv6) represents an evolution of the venerable
    IP. It maintains the same basic operational principles of IPv4, but makes some
    important modifications, particularly in the area of addressing. In fact, some
    of the more significant changes in IPv6 are actually not in IP itself, but in
    the protocols that support IP. One of the most interesting of these was the creation
    of an entirely new support protocol for IPv6\. It combines several tasks previously
    performed by other protocols in IPv4, adds some new functions, and makes numerous
    improvements to the whole package. This new standard is called the IPv6 *Neighbor
    Discovery (ND)* protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I describe the new ND protocol used in IPv6\. I begin with
    an overview of the protocol, discussing its history, the motivation for its creation,
    and the standards that define it. I then describe its operation in general terms,
    listing the fundamental functions that ND performs, the three groups these functions
    fit into, and the Internet Control Message Protocol version 6 (ICMPv6) message
    types used to carry them out. I describe the key differences between ND and the
    way that its functions were carried out in IPv4\. I then provide more information
    on the three functional groups in ND: those that involve discovery of important
    internetwork information from routers, those that are related to address resolution
    and neighbor communication between hosts, and finally, those involved with router
    redirection.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**BACKGROUND INFORMATION** *This chapter assumes basic comprehension of IPv6,
    which, in turn, requires understanding IPv4\. ND uses ICMPv6 messages, so I reference
    Chapters [Chapter 31](ch31.html "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")
    to [Chapter 35](ch35.html "Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND
    FORMATS"), which discuss them. Finally, since ICMP performs some of the functions
    done by the Address Resolution Protocol (ARP) in IPv4, you may need to refer to
    [Chapter 13](ch13.html "Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS
    RESOLUTION PROTOCOL (ARP)") if you''re unfamiliar with ARP''s operation*.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 ND Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of network layer protocols like IP is to provide a means of connecting
    together individual local networks to create a much larger internetwork. To higher-layer
    protocols and to users, this internetwork behaves in most respects as if it were
    a single large network, because the lower layers hide the details that hold together
    the individual networks. Any device can send information to any other regardless
    of where it is located, and like magic, it will work—at least most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The existence of an internetwork means that devices can treat all other devices
    as peers, at least from the perspective of higher-layer protocols and applications.
    From the standpoint of lower layers, however, there is a very important difference
    between devices that are on a host''s local network and those that are elsewhere.
    In a general sense, most devices have a more important relationship with the devices
    that are on their local network than those that are far away. Some of the most
    obvious tasks that a device must perform specifically with other devices on its
    local network include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct Datagram Delivery** Devices deliver data directly to other devices
    on their local network, while data going to distant devices must be indirectly
    delivered (routed).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layer 2 Addressing** To facilitate direct delivery, devices need to know
    the layer 2 addresses of the other devices on the local network; they don''t need
    to know them for nonlocal devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Router Identification** To deliver indirectly, a device needs to find a router
    on its local network that it can talk to.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Router Communication** The local router must communicate information to each
    of the local hosts using it, so the hosts know how best to use it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration** Hosts will usually look to information provided by local
    devices to let them perform configuration tasks such as determining their own
    IP address.'
  prefs: []
  type: TYPE_NORMAL
- en: To support these and other requirements, several special protocols and functions
    were developed along with the original IP (version 4). The IP addressing scheme
    lets devices differentiate local addresses from distant ones. The Address Resolution
    Protocol (ARP) lets devices determine layer 2 addresses from layer 3 addresses.
    ICMP provides a messaging system to support various communication requirements
    between local devices, including the ability of a host to find a local router
    and the router to provide information to local hosts.
  prefs: []
  type: TYPE_NORMAL
- en: These features all work properly in IPv4, but they were developed in sort of
    an ad hoc manner. They are defined not in a single place, but rather in a variety
    of different Internet standards. There were also some limitations with the way
    these local device functions were implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Formalizing Local Network Functions: The Neighbor Concept'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'IPv6 represents the biggest change in decades to not just the IP itself, but
    the entire TCP/IP suite. It thus provided an ideal opportunity to formalize and
    integrate the many disparate functions and tasks related to communication between
    local devices. The result was the creation of a new protocol: *Neighbor Discovery
    for IP version 6*, also commonly called the *IPv6 Neighbor Discovery* protocol.
    Since this protocol is new in IPv6, there is no IPv4 version of it, so the name
    is usually just seen as the *ND* protocol with no further qualifications; its
    use with IPv6 is implied.'
  prefs: []
  type: TYPE_NORMAL
- en: The term *neighbor* is one that has been used for years in various networking
    standards and technologies to refer to devices that are local to each other. In
    the context of the current discussion, two devices are *neighbors* if they are
    on the same local network, meaning that they can send information to each other
    directly. The term can refer to either a regular host or a router. I think this
    is a good analogy to the way humans refer to those who live or work nearby. Just
    as most of us have a special relationship with people who are our neighbors and
    communicate more with them than with those who are far away, so do IP devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a neighbor is a local device, the name of the ND protocol would seem
    to indicate that ND is all about how neighbors discover each other''s existence.
    In the context of this protocol, however, the term *discovery* has a much more
    generic meaning: It refers to discovering not just who are neighbors are, but
    also discovering important information about them. In addition to letting devices
    identify their neighbors, ND facilitates all the tasks listed earlier, including
    such functions as address resolution, parameter communication, autoconfiguration,
    and much more, as you will see in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The new *IPv6 Neighbor Discovery (ND)* protocol formalizes
    for IPv6 a number of functions related to communication between devices on a local
    network that are performed in IPv4 by protocols such as ARP and ICMP. ND is considered
    another helper protocol for IPv6 and is closely related to ICMPv6.'
  prefs: []
  type: TYPE_NORMAL
- en: Neighbor Discovery Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ND protocol was originally defined in RFC 1970, published in August 1996,
    and revised in the current defining standard, RFC 2461, published December 1998\.
    Most of the functions of the ND protocol are implemented using a set of five special
    ICMPv6 control messages, which were discussed in the previous chapter. Thus, to
    some extent, the operation of ND is partially described by the ICMPv6 standard,
    RFC 2463\. Where ICMPv4 can be considered IPv4''s "administrative assistant,"
    IPv6 really has two such assistants working closely together: ICMPv6 and ND. I
    discuss more of the differences between the ways IPv4 and IPv6 implement ND''s
    functions later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 ND General Operational Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I just mentioned, the name of the ND protocol really does not do it justice.
    The protocol facilitates not merely the discovery of neighboring devices, but
    also a substantial number of functions related to local network connectivity,
    datagram routing, and configuration. Both regular hosts and routers in an IPv6
    environment count on the ND protocol to facilitate important exchanges of information
    that are necessary for proper internetwork operation.
  prefs: []
  type: TYPE_NORMAL
- en: The ND protocol has a number of similarities to ICMP. An important one is that
    like ICMP, ND is a *messaging* protocol. It doesn't implement a single specific
    function, but rather a group of activities that are performed through the exchange
    of messages. This means I can't explain the operation of ND through a specific
    description of what ND does, but rather must define its operation by means of
    a list of messages that ND provides, and the specific ways that those messages
    are used.
  prefs: []
  type: TYPE_NORMAL
- en: Any local network on an internetwork will have both regular hosts and routers,
    and the term *neighbor* can refer to either. Of course, hosts and routers play
    different roles on a network, and as a result, ND is very different for each.
    The ND standard describes nine specific functions performed by the protocol. To
    better understand these functions and how they are related, we can divide them
    into three functional groups based on communication type and the kinds of devices
    involved, as illustrated in [Figure 36-1](ch36s02.html#neighbor_discovery_nd_protocol_functiona
    "Figure 36-1. Neighbor Discovery (ND) protocol functional groups and functions").
  prefs: []
  type: TYPE_NORMAL
- en: '![Neighbor Discovery (ND) protocol functional groups and functions](httpatomoreillycomsourcenostarchimages288023.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 36-1. Neighbor Discovery (ND) protocol functional groups and functions
  prefs: []
  type: TYPE_NORMAL
- en: Two main groups of functions in ND are those for handling router discovery and
    those for handling communications between hosts. A third functional group consists
    of just the Redirect function.
  prefs: []
  type: TYPE_NORMAL
- en: Host-Router Discovery Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ND host-router discovery functions are those that facilitate the discovery
    of local routers and the exchange of information between routers and hosts. This
    includes four specific functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Router Discovery (RD)** RD is the core function of this group. It''s the
    method by which hosts locate routers on their local network.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prefix Discovery** Closely related to the process of RD is Prefix Discovery.
    Recall that the term *prefix* refers to the network identifier portion of an IP
    address. Hosts use this function to determine the network they are on, which,
    in turn, tells them how to differentiate between local and distant destinations
    and whether to attempt direct or indirect delivery of datagrams.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parameter Discovery** Also closely related to RD, this is the method by which
    a host learns important parameters about the local network and/or routers, such
    as the maximum transmission unit (MTU) of the local link.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address Autoconfiguration** Hosts in IPv6 are designed to be able to automatically
    configure themselves, but this requires information that is normally provided
    by a router.'
  prefs: []
  type: TYPE_NORMAL
- en: Host-Host Communication Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other main group of functions is associated with information determination
    and communication directly between nodes, usually hosts. Some of these functions
    can be performed between hosts and routers, but this group is not specifically
    related to RD. Host-host communcation functions include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address Resolution** The process by which a device determines the layer 2
    address of another device on the local network from that device''s layer 3 (IP)
    address. This is the job performed by ARP in IPv4.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Next-Hop Determination** The method for looking at an IP datagram''s destination
    address and determining where it should next be sent.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Neighbor Unreachability Detection** The process of determining whether or
    not a neighbor device can be directly contacted.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Duplicate Address Detection** Determining if an address that a device wishes
    to use already exists on the network.'
  prefs: []
  type: TYPE_NORMAL
- en: Redirect Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last functional group contains just one function: *Redirect*. This is the
    technique whereby a router informs a host of a better next-hop node to use for
    a particular destination.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** ND encompasses nine individual functions, many of which are
    related to each other. They are organized into three functional groups: *host-router
    discovery functions*, host-host communications functions, and the *Redirect function*.'
  prefs: []
  type: TYPE_NORMAL
- en: Relationships Between Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The division of ND's overall functionality into nine tasks in three groups is
    somewhat arbitrary, but provides a good frame of reference for understanding what
    the protocol does. Some of the functions in different groups are related; next-hop
    determination uses information obtained as part of Parameter Discovery. The Redirect
    function is also a form of router-host communication but is distinct from RD.
  prefs: []
  type: TYPE_NORMAL
- en: ICMPv6 Messages Used by ND
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as ND is similar to ICMP in its operation, the two protocols are related
    in another way: the way that they perform messaging. ND actually implements its
    functions using ICMPv6 messages. A set of five message types is described in the
    ND standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Router Advertisement Messages** Sent regularly by routers to tell hosts that
    they exist and provide important prefix and parameter information to them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Router Solicitation Messages** Sent by hosts to request that any local routers
    send a Router Advertisement message so they don''t have to wait for the next regular
    advertisement message.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Neighbor Advertisement Messages** Sent by hosts to indicate the existence
    of the host and provide information about it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Neighbor Solicitation Messages** Sent to verify the existence of another
    host and to ask it to transmit a Neighbor Advertisement message.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Redirect Messages** Sent by a router to tell a host of a better method to
    route data to a particular destination.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at how these message types are used later in this chapter. See [Chapter 35](ch35.html
    "Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS") for the structures
    of each of these five ICMPv6 message types used by ND.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 ND Functions Compared to Equivalent IPv4 Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The IPv6 ND protocol has the distinction of being the only truly new protocol
    created as part of the core of IPv6; there is no previous version of ND. Of course,
    most of the services that ND provides to IPv6 were also required in IPv4\. They
    were just provided in a rather diverse set of protocols and standards that the
    ND protocol has formalized, integrated, and improved.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means is that while ND is new, the jobs it does are equivalent to
    the tasks performed by several other protocols in IPv4\. Specifically, the bulk
    of ND functions correspond to the following set of standards, features, and message
    types in IPv4:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ICMPv4 Router Discovery** Most of the functions associated with identifying
    and obtaining information from routers in ND are based on the use of ICMPv4 Router
    Advertisement and Router Solicitation messages, as defined in RFC 1256.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address Resolution Protocol** ND provides enhanced address resolution capabilities
    that are similar to the functions provided in IPv4 by ARP.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ICMPv4 Redirect** ND''s Redirect function and Redirect messages are based
    on similar functionality defined in IPv4 and ICMPv4.'
  prefs: []
  type: TYPE_NORMAL
- en: There are other aspects of ND that only somewhat correlate to how things work
    in IPv4\. There are also improvements or new functionality compared to how these
    IPv4 functions work. Some of these are due to differences in how IPv6 itself operates
    compared to IPv4\. For example, Prefix Discovery in ND is sort of related to the
    Address Mask Request and Address Mask Reply messaging in ICMPv4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, ND represents a substantial improvement compared to the way its job
    was done in IPv4\. Like IPv6 itself, ND is generally better suited to the needs
    of modern networks than the older protocols. Some of the more important specific
    improvements made in ND compared to how its job was done in IPv4 include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Formalizing of Router Discovery** In IPv4, the process of RD and solicitation
    was arguably an afterthought. ND formalizes this process and makes it part of
    the core of the TCP/IP protocol suite.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Formalizing of Address Resolution** In a similar manner, address resolution
    is handled in a superior way in ND, which functions at layer 3 and is tightly
    tied to IP, just as ICMP is. There is no more need for an ambiguously layered
    protocol like ARP, whose implementation depends greatly on the underlying physical
    and data link layers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ability to Perform Functions Securely** ND operates at the network layer,
    so it can make use of the authentication and encryption capabilities of IPsec
    for tasks such as address resolution and RD.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Autoconfiguration** In combination with features built into IPv6, ND allows
    many devices to automatically configure themselves, without the need for something
    like a Dynamic Host Configuration Protocol (DHCP) server (though DHCPv6 does also
    exist).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic Router Selection** Devices use ND to detect if neighbors are reachable.
    If a device is using a router that stops being reachable, it will detect this
    and automatically switch to another one.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multicast-Based Address Resolution** Address resolution is performed using
    special multicast addresses instead of broadcasts, thereby reducing unnecessary
    disruption of "innocent bystanders" when resolution messages must be sent.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better Redirection** Improvements have been made to the method for generating
    and using Redirect messages.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 ND Host-Router Discovery Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connecting individual networks together creates internetworks. The devices that
    are responsible for this connection of networks are routers, which send data from
    one network to the next. A host must rely on a router to forward transmissions
    to all devices other than those on the local network. For this reason, before
    a host can properly use an internetwork, it needs to find a local router and learn
    important information about both the router and the network itself. Enabling this
    information exchange is one of the most important jobs of the IPv6 ND protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The general term used to describe most of the ND communication between hosts
    and routers on a local network is *discovery*. As I mentioned earlier in this
    chapter, the term encompasses not merely discovery of the router, but also communication
    of important parameters. Most of this communication flows from the routers to
    the hosts, since routers control the way that each network is used. They provide
    information to hosts so the hosts know how best to operate.
  prefs: []
  type: TYPE_NORMAL
- en: The various discovery features related to host-router communication are all
    facilitated by the same exchange of two different ICMPv6 message types. Router
    Advertisement messages are sent only by routers, and they contain information
    about the router and the network on which it is located. Router Solicitation messages
    are optional, and they are sent by hosts when they want to find a local router.
    The format of each of these messages is described in [Chapter 35](ch35.html "Chapter 35. ICMPV6
    INFORMATIONAL MESSAGE TYPES AND FORMATS").
  prefs: []
  type: TYPE_NORMAL
- en: Note that both Router Advertisement and Router Solicitation messages may include
    an optional layer 2 address of the device sending the message. This is used to
    update address resolution caches to save time when address resolution is needed
    later.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanisms for using these messages are not really that complicated. The
    best way to see how the discovery process works overall is to look at the specific
    tasks performed both by routers and hosts in ND. Let's start by looking at the
    functions that routers perform.
  prefs: []
  type: TYPE_NORMAL
- en: Host-Router Discovery Functions Performed by Routers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Routers are responsible for the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Routine Advertisement** The main job that routers do in ND is to regularly
    transmit Router Advertisement messages. Each router maintains a timer that controls
    how often an advertisement is sent out. Advertisements are also sent when any
    sort of special situation arises. For example, a message will be sent if key information
    about the router changes, such as its address on the local network. Router Advertisement
    messages include key information about both the router and the network. See [Chapter 35](ch35.html
    "Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS") for a full description
    of the Router Advertisement message format.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parameter Maintenance** Routers are responsible for maintaining key parameters
    about the local network, so they can be sent in advertisements. These include
    the default Hop Limit field value that should be used by hosts on the network,
    a default MTU value for the network, and information such as network prefixes,
    which are used for both first-hop routing by hosts and autoconfiguration. Again,
    some more details on these can be found in [Chapter 35](ch35.html "Chapter 35. ICMPV6
    INFORMATIONAL MESSAGE TYPES AND FORMATS").'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solicitation Processing** Routers listen for Router Solicitation messages.
    When one is received, they will immediately send a Router Advertisement to the
    requesting host.'
  prefs: []
  type: TYPE_NORMAL
- en: Host-Router Discovery Functions Performed by Hosts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For their part, hosts are responsible for three main functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advertisement Processing** Hosts listen for advertisements on their local
    network and process them. They then set appropriate parameters based on the information
    in these messages. This includes maintaining various data structures such as lists
    of prefixes and routers, which are updated regularly as new advertisement information
    comes in.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solicitation Generation** Under certain conditions, a host will generate
    a Router Solicitation and send it out on the local network. This very simple message
    just requests that any local routers that hear it immediately send a Router Advertisement
    message back to the device that made the request. This is most often done when
    a host is first turned on, so it doesn''t have to sit waiting for the next routine
    advertisement.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Autoconfiguration** When required, and if the network supports the function,
    the host will use information from the local router to allow it to automatically
    configure itself with an IP address and other parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** One of the two main functional groups of ND is the set of *host-router
    discovery* functions. They allow hosts on a local network to discover the identity
    of a local router and learn important parameters about how the network is to be
    used. Host-router discovery operations are performed using ICMPv6 Router Advertisement
    and Router Solicitation messages.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 ND Host-Host Communication Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The delivery of datagrams in IP can be divided into two methods: direct and
    indirect. Indirect datagram delivery requires that routers provide help to hosts,
    which leads to the host-router discovery functions described in the previous section.
    Direct delivery of datagrams is performed from one host to another on the same
    network. This doesn''t require the use of routers, but necessitates other IPv6
    ND protocol functions that involve communication directly between local hosts.
    These include next-hop determination, address resolution, neighbor unreachability
    detection, and duplicate address detection.'
  prefs: []
  type: TYPE_NORMAL
- en: Next-Hop Determination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first task that any host must perform when it wants to send a datagram is
    *next-hop determination*. This is the process by which a device looks at the destination
    address in a datagram and decides whether direct or indirect delivery is required.
    In early IPv4, this was done by looking at the class of the address, and later
    on, by using the subnet mask. In IPv6, the prefix information obtained from local
    routers is compared to the destination of the datagram to determine if the destination
    device is local or distant. If it is local, the next hop is the same as the destination
    address; if it is not local, the next hop is chosen from the device's list of
    local routers (which are determined either by manual configuration or using the
    host-router discovery features of ND).
  prefs: []
  type: TYPE_NORMAL
- en: For efficiency purposes, hosts do not perform this next-hop determination for
    each and every datagram. They maintain a destination cache that contains information
    about what the next hop should be for recent devices to which datagrams have been
    sent. Each time a next-hop determination is performed for a particular destination,
    information from that determination is entered into the cache so that it can be
    used the next time datagrams are sent to that device.
  prefs: []
  type: TYPE_NORMAL
- en: Address Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a host determines that the destination of a datagram is local, it will then
    need to send the datagram to that device. The actual transmission will occur using
    whatever physical layer and data link layer technology has been used to implement
    the local network. This requires the host to know the layer 2 address of the destination,
    even though it generally has only the layer 3 address from the datagram. Getting
    from the layer 3 address to the layer 2 address is known as the address resolution
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: In IPv6, the ND protocol is responsible for address resolution. When a host
    wants to get the layer 2 address of a datagram destination it sends an ICMPv6
    Neighbor Solicitation message containing the IP address of the device whose layer
    2 address it wishes to determine. That device responds back with a Neighbor Advertisement
    message that contains its layer 2 address. Instead of using a broadcast that would
    disrupt each device on the local network, the solicitation is sent using a special
    multicast to the destination device's solicited-node address. See Chapters [Chapter 13](ch13.html
    "Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)")
    and [Chapter 25](ch25.html "Chapter 25. IPV6 ADDRESSING") for more information
    about address resolution in IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that even though this discussion does concentrate on communication
    between hosts, address resolution may also be done when a host needs to send a
    datagram to a local router and has no entry for it in its destination cache. In
    the context of address resolution, a destination device is just a neighbor. Whether
    it is a host or a router matters only in terms of what happens after the datagram
    has been sent and received. In other words, these host-to-host functions are so
    named only because they are not specific to the communication between hosts and
    routers like the tasks in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Neighbors Using Neighbor Advertisement Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Devices do not routinely send Neighbor Advertisement messages the way that
    routers send Router Advertisement messages. There really isn''t any need for this:
    Neighbors don''t change much over time, and resolution will occur naturally over
    time as devices send datagrams to each other. In addition, having advertisements
    sent regularly by so many devices on a network would be wasteful.'
  prefs: []
  type: TYPE_NORMAL
- en: A host may, however, send an unsolicited Neighbor Advertisement message under
    certain conditions where it feels it is necessary to immediately provide updated
    information to other neighbors on the local network. A good example of this is
    a hardware failure—in particular, the failure of a network interface card. When
    the card is replaced, the device's layer 2 (MAC) address will change. Assuming
    the device's IP layer can detect this, it can send out an unsolicited Neighbor
    Advertisement message to tell other devices to update their resolution caches
    with the new MAC address.
  prefs: []
  type: TYPE_NORMAL
- en: Neighbor Unreachability Detection and the Neighbor Cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Neighbor Solicitation and Neighbor Advertisement messages are most often associated
    with address resolution, but they also have other purposes. One of these is neighbor
    unreachability detection. Each device maintains information about each of its
    neighbors and updates it dynamically as network conditions change. The information
    is kept for both host and router devices that are neighbors on the local network.
    Knowing that a device has become unreachable is important because a host can adapt
    its behavior accordingly. In the case of an unreachable host, a device may wait
    a certain period of time before trying to send datagrams to an unreachable host,
    instead of flooding the network with repeated attempts to send to the host. An
    unreachable router, on the other hand, is a signal that the device needs to find
    a new router to use, if an alternate is available.
  prefs: []
  type: TYPE_NORMAL
- en: Each host maintains a neighbor cache that contains information about neighboring
    devices. Each time a host receives a datagram from a neighbor, it knows the neighbor
    is reachable at that particular moment, so the device makes an entry in the cache
    for the neighbor to indicate this. Of course, receiving a datagram from a neighbor
    means only that the neighbor is reachable now; the more time that elapses since
    the last datagram was received, the greater the chance that something has happened
    to make the neighbor no longer reachable.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, neighbor reachability information must be considered temporary.
    Each time a neighbor is entered into the cache as reachable, a timer is started.
    When the timer expires, the reachability information for that neighbor is considered
    stale, and reachability is no longer assumed for that neighbor. When a new datagram
    is received from the neighbor in question, the timer is reset and the cache is
    again set to indicate that the device is reachable. The amount of time a host
    should consider a neighbor reachable before expiring it is communicated by a local
    router using a field in a Router Advertisement message.
  prefs: []
  type: TYPE_NORMAL
- en: A host can also dynamically seek out a neighbor if it needs to know its reachability
    status. It sends a Neighbor Solicitation message to the device and waits for a
    Neighbor Advertisement message in response. It then updates the cache accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate Address Detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last use of the two messages we have been discussing here is for duplicate
    address detection. When a host uses the IPv6 autoconfiguration facility, one of
    the steps in the process is to ensure that the address it is trying to use doesn't
    already exist on the network. This is done by sending a Neighbor Solicitation
    message to the address the device wishes to use. If a Neighbor Advertisement message
    is received in reply, the address is already in use.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The second of the two main functional groups of ND is the set
    of *host-host communication* functions. Two ICMPv6 messages, Neighbor Advertisement
    and Neighbor Solicitation, are defined. They enable a variety of types of essential
    communication between adjacent hosts on a local network. These include address
    resolution, determining the next hop to which a datagram should be sent, and also
    the assessment of a neighboring device''s reachability.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 ND Redirect Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last of the major responsibilities of the IPv6 ND protocol is the *Redirect*
    function. This is used by a router to inform a host of a better route to use for
    datagrams that have been sent to a particular destination. An argument could be
    made that the Redirect function should be part of the host-router group since
    it represents a form of communication between routers and regular hosts. However,
    it is somewhat different from the other discovery functions, and so the standard
    treats it separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Routers are responsible for detecting situations where a host on the local
    network has made an inefficient first-hop routing decision, and then attempting
    to correct it. For example, consider a network that has two routers on it, R1
    and R2\. A Host H1 wants to send a datagram to Device X2 on another network that
    is connected to Host H1''s network through Router R2\. If Host H1 sends the datagram
    to Router R1, that router will know it must go through Router R2, and will send
    it there. Seeing that Router R2 was also on the local network, Router R1 therefore
    knows that Host H1 made a poor initial routing decision: The datagram should have
    been sent to Router R2 directly, not Router R1\. If this sounds very similar to
    ICMPv4''s redirect feature, that''s because it is!'
  prefs: []
  type: TYPE_NORMAL
- en: In response, Router R1 will create a special ICMPv6 Redirect message. This message
    will tell Host H1 that for any subsequent datagrams that will be sent to Device
    X2 should be first sent to Router R2, instead of to Router R1\. It is also possible
    that a router may determine other situations where the first hop from a particular
    host should be different and will advise the host using a Redirect message. This
    is illustrated in [Figure 36-2](ch36s06.html#nd_host_redirection_using_an_icmpv6_redi
    "Figure 36-2. ND host redirection using an ICMPv6 Redirect message Host H1 sends
    to Router R1 an IPv6 datagram destined for a device on Network N2\. However, Router
    R1 notices that Router R2 is on the same network as the source device and is a
    more direct route to Network N2\. It forwards the datagram on to Router R2 but
    also sends an ICMPv6 Redirect message back to Host H1 to tell it to use Router
    R2 next time.").
  prefs: []
  type: TYPE_NORMAL
- en: Only routers send Redirect messages, not hosts. Hosts are responsible for looking
    for these Redirect messages and processing them. A host receiving such a message
    will look in it to see which destination's datagram led to the redirection notice,
    and which new first hop the router is saying the host should use in the future
    for that destination. In this example, Host H1 will see that Router R1 is saying
    that any further datagrams to Device X2 should be sent to Router R2 instead of
    Router R1\. Host H1 will update its destination cache for Device X2 accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '![ND host redirection using an ICMPv6 Redirect message Host H1 sends to Router
    R1 an IPv6 datagram destined for a device on Network N2\. However, Router R1 notices
    that Router R2 is on the same network as the source device and is a more direct
    route to Network N2\. It forwards the datagram on to Router R2 but also sends
    an ICMPv6 Redirect message back to Host H1 to tell it to use Router R2 next time.](httpatomoreillycomsourcenostarchimages288025.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 36-2. ND host redirection using an ICMPv6 Redirect message Host H1 sends
    to Router R1 an IPv6 datagram destined for a device on Network N2\. However, Router
    R1 notices that Router R2 is on the same network as the source device and is a
    more direct route to Network N2\. It forwards the datagram on to Router R2 but
    also sends an ICMPv6 Redirect message back to Host H1 to tell it to use Router
    R2 next time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KEY CONCEPT** The ND *Redirect* function allows a router to tell a host to
    use a different router for future transmissions to a particular destination. It
    is similar to the IPv4 redirect feature and is implemented using ICMPv6 Redirect
    messages.'
  prefs: []
  type: TYPE_NORMAL
- en: When a router sends a Redirect message, it may also include in the message the
    data link layer address of the destination to which it is redirecting. This address
    is used by the host to update its address resolution cache, if necessary. This
    may save bandwidth in the future by eliminating an address resolution cycle, when
    the redirected host tries to send to the new, redirected location. In the example,
    Router R1 may include Router R2's own layer 2 address in the Redirect message.
    This can be used by Host H1 the next time it has a datagram for Device X2.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 also supports the authentication of Redirect messages to prevent unauthorized
    devices from causing havoc by sending inappropriate Redirect messages. A host
    may be configured to discard Redirect messages that are not properly authenticated.
  prefs: []
  type: TYPE_NORMAL
