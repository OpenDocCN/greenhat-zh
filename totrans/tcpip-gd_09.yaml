- en: Part II-6. IP SUPPORT PROTOCOLS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分-6. IP 支持协议
- en: '[Chapter 31](ch31.html "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第31章](ch31.html "第31章. ICMP 概念和一般操作")'
- en: '[Chapter 32](ch32.html "Chapter 32. ICMPV4 ERROR MESSAGE TYPES AND FORMATS")'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第32章](ch32.html "第32章. ICMPV4 错误消息类型和格式")'
- en: '[Chapter 33](ch33.html "Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND
    FORMATS")'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第33章](ch33.html "第33章. ICMPV4 信息消息类型和格式")'
- en: '[Chapter 34](ch34.html "Chapter 34. ICMPV6 ERROR MESSAGE TYPES AND FORMATS")'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第34章](ch34.html "第34章. ICMPV6 错误消息类型和格式")'
- en: '[Chapter 35](ch35.html "Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND
    FORMATS")'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第35章](ch35.html "第35章. ICMPV6 信息消息类型和格式")'
- en: '[Chapter 36](ch36.html "Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL")'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[第36章](ch36.html "第36章. IPV6 邻居发现 (ND) 协议")'
- en: 'The Internet Protocol (IP) is the key network layer protocol that implements
    the TCP/IP protocol suite. Since IP is the protocol that provides the mechanism
    for delivering datagrams between devices, it is designed to be relatively basic.
    For example, it lacks provisions for some way to allow errors to be reported back
    to a transmitting device, and for tests and special tasks to be accomplished.
    These auxiliary capabilities are necessary for the operation of an internetwork,
    however, so TCP/IP includes *support protocols* that help IP perform these tasks.
    This part examines the two main IP support protocols: the *Internet Control Message
    Protocol (ICMP)* and the *Neighbor Discovery (ND)* protocol.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议 (IP) 是实现 TCP/IP 协议套件的关键网络层协议。由于 IP 是提供在设备之间传递数据报机制的协议，因此它被设计得相对简单。例如，它缺乏允许错误报告回发送设备以及完成测试和特殊任务的方法。然而，这些辅助功能对于互联网的操作是必要的，因此
    TCP/IP 包括 *支持协议* 来帮助 IP 执行这些任务。本部分探讨了两个主要的 IP 支持协议：*互联网控制消息协议 (ICMP)* 和 *邻居发现
    (ND)* 协议。
- en: The bulk of this part thoroughly describes ICMP, which was initially developed
    to be a companion to the original IP version 4 (IPv4). With the creation of IP
    version 6 (IPv6), a new version of ICMP, called ICMP version 6 (ICMPv6), was created
    as well. The original ICMP is now sometimes called *ICMPv4* to differentiate it,
    just as the original IP is now often called IPv4.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分的大部分内容详细描述了 ICMP，它最初是为了作为原始 IP 版本 4 (IPv4) 的配套而开发的。随着 IP 版本 6 (IPv6) 的创建，一个新的
    ICMP 版本也被创建，称为 ICMP 版本 6 (ICMPv6)。原始的 ICMP 现在有时被称为 *ICMPv4* 以区分它，就像原始的 IP 现在通常被称为
    IPv4 一样。
- en: The two versions of ICMP have some differences in their specifics, but they
    are very similar in overall operation. For this reason, I have integrated the
    general operation description of both versions of ICMP in the first chapter of
    this part. The area where ICMPv4 and ICMPv6 most differ is in specific message
    types and formats, so these have been described separately in the second through
    fifth chapters. These chapters describe the error messages and informational messages
    in each version.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP 的两个版本在具体方面有一些差异，但它们在总体操作上非常相似。因此，我将本部分的两个版本的 ICMP 的一般操作描述整合到了第一章。ICMPv4
    和 ICMPv6 最不同的地方在于特定的消息类型和格式，因此这些内容在第二到第五章中分别进行了描述。这些章节描述了每个版本中的错误消息和信息消息。
- en: The final chapter describes ND, which was created specifically to assist in
    the operation of IPv6 and is closely related to ICMPv6.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一章描述了 ND，它专门创建来协助 IPv6 的操作，并且与 ICMPv6 密切相关。
- en: Due to the close relationship between ICMP and IP, this part assumes that you
    are familiar with basic IP concepts, including IP addressing, the general format
    of IP datagrams, and how they are routed (covered in [Part II-3](pt06.html "Part II-3. INTERNET
    PROTOCOL VERSION 4 (IP/IPV4)")). To better understand ICMPv6 details, you may
    also want to reference the IPv6 addressing and datagram encapsulation information
    (covered in [Part II-4](pt07.html "Part II-4. INTERNET PROTOCOL VERSION 6 (IPV6)")).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ICMP 与 IP 之间的紧密关系，本部分假设您熟悉基本的 IP 概念，包括 IP 地址、IP 数据报的一般格式以及它们的路由方式（在第 II-3
    部分[pt06.html "第 II-3 部分. 互联网协议版本 4 (IP/IPV4)"]中介绍）。为了更好地理解 ICMPv6 的细节，您可能还需要参考
    IPv6 地址和数据报封装信息（在第 II-4 部分[pt07.html "第 II-4 部分. 互联网协议版本 6 (IPV6)"]中介绍）。
- en: Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第31章. ICMP 概念和一般操作
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The Internet Control Message Protocol (ICMP) is one of the underappreciated
    "worker bees" of the networking world. Everyone knows how important key protocols
    such as the Internet Protocol (IP) are to TCP/IP, but few realize that the suite
    as a whole relies on many functions that ICMP provides. Originally created to
    allow the reporting of a small set of error conditions, ICMP messages are now
    used to implement a wide range of error-reporting, feedback, and testing capabilities.
    While each message type is unique, they are all implemented using a common message
    format, sent, and then received based on relatively simple protocol rules. This
    makes ICMP one of the easiest TCP/IP protocols to understand. (Yes, I actually
    said something in this book was easy!)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网控制消息协议（ICMP）是网络世界中未被充分重视的“工蜂”之一。每个人都清楚关键协议如互联网协议（IP）对TCP/IP的重要性，但很少有人意识到整个套件依赖于ICMP提供的许多功能。最初创建是为了允许报告一小组错误条件，ICMP消息现在被用来实现广泛的错误报告、反馈和测试功能。虽然每种消息类型都是独特的，但它们都是使用通用消息格式实现的，然后根据相对简单的协议规则发送和接收。这使得ICMP成为最容易理解的TCP/IP协议之一。（是的，我在这本书中确实说过一些事情是容易的！）
- en: In this chapter, I provide a general description of ICMP. I begin with an overview
    of ICMP, discussing its purpose, history, and the versions and standards that
    define it. I describe the general method by which ICMP operates and discuss the
    rules that govern how and when ICMP messages are created and processed. I then
    outline the common format used for ICMP messages in versions 4 and 6 of the protocol
    (ICMPv4 and ICMPv6), and how data is encapsulated in them in general terms. I
    conclude with a discussion of ICMP message classifications and a summary of different
    message types and codes for both ICMPv4 and ICMPv6.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我提供了ICMP的一般描述。我首先概述ICMP，讨论其目的、历史以及定义它的版本和标准。我描述了ICMP的一般操作方法，并讨论了如何以及何时创建和处理的规则。然后，我概述了协议第4版和第6版（ICMPv4和ICMPv6）中使用的ICMP消息的常见格式，以及它们在一般术语中如何封装数据。最后，我讨论了ICMP消息的分类，并总结了ICMPv4和ICMPv6的不同消息类型和代码。
- en: ICMP Overview, History, Versions, and Standards
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMP概述、历史、版本和标准
- en: IP is the foundation of the TCP/IP protocol suite, because it is the mechanism
    responsible for delivering datagrams. Three of the main characteristics that describe
    IP's datagram delivery method are *connectionless*, *unreliable*, and *unacknowledged*.
    This means that datagrams are just sent over the internetwork with no prior connection
    established, no assurance they will show up, and no acknowledgment sent back to
    the sender that they arrived. On the surface, this seems like it would result
    in a protocol that is difficult to use and impossible to rely on, and thus would
    be a poor choice for designing a protocol suite. However, even though IP makes
    no guarantees, it works very well because most of the time, IP internetworks are
    sufficiently robust that messages get where they need to go.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: IP是TCP/IP协议套件的基础，因为它负责交付数据报的机制。描述IP数据报交付方法的三个主要特征是*无连接的*、*不可靠的*和*无确认的*。这意味着数据报只是在互联网上发送，没有建立先前的连接，没有保证它们会出现，也没有向发送者发送确认它们已到达的确认。表面上，这似乎会导致一个难以使用且无法依赖的协议，因此不适合设计协议套件。然而，尽管IP没有保证，它仍然工作得非常好，因为大多数时候，IP互联网足够健壮，消息能够到达它们需要去的地方。
- en: Even the best-designed system still encounters problems, of course. Incorrect
    packets are occasionally sent, hardware devices have problems, routes are found
    to be invalid, and so forth. IP devices also often need to share specific information
    in order to guide them in their operation, and they need to perform tests and
    diagnostics. However, IP itself includes no provision that allows devices to exchange
    low-level control messages. Instead, these features are provided in the form of
    a companion protocol to IP called the *Internet Control Message Protocol (ICMP)*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最精心设计的系统仍然会遇到问题，这是当然的。偶尔会发送错误的包，硬件设备出现问题，找到无效的路由，等等。IP设备也需要共享特定信息以便引导它们的操作，并且它们需要执行测试和诊断。然而，IP本身并没有提供允许设备交换低级控制消息的条款。相反，这些功能以IP的伴随协议的形式提供，称为*互联网控制消息协议（ICMP）*。
- en: A good analogy for the relationship between IP and ICMP is to consider the one
    between a high-powered executive and her experienced administrative assistant.
    The executive is busy and her time is very expensive. She is paid to do a specific
    job and to do it well, and not to spend time on administrative tasks. However,
    without someone doing those tasks, the executive could not do her job properly.
    The administrative assistant does the important support jobs that make it possible
    for the executive to focus on her work. The working relationship between them
    is very important; a good pair will work together like a cohesive team, even anticipating
    each other's needs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: IP和ICMP之间关系的良好类比是考虑一个高功率执行者和她经验丰富的行政助理之间的关系。执行者很忙，她的时间是极其宝贵的。她被雇佣来做一项具体的工作，并且要做好这项工作，而不是花时间在行政工作上。然而，如果没有人在做这些工作，执行者就无法正确地完成她的工作。行政助理做重要的支持工作，使得执行者能够专注于她的工作。他们之间的工作关系非常重要；一个好的搭档会像一个团结的团队一样一起工作，甚至预见彼此的需求。
- en: In TCP/IP, IP is the executive, and ICMP is its administrative assistant. IP
    focuses on its core activities, such as addressing, datagram packaging, and routing.
    ICMP provides critical support to IP in the form of *ICMP messages* that allow
    different types of communication to occur between IP devices. These messages use
    a common general format and are encapsulated in IP datagrams for transmission.
    They are divided into different categories, and each type has a specific use and
    internal field format.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP/IP中，IP是执行者，而ICMP是其行政助理。IP专注于其核心活动，如寻址、数据报封装和路由。ICMP通过提供允许IP设备之间进行不同类型通信的*ICMP消息*来为IP提供关键支持。这些消息使用一个通用的通用格式，并封装在IP数据报中进行传输。它们被分为不同的类别，每种类型都有特定的用途和内部字段格式。
- en: Just as an administrative assistant often has a special location in an organization
    chart, and usually connects with a dotted line directly to the executive she assists,
    ICMP occupies a unique place in the TCP/IP protocol architecture (see [Chapter 8](ch08.html
    "Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE")). Technically, you might
    consider ICMP to belong to layer 4, because it creates messages that are encapsulated
    in IP datagrams and sent using IP at layer 3\. However, in the standard that first
    defined it, ICMP is specifically declared to be not only part of the network layer,
    but also, as stated in RFC 792, is "actually an integral part of IP, [that] must
    be implemented by every IP module." This was the initial defining standard for
    ICMP, titled simply "Internet Control Message Protocol." It was published at the
    same time as the standard for IP, which was RFC 791\. This is further indication
    that IP and ICMP really are a team of sorts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如行政助理在组织结构图上通常有一个特殊的位置，并且通常用虚线直接连接到她所协助的执行者一样，ICMP在TCP/IP协议架构中占据一个独特的位置（见[第8章](ch08.html
    "第8章。TCP/IP协议套件和架构")）。技术上，你可能认为ICMP属于第4层，因为它创建的消息封装在IP数据报中，并使用第3层的IP发送。然而，在最初定义它的标准中，ICMP被明确声明不仅属于网络层，而且，正如RFC
    792中所述，它是“IP的真正组成部分，[必须]由每个IP模块实现。”这是ICMP的初始定义标准，标题简单地称为“互联网控制消息协议”。它与IP的标准同时发布，即RFC
    791。这进一步表明IP和ICMP确实是一对搭档。
- en: Due to the close relationship between the two, when the new version 6 of the
    Internet Protocol (IPv6) was developed in the mid-1990s, it was necessary to define
    a new version of ICMP as well. This was of course called the "Internet Control
    Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification."
    It was first published as RFC 1885 in 1995, and revised in RFC 2463 in 1998\.
    Just as the original IP is now often called IPv4 to differentiate it from IPv6,
    the original ICMP is now also called *ICMPv4*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两者之间关系密切，当1990年代中期开发新的互联网协议第6版（IPv6）时，有必要定义一个新的ICMP版本。这当然被称为“互联网控制消息协议（ICMPv6）用于互联网协议第6版（IPv6）规范”。它最初于1995年作为RFC
    1885发布，并在1998年作为RFC 2463进行了修订。正如原始IP现在通常称为IPv4以区分IPv6一样，原始的ICMP现在也称为*ICMPv4*。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** In TCP/IP, diagnostic, test, and error-reporting functions
    at the internetwork layer are performed by the *Internet Control Message Protocol
    (ICMP)*, which is like IP''s "administrative assistant." The original version,
    now called ICMPv4, is used with IPv4, and the newer ICMPv6 is used with IPv6.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在TCP/IP中，互联网层中的诊断、测试和错误报告功能由*互联网控制消息协议（ICMP）*执行，它类似于IP的“行政助理”。原始版本，现在称为ICMPv4，与IPv4一起使用，而较新的ICMPv6与IPv6一起使用。'
- en: These two RFCs, 792 and 2463, define the basic operation of ICMPv4 and ICMPv6,
    respectively, and also describe some of the ICMP message types supported by each
    version of the protocol. ICMPv4 and ICMPv6 are very similar in most respects,
    although they have some differences, most of which are a direct result of the
    changes made to IP itself. Another document, RFC 1122, "Requirements for Internet
    Hosts—Communication Layers," contains rules for how ICMPv4 is used, as you will
    see soon in the section on ICMP message creation and processing conventions later
    in this chapter. RFC 1812, "Requirements for IP Version 4 Routers," is also relevant.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个RFC，792和2463，分别定义了ICMPv4和ICMPv6的基本操作，并描述了每种协议版本所支持的ICMP消息类型。ICMPv4和ICMPv6在大多数方面非常相似，尽管它们有一些差异，这些差异大多是由于对IP本身的直接更改而产生的。另一份文档RFC
    1122，“互联网主机需求——通信层”，包含了关于如何使用ICMPv4的规则，正如你将在本章后面关于ICMP消息创建和处理惯例的部分中看到的。RFC 1812，“IP版本4路由器需求”也是相关的。
- en: Both versions of the protocol define a general messaging system that was designed
    to be expandable. This means that in addition to the messages defined in the ICMP
    standards themselves, other protocols may also define message types used in ICMP.
    Some of the more important of these are shown in [Table 31-1](ch31.html#non-icmp_internet_standards_that_define_
    "Table 31-1. Non-ICMP Internet Standards That Define ICMP Messages").
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议的两个版本都定义了一个通用消息系统，该系统被设计为可扩展的。这意味着除了在ICMP标准本身中定义的消息之外，其他协议也可以定义在ICMP中使用的消息类型。其中一些更重要的是在[表31-1](ch31.html#non-icmp_internet_standards_that_define_
    "表31-1. 定义ICMP消息的非ICMP互联网标准")中展示的。
- en: Table 31-1. Non-ICMP Internet Standards That Define ICMP Messages
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表31-1. 定义ICMP消息的非ICMP互联网标准
- en: '| ICMP Version of Message Types Defined | RFC Number | Name | ICMP Message
    Types Defined |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| ICMP版本定义的消息类型 | RFC编号 | 名称 | ICMP消息类型定义 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '|   | 950 | Internet Standard Subnetting Procedure | Address Mask Request,
    Address Mask Reply |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|   | 950 | 互联网标准子网划分过程 | 地址掩码请求，地址掩码回复 |'
- en: '|   | 1256 | ICMP Router Discovery Messages | Router Advertisement, Router
    Solicitation |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|   | 1256 | ICMP路由器发现消息 | 路由器通告，路由器请求 |'
- en: '| ICMPv4 | 1393 | Traceroute Using an IP Option | Traceroute |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| ICMPv4 | 1393 | 使用IP选项进行Traceroute | Traceroute |'
- en: '|   | 1812 | Requirements for IP Version 4 Routers | Defines three new codes
    (subtypes) for the Destination Unreachable message. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|   | 1812 | IP版本4路由器需求 | 定义了目的地不可达消息的三个新代码（子类型）。|'
- en: '| ICMPv6 | 2461 | Neighbor Discovery for IP Version 6 (IPv6) | Router Advertisement,
    Router Solicitation, Neighbor Advertisement, Neighbor Solicitation, Redirect |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| ICMPv6 | 2461 | IP版本6（IPv6）的邻居发现 | 路由器通告，路由器请求，邻居通告，邻居请求，重定向 |'
- en: '|   | 2894 | Router Renumbering for IPv6 | Router Renumbering |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|   | 2894 | IPv6路由器重新编号 | 路由器重新编号 |'
- en: This chapter includes a full list of the ICMPv4 and ICMPv6 message types covered
    in this book and the standards that define each one.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括本书中涵盖的ICMPv4和ICMPv6消息类型的完整列表以及定义每个消息类型的标准。
- en: ICMP General Operation
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMP通用操作
- en: 'ICMP is one of the simplest protocols in the TCP/IP protocol suite. Most protocols
    implement a particular type of functionality to either facilitate basic operation
    of a part of the network stack or an application. To this end, they include many
    specific algorithms and tasks that define the protocol, which is where most of
    the complexity lies. ICMP, in contrast, is exactly what its name suggests: a protocol
    that defines control messages. As such, pretty much all of what ICMP is about
    is providing a mechanism for any IP device to send control messages to another
    device.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP是TCP/IP协议套中最简单的协议之一。大多数协议实现特定类型的功能，以促进网络栈的一部分或应用程序的基本操作。为此，它们包括许多特定的算法和任务，这些定义了协议，这也是大多数复杂性的来源。相比之下，ICMP正是其名称所暗示的：一个定义控制消息的协议。因此，ICMP的大部分内容都是提供一种机制，使任何IP设备都能向另一设备发送控制消息。
- en: The ICMP Message-Passing Service
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMP消息传递服务
- en: Various message types are defined in ICMP that allow different types of information
    to be exchanged. These are usually either generated for the purpose of reporting
    errors or for exchanging important information of different sorts that is needed
    to keep IP operating smoothly. ICMP itself doesn't define how all the different
    ICMP messages are used; this is done by the protocols that use the messages. In
    this manner, ICMP describes a simple message-passing service to other protocols.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP定义了各种消息类型，允许交换不同类型的信息。这些通常是为了报告错误或交换保持IP平稳运行所需的不同类型的重要信息而生成的。ICMP本身并不定义所有不同ICMP消息的使用方式；这是由使用这些消息的协议来完成的。以这种方式，ICMP为其他协议描述了一个简单的消息传递服务。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** ICMP is not like most other TCP/IP protocols in that it does
    not perform a specific task. It defines a mechanism by which various control messages
    can be transmitted and received to implement a variety of functions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ICMP与其他大多数TCP/IP协议不同，它不执行特定任务。它定义了一种机制，通过该机制可以传输和接收各种控制消息以实现各种功能。'
- en: As mentioned in the preceding section, ICMP is considered an integral part of
    IP, even though it uses IP to send its messages. Typically, the operation of ICMP
    involves some portion of the TCP/IP protocol software on a machine detecting a
    condition that causes it to generate an ICMP message. This is often the IP layer
    itself, though it may be some other part of the software. The message is then
    encapsulated and transmitted like any other TCP/IP message, and is given no special
    treatment compared to other IP datagrams. The message is sent over the internetwork
    to the IP layer at the receiving device, as shown in [Figure 31-1](ch31s02.html#icmp_general_operation_a_typical_use_of_
    "Figure 31-1. ICMP general operation A typical use of ICMP is to provide a feedback
    mechanism when an IP message is sent. In this example, Device A is trying to send
    an IP datagram to Device B. However, when it gets to Router R3, a problem of some
    sort is detected that causes the datagram to be dropped. Router R3 sends an ICMP
    message back to Device A to tell it that something happened, hopefully with enough
    information to let Device A correct the problem, if possible. Router R3 can only
    send the ICMP message back to Device A, not to Router R2 or R1.").
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，尽管ICMP使用IP发送其消息，但它被认为是IP的一个组成部分。通常，ICMP的操作涉及机器上TCP/IP协议软件的一部分检测到导致其生成ICMP消息的条件。这通常是IP层本身，尽管也可能是软件的另一个部分。然后，消息被封装并像任何其他TCP/IP消息一样传输，与其他IP数据报相比没有特殊处理。消息通过网络发送到接收设备的IP层，如图[图31-1](ch31s02.html#icmp_general_operation_a_typical_use_of_
    "图31-1. ICMP一般操作 ICMP的一个典型用途是在发送IP消息时提供反馈机制。在这个例子中，设备A试图向设备B发送IP数据报。然而，当它到达路由器R3时，检测到某种问题导致数据报被丢弃。路由器R3向设备A发送一个ICMP消息，告知它发生了某些事情，希望提供足够的信息让设备A纠正问题，如果可能的话。路由器R3只能将ICMP消息发送回设备A，而不能发送给路由器R2或R1。")所示。
- en: Again, since many of the ICMP messages are actually intended to convey information
    to a device's IP software, the IP layer itself may be the ultimate destination
    of an ICMP message once a recipient gets it. In other cases, the ultimate destination
    may be some other part of the TCP/IP protocol software, which is determined by
    the type of message received. ICMP does not use ports like the User Datagram Protocol
    (UDP) or Transmission Control Protocol (TCP) to direct its messages to different
    applications on a host. The software recognizes the message type and directs it
    accordingly within the software.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于许多ICMP消息实际上是为了向设备的IP软件传达信息，因此一旦接收方收到该消息，IP层本身可能就是ICMP消息的最终目的地。在其他情况下，最终目的地可能是TCP/IP协议软件的另一个部分，这取决于接收到的消息类型。ICMP不使用端口，如用户数据报协议（UDP）或传输控制协议（TCP）来将消息定向到主机上的不同应用程序。软件识别消息类型，并在软件内部相应地引导它。
- en: ICMP was originally designed with the idea that most messages would be sent
    by routers, but they can be sent by both routers and by regular hosts as well,
    depending on the message type. Some are obviously sent only by routers, such as
    Redirect messages; others may be sent by either routers or hosts. Many of the
    ICMP messages are used in matched pairs, especially in various kinds of Request
    and Reply messages, and Advertisement and Solicitation messages.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP最初的设计理念是大多数消息将由路由器发送，但它们也可以由路由器和普通主机发送，具体取决于消息类型。有些显然只由路由器发送，例如重定向消息；而其他可能由路由器或主机发送。许多ICMP消息都是成对使用的，尤其是在各种请求和回复消息以及广告和请求消息中。
- en: '![ICMP general operation A typical use of ICMP is to provide a feedback mechanism
    when an IP message is sent. In this example, Device A is trying to send an IP
    datagram to Device B. However, when it gets to Router R3, a problem of some sort
    is detected that causes the datagram to be dropped. Router R3 sends an ICMP message
    back to Device A to tell it that something happened, hopefully with enough information
    to let Device A correct the problem, if possible. Router R3 can only send the
    ICMP message back to Device A, not to Router R2 or R1.](httpatomoreillycomsourcenostarchimages287959.png.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![ICMP通用操作 AICMP的典型用途是在发送IP消息时提供反馈机制。在这个例子中，设备A试图向设备B发送一个IP数据报。然而，当它到达路由器R3时，检测到某种问题导致数据报被丢弃。路由器R3向设备A发送一个ICMP消息，告知它发生了某些事情，希望提供足够的信息让设备A纠正问题，如果可能的话。路由器R3只能将ICMP消息发送回设备A，而不能发送给路由器R2或R1。](httpatomoreillycomsourcenostarchimages287959.png.jpg)'
- en: Figure 31-1. ICMP general operation A typical use of ICMP is to provide a feedback
    mechanism when an IP message is sent. In this example, Device A is trying to send
    an IP datagram to Device B. However, when it gets to Router R3, a problem of some
    sort is detected that causes the datagram to be dropped. Router R3 sends an ICMP
    message back to Device A to tell it that something happened, hopefully with enough
    information to let Device A correct the problem, if possible. Router R3 can only
    send the ICMP message back to Device A, not to Router R2 or R1.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图31-1. ICMP通用操作 AICMP的典型用途是在发送IP消息时提供反馈机制。在这个例子中，设备A试图向设备B发送一个IP数据报。然而，当它到达路由器R3时，检测到某种问题导致数据报被丢弃。路由器R3向设备A发送一个ICMP消息，告知它发生了某些事情，希望提供足够的信息让设备A纠正问题，如果可能的话。路由器R3只能将ICMP消息发送回设备A，而不能发送给路由器R2或R1。
- en: ICMP Error Reporting Limited to the Datagram Source
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMP错误报告限于数据报源
- en: One interesting general characteristic of ICMP's operation is that when errors
    are detected, they can be reported using ICMP, but only back to the original source
    of a datagram. This is actually a big drawback in how ICMP works. Refer back to
    [Figure 31-1](ch31s02.html#icmp_general_operation_a_typical_use_of_ "Figure 31-1. ICMP
    general operation A typical use of ICMP is to provide a feedback mechanism when
    an IP message is sent. In this example, Device A is trying to send an IP datagram
    to Device B. However, when it gets to Router R3, a problem of some sort is detected
    that causes the datagram to be dropped. Router R3 sends an ICMP message back to
    Device A to tell it that something happened, hopefully with enough information
    to let Device A correct the problem, if possible. Router R3 can only send the
    ICMP message back to Device A, not to Router R2 or R1.") and consider again client
    Host A sending a message to server Host B, with a problem detected in the datagram
    by Router R3\. Even if Router R3 suspects that the problem was caused by one of
    the preceding routers that handled the message, such as Router R2, it *cannot*
    send a problem report to Router R2\. It can send an ICMP message only back to
    Host A.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP操作的一个有趣的一般特征是，当检测到错误时，可以使用ICMP报告错误，但只能报告给数据报的原始源。这实际上是ICMP工作方式的一个重大缺点。请参阅[图31-1](ch31s02.html#icmp_general_operation_a_typical_use_of_
    "图31-1. ICMP通用操作 AICMP的典型用途是在发送IP消息时提供反馈机制。在这个例子中，设备A试图向设备B发送一个IP数据报。然而，当它到达路由器R3时，检测到某种问题导致数据报被丢弃。路由器R3向设备A发送一个ICMP消息，告知它发生了某些事情，希望提供足够的信息让设备A纠正问题，如果可能的话。路由器R3只能将ICMP消息发送回设备A，而不能发送给路由器R2或R1。")并再次考虑客户端主机A向服务器主机B发送消息，由路由器R3检测到数据报中的问题。即使路由器R3怀疑问题是由处理消息的前一个路由器（如路由器R2）引起的，它*也不能*向路由器R2发送问题报告。它只能将ICMP消息发送回主机A。
- en: This limitation is an artifact of how IP works. You may recall from looking
    at the IP datagram format that the only address fields are for the original source
    and ultimate destination of the datagram. (The only exception is if the IP Record
    Route option is used, but devices cannot count on this.) When Router R3 receives
    a datagram from Router R2 that Router R2 in turn received from Router R1 (and
    prior to that, from Device A), it is only Device A's address in the datagram.
    Thus, Router R3 *must* send a problem report back to Device A, and Device A must
    decide what to do with it. Device A may decide to change the route it uses or
    to generate an error report that an administrator can use to troubleshoot Router
    R2.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制是IP工作方式的产物。你可能还记得查看IP数据报格式时，唯一的地址字段是用于数据报的原始源地址和最终目的地址。（唯一的例外是如果使用了IP记录路由选项，但设备不能依赖这一点。）当路由器R3从路由器R2接收数据报，而路由器R2又从路由器R1（以及在那之前，从设备A）接收数据报时，数据报中只有设备A的地址。因此，路由器R3*必须*将问题报告发送回设备A，而设备A必须决定如何处理它。设备A可能决定更改它使用的路由，或者生成一个管理员可以用来调试路由器R2的错误报告。
- en: In addition to this basic limitation, several special rules and conventions
    have been put in place to govern the circumstances under which ICMP messages are
    generated, sent, and processed. I'll discuss these later in the chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个基本限制之外，还制定了一些特殊的规则和惯例来规范ICMP消息生成、发送和处理的条件。我将在本章后面讨论这些内容。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** ICMP error-reporting messages sent in response to a problem
    seen in an IP datagram can be sent back only to the originating device. Intermediate
    devices cannot be the recipients of an ICMP message because their addresses are
    normally not carried in the IP datagram''s header.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在响应在IP数据报中看到的某个问题时发送的ICMP错误报告消息只能发送回原始设备。中间设备不能成为ICMP消息的接收者，因为它们的地址通常不在IP数据报的头部中携带。'
- en: ICMP Message Classes, Types, and Codes
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMP消息类别、类型和代码
- en: ICMP messages are used to allow the communication of different types of information
    between IP devices on an internetwork. The messages themselves are used for a
    wide variety of purposes, and they are organized into general categories as well
    as numerous specific types and subtypes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP消息用于允许在互联网中的IP设备之间通信不同类型的信息。这些消息本身用于广泛的目的，并且它们被组织成一般类别以及许多特定类型和子类型。
- en: ICMP Message Classes
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMP消息类别
- en: 'At the highest level, ICMP messages are divided into two classes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在最高级别上，ICMP消息分为两大类：
- en: '**Error Messages** These messages are used to provide feedback to a source
    device about an error that has occurred. They are typically generated specifically
    in response to some sort of action, usually the transmission of a datagram, as
    shown in the example in [Figure 31-1](ch31s02.html#icmp_general_operation_a_typical_use_of_
    "Figure 31-1. ICMP general operation A typical use of ICMP is to provide a feedback
    mechanism when an IP message is sent. In this example, Device A is trying to send
    an IP datagram to Device B. However, when it gets to Router R3, a problem of some
    sort is detected that causes the datagram to be dropped. Router R3 sends an ICMP
    message back to Device A to tell it that something happened, hopefully with enough
    information to let Device A correct the problem, if possible. Router R3 can only
    send the ICMP message back to Device A, not to Router R2 or R1."). Errors are
    usually related to the structure or content of a datagram or to problem situations
    on the internetwork encountered during datagram routing.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误消息** 这些消息用于向源设备提供有关已发生错误的反馈。它们通常专门针对某种操作生成，通常是数据报的传输，如[图31-1](ch31s02.html#icmp_general_operation_a_typical_use_of_
    "图31-1. ICMP一般操作 一个典型的ICMP用途是在发送IP消息时提供一个反馈机制。在这个例子中，设备A试图向设备B发送IP数据报。然而，当它到达路由器R3时，检测到某种问题导致数据报被丢弃。路由器R3向设备A发送ICMP消息，告诉它发生了某些事情，希望提供足够的信息让设备A纠正问题，如果可能的话。路由器R3只能将ICMP消息发送回设备A，而不能发送给路由器R2或R1。")所示。错误通常与数据报的结构或内容有关，或者与在数据报路由过程中在互联网中遇到的问题情况有关。'
- en: '**Informational (or Query) Messages** These are messages that are used to let
    devices exchange information, implement certain IP-related features, and perform
    testing. They do not indicate errors and are typically not sent in response to
    a regular datagram transmission. They are generated either when directed by an
    application or on a regular basis to provide information to other devices. An
    informational ICMP message may also be sent in reply to another informational
    ICMP message, since they often occur in request/reply or solicitation/advertisement
    functional pairs.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息性（或查询）消息** 这些是用于让设备交换信息、实现某些 IP 相关功能以及执行测试的消息。它们不指示错误，并且通常不会在常规数据报传输的响应中发送。它们是在应用程序的指示下生成或在常规基础上定期生成，以向其他设备提供信息。信息性
    ICMP 消息也可能在响应另一个信息性 ICMP 消息时发送，因为它们通常出现在请求/响应或请求/公告功能对中。'
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** ICMP messages are divided into two general categories: *error
    messages* that are used to report problem conditions, and *informational messages*
    that are used for diagnostics, testing, and other purposes.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ICMP 消息分为两大类：*错误消息*，用于报告问题条件，以及*信息性消息*，用于诊断、测试和其他目的。'
- en: ICMP Message Types
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMP 消息类型
- en: Each individual kind of message in ICMP is given its own unique Type value,
    which is put into the field of that name in the ICMP common message format. This
    field is 8 bits wide, so a theoretical maximum of 256 message types can be defined.
    A separate set of Type values is maintained for each of ICMPv4 and ICMPv6.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP 中的每种独立消息类型都分配了一个唯一的类型值，该值放入 ICMP 公共消息格式中同名字段。该字段宽度为 8 位，因此可以定义的理论最大消息类型数为
    256。为 ICMPv4 和 ICMPv6 的每个版本维护一组单独的类型值。
- en: In ICMPv4, Type values were assigned sequentially to both error and informational
    messages on a first-come, first-served basis (sort of), so we cannot tell just
    by the Type value what type of message each is. One minor improvement made in
    ICMPv6 was that the message types were separated. In IPv6, error messages have
    Type values from 0 to 127, and informational messages have values from 128 to
    255\. Only some of the Type values are currently defined.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ICMPv4 中，类型值是按照先来先服务的原则（某种程度上）连续分配给错误和信息性消息的，所以我们不能仅通过类型值来判断每种消息的类型。ICMPv6
    中的一项微小改进是将消息类型分开。在 IPv6 中，错误消息的类型值为 0 到 127，信息性消息的类型值为 128 到 255。目前只定义了部分类型值。
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** A total of 256 different possible message types can be defined
    for each of ICMPv4 and ICMPv6\. The Type field that appears in the header of each
    message specifies the kind of ICMP message. In ICMPv4, there is no relationship
    between Type value and message type. In ICMPv6, error messages have a Type value
    of 0 to 127, and informational messages have a Type value of 128 to 255.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 对于 ICMPv4 和 ICMPv6，可以定义总共 256 种不同的可能消息类型。每个消息的头部中出现的类型字段指定了 ICMP 消息的类型。在
    ICMPv4 中，类型值与消息类型之间没有关系。在 ICMPv6 中，错误消息的类型值为 0 到 127，信息性消息的类型值为 128 到 255。'
- en: ICMP Message Codes
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMP 消息代码
- en: The message type indicates the general purpose of each kind of ICMP message.
    ICMP also provides an additional level of detail within each message type in the
    form of a Code field, which is also 8 bits. You can consider this field as a message
    subtype. Thus, each message type can have up to 256 subtypes that are more detailed
    subdivisions of the message's overall functionality. A good example is the Destination
    Unreachable message, which is generated when a datagram cannot be delivered. In
    this message type, the Code value provides more information on exactly why the
    delivery was not possible.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 消息类型指示每种 ICMP 消息的一般用途。ICMP 还在每个消息类型内部提供了一种额外的详细级别，形式为一个代码字段，该字段也是 8 位。您可以将此字段视为消息子类型。因此，每种消息类型可以有最多
    256 个子类型，这些子类型是消息整体功能的更详细细分。一个很好的例子是目标不可达消息，当数据报无法投递时会产生此消息。在此消息类型中，代码值提供了关于为什么投递不可能的具体信息。
- en: ICMP Message Class and Type Summary
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMP 消息类别和类型摘要
- en: The next four chapters of the book describe all of the major ICMP message types
    for both ICMPv4 and ICMPv6\. For convenience, I have summarized all these message
    types in [Table 31-2](ch31s03.html#icmp_message_classes_types_and_cod-id001 "Table 31-2. ICMP
    Message Classes, Types, and Codes"), which shows each of the Type values for the
    messages covered in this book, the name of each message, a very brief summary
    of its purpose, and the RFC that defines it. (To keep the table from being egregiously
    large, I have not shown each of the Code values for each Type value; these can
    be found in the individual message type descriptions.) The table is organized
    into sections that correspond to the four chapters that describe ICMP message
    types, except this table is sorted by ascending Type value within each category
    for easier reference.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 书的下一章描述了ICMPv4和ICMPv6的所有主要ICMP消息类型。为了方便，我已经将这些消息类型总结在[表31-2](ch31s03.html#icmp_message_classes_types_and_cod-id001
    "表31-2. ICMP消息类别、类型和代码")中，该表显示了本书涵盖的每个消息的类型值、每个消息的名称、其目的的非常简短的摘要以及定义它的RFC。为了使表格不至于过大，我没有显示每个类型值的每个代码值；这些可以在单独的消息类型描述中找到。该表按与描述ICMP消息类型的四个章节相对应的节组织，但此表在每个类别内按类型值升序排序，以便于参考。
- en: Table 31-2. ICMP Message Classes, Types, and Codes
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表31-2. ICMP消息类别、类型和代码
- en: '| Message Class | Type Value | Message Name | Summary Description of Message
    Type | Defining RFC Number |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 消息类别 | 类型值 | 消息名称 | 消息类型摘要描述 | 定义RFC编号 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '|   | 3 | Destination Unreachable | Indicates that a datagram could not be
    delivered to its destination. The Code value provides more information on the
    nature of the error. | 792 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|   | 3 | 目标不可达 | 表示数据报无法送达其目标。代码值提供了关于错误性质更多信息的详细信息。 | 792 |'
- en: '| ICMPv4 Error Messages | 4 | Source Quench | Lets a congested IP device tell
    a device that is sending it datagrams to slow down the rate at which it is sending
    them. | 792 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| ICMPv4 错误消息 | 4 | 源抑制 | 允许拥塞的IP设备告诉发送数据报的设备减慢发送数据报的速度。 | 792 |'
- en: '|   | 5 | Redirect | Allows a router to inform a host of a better route to
    use for sending datagrams. | 792 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|   | 5 | 重定向 | 允许路由器通知主机使用更好的路由发送数据报。 | 792 |'
- en: '|   | 11 | Time Exceeded | Sent when a datagram has been discarded prior to
    delivery due to expiration of its Time to Live field. | 792 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|   | 11 | 时间超限 | 发送时，由于生存时间字段已过期，数据报在交付前被丢弃。 | 792 |'
- en: '|   | 12 | Parameter Problem | Indicates a miscellaneous problem (specified
    by the Code value) in delivering a datagram. | 792 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|   | 12 | 参数问题 | 表示在交付数据报时出现的一些问题（由代码值指定）。 | 792 |'
- en: '|   | 0 | Echo Reply | Sent in reply to an Echo (Request) message; used for
    testing connectivity. | 792 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|   | 0 | 回声响应 | 作为对回声（请求）消息的回复发送；用于测试连通性。 | 792 |'
- en: '|   | 8 | Echo (Request) | Sent by a device to test connectivity to another
    device on the internetwork. The word *Request* sometimes appears in the message
    name. | 792 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|   | 8 | 回声（请求） | 由设备发送，以测试与互联网上另一设备的连通性。消息名称中有时会出现“请求”一词。 | 792 |'
- en: '|   | 9 | Router Advertisement | Used by routers to tell hosts of their existence
    and capabilities. | 1256 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|   | 9 | 路由器通告 | 由路由器用于告知主机其存在和能力。 | 1256 |'
- en: '| ICMPv4 Informational Messages (part 1 of 2) | 10 | Router Solicitation |
    Used by hosts to prompt any listening routers to send a Router Advertisement.
    | 1256 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| ICMPv4 信息消息（第1部分，共2部分） | 10 | 路由器请求 | 由主机使用，以提示任何监听路由器发送路由器通告。 | 1256 |'
- en: '|   | 13 | Timestamp (Request) | Sent by a device to request that another send
    it a timestamp value for propagation time calculation and clock synchronization.
    The word *Request* sometimes appears in the message name. | 792 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|   | 13 | 时间戳（请求） | 由设备发送，请求另一设备发送时间戳值以进行传播时间计算和时钟同步。消息名称中有时会出现“请求”一词。 | 792
    |'
- en: '|   | 14 | Timestamp Reply | Sent in response to a Timestamp (Request) to provide
    time calculation and clock synchronization information. | 792 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|   | 14 | 时间戳响应 | 作为对时间戳（请求）的响应发送，以提供时间计算和时钟同步信息。 | 792 |'
- en: '|   | 15 | Information Request | Originally used to request configuration information
    from another device. Now obsolete. | 792 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|   | 15 | 信息请求 | 最初用于从其他设备请求配置信息。现在已过时。 | 792 |'
- en: '|   | 16 | Information Reply | Originally used to provide configuration information
    in response to an Information Request message. Now obsolete. | 792 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|   | 16 | 信息响应 | 最初用于在信息请求消息的响应中提供配置信息。现在已过时。 | 792 |'
- en: '| ICMPv4 Informational Messages (part 2 of 2) | 17 | Address Mask Request |
    Used to request that a device send a subnet mask. | 950 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| ICMPv4 信息性消息（第2部分，共2部分） | 17 | 地址掩码请求 | 用于请求设备发送子网掩码。 | 950 |'
- en: '|   | 18 | Address Mask Reply | Contains a subnet mask sent in reply to an
    Address Mask Request. | 950 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|   | 18 | 地址掩码回复 | 包含在回复地址掩码请求时发送的子网掩码。 | 950 |'
- en: '|   | 30 | Traceroute | Used to implement the experimental enhanced traceroute
    utility. | 1393 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|   | 30 | 跟踪路由 | 用于实现实验性的增强型跟踪路由实用程序。 | 1393 |'
- en: '|   | 1 | Destination Unreachable | Indicates that a datagram could not be
    delivered to its destination. *Code* value provides more information on the nature
    of the error. | 2463 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|   | 1 | 目的地不可达 | 表示数据报无法递送到其目的地。*代码*值提供有关错误性质的更多信息。 | 2463 |'
- en: '| ICMPv6 Error Messages | 2 | Packet Too Big | Sent when a datagram cannot
    be forwarded because it is too big for the maximum transmission unit (MTU) of
    the next hop in the route. This message is needed in IPv6 and not IPv4 because
    in IPv4, routers can fragment oversized messages, but in IPv6 they cannot. | 2463
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| ICMPv6 错误消息 | 2 | 数据包过大 | 当数据报因为对于路由中下一跳的最大传输单元（MTU）来说太大而无法转发时发送。此消息在IPv6中是必需的，而在IPv4中不是，因为在IPv4中，路由器可以分片过大的消息，但在IPv6中它们不能。
    | 2463 |'
- en: '|   | 3 | Time Exceeded | Sent when a datagram has been discarded prior to
    delivery due to the Hop Limit field being reduced to zero. | 2463 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|   | 3 | 时间超出 | 当数据报在交付前被丢弃，因为跳数限制字段减少到零时发送。 | 2463 |'
- en: '|   | 4 | Parameter Problem | Indicates a miscellaneous problem (specified
    by the *Code* value) in delivering a datagram. | 2463 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|   | 4 | 参数问题 | 表示在递送数据报时出现了一些问题（由*代码*值指定）。 | 2463 |'
- en: '|   | 128 | Echo Request | Sent by a device to test connectivity to another
    device on the internetwork. | 2463 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|   | 128 | 回显请求 | 由设备发送以测试与互联网上另一设备的连通性。 | 2463 |'
- en: '|   | 129 | Echo Reply | Sent in reply to an Echo (Request) message; used for
    testing connectivity. | 2463 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|   | 129 | 回显应答 | 作为对回显（请求）消息的回复发送；用于测试连通性。 | 2463 |'
- en: '|   | 133 | Router Solicitation | Prompts a router to send a Router Advertisement.
    | 2461 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|   | 133 | 路由器请求 | 促使路由器发送路由器通告。 | 2461 |'
- en: '| ICMPv6 Informational Messages | 134 | Router Advertisement | Sent by routers
    to tell hosts on the local network that the router exists. It also describes its
    capabilities. | 2461 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| ICMPv6 信息性消息 | 134 | 路由器通告 | 由路由器发送，告知本地网络上的主机路由器存在。它还描述了其功能。 | 2461 |'
- en: '|   | 135 | Neighbor Solicitation | Sent by a device to request the layer 2
    address of another device while providing its own as well. | 2461 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|   | 135 | 邻居请求 | 由设备发送以请求另一设备的第2层地址，同时提供自己的地址。 | 2461 |'
- en: '|   | 136 | Neighbor Advertisement | Provides information about a host to other
    devices on the network. | 2461 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|   | 136 | 邻居通告 | 向网络上的其他设备提供有关主机的信息。 | 2461 |'
- en: '|   | 137 | Redirect | Redirects transmissions from a host to either an immediate
    neighbor on the network or a router. | 2461 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|   | 137 | 重定向 | 将传输从主机重定向到网络上的直接邻居或路由器。 | 2461 |'
- en: '|   | 138 | Router Renumbering | Conveys renumbering information for router
    renumbering. | 2894 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|   | 138 | 路由器重新编号 | 传达路由器重新编号的信息。 | 2894 |'
- en: You can see that several of the message types are quite similar in ICMPv4 and
    ICMPv6, but there are some slight differences. An obvious one is that Redirect
    is considered an error message in ICMPv4, but it's an informational message in
    ICMPv6\. Messages are often used differently as well. In IPv6, the use of many
    of the ICMP informational messages is described in the Neighbor Discovery (ND)
    protocol, which is new to IPv6 (see [Chapter 36](ch36.html "Chapter 36. IPV6 NEIGHBOR
    DISCOVERY (ND) PROTOCOL")).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在ICMPv4和ICMPv6中，许多消息类型相当相似，但也有一些细微的差异。一个明显的差异是，在ICMPv4中，重定向被视为错误消息，但在ICMPv6中它是信息性消息。消息的使用方式也经常不同。在IPv6中，许多ICMP信息性消息的使用在邻居发现（ND）协议中有描述，这是IPv6中新的（见[第36章](ch36.html
    "第36章。IPv6 邻居发现（ND）协议")）。
- en: Note that the Information Request and Information Reply messages were originally
    created to allow devices to determine an IP address and possibly other configuration
    information. This function was later implemented using host configuration protocols
    such as the Reverse Address Resolution Protocol (RARP; see [Chapter 14](ch14.html
    "Chapter 14. REVERSE ADDRESS RESOLUTION AND THE TCP/IP REVERSE ADDRESS RESOLUTION
    PROTOCOL (RARP)")), Boot Protocol (BOOTP; see [Chapter 60](ch60.html "Chapter 60. TCP/IP
    BOOTSTRAP PROTOCOL (BOOTP)")), and Dynamic Host Configuration Protocol (DHCP,
    discussed in Chapters [Chapter 61](ch61.html "Chapter 61. DHCP OVERVIEW AND ADDRESS
    ALLOCATION CONCEPTS") through [Chapter 64](ch64.html "Chapter 64. DHCP CLIENT/SERVER
    IMPLEMENTATION, FEATURES, AND IPV6 SUPPORT")). These message types are now obsolete.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，信息请求和信息回复消息最初是为了允许设备确定IP地址以及可能的其他配置信息而创建的。这个功能后来通过主机配置协议如反向地址解析协议（RARP；参见[第14章](ch14.html
    "第14章。反向地址解析和TCP/IP反向地址解析协议（RARP)"))、引导协议（BOOTP；参见[第60章](ch60.html "第60章。TCP/IP引导协议（BOOTP)"))和动态主机配置协议（DHCP，在第[第61章](ch61.html
    "第61章。DHCP概述和地址分配概念")至[第64章](ch64.html "第64章。DHCP客户端/服务器实现、功能和IPv6支持")中讨论）来实现。这些消息类型现在已过时。
- en: ICMP Message Creation and Processing Conventions and Rules
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMP消息创建和处理约定和规则
- en: In the overview of ICMP earlier in this chapter, I compared the relationship
    between IP and ICMP to that between an executive and an administrative assistant.
    One of the characteristics that many executives value in a good assistant is that
    the assistant does his work independently, without causing unnecessary disruption.
    A good assistant should save the executive time, not cost her time.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面关于ICMP的概述中，我把IP和ICMP之间的关系比作行政主管和行政助理之间的关系。许多主管在优秀的助理身上看重的特点之一是助理能够独立工作，不会造成不必要的干扰。一个好的助理应该节省主管的时间，而不是浪费她的时间。
- en: As the assistant to IP, ICMP must similarly help IP function without taking
    up too much of its resources. Here, the resource being conserved is not so much
    time as bandwidth. ICMP messages are important, but must be considered part of
    the overhead of running a network. They carry no user data, so each one represents
    a small loss of overall end-user bandwidth on the network. For this reason, we
    want to send them only when necessary, and to carefully control the circumstances
    under which they are generated.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为IP的助手，ICMP必须同样帮助IP正常工作，同时不占用太多资源。在这里，所节约的资源不是时间，而是带宽。ICMP消息很重要，但必须被视为运行网络的开销的一部分。它们不携带用户数据，因此每一条都代表着网络中整体最终用户带宽的小损失。因此，我们只想在必要时发送它们，并且要仔细控制它们生成的条件。
- en: 'Administrative assistants have some serious advantages over networking protocols:
    common sense and experience. They usually know where the line is drawn between
    help and hindrance; computers don''t. To partially compensate, ICMP''s operation
    is guided by a set of *conventions* or *rules* for how messages are created and
    processed. For ICMPv4, these conventions are described in part in the defining
    RFC 792, but much more in RFC 1122, "Requirements for Internet Hosts—Communication
    Layers," which provides specific information on implementing TCP/IP in host devices.
    In ICMPv6, the information related to ICMP implementation that appears in RFC
    1122 has been largely incorporated into the main document that defines ICMPv6,
    RFC 2463.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 行政助理相对于网络协议有一些明显的优势：常识和经验。他们通常知道帮助和阻碍之间的界限在哪里；计算机则不知道。为了部分弥补这一点，ICMP的操作由一套关于如何创建和处理消息的*约定*或*规则*来指导。对于ICMPv4，这些约定部分地描述在定义RFC
    792中，但在RFC 1122，“对互联网主机的要求——通信层”中描述得更多，该文档提供了在主机设备中实现TCP/IP的具体信息。在ICMPv6中，RFC
    1122中出现的与ICMP实现相关的信息已被大量纳入定义ICMPv6的主要文档RFC 2463中。
- en: Most of the issues related to message generation have to do with error messages,
    not informational messages. The latter class of messages usually doesn't cause
    problems because they are generated based on specific rules already established
    in the protocols that use them. For example, routers send Router Advertisement
    messages on a regular basis, and the routers make sure this is infrequent. They
    are also sent in response to Router Solicitation messages sent on occasion by
    hosts, and as long as a host doesn't go haywire and start sending tons of Solicitations,
    there won't be a problem. Even then, you can give a router enough smarts not to
    send Router Advertisements too often.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与消息生成相关的大部分问题都与错误消息有关，而不是信息消息。后一类消息通常不会引起问题，因为它们是根据使用它们的协议中已经建立的特定规则生成的。例如，路由器定期发送路由器通告消息，并且确保这是不频繁的。它们也是响应主机偶尔发送的路由器请求消息而发送的，只要主机不出现混乱并开始发送大量的请求，就不会有问题。即使在这种情况下，你也可以给路由器足够的智能，使其不会太频繁地发送路由器通告。
- en: Limitations on ICMP Message Responses
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMP 消息响应的限制
- en: The problem comes up with error messages specifically because they are sent
    *in response* to so many situations. Potentially, they may even be sent in response
    to each other. Without special care, loops or cascading message generation might
    occur. For example, consider a situation in which Device A encounters an error
    and sends an error report to Device B. Device B finds an error in Device A's message
    and sends an error report back to Device A. This could result in billions of messages
    being sent back and forth, thereby clogging the network, until a human figures
    out what is wrong and fixes it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出现在错误消息上，特别是因为它们是针对许多情况发送的。潜在地，它们甚至可能相互响应。如果没有特别的注意，可能会发生循环或消息生成级联。例如，考虑这样一种情况：设备
    A 遇到错误并向设备 B 发送错误报告。设备 B 发现设备 A 的消息中存在错误，并向设备 A 发送错误报告。这可能导致数十亿条消息在设备之间来回发送，从而阻塞网络，直到有人发现出了什么问题并修复它。
- en: 'To prevent such problems, an ICMP error message *must not* be generated in
    response to any of the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止出现此类问题，在以下任何情况下都不应生成 ICMP 错误消息 *必须不*：
- en: '**An ICMP Error Message** This prevents loops of the type just mentioned. Note,
    however, that an ICMP error message *can* be generated in response to an ICMP
    informational message.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个 ICMP 错误消息** 这防止了前面提到的循环。然而，请注意，ICMP 错误消息 *可以* 在响应 ICMP 信息消息时生成。'
- en: '**A Broadcast or Multicast Datagram** What would happen if a datagram were
    broadcast to 5,000 hosts, and each of them found an error in it and tried to send
    a report back to the source? Something unpleasant!'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个广播或多播数据报** 如果一个数据报被广播到 5,000 个主机，并且每个主机都发现其中的错误并尝试向源发送报告，会发生什么？结果可能很糟糕！'
- en: '**IP Datagram Fragments Except the First** In many cases, the same situation
    that might cause a device to generate an error for one fragment would also apply
    to each successive one, causing unnecessary ICMP traffic. For this reason, when
    a datagram is fragmented, a device may send an error message only in response
    to a problem in the first fragment.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**除了第一个数据报片段之外** 在许多情况下，可能导致设备对某个片段生成错误的情况也会影响到后续的每个片段，从而造成不必要的 ICMP 流量。因此，当一个数据报被分片时，设备可能只在第一个片段出现问题时发送错误消息。'
- en: '**Datagrams with Non-Unicast Source Address** If a datagram''s source address
    doesn''t define a unique, unicast device address, an error message cannot be sent
    back to that source. This prevents ICMP messages from being broadcast, unicast,
    or sent to nonroutable special addresses such as the loopback address.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**非单播源地址的数据报** 如果一个数据报的源地址没有定义一个唯一的单播设备地址，则无法向该源发送错误消息。这防止了 ICMP 消息被广播、单播或发送到非路由的特殊地址，例如回环地址。'
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** In order to prevent excessive numbers of ICMP messages from
    being sent on a network, a special set of rules governs when and how they may
    be created. Most of these are designed to eliminate situations in which very large
    numbers of ICMP error messages would be generated in response to certain occurrences.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 为了防止网络上发送过多的 ICMP 消息，有一套特殊的规则来规定何时以及如何创建它们。其中大部分都是为了消除在特定事件发生时会产生大量
    ICMP 错误消息的情况。'
- en: These rules apply to both ICMPv4 and ICMPv6, but in ICMPv6 there are a couple
    of special cases. In certain circumstances, an ICMPv6 Packet Too Big message may
    be sent to a multicast address, as this is required for Path MTU Discovery (described
    in [Chapter 27](ch27.html "Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY,
    AND ROUTING")) to work. Certain Parameter Problem messages may also be sent to
    multicast or broadcast addresses. Finally, in addition to the rules just mentioned,
    IPv6 implementations are specifically directed to limit the rate at which they
    send ICMPv6 messages overall.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则适用于ICMPv4和ICMPv6，但在ICMPv6中存在一些特殊情况。在特定情况下，ICMPv6数据包太大消息可能被发送到多播地址，因为这是路径MTU发现（在第27章中描述）正常工作所必需的。[第27章](ch27.html
    "第27章. IPV6 数据报大小、分片、重组和路由")。某些参数问题消息也可能被发送到多播或广播地址。最后，除了上述规则外，IPv6实现还特别指示要限制发送ICMPv6消息的整体速率。
- en: ICMP Message Processing Conventions
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMP消息处理约定
- en: Message processing generally takes place as described earlier in the section
    on ICMP general operation, with the ICMP message delivered either to the IP software
    or other protocol software implementation as required. What is done with the message
    usually depends on its type. Some messages are destined for only the IP software
    itself, but many are intended for the higher-layer protocol that generated the
    datagram that led to the error. In the next section, you will see that ICMP error
    messages include information that allows the upper-layer protocol to be extracted
    for the purpose of passing the message to the appropriate software layer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 消息处理通常按照在ICMP一般操作部分中较早描述的方式进行，ICMP消息根据需要交付给IP软件或其他协议软件实现。对消息的处理通常取决于其类型。一些消息仅针对IP软件本身，但许多消息旨在针对生成导致错误的分组的上层协议。在下一节中，您将看到ICMP错误消息包含允许上层协议被提取的信息，以便将消息传递到适当的软件层。
- en: In IPv6, the class of message (error or informational) can be determined from
    the Type value. This knowledge can then be used to guide processing of ICMP messages
    with unknown Type values. The rule is that ICMP error messages with unknown Type
    values must be passed to the appropriate upper-layer protocol. Informational messages
    with unknown Type values are discarded without taking action.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv6中，可以通过类型值确定消息类别（错误或信息）。然后可以使用此知识来指导处理具有未知类型值的ICMP消息。规则是，具有未知类型值的ICMP错误消息必须传递给适当的上层协议。具有未知类型值的信息消息将被丢弃，而不采取任何行动。
- en: In addition to these general rules, there are specific rules put into place
    to guide the processing of some of the message types. I describe some of these
    conventions in the chapters that discuss individual ICMP messages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些一般规则外，还制定了特定规则来指导处理某些消息类型。我在讨论单个ICMP消息的章节中描述了这些约定。
- en: An important final point is that ICMP messages, especially error messages, are
    not considered binding on the device that processes them. To stick with the office
    analogy, they have the equivalent status in an office of only of an FYI memo,
    not an assignment. It is often the case that a device *should* take action upon
    processing an ICMP message, but the device is not required to. The exception,
    again, is when informational messages are used for specific purposes. For example,
    most of the messages that come in pairs are designed so that a Request results
    in the matching Reply and a Solicitation yields an Advertisement.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的最终观点是，ICMP消息，尤其是错误消息，并不被认为对处理它们的设备具有约束力。继续使用办公室类比，它们在办公室中的地位相当于仅相当于一个信息备忘录，而不是一项任务。通常情况下，设备在处理ICMP消息后*应该*采取行动，但设备并不需要这样做。例外情况再次是当信息消息用于特定目的时。例如，大多数成对出现的消息都是设计成请求导致匹配的回复，而请求则产生广告。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** A device receiving an ICMP message is not required to take
    action unless a protocol using a message type dictates a specific response to
    a particular message type. In particular, devices are not mandated to perform
    any specific task when receiving an ICMP error message.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 接收ICMP消息的设备不需要采取行动，除非使用消息类型的协议指定了对特定消息类型的特定响应。特别是，当接收ICMP错误消息时，设备不需要执行任何特定任务。'
- en: ICMP Common Message Format and Data Encapsulation
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMP通用消息格式和数据封装
- en: As you have seen so far in this chapter, ICMP is not so much a protocol that
    performs a specific function as a framework for the exchange of error reports
    and information. Since each of the message types is used for a different purpose,
    they differ in the types of information they contain. This means each ICMP message
    has a slightly different format. At the same time, however, ICMP message types
    also have a degree of commonality—a portion of each message is common between
    message types.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章中迄今为止所看到的，ICMP与其说是一个执行特定功能的协议，不如说是一个交换错误报告和信息的基础框架。由于每种消息类型都用于不同的目的，它们包含的信息类型不同。这意味着每个ICMP消息都有略微不同的格式。然而，同时，ICMP消息类型也有一定程度的共性——每种消息类型之间有部分内容是共同的。
- en: ICMP Common Message Format
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMP通用消息格式
- en: You can think of the structure of an ICMP message as having a *common part*
    and a *unique part*. The common part consists of three fields that have the same
    size and same meaning in all ICMP messages (although the values in the fields
    aren't the same for each ICMP message type). The unique part contains fields that
    are specific to each type of message.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将ICMP消息的结构想象成一个*通用部分*和一个*独特部分*。通用部分由三个字段组成，这些字段在所有ICMP消息中具有相同的大小和相同的含义（尽管每个ICMP消息类型字段中的值并不相同）。独特部分包含特定于每种消息类型的字段。
- en: Interestingly, the common message format is basically the same for ICMPv4 and
    ICMPv6\. It is described in [Table 31-3](ch31s05.html#icmp_common_message_format-id001
    "Table 31-3. ICMP Common Message Format") and illustrated in [Figure 31-2](ch31s05.html#icmp_common_message_format_this_overall_
    "Figure 31-2. ICMP common message format This overall, generic message format
    is used for both ICMPv4 and ICMPv6 message types.").
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，通用消息格式对于ICMPv4和ICMPv6基本上是相同的。它在[表31-3](ch31s05.html#icmp_common_message_format-id001
    "表31-3. ICMP通用消息格式")中描述，并在[图31-2](ch31s05.html#icmp_common_message_format_this_overall_
    "图31-2. ICMP通用消息格式 这个通用的整体消息格式用于ICMPv4和ICMPv6消息类型")中展示。
- en: Table 31-3. ICMP Common Message Format
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表31-3. ICMP通用消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMP message type. For ICMPv6, values from 0 to
    127 are error messages, and values 128 to 255 are informational messages. Common
    values for this field are given in [Table 31-2](ch31s03.html#icmp_message_classes_types_and_cod-id001
    "Table 31-2. ICMP Message Classes, Types, and Codes"). |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMP消息类型。对于ICMPv6，0到127的值是错误消息，128到255的值是信息消息。该字段的常见值在[表31-2](ch31s03.html#icmp_message_classes_types_and_cod-id001
    "表31-2. ICMP消息类别、类型和代码")中给出。|'
- en: '| Code | 1 | Identifies the subtype of message within each ICMP message Type
    value. Thus, up to 256 subtypes can be defined for each message type. Values for
    this field are shown in the following chapters on individual ICMP message types.
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 识别每个ICMP消息类型值内的消息子类型。因此，可以为每种消息类型定义多达256个子类型。该字段的值将在以下章节中关于单个ICMP消息类型的章节中展示。|'
- en: '| Checksum | 2 | A 16-bit checksum field that is calculated in a manner similar
    to the IP header checksum in IPv4\. It provides error-detection coverage for the
    entire ICMP message. Note that in ICMPv6, a pseudo header of IPv6 header fields
    is prepended for checksum calculation; this is similar to the way this is done
    in TCP. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | 一个16位的校验和字段，其计算方式类似于IPv4中的IP头校验和。它为整个ICMP消息提供错误检测覆盖。注意，在ICMPv6中，为校验和计算预先附加了IPv6头字段的一个伪头；这与在TCP中执行的方式相似。|'
- en: '| Message Body/Data | Variable | Contains the specific fields used to implement
    each message type. This is the unique part of the message. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 消息体/数据 | 可变 | 包含用于实现每种消息类型的特定字段。这是消息的独特部分。|'
- en: '![ICMP common message format This overall, generic message format is used for
    both ICMPv4 and ICMPv6 message types.](httpatomoreillycomsourcenostarchimages287961.png.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![ICMP通用消息格式 这个通用的整体消息格式用于ICMPv4和ICMPv6消息类型。](httpatomoreillycomsourcenostarchimages287961.png.jpg)'
- en: Figure 31-2. ICMP common message format This overall, generic message format
    is used for both ICMPv4 and ICMPv6 message types.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图31-2. ICMP通用消息格式 这个通用的整体消息格式用于ICMPv4和ICMPv6消息类型。
- en: Original Datagram Inclusion in ICMP Error Messages
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ICMP错误消息中包含原始数据报
- en: The message body typically contains one or several fields that carry information
    of relevance to each specific type of ICMP message. All ICMP error messages include
    a portion of the original IP datagram that led to the ICMP error message. This
    aids in diagnosing the problem that caused the ICMP message to be generated, by
    allowing the error to be communicated to higher layers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 消息体通常包含一个或多个字段，这些字段携带与每种特定类型 ICMP 消息相关的信息。所有 ICMP 错误消息都包括导致生成 ICMP 错误消息的原始 IP
    数据报的一部分。这有助于通过允许将错误传达给高层来诊断导致生成 ICMP 消息的问题。
- en: 'The inclusion of original IP datagram information is done differently for the
    two ICMP versions:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两种 ICMP 版本，包含原始 IP 数据报信息的方式不同：
- en: '**ICMPv4 Error Messages** Each error message includes the full IP header and
    the first 8 bytes of the payload. Since the beginning of the payload will contain
    the encapsulated higher-layer header, the ICMP message also carries either the
    full UDP header or the first 8 bytes of the TCP header. In both cases, the source
    and destination port numbers are part of what is included. If the original header
    was a standard IP header with no options, the Message Body will therefore have
    a length of 28 bytes; if options are present, it will be larger.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**ICMPv4 错误消息** 每个错误消息都包括完整的 IP 报头和有效负载的前 8 个字节。由于有效负载的开始将包含封装的更高层报头，因此 ICMP
    消息还携带完整的 UDP 报头或 TCP 报头的前 8 个字节。在两种情况下，源端口和目的端口号码都是包含的部分。如果原始报头是一个没有选项的标准 IP 报头，则消息体长度为
    28 字节；如果有选项，则长度更大。'
- en: '**ICMPv6 Error Messages** Each error message includes as much of the IPv6 datagram
    as will fit without causing the size of the ICMPv6 error message (including its
    IP header encapsulation) to exceed the minimum IPv6 maximum transmission unit
    size, which is 1280 bytes. This provides additional information for diagnostic
    purposes when compared to ICMPv4, while ensuring that no ICMPv6 error messages
    will be too large for any physical network segment. The larger size of the included
    data allows the IPv6 extension headers to be included in the error message, since
    the error could be in one of those extension headers.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**ICMPv6 错误消息** 每个错误消息都包括尽可能多的 IPv6 数据报，而不会导致 ICMPv6 错误消息（包括其 IP 报头封装）的大小超过最小
    IPv6 最大传输单元大小，即 1280 字节。与 ICMPv4 相比，这为诊断提供了额外的信息，同时确保没有 ICMPv6 错误消息会太大，以至于无法在任何物理网络段中传输。包含数据的较大大小允许在错误消息中包含
    IPv6 扩展报头，因为错误可能出现在这些扩展报头之一中。'
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Remember that in IPv6, routers cannot fragment IP datagrams; any datagram
    that is oversized for an underlying physical network is dropped. ICMPv6 is thus
    designed to ensure that this does not happen by not creating ICMPv6 datagrams
    over the universal IPv6 MTU size of 1280*.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*记住，在 IPv6 中，路由器不能分片 IP 数据报；任何超出底层物理网络大小的数据报都会被丢弃。因此，ICMPv6 被设计成通过不创建超过通用 IPv6
    MTU 大小（1280 字节）的 ICMPv6 数据报来确保这一点*。'
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Each kind of ICMP message contains data unique to that message
    type, but all messages are structured according to a common ICMP message format.
    ICMP error messages always include in their message body field some portion of
    the original IP datagram that resulted in the error being generated.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 每种 ICMP 消息都包含该消息类型独有的数据，但所有消息都根据通用的 ICMP 消息格式进行结构化。ICMP 错误消息在其消息体字段中始终包含导致生成错误的部分原始
    IP 数据报。'
- en: ICMP Data Encapsulation
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMP 数据封装
- en: After an ICMP message is formatted, it is encapsulated in an IP datagram like
    any other IP message. This is why some people believe ICMP is architecturally
    a higher layer than IP, though as I discussed earlier, it is really more of a
    special case. You can also see that when an ICMP error message is generated, we
    end up with the original IP header and part or all of the payload, encapsulated
    in the ICMP message, which in turn is encapsulated within a new IP header that
    will be sent back as an error report, usually to the device that sent the original
    IP message.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 ICMP 消息格式化后，它就像任何其他 IP 消息一样封装在 IP 数据报中。这就是为什么有些人认为 ICMP 在架构上比 IP 层次更高，尽管如我之前讨论的，它实际上更像是一个特殊情况。你还可以看到，当生成
    ICMP 错误消息时，我们最终会得到原始 IP 报头和部分或全部的有效负载，这些都被封装在 ICMP 消息中，而该消息反过来又封装在一个新的 IP 报头中，该报头将作为错误报告发送回去，通常发送给发送原始
    IP 消息的设备。
- en: Chapter 32. ICMPV4 ERROR MESSAGE TYPES AND FORMATS
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 32 章. ICMPV4 错误消息类型和格式
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: Routers and hosts use Internet Control Message Protocol (ICMP) error messages
    to tell a device that sent a datagram about problems that were encountered during
    delivery. The original ICMP version 4 (ICMPv4) defined five different error messages,
    which are all described in the original ICMP standard, RFC 792\. These are some
    of the most important ICMP messages. They provide critical feedback about error
    conditions and may help a transmitting device take corrective action to ensure
    reliable and efficient datagram delivery.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器和主机使用互联网控制消息协议（ICMP）错误消息来告知发送数据报的设备在投递过程中遇到的问题。原始的ICMP版本4（ICMPv4）定义了五种不同的错误消息，这些消息都在原始ICMP标准RFC
    792中进行了描述。这些是最重要的ICMP消息之一。它们提供了关于错误条件的关键反馈，并可能帮助发送设备采取纠正措施，以确保可靠和高效的数据报投递。
- en: In this first of four chapters on specific ICMP types, I look at the ICMPv4
    error messages. I begin with Destination Unreachable messages, which are sent
    due to datagram delivery failures, and Source Quench messages, which are used
    to tell a device to slow down the rate at which it sends datagrams. Next, I describe
    Time Exceeded messages, which are sent when a datagram has been traveling the
    network too long or takes too long to be reassembled from fragments, and Redirect
    messages, which let a router provide feedback about better routes to a host. Finally,
    I discuss Parameter Problem messages, which are generic messages used for problems
    not covered by other ICMP error messages.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这四章关于特定ICMP类型的章节中，我首先探讨ICMPv4错误消息。我从目的地不可达消息开始，这些消息是由于数据报投递失败而发送的，以及源端抑制消息，这些消息用于告诉设备减慢发送数据报的速度。接下来，我描述了超时消息，这些消息是在数据报在网络中传输时间过长或从片段重新组装所需时间过长时发送的，以及重定向消息，这些消息允许路由器向主机提供关于更好路由的反馈。最后，我讨论了参数问题消息，这些是用于其他ICMP错误消息未涵盖的问题的通用消息。
- en: ICMPv4 Destination Unreachable Messages
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv4 目的地不可达消息
- en: Since the Internet Protocol (IP) is an unreliable protocol, there are no guarantees
    that a datagram sent by one device to another will ever actually get there. The
    internetwork of hosts and routers will make a best effort to deliver the datagram,
    but it may not get where it needs to for any number of reasons. Devices on an
    IP network understand that and are designed accordingly. IP software never assumes
    its datagrams will always be received, and higher-layer protocols like the Transmission
    Control Protocol (TCP) take care of providing reliability and acknowledgments
    of received data for applications that need these features.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于互联网协议（IP）是一个不可靠的协议，因此无法保证一个设备发送给另一个设备的数据报最终会到达。主机和路由器的互联网将尽力投递数据报，但由于各种原因，它可能无法到达目的地。IP网络上的设备理解这一点，并且相应地设计。IP软件从不假设其数据报总是会收到，而像传输控制协议（TCP）这样的高层协议负责为需要这些功能的程序提供可靠性和接收数据的确认。
- en: This setup, with higher layers handling failed deliveries, is sufficient in
    some cases. For example, suppose Device A tries to send to Device B, but a router
    near Device B is overloaded, so it drops the datagram. In this case, the problem
    is likely intermittent, so Device A can retransmit and eventually reach Device
    B. But what about a situation where a device is trying to send to an IP address
    that doesn't exist, or a problem with routing that isn't easily corrected? Having
    the source just continually retry in this case would be inefficient, to say the
    least.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置，由高层处理失败投递，在某些情况下是足够的。例如，假设设备A试图向设备B发送数据，但设备B附近的路由器过载，因此它丢弃了数据报。在这种情况下，问题可能是间歇性的，因此设备A可以重传并最终到达设备B。但是，如果设备试图向一个不存在的IP地址发送数据，或者存在不易纠正的路由问题，该怎么办呢？在这种情况下，让源端不断重试至少是不高效的。
- en: IP is designed to allow IP datagram deliveries to fail, and we should take any
    such failures seriously. What we really need is a feedback mechanism that can
    tell a source device that something improper is happening and why. In IP version
    4 (IPv4), this service is provided through the transmission of *Destination Unreachable*
    ICMP messages. When a source node receives one of these messages, it knows there
    was a problem sending a datagram, and can then decide what action, if any, it
    wants to take. Like all ICMP error messages, Destination Unreachable messages
    include a portion of the datagram that could not be delivered, which helps the
    recipient of the error figure out what the problem is.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: IP协议设计为允许IP数据报投递失败，我们应该认真对待任何此类失败。我们真正需要的是一个反馈机制，能够告诉源设备发生了不适当的事情以及原因。在IP版本4（IPv4）中，这项服务是通过传输*目标不可达*ICMP消息来提供的。当一个源节点收到这些消息之一时，它知道发送数据报出现了问题，然后可以决定是否采取任何行动。像所有ICMP错误消息一样，目标不可达消息包含无法投递的数据报的一部分，这有助于错误接收者找出问题所在。
- en: ICMPv4 Destination Unreachable Message Format
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv4目标不可达消息格式
- en: '[Table 32-1](ch32.html#icmpv_destination_unreachable_message_fo "Table 32-1. ICMPv4
    Destination Unreachable Message Format") and [Figure 32-1](ch32.html#icmpv4_destination_unreachable_mes-id001
    "Figure 32-1. ICMPv4 Destination Unreachable message format") show the specific
    format for ICMPv4 Destination Unreachable messages.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[表32-1](ch32.html#icmpv_destination_unreachable_message_fo "表32-1. ICMPv4目标不可达消息格式")和[图32-1](ch32.html#icmpv4_destination_unreachable_mes-id001
    "图32-1. ICMPv4目标不可达消息格式"）显示了ICMPv4目标不可达消息的具体格式。'
- en: Table 32-1. ICMPv4 Destination Unreachable Message Format
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 表32-1. ICMPv4目标不可达消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMP message type; for Destination Unreachable
    messages, this is set to 3. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMP消息类型；对于目标不可达消息，此值设置为3。|'
- en: '| Code | 1 | Identifies the subtype of unreachable error being communicated.
    See [Table 34-2](ch34.html#icmpv_destination_unreachable_mess-id002 "Table 34-2. ICMPv6
    Destination Unreachable Message Subtypes") for a full list of codes and what they
    mean. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 识别正在通信的不可达错误子类型。见[表34-2](ch34.html#icmpv_destination_unreachable_mess-id002
    "表34-2. ICMPv6目标不可达消息子类型"）获取完整的代码列表及其含义。|'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP头部的16位校验和字段（见[第31章](ch31.html "第31章. ICMP概念和一般操作"））。|'
- en: '| Unused | 4 | The 4 bytes that are left blank and not used. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 未使用 | 4 | 剩余的4个字节留空，不使用。|'
- en: '| Original Datagram Portion | Variable | The full IP header and the first 8
    bytes of the payload of the datagram that prompted this error message to be sent.
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 原始数据报部分 | 可变 | 引起发送此错误消息的数据报的完整IP头部和前8个字节的负载。|'
- en: '![ICMPv4 Destination Unreachable message format](httpatomoreillycomsourcenostarchimages287963.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv4目标不可达消息格式](httpatomoreillycomsourcenostarchimages287963.png)'
- en: Figure 32-1. ICMPv4 Destination Unreachable message format
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图32-1. ICMPv4目标不可达消息格式
- en: ICMPv4 Destination Unreachable Message Subtypes
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv4目标不可达消息子类型
- en: There are many different reasons why it may not be possible for a datagram to
    reach its destination. Some of these may be due to erroneous parameters (like
    the invalid IP address example mentioned earlier). A router might have a problem
    reaching a particular network for whatever reason. There can also be other more
    esoteric reasons related to why a datagram cannot be delivered.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的原因可能导致数据报无法到达其目的地。其中一些可能是因为错误的参数（如前面提到的无效IP地址示例）。路由器可能因为任何原因无法到达特定的网络。也可能存在其他更奇特的原因，这些原因与数据报无法投递有关。
- en: For this reason, the ICMPv4 Destination Unreachable message type can be considered
    as a class of related error messages. The receipt of a Destination Unreachable
    message tells a device that the datagram it sent couldn't be delivered, and the
    Code field in the ICMP header indicates the reason for the nondelivery. [Table 32-2](ch32.html#icmpv_destination_unreachable_message_su
    "Table 32-2. ICMPv4 Destination Unreachable Message Subtypes") shows the different
    Code values, corresponding message subtypes, and a brief explanation of each.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，ICMPv4目标不可达消息类型可以被视为一类相关的错误消息。收到目标不可达消息告诉设备它发送的数据报无法交付，并且ICMP头部中的代码字段指示了非交付的原因。[表32-2](ch32.html#icmpv_destination_unreachable_message_su
    "表32-2。ICMPv4目标不可达消息子类型")显示了不同的代码值、相应的消息子类型以及每个的简要说明。
- en: Table 32-2. ICMPv4 Destination Unreachable Message Subtypes
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 表32-2. ICMPv4 目标不可达消息子类型
- en: '| Code Value | Message Subtype | Description |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 代码值 | 消息子类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | Network Unreachable | The datagram could not be delivered to the network
    specified in the network ID portion of the IP address. This usually means a problem
    with routing but could also be caused by a bad address. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 网络不可达 | 数据报无法发送到IP地址网络ID部分指定的网络。这通常意味着存在路由问题，但也可能是由于地址错误引起的。|'
- en: '| 1 | Host Unreachable | The datagram was delivered to the network specified
    in the network ID portion of the IP address but could not be sent to the specific
    host indicated in the address. Again, this usually implies a routing issue. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 主机不可达 | 数据报被发送到IP地址的网络ID部分指定的网络，但无法发送到地址中指定的特定主机。同样，这通常意味着存在路由问题。|'
- en: '| 2 | Protocol Unreachable | The protocol specified in the Protocol field was
    invalid for the host to which the datagram was delivered. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 协议不可达 | 传输数据报的主机中指定的协议在协议字段中无效。|'
- en: '| 3 | Port Unreachable | The destination port specified in the UDP or TCP header
    was invalid. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 端口不可达 | UDP或TCP头部指定的目标端口无效。|'
- en: '| 4 | Fragmentation Needed and DF Set | This is one of those esoteric codes.
    Normally, an IPv4 router will automatically fragment a datagram that it receives
    if it is too large for the maximum transmission unit (MTU) of the next physical
    network link the datagram needs to traverse. However, if the DF (Don''t Fragment)
    flag is set in the IP header, this means the sender of the datagram does not *want*
    the datagram ever to be fragmented. This puts the router between the proverbial
    rock and a hard place, and it will be forced to drop the datagram and send an
    error message with this code. This message type is most often used in a clever
    way by intentionally sending messages of increasing size to discover the MTU size
    that a link can handle. This process is called Path MTU Discovery (described in
    [Chapter 27](ch27.html "Chapter 27. IPV6 DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY,
    AND ROUTING")). |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 需要分片且设置了DF标志 | 这是那些晦涩难懂的代码之一。通常，如果IPv4路由器接收到的数据报太大，无法适应下一个物理网络链路的最大传输单元（MTU），则会自动分片数据报。然而，如果IP头部中的DF（不要分片）标志被设置，这意味着数据报的发送者不希望数据报被分片。这使路由器处于两难境地，它将被迫丢弃数据报并使用此代码发送错误消息。这种消息类型通常被巧妙地用于故意发送越来越大尺寸的消息，以发现链路可以处理的最大传输单元（MTU）大小。这个过程被称为路径MTU发现（在第27章中描述，[第27章](ch27.html
    "第27章。IPV6数据报大小、分片、重组和路由")）。|'
- en: '| 5 | Source Route Failed | Generated if a source route was specified for the
    datagram in an option but a router could not forward the datagram to the next
    step in the route. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 源路由失败 | 如果在数据报的选项中指定了源路由，但路由器无法将数据报转发到路由中的下一个步骤，则会生成此错误。|'
- en: '| 6 | Destination Network Unknown | Not used; code 0 is used instead. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 目标网络未知 | 未使用；使用代码0代替。|'
- en: '| 7 | Destination Host Unknown | The host specified is not known. This is usually
    generated by a router local to the destination host and usually means a bad address.
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 目标主机未知 | 指定的主机未知。这通常由目标主机本地的路由器生成，通常意味着地址错误。|'
- en: '| 8 | Source Host Isolated | Obsolete, no longer used. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 源主机隔离 | 已过时，不再使用。|'
- en: '| 9 | Communication with Destination Network Is Administratively Prohibited
    | The source device is not allowed to send to the network where the destination
    device is located. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 与目标网络的通信被管理员禁止 | 源设备不允许向目标设备所在的网络发送数据。|'
- en: '| 10 | Communication with Destination Host Is Administratively Prohibited |
    The source device is allowed to send to the network where the destination device
    is located, but not that particular device. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 与目标主机通信被管理员禁止 | 源设备允许发送到目标设备所在的网络，但不能发送到该特定设备。 |'
- en: '| 11 | Destination Network Unreachable for Type of Service | The network specified
    in the IP address cannot be reached due to the inability to provide service specified
    in the Type of Service field of the datagram header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 由于服务类型无法到达目标网络 | 由于无法提供数据报头部服务类型字段中指定的服务，无法到达IP地址中指定的网络。 |'
- en: '| 12 | Destination Host Unreachable for Type of Service | The destination host
    specified in the IP address cannot be reached due to the inability to provide
    service specified in the datagram''s Type of Service field. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 由于服务类型无法到达目标主机 | 由于无法提供数据报服务类型字段中指定的服务，无法到达IP地址中指定的目标主机。 |'
- en: '| 13 | Communication Administratively Prohibited | The datagram could not be
    forwarded due to filtering that blocks the message based on its contents. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 管理性禁止通信 | 由于基于内容过滤阻止消息的过滤导致数据报无法转发。 |'
- en: '| 14 | Host Precedence Violation | Sent by a first-hop router (the first router
    to handle a sent datagram) when the Precedence value in the Type of Service field
    is not permitted. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 主机优先级违规 | 当服务类型字段中的优先级值不被允许时，由第一个路由器（处理发送数据报的第一个路由器）发送。 |'
- en: '| 15 | Precedence Cutoff in Effect | Sent by a router when receiving a datagram
    whose Precedence value (priority) is lower than the minimum allowed for the network
    at that time. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 优先级截止生效 | 当路由器收到一个优先级值（优先级）低于当时网络允许的最小值的数据报时发送。 |'
- en: As you can see in [Table 32-2](ch32.html#icmpv_destination_unreachable_message_su
    "Table 32-2. ICMPv4 Destination Unreachable Message Subtypes"), not all of these
    codes are actively used at this time. For example, code 8 is obsolete and code
    0 is used instead of 6\. Also, some of the higher numbers related to the Type
    of Service field aren't actively used because Type of Service isn't actively used.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[表32-2](ch32.html#icmpv_destination_unreachable_message_su "表32-2. ICMPv4
    Destination Unreachable Message Subtypes")中看到的，目前并不是所有这些代码都在积极使用。例如，代码8已过时，代码0代替了6。此外，一些与服务类型字段相关的较高数字没有积极使用，因为服务类型没有被积极使用。
- en: Tip
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** ICMPv4 *Destination Unreachable* messages are used to inform
    a sending device of a failure to deliver an IP datagram. The message''s Code field
    provides information about the nature of the delivery problem.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ICMPv4 *目的地不可达* 消息用于通知发送设备IP数据报交付失败。消息的代码字段提供了关于交付问题性质的信息。'
- en: Interpretation of Destination Unreachable Messages
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的地不可达消息的解释
- en: It's important to remember that just as IP is a best effort, the reporting of
    unreachable destinations using ICMP is also a best effort. Realize that these
    ICMP messages are themselves carried in IP datagrams. More than that, however,
    remember that there may be problems that prevent a router from detecting failure
    of delivery of an ICMP message, such as a low-level hardware problem. A router
    could, theoretically, also be precluded from sending an ICMP message even when
    failure of delivery *is* detected for whatever reason.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，就像IP是尽力而为一样，使用ICMP报告不可达目的地也是尽力而为。意识到这些ICMP消息本身是在IP数据报中传输的。更重要的是，记住可能存在阻止路由器检测ICMP消息交付失败的问题，例如低级硬件问题。理论上，即使检测到交付失败，路由器也可能被阻止发送ICMP消息。
- en: For this reason, the sending of Destination Unreachable messages should be considered
    supplemental. There is no guarantee that every problem sending a datagram will
    result in a corresponding ICMP message. No device should count on receiving an
    ICMP Destination Unreachable for a failed delivery any more than it counts on
    the delivery in the first place. This is why the higher-layer mechanisms mentioned
    at the start of this discussion are still important.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应将发送目的地不可达消息视为补充。不能保证发送数据报的每个问题都会导致相应的ICMP消息。没有任何设备应该期望在失败交付时收到ICMP目的地不可达消息，就像它最初期望交付一样。这就是为什么在讨论开始时提到的上层机制仍然很重要的原因。
- en: ICMPv4 Source Quench Messages
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv4源抑制消息
- en: When a source device sends out a datagram, it will travel across the internetwork
    and eventually arrive at its intended destination (at least, that's what we hope
    will happen). At that point, it is up to the destination device to process the
    datagram by examining it and determining which higher-layer software process to
    hand the datagram.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当源设备发送数据报时，它将穿越互联网，最终到达其预期的目的地（至少，这是我们希望发生的事情）。在那个时刻，目标设备负责通过检查它并确定要将数据报交给哪个高层软件进程来处理数据报。
- en: If a destination device is receiving datagrams at a relatively slow rate, it
    may be able to process each datagram on the fly as it is received. However, datagram
    receipt in a typical internetwork can tend to be uneven or bursty, with alternating
    higher and lower rates of traffic. To allow for times when datagrams are arriving
    faster than they can be processed, each device has a *buffer* where it can temporarily
    hold datagrams it has received until it has a chance to deal with them.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标设备以相对较慢的速度接收数据报，它可能能够在接收的同时即时处理每个数据报。然而，在典型的互联网中，数据报的接收可能会不均匀或突发，流量速率交替上升和下降。为了允许数据报到达速度超过其处理速度的时间，每个设备都有一个*缓冲区*，它可以暂时存储它已经接收到的数据报，直到它有机会处理它们。
- en: 'However, this buffer is itself limited in size. Assuming the device has been
    properly designed, the buffer may be sufficient to smooth out high-traffic and
    low-traffic periods most of the time. Certain situations can still arise in which
    traffic is received so rapidly that the buffer fills up entirely. Some examples
    of scenarios in which this might happen include the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个缓冲区本身的大小是有限的。假设设备已经得到适当的设计，缓冲区通常足以在大多数时候平滑处理高流量和低流量时段。仍然可能发生某些情况，其中流量接收速度如此之快，以至于缓冲区完全填满。以下是一些可能发生这种情况的场景示例：
- en: A single destination is overwhelmed by datagrams from many sources, such as
    a popular website being swamped by HTTP requests.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个目标设备被来自许多源的数据报淹没，例如，一个流行的网站被HTTP请求淹没。
- en: Device A and Device B are exchanging information, but Device A is a much faster
    computer than Device B, and can generate outgoing and process incoming datagrams
    much faster than Device B can.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备A和设备B正在交换信息，但设备A比设备B快得多，可以比设备B更快地生成出站数据报和处理入站数据报。
- en: A router receives a large number of datagrams over a high-speed link that it
    needs to forward over a low-speed link; they start to pile up while waiting to
    be sent over the slow link.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器通过高速链路接收大量需要通过低速链路转发的数据报；它们在等待通过慢速链路发送时开始堆积。
- en: A hardware failure or other situation causes datagrams to sit at a device unprocessed.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件故障或其他情况导致数据报在设备上停留，无法被处理。
- en: A device that continues to receive datagrams when it has no more buffer space
    is forced to discard them and is said to be *congested*. A source that has its
    datagram discarded due to congestion won't have any way of knowing this, since
    IP itself is unreliable and unacknowledged. Therefore, while it is possible to
    simply allow higher-layer protocols to detect the dropped datagrams and generate
    replacements, it makes a lot more sense to have the congested device provide feedback
    to the sources by telling them that it is overloaded.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备没有更多缓冲区空间时，它被迫丢弃数据报，并被说成是*拥塞的*。由于IP本身是不可靠的且未确认的，因此，虽然简单地允许高层协议检测丢弃的数据报并生成替代品是可能的，但让拥塞设备通过告诉源它已过载来向源提供反馈要合理得多。
- en: In IPv4, a device that is forced to drop datagrams due to congestion provides
    feedback to the sources that overwhelmed it by sending them ICMPv4 *Source Quench*
    messages. Just as you use water to quench a fire, a Source Quench message is a
    signal that attempts to quench a source device that is sending too fast. In other
    words, it's a polite way for one IP device to tell another, "Slow down!" When
    a device receives one of these messages, it knows it needs to reduce the speed
    at which it is sending datagrams to the device that sent it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv4中，由于拥塞而被迫丢弃数据报的设备会通过向其发送ICMPv4 *源抑制*消息向使其过载的源提供反馈。正如你用水来扑灭火焰一样，源抑制消息是一个试图抑制发送速度过快的源设备的信号。换句话说，这是一种礼貌的方式，让一个IP设备告诉另一个设备，“慢一点！”当一个设备收到这样的消息时，它知道它需要降低向发送它的设备发送数据报的速度。
- en: ICMPv4 Source Quench Message Format
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv4源抑制消息格式
- en: '[Table 32-3](ch32s02.html#icmpv_source_quench_message_format "Table 32-3. ICMPv4
    Source Quench Message Format") and [Figure 32-2](ch32s02.html#icmpv4_source_quench_message_forma-id001
    "Figure 32-2. ICMPv4 Source Quench message format") show the specific format for
    ICMPv4 Source Quench messages.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[表32-3](ch32s02.html#icmpv_source_quench_message_format "表32-3. ICMPv4源抑制消息格式")
    和 [图32-2](ch32s02.html#icmpv4_source_quench_message_forma-id001 "图32-2. ICMPv4源抑制消息格式")
    展示了ICMPv4源抑制消息的具体格式。'
- en: Table 32-3. ICMPv4 Source Quench Message Format
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 表32-3. ICMPv4源抑制消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMP message type; for Source Quench messages,
    this is set to 4. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMP消息类型；对于源抑制消息，此值设置为4。 |'
- en: '| Code | 1 | Identifies the subtype of error being communicated. For Source
    Quench messages, this is not used, and the field is set to 0. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 识别正在通信的错误子类型。对于源抑制消息，此字段未使用，并设置为0。 |'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP头的16位校验和字段（见[第31章](ch31.html "第31章. ICMP概念和一般操作"））。 |'
- en: '| Unused | 4 | The 4 bytes that are left blank and not used. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 未使用 | 4 | 剩余的4个字节留空，不使用。 |'
- en: '| Original Datagram Portion | Variable | The full IP header and the first 8
    bytes of the payload of the datagram that was dropped due to congestion. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 原始数据报部分 | 变量 | 由于拥塞而被丢弃的数据报的完整IP头和前8个字节的负载。 |'
- en: '![ICMPv4 Source Quench message format](httpatomoreillycomsourcenostarchimages287965.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv4源抑制消息格式](httpatomoreillycomsourcenostarchimages287965.png)'
- en: Figure 32-2. ICMPv4 Source Quench message format
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图32-2. ICMPv4源抑制消息格式
- en: Problems with Source Quench Messages
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源抑制消息的问题
- en: What's interesting about the Source Quench format is that it is basically a
    null message. It tells the source that the destination is congested but provides
    no specific information about that situation, nor does it specify what exactly
    the destination wants the source to do other than cut back on its transmission
    rate in some way. There is also no method for the destination to signal a source
    that it is no longer congested, and that the source should resume its prior sending
    rate. This means the response to a Source Quench message is left up to the device
    that receives it. Usually, a device will cut back its transmission rate until
    it no longer receives the messages, and then it may try to slowly increase the
    rate again.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 源抑制格式的有趣之处在于它基本上是一个空消息。它告诉源目标已拥塞，但并未提供关于该情况的具体信息，也没有指定目标确切希望源如何减少其传输速率。也没有方法让目标向源发出信号，表明它不再拥塞，源应恢复其先前的发送速率。这意味着源抑制消息的响应留给接收它的设备。通常，设备会减少其传输速率，直到不再收到这些消息，然后它可能尝试缓慢地再次增加速率。
- en: In a similar manner, there are no rules about when and how a device generates
    Source Quench messages in the first place. A common convention is that one message
    is generated for each dropped datagram. However, more intelligent algorithms may
    be employed, especially on higher-end routers, to predict when the device's buffer
    will be filled and preemptively quench certain sources that are sending too quickly.
    Devices may also decide whether to quench all sources when they become busy, or
    only certain ones. As with other ICMP error messages, a device cannot count on
    a Source Quench message being sent when a busy device discards one of its datagrams.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，关于何时以及如何生成源抑制消息没有规则。一个常见的约定是，对于每个被丢弃的数据报生成一条消息。然而，更智能的算法可能在高端路由器上被采用，以预测设备缓冲区何时会满，并预先抑制发送速度过快的某些源。设备还可以决定在变得繁忙时是否抑制所有源，或者只抑制某些源。与其他ICMP错误消息一样，设备不能指望在繁忙设备丢弃其数据报时发送源抑制消息。
- en: The lack of information communicated in Source Quench messages makes them a
    rather crude tool for managing congestion. In general terms, the process of regulating
    the sending of messages between two devices is called *flow control*, and this
    is usually a function of the transport layer. TCP actually has a flow control
    mechanism (discussed in [Chapter 49](ch49.html "Chapter 49. TCP RELIABILITY AND
    FLOW CONTROL FEATURES")) that is far superior to the use of ICMP Source Quench
    messages.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 源抑制消息中传达的信息不足，使它们成为管理拥塞的相当原始的工具。一般来说，在两个设备之间调节消息发送的过程称为 *流量控制*，这通常是传输层的功能。TCP
    实际上有一个流量控制机制（在第 49 章[49](ch49.html "第 49 章。TCP 可靠性和流量控制功能")中讨论），它比使用 ICMP 源抑制消息的使用要优越得多。
- en: Another issue with Source Quench messages is that they can be abused. Transmission
    of these messages by a malicious user can cause a host to be slowed down when
    there is no valid reason. This security issue, combined with the superiority of
    the TCP method for flow control, has caused the use of Source Quench messages
    to largely fall out of favor.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 源抑制消息的另一个问题是它们可能会被滥用。恶意用户发送这些消息可能会导致主机在没有合理原因的情况下变慢。这个问题与 TCP 流量控制方法的优越性相结合，导致源抑制消息的使用在很大程度上不再受欢迎。
- en: Tip
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** ICMPv4 *Source Quench* messages are sent by a device to request
    that another reduce the rate at which it is sending datagrams. The messages are
    a rather crude method of flow control compared to more capable mechanisms such
    as those provided by TCP.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ICMPv4 的 *源抑制* 消息是由设备发送的，以请求另一个设备降低发送数据报的速度。与 TCP 提供的更强大机制相比，这些消息是一种相当原始的流量控制方法。'
- en: ICMPv4 Time Exceeded Messages
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv4 时间超限消息
- en: Large IP internetworks can have thousands of interconnected routers that pass
    datagrams between devices on various networks. In large internetworks, the topology
    of connections between routes can become complex, which makes routing more difficult.
    Routing protocols will normally allow routers to find the best routes between
    networks, but in some situations, an inefficient route might be selected for a
    datagram. In the worst case, a *router loop* may occur. An example of this situation
    is where Router A thinks datagrams intended for Network X should next go to Router
    B, which thinks they should go to Router C, which thinks they need to go to Router
    A. (See the ICMPv6 Time Exceeded Message description in [Chapter 34](ch34.html
    "Chapter 34. ICMPV6 ERROR MESSAGE TYPES AND FORMATS") for an illustration of a
    router loop.)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 大型 IP 互联网可以拥有成千上万的互联路由器，它们在各个网络之间的设备之间传递数据报。在大互联网中，路由器之间的连接拓扑可能变得复杂，这使得路由更加困难。路由协议通常允许路由器在网络上找到最佳路由，但在某些情况下，可能会选择一个低效的路由。在最坏的情况下，可能会发生
    *路由环路*。这种情况的一个例子是，路由器 A 认为发往网络 X 的数据报应该发送到路由器 B，而路由器 B 认为它们应该发送到路由器 C，而路由器 C 认为它们需要发送回路由器
    A。（有关路由环路说明的示例，请参阅[第 34 章](ch34.html "第 34 章。ICMPV6 错误消息类型和格式")中的 ICMPv6 时间超限消息描述。）
- en: If a loop like this occurred, datagrams for Network X that were entering this
    part of the internetwork would circle forever, chewing up bandwidth and eventually
    leading to the network being unusable. As insurance against this occurrence, each
    IP datagram includes in its header a Time to Live (TTL) field. This field was
    originally intended to limit the maximum time (in seconds) that a datagram could
    be on the internetwork, but now limits the life of a datagram by limiting the
    number of times the datagram can be passed from one device to the next. The TTL
    is set to a value by the source that represents the maximum number of hops it
    wants for the datagram. Each router decrements the value; if it ever reaches zero,
    the datagram is said to have *expired* and is discarded.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这样的环路，进入该互联网部分的网络 X 的数据报将永远循环，消耗带宽，最终导致网络无法使用。为了防止这种情况发生，每个 IP 数据报在其报头中都包含一个生存时间（TTL）字段。该字段最初旨在限制数据报在互联网上存在的最大时间（以秒为单位），但现在通过限制数据报从一个设备传递到下一个设备的次数来限制数据报的生命周期。TTL
    由源设备设置，表示它希望数据报经过的最大跳数。每个路由器都会递减该值；如果它达到零，则称数据报已 *过期* 并被丢弃。
- en: When a datagram is dropped due to expiration of the TTL field, the device that
    dropped the datagram will inform the source of this occurrence by sending it an
    ICMPv4 *Time Exceeded* message, as shown in [Figure 32-3](ch32s03.html#expiration_of_an_ip_datagram_and_time_ex
    "Figure 32-3. Expiration of an IP datagram and Time Exceeded message generation
    In this example, Device A sends an IP datagram to Device B, which has a Time to
    Live (TTL) field value of only 4 (perhaps not realizing that Device B is seven
    hops away). On the fourth, hop the datagram reaches Router R4, which decrements
    its TTL field to 0 and then drops it as it expires. Router R4 then sends an ICMP
    Time Exceeded message back to Device A."). Receipt of this message indicates to
    the original sending device that there is a routing problem when sending to that
    particular destination, or that it set the TTL field value too low in the first
    place. As with all ICMP messages, the device receiving it must decide whether
    and how to respond to receipt of the message. For example, it may first try to
    resend the datagram with a higher TTL value.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据报因TTL字段过期而被丢弃时，丢弃数据报的设备将通过发送一个ICMPv4 *时间超限* 消息来通知源设备这一事件，如图[图32-3](ch32s03.html#expiration_of_an_ip_datagram_and_time_ex
    "图32-3. IP数据报过期和时间超限消息生成示例 在本例中，设备A向设备B发送一个IP数据报，设备B的生存时间（TTL）字段值仅为4（可能没有意识到设备B距离有七个跳数）。在第四跳时，数据报到达路由器R4，其将TTL字段减至0，然后因过期而丢弃。路由器R4随后向设备A发送一个ICMP时间超限消息。")所示。收到此消息表明，原始发送设备在向该特定目的地发送时存在路由问题，或者最初设置的TTL字段值太低。与所有ICMP消息一样，接收该消息的设备必须决定是否以及如何对此消息做出响应。例如，它可能首先尝试以更高的TTL值重新发送数据报。
- en: '![Expiration of an IP datagram and Time Exceeded message generation In this
    example, Device A sends an IP datagram to Device B, which has a Time to Live (TTL)
    field value of only 4 (perhaps not realizing that Device B is seven hops away).
    On the fourth, hop the datagram reaches Router R4, which decrements its TTL field
    to 0 and then drops it as it expires. Router R4 then sends an ICMP Time Exceeded
    message back to Device A.](httpatomoreillycomsourcenostarchimages287967.png.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![IP数据报过期和时间超限消息生成示例 在本例中，设备A向设备B发送一个IP数据报，设备B的生存时间（TTL）字段值仅为4（可能没有意识到设备B距离有七个跳数）。在第四跳时，数据报到达路由器R4，其将TTL字段减至0，然后因过期而丢弃。路由器R4随后向设备A发送一个ICMP时间超限消息。](httpatomoreillycomsourcenostarchimages287967.png.jpg)'
- en: Figure 32-3. Expiration of an IP datagram and Time Exceeded message generation
    In this example, Device A sends an IP datagram to Device B, which has a Time to
    Live (TTL) field value of only 4 (perhaps not realizing that Device B is seven
    hops away). On the fourth, hop the datagram reaches Router R4, which decrements
    its TTL field to 0 and then drops it as it expires. Router R4 then sends an ICMP
    Time Exceeded message back to Device A.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图32-3. IP数据报过期和时间超限消息生成示例 在本例中，设备A向设备B发送一个IP数据报，设备B的生存时间（TTL）字段值仅为4（可能没有意识到设备B距离有七个跳数）。在第四跳时，数据报到达路由器R4，其将TTL字段减至0，然后因过期而丢弃。路由器R4随后向设备A发送一个ICMP时间超限消息。
- en: There is another time expiration situation where ICMP Time Exceeded messages
    are used. When an IP message is broken into fragments, the destination device
    is charged with reassembling them into the original message. One or more fragments
    may not make it to the destination, so to prevent the device from waiting forever,
    it sets a timer when the first fragment arrives. If this timer expires before
    the others are received, the device gives up on this message. The fragments are
    discarded, and a Time Exceeded message is generated.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种时间超限情况，ICMP时间超限消息被使用。当一个IP消息被分成片段时，目标设备负责将它们重新组装成原始消息。一个或多个片段可能无法到达目的地，因此为了防止设备无限期地等待，当第一个片段到达时，它设置了一个计时器。如果这个计时器在收到其他片段之前到期，设备将放弃此消息。片段被丢弃，并生成一个时间超限消息。
- en: ICMPv4 Time Exceeded Message Format
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv4 时间超限消息格式
- en: '[Table 32-4](ch32s03.html#icmpv_time_exceeded_message_format "Table 32-4. ICMPv4
    Time Exceeded Message Format") and [Figure 32-4](ch32s03.html#icmpv4_time_exceeded_message_forma-id001
    "Figure 32-4. ICMPv4 Time Exceeded message format") show the specific format for
    ICMPv4 Time Exceeded messages.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[表32-4](ch32s03.html#icmpv_time_exceeded_message_format "表32-4. ICMPv4 时间超限消息格式")
    和 [图32-4](ch32s03.html#icmpv4_time_exceeded_message_forma-id001 "图32-4. ICMPv4
    时间超限消息格式") 展示了 ICMPv4 时间超限消息的具体格式。'
- en: Table 32-4. ICMPv4 Time Exceeded Message Format
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 表32-4. ICMPv4 时间超限消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMP message type; for Time Exceeded messages,
    this is set to 11. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMP消息类型；对于超时消息，此值设置为11。 |'
- en: '| Code | 1 | Identifies the subtype of error being communicated. A value of
    0 indicates expiration of the IP TTL field; a value of 1 indicates that the fragment
    reassembly time has been exceeded. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 识别正在通信的错误子类型。值为0表示IP TTL字段的过期；值为1表示分段重组时间已超过。 |'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP头部的16位校验和字段（见[第31章](ch31.html "第31章。ICMP概念和一般操作")）。 |'
- en: '| Unused | 4 | The 4 bytes that are left blank and not used. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 未使用 | 4 | 留白且未使用的4个字节。 |'
- en: '| Original Datagram Portion | Variable | The full IP header and the first 8
    bytes of the payload of the datagram that was dropped due to expiration of the
    TTL field or reassembly timer. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 原始数据报部分 | 可变 | 由于TTL字段过期或重组定时器到期而被丢弃的数据报的完整IP头和负载的前8个字节。 |'
- en: '![ICMPv4 Time Exceeded message format](httpatomoreillycomsourcenostarchimages287969.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv4超时消息格式](httpatomoreillycomsourcenostarchimages287969.png)'
- en: Figure 32-4. ICMPv4 Time Exceeded message format
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图32-4. ICMPv4超时消息格式
- en: Applications of Time Exceeded Messages
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超时消息的应用
- en: 'ICMP Time Exceeded messages are usually sent in response to the two conditions
    described in [Table 32-4](ch32s03.html#icmpv_time_exceeded_message_format "Table 32-4. ICMPv4
    Time Exceeded Message Format"): TTL or reassembly timer expiration. Generally,
    routers generate TTL expiration messages as they try to route a datagram, while
    end hosts indicate reassembly violations. However, there is actually a very clever
    application of these messages that has nothing to do with reporting errors at
    all.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP超时消息通常是对[表32-4](ch32s03.html#icmpv_time_exceeded_message_format "表32-4。ICMPv4超时消息格式")中描述的两个条件之一的响应：TTL或重组定时器到期。通常，路由器在尝试路由数据报时生成TTL过期消息，而端主机指示重组违规。然而，实际上这些消息有一个非常巧妙的用途，这与报告错误毫无关系。
- en: The TCP/IP *traceroute* (or *tracert*) utility is used to show the sequence
    of devices over which a datagram is passed on a particular route between a source
    and destination. The traceroute utility also shows the amount of time it takes
    for a datagram to reach each hop in that route. This utility was originally implemented
    using Time Exceeded messages by sending datagrams with successively higher TTL
    values.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP的*traceroute*（或*tracert*）实用程序用于显示数据报在源和目的地之间特定路由上传递的设备序列。traceroute实用程序还显示了数据报到达该路由中每个跳所需的时间。该实用程序最初是通过发送具有递增TTL值的数据报并使用超时消息实现的。
- en: First, a dummy datagram is sent with a TTL value of 1, causing the first hop
    in the route to discard the datagram and send back an ICMP Time Exceeded message;
    the time elapsed for this could then be measured. Then, a second datagram is sent
    with a TTL value of 2\. This causes the second device in the route to report back
    a Time Exceeded message, and so on. By continuing to increase the TTL value you
    can get reports back from each hop in the route. See [Chapter 88](ch88.html "Chapter 88. TCP/IP
    ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS") for more details
    on traceroute's operation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，发送一个TTL值为1的虚拟数据报，导致路由中的第一个跳丢弃数据报并发送一个ICMP超时消息；然后可以测量这个过程中的时间。然后，发送一个TTL值为2的数据报。这会导致路由中的第二个设备报告一个超时消息，依此类推。通过继续增加TTL值，你可以从路由中的每个跳获取报告。参见[第88章](ch88.html
    "第88章。TCP/IP 管理和故障排除工具与协议")了解更多关于traceroute操作细节。
- en: Tip
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** ICMPv4 *Time Exceeded* messages are sent in two different time-related
    circumstances. The first is if a datagram''s Time to Live (TTL) field is reduced
    to zero, causing it to expire and the datagram to be dropped. The second is when
    all the pieces of a fragmented message are not received before the expiration
    of the recipient''s reassembly timer.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ICMPv4的*超时*消息在两种不同的时间相关情况下发送。第一种情况是，如果数据报的生存时间（TTL）字段减少到零，导致其过期并丢弃数据报。第二种情况是，在接收方的重组定时器到期之前，未接收到分段消息的所有片段。'
- en: ICMPv4 Redirect Messages
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv4重定向消息
- en: Every device on an internetwork needs to be able to send to every other device.
    If hosts were responsible for determining the routes to each possible destination,
    each host would need to maintain an extensive set of routing information. Since
    there are so many hosts on an internetwork, this would be a very time-consuming
    and maintenance-intensive situation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网中，每个设备都需要能够向其他所有设备发送数据。如果主机负责确定每个可能目的地的路由，那么每个主机都需要维护一个庞大的路由信息集。由于互联网上有如此多的主机，这将是一个非常耗时且维护密集的情况。
- en: 'Instead, IP internetworks are designed around a fundamental design decision:
    Routers are responsible for determining routes and maintaining routing information.
    Hosts determine only when they need a datagram routed, and then hand the datagram
    off to a local router to be sent where it needs to go. I discuss this in more
    detail in my overview of IP routing concepts (see [Chapter 23](ch23.html "Chapter 23. IP
    ROUTING AND MULTICASTING")).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，IP互联网的设计基于一个基本的设计决策：路由器负责确定路由并维护路由信息。主机只确定何时需要将数据报路由，然后将数据报交给本地路由器发送到所需的位置。我在对IP路由概念的概述中详细讨论了这一点（见[第23章](ch23.html
    "第23章。IP路由和多播")）。
- en: Since most hosts do not maintain routing information, they must rely on routers
    to know about routes and where to send datagrams intended for different destinations.
    Typically, a host on an IP network will start out with a routing table that basically
    tells it to send everything not on the local network to a single *default router*,
    which will then figure out what to do with it. Obviously, if there is only one
    router on the network, the host will use that as the default router for all nonlocal
    traffic. However, if there are two or more routers, sending all datagrams to just
    one router may not make sense. It is possible that a host could be manually configured
    to know which router to use for which destinations, but another mechanism in IP
    can allow a host to learn this automatically.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数主机不维护路由信息，它们必须依赖路由器来了解路由以及将数据报发送到不同目的地的情况。通常，一个IP网络上的主机最初会拥有一个基本的路由表，告诉它将本地网络之外的所有内容发送到单个*默认路由器*，然后该路由器将确定如何处理它。显然，如果网络中只有一个路由器，主机将使用该路由器作为所有非本地流量的默认路由器。然而，如果有两个或更多路由器，将所有数据报发送到单个路由器可能没有意义。可能手动配置主机以知道为哪些目的地使用哪个路由器，但IP中的一种机制可以允许主机自动学习这一点。
- en: Consider a Network N1 that contains a number of hosts (H1, H2, and so on) and
    two routers, R1 and R2\. Host H1 has been configured to send all datagrams to
    Router R1, as its default router. Suppose it wants to send a datagram to a device
    on Network N2\. However, Network N2 is most directly connected to Network N1 using
    Router R2, not R1\. The datagram will first be sent to Router R1, which will look
    in its routing table and see that datagrams for Network N2 need to be sent through
    Router R2\. "But wait," R1 says. "R2 is on the local network, and H1 is on the
    local network—so why am I needed as a middleman? H1 should just send datagrams
    for N2 directly to R2 and leave me out of it."
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含多个主机（H1、H2等）和两个路由器R1和R2的网络N1。主机H1已被配置为将所有数据报发送到路由器R1，作为其默认路由器。假设它想向网络N2上的设备发送数据报。然而，网络N2最直接地通过路由器R2而不是R1连接到网络N1。数据报首先会被发送到路由器R1，R1将查看其路由表，并看到网络N2的数据报需要通过路由器R2发送。“但是等等，”R1说。“R2在本地网络中，H1也在本地网络中——那么我作为中间人有什么用？H1应该直接将N2的数据报发送到R2，而不用我。”
- en: In this situation, Router R1 will send an ICMPv4 *Redirect* message back to
    Host H1, telling it that in the future, it should send this type of datagram directly
    to Router R2\. This situation is shown in [Figure 32-5](ch32s04.html#host_redirection_using_an_icmp_redirect_
    "Figure 32-5. Host redirection using an ICMP Redirect message In this example,
    Host H1 sends to Router R1 a datagram destined for Network N2\. However, Router
    R1 notices that Router R2 is on the same network and is a more direct route to
    Network N2\. It forwards the datagram on to Router R2, but also sends an ICMP
    Redirect message back to Host H1 to tell it to use Router R2 next time."). Router
    R1 will also forward the datagram to Router R2 for delivery, since there is no
    reason to drop the datagram. Thus, despite usually being grouped along with true
    ICMP error messages, Redirect messages are really arguably not error messages
    at all. They represent a situation in which only inefficiency exists, not outright
    error. (In fact, in ICMPv6, they have been reclassified.)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，路由器 R1 将向主机 H1 发送一个 ICMPv4 *重定向* 消息，告诉它将来应直接将此类数据报发送到路由器 R2。这种情况在 [图
    32-5](ch32s04.html#host_redirection_using_an_icmp_redirect_ "图 32-5. 使用 ICMP 重定向消息进行主机重定向
    在本例中，主机 H1 向路由器 R1 发送一个目的地为网络 N2 的数据报。然而，路由器 R1 注意到路由器 R2 在同一网络中，并且是到达网络 N2 的更直接路由。它将数据报转发到路由器
    R2，同时也向主机 H1 发送一个 ICMP 重定向消息，告诉它下次使用路由器 R2。") 中显示。路由器 R1 还会将数据报转发到路由器 R2 以进行投递，因为没有理由丢弃数据报。因此，尽管通常与真正的
    ICMP 错误消息一起分组，但重定向消息实际上根本不是错误消息。它们代表只存在低效，而不是明显的错误。实际上，在 ICMPv6 中，它们已被重新分类。
- en: ICMPv4 Redirect Message Format
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv4 重定向消息格式
- en: '[Table 32-5](ch32s04.html#icmpv_redirect_message_format "Table 32-5. ICMPv4
    Redirect Message Format") and [Figure 32-6](ch32s04.html#icmpv4_redirect_message_format-id001
    "Figure 32-6. ICMPv4 Redirect message format") show the specific format for ICMPv4
    Redirect messages.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 32-5](ch32s04.html#icmpv_redirect_message_format "表 32-5. ICMPv4 重定向消息格式")
    和 [图 32-6](ch32s04.html#icmpv4_redirect_message_format-id001 "图 32-6. ICMPv4 重定向消息格式")
    展示了 ICMPv4 重定向消息的具体格式。'
- en: '![Host redirection using an ICMP Redirect message In this example, Host H1
    sends to Router R1 a datagram destined for Network N2\. However, Router R1 notices
    that Router R2 is on the same network and is a more direct route to Network N2\.
    It forwards the datagram on to Router R2, but also sends an ICMP Redirect message
    back to Host H1 to tell it to use Router R2 next time.](httpatomoreillycomsourcenostarchimages287971.png.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![使用 ICMP 重定向消息进行主机重定向 在本例中，主机 H1 向路由器 R1 发送一个目的地为网络 N2 的数据报。然而，路由器 R1 注意到路由器
    R2 在同一网络中，并且是到达网络 N2 的更直接路由。它将数据报转发到路由器 R2，同时也向主机 H1 发送一个 ICMP 重定向消息，告诉它下次使用路由器
    R2。](httpatomoreillycomsourcenostarchimages287971.png.jpg)'
- en: Figure 32-5. Host redirection using an ICMP Redirect message In this example,
    Host H1 sends to Router R1 a datagram destined for Network N2\. However, Router
    R1 notices that Router R2 is on the same network and is a more direct route to
    Network N2\. It forwards the datagram on to Router R2, but also sends an ICMP
    Redirect message back to Host H1 to tell it to use Router R2 next time.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 32-5. 使用 ICMP 重定向消息进行主机重定向 在本例中，主机 H1 向路由器 R1 发送一个目的地为网络 N2 的数据报。然而，路由器 R1
    注意到路由器 R2 在同一网络中，并且是到达网络 N2 的更直接路由。它将数据报转发到路由器 R2，同时也向主机 H1 发送一个 ICMP 重定向消息，告诉它下次使用路由器
    R2。
- en: Table 32-5. ICMPv4 Redirect Message Format
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 表 32-5. ICMPv4 重定向消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMP message type; for Redirect messages, this
    value is 5. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别 ICMP 消息类型；对于重定向消息，此值为 5。 |'
- en: '| Code | 1 | Identifies the meaning or scope of the Redirect message. See [Table 32-6](ch32s04.html#icmp_redirect_message_interpretation_cod
    "Table 32-6. ICMP Redirect Message Interpretation Codes") for an explanation of
    how this field is used in Redirect messages. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 识别重定向消息的意义或范围。有关此字段在重定向消息中如何使用的说明，请参阅 [表 32-6](ch32s04.html#icmp_redirect_message_interpretation_cod
    "表 32-6. ICMP 重定向消息解释代码"）。 |'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP 头部的 16 位校验和字段（见 [第 31 章](ch31.html "第 31 章. ICMP 概念和一般操作"））。
    |'
- en: '| Internet Address | 4 | The address of the router to which future datagrams
    sent to the original destination should be sent. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 互联网地址 | 4 | 应将发送到原始目的地的未来数据报发送到的路由器的地址。 |'
- en: '| Original Datagram Portion | Variable | The full IP header and the first 8
    bytes of the payload of the datagram that led to the creation of the Redirect.
    |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 原始数据报部分 | 可变 | 导致创建重定向的数据报的完整IP头和负载的前8个字节。|'
- en: '![ICMPv4 Redirect message format](httpatomoreillycomsourcenostarchimages287973.png.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv4重定向消息格式](httpatomoreillycomsourcenostarchimages287973.png.jpg)'
- en: Figure 32-6. ICMPv4 Redirect message format
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图32-6. ICMPv4重定向消息格式
- en: Redirect Message Interpretation Codes
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向消息解释代码
- en: When a Redirect message is received back by a device, it inspects the included
    portion of the original datagram. Since this contains the original destination
    address of the redirected target device, this tells the original sender which
    addresses should be redirected in the future. The Internet Address field tells
    it which router it should use for subsequent datagrams. The Code field tells the
    sender how broadly to interpret the redirection. There are four different Code
    values, as shown in [Table 32-6](ch32s04.html#icmp_redirect_message_interpretation_cod
    "Table 32-6. ICMP Redirect Message Interpretation Codes").
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备接收到重定向消息时，它会检查原始数据报包含的部分。由于这包含重定向目标设备的原始目标地址，这告诉原始发送者哪些地址应在未来进行重定向。互联网地址字段告诉它应使用哪个路由器进行后续数据报。代码字段告诉发送者如何广泛地解释重定向。有四个不同的代码值，如[表32-6](ch32s04.html#icmp_redirect_message_interpretation_cod
    "表32-6. ICMP重定向消息解释代码")所示。
- en: Table 32-6. ICMP Redirect Message Interpretation Codes
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 表32-6. ICMP重定向消息解释代码
- en: '| Code Value | Message Subtype | Meaning |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 代码值 | 消息子类型 | 含义 |'
- en: '| --- | --- | --- |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | Redirect Datagrams for the Network (or Subnet) | Redirect all future
    datagrams sent not only to the device whose address caused this Redirect, but
    also to all other devices on the network (or subnet) where that device is located.
    (This code is now obsolete; see the note that follows this table.) |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 为网络（或子网）重定向数据报 | 重定向所有未来发送到导致此重定向的设备地址的数据报，以及该设备所在网络（或子网）上的所有其他设备。（此代码现已过时；请参阅此表后面的注释。）|'
- en: '| 1 | Redirect Datagrams for the Host | Redirect all future datagrams only
    for the address of the specific device to which the original datagram was sent.
    |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 为主机重定向数据报 | 仅针对原始数据报发送的特定设备地址重定向所有未来数据报。|'
- en: '| 2 | Redirect Datagrams for the Type of Service (TOS) and Network (or Subnet)
    | Same as for Code value 0, but only for future datagrams that have the same TOS
    value as the original datagram. (This code is now obsolete; see the note that
    follows this table.) |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 为服务类型（TOS）和网络（或子网）重定向数据报 | 与代码值0相同，但仅针对与原始数据报具有相同TOS值的前瞻数据报。（此代码现已过时；请参阅此表后面的注释。）|'
- en: '| 3 | Redirect Datagrams for the TOS and Host | As for Code value 1, but only
    for future datagrams that have the same TOS value as the original datagram. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 为TOS和主机重定向数据报 | 对于代码值1，但仅针对与原始数据报具有相同TOS值的未来数据报。|'
- en: Note
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*One problem with* Redirects *for whole networks is that the network specification
    may be ambiguous in an environment where subnetting or classless addressing is
    used. For this reason, the use of Code values 0 and 2 was prohibited by RFC 1812;
    the values are considered obsolete on the modern Internet*.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于整个网络的重定向存在一个问题，即在网络划分或无类别寻址的环境中，网络规范可能是不明确的。因此，RFC 1812禁止使用代码值0和2；在现代互联网上，这些值被认为是过时的*。'
- en: Obviously, routers usually generate Redirect messages and send them to hosts;
    hosts do not normally create them. The specific rules for when Redirect messages
    are created can be fairly complex, as a number of conditions may exist that preclude
    these messages from being sent. In particular, special rules exist for when a
    router may redirect an entire network (or subnet) instead of just a single host.
    Also, remember that the TOS field is optional and often not used, so Redirects
    with Code values of 2 or 3 are less common than those with values of 0 and 1.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，路由器通常生成重定向消息并将它们发送到主机；主机通常不会创建它们。重定向消息何时创建的具体规则可能相当复杂，因为可能存在许多条件阻止这些消息被发送。特别是，当路由器可能重定向整个网络（或子网）而不是单个主机时，存在特殊的规则。此外，请记住，TOS字段是可选的，通常不使用，因此代码值为2或3的重定向比代码值为0和1的重定向更不常见。
- en: Limitations of Redirect Messages
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向消息的限制
- en: Keep in mind that ICMP Redirect messages are *not* a mechanism by which the
    general routing process in IP is implemented; they are only a support function.
    They are a convenient way for hosts to be given information about routes by local
    routers, but are not used to communicate route information between routers.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，ICMP重定向消息**不是**实现IP中一般路由过程的机制；它们只是一个辅助功能。它们是主机通过本地路由器获得路由信息的一种方便方式，但不用于在路由器之间通信路由信息。
- en: This means that a Redirect message can tell a host to use a more efficient first-hop
    router, but cannot tell a router to use a more efficient second-hop router. In
    the previous example (illustrated in [Figure 32-5](ch32s04.html#host_redirection_using_an_icmp_redirect_
    "Figure 32-5. Host redirection using an ICMP Redirect message In this example,
    Host H1 sends to Router R1 a datagram destined for Network N2\. However, Router
    R1 notices that Router R2 is on the same network and is a more direct route to
    Network N2\. It forwards the datagram on to Router R2, but also sends an ICMP
    Redirect message back to Host H1 to tell it to use Router R2 next time.")), suppose
    that in addition to the connections mentioned, Router R2 is connected to Router
    R3 and Router R4\. Router R2 sends the datagram in question to Router R3, which
    realizes it needs to send to Router R4, a router already directly connected to
    Router R2\. Router R3 *cannot* send a Redirect message to Router R2 telling it
    to use Router R4 next time. The messages are simply not designed for this purpose—remember
    that ICMP messages always go back to the source of the original datagram, which
    would not be Router R2 in this case. Such inefficiencies must be resolved using
    routing protocols.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着重定向消息可以告诉主机使用一个更高效的第一个跳转路由器，但不能告诉路由器使用一个更高效的第二个跳转路由器。在先前的例子（如图32-5所示[链接](ch32s04.html#host_redirection_using_an_icmp_redirect_
    "图32-5. 使用ICMP重定向消息的主机重定向 本例中，主机H1向路由器R1发送一个目的地为网络N2的数据报。然而，路由器R1注意到路由器R2在同一网络中，并且是到达网络N2的更直接路由。它将数据报转发到路由器R2，同时也向主机H1发送一个ICMP重定向消息，告诉它下次使用路由器R2。"）中，假设除了提到的连接之外，路由器R2还连接到路由器R3和路由器R4。路由器R2将相关数据报发送到路由器R3，R3意识到它需要发送到已经直接连接到路由器R2的路由器R4。路由器R3**不能**向路由器R2发送一个重定向消息，告诉它下次使用路由器R4。这些消息根本不是为了这个目的而设计的——记住，ICMP消息总是返回到原始数据报的源地址，在这种情况下不是路由器R2。这种低效必须通过路由协议来解决。
- en: Tip
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** A router uses ICMPv4 *Redirect* messages to inform a host of
    a preferred router that will be used for future datagrams that are sent to a particular
    host or network. They are not used to alter routes between routers.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 路由器使用ICMPv4 *重定向*消息通知主机一个首选路由器，该路由器将用于将来发送到特定主机或网络的数据报。它们不用于更改路由器之间的路由。'
- en: ICMPv4 Parameter Problem Messages
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv4参数问题消息
- en: The previous sections in this chapter describe four specific ICMPv4 message
    types that allow a device to report various error conditions to the original sender
    of a datagram. However, other error situations may arise that don't correspond
    to any of these four specific message types. Typically, the problem results when
    a device attempts to process the header fields of an IP datagram and finds something
    in it that doesn't make sense.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面的部分描述了四种特定的ICMPv4消息类型，允许设备向数据报的原始发送者报告各种错误条件。然而，可能还会出现其他不符合这四种特定消息类型的错误情况。通常，问题发生在设备尝试处理IP数据报的头字段时，发现其中有些内容没有意义。
- en: If a device finds a problem with any of the parameters in an IP datagram header
    that is serious enough that it cannot complete processing the header, it must
    discard the datagram. As in other cases where a datagram must be tossed out, this
    is serious enough to warrant communication of the problem back to the device that
    sent the original datagram. This is accomplished in ICMPv4 using the *Parameter
    Problem* message type.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备发现IP数据报头中的任何参数有问题，严重到无法完成头部的处理，它必须丢弃该数据报。与其他必须丢弃数据报的情况一样，这个问题严重到需要将问题通知发送原始数据报的设备。这是通过ICMPv4使用*参数问题*消息类型来实现的。
- en: This is a catchall type of message that can be used to indicate an error in
    any header field of an IP datagram. The message type does not contain any specific
    fields or coding to indicate what the problem is. This was done intentionally
    to keep the Parameter Problem message generic and ensure that it could indicate
    any sort of error. Instead of special error codes, most Parameter Problem messages
    tell the original source which parameter caused the problem by including a special
    pointer that indicates which field in the original datagram header caused the
    problem. Both hosts and routers can generate Parameter Problem messages.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种通用的消息类型，可以用来指示 IP 数据报中任何头部字段的错误。消息类型不包含任何特定字段或编码来指示问题是什么。这是有意为之，以保持参数问题消息的通用性并确保它可以指示任何类型的错误。而不是特殊的错误代码，大多数参数问题消息通过包含一个特殊指针来告诉原始源哪个参数导致了问题，该指针指示原始数据报头部中哪个字段导致了问题。主机和路由器都可以生成参数问题消息。
- en: ICMPv4 Parameter Problem Message Format
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv4 参数问题消息格式
- en: '[Table 32-7](ch32s05.html#icmpv_parameter_problem_message_format "Table 32-7. ICMPv4
    Parameter Problem Message Format") and [Figure 32-7](ch32s05.html#icmpv4_parameter_problem_message_f-id001
    "Figure 32-7. ICMPv4 Parameter Problem message format") show the specific format
    for ICMPv4 Parameter Problem messages.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 32-7](ch32s05.html#icmpv_parameter_problem_message_format "表 32-7. ICMPv4
    参数问题消息格式") 和 [图 32-7](ch32s05.html#icmpv4_parameter_problem_message_f-id001 "图
    32-7. ICMPv4 参数问题消息格式") 展示了 ICMPv4 参数问题消息的特定格式。'
- en: '![ICMPv4 Parameter Problem message format](httpatomoreillycomsourcenostarchimages287975.png.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv4 参数问题消息格式](httpatomoreillycomsourcenostarchimages287975.png.jpg)'
- en: Figure 32-7. ICMPv4 Parameter Problem message format
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 32-7. ICMPv4 参数问题消息格式
- en: Table 32-7. ICMPv4 Parameter Problem Message Format
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 表 32-7. ICMPv4 参数问题消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMP message type; for Parameter Problem messages,
    this value is 12. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别 ICMP 消息类型；对于参数问题消息，此值为 12。 |'
- en: '| Code | 1 | Identifies the subtype of the problem being communicated. See
    [Table 32-8](ch32s05.html#icmpv_parameter_problem_message_interpre "Table 32-8. ICMPv4
    Parameter Problem Message Interpretation Codes") for more information about this
    field as it relates to Parameter Problem messages. |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 识别正在通信的问题子类型。有关此字段与参数问题消息相关的更多信息，请参阅 [表 32-8](ch32s05.html#icmpv_parameter_problem_message_interpre
    "表 32-8. ICMPv4 参数问题消息解释代码"）。 |'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP 头部的 16 位校验和字段（见 [第 31 章](ch31.html "第 31 章. ICMP 概念和一般操作"））。
    |'
- en: '| Pointer | 1 | An offset that points to the byte location in the datagram
    that caused the Parameter Problem message to be generated. The device receiving
    the ICMP message can use this value to get an idea of which field in the original
    message had the problem. This field is used only when the Code value is 0. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 指针 | 1 | 一个偏移量，指向导致生成参数问题消息的数据报中的字节位置。接收 ICMP 消息的设备可以使用此值来了解原始消息中哪个字段存在问题。此字段仅在代码值为
    0 时使用。 |'
- en: '| Unused | 3 | 3 bytes that are left blank and not used. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 未使用 | 3 | 3 个空白且未使用的字节。 |'
- en: '| Original Datagram Portion | Variable | The full IP header and the first 8
    bytes of the payload of the datagram that prompted this error message to be sent.
    |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 原始数据报部分 | 可变 | 触发发送此错误消息的数据报的完整 IP 头部和负载的前 8 个字节。 |'
- en: Parameter Problem Message Interpretation Codes and the Pointer Field
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数问题消息解释代码和指针字段
- en: When a Parameter Problem message is generated due to a specific bad field in
    the original message, the Pointer field is used to show the location of the problem.
    This meaning of the Parameter Problem message is the one that was defined in the
    original ICMP standard, RFC 792, and is associated with Code value 0\. There are
    some cases of a parameter problem in which a pointer to a specific field in the
    original message really wouldn't make sense, so other standards have defined two
    new Code field values for Parameter Problem messages. [Table 32-8](ch32s05.html#icmpv_parameter_problem_message_interpre
    "Table 32-8. ICMPv4 Parameter Problem Message Interpretation Codes") shows the
    three Code values and provides a brief explanation of each one.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当由于原始消息中的特定错误字段生成参数问题消息时，指针字段用于显示问题的位置。这种参数问题消息的含义是在原始 ICMP 标准 RFC 792 中定义的，并与代码值
    0 相关联。在某些参数问题的例子中，指向原始消息中特定字段的指针实际上并没有意义，因此其他标准为参数问题消息定义了两个新的代码字段值。[表 32-8](ch32s05.html#icmpv_parameter_problem_message_interpre
    "表 32-8. ICMPv4 参数问题消息解释代码") 展示了三个代码值，并对每个代码值进行了简要说明。
- en: Table 32-8. ICMPv4 Parameter Problem Message Interpretation Codes
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 表 32-8. ICMPv4 参数问题消息解释代码
- en: '| Code Value | Message Subtype | Description |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 代码值 | 消息子类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | Pointer Indicates the Error | This is the normal use of the Parameter
    Problem message. When this Code value is used, the Pointer field indicates the
    location of the problem. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 指针指示错误 | 这是参数问题消息的正常用途。当使用此代码值时，指针字段指示问题的位置。 |'
- en: '| 1 | Missing a Required Option | The IP datagram needed to have an option
    in it that was missing. Since the option was missing, there is no way to point
    to it. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 缺少必需的选项 | IP 数据报需要包含一个缺失的选项。由于选项缺失，无法指向它。 |'
- en: '| 2 | Bad Length | The length of the datagram overall was incorrect, indicating
    a general problem with the message as a whole. Again, the Pointer field makes
    no sense here. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 错误长度 | 数据报的总长度不正确，表明整个消息存在一般性问题。同样，指针字段在这里没有意义。 |'
- en: Tip
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The ICMPv4 *Parameter Problem* message is a generic catchall
    that can be used to convey an error of any type in an IP datagram. A special Pointer
    field is normally used to indicate to the message''s recipient where the problem
    was in the original datagram.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ICMPv4 **参数问题** 消息是一个通用的万能工具，可以用来传达 IP 数据报中任何类型的错误。通常使用一个特殊的指针字段来指示消息接收者，问题出在原始数据报的哪个位置。'
- en: Note that the Pointer field is only eight bits wide, but since this allows for
    values of up to 256, it is sufficient for allowing it to point to any location
    within the IP header. It is possible for the Pointer field to point to a field
    within an IP option.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，指针字段只有八位宽，但由于这允许值高达 256，因此足以允许它指向 IP 头部内的任何位置。指针字段可以指向 IP 选项内的一个字段。
- en: Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 33 章。ICMPV4 信息消息类型和格式
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The five Internet Control Message Protocol (ICMP) error message types we examined
    in the previous chapter communicate important information about error or problem
    conditions encountered during the operation of an Internet Protocol (IP) internetwork.
    In contrast, the other class of ICMP messages contains those messages that are
    *informational*. They are not sent in response to some issue with a regular IP
    datagram, but are used on their own to implement various support functions for
    IP. Informational messages are used for testing and diagnostic purposes, as well
    as for allowing devices to share critical information that they need to function
    correctly.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中我们检查的五个互联网控制消息协议 (ICMP) 错误消息类型，在互联网协议 (IP) 内部网络操作过程中遇到错误或问题条件时，传达了重要的信息。相比之下，另一类
    ICMP 消息包含那些消息，它们是 **信息性的**。它们不是对常规 IP 数据报中某个问题的响应，而是用于实现 IP 的各种支持功能。信息性消息用于测试和诊断目的，以及允许设备共享它们正常工作所需的临界信息。
- en: In this chapter, I describe nine different ICMP version 4 (ICMPv4) informational
    messages. Because many of these messages are used in functional sets, pairs of
    related messages are described together. I begin with a discussion of the Echo
    (Request) and Echo Reply messages used for network testing, and Timestamp (Request)
    and Timestamp Reply messages used for clock synchronization. I explain the use
    and format of Router Advertisement and Router Solicitation messages, which allow
    hosts to discover the identity of local routers and learn important information
    about them. I also describe the Address Mask Request and Address Mask Reply messages
    that communicate subnet mask information. I conclude with a look at the Traceroute
    message, which implements a more sophisticated version of the traceroute utility.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了九种不同的ICMP版本4（ICMPv4）信息消息。由于许多这些消息用于功能集，因此相关消息的对一起描述。我首先讨论了用于网络测试的回声（请求）和回声应答消息，以及用于时钟同步的时间戳（请求）和时间戳应答消息。我解释了路由器通告和路由器请求消息的使用和格式，这些消息允许主机发现本地路由器的身份并了解它们的重要信息。我还描述了用于通信子网掩码信息的地址掩码请求和地址掩码应答消息。最后，我审视了Traceroute消息，它实现了traceroute实用程序的更复杂版本。
- en: Note
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The original ICMP standard also defined two more informational message types:
    Information Request and Information Reply. These were intended to allow devices
    to determine an IP address and possibly other configuration information. This
    function was later implemented using host configuration protocols such as the
    Reverse Address Resolution Protocol (RARP), Boot Protocol (BOOTP), and Dynamic
    Host Configuration Protocol (DHCP). These message types are now obsolete; therefore,
    they are not discussed in this chapter*.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*原始的ICMP标准还定义了两种更多的信息消息类型：信息请求和信息应答。这些消息旨在允许设备确定IP地址以及可能的其他配置信息。这个功能后来通过主机配置协议如反向地址解析协议（RARP）、引导协议（BOOTP）和动态主机配置协议（DHCP）来实现。这些消息类型现在已过时；因此，它们在本章中未讨论*。'
- en: ICMPv4 Echo (Request) and Echo Reply Messages
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv4回声（请求）和回声应答消息
- en: One of the main purposes of ICMP informational messages is to enable testing
    and diagnostics in order to help identify and correct problems on an internetwork.
    The most basic test that can be conducted between two devices is simply checking
    if they are capable of sending datagrams to each other. The usual way that this
    is done is to have one device send a test message to a second device, which receives
    the message and replies back to tell the first device it received the message.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP信息消息的主要目的之一是启用测试和诊断，以帮助识别和纠正互联网中的问题。两个设备之间可以进行的最基本的测试就是简单地检查它们是否能够互相发送数据报。通常的做法是让一个设备向第二个设备发送测试消息，第二个设备接收消息并回复告诉第一个设备它已收到消息。
- en: ICMPv4 includes a pair of messages specifically for connection testing. Suppose
    Device A wants to see if it can reach Device B. Device A begins the test process
    by sending an ICMPv4 *Echo* message to Device B. Device B, when it receives the
    Echo, responds back to Device A with an *Echo* Reply message. When Device A receives
    this message, it knows that it is able to communicate (both send and receive)
    successfully with Device B.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv4包括一对专门用于连接测试的消息。假设设备A想看看它是否能到达设备B。设备A通过向设备B发送ICMPv4 *Echo* 消息来开始测试过程。当设备B接收到回声时，它会向设备A发送一个*Echo*
    应答消息。当设备A接收到这条消息时，它就知道它能够与设备B成功通信（发送和接收）。
- en: Note
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The name of the first message in this pair is often given as Echo Request.
    While this does convey the paired nature of the Echo and Echo Reply messages,
    the formal name used in the standards is simply an Echo message*.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*该对中第一条消息的名称通常被称为回声请求。虽然这确实传达了回声和回声应答消息的配对性质，但标准中使用的正式名称只是一个回声消息*。'
- en: ICMPv4 Echo and Echo Reply Message Format
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv4回声和回声应答消息格式
- en: '[Table 33-1](ch33.html#icmpv_echo_and_echo_reply_message_format "Table 33-1. ICMPv4
    Echo and Echo Reply Message Format") and [Figure 33-1](ch33.html#icmpv4_echo_and_echo_reply_message-id001
    "Figure 33-1. ICMPv4 Echo and Echo Reply message format Two special fields are
    used within the format of these messages. They allow devices to match Echo and
    Echo Reply messages together, and exchange a sequence of messages. The Identifier
    field was envisioned as being used as a higher-level label, like a session identifier,
    while the Sequence Number was seen as something to identify individual test messages
    within a series. However, the use of these fields is up to the particular implementation.
    In some cases, the Identifier field is filled in with the process number of the
    application that is using the Echo or Echo Reply message to allow several users
    to use utilities like ping without interference.") show the format for both ICMPv4
    Echo and Echo Reply messages.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[表33-1](ch33.html#icmpv_echo_and_echo_reply_message_format "表33-1. ICMPv4回显和回显应答消息格式")
    和 [图33-1](ch33.html#icmpv4_echo_and_echo_reply_message-id001 "图33-1. ICMPv4回显和回显应答消息格式这些消息的格式中使用了两个特殊字段。它们允许设备将回显和回显应答消息匹配在一起，并交换一系列消息。标识符字段被设想为用作高级标签，例如会话标识符，而序列号被视为用于识别一系列中的单个测试消息的东西。然而，这些字段的使用取决于特定的实现。在某些情况下，标识符字段被填充为使用回显或回显应答消息的应用程序进程号，以便多个用户可以使用ping等工具而不会相互干扰。")
    展示了ICMPv4回显和回显应答消息的格式。'
- en: Table 33-1. ICMPv4 Echo and Echo Reply Message Format
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 表33-1. ICMPv4回显和回显应答消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMP message type. For Echo messages, the value
    is 8; for Echo Reply messages, the value is 0. |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMP消息类型。对于回显消息，值为8；对于回显应答消息，值为0。 |'
- en: '| Code | 1 | Not used for Echo and Echo Reply messages; set to 0. |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 不用于回显和回显应答消息；设置为0。 |'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP头部的一个16位校验和字段（见[第31章](ch31.html "第31章. ICMP概念和一般操作"））。 |'
- en: '| Identifier | 2 | An identification field that can be used to help in matching
    Echo and Echo Reply messages. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 标识符 | 2 | 一个可以用于帮助匹配回显和回显应答消息的标识字段。 |'
- en: '| Sequence Number | 2 | A sequence number to help in matching Echo and Echo
    Reply messages. |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 序列号 | 2 | 一个序列号，用于帮助匹配回显和回显应答消息。 |'
- en: '| Optional Data | Variable | Additional data to be sent along with the message
    (not specified). |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 可选数据 | 变量 | 随消息一起发送的附加数据（未指定）。 |'
- en: It is possible that a source device may want to send more than one Echo message
    to either a single destination or multiple destinations. Conversely, a single
    destination might receive Echo messages from more than one source. It is essential
    that a device receiving an Echo Reply message knows which Echo message prompted
    it to be sent.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 源设备可能希望向单个目的地或多个目的地发送多个回显消息。相反，单个目的地可能会从多个源接收回显消息。接收回显应答消息的设备知道是哪个回显消息促使它发送是至关重要的。
- en: '![ICMPv4 Echo and Echo Reply message format Two special fields are used within
    the format of these messages. They allow devices to match Echo and Echo Reply
    messages together, and exchange a sequence of messages. The Identifier field was
    envisioned as being used as a higher-level label, like a session identifier, while
    the Sequence Number was seen as something to identify individual test messages
    within a series. However, the use of these fields is up to the particular implementation.
    In some cases, the Identifier field is filled in with the process number of the
    application that is using the Echo or Echo Reply message to allow several users
    to use utilities like ping without interference.](httpatomoreillycomsourcenostarchimages287977.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv4回显和回显应答消息格式这些消息的格式中使用了两个特殊字段。它们允许设备将回显和回显应答消息匹配在一起，并交换一系列消息。标识符字段被设想为用作高级标签，例如会话标识符，而序列号被视为用于识别一系列中的单个测试消息的东西。然而，这些字段的使用取决于特定的实现。在某些情况下，标识符字段被填充为使用回显或回显应答消息的应用程序进程号，以便多个用户可以使用ping等工具而不会相互干扰。](httpatomoreillycomsourcenostarchimages287977.png)'
- en: Figure 33-1. ICMPv4 Echo and Echo Reply message format Two special fields are
    used within the format of these messages. They allow devices to match Echo and
    Echo Reply messages together, and exchange a sequence of messages. The Identifier
    field was envisioned as being used as a higher-level label, like a session identifier,
    while the Sequence Number was seen as something to identify individual test messages
    within a series. However, the use of these fields is up to the particular implementation.
    In some cases, the Identifier field is filled in with the process number of the
    application that is using the Echo or Echo Reply message to allow several users
    to use utilities like ping without interference.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图33-1. ICMPv4 Echo和Echo Reply消息格式 这些消息的格式中使用了两个特殊字段。它们允许设备将Echo和Echo Reply消息配对，并交换一系列消息。标识符字段原本设想为用作高级标签，如会话标识符，而序列号被视为用于识别一系列中的单个测试消息。然而，这些字段的使用取决于特定的实现。在某些情况下，标识符字段被填充为使用Echo或Echo
    Reply消息的应用程序进程号，以便多个用户可以使用ping等工具而不会相互干扰。
- en: Application of Echo and Echo Reply Messages
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Echo和Echo Reply消息的应用
- en: The most common way that you may use the Echo and Echo Reply messages is through
    the popular utility *ping*, which is used to test host reachability. While the
    basic test simply consists of sending an Echo message and waiting for an Echo
    Reply message, modern versions of ping are quite sophisticated. They allow the
    user to specify many parameters, including the number of Echo messages sent, how
    often they are sent, the size of message transmitted, and more. They also provide
    a great deal of information about the connection, including the number of Echo
    Reply messages received, the time elapsed for the pair of messages to be exchanged,
    and a lot more. See the description of ping in [Chapter 88](ch88.html "Chapter 88. TCP/IP
    ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS") for a full explanation
    of the utility.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你最可能使用Echo和Echo Reply消息的方式是通过流行的实用工具*ping*，它用于测试主机可达性。虽然基本测试只是简单地发送一个Echo消息并等待Echo
    Reply消息，但ping的现代版本相当复杂。它们允许用户指定许多参数，包括发送的Echo消息数量、发送频率、传输的消息大小等等。它们还提供了大量有关连接的信息，包括接收到的Echo
    Reply消息数量、交换这对消息所花费的时间以及更多。有关ping的完整说明，请参阅[第88章](ch88.html "第88章。TCP/IP 管理和故障排除实用工具和协议")。
- en: Tip
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** ICMPv4 *Echo (Request)* and *Echo Reply* messages are used
    to facilitate network reachability testing. A device can test its ability to perform
    basic communication with another one by sending an Echo message and waiting for
    an Echo Reply message to be returned by the other device. The ping utility, a
    widely used diagnostic tool in TCP/IP internetworks, makes use of these messages.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ICMPv4的*Echo (请求)*和*Echo Reply*消息用于促进网络可达性测试。一个设备可以通过发送Echo消息并等待另一个设备返回Echo
    Reply消息来测试其与另一个设备进行基本通信的能力。ping实用工具是TCP/IP因特网中广泛使用的诊断工具，它利用了这些消息。'
- en: ICMPv4 Timestamp (Request) and Timestamp Reply Messages
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv4 时间戳（请求）和时间戳回复消息
- en: 'All of the hosts and routers on an internetwork operate independently of each
    other. One aspect of this autonomy is that each device maintains a separate system
    clock. There''s a problem, however: Even highly accurate clocks have slight differences
    in both how accurately they keep time and the time with which they were initialized
    at startup. This means that under normal circumstances, no two devices on an internetwork
    are guaranteed to have exactly the same time.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 因特网上的所有主机和路由器都是相互独立运行的。这种自主性的一个方面是每个设备都维护一个独立的系统时钟。然而，有一个问题：即使是非常精确的时钟，在保持时间的准确性以及启动时初始化的时间上也有细微的差异。这意味着在正常情况下，因特网上的任何两个设备都不保证具有完全相同的时间。
- en: The creators of TCP/IP recognized that certain applications might not work properly
    if there were too much differential between the system clocks of a pair of devices.
    To support this requirement, they created a pair of ICMP messages that allow devices
    to exchange system time information. The initiating device creates a Timestamp
    message and sends it to the device with which it wishes to synchronize. That device
    responds with a Timestamp Reply message. Timestamp fields in these messages are
    used to mark the times that these messages are sent and received to allow the
    devices' clocks to be synchronized.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP的创造者认识到，如果一对设备之间的系统时钟差异太大，某些应用程序可能无法正常工作。为了支持这一需求，他们创建了一对ICMP消息，允许设备交换系统时间信息。发起设备创建一个时间戳消息并将其发送给它希望同步的设备。该设备以时间戳回复消息的形式进行响应。这些消息中的时间戳字段用于标记消息发送和接收的时间，以便同步设备的时钟。
- en: Note
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*As with the Echo message (described in the previous section), the Timestamp
    message is sometimes seen as Timestamp Request, though the word* Request *doesn''t
    appear in its formal name*.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '*与上一节中描述的回显消息一样，时间戳消息有时被视为时间戳请求，尽管其正式名称中并没有出现“请求”一词*。'
- en: ICMPv4 Timestamp and Timestamp Reply Message Format
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv4 时间戳和时间戳回复消息格式
- en: The ICMPv4 *Timestamp* and *Timestamp Reply* messages have the same format.
    The originating device fills in some of the fields, and the replying device fills
    in others. The format is as shown in [Table 33-2](ch33s02.html#icmpv_timestamp_and_timestamp_reply_mess
    "Table 33-2. ICMPv4 Timestamp and Timestamp Reply Message Format") and [Figure 33-2](ch33s02.html#icmpv4_timestamp_and_timestamp_rep-id001
    "Figure 33-2. ICMPv4 Timestamp and Timestamp Reply message format").
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv4的*时间戳*和*时间戳回复*消息具有相同的格式。发起设备填写一些字段，而响应设备填写其他字段。格式如[表33-2](ch33s02.html#icmpv_timestamp_and_timestamp_reply_mess
    "表33-2. ICMPv4 时间戳和时间戳回复消息格式")和[图33-2](ch33s02.html#icmpv4_timestamp_and_timestamp_rep-id001
    "图33-2. ICMPv4 时间戳和时间戳回复消息格式")所示。
- en: Table 33-2. ICMPv4 Timestamp and Timestamp Reply Message Format
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 表33-2. ICMPv4 时间戳和时间戳回复消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMP message type. For Timestamp messages, the
    value is 13; for Timestamp Reply messages, the value is 14. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMP消息类型。对于时间戳消息，值为13；对于时间戳回复消息，值为14。 |'
- en: '| Code | 1 | Not used for Timestamp and Timestamp Reply messages; set to 0.
    |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 对于时间戳和时间戳回复消息未使用；设置为0。 |'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP头部（见[第31章](ch31.html "第31章. ICMP 概念和一般操作"））的16位校验和字段。 |'
- en: '| Identifier | 2 | An identification field that can be used to help in matching
    Timestamp and Timestamp Reply messages. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 标识符 | 2 | 一个识别字段，可用于帮助匹配时间戳和时间戳回复消息。 |'
- en: '| Sequence Number | 2 | A sequence number to help in matching Timestamp and
    Timestamp Reply messages. |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| 序列号 | 2 | 一个序列号，用于匹配时间戳和时间戳回复消息。 |'
- en: '| Originate Timestamp | 4 | A time value filled in by the originating device
    just before sending the Timestamp message. |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| 发起时间戳 | 4 | 发起设备在发送时间戳消息之前填写的时间值。 |'
- en: '| Receive Timestamp | 4 | A time value filled in by the responding device just
    as it receives the Timestamp message. |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| 接收时间戳 | 4 | 响应设备在接收到时间戳消息时填写的时间值。 |'
- en: '| Transmit Timestamp | 4 | A time value filled in by the responding device
    just before sending back the Timestamp Reply message. |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 传输时间戳 | 4 | 响应设备在发送时间戳回复消息之前填写的时间值。 |'
- en: The Identifier and Sequence Number fields are used to match Timestamp and Timestamp
    Reply messages, exactly as they are used for Echo and Echo Reply messages. The
    Identifier field is intended as a higher-level label, like a session identifier,
    while the Sequence Number is often used to identify individual messages within
    a series. However, the use of these fields is up to the particular implementation.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符和序列号字段用于匹配时间戳和时间戳回复消息，正如它们用于回显和回显回复消息一样。标识符字段旨在作为高级标签，如会话标识符，而序列号通常用于识别一系列中的单个消息。然而，这些字段的使用取决于特定的实现。
- en: '![ICMPv4 Timestamp and Timestamp Reply message format](httpatomoreillycomsourcenostarchimages287979.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv4 时间戳和时间戳回复消息格式](httpatomoreillycomsourcenostarchimages287979.png)'
- en: Figure 33-2. ICMPv4 Timestamp and Timestamp Reply message format
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图33-2. ICMPv4 时间戳和时间戳回复消息格式
- en: All three timestamps are represented as the number of milliseconds since midnight,
    *Universal Time* (*UT*, also called *Greenwich mean time* or *GMT* ). The reason
    there are three timestamps instead of the two you might ordinarily expect is that
    the responding device records a separate timestamp when it receives the Timestamp
    message and when it generates the Timestamp Reply. When the Reply message is received
    back by the originating device, it then has the times that both the Timestamp
    and the Timestamp Reply messages were sent. This allows the originating device
    to differentiate between the time required for transmitting datagrams over the
    network and the time for the other device to process the Timestamp message and
    turn it into a Timestamp Reply message.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个时间戳都表示自午夜以来的毫秒数，*世界时* (*UT*)（也称为*格林威治平均时间*或*GMT*）。之所以有三个时间戳而不是你通常期望的两个，是因为响应设备在接收到时间戳消息和生成时间戳回复时记录了单独的时间戳。当回复消息被原始设备接收时，它就有了时间戳和时间戳回复消息发送的时间。这使得原始设备能够区分在网络中传输数据报所需的时间和另一设备处理时间戳消息并将其转换为时间戳回复消息所需的时间。
- en: Issues Using Timestamp and Timestamp Reply Messages
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用时间戳和时间戳回复消息的问题
- en: In practice, even with these three timestamp fields, it is difficult to coordinate
    system clocks over an internetwork, especially a large one like the Internet.
    The main problem is that the amount of time it takes to send a datagram between
    any pair of devices varies from one datagram to the next. And again, since IP
    is unreliable, it's possible that the time for a datagram to be received could
    be infinite. In fact, it might be lost or dropped by a router.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，即使有这三个时间戳字段，在互联网（尤其是像互联网这样的大型互联网）上协调系统时钟也很困难。主要问题是发送数据报所需的时间因数据报而异。再次强调，由于IP不可靠，数据报接收的时间可能是无限的。事实上，它可能被路由器丢失或丢弃。
- en: This means that a simple exchange of Timestamp and Timestamp Reply messages
    is simply not a method that's reliable enough to ensure that two devices are synchronized
    on a typical IP internetwork. For this reason, modern devices often use a more
    sophisticated method for time synchronization, such as the Network Time Protocol
    (NTP).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着简单的交换时间戳和时间戳回复消息并不是一个足够可靠的保证，以确保在典型的IP互联网上两个设备同步。因此，现代设备通常使用更复杂的方法进行时间同步，例如网络时间协议（NTP）。
- en: Note that unlike many of the other ICMP message types, support for Timestamp
    and Timestamp Reply messages is optional, for both hosts and routers.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与许多其他ICMP消息类型不同，对时间戳和时间戳回复消息的支持是可选的，对于主机和路由器都是如此。
- en: ICMPv4 Router Advertisement and Router Solicitation Messages
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv4路由器通告和路由器请求消息
- en: 'In [Chapter 23](ch23.html "Chapter 23. IP ROUTING AND MULTICASTING"), which
    described IP routing fundamentals, I discussed a critical aspect of IP internetwork
    design: the difference between the roles of a router and the roles of a host with
    regard to routing. Routers are charged with the job of routing datagrams, and
    therefore, of knowing routes and exchanging route information. Hosts generally
    do not know a great deal about routes; they rely on routers to convey datagrams
    intended for destinations outside the local network.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第23章](ch23.html "第23章。IP路由和多播")中，我讨论了IP互联网设计的关键方面：路由器与主机在路由方面的角色差异。路由器负责路由数据报，因此需要知道路由并交换路由信息。主机通常对路由了解不多；它们依赖路由器来传递发往本地网络外目的地的数据报。
- en: 'This dependence means that before a host can really participate on an internetwork,
    it needs to know the identity of at least one router on the local network. One
    way to ensure that this is the case is to just manually configure each host with
    the address of a local router as its default router. This method is simple, but
    has the typical drawbacks associated with manual processes: It is time-consuming
    to set up, difficult to maintain, and inflexible.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这种依赖性意味着在主机真正参与互联网之前，它需要知道本地网络中至少一个路由器的身份。确保这一点的一种方法是为每个主机手动配置本地路由器的地址作为其默认路由器。这种方法很简单，但具有与手动过程相关的典型缺点：设置耗时，维护困难，缺乏灵活性。
- en: The Router Discovery Process
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器发现过程
- en: It would be better if there were some method whereby a host could automatically
    discover the identity of local routers and learn important information about them.
    In IP, this process is called *Router Discovery* and was first defined in RFC
    1256, "ICMP Router Discovery Messages." The messages referenced in the RFC title
    are the ICMP Router Advertisement message and the Router Solicitation message.
    They were added to the ICMP message types that were defined in earlier standards
    such as RFC 792.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一种方法可以让宿主机自动发现本地路由器的身份并了解它们的重要信息，那就更好了。在IP中，这个过程称为*路由器发现*，最初在RFC 1256，“ICMP路由器发现消息”中定义。RFC标题中引用的消息是ICMP路由器广告消息和路由器请求消息。它们被添加到在较早标准（如RFC
    792）中定义的ICMP消息类型中。
- en: Routers are responsible for sending *Router Advertisement* messages. These messages
    tell listening devices that the router exists, and they provide important information
    about the router such as its address (or addresses, if it has more than one) and
    how long the host should retain information about the router. Routine Router Advertisement
    messages are sent on a regular basis, and an administrator can configure the time
    between messages (usually between seven and ten minutes). Hosts listen for these
    messages; when an advertisement is received, the host processes it and adds the
    information about the router to its routing table.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器负责发送*路由器广告*消息。这些消息告诉监听设备路由器存在，并提供有关路由器的重要信息，例如其地址（或地址，如果它有多个地址）以及宿主机应保留关于路由器信息的时间。常规路由器广告消息定期发送，管理员可以配置消息之间的时间（通常在七到十分钟之间）。宿主机监听这些消息；当收到广告时，宿主机会处理它并将有关路由器的信息添加到其路由表中。
- en: A host that does not have any manually configured routing information will have
    no knowledge of routers when it first powers on. Having it sit for many minutes
    while it looks for a routine Router Advertisement message is inefficient. Instead
    of waiting, the host may send a *Router Solicitation* message on its local network(s).
    This will prompt any router that hears it to immediately send out an extra Router
    Advertisement message directly to that host.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 一台没有手动配置路由信息的宿主机在首次开机时将没有任何关于路由器的知识。让它坐等数分钟以寻找常规的路由器广告消息是不高效的。而不是等待，宿主机可以在其本地网络（s）上发送一个*路由器请求*消息。这将促使任何听到它的路由器立即向该宿主机发送额外的路由器广告消息。
- en: ICMPv4 Router Advertisement Message Format
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv4路由器广告消息格式
- en: The ICMPv4 Router Advertisement message format is shown in [Table 33-3](ch33s03.html#icmpv_router_advertisement_message_forma
    "Table 33-3. ICMPv4 Router Advertisement Message Format") and [Figure 33-3](ch33s03.html#icmpv4_router_advertisement_messag-id001
    "Figure 33-3. ICMPv4 Router Advertisement Message format").
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv4路由器广告消息格式在[表33-3](ch33s03.html#icmpv_router_advertisement_message_forma
    "表33-3. ICMPv4路由器广告消息格式")和[图33-3](ch33s03.html#icmpv4_router_advertisement_messag-id001
    "图33-3. ICMPv4路由器广告消息格式")中显示。
- en: Table 33-3. ICMPv4 Router Advertisement Message Format
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 表33-3. ICMPv4路由器广告消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMP message type. For Router Advertisement messages,
    the value is 9. |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMP消息类型。对于路由器广告消息，值为9。 |'
- en: '| Code | 1 | Normally set to 0\. When a Mobile IP agent is sending a Router
    Advertisement with an Agent Advertisement extension, it may set the value to 16
    only if the device is a mobile agent and doesn''t intend to handle normal traffic.
    See the discussion of Mobile IP agent discovery for details ([Chapter 30](ch30.html
    "Chapter 30. INTERNET PROTOCOL MOBILITY SUPPORT (MOBILE IP)")). |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| Code | 1 | 通常设置为0。当一个移动IP代理发送带有代理广告扩展的路由器广告时，只有当设备是移动代理且不打算处理正常流量时，它才可以将值设置为16。有关移动IP代理发现的讨论，请参阅[第30章](ch30.html
    "第30章。互联网协议移动支持（移动IP）")的详细信息。 |'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP头部的一个16位校验和字段（见[第31章](ch31.html "第31章。ICMP概念和一般操作")）。 |'
- en: '| Num Addrs | 1 | The number of addresses associated with this router that
    are included in this advertisement. |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| 地址数量 | 1 | 包含在此广告中的与此路由器关联的地址数量。 |'
- en: '| Addr Entry Size | 1 | The address entry size—number of 32-bit words of information
    included with each address. Since in this message format each router address has
    a 32-bit address and a 32-bit preference level, this value is fixed at 2. |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| 地址条目大小 | 1 | 地址条目大小——每个地址包含的信息的32位字数。由于在此消息格式中，每个路由器地址都有一个32位的地址和一个32位的优先级级别，因此此值固定为2。|'
- en: '| Lifetime | 2 | The number of seconds that a host should consider the information
    in this message valid. |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| 生存时间 | 2 | 主机应认为此消息中的信息有效的秒数。|'
- en: '| Router Address Entries | Value of Num Addrs field * 8 | A number of router
    address entries equal to the value of the Num Addrs field. Each is 8 bytes and
    has two subfields, each 4 bytes in size. The Router Address subfield is a valid
    address for an interface to the router sending this message. The Preference Level
    subfield is the preference level of this address. When more than one address is
    included in an advertisement, this field indicates which address the router would
    prefer hosts to use. Higher values mean greater preference. |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 路由器地址条目 | Num Addrs字段值 * 8 | 路由器地址条目数量等于Num Addrs字段值。每个条目为8字节，包含两个子字段，每个子字段大小为4字节。路由器地址子字段是发送此消息的路由器接口的有效地址。优先级级别子字段是该地址的优先级级别。当广告中包含多个地址时，此字段指示路由器希望主机使用的地址。值越大表示优先级越高。|'
- en: '![ICMPv4 Router Advertisement Message format](httpatomoreillycomsourcenostarchimages287981.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv4路由器通告消息格式](httpatomoreillycomsourcenostarchimages287981.png)'
- en: Figure 33-3. ICMPv4 Router Advertisement Message format
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图33-3. ICMPv4路由器通告消息格式
- en: ICMPv4 Router Solicitation Message Format
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv4路由器请求消息格式
- en: 'ICMPv4 Router Solicitation messages are much simpler, because they need to
    convey only the following single piece of information: "If you are a router and
    can hear this, please send a Router Advertisement to me." The format is therefore
    just the trivial set of fields shown in [Table 33-4](ch33s03.html#icmpv_router_solicitation_message_format
    "Table 33-4. ICMPv4 Router Solicitation Message Format") and illustrated in [Figure 33-4](ch33s03.html#icmpv4_router_solicitation_message-id001
    "Figure 33-4. ICMPv4 Router Solicitation Message format").'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv4路由器请求消息非常简单，因为它们只需要传达以下单一信息：“如果你是路由器并且可以听到这个，请向我发送路由器通告。”因此，格式只是[表33-4](ch33s03.html#icmpv_router_solicitation_message_format
    "表33-4. ICMPv4路由器请求消息格式")中显示的平凡字段集，并在[图33-4](ch33s03.html#icmpv4_router_solicitation_message-id001
    "图33-4. ICMPv4路由器请求消息格式")中说明。
- en: Table 33-4. ICMPv4 Router Solicitation Message Format
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 表33-4. ICMPv4路由器请求消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMP message type. For Router Solicitation messages,
    the value is 10. |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMP消息类型。对于路由器请求消息，值为10。|'
- en: '| Code | 1 | Not used; value set to 0. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 未使用；值设置为0。|'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP头部（见[第31章](ch31.html "第31章. ICMP概念和一般操作"））的16位校验和字段。|'
- en: '| Reserved | 4 | The 4 reserved bytes sent as 0. |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 4 | 发送作为0的4个保留字节。|'
- en: '![ICMPv4 Router Solicitation Message format](httpatomoreillycomsourcenostarchimages287983.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv4路由器请求消息格式](httpatomoreillycomsourcenostarchimages287983.png)'
- en: Figure 33-4. ICMPv4 Router Solicitation Message format
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图33-4. ICMPv4路由器请求消息格式
- en: Addressing and Use of Router Advertisement and Router Solicitation Messages
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器通告和路由器请求消息的寻址和使用
- en: If possible, both Router Advertisement and Router Solicitation messages are
    sent out as multicast for efficiency. Router Advertisements use the "all devices"
    multicast address (224.0.0.1), because they are intended for hosts to hear. *Router
    Solicitation* messages use the "all routers" multicast address (224.0.0.2). If
    the local network does not support multicast, messages are instead sent out by
    broadcast (to address 255.255.255.255).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，路由器通告和路由器请求消息都作为多播发送以提高效率。路由器通告使用“所有设备”多播地址（224.0.0.1），因为它们是针对主机接收的。*路由器请求*消息使用“所有路由器”多播地址（224.0.0.2）。如果本地网络不支持多播，则消息将通过广播（发送到地址255.255.255.255）发送。
- en: It is important to remember that just like ICMP Redirect messages, Router Advertisement
    messages are not a generalized method for exchanging routing information. They
    are a support mechanism only, used to inform hosts about the existence of routers.
    Detailed information about routes is communicated between routers using routing
    protocols, like the Routing Information Protocol (RIP) and Open Shortest Path
    First (OSPF).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，就像 ICMP 重定向消息一样，路由器通告消息不是交换路由信息的通用方法。它们仅是一个支持机制，用于通知主机关于路由器的存在。路由器之间使用路由协议（如路由信息协议（RIP）和开放最短路径优先（OSPF））来交换关于路由的详细信息。
- en: Although Router Discovery is one alternative to manual configuration of a host's
    default router, there are other alternatives as well. For example, a host configuration
    protocol like the Dynamic Host Configuration Protocol (DHCP) can allow a host
    to learn the address of a default router on the local network.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然路由器发现是手动配置主机默认路由器的一种替代方案，但还有其他替代方案。例如，像动态主机配置协议（DHCP）这样的主机配置协议可以使主机学习到本地网络中默认路由器的地址。
- en: Finally, note that when Mobile IP is implemented, Router Advertisement messages
    are used as the basis for Mobile IP–aware routers to send Agent Advertisements.
    One or more special extensions are added to the regular Router Advertisement format
    to create an Agent Advertisement. This is discussed extensively in the section
    on Mobile IP Agent Discovery in [Chapter 31](ch31.html "Chapter 31. ICMP CONCEPTS
    AND GENERAL OPERATION").
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，当实现移动 IP 时，路由器通告消息被用作移动 IP 意识路由器发送代理通告的基础。在常规路由器通告格式中添加了一个或多个特殊扩展来创建代理通告。这在第
    31 章（[第 31 章. ICMP 概念和一般操作](ch31.html "第 31 章. ICMP 概念和一般操作")）中关于移动 IP 代理发现的章节中进行了详细讨论。
- en: Tip
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** ICMP *Router Advertisement* messages are sent regularly by
    IP routers to inform hosts of their presence and characteristics. This way, hosts
    know to use them for delivery of datagrams to distant hosts. A host that is new
    to a network and wants to find out immediately what routers are present may send
    a *Router Solicitation* message, which will prompt listening routers to send out
    Router Advertisement messages.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ICMP *路由器通告* 消息由 IP 路由器定期发送，以通知主机其存在和特性。这样，主机就知道使用它们将数据报文发送到远程主机。一个新加入网络并希望立即了解现有路由器的主机可以发送一个
    *路由器请求* 消息，这将促使监听路由器发送路由器通告消息。'
- en: ICMPv4 Address Mask Request and Reply Messages
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv4 地址掩码请求和回复消息
- en: When IP was first developed, IP addresses were based on a simple two-level structure,
    with a network identifier (network ID) and host identifier (host ID). To provide
    more flexibility, a technique called *subnetting* was soon developed. Subnetting
    expands the addressing scheme into a three-level structure, with each address
    containing a network ID, subnet identifier, and host ID. The *subnet mask* is
    a 32-bit number that tells devices (and users) which bits are part of the subnet
    identifier, as compared to the host ID. All of this is described in considerable
    detail in the part on IP addressing ([Part II-3](pt06.html "Part II-3. INTERNET
    PROTOCOL VERSION 4 (IP/IPV4)")).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 当 IP 首次开发时，IP 地址基于简单的两级结构，包括网络标识符（网络 ID）和主机标识符（主机 ID）。为了提供更多灵活性，很快开发了一种称为 *子网划分*
    的技术。子网划分将寻址方案扩展为三级结构，每个地址包含网络 ID、子网标识符和主机 ID。*子网掩码* 是一个 32 位数字，告诉设备（和用户）哪些位是子网标识符的一部分，与主机
    ID 相比。所有这些都在 IP 寻址部分（[第二部分-3](pt06.html "第二部分-3. 互联网协议版本 4 (IP/IPV4)")）中进行了详细描述。
- en: To function properly in a subnetting environment, each host must know the subnet
    mask that corresponds to each address it is assigned. Without the mask, it cannot
    properly interpret IP addresses. Just as in determining the identity of a local
    router, a host can be informed of the local network's subnet mask either manually
    or automatically. The manual method is to simply manually assign the subnet mask
    to each host. The automatic method makes use of a pair of ICMP messages designed
    for subnet mask determination, which were defined in RFC 950, the same standard
    that defined subnetting itself.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在子网环境中正常工作，每个主机都必须知道与其分配的每个地址相对应的子网掩码。没有掩码，它无法正确解释 IP 地址。正如在确定本地路由器身份时，主机可以通过手动或自动方式得知本地网络的子网掩码。手动方法是将子网掩码手动分配给每个主机。自动方法利用了一对用于确定子网掩码的
    ICMP 消息，这些消息在 RFC 950 中定义，该标准本身也定义了子网划分。
- en: To use this method, a host sends an *Address Mask Request* message on the local
    network, usually to get a response from a router. If it knows the address of a
    local router, it may send the request directly (unicast); otherwise, the host
    will broadcast the request to any listening router. A local router (or other device)
    will receive this message and respond back with an *Address Mask Reply* message
    that contains the subnet mask for the local network. This process is somewhat
    similar to the mechanism used by a host to solicit a router to respond with a
    Router Advertisement message, except that routers do not routinely send subnet
    mask information—that information must be requested.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此方法，主机在本地网络上发送一个*地址掩码请求*消息，通常是为了从路由器获取响应。如果它知道本地路由器的地址，它可以直接发送请求（单播）；否则，主机将广播请求到任何监听的路由器。本地路由器（或其他设备）将接收此消息，并回复一个包含本地网络子网掩码的*地址掩码回复*消息。这个过程与主机用于请求路由器响应路由器通告消息的机制类似，但路由器不会定期发送子网掩码信息——该信息必须被请求。
- en: ICMPv4 Address Mask Request and Address Mask Reply Message Format
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv4地址掩码请求和地址掩码回复消息格式
- en: The Address Mask Request and Address Mask Reply, like some other request and
    reply pairs, have the same basic format. The host creates the request with all
    fields filled in except for the subnet mask value itself, and the router supplies
    the mask and sends the reply back to the host. The format is described in [Table 33-5](ch33s04.html#icmpv_address_mask_request_and_address_m
    "Table 33-5. ICMPv4 Address Mask Request and Address Mask Reply Message Format")
    and illustrated in [Figure 33-5](ch33s04.html#icmpv4_address_mask_request_and_ad-id001
    "Figure 33-5. ICMPv4 Address Mask Request and Address Mask Reply message format").
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 地址掩码请求和地址掩码回复，就像其他一些请求和回复对一样，具有相同的基本格式。主机创建请求时，除了子网掩码值本身外，所有字段都已填写，路由器提供掩码并发送回复回主机。格式在[表33-5](ch33s04.html#icmpv_address_mask_request_and_address_m
    "表33-5. ICMPv4地址掩码请求和地址掩码回复消息格式")中描述，并在[图33-5](ch33s04.html#icmpv4_address_mask_request_and_ad-id001
    "图33-5. ICMPv4地址掩码请求和地址掩码回复消息格式")中展示。
- en: Table 33-5. ICMPv4 Address Mask Request and Address Mask Reply Message Format
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 表33-5. ICMPv4地址掩码请求和地址掩码回复消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMP message type. For Address Mask Request messages,
    the value is 17; for Address Mask Reply messages, it is 18. |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMP消息类型。对于地址掩码请求消息，值为17；对于地址掩码回复消息，值为18。|'
- en: '| Code | 1 | Not used for either message type; set to 0. |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 不用于任何消息类型；设置为0。|'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | 用于ICMP头的16位校验和字段（见[第31章](ch31.html "第31章. ICMP概念和一般操作"））。|'
- en: '| Identifier | 2 | An identification field that can be used to help in matching
    Address Mask Request and Address Mask Reply messages. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| 标识符 | 2 | 一个标识字段，可用于帮助匹配地址掩码请求和地址掩码回复消息。|'
- en: '| Sequence Number | 2 | A sequence number to help in matching Address Mask
    Request and Address Mask Reply messages. |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| 序列号 | 2 | 一个序列号，用于帮助匹配地址掩码请求和地址掩码回复消息。|'
- en: '| Address Mask | 4 | The subnet mask for the local network, filled in by the
    router in the Address Mask Reply message. |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| 地址掩码 | 4 | 本地网络的子网掩码，由地址掩码回复消息中的路由器填写。|'
- en: '![ICMPv4 Address Mask Request and Address Mask Reply message format](httpatomoreillycomsourcenostarchimages287985.png.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv4地址掩码请求和地址掩码回复消息格式](httpatomoreillycomsourcenostarchimages287985.png.jpg)'
- en: Figure 33-5. ICMPv4 Address Mask Request and Address Mask Reply message format
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 图33-5. ICMPv4地址掩码请求和地址掩码回复消息格式
- en: The Identifier and Sequence Number fields can be used to match up requests and
    replies, as they are for Echo and Echo Reply messages. However, a host won't normally
    send multiple requests for subnet masks the way it might send Echo messages for
    testing. For this reason, the Identifier and Sequence Number fields may be ignored
    by some implementations.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符和序列号字段可以用来匹配请求和回复，因为它们用于回声和回声回复消息。然而，主机通常不会像发送用于测试的回声消息那样发送多个地址掩码请求。因此，标识符和序列号字段可能被某些实现忽略。
- en: Use of Address Mask Request and Address Mask Reply Messages
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用地址掩码请求和地址掩码回复消息
- en: Note that the use of Address Mask Request and Address Mask Reply messages is
    optional, just as the Router Discovery described in the previous section is. Other
    methods besides these messages or manual configuration may be used to tell a host
    what subnet mask to use. Again, a common alternative to ICMP for this is to use
    a host configuration protocol like DHCP. Routers do need to be able to respond
    to Address Mask Requests for hosts that choose to send them.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用地址掩码请求和地址掩码应答消息是可选的，就像上一节中描述的路由器发现一样。除了这些消息或手动配置之外，还可以使用其他方法来告诉主机使用哪个子网掩码。同样，对于这种情况，ICMP的一个常见替代方案是使用主机配置协议，如DHCP。路由器确实需要能够对选择发送地址掩码请求的主机的地址掩码请求做出响应。
- en: ICMPv4 Traceroute Messages
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv4 Traceroute 消息
- en: 'The Echo and Echo Reply messages you saw earlier in this chapter are used for
    the most basic type of test that can be conducted between two devices: checking
    if they can communicate. A more sophisticated test can also be performed in order
    to see not only if the devices are able to talk, but also to discover the exact
    sequence of routers used to move datagrams between them. In TCP/IP, this diagnostic
    is performed using the traceroute (or tracert) utility.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面看到的回声和回声应答消息用于在两个设备之间进行的最基本的测试：检查它们是否可以通信。还可以进行更复杂的测试，不仅可以看到设备是否能够通信，还可以发现用于在它们之间移动数据报的确切路由器序列。在TCP/IP中，这种诊断是通过traceroute（或tracert）实用程序来执行的。
- en: The first implementation of *traceroute* used a clever application of Time Exceeded
    error messages, as described in the previous chapter. By sending a test message
    to a destination first with a Time to Live (TTL) value of 1, then 2, then 3, and
    so on, each router in the path between the source and destination would successively
    discard the test messages and send back a Time Exceeded message. Each router would
    then display the sequence of routers between the two hosts. This bit of trickery
    works well enough in general terms, but is suboptimal in a couple of respects.
    For example, it requires the source device to send one test message for each router
    in the path, instead of just a single test message. It also doesn't take into
    account the possibility that the path between two devices may change during the
    test.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '*traceroute*的第一个实现使用了一种巧妙的时间超限错误消息的应用，如前一章所述。通过首先向目的地发送一个TTL值为1的测试消息，然后是2，然后是3，依此类推，源和目的地之间的每个路由器都会依次丢弃测试消息并发送回时间超限消息。然后每个路由器会显示两个主机之间的路由器序列。这种小技巧在一般意义上效果很好，但在几个方面都不是最优的。例如，它要求源设备为路径中的每个路由器发送一个测试消息，而不是只发送一个测试消息。它也没有考虑到两个设备之间的路径在测试期间可能发生变化的可能性。'
- en: 'Recognizing these limitations, a new experimental standard was developed in
    1993 that defined a more efficient way to conduct a traceroute: RFC 1393, "Traceroute
    Using an IP Option." As the title suggests, this method of doing a traceroute
    works by having the source device send a single datagram to the destination that
    contains a special Traceroute IP option. Each router that sees that option while
    the test message is conducted along the route responds back to the original source
    with an ICMP Traceroute message, which is also defined in RFC 1393.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 认识到这些限制后，1993年开发了一个新的实验性标准，定义了进行traceroute的更有效的方法：RFC 1393，“使用IP选项的traceroute”。正如标题所暗示的，这种进行traceroute的方法是通过源设备向目的地发送包含特殊Traceroute
    IP选项的单个数据报来实现的。在测试消息沿路由进行的过程中，每个看到该选项的路由器都会向原始源发送ICMP Traceroute消息，该消息也在RFC 1393中定义。
- en: ICMPv4 Traceroute Message Format
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv4 Traceroute 消息格式
- en: Since the *Traceroute* message was specifically designed for the traceroute
    utility, it was possible to incorporate extra information in it that a host tracing
    a route could use. The message format is as shown in [Table 33-6](ch33s05.html#icmpv_traceroute_message_format
    "Table 33-6. ICMPv4 Traceroute Message Format") and [Figure 33-6](ch33s05.html#icmpv4_traceroute_message_format-id001
    "Figure 33-6. ICMPv4 Traceroute message format").
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*Traceroute*消息是专门为traceroute实用程序设计的，因此可以在其中包含额外的信息，以便路由追踪的主机可以使用。消息格式如[表33-6](ch33s05.html#icmpv_traceroute_message_format
    "表33-6. ICMPv4 Traceroute 消息格式")和[图33-6](ch33s05.html#icmpv4_traceroute_message_format-id001
    "图33-6. ICMPv4 Traceroute 消息格式")所示。
- en: Table 33-6. ICMPv4 Traceroute Message Format
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 表33-6. ICMPv4 Traceroute 消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMP message type; in this case, 30. |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMP消息类型；在这种情况下，为30。|'
- en: '| Code | 1 | Set to the value 0 if the datagram the source device sent was
    successfully sent to the next router, or 1 to indicate that the datagram was dropped
    (meaning the traceroute failed). |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| 状态码 | 1 | 如果源设备发送的数据报成功发送到下一个路由器，则设置为0，或者设置为1以指示数据报被丢弃（意味着traceroute失败）。
    |'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP头部的一个16位校验和字段（见[第31章](ch31.html "第31章. ICMP概念和一般操作")）。 |'
- en: '| ID Number | 2 | An identification field used to match up this Traceroute
    message to the original message sent by the source (the one containing the Traceroute
    IP option). |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| ID号 | 2 | 一个标识字段，用于将此Traceroute消息与源端发送的原始消息（包含Traceroute IP选项的消息）匹配。 |'
- en: '| Unused | 2 | Not used, set to 0. |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| 未使用 | 2 | 未使用，设置为0。 |'
- en: '| Outbound Hop Count | 2 | The number of routers the original message has already
    passed through. |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| 输出跳数 | 2 | 原始消息已经经过的路由器数量。 |'
- en: '| Return Hop Count | 2 | The number of routers the return message has passed
    through. |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| 返回跳数 | 2 | 返回消息经过的路由器数量。 |'
- en: '| Output Link Speed | 4 | The speed of the link over which the Traceroute message
    is being sent, in bytes per second. |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| 输出链路速度 | 4 | Traceroute消息正在发送的链路速度，以每秒字节数表示。 |'
- en: '| Output Link MTU | 4 | The maximum transmission unit (MTU) of the link over
    which the Traceroute message is being sent, in bytes. |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| 输出链路MTU | 4 | Traceroute消息正在发送的链路的最大传输单元（MTU），以字节为单位。 |'
- en: '![ICMPv4 Traceroute message format](httpatomoreillycomsourcenostarchimages287987.png)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv4 Traceroute消息格式](http://atomoreilly.com/source/nostarch/images/287987.png)'
- en: Figure 33-6. ICMPv4 Traceroute message format
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 图33-6. ICMPv4 Traceroute消息格式
- en: Use of Traceroute Messages
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Traceroute消息的使用
- en: 'Although this method of implementing traceroute has advantages over the older
    Time Exceeded messages method, it has one critical flaw as well: It requires changes
    to both hosts and routers to support the new IP option and the Traceroute ICMP
    message. People aren''t big on change, especially when it comes to the basic operation
    of IP. For this reason, RFC 1393 never moved beyond experimental status, and most
    IP devices still use the older method of implementing traceroute. It is possible
    that you may encounter ICMP Traceroute messages, however, so it''s good that you
    know they exist.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种实现traceroute的方法比旧的Time Exceeded消息方法有优势，但它也存在一个关键缺陷：它需要修改主机和路由器以支持新的IP选项和Traceroute
    ICMP消息。人们并不热衷于改变，尤其是当涉及到IP的基本操作时。因此，RFC 1393从未超出实验状态，大多数IP设备仍然使用旧的traceroute实现方法。然而，你可能会遇到ICMP
    Traceroute消息，所以了解它们的存在是好的。
- en: Tip
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** ICMP *Traceroute* messages were designed to provide a more
    capable way of implementing the traceroute (tracert) utility. However, most TCP/IP
    implementations still use ICMP Time Exceeded messages for this task.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ICMP *Traceroute*消息被设计为提供一种更强大的实现traceroute（tracert）工具的方法。然而，大多数TCP/IP实现仍然使用ICMP
    Time Exceeded消息来完成这项任务。'
- en: Chapter 34. ICMPV6 ERROR MESSAGE TYPES AND FORMATS
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第34章. ICMPV6错误消息类型和格式
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](http://atomoreilly.com/source/nostarch/images/287681.png.jpg)'
- en: 'The original Internet Control Message Protocol (ICMP) defined for version 4
    of the Internet Protocol (IPv4) has a number of error messages that allow for
    the communication of problems on an internetwork. When IP version 6 (IPv6) was
    developed, the differences between IPv4 and IPv6 were significant enough that
    a new version of ICMP was also required: version 6 *(ICMPv6)*, which is currently
    specified in RFC 2463\. Like ICMPv4, ICMPv6 defines several error messages for
    informing a source that something has gone wrong.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 为互联网协议第四版（IPv4）定义的原始互联网控制消息协议（ICMP）包含多个错误消息，允许在互联网内部进行问题通信。当开发IP版本6（IPv6）时，IPv4和IPv6之间的差异足够大，以至于还需要一个新的ICMP版本：版本6
    *(ICMPv6)*，它目前由RFC 2463指定。与ICMPv4一样，ICMPv6定义了多个错误消息，用于通知源端出现了一些问题。
- en: In this chapter, I describe the four ICMPv6 error messages defined in RFC 2463\.
    I first discuss ICMPv6 Destination Unreachable messages, which are used to tell
    a device that the datagram it sent could not be delivered for a variety of reasons.
    I describe Packet Too Big error messages, which are sent when a datagram can't
    be sent due to being too large for an underlying network it needs to traverse.
    I explain the use of Time Exceeded messages, which indicate that too much time
    was taken to accomplish a transmission. I conclude with a look at Parameter Problem
    messages, which provide a generalized way of reporting errors that are not described
    by any of the preceding ICMPv6 error message types.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了RFC 2463中定义的四个ICMPv6错误消息。我首先讨论ICMPv6目的地不可达消息，这些消息用于告知设备它发送的数据报由于各种原因无法交付。我描述了数据包过大错误消息，当数据报因为太大而无法通过它需要穿越的底层网络时，会发送这些消息。我解释了时间超时消息的使用，这些消息表明完成传输花费了太多时间。最后，我审视了参数问题消息，这些消息提供了一种通用的方式来报告前述任何ICMPv6错误消息类型未描述的错误。
- en: Note
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Three of the four ICMPv6 error messages (all except Packet Too Big) are equivalent
    to the ICMPv4 error messages that have the same names. However, to allow this
    chapter to stand on its own, I describe each one fully, in addition to pointing
    out any significant differences between the ICMPv4 and ICMPv6 version of the message*.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '*四个ICMPv6错误消息中的三个（除了数据包过大之外的所有消息）与具有相同名称的ICMPv4错误消息等效。然而，为了使本章能够独立存在，我详细描述了每一个，并指出了ICMPv4和ICMPv6消息版本之间的任何重大差异*。'
- en: ICMPv6 Destination Unreachable Messages
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv6 目的地不可达消息
- en: IPv6 includes some important enhancements over the older version 4, but the
    basic operation of the two protocols is still fundamentally the same. Like IPv4,
    IPv6 is an unreliable network protocol that makes a best effort to deliver datagrams,
    but offers no guarantees that they will always get there. Just as they did in
    IPv4, devices on an IPv6 network must not assume that datagrams sent to a destination
    will always be received.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6在较旧版本4上包含一些重要增强，但两种协议的基本操作仍然本质上是相同的。与IPv4一样，IPv6是一个不可靠的网络协议，它尽力交付数据报，但并不保证它们总能到达。正如它们在IPv4中所做的那样，IPv6网络上的设备不能假设发送到目的地的数据报总会被接收。
- en: When a datagram cannot be delivered, recovery from this condition normally falls
    to higher-layer protocols like the Transmission Control Protocol (TCP), which
    will detect the miscommunication and resend the lost datagrams. In some situations,
    such as a datagram that was dropped due to the congestion of a router, this is
    sufficient, but in other cases, a datagram may not be delivered due to an inherent
    problem with how it is being sent. For example, the source may have specified
    an invalid destination address, which means that even if it were resent many times,
    the datagram would never get to its intended recipient.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据报无法交付时，从这种状态中恢复通常落在传输控制协议（TCP）等高层协议上，这些协议将检测到通信错误并重新发送丢失的数据报。在某些情况下，例如由于路由器拥塞而丢弃的数据报，这可能足够了，但在其他情况下，数据报可能因为发送方式本身存在固有问题而无法交付。例如，源可能指定了一个无效的目的地址，这意味着即使重发多次，数据报也永远不会到达预期的接收者。
- en: In general, having the source just resend undelivered datagrams while having
    no idea why they were lost is inefficient. It is better to have a feedback mechanism
    that can tell a source device about undeliverable datagrams and provide some information
    about why the datagram delivery failed. As in ICMPv4, in ICMPv6 this is done with
    *Destination Unreachable* messages. Each message includes a code that indicates
    the basic nature of the problem that caused the datagram not to be delivered,
    as well as all or part of the datagram that was undelivered in order to help the
    source device diagnose the problem.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果源只知道重新发送未交付的数据报而不知道它们丢失的原因，这是低效的。更好的是有一个反馈机制，可以告知源设备关于无法交付的数据报，并提供一些关于数据报交付失败原因的信息。与ICMPv4一样，在ICMPv6中，这是通过*目的地不可达*消息来完成的。每个消息都包含一个代码，指示导致数据报无法交付的基本问题性质，以及未交付的数据报的全部或部分，以帮助源设备诊断问题。
- en: ICMPv6 Destination Unreachable Message Format
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv6 目的地不可达消息格式
- en: '[Table 34-1](ch34.html#icmpv_destination_unreachable_mess-id001 "Table 34-1. ICMPv6
    Destination Unreachable Message Format") and [Figure 34-1](ch34.html#icmpv6_destination_unreachable_mes-id001
    "Figure 34-1. ICMPv6 Destination Unreachable message format") show the specific
    format for ICMPv6 Destination Unreachable messages.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 34-1](ch34.html#icmpv_destination_unreachable_mess-id001 "表 34-1. ICMPv6
    目的地不可达消息格式")和[图 34-1](ch34.html#icmpv6_destination_unreachable_mes-id001 "图 34-1.
    ICMPv6 目的地不可达消息格式")显示了 ICMPv6 目的地不可达消息的具体格式。'
- en: '![ICMPv6 Destination Unreachable message format](httpatomoreillycomsourcenostarchimages287989.png.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6 目的地不可达消息格式](httpatomoreillycomsourcenostarchimages287989.png.jpg)'
- en: Figure 34-1. ICMPv6 Destination Unreachable message format
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 图 34-1. ICMPv6 目的地不可达消息格式
- en: Table 34-1. ICMPv6 Destination Unreachable Message Format
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 表 34-1. ICMPv6 目的地不可达消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Destination Unreachable
    messages, this is set to 1. |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| Type | 1 | 标识 ICMPv6 消息类型；对于目的地不可达消息，此值设置为 1。 |'
- en: '| Code | 1 | Identifies the subtype of unreachable errors that are being communicated.
    See [Table 32-2](ch32.html#icmpv_destination_unreachable_message_su "Table 32-2. ICMPv4
    Destination Unreachable Message Subtypes") for a full list of codes and what they
    mean. |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| Code | 1 | 标识正在通信的不可达错误子类型。请参阅[表 32-2](ch32.html#icmpv_destination_unreachable_message_su
    "表 32-2. ICMPv4 目的地不可达消息子类型")以获取完整代码列表及其含义。 |'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP 头部的 16 位校验和字段（见[第 31 章](ch31.html "第 31 章. ICMP 概念和一般操作"））。
    |'
- en: '| Unused | 4 | The 4 bytes that are left blank and not used. |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| 未使用 | 4 | 剩余的 4 个字节留空，不使用。 |'
- en: '| Original Datagram Portion | Variable | As much of the IPv6 datagram as will
    fit without causing the size of the ICMPv6 error message (including its own IP
    header) to exceed the minimum IPv6 maximum transmission unit (MTU) of 1280 bytes.
    |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| 原始数据报部分 | 可变 | IPv6 数据报的尽可能多的部分，但不会导致 ICMPv6 错误消息（包括其自己的 IP 头部）的大小超过最小 IPv6
    最大传输单元（MTU）1280 字节。 |'
- en: ICMPv6 Destination Unreachable Message Subtypes
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv6 目的地不可达消息子类型
- en: There are a number of different reasons why a destination may be unreachable.
    To provide additional information about the nature of the problem to the device
    that originally tried to send the datagram, a value is placed in the message's
    Code field. One interesting difference between ICMPv4 and ICMPv6 Destination Unreachable
    messages is that there are many fewer Code values for ICMPv6\. The ICMPv6 Code
    values were streamlined, mainly because several of the ICMPv4 codes were related
    to relatively obscure features that aren't applicable to ICMPv6.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的原因可能导致目的地不可达。为了向最初尝试发送数据报的设备提供有关问题性质的额外信息，消息的代码字段中放置了一个值。ICMPv4 和 ICMPv6
    目的地不可达消息之间一个有趣的不同之处在于，ICMPv6 的代码值要少得多。ICMPv6 代码值被精简了，主要是因为几个 ICMPv4 代码与相对不为人知的特性相关，这些特性不适用于
    ICMPv6。
- en: '[Table 34-2](ch34.html#icmpv_destination_unreachable_mess-id002 "Table 34-2. ICMPv6
    Destination Unreachable Message Subtypes") shows the different Code values, corresponding
    message subtypes, and a brief explanation of each.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 34-2](ch34.html#icmpv_destination_unreachable_mess-id002 "表 34-2. ICMPv6
    目的地不可达消息子类型")显示了不同的代码值、相应的消息子类型以及每个子类型的简要说明。'
- en: Table 34-2. ICMPv6 Destination Unreachable Message Subtypes
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 表 34-2. ICMPv6 目的地不可达消息子类型
- en: '| Code Value | Message Subtype | Description |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| 代码值 | 消息子类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | No Route to Destination | The datagram was not delivered because it could
    not be routed to the destination. Since this means that the datagram could not
    be sent to the destination device''s local network, this is basically equivalent
    to the Network Unreachable message subtype in ICMPv4. |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 无路由到目的地 | 数据报无法投递，因为它无法路由到目的地。由于这意味着数据报无法发送到目的地设备的本地网络，这基本上等同于 ICMPv4
    中的网络不可达消息子类型。 |'
- en: '| 1 | Communication with Destination Administratively Prohibited | The datagram
    could not be forwarded due to filtering that blocks the message based on its contents.
    Equivalent to the message subtype with the same name (and *Code* value 13) in
    ICMPv4. |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 由于基于内容过滤而禁止与目的地通信 | 由于基于内容过滤而阻止消息转发。等同于 ICMPv4 中具有相同名称（和 *Code* 值 13）的消息子类型。
    |'
- en: '| 3 | Address Unreachable | There was a problem attempting to deliver the datagram
    to the host specified in the destination address. This code is equivalent to the
    ICMPv4 Host Unreachable code and usually means that the destination address was
    bad or that there was a problem with resolving it into a layer 2 address. |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 地址不可达 | 尝试将数据报交付到目标地址中指定的主机时出现了问题。此代码等同于 ICMPv4 主机不可达代码，通常意味着目标地址不正确或解析成层
    2 地址时存在问题。|'
- en: '| 4 | Port Unreachable | The destination port specified in the UDP or TCP header
    was invalid or does not exist on the destination host. |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 端口不可达 | UDP 或 TCP 报头中指定的目标端口无效或不存在于目标主机上。|'
- en: Note that Code value 2 is not used. Also, Destination Unreachable messages are
    sent only when there is a fundamental problem with delivering a particular datagram;
    they are not sent when a datagram is dropped simply due to congestion of a router.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码值 2 未使用。此外，仅在交付特定数据报存在基本问题时才会发送目标不可达消息；当数据报因路由器拥塞而丢弃时，不会发送这些消息。
- en: Processing of Destination Unreachable Messages
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理目标不可达消息
- en: It is up to the recipient of an ICMPv6 Destination Unreachable message to decide
    what to do with it. However, just as the original datagram may not reach its destination,
    the Destination Unreachable message may do the same. Therefore, a device cannot
    rely on the receipt of one of these error messages to inform it of every delivery
    problem. This is especially true given that it is possible that some unreachable
    destination problems may not be detectable.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6 目标不可达消息的接收者需要决定如何处理它。然而，就像原始数据报可能无法到达其目的地一样，目标不可达消息也可能如此。因此，设备不能依赖于接收这些错误消息中的任何一个来通知它每个交付问题。考虑到可能存在一些不可达的目标问题无法检测到，这一点尤其正确。
- en: Tip
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** ICMPv6 *Destination Unreachable* messages are used in the same
    manner as the ICMPv4 Destination Unreachable messages: to inform a sending device
    of a failure to deliver an IP datagram. The message''s Code field provides information
    about the nature of the delivery problem (though the Code values are different
    from those in ICMPv4).'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ICMPv6 的 *目标不可达* 消息与 ICMPv4 的目标不可达消息以相同的方式使用：用于通知发送设备无法交付 IP 数据报。消息的代码字段提供了有关交付问题性质的信息（尽管代码值与
    ICMPv4 中的不同）。'
- en: ICMPv6 Packet Too Big Messages
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv6 数据包过大消息
- en: One of the most interesting changes made to the operation of IP in version 6
    is related to the process of datagram fragmentation and reassembly. In IPv4, a
    host can send a datagram of any size that's allowed by the IP specification out
    onto the internetwork. If a router needs to send the datagram over a physical
    link that has a maximum transmission unit (MTU) size that is too small for the
    size of the datagram, it will automatically fragment the datagram and send the
    fragments individually so they will fit. The destination device will receive the
    fragments and reassemble them. I explain the basics behind this in [Chapter 22](ch22.html
    "Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY").
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 6 中对 IP 操作所做的最有趣的变化之一与数据报分片和重组过程有关。在 IPv4 中，主机可以发送任何允许的 IP 规范大小的数据报到互联网。如果路由器需要通过最大传输单元（MTU）大小小于数据报大小的物理链路发送数据报，它将自动分片数据报并单独发送这些片段，以便它们可以适应。目标设备将接收这些片段并将它们重新组装。我在
    [第 22 章](ch22.html "第 22 章。IP 数据报大小、分片和重组") 中解释了这一过程的基本原理。
- en: Even though it is convenient for hosts to be able to rely on routers to automatically
    fragment messages as needed, it is inefficient for routers to spend time doing
    this. For this reason, in IPv6 developers made the decision to not allow routers
    to fragment datagrams. This puts the responsibility on each host to ensure that
    the datagrams they send out are small enough to fit over every physical network
    between itself and any destination. This is done either by using the IPv6 default
    minimum MTU of 1280, which every physical link must support, or a special Path
    MTU Discovery process for determining the minimum MTU between a pair of devices.
    Again, the full details are in [Chapter 22](ch22.html "Chapter 22. IP DATAGRAM
    SIZE, FRAGMENTATION, AND REASSEMBLY").
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管主机能够依赖路由器自动根据需要分片消息很方便，但路由器花费时间做这件事是不高效的。因此，在IPv6中，开发者决定不允许路由器分片数据报。这把责任放在了每个主机上，以确保它们发送的数据报足够小，可以适应它们与任何目的地之间的每个物理网络。这是通过使用IPv6默认最小MTU
    1280实现的，每个物理链路都必须支持，或者通过一个特殊的路径MTU发现过程来确定一对设备之间的最小MTU。再次强调，详细内容请参阅[第22章](ch22.html
    "第22章。IP数据报大小、分片和重组")。
- en: If an IPv6 router is not allowed to fragment an IPv6 datagram that is too large
    to fit on the next physical link over which it must be forwarded, what should
    the router do with it? The datagram can't be forwarded, so the router has no choice
    but to discard it. When this happens, the router is required to report this occurrence
    back to the device that initially sent the datagram, using an ICMPv6 *Packet Too
    Big* message. The source device will know that it needs to fragment the datagram
    in order to have it successfully reach its destination.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 如果IPv6路由器不允许分片一个太大而无法适应下一个物理链路的数据报，它应该怎么办？数据报无法转发，因此路由器别无选择，只能丢弃它。当这种情况发生时，路由器必须使用ICMPv6
    *数据包过大*消息向最初发送数据报的设备报告这一事件。源设备将知道它需要分片数据报，以便它能够成功到达目的地。
- en: Note
  id: totrans-497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Recall that packet is a synonym for datagram, so you can think of this as
    the "Datagram Too Big" message*.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '*回想一下，数据包是数据报的同义词，所以你可以把它看作是“数据报过大”消息*。'
- en: ICMPv6 Packet Too Big Message Format
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv6数据包过大消息格式
- en: '[Table 34-3](ch34s02.html#icmpv_packet_too_big_message_format "Table 34-3. ICMPv6
    Packet Too Big Message Format") and [Figure 34-2](ch34s02.html#icmpv6_packet_too_big_message_form-id001
    "Figure 34-2. ICMPv6 Packet Too Big message format") show the format for ICMPv6
    Packet Too Big messages.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '[表34-3](ch34s02.html#icmpv_packet_too_big_message_format "表34-3。ICMPv6数据包过大消息格式")和[图34-2](ch34s02.html#icmpv6_packet_too_big_message_form-id001
    "图34-2。ICMPv6数据包过大消息格式")显示了ICMPv6数据包过大消息的格式。'
- en: Table 34-3. ICMPv6 Packet Too Big Message Format
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 表34-3. ICMPv6数据包过大消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Packet Too Big messages,
    this is set to 2. |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMPv6消息类型；对于数据包过大的消息，此值设置为2。|'
- en: '| Code | 1 | Not used for this message type; set to 0. |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| Code | 1 | 此消息类型未使用；设置为0。|'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP头部（见[第31章](ch31.html "第31章。ICMP概念和一般操作"））的16位校验和字段。|'
- en: '| MTU | 4 | The MTU size, in bytes, of the physical link over which the router
    wanted to send the datagram, but was not able to do so due to the datagram''s
    size. Including this value in the Packet Too Big message tells the source device
    the size it needs to use for its next transmission to this destination in order
    to avoid this problem in the future (at least for this particular link). |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| MTU | 4 | 路由器想要发送数据报的物理链路的MTU大小（以字节为单位），但由于数据报的大小，路由器无法发送。在“数据包过大”消息中包含此值告诉源设备它需要使用的大小，以便在未来的下一次传输到该目的地时避免此问题（至少对于此特定链路）。|'
- en: '| Original Datagram Portion | Variable | As much of the IPv6 datagram as will
    fit without causing the size of the ICMPv6 message (including its own IP header)
    to exceed the minimum IPv6 MTU of 1280 bytes. |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| 原始数据报部分 | 可变 | 在不导致ICMPv6消息（包括其自己的IP头部）的大小超过最小IPv6 MTU 1280字节的情况下，可以适应的IPv6数据报的尽可能多的部分。|'
- en: '![ICMPv6 Packet Too Big message format](httpatomoreillycomsourcenostarchimages287991.png.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6数据包过大消息格式](httpatomoreillycomsourcenostarchimages287991.png.jpg)'
- en: Figure 34-2. ICMPv6 Packet Too Big message format
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 图34-2. ICMPv6数据包过大消息格式
- en: Tip
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** In IPv6, routers are not allowed to fragment datagrams that
    are too large to send over a physical link to which they are connected. An oversized
    datagram is dropped, and an ICMPv6 *Packet Too Big* message is sent back to the
    datagram''s originator to inform it of this occurrence.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在IPv6中，路由器不允许将太大而无法通过它们连接的物理链路发送的数据报进行分段。过大的数据报将被丢弃，并向数据报的原始发送者发送一个ICMPv6
    *数据包过大*消息，通知它这一情况。'
- en: Applications of Packet Too Big Messages
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “数据包过大”消息的应用
- en: 'While Packet Too Big is obviously an error message, it also has another use:
    the implementation of Path MTU Discovery. This process, described in RFC 1981,
    defines a way for a device to determine the minimum MTU for a path to a destination.
    To perform Path MTU Discovery, the source device sends a series of test messages,
    decreasing the size of the datagram until it no longer receives Packet Too Big
    messages back in response to its tests. See [Chapter 27](ch27.html "Chapter 27. IPV6
    DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING") for a bit more detail
    on this.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然“数据包过大”显然是一个错误消息，但它还有另一个用途：路径MTU发现的实现。这个过程在RFC 1981中描述，定义了一种设备确定到达目的地路径的最小MTU的方法。为了执行路径MTU发现，源设备发送一系列测试消息，逐渐减小数据报的大小，直到它不再收到对其测试的“数据包过大”消息为止。有关此过程的更多详细信息，请参阅[第27章](ch27.html
    "第27章. IPV6数据报大小、分段、重组和路由")。
- en: Note
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The Packet Too Big message is new to ICMPv6\. However, its use is somewhat
    similar to the use of the Fragmentation Needed and DF Set version of the ICMP4
    Destination Unreachable message type, which is used as part of IPv4''s Path MTU
    Discovery feature*.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '*“数据包过大”消息是ICMPv6中新的。然而，它的使用方式与ICMP4目标不可达消息类型中的“需要分段”和“DF设置”版本的使用方式有些相似，后者作为IPv4路径MTU发现功能的一部分使用*。'
- en: Incidentally, Packet Too Big is an exception to the rule that ICMP messages
    are sent only in response to unicast datagrams; it may be sent in reply to an
    oversized multicast datagram. If this occurs, it is important to realize that
    some of the intended targets of the multicast may still have received it, if the
    path the multicast took to them did not go through the link with the small MTU
    that caused the error.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，“数据包过大”是ICMP消息仅在响应单播数据报时发送的规则的一个例外；它可能是在响应一个过大的多播数据报时发送的。如果发生这种情况，重要的是要意识到，一些多播的预期目标仍然可能已经收到了它，如果多播到达它们的路径没有经过导致错误的具有小MTU的链路。
- en: ICMPv6 Time Exceeded Messages
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv6超时消息
- en: The engineers who first designed IP recognized that due to the nature of how
    routing works on an internetwork, there was always a danger that a datagram might
    get lost in the system and spend too much time being passed from one router to
    another. They included in IPv4 datagrams a field called *Time to Live (TTL)*,
    which was intended to be set to a time value by the device sending the datagram
    and used as a timer to cause the datagram to be discarded if it took too long
    to get to its destination.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 首先设计IP的工程师意识到，由于互联网中路由工作的性质，总有可能数据报在系统中丢失，花费太多时间从一个路由器传递到另一个路由器。他们在IPv4数据报中包含了一个名为*生存时间（TTL）*的字段，该字段旨在由发送数据报的设备设置时间值，并用作计时器，如果数据报到达目的地花费时间过长，则丢弃数据报。
- en: 'Eventually, the meaning of this field was changed, so it represented not a
    time in seconds but the number of hops the datagram was allowed to traverse. In
    IPv6, the new meaning of this field was formalized when it was renamed *Hop Limit*.
    Regardless of its name, the field still has the same basic purpose: It restricts
    how long a datagram can exist on an internetwork by limiting the number of times
    routers can forward it. This is particularly designed to provide protection against
    router loops that may occur in large or improperly configured internetworks. An
    example of this situation is where Router A thinks datagrams intended for Network
    X should next go to Router B, which thinks they should go to Router C, which thinks
    they need to go to Router A. Without a Hop Limit, such datagrams would circle
    forever, clogging networks and never accomplishing anything useful. [Figure 34-3](ch34s03.html#an_example_of_a_router_loop_this_diagram
    "Figure 34-3. An example of a router loop This diagram shows a simple internetwork
    consisting of four networks, each of which is served by a router. It is an adaptation
    of Figure 23-3 from Chapter 23, but in this case, the routing tables have been
    set up incorrectly. Router R1 thinks that it needs to route any traffic intended
    for Network N4 to Router R3, which thinks it goes to Router R2, which thinks it
    goes back to Router R1\. This means that when any device tries to send to Network
    N4, the datagram will circle this triangle until its Hop Limit is reached, at
    which point an ICMPv6 Time Exceeded message will be generated.") illustrates the
    router loop problem.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这个字段的含义发生了变化，因此它代表的是数据报允许穿越的跳数数量，而不是秒数。在IPv6中，当这个字段被重命名为*跳数限制*时，其新的含义得到了正式化。无论其名称如何，该字段仍然具有相同的基本目的：通过限制路由器转发数据报的次数，它限制了数据报在互联网上存在的时间。这是特别设计来防止大型或配置不当的互联网中可能出现的路由器循环。这种情况的一个例子是，路由器A认为发往网络X的数据报应该下个路由到路由器B，而路由器B认为它们应该路由到路由器C，路由器C又认为它们需要路由回路由器A。如果没有跳数限制，这样的数据报将永远循环，堵塞网络，永远不会完成任何有用的任务。[图34-3](ch34s03.html#an_example_of_a_router_loop_this_diagram
    "图34-3。路由器循环的例子 这个图显示了一个由四个网络组成的简单互联网，每个网络都由一个路由器提供服务。它是第23章图23-3的改编，但在这个情况下，路由表被错误地设置。路由器R1认为它需要将任何发往网络N4的流量路由到路由器R3，而路由器R3认为它应该路由到路由器R2，路由器R2又认为它应该路由回路由器R1。这意味着当任何设备尝试发送到网络N4时，数据报将在这个三角形中循环，直到其跳数限制达到，此时将生成一个ICMPv6超时消息。")说明了路由器循环问题。
- en: Each time a router passes an IPv6 datagram, it decreases the Hop Limit field.
    If the value ever reaches zero, the datagram expires and is discarded. When this
    happens, the router that dropped the datagram sends an ICMPv6 Time Exceeded message
    back to the datagram's originator to inform it that the datagram was dropped.
    This is basically the same as the ICMPv4 *Time Exceeded* message. As in the ICMPv4
    case, the device receiving the message must decide whether and how to respond
    to receipt of the message. For example, since a device using a Hop Limit that
    was too low can cause the error, the device may try to resend the datagram with
    a higher value before concluding that there is a routing problem and giving up.
    ([Chapter 32](ch32.html "Chapter 32. ICMPV4 ERROR MESSAGE TYPES AND FORMATS")
    for an illustration of how TTL expiration works.)
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 每当路由器传递一个IPv6数据报时，它会减少跳数限制字段。如果该值达到零，数据报就会过期并被丢弃。当这种情况发生时，丢弃数据报的路由器会向数据报的发送者发送一个ICMPv6超时消息，通知它数据报已被丢弃。这基本上与ICMPv4的*超时*消息相同。与ICMPv4的情况一样，接收消息的设备必须决定是否以及如何响应消息的接收。例如，由于使用跳数限制过低的设备可能引起错误，设备可能会在得出存在路由问题并放弃之前，尝试使用更高的值重新发送数据报。([第32章](ch32.html
    "第32章。ICMPV4错误消息类型和格式")说明了TTL过期的工作原理。)
- en: Just as with the ICMPv4 equivalent, there is also another time expiration situation
    in which ICMPv6 Time Exceeded messages are used. When an IP message is broken
    into fragments that are sent independently, the destination device is charged
    with reassembling the fragments into the original message. One or more fragments
    may not make it to the destination, however. To prevent the device from waiting
    forever, it sets a timer when the first fragment arrives. If this timer expires
    before all of the other fragments are also received, the device gives up on this
    message. The fragments are tossed out, and a Time Exceeded message is generated.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 就像ICMPv4的等效物一样，也存在另一种时间超时情况，其中使用ICMPv6超时消息。当一个IP消息被分割成独立发送的片段时，目标设备负责将这些片段重新组装成原始消息。然而，一个或多个片段可能无法到达目的地。为了防止设备永远等待，当第一个片段到达时，它设置了一个计时器。如果这个计时器在所有其他片段都收到之前到期，设备将放弃这个消息。这些片段将被丢弃，并生成一个超时消息。
- en: '![An example of a router loop This diagram shows a simple internetwork consisting
    of four networks, each of which is served by a router. It is an adaptation of
    from , but in this case, the routing tables have been set up incorrectly. Router
    R1 thinks that it needs to route any traffic intended for Network N4 to Router
    R3, which thinks it goes to Router R2, which thinks it goes back to Router R1\.
    This means that when any device tries to send to Network N4, the datagram will
    circle this triangle until its Hop Limit is reached, at which point an ICMPv6
    Time Exceeded message will be generated.](httpatomoreillycomsourcenostarchimages287993.png.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![路由环路的一个示例 此图显示了一个由四个网络组成的简单互联网，每个网络都由一个路由器提供服务。这是对 的改编，但在这个情况下，路由表设置不正确。路由器R1认为它需要将任何旨在发送到网络N4的流量路由到路由器R3，而R3认为它应该发送到路由器R2，而R2认为它应该返回到路由器R1。这意味着当任何设备尝试发送到网络N4时，数据包将在这个三角形中循环，直到其跳数限制达到，此时将生成一个ICMPv6超时消息。](httpatomoreillycomsourcenostarchimages287993.png.jpg)'
- en: Figure 34-3. An example of a router loop This diagram shows a simple internetwork
    consisting of four networks, each of which is served by a router. It is an adaptation
    of [Figure 23-3](ch23s03.html#ip_routing_and_routing_tables_this_diagr "Figure 23-3. IP
    routing and routing tables This diagram shows a small, simple internetwork consisting
    of four LANs each served by a router. The routing table for each lists the router
    to which datagrams for each destination network should be sent. Notice that due
    to the triangle, R1, R2, and R3 can send to each other. However, R2 and R3 must
    send through R1 to deliver to R4, and R4 must use R1 to reach either of the others.")
    from [Chapter 23](ch23.html "Chapter 23. IP ROUTING AND MULTICASTING"), but in
    this case, the routing tables have been set up incorrectly. Router R1 thinks that
    it needs to route any traffic intended for Network N4 to Router R3, which thinks
    it goes to Router R2, which thinks it goes back to Router R1\. This means that
    when any device tries to send to Network N4, the datagram will circle this triangle
    until its Hop Limit is reached, at which point an ICMPv6 Time Exceeded message
    will be generated.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 图34-3. 路由环路的一个示例 此图显示了一个由四个网络组成的简单互联网，每个网络都由一个路由器提供服务。这是对[图23-3](ch23s03.html#ip_routing_and_routing_tables_this_diagr
    "图23-3. IP路由和路由表 此图显示了一个由四个局域网组成的小型简单互联网，每个局域网都由一个路由器提供服务。每个路由表列出了应将每个目标网络的报文发送到哪个路由器。注意，由于三角形，R1、R2和R3可以相互发送。然而，R2和R3必须通过R1来将数据发送到R4，而R4必须使用R1来到达任何一个其他的。")的改编，但在这个情况下，路由表设置不正确。路由器R1认为它需要将任何旨在发送到网络N4的流量路由到路由器R3，而R3认为它应该发送到路由器R2，而R2认为它应该返回到路由器R1。这意味着当任何设备尝试发送到网络N4时，数据包将在这个三角形中循环，直到其跳数限制达到，此时将生成一个ICMPv6超时消息。
- en: ICMPv6 Time Exceeded Message Format
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv6超时消息格式
- en: '[Table 32-4](ch32s03.html#icmpv_time_exceeded_message_format "Table 32-4. ICMPv4
    Time Exceeded Message Format") and [Figure 34-4](ch34s03.html#icmpv6_time_exceeded_message_forma-id001
    "Figure 34-4. ICMPv6 Time Exceeded message format") show the format for ICMPv6
    Time Exceeded messages.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '[表32-4](ch32s03.html#icmpv_time_exceeded_message_format "表32-4. ICMPv4超时消息格式")和[图34-4](ch34s03.html#icmpv6_time_exceeded_message_forma-id001
    "图34-4. ICMPv6超时消息格式")显示了ICMPv6超时消息的格式。'
- en: Table 34-4. ICMPv6 Time Exceeded Message Format
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 表34-4. ICMPv6超时消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Time Exceeded messages,
    this is set to 3. |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMPv6消息类型；对于超时消息，此值设置为3。 |'
- en: '| Code | 1 | Identifies the subtype of time error that''s being communicated.
    A value of 0 indicates expiration of the Hop Limit field; a value of 1 indicates
    that the fragment reassembly time has been exceeded. |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 识别正在通信的时间错误的子类型。值为0表示跳转限制字段的过期；值为1表示分段重组时间已超过。 |'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP头部的一个16位校验和字段（见[第31章](ch31.html "第31章. ICMP概念和一般操作"））。 |'
- en: '| Unused | 4 | The 4 bytes left blank and not used. |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| 未使用 | 4 | 剩下的4个字节留空，未使用。 |'
- en: '| Original Datagram Portion | Variable | As much of the IPv6 datagram as will
    fit without causing the size of the ICMPv6 error message (including its own IP
    header) to exceed the minimum IPv6 MTU of 1280 bytes. |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| 原始数据报部分 | 变量 | IPv6数据报中可以容纳的部分，在不导致ICMPv6错误消息（包括其自身的IP头部）的大小超过最小IPv6 MTU
    1280字节的情况下。 |'
- en: '![ICMPv6 Time Exceeded message format](httpatomoreillycomsourcenostarchimages287995.png.jpg)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6时间超限消息格式](httpatomoreillycomsourcenostarchimages287995.png.jpg)'
- en: Figure 34-4. ICMPv6 Time Exceeded message format
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 图34-4. ICMPv6时间超限消息格式
- en: Tip
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Like their ICMPv4 namesakes, ICMPv6 *Time Exceeded* messages
    are sent in two different time-related circumstances. The first is if a datagram''s
    *Hop Limit* field is reduced to zero, thereby causing it to expire and the datagram
    to be dropped. The second is when all the pieces of a fragmented message are not
    received before the recipient''s reassembly timer expires.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 与它们的ICMPv4同名者一样，ICMPv6 *时间超限*消息在两种不同的时间相关情况下发送。第一种情况是如果数据报的 *跳转限制*
    字段减少到零，从而使其过期并丢弃数据报。第二种情况是在接收者的重组定时器过期之前，没有接收到分段消息的所有部分。'
- en: Applications of Time Exceeded Messages
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间超限消息的应用
- en: In IPv4, ICMP Time Exceeded messages are used both as an error message and in
    a clever application to implement the TCP/IP traceroute command. This is done
    by first sending a dummy datagram with a TTL value of 1, thereby causing the first
    hop in the route to discard the datagram and send back an ICMP Time Exceeded message.
    Then a second datagram is sent to the same destination with a TTL value of 2,
    thus causing the second device in the route to report back a Time Exceeded message,
    and so on.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv4中，ICMP时间超限消息既用作错误消息，又巧妙地应用于实现TCP/IP的traceroute命令。这是通过首先发送一个具有TTL值为1的虚拟数据报来完成的，从而使得路由中的第一个跳点丢弃数据报并发送回一个ICMP时间超限消息。然后向同一目的地发送第二个数据报，其TTL值为2，从而使得路由中的第二个设备报告一个时间超限消息，依此类推。
- en: There is an IPv6 version of traceroute that is sometimes called *traceroute6*.
    Due to the fact that IPv6 and its protocols and applications are still in development,
    I have not been able to confirm definitively that traceroute6 is implemented using
    ICMPv6 Time Exceeded messages in the manner described earlier, but I believe this
    is the case (and it certainly would make sense). See [Chapter 88](ch88.html "Chapter 88. TCP/IP
    ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS") for more information
    about traceroute.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个IPv6版本的traceroute，有时被称为 *traceroute6*。由于IPv6及其协议和应用仍在开发中，我还没有能够确定traceroute6是否使用前面描述的方式通过ICMPv6时间超限消息实现，但我相信这是可能的（这确实是有意义的）。有关traceroute的更多信息，请参阅[第88章](ch88.html
    "第88章. TCP/IP管理及故障排除工具和协议")。
- en: ICMPv6 Parameter Problem Messages
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv6参数问题消息
- en: The ICMPv6 Destination Unreachable, Packet Too Big, and Time Exceeded messages
    described in the previous sections are used to indicate specific error conditions
    to the original sender of a datagram. Recognizing that a router or host may encounter
    some other problem in processing a datagram that is not covered by any of these
    message types, ICMPv6 includes a generic error message type, just as ICMPv4 did.
    This is called the ICMPv6 *Parameter Problem* message.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中描述的ICMPv6目标不可达、数据包过大和时间超限消息用于向数据报的原始发送者指示特定的错误条件。认识到路由器或主机在处理数据报时可能会遇到这些问题，而这些问题没有被上述任何消息类型所涵盖，ICMPv6包括了一个通用的错误消息类型，就像ICMPv4一样。这被称为ICMPv6
    *参数问题*消息。
- en: As the name suggests, a Parameter Problem message indicates that a device found
    a problem with a parameter (another name for a datagram field) while attempting
    to work its way through the header (or headers) in an IPv6 datagram. This message
    is generated only when the error encountered is serious enough that the device
    could not make sense of the datagram and had to discard it. So, if an error is
    found that a device is able to recover from (does not need to drop the datagram),
    no Parameter Problem message is created.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，参数问题消息表示设备在尝试通过 IPv6 数据报的头部（或多个头部）时发现了一个参数（数据报字段的一个别名）问题。此消息仅在遇到严重错误，设备无法理解数据报并不得不丢弃它时才会生成。因此，如果发现一个设备能够从中恢复的错误（不需要丢弃数据报），则不会创建参数问题消息。
- en: As was the case for the ICMPv4 version of this message, the ICMPv6 message was
    designed to be generic, so it can indicate an error in basically any field in
    the original datagram. A special Pointer field is used that points to the place
    in that datagram where the error was encountered. By looking at the structure
    of the original message (which, as you may recall, is included up to a certain
    size in the ICMP message format), the original device can tell which field contained
    the problem. The Code value is also used to communicate additional general information
    about the nature of the problem.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 与此消息的 ICMPv4 版本一样，ICMPv6 消息被设计为通用，因此它可以指示原始数据报中基本上任何字段中的错误。使用了一个特殊的指针字段，该字段指向数据报中遇到错误的位置。通过查看原始消息的结构（如您所记得，它包含在
    ICMP 消息格式中，直到一定大小），原始设备可以确定哪个字段包含问题。代码值也用于传达有关问题性质的附加一般信息。
- en: ICMPv6 Parameter Problem Message Format
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv6 参数问题消息格式
- en: '[Table 34-5](ch34s04.html#icmpv_parameter_problem_message_fo-id001 "Table 34-5. ICMPv6
    Parameter Problem Message Format") and [Figure 34-5](ch34s04.html#icmpv6_parameter_problem_message_f-id001
    "Figure 34-5. ICMPv6 Parameter Problem message format") show the format for ICMPv6
    Parameter Problem messages.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 34-5](ch34s04.html#icmpv_parameter_problem_message_fo-id001 "表 34-5. ICMPv6
    参数问题消息格式") 和 [图 34-5](ch34s04.html#icmpv6_parameter_problem_message_f-id001 "图
    34-5. ICMPv6 参数问题消息格式") 展示了 ICMPv6 参数问题消息的格式。'
- en: Table 34-5. ICMPv6 Parameter Problem Message Format
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 表 34-5. ICMPv6 参数问题消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Parameter Problem messages,
    this is set to 4. |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别 ICMPv6 消息类型；对于参数问题消息，此值设置为 4。 |'
- en: '| Code | 1 | Identifies the general class of the parameter problem. See [Table 34-6](ch34s04.html#icmpv_parameter_problem_message_in-id001
    "Table 34-6. ICMPv6 Parameter Problem Message Interpretation Codes") for more
    information. |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 识别参数问题的通用类别。有关更多信息，请参阅 [表 34-6](ch34s04.html#icmpv_parameter_problem_message_in-id001
    "表 34-6. ICMPv6 参数问题消息解释代码")。 |'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP 头部的 16 位校验和字段（见 [第 31 章](ch31.html "第 31 章. ICMP 概念和一般操作")）。
    |'
- en: '| Pointer | 4 | An offset that points to the byte location in the original
    datagram that caused the Parameter Problem message to be generated. The device
    receiving the ICMP message can use this value to get an idea of which field in
    the original message had the problem. |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| 指针 | 4 | 一个偏移量，指向原始数据报中导致生成参数问题消息的字节位置。接收 ICMP 消息的设备可以使用此值来了解原始消息中哪个字段存在问题。
    |'
- en: '| Original Datagram Portion | Variable | As much of the IPv6 datagram as will
    fit without causing the size of the ICMPv6 error message (including its own IP
    header) to exceed the minimum IPv6 MTU of 1280 bytes. |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| 原始数据报部分 | 可变 | 在不导致 ICMPv6 错误消息（包括其自己的 IP 头部）大小超过最小 IPv6 MTU 1280 字节的情况下，IPv6
    数据报中可以容纳的部分。 |'
- en: '![ICMPv6 Parameter Problem message format](httpatomoreillycomsourcenostarchimages287997.png)'
  id: totrans-556
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6 参数问题消息格式](httpatomoreillycomsourcenostarchimages287997.png)'
- en: Figure 34-5. ICMPv6 Parameter Problem message format
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 图 34-5. ICMPv6 参数问题消息格式
- en: Parameter Problem Message Interpretation Codes and the Pointer Field
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数问题消息解释代码和指针字段
- en: The Pointer field, which was only 8 bits wide in ICMPv4, has been widened to
    32 bits in ICMPv6 in order to provide more flexibility in isolating the error.
    The Code value is also used somewhat differently in ICMPv6 than it was in the
    ICMPv4 version of this message type. In ICMPv4, the Pointer was used only when
    the Code field was 0, and other code values indicated other problem categories
    for which the Pointer field did not make sense. In ICMPv6, the Pointer field is
    used with all Code types to indicate the general nature of what the problem is.
    This means the Pointer field tells the recipient of the Parameter Problem message
    where the problem happened in the message, and the Code field tells it what the
    nature of the problem is. [Table 34-6](ch34s04.html#icmpv_parameter_problem_message_in-id001
    "Table 34-6. ICMPv6 Parameter Problem Message Interpretation Codes") shows the
    three Code values and provides a brief explanation of each.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: Pointer字段在ICMPv4中只有8位宽，在ICMPv6中已扩展到32位，以便在隔离错误时提供更大的灵活性。Code值在ICMPv6中的使用方式与在ICMPv4版本的此消息类型中有所不同。在ICMPv4中，只有在Code字段为0时才使用Pointer，其他代码值表示其他问题类别，对于这些类别，Pointer字段没有意义。在ICMPv6中，Pointer字段与所有Code类型一起使用，以指示问题的总体性质。这意味着Pointer字段告诉消息接收者问题发生在消息的哪个位置，而Code字段告诉它问题的性质。[表34-6](ch34s04.html#icmpv_parameter_problem_message_in-id001
    "表34-6. ICMPv6 参数问题消息解释代码")显示了三个Code值，并对每个值进行了简要说明。
- en: Table 34-6. ICMPv6 Parameter Problem Message Interpretation Codes
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 表34-6. ICMPv6 参数问题消息解释代码
- en: '| Code Value | Message Subtype | Description |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| 代码值 | 消息子类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | Erroneous Header Field Encountered | The Pointer field points to a header
    that contains an error or otherwise could not be processed. |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 遇到错误的头部字段 | 指针字段指向一个包含错误或无法处理的头部的头部。 |'
- en: '| 1 | Unrecognized Next Header Type Encountered | As explained in [Chapter 26](ch26.html
    "Chapter 26. IPV6 DATAGRAM ENCAPSULATION AND FORMATTING"), in IPv6, a datagram
    can have multiple headers, each of which contains a Next Header field that points
    to the next header in the datagram. This code indicates that the Pointer field
    points to a Next Header field containing an unrecognized value. |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 遇到未识别的下一个头部类型 | 如[第26章](ch26.html "第26章. IPv6 数据报封装和格式")所述，在IPv6中，一个数据报可以包含多个头部，每个头部都包含一个指向数据报中下一个头部的Next
    Header字段。此代码表示指针字段指向一个包含未识别值的Next Header字段。 |'
- en: '| 2 | Unrecognized IPv6 Option Encountered | The Pointer field points to an
    IPv6 option that was not recognized by the processing device. |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 遇到未识别的IPv6选项 | 指针字段指向一个处理设备未识别的IPv6选项。 |'
- en: Tip
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The ICMPv6 *Parameter Problem* message is a generic error message
    that can be used to convey an error of any type in an IP datagram. The Pointer
    field is used to indicate where the problem was in the original datagram to the
    recipient of the message.'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ICMPv6 *参数问题*消息是一个通用错误消息，可以用来传达IP数据报中任何类型的错误。Pointer字段用于向消息接收者指示问题在原始数据报中的位置。'
- en: Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS
  id: totrans-568
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第35章. ICMPv6 信息性消息类型和格式
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-569
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: 'In the previous chapter, we explored a number of Internet Control Message Protocol
    version 6 (ICMPv6) error messages. These are sent back to the originator of an
    Internet Protocol version 6 (IPv6) datagram when the originator detects an error
    it, thereby making it impossible for the error to be delivered. Like the original
    version of ICMP (ICMPv4), ICMPv6 also defines another message class: *informational*
    messages. These ICMPv6 messages are used not to report errors, but to allow the
    sharing of information required to implement various test, diagnostic, and support
    functions critical to the operation of IPv6.'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了多种互联网控制消息协议第6版（ICMPv6）错误消息。当原始发送者检测到错误，使得错误无法被传递时，这些错误消息会被发送回IPv6数据报的原始发送者。与原始的ICMP（ICMPv4）版本一样，ICMPv6还定义了另一个消息类别：*信息性*消息。这些ICMPv6消息不是用来报告错误的，而是用来共享实施各种测试、诊断和支持功能所需的信息，这些功能对于IPv6的运行至关重要。
- en: In this chapter, I describe eight different ICMPv6 informational messages in
    five topics (six of these messages are used in matching pairs, and the pairs are
    described together). I begin by describing ICMPv6 Echo Request and Echo Reply
    messages, which are used for network connectivity testing. I explain the format
    of Router Advertisement and Router Solicitation messages, which are used to let
    hosts discover local routers and learn necessary parameters from them. I then
    describe ICMPv6 Neighbor Advertisement and Neighbor Solicitation messages, which
    are used for various communications between hosts on a local network, including
    IPv6 address resolution. I discuss IPv6 Redirect messages, which let routers inform
    hosts of better first-hop routers, and IPv6 Router Renumbering messages.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了八个不同的ICMPv6信息消息，分为五个主题（其中六个消息是成对使用的，这些对一起描述）。我首先描述了ICMPv6回显请求和回显应答消息，这些消息用于网络连通性测试。我解释了路由器通告和路由器请求消息的格式，这些消息用于让主机发现本地路由器并从它们那里学习必要的参数。然后，我描述了ICMPv6邻居通告和邻居请求消息，这些消息用于本地网络中主机之间的各种通信，包括IPv6地址解析。我还讨论了IPv6重定向消息，这些消息让路由器通知主机更好的下一跳路由器，以及IPv6路由器重新编号消息。
- en: Several of the ICMPv6 informational messages include additional information
    that is either optional, recommended, or mandatory, depending on the circumstances
    under which the message is generated. Some of these are shared between message
    types, so they are described in a separate topic at the end of the chapter.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 一些ICMPv6信息消息包括额外的信息，这些信息根据生成消息的环境是可选的、推荐的或强制性的。其中一些在消息类型之间共享，因此它们在章节末尾的单独主题中进行了描述。
- en: In IPv4, the use of many of the ICMP informational messages was described in
    a variety of different standards. In IPv6, many of the functions using informational
    messages have been gathered together and formalized in the IPv6 *Neighbor Discovery
    (ND) protocol*. The solicitation and advertisement of local routers and neighboring
    hosts, as well as the communication of redirection information are both examples
    of activities for which ND is responsible. In fact, five of the ICMP messages
    described in this chapter are actually defined in the ND standard, RFC 2461.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv4中，许多ICMP信息消息的使用在各种不同的标准中进行了描述。在IPv6中，许多使用信息消息的功能已经汇集在一起，并在IPv6 *邻居发现（ND）协议*中正式化。本地路由器和相邻主机的请求和通告，以及重定向信息的通信都是ND负责的活动示例。实际上，本章中描述的五个ICMP消息实际上是在ND标准RFC
    2461中定义的。
- en: Tip
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**RELATED INFORMATION** *Neighbor Discovery (ND) and ICMPv6 are obviously closely
    related, given that ND describes the use of several of the ICMP messages: Router
    Advertisement, Router Solicitation, Neighbor Advertisement, Neighbor Solicitation,
    and Redirect. Thus, just as ICMPv4 is an important assistant to IPv4, both ICMPv6
    and ND are important helpers for IPv6\. In this book, I provide most of the description
    of how these messages are used in the next chapter, which discusses ND. In this
    chapter, I provide only a brief summary of their use, while focusing primarily
    on message format and the meaning of each of the fields in that format*.'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '**相关信息** *邻居发现（ND）和ICMPv6显然密切相关，因为ND描述了几个ICMP消息的使用：路由器通告、路由器请求、邻居通告、邻居请求和重定向。因此，就像ICMPv4是IPv4的重要助手一样，ICMPv6和ND都是IPv6的重要助手。在这本书中，我提供了关于这些消息如何使用的描述，这些描述将在下一章中讨论ND。在这一章中，我主要提供这些消息使用的简要总结，同时主要关注消息格式以及该格式中每个字段的含义*。'
- en: ICMPv6 Echo Request and Echo Reply Messages
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv6回显请求和回显应答消息
- en: IP is a relatively simple protocol that does not include any method for performing
    tests between devices to help in diagnosing internetwork problems. This means
    that this job, like other support tasks, falls to ICMP. The simplest test performed
    when there is a problem using TCP/IP is usually a check that a pair of devices
    is able to send datagrams to each other. This is most often done by an initiating
    device that sends a test message to a second device, which receives it and replies
    back to tell the first device it received the message.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: IP是一个相对简单的协议，它不包含任何在设备之间执行测试的方法，以帮助诊断互联网问题。这意味着这项工作，就像其他支持任务一样，落到了ICMP头上。当使用TCP/IP出现问题时，通常进行的
    simplest 测试通常是检查一对设备能否互相发送数据报。这通常是通过一个发起设备向第二个设备发送测试消息来完成的，第二个设备接收它并回复告诉第一个设备它已经收到了消息。
- en: Like ICMPv4, ICMPv6 includes a pair of messages specifically for connection
    testing. To use them, Device A begins the test process by sending an ICMPv4 *Echo
    Request* message to Device B, which responds back to Device A with an *Echo Reply*
    message. When Device A receives this message, it knows that it is able to communicate
    (both send and receive) successfully with Device B.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 与ICMPv4一样，ICMPv6包含了一对专门用于连接测试的消息。要使用它们，设备A通过向设备B发送ICMPv4 *回显请求*消息来开始测试过程，设备B会以*回显响应*消息的形式回应设备A。当设备A接收到此消息时，它知道它可以成功与设备B进行通信（发送和接收）。
- en: Note
  id: totrans-579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In ICMPv4 the first message type was named just* Echo *but was often called*
    Echo Request. *In ICMPv6*, Request *is part of the formal message name—a modest
    but useful improvement from a clarity standpoint*.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '*在ICMPv4中，第一个消息类型仅被命名为*回显*，但通常被称为*回显请求*。*在ICMPv6中*，*请求*是正式消息名称的一部分——这是一个既谦虚又实用的改进，从清晰度的角度来看。|'
- en: ICMPv6 Echo and Echo Reply Message Format
  id: totrans-581
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv6回显和回显响应消息格式
- en: The format for ICMPv6 Echo Request and Echo Reply messages is very similar to
    that of the ICMPv4 version, as shown in [Table 35-1](ch35.html#icmpv_echo_request_and_echo_reply_messag
    "Table 35-1. ICMPv6 Echo Request and Echo Reply Message Format") and [Figure 35-1](ch35.html#icmpv6_echo_request_and_echo_reply-id001
    "Figure 35-1. ICMPv6 Echo Request and Echo Reply message format").
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6回显请求和回显响应消息的格式与ICMPv4版本非常相似，如[表35-1](ch35.html#icmpv_echo_request_and_echo_reply_messag
    "表35-1. ICMPv6回显请求和回显响应消息格式")和[图35-1](ch35.html#icmpv6_echo_request_and_echo_reply-id001
    "图35-1. ICMPv6回显请求和回显响应消息格式")所示。
- en: Table 35-1. ICMPv6 Echo Request and Echo Reply Message Format
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 表35-1. ICMPv6回显请求和回显响应消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Echo Request messages,
    the value is 128, and for Echo Reply messages, it''s 129\. (In ICMPv6, informational
    messages always have a Type value of 128 or higher.) |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMPv6消息类型；对于回显请求消息，值为128，对于回显响应消息，值为129。（在ICMPv6中，信息消息始终具有128或更高的类型值。）|'
- en: '| Code | 1 | Not used; set to 0. |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '| 码 | 1 | 未使用；设置为0。|'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | 用于ICMP头部的一个16位校验和字段（见[第31章](ch31.html "第31章. ICMP概念和一般操作"））。|'
- en: '| Identifier | 2 | An optional identification field that can be used to help
    in matching Echo Request and Echo Reply messages. |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '| 标识符 | 2 | 一个可选的标识字段，可用于帮助匹配回显请求和回显响应消息。|'
- en: '| Sequence Number | 2 | A sequence number to help in matching Echo Request
    and Echo Reply messages. |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '| 序列号 | 2 | 一个序列号，有助于匹配回显请求和回显响应消息。|'
- en: '| Optional Data | Variable | Additional optional data to be sent along with
    the message. If this is sent in the Echo Request, it is copied into the Echo Reply
    to be sent back to the source. |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '| 可选数据 | 可变 | 随消息一起发送的附加可选数据。如果这在回显请求中发送，它将被复制到回显响应中并发送回源地址。|'
- en: '![ICMPv6 Echo Request and Echo Reply message format](httpatomoreillycomsourcenostarchimages287999.png)'
  id: totrans-592
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6回显请求和回显响应消息格式](httpatomoreillycomsourcenostarchimages287999.png)'
- en: Figure 35-1. ICMPv6 Echo Request and Echo Reply message format
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 图35-1. ICMPv6回显请求和回显响应消息格式
- en: It is often necessary to match an Echo Reply message with the Echo Request message
    that led to it being generated. Two special fields are used within the format
    of these messages to allow Echo Request and Echo Reply messages to be matched
    together, and to allow a sequence of messages to be exchanged. The Identifier
    field is provided so that a particular test session can be identified, and the
    Sequence Number field allows a series of tests in a session to be numbered. The
    use of both fields is optional.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要将回显响应消息与导致其生成的回显请求消息进行匹配。这些消息的格式中使用了两个特殊字段，以便将回显请求和回显响应消息匹配在一起，并允许交换一系列消息。标识符字段提供了一种方法，可以识别特定的测试会话，而序列号字段允许对会话中的测试进行编号。这两个字段的使用是可选的。
- en: Application of Echo and Echo Reply Messages
  id: totrans-595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回显和回显响应消息的应用
- en: ICMPv6 Echo Request and Echo Reply messages are used via the IPv6 version of
    the IP ping utility, which is commonly called *ping6*. Like its IPv4 predecessor,
    this utility allows an administrator to configure a number of test options to
    perform either a simple or rigorous test of the connection between a pair of devices.
    See [Chapter 88](ch88.html "Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING
    UTILITIES AND PROTOCOLS") for a full explanation.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6 回显请求和回显响应消息通过 IPv6 版本的 IP ping 工具使用，通常称为 *ping6*。像它的 IPv4 前身一样，这个工具允许管理员配置多个测试选项，以执行一对设备之间简单或严格的连接测试。参见
    [第 88 章](ch88.html "第 88 章. TCP/IP 管理和故障排除工具与协议") 以获得完整说明。
- en: Tip
  id: totrans-597
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** ICMPv6 *Echo Request* and *Echo Reply* messages are used to
    facilitate network reachability testing. A device tests its ability to communicate
    with another by sending it an Echo Request message and waiting for an Echo Reply
    in response. The *ping* utility, a widely used diagnostic tool in TCP/IP internetworks,
    makes use of these messages.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ICMPv6 的 *回显请求* 和 *回显响应* 消息用于促进网络可达性测试。一个设备通过发送回显请求消息并等待相应的回显响应来测试其与另一个设备通信的能力。*ping*
    工具，作为 TCP/IP 互联网中广泛使用的诊断工具，利用了这些消息。'
- en: ICMPv6 Router Advertisement and Router Solicitation Messages
  id: totrans-599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv6 路由器通告和路由器请求消息
- en: 'At the highest level, we can separate IP devices into two groups: hosts and
    routers. Both participate in the use of the internetwork, but they have different
    roles. An important IP principle related to this division is that routers take
    care of routing—moving data between networks—while hosts generally don''t need
    to worry about this job. Hosts rely on the routers on their local networks to
    facilitate communication to all other hosts except those on the local network.'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在最高层面上，我们可以将 IP 设备分为两组：主机和路由器。两者都参与互联网的使用，但它们有不同的角色。与这种划分相关的一个重要 IP 原则是，路由器负责路由——在网络上移动数据——而主机通常不需要担心这项工作。主机依赖于它们本地网络中的路由器，以便与其他所有主机（除了本地网络上的主机）进行通信。
- en: 'The implications of this are clear: A host cannot really use an internetwork
    until it knows the identity of at least one local router and the method by which
    that router is to be used. In IPv4, a technique known as *Router Discovery* was
    invented, which provides a means by which a host can locate a router and learn
    important parameters related to the operation of the local network. Router Discovery
    in IPv6 works in a very similar manner by having routers send *Router Advertisement*
    messages both on a regular basis and in response to hosts prompting for them using
    *Router Solicitation* messages. The Router Discovery function has been incorporated
    into the ND protocol, where it is part of a larger class of tools that I call
    *host–Router Discovery* functions.'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 这的后果是明显的：一个主机在知道至少一个本地路由器的身份以及如何使用该路由器的方法之前，实际上无法真正使用互联网。在 IPv4 中，发明了一种称为 *路由器发现*
    的技术，它提供了一种主机可以定位路由器并学习与本地网络操作相关的重要参数的方法。IPv6 中的路由器发现以非常相似的方式工作，通过路由器定期发送 *路由器通告*
    消息，并在主机使用 *路由器请求* 消息提示时响应。路由器发现功能已被纳入 ND 协议，它是更大类工具的一部分，我将其称为 *主机-路由器发现* 功能。
- en: ICMPv6 Router Advertisement Message Format
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv6 路由器通告消息格式
- en: The ICMPv6 Router Advertisement and Router Solicitation messages are fairly
    similar to their counterparts in ICMPv4\. The main differences are in the parameters
    that are communicated. Since routers are responsible for a few more functions
    in IPv6 than they are in IPv4, the Router Advertisement message in ICMPv6 has
    a few more fields than the older version.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6 路由器通告和路由器请求消息与 ICMPv4 的对应消息相当相似。主要区别在于所传递的参数。由于在 IPv6 中，路由器比在 IPv4 中负责更多的功能，因此
    ICMPv6 的路由器通告消息比旧版本多了几个字段。
- en: The format of an ICMPv6 Router Advertisement message is described in [Table 35-2](ch35s02.html#icmpv_router_advertisement_message-id001
    "Table 35-2. ICMPv6 Router Advertisement Message Format") and shown in [Figure 35-2](ch35s02.html#icmpv6_router_advertisement_messag-id001
    "Figure 35-2. ICMPv6 Router Advertisement message format").
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6 路由器通告消息的格式在 [表 35-2](ch35s02.html#icmpv_router_advertisement_message-id001
    "表 35-2. ICMPv6 路由器通告消息格式") 中描述，并在 [图 35-2](ch35s02.html#icmpv6_router_advertisement_messag-id001
    "图 35-2. ICMPv6 路由器通告消息格式") 中展示。
- en: '![ICMPv6 Router Advertisement message format](httpatomoreillycomsourcenostarchimages288001.png.jpg)'
  id: totrans-605
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6 路由器通告消息格式](httpatomoreillycomsourcenostarchimages288001.png.jpg)'
- en: Figure 35-2. ICMPv6 Router Advertisement message format
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 图35-2. ICMPv6 路由器通告消息格式
- en: Table 35-2. ICMPv6 Router Advertisement Message Format
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 表35-2. ICMPv6 路由器通告消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Router Advertisement messages,
    the value is 134. |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMPv6消息类型；对于路由器通告消息，值为134。'
- en: '| Code | 1 | Not used; set to 0. |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 未使用；设置为0。 |'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP头部的一个16位校验和字段（请参阅[第31章](ch31.html "第31章. ICMP 概念和一般操作"））。'
- en: '| Cur Hop Limit | 1 | Current Hop Limit: This is a default number that the
    router recommends that hosts on the local network use as a value in the Hop Limit
    field of datagrams they send. If 0, the router is not recommending a Hop Limit
    value in this Router Advertisement. |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| 当前跳数限制 | 1 | 当前跳数限制：这是路由器建议本地网络上的主机在它们发送的数据报的跳数限制字段中使用的默认数值。如果为0，则表示路由器在此路由器通告中不推荐跳数限制值。'
- en: '| Autoconfig Flags | 1 | Two flags that let the router tell the host how autoconfiguration
    is performed on the local network, as described in [Table 35-3](ch35s02.html#icmpv_router_advertisement_message_autoc
    "Table 35-3. ICMPv6 Router Advertisement Message Autoconfiguration Flags"). (See
    [Chapter 25](ch25.html "Chapter 25. IPV6 ADDRESSING") for details on IPv6 autoconfiguration.)
    |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| 自动配置标志 | 1 | 两个标志允许路由器告诉主机本地网络上如何执行自动配置，如[表35-3](ch35s02.html#icmpv_router_advertisement_message_autoc
    "表35-3. ICMPv6 路由器通告消息自动配置标志"）中所述。（有关IPv6自动配置的详细信息，请参阅[第25章](ch25.html "第25章.
    IPV6 编址"）。）'
- en: '| Router Lifetime | 2 | Tells the host receiving this message how long, in
    seconds, this router should be used as a default router. If 0, it tells the host
    this router should not be used as a default router. Note that this is an expiration
    interval only for the status of the router as a default, not for other information
    in the Router Advertisement message. |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| 路由器生存时间 | 2 | 告诉接收此消息的主机，此路由器应作为默认路由器使用多长时间（以秒为单位）。如果为0，则告诉主机不应使用此路由器作为默认路由器。请注意，这仅是路由器作为默认路由器状态的超时间隔，而不是路由器通告消息中的其他信息。'
- en: '| Reachable Time | 4 | Tells hosts how long, in milliseconds, they should consider
    a neighbor to be reachable after they have received reachability confirmation.
    (See [Chapter 36](ch36.html "Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL")
    for more information.) |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| 可达时间 | 4 | 告诉主机在收到可达性确认后，应将邻居视为可达的时间长度（以毫秒为单位）。（有关更多信息，请参阅[第36章](ch36.html
    "第36章. IPV6 邻居发现（ND）协议"）。）'
- en: '| Retrans Timer | 4 | Retransmission Timer: The amount of time, in milliseconds,
    that a host should wait before retransmitting Neighbor Solicitation messages.
    |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| 重传定时器 | 4 | 重传定时器：主机在重新传输邻居请求消息之前应等待的时间长度（以毫秒为单位）。'
- en: '| Options | Variable | Router Advertisement messages may contain three possible
    options (see the "ICMPv6 Informational Message Options" section later in this
    chapter for more on ICMPv6 options):'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '| 选项 | 可变 | 路由器通告消息可能包含三种可能的选项（有关ICMPv6选项的更多信息，请参阅本章后面的“ICMPv6信息性消息选项”部分）：'
- en: 'Source Link-Layer Address: Included when the router sending the Advertisement
    knows its link-layer (layer 2) address.'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源链路层地址：当发送通告的路由器知道其链路层（第2层）地址时包含在内。
- en: 'MTU: Used to tell local hosts the MTU of the local network when hosts on the
    network may not know this information.'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MTU：用于告诉本地主机本地网络的MTU，当网络上的主机可能不知道此信息时。
- en: 'Prefix Information: Tells local hosts what prefix or prefixes to use for the
    local network. (You''ll recall that the "prefix" indicates which bits of an IPv6
    address are the network identifier when compared to the host identifier; it is
    thus analogous to an IPv4 subnet mask.)'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀信息：告诉本地主机应使用哪些前缀或前缀用于本地网络。（您会记得，“前缀”表示与主机标识符相比，IPv6地址的哪些位是网络标识符；因此，它与IPv4子网掩码类似。）
- en: '|'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Table 35-3. ICMPv6 Router Advertisement Message Autoconfiguration Flags
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 表35-3. ICMPv6 路由器通告消息自动配置标志
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| M | 1/8 (1 bit) | Managed Address Configuration Flag: When set, this flag
    tells hosts to use an administered or stateful method for address autoconfiguration,
    such as the Dynamic Host Configuration Protocol (DHCP). |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '| M | 1/8（1位） | 管理地址配置标志：当设置时，此标志告诉主机使用管理或状态方法进行地址自动配置，例如动态主机配置协议（DHCP）。|'
- en: '| O | 1/8 (1 bit) | Other Stateful Configuration Flag: When set, this tells
    hosts to use an administered or stateful autoconfiguration method for information
    other than addresses. |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '| O | 1/8 (1 位) | 其他状态配置标志：当设置时，这告诉主机对于地址以外的信息使用管理或状态自动配置方法。|'
- en: '| Reserved | 6/8 (6 bits) | Reserved for future use; sent as zeros. |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 6/8 (6 位) | 保留供将来使用；发送为零。|'
- en: ICMPv6 Router Solicitation Message Format
  id: totrans-629
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv6 路由器请求消息格式
- en: The format of an ICMPv6 Router Solicitation message is shown in [Table 35-4](ch35s02.html#icmpv_router_solicitation_message_-id001
    "Table 35-4. ICMPv6 Router Solicitation Message Format") and [Figure 35-3](ch35s02.html#icmpv6_router_solicitation_message-id001
    "Figure 35-3. ICMPv6 Router Solicitation message format").
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6 路由器请求消息的格式显示在[表 35-4](ch35s02.html#icmpv_router_solicitation_message_-id001
    "表 35-4. ICMPv6 路由器请求消息格式")和[图 35-3](ch35s02.html#icmpv6_router_solicitation_message-id001
    "图 35-3. ICMPv6 路由器请求消息格式")中。
- en: Table 35-4. ICMPv6 Router Solicitation Message Format
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 表 35-4. ICMPv6 路由器请求消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Router Solicitation messages,
    the value is 133. |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别 ICMPv6 消息类型；对于路由器请求消息，值为 133。|'
- en: '| Code | 1 | Not used; set to 0. |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 未使用；设置为 0。|'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | 用于 ICMP 头部的 16 位校验和字段（见[第 31 章](ch31.html "第 31 章。ICMP 概念和一般操作"））。|'
- en: '| Reserved | 4 | The 4 reserved bytes set to 0. |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 4 | 4 个保留字节设置为 0。|'
- en: '| Options | Variable | If the device sending the Router Solicitation knows
    its layer 2 address, it should be included in a Source Link-Layer Address option.
    Option formats are described in the "ICMPv6 Informational Message Options" section
    later in this chapter. |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 可变 | 如果发送路由器请求的设备知道其第 2 层地址，则应将其包含在源链路层地址选项中。选项格式在本书本章后面的“ICMPv6 信息性消息选项”部分中描述。|'
- en: '![ICMPv6 Router Solicitation message format](httpatomoreillycomsourcenostarchimages288003.png)'
  id: totrans-639
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6 路由器请求消息格式](httpatomoreillycomsourcenostarchimages288003.png)'
- en: Figure 35-3. ICMPv6 Router Solicitation message format
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 图 35-3. ICMPv6 路由器请求消息格式
- en: Addressing of Router Advertisement and Router Solicitation Messages
  id: totrans-641
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器通告和路由器请求消息的寻址
- en: Router Solicitation messages are normally sent to the IPv6 "all routers" multicast
    address; this is the most efficient method, because routers are required to subscribe
    to this multicast address while hosts will ignore it. A routine (unsolicited)
    Router Advertisement message is sent to all devices using the "all nodes" multicast
    address for the local network. A Router Advertisement message that is sent in
    response to a Router Solicitation message goes in unicast back to the device that
    sent the solicitation.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器请求消息通常发送到 IPv6 的“所有路由器”多播地址；这是最有效的方法，因为路由器需要订阅此多播地址，而主机将忽略它。一个常规（非请求）的路由器通告消息发送到使用本地网络“所有节点”多播地址的所有设备。响应路由器请求消息发送的路由器通告消息以单播形式返回到发送请求的设备。
- en: Tip
  id: totrans-643
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** ICMPv6 *Router Advertisement* messages are sent regularly by
    IPv6 routers to inform hosts of their presence and characteristics, and to provide
    hosts with parameters that they need to function properly on the local network.
    A host that wants to find out immediately which routers are present may send a
    *Router Solicitation* message, which will prompt listening routers to send out
    Router Advertisements.'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ICMPv6 *路由器通告* 消息由 IPv6 路由器定期发送，以通知主机其存在和特性，并为主机提供它们在本地网络中正常工作所需的参数。想要立即了解哪些路由器存在的宿主机可以发送一个
    *路由器请求* 消息，这将促使监听的路由器发送路由器通告。'
- en: ICMPv6 Neighbor Advertisement and Neighbor Solicitation Messages
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv6 邻居通告和邻居请求消息
- en: The previous section described the Router Advertisement and Router Solicitation
    messages, which are used to facilitate host–Router Discovery functions as part
    of the IPv6 ND protocol. The other main group of tasks for which ND is responsible
    relates to the exchange of information between neighboring hosts on the same network.
    I call these *host-host communication* or *host-host discovery* functions.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节描述了路由器通告和路由器请求消息，这些消息用于协助主机-路由器发现功能，作为 IPv6 ND 协议的一部分。ND 负责的另一组主要任务是处理同一网络上的相邻主机之间的信息交换。我称这些为
    *主机-主机通信* 或 *主机-主机发现* 功能。
- en: 'Arguably, the most important additions to the ND protocol are the functions
    that formalize the exchange of parameters and the methods that determine the existence
    of neighboring hosts. These tasks include the new method of address resolution
    in IPv6 as well as the processes of next-hop determination and neighbor unreachability
    detection. They require the use of two ICMPv6 messages: the *Neighbor Solicitation
    message* and the *Neighbor Advertisement message*.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认，ND 协议最重要的补充是那些形式化参数交换的功能以及确定相邻主机存在的方法。这些任务包括 IPv6 中新的地址解析方法，以及下一跳确定和邻居不可达检测的过程。它们需要使用两个
    ICMPv6 消息：*邻居请求消息*和*邻居通告消息*。
- en: The Neighbor Solicitation message allows a device to check that a neighbor exists
    and is reachable, and lets a device initiate address resolution. The Neighbor
    Advertisement message confirms the existence of a host or router, and also provides
    layer 2 address information when needed. As you can see, these two messages are
    comparable to the Router Advertisement and Router Solicitation messages, but they
    are used differently and include different parameters.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 邻居请求消息允许设备检查邻居是否存在且可到达，并允许设备启动地址解析。邻居通告消息确认主机或路由器的存在，并在需要时提供层 2 地址信息。正如您所看到的，这两条消息与路由器通告和路由器请求消息类似，但它们的使用方式不同，并且包含不同的参数。
- en: ICMPv6 Neighbor Advertisement Message Format
  id: totrans-649
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv6 邻居通告消息格式
- en: The format for the Neighbor Advertisement message is shown in [Table 35-5](ch35s03.html#icmpv_neighbor_advertisement_message_for
    "Table 35-5. ICMPv6 Neighbor Advertisement Message Format") and [Figure 35-4](ch35s03.html#icmpv6_neighbor_advertisement_mess-id001
    "Figure 35-4. ICMPv6 Neighbor Advertisement message format").
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 邻居通告消息的格式显示在[表 35-5](ch35s03.html#icmpv_neighbor_advertisement_message_for "表
    35-5。ICMPv6 邻居通告消息格式")和[图 35-4](ch35s03.html#icmpv6_neighbor_advertisement_mess-id001
    "图 35-4。ICMPv6 邻居通告消息格式")中。
- en: Table 35-5. ICMPv6 Neighbor Advertisement Message Format
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 表 35-5. ICMPv6 邻居通告消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Neighbor Advertisement
    messages, the value is 136. |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别 ICMPv6 消息类型；对于邻居通告消息，值为 136。|'
- en: '| Code | 1 | Not used; set to 0. |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 未使用；设置为 0。|'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP 头部的 16 位校验和字段（见[第 31 章](ch31.html "第 31 章。ICMP 概念和一般操作"））。|'
- en: '| Flags | 4 | Three flags that convey information about the message (and a
    lot of empty space for future use), as described in [Table 35-6](ch35s03.html#icmpv_neighbor_advertisement_message_fla
    "Table 35-6. ICMPv6 Neighbor Advertisement Message Flags"). |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 4 | 三个标志，用于传达有关消息的信息（以及大量用于未来的空空间），如[表 35-6](ch35s03.html#icmpv_neighbor_advertisement_message_fla
    "表 35-6。ICMPv6 邻居通告消息标志")中所述。|'
- en: '| Target Address | 16 | If the Neighbor Advertisement is being sent in response
    to a Neighbor Solicitation, this is the same value as in the Target Address field
    of the Solicitation. This field will commonly contain the IPv6 address of the
    device, thereby sending the Neighbor Advertisement, but not in all cases. For
    example, if a device responds as a proxy for the target of the Neighbor Solicitation,
    the Target Address field contains the address of the target, not the device sending
    the response. (See [Chapter 13](ch13.html "Chapter 13. ADDRESS RESOLUTION AND
    THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)") for details on address resolution
    proxying.) If the Neighbor Advertisement is being sent unsolicited, then this
    is the IPv6 address of the device sending it. |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| 目标地址 | 16 | 如果邻居通告是响应邻居请求而发送的，则此值与请求中的目标地址字段相同。此字段通常包含设备的 IPv6 地址，从而发送邻居通告，但并非所有情况都是如此。例如，如果设备作为邻居请求目标的代理进行响应，则目标地址字段包含目标地址，而不是发送响应的设备地址。（有关地址解析代理的详细信息，请参阅[第
    13 章](ch13.html "第 13 章。地址解析和 TCP/IP 地址解析协议 (ARP)"))。如果邻居通告是无请求发送的，则这是发送它的设备的
    IPv6 地址。|'
- en: '| Options | Variable | When sent in response to a multicast Neighbor Solicitation,
    a Neighbor Advertisement message must contain a Target Link-Layer Address option,
    which carries the link-layer address of the device sending the message. This is
    a good example of an option that''s not really "optional." When the Neighbor Advertisement
    is sent in response to a unicast Neighbor Solicitation, this option is technically
    not required (since the sender of the Solicitation must already have the target''s
    link-layer address to have sent it unicast). Despite this, it is still normally
    included to ensure that the link-layer address of the target is refreshed in the
    cache of the device that sent the Neighbor Solicitation. |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 可变 | 当作为对多播邻居请求的响应发送时，邻居通告消息必须包含一个目标链路层地址选项，该选项携带发送消息的设备的链路层地址。这是一个实际上并非“可选”的选项的例子。当邻居通告作为对单播邻居请求的响应发送时，此选项在技术上不是必需的（因为请求的发送者必须已经拥有目标链路层地址才能发送单播）。尽管如此，它通常仍然被包含，以确保目标链路层地址在发送邻居请求的设备的缓存中得到更新。
    |'
- en: '![ICMPv6 Neighbor Advertisement message format](httpatomoreillycomsourcenostarchimages288005.png.jpg)'
  id: totrans-660
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6邻居通告消息格式](httpatomoreillycomsourcenostarchimages288005.png.jpg)'
- en: Figure 35-4. ICMPv6 Neighbor Advertisement message format
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 图35-4. ICMPv6邻居通告消息格式
- en: Table 35-6. ICMPv6 Neighbor Advertisement Message Flags
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 表35-6. ICMPv6邻居通告消息标志
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| R | 1/8 (1 bit) | Router Flag: Set when a router sends a Neighbor Advertisement,
    and cleared when a host sends one. This identifies the type of device that sent
    the datagram, and is also used as part of neighbor unreachability detection to
    detect when a device changes from acting as a router to functioning as a regular
    host. |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
  zh: '| R | 1/8（1位） | 路由器标志：当路由器发送邻居通告时设置，当主机发送时清除。这标识了发送数据报的设备类型，并用于作为邻居不可达性检测的一部分，以检测设备从充当路由器变为作为常规主机时的变化。
    |'
- en: '| S | 1/8 (1 bit) | Solicited Flag: When set, indicates that this message was
    sent in response to a Neighbor Solicitation message. Cleared for unsolicited Neighbor
    Advertisements. |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '| S | 1/8（1位） | 请求标志：当设置时，表示此消息是在响应邻居请求消息时发送的。对于非请求的邻居通告清除。 |'
- en: '| O | 1/8 (1 bit) | Override Flag: When set, tells the recipient that the information
    in this message should override any existing cached entry for the link-layer address
    of this device. This bit is normally set in unsolicited Neighbor Advertisements,
    since these are sent when a host needs to force a change of information in the
    caches of its neighbors. |'
  id: totrans-667
  prefs: []
  type: TYPE_TB
  zh: '| O | 1/8（1位） | 覆盖标志：当设置时，告诉接收方，此消息中的信息应覆盖该设备链路层地址的任何现有缓存条目。此位通常在非请求的邻居通告中设置，因为这些消息是在主机需要强制更改其邻居缓存中的信息时发送的。
    |'
- en: '| Reserved | 3 5/8 (29 bits) | A big set of reserved bits. |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 3 5/8（29位） | 一组大的保留位。 |'
- en: ICMPv6 Neighbor Solicitation Message Format
  id: totrans-669
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv6邻居请求消息格式
- en: The Neighbor Solicitation message format is much simpler, as shown in [Table 35-7](ch35s03.html#icmpv_neighbor_solicitation_message_form
    "Table 35-7. ICMPv6 Neighbor Solicitation Message Format") and [Figure 35-5](ch35s03.html#icmpv6_neighbor_solicitation_messa-id001
    "Figure 35-5. ICMPv6 Neighbor Solicitation message format").
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 邻居请求消息的格式非常简单，如[表35-7](ch35s03.html#icmpv_neighbor_solicitation_message_form
    "表35-7. ICMPv6邻居请求消息格式")和[图35-5](ch35s03.html#icmpv6_neighbor_solicitation_messa-id001
    "图35-5. ICMPv6邻居请求消息格式")所示。
- en: Table 35-7. ICMPv6 Neighbor Solicitation Message Format
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 表35-7. ICMPv6邻居请求消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Neighbor Solicitation
    messages, the value is 135. |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 标识ICMPv6消息类型；对于邻居请求消息，值为135。 |'
- en: '| Code | 1 | Not used; set to 0. |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 未使用；设置为0。 |'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP头部（见[第31章](ch31.html "第31章. ICMP概念和一般操作"））的16位校验和字段。 |'
- en: '| Reserved | 4 | The 4 reserved bytes set to 0. |'
  id: totrans-677
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 4 | 设置为0的4个保留字节。 |'
- en: '| Target Address | 16 | The IPv6 address of the target of the solicitation.
    For IPv6 address resolution, this is the actual unicast IP address of the device
    whose layer 2 (link-layer) address we are trying to resolve. |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '| 目标地址 | 16 | 请求的目标的IPv6地址。对于IPv6地址解析，这是我们试图解析的层2（链路层）地址的设备的实际单播IP地址。 |'
- en: '| Options | Variable | If the device sending the Neighbor Solicitation knows
    both its own IP address and layer 2 address, it should include the layer 2 address
    in a Source Link-Layer Address option. The inclusion of this option will allow
    the destination of the Neighbor Solicitation to enter the layer 2 and layer 3
    addresses of the source of this message into its own address cache. (See the discussion
    of IPv6 address resolution in [Chapter 25](ch25.html "Chapter 25. IPV6 ADDRESSING").)
    |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 可变 | 如果发送邻居请求的设备知道自己的IP地址和链路层地址，它应该在源链路层地址选项中包含链路层地址。包含此选项将允许邻居请求的目的地将其消息源方的链路层和三层地址输入到自己的地址缓存中。（参见[第25章](ch25.html
    "第25章。IPv6寻址")中关于IPv6地址解析的讨论。） |'
- en: '![ICMPv6 Neighbor Solicitation message format](httpatomoreillycomsourcenostarchimages288007.png)'
  id: totrans-680
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6 邻居请求消息格式](httpatomoreillycomsourcenostarchimages288007.png)'
- en: Figure 35-5. ICMPv6 Neighbor Solicitation message format
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 图35-5. ICMPv6 邻居请求消息格式
- en: Addressing of Neighbor Advertisement and Neighbor Solicitation Messages
  id: totrans-682
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻居通告和邻居请求消息的寻址
- en: Neighbor Solicitation messages are sent either unicast to the address of the
    target device or to the solicited-node multicast address of the target. This latter
    address is a special type that's used to allow a device to send a multicast that
    will be heard by the target whose address it is trying to resolve, but won't be
    heard by most other devices; it is explained in [Chapter 25](ch25.html "Chapter 25. IPV6
    ADDRESSING"), which describes IPv6 address resolution.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 邻居请求消息要么是单播发送到目标设备的地址，要么发送到目标设备的请求节点多播地址。后者是一种特殊类型，允许设备发送一个多播，该多播将被尝试解析地址的目标设备听到，但不会被大多数其他设备听到；这已在[第25章](ch25.html
    "第25章。IPv6寻址")中解释，该章节描述了IPv6地址解析。
- en: When a Neighbor Advertisement message is generated in response to a Neighbor
    Solicitation message, it is sent unicast back to the device that sent the Solicitation
    message, unless that message was sent from the unspecified address, in which case
    it is multicast to the "all nodes" multicast address. If the Neighbor Advertisement
    message is sent unsolicited (for example, by a device that wishes to inform others
    of a change in link-layer address), it is sent to the "all nodes" multicast address.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 当响应邻居请求消息生成邻居通告消息时，它将单播发送回发送请求消息的设备，除非该消息是从未指定地址发送的，在这种情况下，它将多播发送到“所有节点”多播地址。如果邻居通告消息是非请求发送的（例如，由希望通知他人链路层地址变化的设备发送），它将发送到“所有节点”多播地址。
- en: Tip
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** ICMPv6 *Neighbor Advertisement* and *Neighbor Solicitation*
    messages are similar in many ways to the Router Advertisement and Router Solicitation
    messages. However, rather than being used to communicate parameters from routers
    to hosts, they are used for various types of communication between hosts on a
    physical network, such as address resolution, next-hop determination, and neighbor
    unreachability detection.'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ICMPv6 *邻居通告* 和 *邻居请求* 消息在许多方面与路由器通告和路由器请求消息相似。然而，它们不是用来从路由器向主机传递参数，而是用于物理网络中主机之间的各种通信，例如地址解析、下一跳确定和邻居不可达检测。'
- en: ICMPv6 Redirect Messages
  id: totrans-687
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv6 重定向消息
- en: Because of the different roles of routers and hosts in an IPv6 internetwork,
    hosts don't need to know very much about routes. They send datagrams intended
    for destinations on the local network directly, while they send those for other
    networks to their local routers and let them "do the driving," so to speak.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在IPv6互联网中路由器和主机扮演着不同的角色，因此主机不需要了解太多的路由信息。它们直接将目的地为本地网络的数据报发送出去，而对于其他网络的数据报，则发送给本地的路由器，让它们“驾驶”，换句话说。
- en: If a local network has only a single router, it will send all such nonlocal
    traffic to that router. If it has more than one local router, the host then must
    decide which router to use for which traffic. In general terms, a host will not
    know the most efficient choice of router for every type of datagram it may need
    to send. In fact, many nodes start out with a limited routing table that says
    to send *everything* to a single default router, even if there are several routers
    on the network.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个本地网络只有一个路由器，它将所有此类非本地流量发送到该路由器。如果有多个本地路由器，那么主机必须决定为哪种流量使用哪个路由器。一般来说，主机不会知道为它可能需要发送的每种数据报选择最有效路由器的方法。实际上，许多节点最初都有一个有限的路由表，指示将*所有*流量发送到单个默认路由器，即使网络上有多个路由器。
- en: When a router receives datagrams destined for certain networks, it may realize
    that it would be more efficient if a host to a different router on the local network
    sent such traffic. If so, it will invoke the Redirect function by sending an ICMPv6
    *Redirect* message to the device that sent the original datagram. This is the
    last of the functions that is performed in IPv6 by the ND protocol and is explained
    in [Chapter 36](ch36.html "Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL").
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器接收到指向某些网络的数据报时，它可能会意识到如果本地网络上不同路由器上的主机发送此类流量会更有效率。如果是这样，它将通过向发送原始数据报的设备发送
    ICMPv6 *重定向* 消息来调用重定向功能。这是 IPv6 中 ND 协议执行的最后一个功能，并在[第 36 章](ch36.html "第 36 章.
    IPv6 邻居发现 (ND) 协议")中解释。
- en: Note
  id: totrans-691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '*In ICMPv6, the Redirect message is informational and no longer considered
    an error message as it was in ICMPv4*.'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 ICMPv6 中，重定向消息是信息性的，不再被视为错误消息，就像在 ICMPv4 中那样*。'
- en: ICMPv6 Redirect Message Format
  id: totrans-693
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv6 重定向消息格式
- en: The format of ICMPv6 Redirect messages is shown in [Table 35-8](ch35s04.html#icmpv_redirect_message_format-id001
    "Table 35-8. ICMPv6 Redirect Message Format") and [Figure 35-6](ch35s04.html#icmpv6_redirect_message_format-id001
    "Figure 35-6. ICMPv6 Redirect message format").
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: ICMPv6 重定向消息的格式显示在[表 35-8](ch35s04.html#icmpv_redirect_message_format-id001
    "表 35-8. ICMPv6 重定向消息格式")和[图 35-6](ch35s04.html#icmpv6_redirect_message_format-id001
    "图 35-6. ICMPv6 重定向消息格式")中。
- en: Table 35-8. ICMPv6 Redirect Message Format
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 表 35-8. ICMPv6 重定向消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Redirect messages, the
    value is 137. |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 标识 ICMPv6 消息类型；对于重定向消息，值为 137。 |'
- en: '| Code | 1 | Not used; set to 0. |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 未使用；设置为 0。 |'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-700
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP 头部的 16 位校验和字段（见[第 31 章](ch31.html "第 31 章. ICMP 概念和一般操作"））。
    |'
- en: '| Reserved | 4 | The 4 bytes sent as zeros. |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 4 | 发送为零的 4 个字节。 |'
- en: '| Target Address | 16 | The address of the router that the router creating
    the Redirect is telling the recipient of the Redirect to use as a first hop for
    future transmissions to the destination. For example, if Router R2 generated a
    Redirect telling Host A that, in the future, transmissions to Host B should be
    sent first to Router R1, then Router R1''s IPv6 address would be in this field.
    |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '| 目标地址 | 16 | 路由器创建重定向时告诉重定向接收者用作未来传输到目标的第一跳的路由器地址。例如，如果路由器 R2 生成一个重定向，告诉主机
    A，将来向主机 B 的传输应首先发送到路由器 R1，那么路由器 R1 的 IPv6 地址将在这个字段中。 |'
- en: '| Destination Address | 16 | The address of the device whose future transmissions
    are being redirected; this is the destination of the datagram that originally
    led to the Redirect being generated. Repeating the previous example: If Router
    R2 generated a Redirect telling Host A that, in the future, transmissions to Host
    B should be sent first to Router R1, then Host B''s IPv6 address would be in this
    field. |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '| 目标地址 | 16 | 正在被重定向的设备的地址；这是最初导致生成重定向的数据报的目标。重复之前的例子：如果路由器 R2 生成一个重定向，告诉主机
    A，将来向主机 B 的传输应首先发送到路由器 R1，那么主机 B 的 IPv6 地址将在这个字段中。 |'
- en: '| Options | Variable | Redirect messages normally include two ICMPv6 option
    fields (see the "ICMPv6 Informational Message Options" section later in this chapter):'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '| 选项 | 可变 | 重定向消息通常包括两个 ICMPv6 选项字段（见本章后面的“ICMPv6 信息性消息选项”部分）：'
- en: 'Target Link-Layer Address: The layer 2 address of the Target Address, if known.
    This saves the recipient of the Redirect message from needing to perform an address
    resolution on the target.'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标链路层地址：如果已知，为目标地址的层 2 地址。这可以节省重定向消息的接收者不需要在目标上进行地址解析。
- en: 'Redirected Header: As much of the IPv6 datagram that spawned this Redirect
    as will fit without causing the size of the ICMPv6 error message (including its
    own IP header) to exceed the minimum IPv6 MTU of 1280 bytes.'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向头部：尽可能多的 IPv6 数据报，以避免使 ICMPv6 错误消息（包括其自己的 IP 头部）的大小超过最小 IPv6 MTU 1280 字节。
- en: '|'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![ICMPv6 Redirect message format](httpatomoreillycomsourcenostarchimages288009.png)'
  id: totrans-708
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6 重定向消息格式](httpatomoreillycomsourcenostarchimages288009.png)'
- en: Figure 35-6. ICMPv6 Redirect message format
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 图 35-6. ICMPv6 重定向消息格式
- en: Redirect messages are always sent in unicast to the address of the device that
    originally sent the datagram that originally created the Redirect message.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向消息始终以单播方式发送到最初发送原始数据报并创建重定向消息的设备的地址。
- en: Application of Redirect Messages
  id: totrans-711
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向消息的应用
- en: The Redirect message has always been somewhat of an oddball. In ICMPv4, it is
    considered an error message, but this makes it different from other error messages.
    For one thing, it's not really an error, since it doesn't represent a failure
    to deliver, only an inefficiency in doing so. For this reason, in ICMPv6 it was
    moved into the set of informational message types. Here, too, it doesn't really
    fit in with the others, since it is sent in reaction to a regular IP message,
    and it also includes a copy of (part of) the datagram that spawned it, as error
    messages do.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向消息一直有点儿另类。在ICMPv4中，它被视为错误消息，但这使其与其他错误消息不同。首先，它实际上并不是错误，因为它并不代表交付失败，而只是交付过程中的低效。因此，在ICMPv6中，它被移动到了信息消息类型集合中。在这里，它也并不真正与其他消息相匹配，因为它是对常规IP消息的反应，并且它还包含（部分）产生它的数据报的副本，就像错误消息一样。
- en: Tip
  id: totrans-713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** ICMPv6 *Redirect* messages are used by a router to inform a
    host of a better router to use for future datagrams that were sent to a particular
    host or network. They are not used to alter routes between routers, however.'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ICMPv6 *重定向*消息由路由器用来通知主机一个更好的路由器，用于将来发送到特定主机或网络的报文。然而，它们并不用于更改路由器之间的路由。'
- en: ICMPv6 Router Renumbering Messages
  id: totrans-715
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv6 路由器重新编号消息
- en: One of the more interesting decisions made in IPv6 was the selection of a very
    large 128-bit address size. This provides an address space far larger than what
    humans are ever likely to need, and probably larger than needed for IPv6, strictly
    speaking. What this wealth of bits provides is the flexibility to assign meaning
    to different bits in the address structure. This, in turn, serves as the basis
    for important features such as the autoconfiguration and automated renumbering
    of IPv6 addresses.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv6中做出的更有趣的决定之一是选择了一个非常大的128位地址大小。这提供了一个远远超过人类可能需要的地址空间，实际上可能比IPv6严格来说所需的还要大。这些比特的丰富性提供了为地址结构中的不同比特分配含义的灵活性。这反过来又为诸如IPv6地址的自动配置和自动重新编号等重要特性奠定了基础。
- en: IPv6 Router Renumbering
  id: totrans-717
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6 路由器重新编号
- en: The renumbering feature in IPv6 is of particular interest to network administrators,
    since it has the potential to make large network migrations and merges much simpler.
    In August 2000, the IETF published RFC 2894, "Router Renumbering for IPv6," which
    describes a similar technique that allows routers in an autonomous system to be
    renumbered by giving them new prefixes (network identifiers).
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6中的重新编号功能对网络管理员来说特别有趣，因为它有可能使大型网络迁移和合并变得更加简单。2000年8月，IETF发布了RFC 2894，“IPv6路由器重新编号”，它描述了一种类似的技术，允许自治系统中的路由器通过给它们新的前缀（网络标识符）来进行重新编号。
- en: Router renumbering is actually a fairly simple process, especially if we avoid
    the gory details, which is exactly what I intend to do. A network administrator
    uses a device on the internetwork to generate one or more *Router Renumbering
    Command* messages. These messages provide a list of prefixes of routers that are
    to be renumbered. Each router processes these messages to see if the addresses
    on any of their interfaces match the specified prefixes. If so, they change the
    matched prefixes to the new ones specified in the message. Additional information
    is also included in the Router Renumbering Command message to control how and
    when the renumbering is done.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器重新编号实际上是一个相当简单的过程，特别是如果我们避免那些血腥的细节，这正是我的意图。网络管理员使用互联网上的设备生成一个或多个*路由器重新编号命令*消息。这些消息提供了一个要重新编号的路由器前缀列表。每个路由器处理这些消息，以查看它们接口上的地址是否与指定的前缀匹配。如果是这样，它们将匹配的前缀更改为消息中指定的新前缀。路由器重新编号命令消息中还包含其他信息，以控制重新编号如何以及何时进行。
- en: If requested, each router processing a Command message will respond with a *Router
    Renumbering Result* message. This serves as feedback to the originator of the
    Command message, indicating whether the renumbering was successful, and what changes,
    if any, were made.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求，每个处理命令消息的路由器将响应一个*路由器重新编号结果*消息。这作为对命令消息发起者的反馈，表明重新编号是否成功，以及是否进行了任何更改。
- en: The router renumbering standard also defines a few important management features.
    Many of these reflect the great power of something that can mass-renumber routers,
    and hence, they represent the potential for such power to be abused. Command messages
    may be sent in a test mode, in which they are processed but the renumbering is
    not actually done. Messages include a sequence number to guard against replay
    attacks, and a special *Sequence Number Reset* message can be used to reset the
    sequence number information that was previously sent. For added security, the
    standard specifies that messages be authenticated and have their identity checked.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 路由重编号标准还定义了一些重要的管理功能。其中许多反映了大规模重编号路由器的强大功能，因此，它们代表了这种权力被滥用的潜在可能性。命令消息可以在测试模式下发送，此时它们会被处理，但实际的重编号并不会执行。消息包括一个序列号以防止重放攻击，并且可以使用特殊的*序列号重置*消息来重置之前发送的序列号信息。为了增加安全性，标准规定消息必须经过身份验证，并检查其身份。
- en: ICMPv6 Router Renumbering Message Format
  id: totrans-722
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ICMPv6 路由重编号消息格式
- en: The format of Router Renumbering messages is shown in [Table 35-9](ch35s05.html#icmpv_router_renumbering_message_format
    "Table 35-9. ICMPv6 Router Renumbering Message Format") and [Figure 35-7](ch35s05.html#icmpv6_router_renumbering_message_-id001
    "Figure 35-7. ICMPv6 Router Renumbering message format").
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 路由重编号消息的格式显示在[表35-9](ch35s05.html#icmpv_router_renumbering_message_format "表35-9.
    ICMPv6 路由重编号消息格式")和[图35-7](ch35s05.html#icmpv6_router_renumbering_message_-id001
    "图35-7. ICMPv6 路由重编号消息格式")中。
- en: '![ICMPv6 Router Renumbering message format](httpatomoreillycomsourcenostarchimages288011.png.jpg)'
  id: totrans-724
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6 路由重编号消息格式](httpatomoreillycomsourcenostarchimages288011.png.jpg)'
- en: Figure 35-7. ICMPv6 Router Renumbering message format
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 图35-7. ICMPv6 路由重编号消息格式
- en: Table 35-9. ICMPv6 Router Renumbering Message Format
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 表35-9. ICMPv6 路由重编号消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 message type; for Router Renumbering messages,
    the value is 138. |'
  id: totrans-729
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别 ICMPv6 消息类型；对于路由重编号消息，该值为 138。 |'
- en: '| Code | 1 | Indicates the subtype of Router Renumbering message:0 = Router
    Renumbering Command1 = Router Renumbering Result255 = Sequence Number Reset |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 指示路由重编号消息的子类型：0 = 路由重编号命令1 = 路由重编号结果255 = 序列号重置 |'
- en: '| Checksum | 2 | A 16-bit checksum field for the ICMP header (see [Chapter 31](ch31.html
    "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")). |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | ICMP头部的一个16位校验和字段（见[第31章](ch31.html "第31章. ICMP 概念和一般操作"））。 |'
- en: '| Sequence Number | 4 | A 32-bit number that guards against replay attacks
    by letting a recipient detect stale, duplicate, or out-of-order commands. |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
  zh: '| 序列号 | 4 | 一个32位数字，通过让接收方检测过时、重复或顺序错误的命令来防止重放攻击。 |'
- en: '| Segment Number | 1 | Differentiates between valid Router Renumbering messages
    within the same Sequence Number. |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
  zh: '| 段编号 | 1 | 区分同一序列号内的有效路由重编号消息。 |'
- en: '| Flags | 1 | Five flags used to control the renumbering process, as described
    in [Table 35-10](ch35s05.html#icmpv_router_renumbering_message_flags "Table 35-10. ICMPv6
    Router Renumbering Message Flags"). |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 1 | 五个用于控制重编号过程的标志，如[表35-10](ch35s05.html#icmpv_router_renumbering_message_flags
    "表35-10. ICMPv6 路由重编号消息标志")中所述。 |'
- en: '| Max Delay | 2 | Tells a router receiving a message the maximum amount of
    time (in milliseconds) it is allowed to delay before sending a reply. |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
  zh: '| 最大延迟 | 2 | 告知接收消息的路由，在发送回复之前允许的最大延迟时间（以毫秒为单位）。 |'
- en: '| Reserved | 4 | The 4 reserved bytes. |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 4 | 4个保留字节。 |'
- en: '| Message Body | Variable | For a Router Renumbering Command, the message body
    contains two sets of information. The first is a Match-Prefix Part for the prefix
    being renumbered. The second is one or more Use-Prefix Parts that describe the
    new prefix for each match. A router receiving a Command checks its own interface
    addresses, and if they match the Match-Prefix-Part, they use Use-Prefix Parts
    data to accomplish the renumbering.For a Router Renumbering Result, the message
    body contains zero or more Match Results entries that describe each prefix that
    a router has matched from a Router Renumbering Command. Each entry provides information
    about whether renumbering for a prefix was successful. |'
  id: totrans-737
  prefs: []
  type: TYPE_TB
  zh: '| 消息体 | 可变 | 对于路由器重新编号命令，消息体包含两套信息。第一套是正在重新编号的前缀的匹配前缀部分。第二套是描述每个匹配的新前缀的一个或多个使用前缀部分。接收命令的路由器检查其自己的接口地址，如果它们与匹配前缀部分匹配，则使用使用前缀部分数据来完成重新编号。对于路由器重新编号结果，消息体包含零个或多个匹配结果条目，描述路由器从路由器重新编号命令中匹配的每个前缀。每个条目都提供有关前缀重新编号是否成功的信息。|'
- en: '[Table 35-10](ch35s05.html#icmpv_router_renumbering_message_flags "Table 35-10. ICMPv6
    Router Renumbering Message Flags") shows the Router Renumbering Message flags.
    The first four flags (T, R, A, and S) control the operation of Command messages.
    They are just copied verbatim in a Result message from the Command message that
    led to the Result message being created. The P flag is used only in Result messages
    (0 in Command messages).'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 35-10](ch35s05.html#icmpv_router_renumbering_message_flags "表 35-10. ICMPv6
    路由重新编号消息标志") 显示了路由器重新编号消息标志。前四个标志（T、R、A 和 S）控制命令消息的操作。它们只是从导致结果消息创建的命令消息中逐字复制到结果消息中。P
    标志仅在结果消息中使用（命令消息中为 0）。'
- en: Table 35-10. ICMPv6 Router Renumbering Message Flags
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 表 35-10. ICMPv6 路由重新编号消息标志
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-740
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| T | 1/8 (1 bit) | Test Command Flag: When set to 1, this flags this Command
    messageas being a test message. This tells the recipient to only simulate processing
    of the renumbering, not to actually do it. |'
  id: totrans-742
  prefs: []
  type: TYPE_TB
  zh: '| T | 1/8（1 位） | 测试命令标志：当设置为 1 时，此标志将此命令消息标记为测试消息。这告诉接收者仅模拟处理重新编号，而不要实际执行。|'
- en: '| R | 1/8 (1 bit) | Result Requested Flag: When set to 1, requests that a Result
    message be sent after processing the Command message. When set to 0, says not
    to send one. |'
  id: totrans-743
  prefs: []
  type: TYPE_TB
  zh: '| R | 1/8（1 位） | 请求结果标志：当设置为 1 时，请求在处理命令消息后发送结果消息。当设置为 0 时，表示不发送。|'
- en: '| A | 1/8 (1 bit) | All Interfaces Flag: When this flag is clear (0), the Command
    message is not applied to any router interfaces that have been administratively
    shut down. When 1, it is applied to all interfaces. |'
  id: totrans-744
  prefs: []
  type: TYPE_TB
  zh: '| A | 1/8（1 位） | 所有接口标志：当此标志清除（0）时，命令消息不应用于任何已由管理员关闭的路由器接口。当为 1 时，它应用于所有接口。|'
- en: '| S | 1/8 (1 bit) | Site-Specific Flag: This flag has meaning only when a router
    treats its interfaces as belonging to different sites. If so, a value of 1 tells
    it to apply the Command message only to interfaces on the same site as the interface
    for which the Command message was received. A value of 0 applies it to all interfaces
    regardless of site. |'
  id: totrans-745
  prefs: []
  type: TYPE_TB
  zh: '| S | 1/8（1 位） | 站点特定标志：当路由器将其接口视为属于不同站点时，此标志才有意义。如果是这样，值为 1 表示仅将命令消息应用于与接收命令消息的接口相同的站点的接口。值为
    0 表示应用于所有接口，无论站点如何。|'
- en: '| P | 1/8 (1 bit) | Processed Previously Flag: This flag is normally 0, meaning
    the Command message was not previously seen and the Result message contains the
    report of processing it. When 1, this indicates that the recipient of the Command
    message believes it has seen it before and is not processing it. (Test commands
    are not included in the assessment of whether a Command message has been seen
    before.) |'
  id: totrans-746
  prefs: []
  type: TYPE_TB
  zh: '| P | 1/8（1 位） | 之前已处理标志：此标志通常为 0，表示命令消息之前未见过，结果消息包含处理它的报告。当为 1 时，这表示命令消息的接收者认为它之前已经见过，并且不会处理它。（测试命令不包括在评估命令消息之前是否已见过。）|'
- en: '| Reserved | 3/8 (3 bits) | Three bits reserved for future flags. |'
  id: totrans-747
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 3/8（3 位） | 保留用于未来标志的 3 位。|'
- en: Addressing of Router Renumbering Messages
  id: totrans-748
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器重新编号消息的寻址
- en: Since Router Renumbering messages are intended for all routers on a site, they
    are normally sent to the "all routers" multicast address, using either link-local
    or site-local scope. They may also be sent to local unicast addresses.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路由器重新编号消息旨在发送到站点的所有路由器，它们通常发送到“所有路由器”多播地址，使用链路本地或站点本地范围。它们也可以发送到本地单播地址。
- en: ICMPv6 Informational Message Options
  id: totrans-750
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMPv6 信息消息选项
- en: Each of the five ICMPv6 informational message types defined and used by the
    protocol has an Options field into which one or more options may be inserted.
    This probably isn't the best name for these sets of data, since they are only
    optional in certain cases. In fact, in some cases the option is actually the entire
    point of the message. For example, a Neighbor Advertisement message containing
    a link-layer address for address resolution carries it in an Options field, but
    the message wouldn't be of much use without it!
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 协议定义并使用的五种 ICMPv6 信息消息类型中，每种类型都有一个选项字段，可以插入一个或多个选项。这些数据集可能不是最好的名称，因为它们在某些情况下是可选的。实际上，在某些情况下，选项实际上是消息的全部目的。例如，包含地址解析链路层地址的邻居通告消息将其包含在选项字段中，但如果没有它，消息将没有太大用处！
- en: Each option has its own structure of subfields based on the classic type, length,
    and value triplet used in many message formats. The Type subfield indicates the
    option type, and the Length field indicates its length, so that the device processing
    the option can determine where it ends. The value may be contained in one or more
    fields, which hold the actual information for which the option is being used.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 每个选项都有其自己的子字段结构，基于在许多消息格式中使用的经典类型、长度和值三元组。类型子字段指示选项类型，长度字段指示其长度，这样处理选项的设备就可以确定其结束位置。值可能包含在一个或多个字段中，这些字段包含选项所使用的实际信息。
- en: Some options are used for only one kind of ICMPv6 message; others are used for
    more than one variety. So, they are best thought of as modular components used
    in different types of messages as needed. I describe the format of each of these
    five options in the following sections.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 一些选项仅用于一种类型的 ICMPv6 消息；而另一些则用于多种类型。因此，它们最好被视为根据需要在不同类型消息中使用的模块化组件。我在以下各节中描述了这些五个选项的格式。
- en: Source Link-Layer Address Option Format
  id: totrans-754
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源链路层地址选项格式
- en: The Source Link-Layer Address Option carries the link-layer address of a device
    sending an ICMPv6 message, as shown in [Table 35-11](ch35s06.html#icmpv_source_link-layer_address_option_f
    "Table 35-11. ICMPv6 Source Link-Layer Address Option Format") and [Figure 35-8](ch35s06.html#icmpv6_source_link-layer_address_option_
    "Figure 35-8. ICMPv6 Source Link-Layer Address option format"). It's used in Router
    Advertisement, Router Solicitation, and Neighbor Solicitation messages.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 源链路层地址选项携带发送 ICMPv6 消息的设备的链路层地址，如[表 35-11](ch35s06.html#icmpv_source_link-layer_address_option_f
    "表 35-11. ICMPv6 源链路层地址选项格式")和[图 35-8](ch35s06.html#icmpv6_source_link-layer_address_option_
    "图 35-8. ICMPv6 源链路层地址选项格式")所示。它在路由器通告、路由器请求和邻居请求消息中使用。
- en: Table 35-11. ICMPv6 Source Link-Layer Address Option Format
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 表 35-11. ICMPv6 源链路层地址选项格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-757
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-758
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 option type. For the Source Link-Layer Address
    option, the value is 1. |'
  id: totrans-759
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别 ICMPv6 选项类型。对于源链路层地址选项，其值为 1。 |'
- en: '| Length | 1 | The length of the entire option (including the Type and Length
    fields), expressed in units of 8 octets (64 bits). |'
  id: totrans-760
  prefs: []
  type: TYPE_TB
  zh: '| 长度 | 1 | 整个选项（包括类型和长度字段）的长度，以8个八位字节（64位）为单位。 |'
- en: '| Source Link-Layer Address | Variable | The link-layer (layer 2) address of
    the device sending the ICMPv6 message. |'
  id: totrans-761
  prefs: []
  type: TYPE_TB
  zh: '| 源链路层地址 | 可变 | 发送 ICMPv6 消息的设备的链路层（第 2 层）地址。 |'
- en: '![ICMPv6 Source Link-Layer Address option format](httpatomoreillycomsourcenostarchimages288013.png.jpg)'
  id: totrans-762
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6 源链路层地址选项格式](httpatomoreillycomsourcenostarchimages288013.png.jpg)'
- en: Figure 35-8. ICMPv6 Source Link-Layer Address option format
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 图 35-8. ICMPv6 源链路层地址选项格式
- en: Target Link-Layer Address Option Format
  id: totrans-764
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标链路层地址选项格式
- en: The Target Link-Layer Address option carries the link-layer address corresponding
    to the Target Address field in Neighbor Advertisement and Redirect messages. Its
    format is shown in [Table 35-12](ch35s06.html#icmpv_target_link-layer_address_option_f
    "Table 35-12. ICMPv6 Target Link-Layer Address Option Format") and [Figure 35-9](ch35s06.html#icmpv6_target_link-layer_address_option_
    "Figure 35-9. ICMPv6 Target Link-Layer Address option format").
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 目标链路层地址选项携带与邻居通告和重定向消息中的目标地址字段相对应的链路层地址。其格式如[表 35-12](ch35s06.html#icmpv_target_link-layer_address_option_f
    "表 35-12. ICMPv6 目标链路层地址选项格式")和[图 35-9](ch35s06.html#icmpv6_target_link-layer_address_option_
    "图 35-9. ICMPv6 目标链路层地址选项格式")所示。
- en: Table 35-12. ICMPv6 Target Link-Layer Address Option Format
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 表 35-12. ICMPv6 目标链路层地址选项格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-767
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-768
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 option type. For the Target Link-Layer Address
    option, the value is 2. |'
  id: totrans-769
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMPv6选项类型。对于目标链路层地址选项，值为2。 |'
- en: '| Length | 1 | The length of the entire option (including the Type and Length
    fields), expressed in units of 8 octets (64 bits). |'
  id: totrans-770
  prefs: []
  type: TYPE_TB
  zh: '| 长度 | 1 | 整个选项的长度（包括类型和长度字段），以8个八位字节（64位）为单位表示。 |'
- en: '| Target Link-Layer Address | Variable | The link-layer (layer 2) address of
    the target device. |'
  id: totrans-771
  prefs: []
  type: TYPE_TB
  zh: '| 目标链路层地址 | 可变 | 目标设备的链路层（第2层）地址。 |'
- en: '![ICMPv6 Target Link-Layer Address option format](httpatomoreillycomsourcenostarchimages288015.png.jpg)'
  id: totrans-772
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6目标链路层地址选项格式](httpatomoreillycomsourcenostarchimages288015.png.jpg)'
- en: Figure 35-9. ICMPv6 Target Link-Layer Address option format
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 图35-9. ICMPv6目标链路层地址选项格式
- en: Prefix Information Option Format
  id: totrans-774
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前缀信息选项格式
- en: The *Prefix Information* option provides a prefix and related information in
    Router Advertisement messages. This is the longest and most complex of the options,
    as you can see in [Table 35-13](ch35s06.html#icmpv_prefix_information_option_format
    "Table 35-13. ICMPv6 Prefix Information Option Format") and [Figure 35-10](ch35s06.html#icmpv6_prefix_information_option_format
    "Figure 35-10. ICMPv6 Prefix Information option format").
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '*前缀信息*选项在路由器通告消息中提供前缀和相关信息。这是选项中最长且最复杂的，如[表35-13](ch35s06.html#icmpv_prefix_information_option_format
    "表35-13. ICMPv6 Prefix Information Option Format")和[图35-10](ch35s06.html#icmpv6_prefix_information_option_format
    "图35-10. ICMPv6 Prefix Information option format")所示。'
- en: Table 35-13. ICMPv6 Prefix Information Option Format
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 表35-13. ICMPv6 Prefix Information Option Format
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-777
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 option type. For the Prefix Information
    option, the value is 3. |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMPv6选项类型。对于前缀信息选项，值为3。 |'
- en: '| Length | 1 | The length of the entire option (including the Type and Length
    fields), expressed in units of 8 octets (64 bits). The Prefix Information option
    is fixed in size at 32 bytes, so the value of the Length field is 4. |'
  id: totrans-780
  prefs: []
  type: TYPE_TB
  zh: '| 长度 | 1 | 整个选项的长度（包括类型和长度字段），以8个八位字节（64位）为单位表示。前缀信息选项的大小固定为32字节，因此长度字段的值为4。
    |'
- en: '| Prefix Length | 1 | The number of bits in the Prefix field that are considered
    part of the network identifier (the remainder are used for the host identifier
    and ignored). See [Chapter 25](ch25.html "Chapter 25. IPV6 ADDRESSING") for details
    on prefix lengths. |'
  id: totrans-781
  prefs: []
  type: TYPE_TB
  zh: '| 前缀长度 | 1 | 前缀字段中作为网络标识符一部分的位数（其余用于主机标识符并被忽略）。有关前缀长度的详细信息，请参阅[第25章](ch25.html
    "第25章. IPV6 ADDRESSING")。 |'
- en: '| Flags | 1 | A pair of flags that convey information about the prefix, as
    described in [Table 35-14](ch35s06.html#icmpv_prefix_information_option_flags
    "Table 35-14. ICMPv6 Prefix Information Option Flags"). |'
  id: totrans-782
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 1 | 一对标志，传达有关前缀的信息，如[表35-14](ch35s06.html#icmpv_prefix_information_option_flags
    "表35-14. ICMPv6 Prefix Information Option Flags")中所述。 |'
- en: '| Valid Lifetime | 4 | The amount of time, in seconds, that the recipient of
    the message containing this option should consider the prefix valid for purposes
    of on-link determination (see the description of the L flag in [Table 35-14](ch35s06.html#icmpv_prefix_information_option_flags
    "Table 35-14. ICMPv6 Prefix Information Option Flags")). A value of all 1s means
    infinity (forever). |'
  id: totrans-783
  prefs: []
  type: TYPE_TB
  zh: '| 有效期限 | 4 | 消息接收者应考虑此选项前缀在链路确定目的上有效的秒数（参见[表35-14](ch35s06.html#icmpv_prefix_information_option_flags
    "表35-14. ICMPv6 Prefix Information Option Flags")中L标志的描述）。全为1的值表示无限（永远）。 |'
- en: '| Preferred Lifetime | 4 | When the recipient of this prefix uses it to automatically
    generate addresses using address autoconfiguration, this specifies the amount
    of time, in seconds, that such addresses remain preferred (meaning, valid and
    freely usable). A value of all 1s means infinity (forever). |'
  id: totrans-784
  prefs: []
  type: TYPE_TB
  zh: '| 推荐寿命 | 4 | 当前缀的接收者使用它来自动生成地址时，这指定了此类地址保持首选（即有效且可自由使用）的秒数。全为1的值表示无限（永远）。 |'
- en: '| Reserved | 4 | The 4 unused bytes sent as zeros. |'
  id: totrans-785
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 4 | 发送为零的4个未使用字节。 |'
- en: '| Prefix | 16 | The prefix being communicated from the router to the host in
    the Router Advertisement message. The Prefix Length field indicates how many of
    the 128 bits in this field are significant (part of the network ID). Only these
    bits are placed in the Prefix field; the remaining bits are cleared to zero. |'
  id: totrans-786
  prefs: []
  type: TYPE_TB
  zh: '| 前缀 | 16 | 在路由器通告消息中从路由器发送到主机的正在通信的前缀。前缀长度字段指示该字段中多少个128位是有效的（网络ID的一部分）。只有这些位被放置在前缀字段中；其余位被清除为零。
    |'
- en: '![ICMPv6 Prefix Information option format](httpatomoreillycomsourcenostarchimages288017.png)'
  id: totrans-787
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6前缀信息选项格式](httpatomoreillycomsourcenostarchimages288017.png)'
- en: Figure 35-10. ICMPv6 Prefix Information option format
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 图35-10. ICMPv6前缀信息选项格式
- en: Table 35-14. ICMPv6 Prefix Information Option Flags
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 表35-14. ICMPv6前缀信息选项标志
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-791
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| L | 1/8 (1 bit) | On-Link Flag: When set to 1, tells the recipient of the
    option that this prefix can be used for on-link determination. This means the
    prefix can be used for deciding whether or not an address is *on-link* (on the
    recipient''s local network). When 0, the sender is making no statement regarding
    whether the prefix can be used for this or not. |'
  id: totrans-792
  prefs: []
  type: TYPE_TB
  zh: '| L | 1/8 (1位) | 链接标志：当设置为1时，告诉选项的接收者此前缀可用于链路确定。这意味着前缀可用于决定地址是否*在链路上*（在接收者的本地网络中）。当为0时，发送者没有关于是否可以使用此前缀的声明。
    |'
- en: '| A | 1/8 (1 bit) | Autonomous Address-Configuration Flag: When set to 1, specifies
    that this prefix can be used for IPv6 address autoconfiguration. (See [Chapter 25](ch25.html
    "Chapter 25. IPV6 ADDRESSING") for details on IPv6 autoconfiguration.) |'
  id: totrans-793
  prefs: []
  type: TYPE_TB
  zh: '| A | 1/8 (1位) | 自动地址配置标志：当设置为1时，指定此前缀可用于IPv6地址自动配置。（有关IPv6自动配置的详细信息，请参阅[第25章](ch25.html
    "第25章. IPv6寻址"）。） |'
- en: '| Reserved | 6/8 (6 bits) | 6 leftover bits reserved and sent as zeros. |'
  id: totrans-794
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 6/8 (6位) | 6个保留位以零的形式发送。 |'
- en: Redirected Header Option Format
  id: totrans-795
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向头部选项格式
- en: In a Redirect message, the *Redirected Header* option provides a copy of the
    original message (or a portion of it) that led to the Redirect message being generated.
    This option's format is shown in [Table 35-15](ch35s06.html#icmpv_redirected_header_option_format
    "Table 35-15. ICMPv6 Redirected Header Option Format") and [Figure 35-11](ch35s06.html#icmpv6_redirected_header_option_format
    "Figure 35-11. ICMPv6 Redirected Header option format").
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 在重定向消息中，*重定向头部*选项提供了导致生成重定向消息的原始消息（或其一部分）的副本。此选项的格式显示在[表35-15](ch35s06.html#icmpv_redirected_header_option_format
    "表35-15. ICMPv6重定向头部选项格式")和[图35-11](ch35s06.html#icmpv6_redirected_header_option_format
    "图35-11. ICMPv6重定向头部选项格式")中。
- en: Table 35-15. ICMPv6 Redirected Header Option Format
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 表35-15. ICMPv6重定向头部选项格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-798
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-799
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 option type. For the Redirected Header option,
    the value is 4. |'
  id: totrans-800
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别ICMPv6选项类型。对于重定向头部选项，值为4。 |'
- en: '| Length | 1 | The length of the entire option (including the Type and Length
    fields), expressed in units of 8 octets (64 bits). |'
  id: totrans-801
  prefs: []
  type: TYPE_TB
  zh: '| 长度 | 1 | 整个选项的长度（包括类型和长度字段），以8个八位字节（64位）为单位表示。 |'
- en: '| Reserved | 6 | The 6 reserved bytes sent as zeros. |'
  id: totrans-802
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 6 | 以零的形式发送的6个保留字节。 |'
- en: '| IP Header + Data | Variable | As much of the original IPv6 datagram as will
    fit without causing the size of the ICMPv6 error message (including its own IP
    header) to exceed the minimum IPv6 MTU of 1280 bytes. |'
  id: totrans-803
  prefs: []
  type: TYPE_TB
  zh: '| IP头部 + 数据 | 可变 | 在不导致ICMPv6错误消息（包括其自身的IP头部）的大小超过最小IPv6 MTU 1280字节的情况下，尽可能多的原始IPv6数据报。
    |'
- en: '![ICMPv6 Redirected Header option format](httpatomoreillycomsourcenostarchimages288019.png)'
  id: totrans-804
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6重定向头部选项格式](httpatomoreillycomsourcenostarchimages288019.png)'
- en: Figure 35-11. ICMPv6 Redirected Header option format
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 图35-11. ICMPv6重定向头部选项格式
- en: MTU Option Format
  id: totrans-806
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MTU选项格式
- en: The *MTU* option lets a router convey a recommended MTU value in Router Advertisement
    messages. Its format is shown in [Table 35-16](ch35s06.html#icmpv_mtu_option_format
    "Table 35-16. ICMPv6 MTU Option Format") and [Figure 35-12](ch35s06.html#icmpv6_mtu_option_format
    "Figure 35-12. ICMPv6 MTU option format").
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '*MTU*选项允许路由器在路由器通告消息中传达推荐的MTU值。其格式显示在[表35-16](ch35s06.html#icmpv_mtu_option_format
    "表35-16. ICMPv6 MTU选项格式")和[图35-12](ch35s06.html#icmpv6_mtu_option_format "图35-12.
    ICMPv6 MTU选项格式")中。'
- en: Table 35-16. ICMPv6 MTU Option Format
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 表35-16. ICMPv6 MTU选项格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-809
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-810
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the ICMPv6 option type. For the MTU option, the value
    is 5. |'
  id: totrans-811
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别 ICMPv6 选项类型。对于 MTU 选项，其值为 5。|'
- en: '| Length | 1 | The length of the entire option (including the Type and Length
    fields), expressed in units of 8 octets (64 bits). The MTU option is fixed in
    length at 8 bytes, so the value of this field is 1. |'
  id: totrans-812
  prefs: []
  type: TYPE_TB
  zh: '| 长度 | 1 | 整个选项的长度（包括类型和长度字段），以 8 个八位字节（64 位）为单位表示。MTU 选项的长度固定为 8 字节，因此此字段的值为
    1。|'
- en: '| Reserved | 2 | The 2 reserved bytes sent as zeros. |'
  id: totrans-813
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 2 | 发送为零的 2 个保留字节。|'
- en: '| MTU | 4 | The MTU value, in bytes, that the router is recommending for use
    on the local link. |'
  id: totrans-814
  prefs: []
  type: TYPE_TB
  zh: '| MTU | 4 | 路由器推荐用于本地链路上的 MTU 值，以字节为单位。|'
- en: '![ICMPv6 MTU option format](httpatomoreillycomsourcenostarchimages288021.png.jpg)'
  id: totrans-815
  prefs: []
  type: TYPE_IMG
  zh: '![ICMPv6 MTU 选项格式](httpatomoreillycomsourcenostarchimages288021.png.jpg)'
- en: Figure 35-12. ICMPv6 MTU option format
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 图 35-12. ICMPv6 MTU 选项格式
- en: Chapter 36. IPV6 NEIGHBOR DISCOVERY (ND) PROTOCOL
  id: totrans-817
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 36 章. IPV6 邻居发现 (ND) 协议
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-818
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The new Internet Protocol version 6 (IPv6) represents an evolution of the venerable
    IP. It maintains the same basic operational principles of IPv4, but makes some
    important modifications, particularly in the area of addressing. In fact, some
    of the more significant changes in IPv6 are actually not in IP itself, but in
    the protocols that support IP. One of the most interesting of these was the creation
    of an entirely new support protocol for IPv6\. It combines several tasks previously
    performed by other protocols in IPv4, adds some new functions, and makes numerous
    improvements to the whole package. This new standard is called the IPv6 *Neighbor
    Discovery (ND)* protocol.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 新的互联网协议版本 6 (IPv6) 是对久经考验的 IP 的演进。它保持了与 IPv4 相同的基本操作原则，但在地址领域进行了一些重要的修改。实际上，IPv6
    中的一些更显著的变化实际上并不在 IP 本身，而是在支持 IP 的协议中。其中最有趣的一个是为 IPv6 创建了一个全新的支持协议。它结合了 IPv4 中其他协议以前执行的一些任务，添加了一些新功能，并对整个包进行了许多改进。这个新标准被称为
    IPv6 *邻居发现 (ND)* 协议。
- en: 'In this chapter, I describe the new ND protocol used in IPv6\. I begin with
    an overview of the protocol, discussing its history, the motivation for its creation,
    and the standards that define it. I then describe its operation in general terms,
    listing the fundamental functions that ND performs, the three groups these functions
    fit into, and the Internet Control Message Protocol version 6 (ICMPv6) message
    types used to carry them out. I describe the key differences between ND and the
    way that its functions were carried out in IPv4\. I then provide more information
    on the three functional groups in ND: those that involve discovery of important
    internetwork information from routers, those that are related to address resolution
    and neighbor communication between hosts, and finally, those involved with router
    redirection.'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了 IPv6 中使用的新 ND 协议。我首先概述了该协议，讨论了其历史、创建动机以及定义它的标准。然后以一般术语描述其操作，列出 ND
    执行的基本功能，这些功能分为三个组，以及用于执行这些功能的 Internet 控制消息协议版本 6 (ICMPv6) 消息类型。我描述了 ND 与 IPv4
    中执行其功能的方式之间的关键区别。然后提供了关于 ND 中的三个功能组的更多信息：涉及从路由器发现重要互联网信息的功能组，涉及主机之间地址解析和邻居通信的功能组，以及涉及路由器重定向的功能组。
- en: Tip
  id: totrans-821
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**BACKGROUND INFORMATION** *This chapter assumes basic comprehension of IPv6,
    which, in turn, requires understanding IPv4\. ND uses ICMPv6 messages, so I reference
    Chapters [Chapter 31](ch31.html "Chapter 31. ICMP CONCEPTS AND GENERAL OPERATION")
    to [Chapter 35](ch35.html "Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND
    FORMATS"), which discuss them. Finally, since ICMP performs some of the functions
    done by the Address Resolution Protocol (ARP) in IPv4, you may need to refer to
    [Chapter 13](ch13.html "Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS
    RESOLUTION PROTOCOL (ARP)") if you''re unfamiliar with ARP''s operation*.'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** *本章假设对 IPv6 有基本理解，而这反过来又需要理解 IPv4。ND 使用 ICMPv6 消息，因此我参考了第 [第 31 章](ch31.html
    "第 31 章. ICMP 概念和一般操作") 到 [第 35 章](ch35.html "第 35 章. ICMPv6 信息性消息类型和格式")，这些章节讨论了它们。最后，由于
    ICMP 执行了 IPv4 中地址解析协议 (ARP) 执行的一些功能，如果您不熟悉 ARP 的操作，可能需要参考 [第 13 章](ch13.html "第
    13 章. 地址解析和 TCP/IP 地址解析协议 (ARP)")。|'
- en: IPv6 ND Overview
  id: totrans-823
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6 ND 概述
- en: The purpose of network layer protocols like IP is to provide a means of connecting
    together individual local networks to create a much larger internetwork. To higher-layer
    protocols and to users, this internetwork behaves in most respects as if it were
    a single large network, because the lower layers hide the details that hold together
    the individual networks. Any device can send information to any other regardless
    of where it is located, and like magic, it will work—at least most of the time.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层协议如IP的目的在于提供一种将单个本地网络连接起来以创建更大互联网的手段。对于高层协议和用户来说，这个互联网在大多数方面表现得就像一个单一的大型网络，因为低层隐藏了将各个网络连接在一起的细节。任何设备都可以向任何其他设备发送信息，无论其位置如何，就像魔法一样，它将工作——至少在大多数时候。
- en: 'The existence of an internetwork means that devices can treat all other devices
    as peers, at least from the perspective of higher-layer protocols and applications.
    From the standpoint of lower layers, however, there is a very important difference
    between devices that are on a host''s local network and those that are elsewhere.
    In a general sense, most devices have a more important relationship with the devices
    that are on their local network than those that are far away. Some of the most
    obvious tasks that a device must perform specifically with other devices on its
    local network include the following:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网的存在意味着设备可以将所有其他设备视为对等体，至少从高层协议和应用的视角来看是这样。然而，从低层角度来看，位于主机本地网络上的设备和位于其他地方的网络设备之间存在一个非常重要的区别。在一般意义上，大多数设备与其本地网络上的设备的关系比与其远端设备的关系更为重要。设备必须特别与其他本地网络上的设备执行的一些最明显的任务包括以下内容：
- en: '**Direct Datagram Delivery** Devices deliver data directly to other devices
    on their local network, while data going to distant devices must be indirectly
    delivered (routed).'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接数据报传输** 设备直接将其数据传输到其本地网络上的其他设备，而前往远程设备的数据必须间接传输（路由）。'
- en: '**Layer 2 Addressing** To facilitate direct delivery, devices need to know
    the layer 2 addresses of the other devices on the local network; they don''t need
    to know them for nonlocal devices.'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '**层2寻址** 为了便于直接传输，设备需要知道本地网络上其他设备的层2地址；对于非本地设备，它们不需要知道这些地址。'
- en: '**Router Identification** To deliver indirectly, a device needs to find a router
    on its local network that it can talk to.'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由器识别** 为了间接传输，设备需要在其本地网络上找到一个可以与之通信的路由器。'
- en: '**Router Communication** The local router must communicate information to each
    of the local hosts using it, so the hosts know how best to use it.'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由器通信** 本地路由器必须将其信息传达给使用它的每个本地主机，以便主机知道如何最好地使用它。'
- en: '**Configuration** Hosts will usually look to information provided by local
    devices to let them perform configuration tasks such as determining their own
    IP address.'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置** 主机通常会寻求本地设备提供的信息，以便它们执行配置任务，例如确定自己的IP地址。'
- en: To support these and other requirements, several special protocols and functions
    were developed along with the original IP (version 4). The IP addressing scheme
    lets devices differentiate local addresses from distant ones. The Address Resolution
    Protocol (ARP) lets devices determine layer 2 addresses from layer 3 addresses.
    ICMP provides a messaging system to support various communication requirements
    between local devices, including the ability of a host to find a local router
    and the router to provide information to local hosts.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这些和其他要求，与原始IP（版本4）一起开发了几个特殊的协议和功能。IP寻址方案让设备能够区分本地地址和远程地址。地址解析协议（ARP）让设备能够从层3地址确定层2地址。ICMP提供了一种消息系统，以支持本地设备之间的各种通信需求，包括主机找到本地路由器以及路由器向本地主机提供信息的能力。
- en: These features all work properly in IPv4, but they were developed in sort of
    an ad hoc manner. They are defined not in a single place, but rather in a variety
    of different Internet standards. There were also some limitations with the way
    these local device functions were implemented.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性在IPv4中都正常工作，但它们是以一种临时的方式开发的。它们不是定义在一个地方，而是在各种不同的互联网标准中定义的。这些本地设备功能的实现方式也存在一些局限性。
- en: 'Formalizing Local Network Functions: The Neighbor Concept'
  id: totrans-833
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正式化本地网络功能：邻居概念
- en: 'IPv6 represents the biggest change in decades to not just the IP itself, but
    the entire TCP/IP suite. It thus provided an ideal opportunity to formalize and
    integrate the many disparate functions and tasks related to communication between
    local devices. The result was the creation of a new protocol: *Neighbor Discovery
    for IP version 6*, also commonly called the *IPv6 Neighbor Discovery* protocol.
    Since this protocol is new in IPv6, there is no IPv4 version of it, so the name
    is usually just seen as the *ND* protocol with no further qualifications; its
    use with IPv6 is implied.'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 代表了数十年来对 IP 本身以及整个 TCP/IP 套件的重大变化。因此，它为正式化和整合与本地设备间通信相关的许多不同功能和任务提供了理想的机会。结果是创建了一个新的协议：*IPv6
    版本的邻居发现*，也通常称为 *IPv6 邻居发现* 协议。由于这个协议在 IPv6 中是新的，因此没有 IPv4 版本，所以这个名字通常只被看作是没有任何进一步说明的
    *ND* 协议；它的使用与 IPv6 是隐含的。
- en: The term *neighbor* is one that has been used for years in various networking
    standards and technologies to refer to devices that are local to each other. In
    the context of the current discussion, two devices are *neighbors* if they are
    on the same local network, meaning that they can send information to each other
    directly. The term can refer to either a regular host or a router. I think this
    is a good analogy to the way humans refer to those who live or work nearby. Just
    as most of us have a special relationship with people who are our neighbors and
    communicate more with them than with those who are far away, so do IP devices.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: “邻居”这个术语多年来在各种网络标准和技术中被用来指代彼此相邻的设备。在当前讨论的上下文中，如果两个设备位于同一本地网络中，它们就是“邻居”，这意味着它们可以直接向对方发送信息。这个术语可以指代一个普通的主机或一个路由器。我认为这与人类称呼附近居住或工作的人的方式相似。就像我们中的大多数人都会与邻居有特殊的关系，并且比与远方的人交流更多一样，IP
    设备也是如此。
- en: 'Since a neighbor is a local device, the name of the ND protocol would seem
    to indicate that ND is all about how neighbors discover each other''s existence.
    In the context of this protocol, however, the term *discovery* has a much more
    generic meaning: It refers to discovering not just who are neighbors are, but
    also discovering important information about them. In addition to letting devices
    identify their neighbors, ND facilitates all the tasks listed earlier, including
    such functions as address resolution, parameter communication, autoconfiguration,
    and much more, as you will see in this chapter.'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 由于邻居是本地设备，ND 协议的名称似乎表明 ND 主要关于邻居如何发现彼此的存在。然而，在这个协议的上下文中，“发现”这个术语有更广泛的意义：它不仅指发现谁是邻居，还指发现关于它们的重要信息。除了让设备识别它们的邻居外，ND
    还促进了前面列出的所有任务，包括地址解析、参数通信、自动配置等功能，您将在本章中看到。
- en: Tip
  id: totrans-837
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The new *IPv6 Neighbor Discovery (ND)* protocol formalizes
    for IPv6 a number of functions related to communication between devices on a local
    network that are performed in IPv4 by protocols such as ARP and ICMP. ND is considered
    another helper protocol for IPv6 and is closely related to ICMPv6.'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 新的 *IPv6 邻居发现 (ND)* 协议为 IPv6 正式定义了一系列与本地网络中设备间通信相关的功能，这些功能在 IPv4 中由
    ARP 和 ICMP 等协议执行。ND 被视为 IPv6 的另一个辅助协议，并且与 ICMPv6 密切相关。'
- en: Neighbor Discovery Standards
  id: totrans-839
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻居发现标准
- en: 'The ND protocol was originally defined in RFC 1970, published in August 1996,
    and revised in the current defining standard, RFC 2461, published December 1998\.
    Most of the functions of the ND protocol are implemented using a set of five special
    ICMPv6 control messages, which were discussed in the previous chapter. Thus, to
    some extent, the operation of ND is partially described by the ICMPv6 standard,
    RFC 2463\. Where ICMPv4 can be considered IPv4''s "administrative assistant,"
    IPv6 really has two such assistants working closely together: ICMPv6 and ND. I
    discuss more of the differences between the ways IPv4 and IPv6 implement ND''s
    functions later in this chapter.'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: ND 协议最初在 1996 年 8 月发布的 RFC 1970 中定义，并在 1998 年 12 月发布的当前定义标准 RFC 2461 中进行了修订。ND
    协议的大部分功能都是通过一组五个特殊的 ICMPv6 控制消息实现的，这些消息在上一章中已有讨论。因此，从某种程度上说，ND 的操作部分由 ICMPv6 标准，RFC
    2463 所描述。ICMPv4 可以被认为是 IPv4 的“行政助理”，而 IPv6 实际上有两个这样的助理紧密协作：ICMPv6 和 ND。我在本章后面将讨论
    IPv4 和 IPv6 实现 ND 功能之间的更多差异。
- en: IPv6 ND General Operational Overview
  id: totrans-841
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6 ND 通用操作概述
- en: As I just mentioned, the name of the ND protocol really does not do it justice.
    The protocol facilitates not merely the discovery of neighboring devices, but
    also a substantial number of functions related to local network connectivity,
    datagram routing, and configuration. Both regular hosts and routers in an IPv6
    environment count on the ND protocol to facilitate important exchanges of information
    that are necessary for proper internetwork operation.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我刚才提到的，ND 协议的名称实际上并不能真正体现其价值。该协议不仅促进了邻近设备的发现，还涉及大量与本地网络连接、数据报路由和配置相关的功能。在
    IPv6 环境中，无论是常规主机还是路由器，都依赖于 ND 协议来促进对正确互联网操作至关重要的信息交换。
- en: The ND protocol has a number of similarities to ICMP. An important one is that
    like ICMP, ND is a *messaging* protocol. It doesn't implement a single specific
    function, but rather a group of activities that are performed through the exchange
    of messages. This means I can't explain the operation of ND through a specific
    description of what ND does, but rather must define its operation by means of
    a list of messages that ND provides, and the specific ways that those messages
    are used.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: ND 协议与 ICMP 有许多相似之处。其中之一是，像 ICMP 一样，ND 是一种 *消息* 协议。它不实现单一特定的功能，而是通过消息交换执行一系列活动。这意味着我无法通过具体描述
    ND 做了什么来解释 ND 的操作，而必须通过 ND 提供的消息列表及其具体使用方式来定义其操作。
- en: Any local network on an internetwork will have both regular hosts and routers,
    and the term *neighbor* can refer to either. Of course, hosts and routers play
    different roles on a network, and as a result, ND is very different for each.
    The ND standard describes nine specific functions performed by the protocol. To
    better understand these functions and how they are related, we can divide them
    into three functional groups based on communication type and the kinds of devices
    involved, as illustrated in [Figure 36-1](ch36s02.html#neighbor_discovery_nd_protocol_functiona
    "Figure 36-1. Neighbor Discovery (ND) protocol functional groups and functions").
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上的任何本地网络都将包含常规主机和路由器，术语 *邻居* 可以指代任一。当然，主机和路由器在网络中扮演不同的角色，因此 ND 在每个网络中都非常不同。ND
    标准描述了协议执行的九个具体功能。为了更好地理解这些功能及其相互关系，我们可以根据通信类型和涉及的设备类型将它们分为三个功能组，如图 36-1 所示。
- en: '![Neighbor Discovery (ND) protocol functional groups and functions](httpatomoreillycomsourcenostarchimages288023.png.jpg)'
  id: totrans-845
  prefs: []
  type: TYPE_IMG
  zh: '![邻居发现（ND）协议功能组和功能](httpatomoreillycomsourcenostarchimages288023.png.jpg)'
- en: Figure 36-1. Neighbor Discovery (ND) protocol functional groups and functions
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 图 36-1. 邻居发现（ND）协议功能组和功能
- en: Two main groups of functions in ND are those for handling router discovery and
    those for handling communications between hosts. A third functional group consists
    of just the Redirect function.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: ND 中的主要功能分为两组：处理路由器发现和处理主机间通信的功能。第三组功能仅包括重定向功能。
- en: Host-Router Discovery Functions
  id: totrans-848
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机-路由器发现功能
- en: 'ND host-router discovery functions are those that facilitate the discovery
    of local routers and the exchange of information between routers and hosts. This
    includes four specific functions:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: ND 主机-路由器发现功能是指促进本地路由器发现以及路由器和主机之间信息交换的功能。这包括以下四个具体功能：
- en: '**Router Discovery (RD)** RD is the core function of this group. It''s the
    method by which hosts locate routers on their local network.'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由器发现（RD）** RD 是该组的核心功能。它是主机在其本地网络上定位路由器的方法。'
- en: '**Prefix Discovery** Closely related to the process of RD is Prefix Discovery.
    Recall that the term *prefix* refers to the network identifier portion of an IP
    address. Hosts use this function to determine the network they are on, which,
    in turn, tells them how to differentiate between local and distant destinations
    and whether to attempt direct or indirect delivery of datagrams.'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '**前缀发现** 与 RD 过程密切相关的是前缀发现。回想一下，术语 *前缀* 指的是 IP 地址的网络标识符部分。主机使用此功能来确定它们所在的网络，这反过来又告诉他们如何区分本地和远程目的地，以及是否尝试直接或间接交付数据报。'
- en: '**Parameter Discovery** Also closely related to RD, this is the method by which
    a host learns important parameters about the local network and/or routers, such
    as the maximum transmission unit (MTU) of the local link.'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数发现** 也与 RD 密切相关，这是主机学习有关本地网络和/或路由器的重要参数的方法，例如本地链路的最大传输单元（MTU）。'
- en: '**Address Autoconfiguration** Hosts in IPv6 are designed to be able to automatically
    configure themselves, but this requires information that is normally provided
    by a router.'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址自动配置** IPv6中的主机被设计成能够自动配置自己，但这需要由路由器提供的信息。'
- en: Host-Host Communication Functions
  id: totrans-854
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机-主机通信功能
- en: 'The other main group of functions is associated with information determination
    and communication directly between nodes, usually hosts. Some of these functions
    can be performed between hosts and routers, but this group is not specifically
    related to RD. Host-host communcation functions include the following:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主要的功能组与信息确定和节点之间的直接通信有关，通常涉及主机。其中一些功能可以在主机和路由器之间执行，但这个组并不专门与RD相关。主机-主机通信功能包括以下内容：
- en: '**Address Resolution** The process by which a device determines the layer 2
    address of another device on the local network from that device''s layer 3 (IP)
    address. This is the job performed by ARP in IPv4.'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址解析** 设备通过该设备的第3层（IP）地址确定本地网络上另一个设备的第2层地址的过程。这是IPv4中ARP执行的任务。'
- en: '**Next-Hop Determination** The method for looking at an IP datagram''s destination
    address and determining where it should next be sent.'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '**下一跳确定** 查看IP数据报的目的地址并确定它应该发送到哪里的方法。'
- en: '**Neighbor Unreachability Detection** The process of determining whether or
    not a neighbor device can be directly contacted.'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '**邻居不可达性检测** 确定邻居设备是否可以直接联系的过程。'
- en: '**Duplicate Address Detection** Determining if an address that a device wishes
    to use already exists on the network.'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '**重复地址检测** 确定设备希望使用的地址是否已经在网络上存在。'
- en: Redirect Function
  id: totrans-860
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向功能
- en: 'The last functional group contains just one function: *Redirect*. This is the
    technique whereby a router informs a host of a better next-hop node to use for
    a particular destination.'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个功能组只包含一个功能：*重定向*。这是一种路由器通知主机使用更好的下一跳节点来路由特定目的地的技术。
- en: Tip
  id: totrans-862
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** ND encompasses nine individual functions, many of which are
    related to each other. They are organized into three functional groups: *host-router
    discovery functions*, host-host communications functions, and the *Redirect function*.'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ND 包含九个独立的功能，其中许多相互关联。它们被组织成三个功能组：*主机-路由器发现功能*、主机-主机通信功能和*重定向功能*。'
- en: Relationships Between Functions
  id: totrans-864
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能之间的关系
- en: The division of ND's overall functionality into nine tasks in three groups is
    somewhat arbitrary, but provides a good frame of reference for understanding what
    the protocol does. Some of the functions in different groups are related; next-hop
    determination uses information obtained as part of Parameter Discovery. The Redirect
    function is also a form of router-host communication but is distinct from RD.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 将ND的整体功能划分为三个组中的九个任务在一定程度上是任意的，但为理解协议的功能提供了一个良好的参考框架。不同组中的某些功能是相关的；下一跳确定使用参数发现获得的信息。重定向功能也是路由器-主机通信的一种形式，但与RD不同。
- en: ICMPv6 Messages Used by ND
  id: totrans-866
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ND使用的ICMPv6消息
- en: 'Just as ND is similar to ICMP in its operation, the two protocols are related
    in another way: the way that they perform messaging. ND actually implements its
    functions using ICMPv6 messages. A set of five message types is described in the
    ND standard:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 正如ND在操作上与ICMP相似，这两个协议在另一个方面也有关系：它们执行消息的方式。ND实际上使用ICMPv6消息来实现其功能。ND标准中描述了五种消息类型：
- en: '**Router Advertisement Messages** Sent regularly by routers to tell hosts that
    they exist and provide important prefix and parameter information to them.'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由器通告消息** 路由器定期发送，告知主机它们的存在，并向它们提供重要的前缀和参数信息。'
- en: '**Router Solicitation Messages** Sent by hosts to request that any local routers
    send a Router Advertisement message so they don''t have to wait for the next regular
    advertisement message.'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由器请求消息** 由主机发送，请求任何本地路由器发送路由器通告消息，这样它们就不必等待下一个常规通告消息。'
- en: '**Neighbor Advertisement Messages** Sent by hosts to indicate the existence
    of the host and provide information about it.'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '**邻居通告消息** 由主机发送，以表明主机存在并提供有关该主机的信息。'
- en: '**Neighbor Solicitation Messages** Sent to verify the existence of another
    host and to ask it to transmit a Neighbor Advertisement message.'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '**邻居请求消息** 发送到验证另一个主机存在并请求它传输邻居通告消息。'
- en: '**Redirect Messages** Sent by a router to tell a host of a better method to
    route data to a particular destination.'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '**重定向消息** 由路由器发送，告知主机一种更好的路由数据到特定目的地的方案。'
- en: We'll look at how these message types are used later in this chapter. See [Chapter 35](ch35.html
    "Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS") for the structures
    of each of these five ICMPv6 message types used by ND.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论这些消息类型的使用方法。参见[第35章](ch35.html "第35章。ICMPv6信息性消息类型和格式")，了解ND使用的这五种ICMPv6消息类型的结构。
- en: IPv6 ND Functions Compared to Equivalent IPv4 Functions
  id: totrans-874
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6 ND功能与等效IPv4功能的比较
- en: The IPv6 ND protocol has the distinction of being the only truly new protocol
    created as part of the core of IPv6; there is no previous version of ND. Of course,
    most of the services that ND provides to IPv6 were also required in IPv4\. They
    were just provided in a rather diverse set of protocols and standards that the
    ND protocol has formalized, integrated, and improved.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 ND协议的独特之处在于它是作为IPv6核心部分创建的唯一真正新的协议；没有ND的先前版本。当然，ND提供给IPv6的大多数服务在IPv4中也是必需的。它们只是被提供在一系列相当多样化的协议和标准中，而ND协议将这些标准化、集成并改进。
- en: 'What this means is that while ND is new, the jobs it does are equivalent to
    the tasks performed by several other protocols in IPv4\. Specifically, the bulk
    of ND functions correspond to the following set of standards, features, and message
    types in IPv4:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着虽然ND是新的，但它所做的工作与IPv4中其他几个协议执行的任务相当。具体来说，ND的大部分功能对应于以下IPv4中的标准、特性和消息类型集：
- en: '**ICMPv4 Router Discovery** Most of the functions associated with identifying
    and obtaining information from routers in ND are based on the use of ICMPv4 Router
    Advertisement and Router Solicitation messages, as defined in RFC 1256.'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '**ICMPv4路由发现** ND中与识别和从路由器获取信息相关的许多功能都是基于RFC 1256中定义的ICMPv4路由器通告和路由器请求消息的使用。'
- en: '**Address Resolution Protocol** ND provides enhanced address resolution capabilities
    that are similar to the functions provided in IPv4 by ARP.'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址解析协议** ND提供了增强的地址解析功能，这与IPv4中ARP提供的功能类似。'
- en: '**ICMPv4 Redirect** ND''s Redirect function and Redirect messages are based
    on similar functionality defined in IPv4 and ICMPv4.'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '**ICMPv4重定向** ND的重定向功能和重定向消息基于IPv4和ICMPv4中定义的类似功能。'
- en: There are other aspects of ND that only somewhat correlate to how things work
    in IPv4\. There are also improvements or new functionality compared to how these
    IPv4 functions work. Some of these are due to differences in how IPv6 itself operates
    compared to IPv4\. For example, Prefix Discovery in ND is sort of related to the
    Address Mask Request and Address Mask Reply messaging in ICMPv4.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: ND还有其他一些方面与IPv4中的工作方式只有一定程度的关联。与这些IPv4功能相比，也有一些改进或新功能。其中一些是由于IPv6本身与IPv4相比的操作方式的不同。例如，ND中的前缀发现与ICMPv4中的地址掩码请求和地址掩码回复消息有关。
- en: 'Overall, ND represents a substantial improvement compared to the way its job
    was done in IPv4\. Like IPv6 itself, ND is generally better suited to the needs
    of modern networks than the older protocols. Some of the more important specific
    improvements made in ND compared to how its job was done in IPv4 include the following:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，ND与IPv4中完成其工作的方式相比，有显著的改进。像IPv6本身一样，ND通常更适合现代网络的需求，而不是较老的协议。与IPv4中完成其工作的方式相比，ND在以下方面做出了一些更重要且具体的改进：
- en: '**Formalizing of Router Discovery** In IPv4, the process of RD and solicitation
    was arguably an afterthought. ND formalizes this process and makes it part of
    the core of the TCP/IP protocol suite.'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由发现的形式化** 在IPv4中，RD和请求的过程可以说是事后才考虑的。ND形式化了这个过程，并将其作为TCP/IP协议套件核心的一部分。'
- en: '**Formalizing of Address Resolution** In a similar manner, address resolution
    is handled in a superior way in ND, which functions at layer 3 and is tightly
    tied to IP, just as ICMP is. There is no more need for an ambiguously layered
    protocol like ARP, whose implementation depends greatly on the underlying physical
    and data link layers.'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址解析的形式化** 以类似的方式，ND在地址解析方面以更优越的方式处理，它位于第3层，与IP紧密相连，就像ICMP一样。不再需要像ARP这样的模糊分层协议，其实现很大程度上依赖于底层物理和数据链路层。'
- en: '**Ability to Perform Functions Securely** ND operates at the network layer,
    so it can make use of the authentication and encryption capabilities of IPsec
    for tasks such as address resolution and RD.'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全执行功能** ND在网络层运行，因此可以利用IPsec的认证和加密功能来执行地址解析和RD等任务。'
- en: '**Autoconfiguration** In combination with features built into IPv6, ND allows
    many devices to automatically configure themselves, without the need for something
    like a Dynamic Host Configuration Protocol (DHCP) server (though DHCPv6 does also
    exist).'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动配置** 与IPv6内建的功能结合使用，ND允许许多设备自动配置自己，无需像动态主机配置协议（DHCP）服务器这样的东西（尽管DHCPv6也存在）。'
- en: '**Dynamic Router Selection** Devices use ND to detect if neighbors are reachable.
    If a device is using a router that stops being reachable, it will detect this
    and automatically switch to another one.'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态路由器选择** 设备使用ND来检测邻居是否可达。如果一个设备正在使用一个不再可达的路由器，它将检测到这一点，并自动切换到另一个路由器。'
- en: '**Multicast-Based Address Resolution** Address resolution is performed using
    special multicast addresses instead of broadcasts, thereby reducing unnecessary
    disruption of "innocent bystanders" when resolution messages must be sent.'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于多播的地址解析** 地址解析使用特殊的组播地址而不是广播，从而在需要发送解析消息时减少对“无辜旁观者”不必要的干扰。'
- en: '**Better Redirection** Improvements have been made to the method for generating
    and using Redirect messages.'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的重定向** 生成和使用重定向消息的方法已经得到了改进。'
- en: IPv6 ND Host-Router Discovery Functions
  id: totrans-889
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6 ND 主机-路由器发现功能
- en: Connecting individual networks together creates internetworks. The devices that
    are responsible for this connection of networks are routers, which send data from
    one network to the next. A host must rely on a router to forward transmissions
    to all devices other than those on the local network. For this reason, before
    a host can properly use an internetwork, it needs to find a local router and learn
    important information about both the router and the network itself. Enabling this
    information exchange is one of the most important jobs of the IPv6 ND protocol.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 将单个网络连接在一起创建互连网络。负责这种网络连接的设备是路由器，它们将数据从一个网络发送到下一个网络。主机必须依赖路由器将传输转发到本地网络以外的所有设备。因此，在主机能够正确使用互连网络之前，它需要找到一个本地路由器，并了解关于路由器和网络本身的重要信息。启用这种信息交换是IPv6
    ND协议最重要的任务之一。
- en: The general term used to describe most of the ND communication between hosts
    and routers on a local network is *discovery*. As I mentioned earlier in this
    chapter, the term encompasses not merely discovery of the router, but also communication
    of important parameters. Most of this communication flows from the routers to
    the hosts, since routers control the way that each network is used. They provide
    information to hosts so the hosts know how best to operate.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地网络上描述主机和路由器之间大部分ND通信的一般术语是*发现*。正如我在本章前面提到的，这个术语不仅包括路由器的发现，还包括重要参数的通信。大部分这种通信都是从路由器流向主机的，因为路由器控制每个网络的使用方式。它们向主机提供信息，以便主机知道如何最佳地操作。
- en: The various discovery features related to host-router communication are all
    facilitated by the same exchange of two different ICMPv6 message types. Router
    Advertisement messages are sent only by routers, and they contain information
    about the router and the network on which it is located. Router Solicitation messages
    are optional, and they are sent by hosts when they want to find a local router.
    The format of each of these messages is described in [Chapter 35](ch35.html "Chapter 35. ICMPV6
    INFORMATIONAL MESSAGE TYPES AND FORMATS").
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 与主机-路由器通信相关的各种发现功能都是由两种不同的ICMPv6消息类型的相同交换所促进的。路由通告消息仅由路由器发送，并包含关于路由器及其所在网络的信息。路由请求消息是可选的，当主机想要找到一个本地路由器时，会发送这些消息。这些消息的格式在[第35章](ch35.html
    "第35章。ICMPV6 信息性消息类型和格式")中进行了描述。
- en: Note that both Router Advertisement and Router Solicitation messages may include
    an optional layer 2 address of the device sending the message. This is used to
    update address resolution caches to save time when address resolution is needed
    later.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，路由通告（Router Advertisement）和路由请求（Router Solicitation）消息都可能包含发送消息的设备的可选二层地址。这用于更新地址解析缓存，以便在需要地址解析时节省时间。
- en: The mechanisms for using these messages are not really that complicated. The
    best way to see how the discovery process works overall is to look at the specific
    tasks performed both by routers and hosts in ND. Let's start by looking at the
    functions that routers perform.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些消息的机制实际上并不复杂。要了解发现过程的整体工作方式，最好的方法是查看在ND中路由器和主机执行的具体任务。让我们首先看看路由器执行的功能。
- en: Host-Router Discovery Functions Performed by Routers
  id: totrans-895
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器执行的主机-路由器发现功能
- en: 'Routers are responsible for the following functions:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器负责以下功能：
- en: '**Routine Advertisement** The main job that routers do in ND is to regularly
    transmit Router Advertisement messages. Each router maintains a timer that controls
    how often an advertisement is sent out. Advertisements are also sent when any
    sort of special situation arises. For example, a message will be sent if key information
    about the router changes, such as its address on the local network. Router Advertisement
    messages include key information about both the router and the network. See [Chapter 35](ch35.html
    "Chapter 35. ICMPV6 INFORMATIONAL MESSAGE TYPES AND FORMATS") for a full description
    of the Router Advertisement message format.'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '**常规通告** 路由器在ND中的主要任务是定期传输路由器通告消息。每个路由器都维护一个计时器，控制广告发送的频率。在出现任何特殊情况下也会发送广告。例如，如果路由器的重要信息发生变化，如其在本地网络上的地址，则会发送消息。路由器通告消息包括关于路由器和网络的关键信息。有关路由器通告消息格式的完整描述，请参阅[第35章](ch35.html
    "第35章。ICMPV6信息性消息类型和格式")。'
- en: '**Parameter Maintenance** Routers are responsible for maintaining key parameters
    about the local network, so they can be sent in advertisements. These include
    the default Hop Limit field value that should be used by hosts on the network,
    a default MTU value for the network, and information such as network prefixes,
    which are used for both first-hop routing by hosts and autoconfiguration. Again,
    some more details on these can be found in [Chapter 35](ch35.html "Chapter 35. ICMPV6
    INFORMATIONAL MESSAGE TYPES AND FORMATS").'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数维护** 路由器负责维护有关本地网络的关键参数，以便它们可以在广告中发送。这些包括网络上的主机应使用的默认跳数限制字段值、网络的默认MTU值以及用于主机首次路由和自动配置的网络前缀等信息。有关这些的更多详细信息，请参阅[第35章](ch35.html
    "第35章。ICMPV6信息性消息类型和格式")。'
- en: '**Solicitation Processing** Routers listen for Router Solicitation messages.
    When one is received, they will immediately send a Router Advertisement to the
    requesting host.'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求处理** 路由器监听路由器请求消息。当接收到请求时，它们将立即向请求的主机发送路由器通告。'
- en: Host-Router Discovery Functions Performed by Hosts
  id: totrans-900
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机执行的主机-路由器发现功能
- en: 'For their part, hosts are responsible for three main functions:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 对于它们的部分，主机负责三个主要功能：
- en: '**Advertisement Processing** Hosts listen for advertisements on their local
    network and process them. They then set appropriate parameters based on the information
    in these messages. This includes maintaining various data structures such as lists
    of prefixes and routers, which are updated regularly as new advertisement information
    comes in.'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '**广告处理** 主机监听其本地网络上的广告并进行处理。然后，它们根据这些消息中的信息设置适当的参数。这包括维护各种数据结构，例如前缀列表和路由器列表，这些结构会随着新广告信息的到来而定期更新。'
- en: '**Solicitation Generation** Under certain conditions, a host will generate
    a Router Solicitation and send it out on the local network. This very simple message
    just requests that any local routers that hear it immediately send a Router Advertisement
    message back to the device that made the request. This is most often done when
    a host is first turned on, so it doesn''t have to sit waiting for the next routine
    advertisement.'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成请求** 在某些条件下，主机将生成路由器请求并将其发送到本地网络。这个非常简单的消息只是请求任何听到它的本地路由器立即向请求该消息的设备发送路由器通告消息。这通常在主机首次开启时进行，这样它就不必等待下一次常规通告。'
- en: '**Autoconfiguration** When required, and if the network supports the function,
    the host will use information from the local router to allow it to automatically
    configure itself with an IP address and other parameters.'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动配置** 当需要时，如果网络支持该功能，主机将使用来自本地路由器的信息来自动配置自己，包括IP地址和其他参数。'
- en: Tip
  id: totrans-905
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '**KEY CONCEPT** One of the two main functional groups of ND is the set of *host-router
    discovery* functions. They allow hosts on a local network to discover the identity
    of a local router and learn important parameters about how the network is to be
    used. Host-router discovery operations are performed using ICMPv6 Router Advertisement
    and Router Solicitation messages.'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ND的两个主要功能组之一是*主机-路由器发现*功能集。它们允许本地网络上的主机发现本地路由器的身份，并学习有关如何使用网络的重要参数。主机-路由器发现操作是通过使用ICMPv6路由器通告和路由器请求消息来执行的。'
- en: IPv6 ND Host-Host Communication Functions
  id: totrans-907
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6 ND主机-主机通信功能
- en: 'The delivery of datagrams in IP can be divided into two methods: direct and
    indirect. Indirect datagram delivery requires that routers provide help to hosts,
    which leads to the host-router discovery functions described in the previous section.
    Direct delivery of datagrams is performed from one host to another on the same
    network. This doesn''t require the use of routers, but necessitates other IPv6
    ND protocol functions that involve communication directly between local hosts.
    These include next-hop determination, address resolution, neighbor unreachability
    detection, and duplicate address detection.'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 在IP中，数据报的交付可以分为两种方法：直接和间接。间接数据报交付需要路由器为主机提供帮助，这导致了前一小节中描述的主机-路由器发现功能。数据报的直接交付是在同一网络上的一个主机到另一个主机之间进行的。这不需要使用路由器，但需要其他涉及本地主机之间直接通信的IPv6
    ND协议功能。这些包括下一个跳数确定、地址解析、邻居不可达检测和重复地址检测。
- en: Next-Hop Determination
  id: totrans-909
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一个跳数确定
- en: The first task that any host must perform when it wants to send a datagram is
    *next-hop determination*. This is the process by which a device looks at the destination
    address in a datagram and decides whether direct or indirect delivery is required.
    In early IPv4, this was done by looking at the class of the address, and later
    on, by using the subnet mask. In IPv6, the prefix information obtained from local
    routers is compared to the destination of the datagram to determine if the destination
    device is local or distant. If it is local, the next hop is the same as the destination
    address; if it is not local, the next hop is chosen from the device's list of
    local routers (which are determined either by manual configuration or using the
    host-router discovery features of ND).
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 任何主机在想要发送数据报时必须执行的第一项任务是*下一个跳数确定*。这是通过检查数据报中的目标地址，并决定是否需要直接或间接交付的过程。在早期的IPv4中，这是通过查看地址类别来完成的，后来则通过使用子网掩码。在IPv6中，从本地路由器获得的前缀信息与数据报的目标地址进行比较，以确定目标设备是本地还是远程。如果是本地，下一个跳数与目标地址相同；如果不是本地，则从设备的本地路由器列表中选择下一个跳数（这些路由器是通过手动配置或使用ND的主机-路由器发现功能确定的）。
- en: For efficiency purposes, hosts do not perform this next-hop determination for
    each and every datagram. They maintain a destination cache that contains information
    about what the next hop should be for recent devices to which datagrams have been
    sent. Each time a next-hop determination is performed for a particular destination,
    information from that determination is entered into the cache so that it can be
    used the next time datagrams are sent to that device.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率，主机不会为每个数据报都执行下一个跳数确定。它们维护一个包含有关最近发送数据报的主机的下一个跳数信息的缓存。每次为特定目标执行下一个跳数确定时，该确定的信息将被输入到缓存中，以便在下一次向该设备发送数据报时使用。
- en: Address Resolution
  id: totrans-912
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址解析
- en: If a host determines that the destination of a datagram is local, it will then
    need to send the datagram to that device. The actual transmission will occur using
    whatever physical layer and data link layer technology has been used to implement
    the local network. This requires the host to know the layer 2 address of the destination,
    even though it generally has only the layer 3 address from the datagram. Getting
    from the layer 3 address to the layer 2 address is known as the address resolution
    problem.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机确定数据报的目标是本地，那么它将需要将数据报发送到该设备。实际的传输将使用实现本地网络的物理层和数据链路层技术来完成。这要求主机知道目标的主机2层地址，尽管它通常只有数据报中的第3层地址。从第3层地址到第2层地址的转换被称为地址解析问题。
- en: In IPv6, the ND protocol is responsible for address resolution. When a host
    wants to get the layer 2 address of a datagram destination it sends an ICMPv6
    Neighbor Solicitation message containing the IP address of the device whose layer
    2 address it wishes to determine. That device responds back with a Neighbor Advertisement
    message that contains its layer 2 address. Instead of using a broadcast that would
    disrupt each device on the local network, the solicitation is sent using a special
    multicast to the destination device's solicited-node address. See Chapters [Chapter 13](ch13.html
    "Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)")
    and [Chapter 25](ch25.html "Chapter 25. IPV6 ADDRESSING") for more information
    about address resolution in IPv6.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv6中，ND协议负责地址解析。当一台主机想要获取数据报目的地的第2层地址时，它会发送一个包含目标设备IP地址的ICMPv6邻居请求消息，该地址是它希望确定其第2层地址的设备。该设备会以包含其第2层地址的邻居通告消息作为回应。为了避免使用广播干扰本地网络上的每个设备，请求是通过一个特殊的组播发送到目标设备的请求节点地址。有关IPv6中地址解析的更多信息，请参阅第[第13章](ch13.html
    "第13章。地址解析和TCP/IP地址解析协议（ARP）")和[第25章](ch25.html "第25章。IPv6寻址")。
- en: Note also that even though this discussion does concentrate on communication
    between hosts, address resolution may also be done when a host needs to send a
    datagram to a local router and has no entry for it in its destination cache. In
    the context of address resolution, a destination device is just a neighbor. Whether
    it is a host or a router matters only in terms of what happens after the datagram
    has been sent and received. In other words, these host-to-host functions are so
    named only because they are not specific to the communication between hosts and
    routers like the tasks in the preceding section.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管这次讨论主要集中在主机之间的通信上，但在主机需要向本地路由器发送数据报且其目标缓存中没有该路由器的条目时，也可能进行地址解析。在地址解析的上下文中，目标设备只是一个邻居。它是一个主机还是路由器，只有在数据报发送和接收之后发生的事情中才有意义。换句话说，这些主机到主机的功能之所以这样命名，仅仅是因为它们不像上一节中的任务那样特定于主机和路由器之间的通信。
- en: Updating Neighbors Using Neighbor Advertisement Messages
  id: totrans-916
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用邻居通告消息更新邻居
- en: 'Devices do not routinely send Neighbor Advertisement messages the way that
    routers send Router Advertisement messages. There really isn''t any need for this:
    Neighbors don''t change much over time, and resolution will occur naturally over
    time as devices send datagrams to each other. In addition, having advertisements
    sent regularly by so many devices on a network would be wasteful.'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 设备不会像路由器发送路由通告消息那样定期发送邻居通告消息。实际上，这并不是必需的：邻居地址在一段时间内变化不大，随着设备之间发送数据报，解析会自然发生。此外，让网络上这么多设备定期发送通告将是浪费的。
- en: A host may, however, send an unsolicited Neighbor Advertisement message under
    certain conditions where it feels it is necessary to immediately provide updated
    information to other neighbors on the local network. A good example of this is
    a hardware failure—in particular, the failure of a network interface card. When
    the card is replaced, the device's layer 2 (MAC) address will change. Assuming
    the device's IP layer can detect this, it can send out an unsolicited Neighbor
    Advertisement message to tell other devices to update their resolution caches
    with the new MAC address.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些条件下，主机可能会发送一个未经请求的邻居通告消息，在这种情况下，它认为有必要立即向本地网络上的其他邻居提供更新的信息。一个很好的例子是硬件故障——特别是网络接口卡的故障。当卡被更换时，设备的第2层（MAC）地址将改变。假设设备的IP层能够检测到这一点，它就可以发送一个未经请求的邻居通告消息，告诉其他设备使用新的MAC地址更新它们的解析缓存。
- en: Neighbor Unreachability Detection and the Neighbor Cache
  id: totrans-919
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻居不可达检测和邻居缓存
- en: Neighbor Solicitation and Neighbor Advertisement messages are most often associated
    with address resolution, but they also have other purposes. One of these is neighbor
    unreachability detection. Each device maintains information about each of its
    neighbors and updates it dynamically as network conditions change. The information
    is kept for both host and router devices that are neighbors on the local network.
    Knowing that a device has become unreachable is important because a host can adapt
    its behavior accordingly. In the case of an unreachable host, a device may wait
    a certain period of time before trying to send datagrams to an unreachable host,
    instead of flooding the network with repeated attempts to send to the host. An
    unreachable router, on the other hand, is a signal that the device needs to find
    a new router to use, if an alternate is available.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 邻居请求和邻居通告消息通常与地址解析相关联，但它们也有其他用途。其中之一是邻居不可达性检测。每个设备都维护有关其每个邻居的信息，并根据网络条件的变化动态更新这些信息。这些信息保留在本地网络上的主机和路由器设备中。知道一个设备已变得不可达很重要，因为主机可以相应地调整其行为。在不可达主机的案例中，设备可能在尝试向不可达主机发送数据报之前等待一段时间，而不是在网络中重复尝试发送到主机。另一方面，不可达的路由器是设备需要找到新路由器来使用的信号，如果可用的话。
- en: Each host maintains a neighbor cache that contains information about neighboring
    devices. Each time a host receives a datagram from a neighbor, it knows the neighbor
    is reachable at that particular moment, so the device makes an entry in the cache
    for the neighbor to indicate this. Of course, receiving a datagram from a neighbor
    means only that the neighbor is reachable now; the more time that elapses since
    the last datagram was received, the greater the chance that something has happened
    to make the neighbor no longer reachable.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主机维护一个包含关于邻居设备信息的邻居缓存。每次主机从邻居接收数据报时，它知道邻居在那一刻是可达的，因此设备在缓存中为邻居创建一个条目以指示这一点。当然，从邻居接收数据报仅意味着邻居现在可达；自上次接收到数据报以来经过的时间越长，邻居不再可达的可能性就越大。
- en: For this reason, neighbor reachability information must be considered temporary.
    Each time a neighbor is entered into the cache as reachable, a timer is started.
    When the timer expires, the reachability information for that neighbor is considered
    stale, and reachability is no longer assumed for that neighbor. When a new datagram
    is received from the neighbor in question, the timer is reset and the cache is
    again set to indicate that the device is reachable. The amount of time a host
    should consider a neighbor reachable before expiring it is communicated by a local
    router using a field in a Router Advertisement message.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，邻居可达性信息必须被视为临时的。每次将一个邻居添加到缓存中作为可达时，都会启动一个计时器。当计时器到期时，该邻居的可达性信息被认为是过时的，不再假设该邻居可达。当从该邻居接收到新的数据报时，计时器重置，并将缓存再次设置为指示该设备可达。主机在过期之前应认为邻居可达的时间量是通过本地路由器使用路由器通告消息中的一个字段来通信的。
- en: A host can also dynamically seek out a neighbor if it needs to know its reachability
    status. It sends a Neighbor Solicitation message to the device and waits for a
    Neighbor Advertisement message in response. It then updates the cache accordingly.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机需要知道其可达性状态，它也可以动态地寻找邻居。它向设备发送邻居请求消息并等待响应的邻居通告消息。然后根据需要更新缓存。
- en: Duplicate Address Detection
  id: totrans-924
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址冲突检测
- en: The last use of the two messages we have been discussing here is for duplicate
    address detection. When a host uses the IPv6 autoconfiguration facility, one of
    the steps in the process is to ensure that the address it is trying to use doesn't
    already exist on the network. This is done by sending a Neighbor Solicitation
    message to the address the device wishes to use. If a Neighbor Advertisement message
    is received in reply, the address is already in use.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在讨论的这两个消息的最后一个用途是用于地址冲突检测。当主机使用IPv6自动配置功能时，该过程的一个步骤是确保它试图使用的地址在网络中尚未存在。这是通过向设备希望使用的地址发送邻居请求消息来完成的。如果收到响应的邻居通告消息，则该地址已被使用。
- en: Tip
  id: totrans-926
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The second of the two main functional groups of ND is the set
    of *host-host communication* functions. Two ICMPv6 messages, Neighbor Advertisement
    and Neighbor Solicitation, are defined. They enable a variety of types of essential
    communication between adjacent hosts on a local network. These include address
    resolution, determining the next hop to which a datagram should be sent, and also
    the assessment of a neighboring device''s reachability.'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ND 的两个主要功能组中的第二个是 *主机-主机通信* 功能集。定义了两种 ICMPv6 消息，即邻居通告和邻居请求。它们使得在本地网络中相邻主机之间进行各种类型的必要通信成为可能。这包括地址解析、确定数据报应发送的下一跳，以及评估邻居设备的可达性。'
- en: IPv6 ND Redirect Function
  id: totrans-928
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6 ND 重定向功能
- en: The last of the major responsibilities of the IPv6 ND protocol is the *Redirect*
    function. This is used by a router to inform a host of a better route to use for
    datagrams that have been sent to a particular destination. An argument could be
    made that the Redirect function should be part of the host-router group since
    it represents a form of communication between routers and regular hosts. However,
    it is somewhat different from the other discovery functions, and so the standard
    treats it separately.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 ND 协议的最后一个主要责任是 *重定向* 功能。该功能由路由器用于通知主机，对于已发送到特定目的地的数据报，应使用更好的路由。可以争辩说，重定向功能应该是主机-路由器组的一部分，因为它代表了路由器与普通主机之间的一种通信形式。然而，它与其他发现功能略有不同，因此标准将其单独处理。
- en: 'Routers are responsible for detecting situations where a host on the local
    network has made an inefficient first-hop routing decision, and then attempting
    to correct it. For example, consider a network that has two routers on it, R1
    and R2\. A Host H1 wants to send a datagram to Device X2 on another network that
    is connected to Host H1''s network through Router R2\. If Host H1 sends the datagram
    to Router R1, that router will know it must go through Router R2, and will send
    it there. Seeing that Router R2 was also on the local network, Router R1 therefore
    knows that Host H1 made a poor initial routing decision: The datagram should have
    been sent to Router R2 directly, not Router R1\. If this sounds very similar to
    ICMPv4''s redirect feature, that''s because it is!'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器负责检测本地网络中某个主机在首次路由决策上做出了低效的选择，并尝试进行纠正。例如，考虑一个网络上有两个路由器，R1 和 R2。主机 H1 想要将数据报发送到另一个网络上的设备
    X2，该网络通过路由器 R2 连接到主机 H1 的网络。如果主机 H1 将数据报发送到路由器 R1，那么该路由器将知道它必须通过路由器 R2，并将其发送到那里。看到路由器
    R2 也在本地网络中，因此路由器 R1 知道主机 H1 做了一个糟糕的初始路由决策：数据报应该直接发送到路由器 R2，而不是路由器 R1。如果这听起来非常类似于
    ICMPv4 的重定向功能，那是因为它就是！
- en: In response, Router R1 will create a special ICMPv6 Redirect message. This message
    will tell Host H1 that for any subsequent datagrams that will be sent to Device
    X2 should be first sent to Router R2, instead of to Router R1\. It is also possible
    that a router may determine other situations where the first hop from a particular
    host should be different and will advise the host using a Redirect message. This
    is illustrated in [Figure 36-2](ch36s06.html#nd_host_redirection_using_an_icmpv6_redi
    "Figure 36-2. ND host redirection using an ICMPv6 Redirect message Host H1 sends
    to Router R1 an IPv6 datagram destined for a device on Network N2\. However, Router
    R1 notices that Router R2 is on the same network as the source device and is a
    more direct route to Network N2\. It forwards the datagram on to Router R2 but
    also sends an ICMPv6 Redirect message back to Host H1 to tell it to use Router
    R2 next time.").
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，路由器 R1 将创建一个特殊的 ICMPv6 重定向消息。此消息将告诉主机 H1，对于任何后续发送到设备 X2 的数据报，应首先发送到路由器
    R2，而不是路由器 R1。也有可能路由器会确定其他情况下特定主机的第一跳应该不同，并使用重定向消息建议主机。这如图 [图 36-2](ch36s06.html#nd_host_redirection_using_an_icmpv6_redi
    "图 36-2. 使用 ICMPv6 重定向消息进行 ND 主机重定向 主机 H1 向路由器 R1 发送一个目的地为网络 N2 上设备的 IPv6 数据报。然而，路由器
    R1 注意到路由器 R2 与源设备在同一网络中，并且是到达网络 N2 的更直接路由。它将数据报转发到路由器 R2，但也向主机 H1 发送一个 ICMPv6
    重定向消息，告诉它下次使用路由器 R2。") 所示。
- en: Only routers send Redirect messages, not hosts. Hosts are responsible for looking
    for these Redirect messages and processing them. A host receiving such a message
    will look in it to see which destination's datagram led to the redirection notice,
    and which new first hop the router is saying the host should use in the future
    for that destination. In this example, Host H1 will see that Router R1 is saying
    that any further datagrams to Device X2 should be sent to Router R2 instead of
    Router R1\. Host H1 will update its destination cache for Device X2 accordingly.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 只有路由器会发送重定向消息，而不是主机。主机负责寻找这些重定向消息并处理它们。接收到此类消息的主机将检查其中哪个目的地的数据报导致了重定向通知，以及路由器表示主机未来应为此目的地使用的新第一个跳。在这个例子中，主机
    H1 将看到路由器 R1 表示，任何发往设备 X2 的进一步数据报都应该发送到路由器 R2 而不是路由器 R1。主机 H1 将相应地更新其设备 X2 的目标缓存。
- en: '![ND host redirection using an ICMPv6 Redirect message Host H1 sends to Router
    R1 an IPv6 datagram destined for a device on Network N2\. However, Router R1 notices
    that Router R2 is on the same network as the source device and is a more direct
    route to Network N2\. It forwards the datagram on to Router R2 but also sends
    an ICMPv6 Redirect message back to Host H1 to tell it to use Router R2 next time.](httpatomoreillycomsourcenostarchimages288025.png.jpg)'
  id: totrans-933
  prefs: []
  type: TYPE_IMG
  zh: '![使用 ICMPv6 重定向消息进行 ND 主机重定向。主机 H1 向路由器 R1 发送一个目的地为网络 N2 上设备的 IPv6 数据报。然而，路由器
    R1 注意到路由器 R2 与源设备位于同一网络，并且是到达网络 N2 的更直接路径。它将数据报转发到路由器 R2，同时也向主机 H1 发送一个 ICMPv6
    重定向消息，告知它下次使用路由器 R2。](http://atomoreilly.com/source/nostarch/images/288025.png.jpg)'
- en: Figure 36-2. ND host redirection using an ICMPv6 Redirect message Host H1 sends
    to Router R1 an IPv6 datagram destined for a device on Network N2\. However, Router
    R1 notices that Router R2 is on the same network as the source device and is a
    more direct route to Network N2\. It forwards the datagram on to Router R2 but
    also sends an ICMPv6 Redirect message back to Host H1 to tell it to use Router
    R2 next time.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 图 36-2. 使用 ICMPv6 重定向消息进行 ND 主机重定向。主机 H1 向路由器 R1 发送一个目的地为网络 N2 上设备的 IPv6 数据报。然而，路由器
    R1 注意到路由器 R2 与源设备位于同一网络，并且是到达网络 N2 的更直接路径。它将数据报转发到路由器 R2，同时也向主机 H1 发送一个 ICMPv6
    重定向消息，告知它下次使用路由器 R2。
- en: Tip
  id: totrans-935
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The ND *Redirect* function allows a router to tell a host to
    use a different router for future transmissions to a particular destination. It
    is similar to the IPv4 redirect feature and is implemented using ICMPv6 Redirect
    messages.'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** ND *重定向* 功能允许路由器告诉主机在未来的传输中为特定目的地使用不同的路由器。它与 IPv4 重定向功能类似，并使用 ICMPv6
    重定向消息实现。'
- en: When a router sends a Redirect message, it may also include in the message the
    data link layer address of the destination to which it is redirecting. This address
    is used by the host to update its address resolution cache, if necessary. This
    may save bandwidth in the future by eliminating an address resolution cycle, when
    the redirected host tries to send to the new, redirected location. In the example,
    Router R1 may include Router R2's own layer 2 address in the Redirect message.
    This can be used by Host H1 the next time it has a datagram for Device X2.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器发送重定向消息时，它还可能在消息中包含它要重定向到的目的地的数据链路层地址。如果需要，该地址由主机用于更新其地址解析缓存。这可能会在未来节省带宽，通过消除地址解析周期，当重定向主机尝试向新的重定向位置发送时。在这个例子中，路由器
    R1 可能会在重定向消息中包含路由器 R2 的自身层 2 地址。这可以在主机 H1 下次有发往设备 X2 的数据报时使用。
- en: IPv6 also supports the authentication of Redirect messages to prevent unauthorized
    devices from causing havoc by sending inappropriate Redirect messages. A host
    may be configured to discard Redirect messages that are not properly authenticated.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 还支持对重定向消息进行身份验证，以防止未经授权的设备通过发送不适当的重定向消息造成混乱。主机可能被配置为丢弃未经适当身份验证的重定向消息。
