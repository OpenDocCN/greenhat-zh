<html><head></head><body><div class="part" title="Part&#xA0;III-4.&#xA0;TCP/IP NETWORK MANAGEMENT FRAMEWORK AND PROTOCOLS"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_network_management_framework_and_p"/>Part III-4. TCP/IP NETWORK MANAGEMENT FRAMEWORK AND PROTOCOLS</h1></div></div></div><div class="partintro" id="id3329010" title="TCP/IP NETWORK MANAGEMENT FRAMEWORK AND PROTOCOLS"><div/><p><a class="xref" href="ch65.html" title="Chapter 65. TCP/IP INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW">Chapter 65</a></p><p><a class="xref" href="ch66.html" title="Chapter 66. TCP/IP STRUCTURE OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT INFORMATION BASES (MIBS)">Chapter 66</a></p><p><a class="xref" href="ch67.html" title="Chapter 67. TCP/IP SIMPLE NETWORK MANAGEMENT PROTOCOL (SNMP) CONCEPTS AND OPERATION">Chapter 67</a></p><p><a class="xref" href="ch68.html" title="Chapter 68. SNMP PROTOCOL MESSAGING AND MESSAGE FORMATS">Chapter 68</a></p><p><a class="xref" href="ch69.html" title="Chapter 69. TCP/IP REMOTE NETWORK MONITORING (RMON)">Chapter 69</a></p><p>Modern networks and internetworks are larger, faster, and more capable than their predecessors of years gone by. As we expand, speed up, and enhance our networks, they become more complex, and as a result, more difficult to manage. Years ago, an administrator could get by with very simple tools to keep a network running, but today, more sophisticated network management technologies are required to match the sophistication of our networks.</p><p>Some of the most important tools in the network manager's toolbox are now in the form of software, not hardware. To manage a sprawling, heterogeneous, and complex internetwork, we can employ software applications to gather information and control devices using the internetwork itself. TCP/IP, being the most popular internetworking suite, has such software tools. One of the most important is a pair of protocols that have been implemented as part of an overall method of network management called the <span class="emphasis"><em>TCP/IP Internet Standard Management Framework</em></span>.</p><p>This part describes the TCP/IP Internet Standard Management Framework, looking at each of its architectural and protocol components and how they interoperate. The first chapter provides an overview of the network management framework itself and serves as an introduction to the chapters that follow. The second chapter discusses the way that network management information is structured and arranged into information stores called <span class="emphasis"><em>management information bases (MIBs)</em></span>. The third chapter describes the concepts behind and operation of the key protocol in TCP/IP network management: the Simple Network Management Protocol (SNMP). The fourth chapter provides details on SNMP's messaging and message formats. Finally, the fifth chapter takes a brief look at Remote Network Monitoring (RMON), an enhancement of SNMP—sometimes called a protocol, even though it really isn't—that provides administrators with greater management and monitoring abilities on a TCP/IP internetwork.</p><p>Note that while you may be tempted to jump straight to the chapter on SNMP, what is written there will make a lot more sense if you read the chapters of this part in order.</p></div></div>
<div class="chapter" title="Chapter&#xA0;65.&#xA0;TCP/IP INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW"><div class="titlepage"><div><div><h1 class="title"><a id="tcp_ip_internet_standard_management_fram"/>Chapter 65. TCP/IP INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject1_d1e69054"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> TCP/IP network management functions are most commonly associated with the key protocol responsible for implementing those functions: the <span class="emphasis"><em>Simple Network Management Protocol (SNMP)</em></span>. Many people have heard of SNMP, and it is common for SNMP to be considered "the" way that network management is performed in TCP/IP. This is true to an extent, but is really an oversimplification. The actual SNMP protocol is only one part of a higher-level network management strategy called the <span class="emphasis"><em>Internet Standard Management Framework</em></span>. In order to really understand how SNMP works, you need to first have some background on the way this network management is structured as a whole.</p><p>In this chapter, I provide an introduction to TCP/IP network management by describing the concepts and components of the TCP/IP Internet Standard Management Framework. I begin with an overview and history of the framework, and discuss how it is related to SNMP. I describe the TCP/IP network management model and the key components that compose a network management system. I provide a summary of the architecture of the Internet Standard Management Framework. I then describe the three main versions of the Framework and SNMP and how they compare. I conclude with a discussion of the many standards used to describe this technology.</p><div class="sect1" title="Overview and History of the TCP/IP Internet Standard Management Framework and Simple Network Management Protocol (SNMP)"><div class="titlepage"><div><div><h1 class="title"><a id="overview_and_history_of_the_tcpip_intern"/>Overview and History of the TCP/IP Internet Standard Management Framework and Simple Network Management Protocol (SNMP)</h1></div></div></div><p>An adage from the world of professional sports says that a baseball umpire is doing a good job when you forget that he is there. In many ways, the same could be said of a network administrator. The administrator is doing a good job when the network is running so smoothly and efficiently that users forget that the administrator exists. Because, as the administrator knows all too well, the second there is a problem, the users will all remember very quickly that he or she is there.</p><p>A primary job of a network administrator is to keep tabs on the network and ensure that it is operating normally. Information about the hardware and software on the network is a key to performing this task properly.</p><p>When networks were small, an administrator could stay informed about the status of hardware and software using simple means, such as physically walking over to a computer and using it, or using a low-level link layer management protocol. This is simply not possible with modern internetworks, which are large, geographically diverse, and often consist of many different lower-layer technologies. Usually, the only thing all the devices on the network have in common is an implementation of a particular internetworking protocol suite, such as TCP/IP. This makes the internetwork itself a logical way to facilitate the communication of network management information between devices and a network administrator.</p><div class="sect2" title="Early Development of SNMP"><div class="titlepage"><div><div><h2 class="title"><a id="early_development_of_snmp"/>Early Development of SNMP</h2></div></div></div><p><a class="indexterm" id="idx-CHP-65-2336"/>Many people recognized during the early days of the Internet that some sort of network management technology would be needed for TCP/IP. Unfortunately, at first there was no single standard. In the 1980s, several different technologies were developed by different working groups. There were three main contestants: the <span class="emphasis"><em>High-level Entity Management System (HEMS)/High-level Entity Management Protocol (<a class="indexterm" id="idx-CHP-65-2338"/>HEMP)</em></span><a class="indexterm" id="idx-CHP-65-2337"/> as defined by RFCs 1021 through 1024; the <a class="indexterm" id="idx-CHP-65-2339"/><span class="emphasis"><em>Simple Gateway Monitoring Protocol (SGMP)</em></span><a class="indexterm" id="idx-CHP-65-2340"/>, defined by RFC 1028; and the <a class="indexterm" id="idx-CHP-65-2341"/><span class="emphasis"><em>Common Management Information Protocol (CMIP)</em></span><a class="indexterm" id="idx-CHP-65-2342"/>, which is actually part of the OSI protocol suite.</p><p>The Internet Engineering Task Force (IETF) recognized the importance of having a unifying management standard for TCP/IP, and in 1988, published RFC 1052, "IAB Recommendations for the Development of Internet Network Management Standards." This memo is not a standard, but more a statement of intention and documentation of a meeting held on this subject. The conclusion of RFC 1052 was that SGMP be used as the basis of a new Internet standard to be called the <span class="emphasis"><em>Simple Network Management Protocol (SNMP)</em></span>. This development was to be carried out by the SNMP Working Group.</p></div><div class="sect2" title="The Two Meanings of SNMP"><div class="titlepage"><div><div><h2 class="title"><a id="the_two_meanings_of_snmp"/>The Two Meanings of SNMP</h2></div></div></div><p>The rationale of the middle two words in the name Simple Network Management Protocol is obvious, but the other two words are slightly more problematic. The word <span class="emphasis"><em>Protocol</em></span> implies that SNMP is just a TCP/IP communication protocol, like other protocols, such as the Dynamic Host Configuration Protocol (DHCP) and the File Transfer Protocol (FTP). Unfortunately, this is both true and untrue: the name is ambiguous.</p><p>At a lower level, SNMP does indeed refer specifically to the actual protocol that carries network management information between devices. This is what most people think of when they talk about SNMP. However, as defined by the SNMP working group, the TCP/IP network management solution as a whole consists of a number of different elements arranged in an architecture. This architecture originally had no specific name, but is now called the <span class="emphasis"><em>Internet Standard Management Framework</em></span>. Oddly, this higher-level framework is not abbreviated ISMF, but is <span class="emphasis"><em>also</em></span> called SNMP, which means that context is important in understanding that term.</p><div class="note" title="Note"><h3 class="title"><a id="note-149"/>Note</h3><p><span class="emphasis"><em>To avoid confusion, I will often use the phrases SNMP Framework and SNMP protocol to differentiate these two uses of the term SNMP</em></span>.</p></div></div><div class="sect2" title="Design Goals of SNMP"><div class="titlepage"><div><div><h2 class="title"><a id="design_goals_of_snmp"/>Design Goals of SNMP</h2></div></div></div><p><a class="indexterm" id="idx-CHP-65-2343"/>The word <span class="emphasis"><em>Simple</em></span> in the protocol's name is another problem. Even in its first iteration, it was only somewhat simple. The most current version of SNMP is fairly complicated indeed, with many different standards defining the SNMP Framework, the SNMP protocol itself, and a number of supporting elements.</p><p>So why is it called <span class="emphasis"><em>Simple?</em></span> Well, as they say, everything is relative. SNMP is simple when compared to other protocols that are even more complex. Some of this can be seen by looking at the basic goals of the Internet Standard Management Framework and the SNMP protocol as a whole:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>SNMP defines a universal way that management information can be easily defined for any object, and then exchanged between that object and a device designed to facilitate network management.</p></li><li class="listitem"><p>SNMP separates the functions of defining and communicating management information from the applications that are used for network management.</p></li><li class="listitem"><p>The actual SNMP protocol is fairly simple, consisting of only a few easy-to-understand protocol operations.</p></li><li class="listitem"><p>The implementation of SNMP is relatively simple for the designers and manufacturers of products.</p></li></ul></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-389"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <span class="emphasis"><em>Simple Network Management Protocol (SNMP)</em></span> defines a set of technologies that allow network administrators to remotely monitor and manage TCP/IP network devices. The term SNMP refers both to a specific communication protocol (sometimes called the <span class="emphasis"><em>SNMP protocol</em></span>) and an overall framework for Internet management (the <span class="emphasis"><em>SNMP Framework</em></span>).</p></div><p>Since SNMP is a TCP/IP application layer protocol, it can theoretically run over a variety of transport mechanisms. It is most commonly implemented over the Internet Protocol (IP), but the most recent versions also define <span class="emphasis"><em>transport mappings</em></span> that can allow SNMP information to be carried over other internetworking technologies.</p></div><div class="sect2" title="Further Development of SNMP and the Problem of SNMP Variations"><div class="titlepage"><div><div><h2 class="title"><a id="further_development_of_snmp_and_the_prob"/>Further Development of SNMP and the Problem of SNMP Variations</h2></div></div></div><p>The first Internet Standard Management Framework developed (in 1988) is now called <span class="emphasis"><em>SNMP version 1 (SNMPv1)</em></span>. This initial version of SNMP achieved widespread acceptance, and it is still probably the most common version of SNMP.</p><p>Much of the history of SNMP since that time has been a rather confusing standards nightmare. SNMPv1 had a number of weaknesses, particularly in the area of security. For this reason, shortly after SNMPv1 was done, work began on a new version of SNMP. Unfortunately, this effort became a quagmire, with many competing variations of SNMPv2 being created. After many years of confusion, none of the SNMPv2 variants achieved significant success.</p><p>Recently, a third version of the SNMP Framework and protocol has been published, which adds new features and reunites SNMP under a single, universal protocol again. The discussions of SNMP versions and SNMP standards later in this chapter further explore the history of SNMP since 1988. They can be considered a continuation of this historical overview, as they help clarify the very confusing story behind SNMP versions over the last decade and a half.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-390"/>Tip</h3><p><span class="strong"><strong>RELATED INFORMATION</strong></span> <span class="emphasis"><em>More background on the SNMP protocol proper can be found in the overview of the actual protocol itself, in <a class="xref" href="ch67.html" title="Chapter 67. TCP/IP SIMPLE NETWORK MANAGEMENT PROTOCOL (SNMP) CONCEPTS AND OPERATION">Chapter 67</a></em></span>.</p></div></div></div></div>
<div class="sect1" title="TCP/IP SNMP Operational Model, Components, and Terminology"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_snmp_operational_model_components_"/>TCP/IP SNMP Operational Model, Components, and Terminology</h1></div></div></div><p>So, it seems the <span class="emphasis"><em>Simple</em></span> Network Management Protocol isn't quite so simple after all. There are many versions and standards and uses of SNMP, and so a lot to learn. I think a good place to start in understanding what SNMP does is to look at its <span class="emphasis"><em>model of operation</em></span>. Then we can examine the components that compose a TCP/IP network management system and define the terminology used to describe them.</p><div class="sect2" title="SNMP Device Types"><div class="titlepage"><div><div><h2 class="title"><a id="snmp_device_types"/>SNMP Device Types</h2></div></div></div><p><a class="indexterm" id="idx-CHP-65-2344"/><a class="indexterm" id="idx-CHP-65-2345"/>The overall idea behind SNMP is to allow the information needed for network management to be exchanged using TCP/IP. More specifically, the protocol allows a network administrator to make use of a special network device that interacts with other network devices to collect information from them and modify how they operate. In the simplest sense, two different basic types of hardware devices are defined:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-65-2346"/>Managed Nodes</strong></span> Regular nodes on a network that have been equipped with software to allow them to be managed using SNMP. These are, generally speaking, conventional TCP/IP devices. They are also sometimes called <span class="emphasis"><em>managed devices</em></span>.</p><p><span class="strong"><strong>Network Management Station (<a class="indexterm" id="idx-CHP-65-2347"/>NMS)</strong></span> A designated network device that runs special software to allow it to manage the regular managed nodes mentioned just above. One or more NMSs must be present on the network, as these devices are the ones that really run <a class="indexterm" id="idx-CHP-65-2348"/>SNMP.</p></div><div class="sect2" title="SNMP Entities"><div class="titlepage"><div><div><h2 class="title"><a id="snmp_entities"/>SNMP Entities</h2></div></div></div><p><a class="indexterm" id="idx-CHP-65-2349"/><a class="indexterm" id="idx-CHP-65-2350"/>Each device that participates in network management using <a class="indexterm" id="idx-CHP-65-2351"/>SNMP runs a piece of software, generically called an <span class="emphasis"><em>SNMP entity</em></span>. The SNMP entity is responsible for implementing all of the various functions of the SNMP protocol. Each entity consists of two primary software components. Which components make up the SNMP entity on a device depends on whether the device is a managed node or an NMS.</p><div class="sect3" title="Managed Node Entities"><div class="titlepage"><div><div><h3 class="title"><a id="managed_node_entities"/>Managed Node Entities</h3></div></div></div><p><a class="indexterm" id="idx-CHP-65-2352"/>The SNMP entity on a managed node consists of the following software elements and constructs:</p><p><span class="strong"><strong>SNMP Agent</strong></span> A software program that implements the SNMP protocol and allows a managed node to provide information to an NMS and accept instructions from it.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-65-2353"/>SNMP Management Information Base (MIB)</strong></span> An MIB defines the types of information stored about the node that can be collected and used to control the managed node. Information exchanged using SNMP takes the form of objects from the MIB.</p></div><div class="sect3" title="Network Management Station Entities"><div class="titlepage"><div><div><h3 class="title"><a id="network_management_station_entities"/>Network Management Station Entities</h3></div></div></div><p><a class="indexterm" id="idx-CHP-65-2354"/>The SNMP entity on an NMS consists of the following:</p><p><span class="strong"><strong>SNMP <a class="indexterm" id="idx-CHP-65-2355"/>Manager</strong></span> A software program that implements the SNMP protocol, allowing the NMS to collect information from managed nodes and to send instructions to them.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-65-2356"/>SNMP Applications</strong></span> One or more software applications that allow a human network administrator to use SNMP to manage a network.</p></div></div><div class="sect2" title="SNMP Operational Model Summary"><div class="titlepage"><div><div><h2 class="title"><a id="snmp_operational_model_summary"/>SNMP Operational Model Summary</h2></div></div></div><p><a class="indexterm" id="idx-CHP-65-2357"/>So, to integrate and reiterate all of this, let's summarize. SNMP consists of a small number of <span class="emphasis"><em>network management stations (NMSs)</em></span> that interact with regular TCP/IP devices that are called <span class="emphasis"><em>managed nodes</em></span>. The <a class="indexterm" id="idx-CHP-65-2358"/><span class="emphasis"><em>SNMP manager</em></span> on the NMS and the <a class="indexterm" id="idx-CHP-65-2359"/><span class="emphasis"><em>SNMP agents</em></span> on the managed nodes implement the SNMP protocol and allow network management information to be exchanged. <span class="emphasis"><em>SNMP applications</em></span> run on the NMS and provide the interface to the human administrator, and allow information to be collected from the <span class="emphasis"><em>management information bases (MIBs)</em></span> at each SNMP agent. <a class="xref" href="ch65s02.html#snmp_operational_model_this_diagram_show" title="Figure 65-1. SNMP operational model This diagram shows a simplified implementation of SNMP, with one network management station (NMS) used to maintain three managed nodes. Each device has an SNMP entity, and they communicate using SNMP messages. The SNMP entity of the NMS consists of the SNMP manager and one or more SNMP applications. The managed nodes each run an SNMP agent and maintain a management information base (MIB).">Figure 65-1</a> illustrates the SNMP operational model.</p><p>An SNMP managed node can be pretty much any network device that can communicate using TCP/IP, as long as it is programmed with the proper SNMP entity software. SNMP is designed to allow regular hosts to be managed, as well as intelligent network interconnection devices, such as routers, bridges, hubs, and switches. Other devices—printers, scanners, consumer electronic devices, specialized medical devices, and so on—can also be managed, as long as they connect to a TCP/IP internetwork.</p><p>On a larger network, an NMS may be a separate, high-powered TCP/IP computer dedicated to network management. However, it is really software that makes a device into an NMS, so the NMS may not be a separate hardware device. It may act as an NMS and also perform other functions on the network.</p><div class="figure"><a id="snmp_operational_model_this_diagram_show"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e69385"/><img alt="SNMP operational model This diagram shows a simplified implementation of SNMP, with one network management station (NMS) used to maintain three managed nodes. Each device has an SNMP entity, and they communicate using SNMP messages. The SNMP entity of the NMS consists of the SNMP manager and one or more SNMP applications. The managed nodes each run an SNMP agent and maintain a management information base (MIB)." src="httpatomoreillycomsourcenostarchimages288225.png.jpg"/></div></div><p class="title">Figure 65-1. SNMP operational model This diagram shows a simplified implementation of SNMP, with one network management station (NMS) used to maintain three managed nodes. Each device has an SNMP entity, and they communicate using SNMP messages. The SNMP entity of the NMS consists of the SNMP manager and one or more SNMP applications. The managed nodes each run an SNMP agent and maintain a management information base (MIB).</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-391"/>Tip</h3><p><a class="indexterm" id="idx-CHP-65-2360"/><span class="strong"><strong>KEY CONCEPT</strong></span> SNMP allows a network administrator using a <span class="emphasis"><em>network management station (NMS)</em></span> to control a set of managed nodes. Each device incorporates an <span class="emphasis"><em>SNMP entity</em></span> that implements the technology. In an NMS, the entity consists of an <span class="emphasis"><em>SNMP manager</em></span> module and a set of SNMP applications. In a managed node, the entity consists of an SNMP agent and <span class="emphasis"><em>management information base (MIB)</em></span>.</p></div></div></div>
<div class="sect1" title="TCP/IP Internet Standard Management Framework Architecture and Protocol Components"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_internet_standard_management_frame"/>TCP/IP Internet Standard Management Framework Architecture and Protocol Components</h1></div></div></div><p>The Internet Standard Management Framework encompasses all of the technologies that compose the TCP/IP network management solution. The <a class="indexterm" id="idx-CHP-65-2361"/>SNMP Framework consists of a number of architectural <a class="indexterm" id="idx-CHP-65-2362"/>components that define how management information is structured, how it is stored, and how it is exchanged using the <a class="indexterm" id="idx-CHP-65-2363"/>SNMP protocol. The Framework also describes how the different components fit together, how SNMP is to be implemented in network devices, and how the devices interact.</p><div class="sect2" title="SNMP Framework Components"><div class="titlepage"><div><div><h2 class="title"><a id="snmp_framework_components"/>SNMP Framework Components</h2></div></div></div><p>As we will explore in more detail in the next chapter, the Internet Standard Management Framework is entirely <span class="emphasis"><em>information-oriented</em></span>. It includes four primary components (see <a class="xref" href="ch65s03.html#components_of_the_tcpip_internet_standar" title="Figure 65-2. Components of the TCP/IP Internet Standard Management Framework">Figure 65-2</a>):</p><p><span class="strong"><strong>Structure of Management Information (SMI)</strong></span> To ensure interoperability of various devices, we want to have a consistent way of describing the characteristics of devices to be managed using SNMP. In computer science, a <span class="emphasis"><em>data description language (DDL)</em></span> is the tool for this job. The <span class="emphasis"><em>SMI</em></span> is a standard that defines the structure, syntax, and characteristics of management information in SNMP.</p><p><span class="strong"><strong>Management Information Bases (MIBs)</strong></span> Each managed device contains a set of variables that is used to manage it. These variables represent information about the operation of the device that is sent to an NMS, and/or parameters sent to the managed device to control it. The <span class="emphasis"><em>MIB</em></span> is the full set of these variables that describe the management characteristics of a particular type of device. Each variable in a MIB is called a <span class="emphasis"><em>MIB object</em></span>, and it is defined using the SMI data description language. A device may have many objects, corresponding to the different hardware and software elements it contains.</p><div class="note" title="Note"><h3 class="title"><a id="note-150"/>Note</h3><p><span class="emphasis"><em>Initially, a single document defined the MIB for SNMP, but this model was inflexible. To allow new MIB objects to be more easily defined, groups of related MIB objects are now defined in separate RFC standards called</em></span> MIB modules. <span class="emphasis"><em>More than 100 such MIB modules have been defined so far</em></span>.</p></div><p><span class="strong"><strong>Simple Network Management Protocol (SNMP)</strong></span> This is the actual SNMP protocol itself. It defines how information is exchanged between SNMP agents and NMSs. The SNMP <span class="emphasis"><em>protocol operations</em></span> define the various SNMP messages and how they are created and used. SNMP <span class="emphasis"><em>transport mappings</em></span> describe how SNMP can be used over various underlying internetworks, such as TCP/IP, IPX, and others.</p><p><span class="strong"><strong>Security and Administration</strong></span> To the previous three main architectural components, the SNMP Framework adds a number of supporting elements. These provide enhancements to the operation of the SNMP protocol for security and address issues related to SNMP implementation, version transition, and other administrative issues.</p><div class="figure"><a id="components_of_the_tcpip_internet_standar"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject1_d1e69490"/><img alt="Components of the TCP/IP Internet Standard Management Framework" src="httpatomoreillycomsourcenostarchimages288227.png.jpg"/></div></div><p class="title">Figure 65-2. Components of the TCP/IP Internet Standard Management Framework</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-392"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The three main components of the Internet Standard Management Framework (<a class="indexterm" id="idx-CHP-65-2364"/>SNMP Framework) are the Structure of Management Information (SMI), management information bases (MIBs), and the SNMP protocol itself. These are supported by SNMP security and administration elements.</p></div></div><div class="sect2" title="SNMP Framework Architecture"><div class="titlepage"><div><div><h2 class="title"><a id="snmp_framework_architecture"/>SNMP Framework Architecture</h2></div></div></div><p><a class="indexterm" id="idx-CHP-65-2365"/>The creators of SNMP specifically designed the Framework to be modular, because when SNMP was originally created, it was seen as only a temporary solution until a transition could be made to another network management protocol from the OSI protocol suite. The modular architecture separated definitional, data, and functional (protocol) elements, to allow the SNMP protocol itself to be replaced without changing how network management information was defined and described.</p><p>This transition to the OSI protocol never occurred, but the architecture has still proven valuable in defining the entire scope of SNMP and in making its implementation much simpler. Each of the major components discussed in the previous section—the SMI, MIBs, and SNMP itself—are described in different standards. The modularity of the SNMP Framework has also allowed changes to be made to these components relatively independently of each other, making the transition between SNMP <a class="indexterm" id="idx-CHP-65-2366"/>versions easier than it would have been if one huge document defined everything.</p></div></div>
<div class="sect1" title="TCP/IP Internet Standard Management Framework and SNMP Versions (SNMPv1, SNMPv2 Variants, and SNMPv3)"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_internet_standard_management-id001"/>TCP/IP Internet Standard Management Framework and SNMP Versions (SNMPv1, SNMPv2 Variants, and SNMPv3)</h1></div></div></div><p>In <a class="xref" href="ch03.html" title="Chapter 3. NETWORK STANDARDS AND STANDARDS ORGANIZATIONS">Chapter 3</a>, I explained the differences between proprietary, de facto, and open standards, and described the many benefits of open standards. History is replete with examples of technologies that have succeeded because they used an open standard when a competing standard was proprietary.</p><p>TCP/IP and the Internet are often held up as a model for proper open-standards development. Thousands of TCP/IP standards have been developed and published using the well-known Request for Comments (RFC) standardization process. The result has been the most successful set of internetworking protocols in computing history, accepted and used worldwide.</p><p>Nobody is perfect, however, and no process is perfect either. Some problems occurred in the introduction of SNMP version 2, leading to a virtual breakdown in the normally smooth protocol standardization method, and a proliferation of incompatible variants that we aren't used to seeing in TCP/IP. The story behind this is a continuation of the general SNMP overview and history from earlier in this chapter, and it explains the many SNMP standard names and numbers, so you can make sense of them. At the same time, the discussion serves as a vivid reminder of how important proper standard development is, and what the consequences are when there isn't universal agreement on how a standard should evolve.</p><div class="sect2" title="SNMPv1"><div class="titlepage"><div><div><h2 class="title"><a id="snmpv1"/>SNMPv1</h2></div></div></div><p><a class="indexterm" id="idx-CHP-65-2367"/>The first version of SNMP was developed in early 1988 and published in the form of three RFC standards in August 1988. This first version is now known as <span class="emphasis"><em>SNMP version 1</em></span> or <span class="emphasis"><em>SNMPv1</em></span>. The three SNMPv1 standards provided the initial description of the three main Internet Standard Management Framework components: the SMI, MIB, and SNMP protocol itself. However, the term <span class="emphasis"><em>Internet Standard Management Framework</em></span> was not actually used at that time.</p><p>SNMPv1 was generally accepted and widely deployed in many networks. SNMPv1 got the job done and became the standard for TCP/IP network management. It is still widely used today. It is the Old Faithful of SNMP versions. Slight revisions were made to the initial standards, and more and more MIB modules were defined over time, but the technology remained the same for a number of years.</p><p>As with any technology, users of SNMPv1 identified weaknesses in it and opportunities for improvement. One of the areas in which SNMPv1 was most criticized was the area of security. SNMPv1 used only a "trivial" (as RFC 3410 puts it) authentication scheme, employing a password-like construct called a <span class="emphasis"><em>community string</em></span>.</p><p>The issue of security turned out to be the bone of contention that eventually led to serious problems in the development of SNMP. Some people felt that community strings were sufficient security, but many others felt it was important that better security be put into SNMP. There were many different ways proposed to add security to SNMP, but no universal agreement on how to do it. The points raised about the security weaknesses in the original SNMPv1 had some validity, as I explore in the discussion of SNMP protocol operations in <a class="xref" href="ch67.html" title="Chapter 67. TCP/IP SIMPLE NETWORK MANAGEMENT PROTOCOL (SNMP) CONCEPTS AND OPERATION">Chapter 67</a>.</p></div><div class="sect2" title="SNMPsec"><div class="titlepage"><div><div><h2 class="title"><a id="snmpsec"/>SNMPsec</h2></div></div></div><p><a class="indexterm" id="idx-CHP-65-2368"/>The first attempt to add security came in the form of three standards published in July 1992 that defined a new security mechanism using logical identifiers called <span class="emphasis"><em>parties</em></span>. This is sometimes called <span class="emphasis"><em>SNMP Security</em></span> or <span class="emphasis"><em>SNMPsec</em></span>. This method was more secure than the original SNMPv1, but SNMPsec was never widely accepted, and it is now considered historical.</p></div><div class="sect2" title="SNMPv2"><div class="titlepage"><div><div><h2 class="title"><a id="snmpv2"/>SNMPv2</h2></div></div></div><p>The idea of party-based security never went away, however. It was used as the basis of the definition of the first full revision of SNMP, when <span class="emphasis"><em>SNMP version 2 (SNMPv2)</em></span><a class="indexterm" id="idx-CHP-65-2369"/> was published in RFCs 1441 through 1452 in April 1993. This new version incorporated the new security model, as well as making changes to the actual SNMP protocol operations, changes to the SMI standard (defining version 2 of SMI, SMIv2), and formalizing the concept of the Internet Standard Management Framework.</p><p>Unfortunately, this new standard also was never universally accepted. Some people thought the whole new version was a great advance, but others took issue with the party-based security, claiming it was too complex. A great deal of debate and discussion took place over the next couple of years, as an attempt was made to get everyone on board with the new version.</p></div><div class="sect2" title="SNMPv2 Variants"><div class="titlepage"><div><div><h2 class="title"><a id="snmpv2_variants"/>SNMPv2 Variants</h2></div></div></div><p>Acceptance of SNMPv2 never happened. Instead, different splinter groups broke off and began work on <span class="emphasis"><em>variants</em></span> of SNMPv2. To prevent confusion, the original SNMPv2 became known as either <span class="emphasis"><em>SNMPv2 classic</em></span> (reminiscent of the name a particular soft drink) or <span class="emphasis"><em>SNMPv2p</em></span>, with the <span class="emphasis"><em>p</em></span> referring to party-based security. Things got very interesting (and confusing) when the following were proposed and/or developed:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-65-2370"/>SNMPv1.5</strong></span> You can tell immediately that an idea is probably going to be a problem when it proposes a version number lower than a number already standardized. SNMPv1.5 was an attempt to retain the uncontroversial elements in SNMPv2p—the enhancements to the SNMP protocol and SMI—while going back to community-based security as in SNMPv1. It never became a standard itself, but became the basis of the next variant.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-65-2371"/>Community-Based SNMPv2 (SNMPv2c)</strong></span> This is SNMPv2p modified to use community strings instead of party-based security; in essence, the same idea as SNMPv1.5, but with a more official-sounding name and a few changes. Interestingly, the standard that defines this, RFC 1901, still has an experimental status, despite the fact that <a class="indexterm" id="idx-CHP-65-2372"/>SNMPv2c actually achieved some degree of commercial success, where the standard SNMPv2p did not. SNMPv2c was defined by standards RFC 1902 through 1908, which incorporate other changes, including a new version of SMI (SMIv2).</p><p><span class="strong"><strong>User-Based <a class="indexterm" id="idx-CHP-65-2373"/>SNMPv2 (SNMPv2u)</strong></span> This is an alternative security method for SNMPv2c, which is based on users rather than community strings. It is considered simpler than party-based but more secure than community-string security. It is defined by RFC 1909 and RFC 1910. It, too, is formally considered experimental.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-65-2374"/>SNMPv2*</strong></span> As if all of the other variants were not enough, a well-known vendor decided to define another variant called <span class="emphasis"><em>SNMPv2*</em></span> that combined elements of SNMPv2p and SNMPv2u. This was never formally standardized. (Yes, that's an asterisk in the name. No, there's no footnote at the bottom of the page, so don't bother looking for one. Yes, putting an asterisk in a name is extremely confusing. No, I don't know how it is that marketing people get paid good money to come up with names like this.)</p><p>Now, imagine that you were a network administrator in the mid-1990s and were faced with SNMPv2p, SNMPv2c, SNMPv2u, and SNMPv2*. Which one would you choose? Well, if you are like most people, you would choose none of the above, saying, "I think I'll stick with SNMPv1 until these version 2 folks get their act together!" And that's basically what happened. Some proponents of these variations promoted them, but there was never any agreement, and the result was that the success of all of the various and sundry SNMPv2s was limited. As I said, this is a classic illustration of how important universal standardization is.</p></div><div class="sect2" title="SNMPv3"><div class="titlepage"><div><div><h2 class="title"><a id="snmpv3"/>SNMPv3</h2></div></div></div><p><a class="indexterm" id="idx-CHP-65-2375"/>I would imagine that, at some point, everyone realized that the situation was a mess and decided enough is enough. In 1996, work began on a new approach to resolve the outstanding issues and return universality to SNMP. In 1998, <span class="emphasis"><em>SNMP version 3 (SNMPv3)</em></span> was developed, which includes additional enhancements to SNMP and finally gets all the players back on the same team.</p><p>SNMPv3 is the most current version of SNMP and is still being actively revised. One of the important changes in SNMPv3 is a more formalized way of handing different security approaches to SNMP—obviously, a lesson learned from the SNMPv2 experience.</p><p>SNMPv3 uses SNMPv2 protocol operations and its protocol data unit (PDU) message format, and the SMIv2 standard from SNMPv2 as well. SNMPv3 allows a number of different security methods to be incorporated into its architecture, and includes <a class="indexterm" id="idx-CHP-65-2376"/>standards describing user-based security as defined in SNMPv2u and SNMPv2*, as well as a new view-based access control model. It also includes additional tools to aid in the administration of SNMP.</p></div></div>
<div class="sect1" title="TCP/IP Internet Standard Management Framework and SNMP Standards"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_internet_standard_management-id002"/>TCP/IP Internet Standard Management Framework and SNMP Standards</h1></div></div></div><p>You've now seen that there are three different versions of the Internet Standard Management Framework. Some of these versions have different variants. Each version or variant of the Framework includes multiple modular components. Each component has one or more documents that define it. Some of these have multiple revisions. Add to that dozens of individual MIBs defined for SNMP and other support documents, and what do you have? A boatload of TCP/IP standards, that's what. There are probably more RFCs defining parts of SNMP than any other single TCP/IP protocol or technology.</p><p>It is specifically because there are so many versions and components and documents associated with SNMP that I feel it is important to keep all the standards straight. To that end, Tables <a class="xref" href="ch65s05.html#snmp_version__snmpv_standards" title="Table 65-1. SNMP Version 1 (SNMPv1) Standards">Table 65-1</a> through <a class="xref" href="ch65s05.html#snmp_version__snmpv_standards-id001" title="Table 65-6. SNMP Version 3 (SNMPv3) Standards">Table 65-6</a> show the major SNMP standards for each of the versions and variants of the SNMP Framework: SNMPv1, SNMPsec, SNMPv2p, SNMPv2c, SNMPv2u, and SNMPv3. (SNMPv2* was not standardized using the regular RFC process.) Each individual RFC defines one component of one version of the Framework.</p><p>The usual way that RFCs work is that when new versions of a standard are released that are direct replacements for older ones, the older ones are obsoleted by the new ones. With SNMP, due to the many versions and the controversy over the variants, this is a bit unclear. For example, the standards defining <a class="indexterm" id="idx-CHP-65-2377"/>SNMPv2p are not considered by the IETF to obsolete the standards for <a class="indexterm" id="idx-CHP-65-2378"/>SNMPv1, but the IETF says the standards for SNMPv2c and SNMPv2u do obsolete those of SNMPv2p.</p><p>To keep all of this distinct, I decided to show the standards for each version or variant separately. I put the RFC numbers for obsolete RFCs only where those RFCs are for the same SNMP version or variant. For example, RFC 3410 obsoletes 2570 because they both deal with SNMPv3 and 3410 is a direct replacement for 2570. Also, there are a few cases where the name of a standard changed slightly between RFC numbers; I have shown the current name. A full, hyperlinked list of RFCs can be found at <a class="ulink" href="http://www.rfc-editor.org/rfc-index.html">http://www.rfc-editor.org/rfc-index.html</a>.</p><div class="table"><a id="snmp_version__snmpv_standards"/><p class="title">Table 65-1. SNMP Version 1 (SNMPv1) Standards</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMP Version 1 (SNMPv1) Standards"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Obsolete RFCs</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Most Recent RFC</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Date of Most Recent RFC</p></th><th style="border-bottom: 0.5pt solid ; "><p>Standard Name</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1065</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1155</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>May 1990</p></td><td style="border-bottom: 0.5pt solid ; "><p>Structure and Identification of Management Information for TCP/IP-Based Internets</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1066</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1156</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>May 1990</p></td><td style="border-bottom: 0.5pt solid ; "><p>Management Information Base for Network Management of TCP/IP-Based Internets</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1067, 1098</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1157</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>May 1990</p></td><td style="border-bottom: 0.5pt solid ; "><p>Simple Network Management Protocol (SNMP)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>1158</p></td><td style="border-right: 0.5pt solid ; "><p>1213</p></td><td style="border-right: 0.5pt solid ; "><p>March 1991</p></td><td style=""><p>Management Information Base for Network Management of TCP/IP-Based Internets: MIB-II</p></td></tr></tbody></table></div></div><div class="table"><a id="snmp_security_snmpsec_standards"/><p class="title">Table 65-2. SNMP Security (SNMPsec) Standards</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMP Security (SNMPsec) Standards"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-65-2379"/>Obsolete RFCs</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Most Recent RFC</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Date of Most Recent RFC</p></th><th style="border-bottom: 0.5pt solid ; "><p>Standard Name</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1351</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>July 1992</p></td><td style="border-bottom: 0.5pt solid ; "><p>SNMP Administrative Model</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1352</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>July 1992</p></td><td style="border-bottom: 0.5pt solid ; "><p>SNMP Security Protocols</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; "><p>1353</p></td><td style="border-right: 0.5pt solid ; "><p>July 1992</p></td><td style=""><p>Definitions of Managed Objects for Administration of SNMP Parties</p></td></tr></tbody></table></div></div><div class="table"><a id="party-based_snmp_version__snmpvp_standar"/><p class="title">Table 65-3. Party-Based SNMP Version 2 (SNMPv2p) Standards</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Party-Based SNMP Version 2 (SNMPv2p) Standards"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Obsolete RFCs</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Most Recent RFC</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Date of Most Recent RFC</p></th><th style="border-bottom: 0.5pt solid ; "><p>Standard Name</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1441</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>April 1993</p></td><td style="border-bottom: 0.5pt solid ; "><p>Introduction to Version 2 of the Internet-Standard Network Management Framework</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1442</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>April 1993</p></td><td style="border-bottom: 0.5pt solid ; "><p>Structure of Management Information for Version 2 of the Simple Network Management Protocol (SNMPv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1443</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>April 1993</p></td><td style="border-bottom: 0.5pt solid ; "><p>Textual Conventions for Version 2 of the Simple Network Management Protocol (SNMPv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1444</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>April 1993</p></td><td style="border-bottom: 0.5pt solid ; "><p>Conformance Statements for Version 2 of the Simple Network Management Protocol (SNMPv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1445</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>April 1993</p></td><td style="border-bottom: 0.5pt solid ; "><p>Administrative Model for Version 2 of the Simple Network Management Protocol (SNMPv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1446</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>April 1993</p></td><td style="border-bottom: 0.5pt solid ; "><p>Security Protocols for Version 2 of the Simple Network Management Protocol (SNMPv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1447</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>April 1993</p></td><td style="border-bottom: 0.5pt solid ; "><p>Party MIB for Version 2 of the Simple Network Management Protocol (SNMPv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1448</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>April 1993</p></td><td style="border-bottom: 0.5pt solid ; "><p>Protocol Operations for Version 2 of the Simple Network Management Protocol (SNMPv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1449</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>April 1993</p></td><td style="border-bottom: 0.5pt solid ; "><p>Transport Mappings for Version 2 of the Simple Network Management Protocol (SNMPv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1450</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>April 1993</p></td><td style="border-bottom: 0.5pt solid ; "><p>Management Information Base for Version 2 of the Simple Network Management Protocol (SNMPv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1451</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>April 1993</p></td><td style="border-bottom: 0.5pt solid ; "><p>Manager-to-Manager Management Information Base</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; "><p>1452</p></td><td style="border-right: 0.5pt solid ; "><p>April 1993</p></td><td style=""><p>Coexistence Between Version 1 and Version 2 of the Internet-Standard Network Management Framework</p></td></tr></tbody></table></div></div><div class="table"><a id="community-based_snmp_version__snmpvc_sta"/><p class="title">Table 65-4. Community-Based SNMP Version 2 (SNMPv2c) Standards</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Community-Based SNMP Version 2 (SNMPv2c) Standards"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-65-2380"/>Obsolete RFCs</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Most Recent RFC</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Date of Most Recent RFC</p></th><th style="border-bottom: 0.5pt solid ; "><p>Standard Name</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1901</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>January 1996</p></td><td style="border-bottom: 0.5pt solid ; "><p>Introduction to Community-Based SNMPv2</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1902</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>January 1996</p></td><td style="border-bottom: 0.5pt solid ; "><p>Structure of Management Information for Version 2 of the Simple Network Management Protocol (SNMPv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1903</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>January 1996</p></td><td style="border-bottom: 0.5pt solid ; "><p>Textual Conventions for Version 2 of the Simple Network Management Protocol (SNMPv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1904</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>January 1996</p></td><td style="border-bottom: 0.5pt solid ; "><p>Conformance Statements for Version 2 of the Simple Network Management Protocol (SNMPv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1905</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>January 1996</p></td><td style="border-bottom: 0.5pt solid ; "><p>Protocol Operations for Version 2 of the Simple Network Management Protocol (SNMPv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1906</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>January 1996</p></td><td style="border-bottom: 0.5pt solid ; "><p>Transport Mappings for Version 2 of the Simple Network Management Protocol (SNMPv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1907</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>January 1996</p></td><td style="border-bottom: 0.5pt solid ; "><p>Management Information Base for Version 2 of the Simple Network Management Protocol (SNMPv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; "><p>1908</p></td><td style="border-right: 0.5pt solid ; "><p>January 1996</p></td><td style=""><p>Coexistence between Version 1 and Version 2 of the Internet-Standard Network Management Framework</p></td></tr></tbody></table></div></div><div class="table"><a id="user-based_snmp_version__snmpvu_standard"/><p class="title">Table 65-5. User-Based SNMP Version 2 (SNMPv2u) Standards</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="User-Based SNMP Version 2 (SNMPv2u) Standards"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-65-2381"/>Obsolete RFCs</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Most Recent RFC</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Date of Most Recent RFC</p></th><th style="border-bottom: 0.5pt solid ; "><p>Standard Name</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1909</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>February 1996</p></td><td style="border-bottom: 0.5pt solid ; "><p>An Administrative Infrastructure for SNMPv2</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; "><p>1910</p></td><td style="border-right: 0.5pt solid ; "><p>February 1996</p></td><td style=""><p>User-Based Security Model for SNMPv2</p></td></tr></tbody></table></div></div><div class="table"><a id="snmp_version__snmpv_standards-id001"/><p class="title">Table 65-6. SNMP Version 3 (SNMPv3) Standards</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMP Version 3 (SNMPv3) Standards"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Obsolete RFCs</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Most Recent RFC</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Date of Most Recent RFC</p></th><th style="border-bottom: 0.5pt solid ; "><p>Standard Name</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2576</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>March 2000</p></td><td style="border-bottom: 0.5pt solid ; "><p>Coexistence between Version 1, Version 2, and Version 3 of the Internet-Standard Network Management Framework</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2578</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>April 1999</p></td><td style="border-bottom: 0.5pt solid ; "><p>Structure of Management Information Version 2 (SMIv2)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2579</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>April 1999</p></td><td style="border-bottom: 0.5pt solid ; "><p>Textual Conventions for SMIv2</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2580</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>April 1999</p></td><td style="border-bottom: 0.5pt solid ; "><p>Conformance Statements for SMIv2</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2570</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3410</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>December 2002</p></td><td style="border-bottom: 0.5pt solid ; "><p>Introduction and Applicability Statements for Internet-Standard Management Framework</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2261, 2271, 2571</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3411</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>December 2002</p></td><td style="border-bottom: 0.5pt solid ; "><p>An Architecture for Describing Simple Network Management Protocol (SNMP) Management Frameworks</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2262, 2272, 2572</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3412</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>December 2002</p></td><td style="border-bottom: 0.5pt solid ; "><p>Message Processing and Dispatching for the Simple Network Management Protocol (SNMP)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2263, 2273, 2573</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3413</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>December 2002</p></td><td style="border-bottom: 0.5pt solid ; "><p>Simple Network Management Protocol (SNMP) Applications</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2264, 2274, 2574</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3414</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>December 2002</p></td><td style="border-bottom: 0.5pt solid ; "><p>User-Based Security Model (USM) for Version 3 of the Simple Network Management Protocol (SNMPv3)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2265, 2275, 2575</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3415</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>December 2002</p></td><td style="border-bottom: 0.5pt solid ; "><p>View-Based Access Control Model (VACM) for the Simple Network Management Protocol (SNMP)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3416</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>December 2002</p></td><td style="border-bottom: 0.5pt solid ; "><p>Version 2 of the Protocol Operations for the Simple Network Management Protocol (SNMP)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3417</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>December 2002</p></td><td style="border-bottom: 0.5pt solid ; "><p>Transport Mappings for the Simple Network Management Protocol (SNMP)</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; "><p>3418</p></td><td style="border-right: 0.5pt solid ; "><p>December 2002</p></td><td style=""><p>Management Information Base (MIB) for the Simple Network Management Protocol (SNMP)</p></td></tr></tbody></table></div></div><p>In addition to all of the standards listed in these tables, there are dozens of supplemental RFCs that describe MIB modules and also clarify various fine points of operation related to SNMP. You can find all the MIBs in an online list of RFCs by searching for "MIB" or "SNMP."</p></div>
<div class="chapter" title="Chapter&#xA0;66.&#xA0;TCP/IP STRUCTURE OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT INFORMATION BASES (MIBS)"><div class="titlepage"><div><div><h1 class="title"><a id="tcp_ip_structure_of_management_informati"/>Chapter 66. TCP/IP STRUCTURE OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT INFORMATION BASES (MIBS)</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject2_d1e70449"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p>
The Internet Standard Management Framework defines three major components that describe how devices can be managed on a TCP/IP internetwork. One of these, the actual Simple Network Management Protocol (SNMP) is relatively well known, but is only part of the overall picture. SNMP describes how information is exchanged between SNMP entities, but two other components are equally important, because they describe the information itself.</p><p>In this chapter, I describe these two important supporting elements of the TCP/IP Internet Standard Management Framework: the Management Information Base (MIB) standard that describes types of information that SNMP works with, and the Structure of Management Information (<a class="indexterm" id="idx-CHP-66-2382"/>SMI) standard that specifies how MIB information is defined. Understanding these two parts of the SNMP Framework is an important initial step before we examine the actual SNMP protocol itself.</p><p>I begin with an overview description of the SMI data description language and how MIBs work. I discuss the MIB object name hierarchy and the notation used to refer to names. I also describe how MIB objects work, discussing the different object types and MIB object groups. I describe MIB concepts common to all of the versions of SNMP, and discuss both of the specific versions of <a class="indexterm" id="idx-CHP-66-2383"/>SMI (SMIv1 and SMIv2) used in those SNMP versions.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-393"/>Tip</h3><p><span class="strong"><strong>BACKGROUND INFORMATION</strong></span> <span class="emphasis"><em>If you have not yet already read the preceding chapter describing the SNMP Internet Standard Management Framework, you should do so before proceeding here</em></span>.</p></div><div class="sect1" title="TCP/IP SMI and MIBs Overview"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_smi_and_mibs_overview"/>TCP/IP SMI and MIBs Overview</h1></div></div></div><p><a class="indexterm" id="idx-CHP-66-2384"/>The key to really understanding TCP/IP network management is to comprehend the <span class="emphasis"><em>information-oriented</em></span> nature of the entire Internet Standard Management Framework (SNMP Framework). To see what I mean by this, let's step back for a moment and consider in general terms the problem of network management, and more specifically, the problem of managing devices on a network.</p><div class="sect2" title="SNMP's Information-Oriented Design"><div class="titlepage"><div><div><h2 class="title"><a id="snmps_information-oriented_design"/>SNMP's Information-Oriented Design</h2></div></div></div><p><a class="indexterm" id="idx-CHP-66-2385"/>A network administrator needs to perform two basic types of actions: gather data about devices to learn how they are functioning and give commands to devices to change how they are functioning. In the simplest terms, the first category can be considered as a read operation, and the second is comparable to a write operation.</p><p>A classic way of implementing this functionality is to define a communication protocol. Most such protocols are <span class="emphasis"><em>command-oriented</em></span>—they consist of a specific set of commands to perform the read and write operations. For example, a network management protocol might have a read command such as "report on number of hours device has been in use," and a write command might be something like "put this device into test mode." The network manager would control the device by giving the appropriate commands.</p><p>A command-oriented management protocol has the advantage of simplicity, since it's clear what the commands are for and how they are to be used. It can be reasonably well suited for use in certain environments, but it doesn't work well on a large, heterogeneous TCP/IP internetwork. The main reason for this is that command-orientation inextricably ties the protocol to the devices being managed. Consider the following problems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Every type of device might require a distinct set of commands. For example, the commands given to a router might need to be different than those given to a host. This would lead either to a proliferation of commands in the protocol or to inflexibility in allowing proper management of different device types.</p></li><li class="listitem"><p>Every time a company created a new type of device, or made a unique version of a type of device, the network management protocol would need to be changed.</p></li><li class="listitem"><p>Whenever the operation of a kind of device changed, due perhaps to a change in another protocol, the management protocol would need to be updated.</p></li><li class="listitem"><p>The protocol itself could not be easily changed without affecting a lot of hardware.</p></li></ul></div><p>The solution to the problems of command-oriented management protocols is to use an <span class="emphasis"><em>information-oriented</em></span> model. Instead of defining specific commands that interrogate or control devices, the devices are defined in terms of units of information that are to be exchanged between the devices and a management station.</p><p>Instead of read commands and write commands, we have <span class="emphasis"><em>variables</em></span> that can be read or written. Take the two examples mentioned earlier. Instead of a command like "report on a number of hours device has been in use," the device keeps a variable called "number of hours in use," and the network management station can read this as one of many variables, with no need for a specific protocol command. Instead of a write command called "put this device into test mode," the device has a variable called "current mode." The network manager can change the mode of the device to test mode by changing the value of the variable.</p><p>This difference may seem subtle, but it underlies every aspect of how SNMP works. I believe part of why the SNMP Framework is hard to understand is because insufficient emphasis is placed on looking at things in the "SNMP way," which means thinking about information objects and not commands.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-394"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Unlike most protocols, which are <span class="emphasis"><em>command-oriented</em></span>, SNMP is <span class="emphasis"><em>information-oriented</em></span>. SNMP operations are implemented using objects called <span class="emphasis"><em>variables</em></span> that are maintained in managed devices. Rather than issuing commands, a network management station checks the status of a device by reading variables, and controls the operation of the device by changing (writing) variables.</p></div></div><div class="sect2" title="MIB and MIB Objects"><div class="titlepage"><div><div><h2 class="title"><a id="mib_and_mib_objects"/>MIB and MIB Objects</h2></div></div></div><p>Given this backdrop, we can look at the SNMP Framework in a new light. The actual SNMP protocol itself, which we'll examine in the next couple of chapters, has only a few, generic commands to accomplish read and write tasks. It deals with only the methods by which network management information is exchanged between SNMP agents and SNMP network management stations (NMSs), which were described in the previous chapter. The network management information is really the heart of TCP/IP network management.</p><p>So, instead of SNMP being defined in terms of commands used to control particular devices, it is defined in terms of management information variables, generally called <span class="emphasis"><em>objects</em></span>. Each object describes a particular characteristic of a device. Some objects are fairly generic and are meaningful for any device on a TCP/IP network; for example, an object describing something related to the Internet Protocol (IP) itself, such as the device's IP address. Other objects might be particular to a specific type of device; for example, a router will have objects that a regular host's Ethernet network interface card would not.</p><p>A collection of objects used in SNMP is called a <span class="emphasis"><em>management information base</em></span>, or <span class="emphasis"><em>MIB</em></span>. (In fact, SNMP objects are often called <span class="emphasis"><em>MIB objects</em></span>.) The first version of SNMP, SNMPv1, had a single standard that defined the entire MIB for SNMP. Newer versions provide more flexibility by using different <span class="emphasis"><em>MIB modules</em></span> that define sets of variables particular to the hardware or software used by a device.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-395"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The management data variables in a managed device are maintained in a logical collection called a <span class="emphasis"><em>management information base (MIB)</em></span>. The objects in the MIB are often called <span class="emphasis"><em>MIB objects</em></span>, and they are typically collected into sets called <span class="emphasis"><em>MIB modules</em></span>.</p></div><p>Defining objects using modules allows for significant flexibility in defining the variables that allow management of different types of devices. A device can incorporate all the MIB modules appropriate to the hardware and software it uses. For example, if you had a device using Ethernet, it would incorporate variables from the Ethernet MIB. A device using Token Ring would use the Token Ring MIB. Both devices would also use the common SNMP MIB that is used by all TCP/IP devices. Other modules might also be included as needed.</p><div class="note" title="Note"><h3 class="title"><a id="note-151"/>Note</h3><p><span class="emphasis"><em>Due to its name, the MIB is often called a database. This is, strictly speaking, inaccurate. The MIB is a description of objects. The actual MIB in a device may be implemented as a software database, but that is not required</em></span>.</p></div></div><div class="sect2" title="Defining MIB Objects: SMI"><div class="titlepage"><div><div><h2 class="title"><a id="defining_mib_objects_smi"/>Defining MIB Objects: SMI</h2></div></div></div><p><a class="indexterm" id="idx-CHP-66-2386"/><a class="indexterm" id="idx-CHP-66-2387"/>The use of MIB objects solves the problem of the network management protocol being tied to the network management information. However, we must be very particular about how we define these objects. Again, the reason is the wide variety of devices that TCP/IP allows to be connected together. Each device may represent information in a different way. For all of them to communicate with each other, we need to ensure that management information is represented in a consistent manner.</p><p>The part of the SNMP Framework that ensures the universality of MIB objects is the <span class="emphasis"><em>Structure of Management Information (SMI)</em></span> standard. SMI defines the rules for how MIB objects and MIB modules are constructed. In SMI, MIB objects are described using a precise set of definitions based on a data description language called the ISO <span class="emphasis"><em>Abstract Syntax Notation 1 (ASN.1)</em></span> standard.</p><p>In essence, we really have three levels of abstraction in SNMP. The actual SNMP protocol moves values that represent the state of management devices. The MIB defines what these variables are. And the SMI defines how the variables in the MIB are themselves defined.</p><p>There are two main SMI standards. The original, <span class="emphasis"><em>SMIv1</em></span>, was part of the first SNMP Framework, SNMPv1, defined in RFC 1155. It sets out the basic rules for MIBs and MIB variables. The second, <span class="emphasis"><em>SMIv2</em></span>, was defined as part of SNMPv2p in RFC 1442 and further updated in RFC 2578, part of SNMPv3. It is similar to the earlier version, but defines more object types, as well as the structure of MIB modules.</p><p>These SMI standards are responsible for defining the following important information elements in SNMP:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The general characteristics associated with all MIB objects—the standard way by which all MIB objects are described</p></li><li class="listitem"><p>The different types of MIB objects that can be created, such as integers, strings, and more complex data types</p></li><li class="listitem"><p>A hierarchical structure for naming MIB <a class="indexterm" id="idx-CHP-66-2388"/>objects, so they can be addressed in a consistent manner without names overlapping</p></li><li class="listitem"><p>The information associated with each MIB module</p></li></ul></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-396"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The <span class="emphasis"><em>Structure of Management Information (SMI)</em></span> standard is responsible for defining the rules for how MIB objects are structured, described, and organized. SMI allows dissimilar devices to communicate by ensuring that they use a universal data representation for all management information.</p></div></div></div></div>
<div class="sect1" title="TCP/IP MIB Objects, Object Characteristics, and Object Types"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_mib_objects_object_characteristics"/>TCP/IP MIB Objects, Object Characteristics, and Object Types</h1></div></div></div><p><a class="indexterm" id="idx-CHP-66-2389"/>As explained in the previous sections, the SNMP Framework is designed to facilitate the exchange of management information. The MIB defines a device's management information and contains a number of variables called <span class="emphasis"><em>MIB objects</em></span>, also called <span class="emphasis"><em>managed objects</em></span>. These objects are defined according to the rules set out in the SMI standard.</p><p>The best place to begin looking at MIB objects is by examining the SMI rules that define them. As I mentioned earlier in this chapter, two different versions of SMI have been created: SMIv1 as part of the original SNMP, and SMIv2 as part of SNMPv2 and SNMPv3. The two are similar in terms of how MIB objects are described, but SMIv2 allows more information to be associated with each object.</p><div class="sect2" title="MIB Object Characteristics"><div class="titlepage"><div><div><h2 class="title"><a id="mib_object_characteristics"/>MIB Object Characteristics</h2></div></div></div><p>Just as a typical protocol uses a field format for specifying the content of messages sent between devices using the protocol, SMI uses a format that specifies the fundamental characteristics of each MIB object. The most basic of these are five mandatory characteristics defined in SMIv1. These are also used in SMIv2, but a couple of names were changed, and the possible values for some of the fields were modified as well. An MIB object may have the following characteristics (see <a class="xref" href="ch66s02.html#snmp_management_information_base_mib_thi" title="Figure 66-1. SNMP management information base (MIB) This diagram shows an SNMP MIB containing N MIB objects. Each object has five mandatory characteristics and a variable number of optional characteristics.">Figure 66-1</a>):</p><p><span class="strong"><strong>Object Name</strong></span> Each object has a name that serves to uniquely identify it. Actually, that's not entirely true. Each object has <span class="emphasis"><em>two</em></span> names: a textual name called an <span class="emphasis"><em>object descriptor</em></span> and a numeric <span class="emphasis"><em>object identifier</em></span>, which indicates the object's place in the MIB object name hierarchy. We'll explore these names and how they are used shortly.</p><p><span class="strong"><strong>Syntax</strong></span> Defines the object's data type and the structure that describes it. This attribute is very important because it defines the data type of information that the object contains. There are two basic categories of data types allowed:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Regular data types are single pieces of information, of the type we are used to dealing with on a regular basis, such as integers and strings. These are called <span class="emphasis"><em>base types</em></span> in SMIv2. SMIv1 differentiates between <span class="emphasis"><em>primitive types</em></span> like integers defined in ASN.1, and <span class="emphasis"><em>defined types</em></span> that are special forms of primitive types that are still single pieces of information but with certain special meaning attached to how they are used. SMIv2 doesn't use those two terms.</p></li><li class="listitem"><p>Tabular data types are collections of multiple data elements. They may take the form of a list of base types or a table of base types. For example, a table of integers could be constructed to represent a set of values. In SMIv1, these are called <span class="emphasis"><em>constructor types</em></span>; in SMIv2 they are <span class="emphasis"><em>conceptual tables</em></span>. They can be <a class="indexterm" id="idx-CHP-66-2390"/>accessed using special SNMP mechanisms designed for reading tables. See the topic on SNMP table traversal for more on tables.</p></li></ul></div><p><span class="strong"><strong>Access (<a class="indexterm" id="idx-CHP-66-2391"/>Max-Access in SMIv2)</strong></span> This field defines the ways that an SNMP application will normally use the object. In SMIv1, there are four different possible values: <span class="emphasis"><em>read-only</em></span>, <span class="emphasis"><em>read-write</em></span>, <span class="emphasis"><em>write-only</em></span>, and <span class="emphasis"><em>not-accessible</em></span>. In SMIv2 there are five values, which are described as a hierarchy of sorts. SMIv2 calls this characteristic <span class="emphasis"><em>Max-Access</em></span> (<span class="emphasis"><em>maximum access</em></span>) to make it explicit that higher access levels include the lower levels as well. For example, an object with read-create access can also be used in any of the modes below it, such as read-write, but not vice versa. The following are the five SMIv2 access values, in decreasing order of access (note that write-only has been removed in SMIv2):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>read-create</em></span> (object can be read, written, or created)</p></li><li class="listitem"><p><span class="emphasis"><em>read-write</em></span> (object can be read or written)</p></li><li class="listitem"><p><span class="emphasis"><em>read-only</em></span> (object can only be read)</p></li><li class="listitem"><p><span class="emphasis"><em>accessible-for-notify</em></span> (object can be used only using SNMP notification or SNMP traps)</p></li><li class="listitem"><p><span class="emphasis"><em>not-accessible</em></span> (used for special purposes)</p></li></ul></div><p><span class="strong"><strong>Status</strong></span> Indicates the currency of the object definition. In SMIv1 there are three values: <span class="emphasis"><em>mandatory</em></span>, <span class="emphasis"><em>optional</em></span>, and <span class="emphasis"><em>obsolete</em></span>. In SMIv2, the first two are combined into simply <span class="emphasis"><em>current</em></span>, meaning a current definition. The value <span class="emphasis"><em>obsolete</em></span> is retained, and <span class="emphasis"><em>deprecated</em></span> is added, meaning the definition is obsolete but maintained for compatibility.</p><p><span class="strong"><strong>Definition (Description in SMIv2)</strong></span> A textual description of the object.</p><p><span class="strong"><strong>Optional Characteristics</strong></span> SMIv2 adds the following optional characteristics that may appear in the definition of an object:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Units</em></span> is a textual description of the units associated with the object.</p></li><li class="listitem"><p><span class="emphasis"><em>Reference</em></span> is a text cross-reference to a related document or other information relevant to the object.</p></li><li class="listitem"><p><span class="emphasis"><em>Index</em></span> is a value used to define objects that are actually more complex rows of other objects.</p></li><li class="listitem"><p><span class="emphasis"><em>Augments</em></span> is an alternative to the Index field.</p></li><li class="listitem"><p><span class="emphasis"><em>DefVal</em></span> defines an acceptable default value for the object.</p></li></ul></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-397"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> Each management information variable, called an <span class="emphasis"><em>MIB object</em></span>, has associated with it five key attributes: its name, syntax, maximum access, status, and definition. It may also have a number of optional characteristics.</p></div><div class="figure"><a id="snmp_management_information_base_mib_thi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e70839"/><img alt="SNMP management information base (MIB) This diagram shows an SNMP MIB containing N MIB objects. Each object has five mandatory characteristics and a variable number of optional characteristics." src="httpatomoreillycomsourcenostarchimages288229.png.jpg"/></div></div><p class="title">Figure 66-1. SNMP management information base (MIB) This diagram shows an SNMP MIB containing N MIB objects. Each object has five mandatory characteristics and a variable number of optional characteristics.</p></div></div><div class="sect2" title="SMI Data Types"><div class="titlepage"><div><div><h2 class="title"><a id="smi_data_types"/>SMI Data Types</h2></div></div></div><p><a class="xref" href="ch66s02.html#snmp_smi_regular_data_types" title="Table 66-1. SNMP SMI Regular Data Types">Table 66-1</a> shows the regular <a class="indexterm" id="idx-CHP-66-2392"/>data types supported for objects in both SMIv1 and SMIv2. (The names with 32 in them are the ones used in SMIv2; they were changed to make the type's bit size explicit.) The first five entries in the table are primitive types; the rest are defined types, using the SMIv1 terminology.</p><div class="table"><a id="snmp_smi_regular_data_types"/><p class="title">Table 66-1. SNMP SMI Regular Data Types</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMP SMI Regular Data Types"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-66-2393"/><a class="indexterm" id="idx-CHP-66-2394"/>Data Type Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>In SMIv1?</p></th><th style="border-bottom: 0.5pt solid ; "><p>In SMIv2?</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer/Integer32</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A 32-bit signed integer in two's complement notation, capable of holding a value from -2,147,483,648 to +2,147,483,647. Can also be used to represent an enumerated type; for example, where 1 represents a particular constant, 2 represents a different one, and so on.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-bottom: 0.5pt solid ; "><p>Yes</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Octet String</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A variable-length string of binary or text data.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-bottom: 0.5pt solid ; "><p>Yes</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Null</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Nothing.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-bottom: 0.5pt solid ; "><p>No</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Bits</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>An enumeration of named bits. Used to allow a set of bit flags to be treated as a single data type.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No</p></td><td style="border-bottom: 0.5pt solid ; "><p>Yes</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Unsigned</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A 32-bit unsigned integer, from 0 to 4,294,967,295.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>No</p></td><td style="border-bottom: 0.5pt solid ; "><p>Yes</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Network Address/IpAddress</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>An IP address, encoded as a 4-byte octet string.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-bottom: 0.5pt solid ; "><p>Yes</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Counter/Counter32</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A 32-bit unsigned integer that begins at 0 and increases up to 4,294,967,295, then wraps back to 0.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-bottom: 0.5pt solid ; "><p>Yes</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Gauge/Gauge32</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A 32-bit unsigned integer that may have a value from 0 to 4,294,967,295 and may increase or decrease, like a gauge. A minimum and maximum value are associated with the gauge, indicating its normal range.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-bottom: 0.5pt solid ; "><p>Yes</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TimeTicks</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>A 32-bit unsigned integer that indicates the number of hundredths of seconds since some arbitrary start date. Used for timestamping and to compute elapsed time.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-bottom: 0.5pt solid ; "><p>Yes</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Opaque</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Data using arbitrary ASN.1 syntax that is to be passed between devices without being interpreted. As in the Network File System's (NFS) XDR (see <a class="xref" href="ch58.html" title="Chapter 58. NETWORK FILE AND RESOURCE SHARING AND THE TCP/IP NETWORK FILE SYSTEM (NFS)">Chapter 58</a>), the term opaque means that the data is treated like a black box, whose internal details cannot be seen.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Yes</p></td><td style="border-bottom: 0.5pt solid ; "><p>Yes</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Counter64</p></td><td style="border-right: 0.5pt solid ; "><p>A counter like Counter32 but 64 bits wide, allowing a value from 0 to 18,446,744,073,709,551,615.</p></td><td style="border-right: 0.5pt solid ; "><p>No</p></td><td style=""><p>Yes</p></td></tr></tbody></table></div></div><p>In addition to the types shown in <a class="xref" href="ch66s02.html#snmp_smi_regular_data_types" title="Table 66-1. SNMP SMI Regular Data Types">Table 66-1</a>, other defined types are also created to indicate more specific semantics for a particular data type. These are called <a class="indexterm" id="idx-CHP-66-2395"/><span class="emphasis"><em>textual conventions</em></span> and are described in RFC 2579 for <a class="indexterm" id="idx-CHP-66-2396"/>SMIv2. For example, a type called <span class="emphasis"><em>TimeStamp</em></span> is the same as <span class="emphasis"><em>TimeTicks</em></span>. However, seeing an object using the former rather than the latter makes it more clear that the variable is representing a particular timestamp value. Another is called <span class="emphasis"><em>TimeInterval</em></span>, which is also just an integer underneath its name, but conveys a different interpreted meaning.</p><p>If all of this seems very confusing to you, note that this description is actually a significant simplification of SMI's object definitions. Check out <a class="xref" href="ch66s02.html#example_snmp_smiv2_object_definition" title="Example 66-1. Example SNMP SMIv2 object definition">Example 66-1</a>, which shows an object definition from RFC 3418, using SMIv2.</p><div class="example"><a id="example_snmp_smiv2_object_definition"/><p class="title">Example 66-1. Example SNMP SMIv2 object definition</p><div class="example-contents"><pre class="programlisting">sysLocation OBJECT-TYPE
     SYNTAX DisplayString (SIZE (0..255))
     MAX-ACCESS read-write
     STATUS current
     DESCRIPTION "The physical location of this node
      (e.g., 'telephone closet, 3rd floor'). If the location
      is unknown, the value is the zero-length string."
              ::= { system 6 }</pre></div></div><p>Note that <code class="literal">DisplayString</code> is a textual convention for a displayed text string. The last part, <code class="literal">{ system 6 }</code>, will be explained in the next section.</p></div></div>
<div class="sect1" title="TCP/IP MIB Object Descriptors and Identifiers and the Object Name Hierarchy"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_mib_object_descriptors_and_identif"/>TCP/IP MIB Object Descriptors and Identifiers and the Object Name Hierarchy</h1></div></div></div><p>Of the many MIB object characteristics, only one is sufficiently interesting that it really deserves its own exposition. Or perhaps I should say that only one is sufficiently complicated to require further explanation. This is the object name, part of the larger naming system used for MIB objects.</p><p>Each MIB object actually has two names: an <span class="emphasis"><em>object descriptor</em></span> and an <span class="emphasis"><em>object identifier</em></span>.</p><div class="sect2" title="Object Descriptors"><div class="titlepage"><div><div><h2 class="title"><a id="object_descriptors"/>Object Descriptors</h2></div></div></div><p><a class="indexterm" id="idx-CHP-66-2397"/>The object descriptor is a conventional text name that provides a user-friendly handle to refer to the object. The name is assigned based on the particular MIB object group in which the object is located. In the previous example, <code class="literal">sysLocation</code> is the object descriptor for that MIB object. I describe these names in greater detail later in this chapter, when I discuss MIB modules and object groups.</p></div><div class="sect2" title="Object Identifiers"><div class="titlepage"><div><div><h2 class="title"><a id="object_identifiers"/>Object Identifiers</h2></div></div></div><p><a class="indexterm" id="idx-CHP-66-2398"/>Text names are convenient, but they are generally unstructured. There are at present more than 10,000 different MIB objects, and even if each has a distinct text name, a huge collection of such names doesn't help us to manage these objects and see how they are related. For this, we need a more structured approach to categorizing and naming objects.</p><p>This problem is similar to another problem that you may recall reading about: the problem of how to assign names on the Internet. Originally, names for hosts were simple, flat names, but this quickly grew unwieldy. The DNS hierarchical name space (see <a class="xref" href="ch53.html" title="Chapter 53. DNS NAME SPACE, ARCHITECTURE, AND TERMINOLOGY">Chapter 53</a>) allows every device to be arranged into a single hierarchical tree structure. The name of the device can be formed by traversing the tree from the top down to the location of the device, listing the labels traversed separated by dots. For example, the web server of The PC Guide is at <a class="ulink" href="http://www.pcguide.com">http://www.pcguide.com</a>.</p><p>This same concept is used to organize MIB objects in SNMP. A single, universal hierarchy that contains all MIB objects is used. It is hierarchical in nature, and it is split into levels from the most general to the most specific. Each object has a particular place in the hierarchy.</p><p>There is an important difference between the MIB name hierarchy and the DNS one: the MIB name hierarchy is even more universal than the one for DNS. The entire subtree of all MIB objects is just one branch of the full, international object hierarchy maintained by the International Organization for Standardization (ISO) and the International Telecommunication Union (ITU). This object identification hierarchy is so general that it can contain a name for every object or variable in use by any technology in the entire world (and possibly other planets or solar systems).</p><p>The reason for my jocularity will become apparent in a moment. Suffice it to say that this object tree is enormous. Each node in this tree is identified with both a label and an integer. The labels are for descriptive purposes. Object (or subtree) identifiers are formed by listing the numbers in sequence from the top of the tree down to the node, separated by dots. SNMP doesn't reverse the order of the labels the way DNS does, however. They are listed top-down from left to right. (The text labels can be used for names, too, but they are not because they would get very long due to how deep the tree structure is.)</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-398"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> SNMP MIB objects have two names. The first is a text <span class="emphasis"><em>object descriptor</em></span>, which provides a means of addressing the object in a way that is familiar and easy for humans. The second is the <span class="emphasis"><em>object identifier</em></span>, which consists of a sequence of integers that specifies the location of the object in the global object hierarchy maintained by the international standards bodies ISO and ITU.</p></div></div><div class="sect2" title="Structure of the MIB Object Name Hierarchy"><div class="titlepage"><div><div><h2 class="title"><a id="structure_of_the_mib_object_name_hierarc"/>Structure of the MIB Object Name Hierarchy</h2></div></div></div><p><a class="indexterm" id="idx-CHP-66-2399"/>Let's explore how the MIB object tree is structured, and more important, how SNMP MIB objects fit into it. <a class="xref" href="ch66s03.html#global_object_name_hierarchy_and_snmp_mi" title="Figure 66-2. Global object name hierarchy and SNMP MIB hierarchies This diagram shows the object name hierarchy defined by ISO and CCITT (ITU) to allow all types of objects to be universally represented. The path within this larger tree to the tree branches relevant to SNMP can be found by following the shaded boxes. The two subtrees used for SNMP are shown as the hatched boxes under internet(1). Each contains its own substructure (some of which is illustrated here) defining thousands of different MIB objects. The branch on the left side is used for generic MIB objects and the one on the right for private ones. A separate hierarchy is also defined for SNMPv2.">Figure 66-2</a> illustrates the global object <a class="indexterm" id="idx-CHP-66-2400"/>name hierarchy and SNMP MIB hierarchies.</p><div class="figure"><a id="global_object_name_hierarchy_and_snmp_mi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject2_d1e71161"/><img alt="Global object name hierarchy and SNMP MIB hierarchies This diagram shows the object name hierarchy defined by ISO and CCITT (ITU) to allow all types of objects to be universally represented. The path within this larger tree to the tree branches relevant to SNMP can be found by following the shaded boxes. The two subtrees used for SNMP are shown as the hatched boxes under internet(1). Each contains its own substructure (some of which is illustrated here) defining thousands of different MIB objects. The branch on the left side is used for generic MIB objects and the one on the right for private ones. A separate hierarchy is also defined for SNMPv2." src="httpatomoreillycomsourcenostarchimages288231.png.jpg"/></div></div><p class="title">Figure 66-2. Global object name hierarchy and SNMP MIB hierarchies This diagram shows the object name hierarchy defined by ISO and CCITT (ITU) to allow all types of objects to be universally represented. The path within this larger tree to the tree branches relevant to SNMP can be found by following the shaded boxes. The two subtrees used for SNMP are shown as the hatched boxes under internet(1). Each contains its own substructure (some of which is illustrated here) defining thousands of different MIB objects. The branch on the left side is used for generic MIB objects and the one on the right for private ones. A separate hierarchy is also defined for SNMPv2.</p></div><p>The tree's root has no label, and has three children:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>ccitt(0) for ITU (formerly the CCITT) standards (also seen as itu(0)).</p></li><li class="listitem"><p>iso(1) for ISO standards.</p></li><li class="listitem"><p>joint-iso-ccitt(2) for joint standards (also seen as joint-iso-itu(2)).</p></li></ul></div><p>Following the iso(1) node, we see the following at the next several levels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Within iso(1), the ISO has created a subtree for use by other organizations, called org(3).</p></li><li class="listitem"><p>Within org(3), there is a subtree for the United States Department of Defense (which, as you may recall, was the originator of the Internet): dod(6).</p></li><li class="listitem"><p>Within dod(6), there is a subtree called internet(1).</p></li></ul></div><p>Everything we work with in SNMP is under this one very specific subtree: 1.3.6.1, which if we used the text labels would be iso.org.dod.internet. Within this part of the name space, there are six subtrees below:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>directory(1) is reserved for future use by ISO.</p></li><li class="listitem"><p>mgmt(2) is the primary subtree where MIB objects are located. This is 1.3.6.1.2. It contains a subtree called mib(1), which is 1.3.6.1.2.1. When MIB-II was created, a subtree called mib-2(1) was created using the same number, 1.3.6.1.2.1.</p></li><li class="listitem"><p>experimental(3) contains objects used for standards under development. This is 1.3.6.1.3.</p></li><li class="listitem"><p>private(4) is used for objects defined by private companies. This node, 1.3.6.1.4, has a subtree called enterprise(1), which is 1.3.6.1.4.1.</p></li><li class="listitem"><p>security(5) is reserved for security use.</p></li><li class="listitem"><p>snmpV2(6) defines objects used specifically for SNMP version 2.</p></li></ul></div><p>So, what's the bottom line of all this? Well, basically all MIB module objects are named within one of these two branches of the overall object tree:</p><p><span class="strong"><strong>Regular MIB Objects</strong></span> These are in the mib(1) subtree under mgmt(2): 1.3.6.1.2.1.</p><p><span class="strong"><strong>Private MIB Objects</strong></span> These are in the enterprise(1) subtree under private(4), which is 1.3.6.1.4.1. For example, within enterprise(1), there is an entry cisco(9) for Cisco Systems. So all Cisco-specific MIB objects start with 1.3.6.1.4.1.9.</p><p>Clear as mud, right? Why didn't they just make a separate hierarchy where "mib" was at the top instead of six levels deep? How dare you even suggest such a thing? Don't you understand the importance of global standards?</p><p>All facetiousness aside, this name hierarchy is a bit cumbersome to deal with (okay, more than a bit), but it does allow us to keep MIB objects organized in a sensible way. Within the 1.3.6.1.2.1 subtree, we find most of the regular MIB objects used in SNMP. Each subtree within 1.3.6.1.2.1 corresponds to one of the regular SNMP object groups or a particular MIB module.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-399"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> All MIB objects have object identifiers that fit within two branches of the global object hierarchy. Regular MIB objects (which are not vendor-specific) fit in the mib(1) subtree under mgmt(2): 1.3.6.1.2.1. Private objects, which can be created by a hardware vendor to assist in managing that vendor's products, are in the enterprise(1) subtree under private(4), which is 1.3.6.1.4.1.</p></div></div><div class="sect2" title="Recursive Definition of MIB Object Identifiers"><div class="titlepage"><div><div><h2 class="title"><a id="recursive_definition_of_mib_object_ident"/>Recursive Definition of MIB Object Identifiers</h2></div></div></div><p><a class="indexterm" id="idx-CHP-66-2401"/>An object is given a text object descriptor by putting its name at the start of the object, as shown in <a class="xref" href="ch66s02.html#example_snmp_smiv2_object_definition" title="Example 66-1. Example SNMP SMIv2 object definition">Example 66-1</a>, but the definition of numeric object identifiers is, again, more complex. It is done by defining only the number of the object within its particular subtree. This means the object identifiers are defined recursively (one based on another) and are not explicitly stated for each object. This is syntactically precise, but makes it hard to see at a glance what the number is for any particular object.</p><p>Consider again the example in <a class="xref" href="ch66s02.html#example_snmp_smiv2_object_definition" title="Example 66-1. Example SNMP SMIv2 object definition">Example 66-1</a>. For this object, <code class="literal">sysLocation</code> is the object descriptor and <code class="literal">{ system 6 }</code> is the object identifier. This means it is object number 6 within the node system, which is in turn defined as <code class="literal">{ mib-2 1 }</code>—it is the first node within the mib-2 subtree. Since mib-2 is 1.3.6.1.2.1, as noted in the previous section, this means <code class="literal">system</code> is 1.3.6.1.2.1.1 and <code class="literal">sysLocation</code> is 1.3.6.1.2.1.1.6.</p></div></div>
<div class="sect1" title="TCP/IP MIB Modules and Object Groups"><div class="titlepage"><div><div><h1 class="title"><a id="tcpip_mib_modules_and_object_groups"/>TCP/IP MIB Modules and Object Groups</h1></div></div></div><p><a class="indexterm" id="idx-CHP-66-2402"/>The MIB contains the collection of MIB objects that describe the characteristics of a device using the SNMP Framework. When SNMP was first created, there were not that many objects in the MIB. Furthermore, they were mostly generic objects that applied fairly universally to TCP/IP devices as a whole. In fact, most of the MIB objects were variables related to the operation of TCP/IP protocols such as IP, the Transmission Control Protocol (TCP), and the Internet Control Message Protocol (ICMP).</p><p>For this reason, at first, a single document defined "the" MIB for SNMP. The first of these documents was RFC 1066, part of the initial SNMPv1 specification. It was then revised in RFC 1156. In RFC 1158, a second version of the MIB, <span class="emphasis"><em>MIB II</em></span>, was defined, which was essentially the same but made a few changes.</p><div class="sect2" title="The Organization of MIB Objects into Object Groups"><div class="titlepage"><div><div><h2 class="title"><a id="the_organization_of_mib_objects_into_obj"/>The Organization of MIB Objects into Object Groups</h2></div></div></div><p>The number of MIB objects defined in the early MIB standards was relatively small. However, there were still several dozen of them, and it was recognized from the start that more would be created in time. To help organize the objects in a logical way, they were arranged into <span class="emphasis"><em>object groups</em></span>. These groups serve the purpose of separating the objects and defining how they should be given object identifiers in the overall object name hierarchy.</p><p>Each group has associated with it three important pieces of information:</p><p><span class="strong"><strong>Group Name</strong></span> This is a name that is used as a text label in the object identification tree described earlier in this chapter (see <a class="xref" href="ch66s03.html#global_object_name_hierarchy_and_snmp_mi" title="Figure 66-2. Global object name hierarchy and SNMP MIB hierarchies This diagram shows the object name hierarchy defined by ISO and CCITT (ITU) to allow all types of objects to be universally represented. The path within this larger tree to the tree branches relevant to SNMP can be found by following the shaded boxes. The two subtrees used for SNMP are shown as the hatched boxes under internet(1). Each contains its own substructure (some of which is illustrated here) defining thousands of different MIB objects. The branch on the left side is used for generic MIB objects and the one on the right for private ones. A separate hierarchy is also defined for SNMPv2.">Figure 66-2</a>). These objects are all located within the iso.org.dod.internet.mgmt.mib subtree. So, for example, the group system would be iso.org.dod.internet.mgmt.mib.system.</p><p><span class="strong"><strong>Group Number</strong></span> This number corresponds to the group name used for making numeric identifiers from the object name tree. For example, the group system has the number 1, and so the group's object identifier is 1.3.6.1.2.1.1. All objects in that group will be under that tree; for example, <code class="literal">sysUpTime</code> is 1.3.6.1.2.1.1.3.</p><p><span class="strong"><strong>Group Code</strong></span> This is a text label that may be the same as the group name or may be an abbreviation. It is used as a prefix in making object descriptors (the text names of objects). For example, for the group system, the code is <code class="literal">sys</code>, and so an object in this group is <code class="literal">sysUpTime</code>.</p><p><a class="xref" href="ch66s04.html#snmp_generic_mib_object_groups" title="Table 66-2. SNMP Generic MIB Object Groups">Table 66-2</a> shows the eight generic SNMP groups defined in RFC 1158, along with their codes, names, and numbers.</p><div class="table"><a id="snmp_generic_mib_object_groups"/><p class="title">Table 66-2. SNMP Generic MIB Object Groups</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMP Generic MIB Object Groups"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-66-2403"/>Group Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Group Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Group Number</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Full Group Identifier</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>system</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">sys</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.1</p></td><td style="border-bottom: 0.5pt solid ; "><p>General objects of relevance to all or most devices. For example, a general description of the device is an object in this group, as is the identifier of the object. Later MIB versions greatly expanded the number of variables in this group.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>interfaces</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">if</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Objects related to the IP interfaces between this device and the internetwork. (Recall that a regular host normally has one interface, while a router has two or more.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>at (address translation)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">at</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.3</p></td><td style="border-bottom: 0.5pt solid ; "><p>Objects used for IP address translation. (No longer used.)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>ip</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ip</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Objects related to the IP layer of the device as a whole (as opposed to interface-specific information in the <code class="literal">if</code> group).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>icmp</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">icmp</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.5</p></td><td style="border-bottom: 0.5pt solid ; "><p>Objects related to the operation of ICMP.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>tcp</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">tcp</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.6</p></td><td style="border-bottom: 0.5pt solid ; "><p>Objects related to the operation of the TCP.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>udp</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">udp</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.7</p></td><td style="border-bottom: 0.5pt solid ; "><p>Objects related to the operation of the User Datagram Protocol (UDP).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>egp</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">egp</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.8</p></td><td style="border-bottom: 0.5pt solid ; "><p>Objects related to the operation of the Exterior Gateway Protocol (EGP).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>cmot</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">cmot</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.9</p></td><td style="border-bottom: 0.5pt solid ; "><p>Objects related to running the CMIP protocol over TCP (historical, not used).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>transmission</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">trans</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.10</p></td><td style="border-bottom: 0.5pt solid ; "><p>Objects related to the specific method of information transmission used by each interface on the system.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>snmp</p></td><td style="border-right: 0.5pt solid ; "><p><code class="literal">snmp</code></p></td><td style="border-right: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; "><p>1.3.6.1.2.1.11</p></td><td style=""><p>Objects used to manage SNMP itself.</p></td></tr></tbody></table></div></div><p>All of the groups in this table are fairly generic, and with the exception of the one about EGP, apply to pretty much every TCP/IP system using SNMP. (The mention of EGP, a routing protocol now considered obsolete, shows the age of this list.) The first five groups and the last one are mandatory for all systems. The others are used only by devices that use the indicated protocols or functions.</p></div><div class="sect2" title="MIB Modules"><div class="titlepage"><div><div><h2 class="title"><a id="mib_modules"/>MIB Modules</h2></div></div></div><p><a class="indexterm" id="idx-CHP-66-2404"/>What's most conspicuous about the object groups listed in <a class="xref" href="ch66s04.html#snmp_generic_mib_object_groups" title="Table 66-2. SNMP Generic MIB Object Groups">Table 66-2</a> is the groups that are not included. There are no groups for most of the other TCP/IP protocols, nor any for variables that might be needed for specific hardware types. For example, most hosts will have a network card in them using a layer 2 protocol like Ethernet or Token Ring. How does a manager check or control the operation of this hardware? What about newer routing protocols like Open Shortest Path First (OSPF) or Border Gateway Protocol (BGP)? How about objects related to running the Domain Name System (DNS)?</p><p>Updating the MIB document constantly would have been impractical. Instead, in SNMPv2, the MIB was changed from a single document to a group of documents. The basic organization into groups of objects was retained, but instead of all groups being in the same standard, they are divided into multiple standards. A method was also defined for how to create <span class="emphasis"><em>MIB modules</em></span><a class="indexterm" id="idx-CHP-66-2405"/> that describe new groups of objects specific to a particular technology. A list of these modules is maintained by the <span class="emphasis"><em>Internet Assigned Numbers Authority</em></span> (IANA), the organization that maintains all of these sorts of numbers. The current list of SNMP MIB modules can be found at <a class="ulink" href="http://www.iana.org/assignments/smi-numbers">http://www.iana.org/assignments/smi-numbers</a>.</p><p>The use of MIB modules makes putting SNMP support into a device somewhat like going shopping. The basic groups common to all devices are incorporated into each device, and then other modules/groups are used as needed. <a class="xref" href="ch66s04.html#some_common_snmp_mib_modules" title="Table 66-3. Some Common SNMP MIB Modules">Table 66-3</a> provides a brief selection of MIB modules to give you an idea of what is out there, also showing the module's group number (within the 1.3.6.1.2.1 name subtree). There are many, many more modules than listed in this table.</p><div class="table"><a id="some_common_snmp_mib_modules"/><p class="title">Table 66-3. Some Common SNMP MIB Modules</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Some Common SNMP MIB Modules"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>MIB Module Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Group Number</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ospf</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-bottom: 0.5pt solid ; "><p>Objects related to OSPF</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">bgp</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15</p></td><td style="border-bottom: 0.5pt solid ; "><p>Objects related to BGP</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">rmon</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-bottom: 0.5pt solid ; "><p>Objects used as part of Remote Network Monitoring (RMON)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">snmpDot3 RptrMgt</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>22</p></td><td style="border-bottom: 0.5pt solid ; "><p>Objects related to IEEE 802.3 (Ethernet) repeaters</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">rip-2</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>23</p></td><td style="border-bottom: 0.5pt solid ; "><p>Objects used as part of version 2 of the Routing Information Protocol (RIP)</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">snmpDot3 MauMgt</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>26</p></td><td style="border-bottom: 0.5pt solid ; "><p>Objects related to IEEE 802.3 (Ethernet) medium attachment units</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">etherMIB</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>35</p></td><td style="border-bottom: 0.5pt solid ; "><p>Ethernet-like generic objects</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">mipMIB</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>44</p></td><td style="border-bottom: 0.5pt solid ; "><p>Mobile IP objects</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ipMIB</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>48</p></td><td style="border-bottom: 0.5pt solid ; "><p>IP objects for SNMPv2</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">tcpMIB</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>49</p></td><td style="border-bottom: 0.5pt solid ; "><p>TCP objects for SNMPv2</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">udpMIB</code></p></td><td style="border-right: 0.5pt solid ; "><p>50</p></td><td style=""><p>UDP objects for SNMPv2</p></td></tr></tbody></table></div></div><p>The last three entries in <a class="xref" href="ch66s04.html#some_common_snmp_mib_modules" title="Table 66-3. Some Common SNMP MIB Modules">Table 66-3</a> might seem a bit confusing, since there were already groups for IP, TCP, and UDP, as shown in <a class="xref" href="ch66s04.html#snmp_generic_mib_object_groups" title="Table 66-2. SNMP Generic MIB Object Groups">Table 66-2</a>. The reason for these is that when the new modular architecture for MIB objects was created in SNMPv2, the definition of objects for the individual protocols that was part of the one document in SNMPv1 was separated out into individual MIB documents for consistency and to allow them to be updated independently. In fact, the base SNMPv2 and SNMPv3 MIB documents now define only objects in the <code class="literal">system</code> and <code class="literal">snmp</code> groups.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-400"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> MIB objects created early in SNMP's history were organized into <span class="emphasis"><em>MIB object groups</em></span> that reside within the mib(1) subtree, starting with identifier code 1.3.6.1.2.1. As the popularity of TCP/IP grew, it became impractical to centrally define all MIB objects, so sets of objects particular to different hardware devices are now specified in <span class="emphasis"><em>MIB modules</em></span>.</p></div></div><div class="sect2" title="MIB Module Format"><div class="titlepage"><div><div><h2 class="title"><a id="mib_module_format"/>MIB Module Format</h2></div></div></div><p>The format for MIB modules is described in the SMI standard, version 2 (SMIv2). This document specifies how modules are to be defined in a way similar to how objects themselves are defined: by listing a set of characteristics that must be included in each module description. The module fields are as follows:</p><p><span class="strong"><strong>Module Name</strong></span> The name of the module. Remember that modules are really objects, syntactically, so like regular objects, they have a textual object descriptor (like <code class="literal">tcpMIB</code>) and an object identifier (in the case of <code class="literal">tcpMIB</code>, the number 50).</p><p><span class="strong"><strong>Last Updated</strong></span> The date and time that the module was last revised.</p><p><span class="strong"><strong>Organization</strong></span> The name of the organization that is managing the development of the module.</p><p><span class="strong"><strong>Contact Information</strong></span> The name, address, telephone number, and email address of the point person for this module.</p><p><span class="strong"><strong>Description</strong></span> A description of the module.</p><p><span class="strong"><strong>Revision and Revision Description</strong></span> One Revision entry is placed for each revision of the module to show its history. Each entry has a description associated with it.</p><p>After the definition of the module itself, the objects in the module are described. For an example, see RFC 2012, which defines the SNMPv2 TCP MIB.</p></div></div>
<div class="chapter" title="Chapter&#xA0;67.&#xA0;TCP/IP SIMPLE NETWORK MANAGEMENT PROTOCOL (SNMP) CONCEPTS AND OPERATION"><div class="titlepage"><div><div><h1 class="title"><a id="tcp_ip_simple_network_management_protoco"/>Chapter 67. TCP/IP SIMPLE NETWORK MANAGEMENT PROTOCOL (SNMP) CONCEPTS AND OPERATION</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e71776"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> The overall network management solution for TCP/IP networks is the Internet Standard Management Framework. In the previous two chapters, we have taken a look at the Framework as a whole, and also discussed the two components that define the management information transmitted between TCP/IP devices to accomplish network management. The third major part of the <a class="indexterm" id="idx-CHP-67-2406"/>SNMP Framework is the actual <span class="emphasis"><em>Simple Network Management Protocol (SNMP)</em></span><a class="indexterm" id="idx-CHP-67-2407"/>, which is responsible for moving management information between devices.</p><p>The core of the protocol consists of a set of <span class="emphasis"><em>protocol operations</em></span> that allow management information to be exchanged between SNMP agents and managers. Having previously examined the generalities of SNMP and what management information base (MIB) objects are, we can now get down to the nitty gritty of how management information is actually communicated using SNMP.</p><p>In this chapter, I provide a detailed description of the operations performed by the <a class="indexterm" id="idx-CHP-67-2408"/>SNMP protocol. I begin with a brief overview and history of the protocol. I then provide a general description of how SNMP operates and the two basic methods that devices use to communicate. I also describe SNMP's message classes and the basic operations performed in SNMP: basic request/response, table traversal, object modification, and notification. I conclude with a discussion of SNMP security issues and a summary of the security methods in each of the SNMP versions.</p><div class="note" title="Note"><h3 class="title"><a id="note-152"/>Note</h3><p><span class="emphasis"><em>The number and types of protocol operations in SNMP changed between SNMPv1 and SNMPv2. The operations defined in SNMPv2 have been carried forward into the newest version, SNMPv3. Most of the discussion focuses on SNMPv3 as the newest implementation, noting the differences between it and the original and still widely used SNMPv1</em></span>.</p></div><div class="sect1" title="SNMP Protocol Overview"><div class="titlepage"><div><div><h1 class="title"><a id="snmp_protocol_overview"/>SNMP Protocol Overview</h1></div></div></div><p>As explained in the previous chapters, the SNMP Framework is often described as being <span class="emphasis"><em>information-oriented</em></span>. A specific decision was made in the design of the SNMP Framework to decouple the management information conveyed between SNMP agents and SNMP managers from the protocol used to carry that information. This provides numerous benefits to the technology as a whole, chief among them flexibility and modularity.</p><p>In this model, the operation of the management protocol is <span class="emphasis"><em>not</em></span> defined in terms of specific commands made to check the status of a device or change how it operates. Instead, the protocol is defined in terms of management information variables called <span class="emphasis"><em>objects</em></span>, and a communication protocol that allows these objects to be either examined or changed by a network administrator. I describe this concept thoroughly in the previous chapter.</p><p>The MIB and Structure of Management Information (SMI) spell out the rules for how MIB objects are created and described. These MIB objects describe the types of information that can be read from the device or written to the device. The last piece of the puzzle is the actual protocol that is responsible for these read- and write-type operations. This is SNMP itself, which I give the somewhat redundant name <span class="emphasis"><em>SNMP protocol</em></span> to differentiate it from the SNMP Framework.</p><p>The result of the separation of the protocol from the management information it carries is that the protocol itself becomes significantly reduced in complexity. Instead of the SNMP protocol needing to define dozens or even hundreds of operations that specify particular network management functions, it needs to deal with only the transmission of MIB object information between SNMP agents and managers. The SNMP protocol itself does not pay attention to what is in these objects; it is merely concerned with moving them around. In some ways, the SNMP protocol is the only really simple part of SNMP!</p><div class="sect2" title="Early Development of SNMPv1"><div class="titlepage"><div><div><h2 class="title"><a id="early_development_of_snmpv1"/>Early Development of SNMPv1</h2></div></div></div><p>The history of the SNMP protocol goes back to the predecessor of the SNMP Framework, the <a class="indexterm" id="idx-CHP-67-2409"/><span class="emphasis"><em>Simple Gateway Monitoring Protocol (SGMP)</em></span><a class="indexterm" id="idx-CHP-67-2410"/>, which was defined in RFC 1028 in 1987. SGMP was designed as an interim solution for network management while larger issues were being explored, as I explained in <a class="xref" href="ch65.html" title="Chapter 65. TCP/IP INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW">Chapter 65</a>. However, this standard is where many of the basic design concepts underlying the modern SNMP protocol can be found.</p><p>The SGMP standard specified the basic design model used in SNMP by describing SGMP in terms of only retrievals of, or alterations to, variables stored on an Internet gateway (router). The standard also outlines the small number of protocol operations that are still the basis for SNMP's operation today.</p><p>The first version of the SNMP Framework, SNMPv1, included the first formal definition of the SNMP protocol in RFC 1067 (later revised by RFCs 1098 and 1157). This standard refines the protocol operations given in the SGMP document. It makes the operation of the SNMP protocol fit into the overall SNMP Framework, working with formally defined MIB objects.</p></div><div class="sect2" title="SNMPv2 and the Division of SNMP into Protocol Operations and Transport Mappings"><div class="titlepage"><div><div><h2 class="title"><a id="snmpv2_and_the_division_of_snmp_into_pro"/>SNMPv2 and the Division of SNMP into Protocol Operations and Transport Mappings</h2></div></div></div><p><a class="indexterm" id="idx-CHP-67-2411"/>When SNMPv2 was created, the single document describing the SNMP protocol was split into two standards, to make the protocol more modular and better reflective of the layers used in internetworks:</p><p><span class="strong"><strong>Protocol Operations</strong></span> The first document of the pair describes the actual mechanics by which MIB objects are moved between SNMP devices using particular SNMP message types. In SNMPv3, it is RFC 3416, "Version 2 of the Protocol Operations for the Simple Network Management Protocol (SNMP)." When people talk about just "the SNMP standard," this is the document they usually mean.</p><p><span class="strong"><strong>Transport Mappings</strong></span> The second document details how the SNMP protocol operations described in the first standard can be transported over a variety of different protocol suites. By using the correct mapping, SNMP operations can be carried out using lower-layer technologies other than the Internet Protocol (IP). This standard is represented in SNMPv3 by RFC 3417, "Transport Mappings for the Simple Network Management Protocol (SNMP)."</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-401"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The actual mechanism used to communicate management information between network management stations (NMSs) and managed devices is called the <span class="emphasis"><em>Simple Network Management Protocol</em></span>, which may be called the <span class="emphasis"><em>SNMP protocol</em></span> to differentiate it from the SNMP Framework. It consists of a number of <span class="emphasis"><em>protocol operations</em></span> that describe the actual message exchanges that take place between devices, and a set of <span class="emphasis"><em>transport mappings</em></span> that define how these messages are carried over various types of internetworks. The Internet Protocol (IP) is the most common transport mapping used for SNMP.</p></div><p>I discuss transport mappings in a little more detail in the description of SNMP messaging later in this chapter, but since the IP/User Datagram Protocol (UDP) method is by far the most common transport mechanism, there isn't a great deal to say about that aspect of the SNMP protocol.</p></div><div class="sect2" title="SNMP Communication Methods"><div class="titlepage"><div><div><h2 class="title"><a id="snmp_communication_methods"/>SNMP Communication Methods</h2></div></div></div><p>For SNMP to be useful in enabling the management of a network, it must allow a network administrator using a network management station (NMS) to easily check the status of SNMP agents in managed devices. In data <a class="indexterm" id="idx-CHP-67-2412"/>communications, there are two general techniques that are used in a situation where one entity needs to be kept informed about activity or occurrences on another:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-67-2413"/>Poll-Driven Communication</strong></span>  This term refers to the general technique of having the one who wants the information ask for it—just like someone might conduct a political poll. In SNMP, the NMS would poll SNMP agents for information. A common real-life example of polling is the model used by the regular mail service; every day you go to check your mailbox to see if you have any mail.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-67-2414"/>Interrupt-Driven Communication</strong></span>  This term refers to having a device with information that another needs to know decide to send the information of its own volition. In SNMP, this would refer to an SNMP agent sending information to an NMS without being asked. This is the model used by that most famous of interrupters—the telephone.</p><p>Which communication method is better? The usual answer applies here: Neither is better or worse universally, which is why both options exist. Due to the obvious strengths and weaknesses of these models, the SNMP protocol is designed to use both. Polling is used for the periodic gathering of routine information, such as checking the usage statistics and general status of a device. Interrupts are used in the form of <span class="emphasis"><em>traps</em></span> that a network administrator can set on a managed device. These traps cause an SNMP agent to interrupt an NMS when an event of importance occurs.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-402"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> SNMP uses two basic methods for exchanging management information. Routine communication uses a <span class="emphasis"><em>poll-driven</em></span> technique, where the network management station (NMS) requests information from managed nodes. An <span class="emphasis"><em>interrupt-driven</em></span> model is also supported. In situations where a managed device needs to tell an NMS about an occurrence immediately, it can send a <span class="emphasis"><em>trap</em></span> message without waiting for a request from the NMS.</p></div><p>The focus of most of our look at SNMP in this chapter will concentrate on SNMP protocol <a class="indexterm" id="idx-CHP-67-2415"/>operations: what messages are used, how they are structured, and how they are exchanged. In examining these messages, we will see the two main ways that information exchanges occur in SNMP—by polling and by interrupt—and also discover how the SNMP protocol works with MIB objects.</p></div></div></div>
<div class="sect1" title="SNMP Protocol Operations"><div class="titlepage"><div><div><h1 class="title"><a id="snmp_protocol_operations"/>SNMP Protocol Operations</h1></div></div></div><p><a class="indexterm" id="idx-CHP-67-2416"/>The actual communication of information in the SNMP protocol is performed in a manner similar to most other protocols, through the exchange of SNMP messages. These messages are sometimes called <span class="emphasis"><em>protocol data units</em></span> or <span class="emphasis"><em>PDUs</em></span>. This is a term you may have heard used in other protocols, and it is part of the formal definition of data encapsulation in the OSI Reference Model, as explained in <a class="xref" href="ch05.html" title="Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND CONCEPTS">Chapter 5</a>. A message is, of course, a data unit used by the protocol. SNMP messages all have <span class="emphasis"><em>-PDU</em></span> at the ends of their names to identify them.</p><p>Some consider <span class="emphasis"><em>protocol data unit</em></span> to be analogous to the military using oblong, metallic-headed, manually operated, fastener-acceleration device to refer to a hammer. To be fair though, strictly speaking, in SNMP, a PDU and a message are not exactly the same. The PDU is the higher-layer data that SNMP encapsulates, as described by the OSI model. The SNMP message format is a <span class="emphasis"><em>wrapper</em></span> that encapsulates a PDU along with header fields, as I describe in the next chapter on SNMP messaging. However, the point of a message is to send a PDU, so the two are close enough, and the terms are sometimes used interchangeably.</p><div class="sect2" title="SNMP PDU Classes"><div class="titlepage"><div><div><h2 class="title"><a id="snmp_pdu_classes"/>SNMP PDU Classes</h2></div></div></div><p><a class="indexterm" id="idx-CHP-67-2417"/><a class="indexterm" id="idx-CHP-67-2418"/>SNMPv1 originally defined six <a class="indexterm" id="idx-CHP-67-2419"/>PDUs. The number of PDUs was expanded, and some changes were made to their names and uses in SNMPv2 and SNMPv3. The current SNMP Framework categorizes the PDUs into different <a class="indexterm" id="idx-CHP-67-2420"/><span class="emphasis"><em>classes</em></span>. These classes describe both the function of each message type and the kind of communication they use to perform their task (polling versus interrupting).</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-403"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> SNMP messages consist of a set of fields wrapped around a data element called a <span class="emphasis"><em>protocol data unit</em></span> or <span class="emphasis"><em>PDU</em></span>. In some cases, the terms message and PDU are used interchangeably, although they are technically not the same. SNMP PDUs are arranged into <span class="emphasis"><em>classes</em></span> based on their function.</p></div><p><a class="xref" href="ch67s02.html#snmp_pdu_message_classes" title="Table 67-1. SNMP PDU (Message) Classes">Table 67-1</a> lists the main SNMPv2/SNMPv3 PDU classes, describes them, and shows which PDUs are in each class in SNMPv2/SNMPv3. These classes were not used in SNMPv1, but for clarity, I also show which messages from SNMPv1 fall into the classes conceptually.</p><div class="table"><a id="snmp_pdu_message_classes"/><p class="title">Table 67-1. SNMP PDU (Message) Classes</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMP PDU (Message) Classes"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>SNMPv3 PDU Class</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></th><th style="border-bottom: 0.5pt solid ; "><p>SNMPv1 PDUs</p></th><th style="border-bottom: 0.5pt solid ; "><p>SNMPv2/SNMPv3 PDUs</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Read</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Messages that read management information from a managed device using a polling mechanism.</p></td><td style="border-bottom: 0.5pt solid ; "><p>GetRequest-PDU, GetNextRequest-PDU</p></td><td style="border-bottom: 0.5pt solid ; "><p>GetRequest-PDU, GetNextRequest-PDU, GetBulkRequest-PDU</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Write</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Messages that change management information on a managed device to affect the device's operation.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>SetRequest-PDU</p></td><td style="border-bottom: 0.5pt solid ; "><p>SetRequest-PDU</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Response</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Messages sent in response to a previous request.</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>GetResponse-PDU</p></td><td style="border-bottom: 0.5pt solid ; "><p>Response-PDU</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Notification</p></td><td style="border-right: 0.5pt solid ; "><p>Messages used by a device to send an interrupt-like notification to an SNMP manager.</p></td><td style="border-right: 0.5pt solid ; "><p>Trap-PDU</p></td><td style=""><p>Trapv2-PDU, InformRequest-PDU</p></td></tr></tbody></table></div></div><p>The GetBulkRequest-PDU and InformRequest-PDU messages are new in SNMPv2/v3. The GetResponse-PDU message was renamed Response-PDU (since it is a response and not a message that gets anything), and the new Trapv2-PDU replaces Trap-PDU.</p><p>There are three other special classes defined by the current SNMP Framework that are of less interest to us because they don't define actively used messages, but which I should mention for completeness. The Internal class contains a special message called Report-PDU defined for internal SNMP communication. The SNMP standards also provide two classes called Confirmed and Unconfirmed, which are used to categorize the messages listed in <a class="xref" href="ch67s02.html#snmp_pdu_message_classes" title="Table 67-1. SNMP PDU (Message) Classes">Table 67-1</a> based on whether or not they are acknowledged. The Report-PDU, Trapv2-PDU, and Response-PDU messages are considered Unconfirmed, and the rest are Confirmed.</p><p>Now we will look at how the major message types in the four main classes are used. Note that in general terms, all protocol exchanges in SNMP are described in terms of one SNMP entity sending messages to another. Most commonly, the entity sending requests is an SNMP manager, and the one responding is an SNMP agent, except for traps, which are sent by agents. For greater clarity, I try to use these more specific terms (<span class="emphasis"><em>manager</em></span> or <span class="emphasis"><em>agent</em></span>) when possible, rather than just <span class="emphasis"><em>entity</em></span>.</p></div><div class="sect2" title="Basic Request/Response Information Poll Using GetRequest and (Get)Response Messages"><div class="titlepage"><div><div><h2 class="title"><a id="basic_requestresponse_information_poll_u"/>Basic Request/Response Information Poll Using GetRequest and (Get)Response Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-67-2421"/>The obvious place to begin our detailed look at SNMP protocol operations is with the simplest type of information exchange. This would be a simple <span class="emphasis"><em>poll</em></span> operation to read one or more management information variables, used by one SNMP entity (typically an SNMP manager) to request or read information from another entity (normally an SNMP agent on a managed device). SNMP implements this as a simple, two-message request/response protocol exchange, similar to the request/reply processes found in so many TCP/IP protocols.</p><p>This information request process typically begins with the user of an application wanting to check the status of a device or look at information about it. As we've seen, all this information is stored on the device in the form of MIB objects. The communication, therefore, takes the form of a request for particular MIB objects and a reply from the device containing those objects' values. In simplified form, the steps in the process are as follows (see <a class="xref" href="ch67s02.html#snmp_information_poll_process_the_basic_" title="Figure 67-1. SNMP information poll process The basic SNMP information polling process involves a simple exchange of a GetRequest-PDU sent by an SNMP manager and a Response-PDU returned by an SNMP agent.">Figure 67-1</a>):</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>SNMP Manager Creates GetRequest-PDU</strong></span> Based on the information required by the application and user, the SNMP software on the NMS creates a GetRequest-PDU message. It contains the names of the MIB objects whose values the application wants to retrieve.</p></li><li class="listitem"><p><span class="strong"><strong>SNMP Manager Sends GetRequest-PDU</strong></span> The SNMP manager sends the PDU to the device that is being polled.</p></li><li class="listitem"><p><span class="strong"><strong>SNMP Agent Receives and Processes GetRequest-PDU</strong></span> The SNMP agent receives and processes the request. It looks at the list of MIB object names contained in the message and checks to see if they are valid (ones the agent actually implements). It looks up the value of each variable that was correctly specified.</p></li><li class="listitem"><p><span class="strong"><strong>SNMP Agent Creates Response-PDU</strong></span> The agent creates a Response-PDU to send back to the SNMP manager. This message contains the values of the MIB objects requested and/or error codes to indicate any problems with the request, such as an invalid object name.</p></li><li class="listitem"><p><span class="strong"><strong>SNMP Agent Sends Response-PDU</strong></span> The agent sends the response back to the SNMP manager.</p></li><li class="listitem"><p><span class="strong"><strong>SNMP Manager Processes Response-PDU</strong></span> The manager processes the information in the Response-PDU received from the agent.</p></li></ol></div><div class="figure"><a id="snmp_information_poll_process_the_basic_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e72162"/><img alt="SNMP information poll process The basic SNMP information polling process involves a simple exchange of a GetRequest-PDU sent by an SNMP manager and a Response-PDU returned by an SNMP agent." src="httpatomoreillycomsourcenostarchimages288233.png.jpg"/></div></div><p class="title">Figure 67-1. SNMP information poll process The basic SNMP information polling process involves a simple exchange of a GetRequest-PDU sent by an SNMP manager and a Response-PDU returned by an SNMP agent.</p></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-404"/>Tip</h3><p><a class="indexterm" id="idx-CHP-67-2422"/><span class="strong"><strong>KEY CONCEPT</strong></span> The most basic type of communication in SNMP is an <span class="emphasis"><em>information poll</em></span>, which allows an NMS to read one or more MIB objects from a managed node using a simple request/reply message exchange.</p></div><p>The Response-PDU message is called GetResponse-PDU in SNMPv1. Presumably, this name was chosen based on the fact that it was a response to a get operation, to make the names GetRequest-PDU and GetResponse-PDU somewhat symmetric. The problem is that this name is confusing, for two reasons. First, it sounds to some people like the purpose of the PDU is to "get a response." Second, the GetResponse-PDU was also defined as the response message for operations other than get operations, including the reply message for SetRequest-PDU. Having a GetResponse message be sent in reply to a SetRequest message is disconcerting. The new name is more generic and avoids these problems.</p></div><div class="sect2" title="Table Traversal Using GetNextRequest and GetBulkRequest Messages"><div class="titlepage"><div><div><h2 class="title"><a id="table_traversal_using_getnextrequest_and"/>Table Traversal Using GetNextRequest and GetBulkRequest Messages</h2></div></div></div><p>The GetRequest-PDU message is used by applications to request values for regular, single variables in an SNMP managed object's MIB. As I mentioned in <a class="xref" href="ch66.html" title="Chapter 66. TCP/IP STRUCTURE OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT INFORMATION BASES (MIBS)">Chapter 66</a>, however, the SMI also allows an MIB to contain <span class="emphasis"><em>tabular data</em></span>.</p><p>MIB tables are a useful way for a device to store and organize a set of related data items. It would be far from ideal to try to structure these items just as collections of regular objects. For example, a device may have multiple IP addresses. It would be inefficient to define one MIB object called ipAddr1, another called ipAddr2, and so on to store IP address information. Instead, an object called ipAddrTable is defined in the original SNMPv1 MIB, which specifies a table containing one or more entries called ipAddrEntry. Each entry contains the IP address and subnet mask for one of the interfaces of the device.</p><div class="sect3" title="SNMPv1 Table Traversal Using GetNextRequest"><div class="titlepage"><div><div><h3 class="title"><a id="snmpv1_table_traversal_using_getnextrequ"/>SNMPv1 Table Traversal Using GetNextRequest</h3></div></div></div><p><a class="indexterm" id="idx-CHP-67-2423"/>There needs to be a way to let an SNMP manager read the contents of these tables from a device. This can be done using the regular GetRequest-PDU message, by specifying each entry in the table, one after the other. However, this is somewhat crude, and it leaves a problem: the SNMP manager may not know how many entries are in the table, and therefore, how many entries it should request.</p><p>The problem of <a class="indexterm" id="idx-CHP-67-2424"/><span class="emphasis"><em>table traversal</em></span> was addressed in SNMPv1 through the creation of a new message type called GetNextRequest-PDU. You can think of this as a relative of the regular GetRequest-PDU. The GetNextRequest-PDU contains the name of a tabular variable, as well as a particular entry in the table. The device receiving the GetNextRequest-PDU uses this to look up the next value in the table and return it in a GetResponse-PDU message.</p><p>The actual protocol exchange is about the same as that described in the previous section: a request is sent by the SNMP manager, and a reply is returned by the SNMP agent. The difference is that instead of the SNMP agent returning the value for the variable specified, it returns the value of the <span class="emphasis"><em>next</em></span> variable in the table. This is then used as the value for the next request, and so on, until the last entry in the table is reached. Once this happens and a GetNextRequest-PDU is sent that contains this last entry, the responding device indicates this by returning the MIB object that conceptually follows the table in the implementation of the MIB. This signals to the SNMP manager that the table has been fully traversed.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-405"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The SNMP GetNextRequest-PDU message allows an NMS to request a series of consecutive variables in an MIB. This is most commonly used to allow tabular data to be more easily retrieved, without requiring that each variable in the table be individually specified.</p></div></div><div class="sect3" title="SNMPv2/v3 Table Traversal Using GetBulkRequest"><div class="titlepage"><div><div><h3 class="title"><a id="snmpv2v3_table_traversal_using_getbulkre"/>SNMPv2/v3 Table Traversal Using GetBulkRequest</h3></div></div></div><p>The GetNextRequest-PDU message is functional, but while it is more elegant than using regular GetRequest-PDU messages, it is not any more efficient—each entry in the table must still be requested one at a time. This means that retrieving the information in a table takes a long time and also results in a great deal of traffic being generated, due to the number of requests and replies that must be sent.</p><p>To make table traversal easier and more conservative in its use of network resources, SNMPv2 introduced a new message type called GetBulkRequest-PDU. You can probably surmise the idea here from the name. Instead of specifying a particular MIB object to get or to get next, a GetBulkRequest-PDU allows an SNMP manager to send a single request that results in a number of entries in a table being returned in a Response-PDU message.</p><p>The GetBulkRequest-PDU is designed to allow both regular variables and tables to be retrieved in a single request. The PDU includes a list of objects, just as in a GetRequest-PDU or GetNextRequest-PDU. The list is organized so that regular objects appear first and table objects come afterwards. Two special parameters are included in the request:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-67-2425"/>Non Repeaters</strong></span> Specifies the number of nonrepeating, regular objects to be retrieved. This is the number of regular objects at the start of the object list.</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-67-2426"/>Max Repetitions</strong></span> Specifies the number of iterations, or entries, to read for the remaining tabular objects.</p><p>For example, suppose an SNMP manager wanted to request four regular variables and three entries from a table. The GetNextRequest-PDU would contain five MIB object specifications, with the table last. The Non Repeaters field would be set to 4, and the Max Repetitions field set to 3.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-406"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> To improve the efficiency of table traversal, SNMPv2 introduced the GetBulkRequest-PDU message, which allows an NMS to request a sequence of MIB objects from a table using a single request to a managed node.</p></div><p>The original method of traversing tables using GetRequest-PDU and GetNextRequest-PDU from SNMPv1 was retained in SNMPv2 and SNMPv3 when they were developed. However, the introduction of the more efficient GetBulkRequest-PDU means that GetNextRequest-PDU is not as important as it was in SNMPv1. Bear in mind, however, that using GetBulkRequest-PDU does require that the requesting entity know how many entries to ask for. So, some trial and error, or multiple requests, may be required to get a whole table if the number of entries is not known.</p></div></div><div class="sect2" title="Object Modification Using SetRequest Messages"><div class="titlepage"><div><div><h2 class="title"><a id="object_modification_using_setrequest_mes"/>Object Modification Using SetRequest Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-67-2427"/><a class="indexterm" id="idx-CHP-67-2428"/>The GetRequest-PDU, GetNextRequest-PDU, and GetBulkRequest-PDU messages are the three members of the SNMP Read class of PDUs—they are used to let an SNMP manager read MIB objects from an SNMP agent. The opposite function is represented by the SNMP Write class, which contains a single member: the SNMP SetRequest-PDU message.</p><p>The use of this PDU is fairly obvious; where one of the three Get PDUs specifies a variable whose value is to be retrieved, the SetRequest-PDU message contains a specification for variables whose values are to be modified by the network administrator. Remember that SNMP does not include specific commands to let a network administrator control a managed device. This is the <span class="emphasis"><em>control</em></span> method, which works by setting variables that affect the operation of the managed device.</p><p>The set process is the complement of the get process, using the same basic idea, but a reversal in how the object values travel and what is done with them. The process follows these steps (see <a class="xref" href="ch67s02.html#snmp_object_modification_process_the_com" title="Figure 67-2. SNMP object modification process The communication process for setting a MIB object value is very similar to that used for reading one. The main difference is that the object values are sent from the SNMP manager to the SNMP agent, carried in the SetRequest-PDU message.">Figure 67-2</a>):</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><span class="strong"><strong>SNMP Manager Creates SetRequest-PDU</strong></span> Based on the information changes specified by the user through the SNMP application, the SNMP software on the NMS creates a SetRequest-PDU message. It contains a set of MIB object names and the values to which they are to be set.</p></li><li class="listitem"><p><span class="strong"><strong>SNMP Manager Sends SetRequest-PDU</strong></span> The SNMP manager sends the PDU to the device being controlled.</p></li><li class="listitem"><p><span class="strong"><strong>SNMP Agent Receives and Processes SetRequest-PDU</strong></span> The SNMP agent receives and processes the set request. It examines each object in the request, along with the value to which the object is to be set, and determines if the request should or should not be honored.</p></li><li class="listitem"><p><span class="strong"><strong>SNMP Agent Makes Changes and Creates Response-PDU</strong></span> Assuming that the information in the request was correct (and any security provisions have been satisfied), the SNMP agent makes changes to its internal variables. The agent creates a Response-PDU to send back to the SNMP manager, which either indicates that the request succeeded or contains error codes to indicate any problems with the request found during processing.</p></li><li class="listitem"><p><span class="strong"><strong>SNMP Agent Sends Response-PDU</strong></span> The agent sends the response back to the SNMP manager.</p></li><li class="listitem"><p><span class="strong"><strong>SNMP Manager Processes Response-PDU</strong></span> The manager processes the information in the Response-PDU to see the results of the set.</p></li></ol></div><div class="figure"><a id="snmp_object_modification_process_the_com"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e72310"/><img alt="SNMP object modification process The communication process for setting a MIB object value is very similar to that used for reading one. The main difference is that the object values are sent from the SNMP manager to the SNMP agent, carried in the SetRequest-PDU message." src="httpatomoreillycomsourcenostarchimages288235.png.jpg"/></div></div><p class="title">Figure 67-2. SNMP object modification process The communication process for setting a MIB object value is very similar to that used for reading one. The main difference is that the object values are sent from the SNMP manager to the SNMP agent, carried in the SetRequest-PDU message.</p></div><p><a class="indexterm" id="idx-CHP-67-2429"/>Obviously, telling a device to change a variable's value is a more significant request than just asking the device to read the value. For this reason, the managed device must very carefully analyze and verify the information in the request to ensure that the request is valid. The checks performed include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Verifying the names of the objects to be changed</p></li><li class="listitem"><p>Verifying that the objects are allowed to be modified (based on their Access or Max-Access object characteristic, as described in <a class="xref" href="ch66.html" title="Chapter 66. TCP/IP STRUCTURE OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT INFORMATION BASES (MIBS)">Chapter 66</a>)</p></li><li class="listitem"><p>Checking the value included in the request to ensure that its type and size are valid for the object to be changed</p></li></ul></div><p>This is also a place where general protocol security issues become more important, as I'll discuss near the end of this chapter.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-407"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> SNMP NMSs control the operation of managed devices by changing MIB objects on those devices. This is done using the SetRequest-PDU message, which specifies the objects to be modified and their values.</p></div></div><div class="sect2" title="Information Notification Using Trap and InformRequest Messages"><div class="titlepage"><div><div><h2 class="title"><a id="information_notification_using_trap_and_"/>Information Notification Using Trap and InformRequest Messages</h2></div></div></div><p><a class="indexterm" id="idx-CHP-67-2430"/>Earlier in this chapter, I introduced the two basic methods of communicating information between SNMP devices: using polls or interrupts. All of the message types and exchanges we have examined thus far in this section have been poll-driven. They consist of an SNMP manager making a specific request that results in action being taken, and a response being generated by an SNMP agent.</p><p>Polling is ideal for the exchange of routine information that needs to be gathered on a regular basis. For example, the regular get requests could be used to verify the settings on a device, examine error counts over a period of time, or check its uptime or use statistics. And, obviously, polling is the only real method for performing a set operation, where data is changed.</p><p>But polling is not well suited for important information that needs to be communicated quickly. The reason is that poll-driven communication is always initiated by the recipient of the information: the SNMP manager. If something significant occurs on a managed device that the manager wasn't expecting, the manager won't find out about it unless it specifically asks to see the variable that has changed. This means that important variables would need to be checked all the time by the SNMP manager, which is highly efficient.</p><p>In the real world, using polling to implement situations where critical information needs to be sent would be like having the emergency response service in your town call everyone every hour to find out if they needed an ambulance or fire truck. Similarly, in SNMP, a mechanism was needed to let an SNMP agent initiate the communication of information. This capability was originally made part of the SNMPv1 protocol through the inclusion of the Trap-PDU message type.</p><p>In computer science, a <span class="emphasis"><em>trap</em></span> is simply a set of conditions that a device monitors continuously. If the appropriate conditions occur, the trap is <span class="emphasis"><em>triggered</em></span> and causes some sort of action to be taken. In SNMP, traps are programmed into SNMP agents, and when they are triggered, an SNMP Trap-PDU message is sent to an SNMP manager to inform it of the occurrence. Examples of traps in the SNMPv1 specification include ones that trigger in the event of a communication link failure, restart of the device, or an authentication problem.</p><div class="sect3" title="Use of SNMP Trap and Trapv2 Messages"><div class="titlepage"><div><div><h3 class="title"><a id="use_of_snmp_trap_and_trapv2_messages"/>Use of SNMP Trap and Trapv2 Messages</h3></div></div></div><p><a class="indexterm" id="idx-CHP-67-2431"/>The communication in the case of a trap is trivial. The SNMP agent sends the trap, and the SNMP manager is thereby considered informed of what happened. That's pretty much it. These are Unconfirmed messages, and no reply is made back to the <a class="indexterm" id="idx-CHP-67-2432"/>SNMP agent. The triggering of the trap may lead the network administrator to take follow-up action at the device that sent the trap.</p><p>The designer of a particular MIB must determine which traps to create for a particular group of objects. The implementation must specify the conditions under which the traps will trigger and also the destination to which the Trap-PDU message will be sent when this occurs. In SNMPv2, the trap notification message was retained in the form of the Trapv2-PDU message.</p></div><div class="sect3" title="Use of the SNMPv2 InformRequest Message"><div class="titlepage"><div><div><h3 class="title"><a id="use_of_the_snmpv2_informrequest_message"/>Use of the SNMPv2 InformRequest Message</h3></div></div></div><p>SNMPv2 also incorporates a second notification message type: the InformRequest-PDU message. This type of message is not the same as a trap, but it is related to traps for two reasons: Both message types are used to communicate information without the recipient initiating the process, and the two messages are sometimes used in conjunction.</p><p>The purpose of the InformRequest-PDU is actually to facilitate the communication of information between NMSs. The SNMP manager on one NMS can choose to inform another of some piece of information by sending an InformRequest-PDU to that other SNMP manager. The receiving manager then replies back with a Response-PDU to the one that sent the InformRequest-PDU, confirming receipt of the inform message.</p><p>A common way that this message is used is to spread the news when a trap occurs. Suppose a device experiences a power failure, which results in a Trapv2-PDU being sent to NMS 1. The network administrator may want to set up NMS 1 so that receipt of particular traps causes the information in the trap to be forwarded to another NMS. The InformRequest-PDU would be used to carry that information from NMS 1 to, say, NMS 2.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-408"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> SNMP managed devices can inform an NMS of an important occurrence by sending it a Trap-PDU or Trapv2-PDU message. Network administrators determine the circumstances under which one of these messages should be transmitted. SNMPv2 adds to this capability the InformRequest-PDU message, which can be used to propagate information about an event between management stations.</p></div></div></div></div>
<div class="sect1" title="SNMP Protocol Security Issues and Methods"><div class="titlepage"><div><div><h1 class="title"><a id="snmp_protocol_security_issues_and_method"/>SNMP Protocol Security Issues and Methods</h1></div></div></div><p><a class="indexterm" id="idx-CHP-67-2433"/>In my description of the various SNMP versions in <a class="xref" href="ch65.html" title="Chapter 65. TCP/IP INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW">Chapter 65</a>, it's possible that I may have been a bit harsh on those who worked on SNMP during the 1990s. The proliferation of many SNMP version 2 variants really was unfortunate, and not something we often see in the world of TCP/IP. However, now that we've seen the sort of work that SNMP does, the desire for security in the protocol would seem to be clear. Given that, and given the very low level of security in the initial SNMPv1 protocol, it's understandable to some extent why a conflict over security issues arose.</p><p>The need for security in SNMP is obvious because the MIB objects being communicated contain critical information about network devices. We don't want just anyone snooping into our network to find out our IP addresses, how long our machines have been running, whether our links are down, or pretty much anything else. When it comes to object write operations using a SetRequest-PDU, the concerns are magnified even more, because we definitely don't want strangers being able to control or interfere with our managed devices by issuing bogus commands to change MIB objects that control device operation!</p><div class="sect2" title="Problems with SNMPv1 Security"><div class="titlepage"><div><div><h2 class="title"><a id="problems_with_snmpv1_security"/>Problems with SNMPv1 Security</h2></div></div></div><p>Unfortunately, the security incorporated into SNMPv1 was extremely limited. It really took the form of only one policy and one simple technology.</p><p>SNMP was created with the mindset that the MIB objects used in the protocol would be relatively <span class="emphasis"><em>weak</em></span>. This means that the objects are designed so that any problems in working with them result in minimal damage. The policy of the designers of SNMP was that MIB objects that are normally read should not contain critical information, and objects that are written should not control critical functions.</p><p>So, a read-only MIB object containing a description of a machine is fine, but one containing the administrative password is not. Similarly, a read-write MIB object that controls when the computer next reboots is acceptable, but one that tells the object to reformat its hard disk is definitely not!</p><p>All the devices in an SNMP network managed by a particular set of NMSs are considered to be in a <span class="emphasis"><em>community</em></span>. Each SNMPv1 message sent between members of the community is identified by a <span class="emphasis"><em>community string</em></span> that appears in a field in the message header. This string is like a simple password. Any messages received with the wrong string will be rejected by the recipient.</p><p>These security features are better than nothing, but not much. The use of weak objects is comparable to a policy that says not to leave your car in front of the convenience store with the doors unlocked and the key in the ignition—it is basically saying, "Don't ask for trouble." This is wise, but it's not a complete security solution.</p><p>The <a class="indexterm" id="idx-CHP-67-2434"/>community strings protect against obvious tampering in the form of unauthorized messages. However, the strings are sent in plain text, and they can easily be discovered and then used to compromise the community. So, this is like locking your doors when parking your car—it protects against the casual thief but not a pro.</p><p>Of course, for some people, not leaving their car running and locking the doors when they park provide enough security, and SNMPv1's security was also sufficient for some users of SNMP. But in newer, larger internetworks, especially ones spanning large distances or using public carriers, SNMPv1 wasn't up to the task. This is why all that fun stuff occurred with SNMPv2.</p></div><div class="sect2" title="SNMPv2/v3 Security Methods"><div class="titlepage"><div><div><h2 class="title"><a id="snmpv2v3_security_methods"/>SNMPv2/v3 Security Methods</h2></div></div></div><p><a class="indexterm" id="idx-CHP-67-2435"/>During the evolution of SNMPv2 variants, and eventually the creation of SNMPv3, several new security models were created to improve SNMPv1's security:</p><p><span class="strong"><strong><a class="indexterm" id="idx-CHP-67-2436"/>Party-Based Security Model</strong></span>  Party-based security was the model for the original SNMPv2 standard, now called <span class="emphasis"><em>SNMPv2p</em></span>. A logical entity called a <span class="emphasis"><em>party</em></span> is defined for communication that specifies a particular authentication protocol and a privacy (encryption) protocol. The information is used to verify that a particular request is authentic, and to ensure that the sender and receiver agree on how to encrypt and decrypt data.</p><p><span class="strong"><strong>User-Based Security Model (USM)</strong></span> USM was developed in the SNMPv2u variant and used in SNMPv2* (SNMPv2 asterisk). It eventually was adopted in SNMPv3. The idea here is to move away from tying security to the machines and instead use more traditional security based on access rights of a user of a machine. A variety of authentication and encryption protocols can be used to ensure access rights are respected and to protect message privacy. The method relies on timestamps, clock synchronization, and other techniques to protect against certain types of attacks.</p><p><span class="strong"><strong>View-Based Access Control Model (VACM)</strong></span> VACM is part of SNMPv3, and it defines a method where more fine control can be placed on access to objects on a device. A <span class="emphasis"><em>view</em></span> specifies a particular set of MIB objects that can be accessed by a particular group in a particular context. By controlling these views, an administrator can manage what information is accessed by whom.</p><p>Party-based security pretty much died with SNMPv2p. USM and VACM are part of SNMPv3 and provide enhanced security for those who need it. Again, it's interesting to note how many networks continue to use SNMPv1, security warts and all.</p><p>SNMPv3 took another important security-related step in redefining the SNMP architecture to seamlessly support multiple security models. This enables different implementations to choose the security model that is best for them. USM is the default model in SNMPv3.</p></div></div>
<div class="chapter" title="Chapter&#xA0;68.&#xA0;SNMP PROTOCOL MESSAGING AND MESSAGE FORMATS"><div class="titlepage"><div><div><h1 class="title"><a id="snmp_protocol_messaging_and_message_form"/>Chapter 68. SNMP PROTOCOL MESSAGING AND MESSAGE FORMATS</h1></div></div></div><p>
</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject4_d1e72481"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> As we saw extensively in the previous chapter, the communication of management information is accomplished through the exchange of Simple Network Management Protocol (SNMP) messages that contain <span class="emphasis"><em>protocol data units (PDUs)</em></span>. Like the messages of most TCP/IP protocols, these PDUs are designed to use a particular field format, and are created, addressed, and transported according to specific protocol rules. SNMP messages include fields that control the operation of the protocol, and they carry a payload of management information in the form of management information base (MIB) objects.</p><p>In this chapter, I describe the details of how messaging is accomplished in the SNMP protocol. I begin with a general discussion of issues related to message generation, addressing, and transport, and a description of how retransmission of messages is handled when necessary. I discuss the way fields are defined in SNMP messages and describe their general format, explaining the difference between the overall message and the PDU it contains. I then examine the message format used in all of the important SNMP versions, showing the structure of each message type and the fields used.</p><div class="sect1" title="SNMP Protocol Message Generation"><div class="titlepage"><div><div><h1 class="title"><a id="snmp_protocol_message_generation"/>SNMP Protocol Message Generation</h1></div></div></div><p>Message <a class="indexterm" id="idx-CHP-68-2437"/>generation in SNMP is a bit different than the typical TCP/IP client/server model used for most other protocols. There aren't really any formal clients and servers in SNMP, since management information can be obtained from any device; it is distributed. Most of the message exchanges use a matched pair of request and reply messages. The network management station (NMS) usually <span class="emphasis"><em>acts</em></span> as the client in these exchanges, sending a particular get or set request to an SNMP agent, which plays the role of server for the information it contains. However, SNMP agents aren't usually considered servers in the conventional sense.</p><p>SNMP traps deviate from the normal request/reply model of message generation entirely. When a trap is triggered, an SNMP agent sends a trap message to an NMS on its own, not in reaction to receiving a request. Since trap messages are unconfirmed, there is no reply. Note, however, that the SNMP versions 2 and 3 (SNMPv2 and SNMPv3) InformRequest-PDU message (discussed later in this chapter) is confirmed, and a response message is thus sent back to the NMS that generates it.</p></div></div>
<div class="sect1" title="SNMP Transport Mappings"><div class="titlepage"><div><div><h1 class="title"><a id="snmp_transport_mappings"/>SNMP Transport Mappings</h1></div></div></div><p>Once a message has been generated, it is sent using the protocols at the levels below the application layer where SNMP resides. As you saw in the overview of the SNMP protocol in the previous chapter, the current SNMP standard set separates the description of protocol operations and PDUs from the methods used to actually send them.<a class="indexterm" id="idx-CHP-68-2438"/></p><p>Starting with version 2, SNMP has defined several <span class="emphasis"><em>transport mappings</em></span> that describe how SNMP PDUs can be sent over a variety of internetworking protocol suites, including TCP/IP, OSI, IPX/SPX (Novell), and AppleTalk. Many of the specific details of SNMP messaging depend on the transport mapping that is used in a particular implementation. SNMP is primarily used on TCP/IP internetworks, and TCP/IP is where our interest lies here, so the rest of this discussion will deal with transport issues when SNMP is used over the Internet Protocol (IP).<a class="indexterm" id="idx-CHP-68-2439"/></p><p>The standard IP transport mapping for SNMP calls for it to be carried using the User Datagram Protocol (UDP). This decision goes back to the initial implementation of SNMPv1 (before there were distinct transport mappings). UDP was likely chosen because it is more efficient for the simple request/reply messaging scheme SNMP uses. The many Transmission Control Protocol (TCP) features were not considered necessary and add overhead that SNMP's designers wanted to avoid. It is possible that TCP could be used to carry SNMP, defined as a different transport mapping, but I don't believe this is actually done.</p><p>Two well-known UDP port numbers are reserved for SNMP. The first is port 161, which is the general-purpose SNMP number. All devices that are set up to listen for SNMP requests—both agents and managers—listen on port 161. Each device receives any messages sent and replies back to the client, the SNMP entity that issued the request, which uses an ephemeral port number to identify the requesting process. The second UDP port number is 162, which is reserved for <a class="indexterm" id="idx-CHP-68-2440"/>SNMP traps. Having two numbers allows regular messages and traps to be kept separate. Normally, only NMSs would listen on port 162, since agents are not recipients of traps.</p><p>The use of UDP allows SNMP information communication to be streamlined, since there is no need to establish a TCP connection, and since message headers are shorter and processing time slightly reduced. But the use of UDP introduces a couple of issues that SNMP implementations must be concerned with, including message size and lost messages.</p><div class="sect2" title="UDP Message Size Issues"><div class="titlepage"><div><div><h2 class="title"><a id="udp_message_size_issues"/>UDP Message Size Issues</h2></div></div></div><p>The first issue is that of message length. SNMP PDUs can carry many MIB objects, which means they could potentially be rather large. However, UDP is limited in the size of message it can carry (where TCP is not). The standards specify that SNMP entities must accept messages up to at least 484 bytes in size. They also recommend that SNMP implementations be able to accept even larger messages, up to 1,472 bytes, which would correspond to the largest size message that can be encapsulated in an Ethernet frame (1,500 bytes, allowing 20 bytes for the IP header and 8 for the UDP header).</p><p>The use of the GetBulkRequest-PDU message type in SNMPv2 and SNMPv3 requires particular care, since it allows a single request to result in many MIB objects being sent back in a response. The Max Repetitions parameter must be chosen conservatively so the SNMP agent doesn't try to send an enormous message that won't fit.</p></div><div class="sect2" title="Lost Transmission Issues"><div class="titlepage"><div><div><h2 class="title"><a id="lost_transmission_issues"/>Lost Transmission Issues</h2></div></div></div><p>The second issue with UDP is the price we pay for its efficiency and simplicity: a lack of transport features. UDP doesn't guarantee data delivery or handle retransmissions, which means a request or reply could, in theory, be lost in transit. Only the device that initially sends a request can know if there was a problem with transport. It sends the request, and if it receives no reply, it knows either the request or response got lost. This puts the responsibility for retransmission on the device that sends the request message.</p><p>NMSs sending requests to SNMP agents generally use a timer to keep track of how much time has elapsed since a request was sent. If the response doesn't arrive within a certain time interval, the request is sent again. Because of how SNMP works, having a request be received more than once accidentally will normally not cause any problems (a property known as <span class="emphasis"><em>idempotence</em></span>). The NMS does need to employ an algorithm to ensure that it does not generate too many retransmissions and clog the network (especially since congestion might be causing the loss of its messages in the first place).</p><p>Since traps are unconfirmed, there is no way for the intended recipient of a trap PDU to know if did not arrive, nor is there any way for the sender of the trap PDU to know. This is just a weakness in the protocol; the overall reliability of TCP/IP (and the underlying networks) ensures that these messages are not lost very often.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-409"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> SNMP is designed with a separately defined set of <span class="emphasis"><em>protocol operations</em></span> and <span class="emphasis"><em>transport mappings</em></span>, so it can be carried over many different internetworking technologies. The most common of these transport mechanisms is TCP/IP, where SNMP makes use of UDP running over IP, for its efficient and simple communication. The lack of reliability features in UDP means that requests must be tracked by the device sending them and retransmitted if no reply is received. The limited size of UDP messages restricts the amount of <a class="indexterm" id="idx-CHP-68-2441"/>information that can be sent in any SNMP PDU.</p></div></div></div>
<div class="sect1" title="SNMP General Message Format"><div class="titlepage"><div><div><h1 class="title"><a id="snmp_general_message_format"/>SNMP General Message Format</h1></div></div></div><p>To structure its messages for transport, SNMP uses a special field format, like most protocols. What's interesting about SNMP, however, is that its standards do not describe the SNMP message format using a simple list of fields the way most TCP/IP standards do. Instead, SNMP messages are defined using the same data description language (<span class="emphasis"><em>Abstract Syntax Notation 1</em></span> or <span class="emphasis"><em>ASN.1</em></span>) that is used to describe MIB objects.<a class="indexterm" id="idx-CHP-68-2442"/></p><p>The reason for this is that SNMP messages implement the various SNMP protocol operations with the ultimate goal of allowing MIB objects to be conveyed between SNMP entities. These MIB objects become fields within the messages to be sent. The MIB objects carried in SNMP messages are defined using ASN.1 as described in the Structure of Management Information (SMI) standard. So, it makes sense to define SNMP messages and all their fields using the same syntax.</p><p>Since all SNMP fields are defined like MIB objects, they are like objects in that they have certain characteristics. Specifically, each field has a name, and its contents are described using one of the standard SMI data types. So, unlike normal message formats where each field has just a name and a length, an SNMP message format field has a name and a <span class="emphasis"><em>syntax</em></span>, such as Integer, Octet String, or IpAddress. The syntax of the field defines its length and how it is formatted and used.</p><p>Just as regular message formats use integers to represent specific values (for example, the numeric Opcode field in the DNS message header, which indicates the DNS message type), this can be done in SNMP using an enumerated integer type. An example would be the Error Status field, where a range of integer values represents different error conditions.</p><p>The decision to define SNMP messages using ASN.1 allows the message format description to be consistent with how the objects in the format are described, which is nice. Unfortunately, it means that the field formats are very hard to determine from the standards, because they are not described in one place. Instead, the overall message format is defined as a set of components, and those components contain subcomponents that may be defined elsewhere, and so on. In fact, the full message format isn't even defined in one standard; parts are spread across several standards. So, you can't look in one place and see the whole message format. Well, I should say that you can't if you use the standards, but you can if you look here.</p><p>To make things easier for you, I have converted these distributed syntax descriptions into the same tabular field formats I use throughout the rest of this book. I will begin here by describing the general format used for SNMP messages, and in the remainder of the chapter, explore the specific formats used in each version of SNMP.</p><div class="sect2" title="The Difference Between SNMP Messages and PDUs"><div class="titlepage"><div><div><h2 class="title"><a id="the_difference_between_snmp_messages_and"/>The Difference Between SNMP Messages and PDUs</h2></div></div></div><p>To understand SNMP messages, it is important that you first grasp the difference between SNMP messages and SNMP <a class="indexterm" id="idx-CHP-68-2443"/>PDUs. We've seen in looking at SNMP protocol operations that the two terms are often used interchangeably. This is because each message carries one PDU, and the PDU is the most important part of the message.</p><p>However, strictly speaking, an SNMP PDU and an SNMP message are not exactly the same. The PDU is the actual piece of <a class="indexterm" id="idx-CHP-68-2444"/>information that is being communicated between SNMP entities. It is carried within the SNMP message along with a number of header fields, which are used to carry identification and security information. Thus, conceptually, the SNMP message format can be considered to have two overall sections:</p><p><span class="strong"><strong>Message Header</strong></span> Contains fields used to control how the message is processed, including fields for implementing SNMP security.</p><p><span class="strong"><strong>Message Body (PDU)</strong></span> Contains the main portion of the message. In this case, the message body is the PDU being transmitted.</p><p>The overall SNMP message is sometimes called a <span class="emphasis"><em>wrapper</em></span> for the PDU, since it encapsulates the PDU and precedes it with additional fields. The distinction between the PDU and the message format as a whole began as a formality in SNMPv1, but it became quite important in later versions. The reason is that it allows the fields used for basic protocol operations (which are in the PDU) to be kept separate from fields used to implement security features. In SNMPv2, the implementation of security became a very big deal indeed, so this flexibility was quite important.</p></div><div class="sect2" title="General PDU Format"><div class="titlepage"><div><div><h2 class="title"><a id="general_pdu_format"/>General PDU Format</h2></div></div></div><p>The fields in each PDU depend on the PDU type, but can be divided into the following general substructure:</p><p><span class="strong"><strong>PDU Control Fields</strong></span> A set of fields that describe the PDU and communicate information from one SNMP entity to another.</p><p><span class="strong"><strong>PDU Variable Bindings</strong></span> A set of descriptions of the MIB objects in the PDU. Each object is described as a <span class="emphasis"><em>binding</em></span> of a name to a value.</p><p>Each PDU will follow this general structure, which is shown in <a class="xref" href="ch68s03.html#snmp_general_message_format-id001" title="Figure 68-1. SNMP general message format">Figure 68-1</a>, differing only in the number of control fields and variable bindings and how they are used. In theory, each PDU could have a different message format using a distinct set of control fields, but in practice, most PDUs for a given SNMP version use the same control fields (with some exceptions).</p><div class="figure"><a id="snmp_general_message_format-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e72664"/><img alt="SNMP general message format" src="httpatomoreillycomsourcenostarchimages288237.png.jpg"/></div></div><p class="title">Figure 68-1. SNMP general message format</p></div><p>Each variable binding describes one MIB object. The binding consists of a pair of subfields, one specifying the name of the object in standard SNMP object identifier notation and one its value, <a class="indexterm" id="idx-CHP-68-2445"/>formatted to match the object's SMI syntax. For example, if the object were of type Integer, the value field would be four bytes wide and contain a numeric integer value. <a class="xref" href="ch68s03.html#snmp_variable_binding_format" title="Table 68-1. SNMP Variable Binding Format">Table 68-1</a> describes the subfield format for each PDU variable binding.</p><div class="table"><a id="snmp_variable_binding_format"/><p class="title">Table 68-1. SNMP Variable Binding Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMP Variable Binding Format"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Object Name</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence of Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>The numeric object identifier of the MIB object, specified as a sequence of integers. For example, the object <code class="literal">sysLocation</code> has the object identifier 1.3.6.1.2.1.1.6, so it would be specified as 1 3 6 1 2 1 1 6 using ASN.1.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Object Value</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>In any type of get request, this subfield is a placeholder; it is structured using the appropriate syntax for the object but has no value (since the get request is asking for that value!). In a set request (SetRequest-PDU) or in a reply message carrying requested data (GetResponse-PDU or Response-PDU), the value of the object is placed here.</p></td></tr></tbody></table></div></div><div class="tip" title="Tip"><h3 class="title"><a id="tip-410"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> The general format of SNMP messages consists of a <span class="emphasis"><em>message header</em></span> and a <span class="emphasis"><em>message body</em></span>. The body of the message is also called the <span class="emphasis"><em>protocol data unit</em></span>, or <span class="emphasis"><em>PDU</em></span>, and contains a set of PDU <span class="emphasis"><em>control fields</em></span> and a number of <span class="emphasis"><em>variable bindings</em></span>. Each variable binding describes one MIB object and consists of the object's name and value.<a class="indexterm" id="idx-CHP-68-2446"/></p></div></div></div>
<div class="sect1" title="SNMP Version 1 (SNMPv1) Message Format"><div class="titlepage"><div><div><h1 class="title"><a id="snmp_version_1_snmpv1_message_format"/>SNMP Version 1 (SNMPv1) Message Format</h1></div></div></div><p>The SNMP general message format was first used to define the format of messages in the original SNMP protocol, SNMPv1. This first version of SNMP is probably best known for its relative simplicity compared to the versions that followed it. This is reflected in its message format, which is quite straightforward.</p><div class="sect2" title="SNMPv1 General Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="snmpv1_general_message_format"/>SNMPv1 General Message Format</h2></div></div></div><p>The general message format in SNMPv1 is a wrapper consisting of a small header and an encapsulated PDU. Not very many header fields were needed in SNMPv1 because the community-based security method in SNMPv1 is very rudimentary. The overall format for <a class="indexterm" id="idx-CHP-68-2447"/>SNMPv1 messages is described in <a class="xref" href="ch68s04.html#snmp_version__snmpv_general_message_form" title="Table 68-2. SNMP Version 1 (SNMPv1) General Message Format">Table 68-2</a> and illustrated in <a class="xref" href="ch68s04.html#snmpv1_general_message_format-id001" title="Figure 68-2. SNMPv1 general message format">Figure 68-2</a>.</p><div class="table"><a id="snmp_version__snmpv_general_message_form"/><p class="title">Table 68-2. SNMP Version 1 (SNMPv1) General Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMP Version 1 (SNMPv1) General Message Format"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Version</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Version Number: Describes the SNMP version number of this message; used for ensuring compatibility between versions. For SNMPv1, this value is actually 0, not 1.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Community</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Octet String</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Community String: Identifies the SNMP community in which the sender and recipient of this message are located. This is used to implement the simple SNMP community-based security mechanism, described in the previous chapter.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>PDU</p></td><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Protocol Data Unit: The PDU being communicated as the body of the message.</p></td></tr></tbody></table></div></div><div class="figure"><a id="snmpv1_general_message_format-id001"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e72849"/><img alt="SNMPv1 general message format" src="httpatomoreillycomsourcenostarchimages288239.png"/></div></div><p class="title">Figure 68-2. SNMPv1 general message format</p></div></div><div class="sect2" title="SNMPv1 PDU Formats"><div class="titlepage"><div><div><h2 class="title"><a id="snmpv1_pdu_formats"/>SNMPv1 PDU Formats</h2></div></div></div><p>All of the PDUs in SNMPv1 have the same format, with one exception: Trap-PDU. The exact semantics of each field in the PDU depend on the particular message. For example, the ErrorStatus field only has meaning in a reply and not a request, and object values are used differently in requests and replies as well.</p><p><a class="xref" href="ch68s04.html#snmpv_common_pdu_format" title="Table 68-3. SNMPv1 Common PDU Format">Table 68-3</a> shows the common format for most of the <a class="indexterm" id="idx-CHP-68-2448"/>SNMPv1 PDUs: GetRequest-PDU, GetNextRequest-PDU, SetRequest-PDU, and GetResponse-PDU.</p><div class="table"><a id="snmpv_common_pdu_format"/><p class="title">Table 68-3. SNMPv1 Common PDU Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMPv1 Common PDU Format"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>PDU Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer (Enumerated)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>PDU Type: An integer value that indicates the PDU type:</p>
<p>0 = GetRequest-PDU</p>
<p>1 = GetNextRequest-PDU</p>
<p>2 = GetNextRequest-PDU</p>
<p>3 = SetRequest-PDU</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Request Identifier: A number used to match requests with replies. It is generated by the device that sends a request and copied into this field in a GetResponse-PDU by the responding SNMP entity.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Error Status</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer (Enumerated)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Error Status: An integer value that is used in a GetResponse<span class="emphasis"><em>-</em></span>PDU to tell the requesting SNMP entity the result of its request. A value of zero indicates that no error occurred; the other values indicate what sort of error happened, as listed in <a class="xref" href="ch68s04.html#snmpv_error_status_field_values" title="Table 68-4. SNMPv1 Error Status Field Values">Table 68-4</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Error Index</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Error Index: When Error Status is nonzero, this field contains a pointer that specifies which object generated the error. Always zero in a request.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Variable Bindings</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Variable Bindings: A set of name/value pairs identifying the MIB objects in the PDU, and in the case of a SetRequest-PDU or GetResponse-PDU, containing their values. See the discussion of the general SNMP general PDU format earlier in this chapter for more on these bindings.</p></td></tr></tbody></table></div></div><div class="table"><a id="snmpv_error_status_field_values"/><p class="title">Table 68-4. SNMPv1 Error Status Field Values</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMPv1 Error Status Field Values"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Error Status Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Error Code</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>noError</p></td><td style="border-bottom: 0.5pt solid ; "><p>No error occurred. This code is also used in all request PDUs, since they have no error status to report.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>tooBig</p></td><td style="border-bottom: 0.5pt solid ; "><p>The size of the GetResponse-PDU would be too large to transport.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>noSuchName</p></td><td style="border-bottom: 0.5pt solid ; "><p>The name of a requested object was not found.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>badValue</p></td><td style="border-bottom: 0.5pt solid ; "><p>A value in the request didn't match the structure that the recipient of the request had for the object. For example, an object in the request was specified with an incorrect length or type.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>readOnly</p></td><td style="border-bottom: 0.5pt solid ; "><p>An attempt was made to set a variable that has an Access value indicating that it is read-only.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; "><p>genErr</p></td><td style=""><p>An error other than one of the preceding four specific types occurred.</p></td></tr></tbody></table></div></div><div class="figure"><a id="snmpv1_common_pdu_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e73057"/><img alt="SNMPv1 common PDU format" src="httpatomoreillycomsourcenostarchimages288241.png"/></div></div><p class="title">Figure 68-3. SNMPv1 common PDU format</p></div><p><a class="xref" href="ch68s04.html#snmpv_trap-pdu_format" title="Table 68-5. SNMPv1 Trap-PDU Format">Table 68-5</a> describes the special format for the <a class="indexterm" id="idx-CHP-68-2449"/>SNMPv1 Trap-PDU, and it is illustrated in <a class="xref" href="ch68s04.html#snmpv1_trap-pdu_format" title="Figure 68-4. SNMPv1 Trap-PDU format">Figure 68-4</a>.</p><div class="table"><a id="snmpv_trap-pdu_format"/><p class="title">Table 68-5. SNMPv1 Trap-PDU Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMPv1 Trap-PDU Format"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>PDU Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer (Enumerated)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>PDU Type: An integer value that indicates the PDU type, which is 4 for a Trap-PDU message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Enterprise</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence of Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Enterprise: An object identifier for a group, which indicates the type of object that generated the trap.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Agent Addr</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NetworkAddress</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Agent Address: The IP address of the SNMP agent that generated the trap. This is also in the IP header at lower levels but inclusion in the SNMP message format allows for easier trap logging within SNMP. Also, in the case of a multihomed host, this specifies the preferred address.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Generic Trap</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer (Enumerated)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Generic Trap Code: A code value specifying one of a number of predefined generic trap types.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Specific Trap</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Specific Trap Code: A code value indicating an implementation-specific trap type.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Time Stamp</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>TimeTicks</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Time Stamp: The amount of time since the SNMP entity sending this message last initialized or reinitialized. Used to time stamp traps for logging purposes.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Variable Bindings</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Variable Bindings: A set of name/value pairs identifying the MIB objects in the PDU. See the discussion of the general SNMP general PDU format earlier in this chapter for more on these bindings.</p></td></tr></tbody></table></div></div><div class="figure"><a id="snmpv1_trap-pdu_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e73192"/><img alt="SNMPv1 Trap-PDU format" src="httpatomoreillycomsourcenostarchimages288243.png"/></div></div><p class="title">Figure 68-4. SNMPv1 Trap-PDU format</p></div></div></div>
<div class="sect1" title="SNMP Version 2 (SNMPv2) Message Formats"><div class="titlepage"><div><div><h1 class="title"><a id="snmp_version_2_snmpv2_message_formats"/>SNMP Version 2 (SNMPv2) Message Formats</h1></div></div></div><p>After SMNPv1 had been in use for several years, certain issues with it were noticed and areas for improvement identified. This led to the development of the original SNMPv2, which was intended to enhance <a class="indexterm" id="idx-CHP-68-2450"/>SNMPv1 in many areas, including MIB object definitions, protocol operations, and security. This last area, security, led to the proliferation of SNMPv2 version variants that I described in <a class="xref" href="ch65.html" title="Chapter 65. TCP/IP INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW">Chapter 65</a>.<a class="indexterm" id="idx-CHP-68-2451"/></p><p>Since there are several different SNMPv2s, there are also several message formats for SNMPv2. This is confusing, but it would be even worse without the modular nature of SNMP messages coming to the rescue. The protocol operations in SNMPv2 were changed from SNMPv1, which necessitated some modifications to the format of SNMPv2 PDUs. However, the protocol operations are the same for all the SNMPv2 variations. The differences between SNMPv2 variants are in the areas of security implementation. Thus, the result of this is that the PDU format is the same for all the SNMPv2 types, while the overall message format differs for each variant. (This is why the distinction between a PDU and a message is not just an academic one!)</p><p>During the SNMPv2 divergence, four variations were defined: the original SNMPv2 (SNMPv2p), community-based SNMPv2 (SNMPv2c), user-based SNMPv2 (SNMPv2u), and SNMPv2 asterisk (SNMPv2*). Of these, the first three were documented in sets of SNMP RFC standards, as discussed in <a class="xref" href="ch65.html" title="Chapter 65. TCP/IP INTERNET STANDARD MANAGEMENT FRAMEWORK OVERVIEW">Chapter 65</a>; the fourth was not. The structure of the overall message format for each variant is discussed in an administrative or security standard for the variation in question, which makes reference to the shared SNMPv2 standard for the PDU format (RFC 1905).</p><div class="sect2" title="SNMP Version 2 (SNMPv2p) Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="snmp_version_2_snmpv2p_message_format"/>SNMP Version 2 (SNMPv2p) Message Format</h2></div></div></div><p>The party-based security model is quite complex, but the basic messaging in this version is described through the definition of a <span class="emphasis"><em>management communication</em></span>, which describes the source and destination party and makes reference to a <span class="emphasis"><em>context</em></span> for the communication. The overall message format is described in detail in RFC 1445. This information is summarized in <a class="xref" href="ch68s05.html#snmp_version__snmpvp_general_message_for" title="Table 68-6. SNMP Version 2 (SNMPv2p) General Message Format">Table 68-6</a> and shown graphically in <a class="xref" href="ch68s05.html#snmpv2p_general_message_format" title="Figure 68-5. SNMPv2p general message format">Figure 68-5</a>.</p><div class="table"><a id="snmp_version__snmpvp_general_message_for"/><p class="title">Table 68-6. SNMP Version 2 (SNMPv2p) General Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMP Version 2 (SNMPv2p) General Message Format"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Version</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Version Number: Describes the SNMP version number of this message; used for ensuring compatibility between versions. For SNMPv2p, this value is 2.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Dst Party</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence of Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Destination Party: An object identifier that specifies the party that is the intended recipient of the message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Src Party</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence of Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Source Party: An object identifier that specifies the party that is the sender of the message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Context</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Sequence of Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Context: Defines a set of MIB object resources that is accessible by a particular entity.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>PDU</p></td><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>PDU: The protocol data unit of the message.</p></td></tr></tbody></table></div></div><div class="figure"><a id="snmpv2p_general_message_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e73331"/><img alt="SNMPv2p general message format" src="httpatomoreillycomsourcenostarchimages288245.png"/></div></div><p class="title">Figure 68-5. SNMPv2p general message format</p></div></div><div class="sect2" title="Community-Based SNMP Version 2 (SNMPv2c) Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="community-based_snmp_version_2_snmpv2c_m"/>Community-Based SNMP Version 2 (SNMPv2c) Message Format</h2></div></div></div><p>The community-based version of SNMPv2 was intended to keep the new protocol enhancements introduced by SNMPv2p but go back to the simple SNMPv1 security model. As such, the defining document for <a class="indexterm" id="idx-CHP-68-2452"/>SNMPv2c, RFC 1901, specifies that its overall message format is the same as that of SNMPv1, except that the version number is changed. This is shown in <a class="xref" href="ch68s05.html#community-based_snmp_version__snmpvc_gen" title="Table 68-7. Community-Based SNMP Version 2 (SNMPv2c) General Message Format">Table 68-7</a> and illustrated in <a class="xref" href="ch68s05.html#snmpv2c_general_message_format" title="Figure 68-6. SNMPv2c general message format">Figure 68-6</a>.<a class="indexterm" id="idx-CHP-68-2453"/></p><div class="table"><a id="community-based_snmp_version__snmpvc_gen"/><p class="title">Table 68-7. Community-Based SNMP Version 2 (SNMPv2c) General Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Community-Based SNMP Version 2 (SNMPv2c) General Message Format"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Version</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Version Number: Describes the SNMP version number of this message; used for ensuring compatibility between versions. For SNMPv2c, this value is 1.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Community</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Octet String</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Community String: Identifies the SNMP community in which the sender and recipient of this message are located.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>PDU</p></td><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Protocol Data Unit: The PDU being communicated as the body of the message.</p></td></tr></tbody></table></div></div><div class="figure"><a id="snmpv2c_general_message_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e73425"/><img alt="SNMPv2c general message format" src="httpatomoreillycomsourcenostarchimages288247.png"/></div></div><p class="title">Figure 68-6. SNMPv2c general message format</p></div></div><div class="sect2" title="User-Based SNMP Version 2 (SNMPv2u) Message Format"><div class="titlepage"><div><div><h2 class="title"><a id="user-based_snmp_version_2_snmpv2u_messag"/>User-Based SNMP Version 2 (SNMPv2u) Message Format</h2></div></div></div><p>The user-based version of SNMPv2 was defined as an optional security model at the time that SNMPv2c was standardized. RFC 1910 defines the user-based security model and the message format described in <a class="xref" href="ch68s05.html#user-based_snmp_version__snmpvu_general_" title="Table 68-8. User-Based SNMP Version 2 (SNMPv2u) General Message Format">Table 68-8</a> and illustrated in <a class="xref" href="ch68s05.html#snmpv2u_general_message_format" title="Figure 68-7. SNMPv2u general message format">Figure 68-7</a>.<a class="indexterm" id="idx-CHP-68-2454"/></p><div class="table"><a id="user-based_snmp_version__snmpvu_general_"/><p class="title">Table 68-8. User-Based SNMP Version 2 (SNMPv2u) General Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="User-Based SNMP Version 2 (SNMPv2u) General Message Format"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Version</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Version Number: Describes the SNMP version number of this message; used for ensuring compatibility between versions. For <a class="indexterm" id="idx-CHP-68-2455"/>SNMPv2u, this value is 2. Note that this is the same value as used for SNMPv2p.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Parameters</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Octet String</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Parameters: A string of parameters used to implement the user-based security model, which are briefly described in <a class="xref" href="ch68s05.html#snmpvu_parameter_field_subfields" title="Table 68-9. SNMPv2u Parameter Field Subfields">Table 68-9</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>PDU</p></td><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Protocol Data Unit: The PDU being communicated as the body of the message. This may be in either encrypted or unencrypted form.</p></td></tr></tbody></table></div></div><div class="figure"><a id="snmpv2u_general_message_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e73521"/><img alt="SNMPv2u general message format" src="httpatomoreillycomsourcenostarchimages288249.png"/></div></div><p class="title">Figure 68-7. SNMPv2u general message format</p></div><div class="table"><a id="snmpvu_parameter_field_subfields"/><p class="title">Table 68-9. SNMPv2u Parameter Field Subfields</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMPv2u Parameter Field Subfields"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Model</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Model Number: Set to 1 to identify the user-based model.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>QoS</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Quality of Service: Indicates whether authentication and/or privacy (encryption) have been used and whether generation of a Report-PDU is allowed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Agent ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-bottom: 0.5pt solid ; "><p>Agent Identifier: The identifier of the agent sending the message. Used to defeat replay attacks and certain other types of security attacks.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Agent Boots</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Agent Number of Boots: The number of times the agent has been booted or rebooted since its Agent ID was set; used to defeat certain security attacks.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Agent Time</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Agent Time Since Last Boot: The number of seconds since the last boot of this agent. Again, used to defeat replay and other security attacks.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Max Size</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-bottom: 0.5pt solid ; "><p>Maximum Message Size: The maximum size of message that the sender of this message can receive.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>User Len</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>User Length: The length of the User Name field below.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>User Name</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable (1 to 16)</p></td><td style="border-bottom: 0.5pt solid ; "><p>User Name: The name of the user on whose behalf the message is being sent.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Auth Len</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Authentication Digest Length: The length of the Auth Digest field.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Auth Digest</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable (0 to 255)</p></td><td style="border-bottom: 0.5pt solid ; "><p>Authentication Digest: An authentication value used to verify the identity and genuineness of this message, when authentication is used.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Context Selector</p></td><td style="border-right: 0.5pt solid ; "><p>Variable (0 to 40)</p></td><td style=""><p>Context Selector: A string that is combined with the Agent ID to specify a particular context that contains the management information referenced by this message.</p></td></tr></tbody></table></div></div></div><div class="sect2" title="SNMPv2 PDU Formats"><div class="titlepage"><div><div><h2 class="title"><a id="snmpv2_pdu_formats"/>SNMPv2 PDU Formats</h2></div></div></div><p>The format of protocol data units in SNMPv2 is described in RFC 1905, and it is similar to that of SNMPv1. The format for all PDUs in SNMPv2 is the same, except for the GetBulkRequest-PDU message. (Oddly, this includes the Trapv2-PDU message, even though the Trap-PDU message in SNMPv1 used a distinct format.)</p><p><a class="xref" href="ch68s05.html#snmpv_common_pdu_format-id001" title="Table 68-10. SNMPv2 Common PDU Format">Table 68-10</a> shows the common SNMPv2 PDU format. <a class="xref" href="ch68s05.html#snmpv_pdu_error_status_field_values" title="Table 68-11. SNMPv2 PDU Error Status Field Values">Table 68-11</a> contains a listing of the different values for the Error Status field and how they are interpreted. <a class="xref" href="ch68s05.html#snmpv2_common_pdu_format" title="Figure 68-8. SNMPv2 common PDU format">Figure 68-8</a> illustrates the <a class="indexterm" id="idx-CHP-68-2456"/>SNMPv2 common PDU format.</p><div class="table"><a id="snmpv_common_pdu_format-id001"/><p class="title">Table 68-10. SNMPv2 Common PDU Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMPv2 Common PDU Format"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>PDU Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer (Enumerated)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>PDU Type: An integer value that indicates the PDU type:</p>
<p>0 = GetRequest-PDU</p>
<p>1 = GetNextRequest-PDU</p>
<p>2 = Response-PDU</p>
<p>3 = SetRequest-PDU</p>
<p>4 = Obsolete, not used (this was the old Trap-PDU in SNMPv1)</p>
<p>5 = GetBulkRequest-PDU (has its own format; see <a class="xref" href="ch68s05.html#snmpv_getbulkrequest-pdu_format" title="Table 68-12. SNMPv2 GetBulkRequest-PDU Format">Table 68-12</a>)</p>
<p>6 = InformRequest-PDU</p>
<p>7 = Trapv2-PDU</p>
<p>8 = Report-PDU</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Request Identifier: A number used to match requests with replies. It is generated by the device that sends a request and copied into this field in a Response-PDU by the responding SNMP entity.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Error Status</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer (Enumerated)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Error Status: An integer value that is used in a Response-PDU to tell the requesting SNMP entity the result of its request. A value of zero indicates that no error occurred; the other values indicate what sort of error happened (see <a class="xref" href="ch68s05.html#snmpv_pdu_error_status_field_values" title="Table 68-11. SNMPv2 PDU Error Status Field Values">Table 68-11</a>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Error Index</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Error Index: When Error Status is nonzero, this field contains a pointer that specifies which object generated the error. Always zero in a request.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Variable Bindings</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Variable Bindings: A set of name/value pairs identifying the MIB objects in the PDU, and in the case of messages other than requests, containing their values. See the discussion of the general SNMP general PDU format earlier in this chapter for more on these bindings.</p></td></tr></tbody></table></div></div><div class="note" title="Note"><h3 class="title"><a id="note-153"/>Note</h3><p><span class="emphasis"><em>The first six Error Status field values (0 to 5) are maintained as used in SNMPv1 for compatibility, but SNMPv2 adds many new error codes that provide more specific indication of the exact nature of an error in a request. The genErr code is still used only when none of the specific error types (either the old codes or the new ones) apply</em></span>.</p></div><div class="table"><a id="snmpv_pdu_error_status_field_values"/><p class="title">Table 68-11. SNMPv2 PDU Error Status Field Values</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMPv2 PDU Error Status Field Values"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Error Status Value</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Error Code</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>noError</p></td><td style="border-bottom: 0.5pt solid ; "><p>No error occurred. This code is also used in all request PDUs, since they have no error status to report.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>tooBig</p></td><td style="border-bottom: 0.5pt solid ; "><p>The size of the Response-PDU would be too large to transport.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>noSuchName</p></td><td style="border-bottom: 0.5pt solid ; "><p>The name of a requested object was not found.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>badValue</p></td><td style="border-bottom: 0.5pt solid ; "><p>A value in the request didn't match the structure that the recipient of the request had for the object. For example, an object in the request was specified with an incorrect length or type.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>readOnly</p></td><td style="border-bottom: 0.5pt solid ; "><p>An attempt was made to set a variable that has an Access value indicating that it is read-only.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>genErr</p></td><td style="border-bottom: 0.5pt solid ; "><p>An error occurred other than one indicated by a more specific error code in this table.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>noAccess</p></td><td style="border-bottom: 0.5pt solid ; "><p>Access was denied to the object for security reasons.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>wrongType</p></td><td style="border-bottom: 0.5pt solid ; "><p>The object type in a variable binding is incorrect for the object.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>wrongLength</p></td><td style="border-bottom: 0.5pt solid ; "><p>A variable binding specifies a length incorrect for the object.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>wrongEncoding</p></td><td style="border-bottom: 0.5pt solid ; "><p>A variable binding specifies an encoding incorrect for the object.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>10</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>wrongValue</p></td><td style="border-bottom: 0.5pt solid ; "><p>The value given in a variable binding is not possible for the object.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>noCreation</p></td><td style="border-bottom: 0.5pt solid ; "><p>A specified variable does not exist and cannot be created.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>inconsistentValue</p></td><td style="border-bottom: 0.5pt solid ; "><p>A variable binding specifies a value that could be held by the variable but cannot be assigned to it at this time.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>13</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>resourceUnavailable</p></td><td style="border-bottom: 0.5pt solid ; "><p>An attempt to set a variable required a resource that is not available.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>14</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>commitFailed</p></td><td style="border-bottom: 0.5pt solid ; "><p>An attempt to set a particular variable failed.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>15</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>undoFailed</p></td><td style="border-bottom: 0.5pt solid ; "><p>An attempt to set a particular variable as part of a group of variables failed, and the attempt to then undo the setting of other variables was not successful.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>authorizationError</p></td><td style="border-bottom: 0.5pt solid ; "><p>A problem occurred in authorization.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>17</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>notWritable</p></td><td style="border-bottom: 0.5pt solid ; "><p>The variable cannot be written or created.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>18</p></td><td style="border-right: 0.5pt solid ; "><p>inconsistentName</p></td><td style=""><p>The name in a variable binding specifies a variable that does not exist.</p></td></tr></tbody></table></div></div><div class="figure"><a id="snmpv2_common_pdu_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e74013"/><img alt="SNMPv2 common PDU format" src="httpatomoreillycomsourcenostarchimages288251.png"/></div></div><p class="title">Figure 68-8. SNMPv2 common PDU format</p></div><p>The special format of the SNMPv2 GetBulkRequest-PDU message is shown in <a class="xref" href="ch68s05.html#snmpv_getbulkrequest-pdu_format" title="Table 68-12. SNMPv2 GetBulkRequest-PDU Format">Table 68-12</a> and illustrated in <a class="xref" href="ch68s05.html#snmpv2_getbulkrequest-pdu_format" title="Figure 68-9. SNMPv2 GetBulkRequest-PDU format">Figure 68-9</a>.<a class="indexterm" id="idx-CHP-68-2457"/></p><div class="figure"><a id="snmpv2_getbulkrequest-pdu_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e74034"/><img alt="SNMPv2 GetBulkRequest-PDU format" src="httpatomoreillycomsourcenostarchimages288253.png"/></div></div><p class="title">Figure 68-9. SNMPv2 GetBulkRequest-PDU format</p></div><div class="table"><a id="snmpv_getbulkrequest-pdu_format"/><p class="title">Table 68-12. SNMPv2 GetBulkRequest-PDU Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMPv2 GetBulkRequest-PDU Format"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>PDU Type</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer (Enumerated)</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>PDU Type: An integer value that indicates the PDU type, which is 5 for a GetBulkRequest-PDU message.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Request ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Request Identifier: A number used to match requests with replies. It is generated by the device that sends a request and copied into this field in a Response-PDU by the responding SNMP entity.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Non Repeaters</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Non Repeaters: Specifies the number of nonrepeating, regular objects at the start of the variable list in the request.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Max Repetitions</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Maximum Repetitions: The number of iterations in the table to be read for the repeating objects that follow the nonrepeating objects.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Variable Bindings</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Variable Bindings: A set of name/value pairs identifying the MIB objects in the PDU. See the discussion of the general SNMP general PDU format earlier in this chapter for more on these bindings.</p></td></tr></tbody></table></div></div><p><a class="xref" href="ch67.html" title="Chapter 67. TCP/IP SIMPLE NETWORK MANAGEMENT PROTOCOL (SNMP) CONCEPTS AND OPERATION">Chapter 67</a> contains full details on how the Non Repeaters and Max Repetitions fields are used.</p></div></div>
<div class="sect1" title="SNMP Version 3 (SNMPv3) Message Format"><div class="titlepage"><div><div><h1 class="title"><a id="snmp_version_3_snmpv3_message_format"/>SNMP Version 3 (SNMPv3) Message Format</h1></div></div></div><p>In the late 1990s, SNMPv3 was created to resolve the problems that occurred with the many different variations of <a class="indexterm" id="idx-CHP-68-2458"/>SNMPv2. The SNMPv3 Framework adopts many components that were created in SNMPv2, including the SNMPv2 protocol operations, PDU types, and PDU format. The significant changes made in SNMPv3 include a more flexible way of defining security methods and parameters to allow the coexistence of multiple security techniques.</p><p>The general message format for SNMPv3 still follows the same idea of an overall message wrapper that contains a header and an encapsulated PDU, but it is further refined. The fields in the header have themselves been divided into those dealing with security and those that do not deal with security matters. The fields not related to security are common to all SNMPv3 implementations. The use of the security fields can be tailored by each SNMPv3 security model, and processed by the module in an SNMP entity that deals with security. This solution provides considerable flexibility while avoiding the problems that plagued SNMPv2.</p><p>The overall <a class="indexterm" id="idx-CHP-68-2459"/>SNMPv3 message format is described in RFC 3412, which specifies its message processing and dispatching. <a class="xref" href="ch68s06.html#snmp_version__snmpv_general_messag-id001" title="Table 68-13. SNMP Version 3 (SNMPv3) General Message Format">Table 68-13</a> describes the SNMPv3 message format, and it is illustrated in <a class="xref" href="ch68s06.html#snmpv3_general_message_format" title="Figure 68-10. SNMPv3 general message format">Figure 68-10</a>.</p><div class="figure"><a id="snmpv3_general_message_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e74162"/><img alt="SNMPv3 general message format" src="httpatomoreillycomsourcenostarchimages288255.png.jpg"/></div></div><p class="title">Figure 68-10. SNMPv3 general message format</p></div><div class="table"><a id="snmp_version__snmpv_general_messag-id001"/><p class="title">Table 68-13. SNMP Version 3 (SNMPv3) General Message Format</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMP Version 3 (SNMPv3) General Message Format"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Field Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bytes)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Msg Version</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Message Version Number: Describes the SNMP version number of this message; used for ensuring compatibility between versions. For SNMPv3, this value is 3.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Msg ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Message Identifier: A number used to identify an <a class="indexterm" id="idx-CHP-68-2460"/>SNMPv3 message and to match response messages to request messages. The use of this field is similar to that of the Request ID field in the SNMPv2 PDU format (see <a class="xref" href="ch68s05.html#snmpv_common_pdu_format-id001" title="Table 68-10. SNMPv2 Common PDU Format">Table 68-10</a>), but they are not identical. This field was created to allow matching at the message-processing level, regardless of the contents of the PDU, to protect against certain security attacks. Thus, Msg ID and Request ID are used independently.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Msg Max Size</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Maximum Message Size: The maximum size of message that the sender of this message can receive. Minimum value of this field is 484.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Msg Flags</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Octet String</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Message Flags: A set of flags that controls processing of the message. The current substructure of this field is shown in <a class="xref" href="ch68s06.html#snmpv_msg_flags_subfields" title="Table 68-14. SNMPv3 Msg Flags Subfields">Table 68-14</a>.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Msg Security Model</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Integer</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-bottom: 0.5pt solid ; "><p>Message Security Model: An integer value indicating which security model was used for this message. For the user-based security model (the default in SNMPv3), this value is 3.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Msg Security Parameters</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Message Security Parameters: A set of fields that contain parameters required to implement the particular security model used for this message. The contents of this field are specified in each document describing an SNMPv3 security model. For example, the parameters for the user-based model are in RFC 3414.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Scoped PDU</p></td><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>Scoped PDU: Contains the PDU to be transmitted, along with parameters that identify an SNMP context, which describes a set of management information accessible by a particular entity. The PDU is said to be <span class="emphasis"><em>scoped</em></span> because it is applied within the scope of this context. (Yes, security stuff is confusing, sorry; it would take pages and pages to properly explain contexts; see RFC 3411.) The field may be encrypted or unencrypted depending on the value of <span class="emphasis"><em>Priv Flag</em></span>. Its structure is shown in <a class="xref" href="ch68s06.html#snmpv_scoped_pdu_subfields" title="Table 68-15. SNMPv3 Scoped PDU Subfields">Table 68-15</a>.</p></td></tr></tbody></table></div></div><div class="table"><a id="snmpv_msg_flags_subfields"/><p class="title">Table 68-14. SNMPv3 Msg Flags Subfields</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMPv3 Msg Flags Subfields"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size (Bits)</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reserved</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reserved: Reserved for future use.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Reportable Flag</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Reportable Flag: When set to 1, a device receiving this message must send back a Report-PDU whenever conditions arise where such a PDU should be generated.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Priv Flag</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-bottom: 0.5pt solid ; "><p>Privacy Flag: When set to 1, indicates that encryption was used to protect the privacy of the message. May not be set to 1 unless Auth Flag is also set to 1.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>Auth Flag</p></td><td style="border-right: 0.5pt solid ; "><p>1</p></td><td style=""><p>Authentication Flag: When set to 1, indicates that authentication was used to protect the authenticity of this message.</p></td></tr></tbody></table></div></div><div class="table"><a id="snmpv_scoped_pdu_subfields"/><p class="title">Table 68-15. SNMPv3 Scoped PDU Subfields</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMPv3 Scoped PDU Subfields"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Subfield Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Syntax</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Size</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Context Engine ID</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Octet String</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>Used to identify to which application the PDU will be sent for processing.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Context Name</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Octet String</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Variable</p></td><td style="border-bottom: 0.5pt solid ; "><p>An object identifier specifying the particular context associated with this PDU.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>PDU</p></td><td style="border-right: 0.5pt solid ; "><p>—</p></td><td style="border-right: 0.5pt solid ; "><p>Variable</p></td><td style=""><p>The protocol data unit being transmitted.</p></td></tr></tbody></table></div></div><p>Fortunately, SNMPv3 uses the protocol operations from SNMPv2, as described in RFC 3416, which is just an update of RFC 1904. Thus, the PDU formats for SNMPv3 are the same as those of SNMPv2 (see Tables <a class="xref" href="ch68s05.html#snmpv_common_pdu_format-id001" title="Table 68-10. SNMPv2 Common PDU Format">Table 68-10</a> through <a class="xref" href="ch68s05.html#snmpv_getbulkrequest-pdu_format" title="Table 68-12. SNMPv2 GetBulkRequest-PDU Format">Table 68-12</a> and Figures <a class="xref" href="ch68s05.html#snmpv2_common_pdu_format" title="Figure 68-8. SNMPv2 common PDU format">Figure 68-8</a> and <a class="xref" href="ch68s05.html#snmpv2_getbulkrequest-pdu_format" title="Figure 68-9. SNMPv2 GetBulkRequest-PDU format">Figure 68-9</a>).</p></div>
<div class="chapter" title="Chapter&#xA0;69.&#xA0;TCP/IP REMOTE NETWORK MONITORING (RMON)"><div class="titlepage"><div><div><h1 class="title"><a id="tcp_ip_remote_network_monitoring_rmon"/>Chapter 69. TCP/IP REMOTE NETWORK MONITORING (RMON)</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject5_d1e74437"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages287681.png.jpg"/></div></div><p> We've seen in the preceding chapters of this part that the Simple <a class="indexterm" id="idx-CHP-69-2461"/>Network Management Protocol (SNMP) defines both a framework and a specific protocol for exchanging network information on a TCP/IP internetwork. The general model used by SNMP is that of a network management station (NMS) that sends requests to SNMP agents running on managed devices. The SNMP agents may also initiate certain types of communication by sending <span class="emphasis"><em>trap</em></span> messages to tell the NMS when particular events occur.</p><p>This model works well, which is why SNMP has become so popular. However, one fundamental limitation of the protocol and the model it uses is that it is oriented around the communication of network information from SNMP agents that are normally part of regular TCP/IP devices, such as hosts and routers. The amount of information gathered by these devices is usually somewhat limited, because obviously hosts and routers have real work to do—that is, doing the jobs of being hosts and routers. They can't devote themselves to network management tasks.</p><p>Thus, in situations where more information is needed about a network than is gathered by traditional devices, administrators often use special hardware units called <span class="emphasis"><em>network analyzers</em></span>, <span class="emphasis"><em>monitors</em></span>, or <span class="emphasis"><em>probes</em></span>. These are dedicated pieces of equipment that are connected to a network and used strictly for the purpose of gathering statistics and watching for events of interest or concern to the administrator. It would obviously be very useful if these devices could use SNMP to allow the information they gather to be retrieved, and to let them generate traps when they notice something important. To enable this, the <span class="emphasis"><em>Remote Network Monitoring (RMON)</em></span> specification was created.</p><div class="sect1" title="RMON Standards"><div class="titlepage"><div><div><h1 class="title"><a id="rmon_standards"/>RMON Standards</h1></div></div></div><p>RMON is often called a protocol, and you will sometimes see SNMP and RMON referred to as the TCP/IP network management protocols. However, RMON really isn't a separate protocol at all—it defines no protocol operations. RMON is actually part of SNMP, and the RMON specification is simply a management information base (MIB) module that defines a particular set of MIB objects for use by network monitoring probes. Architecturally, it is just one of the many MIB modules that compose the SNMP Framework.<a class="indexterm" id="idx-CHP-69-2462"/></p><div class="tip" title="Tip"><h3 class="title"><a id="tip-411"/>Tip</h3><p><span class="strong"><strong>KEY CONCEPT</strong></span> SNMP <span class="emphasis"><em>Remote Network Monitoring (RMON)</em></span> was created to enable the efficient management of networks using dedicated management devices such as network analyzers, monitors, or probes. RMON is often called a protocol, but it does not define any new protocol operations. It is actually an MIB module for SNMP that describes objects that permit advanced network management capabilities.</p></div><p>The first standard documenting RMON was RFC 1271, "Remote Network Monitoring Management Information Base," published in 1991. RFC 1271 was replaced by RFC 1757 in 1995, which made a couple of changes to the specification. RFC 2819, published in May 2000, updates RMON to use the new Structure of Management Information version 2 (SMIv2) specification that is part of SNMPv2 but is functionally the same as RFC 1757.</p></div></div>
<div class="sect1" title="RMON MIB Hierarchy and Object Groups"><div class="titlepage"><div><div><h1 class="title"><a id="rmon_mib_hierarchy_and_object_groups"/>RMON MIB Hierarchy and Object Groups</h1></div></div></div><p>Since RMON is a MIB module, it consists almost entirely of descriptions for MIB objects, each with the standard characteristics belonging to all such objects. All the objects within RMON are arranged into the SNMP object name hierarchy within the <span class="emphasis"><em>rmon</em></span> group, which is group number 16 within the SNMP mib (mib-2) object tree, 1.3.6.1.2.1. So, all RMON objects have identifiers starting with 1.3.6.1.2.1.16. This single RMON group is broken down into several lower-level groups that provide more structure for the RMON objects defined by the specification. <a class="xref" href="ch69s02.html#snmp_remote_network_monitoring_rmon_mib_" title="Figure 69-1. SNMP Remote Network Monitoring (RMON) MIB hierarchy RMON uses a special MIB module, rmon(16), which fits into the overall SNMP object hierarchy tree under mib/mib-2(1) within mgmt(2)—just like other MIB object groups such as sys(1) and if(2); see Figure 66-2 in Chapter 66. Within this group, which has the group identifier 1.3.6.1.2.1.16, are nine subgroups of RMON objects.">Figure 69-1</a> shows this structure.<a class="indexterm" id="idx-CHP-69-2463"/></p><p><a class="xref" href="ch69s02.html#snmp_rmon_mib_object_groups" title="Table 69-1. SNMP RMON MIB Object Groups">Table 69-1</a> describes each of the RMON groups, showing its name, group code (which is used as the prefix for object descriptors in the group), and RMON group number and SNMP object hierarchy identifier.</p><div class="figure"><a id="snmp_remote_network_monitoring_rmon_mib_"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject5_d1e74511"/><img alt="SNMP Remote Network Monitoring (RMON) MIB hierarchy RMON uses a special MIB module, rmon(16), which fits into the overall SNMP object hierarchy tree under mib/mib-2(1) within mgmt(2)—just like other MIB object groups such as sys(1) and if(2); see in . Within this group, which has the group identifier 1.3.6.1.2.1.16, are nine subgroups of RMON objects." src="httpatomoreillycomsourcenostarchimages288257.png.jpg"/></div></div><p class="title">Figure 69-1. SNMP Remote Network Monitoring (RMON) MIB hierarchy RMON uses a special MIB module, rmon(16), which fits into the overall SNMP object hierarchy tree under mib/mib-2(1) within mgmt(2)—just like other MIB object groups such as sys(1) and if(2); see <a class="xref" href="ch66s03.html#global_object_name_hierarchy_and_snmp_mi" title="Figure 66-2. Global object name hierarchy and SNMP MIB hierarchies This diagram shows the object name hierarchy defined by ISO and CCITT (ITU) to allow all types of objects to be universally represented. The path within this larger tree to the tree branches relevant to SNMP can be found by following the shaded boxes. The two subtrees used for SNMP are shown as the hatched boxes under internet(1). Each contains its own substructure (some of which is illustrated here) defining thousands of different MIB objects. The branch on the left side is used for generic MIB objects and the one on the right for private ones. A separate hierarchy is also defined for SNMPv2.">Figure 66-2</a> in <a class="xref" href="ch66.html" title="Chapter 66. TCP/IP STRUCTURE OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT INFORMATION BASES (MIBS)">Chapter 66</a>. Within this group, which has the group identifier 1.3.6.1.2.1.16, are nine subgroups of RMON objects.</p></div><div class="table"><a id="snmp_rmon_mib_object_groups"/><p class="title">Table 69-1. SNMP RMON MIB Object Groups</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="SNMP RMON MIB Object Groups"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a class="indexterm" id="idx-CHP-69-2464"/>RMON Group Name</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RMON Group Code</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>RMON Group Number</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Full Group Identifier</p></th><th style="border-bottom: 0.5pt solid ; "><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>statistics</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>etherStats</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.16.1</p></td><td style="border-bottom: 0.5pt solid ; "><p>This group contains objects that keep track of <a class="indexterm" id="idx-CHP-69-2465"/>network statistics measured by the device. Statistics may include network traffic load, average packet size, number of broadcasts observed, counts of errors that have occurred, the number of packets in various size ranges, and so forth.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>history</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>history, etherHistory</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.16.2</p></td><td style="border-bottom: 0.5pt solid ; "><p>The history group contains a single table object that controls how often statistical data is sampled by the probe. The additional etherHistory group is optional and contains extra Ethernet-specific information; it is contained logically within the history group.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>alarm</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>alarm</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.16.3</p></td><td style="border-bottom: 0.5pt solid ; "><p>This group defines the parameters under which an alarm may be generated to inform an administrator of an occurrence of import. The alarm group contains a table that describes the thresholds that will cause an event to be triggered (see the event group description in this table).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>hosts</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>host</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.16.4</p></td><td style="border-bottom: 0.5pt solid ; "><p>This group contains objects that keep track of information for each host on a network.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>hostsTopN</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>hostTopN</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.16.5</p></td><td style="border-bottom: 0.5pt solid ; "><p>This group contains objects that facilitate reporting of hosts sorted in a particular way. The administrator determines how these ordered statistics are tracked. For example, an administrator could generate a report listing hosts sorted by the number of packets transmitted, showing the most active devices.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>matrix</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>matrix</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.16.6</p></td><td style="border-bottom: 0.5pt solid ; "><p>This group keeps track of statistics for data exchanges between particular pairs of hosts. The amount of data sent between any two devices on the network could be tracked here. Since a large network could have thousands of such device pairs, to conserve resources on the probe, often only the most recent conversations between device pairs are kept in the MIB.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>filter</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>filter</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.16.7</p></td><td style="border-bottom: 0.5pt solid ; "><p>This group allows an administrator to set up filters that control what sorts of network packets the probe will capture.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>capture</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>buffer, capture</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>1.3.6.1.2.1.16.8</p></td><td style="border-bottom: 0.5pt solid ; "><p>This group is used to allow a probe to capture packets based on particular parameters set up in the filter group.</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p>event</p></td><td style="border-right: 0.5pt solid ; "><p>event</p></td><td style="border-right: 0.5pt solid ; "><p>9</p></td><td style="border-right: 0.5pt solid ; "><p>1.3.6.1.2.1.16.9</p></td><td style=""><p>When a particular alarm is triggered based on the parameters in the objects in the alarm group, an event is generated. This group controls how these events are processed, including creating and sending an SNMP trap message to an NMS.</p></td></tr></tbody></table></div></div><p>The original RMON standard was heavily oriented around Ethernet local area networks (LANs), and you can see some of that in <a class="xref" href="ch69s02.html#snmp_rmon_mib_object_groups" title="Table 69-1. SNMP RMON MIB Object Groups">Table 69-1</a>. Probes can also gather and report information related to other networking technologies by using other RMON groups created for that purpose. The best example of this was the definition of a set of groups specifically for Token Ring, which was defined in RFC 1513 in 1993.</p></div>
<div class="sect1" title="RMON Alarms, Events, and Statistics"><div class="titlepage"><div><div><h1 class="title"><a id="rmon_alarms_events_and_statistics"/>RMON Alarms, Events, and Statistics</h1></div></div></div><p>Alarms and events are particularly useful constructs in RMON, as they allow the immediate communication of important information to an NMS. The administrator has full control over what conditions will cause an alarm to be sounded and how an event is generated. This includes specifying which variables or statistics to monitor, how often to check them, and what values will trigger an alarm. A log entry may also be recorded when an event occurs. If an event results in transmission of a trap message, the administrator will thus be notified and can decide how to respond, depending on the severity of the event.</p><p>Like all MIB modules and groups, a particular manufacturer may decide which RMON groups to implement. However, certain groups—such as alarm and event—are related, and some groups—such as statistics—are usually implemented in all RMON probes. Obviously, when RMON is used, the NMS must be aware of RMON groups and must allow a network management application to be run that will exploit the capabilities of the RMON MIB objects.</p></div></body></html>