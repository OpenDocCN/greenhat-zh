<html><head></head><body><div class="chapter" title="Chapter&#xA0;14.&#xA0;For a Few Monads More"><div class="titlepage"><div><div><h1 class="title"><a id="for_a_few_monads_more"/>Chapter 14. For a Few Monads More</h1></div></div></div><p>You’ve seen how monads can be used to take values with contexts and apply them to functions, and how using <code class="literal">&gt;&gt;=</code> or <code class="literal">do</code> notation allows you to focus on the values themselves, while Haskell handles the context for you.<a id="IDX-CHP-14-0001" class="indexterm"/><a id="IDX-CHP-14-0002" class="indexterm"/><a id="IDX-CHP-14-0003" class="indexterm"/></p><p>You’ve met the <code class="literal">Maybe</code> monad and seen how it adds a context of possible failure to values. You’ve learned about the list monad and seen how it lets us easily introduce nondeterminism into our programs. You’ve also learned how to work in the <code class="literal">IO</code> monad, even before you knew what a monad was!</p><p>In this chapter, we’ll cover a few other monads. You’ll see how they can make your programs clearer by letting you treat all sorts of values as monadic ones. Further exploration of monads will also solidify your intuition for recognizing and working with monads.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject14_d1e27149"/><img src="httpatomoreillycomsourcenostarchimages802698.png.jpg" alt="image with no caption"/></div></div><p>The monads that we’ll be exploring are all part of the <code class="literal">mtl</code> package.(A Haskell <span class="emphasis"><em>package</em></span> is a collection of modules.) The <code class="literal">mtl</code> package comes with the Haskell Platform, so you probably already have it. To check if you do, type <strong class="userinput"><code>ghc-pkg list</code></strong> from the command line. This will show which Haskell packages you have installed, and one of them should be <code class="literal">mtl</code>, followed by a version number.<a id="IDX-CHP-14-0004" class="indexterm"/><a id="IDX-CHP-14-0005" class="indexterm"/></p><div class="sect1" title="Writer? I Hardly Knew Her!"><div class="titlepage"><div><div><h1 class="title"><a id="writer_question_i_hardly_knew_her_exclam"/>Writer? I Hardly Knew Her!</h1></div></div></div><p>We’ve loaded our gun with the <code class="literal">Maybe</code> monad, the list monad, and the <code class="literal">IO</code> monad. Now let’s put the <code class="literal">Writer</code> monad in the chamber and see what happens when we fire it!</p><p>Whereas the <code class="literal">Maybe</code> monad is for values with an added context of failure, and the list monad is for nondeterministic values, the <code class="literal">Writer</code> monad is for values that have another value attached that acts as a sort of log value. <code class="literal">Writer</code> allows us to do computations while making sure that all the log values are combined into one log value, which then is attached to the result.</p><p>For instance, we might want to equip our values with strings that explain what’s going on, probably for debugging purposes. Consider a function that takes a number of bandits in a gang and tells us if that’s a big gang. It’s a very simple function:</p><a id="I_programlisting14_d1e27207"/><pre class="programlisting">isBigGang :: Int -&gt; Bool
isBigGang x = x &gt; 9</pre><p>Now, what if instead of just giving us a <code class="literal">True</code> or <code class="literal">False</code> value, we want the function to also return a log string that says what it did? Well, we just make that string and return it alongside our <code class="literal">Bool</code>:</p><a id="I_programlisting14_d1e27220"/><pre class="programlisting">isBigGang :: Int -&gt; (Bool, String)
isBigGang x = (x &gt; 9, "Compared gang size to 9.")</pre><p>So now, instead of just returning a <code class="literal">Bool</code>, we return a tuple, where the first component of the tuple is the actual value and the second component is the string that accompanies that value. There’s some added context to our value now. Let’s give this a go:</p><a id="I_programlisting14_d1e27227"/><pre class="programlisting">ghci&gt; isBigGang 3
(False,"Compared gang size to 9.")
ghci&gt; isBigGang 30
(True,"Compared gang size to 9.")</pre><p>So far, so good. <code class="literal">isBigGang</code> takes a normal value and returns a value with a context. As you’ve just seen, feeding it a normal value is not a problem. Now what if we already have a value that has a log string attached to it, such as <code class="literal">(3, "Smallish gang.")</code>, and we want to feed it to <code class="literal">isBigGang</code>? It seems like once again, we’re faced with this question: If we have a function that takes a normal value and returns a value with a context, how do we take a value with a context and feed it to the function?</p><p>When we were exploring the <code class="literal">Maybe</code> monad in the previous chapter, we made a function <code class="literal">applyMaybe</code>. This function takes a <code class="literal">Maybe a</code> value and a function of type <code class="literal">a -&gt; Maybe b</code>. We feed that <code class="literal">Maybe a</code> value into the function, even though the function takes a normal <code class="literal">a</code> instead of a <code class="literal">Maybe a</code>. It does this by minding the context that comes with <code class="literal">Maybe a</code> values, which is that they are values with possible failure. But inside the <code class="literal">a -&gt; Maybe b</code> function, we can treat that value as just a normal value, because <code class="literal">applyMaybe</code> (which later becomes <code class="literal">&gt;&gt;=</code>) takes care of checking if it is a <code class="literal">Nothing</code> or a <code class="literal">Just</code> value.<a id="IDX-CHP-14-0006" class="indexterm"/><a id="IDX-CHP-14-0007" class="indexterm"/><a id="IDX-CHP-14-0008" class="indexterm"/><a id="IDX-CHP-14-0009" class="indexterm"/><a id="IDX-CHP-14-0010" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject14_d1e27308"/><img src="httpatomoreillycomsourcenostarchimages802700.png.jpg" alt="image with no caption"/></div></div><p>In the same vein, let’s make a function that takes a value with an attached log—that is, an <code class="literal">(a, String)</code> value—and a function of type <code class="literal">a -&gt; (b, String)</code>, and feeds that value into the function. We’ll call it <code class="literal">applyLog</code>. But an <code class="literal">(a, String)</code> value doesn’t carry with it a context of possible failure, but rather a context of an additional log value. So, <code class="literal">applyLog</code> will make sure that the log of the original value isn’t lost, but is joined together with the log of the value that results from the function. Here’s the implementation of <code class="literal">applyLog</code>:</p><a id="I_programlisting14_d1e27334"/><pre class="programlisting">applyLog :: (a, String) -&gt; (a -&gt; (b, String)) -&gt; (b, String)
applyLog (x, log) f = let (y, newLog) = f x in (y, log ++ newLog)</pre><p>When we have a value with a context that we want to feed to a function, we usually try to separate the actual value from the context, apply the function to the value, and then see whether the context is handled. In the <code class="literal">Maybe</code> monad, we checked if the value was a <code class="literal">Just x</code>, and if it was, we took that <code class="literal">x</code> and applied the function to it. In this case, it’s very easy to find the actual value, because we’re dealing with a pair where one component is the value and the other a log. So, first, we just take the value, which is <code class="literal">x</code>, and we apply the function <code class="literal">f</code> to it. We get a pair of <code class="literal">(y, newLog)</code>, where <code class="literal">y</code> is the new result and <code class="literal">newLog</code> is the new log. But if we returned that as the result, the old log value wouldn’t be included in the result, so we return a pair of <code class="literal">(y, log ++ newLog)</code>. We use <code class="literal">++</code> to append the new log to the old one.</p><p>Here’s <code class="literal">applyLog</code> in action:</p><a id="I_programlisting14_d1e27374"/><pre class="programlisting">ghci&gt; (3, "Smallish gang.") `applyLog` isBigGang
(False,"Smallish gang.Compared gang size to 9.")
ghci&gt; (30, "A freaking platoon.") `applyLog` isBigGang
(True,"A freaking platoon.Compared gang size to 9.")</pre><p>The results are similar to before, except that now the number of people in the gang has its accompanying log, which is included in the result log.</p><p>Here are a few more examples of using <code class="literal">applyLog</code>:<a id="IDX-CHP-14-0011" class="indexterm"/><a id="IDX-CHP-14-0012" class="indexterm"/><a id="IDX-CHP-14-0013" class="indexterm"/><a id="IDX-CHP-14-0014" class="indexterm"/><a id="IDX-CHP-14-0015" class="indexterm"/><a id="IDX-CHP-14-0016" class="indexterm"/><a id="IDX-CHP-14-0017" class="indexterm"/><a id="IDX-CHP-14-0018" class="indexterm"/><a id="IDX-CHP-14-0019" class="indexterm"/><a id="IDX-CHP-14-0020" class="indexterm"/><a id="IDX-CHP-14-0021" class="indexterm"/></p><a id="I_programlisting14_d1e27435"/><pre class="programlisting">ghci&gt; ("Tobin", "Got outlaw name.") `applyLog` (\x -&gt; (length x, "Applied length."))
(5,"Got outlaw name.Applied length.")
ghci&gt; ("Bathcat", "Got outlaw name.") `applyLog` (\x -&gt; (length x, "Applied length."))
(7,"Got outlaw name.Applied length.")</pre><p>See how inside the lambda, <code class="literal">x</code> is just a normal string and not a tuple, and how <code class="literal">applyLog</code> takes care of appending the logs?</p><div class="sect2" title="Monoids to the Rescue"><div class="titlepage"><div><div><h2 class="title"><a id="monoids_to_the_rescue"/>Monoids to the Rescue</h2></div></div></div><p>Right now, <code class="literal">applyLog</code> takes values of type <code class="literal">(a, String)</code>, but is there a reason that the log must be a <code class="literal">String</code>? It uses <code class="literal">++</code> to append the logs, so wouldn’t this work on any kind of list, not just a list of characters? Sure, it would. We can change its type to this:</p><a id="I_programlisting14_d1e27462"/><pre class="programlisting">applyLog :: (a, [c]) -&gt; (a -&gt; (b, [c])) -&gt; (b, [c])</pre><p>Now the log is a list. The type of values contained in the list must be the same for the original list as well as for the list that the function returns. Otherwise, we wouldn’t be able to use <code class="literal">++</code> to stick them together.</p><p>Would this work for bytestrings? There’s no reason it shouldn’t. However, the type we have now works only for lists. It seems as though we would need to make a separate <code class="literal">applyLog</code> for bytestrings. But wait! Both lists and bytestrings are monoids. As such, they are both instances of the <code class="literal">Monoid</code> type class, which means that they implement the <code class="literal">mappend</code> function. And for both lists and bytestrings, <code class="literal">mappend</code> is for appending. Watch it in action:</p><a id="I_programlisting14_d1e27483"/><pre class="programlisting">ghci&gt; [1,2,3] `mappend` [4,5,6]
[1,2,3,4,5,6]
ghci&gt; B.pack [99,104,105] `mappend` B.pack [104,117,97,104,117,97]
Chunk "chi" (Chunk "huahua" Empty)</pre><p>Cool! Now our <code class="literal">applyLog</code> can work for any monoid. We need to change the type to reflect this, as well as the implementation, because we need to change <code class="literal">++</code> to <code class="literal">mappend</code>:</p><a id="I_programlisting14_d1e27496"/><pre class="programlisting">applyLog :: (Monoid m) =&gt; (a, m) -&gt; (a -&gt; (b, m)) -&gt; (b, m)
applyLog (x, log) f = let (y, newLog) = f x in (y, log `mappend` newLog)</pre><p>Because the accompanying value can now be any monoid value, we no longer need to think of the tuple as a value and a log; now we can think of it as a value with an accompanying monoid value. For instance, we can have a tuple that has an item name and an item price as the monoid value. We just use the <code class="literal">Sum newtype</code> to make sure that the prices are added as we operate with the items. Here’s a function that adds drink to some cowboy food order:<a id="IDX-CHP-14-0022" class="indexterm"/></p><a id="I_programlisting14_d1e27506"/><pre class="programlisting">import Data.Monoid

type Food = String
type Price = Sum Int

addDrink :: Food -&gt; (Food, Price)
addDrink "beans" = ("milk", Sum 25)
addDrink "jerky" = ("whiskey", Sum 99)
addDrink _ = ("beer", Sum 30)</pre><p>We use strings to represent foods and an <code class="literal">Int</code> in a <code class="literal">Sum newtype</code> wrapper to keep track of how many cents something costs. As a reminder, doing <code class="literal">mappend</code> with <code class="literal">Sum</code> results in the wrapped values being added together:</p><a id="I_programlisting14_d1e27523"/><pre class="programlisting">ghci&gt; Sum 3 `mappend` Sum 9
Sum {getSum = 12}</pre><p>The <code class="literal">addDrink</code> function is pretty simple. If we’re eating beans, it returns <code class="literal">"milk"</code> along with <code class="literal">Sum 25</code>, so 25 cents wrapped in <code class="literal">Sum</code>. If we’re eating jerky, we drink whiskey. And if we’re eating anything else, we drink beer. Just normally applying this function to a food wouldn’t be terribly interesting right now. But using <code class="literal">applyLog</code> to feed a food that comes with a price itself into this function is worth a look:</p><a id="I_programlisting14_d1e27542"/><pre class="programlisting">ghci&gt; ("beans", Sum 10) `applyLog` addDrink
("milk",Sum {getSum = 35})
ghci&gt; ("jerky", Sum 25) `applyLog` addDrink
("whiskey",Sum {getSum = 124})
ghci&gt; ("dogmeat", Sum 5) `applyLog` addDrink
("beer",Sum {getSum = 35})</pre><p>Milk costs 25 cents, but if we have it with beans that cost 25 cents, we’ll end up paying 35 cents.</p><p>Now it’s clear how the attached value doesn’t always need to be a log. It can be any monoid value, and how two such values are combined depends on the monoid. When we were doing logs, they were appended, but now, the numbers are being added up.</p><p>Because the value that <code class="literal">addDrink</code> returns is a tuple of type <code class="literal">(Food, Price)</code>, we can feed that result to <code class="literal">addDrink</code> again, so that it tells us what we should drink along with our meal and how much that will cost us. Let’s give it a shot:</p><a id="I_programlisting14_d1e27559"/><pre class="programlisting">ghci&gt; ("dogmeat", Sum 5) `applyLog` addDrink `applyLog` addDrink
("beer",Sum {getSum = 65})</pre><p>Adding a drink to some dog meat results in a beer and an additional 30 cents, so <code class="literal">("beer", Sum 35)</code>. And if we use <code class="literal">applyLog</code> to feed that to <code class="literal">addDrink</code>, we get another beer, and the result is <code class="literal">("beer", Sum 65)</code>.<a id="IDX-CHP-14-0023" class="indexterm"/><a id="IDX-CHP-14-0024" class="indexterm"/><a id="IDX-CHP-14-0025" class="indexterm"/><a id="IDX-CHP-14-0026" class="indexterm"/><a id="IDX-CHP-14-0027" class="indexterm"/><a id="IDX-CHP-14-0028" class="indexterm"/></p></div><div class="sect2" title="The Writer Type"><div class="titlepage"><div><div><h2 class="title"><a id="the_writer_type"/>The Writer Type</h2></div></div></div><p>Now that you’ve seen how a value with an attached monoid acts like a monadic value, let’s examine the <code class="literal">Monad</code> instance for types of such values. The <code class="literal">Control.Monad.Writer</code> module exports the <code class="literal">Writer w a</code> type along with its <code class="literal">Monad</code> instance and some useful functions for dealing with values of this type.</p><p>To attach a monoid to a value, we just need to put them together in a tuple. The <code class="literal">Writer w a</code> type is just a <code class="literal">newtype</code> wrapper for this. Its definition is very simple:</p><a id="I_programlisting14_d1e27630"/><pre class="programlisting">newtype Writer w a = Writer { runWriter :: (a, w) }</pre><p>It’s wrapped in a <code class="literal">newtype</code> so that it can be made an instance of <code class="literal">Monad</code> and so that its type is separate from a normal tuple. The <code class="literal">a</code> type parameter represents the type of the value, and the <code class="literal">w</code> type parameter represents the type of the attached monoid value.</p><p>The <code class="literal">Control.Monad.Writer</code> module reserves the right to change the way it internally implements the <code class="literal">Writer w a</code> type, so it doesn’t export the <code class="literal">Writer</code> value constructor. However, it does export the <code class="literal">writer</code> function, which does the same thing that the <code class="literal">Writer</code> constructor would do. Use it when you want to take a tuple and make a <code class="literal">Writer</code> value from it.</p><p>Because the <code class="literal">Writer</code> value constructor is not exported, you also can’t pattern match against it. Instead, you need to use the <code class="literal">runWriter</code> function, which takes a tuple that’s wrapped in a <code class="literal">Writer newtype</code> and unwraps it, returning a simple tuple.</p><p>Its <code class="literal">Monad</code> instance is defined like so:</p><a id="I_programlisting14_d1e27683"/><pre class="programlisting">instance (Monoid w) =&gt; Monad (Writer w) where
    return x = Writer (x, mempty)
    (Writer (x, v)) &gt;&gt;= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')</pre><p>First, let’s examine <code class="literal">&gt;&gt;=</code>. Its implementation is essentially the same as <code class="literal">applyLog</code>, only now that our tuple is wrapped in the <code class="literal">Writer newtype</code>, we need to unwrap it when pattern matching. We take the value <code class="literal">x</code> and apply the function <code class="literal">f</code> to it. This gives us gives us a <code class="literal">Writer w a</code> value, and we use a <code class="literal">let</code> expression to pattern match on it. We present <code class="literal">y</code> as the new result and use <code class="literal">mappend</code> to combine the old monoid value with the new one. We pack that up with the result value in a tuple and then wrap that with the <code class="literal">Writer</code> constructor so that our result is a <code class="literal">Writer</code> value, instead of just an unwrapped tuple.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject14_d1e27722"/><img src="httpatomoreillycomsourcenostarchimages802702.png.jpg" alt="image with no caption"/></div></div><p>So, what about <code class="literal">return</code>? It must take a value and put it in a default minimal context that still presents that value as the result. What would such a context be for <code class="literal">Writer</code> values? If we want the accompanying monoid value to affect other monoid values as little as possible, it makes sense to use <code class="literal">mempty</code>.<a id="IDX-CHP-14-0029" class="indexterm"/><a id="IDX-CHP-14-0030" class="indexterm"/><a id="IDX-CHP-14-0031" class="indexterm"/><a id="IDX-CHP-14-0032" class="indexterm"/><a id="IDX-CHP-14-0033" class="indexterm"/></p><p><code class="literal">mempty</code> is used to present identity monoid values, such as <code class="literal">""</code> and <code class="literal">Sum 0</code> and empty bytestrings. Whenever we use <code class="literal">mappend</code> between <code class="literal">mempty</code> and some other monoid value, the result is that other monoid value. So, if we use <code class="literal">return</code> to make a <code class="literal">Writer</code> value and then use <code class="literal">&gt;&gt;=</code> to feed that value to a function, the resulting monoid value will be only what the function returns.</p><p>Let’s use <code class="literal">return</code> on the number <code class="literal">3</code> a bunch of times, pairing it with a different monoid each time:</p><a id="I_programlisting14_d1e27799"/><pre class="programlisting">ghci&gt; runWriter (return 3 :: Writer String Int)
(3,"")
ghci&gt; runWriter (return 3 :: Writer (Sum Int) Int)
(3,Sum {getSum = 0})
ghci&gt; runWriter (return 3 :: Writer (Product Int) Int)
(3,Product {getProduct = 1})</pre><p>Because <code class="literal">Writer</code> doesn’t have a <code class="literal">Show</code> instance, we used <code class="literal">runWriter</code> to convert our <code class="literal">Writer</code> values to normal tuples that can be shown. For <code class="literal">String</code>, the monoid value is the empty string. With <code class="literal">Sum</code>, it’s <code class="literal">0</code>, because if we add 0 to something, that something stays the same. For <code class="literal">Product</code>, the identity is <code class="literal">1</code>.</p><p>The <code class="literal">Writer</code> instance doesn’t feature an implementation for <code class="literal">fail</code>, so if a pattern match fails in <code class="literal">do</code> notation, <code class="literal">error</code> is called.</p></div><div class="sect2" title="Using do Notation with Writer"><div class="titlepage"><div><div><h2 class="title"><a id="using_do_notation_with_writer"/>Using do Notation with Writer</h2></div></div></div><p>Now that we have a <code class="literal">Monad</code> instance, we’re free to use <code class="literal">do</code> notation for <code class="literal">Writer</code> values. It’s handy when we have several <code class="literal">Writer</code> values and want to do stuff with them. As with other monads, we can treat them as normal values, and the context gets taken care of for us. In this case, all the monoid values that come attached are <code class="literal">mappend</code>ed, and so are reflected in the final result.</p><p>Here’s a simple example of using <code class="literal">do</code> notation with <code class="literal">Writer</code> to multiply two numbers:</p><a id="I_programlisting14_d1e27873"/><pre class="programlisting">import Control.Monad.Writer

logNumber :: Int -&gt; Writer [String] Int
logNumber x = writer (x, ["Got number: " ++ show x])

multWithLog :: Writer [String] Int multWithLog = do
    a &lt;- logNumber 3
    b &lt;- logNumber 5
    return (a*b)</pre><p><code class="literal">logNumber</code> takes a number and makes a <code class="literal">Writer</code> value out of it. Notice how we used the <code class="literal">writer</code> function to construct a <code class="literal">Writer</code> value, instead of directly using the <code class="literal">Writer</code> value constructor. For the monoid, we use a list of strings, and we equip the number with a singleton list that just says that we have that number. <code class="literal">multWithLog</code> is a <code class="literal">Writer</code> value that multiplies <code class="literal">3</code> and <code class="literal">5</code> and makes sure that their attached logs are included in the final log. We use <code class="literal">return</code> to present <code class="literal">a*b</code> as the result. Because <code class="literal">return</code> just takes something and puts it in a minimal context, we can be sure that it won’t add anything to the log.<a id="IDX-CHP-14-0034" class="indexterm"/><a id="IDX-CHP-14-0035" class="indexterm"/><a id="IDX-CHP-14-0036" class="indexterm"/><a id="IDX-CHP-14-0037" class="indexterm"/><a id="IDX-CHP-14-0038" class="indexterm"/><a id="IDX-CHP-14-0039" class="indexterm"/><a id="IDX-CHP-14-0040" class="indexterm"/></p><p>Here’s what we see if we run this code:</p><a id="I_programlisting14_d1e27941"/><pre class="programlisting">ghci&gt; runWriter multWithLog
(15,["Got number: 3","Got number: 5"])</pre><p>Sometimes, we just want some monoid value to be included at some particular point. For this, the <code class="literal">tell</code> function is useful. It’s part of the <code class="literal">MonadWriter</code> type class. In the case of <code class="literal">Writer</code>, it takes a monoid value, like <code class="literal">["This is going on"]</code>, and creates a <code class="literal">Writer</code> value that presents the dummy value <code class="literal">()</code> as its result, but has the desired monoid value attached. When we have a monadic value that has <code class="literal">()</code> as its result, we don’t bind it to a variable.</p><p>Here’s <code class="literal">multWithLog</code> with some extra reporting included:</p><a id="I_programlisting14_d1e27972"/><pre class="programlisting">multWithLog :: Writer [String] Int
multWithLog = do
    a &lt;- logNumber 3
    b &lt;- logNumber 5
    tell ["Gonna multiply these two"]
    return (a*b)</pre><p>It’s important that <code class="literal">return (a*b)</code> is the last line, because the result of the last line in a <code class="literal">do</code> expression is the result of the whole <code class="literal">do</code> expression. Had we put <code class="literal">tell</code> as the last line, the result of this <code class="literal">do</code> expression would be <code class="literal">()</code>. We would lose the result of the multiplication. However, the log would be the same. Here’s this in action:</p><a id="I_programlisting14_d1e27996"/><pre class="programlisting">ghci&gt; runWriter multWithLog
(15,["Got number: 3","Got number: 5","Gonna multiply these two"])</pre></div><div class="sect2" title="Adding Logging to Programs"><div class="titlepage"><div><div><h2 class="title"><a id="adding_logging_to_programs"/>Adding Logging to Programs</h2></div></div></div><p>Euclid’s algorithm takes two numbers and computes their greatest common divisor—that is, the biggest number that still divides both of them. Haskell already features the <code class="literal">gcd</code> function, which does exactly this, but let’s implement our own function and then equip it with logging capabilities. Here’s the normal algorithm:</p><a id="I_programlisting14_d1e28006"/><pre class="programlisting">gcd' :: Int -&gt; Int -&gt; Int gcd' a b
    | b == 0    = a
    | otherwise = gcd' b (a `mod` b)</pre><p>The algorithm is very simple. First, it checks if the second number is 0. If it is, then the result is the first number. If it isn’t, then the result is the greatest common divisor of the second number and the remainder of dividing the first number with the second one.<a id="IDX-CHP-14-0041" class="indexterm"/><a id="IDX-CHP-14-0042" class="indexterm"/><a id="IDX-CHP-14-0043" class="indexterm"/></p><p>For instance, if we want to know what the greatest common divisor of 8 and 3 is, we just follow this algorithm. Because 3 isn’t 0, we need to find the greatest common divisor of 3 and 2 (if we divide 8 by 3, the remainder is 2). Next, we find the greatest common divisor of 3 and 2. 2 still isn’t 0, so now we have have 2 and 1. The second number isn’t 0, so we run the algorithm again for 1 and 0, as dividing 2 by 1 gives us a remainder of 0. And finally, because the second number is now 0, the final result is 1. Let’s see if our code agrees:</p><a id="I_programlisting14_d1e28023"/><pre class="programlisting">ghci&gt; gcd' 8 3
1</pre><p>It does. Very good! Now, we want to equip our result with a context, and the context will be a monoid value that acts as a log. As before, we’ll use a list of strings as our monoid. So, this should be the type of our new <code class="literal">gcd'</code> function:</p><a id="I_programlisting14_d1e28030"/><pre class="programlisting">gcd' :: Int -&gt; Int -&gt; Writer [String] Int</pre><p>All that’s left now is to equip our function with log values. Here is the code:</p><a id="I_programlisting14_d1e28034"/><pre class="programlisting">import Control.Monad.Writer

gcd' :: Int -&gt; Int -&gt; Writer [String] Int
gcd' a b
    | b == 0 = do
        tell ["Finished with " ++ show a]
        return a
    | otherwise = do
        tell [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)]
        gcd' b (a `mod` b)</pre><p>This function takes two normal <code class="literal">Int</code> values and returns a <code class="literal">Writer [String] Int</code>—that is, an <code class="literal">Int</code> that has a log context. In the case where <code class="literal">b</code> is <code class="literal">0</code>, instead of just giving <code class="literal">a</code> as the result, we use a <code class="literal">do</code> expression to put together a <code class="literal">Writer</code> value as a result. First, we use <code class="literal">tell</code> to report that we’re finished, and then we use <code class="literal">return</code> to present <code class="literal">a</code> as the result of the <code class="literal">do</code> expression. Instead of this <code class="literal">do</code> expression, we could have also written this:</p><a id="I_programlisting14_d1e28080"/><pre class="programlisting">writer (a, ["Finished with " ++ show a])</pre><p>However, I think the <code class="literal">do</code> expression is easier to read.<a id="IDX-CHP-14-0044" class="indexterm"/><a id="IDX-CHP-14-0045" class="indexterm"/><a id="IDX-CHP-14-0046" class="indexterm"/><a id="IDX-CHP-14-0047" class="indexterm"/><a id="IDX-CHP-14-0048" class="indexterm"/></p><p>Next, we have the case when <code class="literal">b</code> isn’t <code class="literal">0</code>. In this case, we log that we’re using <code class="literal">mod</code> to figure out the remainder of dividing <code class="literal">a</code> and <code class="literal">b</code>. Then the second line of the <code class="literal">do</code> expression just recursively calls <code class="literal">gcd'</code>. Remember that <code class="literal">gcd'</code> now ultimately returns a <code class="literal">Writer</code> value, so it’s perfectly valid that <code class="literal">gcd' b (a `mod` b)</code> is a line in a <code class="literal">do</code> expression.</p><p>Let’s try out our new <code class="literal">gcd'</code>. Its result is a <code class="literal">Writer [String] Int</code> value, and if we unwrap that from its <code class="literal">newtype</code>, we get a tuple. The first part of the tuple is the result. Let’s see if it’s okay:</p><a id="I_programlisting14_d1e28159"/><pre class="programlisting">ghci&gt; fst $ runWriter (gcd' 8 3)
1</pre><p>Good! Now what about the log? Because the log is a list of strings, let’s use <code class="literal">mapM_ putStrLn</code> to print those strings on the screen:</p><a id="I_programlisting14_d1e28166"/><pre class="programlisting">ghci&gt; mapM_ putStrLn $ snd $ runWriter (gcd' 8 3)
8 mod 3 = 2
3 mod 2 = 1
2 mod 1 = 0
Finished with 1</pre><p>I think it’s awesome how we were able to change our ordinary algorithm to one that reports what it does as it goes along. And we did this just by changing normal values to monadic values. We let the implementation of <code class="literal">&gt;&gt;=</code> for <code class="literal">Writer</code> take care of the logs for us.</p><p>You can add a logging mechanism to pretty much any function. You just replace normal values with <code class="literal">Writer</code> values where you want and change normal function application to <code class="literal">&gt;&gt;=</code> (or <code class="literal">do</code> expressions if it increases readability).</p></div><div class="sect2" title="Inefficient List Construction"><div class="titlepage"><div><div><h2 class="title"><a id="inefficient_list_construction"/>Inefficient List Construction</h2></div></div></div><p>When using the <code class="literal">Writer</code> monad, you need to be careful which monoid to use, because using lists can sometimes turn out to be very slow. Lists use <code class="literal">++</code> for <code class="literal">mappend</code>, and using <code class="literal">++</code> to add something to the end of a list is slow if that list is really long.</p><p>In our <code class="literal">gcd'</code> function, the logging is fast because the list appending ends up looking like this:</p><a id="I_programlisting14_d1e28209"/><pre class="programlisting">a ++ (b ++ (c ++ (d ++ (e ++ f))))</pre><p>A list is a data structure that’s constructed from left to right. This is efficient, because we first fully construct the left part of a list and only then add a longer list on the right. But if we’re not careful, using the <code class="literal">Writer</code> monad can produce list appending that looks like this:<a id="IDX-CHP-14-0049" class="indexterm"/><a id="IDX-CHP-14-0050" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject14_d1e28225"/><img src="httpatomoreillycomsourcenostarchimages802704.png.jpg" alt="image with no caption"/></div></div><a id="I_programlisting14_d1e28230"/><pre class="programlisting">((((a ++ b) ++ c) ++ d) ++ e) ++ f</pre><p>This associates to the left instead of to the right. It’s inefficient because every time it wants to add the right part to the left part, it must construct the left part all the way from the beginning!</p><p>The following function works like <code class="literal">gcd'</code>, but it logs stuff in reverse. First, it produces the log for the rest of the procedure, and then it adds the current step to the end of the log.</p><a id="I_programlisting14_d1e28239"/><pre class="programlisting">import Control.Monad.Writer

gcdReverse :: Int -&gt; Int -&gt; Writer [String]
Int gcdReverse a b
    | b == 0 = do
        tell ["Finished with " ++ show a]
        return a
    | otherwise = do
        result &lt;- gcdReverse b (a `mod` b)
        tell [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)]
        return result</pre><p>It does the recursion first and binds its resulting value to <code class="literal">result</code>. Then it adds the current step to the log, but the current step goes at the end of the log that was produced by the recursion. At the end, it presents the result of the recursion as the final result. Here it is in action:</p><a id="I_programlisting14_d1e28247"/><pre class="programlisting">ghci&gt; mapM_ putStrLn $ snd $ runWriter (gcdReverse 8 3)
Finished with 1
2 mod 1 = 0
3 mod 2 = 1
8 mod 3 = 2</pre><p>This function is inefficient because it ends up associating the use of <code class="literal">++</code> to the left instead of to the right.</p><p>Because lists can sometimes be inefficient when repeatedly appended in this manner, it’s best to use a data structure that always supports efficient appending. One such data structure is the difference list.</p></div><div class="sect2" title="Using Difference Lists"><div class="titlepage"><div><div><h2 class="title"><a id="using_difference_lists"/>Using Difference Lists</h2></div></div></div><p>While similar to a normal list, a <span class="emphasis"><em>difference list</em></span> is actually a function that takes a list and prepends another list to it. For example, the difference list equivalent of a list like <code class="literal">[1,2,3]</code> is the function <code class="literal">\xs -&gt; [1,2,3] ++ xs</code>. A normal empty list is <code class="literal">[]</code>, whereas an empty difference list is the function <code class="literal">\xs -&gt; [] ++ xs</code>.</p><p>Difference lists support efficient appending. When we append two normal lists with <code class="literal">++</code>, the code must walk all the way to the end of the list on the left of <code class="literal">++</code>, and then stick the other one there. But what if we take the difference list approach and represent our lists as functions?</p><p>Appending two difference lists can be done like so:</p><a id="I_programlisting14_d1e28286"/><pre class="programlisting">f `append` g = \xs -&gt; f (g xs)</pre><p>Remember that <code class="literal">f</code> and <code class="literal">g</code> are functions that take lists and prepend something to them. For instance, if <code class="literal">f</code> is the function <code class="literal">("dog"++)</code> (just another way of writing <code class="literal">\xs -&gt; "dog" ++ xs</code>) and <code class="literal">g</code> is the function <code class="literal">("meat"++)</code>, then <code class="literal">f `append` g</code> makes a new function that’s equivalent to the following:</p><a id="I_programlisting14_d1e28315"/><pre class="programlisting">\xs -&gt; "dog" ++ ("meat" ++ xs)</pre><p>We’ve appended two difference lists just by making a new function that first applies one difference list to some list and then to the other.</p><p>Let’s make a <code class="literal">newtype</code> wrapper for difference lists so that we can easily give them monoid instances:</p><a id="I_programlisting14_d1e28324"/><pre class="programlisting">newtype DiffList a = DiffList { getDiffList :: [a] -&gt; [a] }</pre><p>The type that we wrap is <code class="literal">[a] -&gt; [a]</code>, because a difference list is just a function that takes a list and returns another list. Converting normal lists to difference lists and vice versa is easy:</p><a id="I_programlisting14_d1e28332"/><pre class="programlisting">toDiffList :: [a] -&gt; DiffList a
toDiffList xs = DiffList (xs++)

fromDiffList :: DiffList a -&gt; [a]
fromDiffList (DiffList f) = f []</pre><p>To make a normal list into a difference list, we just do what we did before and make it a function that prepends it to another list. Because a difference list is a function that prepends something to another list, if we just want that something, we apply the function to an empty list!</p><p>Here’s the <code class="literal">Monoid</code> instance:</p><a id="I_programlisting14_d1e28341"/><pre class="programlisting">instance Monoid (DiffList a) where
    mempty = DiffList (\xs -&gt; [] ++ xs)
    (DiffList f) `mappend` (DiffList g) = DiffList (\xs -&gt; f (g xs))</pre><p>Notice how for lists, <code class="literal">mempty</code> is just the <code class="literal">id</code> function, and <code class="literal">mappend</code> is actually just function composition. Let’s see if this works:</p><a id="I_programlisting14_d1e28354"/><pre class="programlisting">ghci&gt; fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])
[1,2,3,4,1,2,3]</pre><p>Tip-top! Now we can increase the efficiency of our <code class="literal">gcdReverse</code> function by making it use difference lists instead of normal lists:<a id="IDX-CHP-14-0051" class="indexterm"/><a id="IDX-CHP-14-0052" class="indexterm"/><a id="IDX-CHP-14-0053" class="indexterm"/></p><a id="I_programlisting14_d1e28374"/><pre class="programlisting">import Control.Monad.Writer

gcd' :: Int -&gt; Int -&gt; Writer (DiffList String) Int gcd' a b
    | b == 0 = do
        tell (toDiffList ["Finished with " ++ show a])
        return a
    | otherwise = do
        result &lt;- gcd' b (a `mod` b)
        tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
        return result</pre><p>We just needed to change the type of the monoid from <code class="literal">[String]</code> to <code class="literal">DiffList String</code> and then when using <code class="literal">tell</code>, convert our normal lists into difference lists with <code class="literal">toDiffList</code>. Let’s see if the log gets assembled properly:</p><a id="I_programlisting14_d1e28390"/><pre class="programlisting">ghci&gt; mapM_ putStrLn . fromDiffList . snd . runWriter $ gcdReverse 110 34
Finished with 2
8 mod 2 = 0
34 mod 8 = 2
110 mod 34 = 8</pre><p>We do <code class="literal">gcdReverse 110 34</code>, then use <code class="literal">runWriter</code> to unwrap it from the <code class="literal">newtype</code>, then apply <code class="literal">snd</code> to that to just get the log, then apply <code class="literal">fromDiffList</code> to convert it to a normal list, and, finally, print its entries to the screen.</p></div><div class="sect2" title="Comparing Performance"><div class="titlepage"><div><div><h2 class="title"><a id="comparing_performance"/>Comparing Performance</h2></div></div></div><p>To get a feel for just how much difference lists may improve your performance, consider the following function. It just counts down from some number to zero but produces its log in reverse, like <code class="literal">gcdReverse</code>, so that the numbers in the log will actually be counted up.<a id="IDX-CHP-14-0054" class="indexterm"/></p><a id="I_programlisting14_d1e28420"/><pre class="programlisting">finalCountDown :: Int -&gt; Writer (DiffList String) ()
finalCountDown 0 = do
    tell (toDiffList ["0"])
finalCountDown x = do
    finalCountDown (x-1)
    tell (toDiffList [show x])</pre><p>If we give it <code class="literal">0</code>, it just logs that value. For any other number, it first counts down its predecessor to <code class="literal">0</code>, and then appends that number to the log. So, if we apply <code class="literal">finalCountDown</code> to <code class="literal">100</code>, the string <code class="literal">"100"</code> will come last in the log.</p><p>If you load this function in GHCi and apply it to a big number, like <code class="literal">500000</code>, you’ll see that it quickly starts counting from <code class="literal">0</code> onward:<a id="IDX-CHP-14-0055" class="indexterm"/><a id="IDX-CHP-14-0056" class="indexterm"/></p><a id="I_programlisting14_d1e28455"/><pre class="programlisting">ghci&gt; mapM_ putStrLn . fromDiffList . snd . runWriter $ finalCountDown 500000
0
1
2
...</pre><p>However, if you change it to use normal lists instead of difference lists, like so:</p><a id="I_programlisting14_d1e28459"/><pre class="programlisting">finalCountDown :: Int -&gt; Writer [String] ()
finalCountDown 0 = do
    tell ["0"]
finalCountDown x = do
    finalCountDown (x-1)
    tell [show x]</pre><p>and then tell GHCi to start counting:</p><a id="I_programlisting14_d1e28463"/><pre class="programlisting">ghci&gt; mapM_ putStrLn . snd . runWriter $ finalCountDown 500000</pre><p>you’ll see that the counting is really slow.</p><p>Of course, this is not the proper and scientific way to test the speed of your programs. However, we were able to see that, in this case, using difference lists starts producing results immediately, whereas normal lists take forever.</p><p>Oh, by the way, the song “Final Countdown” by Europe is now stuck in your head. Enjoy!</p></div></div></div>
<div class="sect1" title="Reader? Ugh, Not This Joke Again"><div class="titlepage"><div><div><h1 class="title"><a id="reader_question_ugh_comma_not_this_joke"/>Reader? Ugh, Not This Joke Again</h1></div></div></div><p>In <a class="xref" href="ch11.html" title="Chapter 11. Applicative Functors">Chapter 11</a>, you saw that the function type <code class="literal">(-&gt;) r</code> is an instance of <code class="literal">Functor</code>. Mapping a function <code class="literal">f</code> over a function <code class="literal">g</code> will make a function that takes the same thing as <code class="literal">g</code>, applies <code class="literal">g</code> to it, and then applies <code class="literal">f</code> to that result. So basically, we’re making a new function that’s like <code class="literal">g</code>, but before returning its result, <code class="literal">f</code> is applied to that result as well. Here’s an example:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject14_d1e28508"/><img src="httpatomoreillycomsourcenostarchimages802706.png.jpg" alt="image with no caption"/></div></div><a id="I_programlisting14_d1e28513"/><pre class="programlisting">ghci&gt; let f = (*5)
ghci&gt; let g = (+3)
ghci&gt; (fmap f g) 8
55</pre><p>You’ve also seen that functions are applicative functors. They allow us to operate on the eventual results of functions as if we already had their results. Here’s an example:<a id="IDX-CHP-14-0057" class="indexterm"/><a id="IDX-CHP-14-0058" class="indexterm"/><a id="IDX-CHP-14-0059" class="indexterm"/><a id="IDX-CHP-14-0060" class="indexterm"/><a id="IDX-CHP-14-0061" class="indexterm"/><a id="IDX-CHP-14-0062" class="indexterm"/><a id="IDX-CHP-14-0063" class="indexterm"/></p><a id="I_programlisting14_d1e28546"/><pre class="programlisting">ghci&gt; let f = (+) &lt;$&gt; (*2) &lt;*&gt; (+10)
ghci&gt; f 3
19</pre><p>The expression <code class="literal">(+) &lt;$&gt; (*2) &lt;*&gt; (+10)</code> makes a function that takes a number, gives that number to <code class="literal">(*2)</code> and <code class="literal">(+10)</code>, and then adds together the results. For instance, if we apply this function to <code class="literal">3</code>, it applies both <code class="literal">(*2)</code> and <code class="literal">(+10)</code> to <code class="literal">3</code>, giving <code class="literal">6</code> and <code class="literal">13</code>. Then it calls <code class="literal">(+)</code> with <code class="literal">6</code> and <code class="literal">13</code>, and the result is <code class="literal">19</code>.</p><div class="sect2" title="Functions As Monads"><div class="titlepage"><div><div><h2 class="title"><a id="functions_as_monads"/>Functions As Monads</h2></div></div></div><p>Not only is the function type <code class="literal">(-&gt;) r</code> a functor and an applicative functor, but it’s also a monad. Just like other monadic values that you’ve met so far, a function can also be considered a value with a context. The context for functions is that that value is not present yet and that we need to apply that function to something in order to get its result.</p><p>Because you’re already acquainted with how functions work as functors and applicative functors, let’s dive right in and see what their <code class="literal">Monad</code> instance looks like. It’s located in <code class="literal">Control.Monad.Instances</code>, and it goes a little something like this:<a id="IDX-CHP-14-0064" class="indexterm"/></p><a id="I_programlisting14_d1e28612"/><pre class="programlisting">instance Monad ((-&gt;) r) where
    return x = \_ -&gt; x
    h &gt;&gt;= f = \w -&gt; f (h w) w</pre><p>You’ve seen how <code class="literal">pure</code> is implemented for functions, and <code class="literal">return</code> is pretty much the same thing as <code class="literal">pure</code>. It takes a value and puts it in a minimal context that always has that value as its result. And the only way to make a function that always has a certain value as its result is to make it completely ignore its parameter.</p><p>The implementation for <code class="literal">&gt;&gt;=</code> may seem a bit cryptic, but it’s really not all that complicated. When we use <code class="literal">&gt;&gt;=</code> to feed a monadic value to a function, the result is always a monadic value. So, in this case, when we feed a function to another function, the result is a function as well. That’s why the result starts off as a lambda.</p><p>All of the implementations of <code class="literal">&gt;&gt;=</code> so far somehow isolated the result from the monadic value and then applied the function <code class="literal">f</code> to that result. The same thing happens here. To get the result from a function, we need to apply it to something, which is why we use <code class="literal">(h w)</code> here, and then we apply <code class="literal">f</code> to that. <code class="literal">f</code> returns a monadic value, which is a function in our case, so we apply it to <code class="literal">w</code> as well.</p></div><div class="sect2" title="The Reader Monad"><div class="titlepage"><div><div><h2 class="title"><a id="the_reader_monad"/>The Reader Monad</h2></div></div></div><p>If you don’t get how <code class="literal">&gt;&gt;=</code> works at this point, don’t worry. After a few examples, you’ll see that this is a really simple monad. Here’s a <code class="literal">do</code> expression that utilizes it:<a id="IDX-CHP-14-0065" class="indexterm"/><a id="IDX-CHP-14-0066" class="indexterm"/><a id="IDX-CHP-14-0067" class="indexterm"/></p><a id="I_programlisting14_d1e28678"/><pre class="programlisting">import Control.Monad.Instances

addStuff :: Int -&gt; Int
addStuff = do
    a &lt;- (*2)
    b &lt;- (+10)
    return (a+b)</pre><p>This is the same thing as the applicative expression that we wrote earlier, but now it relies on functions being monads. A <code class="literal">do</code> expression always results in a monadic value, and this one is no different. The result of this monadic value is a function. It takes a number, then <code class="literal">(*2)</code> is applied to that number, and the result becomes <code class="literal">a</code>. <code class="literal">(+10)</code> is applied to the same number that <code class="literal">(*2)</code> was applied to, and the result becomes <code class="literal">b</code>. <code class="literal">return</code>, as in other monads, doesn’t have any effect but to make a monadic value that presents some result. This presents <code class="literal">a+b</code> as the result of this function. If we test it, we get the same result as before:</p><a id="I_programlisting14_d1e28707"/><pre class="programlisting">ghci&gt; addStuff 3
19</pre><p>Both <code class="literal">(*2)</code> and <code class="literal">(+10)</code> are applied to the number <code class="literal">3</code> in this case. <code class="literal">return (a+b)</code> does as well, but it ignores that value and always presents <code class="literal">a+b</code> as the result. For this reason, the function monad is also called the <span class="emphasis"><em>reader monad</em></span>. All the functions read from a common source. To make this even clearer, we can rewrite <code class="literal">addStuff</code> like so:</p><a id="I_programlisting14_d1e28733"/><pre class="programlisting">addStuff :: Int -&gt; Int
addStuff x = let
    a = (*2) x
    b = (+10) x
    in a+b</pre><p>You see that the reader monad allows us to treat functions as values with a context. We can act as if we already know what the functions will return. It does this by gluing functions together into one function and then giving that function’s parameter to all of the functions that compose it. So, if we have a lot of functions that are all just missing one parameter, and they will eventually be applied to the same thing, we can use the reader monad to sort of extract their future results, and the <code class="literal">&gt;&gt;=</code> implementation will make sure that it all works out.</p></div></div>
<div class="sect1" title="Tasteful Stateful Computations"><div class="titlepage"><div><div><h1 class="title"><a id="tasteful_stateful_computations"/>Tasteful Stateful Computations</h1></div></div></div><p>Haskell is a pure language, and because of that, our programs are made of functions that can’t change any global state or variables; they can only do some computations and return the results. This restriction actually makes it easier to think about our programs, as it frees us from worrying what every variable’s value is at some point in time.<a id="IDX-CHP-14-0068" class="indexterm"/><a id="IDX-CHP-14-0069" class="indexterm"/><a id="IDX-CHP-14-0070" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject14_d1e28757"/><img src="httpatomoreillycomsourcenostarchimages802708.png.jpg" alt="image with no caption"/></div></div><p>However, some problems are inherently stateful, in that they rely on some state that changes over time. While this isn’t a problem for Haskell, these computations can be a bit tedious to model. That’s why Haskell features the <code class="literal">State</code> monad, which makes dealing with stateful problems a breeze, while still keeping everything nice and pure.</p><p>When we were looking at random numbers back in <a class="xref" href="ch09.html" title="Chapter 9. More Input and More Output">Chapter 9</a>, we dealt with functions that took a random generator as a parameter and returned a random number and a new random generator. If we wanted to generate several random numbers, we always needed to use the random generator that a previous function returned along with its result. For example, to create a function that takes a <code class="literal">StdGen</code> and tosses a coin three times based on that generator, we did this:</p><a id="I_programlisting14_d1e28774"/><pre class="programlisting">threeCoins :: StdGen -&gt; (Bool, Bool, Bool)
threeCoins gen =
    let (firstCoin, newGen) = random gen
        (secondCoin, newGen') = random newGen
        (thirdCoin, newGen'') = random newGen'
    in  (firstCoin, secondCoin, thirdCoin)</pre><p>This function takes a generator <code class="literal">gen</code>, and then <code class="literal">random gen</code> returns a <code class="literal">Bool</code> value along with a new generator. To throw the second coin, we use the new generator, and so on.</p><p>In most other languages, we wouldn’t need to return a new generator along with a random number. We could just modify the existing one! But since Haskell is pure, we can’t do that, so we need to take some state, make a result from it and a new state, and then use that new state to generate new results.</p><p>You would think that to avoid manually dealing with stateful computations in this way, we would need to give up the purity of Haskell. Well, we don’t have to, since there’s a special little monad called the <code class="literal">State</code> monad that handles all this state business for us, without impacting any of the purity that makes Haskell programming so cool.<a id="IDX-CHP-14-0071" class="indexterm"/></p><div class="sect2" title="Stateful Computations"><div class="titlepage"><div><div><h2 class="title"><a id="stateful_computations"/>Stateful Computations</h2></div></div></div><p>To help demonstrate stateful computations, let’s go ahead and give them a type. We’ll say that a stateful computation is a function that takes some state and returns a value along with some new state. That function has the following type:<a id="IDX-CHP-14-0072" class="indexterm"/><a id="IDX-CHP-14-0073" class="indexterm"/><a id="IDX-CHP-14-0074" class="indexterm"/><a id="IDX-CHP-14-0075" class="indexterm"/><a id="IDX-CHP-14-0076" class="indexterm"/><a id="IDX-CHP-14-0077" class="indexterm"/><a id="IDX-CHP-14-0078" class="indexterm"/></p><a id="I_programlisting14_d1e28833"/><pre class="programlisting">s -&gt; (a, s)</pre><p><code class="literal">s</code> is the type of the state, and <code class="literal">a</code> is the result of the stateful computations.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Assignment in most other languages could be thought of as a stateful computation. For instance, when we do <code class="literal">x = 5</code> in an imperative language, it will usually assign the value <code class="literal">5</code> to the variable <code class="literal">x</code>, and it will also have the value <code class="literal">5</code> as an expression. If you look at that functionally, it’s like a function that takes a state (that is, all the variables that have been assigned previously) and returns a result (in this case, <code class="literal">5</code>) and a new state, which would be all the previous variable mappings plus the newly assigned variable.</p></div><p>This stateful computation—a function that takes a state and returns a result and a new state—can be thought of as a value with a context as well. The actual value is the result, whereas the context is that we must provide some initial state to actually get that result, and that apart from getting a result, we also get a new state.</p></div><div class="sect2" title="Stacks and Stones"><div class="titlepage"><div><div><h2 class="title"><a id="stacks_and_stones"/>Stacks and Stones</h2></div></div></div><p>Say we want to model a stack. A <span class="emphasis"><em>stack</em></span> is a data structure that contains a bunch of elements and supports exactly two operations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Pushing</em></span> an element to the stack, which adds an element onto the top of the stack</p></li><li class="listitem"><p><span class="emphasis"><em>Popping</em></span> an element off the stack, which removes the topmost element from the stack</p></li></ul></div><p>We’ll use a list to represent our stack, with the head of the list acting as the top of the stack. To help us with our task, we’ll make two functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">pop</code> will take a stack, pop one item, and return that item as the result. It will also return a new stack, without the popped item.</p></li><li class="listitem"><p><code class="literal">push</code> will take an item and a stack and then push that item onto the stack. It will return <code class="literal">()</code> as its result, along with a new stack.</p></li></ul></div><p>Here are the functions in use:</p><a id="I_programlisting14_d1e28899"/><pre class="programlisting">type Stack = [Int]

pop :: Stack -&gt; (Int, Stack)
pop (x:xs) = (x, xs)

push :: Int -&gt; Stack -&gt; ((), Stack)
push a xs = ((), a:xs)</pre><p>We used <code class="literal">()</code> as the result when pushing to the stack because pushing an item onto the stack doesn’t have any important result value—its main job is to change the stack. If we apply only the first parameter of <code class="literal">push</code>, we get a stateful computation. <code class="literal">pop</code> is already a stateful computation because of its type.</p><p>Let’s write a small piece of code to simulate a stack using these functions. We’ll take a stack, push <code class="literal">3</code> to it, and then pop two items, just for kicks. Here it is:<a id="IDX-CHP-14-0079" class="indexterm"/></p><a id="I_programlisting14_d1e28922"/><pre class="programlisting">stackManip :: Stack -&gt; (Int, Stack)
stackManip stack = let
    ((), newStack1) = push 3 stack
    (a , newStack2) = pop newStack1
    in pop newStack2</pre><p>We take a <code class="literal">stack</code>, and then we do <code class="literal">push 1 stack</code>, which results in a tuple. The first part of the tuple is a <code class="literal">()</code>, and the second is a new stack, which we call <code class="literal">newStack1</code>. Then we pop a number from <code class="literal">newStack1</code>, which results in a number <code class="literal">a</code> (which is the <code class="literal">3</code>) that we pushed and a new stack, which we call <code class="literal">newStack2</code>. Then we pop a number off <code class="literal">newStack2</code>, and we get a number that’s <code class="literal">b</code> and a <code class="literal">newStack3</code>. We return a tuple with that number and that stack. Let’s try it out:</p><a id="I_programlisting14_d1e28961"/><pre class="programlisting">ghci&gt; stackManip [5,8,2,1]
(5,[8,2,1])</pre><p>The result is <code class="literal">5</code>, and the new stack is <code class="literal">[8,2,1]</code>. Notice how <code class="literal">stackManip</code> is itself a stateful computation. We’ve taken a bunch of stateful computations and sort of glued them together. Hmm, sounds familiar.</p><p>The preceding code for <code class="literal">stackManip</code> is kind of tedious, since we’re manually giving the state to every stateful computation and storing it and then giving it to the next one. Wouldn’t it be cooler if, instead of giving the stack manually to each function, we could write something like the following?</p><a id="I_programlisting14_d1e28979"/><pre class="programlisting">stackManip = do
    push 3
    a &lt;- pop
    pop</pre><p>Well, using the <code class="literal">State</code> monad will allow us to do exactly that. With it, we will be able to take stateful computations like these and use them without needing to manage the state manually.</p></div><div class="sect2" title="The State Monad"><div class="titlepage"><div><div><h2 class="title"><a id="the_state_monad"/>The State Monad</h2></div></div></div><p>The <code class="literal">Control.Monad.State</code> module provides a <code class="literal">newtype</code> that wraps stateful computations. Here’s its definition:<a id="IDX-CHP-14-0080" class="indexterm"/><a id="IDX-CHP-14-0081" class="indexterm"/><a id="IDX-CHP-14-0082" class="indexterm"/></p><a id="I_programlisting14_d1e29013"/><pre class="programlisting">newtype State s a = State { runState :: s -&gt; (a, s) }</pre><p>A <code class="literal">State s a</code> is a stateful computation that manipulates a state of type <code class="literal">s</code> and has a result of type <code class="literal">a</code>.</p><p>Much like <code class="literal">Control.Monad.Writer</code>, <code class="literal">Control.Monad.State</code> doesn’t export its value constructor. If you want to take a stateful computation and wrap it in the <code class="literal">State newtype</code>, use the <code class="literal">state</code> function, which does the same thing that the <code class="literal">State</code> constructor would do.</p><p>Now that you’ve seen what stateful computations are about and how they can even be thought of as values with contexts, let’s check out their <code class="literal">Monad</code> instance:</p><a id="I_programlisting14_d1e29048"/><pre class="programlisting">instance Monad (State s) where
    return x = State $ \s -&gt; (x, s)
    (State h) &gt;&gt;= f = State $ \s -&gt; let (a, newState) = h s
                                        (State g) = f a
                                    in  g newState</pre><p>Our aim with <code class="literal">return</code> is to take a value and make a stateful computation that always has that value as its result. That’s why we just make a lambda <code class="literal">\s -&gt; (x, s)</code>. We always present <code class="literal">x</code> as the result of the stateful computation, and the state is kept unchanged, because <code class="literal">return</code> must put a value in a minimal context. So <code class="literal">return</code> will make a stateful computation that presents a certain value as the result and keeps the state unchanged.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject14_d1e29068"/><img src="httpatomoreillycomsourcenostarchimages802710.png" alt="image with no caption"/></div></div><p>What about <code class="literal">&gt;&gt;=</code>? Well, the result of feeding a stateful computation to a function with <code class="literal">&gt;&gt;=</code> must be a stateful computation, right? So, we start of with the <code class="literal">State newtype</code> wrapper, and then we type out a lambda. This lambda will be our new stateful computation. But what goes on in it? Well, we need to somehow extract the result value from the first stateful computation. Because we’re in a stateful computation right now, we can give the stateful computation <code class="literal">h</code> our current state <code class="literal">s</code>, which results in a pair of the result and a new state: <code class="literal">(a, newState)</code>.</p><p>So far, every time we implemented <code class="literal">&gt;&gt;=</code>, once we had extracted just the result from the monadic value, we applied the function <code class="literal">f</code> to it to get the new monadic value. In <code class="literal">Writer</code>, after doing that and getting the new monadic value, we still need to make sure that the context is taken care of by <code class="literal">mappend</code>ing the old monoid value with the new one. Here, we do <code class="literal">f a</code>, and we get a new stateful computation <code class="literal">g</code>. Now that we have a new stateful computation and a new state (which goes by the name of <code class="literal">newState</code>), we just apply that stateful computation <code class="literal">g</code> to the <code class="literal">newState</code>. The result is a tuple of the final result and final state!<a id="IDX-CHP-14-0083" class="indexterm"/><a id="IDX-CHP-14-0084" class="indexterm"/></p><p>So, with <code class="literal">&gt;&gt;=</code>, we kind of glue two stateful computations together. The second computation is hidden inside a function that takes the previous computation’s result. Because <code class="literal">pop</code> and <code class="literal">push</code> are already stateful computations, it’s easy to wrap them into a <code class="literal">State</code> wrapper:</p><a id="I_programlisting14_d1e29145"/><pre class="programlisting">import Control.Monad.State

pop :: State Stack Int
pop = state $ \(x:xs) -&gt; (x, xs)

push :: Int -&gt; State Stack ()
push a = state $ \xs -&gt; ((), a:xs)</pre><p>Notice how we used the <code class="literal">state</code> function to wrap a function into the <code class="literal">State newtype</code> instead of using the <code class="literal">State</code> value constructor directly.</p><p><code class="literal">pop</code> is already a stateful computation, and <code class="literal">push</code> takes an <code class="literal">Int</code> and returns a stateful computation. Now we can rewrite our previous example of pushing <code class="literal">3</code> onto the stack and then popping two numbers off, like this:</p><a id="I_programlisting14_d1e29171"/><pre class="programlisting">import Control.Monad.State

stackManip :: State Stack Int
stackManip = do
    push 3
    a &lt;- pop
    pop</pre><p>See how we’ve glued a push and two pops into one stateful computation? When we unwrap it from its <code class="literal">newtype</code> wrapper, we get a function to which we can provide some initial state:</p><a id="I_programlisting14_d1e29178"/><pre class="programlisting">ghci&gt; runState stackManip [5,8,2,1]
(5,[8,2,1])</pre><p>We didn’t need to bind the second <code class="literal">pop</code> to <code class="literal">a</code>, because we didn’t use that <code class="literal">a</code> at all. So, we could have written it like this:</p><a id="I_programlisting14_d1e29191"/><pre class="programlisting">stackManip :: State Stack Int
stackManip = do
    push 3
    pop
    pop</pre><p>Pretty cool. But what if we want to do something a little more complicated? Let’s say we want to pop one number off the stack, and if that number is <code class="literal">5</code>, we’ll just push it back on the stack and stop. But if the number <span class="emphasis"><em>isn’t</em></span> <code class="literal">5</code>, we’ll push <code class="literal">3</code> and <code class="literal">8</code> back on instead. Here’s the code:<a id="IDX-CHP-14-0085" class="indexterm"/><a id="IDX-CHP-14-0086" class="indexterm"/><a id="IDX-CHP-14-0087" class="indexterm"/><a id="IDX-CHP-14-0088" class="indexterm"/><a id="IDX-CHP-14-0089" class="indexterm"/></p><a id="I_programlisting14_d1e29228"/><pre class="programlisting">stackStuff :: State Stack ()
stackStuff = do
    a &lt;- pop
    if a == 5
        then push 5
        else do
            push 3
            push 8</pre><p>This is quite straightforward. Let’s run it with an initial stack:</p><a id="I_programlisting14_d1e29233"/><pre class="programlisting">ghci&gt; runState stackStuff [9,0,2,1,0]
((),[8,3,0,2,1,0])</pre><p>Remember that <code class="literal">do</code> expressions result in monadic values, and with the <code class="literal">State</code> monad, a single <code class="literal">do</code> expression is also a stateful function. Because <code class="literal">stackManip</code> and <code class="literal">stackStuff</code> are ordinary stateful computations, we can glue them together to produce further stateful computations:</p><a id="I_programlisting14_d1e29252"/><pre class="programlisting">moreStack :: State Stack ()
moreStack = do
    a &lt;- stackManip
    if a == 100
        then stackStuff
        else return ()</pre><p>If the result of <code class="literal">stackManip</code> on the current stack is <code class="literal">100</code>, we run <code class="literal">stackStuff</code>; otherwise, we do nothing. <code class="literal">return ()</code> just keeps the state as it is and does nothing.</p></div><div class="sect2" title="Getting and Setting State"><div class="titlepage"><div><div><h2 class="title"><a id="getting_and_setting_state"/>Getting and Setting State</h2></div></div></div><p>The <code class="literal">Control.Monad.State</code> module provides a type class called <code class="literal">MonadState</code>, which features two pretty useful functions: <code class="literal">get</code> and <code class="literal">put</code>. For <code class="literal">State</code>, the <code class="literal">get</code> function is implemented like this:</p><a id="I_programlisting14_d1e29292"/><pre class="programlisting">get = state $ \s -&gt; (s, s)</pre><p>It just takes the current state and presents it as the result.</p><p>The <code class="literal">put</code> function takes some state and makes a stateful function that replaces the current state with it:</p><a id="I_programlisting14_d1e29301"/><pre class="programlisting">put newState = state $ \s -&gt; ((), newState)</pre><p>So, with these, we can see what the current stack is or we can replace it with a whole other stack, like so:</p><a id="I_programlisting14_d1e29305"/><pre class="programlisting">stackyStack :: State Stack ()
stackyStack = do
    stackNow &lt;- get
    if stackNow == [1,2,3]
        then put [8,3,1]
        else put [9,2,1]</pre><p>We can also use <code class="literal">get</code> and <code class="literal">put</code> to implement <code class="literal">pop</code> and <code class="literal">push</code>. Here’s <code class="literal">pop</code>:</p><a id="I_programlisting14_d1e29324"/><pre class="programlisting">pop :: State Stack Int
pop = do
    (x:xs) &lt;- get
    put xs
    return x</pre><p>We use <code class="literal">get</code> to get the whole stack, and then we use <code class="literal">put</code> to make everything but the top element the new state. Then we use <code class="literal">return</code> to present <code class="literal">x</code> as the result.</p><p>Here’s <code class="literal">push</code> implemented with <code class="literal">get</code> and <code class="literal">put</code>:</p><a id="I_programlisting14_d1e29352"/><pre class="programlisting">push :: Int -&gt; State Stack ()
push x = do
    xs &lt;- get
    put (x:xs)</pre><p>We just use <code class="literal">get</code> to get the current stack and use <code class="literal">put</code> to make the set the new state as our stack, with the element <code class="literal">x</code> on top.</p><p>It’s worth examining what the type of <code class="literal">&gt;&gt;=</code> would be if it worked only for <code class="literal">State</code> values:</p><a id="I_programlisting14_d1e29373"/><pre class="programlisting">(&gt;&gt;=) :: State s a -&gt; (a -&gt; State s b) -&gt; State s b</pre><p>See how the type of the state <code class="literal">s</code> stays the same, but the type of the result can change from <code class="literal">a</code> to <code class="literal">b</code>? This means that we can glue together several stateful computations whose results are of different types, but the type of the state must stay the same. Now why is that? Well, for instance, for <code class="literal">Maybe</code>, <code class="literal">&gt;&gt;=</code> has this type:</p><a id="I_programlisting14_d1e29392"/><pre class="programlisting">(&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b</pre><p>It makes sense that the monad itself, <code class="literal">Maybe</code>, doesn’t change. It wouldn’t make sense to use <code class="literal">&gt;&gt;=</code> between two different monads. Well, for the <code class="literal">State</code> monad, the monad is actually <code class="literal">State s</code>, so if that <code class="literal">s</code> were different, we would be using <code class="literal">&gt;&gt;=</code> between two different monads.</p></div><div class="sect2" title="Randomness and the State Monad"><div class="titlepage"><div><div><h2 class="title"><a id="randomness_and_the_state_monad"/>Randomness and the State Monad</h2></div></div></div><p>At the beginning of this section, we talked about how generating random numbers can sometimes be awkward. Every random function takes a generator and returns a random number along with a new generator, which must then be used instead of the old one if we want to generate another random number. The <code class="literal">State</code> monad makes dealing with this a lot easier.<a id="IDX-CHP-14-0090" class="indexterm"/><a id="IDX-CHP-14-0091" class="indexterm"/><a id="IDX-CHP-14-0092" class="indexterm"/><a id="IDX-CHP-14-0093" class="indexterm"/></p><p>The <code class="literal">random</code> function from <code class="literal">System.Random</code> has the following type:</p><a id="I_programlisting14_d1e29445"/><pre class="programlisting">random :: (RandomGen g, Random a) =&gt; g -&gt; (a, g)</pre><p>This means it takes a random generator and produces a random number along with a new generator. We can see that it’s a stateful computation, so we can wrap it in the <code class="literal">State newtype</code> constructor by using the <code class="literal">state</code> function, and then use it as a monadic value so that passing the state is handled for us:</p><a id="I_programlisting14_d1e29455"/><pre class="programlisting">import System.Random
import Control.Monad.State

randomSt :: (RandomGen g, Random a) =&gt; State g a
randomSt = state random</pre><p>So, now if we want to throw three coins (<code class="literal">True</code> is tails, and <code class="literal">False</code> is heads), we just do the following:</p><a id="I_programlisting14_d1e29465"/><pre class="programlisting">import System.Random
import Control.Monad.State

threeCoins :: State StdGen (Bool, Bool, Bool)
threeCoins = do
    a &lt;- randomSt
    b &lt;- randomSt
    c &lt;- randomSt
    return (a, b, c)</pre><p><code class="literal">threeCoins</code> is now a stateful computation, and after taking an initial random generator, it passes that generator to the first <code class="literal">randomSt</code>, which produces a number and a new generator, which is passed to the next one, and so on. We use <code class="literal">return (a, b, c)</code> to present <code class="literal">(a, b, c)</code> as the result without changing the most recent generator. Let’s give this a go:</p><a id="I_programlisting14_d1e29480"/><pre class="programlisting">ghci&gt; runState threeCoins (mkStdGen 33)
((True,False,True),680029187 2103410263)</pre><p>Now doing things that require some state to be saved in between steps just became much less of a hassle!</p></div></div>
<div class="sect1" title="Error Error on the Wall"><div class="titlepage"><div><div><h1 class="title"><a id="error_error_on_the_wall"/>Error Error on the Wall</h1></div></div></div><p>You know by now that <code class="literal">Maybe</code> is used to add a context of possible failure to values. A value can be a <code class="literal">Just something</code> or a <code class="literal">Nothing</code>. However useful it may be, when we have a <code class="literal">Nothing</code>, all we know is that there was some sort of failure—there’s no way to cram more information in there telling us what kind of failure it was.<a id="IDX-CHP-14-0094" class="indexterm"/><a id="IDX-CHP-14-0095" class="indexterm"/><a id="IDX-CHP-14-0096" class="indexterm"/><a id="IDX-CHP-14-0097" class="indexterm"/><a id="IDX-CHP-14-0098" class="indexterm"/></p><p>The <code class="literal">Either e a</code> type also allows us to incorporate a context of possible failure into our values. It also lets us attach values to the failure, so they can describe what went wrong or provide other useful information regarding the failure. An <code class="literal">Either e a</code> value can either be a <code class="literal">Right</code> value, signifying the right answer and a success, or it can be a <code class="literal">Left</code> value, signifying failure. Here’s an example:</p><a id="I_programlisting14_d1e29533"/><pre class="programlisting">ghci&gt; :t Right 4
Right 4 :: (Num t) =&gt; Either a t
ghci&gt; :t Left "out of cheese error"
Left "out of cheese error" :: Either [Char] b</pre><p>This is pretty much just an enhanced <code class="literal">Maybe</code>, so it makes sense for it to be a monad. It can also be viewed as a value with an added context of possible failure, but now there’s a value attached when there’s an error as well.</p><p>Its <code class="literal">Monad</code> instance is similar to that of <code class="literal">Maybe</code>, and it can be found in <code class="literal">Control.Monad.Error</code>:</p><a id="I_programlisting14_d1e29551"/><pre class="programlisting">instance (Error e) =&gt; Monad (Either e) where
    return x = Right x
    Right x &gt;&gt;= f = f x
    Left err &gt;&gt;= f = Left err
    fail msg = Left (strMsg msg)</pre><p><code class="literal">return</code>, as always, takes a value and puts it in a default minimal context. It wraps our value in the <code class="literal">Right</code> constructor because we’re using <code class="literal">Right</code> to represent a successful computation where a result is present. This is a lot like <code class="literal">return</code> for <code class="literal">Maybe</code>.</p><p>The <code class="literal">&gt;&gt;=</code> examines two possible cases: a <code class="literal">Left</code> and a <code class="literal">Right</code>. In the case of a <code class="literal">Right</code>, the function <code class="literal">f</code> is applied to the value inside it, similar to the case of a <code class="literal">Just</code> where the function is just applied to its contents. In the case of an error, the <code class="literal">Left</code> value is kept, along with its contents, which describe the failure.</p><p>The <code class="literal">Monad</code> instance for <code class="literal">Either e</code> has an additional requirement. The type of the value contained in a <code class="literal">Left</code>—the one that’s indexed by the <code class="literal">e</code> type parameter—must be an instance of the <code class="literal">Error</code> type class. The <code class="literal">Error</code> type class is for types whose values can act like error messages. It defines the <code class="literal">strMsg</code> function, which takes an error in the form of a string and returns such a value. A good example of an <code class="literal">Error</code> instance is the <code class="literal">String</code> type! In the case of <code class="literal">String</code>, the <code class="literal">strMsg</code> function just returns the string that it got:<a id="IDX-CHP-14-0099" class="indexterm"/><a id="IDX-CHP-14-0100" class="indexterm"/><a id="IDX-CHP-14-0101" class="indexterm"/></p><a id="I_programlisting14_d1e29639"/><pre class="programlisting">ghci&gt; :t strMsg
strMsg :: (Error a) =&gt; String -&gt; a
ghci&gt; strMsg "boom!" :: String
"boom!"</pre><p>But since we usually use <code class="literal">String</code> to describe the error when using <code class="literal">Either</code>, we don’t need to worry about this too much. When a pattern match fails in <code class="literal">do</code> notation, a <code class="literal">Left</code> value is used to signify this failure.</p><p>Here are a few examples of usage:</p><a id="I_programlisting14_d1e29658"/><pre class="programlisting">ghci&gt; Left "boom" &gt;&gt;= \x -&gt; return (x+1)
Left "boom"
ghci&gt; Left "boom " &gt;&gt;= \x -&gt; Left "no way!"
Left "boom "
ghci&gt; Right 100 &gt;&gt;= \x -&gt; Left "no way!"
Left "no way!"</pre><p>When we use <code class="literal">&gt;&gt;=</code> to feed a <code class="literal">Left</code> value to a function, the function is ignored and an identical <code class="literal">Left</code> value is returned. When we feed a <code class="literal">Right</code> value to a function, the function is applied to what’s on the inside, but in this case, that function produced a <code class="literal">Left</code> value anyway!</p><p>When we try to feed a <code class="literal">Right</code> value to a function that also succeeds, we’re tripped up by a peculiar type error. Hmmm.</p><a id="I_programlisting14_d1e29682"/><pre class="programlisting">ghci&gt; Right 3 &gt;&gt;= \x -&gt; return (x + 100)

&lt;interactive&gt;:1:0:
    Ambiguous type variable `a' in the constraints:
      `Error a' arising from a use of `it' at &lt;interactive&gt;:1:0-33
      `Show a' arising from a use of `print' at &lt;interactive&gt;:1:0-33
    Probable fix: add a type signature that fixes these type variable(s)</pre><p>Haskell says that it doesn’t know which type to choose for the <code class="literal">e</code> part of our <code class="literal">Either e a</code>-typed value, even though we’re just printing the <code class="literal">Right</code> part. This is due to the <code class="literal">Error e</code> constraint on the <code class="literal">Monad</code> instance. So, if you get type errors like this one when using <code class="literal">Either</code> as a monad, just add an explicit type signature:</p><a id="I_programlisting14_d1e29705"/><pre class="programlisting">ghci&gt; Right 3 &gt;&gt;= \x -&gt; return (x + 100) :: Either String Int
Right 103</pre><p>And now it works!<a id="IDX-CHP-14-0102" class="indexterm"/><a id="IDX-CHP-14-0103" class="indexterm"/><a id="IDX-CHP-14-0104" class="indexterm"/><a id="IDX-CHP-14-0105" class="indexterm"/><a id="IDX-CHP-14-0106" class="indexterm"/></p><p>Other than this little hang-up, using the error monad is very similar to using <code class="literal">Maybe</code> as a monad.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>In the previous chapter, we used the monadic aspects of <code class="literal">Maybe</code> to simulate birds landing on the balancing pole of a tightrope walker. As an exercise, you can rewrite that with the error monad so that when the tightrope walker slips and falls, you remember how many birds were on each side of the pole when he fell.</p></div></div>
<div class="sect1" title="Some Useful Monadic Functions"><div class="titlepage"><div><div><h1 class="title"><a id="some_useful_monadic_functions"/>Some Useful Monadic Functions</h1></div></div></div><p>In this section, we’re going to explore a few functions that operate on monadic values or return monadic values as their results (or both!). Such functions are usually referred to as <span class="emphasis"><em>monadic functions</em></span>. While some of them will be brand new, others will be monadic counterparts of functions that you already know, like <code class="literal">filter</code> and <code class="literal">foldl</code>. Here, we’ll look at <code class="literal">liftM</code>, <code class="literal">join</code>, <code class="literal">filterM</code>, and <code class="literal">foldM</code>.</p><div class="sect2" title="liftM and Friends"><div class="titlepage"><div><div><h2 class="title"><a id="liftm_and_friends"/>liftM and Friends</h2></div></div></div><p>When we started our journey to the top of Monad Mountain, we first looked at <span class="emphasis"><em>functors</em></span>, which are for things that can be mapped over. Then we covered improved functors called <span class="emphasis"><em>applicative functors</em></span>, which allow us to apply normal functions between several applicative values as well as to take a normal value and put it in some default context. Finally, we introduced <span class="emphasis"><em>monads</em></span> as improved applicative functors, which add the ability for these values with context to somehow be fed into normal functions.<a id="IDX-CHP-14-0107" class="indexterm"/><a id="IDX-CHP-14-0108" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject14_d1e29787"/><img src="httpatomoreillycomsourcenostarchimages802712.png.jpg" alt="image with no caption"/></div></div><p>So, every monad is an applicative functor, and every applicative functor is a functor. The <code class="literal">Applicative</code> type class has a class constraint such that our type must be an instance of <code class="literal">Functor</code> before we can make it an instance of <code class="literal">Applicative</code>. <code class="literal">Monad</code> should have the same constraint for <code class="literal">Applicative</code>, as every monad is an applicative functor, but it doesn’t, because the <code class="literal">Monad</code> type class was introduced to Haskell long before <code class="literal">Applicative</code>.</p><p>But even though every monad is a functor, we don’t need to rely on it having a <code class="literal">Functor</code> instance because of the <code class="literal">liftM</code> function. <code class="literal">liftM</code> takes a function and a monadic value and maps the function over the monadic value. So it’s pretty much the same thing as <code class="literal">fmap</code>! This is <code class="literal">liftM</code>’s type:</p><a id="I_programlisting14_d1e29833"/><pre class="programlisting">liftM :: (Monad m) =&gt; (a -&gt; b) -&gt; m a -&gt; m b</pre><p>And this is the type of <code class="literal">fmap</code>:<a id="IDX-CHP-14-0109" class="indexterm"/></p><a id="I_programlisting14_d1e29845"/><pre class="programlisting">fmap :: (Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b</pre><p>If the <code class="literal">Functor</code> and <code class="literal">Monad</code> instances for a type obey the functor and monad laws, these two amount to the same thing (and all the monads that we’ve met so far obey both). This is kind of like <code class="literal">pure</code> and <code class="literal">return</code> do the same thing, but one has an <code class="literal">Applicative</code> class constraint, whereas the other has a <code class="literal">Monad</code> constraint. Let’s try out <code class="literal">liftM</code>:</p><a id="I_programlisting14_d1e29871"/><pre class="programlisting">ghci&gt; liftM (*3) (Just 8)
Just 24
ghci&gt; fmap (*3) (Just 8)
Just 24
ghci&gt; runWriter $ liftM not $ Writer (True, "chickpeas")
(False,"chickpeas")
ghci&gt; runWriter $ fmap not $ Writer (True, "chickpeas")
(False,"chickpeas")
ghci&gt; runState (liftM (+100) pop) [1,2,3,4]
(101,[2,3,4])
ghci&gt; runState (fmap (+100) pop) [1,2,3,4]
(101,[2,3,4])</pre><p>You already know quite well how <code class="literal">fmap</code> works with <code class="literal">Maybe</code> values. And <code class="literal">liftM</code> does the same thing. For <code class="literal">Writer</code> values, the function is mapped over the first component of the tuple, which is the result. Running <code class="literal">fmap</code> or <code class="literal">liftM</code> over a stateful computation results in another stateful computation, but its eventual result is modified by the supplied function. Had we not mapped <code class="literal">(+100)</code> over <code class="literal">pop</code> before running it, it would have returned <code class="literal">(1, [2,3,4])</code>.</p><p>This is how <code class="literal">liftM</code> is implemented:</p><a id="I_programlisting14_d1e29909"/><pre class="programlisting">liftM :: (Monad m) =&gt; (a -&gt; b) -&gt; m a -&gt; m b
liftM f m = m &gt;&gt;= (\x -&gt; return (f x))</pre><p>Or with <code class="literal">do</code> notation:</p><a id="I_programlisting14_d1e29916"/><pre class="programlisting">liftM :: (Monad m) =&gt; (a -&gt; b) -&gt; m a -&gt; m b
liftM f m = do
    x &lt;- m
    return (f x)</pre><p>We feed the monadic value <code class="literal">m</code> into the function, and then we apply the function <code class="literal">f</code> to its result before putting it back into a default context. Because of the monad laws, this is guaranteed not to change the context; it changes only the result that the monadic value presents.</p><p>You see that <code class="literal">liftM</code> is implemented without referencing the <code class="literal">Functor</code> type class at all. This means that we can implement <code class="literal">fmap</code> (or <code class="literal">liftM</code>—whatever you want to call it) just by using the goodies that monads offer us. Because of this, we can conclude that monads are at least as strong as functors.<a id="IDX-CHP-14-0110" class="indexterm"/></p><p>The <code class="literal">Applicative</code> type class allows us to apply functions between values with contexts as if they were normal values, like this:</p><a id="I_programlisting14_d1e29950"/><pre class="programlisting">ghci&gt; (+) &lt;$&gt; Just 3 &lt;*&gt; Just 5
Just 8
ghci&gt; (+) &lt;$&gt; Just 3 &lt;*&gt; Nothing
Nothing</pre><p>Using this applicative style makes things pretty easy. <code class="literal">&lt;$&gt;</code> is just <code class="literal">fmap</code>, and <code class="literal">&lt;*&gt;</code> is a function from the <code class="literal">Applicative</code> type class that has the following type:</p><a id="I_programlisting14_d1e29966"/><pre class="programlisting">(&lt;*&gt;) :: (Applicative f) =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</pre><p>So it’s kind of like <code class="literal">fmap</code>, but the function itself is in a context. We need to somehow extract it from the context and map it over the <code class="literal">f a</code> value, and then reassemble the context. Because all functions are curried in Haskell by default, we can use the combination of <code class="literal">&lt;$&gt;</code> and <code class="literal">&lt;*&gt;</code> to apply functions that take several parameters between applicative values.</p><p>Anyway, it turns out that just like <code class="literal">fmap</code>, <code class="literal">&lt;*&gt;</code> can also be implemented by using only what the <code class="literal">Monad</code> type class gives us. The <code class="literal">ap</code> function is basically <code class="literal">&lt;*&gt;</code>, but with a <code class="literal">Monad</code> constraint instead of an <code class="literal">Applicative</code> one. Here’s its definition:</p><a id="I_programlisting14_d1e30007"/><pre class="programlisting">ap :: (Monad m) =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
ap mf m = do
    f &lt;- mf
    x &lt;- m
    return (f x)</pre><p><code class="literal">mf</code> is a monadic value whose result is a function. Because the function as well as the value is in a context, we get the function from the context and call it <code class="literal">f</code>, then get the value and call that <code class="literal">x</code>, and, finally, apply the function to the value and present that as a result. Here’s a quick demonstration:</p><a id="I_programlisting14_d1e30019"/><pre class="programlisting">ghci&gt; Just (+3) &lt;*&gt; Just 4
Just 7
ghci&gt; Just (+3) `ap` Just 4
Just 7
ghci&gt; [(+1),(+2),(+3)] &lt;*&gt; [10,11]
[11,12,12,13,13,14]
ghci&gt; [(+1),(+2),(+3)] `ap` [10,11]
[11,12,12,13,13,14]</pre><p>Now we can see that monads are at least as strong as applicatives as well, because we can use the functions from <code class="literal">Monad</code> to implement the ones for <code class="literal">Applicative</code>. In fact, many times, when a type is found to be a monad, people first write up a <code class="literal">Monad</code> instance, and then make an <code class="literal">Applicative</code> instance by just saying that <code class="literal">pure</code> is <code class="literal">return</code> and <code class="literal">&lt;*&gt;</code> is <code class="literal">ap</code>. Similarly, if you already have a <code class="literal">Monad</code> instance for something, you can give it a <code class="literal">Functor</code> instance just by saying that <code class="literal">fmap</code> is <code class="literal">liftM</code>.<a id="IDX-CHP-14-0111" class="indexterm"/><a id="IDX-CHP-14-0112" class="indexterm"/></p><p><code class="literal">liftA2</code> is a convenience function for applying a function between two applicative values. It’s defined like so:</p><a id="I_programlisting14_d1e30073"/><pre class="programlisting">liftA2 :: (Applicative f) =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
liftA2 f x y = f &lt;$&gt; x &lt;*&gt; y</pre><p>The <code class="literal">liftM2</code> function does the same thing, but with a <code class="literal">Monad</code> constraint. There are also <code class="literal">liftM3</code>, <code class="literal">liftM4</code>, and <code class="literal">liftM5</code> functions.</p><p>You saw how monads are at least as strong as applicatives and functors and how even though all monads are functors and applicative functors, they don’t necessarily have <code class="literal">Functor</code> and <code class="literal">Applicative</code> instances. We examined the monadic equivalents of the functions that functors and applicative functors use.</p></div><div class="sect2" title="The join Function"><div class="titlepage"><div><div><h2 class="title"><a id="the_join_function"/>The join Function</h2></div></div></div><p>Here’s some food for thought: If the result of one monadic value is another monadic value (one monadic value is nested inside the other), can you flatten them to just a single, normal monadic value? For instance, if we have <code class="literal">Just (Just 9)</code>, can we make that into <code class="literal">Just 9</code>? It turns out that any nested monadic value can be flattened and that this is actually a property unique to monads. For this, we have the <code class="literal">join</code> function. Its type is this:</p><a id="I_programlisting14_d1e30114"/><pre class="programlisting">join :: (Monad m) =&gt; m (m a) -&gt; m a</pre><p>So, <code class="literal">join</code> takes a monadic value within a monadic value and gives us just a monadic value—it flattens it, in other words. Here it is with some <code class="literal">Maybe</code> values:</p><a id="I_programlisting14_d1e30124"/><pre class="programlisting">ghci&gt; join (Just (Just 9))
Just 9
ghci&gt; join (Just Nothing)
Nothing ghci&gt; join Nothing
Nothing</pre><p>The first line has a successful computation as a result of a successful computation, so they are both just joined into one big successful computation. The second line features a <code class="literal">Nothing</code> as a result of a <code class="literal">Just</code> value. Whenever we were dealing with <code class="literal">Maybe</code> values before and we wanted to combine several of them into one—be it with <code class="literal">&lt;*&gt;</code> or <code class="literal">&gt;&gt;=</code>—they all needed to be <code class="literal">Just</code> values for the result to be a <code class="literal">Just</code> value. If there was any failure along the way, the result was a failure, and the same thing happens here. In the third line, we try to flatten what is from the onset a failure, so the result is a failure as well.</p><p>Flattening lists is pretty intuitive:</p><a id="I_programlisting14_d1e30152"/><pre class="programlisting">ghci&gt; join [[1,2,3],[4,5,6]]
[1,2,3,4,5,6]</pre><p>As you can see, for lists, <code class="literal">join</code> is just <code class="literal">concat</code>. To flatten a <code class="literal">Writer</code> value whose result is a <code class="literal">Writer</code> value itself, we need to <code class="literal">mappend</code> the monoid value:</p><a id="I_programlisting14_d1e30171"/><pre class="programlisting">ghci&gt; runWriter $ join (Writer (Writer (1, "aaa"), "bbb"))
(1,"bbbaaa")</pre><p>The outer monoid value <code class="literal">"bbb"</code> comes first, and then <code class="literal">"aaa"</code> is appended to it. Intuitively speaking, when you want to examine the result of a <code class="literal">Writer</code> value, you need to write its monoid value to the log first, and only then can you look at what it has inside.</p><p>Flattening <code class="literal">Either</code> values is very similar to flattening <code class="literal">Maybe</code> values:</p><a id="I_programlisting14_d1e30193"/><pre class="programlisting">ghci&gt; join (Right (Right 9)) :: Either String Int
Right 9
ghci&gt; join (Right (Left "error")) :: Either String Int
Left "error"
ghci&gt; join (Left "error") :: Either String Int
Left "error"</pre><p>If we apply <code class="literal">join</code> to a stateful computation whose result is a stateful computation, the result is a stateful computation that first runs the outer stateful computation and then the resulting one. Watch it at work:</p><a id="I_programlisting14_d1e30200"/><pre class="programlisting">ghci&gt; runState (join (state $ \s -&gt; (push 10, 1:2:s))) [0,0,0]
((),[10,1,2,0,0,0])</pre><p>The lambda here takes a state, puts <code class="literal">2</code> and <code class="literal">1</code> onto the stack, and presents <code class="literal">push 10</code> as its result. So, when this whole thing is flattened with <code class="literal">join</code> and then run, it first puts <code class="literal">2</code> and <code class="literal">1</code> onto the stack, and then <code class="literal">push 10</code> is carried out, pushing a <code class="literal">10</code> onto the top.</p><p>The implementation for <code class="literal">join</code> is as follows:</p><a id="I_programlisting14_d1e30234"/><pre class="programlisting">join :: (Monad m) =&gt; m (m a) -&gt; m a
join mm = do
    m &lt;- mm
    m</pre><p>Because the result of <code class="literal">mm</code> is a monadic value, we get that result and then just put it on a line of its own because it’s a monadic value. The trick here is that when we call <code class="literal">m &lt;- mm</code>, the context of the monad that we are in is taken care of. That’s why, for instance, <code class="literal">Maybe</code> values result in <code class="literal">Just</code> values only if the outer and inner values are both <code class="literal">Just</code> values. Here’s what this would look like if the <code class="literal">mm</code> value were set in advance to <code class="literal">Just (Just 8)</code>:<a id="IDX-CHP-14-0113" class="indexterm"/><a id="IDX-CHP-14-0114" class="indexterm"/></p><a id="I_programlisting14_d1e30268"/><pre class="programlisting">joinedMaybes :: Maybe Int
joinedMaybes = do
    m &lt;- Just (Just 8)
    m</pre><p>Perhaps the most interesting thing about <code class="literal">join</code> is that for every monad, feeding a monadic value to a function with <code class="literal">&gt;&gt;=</code> is the same thing as just mapping that function over the value and then using <code class="literal">join</code> to flatten the resulting nested monadic value! In other words, <code class="literal">m &gt;&gt;= f</code> is always the same thing as <code class="literal">join (fmap f m)</code>. It makes sense when you think about it.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject14_d1e30288"/><img src="httpatomoreillycomsourcenostarchimages802714.png.jpg" alt="image with no caption"/></div></div><p>With <code class="literal">&gt;&gt;=</code>, we’re always thinking about how to feed a monadic value to a function that takes a normal value but returns a monadic value. If we just map that function over the monadic value, we have a monadic value inside a monadic value. For instance, say we have <code class="literal">Just 9</code> and the function <code class="literal">\x -&gt; Just (x+1)</code>. If we map this function over <code class="literal">Just 9</code>, we’re left with <code class="literal">Just (Just 10)</code>.</p><p>The fact that <code class="literal">m &gt;&gt;= f</code> always equals <code class="literal">join (fmap f m)</code> is very useful if we’re making our own <code class="literal">Monad</code> instance for some type. This is because it’s often easier to figure out how we would flatten a nested monadic value than to figure out how to implement <code class="literal">&gt;&gt;=</code>.</p><p>Another interesting thing is that <code class="literal">join</code> cannot be implemented by just using the functions that functors and applicatives provide. This leads us to conclude that not only are monads as strong as functors and applicatives, but they are in fact stronger, because we can do more stuff with them than we can with just functors and applicatives.</p></div><div class="sect2" title="filterM"><div class="titlepage"><div><div><h2 class="title"><a id="filterm"/>filterM</h2></div></div></div><p>The <code class="literal">filter</code> function is pretty much the bread of Haskell programming (<code class="literal">map</code> being the butter). It takes a predicate and a list to filter and then returns a new list where only the elements that satisfy the predicate are kept. Its type is this:</p><a id="I_programlisting14_d1e30341"/><pre class="programlisting">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</pre><p>The predicate takes an element of the list and returns a <code class="literal">Bool</code> value. Now, what if the <code class="literal">Bool</code> value that it returned was actually a monadic value? What if it came with a context? For instance, what if every <code class="literal">True</code> or <code class="literal">False</code> value that the predicate produced also had an accompanying monoid value, like <code class="literal">["Accepted the number 5"]</code> or <code class="literal">["3 is too small"]</code>? If that were the case, we would expect the resulting list to also come with a log of all the log values that were produced along the way. So, if the <code class="literal">Bool</code> that the predicate returned came with a context, we would expect the final resulting list to have some context attached as well. Otherwise, the context that each <code class="literal">Bool</code> came with would be lost.</p><p>The <code class="literal">filterM</code> function from <code class="literal">Control.Monad</code> does just what we want! Its type is this:</p><a id="I_programlisting14_d1e30378"/><pre class="programlisting">filterM :: (Monad m) =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m [a]</pre><p>The predicate returns a monadic value whose result is a <code class="literal">Bool</code>, but because it’s a monadic value, its context can be anything from a possible failure to nondeterminism and more! To ensure that the context is reflected in the final result, the result is also a monadic value.</p><p>Let’s take a list and keep only those values that are smaller than 4. To start, we’ll just use the regular <code class="literal">filter</code> function:</p><a id="I_programlisting14_d1e30390"/><pre class="programlisting">ghci&gt; filter (\x -&gt; x &lt; 4) [9,1,5,2,10,3]
[1,2,3]</pre><p>That’s pretty easy. Now, let’s make a predicate that, aside from presenting a <code class="literal">True</code> or <code class="literal">False</code> result, also provides a log of what it did. Of course, we’ll be using the <code class="literal">Writer</code> monad for this:</p><a id="I_programlisting14_d1e30403"/><pre class="programlisting">keepSmall :: Int -&gt; Writer [String] Bool
keepSmall x
    | x &lt; 4 = do
        tell ["Keeping " ++ show x]
        return True
    | otherwise = do
        tell [show x ++ " is too large, throwing it away"]
        return False</pre><p>Instead of just returning a <code class="literal">Bool</code>, this function returns a <code class="literal">Writer [String] Bool</code>. It’s a monadic predicate. Sounds fancy, doesn’t it? If the number is smaller than <code class="literal">4</code>, we report that we’re keeping it, and then <code class="literal">return True</code>.</p><p>Now, let’s give it to <code class="literal">filterM</code> along with a list. Because the predicate returns a <code class="literal">Writer</code> value, the resulting list will also be a <code class="literal">Writer</code> value.</p><a id="I_programlisting14_d1e30431"/><pre class="programlisting">ghci&gt; fst $ runWriter $ filterM keepSmall [9,1,5,2,10,3]
[1,2,3]</pre><p>Examining the result of the resulting <code class="literal">Writer</code> value, we see that everything is in order. Now, let’s print the log and see what we have:<a id="IDX-CHP-14-0115" class="indexterm"/></p><a id="I_programlisting14_d1e30441"/><pre class="programlisting">ghci&gt; mapM_ putStrLn $ snd $ runWriter $ filterM keepSmall [9,1,5,2,10,3]
9 is too large, throwing it away
Keeping 1
5 is too large, throwing it away
Keeping 2
10 is too large, throwing it away
Keeping 3</pre><p>So, just by providing a monadic predicate to <code class="literal">filterM</code>, we were able to filter a list while taking advantage of the monadic context that we used.</p><p>A very cool Haskell trick is using <code class="literal">filterM</code> to get the powerset of a list (if we think of them as sets for now). The <span class="emphasis"><em>powerset</em></span> of some set is a set of all subsets of that set. So if we have a set like <code class="literal">[1,2,3]</code>, its powerset includes the following sets:</p><a id="I_programlisting14_d1e30459"/><pre class="programlisting">[1,2,3]
[1,2]
[1,3]
[1]
[2,3]
[2]
[3]
[]</pre><p>In other words, getting a powerset is like getting all the combinations of keeping and throwing out elements from a set. For example, <code class="literal">[2,3]</code> is the original set with the number <code class="literal">1</code> excluded, <code class="literal">[1,2]</code> is the original set with <code class="literal">3</code> excluded, and so on.</p><p>To make a function that returns a powerset of some list, we’re going to rely on nondeterminism. We take the list <code class="literal">[1,2,3]</code> and then look at the first element, which is <code class="literal">1</code>, and we ask ourselves, “Should we keep it or drop it?” Well, we would like to do both actually. So, we are going to filter a list, and we’ll use a predicate that nondeterministically both keeps and drops every element from the list. Here’s our <code class="literal">powerset</code> function:</p><a id="I_programlisting14_d1e30486"/><pre class="programlisting">powerset :: [a] -&gt; [[a]]
powerset xs = filterM (\x -&gt; [True, False]) xs</pre><p>Wait, that’s it? Yup. We choose to drop and keep every element, regardless of what that element is. We have a nondeterministic predicate, so the resulting list will also be a nondeterministic value and will thus be a list of lists. Let’s give this a go:</p><a id="I_programlisting14_d1e30491"/><pre class="programlisting">ghci&gt; powerset [1,2,3]
[[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]</pre><p>This takes a bit of thinking to wrap your head around. Just consider lists as nondeterministic values that don’t know what to be, so they decide to be everything at once, and the concept is a bit easier to grasp.<a id="IDX-CHP-14-0116" class="indexterm"/><a id="IDX-CHP-14-0117" class="indexterm"/></p></div><div class="sect2" title="foldM"><div class="titlepage"><div><div><h2 class="title"><a id="foldm"/>foldM</h2></div></div></div><p>The monadic counterpart to <code class="literal">foldl</code> is <code class="literal">foldM</code>. If you remember your folds from <a class="xref" href="ch05.html" title="Chapter 5. Higher-Order Functions">Chapter 5</a>, you know that <code class="literal">foldl</code> takes a binary function, a starting accumulator, and a list to fold up and then folds it from the left into a single value by using the binary function. <code class="literal">foldM</code> does the same thing, except it takes a binary function that produces a monadic value and folds the list up with that. Unsurprisingly, the resulting value is also monadic. The type of <code class="literal">foldl</code> is this:</p><a id="I_programlisting14_d1e30526"/><pre class="programlisting">foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</pre><p>Whereas <code class="literal">foldM</code> has the following type:</p><a id="I_programlisting14_d1e30533"/><pre class="programlisting">foldM :: (Monad m) =&gt; (a -&gt; b -&gt; m a) -&gt; a -&gt; [b] -&gt; m a</pre><p>The value that the binary function returns is monadic, so the result of the whole fold is monadic as well. Let’s sum a list of numbers with a fold:</p><a id="I_programlisting14_d1e30537"/><pre class="programlisting">ghci&gt; foldl (\acc x -&gt; acc + x) 0 [2,8,3,1]
14</pre><p>The starting accumulator is <code class="literal">0</code>, and then <code class="literal">2</code> is added to the accumulator, resulting in a new accumulator that has a value of <code class="literal">2</code>. <code class="literal">8</code> is added to this accumulator, resulting in an accumulator of <code class="literal">10</code>, and so on. When we reach the end, the final accumulator is the result.</p><p>Now, what if we wanted to sum a list of numbers but with the added condition that if any number in the list is greater than <code class="literal">9</code>, the whole thing fails? It would make sense to use a binary function that checks if the current number is greater than <code class="literal">9</code>. If it is, the function fails; if it isn’t, the function continues on its merry way. Because of this added possibility of failure, let’s make our binary function return a <code class="literal">Maybe</code> accumulator instead of a normal one. Here’s the binary function:</p><a id="I_programlisting14_d1e30567"/><pre class="programlisting">binSmalls :: Int -&gt; Int -&gt; Maybe Int
binSmalls acc x
    | x &gt; 9     = Nothing
    | otherwise = Just (acc + x)</pre><p>Because our binary function is now a monadic function, we can’t use it with the normal <code class="literal">foldl</code>; we must use <code class="literal">foldM</code>. Here goes:</p><a id="I_programlisting14_d1e30578"/><pre class="programlisting">ghci&gt; foldM binSmalls 0 [2,8,3,1]
Just 14
ghci&gt; foldM binSmalls 0 [2,11,3,1]
Nothing</pre><p>Excellent! Because one number in the list was greater than <code class="literal">9</code>, the whole thing resulted in a <code class="literal">Nothing</code>. Folding with a binary function that returns a <code class="literal">Writer</code> value is cool as well, because then you log whatever you want as your fold goes along its way.<a id="IDX-CHP-14-0118" class="indexterm"/></p></div></div>
<div class="sect1" title="Making a Safe RPN Calculator"><div class="titlepage"><div><div><h1 class="title"><a id="making_a_safe_rpn_calculator"/>Making a Safe RPN Calculator</h1></div></div></div><p>When we were solving the problem of implementing an RPN calculator in <a class="xref" href="ch10.html" title="Chapter 10. Functionally Solving Problems">Chapter 10</a>, we noted that it worked fine as long as the input that it got made sense. But if something went wrong, it caused our whole program to crash. Now that we know how to make already existing code monadic, let’s take our RPN calculator and add error handling to it by taking advantage of the <code class="literal">Maybe</code> monad.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject14_d1e30608"/><img src="httpatomoreillycomsourcenostarchimages802716.png" alt="image with no caption"/></div></div><p>We implemented our RPN calculator by taking a string like <code class="literal">"1 3 + 2 *"</code>, breaking it up into words to get something like <code class="literal">["1","3","+","2","*"]</code>. Then we folded over that list by starting out with an empty stack and using a binary folding function that adds numbers to the stack or manipulates numbers on the top of the stack to add them together and divide them and such.</p><p>This was the main body of our function:</p><a id="I_programlisting14_d1e30623"/><pre class="programlisting">import Data.List

solveRPN :: String -&gt; Double
solveRPN = head . foldl foldingFunction [] . words</pre><p>We made the expression into a list of strings, and folded over it with our folding function. Then, when we were left with just one item in the stack, we returned that item as the answer. This was the folding function:</p><a id="I_programlisting14_d1e30627"/><pre class="programlisting">foldingFunction :: [Double] -&gt; String -&gt; [Double]
foldingFunction (x:y:ys) "*" = (y * x):ys
foldingFunction (x:y:ys) "+" = (y + x):ys
foldingFunction (x:y:ys) "-" = (y - x):ys
foldingFunction xs numberString = read numberString:xs</pre><p>The accumulator of the fold was a stack, which we represented with a list of <code class="literal">Double</code> values. As the folding function went over the RPN expression, if the current item was an operator, it took two items off the top of the stack, applied the operator between them, and then put the result back on the stack. If the current item was a string that represented a number, it converted that string into an actual number and returned a new stack that was like the old one, except with that number pushed to the top.<a id="IDX-CHP-14-0119" class="indexterm"/></p><p>Let’s first make our folding function capable of graceful failure. Its type is going to change from what it is now to this:<a id="IDX-CHP-14-0120" class="indexterm"/></p><a id="I_programlisting14_d1e30646"/><pre class="programlisting">foldingFunction :: [Double] -&gt; String -&gt; Maybe [Double]</pre><p>So, it will either return <code class="literal">Just</code> a new stack or it will fail with <code class="literal">Nothing</code>.</p><p>The <code class="literal">reads</code> function is like <code class="literal">read</code>, except that it returns a list with a single element in case of a successful read. If it fails to read something, it returns an empty list. Apart from returning the value that it read, it also returns the part of the string that it didn’t consume. We’re going to say that it always must consume the full input to work, and make it into a <code class="literal">readMaybe</code> function for convenience. Here it is:</p><a id="I_programlisting14_d1e30668"/><pre class="programlisting">readMaybe :: (Read a) =&gt; String -&gt; Maybe a
readMaybe st = case reads st of [(x, "")] -&gt; Just x
                                _ -&gt; Nothing</pre><p>Now let’s test it:</p><a id="I_programlisting14_d1e30672"/><pre class="programlisting">ghci&gt; readMaybe "1" :: Maybe Int
Just 1
ghci&gt; readMaybe "GOTO HELL" :: Maybe Int
Nothing</pre><p>Okay, it seems to work. So, let’s make our folding function into a monadic function that can fail:</p><a id="I_programlisting14_d1e30676"/><pre class="programlisting">foldingFunction :: [Double] -&gt; String -&gt; Maybe [Double]
foldingFunction (x:y:ys) "*" = return ((y * x):ys)
foldingFunction (x:y:ys) "+" = return ((y + x):ys)
foldingFunction (x:y:ys) "-" = return ((y - x):ys)
foldingFunction xs numberString = liftM (:xs) (readMaybe numberString)</pre><p>The first three cases are like the old ones, except the new stack is wrapped in a <code class="literal">Just</code> (we used <code class="literal">return</code> here to do this, but we could just as well have written <code class="literal">Just</code>). In the last case, we use <code class="literal">readMaybe numberString</code>, and then we map <code class="literal">(:xs)</code> over it. So, if the stack <code class="literal">xs</code> is <code class="literal">[1.0,2.0]</code>, and <code class="literal">readMaybe numberString</code> results in a <code class="literal">Just 3.0</code>, the result is <code class="literal">Just [3.0,1.0,2.0]</code>. If <code class="literal">readMaybe numberString</code> results in a <code class="literal">Nothing</code>, the result is <code class="literal">Nothing</code>.</p><p>Let’s try out the folding function by itself:</p><a id="I_programlisting14_d1e30723"/><pre class="programlisting">ghci&gt; foldingFunction [3,2] "*"
Just [6.0]
ghci&gt; foldingFunction [3,2] "-"
Just [-1.0]
ghci&gt; foldingFunction [] "*"
Nothing ghci&gt; foldingFunction [] "1"
Just [1.0]
ghci&gt; foldingFunction [] "1 wawawawa"
Nothing</pre><p>It looks like it’s working! And now it’s time for the new and improved <code class="literal">solveRPN</code>. Here it is ladies and gents!<a id="IDX-CHP-14-0121" class="indexterm"/><a id="IDX-CHP-14-0122" class="indexterm"/></p><a id="I_programlisting14_d1e30739"/><pre class="programlisting">import Data.List

solveRPN :: String -&gt; Maybe Double
solveRPN st = do
    [result] &lt;- foldM foldingFunction [] (words st)
    return result</pre><p>Just as in the previous version, we take the string and make it into a list of words. Then we do a fold, starting with the empty stack, but instead of doing a normal <code class="literal">foldl</code>, we do a <code class="literal">foldM</code>. The result of that <code class="literal">foldM</code> should be a <code class="literal">Maybe</code> value that contains a list (that’s our final stack), and that list should have only one value. We use a <code class="literal">do</code> expression to get that value, and we call it <code class="literal">result</code>. In case the <code class="literal">foldM</code> returns a <code class="literal">Nothing</code>, the whole thing will be a <code class="literal">Nothing</code>, because that’s how <code class="literal">Maybe</code> works. Also notice that we pattern match in the <code class="literal">do</code> expression, so if the list has more than one value or none at all, the pattern match fails, and a <code class="literal">Nothing</code> is produced. In the last line, we just call <code class="literal">return result</code> to present the result of the RPN calculation as the result of the final <code class="literal">Maybe</code> value.</p><p>Let’s give it a shot:</p><a id="I_programlisting14_d1e30789"/><pre class="programlisting">ghci&gt; solveRPN "1 2 * 4 +"
Just 6.0
ghci&gt; solveRPN "1 2 * 4 + 5 *"
Just 30.0
ghci&gt; solveRPN "1 2 * 4"
Nothing ghci&gt; solveRPN "1 8 wharglbllargh"
Nothing</pre><p>The first failure happens because the final stack isn’t a list with one element in it, so the pattern matching in the <code class="literal">do</code> expression fails. The second failure happens because <code class="literal">readMaybe</code> returns a <code class="literal">Nothing</code>.</p></div>
<div class="sect1" title="Composing Monadic Functions"><div class="titlepage"><div><div><h1 class="title"><a id="composing_monadic_functions"/>Composing Monadic Functions</h1></div></div></div><p>When we were talking about the monad laws in <a class="xref" href="ch13.html" title="Chapter 13. A Fistful of Monads">Chapter 13</a>, you learned that the <code class="literal">&lt;=&lt;</code> function is just like composition, but instead of working for normal functions like <code class="literal">a -&gt; b</code>, it works for monadic functions like <code class="literal">a -&gt; m b</code>. Here is an example:<a id="IDX-CHP-14-0123" class="indexterm"/><a id="IDX-CHP-14-0124" class="indexterm"/></p><a id="I_programlisting14_d1e30826"/><pre class="programlisting">ghci&gt; let f = (+1) . (*100)
ghci&gt; f 4
401
ghci&gt; let g = (\x -&gt; return (x+1)) &lt;=&lt; (\x -&gt; return (x*100))
ghci&gt; Just 4 &gt;&gt;= g
Just 401</pre><p>In this example, we first composed two normal functions, applied the resulting function to <code class="literal">4</code>, and then composed two monadic functions and fed <code class="literal">Just 4</code> to the resulting function with <code class="literal">&gt;&gt;=</code>.</p><p>If you have a bunch of functions in a list, you can compose them all into one big function just by using <code class="literal">id</code> as the starting accumulator and the <code class="literal">.</code> function as the binary function. Here’s an example:</p><a id="I_programlisting14_d1e30847"/><pre class="programlisting">ghci&gt; let f = foldr (.) id [(+1),(*100),(+1)]
ghci&gt; f 1
201</pre><p>The function <code class="literal">f</code> takes a number and then adds <code class="literal">1</code> to it, multiplies the result by <code class="literal">100</code>, and then adds <code class="literal">1</code> to that.</p><p>We can compose monadic functions in the same way, but instead of normal composition, we use <code class="literal">&lt;=&lt;</code>, and instead of <code class="literal">id</code>, we use <code class="literal">return</code>. We don’t need to use a <code class="literal">foldM</code> over a <code class="literal">foldr</code> or anything like that, because the <code class="literal">&lt;=&lt;</code> function makes sure that composition happens in a monadic fashion.</p><p>When you were introduced to the list monad in <a class="xref" href="ch13.html" title="Chapter 13. A Fistful of Monads">Chapter 13</a>, we used it to figure out if a knight can go from one position on a chessboard to another in exactly three moves. We created a function called <code class="literal">moveKnight</code>, which takes the knight’s position on the board and returns all the possible moves that he can make next. Then, to generate all the possible positions that he can have after taking three moves, we made the following function:</p><a id="I_programlisting14_d1e30891"/><pre class="programlisting">in3 start = return start &gt;&gt;= moveKnight &gt;&gt;= moveKnight &gt;&gt;= moveKnight</pre><p>And to check if he can go from <code class="literal">start</code> to <code class="literal">end</code> in three moves, we did the following:</p><a id="I_programlisting14_d1e30902"/><pre class="programlisting">canReachIn3 :: KnightPos -&gt; KnightPos -&gt; Bool
canReachIn3 start end = end `elem` in3 start</pre><p>Using monadic function composition, we can make a function like <code class="literal">in3</code>, except instead of generating all the positions that the knight can have after making three moves, we can do it for an arbitrary number of moves. If you look at <code class="literal">in3</code>, you’ll see that we used our <code class="literal">moveKnight</code> three times, and each time, we used <code class="literal">&gt;&gt;=</code> to feed it all the possible previous positions. So now, let’s make it more general. Here’s how:<a id="IDX-CHP-14-0125" class="indexterm"/><a id="IDX-CHP-14-0126" class="indexterm"/></p><a id="I_programlisting14_d1e30928"/><pre class="programlisting">import Data.List

inMany :: Int -&gt; KnightPos -&gt; [KnightPos]
inMany x start = return start &gt;&gt;= foldr (&lt;=&lt;) return (replicate x moveKnight)</pre><p>First, we use <code class="literal">replicate</code> to make a list that contains <code class="literal">x</code> copies of the function <code class="literal">moveKnight</code>. Then we monadically compose all those functions into one, which gives us a function that takes a starting position and nondeterministically moves the knight <code class="literal">x</code> times. Then we just make the starting position into a singleton list with <code class="literal">return</code> and feed it to the function.</p><p>Now, we can change our <code class="literal">canReachIn3</code> function to be more general as well:</p><a id="I_programlisting14_d1e30952"/><pre class="programlisting">canReachIn :: Int -&gt; KnightPos -&gt; KnightPos -&gt; Bool
canReachIn x start end = end `elem` inMany x start</pre></div>
<div class="sect1" title="Making Monads"><div class="titlepage"><div><div><h1 class="title"><a id="making_monads"/>Making Monads</h1></div></div></div><p>In this section, we’re going to look at an example of how a type gets made, identified as a monad, and then given the appropriate <code class="literal">Monad</code> instance. We don’t usually set out to make a monad with the sole purpose of making a monad. Rather, we make a type whose purpose is to model an aspect of some problem, and then later on, if we see that the type represents a value with a context and can act like a monad, we give it a <code class="literal">Monad</code> instance.</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject14_d1e30966"/><img src="httpatomoreillycomsourcenostarchimages802718.png.jpg" alt="image with no caption"/></div></div><p>As you’ve seen, lists are used to represent nondeterministic values. A list like <code class="literal">[3,5,9]</code> can be viewed as a single nondeterministic value that just can’t decide what it’s going to be. When we feed a list into a function with <code class="literal">&gt;&gt;=</code>, it just makes all the possible choices of taking an element from the list and applying the function to it and then presents those results in a list as well.<a id="IDX-CHP-14-0127" class="indexterm"/></p><p>If we look at the list <code class="literal">[3,5,9]</code> as the numbers <code class="literal">3</code>, <code class="literal">5</code>, and <code class="literal">9</code> occurring at once, we might notice that there’s no information regarding the probability that each of those numbers occurs. What if we wanted to model a nondeterministic value like <code class="literal">[3,5,9]</code>, but we wanted to express that <code class="literal">3</code> has a 50 percent chance of happening and <code class="literal">5</code> and <code class="literal">9</code> both have a 25 percent chance of happening? Let’s try to make this work!<a id="IDX-CHP-14-0128" class="indexterm"/><a id="IDX-CHP-14-0129" class="indexterm"/><a id="IDX-CHP-14-0130" class="indexterm"/></p><p>Let’s say that every item in the list comes with another value: a probability of it happening. It might make sense to present that value like this:</p><a id="I_programlisting14_d1e31020"/><pre class="programlisting">[(3,0.5),(5,0.25),(9,0.25)]</pre><p>In mathemathics, probabilities aren’t usually expressed in percentages, but rather in real numbers between a 0 and 1. A 0 means that there’s no chance in hell for something to happen, and a 1 means that it’s happening for sure. Floating-point numbers can get messy fast because they tend to lose precision, but Haskell offers a data type for rational numbers. It’s called <code class="literal">Rational</code>, and it lives in <code class="literal">Data.Ratio</code>. To make a <code class="literal">Rational</code>, we write it as if it were a fraction. The numerator and the denominator are separated by a <code class="literal">%</code>. Here are a few examples:</p><a id="I_programlisting14_d1e31036"/><pre class="programlisting">ghci&gt; 1%4
1 % 4
ghci&gt; 1%2 + 1%2
1 % 1
ghci&gt; 1%3 + 5%4
19 % 12</pre><p>The first line is just one-quarter. In the second line, we add two halves to get a whole. In the third line, we add one-third with five-quarters and get nineteen-twelfths. So, let’s throw out our floating points and use <code class="literal">Rational</code> for our probabilities:</p><a id="I_programlisting14_d1e31043"/><pre class="programlisting">ghci&gt; [(3,1%2),(5,1%4),(9,1%4)]
[(3,1 % 2),(5,1 % 4),(9,1 % 4)]</pre><p>Okay, so <code class="literal">3</code> has a one-out-of-two chance of happening, while <code class="literal">5</code> and <code class="literal">9</code> will happen one time out of four. Pretty neat.</p><p>We took lists and we added some extra context to them, so this represents values with contexts as well. Before we go any further, let’s wrap this into a <code class="literal">newtype</code>, because something tells me we’ll be making some instances.</p><a id="I_programlisting14_d1e31062"/><pre class="programlisting">import Data.Ratio

newtype Prob a = Prob { getProb :: [(a, Rational)] } deriving Show</pre><p>Is this a functor? Well, the list is a functor, so this should probably be a functor, too, because we just added some stuff to the list. When we map a function over a list, we apply it to each element. Here, we’ll apply it to each element as well, but we’ll leave the probabilities as they are. Let’s make an instance:<a id="IDX-CHP-14-0131" class="indexterm"/></p><a id="I_programlisting14_d1e31071"/><pre class="programlisting">instance Functor Prob where
    fmap f (Prob xs) = Prob $ map (\(x, p) -&gt; (f x, p)) xs</pre><p>We unwrap it from the <code class="literal">newtype</code> with pattern matching, apply the function <code class="literal">f</code> to the values while keeping the probabilities as they are, and then wrap it back up. Let’s see if it works:</p><a id="I_programlisting14_d1e31081"/><pre class="programlisting">ghci&gt; fmap negate (Prob [(3,1%2),(5,1%4),(9,1%4)])
Prob {getProb = [(-3,1 % 2),(-5,1 % 4),(-9,1 % 4)]}</pre><p>Note that the probabilities should always add up to <code class="literal">1</code>. If those are all the things that can happen, it doesn’t make sense for the sum of their probabilities to be anything other than <code class="literal">1</code>. A coin that lands tails 75 percent of the time and heads 50 percent of the time seems like it could work only in some other strange universe.</p><p>Now the big question: Is this a monad? Given how the list is a monad, this looks like it should be a monad as well. First, let’s think about <code class="literal">return</code>. How does it work for lists? It takes a value and puts it in a singleton list. What about here? Well, since it’s supposed to be a default minimal context, it should also make a singleton list. What about the probability? Well, <code class="literal">return x</code> is supposed to make a monadic value that always presents <code class="literal">x</code> as its result, so it doesn’t make sense for the probability to be <code class="literal">0</code>. If it always must present this value as its result, the probability should be <code class="literal">1</code>!</p><p>What about <code class="literal">&gt;&gt;=</code>? Seems kind of tricky, so let’s make use of the fact that <code class="literal">m &gt;&gt;= f</code> always equals <code class="literal">join (fmap f m)</code> for monads and think about how we would flatten a probability list of probability lists. As an example, let’s consider this list where there’s a 25 percent chance that exactly one of <code class="literal">'a'</code> or <code class="literal">'b'</code> will happen. Both <code class="literal">'a'</code> and <code class="literal">'b'</code> are equally likely to occur. Also, there’s a 75 percent chance that exactly one of <code class="literal">'c'</code> or <code class="literal">'d'</code> will happen. <code class="literal">'c'</code> and <code class="literal">'d'</code> are also equally likely to happen. Here’s a picture of a probability list that models this scenario:</p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject14_d1e31145"/><img src="httpatomoreillycomsourcenostarchimages802720.png.jpg" alt="image with no caption"/></div></div><p>What are the chances for each of these letters to occur? If we were to draw this as just four boxes, each with a probability, what would those probabilites be? To find out, all we need to do is multiply each probability with all of the probabilities that it contains. <code class="literal">'a'</code> would occur one time out of eight, as would <code class="literal">'b'</code>, because if we multiply one-half by one-quarter, we get one-eighth. <code class="literal">'c'</code> would happen three times out of eight, because three-quarters multiplied by one-half is three-eighths. <code class="literal">'d'</code> would also happen three times out of eight. If we sum all the probabilities, they still add up to one.</p><p>Here’s this situation expressed as a probability list:</p><a id="I_programlisting14_d1e31167"/><pre class="programlisting">thisSituation :: Prob (Prob Char)
thisSituation = Prob
    [(Prob [('a',1%2),('b',1%2)], 1%4)
    ,(Prob [('c',1%2),('d',1%2)], 3%4)
    ]</pre><p>Notice that its type is <code class="literal">Prob (Prob Char)</code>. So now that we’ve figured out how to flatten a nested probability list, all we need to do is write the code for this. Then we can write <code class="literal">&gt;&gt;=</code> simply as <code class="literal">join (fmap f m)</code>, and we have ourselves a monad! So here’s <code class="literal">flatten</code>, which we’ll use because the name <code class="literal">join</code> is already taken:</p><a id="I_programlisting14_d1e31186"/><pre class="programlisting">flatten :: Prob (Prob a) -&gt; Prob a
flatten (Prob xs) = Prob $ concat $ map multAll xs
    where multAll (Prob innerxs, p) = map (\(x, r) -&gt; (x, p*r)) innerxs</pre><p>The function <code class="literal">multAll</code> takes a tuple of probability list and a probability <code class="literal">p</code> that comes with it and then multiplies every inner probability with <code class="literal">p</code>, returning a list of pairs of items and probabilities. We map <code class="literal">multAll</code> over each pair in our nested probability list, and then we just flatten the resulting nested list.</p><p>Now we have all that we need. We can write a <code class="literal">Monad</code> instance!</p><a id="I_programlisting14_d1e31207"/><pre class="programlisting">instance Monad Prob where
    return x = Prob [(x,1%1)]
    m &gt;&gt;= f = flatten (fmap f m)
    fail _ = Prob []</pre><p>Because we already did all the hard work, the instance is very simple. We also defined the <code class="literal">fail</code> function, which is the same as it is for lists, so if there’s a pattern-match failure in a <code class="literal">do</code> expression, a failure occurs within the context of a probability list.</p><p>It’s also important to check if the monad laws hold for the monad that we just made:<a id="IDX-CHP-14-0132" class="indexterm"/></p><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject14_d1e31223"/><img src="httpatomoreillycomsourcenostarchimages802722.png" alt="image with no caption"/></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The first law says that <code class="literal">return x &gt;&gt;= f</code> should be equal to <code class="literal">f x</code>. A rigorous proof would be rather tedious, but we can see that if we put a value in a default context with <code class="literal">return</code>, then <code class="literal">fmap</code> a function over that, and then flatten the resulting probability list, every probability that results from the function would be multiplied by the <code class="literal">1%1</code> probability that we made with <code class="literal">return</code>, so it wouldn’t affect the context.</p></li><li class="listitem"><p>The second law states that <code class="literal">m &gt;&gt;= return</code> is no different than <code class="literal">m</code>. For our example, the reasoning for <code class="literal">m &gt;&gt;= return</code> being equal to just <code class="literal">m</code> is similar to that for the first law.</p></li><li class="listitem"><p>The third law states that <code class="literal">f &lt;=&lt; (g &lt;=&lt; h)</code> should be the same as <code class="literal">(f &lt;=&lt; g) &lt;=&lt; h</code>. This one is true as well, because it holds for the list monad that forms the basis of the probability monad and because multiplication is associative. <code class="literal">1%2 * (1%3 * 1%5)</code> is equal to <code class="literal">(1%2 * 1%3) * 1%5</code>.</p></li></ol></div><p>Now that we have a monad, what can we do with it? Well, it can help us do calculations with probabilities. We can treat probabilistic events as values with contexts, and the probability monad will make sure that those probabilities are reflected in the probabilities of the final result.</p><p>Say we have two normal coins and one loaded coin that lands tails an astounding nine times out of ten and heads only one time out of ten. If we throw all the coins at once, what are the odds of all of them landing tails? First, let’s make probability values for a normal coin flip and for a loaded one:</p><a id="I_programlisting14_d1e31286"/><pre class="programlisting">data Coin = Heads | Tails deriving (Show, Eq)

coin :: Prob Coin
coin = Prob [(Heads,1%2),(Tails,1%2)]

loadedCoin :: Prob Coin
loadedCoin = Prob [(Heads,1%10),(Tails,9%10)]</pre><p>And finally, the coin-throwing action:</p><a id="I_programlisting14_d1e31290"/><pre class="programlisting">import Data.List (all)

flipThree :: Prob Bool
flipThree = do
    a &lt;- coin
    b &lt;- coin
    c &lt;- loadedCoin
    return (all (==Tails) [a,b,c])</pre><p>Giving it a go, we see that the odds of all three landing tails are not that good, despite cheating with our loaded coin:</p><a id="I_programlisting14_d1e31294"/><pre class="programlisting">ghci&gt; getProb flipThree
[(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),
  (False,1 % 40),(False,9 % 40),(False,1 % 40),(True,9 % 40)]</pre><p>All three of them will land tails 9 times out of 40, which is less than 25 percent. We see that our monad doesn’t know how to join all of the <code class="literal">False</code> outcomes where all coins don’t land tails into one outcome. That’s not a big problem, since writing a function to put all the same outcomes into one outcome is pretty easy (and left as an exercise to you, the reader).</p><p>In this section, we went from having a question (what if lists also carried information about probability?) to making a type, recognizing a monad, and finally making an instance and doing something with it. I think that’s quite fetching! By now, you should have a pretty good grasp of monads and what they’re about.</p></div></body></html>