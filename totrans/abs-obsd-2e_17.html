<html><head></head><body><section class="chapter" epub:type="chapter" id="desktop_openbsd" title="Chapter&#xA0;17.&#xA0;Desktop OpenBSD"><div class="titlepage"><div><div><h2 class="title">Chapter 17. Desktop OpenBSD</h2></div></div></div><div class="epigraph" epub:type="epigraph"><div class="literallayout"><p><span class="emphasis"><em>Spend summer days with</em></span><br/>
<span class="emphasis"><em>blowfish at your fingertips:</em></span><br/>
<span class="emphasis"><em>no passwords stolen!</em></span></p></div></div><p><a class="indexterm" id="idx0410"/><a class="indexterm" id="idx1587"/><a class="indexterm" id="idx2670"/><a class="indexterm" id="idx2687"/><a class="indexterm" id="idx2700"/><span class="inlinemediaobject"><a id="inline_id00018"/><img alt="" src="httpatomoreillycomsourcenostarchimages1616079.png"/></span> OpenBSD is best known as a server operating system, but it can be a very effective and powerful desktop system. The X Window System is the standard graphic desktop software for Unix-like operating systems, and OpenBSD includes tools for using it. As this book assumes that you have some Unix experience, I won’t cover all the applications that make X Windows comfortable. You’ll need to experiment to find your preferred mail client, web browser, and text editors—most of which aren’t OpenBSD-specific. Instead, this chapter covers items that are unique to OpenBSD, originated with OpenBSD, or require specific configuration.</p><p>OpenBSD includes the Xenocara framework for modifying and building X.Org in a manner tightly integrated with OpenBSD. We’ll discuss making OpenBSD boot into a graphical desktop using the <code class="literal">cwm</code> desktop environment, as well as a text console using the <code class="literal">tmux</code> terminal multiplexer. But we’ll start by customizing the console.</p><div class="sect1" title="Configuring Your Console with wscons"><div class="titlepage"><div><div><h2 class="title" id="configuring_your_console_with_wscons" style="clear: both">Configuring Your Console with wscons</h2></div></div></div><p><a class="indexterm" id="idx0118"/><a class="indexterm" id="idx0143"/><a class="indexterm" id="idx0290"/><a class="indexterm" id="idx0412"/><a class="indexterm" id="idx0491"/><a class="indexterm" id="idx1170"/><a class="indexterm" id="idx2025"/><a class="indexterm" id="idx2664"/>The <code class="literal">wscons(4)</code> hardware-independent console driver lets you configure your boring, black-and-white, nongraphical console in many ways.</p><p>Start by viewing the current console settings using <code class="literal">wsconsctl(8)</code>. Run the following on a text console, not in an X session (changes made in <code class="literal">wscons</code> can carry over to an X session, but once you start X, you’re mostly stuck with X’s configuration system).</p><a id="I_programlisting17_id483824"/><pre class="programlisting">$ <span class="strong"><strong>wsconsctl</strong></span>
keyboard.type=pc-xt
keyboard.bell.pitch=400
keyboard.bell.period=100
keyboard.bell.volume=50
…</pre><p>Each line contains a system variable and a setting, many of which you can change. The <code class="literal">keyboard.type</code> variable represents the type of keyboard on the system. Because this is an amd64 system, it uses the <code class="literal">pc-xt</code> keyboard common to consumer computers, but you’ll see different keyboard types with different hardware.</p><p>You can also change these settings with <code class="literal">wsconsctl</code>. For example, in the previous listing, the variable <code class="literal">keyboard.bell.volume</code> sets the volume of the computer’s beep. Now, I’m a <code class="literal">tcsh</code> user, and I frequently use tab completion (type a character or two, press <span class="smallcaps">TAB</span>, and the shell fills in the name of the command or file you’re about to type). Unfortunately, when tab completion hits an ambiguous spot, it stops. That’s not a problem when I’m logged in over SSH, because I can just type a character or two and press <span class="smallcaps">TAB</span> again. But when I’m on the local console, each ambiguity is accompanied by a beep (or bell) from the computer. When I’m trying to fix a problem, and the bell rings, shouting “<span class="emphasis"><em>beep</em></span> WRONG! <span class="emphasis"><em>beep</em></span> WRONG! <span class="emphasis"><em>beep</em></span> WRONG!” I have only one thought:</p><p>The beep must die.</p><a id="I_programlisting17_id483894"/><pre class="programlisting">$ <span class="strong"><strong>wsconsctl keyboard.bell.volume=0</strong></span>
keyboard.bell.volume=0</pre><p>Now silence reigns and I can resolve the problem without the computer nagging me. (You could choose to turn up the volume, if you’re a masochist. I won’t judge you—at least not in public.)</p><p>Here, we’ll look at a couple other things you can do with <code class="literal">wscons</code>.</p><div class="sect2" title="Screen Blanking"><div class="titlepage"><div><div><h3 class="title" id="screen_blanking">Screen Blanking</h3></div></div></div><p>If you leave the system alone for a few minutes, the screen should go blank to reduce power usage. Modern monitors often do this on their own, but you can also configure this behavior in the operating system, especially for older platforms. OpenBSD turns off the display only once it knows how to reactivate the display.</p><p><a class="indexterm" id="idx0181"/><a class="indexterm" id="idx0215"/><a class="indexterm" id="idx0414"/><a class="indexterm" id="idx0492"/><a class="indexterm" id="idx0493"/><a class="indexterm" id="idx0494"/><a class="indexterm" id="idx0495"/><a class="indexterm" id="idx2027"/><a class="indexterm" id="idx2154"/><a class="indexterm" id="idx2404"/><a class="indexterm" id="idx2439"/><a class="indexterm" id="idx2616"/>You have three choices:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><p title="display.kbdact"><span class="title"><strong><span class="strong"><strong><code class="literal">display.kbdact</code></strong></span></strong></span>. Wake on keyboard activity</p></li><li class="listitem" style="list-style-type: none"><p title="display.msact"><span class="title"><strong><span class="strong"><strong><code class="literal">display.msact</code></strong></span></strong></span>. Wake on mouse activity</p></li><li class="listitem" style="list-style-type: none"><p title="display.outact"><span class="title"><strong><span class="strong"><strong><code class="literal">display.outact</code></strong></span></strong></span>. Wake on monitor output</p></li></ul></div><p>Set one of these <code class="literal">wscons</code> variables to <code class="literal">on</code>, and OpenBSD will realize it should start blanking the monitor after the idle timeout. The variable <code class="literal">display.screen_off</code> gives the idle timeout in milliseconds; the default, <code class="literal">600000</code>, is 10 minutes.</p><p>You can also choose between turning the screen black and putting the monitor into “power-saver” mode, also known as <span class="emphasis"><em>sleep</em></span>. A monitor showing a black screen reactivates immediately when triggered, but uses more power. A sleeping monitor really is off, and needs a few seconds to reactivate. To set power-saver mode, change the variable <code class="literal">display.vblank</code> to <code class="literal">on</code>. (Some old monitors don’t believe in saving power, so this won’t work on them.)</p></div><div class="sect2" title="Setting wscons Variables at Boot"><div class="titlepage"><div><div><h3 class="title" id="setting_wscons_variables_at_boot">Setting wscons Variables at Boot</h3></div></div></div><p>Users can adjust console settings, but those settings will disappear at the next reboot. To set <code class="literal">wscons</code> variables at boot, add them to <span class="emphasis"><em>/etc/wsconsctl.conf</em></span>. The boot process reads this file and applies any variables it finds to the console.</p></div></div><div class="sect1" title="Running Virtual Terminals with tmux"><div class="titlepage"><div><div><h2 class="title" id="running_virtual_terminals_with_tmux" style="clear: both">Running Virtual Terminals with tmux</h2></div></div></div><p>The terminal multiplexer <code class="literal">tmux(1)</code> lets you run multiple virtual terminals inside one OpenBSD terminal window. While standard virtual terminals disappear when you disconnect from the system, <code class="literal">tmux</code> virtual terminals continue to run even after you disconnect. <code class="literal">tmux</code> is small, fast, easy to use, and written with the same care as the rest of OpenBSD.</p><p>Why would you need <code class="literal">tmux</code>? One example is for building programs. Just before I leave the office, I use my laptop to make an SSH connection into an OpenBSD server, create a virtual terminal, start building a huge program (such as OpenOffice.org), and shut down my laptop. Normally, the build on the server would terminate when my session is interrupted, but the <code class="literal">tmux</code> virtual terminal continues to run even when I log out. The build continues in the disconnected virtual terminal while I drive home, and when I reconnect to it later, I can see how the build has progressed. Virtual terminal sessions even survive accidental disconnections caused by network or client failures.</p><p>This section provides an introduction to <code class="literal">tmux</code>. For complete details on the features discussed here, as well as dozens of other features, read <code class="literal">tmux(1)</code>.</p><div class="sect2" title="The tmux Status Bar and Window Names"><div class="titlepage"><div><div><h3 class="title" id="the_tmux_status_bar_and_window_names">The tmux Status Bar and Window Names</h3></div></div></div><p><a class="indexterm" id="idx2250"/><a class="indexterm" id="idx2441"/><a class="indexterm" id="idx2446"/><a class="indexterm" id="idx2655"/><a class="indexterm" id="idx2656"/>To start a virtual terminal session, run <code class="literal">tmux</code>. Your terminal window will show the command prompt and a green <code class="literal">tmux</code> status bar along the bottom, with information like the following:</p><a id="I_programlisting17_id484271"/><pre class="programlisting">[0] 0:ksh*        "caddis.blackhelicop" 11:55  26-Jun-13</pre><p>This is a virtual terminal session. The left side of the status bar displays the <code class="literal">tmux</code> session number in brackets <code class="literal">[0]</code> and the list of <code class="literal">tmux</code> windows <code class="literal">0:ksh*</code> (beginning with window number 0). The right side shows the first part of your machine name (<code class="literal">caddis.blackhelicopters.org</code>), followed by the time and date. You’ll learn how to customize things in <a class="xref" href="ch17.html#setting_tmux_options" title="Setting tmux Options">Setting tmux Options</a> and <a class="xref" href="ch17.html#configuring_tmux" title="Configuring tmux">Configuring tmux</a>.</p><p>The window name defaults to the name of the program running in that <code class="literal">tmux(1)</code> window. For example, if you start a command that continues until interrupted, such as <code class="literal">iostat -w 5</code>, the session name will change to match the command. Interrupt the command, return to a shell prompt, and the status bar should change its name to match your shell.</p><p>The status bar is normally green, but if it turns yellow, <code class="literal">tmux</code> is expecting input. When it’s yellow, any typing is interpreted as a <code class="literal">tmux</code> command. If you reach this mode accidentally, press <span class="smallcaps">ENTER</span> to return to a green status bar and normal operation.</p></div><div class="sect2" title="tmux Commands and Window Management"><div class="titlepage"><div><div><h3 class="title" id="tmux_commands_and_window_management">tmux Commands and Window Management</h3></div></div></div><p>Pressing <span class="smallcaps">CTRL</span>-B tells <code class="literal">tmux</code> that the next command is for <code class="literal">tmux</code>, not for the program running in the virtual terminal. (If pressing <span class="smallcaps">CTRL</span>-B interferes with another program you use frequently, you can change this key combination, as you’ll see in <a class="xref" href="ch17.html#unmapping_and_remapping_keys" title="Unmapping and Remapping Keys">Unmapping and Remapping Keys</a>.)</p><p>The most commonly used <code class="literal">tmux</code> commands are single characters. For example, to create a second terminal window in this <code class="literal">tmux</code> session, press <span class="smallcaps">CTRL</span>-B-C. Your screen will display only a command prompt and a new status bar.</p><a id="I_programlisting17_id484397"/><pre class="programlisting">[0] 0:iostat-  1:ksh*          "caddis.blackhelicopte" 11:58 26-Jun-13</pre><p>You have two windows: window 0 shows <code class="literal">iostat</code> output, and window 1 displays the <code class="literal">ksh</code> prompt. The asterisk next to window 1 means that you’re currently looking at it. Run an ongoing command in your new window, such as <code class="literal">top</code>, and the window name should automatically change to the name of that command.</p><div class="sect3" title="Changing the Current Window"><div class="titlepage"><div><div><h4 class="title" id="changing_the_current_window">Changing the Current Window</h4></div></div></div><p>To view another window, use one of the following key combinations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>To see the next window, press <span class="smallcaps">CTRL</span>-B-N.</p></li><li class="listitem"><p>To switch to the previous window, press <span class="smallcaps">CTRL</span>-B-P.</p></li></ul></div><div class="note" title="Note"><h3 class="title"><a id="ch17note01"/>Note</h3><p><a class="indexterm" id="idx1435"/><a class="indexterm" id="idx2095"/><a class="indexterm" id="idx2405"/><a class="indexterm" id="idx2443"/><a class="indexterm" id="idx2444"/><a class="indexterm" id="idx2657"/><a class="indexterm" id="idx2658"/>Keep in mind that window ordering wraps. For example, if you are on the last window and press <span class="smallcaps">CTRL</span>-B-N, you should see the first window.</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>To jump directly to a window by number, press <span class="smallcaps">CTRL</span>-B followed by the window number.</p></li><li class="listitem"><p>To open a menu of all windows, press <span class="smallcaps">CTRL</span>-B-W, and then select a window with the arrow keys.</p></li></ul></div><p>I find the next and previous sequences sufficient, but if you end up with a dozen windows in one terminal, you might think otherwise.</p></div><div class="sect3" title="Renaming Windows"><div class="titlepage"><div><div><h4 class="title" id="renaming_windows">Renaming Windows</h4></div></div></div><p>Terminal windows take the name of the currently running program, but that’s not always useful. For example, if I’m compiling the newest source with <code class="literal">make build</code>, the window name will continually change to reflect the command running in the build at that moment. The only problem is that the constant flickering change in my status bar drives me nuts.</p><p>If you don’t want to see the window name change with each command, use <span class="smallcaps">CTRL</span>-B to assign a static name to the window. A yellow <code class="literal">[rename-window]</code> prompt will appear in the status bar. Enter your preferred window name, such as <code class="literal">upgrade</code>, and then press <span class="smallcaps">ENTER</span>.</p></div><div class="sect3" title="Terminating Windows"><div class="titlepage"><div><div><h4 class="title" id="terminating_windows">Terminating Windows</h4></div></div></div><p>To kill a window and end any processes running in it, change to that window and press <span class="smallcaps">CTRL</span>-B-&amp;. You will get a confirmation prompt.</p></div></div><div class="sect2" title="Getting Online Help"><div class="titlepage"><div><div><h3 class="title" id="getting_online_help">Getting Online Help</h3></div></div></div><p>Press <span class="smallcaps">CTRL</span>-B-? to see a complete list of all <code class="literal">tmux</code> commands.</p><a id="I_programlisting17_id484662"/><pre class="programlisting">  C-b: send-prefix
  C-o: rotate-window
  C-z: suspend-client
 Space: next-layout
   !: break-pane
   ": split-window
   #: list-buffers
…</pre><p>Now you can easily explore <code class="literal">tmux</code> without reading the manual page. You’ll use this list to remap keys in <a class="xref" href="ch17.html#unmapping_and_remapping_keys" title="Unmapping and Remapping Keys">Unmapping and Remapping Keys</a>.</p></div><div class="sect2" title="Disconnecting, Reconnecting, and Managing Sessions"><div class="titlepage"><div><div><h3 class="title" id="disconnecting_reconnecting_and_managing">Disconnecting, Reconnecting, and Managing Sessions</h3></div></div></div><p>A collection of <code class="literal">tmux</code> windows is called a <span class="emphasis"><em>session</em></span>. Conveniently, <code class="literal">tmux</code> can disconnect from a running session without interrupting its windows. Press <span class="smallcaps">CTRL</span>-B-D to disconnect your terminal from the current <code class="literal">tmux</code> session. Your terminal should now show what it held before starting <code class="literal">tmux</code>. To reconnect to your <code class="literal">tmux</code> session, run <code class="literal">tmux attach</code>.</p><p><a class="indexterm" id="idx1174"/><a class="indexterm" id="idx1885"/><a class="indexterm" id="idx2437"/><a class="indexterm" id="idx2438"/><a class="indexterm" id="idx2440"/>You can have multiple <code class="literal">tmux</code> sessions simultaneously. The session number appears on the far left of the status bar. (In our sample status bars, the <code class="literal">tmux</code> session is 0.)</p><p>To start a new <code class="literal">tmux</code> session without attaching to your previous session, run <code class="literal">tmux</code> without any arguments. For example, I type <code class="literal">tmux</code> instead of <code class="literal">tmux attach</code> in order to spawn a new <code class="literal">tmux</code> session when I want to pick up where I left off. You can change your <code class="literal">tmux</code> session within <code class="literal">tmux</code> itself, using a <code class="literal">tmux</code> command, but I usually just end the session and enter the correct command.</p><p>If you can have all these <code class="literal">tmux</code> sessions, how can you be sure that you haven’t left old, useless sessions lying around, with abandoned commands running in them? Use <code class="literal">tmux list-sessions</code>.</p><a id="I_programlisting17_id484836"/><pre class="programlisting">$ <span class="strong"><strong>tmux list-sessions</strong></span>
0: 4 windows (created Sun Feb 13 12:17:14 2011) [80x23]
2: 1 windows (created Mon Feb 21 21:57:59 2011) [131x36] (attached)</pre><p>I can see from the last line of this output that I left session 2 running on my other workstation, and am still attached to it.</p><p>To connect to session 2, use <code class="literal">attach-session</code> and option <code class="literal">-t</code> to choose a target session. Here, I attach to <code class="literal">tmux</code> session 2:</p><a id="I_programlisting17_id484866"/><pre class="programlisting">$ <span class="strong"><strong>tmux attach-session -t 2</strong></span></pre><p>I’m now connected to the same session from two separate SSH sessions—in this case, from two separate client workstations. My typing in one screen is echoed on the other.</p><p>To destroy a session, use the <code class="literal">kill-session</code> command, specifying the session number with <code class="literal">-t</code>. Here, I kill <code class="literal">tmux</code> session 2:</p><a id="I_programlisting17_id484894"/><pre class="programlisting">$ <span class="strong"><strong>tmux kill-session -t 2</strong></span></pre><p>Any programs running in windows in <code class="literal">tmux</code> session 2 will also be killed.</p></div><div class="sect2" title="Using tmux Commands"><div class="titlepage"><div><div><h3 class="title" id="using_tmux_commands">Using tmux Commands</h3></div></div></div><p>Command mode in <code class="literal">tmux</code> offers a prompt for entering more complicated commands. To enter command mode, press <span class="smallcaps">CTRL</span>-B-:. The status bar will turn yellow, and a single colon replaces all window names. For example, to create a new window dedicated to running <code class="literal">systat(1)</code>, press <span class="smallcaps">CTRL</span>-B-: and enter <span class="strong"><strong><code class="literal">neww systat</code></strong></span>. A window named <code class="literal">systat</code> will appear. Switch to that window, and then press <span class="smallcaps">CTRL</span>-C to stop <code class="literal">systat</code>. That window will disappear.</p><p>You can do all sorts of things with <code class="literal">tmux</code> commands, including split windows into multiple panels, copy and paste text, and so on. (Read <code class="literal">tmux(1)</code> for the full list.) If you want to cut and paste from one window to another, it’s easiest if you use multiple terminal windows, but if you are working in a text-only console or another restricted environment, you might find these <code class="literal">tmux</code> features useful.</p><p><a class="indexterm" id="idx0773"/><a class="indexterm" id="idx0920"/><a class="indexterm" id="idx0976"/><a class="indexterm" id="idx2105"/><a class="indexterm" id="idx2124"/><a class="indexterm" id="idx2251"/><a class="indexterm" id="idx2442"/><a class="indexterm" id="idx2445"/>The <code class="literal">tmux</code> command mode is most commonly used to set options.</p></div><div class="sect2" title="Setting tmux Options"><div class="titlepage"><div><div><h3 class="title" id="setting_tmux_options">Setting tmux Options</h3></div></div></div><p>Options change how <code class="literal">tmux</code> windows, sessions, and the <code class="literal">tmux</code> server itself behave. The most common changes involve the appearance of windows, colors, or items displayed in the status bar. Some options affect the entire <code class="literal">tmux</code> session; others affect only a specific window. You can change options on the fly with the <code class="literal">tmux</code> command <code class="literal">set-option</code>.</p><p>Go ahead and open a <code class="literal">tmux</code> session to follow along. Press <span class="smallcaps">CTRL</span>-B-: to enter command mode. When the colon appears, enter <span class="strong"><strong><code class="literal">set-option status-fg green</code></strong></span>, and then press <span class="smallcaps">ENTER</span>. Your status bar should now be solid green bar. Congratulations! You’ve set the status bar text color identical to the background color, making it unreadable. Return to command mode, and change the color to black to make it readable again. (If this bugs you, you can kill this <code class="literal">tmux</code> session and start a new one to reset all options.)</p><p>When making changes, use <span class="strong"><strong><code class="literal">set-option</code></strong></span> (or just <code class="literal">set</code>) for options that affect the <code class="literal">tmux</code> server and the entire session. Use <span class="strong"><strong><code class="literal">set-window-option</code></strong></span> (abbreviated <code class="literal">setw</code>) for options that affect only a single window.</p><p>Most people won’t need many (if any) <code class="literal">tmux</code> options, but they can prove useful. For example, say you want the status bar clock to display time in 24-hour format, or you want a visual bell instead of a beep. Options let you control these behaviors, as well as run commands in the status bar. To change basic <code class="literal">tmux</code> appearance and behavior, see the options in <code class="literal">tmux(1)</code>.</p><p>Be sure to try any interesting options interactively. Once you have a <code class="literal">tmux</code> session running the way you like, enter <span class="strong"><strong><code class="literal">show-options</code></strong></span> for an accurate list of the current options. Copy that list because we’ll use it to build a configuration file.</p></div><div class="sect2" title="Configuring tmux"><div class="titlepage"><div><div><h3 class="title" id="configuring_tmux">Configuring tmux</h3></div></div></div><p>Modify <span class="emphasis"><em>$HOME/.tmux.conf</em></span> in your home directory to configure your <code class="literal">tmux</code> sessions, or use <span class="emphasis"><em>/etc/tmux.conf</em></span> to inflict your <code class="literal">tmux</code> preferences on every system user. Personal <code class="literal">tmux</code> configurations override global settings.</p><p>As a simple example, I’ve set the left side of my status bar (containing the session number) to blue, and the right side (the hostname, time, and date) to red. If I decide I like this, I can make this change permanent by entering the following in <span class="emphasis"><em>tmux.conf</em></span>:</p><a id="I_programlisting17_id485242"/><pre class="programlisting">set -g status-left-bg blue
set -g status-right-bg red</pre><p>The <code class="literal">-g</code> flag sets an option globally, so it takes effect for all sessions and windows.</p><p>This should get you comfortable with using <code class="literal">tmux</code>. If you need multiple terminal windows simultaneously, use a graphical desktop. Stay tuned.</p></div></div><div class="sect1" title="Setting Up X"><div class="titlepage"><div><div><h2 class="title" id="setting_up_x" style="clear: both">Setting Up X</h2></div></div></div><p><a class="indexterm" id="idx0185"/><a class="indexterm" id="idx0343"/><a class="indexterm" id="idx0415"/><a class="indexterm" id="idx0768"/><a class="indexterm" id="idx1256"/><a class="indexterm" id="idx2234"/><a class="indexterm" id="idx2672"/><a class="indexterm" id="idx2678"/><a class="indexterm" id="idx2685"/><a class="indexterm" id="idx2690"/>The OpenBSD developers modified the industry-standard X graphic interface provided by X.Org to better fit with OpenBSD. The combination of X.Org and OpenBSD-specific patches is called Xenocara.</p><p>In most cases, Xenocara works exactly like X.Org, and X.Org documentation is applicable to OpenBSD. Most of Xenocara is there for security and for the convenience of developers building X, but there are a few additions. In my opinion, OpenBSD’s best enhancement to X.Org is the <code class="literal">cwm(1)</code> window manager. Here, we’ll cover configuring and starting X. The next section provides details about using the window manager.</p><div class="sect2" title="Configuring X"><div class="titlepage"><div><div><h3 class="title" id="configuring_x">Configuring X</h3></div></div></div><p>Configuring X can be simple or agonizing, depending on your hardware.</p><p>Most video cards require special access to system memory, though some new Intel video cards can work without this access. For other cards, you must adjust the <code class="literal">machdep.allowaperture=2</code> sysctl in <span class="emphasis"><em>/etc/sysctl.conf</em></span> and reboot.</p><p>Most amd64 and i386 systems need <code class="literal">machdep.allowaperture</code> set to <code class="literal">2</code>, but other platforms might require <code class="literal">1</code> or <code class="literal">2</code>. Without this sysctl setting, the kernel will not permit X to communicate with the graphics card. If you’re in doubt, try X without changing the sysctl, and when you find out your hardware is too old or the wrong model to work that way, set it to <code class="literal">2</code>.</p><p>After rebooting, see if X.Org can automatically set up your graphics interface by running <code class="literal">startx</code>. If it works, you should see the <code class="literal">fvwm(1)</code> desktop and a very bland gray background with a couple of terminal windows.</p><div class="note" title="Note"><h3 class="title"><a id="ch17note02"/>Note</h3><p>If X doesn’t start, see the OpenBSD FAQ, the X.Org documentation, and <span class="emphasis"><em>/var/log/Xorg.0.log</em></span>. Many things can go wrong with X autoconfiguration. Read your error log and search the Internet for solutions.</p></div><p>Once you know that X works, it’s time to decide whether you want to start X manually each time you need it or if you want OpenBSD to boot in to X automatically.</p></div><div class="sect2" title="Starting X Manually"><div class="titlepage"><div><div><h3 class="title" id="starting_x_manually">Starting X Manually</h3></div></div></div><p>After logging into the text console, run <code class="literal">startx(1)</code>. This command starts the commands in <span class="emphasis"><em>$HOME/.xinitrc</em></span> and starts X.</p></div><div class="sect2" title="Booting into X"><div class="titlepage"><div><div><h3 class="title" id="booting_into_x">Booting into X</h3></div></div></div><p>OpenBSD includes an <span class="emphasis"><em>/etc/rc.conf</em></span> hook for starting the X Display Manager, <code class="literal">xdm(1)</code>, at boot time with a login prompt, but the default is to not use <code class="literal">xdm</code>. Here’s the line to add to your <span class="emphasis"><em>rc.conf.local</em></span> to have <code class="literal">xdm</code> without any flags start X at boot:</p><a id="I_programlisting17_id485515"/><pre class="programlisting">xdm_flags=""</pre><p><a class="indexterm" id="idx0344"/><a class="indexterm" id="idx0346"/><a class="indexterm" id="idx0347"/><a class="indexterm" id="idx0353"/><a class="indexterm" id="idx0413"/><a class="indexterm" id="idx0907"/><a class="indexterm" id="idx0921"/><a class="indexterm" id="idx0975"/><a class="indexterm" id="idx0977"/><a class="indexterm" id="idx1134"/><a class="indexterm" id="idx1166"/><a class="indexterm" id="idx1411"/><a class="indexterm" id="idx2418"/><a class="indexterm" id="idx2468"/><a class="indexterm" id="idx2691"/><a class="indexterm" id="idx2697"/>After booting, the console will show a graphical login prompt. Once a user logs in, <code class="literal">xdm</code> runs any commands in <span class="emphasis"><em>$HOME/.xsession</em></span>.</p><div class="note" title="Note"><h3 class="title"><a id="ch17note03"/>Note</h3><p>Because this is a chapter about using OpenBSD as a desktop, I assume that you’re using <code class="literal">xdm(1)</code>. Examples refer to <span class="emphasis"><em>$HOME/.xsession</em></span>. If you use <code class="literal">startx(1)</code> instead, substitute <span class="emphasis"><em>.xinitrc</em></span>.</p></div></div><div class="sect2" title="Emulating a Three-Button Mouse"><div class="titlepage"><div><div><h3 class="title" id="emulating_a_three-button_mouse">Emulating a Three-Button Mouse</h3></div></div></div><p>A lot of X software expects you to have a mouse with three or more buttons, but many have only two buttons. Xenocara lets you pretend that you have a third mouse button, and when you press both mouse buttons simultaneously, it interprets that as pressing the nonexistent third button.</p><p>Of course, the best solution is to buy a real mouse with three or more buttons. They’re much easier to get than they used to be.</p><p>Now that you have X ready to use, let’s explore that <code class="literal">cwm</code> window manager I mentioned earlier.</p></div></div><div class="sect1" title="Using the cwm Window Manager"><div class="titlepage"><div><div><h2 class="title" id="using_the_cwm_window_manager" style="clear: both">Using the cwm Window Manager</h2></div></div></div><p>While X provides operating system support for a graphical interface, management of that interface falls to the window manager. OpenBSD has packages for button-heavy, pointy-clicky window managers such as KDE, Gnome, and Xfce. These window managers might provide a comfortable bridge between consumer-friendly operating systems and OpenBSD, but they’re not designed for the more hard-core Unix user.</p><p>Xenocara includes three window managers: the classic <code class="literal">fvwm(1)</code> and <code class="literal">twm(1)</code> window managers that have shipped with X since the last millennium, and the OpenBSD-specific <code class="literal">cwm(1)</code>. OpenBSD developers wrote <code class="literal">cwm</code> specifically as a modern, fast, keyboard-friendly interface.</p><p>To start <code class="literal">cwm</code> at login, invoke it in <span class="emphasis"><em>$HOME/.xsession</em></span>:</p><a id="I_programlisting17_id485761"/><pre class="programlisting">/usr/X11R6/bin/cwm</pre><p>When your <code class="literal">cwm</code> session ends, <code class="literal">xdm</code> returns you to the login screen.</p><div class="sect2" title="Configuring cwm"><div class="titlepage"><div><div><h3 class="title" id="configuring_cwm">Configuring cwm</h3></div></div></div><p>Rather than using mouse-driven configuration menus, <code class="literal">cwm</code> uses a single configuration file, <span class="emphasis"><em>$HOME/.cwmrc</em></span>. You can read the complete documentation in <code class="literal">cwmrc(5)</code>. Here, as I discuss various <code class="literal">cwm</code> features, I’ll mention how each can be configured or changed in <span class="emphasis"><em>.cwmrc</em></span>.</p><div class="sect3" title="Modifier Keys"><div class="titlepage"><div><div><h4 class="title" id="modifier_keys">Modifier Keys</h4></div></div></div><p>Most <code class="literal">cwm</code> operations require you to press a configurable combination of keys. For example, <span class="smallcaps">CTRL-ALT-DEL</span> locks the screen. The <code class="literal">cwm</code> documentation lists the modifier keys shown in <a class="xref" href="ch17.html#cwm_modifier_keys" title="Table 17-1. Table 17-1: cwm Modifier Keys">Table 17-1</a>.</p><div class="table"><a id="cwm_modifier_keys"/><div class="table-title">Table 17-1. Table 17-1: cwm Modifier Keys</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Symbol</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Key<a class="indexterm" id="idx0136"/><a class="indexterm" id="idx0345"/><a class="indexterm" id="idx0348"/><a class="indexterm" id="idx2653"/></p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>C</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><span class="smallcaps">CTRL</span></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>S</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><span class="smallcaps">SHIFT</span></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>M</p></td><td style="vertical-align: top; "><p><span class="smallcaps">META</span>/<span class="smallcaps">ALT</span></p></td></tr></tbody></table></div></div><p>For example, <code class="literal">CS-r</code> in <span class="emphasis"><em>.cwmrc</em></span> means <span class="smallcaps">CTRL-SHIFT</span>-R. <code class="literal">CM-W</code> represents <span class="smallcaps">CTRL-ALT</span>-W.</p></div><div class="sect3" title="Choosing a New Window Manager"><div class="titlepage"><div><div><h4 class="title" id="choosing_a_new_window_manager">Choosing a New Window Manager</h4></div></div></div><p>The default <code class="literal">cwm</code> configuration allows you to choose a new window manager with <span class="smallcaps">CTRL-ALT</span>-W from any command on the system. Enter <span class="strong"><strong><code class="literal">cwm</code></strong></span>, and <code class="literal">cwm</code> should restart without losing any of your windows.</p><div class="note" title="Note"><h3 class="title"><a id="ch17note04"/>Note</h3><p>You can also enter a command that isn’t a window manager, such as <code class="literal">grep</code>. If you do, OpenBSD will silently log you out. It won’t say, “Please step away from the keyboard before I hurt you.” Not threatening you passes for user-friendly in OpenBSD.</p></div></div><div class="sect3" title="Binding a Key Sequence to a Command"><div class="titlepage"><div><div><h4 class="title" id="binding_a_key_sequence_to_a_command">Binding a Key Sequence to a Command</h4></div></div></div><p>You can also bind a key sequence to any <code class="literal">cwm</code> command listed in <code class="literal">cwmrc(5)</code>. For example, suppose you want to use the key sequence <span class="smallcaps">CTRL-ALT</span>-R to delete your current window. Add the following to <span class="emphasis"><em>.cwmrc</em></span>:</p><a id="I_programlisting17_id486124"/><pre class="programlisting">bind CM-r		delete</pre><p>The change will take effect only once you use <span class="smallcaps">CTRL-ALT</span>-W to restart <code class="literal">cwm</code> or you log out and back in again. After you’ve done one or the other, use <span class="smallcaps">CTRL-ALT</span>-R to delete the current window.</p><div class="warning" epub:type="warning" title="Warning"><h3 class="title"><a id="ch17note05"/>Warning</h3><p>If you make an entry in <span class="emphasis"><em>.cwmrc</em></span> that <code class="literal">cwm</code> cannot parse, <code class="literal">cwm</code> will not process the configuration file, and you will lose all of your custom <code class="literal">cwm</code> settings as soon as you load the configuration file. If your custom settings vanish, your most recent changes to <span class="emphasis"><em>.cwmrc</em></span> are wrong. If you make an error that <code class="literal">cwm</code> <span class="emphasis"><em>can</em></span> parse, <code class="literal">cwm</code> will accept it. No one except the user will have trouble in this case.</p></div></div></div><div class="sect2" title="Creating cwm Windows"><div class="titlepage"><div><div><h3 class="title" id="creating_cwm_windows">Creating cwm Windows</h3></div></div></div><p>When you are running the graphical desktop, everything on screen is a <span class="emphasis"><em>window</em></span>. A terminal runs in a window, as do web browsers and games. Managing windows—raising, hiding, resizing, naming, and so on—is the core task of a window manager.</p><p>A default <code class="literal">cwm</code> session starts with a plain gray screen and a small <code class="literal">xconsole(1)</code> window. Create a new terminal window with <span class="smallcaps">CTRL-SHIFT-ENTER</span>. The window manager should focus on whatever window your mouse is over. (Press <span class="smallcaps">SHIFT</span>-+ to increase the font size of the terminal windows.)</p><p><a class="indexterm" id="idx0350"/><a class="indexterm" id="idx0351"/><a class="indexterm" id="idx0352"/><a class="indexterm" id="idx0800"/><a class="indexterm" id="idx0965"/><a class="indexterm" id="idx1330"/><a class="indexterm" id="idx1434"/><a class="indexterm" id="idx2026"/><a class="indexterm" id="idx2288"/><a class="indexterm" id="idx2654"/>If you press <span class="smallcaps">CTRL-SHIFT-ENTER</span> repeatedly, you won’t see additional terminal windows. Oh, the new windows will be created, but on top of one another. Press <span class="smallcaps">ALT</span> and the left mouse button to move the currently active window, and you should expose another terminal window beneath that one.</p><p>I find the default terminal size too small; I want wider terminals with more rows. To resize the terminal window, press <span class="smallcaps">ALT</span> and the center mouse button (or both buttons simultaneously). The mouse will move to the lower-right corner of the window and change to a right angle bracket. The window will continue to resize as long as you hold down the mouse button.</p><p>To maximize windows vertically, press <span class="smallcaps">CTRL-ALT</span>-=. To maximize windows horizontally, press <span class="smallcaps">CTRL-ALT- SHIFT</span>-=. To destroy a window, focus on it and press <span class="smallcaps">CTRL-ALT</span>-X. You will not be asked to confirm your decision; <code class="literal">cwm</code> will obey and exterminate the window immediately.</p><p>To exit <code class="literal">cwm</code> and return to the login screen, press <span class="smallcaps">CTRL-ALT</span>-Q.</p></div><div class="sect2" title="Managing Windows"><div class="titlepage"><div><div><h3 class="title" id="managing_windows">Managing Windows</h3></div></div></div><p>Now that you can create windows, let’s look at ways to manage them.</p><p>First, switch between visible windows with <span class="smallcaps">ALT-TAB</span>. The newly active window should rise to the foreground.</p><p>To assign a name to a window, press <span class="smallcaps">CTRL-ALT</span>-N to access the label prompt, and then enter the window’s desired name. Names are useful when you choose to hide a window without destroying it.</p><p>To hide a window, focus on it, and then press <span class="smallcaps">ALT-ENTER</span> to make it disappear. Pressing <span class="smallcaps">ALT-TAB</span> won’t bring it back because it’s hidden. Press the left mouse button for a list of all hidden windows, arranged by name. Any windows you didn’t name will show up as the program name. All terminals show up as <code class="literal">xterm</code>. Click the name to unhide the window.</p><div class="note" title="Note"><h3 class="title"><a id="ch17note06"/>Note</h3><p>It’s a good idea to name windows that have a specific purpose, such as a long-running software build. That way, you can minimize the window when it’s not interesting, and quickly find it again when necessary. I name windows created by SSH sessions after the connected server.</p></div><p>You can search for windows by name. Press <span class="smallcaps">CTRL-ALT</span>-/ to get a <code class="literal">window&gt;&gt;</code> prompt, and then start typing the name of the window. <code class="literal">cwm</code> will list all matching windows. Hidden windows have an ampersand (<code class="literal">&amp;</code>) before their name. Exclamation points indicate the window with focus.</p></div><div class="sect2" title="Locking the Screen"><div class="titlepage"><div><div><h3 class="title" id="locking_the_screen">Locking the Screen</h3></div></div></div><p>Don’t walk away from an active workstation without locking it, especially if you’re logged on to sensitive systems or as root. Press <span class="smallcaps">CTRL-ALT-DEL</span> to lock your desktop, and the screen will go blank. Press another key, and <code class="literal">cwm</code> will request your password to unlock the workstation.</p><p><a class="indexterm" id="idx0064"/><a class="indexterm" id="idx0393"/><a class="indexterm" id="idx1954"/><a class="indexterm" id="idx2213"/><a class="indexterm" id="idx2671"/><a class="indexterm" id="idx2675"/><a class="indexterm" id="idx2699"/><a class="indexterm" id="idx2701"/>The default screensaver is a blank screen, provided with <code class="literal">xlock(1)</code>. To use a different screensaver, set a path to it in <span class="emphasis"><em>.cwmrc</em></span>, as follows:</p><a id="I_programlisting17_id486594"/><pre class="programlisting">command lock <span class="emphasis"><em>path-to-command</em></span></pre><p>For example, to use <code class="literal">xlock</code>’s flow mode as a screensaver, add the following to <span class="emphasis"><em>.cwmrc</em></span>:</p><a id="I_programlisting17_id486612"/><pre class="programlisting">command lock '/usr/X11R6/bin/xlock -mode flow'</pre><p>If you don’t like any of the screensavers in Xenocara’s <code class="literal">xlock(1)</code>, try the <code class="literal">xscreensaver</code> package.</p><div class="note" title="Note"><h3 class="title"><a id="ch17note07"/>Note</h3><p><code class="literal">xlock</code> is easily bypassed by anyone with console access. You can’t count on it for security, but it does make a decent reminder for your coworkers.</p></div></div><div class="sect2" title="Connecting to Other Machines with SSH"><div class="titlepage"><div><div><h3 class="title" id="connecting_to_other_machines_with_ssh">Connecting to Other Machines with SSH</h3></div></div></div><p>One common task is to connect to remote machines with SSH. To do so, press <span class="smallcaps">ALT</span>-. to display an <code class="literal">ssh&gt;&gt;</code> prompt, and then enter the name of the machine to which you want to make the connection. Conveniently, <code class="literal">cwm</code> supports autocompletion, based on entries in <span class="emphasis"><em>known_hosts</em></span>. As you type a hostname at the <code class="literal">ssh</code> prompt, <code class="literal">cwm</code> checks for matching names in the system’s and users’ <span class="emphasis"><em>known_hosts</em></span>. Press the down-arrow key to find your desired hosts, or keep typing the hostname to connect to a new host. (Autocompletion won’t work if you hash <span class="emphasis"><em>known_hosts</em></span> entries.)</p><p>And by the way, if you open multiple SSH sessions, name them, because sorting through multiple sessions labeled <code class="literal">ssh</code> is annoying.</p></div><div class="sect2" title="Creating an Application Menu"><div class="titlepage"><div><div><h3 class="title" id="creating_an_application_menu">Creating an Application Menu</h3></div></div></div><p>Click the right mouse button on the background to bring up the application menu. The <code class="literal">cwm</code> developers have no idea which programs are important to you, so they don’t even try to provide a default application menu. You need to build that yourself with <span class="emphasis"><em>.cwmrc</em></span> entries. Each command has the following format:</p><a id="I_programlisting17_id486719"/><pre class="programlisting"><span class="emphasis"><em>command name path-to-command</em></span></pre><p>Yes, this is exactly the same as the format for setting the screensaver. The <code class="literal">lock</code> command is actually one of two special command keywords. Here, I’ve created an application menu with two choices, which are my web browser and my PDF reader:</p><a id="I_programlisting17_id486733"/><pre class="programlisting">command firefox /usr/local/bin/firefox
command xpdf /usr/local/bin/xpdf</pre><p>When I right-click the desktop background, I’ll see a menu with these two choices.</p></div><div class="sect2" title="Using Keyboard Navigation"><div class="titlepage"><div><div><h3 class="title" id="using_keyboard_navigation">Using Keyboard Navigation</h3></div></div></div><p><a class="indexterm" id="idx0100"/><a class="indexterm" id="idx0321"/><a class="indexterm" id="idx0349"/><a class="indexterm" id="idx0411"/><a class="indexterm" id="idx0823"/><a class="indexterm" id="idx1168"/><a class="indexterm" id="idx2576"/><a class="indexterm" id="idx2677"/><a class="indexterm" id="idx2703"/>Almost everyone has a mouse these days, but sometimes you’re in a situation where it’s best to ignore that mouse. Perhaps your desk is too small, your mouse is broken, repeatedly removing your hands from the keyboard slows you down (as in you don’t have a sensible mouse-in-keyboard), or you just hate your mouse today (which is both valid and respectable).</p><p>To control the mouse cursor with the keyboard, use <span class="smallcaps">CTRL</span> and the arrow keys to move the pointer a small amount, or press <span class="smallcaps">CTRL-SHIFT</span> and an arrow key to make larger pointer movements. On my system <span class="smallcaps">CTRL-SHIFT</span>-up arrow moves the mouse pointer up about a terminal line, but that varies with font size.</p><p>You can also use keyboard commands to shift window placement and size, as shown in <a class="xref" href="ch17.html#cwm_window_movement_direction_keys" title="Table 17-2. Table 17-2: cwm Window Movement Direction Keys">Table 17-2</a>.</p><div class="table"><a id="cwm_window_movement_direction_keys"/><div class="table-title">Table 17-2. Table 17-2: cwm Window Movement Direction Keys</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Key Combination</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Direction</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>alt-shift–H</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Left</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>alt-shift–J</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Down</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>alt-shift–K</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Up</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>alt-shift–l</p></td><td style="vertical-align: top; "><p>Right</p></td></tr></tbody></table></div></div><p>Use <span class="smallcaps">ALT</span> and a direction key to move a window a small amount, or <span class="smallcaps">ALT-SHIFT</span> to move the window a larger amount. To resize a window by a small amount, use <span class="smallcaps">CTRL-ALT</span> and a direction key. <span class="smallcaps">CTRL-ALT-SHIFT</span> and a direction key resizes the window a larger amount. Just as if you were resizing with the mouse, the size change occurs from the lower-right corner of the window. Place a window’s upper-left corner where you want it, and then resize the window.</p></div><div class="sect2" title="Decorating cwm"><div class="titlepage"><div><div><h3 class="title" id="decorating_cwm">Decorating cwm</h3></div></div></div><p>The default <code class="literal">cwm</code> desktop is rather bland, but a few adjustments make it easier on the eyes. One of the first things I set is a background color: black. Use <code class="literal">xsetroot(1)</code> to set your background color.</p><a id="I_programlisting17_id487042"/><pre class="programlisting">$ <span class="strong"><strong>xsetroot -solid black</strong></span></pre><p>You can include this command in <span class="emphasis"><em>.xsession</em></span> or run it in a terminal. The file <span class="emphasis"><em>/usr/X11R6/share/X11/rgb.txt</em></span> lists the colors X recognizes. If a color name is two words, either remove the spaces in the name or put the name in single quotes, like this:</p><a id="I_programlisting17_id487063"/><pre class="programlisting">$ <span class="strong"><strong>xsetroot -solid 'hot pink'</strong></span></pre><p>If you want an image in the background, use <code class="literal">feh</code> (<span class="emphasis"><em>/usr/ports/graphics/feh</em></span>).</p><a id="I_programlisting17_id487082"/><pre class="programlisting">$ <span class="strong"><strong>feh --bg-scale /home/mwlucas/galaxies.jpg</strong></span></pre><p><a class="indexterm" id="idx0068"/><a class="indexterm" id="idx0135"/><a class="indexterm" id="idx0191"/><a class="indexterm" id="idx0354"/><a class="indexterm" id="idx0968"/><a class="indexterm" id="idx1167"/><a class="indexterm" id="idx1323"/><a class="indexterm" id="idx1633"/><a class="indexterm" id="idx2496"/><a class="indexterm" id="idx2682"/>To make window edges easier to identify, put borders around them. The default border is 1 pixel wide, in your choice of colors. I prefer 3-pixel borders, blue for the active window and dark blue for the inactive windows. That requires the following entries in <span class="emphasis"><em>.cwmrc</em></span>:</p><a id="I_programlisting17_id487177"/><pre class="programlisting">borderwidth 3
color activeborder blue
color inactiveborder darkblue</pre><p>As you grow more accustomed to <code class="literal">cwm</code>, you might find that you want particular applications—perhaps an MP3 player, a clock, and a fancy graphic system load indicator—to always be visible. Maximizing a window can bury these applications. To address this, define a gap in <span class="emphasis"><em>.cwmrc</em></span>, which sets the number of pixels to be kept clear even when you maximize a window.</p><a id="I_programlisting17_id487194"/><pre class="programlisting">gap <span class="emphasis"><em>top bottom left right</em></span></pre><p>For example, when I must keep track of time, I run <code class="literal">xclock(1)</code> on the right side of my screen. Experimentation has shown that my clock is about 175 pixels wide. I leave a gap of 180 pixels, so that even when I maximize a window, it doesn’t cover the clock. Here’s my <code class="literal">gap</code> entry in <span class="emphasis"><em>.cwmrc</em></span>:</p><a id="I_programlisting17_id487216"/><pre class="programlisting">gap 0 0 0 180</pre><p>Now I can no longer use the excuse that I missed work because I lost my clock on my desktop. Fortunately, I have many other handy excuses.</p></div><div class="sect2" title="Unmapping and Remapping Keys"><div class="titlepage"><div><div><h3 class="title" id="unmapping_and_remapping_keys">Unmapping and Remapping Keys</h3></div></div></div><p>While the <code class="literal">cwm</code> authors did their best to choose keyboard shortcuts that wouldn’t conflict with those used by other programs, they could not avoid every possible conflict. If you run into such a conflict, you can solve the problem by modifying entries in <span class="emphasis"><em>.cwmrc</em></span> to replace conflicting <code class="literal">cwm</code> key bindings.</p><p>For example, <code class="literal">cwm</code> uses <span class="smallcaps">CTRL</span> and <span class="smallcaps">CTRL-SHIFT</span> with the arrow keys to move the pointer, but OpenOffice also uses these key combinations to move the pointer and highlight within a text document. I’ve used OpenOffice for more than 10 years, and have written millions of words in it. My fingers have been well-trained, and I’m not going to try to retrain them. The <code class="literal">cwm</code> key assignments must change.</p><p>Use the <code class="literal">bind</code> command to remap keys. Start by disconnecting the <span class="smallcaps">CTRL</span> and <span class="smallcaps">CTRL-SHIFT</span> and arrow key combinations from <code class="literal">cwm</code> with the <code class="literal">unmap</code> option. Remember that <span class="emphasis"><em>.cwmrc</em></span> uses <code class="literal">C</code> to represent <span class="smallcaps">CTRL</span> and <code class="literal">S</code> to represent <span class="smallcaps">SHIFT</span> (as shown earlier in <a class="xref" href="ch17.html#cwm_modifier_keys" title="Table 17-1. Table 17-1: cwm Modifier Keys">Table 17-1</a>).</p><a id="I_programlisting17_id487283"/><pre class="programlisting">bind CS-Left unmap
bind CS-Right unmap
bind CS-Up unmap
bind CS-Down unmap
bind C-Left unmap
bind C-Right unmap
bind C-Up unmap
bind C-Down unmap</pre><p><a class="indexterm" id="idx0130"/><a class="indexterm" id="idx1814"/><a class="indexterm" id="idx1894"/>These keystrokes will now pass through to applications, such as OpenOffice.</p><p>To determine how to move the pointer with the keyboard, I check <code class="literal">cwmrc(5)</code> for the list of commands that can be bound to a key. The manual defines commands with a brief name and a description of their functionality. The pointer movement commands begin with <code class="literal">ptrmove</code> and <code class="literal">bigptrmove</code>, plus a direction. I find them and use the Windows key (also known as modifier 4) to replace the functions I removed from the <span class="smallcaps">CTRL</span> key.</p><a id="I_programlisting17_id487384"/><pre class="programlisting">bind 4-Left ptrmoveleft
bind 4-Right ptrmoveright
bind 4-Up ptrmoveup
bind 4-Down ptrmovedown
bind 4S-Left bigptrmoveleft
bind 4S-Right bigptrmoveright
bind 4S-Up bigptrmoveup
bind 4S-Down bigptrmovedown</pre><p>I can now use both OpenOffice and <code class="literal">cwm</code>’s keyboard functions.</p><p>At this point, I’ve covered everything I’ve used since OpenBSD introduced <code class="literal">cwm</code>, which should get you started. For more information, read <code class="literal">cwm(1)</code> and <code class="literal">cwmrc(5)</code>. You’ll see that <code class="literal">cwm</code> supports many more features.</p><p>Now that we’ve covered OpenBSD’s appearance, let’s dive deep into the operating system core.</p></div></div></section></body></html>