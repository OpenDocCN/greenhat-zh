- en: Chapter 4. Hello Recursion!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。你好，递归！
- en: In this chapter, we’ll take a look at recursion. We’ll learn why it’s important
    in Haskell programming and how we can find very concise and elegant solutions
    to problems by thinking recursively.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨递归。我们将了解为什么递归在 Haskell 编程中很重要，以及我们如何通过递归思考来找到非常简洁和优雅的解决方案。
- en: Recursion is a way of defining functions in which a function is applied inside
    its own definition. In other words, the function calls itself. If you still don’t
    know what recursion is, read this sentence. (Haha! Just kidding!)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种定义函数的方式，其中函数在其定义内部应用自己。换句话说，函数调用自己。如果你仍然不知道递归是什么，请阅读这句话。（哈哈！只是开玩笑！）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802540.png.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802540.png.jpg)'
- en: Kidding aside, the strategy of a recursively defined function is to break down
    the problem at hand into smaller problems of the same kind and then try to solve
    those subproblems, breaking them down further if necessary. Eventually we reach
    the *base case* (or base cases) of the problem, which can’t be broken down any
    more and whose solutions need to be explicitly (non-recursively) defined by the
    programmer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 开个玩笑，递归定义的函数的策略是将当前问题分解为相同类型的小问题，然后尝试解决这些子问题，如果需要，进一步分解它们。最终，我们达到问题的 *基本情况*（或基本情况），不能再分解，并且程序员需要明确（非递归地）定义其解决方案。
- en: 'Definitions in mathematics are often recursive. For instance, we can specify
    the *Fibonacci sequence* recursively as follows: We define the first two Fibonacci
    numbers directly by saying that *F*(0) = 0 and *F*(1) = 1, meaning that the zeroth
    and first Fibonacci numbers are 0 and 1, respectively. These are our base cases.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 数学中的定义通常是递归的。例如，我们可以递归地指定 *斐波那契序列* 如下：我们通过直接说 *F*(0) = 0 和 *F*(1) = 1 来定义前两个斐波那契数，这意味着零和第一斐波那契数分别是
    0 和 1。这些都是我们的基本情况。
- en: Then we specify that for any natural number other than 0 or 1, the corresponding
    Fibonacci number is the sum of the previous two Fibonacci numbers. In other words,
    *F(n)* = *F*(*n*-1) + *F*(*n*-2). For example, *F*(3) is *F*(2) + *F*(1), which
    in turn breaks down as (*F*(1) + *F*(0)) + *F*(1). Because we’ve now come down
    to nothing but nonrecursively defined Fibonacci numbers, we can safely say that
    the value of *F*(3) is 2.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们指定对于除了0或1之外的任何自然数，相应的斐波那契数是前两个斐波那契数的和。换句话说，*F(n)* = *F*(*n*-1) + *F*(*n*-2)。例如，*F*(3)
    是 *F*(2) + *F*(1)，这又分解为 (*F*(1) + *F*(0)) + *F*(1)。因为我们现在只剩下非递归定义的斐波那契数，我们可以安全地说
    *F*(3) 的值是 2。
- en: Recursion is important in Haskell because, unlike with imperative languages,
    you do computations in Haskell by declaring *what* something is rather than specifying
    *how* you compute it. That’s why Haskell isn’t about issuing your computer a sequence
    of steps to execute, but rather about directly defining what the desired result
    is, often in a recursive manner.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 递归在 Haskell 中很重要，因为与命令式语言不同，你在 Haskell 中通过声明“是什么”而不是指定“如何”来执行计算。这就是为什么 Haskell
    不是关于向计算机发出一系列要执行的步骤，而是直接定义所需的结果，通常以递归的方式。
- en: Maximum Awesome
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最大酷
- en: Let’s take a look at an existing Haskell function and see how we can write the
    function ourselves if we shift our brains into the “R” gear (for “recursion”).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个现有的 Haskell 函数，看看如果我们把大脑切换到“R”档（代表“递归”），我们如何自己编写这个函数。
- en: The `maximum` function takes a list of things that can be put in order (i.e.,
    instances of the `Ord` type class) and returns the largest of them. It can be
    expressed very elegantly using recursion.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`maximum` 函数接受一个可以排序的事物列表（即 `Ord` 类型类的实例）并返回其中的最大值。它可以非常优雅地使用递归表达。'
- en: Before we discuss a recursive solution, think about how you might implement
    the `maximum` function imperatively. You’d probably set up a variable to hold
    the current maximum value, then you’d loop through every element of the list.
    If the current element is bigger than the current maximum value, you’d replace
    the maximum value with that element. The maximum value that remains at the end
    of the loop would be the final result.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论递归解决方案之前，想想你可能如何命令式地实现 `maximum` 函数。你可能设置一个变量来保存当前的最大值，然后你会遍历列表中的每个元素。如果当前元素比当前最大值大，你会用那个元素替换最大值。循环结束时剩下的最大值将是最终结果。
- en: 'Now let’s see how we’d define it recursively. First, we need to define a base
    case: We say that the maximum of a singleton list is equal to the only element
    in it. But what if the list has more than one element? Well, then we check which
    is bigger: the first element (the head) or the maximum of the rest of the list
    (the tail). Here’s the code for our recursive `maximum''` function:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何递归地定义它。首先，我们需要定义一个基本情况：我们说单元素列表的最大值等于它唯一的元素。但如果列表有多个元素呢？嗯，那么我们就检查哪个更大：第一个元素（头部）还是列表剩余部分的最大值（尾部）。下面是我们递归
    `maximum'` 函数的代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see here, pattern matching is really useful for defining recursive
    functions. Being able to match and deconstruct values makes it easy to break down
    the maximum-finding problem into the relevant cases and recursive subproblems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，模式匹配对于定义递归函数非常有用。能够匹配和分解值使得将查找最大值的问题分解为相关情况和递归子问题变得容易。
- en: The first pattern says that if the list is empty, the program should crash.
    This makes sense, because we just can’t say what the maximum of an empty list
    is. The second pattern says that if `maximum'` is passed a singleton list, it
    should just return that list’s only element.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模式表示如果列表为空，程序应该崩溃。这很有道理，因为我们根本无法说空列表的最大值是什么。第二个模式表示如果 `maximum'` 接收到一个单元素列表，它应该只返回该列表的唯一元素。
- en: Our third pattern represents the meat of the recursion. The list is split into
    a head and a tail. We call the head `x` and the tail `xs`. Then, we make use of
    our old friend, the `max` function. The `max` function takes two things and returns
    whichever of them is larger. If `x` is larger than the largest element in `xs`,
    our function will return `x`, otherwise it will return the largest element in
    `xs`. But how does our `maximum'` find the largest element in `xs`? Simple—by
    calling itself, recursively!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个模式代表了递归的核心。列表被分为头部和尾部。我们将头部称为 `x`，尾部称为 `xs`。然后，我们利用我们老朋友，`max` 函数。`max`
    函数接受两个参数，并返回其中较大的一个。如果 `x` 大于 `xs` 中最大的元素，我们的函数将返回 `x`，否则它将返回 `xs` 中的最大元素。但是我们的
    `maximum'` 函数是如何在 `xs` 中找到最大元素的？简单——通过递归调用自己！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802542.png.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802542.png.jpg)'
- en: Let’s work through this code with a specific example, just in case you’re having
    trouble visualizing how `maximum'` works. If we call `maximum'` on `[2,5,1]`,
    the first two patterns don’t match the function call. However, the third pattern
    does, so the list value is split into `2` and `[5,1]`, and `maximum'` is called
    with `[5,1]`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的例子来分析这段代码，以防你难以想象 `maximum'` 的工作方式。如果我们对 `[2,5,1]` 调用 `maximum'`，前两个模式不匹配函数调用。然而，第三个模式匹配，所以列表值被拆分为
    `2` 和 `[5,1]`，然后对 `[5,1]` 调用 `maximum'`。
- en: For this new call to `maximum'`, `[5,1]` matches the third pattern, and once
    again the input list is split—this time into `5` and `[1]`—and `maximum'` is recursively
    called on `[1]`. This is a singleton list, so the newest call now matches one
    of our base cases and returns `1` as a result.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这次对 `maximum'` 的新调用，`[5,1]` 匹配第三个模式，并且输入列表再次被拆分——这次是 `5` 和 `[1]`——然后对 `[1]`
    递归调用 `maximum'`。这是一个单元素列表，所以最新的调用现在匹配我们的一个基本情况，并返回 `1` 作为结果。
- en: Now, we go up a level, comparing `5` to `1` with the use of the `max` function.
    `1` was the result of our last recursive call. Since `5` is larger, we now know
    that the maximum of `[5,1]` is `5`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们上升一个层次，使用 `max` 函数比较 `5` 和 `1`。`1` 是我们上一次递归调用的结果。由于 `5` 更大，我们现在知道 `[5,1]`
    的最大值是 `5`。
- en: Finally, comparing `2` to the maximum of `[5,1]`, which we now know is `5`,
    we obtain the answer to the original problem. Since `5` is greater than `2`, we
    can now say that `5` is the maximum of `[2,5,1]`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 `2` 与 `[5,1]` 的最大值比较，我们现在知道它是 `5`，我们得到了原始问题的答案。由于 `5` 大于 `2`，我们现在可以说 `5`
    是 `[2,5,1]` 的最大值。
- en: A Few More Recursive Functions
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些更多的递归函数
- en: Now that we’ve seen how to think recursively, let’s implement a few more functions
    this way. Like `maximum`, these functions already exist in Haskell, but we’re
    going to write our own versions to exercise the recursive muscle fibers in the
    recursive muscles of our recursive muscle groups. Let’s get buff!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何递归地思考，让我们以这种方式实现更多函数。像 `maximum` 一样，这些函数在 Haskell 中已经存在，但我们将编写自己的版本来锻炼我们递归肌肉群的递归肌肉中的递归肌肉纤维。让我们变得更强壮！
- en: replicate
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: replicate
- en: 'First off, we’ll implement `replicate`. Remember that `replicate` takes an
    `Int` and a value, and returns a list that has several repetitions of that value
    (namely, however many the `Int` specifies). For instance, `replicate 3 5` returns
    a list of three fives: `[5,5,5]`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现 `replicate`。记住，`replicate` 接受一个 `Int` 和一个值，并返回一个包含该值重复次数（即 `Int` 指定的次数）的列表。例如，`replicate
    3 5` 返回一个包含三个五的列表：`[5,5,5]`。
- en: Let’s think about the base cases. We immediately know what to return if we’re
    asked to replicate something zero or fewer times. If we try to replicate something
    zero times, we should get an empty list. And we declare that the result should
    be the same for negative numbers, because replicating an item fewer than zero
    times doesn’t make sense.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑基本情况。如果我们被要求复制零次或更少的次数，我们立即知道应该返回什么。如果我们尝试复制零次，我们应该得到一个空列表。我们还声明负数的结果应该相同，因为复制少于零次的项没有意义。
- en: 'In general, a list with `n` repetitions of `x` is a list with `x` as its head
    and a tail consisting of `x` replicated `n-1` times. We get the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个包含 `n` 次重复的 `x` 的列表是一个以 `x` 为首元素，尾部由 `x` 复制 `n-1` 次组成的列表。我们得到以下代码：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We used guards here instead of patterns because we’re testing for a Boolean
    condition.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用守卫而不是模式，因为我们正在测试布尔条件。
- en: take
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: take
- en: 'Next up, we’ll implement `take`. This function returns a specified number of
    elements from a specified list. For instance, `take 3 [5,4,3,2,1]` will return
    `[5,4,3]`. If we try to take zero or fewer elements from a list, we should get
    an empty list, and if we try to take anything at all from an empty list, we should
    get an empty list. Notice that those are our two base cases. Now let’s write the
    function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现 `take`。这个函数从指定的列表中返回指定数量的元素。例如，`take 3 [5,4,3,2,1]` 将返回 `[5,4,3]`。如果我们尝试从一个列表中取出零个或更少的元素，我们应该得到一个空列表，如果我们尝试从一个空列表中取出任何东西，我们也应该得到一个空列表。注意，这些都是我们的两个基本情况。现在让我们编写这个函数：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that in the first pattern, which specifies that we get an empty list
    if we try to take zero or fewer elements from a list, we use the `_` placeholder
    to match the list value, because we don’t really care what it is in this case.
    Also notice that we use a guard, but without an `otherwise` part. That means that
    if `n` turns out to be more than 0, the matching will fall through to the next
    pattern.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第一个模式中，指定如果我们尝试从一个列表中取出零个或更少的元素，我们会得到一个空列表，我们使用 `_` 占位符来匹配列表值，因为我们在这种情况下并不关心它是什么。另外，注意我们使用了守卫，但没有
    `otherwise` 部分。这意味着如果 `n` 转而大于 0，匹配将传递到下一个模式。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802544.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802544.png.jpg)'
- en: The second pattern indicates that if we try to take any number of things at
    all from an empty list, we get an empty list.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个模式表明，如果我们尝试从一个空列表中取出任何数量的东西，我们都会得到一个空列表。
- en: The third pattern breaks the list into a head and a tail. We call the head `x`
    and the tail `xs`. Then we state that taking `n` elements from a list is the same
    as creating a list that has `x` as its first element and `n-1` elements from `xs`
    as its remaining elements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个模式将列表分为头部和尾部。我们称头部为 `x`，尾部为 `xs`。然后我们声明从列表中取出 `n` 个元素与创建一个以 `x` 为首元素，从 `xs`
    中取出 `n-1` 个元素作为其余元素的列表是相同的。
- en: reverse
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: reverse
- en: 'The `reverse` function takes a list and returns a list with the same elements,
    but in the reverse order. Once again, the empty list is the base case, since trying
    to reverse an empty list just results in the empty list. What about the rest of
    the function? Well, if we split the original list into its head and tail, the
    reversed list that we want is the reverse of the tail, with the head stuck at
    the end:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse` 函数接受一个列表并返回一个包含相同元素但顺序相反的列表。同样，空列表是基本情况，因为尝试反转一个空列表只会得到一个空列表。那么函数的其余部分呢？好吧，如果我们把原始列表分成头部和尾部，我们想要的反转列表就是尾部的反转，头部被固定在末尾：'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: repeat
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: repeat
- en: 'The `repeat` function takes an element and returns an infinite list composed
    of that element. A recursive implementation of `repeat` is really easy:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat` 函数接受一个元素并返回一个由该元素组成的无限列表。`repeat` 的递归实现非常简单：'
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Calling `repeat 3` will give us a list that starts with `3` as the head and
    has an infinite amount of `3`s as the tail. So calling `repeat 3` evaluates to
    `3:repeat 3`, which evaluates to `3:(3:repeat 3)`, which evaluates to `3:(3:(3:repeat
    3))`, and so on. `repeat 3` will never finish evaluating. However, `take 5 (repeat
    3)` will give us a list of five `3`s. Essentially, it’s like calling `replicate
    5 3`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`repeat 3`将给我们一个以`3`作为头部，尾部有无限多个`3`的列表。所以调用`repeat 3`的结果是`3:repeat 3`，这又等于`3:(3:repeat
    3)`，然后等于`3:(3:(3:repeat 3))`，以此类推。`repeat 3`永远不会完成评估。然而，`take 5 (repeat 3)`将给我们一个包含五个`3`的列表。本质上，这就像调用`replicate
    5 3`。
- en: This is a nice example of how we can successfully use recursion that doesn’t
    have a base case to make infinite lists—we just have to be sure to chop them off
    somewhere along the way.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的例子，说明了我们可以如何成功地使用没有基本情况但可以创建无限列表的递归——我们只需确保在某个地方切断它们即可。
- en: zip
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: zip
- en: '`zip` is another function for working with lists that we’ve met in [Chapter 1](ch01.html
    "Chapter 1. Starting Out"). It takes two lists and zips them together. For instance,
    calling `zip [1,2,3] [7,8]` returns `[(1,7),(2,8)]` (the function truncates the
    longer list to match the length of the shorter one).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip`是我们已经在[第1章](ch01.html "第1章。开始")中遇到过的另一个用于处理列表的函数。它接受两个列表并将它们组合在一起。例如，调用`zip
    [1,2,3] [7,8]`返回`[(1,7),(2,8)]`（该函数截断较长的列表以匹配较短的长度）。'
- en: 'Zipping something with an empty list just returns an empty list, which gives
    us our base case. However, `zip` takes two lists as parameters, so there are actually
    two base cases:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空列表压缩某个东西只会返回一个空列表，这就是我们的基本情况。然而，`zip`函数接受两个列表作为参数，所以实际上有两个基本情况：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first two patterns are our base cases: If the first or second list is empty,
    we return an empty list. The third pattern says that zipping two lists together
    is equivalent to pairing up their heads, then appending their zipped tails to
    that.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种模式是我们的基本情况：如果第一个或第二个列表为空，我们返回一个空列表。第三种模式说明将两个列表组合在一起相当于将它们的头部配对，然后将它们的压缩尾部附加到那个头部上。
- en: For example, if we call `zip'` with `[1,2,3]` and `['a','b']`, the function
    will form `(1,'a')` as the first element of the result, then zip together `[2,3]`
    and `[b]` to obtain the rest of the result. After one more recursive call, the
    function will try to zip `[3]` with `[]`, which matches one of the base case patterns.
    The final result is then computed directly as `(1,'a'):((2,'b'):[])`, which is
    just `[(1,'a'),(2,'b')]`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们用`[1,2,3]`和`['a','b']`调用`zip'`，该函数将形成`(1,'a')`作为结果的第一元素，然后将`[2,3]`和`[b]`压缩在一起以获得其余的结果。在另一次递归调用之后，该函数将尝试将`[3]`与`[]`压缩，这符合基本情况模式之一。最终结果直接计算为`(1,'a'):((2,'b'):[])`，这正好是`[(1,'a'),(2,'b')]`。
- en: elem
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: elem
- en: 'Let’s implement one more standard library function: `elem`. This function takes
    a value and a list, and checks whether the value is a member of the list. Once
    again, the empty list is a base case—an empty list contains no values, so it certainly
    can’t have the one we’re looking for. In general, the value we’re looking for
    might be at the head of the list if we’re lucky; otherwise, we have to check whether
    it’s in the tail. Here’s the code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再实现一个标准库函数：`elem`。该函数接受一个值和一个列表，并检查该值是否是列表的成员。同样，空列表是一个基本情况——空列表不包含任何值，所以它当然不可能包含我们要找的值。一般来说，如果我们幸运的话，我们可能在我们所寻找的值在列表的头部；否则，我们必须检查它是否在尾部。以下是代码：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Quick, Sort!
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速排序！
- en: 'The problem of sorting a list containing elements that can be put in order
    (like numbers) naturally lends itself to a recursive solution. There are many
    approaches to recursively sorting lists, but we’ll look at one of the coolest
    ones: *quicksort*. First we’ll go over how the algorithm works, and then we’ll
    implement it in Haskell.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对包含可以按顺序排列的元素（如数字）的列表进行排序的问题自然适合递归解决方案。有许多递归排序列表的方法，但我们将查看其中最酷的一种：*快速排序*。首先，我们将了解算法的工作原理，然后我们将用Haskell实现它。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802546.png.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802546.png.jpg)'
- en: The Algorithm
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法
- en: 'The quicksort algorithm works like this. You have a list that you want to sort,
    say `[5,1,9,4,6,7,3]`. You select the first element, which is `5`, and put all
    the other list elements that are less than or equal to `5` on its left side. Then
    you take the ones that are greater than `5` and put them on its right side. If
    you did this, you’d have a list that looks like this: `[1,4,3,5,9,6,7]`. In this
    example, `5` is called the *pivot*, because we chose to compare the other elements
    to it and move them to its left and right sides. The only reason we chose the
    first element as the pivot is because it will be easy to snag using pattern matching.
    But really, any element can be the pivot.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序算法的工作原理是这样的。你有一个想要排序的列表，比如说`[5,1,9,4,6,7,3]`。你选择第一个元素，即`5`，并将所有小于或等于`5`的其他列表元素放在它的左侧。然后，你将大于`5`的元素放在它的右侧。如果你这样做，你会得到一个看起来像这样的列表：`[1,4,3,5,9,6,7]`。在这个例子中，`5`被称为*枢轴*，因为我们选择将其他元素与它比较并将它们移动到它的左右两侧。我们选择第一个元素作为枢轴的唯一原因是它将很容易通过模式匹配来捕获。但事实上，任何元素都可以作为枢轴。
- en: Now, we recursively sort all the elements that are on the left and right sides
    of the pivot by calling the same function on them. The final result is a completely
    sorted list!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过在它们上调用相同的函数递归地排序枢轴左右两侧的所有元素。最终结果是完全排序的列表！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802548.png.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802548.png.jpg)'
- en: The above diagram illustrates how quicksort works on our example. When we want
    to sort `[5,1,9,4,6,7,3]`, we decide that the first element is our pivot. Then
    we sandwich it in between `[1,4,3]` and `[9,6,7]`. Once we’ve done that, we sort
    `[1,4,3]` and `[9,6,7]` by using the same approach.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图解说明了快速排序在我们例子中的工作原理。当我们想要排序`[5,1,9,4,6,7,3]`时，我们决定第一个元素是我们的枢轴。然后我们在`[1,4,3]`和`[9,6,7]`之间将其夹在中间。一旦我们这样做，我们就使用相同的方法对`[1,4,3]`和`[9,6,7]`进行排序。
- en: To sort `[1,4,3]`, we choose the first element, `1`, as the pivot and we make
    a list of elements that are less than or equal to `1`. That turns out to be the
    empty list, `[]`, because `1` is the smallest element in `[1,4,3]`. The elements
    larger than `1` go to its right, so that’s `[4,3]`. Again, `[4,3]` is sorted in
    the same way. It too will eventually be broken up into empty lists and put back
    together.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要排序`[1,4,3]`，我们选择第一个元素`1`作为枢轴，并创建一个包含小于或等于`1`的元素的列表。结果是一个空列表`[]`，因为`1`是`[1,4,3]`中最小的元素。大于`1`的元素移到它的右侧，所以是`[4,3]`。同样，`[4,3]`也是以相同的方式排序的。它最终也会被拆分成空列表并重新组合。
- en: The algorithm then returns to the right side of `1`, which has the empty list
    on its left side. Suddenly, we have `[1,3,4]`, which is sorted. This is kept on
    the left side of the `5`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 算法然后返回到`1`的右侧，其左侧是空列表。突然，我们有了`[1,3,4]`，它是排序好的。这被保留在`5`的左侧。
- en: 'Once the elements on the right side of the `5` are sorted in the same way,
    we will have a completely sorted list: `[1,3,4,5,6,7,9]`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`5`右侧的元素以相同的方式排序，我们将得到一个完全排序的列表：`[1,3,4,5,6,7,9]`。
- en: The Code
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: 'Now that we’re familiar with the quicksort algorithm, let’s dive into its implementation
    in Haskell:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了快速排序算法，让我们深入了解其在Haskell中的实现：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The type signature of our function is `quicksort :: (Ord a) => [a] -> [a]`,
    and the empty list is the base case, as we just saw.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '我们函数的类型签名是`quicksort :: (Ord a) => [a] -> [a]`，空列表是基础情况，正如我们刚才看到的。'
- en: Remember, we’ll put all the elements less than or equal to `x` (our pivot) to
    its left. To retrieve those elements, we use the list comprehension `[a | a <-
    xs, a <= x]`. This list comprehension will draw from `xs` (all the elements that
    aren’t our pivot) and keep only those that satisfy the condition `a <= x`, meaning
    those elements that are less than or equal to `x`. We then get the list of elements
    larger than `x` in a similar fashion.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们将所有小于或等于`x`（我们的枢轴）的元素放在它的左侧。要检索这些元素，我们使用列表推导式`[a | a <- xs, a <= x]`。这个列表推导式将从`xs`（所有不是我们的枢轴的元素）中抽取，并仅保留满足条件`a
    <= x`的元素，这意味着小于或等于`x`的元素。然后我们以类似的方式获取大于`x`的元素列表。
- en: 'We use `let` bindings to give the two lists handy names: `smallerOrEqual` and
    `larger`. Finally, we use the list concatenation operator (`++`) and a recursive
    application of our `quicksort` function to express that we want our final list
    to be made of a sorted `smallerOrEqual` list, followed by our pivot, followed
    by a sorted `larger` list.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`let`绑定来给两个列表起方便的名字：`smallerOrEqual`和`larger`。最后，我们使用列表连接运算符（`++`）和我们的`quicksort`函数的递归应用来表达我们想要最终的列表由一个排序后的`smallerOrEqual`列表、我们的枢轴以及一个排序后的`larger`列表组成。
- en: 'Let’s give our function a test drive to see if it behaves correctly:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下我们的函数，看看它是否表现正常：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that’s what I’m talking about!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我所说的！
- en: Thinking Recursively
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归思考
- en: 'We’ve used recursion quite a bit in this chapter, and as you’ve probably noticed,
    there’s a pattern to it. You start by defining a base case: simple, nonrecursive
    solution that holds when the input is trivial. For example, the result of sorting
    an empty list is the empty list, because—well, what else could it be?'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了大量的递归，而且正如你可能注意到的，它有一个模式。你首先定义一个基本情况：当输入是平凡的时，它保持简单、非递归的解决方案。例如，排序空列表的结果是空列表，因为——好吧，那还能是什么？
- en: Then, you break your problem down into one or many subproblems and recursively
    solve those by applying the same function to them. You then build up your final
    solution from those solved subproblems. For instance, when sorting, we broke our
    list into two lists, plus a pivot. We sorted each of those lists separately by
    applying the same function to them. When we got the results, we joined them into
    one big sorted list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将你的问题分解为一个或多个子问题，并通过对它们应用相同的函数递归地解决这些子问题。然后，你从这些已解决的子问题中构建你的最终解决方案。例如，在排序时，我们将我们的列表分解为两个列表，加上一个枢轴。我们通过将相同的函数应用于它们来分别对每个列表进行排序。当我们得到结果时，我们将它们合并成一个大的已排序列表。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802550.png.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages802550.png.jpg)'
- en: The best way to approach recursion is to identify base cases and think about
    how you can break the problem at hand into something similar, but smaller. If
    you’ve correctly chosen the base cases and subproblems, you don’t even have to
    think about the details of how everything will happen. You can just trust that
    the solutions of the subproblems are correct, and then you can just build up your
    final solutions from those smaller solutions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 处理递归的最佳方式是识别基本情况，并思考你如何将当前的问题分解成类似但更小的问题。如果你正确地选择了基本情况和子问题，你甚至不需要考虑所有事情发生的细节。你只需相信子问题的解决方案是正确的，然后你可以从这些较小的解决方案中构建你的最终解决方案。
