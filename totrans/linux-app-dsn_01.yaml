- en: '![](../images/25-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[**APPLIANCE ARCHITECTURE**](toc.html#chapter1)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/as.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We’ll begin our adventure with a high-level look at the architecture of a Linux
    appliance. We’ll then drop a little lower in altitude and look at a Linux appliance
    from the perspective of processes. As you’ll soon see, the view from this lower
    altitude matches the organization and chapters used throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • UIs and daemons
  prefs: []
  type: TYPE_NORMAL
- en: • The architecture of the Laddie appliance
  prefs: []
  type: TYPE_NORMAL
- en: We have worked on Linux appliances that range from small, handheld devices to
    large, multi-gigabyte, multi-processor network servers. Most of these appliances
    have a strikingly similar software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1-1 shows the software stack we typically see in a Linux appliance. At
    the bottom of this stack is an embedded Linux kernel. Above the kernel are the
    various user interfaces and common services such as network management and logging,
    and at the top is the particular function that defines the appliance.
  prefs: []
  type: TYPE_NORMAL
- en: Where appliances are concerned, the term *user interface (UI)* refers to an
    interface through which the user manages the appliance configuration and views
    its status and statistics. The lack of a screen and keyboard are hallmarks of
    an appliance, but do not let that fool you—all appliances have UIs. To be sure,
    the more invisible the UI the better the appliance, but the UI is always there
    nonetheless. Also, network appliances often have web, SNMP, and command line interfaces,
    while consumer appliances have framebuffers and small, alphanumeric LCD interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/26-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: Linux appliance software stack*'
  prefs: []
  type: TYPE_NORMAL
- en: '[**UIs and Daemons**](toc.html#chapter1.1)'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that our Linux appliance will have multiple, simultaneous UIs, when
    we look at the appliance from the point of view of running processes we get an
    architecture something like that shown in Figure 1-2\. The UI programs interact
    with the users to accept commands and configuration and to display status and
    statistics. Daemons, on the other hand, interact with the hardware, other daemons,
    and the UIs to provide the appliance’s defining service as well as status and
    statistics.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/26-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-2: A common appliance architecture*'
  prefs: []
  type: TYPE_NORMAL
- en: '[***Daemons***](toc.html#chapter1.2)'
  prefs: []
  type: TYPE_NORMAL
- en: Daemons are background programs that are most often started just after booting
    Linux. Daemons distinguish themselves in that they don’t have a controlling terminal
    like programs started from the bash command line. Let’s look at the kinds of daemons
    found on a typical appliance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining Application**'
  prefs: []
  type: TYPE_NORMAL
- en: The *defining application* in the diagram refers to the daemon that provides
    the unique function offered by the appliance. For example, the defining application
    for an advanced telephone answering machine is the daemon that actually answers
    the phone and records the call.
  prefs: []
  type: TYPE_NORMAL
- en: '**Logging Daemon**'
  prefs: []
  type: TYPE_NORMAL
- en: The *logging daemon* shown in Figure 1-2 collects log messages and either saves
    them to disk or routes them to another host on the network. The syslog daemon
    is the default logging daemon on most Linux systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Event Handler**'
  prefs: []
  type: TYPE_NORMAL
- en: The *event handler* provides a local, active response to events. Often the logging
    daemon and the event-handling daemon are one in the same, as they are in the logmuxd
    daemon that runs on our sample appliance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Security Monitor**'
  prefs: []
  type: TYPE_NORMAL
- en: The *security monitor* controls access to critical configuration or resources,
    such as identification and authentication credentials. The security monitor should
    also respond to Mandatory Access Control (MAC) violations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware Monitor**'
  prefs: []
  type: TYPE_NORMAL
- en: The *hardware monitor* watches for temperature alarms and disk drive problems.
    Most PC-based Linux appliances will use the lm_sensors package to monitor CPU
    and motherboard sensors and the smartd daemon to monitor the temperature and error
    statistics on hard disks. A hardware monitor might combine the information from
    these and other sources into a comprehensive report of the health of the appliance.
  prefs: []
  type: TYPE_NORMAL
- en: '[***User Interfaces***](toc.html#chapter1.3)'
  prefs: []
  type: TYPE_NORMAL
- en: When we first started building Linux appliances we thought that the nature of
    the appliance defined the type of UI it would have. Boy, were we wrong. Customers
    always ask for more than one way to manage the device. Smart-phones need a framebuffer
    interface *and* a web interface over Bluetooth. Network appliances need a web
    interface *and* an SNMP interface. When you look at Figure 1-2, don’t think “Which
    one?” Think “How many?”
  prefs: []
  type: TYPE_NORMAL
- en: The UIs depicted in Figure 1-2 are not the only possible choices. For example,
    you might want an interface that runs natively on a Windows PC, or if you’re building
    a network appliance, you may want to add interfaces to an LDAP or RADIUS authentication
    server or to the network’s billing system and database. Figure 1-2 shows the most
    common UIs and the ones described in the book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Web Interface**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *web interface* is mandatory if your appliance has a network interface. You’ll
    have a lot to decide here: Do you use JavaScript or not? Is the back end written
    in Perl, PHP, C, or Java? Which do you use? Do you presume that all browsers support
    cascading style sheets? Chapter 8 on web UIs will help you evaluate the trade-offs
    for all these issues.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Framebuffer Interface**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Framebuffer interfaces* are popular for television set-top boxes, such as
    TiVo or a PVR, stand-alone kiosks, and some handheld devices. The hardware in
    a framebuffer gives you direct control over each pixel on the screen. This gives
    you great flexibility in what your interface looks like, but at the cost of burdening
    you with *managing* every pixel on the screen. Some libraries and graphics toolsets,
    such as the Simple DirectMedia Layer (SDL) can help. The art in building a framebuffer
    interface is in choosing the right toolset.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Front Panel**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Front panel interfaces*, whether simple or complex, appear on almost all Linux
    appliances. A simple front panel might have only a few lights and buttons, while
    a more complex one might have an alphanumeric liquid crystal display (LCD) or
    a vacuum florescent display. Even a simple front panel may require a deep understanding
    of the underlying hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SNMP Interface**'
  prefs: []
  type: TYPE_NORMAL
- en: We have heard it said that an *SNMP interface* makes the difference between
    a commercially viable network appliance and a hobby. From our experience we’d
    have to agree. SNMP is not too difficult if you break it into pieces. First, you
    need to familiarize yourself with the concepts used in SNMP and with the SNMP
    commands available in Linux. Then, you need to design a Management Information
    Base (MIB), or schema, for the data made visible by your SNMP interface. Finally,
    you need to write the software that makes the MIB available to the SNMP commands.
  prefs: []
  type: TYPE_NORMAL
- en: '**Command Line Interfaces**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Command line interfaces* (CLIs) are often used as the control interface of
    last resort for network appliances. A CLI on a serial port remains available even
    when the entire network is down. CLIs also find use as an appliance-specific scripting
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: '[***Interprocess Communication***](toc.html#chapter1.4)'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you may have noticed the full-mesh interconnect of lines in Figure
    1-2\. Don’t let it intimidate you. Our point is that any UI should be able to
    connect to any daemon. This requirement dictates a lot of the features to look
    for in the interprocess communication (IPC) mechanism used between the UIs and
    the daemons. (We’ll have more to say about this in Chapter 2.)
  prefs: []
  type: TYPE_NORMAL
- en: '[**The Architecture of the Laddie Appliance**](toc.html#chapter1.5)'
  prefs: []
  type: TYPE_NORMAL
- en: This book’s sample appliance is an alarm system that uses the input pins on
    a parallel port for input from the alarm sensors. The UIs include web, command
    line, LCD with a keypad, framebuffer with IR remote control, and SNMP.
  prefs: []
  type: TYPE_NORMAL
- en: The daemons on our appliance include the alarm system daemon and one to respond
    to appliance events. We chose not to implement all of the daemons shown in Figure
    1-2 so that we could focus on describing how to build and secure daemons in general.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, our sample appliance includes ladd (the defining application), an
    event handler, and a utility to make common Linux configuration files visible
    using a protocol common to all the UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1-3 shows the architecture of the Laddie appliance and maps the UI, feature,
    or daemon to a chapter number or appendix so that you can see how things will
    come together throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/29-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-3: A chapter map of the Laddie appliance*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve limited the functionality of our UIs to make them more useful as tutorials.
    Only the web interface is full featured and representative of what a real appliance
    might have.
  prefs: []
  type: TYPE_NORMAL
- en: '[**Summary**](toc.html#chapter1.6)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most Linux appliances have a common architecture: Linux on the bottom, the
    defining application on top, and common services and UIs in the middle. We discussed
    some of the reasons to include various daemons and UIs and mapped this book’s
    chapters into an architecture diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter looks at the API between the UIs and daemons, since the chosen
    API impacts both UIs and daemons.
  prefs: []
  type: TYPE_NORMAL
