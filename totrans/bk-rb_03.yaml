- en: Chapter 3. Strings and Ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I’ve made use of strings in many of my programs so far. In fact, a string was
    featured in the very first program in the book. Here it is again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Although that first program used a string enclosed within single quotes, my
    second program used a string in double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Double-quoted strings do more work than single-quoted strings. In particular,
    they have the ability to evaluate bits of themselves as though they were programming
    code. To have something evaluated, you need to place it between a pair of curly
    brackets preceded by a hash mark (`#`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, `#{name}` in a double-quoted string tells Ruby to
    get the value of the `name` variable and insert that value into the string itself.
    The second line of code calls the `gets()` method to get some user input, which
    is then assigned to the variable `name`. If the user entered **`Fred`**, the final
    line of code would evaluate the embedded variable, `#{name}`, and the string “Hello
    Fred” would be displayed. The *1strings.rb* sample program provides a few more
    examples of embedded evaluation in double-quoted strings. For example, here I
    have created an object, ob, from a custom class, MyClass, and used embedded evaluation
    to display the values of its `name` and `number` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*1strings.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When the final line of code executes, this is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A double-quoted string can also evaluate expressions such as `2*3`, bits of
    code such as the method-call `ob.ten` (where `ten` is a method name), and escape
    characters such as `\n` and `\t` (representing a newline and a tab). A single-quoted
    string does no such evaluation. A single-quoted string can, however, use a backslash
    to indicate that the next character should be used literally. This is useful when
    a single-quoted string contains a single-quote character, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that the method named `ten` returns the value 10, you might write
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this is a double-quoted string, the embedded elements are evaluated,
    and the following is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s see what happens when a single-quoted string is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, no embedded evaluation is done, so this is what is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: User-Defined String Delimiters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If, for some reason, single and double quotes aren’t convenient—for example,
    if your strings contain lots of quote characters and you don’t want to have to
    keep putting backslashes in front of them—you can also delimit strings in many
    other ways.
  prefs: []
  type: TYPE_NORMAL
- en: The standard alternative delimiters for double-quoted strings are `%Q` and `/`
    or `%/` and `/`, while for single-quoted strings they are `%q` and `/`. Thus .
    . .
  prefs: []
  type: TYPE_NORMAL
- en: '*2strings.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even define your own string delimiters. They must be nonalphanumeric
    characters, and they may include nonprinting characters such as newlines or tabs
    as well as various characters that normally have a special meaning in Ruby such
    as the hash mark (`#`). Your chosen character should be placed after `%q` or `%Q`,
    and you should be sure to terminate the string with the same character. If your
    delimiter is an opening square bracket, the corresponding closing bracket should
    be used at the end of the string, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*3strings.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will find examples of a broad range of user-selected string delimiters
    in the sample program *3strings.rb*. Here are two examples using an asterisk (`*`)
    after `%Q` instead of a double-quoted string and using an exclamation point (`!`)
    after `%q` instead of a single-quoted string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, as in the previous program, ob is a user-defined object whose method
    named `ten` returns the integer, 10\. The previous code produces the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Although there may be times when it is useful to delimit a string by some esoteric
    character such as a newline or an asterisk, in many cases the disadvantages (not
    least the mental anguish and confusion) resulting from such arcane practices may
    significantly outweigh the advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Backquotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One other type of string deserves a special mention: a string enclosed by backquotes—that
    is, the inward-pointing quote character that is usually tucked away up toward
    the top-left corner of the keyboard: `` ` ``.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby considers anything enclosed by back-quotes to be a command that can be
    passed for execution by the operating system using a method such as `print` or
    `puts`. By now, you will probably already have guessed that Ruby provides more
    than one way of doing this. It turns out `%x/some command/` has the same effect
    as `` `somecommand` `` and so does `%x{some command}`. On the Windows operating
    system, for example, each of the three lines shown next would pass the command
    `dir` to the operating system, causing a directory listing to be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '*4backquotes.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also embed commands inside double-quoted strings like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Be careful if you do this. The command itself is evaluated first. Your Ruby
    program then waits until the process that starts has terminated. In the present
    case, the calculator will pop up. You are now free to do some calculations, if
    you want. Only when you close the calculator will the string “Goodbye” be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: String Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before leaving the subject of strings, you’ll take a quick look at a few common
    string operations.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can concatenate strings using `<<` or `+` or just by placing a space between
    them. Here are three examples of string concatenation; in each case, `s` is assigned
    the string “Hello world”:'
  prefs: []
  type: TYPE_NORMAL
- en: '*hello_world_concat.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that when you use the `<<` method, you can append Fixnum integers (in
    the range 0 to 255), in which case those integers are converted to the character
    with that character code. Character codes 65 to 90 are converted to the uppercase
    characters *A* to *Z*, 97 to 122 are converted to the lowercase *a* to *z*, and
    other codes are converted to punctuation, special characters, and nonprinting
    characters. However, if you want to print the number itself, you must convert
    it to a string using the `to_s` method. The `to_s` method is obligatory when concatenating
    Fixnums using the `+` method or a space; attempting to concatenate a number without
    using `to_s` is an error. The following program prints out characters and numeric
    codes for values between 0 and 126, which include the standard Western alphanumeric
    and punctuation characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '*char_codes.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For examples of concatenating using `<<`, `+`, or a space, see *string_contact.rb*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*string_contact.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous program produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What About Commas?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may sometimes see Ruby code that uses commas to separate strings and other
    data types. In some circumstances, these commas appear to have the effect of concatenating
    strings. For example, the following code might, at first sight, seem to create
    and display a string from three substrings plus an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, a list separated by commas creates an array—an ordered list of the
    original strings. The *string_concat.rb* program contains examples that prove
    this to be the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code causes the following to be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first `print` statement here looks as though it is displaying a single string.
    This is because each successive item in the array, `x`, is printed on the same
    line as the preceding item. When you use `puts` instead of `print`, you can see
    that each item is printed on a separate line. This is because `puts` prints each
    item in turn and appends a carriage return after it. The fact that you are dealing
    with an array rather than a string is confirmed when you ask Ruby to print the
    class of the `x` object. It displays `Array`. You’ll learn about arrays in more
    depth in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: String Assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Ruby String class provides a number of useful string-handling methods.
    Most of these methods create new string objects. So, for example, in the following
    code, the `s` on the left side of the assignment on the second line is not the
    same object as the `s` on the right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A few string methods actually alter the string itself without creating a new
    object. These methods generally end with an exclamation mark (for example, the
    `capitalize!` method changes the original string, whereas the `capitalize` method
    does not). In addition, the string itself is also modified—and no new string is
    created—when you assign a character at an index of the string. For example, `s[1]
    = 'A'` would place the character *A* at index 1 (the second character) of the
    string `s`.
  prefs: []
  type: TYPE_NORMAL
- en: If in doubt, you can check an object’s identity using the `object_id` method.
    I’ve provided a few examples of operations that do and do not create new strings
    in the *string_assign.rb* program. Run this, and check the `object_id` of `s`
    after each string operation is performed.
  prefs: []
  type: TYPE_NORMAL
- en: '*string_assign.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces output similar to that shown next. The actual object ID values
    may differ, but the important thing to notice is when consecutive values remain
    the same, showing that the string object, `s`, remains the same and, when they
    change, showing that a new string object, `s`, has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Indexing into a String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In one of the previous examples, I treated a string as an array of characters
    and specified a character index with an integer inside square brackets: `s[1]`.
    Strings and arrays in Ruby are indexed from the first character at index 0\. So,
    for instance, to replace the character *e* with *u* in the string `s` (which currently
    contains “Hello world”), you would assign a new character to index 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you index into a string in order to find a character at a specific location,
    the behavior differs according to which version of Ruby you are using. Ruby 1.8
    returns a numeric ASCII code of the character, whereas Ruby 1.9 returns the character
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To obtain the actual character from the numeric value returned by Ruby 1.8,
    you can use a double index to print a single character, starting at index 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If, on the other hand, you need the numeric value of the character returned
    by Ruby 1.9, you can use the `ord` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ord` method does not exist in Ruby 1.8, so the previous code causes an
    “undefined method” error. To ensure compatibility between Ruby 1.8 and 1.9, you
    should use the double-index technique, with the first index indicating the starting
    position and the second index indicating the number of characters. For example,
    this returns one character at position 1: `s[1,1]`. You can see some more examples
    in the *char_in_string.rb* program:'
  prefs: []
  type: TYPE_NORMAL
- en: '*char_in_string.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, Ruby 1.9 displays this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'whereas Ruby 1.8 displays this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use double-indexes to return more than one character. If you want
    to return three characters starting at position 1, you would enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells Ruby to start at position 1 and return the next three characters.
    Alternatively, you could use the two-dot range notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ranges are discussed in more detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings can also be indexed using negative values, in which case −1 is the
    index of the last character, and, once again, you can specify the number of characters
    to be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '*string_index.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When specifying ranges using a negative index, you must use negative values
    for both the start and end indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*string_methods.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you may want to experiment with a few of the standard methods available
    for manipulating strings. These include methods to change the case of a string,
    reverse it, insert substrings, remove repeating characters, and so on. I’ve provided
    a few examples in *string_methods.rb*. The method names are generally descriptive
    of their functions. However, bear in mind that methods such as `reverse` (with
    no `!` at the end) return a new string but do not modify the original string,
    whereas `reverse!` (with the `!`) modifies the original string. You saw similar
    behavior with the `capitalize` end `capitalize!` methods used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `insert` method takes two arguments, an index and a string, and it inserts
    the string argument at the given index of the string, `s`. The `squeeze` method
    returns a string with any repeating character, such as the second adjacent *l*
    in “Hello” removed. The `split` method splits a string into an array. I’ll have
    more to say on `split` when I discuss regular expressions in [Chapter 6](ch06.html
    "Chapter 6. Conditional Statements"). The following examples assume that `s` is
    the string “Hello world” and the output is shown in the `#=>` comments. In the
    program supplied in this book’s code archive, you may also experiment using much
    longer strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing Newline Characters: chop and chomp'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A couple of handy string-processing methods deserve special mention. The `chop`
    and `chomp` methods can be used to remove characters from the end of a string.
    The `chop` method returns a string with the last character removed or with the
    carriage return and newline characters removed (`\r\n`) if these are found at
    the end of the string. The `chomp` method returns a string with the terminating
    carriage return or newline character removed (or both the carriage return *and*
    the newline character if both are found).
  prefs: []
  type: TYPE_NORMAL
- en: These methods are useful when you need to remove line feeds entered by the user
    or read from a file. For instance, when you use `gets` to read in a line of text,
    this returns the line including the terminating *record separator*, which, by
    default, is the newline character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Record Separator: $/'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby predefines a variable, `$/`, as a record separator. This variable is used
    by methods such as `gets` and `chomp`. The `gets` method reads in a string up
    to and including the record separator. The `chomp` method returns a string with
    the record separator removed from the end (if present); otherwise, it returns
    the original string unmodified. You can redefine the record separator if you want,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When you redefine the record separator, this new character (or string) will
    now be used by methods such as `gets` and `chomp`. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*record_separator.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can remove the newline character using either `chop` or `chomp`. In most
    cases, `chomp` is preferable because it won’t remove the final character unless
    it is the record separator (usually a newline), whereas `chop` will remove the
    last character no matter what it is. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '*chop_chomp.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `chomp` method also lets you specify a character or string to use as the
    separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Format Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ruby provides the `printf` method to print “format strings” containing specifiers
    starting with a percent sign (`%`). The format string may be followed by one or
    more data items separated by commas; the list of data items should match the number
    and type of the format specifiers. The actual data items replace the matching
    specifiers in the string, and they are formatted accordingly. These are some common
    formatting specifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can control floating-point precision by putting a point-number before the
    floating-point formatting specifier, `%f`. For example, this would display the
    floating-point value to six digits (the default) followed by a carriage return
    (`"\n"`):'
  prefs: []
  type: TYPE_NORMAL
- en: '*string_printf.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: And the following would display the floating-point value to two digits (`"%0.02f"`).
    It is purely a matter of stylistic preference whether the floating-point specifier
    includes a preceding 0 or not and `"%0.2f"` is equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a couple more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: That would output `d=10 f=10.000000 o=12 x=a s=10`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'That would output `0.04f=10.1295 : 0.02f=10.13`.'
  prefs: []
  type: TYPE_NORMAL
- en: Ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Ruby, a Range is a class that represents a set of values defined by a starting
    value and an ending value. Typically a range is defined using integers, but it
    may also be defined using other ordered values such as floating-point numbers
    or characters. Values can be negative, though you should be careful that your
    starting value is lower than your ending value!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ranges.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify ranges using three dots instead of two; this creates a
    range that omits the final value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create an array of the values defined by a range using the `to_a` method,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that `to_a` is not defined for floating-point numbers for the simple reason
    that the number of possible values between two floating-point numbers is not finite.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges of Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can even create ranges of strings—though you would need to take great care
    in so doing because you might end up with more than you bargain for. For example,
    see whether you can figure out which values are specified by this range:'
  prefs: []
  type: TYPE_NORMAL
- en: '*str_range.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'At first sight, the range from `''abc''` to `''def''` might not look like much.
    In fact, this defines a range of no less than 2,110 values! They are ordered like
    this: `abc`, `abd`, `abe`, and so on, until the end of the *a*s; then you start
    on the *b*s: `baa`, `bab`, `bac`, and so on. Suffice to say that ranges of this
    sort are probably rather a rare requirement and are best used with extreme caution
    or not at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Iterating with a Range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may use a range to iterate from a start value to an end value. For example,
    here is one way of printing all the numbers from 1 to 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '*for_to.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: Here you will learn how to create and iterate over ranges, write multiline strings
    with heredocs, and define your own string delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: Heredocs
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you can write long strings spanning multiple lines between single
    or double quotes, many Ruby programmers prefer to use an alternative type of string
    called a *heredoc*. A heredoc is a block of text that starts by specifying an
    end marker, which is simply an identifier of your choice. Here, I specify `EODOC`
    as the end marker:'
  prefs: []
  type: TYPE_NORMAL
- en: '*heredoc.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells Ruby that everything following the previous line is a single string
    that terminates when the end marker is located. The string is assigned to the
    variable, `hdoc1`. Here is an example of a complete heredoc assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, heredocs are treated as double-quoted strings, so expressions such
    as `#{"cloud".upcase}` will be evaluated. If you want a heredoc to be treated
    as single-quoted string, specify its end marker between single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The end marker of a heredoc must, by default, be placed flush with the left
    margin. If you want to indent it, you should use `<<-` rather than `<<` when assigning
    the end marker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It is up to you to pick an appropriate end marker. It is even legitimate (though,
    perhaps, not particularly sensible!) to use a reserved word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'A variable to which a heredoc is assigned can be used just like any other string
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: String Literals
  prefs: []
  type: TYPE_NORMAL
- en: As explained earlier in this chapter, you can optionally delimit strings by
    `%q/` and `/` for single-quoted strings and either `%Q/` and `/` or `%/` and `/`
    for double-quoted strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby provides similar means of delimiting back-quoted strings, regular expressions,
    symbols, and arrays of either single-quoted or double-quoted strings. The ability
    to define arrays of strings in this way is particularly useful since it avoids
    the necessity of entering string delimiters for each item. Here is a reference
    to these string literal delimiters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you may choose which delimiters to use. I have used `/` except with
    the regular expression where I have used `|` (since `/` is the “normal” regular
    expression delimiter), but I could equally have used square brackets, asterisks,
    ampersands, or other symbols (for example, `%W*dog cat #{1+2}*` or `%s&dog&`).
    Here is an example of these literals in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '*literals.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
