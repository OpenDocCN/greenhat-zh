- en: Chapter 5. Loops and Iterators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。循环和迭代器
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: Much of programming is concerned with repetition. Maybe you want your program
    to beep 10 times, read lines from a file as long as there are more lines to read,
    or display a warning until the user presses a key. Ruby provides a number of ways
    of performing this kind of repetition.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程都涉及重复。也许你希望程序响铃10次，只要还有更多行要读取，就读取文件中的行，或者显示警告直到用户按下键。Ruby提供了多种执行此类重复的方法。
- en: for Loops
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: In many programming languages, when you want to run a bit of code a certain
    number of times, you can just put it inside a `for` loop. In most languages, you
    give a `for` loop a variable initialized with a starting value that is incremented
    by 1 on each turn through the loop until it meets some specific ending value.
    When the ending value is met, the `for` loop stops running.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言中，当你想要运行一段代码一定次数时，你只需将其放在`for`循环中即可。在大多数语言中，你给`for`循环一个变量，该变量初始化为起始值，并在每次循环迭代中增加1，直到它达到某个特定的结束值。当达到结束值时，`for`循环停止运行。
- en: 'Here’s a version of this traditional type of `for` loop written in Pascal:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这种传统类型的`for`循环的Pascal版本：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may recall from the previous chapter that Ruby’s `for` loop doesn’t work
    like this at all! Instead of giving it starting and ending values, you give the
    `for` loop a list of items, and it iterates over them, one by one, assigning each
    value in turn to a loop variable until it gets to the end of the list.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，在上一章中，Ruby的`for`循环根本不是这样工作的！你不需要给它起始和结束值，你只需要给`for`循环一个项目列表，它会逐个迭代它们，将每个值依次分配给循环变量，直到到达列表的末尾。
- en: 'For example, here is a `for` loop that iterates over the items in an array,
    displaying each in turn:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个遍历数组中项的`for`循环，依次显示每个项：
- en: '*for_loop.rb*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*for_loop.rb*'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `for` loop is more like the “for each” iterator provided by some other
    programming languages. The items over which the loop iterates don’t have to be
    integers. This works just as well:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环更像是某些其他编程语言提供的“for each”迭代器。循环迭代的项不必是整数。这也同样有效：'
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The author of Ruby describes `for` as “syntax sugar” for the `each` method,
    which is implemented by collection types such as Arrays, Sets, Hashes, and Strings
    (a String being, in effect, a collection of characters). For the sake of comparison,
    this is one of the `for` loops shown earlier rewritten using the `each` method:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby的作者将`for`描述为`each`方法的“语法糖”，该方法由数组、集合、哈希和字符串（字符串实际上是一组字符的集合）等集合类型实现。为了比较，这是之前显示的`for`循环之一，使用`each`方法重写的版本：
- en: '*each_loop.rb*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*each_loop.rb*'
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, there isn’t really all that much difference. To convert the
    `for` loop to an `each` iterator, all I’ve had to do is delete `for` and `in`
    and append `.each` to the array. Then I’ve put the iterator variable, `i`, between
    a pair of upright bars after `do`. Compare these other examples to see just how
    similar `for` loops are to `each` iterators.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，实际上并没有太大的区别。要将`for`循环转换为`each`迭代器，我只需要删除`for`和`in`，并在数组后附加`.each`。然后我在`do`之后将迭代器变量`i`放在一对竖线之间。比较这些其他示例，看看`for`循环和`each`迭代器有多么相似。
- en: '*for_each.rb*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*for_each.rb*'
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note, incidentally, that the `do` keyword is optional in a `for` loop that
    spans multiple lines, but it is obligatory when it is written on a single line:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，在跨越多行的`for`循环中，`do`关键字是可选的，但当它写在单行时则是必需的：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This example shows how both `for` and `each` can be used to iterate over the
    values in a range:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了`for`和`each`都可以用来遍历范围内的值：
- en: '*for_each2.rb*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*for_each2.rb*'
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How to Write a “Normal” for Loop
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如何编写“常规”的`for`循环
- en: 'If you miss the traditional type of `for` loop, you can always fake it in Ruby
    by using a `for` loop to iterate over the values in a range. For example, this
    is how to use a `for` loop variable to count up from 1 to 10, displaying its value
    at each turn through the loop:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你错过了传统的`for`循环类型，你总是可以在Ruby中使用`for`循环遍历一个范围内的值来模拟它。例如，这就是如何使用`for`循环变量从1计数到10，并在每次循环迭代中显示其值：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*for_to.rb*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*for_to.rb*'
- en: Note, incidentally, that a range expression such as `1..3` must be enclosed
    between parentheses when used with the `each` method, or Ruby assumes you are
    attempting to use `each` as a method of the final integer (a Fixnum) rather than
    of the entire expression (a Range). The parentheses are optional when a range
    is used in a `for` loop.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，当与 `each` 方法一起使用时，例如 `1..3` 这样的范围表达式必须放在括号内，否则 Ruby 会假设你试图将 `each` 作为最终整数（Fixnum）的方法，而不是整个表达式（Range）的方法。当在
    `for` 循环中使用范围时，括号是可选的。
- en: Blocks and Block Parameters
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块和块参数
- en: In Ruby, the body of an iterator is called a *block*, and any variables declared
    between upright bars at the top of a block are called *block parameters*. In a
    way, a block works like a function, and the block parameters work like a function’s
    argument list. The `each` method runs the code inside the block and passes to
    it the arguments supplied by a collection (such as the array, `multiarr`). In
    the example from the previous section, the `each` method repeatedly passes an
    array of four elements to the block, and those elements initialize the four block
    parameters, `a, b, c, d`. Blocks can be used for other things, in addition to
    iterating over collections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，迭代器的主体被称为 *块*，而在块顶部竖线之间声明的任何变量被称为 *块参数*。从某种意义上说，块就像一个函数，而块参数就像函数的参数列表。`each`
    方法运行块内的代码，并将由集合（如数组 `multiarr`）提供的参数传递给它。在上一节中的示例中，`each` 方法反复将一个包含四个元素的数组传递给块，这些元素初始化了四个块参数
    `a`、`b`、`c`、`d`。除了遍历集合之外，块还可以用于其他目的。
- en: 'Ruby also has an alternative syntax for delimiting blocks. Instead of using
    `do..end`, you can use curly brackets `{..}` like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 还有一种用于定义块的替代语法。你不需要使用 `do..end`，而是可以使用这样的花括号 `{..}`：
- en: '*block_syntax.rb*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*block_syntax.rb*'
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: No matter which block delimiters you use, you must ensure that the opening delimiter,
    `{` or `do`, is placed on the same line as the `each` method. Inserting a line
    break between `each` and the opening block delimiter is a syntax error. I’ll have
    more to say on blocks in [Chapter 10](ch10.html "Chapter 10. Blocks, Procs, and
    Lambdas").
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪种块定界符，都必须确保开界定符 `{` 或 `do` 放在与 `each` 方法相同的行上。在 `each` 和开块界定符之间插入换行符是一个语法错误。我将在第
    [10章](ch10.html "第10章。块、Proc和Lambda") 中有更多关于块的内容要讲。
- en: Iterating upto and downto
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代到和倒序迭代
- en: 'If you need to count from a specific low value up to a high value, you may
    use the `upto()` method of an integer. A block argument may optionally be used
    if you want to display the value at each iteration:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从一个特定的低值计数到高值，你可以使用整数的 `upto()` 方法。如果你想在每次迭代中显示值，可以使用可选的块参数：
- en: '*upto_downto.rb*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*upto_downto.rb*'
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The previous code displays the integers 0 to 10\. You may also count down from
    a high to a low value using the `downto()` method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码显示了从 0 到 10 的整数。你也可以使用 `downto()` 方法从高值向下计数到低值：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can probably guess, this code displays 10 to 0.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所能猜到的，这段代码显示了从 10 到 0。
- en: Multiple Iterator Arguments
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个迭代器参数
- en: 'In the previous chapter, you used a `for` loop with more than one loop variable
    to iterate over a multidimensional array. On each turn through the `for` loop,
    a variable was assigned one row (that is, one “subarray”) from the outer array:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你使用了一个包含多个循环变量的 `for` 循环来遍历一个多维数组。在 `for` 循环的每次迭代中，一个变量从外数组中分配了一行（即一个“子数组”）：
- en: '*multi_array.rb*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*multi_array.rb*'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The previous loop prints this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的循环打印出以下内容：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, you could also use the `each` method to iterate over this four-item
    array by passing four block parameters—`a`, `b`, `c`, `d`—into the block delimited
    by `do` and `end` at each iteration:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你也可以使用 `each` 方法通过传递四个块参数——`a`、`b`、`c`、`d`——在每次迭代中通过 `do` 和 `end` 定界的块来遍历这个包含四个元素的数组：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And, of course, the alternative block syntax, delimited by curly brackets,
    works just as well:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有使用花括号分隔的替代块语法，它同样有效：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Both of the previous examples pass the two elements from the `multiarr` array
    into the iterator block. The first element is itself an array of four strings:
    `[''one'',''two'',''three'',''four'']`. Since the block has four parameters declared
    between a pair of upright bars, `|a,b,c,d|`, the four strings are assigned to
    the matching parameters, which are then printed with the `print` statement. Then
    the `each` method passes the second element of `multiarr` into the block. This
    is another four-element array, this time containing integers: `[1,2,3,4]`. These
    are again assigned to the block parameters, `|a,b,c,d|`, and the `print` statement
    displays them. Note that the output is identical as when you used the `for` loop:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的两个例子都将`multiarr`数组中的两个元素传递给迭代块。第一个元素本身是一个包含四个字符串的数组：`['one','two','three','four']`。由于块在竖线`|a,b,c,d|`之间声明了四个参数，这四个字符串被分配给匹配的参数，然后使用`print`语句打印出来。然后`each`方法将`multiarr`的第二个元素传递给块。这是一个包含整数的四个元素数组：`[1,2,3,4]`。这些也被分配给块参数`|a,b,c,d|`，`print`语句显示它们。请注意，输出与使用for循环时的输出相同：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: while Loops
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: while循环
- en: 'Ruby has a few other loop constructs too. This is how to do a `while` loop:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby还有一些其他的循环结构。这是如何进行while循环的：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or, here’s another way to put it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以这样表达：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Even though the syntax of these two examples is different, they perform the
    same function. In the first example, the code between `while` and `end` (here
    a call to a method named `sleep`) executes just as long as the Boolean condition
    (which, in this case, is the value returned by a method called `tired`) evaluates
    to true. As in `for` loops, the keyword `do` may optionally be placed between
    the test condition and the code to be executed when these appear on separate lines;
    the `do` keyword is obligatory when the test condition and the code to be executed
    appear on the same line.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个例子的语法不同，但它们执行的功能相同。在第一个例子中，`while`和`end`之间的代码（这里是对名为`sleep`的方法的调用）只要布尔条件（在这种情况下，是名为`tired`的方法返回的值）评估为true就会执行。与for循环一样，当测试条件和要执行的代码出现在不同的行上时，可以在它们之间可选地放置`do`关键字；当测试条件和要执行的代码出现在同一行上时，`do`关键字是必需的。
- en: while Modifiers
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: while循环修饰符
- en: 'In the second version of the loop (`sleep while tired`), the code to be executed
    (`sleep`) precedes the test condition (`while tired`). This syntax is called a
    *while modifier*. When you want to execute several expressions using this syntax,
    you can put them between the `begin` and `end` keywords:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的第二个版本（`sleep while tired`）中，要执行的代码（`sleep`）位于测试条件（`while tired`）之前。这种语法称为while修饰符。当你想使用这种语法执行多个表达式时，你可以将它们放在begin和end关键字之间：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is an example showing the various alternative syntaxes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，展示了各种不同的语法：
- en: '*1loops.rb*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*1loops.rb*'
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The last example in the previous code (the multiline `while` modifier) needs
    close consideration because it introduces some important new behavior. When a
    block of code delimited by `begin` and `end` precedes the `while` test, that code
    always executes at least once. In the other types of `while` loop, the code may
    never execute at all if the Boolean condition initially evaluates to false.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的最后一个例子（多行的while循环修饰符）需要仔细考虑，因为它引入了一些重要的新行为。当一个由begin和end分隔的代码块位于while测试之前时，该代码总是至少执行一次。在其他类型的while循环中，如果布尔条件最初评估为false，则代码可能根本不会执行。
- en: Ensuring a while Loop Executes at Least Once
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保while循环至少执行一次
- en: Usually a `while` loops executes zero or more times since the Boolean test is
    evaluated before the loop executes; if the test returns false at the outset, the
    code inside the loop never runs. However, when the `while` test follows a block
    of code enclosed between `begin` and `end`, the loop executes one or more times
    as the Boolean expression is evaluated after the code inside the loop executes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，while循环执行零次或多次，因为布尔测试是在循环执行之前评估的；如果测试一开始就返回false，则循环内的代码永远不会运行。然而，当while测试跟在由begin和end括起来的代码块之后时，循环会根据布尔表达式的评估执行一次或多次，因为布尔表达式是在循环内的代码执行之后评估的。
- en: 'These examples should help clarify:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子应该有助于澄清：
- en: '*2loops.rb*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*2loops.rb*'
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: until Loops
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: until循环
- en: Ruby also has an `until` loop, which can be thought of as a *while not* loop.
    Its syntax and options are the same as those applying to `while`—that is, the
    test condition and the code to be executed can be placed on a single line (in
    which case the `do` keyword is obligatory) or can be placed on separate lines
    (in which case `do` is optional). There is also an `until` modifier that lets
    you put the code before the test condition and an option to enclose the code between
    `begin` and `end` in order to ensure that the code block is run at least once.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 还有一个 `until` 循环，可以将其视为 *while not* 循环。其语法和选项与 `while` 相同——也就是说，测试条件和要执行的代码可以放在同一行（在这种情况下，`do`
    关键字是强制性的）或放在不同的行（在这种情况下，`do` 是可选的）。还有一个 `until` 修饰符，允许你将代码放在测试条件之前，并有一个选项将代码放在
    `begin` 和 `end` 之间，以确保代码块至少运行一次。
- en: 'Here are some simple examples of `until` loops:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些 `until` 循环的简单示例：
- en: '*until.rb*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*until.rb*'
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Both `while` and `until` loops can, just like a `for` loop, be used to iterate
    over arrays and other collections. For example, the following code shows two ways
    of iterating over all the elements in an array:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 和 `until` 循环都可以像 `for` 循环一样，用于遍历数组和其他集合。例如，以下代码展示了两种遍历数组中所有元素的方法：'
- en: '*array_iterate.rb*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*array_iterate.rb*'
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: loop
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: loop
- en: 'Unlike `for` and `while`, the `loop` command does not evaluate a test condition
    to determine whether to continue looping. To break out of the loop, you have to
    explicitly use the `break` keyword, as you can see in the following examples:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `for` 和 `while` 不同，`loop` 命令不会评估测试条件以确定是否继续循环。要跳出循环，你必须显式地使用 `break` 关键字，如下面的示例所示：
- en: '*3loops.rb*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*3loops.rb*'
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: These use the `loop` method repeatedly to execute the block of code that follows.
    These blocks are just like the iterator blocks you used earlier with the `each`
    method. Once again, you have a choice of block delimiters, either curly brackets
    or `do` and `end`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些使用 `loop` 方法重复执行随后的代码块。这些块与之前使用 `each` 方法时使用的迭代器块类似。再次强调，你有选择块定界符，要么是花括号，要么是
    `do` 和 `end`。
- en: In each case, the code iterates through the array, `arr`, by incrementing a
    counter variable, `i`, and breaking out of the loop when the `(i == arr.length)`
    condition evaluates to true. Note that without a `break`, these would loop forever.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，代码通过递增计数器变量 `i` 来遍历数组 `arr`，并在 `(i == arr.length)` 条件评估为 true 时跳出循环。注意，如果没有
    `break`，这些循环将永远进行下去。
- en: Digging Deeper
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: Ruby provides a number of ways of iterating over items in structures such as
    arrays and ranges. Here we discover the inner details of the enumerations and
    comparisons.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 提供了多种遍历数组、范围等结构中项的方法。在这里，我们发现了枚举和比较的内部细节。
- en: The Enumerable Module
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Enumerable 模块
- en: 'Hashes, Arrays, Ranges, and Sets all include a Ruby module called `Enumerable`.
    It provides these data structures with a number of useful methods such as `include?`,
    which returns true if a specific value is found; `min`, which returns the smallest
    value; `max`, which returns the largest; and `collect`, which creates a new structure
    made up of values returned from a block. In the following code, you can see some
    of these functions being used on an array:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Hashes、Arrays、Ranges 和 Sets 都包含一个名为 `Enumerable` 的 Ruby 模块。它为这些数据结构提供了一些有用的方法，例如
    `include?`，如果找到特定值则返回 true；`min`，返回最小值；`max`，返回最大值；以及 `collect`，它创建一个由块返回的值组成的新结构。在以下代码中，你可以看到一些这些函数在数组上的使用：
- en: '*enum.rb*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*enum.rb*'
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'These same methods are available to other collection classes too, as long as
    those classes include `Enumerable`. Here’s an example using the Hash class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些相同的方法也适用于其他包含 `Enumerable` 的集合类。以下是一个使用 Hash 类的示例：
- en: '*enum2.rb*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*enum2.rb*'
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This code outputs the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码输出以下内容：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that because of changes in the way hashes are stored, the order of the
    items displayed when this code runs differs in Ruby 1.8 and Ruby 1.9\. Remember
    too that the items in a Hash are not indexed in sequential order, so when you
    use the `min` and `max` methods, these return the items that are lowest and highest
    according to their numerical value—here the items are strings, and the numerical
    value is determined by the ASCII codes of the characters in the key.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于哈希存储方式的变化，当此代码运行时，Ruby 1.8 和 Ruby 1.9 显示的项目顺序不同。还要记住，哈希中的项目不是按顺序索引的，所以当你使用
    `min` 和 `max` 方法时，这些返回根据它们的数值最低和最高的项目——这里的项是字符串，数值由键中字符的 ASCII 码确定。
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Custom Comparisons
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义比较
- en: 'What if you want `min` and `max` to return items based on some other criterion
    (say the length of a string)? The easiest way to do this would be to define the
    nature of the comparison inside a block. This is done in a similar manner to the
    sorting blocks I defined in [Chapter 4](ch04.html "Chapter 4. Arrays and Hashes").
    You may recall that you sorted a hash (here the variable `h`) by passing a block
    to the `sort` method like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让 `min` 和 `max` 根据某些其他标准（比如字符串的长度）返回项目，最简单的方法是在一个块中定义比较的性质。这与我在[第4章](ch04.html
    "第4章。数组和哈希")中定义的排序块的方式类似。你可能还记得，你是通过将一个块传递给 `sort` 方法来对哈希（这里变量为 `h`）进行排序的，如下所示：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The two parameters, `a` and `b`, represent two items from the hash that are
    compared using the `<=>` comparison method. You can similarly pass blocks to the
    `max` and `min` methods:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 两个参数 `a` 和 `b` 代表哈希中的两个项目，它们使用 `<=>` 比较方法进行比较。你可以类似地传递块给 `max` 和 `min` 方法：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When a hash passes items into a block, it does so in the form of arrays, each
    of which contains a key-value pair. So, if a hash contains items like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当哈希将项目传递给一个块时，它是以数组的形式进行的，每个数组都包含一个键值对。所以，如果一个哈希包含如下项目：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'then the two block arguments, `a` and `b`, would be initialized to two arrays:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，两个块参数 `a` 和 `b` 将初始化为两个数组：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This explains why the two blocks in which I have defined custom comparisons
    for the `max` and `min` methods specifically compare the first elements, at index
    0, of the two block parameters:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了为什么我定义了 `max` 和 `min` 方法的自定义比较的两个块特别比较了两个块参数的第一个元素，即索引0处的元素：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This ensures that the comparisons are based on the *keys* in the hash. There
    is a potential pitfall here, however. As explained in the previous chapter, the
    default ordering of hashes is different in Ruby 1.8 and Ruby 1.9\. This means
    that if you sort by the length of the key, as I did with my custom comparator
    earlier, and more than one key has the same length, the first match returned will
    be different in different versions of Ruby. For example, in my hash, the first
    two keys (“one” and “two”) have the same length. So when I use `min` with a comparison
    based on the key length, the result will be different in Ruby versions 1.8 and
    1.9:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了比较是基于哈希中的 *键* 的。然而，这里有一个潜在的陷阱。正如前一章所解释的，Ruby 1.8 和 Ruby 1.9 中哈希的默认排序方式不同。这意味着如果你按键的长度排序，就像我之前使用自定义比较器所做的那样，并且有多个键具有相同的长度，那么在不同版本的
    Ruby 中返回的第一个匹配项将不同。例如，在我的哈希中，前两个键（“one”和“two”）的长度相同。所以当我使用基于键长度的比较进行 `min` 操作时，结果将在
    Ruby 版本 1.8 和 1.9 中不同：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Ruby 1.8 displays the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.8显示以下内容：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Ruby 1.9 displays the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.9显示以下内容：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is another illustration of why it is always safer to make no assumptions
    of the ordering of the elements in a hash. Now let’s assume you want to compare
    the *values* rather than the keys. In the previous example, you could do this
    quite simply by changing the array indexes from 0 to 1:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是说明为什么始终不要对哈希中元素的排序做出假设的另一个例子。现在假设你想比较值而不是键。在前面的例子中，你可以通过将数组索引从0改为1来简单地做到这一点：
- en: '*enum3.rb*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*enum3.rb*'
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The value with the lowest length is “for joy” and the value with the highest
    length is “for a secret never to be told,” so the previous code displays the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最短长度的值是“for joy”，最长长度的值是“for a secret never to be told”，因此之前的代码显示以下内容：
- en: '[PRE37]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You could, of course, define other types of custom comparisons in your blocks.
    Let’s suppose, for example, that you want the strings “one,” “two,” “three,” and
    so on, to be evaluated in the order in which you would speak them. One way of
    doing this would be to create an ordered array of strings:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在你的块中定义其他类型的自定义比较。假设，例如，你想按照你说话的顺序评估字符串“one”，“two”，“three”，等等。实现这一点的其中一种方法就是创建一个有序的字符串数组：
- en: '[PRE38]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, if a hash, `h`, contains these strings as keys, a block can use `str_array`
    as a reference in order to determine the minimum and maximum values. This also
    assures that we obtain the same results no matter which version of Ruby is used:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果一个哈希 `h` 包含这些字符串作为键，一个块可以使用 `str_array` 作为参考来确定最小和最大值。这也确保了我们无论使用哪个版本的
    Ruby 都能获得相同的结果：
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This displays the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了以下内容：
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: All the previous examples use the `min` and `max` methods of the Array and Hash
    classes. Remember that these methods are provided to those classes by the `Enumerable`
    module, which is “included” in the Array and Hash classes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一个示例都使用了 Array 和 Hash 类的 `min` 和 `max` 方法。记住，这些方法是由 `Enumerable` 模块提供的，该模块被“包含”在
    Array 和 Hash 类中。
- en: 'There may be occasions when it would be useful to be able to apply `Enumerable`
    methods such as `max`, `min`, and `collect` to classes that do not descend from
    existing classes (such as Array) that implement those methods. You can do that
    by including the `Enumerable` module in your class and then writing an iterator
    method called `each` like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，可能需要将 `Enumerable` 方法（如 `max`、`min` 和 `collect`）应用于不继承自实现这些方法的现有类（如 Array）的类。你可以通过在你的类中包含
    `Enumerable` 模块，然后编写一个名为 `each` 的迭代器方法来实现这一点：
- en: '*include_enum1.rb*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*include_enum1.rb*'
- en: '[PRE41]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here you initialize a MyCollection object with an array, which will be stored
    in the instance variable, `@items`. When you call one of the methods provided
    by the `Enumerable` module (such as `min`, `max`, or `collect`), this will call
    the `each` method to obtain each piece of data one at a time. So, here the `each`
    method passes each value from the `@items` array into the block where that item
    is assigned to the block parameter `i`. The keyword `yield` is a special bit of
    Ruby magic that runs a block of code that was passed to the `each` method. You’ll
    look at this in much more depth when I discuss Ruby blocks in [Chapter 10](ch10.html
    "Chapter 10. Blocks, Procs, and Lambdas").
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用一个数组初始化一个 MyCollection 对象，该数组将被存储在实例变量 `@items` 中。当你调用 `Enumerable` 模块提供的方法之一（如
    `min`、`max` 或 `collect`）时，这将调用 `each` 方法逐个获取数据。因此，这里的 `each` 方法将 `@items` 数组中的每个值传递到包含该项目的代码块中，该项目被分配给代码块参数
    `i`。关键字 `yield` 是 Ruby 中的一个特殊功能，它运行传递给 `each` 方法的代码块。当我讨论第 10 章（[第 10 章](ch10.html
    "第 10 章。块、Proc 和 Lambda")）中的 Ruby 块时，你将更深入地了解这一点。
- en: 'Now you can use the `Enumerable` methods with your MyCollection objects:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 `Enumerable` 方法与你的 MyCollection 对象一起使用：
- en: '*include_enum2.rb*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*include_enum2.rb*'
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You could similarly use your MyCollection class to process arrays such as the
    keys or values of hashes. Currently the `min` and `max` methods adopt the default
    behavior: They perform comparisons based on numerical values. This means that
    “xy” is considered to have a “higher” value than “abcd” on the basis of the characters’
    ASCII values. If you want to perform some other type of comparison—say, by string
    length, so that “abcd” would be deemed to be higher than “xz”—you can override
    the `min` and `max` methods:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你同样可以使用你的 MyCollection 类来处理数组，如哈希的键或值。目前，`min` 和 `max` 方法采用默认行为：它们基于数值进行比较。这意味着根据字符的
    ASCII 值，“xy”被认为比“abcd”的值“更高”。如果你想执行其他类型的比较——比如说，根据字符串长度，使得“abcd”被认为比“xz”的值更高——你可以重写
    `min` 和 `max` 方法：
- en: '[PRE43]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here is the complete class definition with its versions of `each`, `min`, and
    `max`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完整的类定义及其 `each`、`min` 和 `max` 的版本：
- en: '*include_enum3.rb*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*include_enum3.rb*'
- en: '[PRE44]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A MyCollection object can now be created, and its overridden methods can be
    used in this way:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以创建一个 MyCollection 对象，并且可以使用以下方式使用其重写的方法：
- en: '[PRE45]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: each and yield
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: each 和 yield
- en: 'So what is really going on when a method from the `Enumerable` module uses
    the `each` method that you’ve written? It turns out that the `Enumerable` methods
    (`min`, `max`, `collect` and so forth) pass to the `each` method a block of code.
    This block of code expects to receive one piece of data at a time (namely, each
    item from a collection of some sort). Your `each` method supplies it with that
    item in the form of a block parameter, such as the parameter `i` here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Enumerable` 模块中的方法使用你编写的 `each` 方法时，实际上发生了什么？结果是 `Enumerable` 方法（如 `min`、`max`、`collect`
    等）将一个代码块传递给 `each` 方法。这个代码块期望一次接收一个数据项（即某个集合中的每个项目）。你的 `each` 方法通过一个代码块参数（如这里的参数
    `i`）提供这个项目：
- en: '[PRE46]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As mentioned earlier, the keyword `yield` tells the code to run the block that
    was passed to the `each` method—that is, to run the code supplied by the `Enumerable`
    module’s `min`, `max`, or `collect` methods. This means that the code of those
    methods can be used with all kinds of different types of collections. All you
    have to do is include the `Enumerable` module into your class and write an `each`
    method that determines which values will be used by the `Enumerable` methods.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，关键字 `yield` 告诉代码运行传递给 `each` 方法的块——也就是说，运行由 `Enumerable` 模块的 `min`、`max`
    或 `collect` 方法提供的代码。这意味着这些方法中的代码可以与各种不同类型的集合一起使用。你所要做的就是将 `Enumerable` 模块包含到你的类中，并编写一个
    `each` 方法，以确定哪些值将由 `Enumerable` 方法使用。
