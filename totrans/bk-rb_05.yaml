- en: Chapter 5. Loops and Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Much of programming is concerned with repetition. Maybe you want your program
    to beep 10 times, read lines from a file as long as there are more lines to read,
    or display a warning until the user presses a key. Ruby provides a number of ways
    of performing this kind of repetition.
  prefs: []
  type: TYPE_NORMAL
- en: for Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many programming languages, when you want to run a bit of code a certain
    number of times, you can just put it inside a `for` loop. In most languages, you
    give a `for` loop a variable initialized with a starting value that is incremented
    by 1 on each turn through the loop until it meets some specific ending value.
    When the ending value is met, the `for` loop stops running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a version of this traditional type of `for` loop written in Pascal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You may recall from the previous chapter that Ruby’s `for` loop doesn’t work
    like this at all! Instead of giving it starting and ending values, you give the
    `for` loop a list of items, and it iterates over them, one by one, assigning each
    value in turn to a loop variable until it gets to the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a `for` loop that iterates over the items in an array,
    displaying each in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '*for_loop.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` loop is more like the “for each” iterator provided by some other
    programming languages. The items over which the loop iterates don’t have to be
    integers. This works just as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The author of Ruby describes `for` as “syntax sugar” for the `each` method,
    which is implemented by collection types such as Arrays, Sets, Hashes, and Strings
    (a String being, in effect, a collection of characters). For the sake of comparison,
    this is one of the `for` loops shown earlier rewritten using the `each` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*each_loop.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there isn’t really all that much difference. To convert the
    `for` loop to an `each` iterator, all I’ve had to do is delete `for` and `in`
    and append `.each` to the array. Then I’ve put the iterator variable, `i`, between
    a pair of upright bars after `do`. Compare these other examples to see just how
    similar `for` loops are to `each` iterators.
  prefs: []
  type: TYPE_NORMAL
- en: '*for_each.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, incidentally, that the `do` keyword is optional in a `for` loop that
    spans multiple lines, but it is obligatory when it is written on a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows how both `for` and `each` can be used to iterate over the
    values in a range:'
  prefs: []
  type: TYPE_NORMAL
- en: '*for_each2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How to Write a “Normal” for Loop
  prefs: []
  type: TYPE_NORMAL
- en: 'If you miss the traditional type of `for` loop, you can always fake it in Ruby
    by using a `for` loop to iterate over the values in a range. For example, this
    is how to use a `for` loop variable to count up from 1 to 10, displaying its value
    at each turn through the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*for_to.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: Note, incidentally, that a range expression such as `1..3` must be enclosed
    between parentheses when used with the `each` method, or Ruby assumes you are
    attempting to use `each` as a method of the final integer (a Fixnum) rather than
    of the entire expression (a Range). The parentheses are optional when a range
    is used in a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks and Block Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Ruby, the body of an iterator is called a *block*, and any variables declared
    between upright bars at the top of a block are called *block parameters*. In a
    way, a block works like a function, and the block parameters work like a function’s
    argument list. The `each` method runs the code inside the block and passes to
    it the arguments supplied by a collection (such as the array, `multiarr`). In
    the example from the previous section, the `each` method repeatedly passes an
    array of four elements to the block, and those elements initialize the four block
    parameters, `a, b, c, d`. Blocks can be used for other things, in addition to
    iterating over collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby also has an alternative syntax for delimiting blocks. Instead of using
    `do..end`, you can use curly brackets `{..}` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*block_syntax.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: No matter which block delimiters you use, you must ensure that the opening delimiter,
    `{` or `do`, is placed on the same line as the `each` method. Inserting a line
    break between `each` and the opening block delimiter is a syntax error. I’ll have
    more to say on blocks in [Chapter 10](ch10.html "Chapter 10. Blocks, Procs, and
    Lambdas").
  prefs: []
  type: TYPE_NORMAL
- en: Iterating upto and downto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need to count from a specific low value up to a high value, you may
    use the `upto()` method of an integer. A block argument may optionally be used
    if you want to display the value at each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '*upto_downto.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code displays the integers 0 to 10\. You may also count down from
    a high to a low value using the `downto()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can probably guess, this code displays 10 to 0.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Iterator Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you used a `for` loop with more than one loop variable
    to iterate over a multidimensional array. On each turn through the `for` loop,
    a variable was assigned one row (that is, one “subarray”) from the outer array:'
  prefs: []
  type: TYPE_NORMAL
- en: '*multi_array.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous loop prints this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you could also use the `each` method to iterate over this four-item
    array by passing four block parameters—`a`, `b`, `c`, `d`—into the block delimited
    by `do` and `end` at each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, the alternative block syntax, delimited by curly brackets,
    works just as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of the previous examples pass the two elements from the `multiarr` array
    into the iterator block. The first element is itself an array of four strings:
    `[''one'',''two'',''three'',''four'']`. Since the block has four parameters declared
    between a pair of upright bars, `|a,b,c,d|`, the four strings are assigned to
    the matching parameters, which are then printed with the `print` statement. Then
    the `each` method passes the second element of `multiarr` into the block. This
    is another four-element array, this time containing integers: `[1,2,3,4]`. These
    are again assigned to the block parameters, `|a,b,c,d|`, and the `print` statement
    displays them. Note that the output is identical as when you used the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: while Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ruby has a few other loop constructs too. This is how to do a `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, here’s another way to put it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Even though the syntax of these two examples is different, they perform the
    same function. In the first example, the code between `while` and `end` (here
    a call to a method named `sleep`) executes just as long as the Boolean condition
    (which, in this case, is the value returned by a method called `tired`) evaluates
    to true. As in `for` loops, the keyword `do` may optionally be placed between
    the test condition and the code to be executed when these appear on separate lines;
    the `do` keyword is obligatory when the test condition and the code to be executed
    appear on the same line.
  prefs: []
  type: TYPE_NORMAL
- en: while Modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the second version of the loop (`sleep while tired`), the code to be executed
    (`sleep`) precedes the test condition (`while tired`). This syntax is called a
    *while modifier*. When you want to execute several expressions using this syntax,
    you can put them between the `begin` and `end` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example showing the various alternative syntaxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*1loops.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The last example in the previous code (the multiline `while` modifier) needs
    close consideration because it introduces some important new behavior. When a
    block of code delimited by `begin` and `end` precedes the `while` test, that code
    always executes at least once. In the other types of `while` loop, the code may
    never execute at all if the Boolean condition initially evaluates to false.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring a while Loop Executes at Least Once
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually a `while` loops executes zero or more times since the Boolean test is
    evaluated before the loop executes; if the test returns false at the outset, the
    code inside the loop never runs. However, when the `while` test follows a block
    of code enclosed between `begin` and `end`, the loop executes one or more times
    as the Boolean expression is evaluated after the code inside the loop executes.
  prefs: []
  type: TYPE_NORMAL
- en: 'These examples should help clarify:'
  prefs: []
  type: TYPE_NORMAL
- en: '*2loops.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: until Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ruby also has an `until` loop, which can be thought of as a *while not* loop.
    Its syntax and options are the same as those applying to `while`—that is, the
    test condition and the code to be executed can be placed on a single line (in
    which case the `do` keyword is obligatory) or can be placed on separate lines
    (in which case `do` is optional). There is also an `until` modifier that lets
    you put the code before the test condition and an option to enclose the code between
    `begin` and `end` in order to ensure that the code block is run at least once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some simple examples of `until` loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '*until.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `while` and `until` loops can, just like a `for` loop, be used to iterate
    over arrays and other collections. For example, the following code shows two ways
    of iterating over all the elements in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '*array_iterate.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike `for` and `while`, the `loop` command does not evaluate a test condition
    to determine whether to continue looping. To break out of the loop, you have to
    explicitly use the `break` keyword, as you can see in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '*3loops.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These use the `loop` method repeatedly to execute the block of code that follows.
    These blocks are just like the iterator blocks you used earlier with the `each`
    method. Once again, you have a choice of block delimiters, either curly brackets
    or `do` and `end`.
  prefs: []
  type: TYPE_NORMAL
- en: In each case, the code iterates through the array, `arr`, by incrementing a
    counter variable, `i`, and breaking out of the loop when the `(i == arr.length)`
    condition evaluates to true. Note that without a `break`, these would loop forever.
  prefs: []
  type: TYPE_NORMAL
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: Ruby provides a number of ways of iterating over items in structures such as
    arrays and ranges. Here we discover the inner details of the enumerations and
    comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: The Enumerable Module
  prefs: []
  type: TYPE_NORMAL
- en: 'Hashes, Arrays, Ranges, and Sets all include a Ruby module called `Enumerable`.
    It provides these data structures with a number of useful methods such as `include?`,
    which returns true if a specific value is found; `min`, which returns the smallest
    value; `max`, which returns the largest; and `collect`, which creates a new structure
    made up of values returned from a block. In the following code, you can see some
    of these functions being used on an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '*enum.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'These same methods are available to other collection classes too, as long as
    those classes include `Enumerable`. Here’s an example using the Hash class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*enum2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This code outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that because of changes in the way hashes are stored, the order of the
    items displayed when this code runs differs in Ruby 1.8 and Ruby 1.9\. Remember
    too that the items in a Hash are not indexed in sequential order, so when you
    use the `min` and `max` methods, these return the items that are lowest and highest
    according to their numerical value—here the items are strings, and the numerical
    value is determined by the ASCII codes of the characters in the key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Custom Comparisons
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you want `min` and `max` to return items based on some other criterion
    (say the length of a string)? The easiest way to do this would be to define the
    nature of the comparison inside a block. This is done in a similar manner to the
    sorting blocks I defined in [Chapter 4](ch04.html "Chapter 4. Arrays and Hashes").
    You may recall that you sorted a hash (here the variable `h`) by passing a block
    to the `sort` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The two parameters, `a` and `b`, represent two items from the hash that are
    compared using the `<=>` comparison method. You can similarly pass blocks to the
    `max` and `min` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When a hash passes items into a block, it does so in the form of arrays, each
    of which contains a key-value pair. So, if a hash contains items like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'then the two block arguments, `a` and `b`, would be initialized to two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This explains why the two blocks in which I have defined custom comparisons
    for the `max` and `min` methods specifically compare the first elements, at index
    0, of the two block parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This ensures that the comparisons are based on the *keys* in the hash. There
    is a potential pitfall here, however. As explained in the previous chapter, the
    default ordering of hashes is different in Ruby 1.8 and Ruby 1.9\. This means
    that if you sort by the length of the key, as I did with my custom comparator
    earlier, and more than one key has the same length, the first match returned will
    be different in different versions of Ruby. For example, in my hash, the first
    two keys (“one” and “two”) have the same length. So when I use `min` with a comparison
    based on the key length, the result will be different in Ruby versions 1.8 and
    1.9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Ruby 1.8 displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Ruby 1.9 displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is another illustration of why it is always safer to make no assumptions
    of the ordering of the elements in a hash. Now let’s assume you want to compare
    the *values* rather than the keys. In the previous example, you could do this
    quite simply by changing the array indexes from 0 to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '*enum3.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The value with the lowest length is “for joy” and the value with the highest
    length is “for a secret never to be told,” so the previous code displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You could, of course, define other types of custom comparisons in your blocks.
    Let’s suppose, for example, that you want the strings “one,” “two,” “three,” and
    so on, to be evaluated in the order in which you would speak them. One way of
    doing this would be to create an ordered array of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if a hash, `h`, contains these strings as keys, a block can use `str_array`
    as a reference in order to determine the minimum and maximum values. This also
    assures that we obtain the same results no matter which version of Ruby is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: All the previous examples use the `min` and `max` methods of the Array and Hash
    classes. Remember that these methods are provided to those classes by the `Enumerable`
    module, which is “included” in the Array and Hash classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be occasions when it would be useful to be able to apply `Enumerable`
    methods such as `max`, `min`, and `collect` to classes that do not descend from
    existing classes (such as Array) that implement those methods. You can do that
    by including the `Enumerable` module in your class and then writing an iterator
    method called `each` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*include_enum1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here you initialize a MyCollection object with an array, which will be stored
    in the instance variable, `@items`. When you call one of the methods provided
    by the `Enumerable` module (such as `min`, `max`, or `collect`), this will call
    the `each` method to obtain each piece of data one at a time. So, here the `each`
    method passes each value from the `@items` array into the block where that item
    is assigned to the block parameter `i`. The keyword `yield` is a special bit of
    Ruby magic that runs a block of code that was passed to the `each` method. You’ll
    look at this in much more depth when I discuss Ruby blocks in [Chapter 10](ch10.html
    "Chapter 10. Blocks, Procs, and Lambdas").
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can use the `Enumerable` methods with your MyCollection objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '*include_enum2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You could similarly use your MyCollection class to process arrays such as the
    keys or values of hashes. Currently the `min` and `max` methods adopt the default
    behavior: They perform comparisons based on numerical values. This means that
    “xy” is considered to have a “higher” value than “abcd” on the basis of the characters’
    ASCII values. If you want to perform some other type of comparison—say, by string
    length, so that “abcd” would be deemed to be higher than “xz”—you can override
    the `min` and `max` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the complete class definition with its versions of `each`, `min`, and
    `max`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*include_enum3.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'A MyCollection object can now be created, and its overridden methods can be
    used in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: each and yield
  prefs: []
  type: TYPE_NORMAL
- en: 'So what is really going on when a method from the `Enumerable` module uses
    the `each` method that you’ve written? It turns out that the `Enumerable` methods
    (`min`, `max`, `collect` and so forth) pass to the `each` method a block of code.
    This block of code expects to receive one piece of data at a time (namely, each
    item from a collection of some sort). Your `each` method supplies it with that
    item in the form of a block parameter, such as the parameter `i` here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, the keyword `yield` tells the code to run the block that
    was passed to the `each` method—that is, to run the code supplied by the `Enumerable`
    module’s `min`, `max`, or `collect` methods. This means that the code of those
    methods can be used with all kinds of different types of collections. All you
    have to do is include the `Enumerable` module into your class and write an `each`
    method that determines which values will be used by the `Enumerable` methods.
  prefs: []
  type: TYPE_NORMAL
