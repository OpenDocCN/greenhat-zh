- en: Chapter 9. Exception Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: Even the most carefully written program will sometimes encounter unforeseen
    errors. For example, if you write a program that needs to read some data from
    disk, it works on the assumption that the specified disk is actually available
    and the data is valid. If your program does calculations based on user input,
    it works on the assumption that the input is suitable to be used in a calculation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Although you may try to anticipate some potential problems before they arise—for
    example, by writing code to check that a file exists before reading data from
    it or checking that user input is numerical before doing a calculation—you will
    never be able to predict every possible problem in advance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The user may remove a data disk after you’ve already started reading data from
    it, for example; or some obscure calculation may yield 0 just before your code
    attempts to divide by this value. When you know that there is the possibility
    that your code may be “broken” by some unforeseen circumstances at runtime, you
    can attempt to avoid disaster by using *exception handling*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: An *exception* is an error that is packaged into an object. The object is an
    instance of the Exception class (or one of its descendants). You can handle exceptions
    by trapping the Exception object, optionally using information that it contains
    (to print an appropriate error message, for instance) and taking any actions needed
    to recover from the error—perhaps by closing any files that are still open or
    assigning a sensible value to a variable that may have been assigned some nonsensical
    value as the result of an erroneous calculation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'rescue: Execute Code When Error Occurs'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic syntax of exception handling can be summarized as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When an exception is unhandled, your program may crash, and Ruby is likely
    to display a relatively unfriendly error message:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '*div_by_zero.rb*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The program terminates with this error:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To prevent this from happening, you should handle exceptions yourself. Here
    is an example of an exception handler that deals with an attempt to divide by
    zero:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '*exception1.rb*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When this runs, the code following `rescue Exception` executes and displays
    this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code between `begin` and `end` is my exception-handling block. I’ve placed
    the troublesome code after `begin`. When an exception occurs, it is handled in
    the section beginning with `rescue`. The first thing I’ve done is to set the variable
    `x` to a meaningful value. Next come these two inscrutable statements:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In Ruby, `$!` is a global variable to which is assigned the last exception.
    Printing `$!.class` displays the class name, which here is ZeroDivisionError;
    printing the variable `$!` alone has the effect of displaying the error message
    contained by the Exception object, which here is “divided by 0.”
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'I am not generally keen on relying upon global variables, particularly when
    they have names as undescriptive as `$!`. Fortunately, there is an alternative.
    You can associate a variable name with the exception by placing the “assoc operator”
    (`=>`) after the class name of the exception and before the variable name:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '*exception2.rb*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can now use the variable name (here `exc`) to refer to the Exception object:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Although it may seem pretty obvious that when you divide by zero, you are going
    to get a ZeroDivisionError exception, in real-world code there may be times when
    the type of exception is not so predictable. Let’s suppose, for instance, that
    you have a method that does a division based on two values supplied by a user:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This could potentially produce a variety of different exceptions. Obviously,
    if the second value entered by the user is 0, you will get a ZeroDivisionError.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions Have a Family Tree
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how `rescue` clauses trap exceptions, just remember that exceptions
    are objects, and like all other objects, they are defined by a class. There is
    also a clear “line of descent” that starts with the base class: Object (in Ruby
    1.8) or BasicObject (Ruby 1.9). Run *exception_tree.rb* to display the ancestors
    of an exception. This is what is displayed by Ruby 1.9:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*exception_tree.rb*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the *second* value is a string, the exception will be a TypeError,
    whereas if the *first* value is a string, it will be a NoMethodError (because
    the String class does not define the “division operator,” which is `/`). Here
    the `rescue` block handles all possible exceptions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '*multi_except.rb*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can test this by deliberately generating different error conditions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Often it will be useful to take different actions for different exceptions.
    You can do that by adding multiple `rescue` clauses. Each `rescue` clause can
    handle multiple exception types, with the exception class names separated by commas.
    Here my `calc` method handles TypeError and NoMethodError exceptions in one clause
    with a catchall Exception handler to deal with other exception types:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '*multi_except2.rb*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This time, when a TypeError or NoMethodError is handled (but no other sort
    of error), my additional error message is displayed like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When handling multiple exception types, you should always put the `rescue` clauses
    dealing with specific exceptions first and then follow these with `rescue` clauses
    dealing with more generalized exceptions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: When a specific exception such as TypeError is handled, the `begin..end` exception
    block exits so the flow of execution won’t “trickle down” to more generalized
    `rescue` clauses. However, if you put a generalized exception-handling `rescue`
    clause first, that will handle all exceptions, so any more specific clauses lower
    down will never execute.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'If, for example, I had reversed the order of the `rescue` clauses in my `calc`
    method, placing the generalized Exception handler first, this would match all
    exception types so the clause for the specific TypeError and NoMethodError exceptions
    would never be run:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '*multi_except_err.rb*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'ensure: Execute Code Whether or Not an Error Occurs'
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be some circumstances in which you want to take some particular action
    whether or not an exception occurs. For example, whenever you are dealing with
    some kind of unpredictable input/output—say, when working with files and directories
    on disk—there is always the possibility that the location (the disk or directory)
    or the data source (the file) either may not be there at all or may provide some
    other kinds of problems—such as the disk being full when you attempt to write
    to it or the file containing the wrong kind of data when you attempt to read from
    it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: You may need to perform some final “cleanup” procedures whether or not you have
    encountered any problems, such as logging onto a specific working directory or
    closing a file that was previously opened. You can do this by following a `begin..rescue`
    block of code with another block starting with the `ensure` keyword. The code
    in the `ensure` block will always execute, whether or not an exception has arisen
    beforehand.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at two simple examples. In the first one, I try to log onto a disk
    and display the directory listing. At the end of this, I want to be sure that
    my working directory (given by `Dir.getwd`) is always restored to its original
    location. I do this by saving the original directory in the `startdir` variable
    and once again making this the working directory in the `ensure` block:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '*ensure.rb*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When I run this, the following is displayed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let’s now see how to deal with the problem of reading the incorrect data from
    a file. This might happen if the data is corrupt, if you accidentally open the
    wrong file, or—quite simply—if your program code contains a bug.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Here I have a file, *test.txt*, containing six lines. The first five lines
    are numbers; the sixth line is a string, “six.” My code opens this file and reads
    in all six lines:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '*ensure2.rb*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The lines are read in as strings (using `gets`), and the code attempts to convert
    them to integers (using `to_i`). No error is produced when the conversion fails;
    instead, Ruby returns the value 0\. The problem arises in the next line of code,
    which attempts a division by the converted number.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Having opened the data file at the outset, I want to ensure that the file is
    closed whether or not an error occurs. If, for example, I read in only the first
    five lines by editing the range in the `for` loop to `(1..5)`, then there would
    be no exception. I would still want to close the file. But it would be no good
    putting the file-closing code (`f.close`) in the `rescue` clause because it would
    not, in this case, be executed. By putting it in the `ensure` clause, however,
    I can be certain that the file will be closed whether or not an exception occurs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'else: Execute Code When No Error Occurs'
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the `rescue` section executes when an error occurs and `ensure` executes
    whether or not an error occurs, how can you specifically execute some code only
    when an error does *not* occur?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to do this is to add an optional `else` clause after the `rescue` section
    and before the `ensure` section (if there is one), like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is an example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '*else.rb*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Try running the previous program and enter a number such as 10, which won’t
    cause an error, so `msg` will be assigned in the `else` clause; then try entering
    0, which will cause an error, so `msg` will be assigned in the `rescue` clause.
    Whether or not there is an error, the `ensure` section will execute to create
    a `msg` string that begins with “You entered ” followed by any other messages.
    For example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Error Numbers
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you ran the *ensure.rb* program earlier and you were watching closely, you
    may have noticed something unusual when you tried to log onto a nonexistent drive
    (for example, on my system that might be the *X:\* drive). Often, when an exception
    occurs, the exception class is an instance of a specific named type such as ZeroDivisionError
    or NoMethodError. In this case, however, the class of the exception is shown to
    be `Errno::ENOENT`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that there is quite a variety of `Errno` errors in Ruby. Try *disk_err.rb*.
    This defines a method, `chDisk`, which attempts to log onto a disk identified
    by the character, `aChar`. So if you pass “A” as an argument to `chDisk`, it will
    try to log onto the *A:\* drive. I’ve called the `chDisk` method three times,
    passing to it a different string each time:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '*disk_err.rb*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You might, of course, need to edit the paths to something different on your
    computer. On my PC, *F:\* is my DVD drive. At the moment, it is empty, and when
    my program tries to log onto it, Ruby returns an exception of this type: `Errno::EACCES`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'I have no *X:\* drive on my PC, and when I try to log onto that, Ruby returns
    an exception of this type: `Errno::ENOENT`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, I pass the string parameter “ABC,” which is invalid
    as a disk identifier, and Ruby returns an exception of this type: `Errno::EINVAL`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Errors of this type are descendants of the SystemCallError class. You can easily
    verify this by uncommenting the line of code to show the class’s family where
    indicated in the source code of *disk_err.rb*. This calls the same `showFamily`
    method, which you used earlier in the *exception_tree.rb* program.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: These Error classes, in effect, wrap up integer error values that are returned
    by the underlying operating system. Both the names and the values of constants
    may vary according to the operating system and the version of Ruby. Here `Errno`
    is the name of the module containing the constants, such as `EACCES` and `ENOENT`,
    which match the integer error values.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'To see a complete list of `Errno` constants, run this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '*errno.rb*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To view the corresponding numerical value of any given constant, append `::Errno`
    to the constant name, like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can use the following code to display a list of all `Errno` constants along
    with their numerical values (here the `eval` method evaluates the expression passed
    to it—you’ll look at how this works in [Chapter 20](ch20.html "Chapter 20. Dynamic
    Programming")):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'retry: Attempt to Execute Code Again After an Error'
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you think an error condition may be transient or may be corrected (by the
    user, perhaps?), you can rerun all the code in a `begin..end` block using the
    keyword `retry`, as in this example that prompts the user to re-enter a value
    if an error such as ZeroDivisionError occurs:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '*retry.rb*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you want to append the message from an exception object such as `e` to
    a string such as `"Error: "`, Ruby 1.9 insists that you explicitly convert `e`
    to a string ( `"Error: " + e.to_s`), whereas Ruby 1.8 does the conversion for
    you ( `"Error: " + e`).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: There is, of course, the danger that the error may not be as transient as you
    think, so if you use `retry`, you may want to provide a clearly defined exit condition
    to ensure that the code stops executing after a fixed number of attempts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'You could, for example, increment a local variable in the `begin` clause. (If
    you do this, make sure it is incremented *before* any code that is liable to generate
    an exception since once an exception occurs, the remainder of the code prior to
    the `rescue` clause will be skipped!) Then test the value of that variable in
    the `rescue` section, like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is a complete example, in which I test the value of a variable named `tries`
    to ensure no more than three tries to run the code without error before the exception-handling
    block exits:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '*retry2.rb*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the user were to enter 0 three times in a row, this would be the output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'raise: Reactivate a Handled Error'
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you may want to keep an exception “alive” even after it has been
    trapped in an exception-handling block. You can do this, for example, to defer
    the handling of the exception, say by passing it on to some other method. You
    can do this using the `raise` method. You need to be aware, however, that, once
    raised, an exception needs to be rehandled; otherwise, it may cause your program
    to crash. Here is a simple example of raising a ZeroDivisionError exception and
    passing on the exception to a method called, in this case, `handleError`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '*raise.rb*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here `divbyzero` is the name of a method in which the divide-by-zero operation
    takes place, and `handleError` is a method that prints more detailed information
    on the exception:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice that this uses the `backtrace` method, which displays an array of strings
    showing the filenames and line numbers where the error occurred and, in this case,
    the line that called the error-producing `divbyzero` method. This is an example
    of this program’s output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also specifically raise your exceptions to force an error condition
    even when the program code has not caused an exception. Calling `raise` on its
    own raises an exception of the type RuntimeError (or whatever exception is in
    the global variable `$!`):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'By default, this will have no descriptive message associated with it. You can
    add a message as a parameter, like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can raise a specific type of error:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can also create an object of a specific exception type and initialize it
    with a custom message:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is a simple example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '*raise2.rb*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This outputs the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the standard exception types don’t meet your requirements, you can, of course,
    create new ones just by subclassing existing exceptions. Provide your classes
    with a `to_str` method in order to give them a default message.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '*raise3.rb*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is an example of how you might raise a custom exception:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you now enter `sayHello( nil )`, this would be the output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Digging Deeper
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: When trapping exceptions, the `begin` keyword may, in some circumstances, be
    omitted. Here you will learn about this syntax. I will also clarify some potential
    confusion about `catch` and `throw`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Omitting begin and end
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'You can optionally omit `begin` and `end` when trapping exceptions inside a
    method, a class, or a module. For example, all the following are legal:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '*omit_begin_end.rb*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In all the previous cases, the exception-handling will also work if you place
    the `begin` and `end` keywords at the start and end of the exception-handling
    code in the usual way.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: catch..throw
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'In some languages, exceptions are trapped using the keyword `catch` and may
    be raised using the keyword `throw`. Although Ruby provides `catch` and `throw`
    methods, these are not directly related to its exception handling. Instead, `catch`
    and `throw` are used to break out of a defined block of code when some condition
    is met. You could, of course, use `catch` and `throw` to break out of a block
    of code when an exception occurs (though this may not be the most elegant way
    of handling errors). For example, this code will exit the block delimited by curly
    brackets if a ZeroDivisionError occurs:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，异常是通过使用关键字`catch`来捕获的，并且可以使用关键字`throw`来引发。尽管Ruby提供了`catch`和`throw`方法，但这些方法与其异常处理没有直接关系。相反，`catch`和`throw`用于在满足某些条件时跳出定义的代码块。当然，您可以使用`catch`和`throw`在发生异常时跳出代码块（尽管这可能不是处理错误的最优雅方式）。例如，如果发生`ZeroDivisionError`，此代码将退出由大括号分隔的代码块：
- en: '*catch_except.rb*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*catch_except.rb*'
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: See [Chapter 6](ch06.html "Chapter 6. Conditional Statements") for more on `catch`
    and `throw`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 详见[第6章](ch06.html "第6章. 条件语句")了解`catch`和`throw`的更多内容。
