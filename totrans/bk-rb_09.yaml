- en: Chapter 9. Exception Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even the most carefully written program will sometimes encounter unforeseen
    errors. For example, if you write a program that needs to read some data from
    disk, it works on the assumption that the specified disk is actually available
    and the data is valid. If your program does calculations based on user input,
    it works on the assumption that the input is suitable to be used in a calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Although you may try to anticipate some potential problems before they arise—for
    example, by writing code to check that a file exists before reading data from
    it or checking that user input is numerical before doing a calculation—you will
    never be able to predict every possible problem in advance.
  prefs: []
  type: TYPE_NORMAL
- en: The user may remove a data disk after you’ve already started reading data from
    it, for example; or some obscure calculation may yield 0 just before your code
    attempts to divide by this value. When you know that there is the possibility
    that your code may be “broken” by some unforeseen circumstances at runtime, you
    can attempt to avoid disaster by using *exception handling*.
  prefs: []
  type: TYPE_NORMAL
- en: An *exception* is an error that is packaged into an object. The object is an
    instance of the Exception class (or one of its descendants). You can handle exceptions
    by trapping the Exception object, optionally using information that it contains
    (to print an appropriate error message, for instance) and taking any actions needed
    to recover from the error—perhaps by closing any files that are still open or
    assigning a sensible value to a variable that may have been assigned some nonsensical
    value as the result of an erroneous calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'rescue: Execute Code When Error Occurs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic syntax of exception handling can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When an exception is unhandled, your program may crash, and Ruby is likely
    to display a relatively unfriendly error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '*div_by_zero.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The program terminates with this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent this from happening, you should handle exceptions yourself. Here
    is an example of an exception handler that deals with an attempt to divide by
    zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '*exception1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When this runs, the code following `rescue Exception` executes and displays
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The code between `begin` and `end` is my exception-handling block. I’ve placed
    the troublesome code after `begin`. When an exception occurs, it is handled in
    the section beginning with `rescue`. The first thing I’ve done is to set the variable
    `x` to a meaningful value. Next come these two inscrutable statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In Ruby, `$!` is a global variable to which is assigned the last exception.
    Printing `$!.class` displays the class name, which here is ZeroDivisionError;
    printing the variable `$!` alone has the effect of displaying the error message
    contained by the Exception object, which here is “divided by 0.”
  prefs: []
  type: TYPE_NORMAL
- en: 'I am not generally keen on relying upon global variables, particularly when
    they have names as undescriptive as `$!`. Fortunately, there is an alternative.
    You can associate a variable name with the exception by placing the “assoc operator”
    (`=>`) after the class name of the exception and before the variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '*exception2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now use the variable name (here `exc`) to refer to the Exception object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it may seem pretty obvious that when you divide by zero, you are going
    to get a ZeroDivisionError exception, in real-world code there may be times when
    the type of exception is not so predictable. Let’s suppose, for instance, that
    you have a method that does a division based on two values supplied by a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This could potentially produce a variety of different exceptions. Obviously,
    if the second value entered by the user is 0, you will get a ZeroDivisionError.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions Have a Family Tree
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how `rescue` clauses trap exceptions, just remember that exceptions
    are objects, and like all other objects, they are defined by a class. There is
    also a clear “line of descent” that starts with the base class: Object (in Ruby
    1.8) or BasicObject (Ruby 1.9). Run *exception_tree.rb* to display the ancestors
    of an exception. This is what is displayed by Ruby 1.9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*exception_tree.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the *second* value is a string, the exception will be a TypeError,
    whereas if the *first* value is a string, it will be a NoMethodError (because
    the String class does not define the “division operator,” which is `/`). Here
    the `rescue` block handles all possible exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*multi_except.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test this by deliberately generating different error conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Often it will be useful to take different actions for different exceptions.
    You can do that by adding multiple `rescue` clauses. Each `rescue` clause can
    handle multiple exception types, with the exception class names separated by commas.
    Here my `calc` method handles TypeError and NoMethodError exceptions in one clause
    with a catchall Exception handler to deal with other exception types:'
  prefs: []
  type: TYPE_NORMAL
- en: '*multi_except2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, when a TypeError or NoMethodError is handled (but no other sort
    of error), my additional error message is displayed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When handling multiple exception types, you should always put the `rescue` clauses
    dealing with specific exceptions first and then follow these with `rescue` clauses
    dealing with more generalized exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: When a specific exception such as TypeError is handled, the `begin..end` exception
    block exits so the flow of execution won’t “trickle down” to more generalized
    `rescue` clauses. However, if you put a generalized exception-handling `rescue`
    clause first, that will handle all exceptions, so any more specific clauses lower
    down will never execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, for example, I had reversed the order of the `rescue` clauses in my `calc`
    method, placing the generalized Exception handler first, this would match all
    exception types so the clause for the specific TypeError and NoMethodError exceptions
    would never be run:'
  prefs: []
  type: TYPE_NORMAL
- en: '*multi_except_err.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'ensure: Execute Code Whether or Not an Error Occurs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be some circumstances in which you want to take some particular action
    whether or not an exception occurs. For example, whenever you are dealing with
    some kind of unpredictable input/output—say, when working with files and directories
    on disk—there is always the possibility that the location (the disk or directory)
    or the data source (the file) either may not be there at all or may provide some
    other kinds of problems—such as the disk being full when you attempt to write
    to it or the file containing the wrong kind of data when you attempt to read from
    it.
  prefs: []
  type: TYPE_NORMAL
- en: You may need to perform some final “cleanup” procedures whether or not you have
    encountered any problems, such as logging onto a specific working directory or
    closing a file that was previously opened. You can do this by following a `begin..rescue`
    block of code with another block starting with the `ensure` keyword. The code
    in the `ensure` block will always execute, whether or not an exception has arisen
    beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at two simple examples. In the first one, I try to log onto a disk
    and display the directory listing. At the end of this, I want to be sure that
    my working directory (given by `Dir.getwd`) is always restored to its original
    location. I do this by saving the original directory in the `startdir` variable
    and once again making this the working directory in the `ensure` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ensure.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When I run this, the following is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now see how to deal with the problem of reading the incorrect data from
    a file. This might happen if the data is corrupt, if you accidentally open the
    wrong file, or—quite simply—if your program code contains a bug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here I have a file, *test.txt*, containing six lines. The first five lines
    are numbers; the sixth line is a string, “six.” My code opens this file and reads
    in all six lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ensure2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The lines are read in as strings (using `gets`), and the code attempts to convert
    them to integers (using `to_i`). No error is produced when the conversion fails;
    instead, Ruby returns the value 0\. The problem arises in the next line of code,
    which attempts a division by the converted number.
  prefs: []
  type: TYPE_NORMAL
- en: Having opened the data file at the outset, I want to ensure that the file is
    closed whether or not an error occurs. If, for example, I read in only the first
    five lines by editing the range in the `for` loop to `(1..5)`, then there would
    be no exception. I would still want to close the file. But it would be no good
    putting the file-closing code (`f.close`) in the `rescue` clause because it would
    not, in this case, be executed. By putting it in the `ensure` clause, however,
    I can be certain that the file will be closed whether or not an exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'else: Execute Code When No Error Occurs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the `rescue` section executes when an error occurs and `ensure` executes
    whether or not an error occurs, how can you specifically execute some code only
    when an error does *not* occur?
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to do this is to add an optional `else` clause after the `rescue` section
    and before the `ensure` section (if there is one), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*else.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Try running the previous program and enter a number such as 10, which won’t
    cause an error, so `msg` will be assigned in the `else` clause; then try entering
    0, which will cause an error, so `msg` will be assigned in the `rescue` clause.
    Whether or not there is an error, the `ensure` section will execute to create
    a `msg` string that begins with “You entered ” followed by any other messages.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Error Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you ran the *ensure.rb* program earlier and you were watching closely, you
    may have noticed something unusual when you tried to log onto a nonexistent drive
    (for example, on my system that might be the *X:\* drive). Often, when an exception
    occurs, the exception class is an instance of a specific named type such as ZeroDivisionError
    or NoMethodError. In this case, however, the class of the exception is shown to
    be `Errno::ENOENT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that there is quite a variety of `Errno` errors in Ruby. Try *disk_err.rb*.
    This defines a method, `chDisk`, which attempts to log onto a disk identified
    by the character, `aChar`. So if you pass “A” as an argument to `chDisk`, it will
    try to log onto the *A:\* drive. I’ve called the `chDisk` method three times,
    passing to it a different string each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '*disk_err.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You might, of course, need to edit the paths to something different on your
    computer. On my PC, *F:\* is my DVD drive. At the moment, it is empty, and when
    my program tries to log onto it, Ruby returns an exception of this type: `Errno::EACCES`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I have no *X:\* drive on my PC, and when I try to log onto that, Ruby returns
    an exception of this type: `Errno::ENOENT`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, I pass the string parameter “ABC,” which is invalid
    as a disk identifier, and Ruby returns an exception of this type: `Errno::EINVAL`.'
  prefs: []
  type: TYPE_NORMAL
- en: Errors of this type are descendants of the SystemCallError class. You can easily
    verify this by uncommenting the line of code to show the class’s family where
    indicated in the source code of *disk_err.rb*. This calls the same `showFamily`
    method, which you used earlier in the *exception_tree.rb* program.
  prefs: []
  type: TYPE_NORMAL
- en: These Error classes, in effect, wrap up integer error values that are returned
    by the underlying operating system. Both the names and the values of constants
    may vary according to the operating system and the version of Ruby. Here `Errno`
    is the name of the module containing the constants, such as `EACCES` and `ENOENT`,
    which match the integer error values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see a complete list of `Errno` constants, run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*errno.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the corresponding numerical value of any given constant, append `::Errno`
    to the constant name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the following code to display a list of all `Errno` constants along
    with their numerical values (here the `eval` method evaluates the expression passed
    to it—you’ll look at how this works in [Chapter 20](ch20.html "Chapter 20. Dynamic
    Programming")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'retry: Attempt to Execute Code Again After an Error'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you think an error condition may be transient or may be corrected (by the
    user, perhaps?), you can rerun all the code in a `begin..end` block using the
    keyword `retry`, as in this example that prompts the user to re-enter a value
    if an error such as ZeroDivisionError occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*retry.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you want to append the message from an exception object such as `e` to
    a string such as `"Error: "`, Ruby 1.9 insists that you explicitly convert `e`
    to a string ( `"Error: " + e.to_s`), whereas Ruby 1.8 does the conversion for
    you ( `"Error: " + e`).'
  prefs: []
  type: TYPE_NORMAL
- en: There is, of course, the danger that the error may not be as transient as you
    think, so if you use `retry`, you may want to provide a clearly defined exit condition
    to ensure that the code stops executing after a fixed number of attempts.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could, for example, increment a local variable in the `begin` clause. (If
    you do this, make sure it is incremented *before* any code that is liable to generate
    an exception since once an exception occurs, the remainder of the code prior to
    the `rescue` clause will be skipped!) Then test the value of that variable in
    the `rescue` section, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a complete example, in which I test the value of a variable named `tries`
    to ensure no more than three tries to run the code without error before the exception-handling
    block exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '*retry2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user were to enter 0 three times in a row, this would be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'raise: Reactivate a Handled Error'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you may want to keep an exception “alive” even after it has been
    trapped in an exception-handling block. You can do this, for example, to defer
    the handling of the exception, say by passing it on to some other method. You
    can do this using the `raise` method. You need to be aware, however, that, once
    raised, an exception needs to be rehandled; otherwise, it may cause your program
    to crash. Here is a simple example of raising a ZeroDivisionError exception and
    passing on the exception to a method called, in this case, `handleError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*raise.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `divbyzero` is the name of a method in which the divide-by-zero operation
    takes place, and `handleError` is a method that prints more detailed information
    on the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this uses the `backtrace` method, which displays an array of strings
    showing the filenames and line numbers where the error occurred and, in this case,
    the line that called the error-producing `divbyzero` method. This is an example
    of this program’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specifically raise your exceptions to force an error condition
    even when the program code has not caused an exception. Calling `raise` on its
    own raises an exception of the type RuntimeError (or whatever exception is in
    the global variable `$!`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, this will have no descriptive message associated with it. You can
    add a message as a parameter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can raise a specific type of error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create an object of a specific exception type and initialize it
    with a custom message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*raise2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If the standard exception types don’t meet your requirements, you can, of course,
    create new ones just by subclassing existing exceptions. Provide your classes
    with a `to_str` method in order to give them a default message.
  prefs: []
  type: TYPE_NORMAL
- en: '*raise3.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of how you might raise a custom exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now enter `sayHello( nil )`, this would be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: When trapping exceptions, the `begin` keyword may, in some circumstances, be
    omitted. Here you will learn about this syntax. I will also clarify some potential
    confusion about `catch` and `throw`.
  prefs: []
  type: TYPE_NORMAL
- en: Omitting begin and end
  prefs: []
  type: TYPE_NORMAL
- en: 'You can optionally omit `begin` and `end` when trapping exceptions inside a
    method, a class, or a module. For example, all the following are legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '*omit_begin_end.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In all the previous cases, the exception-handling will also work if you place
    the `begin` and `end` keywords at the start and end of the exception-handling
    code in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: catch..throw
  prefs: []
  type: TYPE_NORMAL
- en: 'In some languages, exceptions are trapped using the keyword `catch` and may
    be raised using the keyword `throw`. Although Ruby provides `catch` and `throw`
    methods, these are not directly related to its exception handling. Instead, `catch`
    and `throw` are used to break out of a defined block of code when some condition
    is met. You could, of course, use `catch` and `throw` to break out of a block
    of code when an exception occurs (though this may not be the most elegant way
    of handling errors). For example, this code will exit the block delimited by curly
    brackets if a ZeroDivisionError occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*catch_except.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: See [Chapter 6](ch06.html "Chapter 6. Conditional Statements") for more on `catch`
    and `throw`.
  prefs: []
  type: TYPE_NORMAL
