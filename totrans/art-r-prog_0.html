<html><head></head><body>
<p class="calibre1">34</p>
<p class="calibre1">[1] 3 4 5 5 12 13</p>
<p class="calibre1">35</p>
<p class="calibre1">36</p>
<p class="calibre1">$wrts</p>
<p class="calibre1">37</p>
<p class="calibre1">[1] 0 0 0 0 0 0</p>
<p class="calibre1">38</p>
<p class="calibre1">39</p>
<p class="calibre1">attr(,"class")</p>
<p class="calibre1">40</p>
<p class="calibre1">[1] "bookvec" </p>
<p class="calibre1">41</p>
<p class="calibre1">&gt; b[2]</p>
<p class="calibre1">42</p>
<p class="calibre1">[1] 4</p>
<p class="calibre1">43</p>
<p class="calibre1">&gt; b[2] &lt;- 88 # try writing</p>
<p class="calibre1">44</p>
<p class="calibre1">&gt; b[2] # worked? </p>
<p class="calibre1">45</p>
<p class="calibre1">[1] 88</p>
<p class="calibre1">46</p>
<p class="calibre1">&gt; b$wrts # write count incremented? </p>
<p class="calibre1">47</p>
<p class="calibre1">[1] 0 1 0 0 0 0</p>
<p class="calibre1">We have named our class "bookvec", because these vectors will do their own bookkeeping—that is, keep track of write counts. So, the subscripting functions will be [.bookvec() and [&lt;-.bookvec(). </p>
<p class="calibre1">R Programming Structures</p>
<p class="calibre1"><b class="calibre3">185</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p212"/>Our function newbookvec() (line 7) does the construction for this class. In it, you can see the structure of the class: An object will consist of the vector itself, vec (line 9), and a vector of write counts, wrts (line 10). </p>
<p class="calibre1">By the way, note in line 11 that the function class() itself is a replacement function! </p>
<p class="calibre1">The functions [.bookvec() and [&lt;-.bookvec() are fairly straightforward. </p>
<p class="calibre1">Just remember to return the entire object in the latter. </p>
<p class="calibre1"><b class="calibre3">7.11 Tools for Composing Function Code</b></p>
<p class="calibre1">If you are writing a short function that’s needed only temporarily, a quick-and-dirty way to do this is to write it on the spot, right there in your interactive terminal session. Here’s an example:</p>
<p class="calibre1">&gt; g &lt;- function(x) {</p>
<p class="calibre1">+</p>
<p class="calibre1">return(x+1)</p>
<p class="calibre1">+ }</p>
<p class="calibre1">This approach obviously is infeasible for longer, more complex functions. Now, let’s look at some better ways to compose R code. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">7.11.1 Text Editors and Integrated Development Environments</b></i></p>
<p class="calibre1">You can use a text editor such as Vim, Emacs, or even Notepad, or an editor within an integrated development environment (IDE) to write your code in a file and then read it into R from the file. To do the latter, you can use R’s source() function. </p>
<p class="calibre1">For instance, suppose we have functions f() and g() in a file  <i class="calibre4">xyz.R</i>. In R, we give this command:</p>
<p class="calibre1">&gt; source("xyz.R")</p>
<p class="calibre1">This reads f() and g() into R as if we had typed them using the quick-and-dirty way shown at the beginning of this section. </p>
<p class="calibre1">If you don’t have much code, you can cut and paste from your editor window to your R window. </p>
<p class="calibre1">Some general-purpose editors have special plug-ins available for R, such as ESS for Emacs and Vim-R for Vim. There are also IDEs for R, such as the commercial one by Revolution Analytics, and open source products such as StatET, JGR, Rcmdr, and RStudio. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">7.11.2 The edit() Function</b></i></p>
<p class="calibre1">A nice implication of the fact that functions are objects is that you can edit functions from within R’s interactive mode. Most R programmers do their code editing with a text editor in a separate window, but for a small, quick change, the edit() function can be handy. </p>
<p class="calibre1"><b class="calibre3">186</b></p>
<p class="calibre1">Chapter 7</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p213"/>For instance, we could edit the function f1() by typing this:</p>
<p class="calibre1">&gt; f1 &lt;- edit(f1)</p>
<p class="calibre1">This opens the default editor on the code for f1, which we could then edit and assign back to f1. </p>
<p class="calibre1">Or, we might be interested in having a function f2() very similar to f1() and thus could execute the following:</p>
<p class="calibre1">&gt; f2 &lt;- edit(f1)</p>
<p class="calibre1">This gives us a copy of f1() to start from. We would do a little editing and then save to f2(), as seen in the preceding command. </p>
<p class="calibre1">The editor involved will depend on R’s internal options variable editor. </p>
<p class="calibre1">In UNIX-class systems, R will set this from your shell’s EDITOR or VISUAL environment variable, or you can set it yourself, as follows:</p>
<p class="calibre1">&gt; options(editor="/usr/bin/vim")</p>
<p class="calibre1">For more details on using options, see the online documentation by typing the following:</p>
<p class="calibre1">&gt; ?options</p>
<p class="calibre1">You can use edit() to edit data structures, too. </p>
<p class="calibre1"><b class="calibre3">7.12 Writing Your Own Binary Operations</b></p>
<p class="calibre1">You can invent your own operations! Just write a function whose name begins and ends with %, with two arguments of a certain type, and a return value of that type. </p>
<p class="calibre1">For example, here’s a binary operation that adds double the second</p>
<p class="calibre1">operand to the first:</p>
<p class="calibre1">&gt; "%a2b%" &lt;- function(a,b) return(a+2*b)</p>
<p class="calibre1">&gt; 3 %a2b% 5</p>
<p class="calibre1">[1] 13</p>
<p class="calibre1">A less trivial example is given in the section about set operations in Section 8.5. </p>
<p class="calibre1"><b class="calibre3">7.13 Anonymous Functions</b></p>
<p class="calibre1">As remarked at several points in this book, the purpose of the R function function() is to create functions. For instance, consider this code: inc &lt;- function(x) return(x+1)</p>
<p class="calibre1">R Programming Structures</p>
<p class="calibre1"><b class="calibre3">187</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p214"/>It instructs R to create a function that adds 1 to its argument and then assigns that function to inc. However, that last step—the assignment—is not always taken. We can simply use the function object created by our call to function() without naming that object. The functions in that context are called  <i class="calibre4">anonymous</i>, since they have no name. (That is somewhat misleading, since even nonanonymous functions only have a name in the sense that a variable is pointing to them.)</p>
<p class="calibre1">Anonymous functions can be convenient if they are short one-liners and are called by another function. Let’s go back to our example of using apply in Section 3.3:</p>
<p class="calibre1">&gt; z</p>
<p class="calibre1">[,1] [,2]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">1</p>
<p class="calibre1">4</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">2</p>
<p class="calibre1">5</p>
<p class="calibre1">[3,]</p>
<p class="calibre1">3</p>
<p class="calibre1">6</p>
<p class="calibre1">&gt; f &lt;- function(x) x/c(2,8)</p>
<p class="calibre1">&gt; y &lt;- apply(z,1,f)</p>
<p class="calibre1">&gt; y</p>
<p class="calibre1">[,1] [,2] [,3]</p>
<p class="calibre1">[1,] 0.5 1.000 1.50</p>
<p class="calibre1">[2,] 0.5 0.625 0.75</p>
<p class="calibre1">Let’s bypass the middleman—that is, skip the assignment to f—by using an anonymous function within our call to apply(), as follows:</p>
<p class="calibre1">&gt; y &lt;- apply(z,1,function(x) x/c(2,8))</p>
<p class="calibre1">&gt; y</p>
<p class="calibre1">[,1] [,2] [,3]</p>
<p class="calibre1">[1,] 0.5 1.000 1.50</p>
<p class="calibre1">[2,] 0.5 0.625 0.75</p>
<p class="calibre1">What really happened here? The third formal argument to apply() must be a function, which is exactly what we supplied here, since the return value of function() is a function! </p>
<p class="calibre1">Doing things this way is often clearer than defining the function externally. Of course, if the function is more complicated, that clarity is not attained. </p>
<p class="calibre1"><b class="calibre3">188</b></p>
<p class="calibre1">Chapter 7</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p215"/><img src="index-215_1.png" alt="Image 20" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">8</b></p>
<p class="calibre1"><b class="calibre3">DOING MATH AND SIMULATIONS IN R</b></p>
<p class="calibre1">R contains built-in functions for your</p>
<p class="calibre1">favorite math operations and, of course, </p>
<p class="calibre1">for statistical distributions. This chapter</p>
<p class="calibre1">provides an overview of using these functions. </p>
<p class="calibre1">Given the mathematical nature of this chapter, the</p>
<p class="calibre1">examples assume a slightly higher-level knowledge</p>
<p class="calibre1">than those in other chapters. You should be familiar</p>
<p class="calibre1">with calculus and linear algebra to get the most out</p>
<p class="calibre1">of these examples. </p>
<p class="calibre1"><b class="calibre3">8.1 Math Functions</b></p>
<p class="calibre1">R includes an extensive set of built-in math functions. Here is a partial list:</p>
<p class="calibre1">•</p>
<p class="calibre1">exp(): Exponential function, base e</p>
<p class="calibre1">•</p>
<p class="calibre1">log(): Natural logarithm</p>
<p class="calibre1">•</p>
<p class="calibre1">log10(): Logarithm base 10</p>
<p class="calibre1">•</p>
<p class="calibre1">sqrt(): Square root</p>
<p class="calibre1">•</p>
<p class="calibre1">abs(): Absolute value</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p216"/>•</p>
<p class="calibre1">sin(), cos(), and so on: Trig functions</p>
<p class="calibre1">•</p>
<p class="calibre1">min() and max(): Minimum value and maximum value within a vector</p>
<p class="calibre1">•</p>
<p class="calibre1">which.min() and which.max(): Index of the minimal element and maximal element of a vector</p>
<p class="calibre1">•</p>
<p class="calibre1">pmin() and pmax(): Element-wise minima and maxima of several vectors</p>
<p class="calibre1">•</p>
<p class="calibre1">sum() and prod(): Sum and product of the elements of a vector</p>
<p class="calibre1">•</p>
<p class="calibre1">cumsum() and cumprod(): Cumulative sum and product of the elements of a vector</p>
<p class="calibre1">•</p>
<p class="calibre1">round(), floor(), and ceiling(): Round to the closest integer, to the closest integer below, and to the closest integer above</p>
<p class="calibre1">•</p>
<p class="calibre1">factorial(): Factorial function</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">8.1.1 Extended Example: Calculating a Probability</b></i></p>
<p class="calibre1">As our first example, we’ll work through calculating a probability using the prod() function. Suppose we have  <i class="calibre4">n </i> independent events, and the  <i class="calibre4">i</i> th event has the probability  <i class="calibre4">pi </i> of occurring. What is the probability of exactly one of these events occurring? </p>
<p class="calibre1">Suppose first that  <i class="calibre4">n </i>= 3 and our events are named A, B, and C. Then we break down the computation as follows:</p>
<p class="calibre1">P(exactly one event occurs)</p>
<p class="calibre1">=</p>
<p class="calibre1">P(A and not B and not C)</p>
<p class="calibre1">+</p>
<p class="calibre1">P(not A and B and not C)</p>
<p class="calibre1">+</p>
<p class="calibre1">P(not A and not B and C)</p>
<p class="calibre1">P(A and not B and not C) would be  <i class="calibre4">pA</i>(1  <i class="calibre4">− pB</i>)(1  <i class="calibre4">− pC</i>), and so on. </p>
<p class="calibre1">For general  <i class="calibre4">n</i>, that is calculated as follows:</p>
<p class="calibre1"> <i class="calibre4">n</i></p>
<p class="calibre1"> <i class="calibre4">pi</i>(1 <i class="calibre4">−p</i> 1) <i class="calibre4">... </i>(1 <i class="calibre4">−pi−</i> 1)(1 <i class="calibre4">−pi</i>+1) <i class="calibre4">... </i>(1 <i class="calibre4">−pn</i>) <i class="calibre4">i</i>=1</p>
<p class="calibre1">(The  <i class="calibre4">i</i> th term inside the sum is the probability that event  <i class="calibre4">i </i> occurs and all the others do  <i class="calibre4">not </i> occur.)</p>
<p class="calibre1">Here’s code to compute this, with our probabilities  <i class="calibre4">pi </i> contained in the vector p:</p>
<p class="calibre1">exactlyone &lt;- function(p) {</p>
<p class="calibre1">notp &lt;- 1 - p</p>
<p class="calibre1">tot &lt;- 0.0</p>
<p class="calibre1">for (i in 1:length(p))</p>
<p class="calibre1">tot &lt;- tot + p[i] * prod(notp[-i])</p>
<p class="calibre1">return(tot)</p>
<p class="calibre1">}</p>
<p class="calibre1"><b class="calibre3">190</b></p>
<p class="calibre1">Chapter 8</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p217"/>How does it work? Well, the assignment</p>
<p class="calibre1">notp &lt;- 1 - p</p>
<p class="calibre1">creates a vector of all the “not occur” probabilities 1  <i class="calibre4">− pj</i>, using recycling. </p>
<p class="calibre1">The expression notp[-i] computes the product of all the elements of notp, except the  <i class="calibre4">i</i> th—exactly what we need. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">8.1.2 Cumulative Sums and Products</b></i></p>
<p class="calibre1">As mentioned, the functions cumsum() and cumprod() return cumulative sums and products. </p>
<p class="calibre1">&gt; x &lt;- c(12,5,13)</p>
<p class="calibre1">&gt; cumsum(x)</p>
<p class="calibre1">[1] 12 17 30</p>
<p class="calibre1">&gt; cumprod(x)</p>
<p class="calibre1">[1] 12 60 780</p>
<p class="calibre1">In x, the sum of the first element is 12, the sum of the first two elements is 17, and the sum of the first three elements is 30. </p>
<p class="calibre1">The function cumprod() works the same way as cumsum(), but with the product instead of the sum. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">8.1.3 Minima and Maxima</b></i></p>
<p class="calibre1">There is quite a difference between min() and pmin(). The former simply combines all its arguments into one long vector and returns the minimum value in that vector. In contrast, if pmin() is applied to two or more vectors, it returns a vector of the pair-wise minima, hence the name pmin. </p>
<p class="calibre1">Here’s an example:</p>
<p class="calibre1">&gt; z</p>
<p class="calibre1">[,1] [,2]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">1</p>
<p class="calibre1">2</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">5</p>
<p class="calibre1">3</p>
<p class="calibre1">[3,]</p>
<p class="calibre1">6</p>
<p class="calibre1">2</p>
<p class="calibre1">&gt; min(z[,1],z[,2])</p>
<p class="calibre1">[1] 1</p>
<p class="calibre1">&gt; pmin(z[,1],z[,2])</p>
<p class="calibre1">[1] 1 3 2</p>
<p class="calibre1">In the first case, min() computed the smallest value in (1,5,6,2,3,2). But the call to pmin() computed the smaller of 1 and 2, yielding 1; then the smaller of 5 and 3, which is 3; then finally the minimum of 6 and 2, giving 2. Thus, the call returned the vector (1,3,2). </p>
<p class="calibre1">Doing Math and Simulations in R</p>
<p class="calibre1"><b class="calibre3">191</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p218"/>You can use more than two arguments in pmin(), like this:</p>
<p class="calibre1">&gt; pmin(z[1,],z[2,],z[3,])</p>
<p class="calibre1">[1] 1 2</p>
<p class="calibre1">The 1 in the output is the minimum of 1, 5, and 6, with a similar computation leading to the 2. </p>
<p class="calibre1">The max() and pmax() functions act analogously to min() and pmin(). </p>
<p class="calibre1">Function minimization/maximization can be done via nlm() and optim(). </p>
<p class="calibre1">For example, let’s find the smallest value of  <i class="calibre4">f </i>( <i class="calibre4">x</i>) =  <i class="calibre4">x</i> 2  <i class="calibre4">− </i> sin( <i class="calibre4">x</i>). </p>
<p class="calibre1">&gt; nlm(function(x) return(x^2-sin(x)),8)</p>
<p class="calibre1">$minimum</p>
<p class="calibre1">[1] -0.2324656</p>
<p class="calibre1">$estimate</p>
<p class="calibre1">[1] 0.4501831</p>
<p class="calibre1">$gradient</p>
<p class="calibre1">[1] 4.024558e-09</p>
<p class="calibre1">$code</p>
<p class="calibre1">[1] 1</p>
<p class="calibre1">$iterations</p>
<p class="calibre1">[1] 5</p>
<p class="calibre1">Here, the minimum value was found to be approximately  <i class="calibre4">−</i> 0.23, occurring at  <i class="calibre4">x </i>= 0.45. A Newton-Raphson method (a technique from numerical analysis for approximating roots) is used, running five iterations in this case. </p>
<p class="calibre1">The second argument specifies the initial guess, which we set to be 8. (This second argument was picked pretty arbitrarily here, but in some problems, you may need to experiment to find a value that will lead to convergence.)</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">8.1.4 Calculus</b></i></p>
<p class="calibre1">R also has some calculus capabilities, including symbolic differentiation and numerical integration, as you can see in the following example. </p>
<p class="calibre1">&gt; D(expression(exp(x^2)),"x") # derivative</p>
<p class="calibre1">exp(x^2) * (2 * x)</p>
<p class="calibre1">&gt; integrate(function(x) x^2,0,1)</p>
<p class="calibre1">0.3333333 with absolute error &lt; 3.7e-15</p>
<p class="calibre1"><b class="calibre3">192</b></p>
<p class="calibre1">Chapter 8</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p219"/>Here, R reported</p>
<p class="calibre1"> <i class="calibre4">d ex</i> 2 = 2 <i class="calibre4">xex</i> 2</p>
<p class="calibre1"> <i class="calibre4">dx</i></p>
<p class="calibre1">and</p>
<p class="calibre1">1</p>
<p class="calibre1"> <i class="calibre4">x</i> 2  <i class="calibre4">dx ≈ </i> 0 <i class="calibre4">. </i> 3333333</p>
<p class="calibre1">0</p>
<p class="calibre1">You can find R packages for differential equations (odesolve), for interfacing R with the Yacas symbolic math system (ryacas), and for other calculus operations. These packages, and thousands of others, are available from the Comprehensive R Archive Network (CRAN); see Appendix B. </p>
<p class="calibre1"><b class="calibre3">8.2 Functions for Statistical Distributions</b></p>
<p class="calibre1">R has functions available for most of the famous statistical distributions. </p>
<p class="calibre1">Prefix the name as follows:</p>
<p class="calibre1">•</p>
<p class="calibre1">With d for the density or probability mass function (pmf)</p>
<p class="calibre1">•</p>
<p class="calibre1">With p for the cumulative distribution function (cdf)</p>
<p class="calibre1">•</p>
<p class="calibre1">With q for quantiles</p>
<p class="calibre1">•</p>
<p class="calibre1">With r for random number generation</p>
<p class="calibre1">The rest of the name indicates the distribution. Table 8-1 lists some common statistical distribution functions. </p>
<p class="calibre1"><b class="calibre3">Table 8-1: </b>Common R Statistical Distribution Functions</p>
<p class="calibre1"><b class="calibre3">Distribution</b></p>
<p class="calibre1"><b class="calibre3">Density/pmf</b></p>
<p class="calibre1"><b class="calibre3">cdf</b></p>
<p class="calibre1"><b class="calibre3">Quantiles</b></p>
<p class="calibre1"><b class="calibre3">Random Numbers</b></p>
<p class="calibre1">Normal</p>
<p class="calibre1">dnorm()</p>
<p class="calibre1">pnorm()</p>
<p class="calibre1">qnorm()</p>
<p class="calibre1">rnorm()</p>
<p class="calibre1">Chi square</p>
<p class="calibre1">dchisq()</p>
<p class="calibre1">pchisq()</p>
<p class="calibre1">qchisq()</p>
<p class="calibre1">rchisq()</p>
<p class="calibre1">Binomial</p>
<p class="calibre1">dbinom()</p>
<p class="calibre1">pbinom()</p>
<p class="calibre1">qbinom()</p>
<p class="calibre1">rbinom()</p>
<p class="calibre1">As an example, let’s simulate 1,000 chi-square variates with 2 degrees of freedom and find their mean. </p>
<p class="calibre1">&gt; mean(rchisq(1000,df=2))</p>
<p class="calibre1">[1] 1.938179</p>
<p class="calibre1">The r in rchisq specifies that we wish to generate random numbers—</p>
<p class="calibre1">in this case, from the chi-square distribution. As seen in this example, the first argument in the r-series functions is the number of random variates to generate. </p>
<p class="calibre1">Doing Math and Simulations in R</p>
<p class="calibre1"><b class="calibre3">193</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p220"/>These functions also have arguments specific to the given distribution families. In our example, we use the df argument for the chi-square family, indicating the number of degrees of freedom. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">Consult R’s online help for details on the arguments for the statistical distribution</i> <i class="calibre4">functions. For instance, to find our more about the chi-square function for quantiles,</i> <i class="calibre4">type ?qchisq at the command prompt. </i></p>
<p class="calibre1">Let’s also compute the 95th percentile of the chi-square distribution with two degrees of freedom:</p>
<p class="calibre1">&gt; qchisq(0.95,2)</p>
<p class="calibre1">[1] 5.991465</p>
<p class="calibre1">Here, we used q to indicate quantile—in this case, the 0.95 quantile, or the 95th percentile. </p>
<p class="calibre1">The first argument in the d, p, and q series is actually a vector so that we can evaluate the density/pmf, cdf, or quantile function at multiple points. </p>
<p class="calibre1">Let’s find both the 50th and 95th percentiles of the chi-square distribution with 2 degrees of freedom. </p>
<p class="calibre1">qchisq(c(0.5,0.95),df=2)</p>
<p class="calibre1">[1] 1.386294 5.991465</p>
<p class="calibre1"><b class="calibre3">8.3 Sorting</b></p>
<p class="calibre1">Ordinary numerical sorting of a vector can be done with the sort() function, as in this example:</p>
<p class="calibre1">&gt; x &lt;- c(13,5,12,5)</p>
<p class="calibre1">&gt; sort(x)</p>
<p class="calibre1">[1] 5 5 12 13</p>
<p class="calibre1">&gt; x</p>
<p class="calibre1">[1] 13 5 12 5</p>
<p class="calibre1">Note that x itself did not change, in keeping with R’s functional language philosophy. </p>
<p class="calibre1">If you want the indices of the sorted values in the original vector, use the order() function. Here’s an example:</p>
<p class="calibre1">&gt; order(x)</p>
<p class="calibre1">[1] 2 4 3 1</p>
<p class="calibre1">This means that x[2] is the smallest value in x, x[4] is the second smallest, x[3] is the third smallest, and so on. </p>
<p class="calibre1"><b class="calibre3">194</b></p>
<p class="calibre1">Chapter 8</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p221"/>You can use order(), together with indexing, to sort data frames, like this:</p>
<p class="calibre1">&gt; y</p>
<p class="calibre1">V1 V2</p>
<p class="calibre1">1 def 2</p>
<p class="calibre1">2</p>
<p class="calibre1">ab 5</p>
<p class="calibre1">3 zzzz 1</p>
<p class="calibre1">&gt; r &lt;- order(y$V2)</p>
<p class="calibre1">&gt; r</p>
<p class="calibre1">[1] 3 1 2</p>
<p class="calibre1">&gt; z &lt;- y[r,]</p>
<p class="calibre1">&gt; z</p>
<p class="calibre1">V1 V2</p>
<p class="calibre1">3 zzzz 1</p>
<p class="calibre1">1 def 2</p>
<p class="calibre1">2</p>
<p class="calibre1">ab 5</p>
<p class="calibre1">What happened here? We called order() on the second column of y, </p>
<p class="calibre1">yielding a vector r, telling us where numbers should go if we want to sort them. The 3 in this vector tells us that x[3,2] is the smallest number in x[,2]; the 1 tells us that x[1,2] is the second smallest; and the 2 tells us that x[2,2]</p>
<p class="calibre1">is the third smallest. We then use indexing to produce the frame sorted by column 2, storing it in z. </p>
<p class="calibre1">You can use order() to sort according to character variables as well as numeric ones, as follows:</p>
<p class="calibre1">&gt; d</p>
<p class="calibre1">kids ages</p>
<p class="calibre1">1 Jack</p>
<p class="calibre1">12</p>
<p class="calibre1">2 Jill</p>
<p class="calibre1">10</p>
<p class="calibre1">3 Billy</p>
<p class="calibre1">13</p>
<p class="calibre1">&gt; d[order(d$kids),]</p>
<p class="calibre1">kids ages</p>
<p class="calibre1">3 Billy</p>
<p class="calibre1">13</p>
<p class="calibre1">1 Jack</p>
<p class="calibre1">12</p>
<p class="calibre1">2 Jill</p>
<p class="calibre1">10</p>
<p class="calibre1">&gt; d[order(d$ages),]</p>
<p class="calibre1">kids ages</p>
<p class="calibre1">2 Jill</p>
<p class="calibre1">10</p>
<p class="calibre1">1 Jack</p>
<p class="calibre1">12</p>
<p class="calibre1">3 Billy</p>
<p class="calibre1">13</p>
<p class="calibre1">A related function is rank(), which reports the rank of each element of a vector. </p>
<p class="calibre1">Doing Math and Simulations in R</p>
<p class="calibre1"><b class="calibre3">195</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p222"/>&gt; x &lt;- c(13,5,12,5)</p>
<p class="calibre1">&gt; rank(x)</p>
<p class="calibre1">[1] 4.0 1.5 3.0 1.5</p>
<p class="calibre1">This says that 13 had rank 4 in x; that is, it is the fourth smallest. The value 5 appears twice in x, with those two being the first and second smallest, so the rank 1.5 is assigned to both. Optionally, other methods of handling ties can be specified. </p>
<p class="calibre1"><b class="calibre3">8.4 Linear Algebra Operations on Vectors and Matrices</b></p>
<p class="calibre1">Multiplying a vector by a scalar works directly, as you saw earlier. Here’s another example:</p>
<p class="calibre1">&gt; y</p>
<p class="calibre1">[1] 1 3 4 10</p>
<p class="calibre1">&gt; 2*y</p>
<p class="calibre1">[1] 2 6 8 20</p>
<p class="calibre1">If you wish to compute the inner product (or dot product) of two vectors, use crossprod(), like this:</p>
<p class="calibre1">&gt; crossprod(1:3,c(5,12,13))</p>
<p class="calibre1">[,1]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">68</p>
<p class="calibre1">The function computed 1  <i class="calibre4">· </i> 5 + 2  <i class="calibre4">· </i> 12 + 3  <i class="calibre4">· </i> 13 = 68. </p>
<p class="calibre1">Note that the name crossprod() is a misnomer, as the function does not compute the vector cross product. We’ll develop a function to compute real cross products in Section 8.4.1. </p>
<p class="calibre1">For matrix multiplication in the mathematical sense, the operator to use is %*%, not *. For instance, here we compute the matrix product:</p>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1">1 2</p>
<p class="calibre1">1  <i class="calibre4">−</i> 1</p>
<p class="calibre1">1 1</p>
<p class="calibre1">3 4</p>
<p class="calibre1">0</p>
<p class="calibre1">1</p>
<p class="calibre1">=</p>
<p class="calibre1">3 1</p>
<p class="calibre1">Here’s the code:</p>
<p class="calibre1">&gt; a</p>
<p class="calibre1">[,1] [,2]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">1</p>
<p class="calibre1">2</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">3</p>
<p class="calibre1">4</p>
<p class="calibre1">&gt; b</p>
<p class="calibre1">[,1] [,2]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">1</p>
<p class="calibre1">-1</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">0</p>
<p class="calibre1">1</p>
<p class="calibre1"><b class="calibre3">196</b></p>
<p class="calibre1">Chapter 8</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p223"/>&gt; a %*% b</p>
<p class="calibre1">[,1] [,2]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">1</p>
<p class="calibre1">1</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">3</p>
<p class="calibre1">1</p>
<p class="calibre1">The function solve() will solve systems of linear equations and even find matrix inverses. For example, let’s solve this system:</p>
<p class="calibre1"> <i class="calibre4">x</i> 1 +  <i class="calibre4">x</i> 2 = 2</p>
<p class="calibre1"> <i class="calibre4">−x</i> 1 +  <i class="calibre4">x</i> 2 = 4</p>
<p class="calibre1">Its matrix form is as follows:</p>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1">1</p>
<p class="calibre1">1</p>
<p class="calibre1"> <i class="calibre4">x</i> 1</p>
<p class="calibre1">2</p>
<p class="calibre1"> <i class="calibre4">−</i> 1 1</p>
<p class="calibre1">=</p>
<p class="calibre1"> <i class="calibre4">x</i> 2</p>
<p class="calibre1">4</p>
<p class="calibre1">Here’s the code:</p>
<p class="calibre1">&gt; a &lt;- matrix(c(1,1,-1,1),nrow=2,ncol=2)</p>
<p class="calibre1">&gt; b &lt;- c(2,4)</p>
<p class="calibre1">&gt; solve(a,b)</p>
<p class="calibre1">[1] 3 1</p>
<p class="calibre1">&gt; solve(a)</p>
<p class="calibre1">[,1] [,2]</p>
<p class="calibre1">[1,] 0.5 0.5</p>
<p class="calibre1">[2,] -0.5 0.5</p>
<p class="calibre1">In that second call to solve(), the lack of a second argument signifies that we simply wish to compute the inverse of the matrix. </p>
<p class="calibre1">Here are a few other linear algebra functions:</p>
<p class="calibre1">•</p>
<p class="calibre1">t(): Matrix transpose</p>
<p class="calibre1">•</p>
<p class="calibre1">qr(): QR decomposition</p>
<p class="calibre1">•</p>
<p class="calibre1">chol(): Cholesky decomposition</p>
<p class="calibre1">•</p>
<p class="calibre1">det(): Determinant</p>
<p class="calibre1">•</p>
<p class="calibre1">eigen(): Eigenvalues/eigenvectors</p>
<p class="calibre1">•</p>
<p class="calibre1">diag(): Extracts the diagonal of a square matrix (useful for obtaining variances from a covariance matrix and for constructing a diagonal</p>
<p class="calibre1">matrix). </p>
<p class="calibre1">•</p>
<p class="calibre1">sweep(): Numerical analysis sweep operations</p>
<p class="calibre1">Note the versatile nature of diag(): If its argument is a matrix, it returns a vector, and vice versa. Also, if the argument is a scalar, the function returns the identity matrix of the specified size. </p>
<p class="calibre1">Doing Math and Simulations in R</p>
<p class="calibre1"><b class="calibre3">197</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p224"/>&gt; m</p>
<p class="calibre1">[,1] [,2]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">1</p>
<p class="calibre1">2</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">7</p>
<p class="calibre1">8</p>
<p class="calibre1">&gt; dm &lt;- diag(m)</p>
<p class="calibre1">&gt; dm</p>
<p class="calibre1">[1] 1 8</p>
<p class="calibre1">&gt; diag(dm)</p>
<p class="calibre1">[,1] [,2]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">1</p>
<p class="calibre1">0</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">0</p>
<p class="calibre1">8</p>
<p class="calibre1">&gt; diag(3)</p>
<p class="calibre1">[,1] [,2] [,3]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">1</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">0</p>
<p class="calibre1">1</p>
<p class="calibre1">0</p>
<p class="calibre1">[3,]</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">1</p>
<p class="calibre1">The sweep() function is capable of fairly complex operations. As a simple example, let’s take a 3-by-3 matrix and add 1 to row 1, 4 to row 2, and 7 to row 3. </p>
<p class="calibre1">&gt; m</p>
<p class="calibre1">[,1] [,2] [,3]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">1</p>
<p class="calibre1">2</p>
<p class="calibre1">3</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">4</p>
<p class="calibre1">5</p>
<p class="calibre1">6</p>
<p class="calibre1">[3,]</p>
<p class="calibre1">7</p>
<p class="calibre1">8</p>
<p class="calibre1">9</p>
<p class="calibre1">&gt; sweep(m,1,c(1,4,7),"+")</p>
<p class="calibre1">[,1] [,2] [,3]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">2</p>
<p class="calibre1">3</p>
<p class="calibre1">4</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">8</p>
<p class="calibre1">9</p>
<p class="calibre1">10</p>
<p class="calibre1">[3,]</p>
<p class="calibre1">14</p>
<p class="calibre1">15</p>
<p class="calibre1">16</p>
<p class="calibre1">The first two arguments to sweep() are like those of apply(): the array and the margin, which is 1 for rows in this case. The fourth argument is a function to be applied, and the third is an argument to that function (to the</p>
<p class="calibre1">"+" function). </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">8.4.1 Extended Example: Vector Cross Product</b></i></p>
<p class="calibre1">Let’s consider the issue of vector cross products. The definition is very simple: The cross product of vectors ( <i class="calibre4">x</i> 1 <i class="calibre4">, x</i> 2 <i class="calibre4">, x</i> 3) and ( <i class="calibre4">y</i> 1 <i class="calibre4">, y</i> 2 <i class="calibre4">, y</i> 3) in three-dimensional space is a new three-dimensional vector, as shown in Equation 8.1. </p>
<p class="calibre1">( <i class="calibre4">x</i> 2 <i class="calibre4">y</i> 3  <i class="calibre4">− x</i> 3 <i class="calibre4">y</i> 2 <i class="calibre4">, −x</i> 1 <i class="calibre4">y</i> 3 +  <i class="calibre4">x</i> 3 <i class="calibre4">y</i> 1 <i class="calibre4">, x</i> 1 <i class="calibre4">y</i> 2  <i class="calibre4">− x</i> 2 <i class="calibre4">y</i> 1) (8.1)</p>
<p class="calibre1"><b class="calibre3">198</b></p>
<p class="calibre1">Chapter 8</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p225"/>This can be expressed compactly as the expansion along the top row of the determinant, as shown in Equation 8.2. </p>
<p class="calibre1">⎛</p>
<p class="calibre1">⎞</p>
<p class="calibre1"> <i class="calibre4">− − −</i></p>
<p class="calibre1">⎝  <i class="calibre4">x</i> 1  <i class="calibre4">x</i> 2  <i class="calibre4">x</i> 3 ⎠</p>
<p class="calibre1">(8.2)</p>
<p class="calibre1"> <i class="calibre4">y</i> 1</p>
<p class="calibre1"> <i class="calibre4">y</i> 2</p>
<p class="calibre1"> <i class="calibre4">y</i> 3</p>
<p class="calibre1">Here, the elements in the top row are merely placeholders. </p>
<p class="calibre1">Don’t worry about this bit of pseudomath. The point is that the cross product vector can be computed as a sum of subdeterminants. For instance, the first component in Equation 8.1,  <i class="calibre4">x</i> 2 <i class="calibre4">y</i> 3  <i class="calibre4">− x</i> 3 <i class="calibre4">y</i> 2, is easily seen to be the determinant of the submatrix obtained by deleting the first row and first column in Equation 8.2, as shown in Equation 8.3. </p>
<p class="calibre1"/>
<p class="calibre1"/>
<p class="calibre1"> <i class="calibre4">x</i> 2  <i class="calibre4">x</i> 3</p>
<p class="calibre1">(8.3)</p>
<p class="calibre1"> <i class="calibre4">y</i> 2</p>
<p class="calibre1"> <i class="calibre4">y</i> 3</p>
<p class="calibre1">Our need to calculate subdeterminants—that is determinants of</p>
<p class="calibre1">submatrices—fits perfectly with R, which excels at specifying submatrices. </p>
<p class="calibre1">This suggests calling det() on the proper submatrices, as follows:</p>
<p class="calibre1">xprod &lt;- function(x,y) {</p>
<p class="calibre1">m &lt;- rbind(rep(NA,3),x,y)</p>
<p class="calibre1">xp &lt;- vector(length=3)</p>
<p class="calibre1">for (i in 1:3)</p>
<p class="calibre1">xp[i] &lt;- -(-1)^i * det(m[2:3,-i])</p>
<p class="calibre1">return(xp)</p>
<p class="calibre1">}</p>
<p class="calibre1">Note that even R’s ability to specify values as NA came into play here to deal with the “placeholders” mentioned above. </p>
<p class="calibre1">All this may seem like overkill. After all, it wouldn’t have been hard to code Equation 8.1 directly, without resorting to use of submatrices and determinants. But while that may be true in the three-dimensional case, the approach shown here is quite fruitful in the  <i class="calibre4">n</i>-ary case, in  <i class="calibre4">n</i>-dimensional space. The cross product there is defined as an  <i class="calibre4">n</i>-by- <i class="calibre4">n </i> determinant of the form shown in Equation 8.1, and thus the preceding code generalizes perfectly. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">8.4.2 Extended Example: Finding Stationary Distributions of Markov Chains</b></i></p>
<p class="calibre1">A Markov chain is a random process in which we move among various  <i class="calibre4">states</i>, in a “memoryless” fashion, whose definition need not concern us here. The state could be the number of jobs in a queue, the number of items stored in inventory, and so on. We will assume the number of states to be finite. </p>
<p class="calibre1">As a simple example, consider a game in which we toss a coin repeatedly and win a dollar whenever we accumulate three consecutive heads. </p>
<p class="calibre1">Our state at any time  <i class="calibre4">i </i> will the number of consecutive heads we have so far, so our state can be 0, 1, or 2. (When we get three heads in a row, our state reverts to 0.)</p>
<p class="calibre1">Doing Math and Simulations in R</p>
<p class="calibre1"><b class="calibre3">199</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p226"/>The central interest in Markov modeling is usually the long-run state distribution, meaning the long-run proportions of the time we are in each state. In our coin-toss game, we can use the code we’ll develop here to calculate that distribution, which turns out to have us at states 0, 1, and 2 in proportions 57.1%, 28.6%, and 14.3% of the time. Note that we win our dollar if we are in state 2 and toss a head, so 0.143  <i class="calibre4">× </i> 0.5 = 0.071 of our tosses will result in wins. </p>
<p class="calibre1">Since R vector and matrix indices start at 1 rather than 0, it will be convenient to relabel our states here as 1, 2, and 3 rather than 0, 1, and 2. For example, state 3 now means that we currently have two consecutive heads. </p>
<p class="calibre1">Let  <i class="calibre4">pij </i> denote the  <i class="calibre4">transition probability </i> of moving from state  <i class="calibre4">i </i> to state  <i class="calibre4">j</i> during a time step. In the game example, for instance,  <i class="calibre4">p</i> 23 = 0 <i class="calibre4">. </i> 5, reflecting the fact that with probability 1/2, we will toss a head and thus move from having one consecutive head to two. On the other hand, if we toss a tail while we are in state 2, we go to state 1, meaning 0 consecutive heads; thus <i class="calibre4">p</i> 21 = 0 <i class="calibre4">. </i> 5. </p>
<p class="calibre1">We are interested in calculating the vector  <i class="calibre4">π </i>= ( <i class="calibre4">π</i> 1 <i class="calibre4">, ..., πs</i>), where  <i class="calibre4">πi</i> is the long-run proportion of time spent at state i, over all states i. Let  <i class="calibre4">P</i></p>
<p class="calibre1">denote the transition probability matrix whose  <i class="calibre4">i</i> th row,  <i class="calibre4">j</i> th column element is  <i class="calibre4">pij</i>. Then it can be shown that  <i class="calibre4">π </i> must satisfy Equation 8.4, <i class="calibre4">π </i>=  <i class="calibre4">πP</i></p>
<p class="calibre1">(8.4)</p>
<p class="calibre1">which is equivalent to Equation 8.5:</p>
<p class="calibre1">( <i class="calibre4">I − P T </i>) <i class="calibre4">π </i>= 0</p>
<p class="calibre1">(8.5)</p>
<p class="calibre1">Here  <i class="calibre4">I </i> is the identity matrix and  <i class="calibre4">P T </i> denotes the transpose of  <i class="calibre4">P</i>. </p>
<p class="calibre1">Any single one of the equations in the system of Equation 8.5 is redundant. We thus eliminate one of them, by removing the last row of  <i class="calibre4">I −P </i> in Equation 8.5. That also means removing the last 0 in the 0 vector on the right-hand side of Equation 8.5. </p>
<p class="calibre1">But note that there is also the constraint shown in Equation 8.6. </p>
<p class="calibre1"> <i class="calibre4">πi </i>= 1</p>
<p class="calibre1">(8.6)</p>
<p class="calibre1"> <i class="calibre4">i</i></p>
<p class="calibre1">In matrix terms, this is as follows:</p>
<p class="calibre1">1 <i class="calibre4">Tnπ </i>= 1</p>
<p class="calibre1">where 1 <i class="calibre4">n </i> is a vector of  <i class="calibre4">n </i> 1s. </p>
<p class="calibre1">So, in the modified version of Equation 8.5, we replace the removed row with a row of all 1s and, on the right-hand side, replace the removed 0 with a 1. We can then solve the system. </p>
<p class="calibre1">All this can be computed with R’s solve() function, as follows:</p>
<p class="calibre1">1</p>
<p class="calibre1">findpi1 &lt;- function(p) {</p>
<p class="calibre1">2</p>
<p class="calibre1">n &lt;- nrow(p)</p>
<p class="calibre1">3</p>
<p class="calibre1">imp &lt;- diag(n) - t(p)</p>
<p class="calibre1"><b class="calibre3">200</b></p>
<p class="calibre1">Chapter 8</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p227"/>4</p>
<p class="calibre1">imp[n,] &lt;- rep(1,n)</p>
<p class="calibre1">5</p>
<p class="calibre1">rhs &lt;- c(rep(0,n-1),1)</p>
<p class="calibre1">6</p>
<p class="calibre1">pivec &lt;- solve(imp,rhs)</p>
<p class="calibre1">7</p>
<p class="calibre1">return(pivec)</p>
<p class="calibre1">8</p>
<p class="calibre1">}</p>
<p class="calibre1">Here are the main steps:</p>
<p class="calibre1">1. </p>
<p class="calibre1">Calculate  <i class="calibre4">I − P T </i> in line 3. Note again that diag(), when called with a scalar argument, returns the identity matrix of the size given by that argument. </p>
<p class="calibre1">2. </p>
<p class="calibre1">Replace the last row of  <i class="calibre4">P </i> with 1 values in line 4. </p>
<p class="calibre1">3. </p>
<p class="calibre1">Set up the right-hand side vector in line 5. </p>
<p class="calibre1">4. </p>
<p class="calibre1">Solve for  <i class="calibre4">π </i> in line 6. </p>
<p class="calibre1">Another approach, using more advanced knowledge, is based on eigen-</p>
<p class="calibre1">values. Note from Equation 8.4 that  <i class="calibre4">π </i> is a left eigenvector of  <i class="calibre4">P </i> with eigenvalue 1. This suggests using R’s eigen() function, selecting the eigenvector corresponding to that eigenvalue. (A result from mathematics, the Perron-Frobenius theorem, can be used to carefully justify this.)</p>
<p class="calibre1">Since  <i class="calibre4">π </i> is a left eigenvector, the argument in the call to eigen() must be  <i class="calibre4">P </i> transpose rather than  <i class="calibre4">P</i>. In addition, since an eigenvector is unique only up to scalar multiplication, we must deal with two issues regarding the eigenvector returned to us by eigen():</p>
<p class="calibre1">•</p>
<p class="calibre1">It may have negative components. If so, we multiply by  <i class="calibre4">−</i> 1. </p>
<p class="calibre1">•</p>
<p class="calibre1">It may not satisfy Equation 8.6. We remedy this by dividing by the length of the returned vector. </p>
<p class="calibre1">Here is the code:</p>
<p class="calibre1">1</p>
<p class="calibre1">findpi2 &lt;- function(p) {</p>
<p class="calibre1">2</p>
<p class="calibre1">n &lt;- nrow(p)</p>
<p class="calibre1">3</p>
<p class="calibre1"># find first eigenvector of P transpose</p>
<p class="calibre1">4</p>
<p class="calibre1">pivec &lt;- eigen(t(p))$vectors[,1]</p>
<p class="calibre1">5</p>
<p class="calibre1"># guaranteed to be real, but could be negative</p>
<p class="calibre1">6</p>
<p class="calibre1">if (pivec[1] &lt; 0) pivec &lt;- -pivec</p>
<p class="calibre1">7</p>
<p class="calibre1"># normalize to sum to 1</p>
<p class="calibre1">8</p>
<p class="calibre1">pivec &lt;- pivec / sum(pivec)</p>
<p class="calibre1">9</p>
<p class="calibre1">return(pivec)</p>
<p class="calibre1">10</p>
<p class="calibre1">}</p>
<p class="calibre1">The return value of eigen() is a list. One of the list’s components is a matrix named vectors. These are the eigenvectors, with the  <i class="calibre4">i</i> th column being the eigenvector corresponding to the  <i class="calibre4">i</i> th eigenvalue. Thus, we take column 1 here. </p>
<p class="calibre1">Doing Math and Simulations in R</p>
<p class="calibre1"><b class="calibre3">201</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p228"/><b class="calibre3">8.5 Set Operations</b></p>
<p class="calibre1">R includes some handy set operations, including these:</p>
<p class="calibre1">•</p>
<p class="calibre1">union(x,y): Union of the sets x and y</p>
<p class="calibre1">•</p>
<p class="calibre1">intersect(x,y): Intersection of the sets x and y</p>
<p class="calibre1">•</p>
<p class="calibre1">setdiff(x,y): Set difference between x and y, consisting of all elements of x that are not in y</p>
<p class="calibre1">•</p>
<p class="calibre1">setequal(x,y): Test for equality between x and y</p>
<p class="calibre1">•</p>
<p class="calibre1">c %in% y: Membership, testing whether c is an element of the set y</p>
<p class="calibre1">•</p>
<p class="calibre1">choose(n,k): Number of possible subsets of size k chosen from a set of size n</p>
<p class="calibre1">Here are some simple examples of using these functions:</p>
<p class="calibre1">&gt; x &lt;- c(1,2,5)</p>
<p class="calibre1">&gt; y &lt;- c(5,1,8,9)</p>
<p class="calibre1">&gt; union(x,y)</p>
<p class="calibre1">[1] 1 2 5 8 9</p>
<p class="calibre1">&gt; intersect(x,y)</p>
<p class="calibre1">[1] 1 5</p>
<p class="calibre1">&gt; setdiff(x,y)</p>
<p class="calibre1">[1] 2</p>
<p class="calibre1">&gt; setdiff(y,x)</p>
<p class="calibre1">[1] 8 9</p>
<p class="calibre1">&gt; setequal(x,y)</p>
<p class="calibre1">[1] FALSE</p>
<p class="calibre1">&gt; setequal(x,c(1,2,5))</p>
<p class="calibre1">[1] TRUE</p>
<p class="calibre1">&gt; 2 %in% x</p>
<p class="calibre1">[1] TRUE</p>
<p class="calibre1">&gt; 2 %in% y</p>
<p class="calibre1">[1] FALSE</p>
<p class="calibre1">&gt; choose(5,2)</p>
<p class="calibre1">[1] 10</p>
<p class="calibre1">Recall from Section 7.12 that you can write your own binary operations. </p>
<p class="calibre1">For instance, consider coding the symmetric difference between two sets—</p>
<p class="calibre1">that is, all the elements belonging to exactly one of the two operand sets. </p>
<p class="calibre1">Because the symmetric difference between sets x and y consists exactly of those elements in x but not y and vice versa, the code consists of easy calls to setdiff() and union(), as follows:</p>
<p class="calibre1">&gt; symdiff</p>
<p class="calibre1">function(a,b) {</p>
<p class="calibre1">sdfxy &lt;- setdiff(x,y)</p>
<p class="calibre1">sdfyx &lt;- setdiff(y,x)</p>
<p class="calibre1"><b class="calibre3">202</b></p>
<p class="calibre1">Chapter 8</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p229"/>return(union(sdfxy,sdfyx))</p>
<p class="calibre1">}</p>
<p class="calibre1">Let’s try it. </p>
<p class="calibre1">&gt; x</p>
<p class="calibre1">[1] 1 2 5</p>
<p class="calibre1">&gt; y</p>
<p class="calibre1">[1] 5 1 8 9</p>
<p class="calibre1">&gt; symdiff(x,y)</p>
<p class="calibre1">[1] 2 8 9</p>
<p class="calibre1">Here’s another example: a binary operand for determining whether one set u is a subset of another set v. A bit of thought shows that this property is equivalent to the intersection of u and v being equal to u. Hence we have another easily coded function:</p>
<p class="calibre1">&gt; "%subsetof%" &lt;- function(u,v) {</p>
<p class="calibre1">+</p>
<p class="calibre1">return(setequal(intersect(u,v),u))</p>
<p class="calibre1">+ }</p>
<p class="calibre1">&gt; c(3,8) %subsetof% 1:10</p>
<p class="calibre1">[1] TRUE</p>
<p class="calibre1">&gt; c(3,8) %subsetof% 5:10</p>
<p class="calibre1">[1] FALSE</p>
<p class="calibre1">The function combn() generates combinations. Let’s find the subsets of</p>
<p class="calibre1">{1,2,3} of size 2. </p>
<p class="calibre1">&gt; c32 &lt;- combn(1:3,2)</p>
<p class="calibre1">&gt; c32</p>
<p class="calibre1">[,1] [,2] [,3]</p>
<p class="calibre1">[1,]</p>
<p class="calibre1">1</p>
<p class="calibre1">1</p>
<p class="calibre1">2</p>
<p class="calibre1">[2,]</p>
<p class="calibre1">2</p>
<p class="calibre1">3</p>
<p class="calibre1">3</p>
<p class="calibre1">&gt; class(c32)</p>
<p class="calibre1">[1] "matrix" </p>
<p class="calibre1">The results are in the columns of the output. We see that the subsets of</p>
<p class="calibre1">{1,2,3} of size 2 are (1,2), (1,3), and (2,3). </p>
<p class="calibre1">The function also allows you to specify a function to be called by combn() on each combination. For example, we can find the sum of the numbers in each subset, like this:</p>
<p class="calibre1">&gt; combn(1:3,2,sum)</p>
<p class="calibre1">[1] 3 4 5</p>
<p class="calibre1">The first subset, {1,2}, has a sum of 2, and so on. </p>
<p class="calibre1">Doing Math and Simulations in R</p>
<p class="calibre1"><b class="calibre3">203</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p230"/><b class="calibre3">8.6 Simulation Programming in R</b></p>
<p class="calibre1">One of the most common uses of R is simulation. Let’s see what kinds of tools R has available for this application. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">8.6.1 Built-In Random Variate Generators</b></i></p>
<p class="calibre1">As mentioned, R has functions to generate variates from a number of different distributions. For example, rbinom() generates binomial or Bernoulli random variates.1</p>
<p class="calibre1">Let’s say we want to find the probability of getting at least four heads out of five tosses of a coin (easy to find analytically, but a handy example). </p>
<p class="calibre1">Here’s how we can do this:</p>
<p class="calibre1">&gt; x &lt;- rbinom(100000,5,0.5)</p>
<p class="calibre1">&gt; mean(x &gt;= 4)</p>
<p class="calibre1">[1] 0.18829</p>
<p class="calibre1">First, we generate 100,000 variates from a binomial distribution with five trials and a success probability of 0.5. We then determine which of them has a value 4 or 5, resulting in a Boolean vector of the same length as x. The TRUE</p>
<p class="calibre1">and FALSE values in that vector are treated as 1s and 0s by mean(), giving us our estimated probability (since the average of a bunch of 1s and 0s is the proportion of 1s). </p>
<p class="calibre1">Other functions include rnorm() for the normal distribution, rexp() for the exponential, runif() for the uniform, rgamma() for the gamma, rpois() for the Poisson, and so on. </p>
<p class="calibre1">Here is another simple example, which finds  <i class="calibre4">E</i>[max( <i class="calibre4">X, Y </i>)], the expected value of the maximum of independent N(0,1) random variables X and Y:</p>
<p class="calibre1">sum &lt;- 0</p>
<p class="calibre1">nreps &lt;- 100000</p>
<p class="calibre1">for (i in 1:nreps) {</p>
<p class="calibre1">xy &lt;- rnorm(2) # generate 2 N(0,1)s</p>
<p class="calibre1">sum &lt;- sum + max(xy)</p>
<p class="calibre1">}</p>
<p class="calibre1">print(sum/nreps)</p>
<p class="calibre1">We generated 100,000 pairs, found the maximum for each, and aver-</p>
<p class="calibre1">aged those maxima to obtain our estimated expected value. </p>
<p class="calibre1">The preceding code, with an explicit loop, may be clearer, but as before, if we are willing to use some more memory, we can do this more compactly. </p>
<p class="calibre1">1 A sequence of independent 0- and 1- valued random variables with the same probability of 1</p>
<p class="calibre1">for each is called  <i class="calibre4">Bernoulli</i>. </p>
<p class="calibre1"><b class="calibre3">204</b></p>
<p class="calibre1">Chapter 8</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p231"/>&gt; emax</p>
<p class="calibre1">function(nreps) {</p>
<p class="calibre1">x &lt;- rnorm(2*nreps)</p>
<p class="calibre1">maxxy &lt;- pmax(x[1:nreps],x[(nreps+1):(2*nreps)])</p>
<p class="calibre1">return(mean(maxxy))</p>
<p class="calibre1">}</p>
<p class="calibre1">Here, we generated double nreps values. The first nreps value simulates X, and the remaining nreps value represents Y. The pmax() call then computes the pair-wise maxima that we need. Again, note the contrast here between max() and pmax(), the latter producing pair-wise maxima. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">8.6.2 Obtaining the Same Random Stream in Repeated Runs</b></i></p>
<p class="calibre1">According to the R documentation, all random-number generators use</p>
<p class="calibre1">32-bit integers for seed values. Thus, other than round-off error, the same initial seed should generate the same stream of numbers. </p>
<p class="calibre1">By default, R will generate a different random number stream from run to run of a program. If you want the same stream each time—important in debugging, for instance—call set.seed(), like this:</p>
<p class="calibre1">&gt; set.seed(8888) # or your favorite number as an argument</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">8.6.3 Extended Example: A Combinatorial Simulation</b></i></p>
<p class="calibre1">Consider the following probability problem:</p>
<p class="calibre1">Three committees, of sizes 3, 4 and 5, are chosen from 20 people. </p>
<p class="calibre1">What is the probability that persons A and B are chosen for the</p>
<p class="calibre1">same committee? </p>
<p class="calibre1">This problem is not hard to solve analytically, but we may wish to check our solution using simulation, and in any case, writing the code will demonstrate how R’s set operations can come in handy in combinatorial settings. </p>
<p class="calibre1">Here is the code:</p>
<p class="calibre1">1</p>
<p class="calibre1">sim &lt;- function(nreps) {</p>
<p class="calibre1">2</p>
<p class="calibre1">commdata &lt;- list() # will store all our info about the 3 committees 3</p>
<p class="calibre1">commdata$countabsamecomm &lt;- 0</p>
<p class="calibre1">4</p>
<p class="calibre1">for (rep in 1:nreps) {</p>
<p class="calibre1">5</p>
<p class="calibre1">commdata$whosleft &lt;- 1:20 # who's left to choose from</p>
<p class="calibre1">6</p>
<p class="calibre1">commdata$numabchosen &lt;- 0 # number among A, B chosen so far</p>
<p class="calibre1">7</p>
<p class="calibre1"># choose committee 1, and check for A,B serving together</p>
<p class="calibre1">8</p>
<p class="calibre1">commdata &lt;- choosecomm(commdata,5)</p>
<p class="calibre1">Doing Math and Simulations in R</p>
<p class="calibre1"><b class="calibre3">205</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p232"/>9</p>
<p class="calibre1"># if A or B already chosen, no need to look at the other comms. </p>
<p class="calibre1">10</p>
<p class="calibre1">if (commdata$numabchosen &gt; 0) next</p>
<p class="calibre1">11</p>
<p class="calibre1"># choose committee 2 and check</p>
<p class="calibre1">12</p>
<p class="calibre1">commdata &lt;- choosecomm(commdata,4)</p>
<p class="calibre1">13</p>
<p class="calibre1">if (commdata$numabchosen &gt; 0) next</p>
<p class="calibre1">14</p>
<p class="calibre1"># choose committee 3 and check</p>
<p class="calibre1">15</p>
<p class="calibre1">commdata &lt;- choosecomm(commdata,3)</p>
<p class="calibre1">16</p>
<p class="calibre1">}</p>
<p class="calibre1">17</p>
<p class="calibre1">print(commdata$countabsamecomm/nreps)</p>
<p class="calibre1">18</p>
<p class="calibre1">}</p>
<p class="calibre1">19</p>
<p class="calibre1">20</p>
<p class="calibre1">choosecomm &lt;- function(comdat,comsize) {</p>
<p class="calibre1">21</p>
<p class="calibre1"># choose committee</p>
<p class="calibre1">22</p>
<p class="calibre1">committee &lt;- sample(comdat$whosleft,comsize)</p>
<p class="calibre1">23</p>
<p class="calibre1"># count how many of A and B were chosen</p>
<p class="calibre1">24</p>
<p class="calibre1">comdat$numabchosen &lt;- length(intersect(1:2,committee))</p>
<p class="calibre1">25</p>
<p class="calibre1">if (comdat$numabchosen == 2)</p>
<p class="calibre1">26</p>
<p class="calibre1">comdat$countabsamecomm &lt;- comdat$countabsamecomm + 1</p>
<p class="calibre1">27</p>
<p class="calibre1"># delete chosen committee from the set of people we now have to choose from 28</p>
<p class="calibre1">comdat$whosleft &lt;- setdiff(comdat$whosleft,committee)</p>
<p class="calibre1">29</p>
<p class="calibre1">return(comdat)</p>
<p class="calibre1">30</p>
<p class="calibre1">}</p>
<p class="calibre1">We number the potential committee members from 1 to 20, with per-</p>
<p class="calibre1">sons A and B having ID 1 and 2. Recalling that R lists are often used to store several related variables in one basket, we se up a list comdat. Its components include the following:</p>
<p class="calibre1">•</p>
<p class="calibre1">comdat$whosleft: We simulate the random selection of the committees by randomly choosing from this vector. Each time we choose a committee, we remove the committee members’ IDs. It is initialized to 1:20, indicating that no one has been selected yet. </p>
<p class="calibre1">•</p>
<p class="calibre1">comdat$numabchosen: This is a count of how many among the people A and B have been chosen so far. If we choose a committee and find this to be positive, we can skip choosing the remaining committees for the following reason: If this number is 2, we know definitely that A and B are on the same committee; if it is 1, we know definitely that A and B are  <i class="calibre4">not</i> on the same committee. </p>
<p class="calibre1">•</p>
<p class="calibre1">comdat$countabsamecomm: Here, we store a count of the number of times A and B are on the same committee. </p>
<p class="calibre1">Since committee selection involves subsets, it’s not surprising that a couple of R’s set operations—intersect() and setdiff()—come in handy here. </p>
<p class="calibre1">Note, too, the use of R’s next statement, which tells R to skip the rest of this iteration of the loop. </p>
<p class="calibre1"><b class="calibre3">206</b></p>
<p class="calibre1">Chapter 8</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p233"/><img src="index-233_1.png" alt="Image 21" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">9</b></p>
<p class="calibre1"><b class="calibre3">OBJECT-ORIENTED PROGRAMMING</b></p>
<p class="calibre1">Many programmers believe that object-</p>
<p class="calibre1">oriented programming (OOP) makes for</p>
<p class="calibre1">clearer, more reusable code. Though very</p>
<p class="calibre1">different from the familiar OOP languages like</p>
<p class="calibre1">C++, Java, and Python, R is very much OOP in outlook. </p>
<p class="calibre1">The following themes are key to R:</p>
<p class="calibre1">•</p>
<p class="calibre1">Everything you touch in R—ranging from numbers to character strings to matrices—is an object. </p>
<p class="calibre1">•</p>
<p class="calibre1">R promotes  <i class="calibre4">encapsulation</i>, which is packaging separate but related data items into one class instance. Encapsulation helps you keep track of related variables, enhancing clarity. </p>
<p class="calibre1">•</p>
<p class="calibre1">R classes are  <i class="calibre4">polymorphic</i>, which means that the same function call leads to different operations for objects of different classes. For instance, a call to print() on an object of a certain class triggers a call to a print function tailored to that class. Polymorphism promotes reusability. </p>
<p class="calibre1">•</p>
<p class="calibre1">R allows  <i class="calibre4">inheritance</i>, which allows extending a given class to a more specialized class. </p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p234"/>This chapter covers OOP in R. We’ll discuss programming in the two types of classes, S3 and S4, and then present a few useful OOP-related R</p>
<p class="calibre1">utilities. </p>
<p class="calibre1"><b class="calibre3">9.1 S3 Classes</b></p>
<p class="calibre1">The original R structure for classes, known as S3, is still the dominant class paradigm in R use today. Indeed, most of R’s own built-in classes are of the S3 type. </p>
<p class="calibre1">An S3 class consists of a list, with a class name attribute and  <i class="calibre4">dispatch</i> capability added. The latter enables the use of generic functions, as we saw in Chapter 1. S4 classes were developed later, with goal of adding  <i class="calibre4">safety</i>, meaning that you cannot accidentally access a class component that is not already in existence. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">9.1.1 S3 Generic Functions</b></i></p>
<p class="calibre1">As mentioned, R is polymorphic, in the sense that the same function can lead to different operations for different classes. You can apply plot(), for example, to many different types of objects, getting a different type of plot for each. The same is true for print(), summary(), and many other functions. </p>
<p class="calibre1">In this manner, we get a uniform interface to different classes. For example, if you are writing code that includes plot operations, polymorphism may allow you to write your program without worrying about the various types of objects that might be plotted. </p>
<p class="calibre1">In addition, polymorphism certainly makes things easier to remem-</p>
<p class="calibre1">ber for the user and makes it fun and convenient to explore new library functions and associated classes. If a function is new to you, just try running plot() on the function’s output; it will likely work. From a programmer’s viewpoint, polymorphism allows writing fairly general code, without worrying about what type of object is being manipulated, because the underlying class mechanisms take care of that. </p>
<p class="calibre1">The functions that work with polymorphism, such as plot() and print(), are known as  <i class="calibre4">generic functions</i>. When a generic function is called, R will then dispatch the call to the proper class method, meaning that it will reroute the call to a function defined for the object’s class. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">9.1.2 Example: OOP in the lm() Linear Model Function</b></i></p>
<p class="calibre1">As an example, let’s look at a simple regression analysis run via R’s lm() function. First, let’s see what lm() does:</p>
<p class="calibre1">&gt; ?lm</p>
<p class="calibre1">The output of this help query will tell you, among other things, that this function returns an object of class "lm". </p>
<p class="calibre1"><b class="calibre3">208</b></p>
<p class="calibre1">Chapter 9</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p235"/>Let’s try creating an instance of this object and then printing it:</p>
<p class="calibre1">&gt; x &lt;- c(1,2,3)</p>
<p class="calibre1">&gt; y &lt;- c(1,3,8)</p>
<p class="calibre1">&gt; lmout &lt;- lm(y ~ x)</p>
<p class="calibre1">&gt; class(lmout)</p>
<p class="calibre1">[1] "lm" </p>
<p class="calibre1">&gt; lmout</p>
<p class="calibre1">Call:</p>
<p class="calibre1">lm(formula = y ~ x)</p>
<p class="calibre1">Coefficients:</p>
<p class="calibre1">(Intercept)</p>
<p class="calibre1">x</p>
<p class="calibre1">-3.0</p>
<p class="calibre1">3.5</p>
<p class="calibre1">Here, we printed out the object lmout. (Remember that by simply typing the name of an object in interactive mode, the object is printed.) The R interpreter then saw that lmout was an object of class "lm" and thus called print.lm(), a special print method for the "lm" class. In R terminology, the call to the generic function print() was dispatched to the method print.lm() associated with the class "lm". </p>
<p class="calibre1">Let’s take a look at the generic function and the class method in</p>
<p class="calibre1">this case:</p>
<p class="calibre1">&gt; print</p>
<p class="calibre1">function(x, ...) UseMethod("print")</p>
<p class="calibre1">&lt;environment: namespace:base&gt; </p>
<p class="calibre1">&gt; print.lm</p>
<p class="calibre1">function (x, digits = max(3, getOption("digits") - 3), ...)</p>
<p class="calibre1">{</p>
<p class="calibre1">cat("\nCall:\n", deparse(x$call), "\n\n", sep = "") if (length(coef(x))) {</p>
<p class="calibre1">cat("Coefficients:\n")</p>
<p class="calibre1">print.default(format(coef(x), digits = digits), print.gap = 2, </p>
<p class="calibre1">quote = FALSE)</p>
<p class="calibre1">}</p>
<p class="calibre1">else cat("No coefficients\n")</p>
<p class="calibre1">cat("\n")</p>
<p class="calibre1">invisible(x)</p>
<p class="calibre1">}</p>
<p class="calibre1">&lt;environment: namespace:stats&gt; </p>
<p class="calibre1">You may be surprised to see that print() consists solely of a call to UseMethod(). But this is actually the dispatcher function, so in view of print()’s role as a generic function, you should not be surprised after all. </p>
<p class="calibre1">Object-Oriented Programming</p>
<p class="calibre1"><b class="calibre3">209</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p236"/>Don’t worry about the details of print.lm(). The main point is that the printing depends on context, with a special print function called for the</p>
<p class="calibre1">"lm" class. Now let’s see what happens when we print this object with its class attribute removed:</p>
<p class="calibre1">&gt; unclass(lmout)</p>
<p class="calibre1">$coefficients</p>
<p class="calibre1">(Intercept)</p>
<p class="calibre1">x</p>
<p class="calibre1">-3.0</p>
<p class="calibre1">3.5</p>
<p class="calibre1">$residuals</p>
<p class="calibre1">1</p>
<p class="calibre1">2</p>
<p class="calibre1">3</p>
<p class="calibre1">0.5 -1.0 0.5</p>
<p class="calibre1">$effects</p>
<p class="calibre1">(Intercept)</p>
<p class="calibre1">x</p>
<p class="calibre1">-6.928203</p>
<p class="calibre1">-4.949747</p>
<p class="calibre1">1.224745</p>
<p class="calibre1">$rank</p>
<p class="calibre1">[1] 2</p>
<p class="calibre1">... </p>
<p class="calibre1">I’ve shown only the first few lines here—there’s a lot more. (Try running this on your own!) But you can see that the author of lm() decided to make print.lm() much more concise, limiting it to printing a few key quantities. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">9.1.3 Finding the Implementations of Generic Methods</b></i></p>
<p class="calibre1">You can find all the implementations of a given generic method by calling methods(), like this:</p>
<p class="calibre1">&gt; methods(print)</p>
<p class="calibre1">[1] print.acf*</p>
<p class="calibre1">[2] print.anova</p>
<p class="calibre1">[3] print.aov*</p>
<p class="calibre1">[4] print.aovlist*</p>
<p class="calibre1">[5] print.ar*</p>
<p class="calibre1">[6] print.Arima*</p>
<p class="calibre1">[7] print.arima0*</p>
<p class="calibre1">[8] print.AsIs</p>
<p class="calibre1">[9] print.aspell*</p>
<p class="calibre1">[10] print.Bibtex*</p>
<p class="calibre1">[11] print.browseVignettes*</p>
<p class="calibre1">[12] print.by</p>
<p class="calibre1">[13] print.check_code_usage_in_package*</p>
<p class="calibre1">[14] print.check_demo_index*</p>
<p class="calibre1">[15] print.checkDocFiles*</p>
<p class="calibre1"><b class="calibre3">210</b></p>
<p class="calibre1">Chapter 9</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p237"/>[16] print.checkDocStyle*</p>
<p class="calibre1">[17] print.check_dotInternal*</p>
<p class="calibre1">[18] print.checkFF*</p>
<p class="calibre1">[19] print.check_make_vars*</p>
<p class="calibre1">[20] print.check_package_code_syntax*</p>
<p class="calibre1">... </p>
<p class="calibre1">Asterisks denote  <i class="calibre4">nonvisible </i> functions, meaning ones that are not in the default namespaces. You can find these functions via getAnywhere() and then access them by using a namespace qualifier. An example is print.aspell(). </p>
<p class="calibre1">The aspell() function itself does a spellcheck on the file specified in its argument. For example, suppose the file  <i class="calibre4">wrds </i> consists of this line: Which word is mispelled? </p>
<p class="calibre1">In this case, this function will catch the misspelled word, as follows: aspell("wrds")</p>
<p class="calibre1">mispelled</p>
<p class="calibre1">wrds:1:15</p>
<p class="calibre1">The output says that there is the indicated spelling error in line 1, character 15 of the input file. But what concerns us here is the mechanism by which that output was printed. </p>
<p class="calibre1">The aspell() function returns an object of class "aspell", which does have its own generic print function, print.aspell(). In fact, that function was invoked in our example, after the call to aspell(), and the return value was printed out. At that time, R called UseMethod() on the object of class "aspell". </p>
<p class="calibre1">But if we call that print method directly, R won’t recognize it:</p>
<p class="calibre1">&gt; aspout &lt;- aspell("wrds")</p>
<p class="calibre1">&gt; print.aspell(aspout)</p>
<p class="calibre1">Error: could not find function "print.aspell" </p>
<p class="calibre1">However, we can find it by calling getAnywhere():</p>
<p class="calibre1">&gt; getAnywhere(print.aspell)</p>
<p class="calibre1">A single object matching 'print.aspell' was found</p>
<p class="calibre1">It was found in the following places</p>
<p class="calibre1">registered S3 method for print from namespace utils</p>
<p class="calibre1">namespace:utils</p>
<p class="calibre1">with value</p>
<p class="calibre1">function (x, sort = TRUE, verbose = FALSE, indent = 2L, ...)</p>
<p class="calibre1">{</p>
<p class="calibre1">if (!(nr &lt;- nrow(x)))</p>
<p class="calibre1">... </p>
<p class="calibre1">Object-Oriented Programming</p>
<p class="calibre1"><b class="calibre3">211</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p238"/>So, the function is in the utils namespace, and we can execute it by adding such a qualifier:</p>
<p class="calibre1">&gt; utils:::print.aspell(aspout)</p>
<p class="calibre1">mispelled</p>
<p class="calibre1">wrds:1:15</p>
<p class="calibre1">You can see all the generic methods this way:</p>
<p class="calibre1">&gt; methods(class="default")</p>
<p class="calibre1">... </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">9.1.4 Writing S3 Classes</b></i></p>
<p class="calibre1">S3 classes have a rather cobbled-together structure. A class instance is created by forming a list, with the components of the list being the member variables of the class. (Readers who know Perl may recognize this ad hoc nature in Perl’s own OOP system.) The "class" attribute is set by hand by using the attr() or class() function, and then various implementations of generic functions are defined. We can see this in the case of lm() by inspecting the function:</p>
<p class="calibre1">&gt; lm</p>
<p class="calibre1">... </p>
<p class="calibre1">z &lt;- list(coefficients = if (is.matrix(y))</p>
<p class="calibre1">matrix(,0,3) else numeric(0L), residuals = y, </p>
<p class="calibre1">fitted.values = 0 * y, weights = w, rank = 0L, </p>
<p class="calibre1">df.residual = if (is.matrix(y)) nrow(y) else length(y))</p>
<p class="calibre1">}</p>
<p class="calibre1">... </p>
<p class="calibre1">class(z) &lt;- c(if(is.matrix(y)) "mlm", "lm")</p>
<p class="calibre1">... </p>
<p class="calibre1">Again, don’t mind the details; the basic process is there. A list was created and assigned to z, which will serve as the framework for the "lm" class instance (and which will eventually be the value returned by the function). </p>
<p class="calibre1">Some components of that list, such as residuals, were already assigned when the list was created. In addition, the class attribute was set to "lm" (and possibly to "mlm", as will be explained in the next section). </p>
<p class="calibre1">As an example of how to write an S3 class, let’s switch to something simpler. Continuing our employee example from Section 4.1, we could write this:</p>
<p class="calibre1">&gt; j &lt;- list(name="Joe", salary=55000, union=T)</p>
<p class="calibre1">&gt; class(j) &lt;- "employee" </p>
<p class="calibre1">&gt; attributes(j) # let's check</p>
<p class="calibre1"><b class="calibre3">212</b></p>
<p class="calibre1">Chapter 9</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p239"/>$names</p>
<p class="calibre1">[1] "name" "salary" "union" </p>
<p class="calibre1">$class</p>
<p class="calibre1">[1] "employee" </p>
<p class="calibre1">Before we write a print method for this class, let’s see what happens when we call the default print():</p>
<p class="calibre1">&gt; j</p>
<p class="calibre1">$name</p>
<p class="calibre1">[1] "Joe" </p>
<p class="calibre1">$salary</p>
<p class="calibre1">[1] 55000</p>
<p class="calibre1">$union</p>
<p class="calibre1">[1] TRUE</p>
<p class="calibre1">attr(,"class")</p>
<p class="calibre1">[1] "employee" </p>
<p class="calibre1">Essentially, j was treated as a list for printing purposes. </p>
<p class="calibre1">Now let’s write our own print method:</p>
<p class="calibre1">print.employee &lt;- function(wrkr) {</p>
<p class="calibre1">cat(wrkr$name,"\n")</p>
<p class="calibre1">cat("salary",wrkr$salary,"\n")</p>
<p class="calibre1">cat("union member",wrkr$union,"\n")</p>
<p class="calibre1">}</p>
<p class="calibre1">So, any call to print() on an object of class "employee" should now be referred to print.employee(). We can check that formally:</p>
<p class="calibre1">&gt; methods(,"employee")</p>
<p class="calibre1">[1] print.employee</p>
<p class="calibre1">Or, of course, we can simply try it out:</p>
<p class="calibre1">&gt; j</p>
<p class="calibre1">Joe</p>
<p class="calibre1">salary 55000</p>
<p class="calibre1">union member TRUE</p>
<p class="calibre1">Object-Oriented Programming</p>
<p class="calibre1"><b class="calibre3">213</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p240"/> <i class="calibre4"><b class="calibre3">9.1.5 Using Inheritance</b></i></p>
<p class="calibre1">The idea of inheritance is to form new classes as specialized versions of old ones. In our previous employee example, for instance, we could form a new class devoted to hourly employees, "hrlyemployee", as a subclass of "employee", as follows:</p>
<p class="calibre1">k &lt;- list(name="Kate", salary= 68000, union=F, hrsthismonth= 2) class(k) &lt;- c("hrlyemployee","employee")</p>
<p class="calibre1">Our new class has one extra variable: hrsthismonth. The name of the new class consists of two character strings, representing the new class and the old class. Our new class inherits the methods of the old one. For instance, print.employee() still works on the new class:</p>
<p class="calibre1">&gt; k</p>
<p class="calibre1">Kate</p>
<p class="calibre1">salary 68000</p>
<p class="calibre1">union member FALSE</p>
<p class="calibre1">Given the goals of inheritance, that is not surprising. However, it’s important to understand exactly what transpired here. </p>
<p class="calibre1">Once again, simply typing k resulted in the call print(k). In turn, that caused UseMethod() to search for a print method on the first of k’s two class names, "hrlyemployee". That search failed, so UseMethod() tried the other class name, "employee", and found print.employee(). It executed the latter. </p>
<p class="calibre1">Recall that in inspecting the code for "lm", you saw this line: class(z) &lt;- c(if(is.matrix(y)) "mlm", "lm")</p>
<p class="calibre1">You can now see that "mlm" is a subclass of "lm" for vector-valued response variables. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">9.1.6 Extended Example: A Class for Storing Upper-Triangular Matrices</b></i></p>
<p class="calibre1">Now it’s time for a more involved example, in which we will write an R class</p>
<p class="calibre1">"ut" for upper-triangular matrices. These are square matrices whose elements below the diagonal are zeros, such as shown in Equation 9.1. </p>
<p class="calibre1">⎛</p>
<p class="calibre1">⎞</p>
<p class="calibre1">1 5 12</p>
<p class="calibre1">⎝0 6 9 ⎠</p>
<p class="calibre1">(9.1)</p>
<p class="calibre1">0 0 2</p>
<p class="calibre1">Our motivation here is to save storage space (though at the expense of a little extra access time) by storing only the nonzero portion of the matrix. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">The R class "dist" also uses such storage, though in a more focused context and without the class functions we have here. </i></p>
<p class="calibre1"><b class="calibre3">214</b></p>
<p class="calibre1">Chapter 9</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p241"/>The component mat of this class will store the matrix. As mentioned, to save on storage space, only the diagonal and above-diagonal elements will be stored, in column-major order. Storage for the matrix (9.1), for instance, consists of the vector (1,5,6,12,9,2), and the component mat has that value. </p>
<p class="calibre1">We will include a component ix in this class, to show where in mat the various columns begin. For the preceding case, ix is c(1,2,4), meaning that column 1 begins at mat[1], column 2 begins at mat[2], and column 3 begins at mat[4]. This allows for handy access to individual elements or columns of the matrix. </p>
<p class="calibre1">The following is the code for our class. </p>
<p class="calibre1">1</p>
<p class="calibre1"># class "ut", compact storage of upper-triangular matrices 2</p>
<p class="calibre1">3</p>
<p class="calibre1"># utility function, returns 1+...+i</p>
<p class="calibre1">4</p>
<p class="calibre1">sum1toi &lt;- function(i) return(i*(i+1)/2)</p>
<p class="calibre1">5</p>
<p class="calibre1">6</p>
<p class="calibre1"># create an object of class "ut" from the full matrix inmat (0s included) 7</p>
<p class="calibre1">ut &lt;- function(inmat) {</p>
<p class="calibre1">8</p>
<p class="calibre1">n &lt;- nrow(inmat)</p>
<p class="calibre1">9</p>
<p class="calibre1">rtrn &lt;- list() # start to build the object</p>
<p class="calibre1">10</p>
<p class="calibre1">class(rtrn) &lt;- "ut" </p>
<p class="calibre1">11</p>
<p class="calibre1">rtrn$mat &lt;- vector(length=sum1toi(n))</p>
<p class="calibre1">12</p>
<p class="calibre1">rtrn$ix &lt;- sum1toi(0:(n-1)) + 1</p>
<p class="calibre1">13</p>
<p class="calibre1">for (i in 1:n) {</p>
<p class="calibre1">14</p>
<p class="calibre1"># store column i</p>
<p class="calibre1">15</p>
<p class="calibre1">ixi &lt;- rtrn$ix[i]</p>
<p class="calibre1">16</p>
<p class="calibre1">rtrn$mat[ixi:(ixi+i-1)] &lt;- inmat[1:i,i]</p>
<p class="calibre1">17</p>
<p class="calibre1">}</p>
<p class="calibre1">18</p>
<p class="calibre1">return(rtrn)</p>
<p class="calibre1">19</p>
<p class="calibre1">}</p>
<p class="calibre1">20</p>
<p class="calibre1">21</p>
<p class="calibre1"># uncompress utmat to a full matrix</p>
<p class="calibre1">22</p>
<p class="calibre1">expandut &lt;- function(utmat) {</p>
<p class="calibre1">23</p>
<p class="calibre1">n &lt;- length(utmat$ix) # numbers of rows and cols of matrix</p>
<p class="calibre1">24</p>
<p class="calibre1">fullmat &lt;- matrix(nrow=n,ncol=n)</p>
<p class="calibre1">25</p>
<p class="calibre1">for (j in 1:n) {</p>
<p class="calibre1">26</p>
<p class="calibre1"># fill jth column</p>
<p class="calibre1">27</p>
<p class="calibre1">start &lt;- utmat$ix[j]</p>
<p class="calibre1">28</p>
<p class="calibre1">fin &lt;- start + j - 1</p>
<p class="calibre1">29</p>
<p class="calibre1">abovediagj &lt;- utmat$mat[start:fin] # above-diag part of col j</p>
<p class="calibre1">30</p>
<p class="calibre1">fullmat[,j] &lt;- c(abovediagj,rep(0,n-j))</p>
<p class="calibre1">31</p>
<p class="calibre1">}</p>
<p class="calibre1">32</p>
<p class="calibre1">return(fullmat)</p>
<p class="calibre1">33</p>
<p class="calibre1">}</p>
<p class="calibre1">34</p>
<p class="calibre1">35</p>
<p class="calibre1"># print matrix</p>
<p class="calibre1">36</p>
<p class="calibre1">print.ut &lt;- function(utmat)</p>
<p class="calibre1">37</p>
<p class="calibre1">print(expandut(utmat))</p>
<p class="calibre1">Object-Oriented Programming</p>
<p class="calibre1"><b class="calibre3">215</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p242"/>38</p>
<p class="calibre1">39</p>
<p class="calibre1"># multiply one ut matrix by another, returning another ut instance; 40</p>
<p class="calibre1"># implement as a binary operation</p>
<p class="calibre1">41</p>
<p class="calibre1">"%mut%" &lt;- function(utmat1,utmat2) {</p>
<p class="calibre1">42</p>
<p class="calibre1">n &lt;- length(utmat1$ix) # numbers of rows and cols of matrix</p>
<p class="calibre1">43</p>
<p class="calibre1">utprod &lt;- ut(matrix(0,nrow=n,ncol=n))</p>
<p class="calibre1">44</p>
<p class="calibre1">for (i in 1:n) { # compute col i of product</p>
<p class="calibre1">45</p>
<p class="calibre1"># let a[j] and bj denote columns j of utmat1 and utmat2, respectively, 46</p>
<p class="calibre1"># so that, e.g. b2[1] means element 1 of column 2 of utmat2</p>
<p class="calibre1">47</p>
<p class="calibre1"># then column i of product is equal to</p>
<p class="calibre1">48</p>
<p class="calibre1">#</p>
<p class="calibre1">bi[1]*a[1] + ... + bi[i]*a[i]</p>
<p class="calibre1">49</p>
<p class="calibre1"># find index of start of column i in utmat2</p>
<p class="calibre1">50</p>
<p class="calibre1">startbi &lt;- utmat2$ix[i]</p>
<p class="calibre1">51</p>
<p class="calibre1"># initialize vector that will become bi[1]*a[1] + ... + bi[i]*a[i]</p>
<p class="calibre1">52</p>
<p class="calibre1">prodcoli &lt;- rep(0,i)</p>
<p class="calibre1">53</p>
<p class="calibre1">for (j in 1:i) { # find bi[j]*a[j], add to prodcoli</p>
<p class="calibre1">54</p>
<p class="calibre1">startaj &lt;- utmat1$ix[j]</p>
<p class="calibre1">55</p>
<p class="calibre1">bielement &lt;- utmat2$mat[startbi+j-1]</p>
<p class="calibre1">56</p>
<p class="calibre1">prodcoli[1:j] &lt;- prodcoli[1:j] +</p>
<p class="calibre1">57</p>
<p class="calibre1">bielement * utmat1$mat[startaj:(startaj+j-1)]</p>
<p class="calibre1">58</p>
<p class="calibre1">}</p>
<p class="calibre1">59</p>
<p class="calibre1"># now need to tack on the lower 0s</p>
<p class="calibre1">60</p>
<p class="calibre1">startprodcoli &lt;- sum1toi(i-1)+1</p>
<p class="calibre1">61</p>
<p class="calibre1">utprod$mat[startbi:(startbi+i-1)] &lt;- prodcoli</p>
<p class="calibre1">62</p>
<p class="calibre1">}</p>
<p class="calibre1">63</p>
<p class="calibre1">return(utprod)</p>
<p class="calibre1">64</p>
<p class="calibre1">}</p>
<p class="calibre1">Let’s test it. </p>
<p class="calibre1">&gt; test</p>
<p class="calibre1">function() {</p>
<p class="calibre1">utm1 &lt;- ut(rbind(1:2,c(0,2)))</p>
<p class="calibre1">utm2 &lt;- ut(rbind(3:2,c(0,1)))</p>
<p class="calibre1">utp &lt;- utm1 %mut% utm2</p>
<p class="calibre1">print(utm1)</p>
<p class="calibre1">print(utm2)</p>
<p class="calibre1">print(utp)</p>
<p class="calibre1">utm1 &lt;- ut(rbind(1:3,0:2,c(0,0,5)))</p>
<p class="calibre1">utm2 &lt;- ut(rbind(4:2,0:2,c(0,0,1)))</p>
<p class="calibre1">utp &lt;- utm1 %mut% utm2</p>
<p class="calibre1">print(utm1)</p>
<p class="calibre1">print(utm2)</p>
<p class="calibre1">print(utp)</p>
<p class="calibre1">}</p>
<p class="calibre1"><b class="calibre3">216</b></p>
<p class="calibre1">Chapter 9</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p243"/>&gt; test()</p>
<p class="calibre1">[,1] [,2]</p>
<p class="calibre1">[1,] 1 2</p>
<p class="calibre1">[2,] 0 2</p>
<p class="calibre1">[,1] [,2]</p>
<p class="calibre1">[1,] 3 2</p>
<p class="calibre1">[2,] 0 1</p>
<p class="calibre1">[,1] [,2]</p>
<p class="calibre1">[1,] 3 4</p>
<p class="calibre1">[2,] 0 2</p>
<p class="calibre1">[,1] [,2] [,3]</p>
<p class="calibre1">[1,] 1 2 3</p>
<p class="calibre1">[2,] 0 1 2</p>
<p class="calibre1">[3,] 0 0 5</p>
<p class="calibre1">[,1] [,2] [,3]</p>
<p class="calibre1">[1,] 4 3 2</p>
<p class="calibre1">[2,] 0 1 2</p>
<p class="calibre1">[3,] 0 0 1</p>
<p class="calibre1">[,1] [,2] [,3]</p>
<p class="calibre1">[1,] 4 5 9</p>
<p class="calibre1">[2,] 0 1 4</p>
<p class="calibre1">[3,] 0 0 5</p>
<p class="calibre1">Throughout the code, we take into account the fact that the matrices involved have a lot of zeros. For example, we avoid multiplying by zeros simply by not adding terms to sums when the terms include a 0 factor. </p>
<p class="calibre1">The ut() function is fairly straightforward. This function is a  <i class="calibre4">constructor</i>, which is a function whose job it is to create an instance of the given class, eventually returning that instance. So in line 9, we create a list that will serve as the body of the class object, naming it rtrn as a reminder that this will be the class instance to be constructed and returned. </p>
<p class="calibre1">As noted earlier, the main member variables of our class will be mat and idx, implemented as components of the list. Memory for these two components is allocated in lines 11 and 12. </p>
<p class="calibre1">The loop that follows then fills in rtrn$mat column by column and</p>
<p class="calibre1">assigns rtrn$idx element by element. A slicker way to do this for loop would be to use the rather obscure row() and col() functions. The row() function takes a matrix input and returns a new matrix of the same size, but with each element replaced by its row number. Here’s an example:</p>
<p class="calibre1">&gt; m</p>
<p class="calibre1">[,1] [,2]</p>
<p class="calibre1">[1,] 1 4</p>
<p class="calibre1">[2,] 2 5</p>
<p class="calibre1">[3,] 3 6</p>
<p class="calibre1">Object-Oriented Programming</p>
<p class="calibre1"><b class="calibre3">217</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p244"/>&gt; row(m)</p>
<p class="calibre1">[,1] [,2]</p>
<p class="calibre1">[1,] 1 1</p>
<p class="calibre1">[2,] 2 2</p>
<p class="calibre1">[3,] 3 3</p>
<p class="calibre1">The col() function works similarly. </p>
<p class="calibre1">Using this idea, we could replace the for loop in ut() with a one-liner: rtrn$mat &lt;- inmat[row(inmat) &lt;= col(inmat)]</p>
<p class="calibre1">Whenever possible, we should exploit vectorization. Take a look at</p>
<p class="calibre1">line 12, for example:</p>
<p class="calibre1">rtrn$ix &lt;- sum1toi(0:(n-1)) + 1</p>
<p class="calibre1">Since sum1toi() (which we defined on line 4) is based only on the vectorized functions "*"() and "+"(), sum1toi() itself is also vectorized. This allows us to apply sum1toi() to a vector above. Note that we used recycling as well. </p>
<p class="calibre1">We want our "ut" class to include some methods, not just variables. To this end, we have included three methods:</p>
<p class="calibre1">•</p>
<p class="calibre1">The expandut() function converts from a compressed matrix to an ordinary one. In expandut(), the key lines are 27 and 28, where we use rtrn$ix to determine where in utmat$mat the  <i class="calibre4">j</i> th column of our matrix is stored. </p>
<p class="calibre1">That data is then copied to the  <i class="calibre4">j</i> th column of fullmat in line 30. Note the use of rep() to generate the zeros in the lower portion of this column. </p>
<p class="calibre1">•</p>
<p class="calibre1">The print.ut() function is for printing. This function is quick and easy, using expandut(). Recall that any call to print() on an object of type "ut" </p>
<p class="calibre1">will be dispatched to print.ut(), as in our test cases earlier. </p>
<p class="calibre1">•</p>
<p class="calibre1">The "%mut%"() function is for multiplying two compressed matrices (without uncompressing them). This function starts in line 39. Since this is a binary operation, we take advantage of the fact that R accommodates user-defined binary operations, as described in Section 7.12, and implement our matrix-multiply function as %mut%. </p>
<p class="calibre1">Let’s look at the details of the "%mut%"() function. First, in line 43, we allocate space for the product matrix. Note the use of recycling in an unusual context. The first argument of matrix() is required to be a vector of a length compatible with the number of specified rows and columns, so the 0 we provide is recycled to a vector of length  <i class="calibre4">n</i> 2. Of course, rep() could be used instead, but exploiting recycling makes for a bit shorter, more elegant code. </p>
<p class="calibre1">For both clarity and fast execution, the code here has been written around the fact that R stores matrices in column-major order. As mentioned in the comments, our code then makes use of the fact that column  <i class="calibre4">i </i> of the <b class="calibre3">218</b></p>
<p class="calibre1">Chapter 9</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p245"/>product can be expressed as a linear combination of the columns of the first factor. It will help to see a specific example of this property, shown in Equation 9.2. </p>
<p class="calibre1">⎛</p>
<p class="calibre1">⎞ ⎛</p>
<p class="calibre1">⎞</p>
<p class="calibre1">⎛</p>
<p class="calibre1">⎞</p>
<p class="calibre1">1 2 3</p>
<p class="calibre1">4 3 2</p>
<p class="calibre1">4 5 9</p>
<p class="calibre1">⎝ 0 1 2 ⎠ ⎝ 0 1 2 ⎠ = ⎝ 0 1 4 ⎠</p>
<p class="calibre1">(9.2)</p>
<p class="calibre1">0 0 5</p>
<p class="calibre1">0 0 1</p>
<p class="calibre1">0 0 5</p>
<p class="calibre1">The comments say that, for instance, column 3 of the product is equal to the following:</p>
<p class="calibre1">⎛</p>
<p class="calibre1">⎞</p>
<p class="calibre1">⎛</p>
<p class="calibre1">⎞</p>
<p class="calibre1">⎛</p>
<p class="calibre1">⎞</p>
<p class="calibre1">1</p>
<p class="calibre1">2</p>
<p class="calibre1">3</p>
<p class="calibre1">2 ⎝ 0 ⎠ + 2 ⎝ 1 ⎠ + 1 ⎝ 2 ⎠</p>
<p class="calibre1">0</p>
<p class="calibre1">0</p>
<p class="calibre1">5</p>
<p class="calibre1">Inspection of Equation 9.2 confirms the relation. </p>
<p class="calibre1">Couching the multiplication problem in terms of columns of the</p>
<p class="calibre1">two input matrices enables us to compact the code and to likely increase the speed. The latter again stems from vectorization, a benefit discussed in detail in Chapter 14. This approach is used in the loop beginning at line 53. (Arguably, in this case, the increase in speed comes at the expense of readability of the code.)</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">9.1.7 Extended Example: A Procedure for Polynomial Regression</b></i></p>
<p class="calibre1">As another example, consider a statistical regression setting with one predictor variable. Since any statistical model is merely an approximation, in principle, you can get better and better models by fitting polynomials of higher and higher degrees. However, at some point, this becomes over-fitting, so that the prediction of new, future data actually deteriorates for degrees higher than some value. </p>
<p class="calibre1">The class "polyreg" aims to deal with this issue. It fits polynomials of various degrees but assesses fits via cross-validation to reduce the risk of over-fitting. In this form of cross-validation, known as the  <i class="calibre4">leaving-one-out method</i>, for each point we fit the regression to all the data  <i class="calibre4">except </i> this observation, and then we predict that observation from the fit. An object of this class consists of outputs from the various regression models, plus the original data. </p>
<p class="calibre1">The following is the code for the "polyreg" class. </p>
<p class="calibre1">1</p>
<p class="calibre1"># "polyreg," S3 class for polynomial regression in one predictor variable 2</p>
<p class="calibre1">3</p>
<p class="calibre1"># polyfit(y,x,maxdeg) fits all polynomials up to degree maxdeg; y is 4</p>
<p class="calibre1"># vector for response variable, x for predictor; creates an object of 5</p>
<p class="calibre1"># class "polyreg" </p>
<p class="calibre1">6</p>
<p class="calibre1">polyfit &lt;- function(y,x,maxdeg) {</p>
<p class="calibre1">7</p>
<p class="calibre1"># form powers of predictor variable, ith power in ith column</p>
<p class="calibre1">8</p>
<p class="calibre1">pwrs &lt;- powers(x,maxdeg) # could use orthog polys for greater accuracy 9</p>
<p class="calibre1">lmout &lt;- list() # start to build class</p>
<p class="calibre1">10</p>
<p class="calibre1">class(lmout) &lt;- "polyreg" # create a new class</p>
<p class="calibre1">Object-Oriented Programming</p>
<p class="calibre1"><b class="calibre3">219</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p246"/>11</p>
<p class="calibre1">for (i in 1:maxdeg) {</p>
<p class="calibre1">12</p>
<p class="calibre1">lmo &lt;- lm(y ~ pwrs[,1:i])</p>
<p class="calibre1">13</p>
<p class="calibre1"># extend the lm class here, with the cross-validated predictions</p>
<p class="calibre1">14</p>
<p class="calibre1">lmo$fitted.cvvalues &lt;- lvoneout(y,pwrs[,1:i,drop=F])</p>
<p class="calibre1">15</p>
<p class="calibre1">lmout[[i]] &lt;- lmo</p>
<p class="calibre1">16</p>
<p class="calibre1">}</p>
<p class="calibre1">17</p>
<p class="calibre1">lmout$x &lt;- x</p>
<p class="calibre1">18</p>
<p class="calibre1">lmout$y &lt;- y</p>
<p class="calibre1">19</p>
<p class="calibre1">return(lmout)</p>
<p class="calibre1">20</p>
<p class="calibre1">}</p>
<p class="calibre1">21</p>
<p class="calibre1">22</p>
<p class="calibre1"># print() for an object fits of class "polyreg": print</p>
<p class="calibre1">23</p>
<p class="calibre1"># cross-validated mean-squared prediction errors</p>
<p class="calibre1">24</p>
<p class="calibre1">print.polyreg &lt;- function(fits) {</p>
<p class="calibre1">25</p>
<p class="calibre1">maxdeg &lt;- length(fits) - 2</p>
<p class="calibre1">26</p>
<p class="calibre1">n &lt;- length(fits$y)</p>
<p class="calibre1">27</p>
<p class="calibre1">tbl &lt;- matrix(nrow=maxdeg,ncol=1)</p>
<p class="calibre1">28</p>
<p class="calibre1">colnames(tbl) &lt;- "MSPE" </p>
<p class="calibre1">29</p>
<p class="calibre1">for (i in 1:maxdeg) {</p>
<p class="calibre1">30</p>
<p class="calibre1">fi &lt;- fits[[i]]</p>
<p class="calibre1">31</p>
<p class="calibre1">errs &lt;- fits$y - fi$fitted.cvvalues</p>
<p class="calibre1">32</p>
<p class="calibre1">spe &lt;- crossprod(errs,errs) # sum of squared prediction errors</p>
<p class="calibre1">33</p>
<p class="calibre1">tbl[i,1] &lt;- spe/n</p>
<p class="calibre1">34</p>
<p class="calibre1">}</p>
<p class="calibre1">35</p>
<p class="calibre1">cat("mean squared prediction errors, by degree\n")</p>
<p class="calibre1">36</p>
<p class="calibre1">print(tbl)</p>
<p class="calibre1">37</p>
<p class="calibre1">}</p>
<p class="calibre1">38</p>
<p class="calibre1">39</p>
<p class="calibre1"># forms matrix of powers of the vector x, through degree dg</p>
<p class="calibre1">40</p>
<p class="calibre1">powers &lt;- function(x,dg) {</p>
<p class="calibre1">41</p>
<p class="calibre1">pw &lt;- matrix(x,nrow=length(x))</p>
<p class="calibre1">42</p>
<p class="calibre1">prod &lt;- x</p>
<p class="calibre1">43</p>
<p class="calibre1">for (i in 2:dg) {</p>
<p class="calibre1">44</p>
<p class="calibre1">prod &lt;- prod * x</p>
<p class="calibre1">45</p>
<p class="calibre1">pw &lt;- cbind(pw,prod)</p>
<p class="calibre1">46</p>
<p class="calibre1">}</p>
<p class="calibre1">47</p>
<p class="calibre1">return(pw)</p>
<p class="calibre1">48</p>
<p class="calibre1">}</p>
<p class="calibre1">49</p>
<p class="calibre1">50</p>
<p class="calibre1"># finds cross-validated predicted values; could be made much faster via 51</p>
<p class="calibre1"># matrix-update methods</p>
<p class="calibre1">52</p>
<p class="calibre1">lvoneout &lt;- function(y,xmat) {</p>
<p class="calibre1">53</p>
<p class="calibre1">n &lt;- length(y)</p>
<p class="calibre1">54</p>
<p class="calibre1">predy &lt;- vector(length=n)</p>
<p class="calibre1">55</p>
<p class="calibre1">for (i in 1:n) {</p>
<p class="calibre1">56</p>
<p class="calibre1"># regress, leaving out ith observation</p>
<p class="calibre1">57</p>
<p class="calibre1">lmo &lt;- lm(y[-i] ~ xmat[-i,])</p>
<p class="calibre1">58</p>
<p class="calibre1">betahat &lt;- as.vector(lmo$coef)</p>
<p class="calibre1"><b class="calibre3">220</b></p>
<p class="calibre1">Chapter 9</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p247"/>59</p>
<p class="calibre1"># the 1 accommodates the constant term</p>
<p class="calibre1">60</p>
<p class="calibre1">predy[i] &lt;- betahat %*% c(1,xmat[i,])</p>
<p class="calibre1">61</p>
<p class="calibre1">}</p>
<p class="calibre1">62</p>
<p class="calibre1">return(predy)</p>
<p class="calibre1">63</p>
<p class="calibre1">}</p>
<p class="calibre1">64</p>
<p class="calibre1">65</p>
<p class="calibre1"># polynomial function of x, coefficients cfs</p>
<p class="calibre1">66</p>
<p class="calibre1">poly &lt;- function(x,cfs) {</p>
<p class="calibre1">67</p>
<p class="calibre1">val &lt;- cfs[1]</p>
<p class="calibre1">68</p>
<p class="calibre1">prod &lt;- 1</p>
<p class="calibre1">69</p>
<p class="calibre1">dg &lt;- length(cfs) - 1</p>
<p class="calibre1">70</p>
<p class="calibre1">for (i in 1:dg) {</p>
<p class="calibre1">71</p>
<p class="calibre1">prod &lt;- prod * x</p>
<p class="calibre1">72</p>
<p class="calibre1">val &lt;- val + cfs[i+1] * prod</p>
<p class="calibre1">73</p>
<p class="calibre1">}</p>
<p class="calibre1">74</p>
<p class="calibre1">}</p>
<p class="calibre1">As you can see, "polyreg" consists of polyfit(), the constructor function, and print.polyreg(), a print function tailored to this class. It also contains several utility functions to evaluate powers and polynomials and to perform cross-validation. (Note that in some cases here, efficiency has been sacrificed for clarity.)</p>
<p class="calibre1">As an example of using the class, we’ll generate some artificial data and create an object of class "polyreg" from it, printing out the results. </p>
<p class="calibre1">&gt; n &lt;- 60</p>
<p class="calibre1">&gt; x &lt;- (1:n)/n</p>
<p class="calibre1">&gt; y &lt;- vector(length=n)</p>
<p class="calibre1">&gt; for (i in 1:n) y[i] &lt;- sin((3*pi/2)*x[i]) + x[i]^2 + rnorm(1,mean=0,sd=0.5)</p>
<p class="calibre1">&gt; dg &lt;- 15</p>
<p class="calibre1">&gt; (lmo &lt;- polyfit(y,x,dg))</p>
<p class="calibre1">mean squared prediction errors, by degree</p>
<p class="calibre1">MSPE</p>
<p class="calibre1">[1,] 0.4200127</p>
<p class="calibre1">[2,] 0.3212241</p>
<p class="calibre1">[3,] 0.2977433</p>
<p class="calibre1">[4,] 0.2998716</p>
<p class="calibre1">[5,] 0.3102032</p>
<p class="calibre1">[6,] 0.3247325</p>
<p class="calibre1">[7,] 0.3120066</p>
<p class="calibre1">[8,] 0.3246087</p>
<p class="calibre1">[9,] 0.3463628</p>
<p class="calibre1">[10,] 0.4502341</p>
<p class="calibre1">[11,] 0.6089814</p>
<p class="calibre1">[12,] 0.4499055</p>
<p class="calibre1">[13,]</p>
<p class="calibre1">NA</p>
<p class="calibre1">[14,]</p>
<p class="calibre1">NA</p>
<p class="calibre1">[15,]</p>
<p class="calibre1">NA</p>
<p class="calibre1">Object-Oriented Programming</p>
<p class="calibre1"><b class="calibre3">221</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p248"/>Note first that we used a common R trick in this command:</p>
<p class="calibre1">&gt; (lmo &lt;- polyfit(y,x,dg))</p>
<p class="calibre1">By surrounding the entire assignment statement in parentheses, we get the printout and form lmo at the same time, in case we need the latter for other things. </p>
<p class="calibre1">The function polyfit() fits polynomial models up through a specified degree, in this case 15, calculating the cross-validated mean squared prediction error for each model. The last few values in the output were NA, because roundoff error considerations led R to refuse to fit polynomials of degrees that high. </p>
<p class="calibre1">So, how is it all done? The main work is handled by the function</p>
<p class="calibre1">polyfit(), which creates an object of class "polyreg". That object consists mainly of the objects returned by the R regression fitter lm() for each degree. </p>
<p class="calibre1">In forming those objects, note line 14:</p>
<p class="calibre1">lmo$fitted.cvvalues &lt;- lvoneout(y,pwrs[,1:i,drop=F])</p>
<p class="calibre1">Here, lmo is an object returned by lm(), but we are adding an extra component to it: fitted.cvvalues. Since we can add a new component to a list at any time, and since S3 classes are lists, this is possible. </p>
<p class="calibre1">We also have a method for the generic function print(), print.polyreg() in line 24. In Section 12.1.5, we will add a method for the plot() generic function, plot.polyreg(). </p>
<p class="calibre1">In computing prediction errors, we used cross-validation, or the leaving-one-out method, in a form that predicts each observation from all the others. To implement this, we take advantage of R’s use of negative subscripts in line 57:</p>
<p class="calibre1">lmo &lt;- lm(y[-i] ~ xmat[-i,])</p>
<p class="calibre1">So, we are fitting the model with the  <i class="calibre4">i</i> th observation deleted from our data set. </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">As mentioned in the comment in the code, we could make a much faster implementation by using a matrix-inverse update method, known as the Sherman-Morrison-Woodbury formula. For more information, see J. H. Venter and J. L. J. Snyman, </i></p>
<p class="calibre1"> <i class="calibre4">“A Note on the Generalised Cross-Validation Criterion in Linear Model Selection,” </i></p>
<p class="calibre1">Biometrika <i class="calibre4">, Vol. 82, no. 1, pp. 215–219. </i></p>
<p class="calibre1"><b class="calibre3">9.2 S4 Classes</b></p>
<p class="calibre1">Some programmers feel that S3 does not provide the safety normally associated with OOP. For example, consider our earlier employee database <b class="calibre3">222</b></p>
<p class="calibre1">Chapter 9</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p249"/>example, where our class "employee" had three fields: name, salary, and union. </p>
<p class="calibre1">Here are some possible mishaps:</p>
<p class="calibre1">•</p>
<p class="calibre1">We forget to enter the union status. </p>
<p class="calibre1">•</p>
<p class="calibre1">We misspell  <i class="calibre4">union </i> as  <i class="calibre4">onion</i>. </p>
<p class="calibre1">•</p>
<p class="calibre1">We create an object of some class other than "employee" but accidentally set its class attribute to "employee". </p>
<p class="calibre1">In each of these cases, R will not complain. The goal of S4 is to elicit a complaint and prevent such accidents. </p>
<p class="calibre1">S4 structures are considerably richer than S3 structures, but here we present just the basics. Table 9-1 shows an overview of the differences between the two classes. </p>
<p class="calibre1"><b class="calibre3">Table 9-1: </b>Basic R Operators</p>
<p class="calibre1"><b class="calibre3">Operation</b></p>
<p class="calibre1"><b class="calibre3">S3</b></p>
<p class="calibre1"><b class="calibre3">S4</b></p>
<p class="calibre1">Define class</p>
<p class="calibre1">Implicit in constructor code</p>
<p class="calibre1">setClass()</p>
<p class="calibre1">Create object</p>
<p class="calibre1">Build list, set class attr</p>
<p class="calibre1">new()</p>
<p class="calibre1">Reference member variable</p>
<p class="calibre1">$</p>
<p class="calibre1">@</p>
<p class="calibre1">Implement generic f()</p>
<p class="calibre1">Define f.classname()</p>
<p class="calibre1">setMethod()</p>
<p class="calibre1">Declare generic</p>
<p class="calibre1">UseMethod()</p>
<p class="calibre1">setGeneric()</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">9.2.1 Writing S4 Classes</b></i></p>
<p class="calibre1">You define an S4 class by calling setClass(). Continuing our employee example, we could write the following:</p>
<p class="calibre1">&gt; setClass("employee", </p>
<p class="calibre1">+</p>
<p class="calibre1">representation(</p>
<p class="calibre1">+</p>
<p class="calibre1">name="character", </p>
<p class="calibre1">+</p>
<p class="calibre1">salary="numeric", </p>
<p class="calibre1">+</p>
<p class="calibre1">union="logical")</p>
<p class="calibre1">+ )</p>
<p class="calibre1">[1] "employee" </p>
<p class="calibre1">This defines a new class, "employee", with three member variables of the specified types. </p>
<p class="calibre1">Now let’s create an instance of this class, for Joe, using new(), a built-in constructor function for S4 classes:</p>
<p class="calibre1">&gt; joe &lt;- new("employee",name="Joe",salary=55000,union=T)</p>
<p class="calibre1">&gt; joe</p>
<p class="calibre1">An object of class "employee" </p>
<p class="calibre1">Slot "name":</p>
<p class="calibre1">[1] "Joe" </p>
<p class="calibre1">Object-Oriented Programming</p>
<p class="calibre1"><b class="calibre3">223</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p250"/>Slot "salary":</p>
<p class="calibre1">[1] 55000</p>
<p class="calibre1">Slot "union":</p>
<p class="calibre1">[1] TRUE</p>
<p class="calibre1">Note that the member variables are called  <i class="calibre4">slots</i>, referenced via the @ symbol. Here’s an example:</p>
<p class="calibre1">&gt; joe@salary</p>
<p class="calibre1">[1] 55000</p>
<p class="calibre1">We can also use the slot() function, say, as another way to query Joe’s salary:</p>
<p class="calibre1">&gt; slot(joe,"salary")</p>
<p class="calibre1">[1] 55000</p>
<p class="calibre1">We can assign components similarly. Let’s give Joe a raise:</p>
<p class="calibre1">&gt; joe@salary &lt;- 65000</p>
<p class="calibre1">&gt; joe</p>
<p class="calibre1">An object of class "employee" </p>
<p class="calibre1">Slot "name":</p>
<p class="calibre1">[1] "Joe" </p>
<p class="calibre1">Slot "salary":</p>
<p class="calibre1">[1] 65000</p>
<p class="calibre1">Slot "union":</p>
<p class="calibre1">[1] TRUE</p>
<p class="calibre1">Nah, he deserves a bigger raise that that:</p>
<p class="calibre1">&gt; slot(joe,"salary") &lt;- 88000</p>
<p class="calibre1">&gt; joe</p>
<p class="calibre1">An object of class "employee" </p>
<p class="calibre1">Slot "name":</p>
<p class="calibre1">[1] "Joe" </p>
<p class="calibre1">Slot "salary":</p>
<p class="calibre1">[1] 88000</p>
<p class="calibre1">Slot "union":</p>
<p class="calibre1">[1] TRUE</p>
<p class="calibre1"><b class="calibre3">224</b></p>
<p class="calibre1">Chapter 9</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p251"/>As noted, an advantage of using S4 is safety. To illustrate this, suppose we were to accidentally spell  <i class="calibre4">salary </i> as  <i class="calibre4">salry</i>, like this:</p>
<p class="calibre1">&gt; joe@salry &lt;- 48000</p>
<p class="calibre1">Error in checkSlotAssignment(object, name, value) :</p>
<p class="calibre1">"salry" is not a slot in class "employee" </p>
<p class="calibre1">By contrast, in S3 there would be no error message. S3 classes are just lists, and you are allowed to add a new component (deliberately or not) at any time. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">9.2.2 Implementing a Generic Function on an S4 Class</b></i></p>
<p class="calibre1">To define an implementation of a generic function on an S4 class, use setMethod(). Let’s do that for our class "employee" here. We’ll implement the show() function, which is the S4 analog of S3’s generic "print". </p>
<p class="calibre1">As you know, in R, when you type the name of a variable while in interactive mode, the value of the variable is printed out:</p>
<p class="calibre1">&gt; joe</p>
<p class="calibre1">An object of class "employee" </p>
<p class="calibre1">Slot "name":</p>
<p class="calibre1">[1] "Joe" </p>
<p class="calibre1">Slot "salary":</p>
<p class="calibre1">[1] 88000</p>
<p class="calibre1">Slot "union":</p>
<p class="calibre1">[1] TRUE</p>
<p class="calibre1">Since joe is an S4 object, the action here is that show() is called. In fact, we would get the same output by typing this:</p>
<p class="calibre1">&gt; show(joe)</p>
<p class="calibre1">Let’s override that, with the following code:</p>
<p class="calibre1">setMethod("show", "employee", </p>
<p class="calibre1">function(object) {</p>
<p class="calibre1">inorout &lt;- ifelse(object@union,"is","is not") cat(object@name,"has a salary of",object@salary, </p>
<p class="calibre1">"and",inorout, "in the union", "\n")</p>
<p class="calibre1">}</p>
<p class="calibre1">)</p>
<p class="calibre1">The first argument gives the name of the generic function for which we will define a class-specific method, and the second argument gives the class name. We then define the new function. </p>
<p class="calibre1">Object-Oriented Programming</p>
<p class="calibre1"><b class="calibre3">225</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p252"/>Let’s try it out:</p>
<p class="calibre1">&gt; joe</p>
<p class="calibre1">Joe has a salary of 55000 and is in the union</p>
<p class="calibre1"><b class="calibre3">9.3 S3 Versus S4</b></p>
<p class="calibre1">The type of class to use is the subject of some controversy among R programmers. In essence, your view here will likely depend on your personal choice of which you value more—the convenience of S3 or the safety of S4. </p>
<p class="calibre1">John Chambers, the creator of the S language and one of the central developers of R, recommends S4 over S3 in his book  <i class="calibre4">Software for Data Analysis </i>(Springer, 2008). He argues that S4 is needed in order to write “clear and reliable software.” On the other hand, he notes that S3 remains quite popular. </p>
<p class="calibre1">Google’s R Style Guide, which you can find at  <i class="calibre4">http://google-styleguide</i></p>
<p class="calibre1"> <i class="calibre4">.googlecode.com/svn/trunk/google-r-style.html</i>, is interesting in this regard. Google comes down squarely on the S3 side, stating “avoid S4 objects and methods when possible.” (Of course, it’s also interesting that Google even has an R</p>
<p class="calibre1">style guide in the first place!)</p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">A nice, concrete comparison of the two methods is given in Thomas Lumley’s</i></p>
<p class="calibre1"> <i class="calibre4">“Programmer’s Niche: A Simple Class, in S3 and S4,” </i> R News <i class="calibre4">, April 1, 2004,</i> <i class="calibre4">pp. 33–36. </i></p>
<p class="calibre1"><b class="calibre3">9.4 Managing Your Objects</b></p>
<p class="calibre1">As a typical R session progresses, you tend to accumulate a large number of objects. Various tools are available to manage them. Here, we’ll look at the following:</p>
<p class="calibre1">•</p>
<p class="calibre1">The ls() function</p>
<p class="calibre1">•</p>
<p class="calibre1">The rm() function</p>
<p class="calibre1">•</p>
<p class="calibre1">The save() function</p>
<p class="calibre1">•</p>
<p class="calibre1">Several functions that tell you more about the structure of an object, such as class() and mode()</p>
<p class="calibre1">•</p>
<p class="calibre1">The exists() function</p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">9.4.1 Listing Your Objects with the ls() Function</b></i></p>
<p class="calibre1">The ls() command will list all of your current objects. A useful named argument for this function is pattern, which enables  <i class="calibre4">wildcards</i>. Here, you tell ls() to list only the objects whose names include a specified pattern. The following is an example. </p>
<p class="calibre1"><b class="calibre3">226</b></p>
<p class="calibre1">Chapter 9</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p253"/>&gt; ls()</p>
<p class="calibre1">[1] "acc" </p>
<p class="calibre1">"acc05" </p>
<p class="calibre1">"binomci" </p>
<p class="calibre1">"cmeans" </p>
<p class="calibre1">"divorg" </p>
<p class="calibre1">"dv" </p>
<p class="calibre1">[7] "fit" </p>
<p class="calibre1">"g" </p>
<p class="calibre1">"genxc" </p>
<p class="calibre1">"genxnt" </p>
<p class="calibre1">"j" </p>
<p class="calibre1">"lo" </p>
<p class="calibre1">[13] "out1" </p>
<p class="calibre1">"out1.100" "out1.25" </p>
<p class="calibre1">"out1.50" </p>
<p class="calibre1">"out1.75" </p>
<p class="calibre1">"out2" </p>
<p class="calibre1">[19] "out2.100" "out2.25" </p>
<p class="calibre1">"out2.50" </p>
<p class="calibre1">"out2.75" </p>
<p class="calibre1">"par.set" </p>
<p class="calibre1">"prpdf" </p>
<p class="calibre1">[25] "ratbootci" "simonn" </p>
<p class="calibre1">"vecprod" </p>
<p class="calibre1">"x" </p>
<p class="calibre1">"zout" </p>
<p class="calibre1">"zout.100" </p>
<p class="calibre1">[31] "zout.125" "zout3" </p>
<p class="calibre1">"zout5" </p>
<p class="calibre1">"zout.50" </p>
<p class="calibre1">"zout.75" </p>
<p class="calibre1">&gt; ls(pattern="ut")</p>
<p class="calibre1">[1] "out1" </p>
<p class="calibre1">"out1.100" "out1.25" "out1.50" "out1.75" "out2" </p>
<p class="calibre1">[7] "out2.100" "out2.25" "out2.50" "out2.75" "zout" </p>
<p class="calibre1">"zout.100" </p>
<p class="calibre1">[13] "zout.125" "zout3" </p>
<p class="calibre1">"zout5" </p>
<p class="calibre1">"zout.50" "zout.75" </p>
<p class="calibre1">In the second case, we asked for a list of all objects whose names include the string "ut". </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">9.4.2 Removing Specific Objects with the rm() Function</b></i></p>
<p class="calibre1">To remove objects you no longer need, use rm(). Here’s an example:</p>
<p class="calibre1">&gt; rm(a,b,x,y,z,uuu)</p>
<p class="calibre1">This code removes the six specified objects (a, b, and so on). </p>
<p class="calibre1">One of the named arguments of rm() is list, which makes it easier to remove multiple objects. This code assigns all of our objects to list, thus removing everything:</p>
<p class="calibre1">&gt; rm(list = ls())</p>
<p class="calibre1">Using ls()’s pattern argument, this tool becomes even more powerful. </p>
<p class="calibre1">Here’s an example:</p>
<p class="calibre1">&gt; ls()</p>
<p class="calibre1">[1] "doexpt" </p>
<p class="calibre1">"notebookline" </p>
<p class="calibre1">"nreps" </p>
<p class="calibre1">"numcorrectcis" </p>
<p class="calibre1">[5] "numnotebooklines" "numrules" </p>
<p class="calibre1">"observationpt" </p>
<p class="calibre1">"prop" </p>
<p class="calibre1">[9] "r" </p>
<p class="calibre1">"rad" </p>
<p class="calibre1">"radius" </p>
<p class="calibre1">"rep" </p>
<p class="calibre1">[13] "s" </p>
<p class="calibre1">"s2" </p>
<p class="calibre1">"sim" </p>
<p class="calibre1">"waits" </p>
<p class="calibre1">[17] "wbar" </p>
<p class="calibre1">"x" </p>
<p class="calibre1">"y" </p>
<p class="calibre1">"z" </p>
<p class="calibre1">&gt; ls(pattern="notebook")</p>
<p class="calibre1">[1] "notebookline" </p>
<p class="calibre1">"numnotebooklines" </p>
<p class="calibre1">&gt; rm(list=ls(pattern="notebook"))</p>
<p class="calibre1">&gt; ls()</p>
<p class="calibre1">[1] "doexpt" </p>
<p class="calibre1">"nreps" </p>
<p class="calibre1">"numcorrectcis" "numrules" </p>
<p class="calibre1">[5] "observationpt" "prop" </p>
<p class="calibre1">"r" </p>
<p class="calibre1">"rad" </p>
<p class="calibre1">[9] "radius" </p>
<p class="calibre1">"rep" </p>
<p class="calibre1">"s" </p>
<p class="calibre1">"s2" </p>
<p class="calibre1">[13] "sim" </p>
<p class="calibre1">"waits" </p>
<p class="calibre1">"wbar" </p>
<p class="calibre1">"x" </p>
<p class="calibre1">[17] "y" </p>
<p class="calibre1">"z" </p>
<p class="calibre1">Object-Oriented Programming</p>
<p class="calibre1"><b class="calibre3">227</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p254"/>Here, we found two objects whose names include the string "notebook" </p>
<p class="calibre1">and then asked to remove them, which was confirmed by the second call to ls(). </p>
<p class="calibre1"><b class="calibre3">NOTE</b></p>
<p class="calibre1"> <i class="calibre4">You may find the function browseEnv() helpful. It will show in your web browser your</i> <i class="calibre4">globals (or objects in a different specified environment), with some details on each. </i></p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">9.4.3 Saving a Collection of Objects with the save() Function</b></i></p>
<p class="calibre1">Calling save() on a collection of objects will write them to disk for later retrieval by load(). Here’s a quick example:</p>
<p class="calibre1">&gt; z &lt;- rnorm(100000)</p>
<p class="calibre1">&gt; hz &lt;- hist(z)</p>
<p class="calibre1">&gt; save(hz,"hzfile")</p>
<p class="calibre1">&gt; ls()</p>
<p class="calibre1">[1] "hz" "z" </p>
<p class="calibre1">&gt; rm(hz)</p>
<p class="calibre1">&gt; ls()</p>
<p class="calibre1">[1] "z" </p>
<p class="calibre1">&gt; load("hzfile")</p>
<p class="calibre1">&gt; ls()</p>
<p class="calibre1">[1] "hz" "z" </p>
<p class="calibre1">&gt; plot(hz) # graph window pops up</p>
<p class="calibre1">Here, we generate some data and then draw a histogram of it. But</p>
<p class="calibre1">we also save the output of hist() in a variable, hz. That variable is an object (of class "histogram", of course). Anticipating that we will want to reuse this object in a later R session, we use the save() function to save the object to the file  <i class="calibre4">hzfile</i>. It can be reloaded in that future session via load(). To demonstrate this, we deliberately removed the hz object, then called load() to reload it, and then called ls() to show that it had indeed been reloaded. </p>
<p class="calibre1">I once needed to read in a very large data file, each record of which required processing. I then used save() to keep the R object version of the processed file for future R sessions. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">9.4.4 “What Is This?” </b></i></p>
<p class="calibre1">Developers often need to know the exact structure of the object returned by a library function. If the documentation does not give sufficient details, what can we do? </p>
<p class="calibre1">The following R functions may be helpful:</p>
<p class="calibre1">•</p>
<p class="calibre1">class(), mode()</p>
<p class="calibre1">•</p>
<p class="calibre1">names(), attributes()</p>
<p class="calibre1">•</p>
<p class="calibre1">unclass(), str()</p>
<p class="calibre1">•</p>
<p class="calibre1">edit()</p>
<p class="calibre1"><b class="calibre3">228</b></p>
<p class="calibre1">Chapter 9</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p255"/>Let’s go through an example. R includes facilities for constructing  <i class="calibre4">contingency tables</i>, which we discussed in Section 6.4. An example in that section involved an election survey in which five respondents are asked whether they intend to vote for candidate X and whether they voted for X in the last election. Here is the resulting table:</p>
<p class="calibre1">&gt; cttab &lt;- table(ct)</p>
<p class="calibre1">&gt; cttab</p>
<p class="calibre1">Voted.for.X.Last.Time</p>
<p class="calibre1">Vote.for.X No Yes</p>
<p class="calibre1">No</p>
<p class="calibre1">2</p>
<p class="calibre1">0</p>
<p class="calibre1">Not Sure 0</p>
<p class="calibre1">1</p>
<p class="calibre1">Yes</p>
<p class="calibre1">1</p>
<p class="calibre1">1</p>
<p class="calibre1">For instance, two respondents answered no to both questions. </p>
<p class="calibre1">The object cttab was returned by the function table and thus is likely of class "table". A check of the documentation (?table) confirms this. But what is in the class? </p>
<p class="calibre1">Let’s explore the structure of that object cttab of class "table". </p>
<p class="calibre1">&gt; ctu &lt;- unclass(cttab)</p>
<p class="calibre1">&gt; ctu</p>
<p class="calibre1">Votes.for.X.Last.Time</p>
<p class="calibre1">Vote.for.X No Yes</p>
<p class="calibre1">No</p>
<p class="calibre1">2</p>
<p class="calibre1">0</p>
<p class="calibre1">Not Sure 0</p>
<p class="calibre1">1</p>
<p class="calibre1">Yes</p>
<p class="calibre1">1</p>
<p class="calibre1">1</p>
<p class="calibre1">&gt; class(ctu)</p>
<p class="calibre1">[1] "matrix" </p>
<p class="calibre1">So, the counts portion of the object is a matrix. (If the data had involved three or more questions, rather than just two, this would have been a higher-dimensional array.) Note that the names of the dimensions and of the individual rows and columns are there, too; they are associated with the matrix. </p>
<p class="calibre1">The unclass() function is quite useful as a first step. If you simply print an object, you are at the mercy of the version of print() associated with that class, which may in the name of succinctness hide or distort some valuable information. Printing the result of calling unclass() allows you to work around this problem, though there was no difference in this example. (You saw an instance in which it did make a difference in the section about S3</p>
<p class="calibre1">generic functions in Section 9.1.1 earlier.) The function str() serves the same purpose, in a more compact manner. </p>
<p class="calibre1">Note, though, applying unclass() to an object still results in an object with some basic class. Here, cttab had the class "table", but unclass(cttab) still had the class "matrix". </p>
<p class="calibre1">Let’s try looking at the code for table(), the library function that produced cttab. We could simply type table, but since this is a somewhat longish Object-Oriented Programming</p>
<p class="calibre1"><b class="calibre3">229</b></p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p256"/>function, a lot of the function would zoom by on the screen too fast for us to absorb it. We could use page() to solve this problem, but I prefer edit():</p>
<p class="calibre1">&gt; edit(table)</p>
<p class="calibre1">This allows you to browse through the code with your text editor. In doing so, you’ll find this code at the end:</p>
<p class="calibre1">y &lt;- array(tabulate(bin, pd), dims, dimnames = dn)</p>
<p class="calibre1">class(y) &lt;- "table" </p>
<p class="calibre1">y</p>
<p class="calibre1">Ah, interesting. This shows that table() is, to some extent, a wrapper for another function, tabulate(). But what might be more important here is that the structure of a "table" object is really pretty simple: It consists of an array created from the counts, with the class attribute tacked on. So, it’s essentially just an array. </p>
<p class="calibre1">The function names() shows the components in an object, and attributes() gives you this and a bit more, notably the class name. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">9.4.5 The exists() Function</b></i></p>
<p class="calibre1">The function exists() returns TRUE or FALSE, depending on whether the argument exists. Be sure to put the argument in quotation marks. </p>
<p class="calibre1">For example, the following code shows that the acc object exists:</p>
<p class="calibre1">&gt; exists("acc")</p>
<p class="calibre1">[1] TRUE</p>
<p class="calibre1">Why would this function be useful? Don’t we always know whether or</p>
<p class="calibre1">not we’ve created an object and whether it’s still there? Not necessarily. If you are writing general-purpose code, say to be made available to the world in R’s CRAN code repository, your code may need to check whether a certain object exists, and if it doesn’t, then your code must create it. For example, as you learned in Section 9.4.3, you can save objects to disk files using save() and then later restore them to R’s memory space by calling load(). </p>
<p class="calibre1">You might write general-purpose code that makes the latter call if the object is not already present, a condition you could check by calling exists(). </p>
<p class="calibre1"><b class="calibre3">230</b></p>
<p class="calibre1">Chapter 9</p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p257"/><img src="index-257_1.png" alt="Image 22" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">10</b></p>
<p class="calibre1"><b class="calibre3">INPUT/OUTPUT</b></p>
<p class="calibre1">One of the most underemphasized topics</p>
<p class="calibre1">in many university programming courses</p>
<p class="calibre1">is input/output (I/O). I/O plays a central</p>
<p class="calibre1">role in most real-world applications of comput-</p>
<p class="calibre1">ers. Just consider an ATM cash machine, which uses</p>
<p class="calibre1">multiple I/O operations for both input—reading your</p>
<p class="calibre1">card and reading your typed-in cash request—and</p>
<p class="calibre1">output—printing instructions on the screen, printing</p>
<p class="calibre1">your receipt, and most important, controlling the</p>
<p class="calibre1">machine to output your money! </p>
<p class="calibre1">R is not the tool you would choose for running an ATM, but it features a highly versatile array of I/O capabilities, as you will learn in this chapter. </p>
<p class="calibre1">We’ll start with the basics of access to the keyboard and monitor, and then go into considerable detail on reading and writing files, including the navigation of file directories. Finally, we discuss R’s facilities for accessing the Internet. </p>
<p class="calibre1"><a href="http://www.it-ebooks.info/">www.it-ebooks.info</a></p>
<p class="calibre1"><a id="p258"/><b class="calibre3">10.1 Accessing the Keyboard and Monitor</b></p>
<p class="calibre1">R provides several functions for accesssing the keyboard and monitor. Here, we’ll look at the scan(), readline(), print(), and cat() functions. </p>
<p class="calibre1"> <i class="calibre4"><b class="calibre3">10.1.1 Using the scan() Function</b></i></p>
<p class="calibre1">You can use scan() to read in a vector, whether numeric or character, from a file or the keyboard. With a little extra work, you can even read in data to form a list. </p>
<p class="calibre1">Suppose we have files named  <i class="calibre4">z1.txt</i>,  <i class="calibre4">z2.txt</i>,  <i class="calibre4">z3.txt</i>, and  <i class="calibre4">z4.txt</i>. The  <i class="calibre4">z1.txt </i> file contains the following:</p>
<p class="calibre1">123</p>
<p class="calibre1">4 5</p>
<p class="calibre1">6</p>
<p class="calibre1">The  <i class="calibre4">z2.txt </i> file contents are as follows:</p>
<p class="calibre1">123</p>
<p class="calibre1">4.2 5</p>
<p class="calibre1">6</p>
<p class="calibre1">The  <i class="calibre4">z3.txt </i> file contains this:</p>
<p class="calibre1">abc</p>
<p class="calibre1">de f</p>
<p class="calibre1">g</p>
<p class="calibre1">And finally, the  <i class="calibre4">z4.txt </i> file has these contents:</p>
<p class="calibre1">abc</p>
<p class="calibre1">123 6</p>
<p class="calibre1">y</p>
<p class="calibre1">Let’s see what we can do with these files using the scan() function. </p>
<p class="calibre1">&gt; scan("z1.txt")</p>
<p class="calibre1">Read 4 items</p>
</body></html>