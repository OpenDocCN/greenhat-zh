- en: Chapter 4. Text Manipulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 文本操作
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
- en: Text is the basic format for storing configuration data, web content, email,
    as well as data written in XML (eXtensible Markup Language) and YAML (YAML Ain’t
    Markup Language) which we’ll be looking at in greater detail later. It’s important
    for a programming language to deal with text easily and efficiently. Luckily,
    Ruby meets this requirement. This chapter includes several scripts that demonstrate
    Ruby’s approach to some common text-oriented problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 文本是存储配置数据、网页内容、电子邮件以及XML（可扩展标记语言）和YAML（YAML不是标记语言）等数据的常用格式，我们将在稍后更详细地探讨这些内容。对于一种编程语言来说，能够轻松高效地处理文本是很重要的。幸运的是，Ruby满足了这一要求。本章包含几个脚本，展示了Ruby在处理一些常见文本问题上的方法。
- en: '#9 End-of-Line Conversion (dos2unix.rb)'
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#9 行尾转换 (dos2unix.rb)'
- en: If you’ve never had to deal with end-of-line (EOL) differences among operating
    systems, consider yourself fortunate. Microsoft, Apple, and the various Unix-like
    operating systems (such as the BSDs and GNU/Linux systems) all disagree about
    how a text file should show the end of a line. This is further complicated by
    Apple’s transition to a Unix-like operating system with Mac OS X, which is very
    similar to FreeBSD. Unix-like systems mark the end of a line with the *line feed*
    character (also called *newline*); in interfaces that predate the cathode-ray
    tube (CRT), this character indicated that the paper should move up a line so that
    there would be more blank paper on which to print. On the other hand, older Macintosh
    systems (pre–Mac OS X) indicated the end of a line with the *carriage return*
    character, which indicated that the printer should move back to the left side
    to start printing again (this assumes you are using a language that is written
    left to right, like English). Windows (and DOS) systems, on the third hand, mark
    the end of a line with a carriage return followed by a line feed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未处理过操作系统之间的行尾（EOL）差异，那么你应该感到幸运。微软、苹果以及各种类Unix操作系统（如BSD和GNU/Linux系统）都对文本文件应该如何显示行尾有不同的看法。苹果从Mac
    OS X过渡到类Unix操作系统进一步复杂化了这个问题，它与FreeBSD非常相似。类Unix系统使用*换行符*（也称为*新行*）标记行尾；在阴极射线管（CRT）之前的接口中，这个字符表示纸张应该向上移动一行，以便有更多的空白纸张可以打印。另一方面，较老的Macintosh系统（在Mac
    OS X之前）使用*回车符*来标记行尾，这表示打印机应该回到左边开始重新打印（这假设你使用的是从左到右书写的语言，如英语）。Windows（和DOS）系统，另一方面，使用回车符后跟换行符来标记行尾。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Some Internet protocols also use the Windows EOL convention, despite often
    being hosted on Unix-like machines. Go figure*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些互联网协议也使用Windows行尾约定，尽管它们通常托管在类Unix机器上。想想看*。'
- en: Why the difference? One could argue that the Windows approach makes the most
    sense—if we’re modeling the physical action of something like a typewriter, then
    both a carriage return and a line feed would be needed. However, the Unix-like
    and Macintosh approaches have the benefit of only using one character. This is
    an important savings, given how often newlines appear in text documents, and it
    was even more important in the early days of computers when both RAM and storage
    were much more limited and expensive than they are now.^([[9](#ftn.CHP-4-FNOTE-1)])
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会有这种差异？有人可能会认为Windows的方法最有道理——如果我们模拟类似打字机的物理动作，那么需要一个回车符和一个换行符。然而，类Unix和Macintosh的方法的好处是只使用一个字符。考虑到文本文档中新行出现的频率，这是一个重要的节省，而且在计算机的早期，RAM和存储都比现在要有限和昂贵得多.^([[9](#ftn.CHP-4-FNOTE-1)])
- en: Today, most text editors and similar programs can deal with these differences
    without too much difficulty, so the end-of-line compatibility problem is generally
    no more than a nuisance. But why put up with a nuisance when you don’t have to?
    We can write a Ruby program that converts DOS or old-style Mac EOLs to Unix EOLs
    for us.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数文本编辑器和类似程序都能轻松处理这些差异，因此行尾兼容性问题通常不会造成太大的麻烦。但为什么非得忍受这种麻烦呢？我们可以编写一个Ruby程序，将DOS或旧式Mac行尾转换为Unix行尾。
- en: The Code
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How It Works
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: My pro-Unix biases are clear from both the name and purpose of this program.
    Let’s see what it does. At ❶, we start looping through the arguments to the script,
    calling each `filename` in turn. We open and close that argument (currently called
    `filename`) as we’ve done before, reading its contents into the creatively named
    variable `contents`. We do some magic with `gsub!` at ❸, and then write `contents`
    into a new file (❹) called `replace_file`. What’s the magic at ❸? Let’s look at
    it again.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个程序的名字和目的来看，我的Unix倾向是显而易见的。让我们看看它做了什么。在❶处，我们开始遍历脚本的参数，依次调用每个`filename`。我们打开和关闭这个参数（目前称为`filename`），就像之前做的那样，将其内容读入名为`contents`的变量中。我们在❸处用`gsub!`做了一些魔法，然后将`contents`写入一个名为`replace_file`的新文件中。❸处的魔法是什么？让我们再看一遍。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’re calling a method called `gsub!` on our `contents` String. We know that
    `gsub!` (which stands for *global substitution*) is a destructive method because
    of its exclamation-mark ending, and it looks like it takes two arguments. The
    first argument is enclosed in regular slashes, and the second argument is a newline
    String. The first argument is a *regular expression*, which is a special kind
    of variable that can describe the contents of a piece of text without knowing
    everything about it. Regular expressions (*regexes* for short) allow you to test
    for conditions like *Does this text consist entirely of digits?*, which you could
    imagine might be useful before using the `to_i` method of a String. Regexes also
    allow tests like *Are there exactly seven words in the text?* or *Do all words
    in this text start with a capital letter?*, as well as many others.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的`contents`字符串上调用了一个名为`gsub!`的方法。我们知道`gsub!`（代表全局替换）是一个破坏性方法，因为它以感叹号结尾，看起来它接受两个参数。第一个参数被正则斜杠包围，第二个参数是一个换行字符串。第一个参数是一个*正则表达式*，这是一种特殊类型的变量，可以在不知道文本所有内容的情况下描述文本的内容。正则表达式（简称*regexes*）允许你测试条件，例如*这个文本是否完全由数字组成？*，这在使用字符串的`to_i`方法之前可能很有用。正则表达式还允许测试，例如*文本中是否有恰好七个单词？*或*这个文本中的所有单词是否都以大写字母开头？*，以及许多其他情况。
- en: Regexes accomplish tasks by defining descriptors for characters as well as groupings
    and the number of occurrences of those characters. As you can see in the code,
    regexes are delineated with slashes. This practice of using slashes is not specific
    to Ruby; it is common in other languages as well. The question mark in the regex
    does not mean a literal question mark appearing in the text; instead, it means
    that whatever preceded it is optional, occurring zero or more times. Let’s try
    out some regexes in irb. We’ll use a new operator called `=~`, which is similar
    to `==`. Instead of testing for exact equality, though, it tests whether or not
    the regular expression matches any part of the String we call it on. It returns
    the first point at which a match occurs if the question the regex represents (i.e.,
    *Does this text consist entirely of digits?*) is true for that String; it returns
    `nil` if there is no match.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式通过定义字符、分组以及这些字符出现的次数的描述符来完成任务。正如你在代码中所看到的，正则表达式是用斜杠界定的。使用斜杠的做法并不仅限于Ruby；在其他语言中也很常见。正则表达式中的问号并不代表文本中出现的字面问号；相反，它表示它之前的内容是可选的，出现零次或多次。让我们在irb中尝试一些正则表达式。我们将使用一个名为`=~`的新操作符，它类似于`==`。不过，它不是测试精确相等，而是测试正则表达式是否与我们所调用的字符串的任何部分匹配。如果正则表达式所代表的问题（即*这个文本是否完全由数字组成？*）对于该字符串为真，它返回匹配发生的第一个点；如果没有匹配，它返回`nil`。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have our String, `letters`, which is just the first five letters of the alphabet.
    We then test whether the letter *a* appears anywhere in `letters`. It does, right
    at the beginning, so our test returns zero. Why? Because that is the index within
    the String where the first match occurs—remember that we start counting with zero,
    not one. Since the next letter is *b*, when we test for the presence of *b* within
    `letters`, we should get a result that is one higher than the value when we tested
    for *a*. We do. Jumping ahead to the letter *e*, we have a match at the last index,
    which is the fifth letter and has the index of four, again because we start counting
    with zero. When we test for a letter that does not appear in `letters`, we get
    the return value `nil`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有字符串`letters`，它只是字母表的前五个字母。然后我们测试字母*a*是否出现在`letters`中的任何位置。它确实出现了，就在开头，所以我们的测试返回零。为什么？因为这是字符串中第一次匹配发生的索引——记住我们是从零开始计数的，而不是从一。由于下一个字母是*b*，当我们测试*b*在`letters`中的存在时，我们应该得到一个比测试*a*时高一个的结果。我们确实得到了。跳到字母*e*，我们在最后一个索引处有一个匹配，这是第五个字母，索引为四，同样是因为我们是从零开始计数的。当我们测试一个不在`letters`中出现的字母时，我们得到返回值`nil`。
- en: That’s simple matching. Now let’s use that question mark.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简单的匹配。现在让我们使用那个问号。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At first, line six seems similar to line two. Line seven is more interesting,
    in that the optional second letter is a new letter that does not appear in `letters`
    at all. In both cases, the second letter precedes a question mark, which makes
    it optional. On line six, we are asking if our String (consisting of the first
    five letters) has an *a* followed by zero or more *a*s. It does, starting at index
    zero, so that is our return value. We then ask if our String has an *a* followed
    by zero or more *x*s. It does, starting at index zero. Let’s continue.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，第六行看起来与第二行相似。第七行更有趣，因为可选的第二个字母是一个在`letters`中根本不出现的新的字母。在这两种情况下，第二个字母前面都有一个问号，这使得它是可选的。在第六行，我们是在问我们的字符串（由前五个字母组成）是否有一个*a*后面跟着零个或多个*a*。它确实有，从索引零开始，所以这就是我们的返回值。然后我们问我们的字符串是否有一个*a*后面跟着零个或多个*x*。它确实有，从索引零开始。让我们继续。
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Line eight asks if `letters` has an *a* followed by any optional *b*s, which
    it does at index zero. Line nine asks if `letters` has a *b* followed by any optional
    *c* s, which is does at index one. Line ten asks if `letters` has any optional
    *b*s, which it does at index zero. The lesson is clear—matching optional characters
    is very enthusiastic, and the complete absence of a character matches zero or
    more occurrences of any character. Be very careful with your use of the question
    mark, especially as a regex argument used by a destructive method. Here’s another
    demonstration of a match for zero occurrences of a character:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第八行询问`letters`是否有一个*a*后面跟着任何可选的*b*，它在索引零处确实有。第九行询问`letters`是否有一个*b*后面跟着任何可选的*c*，它在索引一处确实有。第十行询问`letters`是否有一个可选的*b*，它在索引零处确实有。教训很明确——匹配可选字符非常热情，一个字符的完全缺失匹配零个或多个任何字符的出现。在使用问号时，特别是作为一个由破坏性方法使用的正则表达式参数时，要非常小心。这里是一个匹配零个字符出现的另一个示例：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There’s nothing at the beginning of `letters`. Matching on nothing is conceptually
    odd, but it can be very useful when you want to break a String into an Array of
    each of its characters. You may recall we used the `split` method matching the
    empty string in our script `palindrome2.rb` ([Chapter 3](ch03.html "Chapter 3. Programmer
    Utilities")) to deal with each letter in the String in turn.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在`letters`的开头没有内容。匹配空内容在概念上很奇怪，但当你想要将字符串分割成每个字符的数组时，它非常有用。你可能记得我们在`palindrome2.rb`脚本中使用了`split`方法匹配空字符串（[第3章](ch03.html
    "第3章。程序员工具"))，逐个处理字符串中的每个字母。
- en: Now we’ve done our matching. I said earlier that `gsub` stands for *global substitution*,
    so let’s do some substituting, again in irb.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了匹配。我之前说过`gsub`代表*全局替换*，所以让我们再次进行一些替换，这次在irb中。
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can see that `gsub` finds the portion of the String that matches the first
    argument and returns a result in which the first argument is replaced by the second
    argument. Now let’s review the differences between destructive and non-destructive
    methods, as they relate to these substitutions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`gsub`找到与第一个参数匹配的字符串部分，并将第一个参数替换为第二个参数后返回结果。现在让我们回顾一下破坏性和非破坏性方法之间的区别，因为它们与这些替换相关。
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The non-destructive version leaves the original `letters` alone, as you’d expect,
    while the destructive version makes permanent changes to `letters`. The `gsub!`
    method also returns `nil` if it is unable to comply, as shown in irb:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 非破坏性版本会保留原始的`letters`不变，正如你所期望的，而破坏性版本会对`letters`进行永久性更改。`gsub!`方法如果不能执行，也会返回`nil`，如下所示在irb中：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This interlude barely scratches the surface of regular expressions—they’re tremendously
    useful. I’ll certainly explain the specific regexes used in the scripts in this
    book, but there’s a lot more to learn about them. If you want to explore regular
    expressions further, an excellent resource is Jeffrey Friedl’s *Mastering Regular
    Expressions* (O’Reilly, 2006) and its companion website, [http://regex.info](http://regex.info).
    This is the definitive text on the subject of regular expressions. It has a slight
    Perl bias, although its respect for Ruby seems to increase with every new edition.
    Since the implementation of regular expressions in many languages (including Ruby)
    is inspired by Perl, the Perl-specific content is easily transferable to Ruby,
    largely because the two languages’ treatment of regular expressions is so similar
    in the first place.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插曲只是触及了正则表达式的表面——它们非常有用。我肯定会解释这本书中脚本中使用的特定正则表达式，但还有更多关于它们的知识可以学习。如果你想进一步探索正则表达式，一个极好的资源是Jeffrey
    Friedl的*精通正则表达式*（O’Reilly，2006）及其配套网站[http://regex.info](http://regex.info)。这是关于正则表达式的权威文本。它有轻微的Perl倾向，尽管它的Ruby尊重似乎随着每一版的新增而增加。由于许多语言（包括Ruby）中的正则表达式实现都受到Perl的启发，因此Perl特定的内容很容易转移到Ruby上，主要是因为这两种语言在处理正则表达式方面从一开始就非常相似。
- en: How does all this relate to our script, `dos2unix.rb`? The `\r` String stands
    for the carriage return character—the one used on older Macintosh systems to indicate
    a line break. The `\n` String is the newline character, which is used on Unix-like
    systems and after a carriage return on Windows systems to indicate a line break.
    This substitution finds all occurrences of a carriage return, as well as any optional
    newlines that follow it, and replaces them with a single newline.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些与我们的脚本`dos2unix.rb`有什么关系？`\r`字符串代表回车字符——在较老的Macintosh系统中用来表示换行。`\n`字符串是换行字符，在类Unix系统中以及Windows系统中的回车之后用来表示换行。这个替换操作会找到所有回车字符的出现，以及任何可选的新行，并将它们替换为单个换行。
- en: Running the Script
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: Execute this as `ruby -w dos2unix.rb file_to_modify`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以`ruby -w dos2unix.rb file_to_modify`执行此命令。
- en: The Results
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'When I look at my sample file `extras/DOS_file.txt` in my text editor of choice
    (vim), it looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我用我选择的文本编辑器（vim）查看我的样本文件`extras/DOS_file.txt`时，它看起来像这样：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `^M` is how vim displays a `\r` character on my system. After running the
    script with `ruby -w dos2unix.rb extras/DOS_file.txt`, the results are
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`^M`是我系统上vim显示`\r`字符的方式。在用`ruby -w dos2unix.rb extras/DOS_file.txt`运行脚本后，结果是'
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Hacking the Script
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本黑客
- en: What if you want to convert to one of the other line break formats? To convert
    a file to Windows EOL format, you can replace the line at ❸ in `dos2unix.rb` with
    the following line, which essentially means *Replace all occurrences of either
    a carriage return or a newline with a carriage return followed by a new line*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想转换到其他行结束格式怎么办？要将文件转换为Windows EOL格式，你可以在`dos2unix.rb`中的第❸行替换为以下行，这实际上意味着*将所有回车或新行的出现替换为回车后跟新行*。
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For a nostalgic Mac that wants to go back to its pre–OS X line breaks, you can
    convert to the old Apple format by replacing the line at ❸ with this line; this
    will replace all optional carriage returns followed by a mandatory new-line with
    just a carriage return.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于想要回到其预-OS X行结束符的怀旧Mac，你可以通过在第❸行替换以下行来将其转换为旧的Apple格式；这将替换所有可选的回车后跟强制换行，只留下回车。
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The parentheses in a regex are similar to the parentheses in Ruby—they indicate
    a grouping that should be considered a single entity. The *pipe* character (also
    called the *vertical bar*) in a regex indicates a choice between what is on either
    side of it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式中的括号与Ruby中的括号类似——它们表示一个应该被视为单个实体的分组。正则表达式中的*管道*字符（也称为*垂直线*）表示在其两侧之间的选择。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Subexpressions that are grouped together by parentheses within a regular expression
    are also captured into specific variables, depending on the programming language’s
    implementation of regular expressions. You can read more in Friedl’s book if this
    topic interests you*.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*由正则表达式中的括号分组在一起的表达式子集也会被捕获到特定的变量中，这取决于编程语言对正则表达式的实现。如果您对这个主题感兴趣，可以在Friedl的书中了解更多信息*。'
- en: 'You can also accomplish a DOS-to-Unix EOL conversion with a one-liner:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用一行命令完成DOS到Unix EOL的转换：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Sometimes a quick-and-dirty solution is all you need. If you’re curious about
    the implementation of this one-liner, you can consult the Ruby man page (`man
    ruby`) for more about the `-p` flag (which provides a shortcut for dealing with
    the lines of a file), the `-i` flag (which specifies in-place editing of a file),
    and the `-e` flag (which specifies that a command should be executed).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个快速而简单的解决方案就足够了。如果您对这个一行的实现感兴趣，可以查阅Ruby手册页（`man ruby`）了解更多关于 `-p` 标志（提供处理文件行的快捷方式）、`-i`
    标志（指定文件就地编辑）和 `-e` 标志（指定应执行命令）的信息。
- en: '* * *'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[9](#CHP-4-FNOTE-1)]) This is also the reason many Unix commands are so
    short: `rm` for *remove*, `cp` for *copy*, and so on.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[9](#CHP-4-FNOTE-1)]) 这也是为什么许多Unix命令如此简短的原因：`rm` 用于 *删除*，`cp` 用于 *复制*，等等。
- en: '#10 Showing Line Numbers (line_num.rb)'
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#10 显示行号（line_num.rb）'
- en: Another useful trick when dealing with text files is the ability to automatically
    add line numbers to them. Here’s a script that does just that.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文本文件时，另一个有用的技巧是能够自动为它们添加行号。以下是一个执行此操作的脚本。
- en: The Code
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How It Works
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The `get_lines` method (❶) should look familiar at this point, since we’ve
    covered some very similar methods earlier in the book. This method returns an
    Array of lines based on the contents of an input filename. The `get_format` method
    (❷), on the other hand, behaves a bit differently. It returns a single String
    with the form `“%0`*`x`*`d”`, where *`x`* is the number of characters taken up
    by the String representation of the number of members of the `lines` Array. Let’s
    explore the methods a bit in irb:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`get_lines` 方法（❶）应该看起来很熟悉，因为我们已经在本书的早期部分介绍了一些非常类似的方法。另一方面，`get_format`
    方法（❷）的行为略有不同。它返回一个格式为 `“%0`*`x`*`d”` 的单个字符串，其中 *`x`* 是 `lines` 数组的成员数量的字符串表示所占的字符数。让我们在irb中探索一下这些方法：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see that the numeral part of the format changes; it is always equal
    to the digits taken up by the size of the Array. Incidentally, you can also see
    how the Array class implements multiplication. One way would have been to multiply
    each member of the Array by the operand outside of the Array, but that would only
    work when each member of the Array knows how to be multiplied by something. Instead,
    the Array just duplicates itself as many times as the value of the operand. If
    you multiply an Array by one, you should get an equivalent Array.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到格式中的数字部分发生了变化；它始终等于数组大小的数字。顺便说一下，您还可以看到数组类是如何实现乘法的。一种方法是将数组中的每个成员乘以数组外的操作数，但这只有在数组的每个成员都知道如何与某物相乘时才有效。相反，数组会根据操作数的值重复自身。如果您乘以一个数组，您应该得到一个等效的数组。
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We see that we do.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到确实是这样的。
- en: The `get_output` method (❸) starts by establishing the necessary `format` and
    setting a variable called `output` to the empty String. You can guess that we’ll
    be concatenating other Strings onto it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_output` 方法（❸）首先建立必要的 `format` 并将一个名为 `output` 的变量设置为空字符串。您可以猜测我们将在其上连接其他字符串。'
- en: 'We do that at ❺ with a new Array method called `each_with_index`. This method
    is very similar to the `each` method that we’ve already seen, except that it also
    gives us the appropriate index number. We’ll call the given element of `lines`
    by the name `line`, and we’ll refer to the index number as the letter `i`. We
    then use a new method called `sprintf` that formats data into Strings (❻). It
    takes two arguments: the first is the format to use, and the second is the data
    to be formatted. We want to format the index number `i` using the output of the
    `get_format` method.^([[10](#ftn.CHP-4-FNOTE-2)]) The purpose of this operation
    is to calculate the number of digits needed for the maximum line number we’ll
    be displaying (the width), and format each line number according to that width.
    This formatting ensures a prettier output.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一个新的数组方法 `each_with_index` 在❺处这样做。这个方法与我们已经看到的 `each` 方法非常相似，只不过它还给了我们适当的索引号。我们将
    `lines` 的给定元素命名为 `line`，并将索引号称为字母 `i`。然后我们使用一个新的名为 `sprintf` 的方法，该方法将数据格式化为字符串（❻）。它接受两个参数：第一个是要使用的格式，第二个是要格式化的数据。我们想使用
    `get_format` 方法的输出来格式化索引号 `i`.^([[10](#ftn.CHP-4-FNOTE-2)]) 这个操作的目的是为了计算我们将要显示的最大行号所需的数字位数（宽度），并按该宽度格式化每个行号。这种格式化确保了更美观的输出。
- en: Each line of our output consists of `sprintf`’s output, a colon, a space, and
    the original line. All of this happens with the first argument on the command
    line.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输出的每一行都由 `sprintf` 的输出、一个冒号、一个空格和原始行组成。所有这些都是在命令行的第一个参数上发生的。
- en: Running the Script
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: You can run with `ruby -w line_num.rb` *`some_file`*, replacing *`some_file`*
    with the file to which you want to add line numbers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 `ruby -w line_num.rb` *`some_file`* 运行，将 *`some_file`* 替换为你想要添加行号的文件。
- en: The Results
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If your text file has one 100 or more lines, the pre-colon portion of this output
    will automatically add as many characters as needed to accommodate its new requirements.
    That’s all there is to it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的文本文件有一行 100 或更多，输出中冒号之前的部分将自动添加所需的所有字符，以适应其新的要求。这就是全部。
- en: '* * *'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[10](#CHP-4-FNOTE-2)]) Actually, we format the value of *`i`* + 1; we want
    to call the first line number one, but the index value is zero, because computers
    start counting with zero.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[10](#CHP-4-FNOTE-2)]) 实际上，我们格式化 `*`i`* + 1 的值；我们希望将第一行编号为 1，但索引值是 0，因为计算机从
    0 开始计数。
- en: '#11 Wrapping Lines of Text (softwrap.rb)'
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#11 文本换行（softwrap.rb）'
- en: Sometimes you may have a text file that you want to perform whitespace compression
    on, such as converting all repeated spaces into a single space. The script below
    assumes that all double line breaks should be preserved and that all single line
    breaks should be converted into spaces. Each group of repeated spaces should also
    be converted into a single space. Let’s dive right in.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能有一个文本文件，你想对其执行空白压缩，例如将所有重复的空格转换为单个空格。下面的脚本假设所有双行断应该保留，而所有单行断应该转换为空格。每组重复的空格也应该转换为单个空格。让我们直接进入正题。
- en: The Code
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We define a `softwrap` method (❶) that takes a `filename` argument and then
    call `softwrap` on the first command-line argument to the script. The script then
    calls the `readlines` method upon the opening of a file, as we’ve done many times
    already. Usually, as in the previous script, we would assign that result into
    an Array of lines. This time, we call a new method called `inject` that you can
    see takes an argument (the empty String, in our example) and a block; we define
    two variables within the block in the process (❷).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一种名为 `softwrap` 的方法（❶），它接受一个 `filename` 参数，然后在脚本的第一个命令行参数上调用 `softwrap`。脚本随后在文件打开时调用
    `readlines` 方法，就像我们已经多次做的那样。通常，就像在之前的脚本中一样，我们会将结果分配给一个包含行的数组。这次，我们调用一个新的名为 `inject`
    的方法，你可以看到它接受一个参数（在我们的例子中是空字符串）和一个块；在这个过程中我们定义了两个变量（❷）。
- en: In our example, we’re calling those two variables `output` and `line`. The name
    `line` is familiar enough. The name `output` is apt, as the `inject` method assumes
    that the first block-level variable should start with the value of the argument
    to `inject` that preceded the block—the empty String, in this case. The `inject`
    method is remarkable in that modifications of the `output` variable persist from
    each iteration to the next. At ❸ we append `softwrap_line(line)` onto `output`
    each time through the iterations within `inject`, and the appends are remembered
    each time. The `inject` method is very useful for any sort of appending or successive
    operations. Let’s look at how it operates on some numbers in irb.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们称这两个变量为 `output` 和 `line`。`line` 这个名字足够熟悉。`output` 这个名字很合适，因为 `inject`
    方法假定第一个块级变量应该以 `inject` 参数的值开始，这个参数在块之前，在这种情况下是空字符串。`inject` 方法非常出色，因为 `output`
    变量的修改会从每次迭代持续到下一次。在 ❸，我们每次通过 `inject` 内部的迭代将 `softwrap_line(line)` 附加到 `output`
    上，并且每次都会记住这些附加操作。`inject` 方法对于任何类型的附加或连续操作都非常有用。让我们看看它在 irb 中的操作方式。
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On line one we define a variable that holds the digits from one to four. One
    operation that `inject` seems well suited for is adding a list of numbers; we
    do that on line two. The `inject` method can handle any operation, though, so
    let’s try multiplication on line three. When we do this, we get a result of zero.
    The reason is that our initial value for `product` is zero, so any multiplication
    after that will get us nowhere. On line four, we set the initial value to one,
    which is more appropriate for multiplication, and we get a result that makes sense.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们定义了一个变量，它包含了从一到四的数字。`inject` 似乎非常适合执行添加数字列表的操作；我们在第二行这样做。不过，`inject`
    方法可以处理任何操作，所以让我们在第三行尝试乘法。当我们这样做时，我们得到的结果是零。原因是我们的 `product` 初始值是零，所以之后的任何乘法都不会有任何结果。在第四行，我们将初始值设置为
    一，这对于乘法来说更合适，我们得到了一个有意义的 结果。
- en: The `inject` method is your first real taste of *functional programming*, a
    style of programming in which operations are treated as mathematical functions
    and side effects are minimized. We’ll see much more of `inject` and similar methods
    in later chapters. For now, all we need to concern ourselves with is the fact
    that it collects each line, passes `line` through the `softwrap_line` function,
    and then appends the result onto `output`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`inject` 方法是你第一次真正接触到的 *函数式编程*，这是一种编程风格，其中操作被视为数学函数，副作用被最小化。在后面的章节中，我们将看到更多关于
    `inject` 和类似方法的介绍。目前，我们只需要关注这样一个事实：它收集每一行，将 `line` 通过 `softwrap_line` 函数传递，然后将结果附加到
    `output` 上。'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Remember that* side effects *are persistent changes made to something (anything)
    apart from the value returned. In Ruby, methods that have side effects generally
    end with an exclamation mark, as we’ve seen already. Methods with no side effects
    return some value that you requested, but leave the object on which the method
    was called in the same state it was in before you called the method*.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，*副作用是指对除了返回值之外的东西（任何东西）所做的持久性更改。在 Ruby 中，具有副作用的方法通常以感叹号结尾，正如我们之前所看到的。没有副作用的方法返回你请求的某个值，但将方法被调用的对象留在调用方法之前的状态。'
- en: What does `softwrap_line` do? The name suggests that it performs the soft-wrapping
    operation (however we are about to define it) on one line at a time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`softwrap_line` 做什么？这个名字暗示它对每一行执行软换行操作（无论我们即将如何定义它）。'
- en: The method definition starts at ❹, where it takes in a `line`. At ❺, we return
    right away if our new `line` variable is only a carriage return, since this would
    indicate a real break that we want to preserve. In all other cases, we return
    the chomped `line` plus a space character (❻), which is how this script implements
    the actual wrapping. We do this `softwrap_line` operation on every line, appending
    it onto the `inject` ’s `output` variable at ❸ as described earlier. Our block
    for `inject` is of the `do`/`end` variety, rather than one that uses the brace
    characters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义从 ❹ 开始，它接收一个 `line` 参数。在 ❺，如果我们的新 `line` 变量仅是一个回车符，我们就立即返回，因为这表明了一个我们想要保留的实际断行。在其他所有情况下，我们返回被截断的
    `line` 加上一个空格字符（❻），这就是这个脚本实现实际换行的方法。我们对每一行执行 `softwrap_line` 操作，如前所述，将其附加到 `inject`
    的 `output` 变量上，在 ❸ 处。我们的 `inject` 块是 `do`/`end` 类型的，而不是使用花括号的类型。
- en: We see something new at ❽—a method called on the keyword `end`.^([[11](#ftn.CHP-4-FNOTE-3)])
    There’s no reason we shouldn’t see this, though. Everything in Ruby is a object,
    and the the result of our `inject` method is whatever has accumulated into its
    `output` variable. In our script, it’s a String, so the value of our `inject`
    block can respond to any String methods, such as `gsub`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在❽处我们看到一个新的现象——在关键字`end`上调用了一个方法。^([[11](#ftn.CHP-4-FNOTE-3)]) 没有理由我们不应该看到这一点。在Ruby中，一切都是对象，我们`inject`方法的结果就是其`output`变量中累积的内容。在我们的脚本中，它是一个字符串，所以我们的`inject`块可以响应任何字符串方法，例如`gsub`。
- en: The first `gsub` at ❽ searches for any grouping of tab characters (represented
    within the regular expression as `“\t”`) and replaces the set of them with a space.
    The plus sign within the regular expression is similar to the question mark we’ve
    seen before, except that instead of meaning *Zero or more of the preceding thing*
    it means *One or more of the preceding thing*. This regular expression replaces
    one tab with one space, three tabs with one space, and so on. Let’s try something
    similar in irb. I’ll use letters rather than tabs in the irb example because they’ll
    be easy to read in a printed book. The question mark was just for a review and
    to show the difference between it and the plus sign within a regular expression.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❽行上的第一个`gsub`搜索任何制表符字符的分组（在正则表达式中表示为`“\t”`），并将这些制表符替换为一个空格。正则表达式中的加号与之前见过的问号类似，但它的意思不是“前面的东西零个或多个”，而是“前面的东西一个或多个”。这个正则表达式将一个制表符替换为一个空格，三个制表符替换为一个空格，依此类推。让我们在irb中尝试类似的方法。在irb的例子中，我将使用字母而不是制表符，因为在打印的书中更容易阅读。问号只是用来复习，并展示它与正则表达式中的加号的区别。
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So we replace tabs (if there are any) with a space. The output of the first
    `gsub` is also a String, so it can respond to any String methods, such as another
    `gsub`. This time we want to replace any occurrences of one or more spaces with
    a single space—basically just compressing the whitespace. The last line of the
    script at ❼ shows that we do all of this on the first `filename` argument to the
    script.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将制表符（如果有）替换为空格。第一个`gsub`的输出也是一个字符串，所以它可以响应任何字符串方法，例如另一个`gsub`。这次我们想要将一个或多个空格替换为单个空格——基本上就是压缩空白。脚本的第❽行显示，我们是在脚本的第一个`filename`参数上执行所有这些操作。
- en: Running the Script
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: This script is run with `ruby -w softwrap.rb some_file`, where *`some_file`*
    is the file whose whitespace will be compressed. Note that this script does not
    modify the original file, but rather outputs the changed version, just like a
    non-destructive method in Ruby.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本通过`ruby -w softwrap.rb some_file`运行，其中*`some_file`*是要压缩空白的文件。请注意，这个脚本不会修改原始文件，而是输出更改后的版本，就像Ruby中的非破坏性方法一样。
- en: The Results
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'Here’s the result of calling this script on itself:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是调用此脚本自身的输出结果：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Hacking the Script
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: 'The successive `gsub` calls on line ❽ could have been expressed with a more
    complex regular expression instead: `gsub(/(\t| )+/, ‘ ’)`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❽行上的连续`gsub`调用可以用更复杂的正则表达式来表示：`gsub(/(\t| )+/, ‘ ’)`。
- en: '* * *'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[11](#CHP-4-FNOTE-3)]) More precisely, the method is being called on the
    result of the code concluded by `end`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[11](#CHP-4-FNOTE-3)]) 更确切地说，方法是在`end`结束的代码结果上被调用的。
- en: '#12 Counting Words in a File (word_count.rb)'
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#12 文件中单词计数（word_count.rb）'
- en: It’s often handy to know the number of words in a file. Word count is a standard
    feature in word-processing programs, but if you’re not using a word processor,
    obtaining a word count might not be so easy. I originally wrote this script when
    I was working on a project using an XML-based document production system called
    *DocBook* ([http://www.docbook.org](http://www.docbook.org)) and wanted to have
    a word count that roughly corresponded to those you could get from a word processor.
    The Unix command `wc` counts words, but the numbers it reported didn’t necessarily
    match what a word processor might report; the main reason probably had to do with
    issues like whether words with fewer than a certain number of letters should count
    as a “word” in the word processor’s counter. I knew the approximate ratio of the
    word processor’s word count versus the output of `wc` (I call this the *fudge
    factor*), and I could certainly do the math, but I wanted something that would
    do all of this for me automatically. Let’s take a look.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 知道一个文件中的单词数量通常很有用。单词计数是文字处理程序的标准功能，但如果你不使用文字处理器，获取单词计数可能并不容易。我最初编写这个脚本时，我正在使用一个基于
    XML 的文档生成系统 *DocBook* ([http://www.docbook.org](http://www.docbook.org)) 进行项目工作，并希望有一个单词计数，大致相当于从文字处理器中获得的单词计数。Unix
    命令 `wc` 可以计算单词数，但报告的数字不一定与文字处理器报告的数字相符；主要原因可能涉及诸如是否应该将少于一定数量的字母的单词视为文字处理器计数器中的“单词”等问题。我知道文字处理器单词计数与
    `wc` 输出的近似比率（我称之为 *fudge factor*），我当然可以进行数学计算，但我想有一个能自动完成所有这些的脚本。让我们看看。
- en: The Code
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How It Works
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: We start out by adding a new method called `num_matches` to the String class
    (❶). It simply returns the number of times the argument appears within the calling
    String. I also define top-level constants called `BAR_LENGTH` (❷), which is just
    for visual formatting, and `FUDGE_FACTOR` (❸), which I already noted is the ratio
    between the two different word-counting programs I was working with.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先向 String 类添加一个名为 `num_matches` 的新方法（❶）。它简单地返回参数在调用字符串中出现的次数。我还定义了顶级常量 `BAR_LENGTH`（❷），它仅用于视觉格式化，以及
    `FUDGE_FACTOR`（❸），这是我之前提到的两个不同单词计数程序之间的比率。
- en: We then define the `word_count` method (❹), which takes the `files` argument.
    You’ll notice on the last line of the script that this program takes an arbitrary
    number of filenames as its argument, which is different from our earlier scripts
    that would only deal with a single file at a time. The `word_count` method defines
    local variables called `output` and `total_word_count`, setting them to useful
    defaults for a String and an Integer, respectively. We then loop through the files
    (❺), assigning the proper values into `file_word_count` and `output` and accumulating
    each `file_word_count` into the `total_word_count`. The `output` variable now
    has a description of each file’s count. We `return` that, followed by a line consisting
    of the hyphen character multiplied by the `BAR_LENGTH` constant (❻). Multiplication
    of Strings is very similar to multiplication of Arrays, which we’ve already seen.
    We add a String consisting of 20 hyphen characters to the overall expression returned.
    The returned expression closes with the total multiplied by the `FUDGE_FACTOR`
    constant in parentheses.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `word_count` 的方法（❹），它接受 `files` 参数。你会在脚本的最后一行注意到这个程序接受任意数量的文件名作为其参数，这与我们之前的脚本不同，之前的脚本一次只会处理一个文件。`word_count`
    方法定义了局部变量 `output` 和 `total_word_count`，分别将它们设置为 String 和 Integer 的有用默认值。然后我们遍历文件（❺），将适当的值赋给
    `file_word_count` 和 `output`，并将每个 `file_word_count` 累加到 `total_word_count` 中。现在
    `output` 变量包含了每个文件计数的描述。我们 `return` 这个结果，然后是一行由 `BAR_LENGTH` 常量乘以连字符字符（❻）。字符串的乘法与数组的乘法非常相似，我们之前已经见过。我们向整体表达式返回值中添加了一个由
    20 个连字符字符组成的字符串。返回的表达式以括号中的 `total` 乘以 `FUDGE_FACTOR` 常量结束。
- en: Before finishing with this script, we need to understand how it calculates the
    word count for each file. Let’s examine the `word_count_for_file` function (❼).
    It opens by getting the `contents` out of the file being worked on. It then uses
    some quick-and-dirty calls to the `num_matches` method on the `contents` variable
    to get counts for spaces, line breaks, and so on. It then calculates the number
    of words in the `contents` String using those rough numbers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个脚本之前，我们需要了解它是如何计算每个文件的单词计数的。让我们检查 `word_count_for_file` 函数（❼）。它首先从正在处理的文件中获取
    `contents`。然后它使用对 `contents` 变量的 `num_matches` 方法的快速而简单的调用，以获取空格、换行符等的计数。然后它使用这些粗略的数字计算
    `contents` 字符串中的单词数。
- en: There are more accurate ways to count words in a String, many of which use techniques
    described in Jeffrey Friedl’s *Mastering Regular Expressions*. However, this script
    is intended for quick, approximate results, given that it uses a fudge factor.
    This script shows that just adding one new method to an existing class can be
    very handy even for a short, back-of-the-envelope task. We’ll see more of that
    in later scripts, as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串中计数单词有更准确的方法，其中许多方法使用了 Jeffrey Friedl 的 *Mastering Regular Expressions*
    中描述的技术。然而，此脚本旨在提供快速、近似的结果，因为它使用了伪造因子。此脚本表明，只需向现有类添加一个新方法，就可以非常方便地完成短期任务。我们将在后面的脚本中看到更多这样的例子。
- en: Running the Script
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: You can run this script with `ruby -w word_count.rb` *`some_file`*, where *`some_file`*
    is the file whose word count you want to compute.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `ruby -w word_count.rb` *`some_file`* 运行此脚本，其中 *`some_file`* 是您想要计算单词计数的文件。
- en: The Results
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'Here is the result of calling this file on itself:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调用此文件的结果：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice how the script reports both the literal and fudged word counts.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意脚本如何报告字面和伪造的单词计数。
- en: '#13 Word Histogram (most_common_words.rb)'
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#13 单词直方图（most_common_words.rb）'
- en: 'And now for something that most word processors don’t do: finding the most
    commonly used words in a document. Like the previous script, it adds an additional
    “helper” method to an existing built-in class to simplify the job for our new
    main method. Let’s take a look.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看大多数文字处理器都不做的功能：在文档中查找最常用的单词。像之前的脚本一样，它向现有的内置类添加了一个额外的“辅助”方法，以简化我们的新主方法的工作。让我们看看。
- en: The Code
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How It Works
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The new method of Array is called `count_of` (❶); it takes an argument called
    `item` and returns the number of times that `item` is found within the Array in
    question. The default implementation of this method (❷) uses an Array method called
    `grep`, which takes an argument and returns all elements that match that element.
    Since we want the count of items matching the condition (and not those items themselves),
    we call the `size` method on the return value of `grep`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的新方法被称为 `count_of`（❶）；它接受一个名为 `item` 的参数，并返回该 `item` 在所讨论的数组中出现的次数。此方法的默认实现（❷）使用一个名为
    `grep` 的数组方法，该方法接受一个参数并返回所有匹配该元素的元素。由于我们想要匹配条件的项目数量（而不是这些项目本身），我们在 `grep` 的返回值上调用
    `size` 方法。
- en: The line at ❸ shows a way to accomplish the same task using the `inject` method,
    which we’ve already covered.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 行显示了使用 `inject` 方法完成相同任务的方法，我们之前已经介绍过。
- en: At ❹ we define the `most_common_words` method; it takes a mandatory `input`
    argument and an optional `limit` argument, which defaults to 25\. We define a
    new Hash variable called `freq`, which will store the frequency of each word.
    We define an Array called `sample`, which consists of a case-insensitive input,
    broken at each whitespace portion (the `\W` in the regular expression means *any
    whitespace*). We loop through each unique `word` in the sample, adding its frequency
    to the `freq` Hash. I chose to skip the empty string, not counting it as a word
    (❺).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❹ 我们定义了 `most_common_words` 方法；它接受一个必需的 `input` 参数和一个可选的 `limit` 参数，默认为 25。我们定义了一个名为
    `freq` 的新哈希变量，它将存储每个单词的频率。我们定义了一个名为 `sample` 的数组，它由不区分大小写的输入组成，在每个空白部分（正则表达式中的
    `\W` 表示 *任何空白*）处断裂。我们遍历样本中的每个唯一的 `word`，将其频率添加到 `freq` 哈希中。我选择跳过空字符串，不计入单词（❺）。
- en: Once we’ve constructed the `freq` Hash, we want to use our `limit` argument.
    We loop through the keys of `freq` (which are the actual words themselves) and
    sort them by their frequency of appearance (❻). We want to see the most common
    words, rather than the least common words, so we `reverse` that sorted list, and
    `map` an operation onto it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建了 `freq` 哈希，我们想要使用我们的 `limit` 参数。我们遍历 `freq` 的键（即实际的单词本身）并按它们出现的频率排序（❻）。我们想要看到最常见的单词，而不是最不常见的单词，所以我们将排序后的列表
    `reverse`，并对它执行 `map` 操作。
- en: The `map` operation is very common in the world of functional programming. It’s
    often used as an alternative to looping, so in Ruby, we’ll often find that we
    want to use either the `each` method or the `map` method for a given task, depending
    on our needs. Generally, if you want to make destructive changes to a list of
    items, use `each`; if you want to make a new list of transformed items, use `map`.
    Let’s try `map` in irb. I’ve been showing you lots of irb examples with digits,
    so now I’ll show you a quick way to create an Array of them. Ruby has a class
    called *Range*, which indicates the items from a given starting point to a given
    endpoint. We’ll use that class to construct an Array.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 操作在函数式编程的世界中非常常见。它通常用作循环的替代方案，所以在 Ruby 中，我们经常会发现，根据我们的需求，我们可能想要使用 `each`
    方法或 `map` 方法来完成给定的任务。一般来说，如果你想对一系列项目进行破坏性更改，请使用 `each`；如果你想创建一个新列表，其中包含转换后的项目，请使用
    `map`。让我们在 irb 中尝试 `map`。我一直在向你展示很多带有数字的 irb 示例，所以现在我将向你展示一种快速创建数字数组的方法。Ruby 有一个名为
    *Range* 的类，它表示从给定起点到给定终点的项目。我们将使用该类来构建一个数组。'
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, `map` is very convenient for any sort of transformation of a
    list of items that can be expressed with a simple description, such as *double
    all of these things* on line six, or *square all of these things* on line seven.
    Remember that `map` is non-destructive (as shown on line eight) unless you call
    it with the exclamation mark (as shown on lines nine and ten). We’ll `map` an
    operation onto the words, sorted in `reverse` order by frequency of appearance
    in our sample text. The operation to be mapped (❼) is the outputting of a String
    consisting of the `word` itself followed by a space character, followed by the
    frequency of that `word`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`map` 对于任何可以用简单描述表达的项目列表的转换都非常方便，例如在第六行上的 *将这些所有东西都加倍*，或者在第七行上的 *将这些所有东西都平方*。请记住，`map`
    是非破坏性的（如第八行所示），除非你用感叹号调用它（如第九行和第十行所示）。我们将按频率出现顺序对样本文本中的单词进行排序，并将操作映射到单词上。要映射的操作（❼）是输出一个由
    `word` 本身、一个空格字符和该 `word` 的频率组成的字符串。
- en: All of this occurs within the assignment into the `words` variable on the same
    line as ❺, so each member of the Array called `words` is a String that is the
    result of the ❼ operation. At ❽, we `return` a subsection of the `words` Array,
    starting at the beginning, and limit it to a length equal to the `limit` argument.
    Since the output of the `most_common_words` method is an Array and we want to
    print it as a String, we do a `join` with a newline at ❾, making each Array item
    a separate line.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在与❺同一行的 `words` 变量的赋值中发生，因此 `words` 数组中的每个成员都是一个字符串，它是 ❷ 操作的结果。在❽处，我们返回
    `words` 数组的子集，从开头开始，并限制其长度等于 `limit` 参数。由于 `most_common_words` 方法的输出是一个数组，而我们想将其作为字符串打印出来，所以在❾处我们使用换行符进行
    `join`，使每个数组项成为单独的一行。
- en: Running the Script
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: We call this script with `ruby most_common_words.rb filename_to_analyze`, calling
    `readlines.to_s` on the `filename` argument, which provides the input to analyze.
    Let’s try it on itself.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ruby most_common_words.rb filename_to_analyze` 来调用此脚本，对 `filename` 参数调用
    `readlines.to_s`，这提供了要分析输入。让我们尝试用它自己来试试。
- en: The Results
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Hacking the Script
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: 'Just as an aside, you could also implement `count_of` using this line:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，你也可以使用此行来实现 `count_of`：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '#14 Rotating Characters in a String (rotate.rb)'
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#14 在字符串中旋转字符（rotate.rb）'
- en: We’ll close with a simple program that rotates the order of characters within
    a String. We’ll accomplish this via a method that takes a character (meaning a
    String of length one) argument. The String to be rotated will try to keep rotating
    until the character argument appears at index `0`. If the character is not found
    at all, it will return `nil`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个简单的程序结束，该程序将旋转字符串中字符的顺序。我们将通过一个接受一个字符（意味着长度为1的字符串）参数的方法来完成此操作。要旋转的字符串将尝试旋转，直到字符参数出现在索引
    `0` 处。如果字符根本找不到，它将返回 `nil`。
- en: The Code
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How It Works
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: This program introduces a concept called *recursion*, which (like `map`) is
    used frequently in functional programming, often as an alternative to looping.
    A *recursive operation* is one that is partly defined in terms of itself. Let’s
    explore the concept in our `rotate.rb` script.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本程序介绍了一个名为 *递归* 的概念，它（就像 `map` 一样）在函数式编程中经常被使用，通常作为循环的替代方案。一个 *递归操作* 是部分定义为自己本身的操作。让我们在我们的
    `rotate.rb` 脚本中探索这个概念。
- en: The definition of the main `rotate` method that we add to the String object
    is at ❶. I said earlier that if the character argument (called `char`) is not
    found within the main String (here called `self`), the rotate method will return
    `nil` (❷). If `char` is the initial character within the String, we don’t need
    to do any rotating, so it will return the main String under those conditions (❸).
    The numeral `0` within braces is not an anonymous Array—it’s a method of `self`
    that returns the first character of a String. We call that method on both the
    `self` String and the single-character String `char`. When those two Strings are
    equal, we know that the `self` String starts with the requested rotation character.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到字符串对象中的主要`rotate`方法的定义在❶处。我之前说过，如果字符参数（称为`char`）在主字符串（这里称为`self`）中找不到，`rotate`方法将返回`nil`（❷）。如果`char`是字符串中的初始字符，我们不需要进行任何旋转，所以它将在这些条件下返回主字符串（❸）。大括号内的数字`0`不是一个匿名数组——它是`self`的方法，用于返回字符串的第一个字符。我们在`self`字符串和单字符字符串`char`上调用该方法。当这两个字符串相等时，我们知道`self`字符串以请求的旋转字符开头。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*We use an index of zero within the braces to return the first character in
    the String on line ❸ because Ruby (like many languages) starts counting indexes
    at zero, not one*.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们在大括号内使用零索引来返回第❸行的字符串中的第一个字符，因为Ruby（像许多语言一样）从零开始计数索引，而不是从一*。'
- en: We know that if we’ve gotten this far without returning, we have a String that
    is eligible for rotation (because it contains `char`), and needs to be rotated
    to match (because it doesn’t start with `char`). We perform the rotation by defining
    a new variable called `chars` (❹), which is an Array of each character within
    the String. We use the `pop` method at ❺ to remove the last character from `chars`,
    remembering that `pop` is destructive (despite the lack of an exclamation mark,
    for historical reasons). The `chars` Array now contains all the characters except
    the one that was just `pop`ped off. If we add those Arrays together, putting the
    Array containing the `pop`ped character first, we’ve just created a new Array
    in which the last member has been moved from the end to the front, shifting all
    other members back.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，如果我们没有返回就到这里，我们就有一个符合条件的字符串，可以进行旋转（因为它包含`char`），并且需要旋转以匹配（因为它不以`char`开头）。我们通过定义一个新的变量`chars`（❹）来执行旋转，它是一个包含字符串中每个字符的数组。我们在❺处使用`pop`方法来从`chars`中移除最后一个字符，记住`pop`是破坏性的（尽管没有感叹号，但出于历史原因）。现在`chars`数组包含除了刚刚`pop`出来的字符之外的所有字符。如果我们把这些数组加在一起，把包含`pop`出来的字符的数组放在前面，我们就创建了一个新的数组，其中最后一个成员已经被从末尾移动到前面，其他成员都向后移动。
- en: We wrap the `pop`ped character in brackets so that we can more easily add the
    two Arrays (the `pop`ped off character and the remaining characters, respectively).
    Since the `rotate` method will eventually return a String, we `join` our Array
    elements with an empty String separator. This produces a String that has been
    rotated once. Are we done? Not really.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`pop`出来的字符用括号括起来，这样我们就可以更容易地添加两个数组（分别是从`pop`出来的字符和剩余的字符）。由于`rotate`方法最终会返回一个字符串，我们使用空字符串作为分隔符来`join`我们的数组元素。这会产生一个旋转过一次的字符串。我们完成了吗？其实并没有。
- en: Recursion
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归
- en: The rotation works well, but it might not be enough. What if we need to `rotate`
    multiple characters before we find a match? There’s an easy way to do that; it’s
    called the `rotate` method—you know, the method we’re still in the process of
    defining. We can just call `rotate` on our newly created String.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转工作得很好，但可能还不够。如果我们需要在找到匹配之前旋转多个字符怎么办？有一个简单的方法来做这件事；它被称为`rotate`方法——你知道的，我们还在定义过程中的方法。我们只需在我们的新创建的字符串上调用`rotate`。
- en: We already know that our newly created String will pass the test at ❷. We’re
    mainly interested in whether or not it needs further rotation. That’s the test
    at ❸. If only one rotation was needed, this second call to the `rotate` method
    will return the newly created String, and since the second call to `rotate` was
    within a `return` call on the line at ❺, the main call to `rotate` will `return`
    that value, as well.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们新创建的字符串会在❷处通过测试。我们主要感兴趣的是它是否需要进一步的旋转。这就是❸处的测试。如果只需要一次旋转，这个`rotate`方法的第二次调用将返回新创建的字符串，并且由于在❺行的`return`调用中进行了第二次`rotate`调用，主要的`rotate`调用也将返回这个值。
- en: If only one rotation was not enough to find a match, our second call to the
    `rotate` method will do the same shifting of characters (starting at ❹) that we
    just discussed, culminating in yet another call to `rotate`, this time on a String
    that has been rotated two characters’ worth, and so on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一次旋转不足以找到匹配项，我们对`rotate`方法的第二次调用将执行我们刚才讨论的相同字符移动（从❹开始），最终又调用一次`rotate`，这次是在旋转了两个字符的字符串上，依此类推。
- en: Each successive time `rotate` is called, the String to be operated on is one
    step closer to our desired result. This is very common in recursion, which we
    will be discussing in greater depth in later chapters. As you can see at ❻, we
    also define a destructive version called `rotate!`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`rotate`时，要操作的字符串都会更接近我们期望的结果。这在递归中非常常见，我们将在后面的章节中更深入地讨论。正如您在❻中看到的，我们还定义了一个破坏性版本，称为`rotate!`。
- en: Running the Script
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: Let’s look at some output using irb with `irb -r rotate.rb`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`irb -r rotate.rb`的irb命令的输出。
- en: The Results
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In each case, the String on which `rotate` is called has its characters shifted
    until the character asked for is the first character in the String. That’s it
    for this chapter’s scripts.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，被`rotate`方法调用的字符串中的字符都会移动，直到所需的字符成为字符串的第一个字符。这就是本章脚本的结束。
- en: Chapter Recap
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章回顾
- en: What was new in this chapter?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有哪些新内容？
- en: End-of-line differences among operating systems
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统之间的换行符差异
- en: Regular expressions, including the `?` counter
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式，包括`?`计数器
- en: The `sprintf` method
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sprintf`方法'
- en: Multiplication of Arrays
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的乘法
- en: The `inject` method
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inject`方法'
- en: Regular expressions with the `+` counter
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`+`计数器的正则表达式
- en: Objects as the results of blocks
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块的结果作为对象
- en: Calling successive methods on the output of methods (“chaining” methods)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法输出上连续调用方法（“方法链”）
- en: Using new methods of Open Classes in quick scripts
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在快速脚本中使用Open Classes的新方法
- en: Multiplication of Strings
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的乘法
- en: The `grep` method
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep`方法'
- en: The `map` method
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`方法'
- en: The Range class
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Range类
- en: Recursion
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: That’s quite a bit, including some important new functional concepts like recursion
    and a few very handy functional methods. You’ll need these concepts as we move
    on. Let’s proceed to some more complex treatment of numbers in [Chapter 5](ch05.html
    "Chapter 5. Number Utilities").
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括很多内容，包括一些重要的新功能概念，如递归和一些非常实用的功能方法。随着我们继续前进，您将需要这些概念。让我们继续到第5章（[Chapter 5](ch05.html
    "Chapter 5. Number Utilities")）中更复杂的数字处理。
