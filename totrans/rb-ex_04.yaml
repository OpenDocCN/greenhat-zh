- en: Chapter 4. Text Manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Text is the basic format for storing configuration data, web content, email,
    as well as data written in XML (eXtensible Markup Language) and YAML (YAML Ain’t
    Markup Language) which we’ll be looking at in greater detail later. It’s important
    for a programming language to deal with text easily and efficiently. Luckily,
    Ruby meets this requirement. This chapter includes several scripts that demonstrate
    Ruby’s approach to some common text-oriented problems.
  prefs: []
  type: TYPE_NORMAL
- en: '#9 End-of-Line Conversion (dos2unix.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve never had to deal with end-of-line (EOL) differences among operating
    systems, consider yourself fortunate. Microsoft, Apple, and the various Unix-like
    operating systems (such as the BSDs and GNU/Linux systems) all disagree about
    how a text file should show the end of a line. This is further complicated by
    Apple’s transition to a Unix-like operating system with Mac OS X, which is very
    similar to FreeBSD. Unix-like systems mark the end of a line with the *line feed*
    character (also called *newline*); in interfaces that predate the cathode-ray
    tube (CRT), this character indicated that the paper should move up a line so that
    there would be more blank paper on which to print. On the other hand, older Macintosh
    systems (pre–Mac OS X) indicated the end of a line with the *carriage return*
    character, which indicated that the printer should move back to the left side
    to start printing again (this assumes you are using a language that is written
    left to right, like English). Windows (and DOS) systems, on the third hand, mark
    the end of a line with a carriage return followed by a line feed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Some Internet protocols also use the Windows EOL convention, despite often
    being hosted on Unix-like machines. Go figure*.'
  prefs: []
  type: TYPE_NORMAL
- en: Why the difference? One could argue that the Windows approach makes the most
    sense—if we’re modeling the physical action of something like a typewriter, then
    both a carriage return and a line feed would be needed. However, the Unix-like
    and Macintosh approaches have the benefit of only using one character. This is
    an important savings, given how often newlines appear in text documents, and it
    was even more important in the early days of computers when both RAM and storage
    were much more limited and expensive than they are now.^([[9](#ftn.CHP-4-FNOTE-1)])
  prefs: []
  type: TYPE_NORMAL
- en: Today, most text editors and similar programs can deal with these differences
    without too much difficulty, so the end-of-line compatibility problem is generally
    no more than a nuisance. But why put up with a nuisance when you don’t have to?
    We can write a Ruby program that converts DOS or old-style Mac EOLs to Unix EOLs
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: My pro-Unix biases are clear from both the name and purpose of this program.
    Let’s see what it does. At ❶, we start looping through the arguments to the script,
    calling each `filename` in turn. We open and close that argument (currently called
    `filename`) as we’ve done before, reading its contents into the creatively named
    variable `contents`. We do some magic with `gsub!` at ❸, and then write `contents`
    into a new file (❹) called `replace_file`. What’s the magic at ❸? Let’s look at
    it again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We’re calling a method called `gsub!` on our `contents` String. We know that
    `gsub!` (which stands for *global substitution*) is a destructive method because
    of its exclamation-mark ending, and it looks like it takes two arguments. The
    first argument is enclosed in regular slashes, and the second argument is a newline
    String. The first argument is a *regular expression*, which is a special kind
    of variable that can describe the contents of a piece of text without knowing
    everything about it. Regular expressions (*regexes* for short) allow you to test
    for conditions like *Does this text consist entirely of digits?*, which you could
    imagine might be useful before using the `to_i` method of a String. Regexes also
    allow tests like *Are there exactly seven words in the text?* or *Do all words
    in this text start with a capital letter?*, as well as many others.
  prefs: []
  type: TYPE_NORMAL
- en: Regexes accomplish tasks by defining descriptors for characters as well as groupings
    and the number of occurrences of those characters. As you can see in the code,
    regexes are delineated with slashes. This practice of using slashes is not specific
    to Ruby; it is common in other languages as well. The question mark in the regex
    does not mean a literal question mark appearing in the text; instead, it means
    that whatever preceded it is optional, occurring zero or more times. Let’s try
    out some regexes in irb. We’ll use a new operator called `=~`, which is similar
    to `==`. Instead of testing for exact equality, though, it tests whether or not
    the regular expression matches any part of the String we call it on. It returns
    the first point at which a match occurs if the question the regex represents (i.e.,
    *Does this text consist entirely of digits?*) is true for that String; it returns
    `nil` if there is no match.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have our String, `letters`, which is just the first five letters of the alphabet.
    We then test whether the letter *a* appears anywhere in `letters`. It does, right
    at the beginning, so our test returns zero. Why? Because that is the index within
    the String where the first match occurs—remember that we start counting with zero,
    not one. Since the next letter is *b*, when we test for the presence of *b* within
    `letters`, we should get a result that is one higher than the value when we tested
    for *a*. We do. Jumping ahead to the letter *e*, we have a match at the last index,
    which is the fifth letter and has the index of four, again because we start counting
    with zero. When we test for a letter that does not appear in `letters`, we get
    the return value `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: That’s simple matching. Now let’s use that question mark.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: At first, line six seems similar to line two. Line seven is more interesting,
    in that the optional second letter is a new letter that does not appear in `letters`
    at all. In both cases, the second letter precedes a question mark, which makes
    it optional. On line six, we are asking if our String (consisting of the first
    five letters) has an *a* followed by zero or more *a*s. It does, starting at index
    zero, so that is our return value. We then ask if our String has an *a* followed
    by zero or more *x*s. It does, starting at index zero. Let’s continue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Line eight asks if `letters` has an *a* followed by any optional *b*s, which
    it does at index zero. Line nine asks if `letters` has a *b* followed by any optional
    *c* s, which is does at index one. Line ten asks if `letters` has any optional
    *b*s, which it does at index zero. The lesson is clear—matching optional characters
    is very enthusiastic, and the complete absence of a character matches zero or
    more occurrences of any character. Be very careful with your use of the question
    mark, especially as a regex argument used by a destructive method. Here’s another
    demonstration of a match for zero occurrences of a character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There’s nothing at the beginning of `letters`. Matching on nothing is conceptually
    odd, but it can be very useful when you want to break a String into an Array of
    each of its characters. You may recall we used the `split` method matching the
    empty string in our script `palindrome2.rb` ([Chapter 3](ch03.html "Chapter 3. Programmer
    Utilities")) to deal with each letter in the String in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ve done our matching. I said earlier that `gsub` stands for *global substitution*,
    so let’s do some substituting, again in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can see that `gsub` finds the portion of the String that matches the first
    argument and returns a result in which the first argument is replaced by the second
    argument. Now let’s review the differences between destructive and non-destructive
    methods, as they relate to these substitutions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The non-destructive version leaves the original `letters` alone, as you’d expect,
    while the destructive version makes permanent changes to `letters`. The `gsub!`
    method also returns `nil` if it is unable to comply, as shown in irb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This interlude barely scratches the surface of regular expressions—they’re tremendously
    useful. I’ll certainly explain the specific regexes used in the scripts in this
    book, but there’s a lot more to learn about them. If you want to explore regular
    expressions further, an excellent resource is Jeffrey Friedl’s *Mastering Regular
    Expressions* (O’Reilly, 2006) and its companion website, [http://regex.info](http://regex.info).
    This is the definitive text on the subject of regular expressions. It has a slight
    Perl bias, although its respect for Ruby seems to increase with every new edition.
    Since the implementation of regular expressions in many languages (including Ruby)
    is inspired by Perl, the Perl-specific content is easily transferable to Ruby,
    largely because the two languages’ treatment of regular expressions is so similar
    in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: How does all this relate to our script, `dos2unix.rb`? The `\r` String stands
    for the carriage return character—the one used on older Macintosh systems to indicate
    a line break. The `\n` String is the newline character, which is used on Unix-like
    systems and after a carriage return on Windows systems to indicate a line break.
    This substitution finds all occurrences of a carriage return, as well as any optional
    newlines that follow it, and replaces them with a single newline.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute this as `ruby -w dos2unix.rb file_to_modify`.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When I look at my sample file `extras/DOS_file.txt` in my text editor of choice
    (vim), it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `^M` is how vim displays a `\r` character on my system. After running the
    script with `ruby -w dos2unix.rb extras/DOS_file.txt`, the results are
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if you want to convert to one of the other line break formats? To convert
    a file to Windows EOL format, you can replace the line at ❸ in `dos2unix.rb` with
    the following line, which essentially means *Replace all occurrences of either
    a carriage return or a newline with a carriage return followed by a new line*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For a nostalgic Mac that wants to go back to its pre–OS X line breaks, you can
    convert to the old Apple format by replacing the line at ❸ with this line; this
    will replace all optional carriage returns followed by a mandatory new-line with
    just a carriage return.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The parentheses in a regex are similar to the parentheses in Ruby—they indicate
    a grouping that should be considered a single entity. The *pipe* character (also
    called the *vertical bar*) in a regex indicates a choice between what is on either
    side of it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Subexpressions that are grouped together by parentheses within a regular expression
    are also captured into specific variables, depending on the programming language’s
    implementation of regular expressions. You can read more in Friedl’s book if this
    topic interests you*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also accomplish a DOS-to-Unix EOL conversion with a one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes a quick-and-dirty solution is all you need. If you’re curious about
    the implementation of this one-liner, you can consult the Ruby man page (`man
    ruby`) for more about the `-p` flag (which provides a shortcut for dealing with
    the lines of a file), the `-i` flag (which specifies in-place editing of a file),
    and the `-e` flag (which specifies that a command should be executed).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[9](#CHP-4-FNOTE-1)]) This is also the reason many Unix commands are so
    short: `rm` for *remove*, `cp` for *copy*, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '#10 Showing Line Numbers (line_num.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another useful trick when dealing with text files is the ability to automatically
    add line numbers to them. Here’s a script that does just that.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `get_lines` method (❶) should look familiar at this point, since we’ve
    covered some very similar methods earlier in the book. This method returns an
    Array of lines based on the contents of an input filename. The `get_format` method
    (❷), on the other hand, behaves a bit differently. It returns a single String
    with the form `“%0`*`x`*`d”`, where *`x`* is the number of characters taken up
    by the String representation of the number of members of the `lines` Array. Let’s
    explore the methods a bit in irb:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the numeral part of the format changes; it is always equal
    to the digits taken up by the size of the Array. Incidentally, you can also see
    how the Array class implements multiplication. One way would have been to multiply
    each member of the Array by the operand outside of the Array, but that would only
    work when each member of the Array knows how to be multiplied by something. Instead,
    the Array just duplicates itself as many times as the value of the operand. If
    you multiply an Array by one, you should get an equivalent Array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We see that we do.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_output` method (❸) starts by establishing the necessary `format` and
    setting a variable called `output` to the empty String. You can guess that we’ll
    be concatenating other Strings onto it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do that at ❺ with a new Array method called `each_with_index`. This method
    is very similar to the `each` method that we’ve already seen, except that it also
    gives us the appropriate index number. We’ll call the given element of `lines`
    by the name `line`, and we’ll refer to the index number as the letter `i`. We
    then use a new method called `sprintf` that formats data into Strings (❻). It
    takes two arguments: the first is the format to use, and the second is the data
    to be formatted. We want to format the index number `i` using the output of the
    `get_format` method.^([[10](#ftn.CHP-4-FNOTE-2)]) The purpose of this operation
    is to calculate the number of digits needed for the maximum line number we’ll
    be displaying (the width), and format each line number according to that width.
    This formatting ensures a prettier output.'
  prefs: []
  type: TYPE_NORMAL
- en: Each line of our output consists of `sprintf`’s output, a colon, a space, and
    the original line. All of this happens with the first argument on the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can run with `ruby -w line_num.rb` *`some_file`*, replacing *`some_file`*
    with the file to which you want to add line numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If your text file has one 100 or more lines, the pre-colon portion of this output
    will automatically add as many characters as needed to accommodate its new requirements.
    That’s all there is to it.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[10](#CHP-4-FNOTE-2)]) Actually, we format the value of *`i`* + 1; we want
    to call the first line number one, but the index value is zero, because computers
    start counting with zero.
  prefs: []
  type: TYPE_NORMAL
- en: '#11 Wrapping Lines of Text (softwrap.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you may have a text file that you want to perform whitespace compression
    on, such as converting all repeated spaces into a single space. The script below
    assumes that all double line breaks should be preserved and that all single line
    breaks should be converted into spaces. Each group of repeated spaces should also
    be converted into a single space. Let’s dive right in.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We define a `softwrap` method (❶) that takes a `filename` argument and then
    call `softwrap` on the first command-line argument to the script. The script then
    calls the `readlines` method upon the opening of a file, as we’ve done many times
    already. Usually, as in the previous script, we would assign that result into
    an Array of lines. This time, we call a new method called `inject` that you can
    see takes an argument (the empty String, in our example) and a block; we define
    two variables within the block in the process (❷).
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we’re calling those two variables `output` and `line`. The name
    `line` is familiar enough. The name `output` is apt, as the `inject` method assumes
    that the first block-level variable should start with the value of the argument
    to `inject` that preceded the block—the empty String, in this case. The `inject`
    method is remarkable in that modifications of the `output` variable persist from
    each iteration to the next. At ❸ we append `softwrap_line(line)` onto `output`
    each time through the iterations within `inject`, and the appends are remembered
    each time. The `inject` method is very useful for any sort of appending or successive
    operations. Let’s look at how it operates on some numbers in irb.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: On line one we define a variable that holds the digits from one to four. One
    operation that `inject` seems well suited for is adding a list of numbers; we
    do that on line two. The `inject` method can handle any operation, though, so
    let’s try multiplication on line three. When we do this, we get a result of zero.
    The reason is that our initial value for `product` is zero, so any multiplication
    after that will get us nowhere. On line four, we set the initial value to one,
    which is more appropriate for multiplication, and we get a result that makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: The `inject` method is your first real taste of *functional programming*, a
    style of programming in which operations are treated as mathematical functions
    and side effects are minimized. We’ll see much more of `inject` and similar methods
    in later chapters. For now, all we need to concern ourselves with is the fact
    that it collects each line, passes `line` through the `softwrap_line` function,
    and then appends the result onto `output`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Remember that* side effects *are persistent changes made to something (anything)
    apart from the value returned. In Ruby, methods that have side effects generally
    end with an exclamation mark, as we’ve seen already. Methods with no side effects
    return some value that you requested, but leave the object on which the method
    was called in the same state it was in before you called the method*.'
  prefs: []
  type: TYPE_NORMAL
- en: What does `softwrap_line` do? The name suggests that it performs the soft-wrapping
    operation (however we are about to define it) on one line at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The method definition starts at ❹, where it takes in a `line`. At ❺, we return
    right away if our new `line` variable is only a carriage return, since this would
    indicate a real break that we want to preserve. In all other cases, we return
    the chomped `line` plus a space character (❻), which is how this script implements
    the actual wrapping. We do this `softwrap_line` operation on every line, appending
    it onto the `inject` ’s `output` variable at ❸ as described earlier. Our block
    for `inject` is of the `do`/`end` variety, rather than one that uses the brace
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: We see something new at ❽—a method called on the keyword `end`.^([[11](#ftn.CHP-4-FNOTE-3)])
    There’s no reason we shouldn’t see this, though. Everything in Ruby is a object,
    and the the result of our `inject` method is whatever has accumulated into its
    `output` variable. In our script, it’s a String, so the value of our `inject`
    block can respond to any String methods, such as `gsub`.
  prefs: []
  type: TYPE_NORMAL
- en: The first `gsub` at ❽ searches for any grouping of tab characters (represented
    within the regular expression as `“\t”`) and replaces the set of them with a space.
    The plus sign within the regular expression is similar to the question mark we’ve
    seen before, except that instead of meaning *Zero or more of the preceding thing*
    it means *One or more of the preceding thing*. This regular expression replaces
    one tab with one space, three tabs with one space, and so on. Let’s try something
    similar in irb. I’ll use letters rather than tabs in the irb example because they’ll
    be easy to read in a printed book. The question mark was just for a review and
    to show the difference between it and the plus sign within a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So we replace tabs (if there are any) with a space. The output of the first
    `gsub` is also a String, so it can respond to any String methods, such as another
    `gsub`. This time we want to replace any occurrences of one or more spaces with
    a single space—basically just compressing the whitespace. The last line of the
    script at ❼ shows that we do all of this on the first `filename` argument to the
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This script is run with `ruby -w softwrap.rb some_file`, where *`some_file`*
    is the file whose whitespace will be compressed. Note that this script does not
    modify the original file, but rather outputs the changed version, just like a
    non-destructive method in Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the result of calling this script on itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The successive `gsub` calls on line ❽ could have been expressed with a more
    complex regular expression instead: `gsub(/(\t| )+/, ‘ ’)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[11](#CHP-4-FNOTE-3)]) More precisely, the method is being called on the
    result of the code concluded by `end`.
  prefs: []
  type: TYPE_NORMAL
- en: '#12 Counting Words in a File (word_count.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s often handy to know the number of words in a file. Word count is a standard
    feature in word-processing programs, but if you’re not using a word processor,
    obtaining a word count might not be so easy. I originally wrote this script when
    I was working on a project using an XML-based document production system called
    *DocBook* ([http://www.docbook.org](http://www.docbook.org)) and wanted to have
    a word count that roughly corresponded to those you could get from a word processor.
    The Unix command `wc` counts words, but the numbers it reported didn’t necessarily
    match what a word processor might report; the main reason probably had to do with
    issues like whether words with fewer than a certain number of letters should count
    as a “word” in the word processor’s counter. I knew the approximate ratio of the
    word processor’s word count versus the output of `wc` (I call this the *fudge
    factor*), and I could certainly do the math, but I wanted something that would
    do all of this for me automatically. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start out by adding a new method called `num_matches` to the String class
    (❶). It simply returns the number of times the argument appears within the calling
    String. I also define top-level constants called `BAR_LENGTH` (❷), which is just
    for visual formatting, and `FUDGE_FACTOR` (❸), which I already noted is the ratio
    between the two different word-counting programs I was working with.
  prefs: []
  type: TYPE_NORMAL
- en: We then define the `word_count` method (❹), which takes the `files` argument.
    You’ll notice on the last line of the script that this program takes an arbitrary
    number of filenames as its argument, which is different from our earlier scripts
    that would only deal with a single file at a time. The `word_count` method defines
    local variables called `output` and `total_word_count`, setting them to useful
    defaults for a String and an Integer, respectively. We then loop through the files
    (❺), assigning the proper values into `file_word_count` and `output` and accumulating
    each `file_word_count` into the `total_word_count`. The `output` variable now
    has a description of each file’s count. We `return` that, followed by a line consisting
    of the hyphen character multiplied by the `BAR_LENGTH` constant (❻). Multiplication
    of Strings is very similar to multiplication of Arrays, which we’ve already seen.
    We add a String consisting of 20 hyphen characters to the overall expression returned.
    The returned expression closes with the total multiplied by the `FUDGE_FACTOR`
    constant in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Before finishing with this script, we need to understand how it calculates the
    word count for each file. Let’s examine the `word_count_for_file` function (❼).
    It opens by getting the `contents` out of the file being worked on. It then uses
    some quick-and-dirty calls to the `num_matches` method on the `contents` variable
    to get counts for spaces, line breaks, and so on. It then calculates the number
    of words in the `contents` String using those rough numbers.
  prefs: []
  type: TYPE_NORMAL
- en: There are more accurate ways to count words in a String, many of which use techniques
    described in Jeffrey Friedl’s *Mastering Regular Expressions*. However, this script
    is intended for quick, approximate results, given that it uses a fudge factor.
    This script shows that just adding one new method to an existing class can be
    very handy even for a short, back-of-the-envelope task. We’ll see more of that
    in later scripts, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can run this script with `ruby -w word_count.rb` *`some_file`*, where *`some_file`*
    is the file whose word count you want to compute.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the result of calling this file on itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the script reports both the literal and fudged word counts.
  prefs: []
  type: TYPE_NORMAL
- en: '#13 Word Histogram (most_common_words.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'And now for something that most word processors don’t do: finding the most
    commonly used words in a document. Like the previous script, it adds an additional
    “helper” method to an existing built-in class to simplify the job for our new
    main method. Let’s take a look.'
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new method of Array is called `count_of` (❶); it takes an argument called
    `item` and returns the number of times that `item` is found within the Array in
    question. The default implementation of this method (❷) uses an Array method called
    `grep`, which takes an argument and returns all elements that match that element.
    Since we want the count of items matching the condition (and not those items themselves),
    we call the `size` method on the return value of `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ❸ shows a way to accomplish the same task using the `inject` method,
    which we’ve already covered.
  prefs: []
  type: TYPE_NORMAL
- en: At ❹ we define the `most_common_words` method; it takes a mandatory `input`
    argument and an optional `limit` argument, which defaults to 25\. We define a
    new Hash variable called `freq`, which will store the frequency of each word.
    We define an Array called `sample`, which consists of a case-insensitive input,
    broken at each whitespace portion (the `\W` in the regular expression means *any
    whitespace*). We loop through each unique `word` in the sample, adding its frequency
    to the `freq` Hash. I chose to skip the empty string, not counting it as a word
    (❺).
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve constructed the `freq` Hash, we want to use our `limit` argument.
    We loop through the keys of `freq` (which are the actual words themselves) and
    sort them by their frequency of appearance (❻). We want to see the most common
    words, rather than the least common words, so we `reverse` that sorted list, and
    `map` an operation onto it.
  prefs: []
  type: TYPE_NORMAL
- en: The `map` operation is very common in the world of functional programming. It’s
    often used as an alternative to looping, so in Ruby, we’ll often find that we
    want to use either the `each` method or the `map` method for a given task, depending
    on our needs. Generally, if you want to make destructive changes to a list of
    items, use `each`; if you want to make a new list of transformed items, use `map`.
    Let’s try `map` in irb. I’ve been showing you lots of irb examples with digits,
    so now I’ll show you a quick way to create an Array of them. Ruby has a class
    called *Range*, which indicates the items from a given starting point to a given
    endpoint. We’ll use that class to construct an Array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `map` is very convenient for any sort of transformation of a
    list of items that can be expressed with a simple description, such as *double
    all of these things* on line six, or *square all of these things* on line seven.
    Remember that `map` is non-destructive (as shown on line eight) unless you call
    it with the exclamation mark (as shown on lines nine and ten). We’ll `map` an
    operation onto the words, sorted in `reverse` order by frequency of appearance
    in our sample text. The operation to be mapped (❼) is the outputting of a String
    consisting of the `word` itself followed by a space character, followed by the
    frequency of that `word`.
  prefs: []
  type: TYPE_NORMAL
- en: All of this occurs within the assignment into the `words` variable on the same
    line as ❺, so each member of the Array called `words` is a String that is the
    result of the ❼ operation. At ❽, we `return` a subsection of the `words` Array,
    starting at the beginning, and limit it to a length equal to the `limit` argument.
    Since the output of the `most_common_words` method is an Array and we want to
    print it as a String, we do a `join` with a newline at ❾, making each Array item
    a separate line.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We call this script with `ruby most_common_words.rb filename_to_analyze`, calling
    `readlines.to_s` on the `filename` argument, which provides the input to analyze.
    Let’s try it on itself.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Hacking the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as an aside, you could also implement `count_of` using this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '#14 Rotating Characters in a String (rotate.rb)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll close with a simple program that rotates the order of characters within
    a String. We’ll accomplish this via a method that takes a character (meaning a
    String of length one) argument. The String to be rotated will try to keep rotating
    until the character argument appears at index `0`. If the character is not found
    at all, it will return `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How It Works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This program introduces a concept called *recursion*, which (like `map`) is
    used frequently in functional programming, often as an alternative to looping.
    A *recursive operation* is one that is partly defined in terms of itself. Let’s
    explore the concept in our `rotate.rb` script.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the main `rotate` method that we add to the String object
    is at ❶. I said earlier that if the character argument (called `char`) is not
    found within the main String (here called `self`), the rotate method will return
    `nil` (❷). If `char` is the initial character within the String, we don’t need
    to do any rotating, so it will return the main String under those conditions (❸).
    The numeral `0` within braces is not an anonymous Array—it’s a method of `self`
    that returns the first character of a String. We call that method on both the
    `self` String and the single-character String `char`. When those two Strings are
    equal, we know that the `self` String starts with the requested rotation character.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*We use an index of zero within the braces to return the first character in
    the String on line ❸ because Ruby (like many languages) starts counting indexes
    at zero, not one*.'
  prefs: []
  type: TYPE_NORMAL
- en: We know that if we’ve gotten this far without returning, we have a String that
    is eligible for rotation (because it contains `char`), and needs to be rotated
    to match (because it doesn’t start with `char`). We perform the rotation by defining
    a new variable called `chars` (❹), which is an Array of each character within
    the String. We use the `pop` method at ❺ to remove the last character from `chars`,
    remembering that `pop` is destructive (despite the lack of an exclamation mark,
    for historical reasons). The `chars` Array now contains all the characters except
    the one that was just `pop`ped off. If we add those Arrays together, putting the
    Array containing the `pop`ped character first, we’ve just created a new Array
    in which the last member has been moved from the end to the front, shifting all
    other members back.
  prefs: []
  type: TYPE_NORMAL
- en: We wrap the `pop`ped character in brackets so that we can more easily add the
    two Arrays (the `pop`ped off character and the remaining characters, respectively).
    Since the `rotate` method will eventually return a String, we `join` our Array
    elements with an empty String separator. This produces a String that has been
    rotated once. Are we done? Not really.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rotation works well, but it might not be enough. What if we need to `rotate`
    multiple characters before we find a match? There’s an easy way to do that; it’s
    called the `rotate` method—you know, the method we’re still in the process of
    defining. We can just call `rotate` on our newly created String.
  prefs: []
  type: TYPE_NORMAL
- en: We already know that our newly created String will pass the test at ❷. We’re
    mainly interested in whether or not it needs further rotation. That’s the test
    at ❸. If only one rotation was needed, this second call to the `rotate` method
    will return the newly created String, and since the second call to `rotate` was
    within a `return` call on the line at ❺, the main call to `rotate` will `return`
    that value, as well.
  prefs: []
  type: TYPE_NORMAL
- en: If only one rotation was not enough to find a match, our second call to the
    `rotate` method will do the same shifting of characters (starting at ❹) that we
    just discussed, culminating in yet another call to `rotate`, this time on a String
    that has been rotated two characters’ worth, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Each successive time `rotate` is called, the String to be operated on is one
    step closer to our desired result. This is very common in recursion, which we
    will be discussing in greater depth in later chapters. As you can see at ❻, we
    also define a destructive version called `rotate!`.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at some output using irb with `irb -r rotate.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In each case, the String on which `rotate` is called has its characters shifted
    until the character asked for is the first character in the String. That’s it
    for this chapter’s scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What was new in this chapter?
  prefs: []
  type: TYPE_NORMAL
- en: End-of-line differences among operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions, including the `?` counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sprintf` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplication of Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `inject` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions with the `+` counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects as the results of blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling successive methods on the output of methods (“chaining” methods)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using new methods of Open Classes in quick scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplication of Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `grep` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `map` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Range class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s quite a bit, including some important new functional concepts like recursion
    and a few very handy functional methods. You’ll need these concepts as we move
    on. Let’s proceed to some more complex treatment of numbers in [Chapter 5](ch05.html
    "Chapter 5. Number Utilities").
  prefs: []
  type: TYPE_NORMAL
