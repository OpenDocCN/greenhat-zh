- en: Chapter 11. Applicative Functors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. 应用函子
- en: Haskell’s combination of purity, higher-order functions, parameterized algebraic
    data types, and type classes makes implementing polymorphism much easier than
    in other languages. We don’t need to think about types belonging to a big hierarchy.
    Instead, we consider what the types can act like and then connect them with the
    appropriate type classes. An `Int` can act like a lot of things—an equatable thing,
    an ordered thing, an enumerable thing, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell结合了纯度、高阶函数、参数化代数数据类型和类型类，这使得实现多态性比在其他语言中要容易得多。我们不需要考虑类型属于一个大层次。相反，我们考虑类型可以像什么样子，然后通过适当的类型类将它们连接起来。一个`Int`可以像很多东西一样——一个可比较的东西、一个有序的东西、一个可枚举的东西等等。
- en: Type classes are open, which means that we can define our own data type, think
    about what it can act like, and connect it with the type classes that define its
    behaviors. We can also introduce a new type class and then make already existing
    types instances of it. Because of that, and because Haskell’s type system allows
    us to know a lot about a function just by its type declaration, we can define
    type classes that define very general and abstract behavior.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类是开放的，这意味着我们可以定义自己的数据类型，考虑它可能像什么样子，并将其与定义其行为的类型类连接起来。我们还可以引入一个新的类型类，然后使已经存在的类型成为它的实例。正因为如此，以及因为Haskell的类型系统允许我们仅通过函数的类型声明就了解很多关于函数的信息，我们可以定义定义非常通用和抽象行为的类型类。
- en: We’ve talked about type classes that define operations for seeing if two things
    are equal and comparing two things by some ordering. Those are very abstract and
    elegant behaviors, although we don’t think of them as very special, since we’ve
    been dealing with them for most of our lives. [Chapter 7](ch07.html "Chapter 7. Making
    Our Own Types and Type Classes") introduced functors, which are types whose values
    can be mapped over. That’s an example of a useful and yet still pretty abstract
    property that type classes can describe. In this chapter, we’ll take a closer
    look at functors, along with slightly stronger and more useful versions of functors
    called *applicative functors*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过定义操作以检查两个事物是否相等以及按某种顺序比较两个事物的类型类。这些行为非常抽象且优雅，尽管我们并不认为它们非常特别，因为我们大多数时候都在处理这些。在第7章（[第7章.
    创建自己的类型和类型类](ch07.html "Chapter 7. Making Our Own Types and Type Classes")）中介绍了函子，它们是值可以被映射的类型。这是一个有用的例子，展示了类型类可以描述的既实用又相当抽象的性质。在本章中，我们将更深入地探讨函子，以及比函子更强、更有用的版本，称为*应用函子*。
- en: Functors Redux
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程重述
- en: 'As you learned in [Chapter 7](ch07.html "Chapter 7. Making Our Own Types and
    Type Classes"), functors are things that can be mapped over, like lists, `Maybe`s,
    and trees. In Haskell, they’re described by the type class `Functor`, which has
    only one type class method: `fmap`. `fmap` has a type of `fmap :: (a -> b) ->
    f a -> f b`, which says, “Give me a function that takes an `a` and returns a `b`
    and a box with an `a` (or several of them) inside it, and I’ll give you a box
    with a `b` (or several of them) inside it.” It applies the function to the element
    inside the box.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '正如你在第7章（[第7章. 创建自己的类型和类型类](ch07.html "Chapter 7. Making Our Own Types and Type
    Classes")）中学到的，函子是可以被映射的事物，例如列表、`Maybe`和树。在Haskell中，它们通过`Functor`类型类来描述，该类型类只有一个类型类方法：`fmap`。`fmap`的类型是`fmap
    :: (a -> b) -> f a -> f b`，这意味着“给我一个接受`a`并返回`b`的函数，以及一个包含`a`（或多个）的盒子，我会给你一个包含`b`（或多个）的盒子。”它将函数应用于盒子内的元素。'
- en: We can also look at functor values as values with an added *context*. For instance,
    `Maybe` values have the extra context that they might have failed. With lists,
    the context is that the value can actually be several values at once or none.
    `fmap` applies a function to the value while preserving its context.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将函子值视为具有附加*上下文*的值。例如，`Maybe`值有额外的上下文，即它们可能失败。对于列表，上下文是值实际上可以同时是多个值或没有值。`fmap`在保留其上下文的同时将函数应用于值。
- en: 'If we want to make a type constructor an instance of `Functor`, it must have
    a kind of `* -> *`, which means that it takes exactly one concrete type as a type
    parameter. For example, `Maybe` can be made an instance because it takes one type
    parameter to produce a concrete type, like `Maybe Int` or `Maybe String`. If a
    type constructor takes two parameters, like `Either`, we need to partially apply
    the type constructor until it takes only one type parameter. So we can’t write
    `instance Functor Either where`, but we *can* write `instance Functor (Either
    a) where`. Then if we imagine that `fmap` is only for `Either a`, it would have
    this type declaration:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让一个类型构造器成为`Functor`的实例，它必须具有`* -> *`的类型，这意味着它恰好接受一个具体的类型作为类型参数。例如，`Maybe`可以成为一个实例，因为它接受一个类型参数来产生一个具体类型，如`Maybe
    Int`或`Maybe String`。如果一个类型构造器接受两个参数，如`Either`，我们需要部分应用类型构造器，直到它只接受一个类型参数。因此，我们不能写`instance
    Functor Either where`，但我们可以写`instance Functor (Either a) where`。然后如果我们想象`fmap`只为`Either
    a`，它将具有以下类型声明：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the `Either a` part is fixed, because `Either a` takes only
    one type parameter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Either a`部分是固定的，因为`Either a`只接受一个类型参数。
- en: I/O Actions As Functors
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I/O操作作为函子
- en: 'You’ve learned how a lot of types (well, type constructors really) are instances
    of `Functor`: `[]`, and `Maybe`, `Either a`, as well as a `Tree` type that we
    created in [Chapter 7](ch07.html "Chapter 7. Making Our Own Types and Type Classes").
    You saw how you can map functions over them for great good. Now, let’s take a
    look at the `IO` instance.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何让许多类型（好吧，类型构造器实际上）成为`Functor`的实例：`[]`，`Maybe`，`Either a`，以及我们在[第7章](ch07.html
    "第7章。创建自己的类型和类型类")中创建的`Tree`类型。你看到了如何通过它们映射函数以获得巨大的好处。现在，让我们来看看`IO`实例。
- en: If some value has a type of, say, `IO String`, that means it’s an I/O action
    that will go out into the real world and get some string for us, which it will
    then yield as a result. We can use `<-` in `do` syntax to bind that result to
    a name. In [Chapter 8](ch08.html "Chapter 8. Input and Output"), we talked about
    how I/O actions are like boxes with little feet that go out and fetch some value
    from the outside world for us. We can inspect what they fetched, but after inspecting,
    we need to wrap the value back in `IO`. Considering this box with feet analogy,
    you can see how `IO` acts like a functor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个值具有如`IO String`这样的类型，这意味着它是一个将进入现实世界并为我们获取一些字符串的I/O操作，然后它将作为结果产生。我们可以在`do`语法中使用`<-`来将这个结果绑定到一个名字上。在[第8章](ch08.html
    "第8章。输入和输出")中，我们讨论了I/O操作如何像有脚的盒子一样走出去并为我们从外部世界获取一些值。我们可以检查它们获取了什么，但在检查之后，我们需要将值包装回`IO`中。考虑到这个有脚的盒子类比，你可以看到`IO`如何像一个函子。
- en: 'Let’s see how `IO` is an instance of `Functor`. When we `fmap` a function over
    an I/O action, we want to get back an I/O action that does the same thing but
    has our function applied over its result value. Here’s the code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`IO`是如何成为`Functor`的实例的。当我们对I/O操作应用一个函数时，我们想要得到一个I/O操作，它执行相同的事情，但将我们的函数应用于其结果值。以下是代码：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result of mapping something over an I/O action will be an I/O action, so
    right off the bat, we use the `do` syntax to glue two actions and make a new one.
    In the implementation for `fmap`, we make a new I/O action that first performs
    the original I/O action and calls its result `result`. Then we do `return (f result)`.
    Recall that `return` is a function that makes an I/O action that doesn’t do anything
    but only yields something as its result.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在I/O操作上映射某个东西的结果将是一个I/O操作，所以我们可以立即使用`do`语法来粘合两个操作并创建一个新的操作。在`fmap`的实现中，我们创建一个新的I/O操作，它首先执行原始的I/O操作，并调用其结果为`result`。然后我们做`return
    (f result)`。回想一下，`return`是一个函数，它创建一个不执行任何操作但只产生结果的I/O操作。
- en: 'The action that a `do` block produces will always yield the result value of
    its last action. That’s why we use `return` to make an I/O action that doesn’t
    really do anything; it just yields `f result` as the result of the new I/O action.
    Check out this piece of code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`do`块产生的操作将始终产生其最后一个操作的值。这就是为什么我们使用`return`来创建一个不执行任何操作但只产生`f result`作为新I/O操作结果的I/O操作。查看以下代码：'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The user is prompted for a line, which we give back, but reversed. Here’s how
    to rewrite this by using `fmap`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 用户被提示输入一行，我们将其返回，但顺序相反。以下是使用`fmap`重写此操作的方法：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802644.png.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802644.png.jpg)'
- en: Just as we can `fmap reverse` over `Just "blah"` to get `Just "halb"`, we can
    `fmap reverse` over `getLine`. `getLine` is an I/O action that has a type of `IO
    String`, and mapping `reverse` over it gives us an I/O action that will go out
    into the real world and get a line and then apply `reverse` to its result. In
    the same way that we can apply a function to something that’s inside a `Maybe`
    box, we can apply a function to what’s inside an `IO` box, but it must go out
    into the real world to get something. Then when we bind it to a name using `<-`.
    The name will reflect the result that already has `reverse` applied to it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以对 `Just "blah"` 应用 `fmap reverse` 来得到 `Just "halb"` 一样，我们也可以对 `getLine`
    应用 `fmap reverse`。`getLine` 是一个类型为 `IO String` 的 I/O 操作，对它应用 `reverse` 会生成一个 I/O
    操作，该操作将进入现实世界获取一行，然后对其结果应用 `reverse`。以同样的方式，我们可以将一个函数应用于 `Maybe` 框架内部的内容，我们也可以将一个函数应用于
    `IO` 框架内部的内容，但它必须进入现实世界以获取某些内容。然后当我们使用 `<-` 绑定它到一个名称时，该名称将反映已经应用了 `reverse` 的结果。
- en: The I/O action `fmap (++"!") getLine` behaves just like `getLine`, except that
    its result always has `"!"` appended to it!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 操作 `fmap (++"!") getLine` 的行为就像 `getLine` 一样，除了其结果总是附加了 `"!"`。
- en: 'If `fmap` were limited to `IO`, its type would be `fmap :: (a -> b) -> IO a
    -> IO b`. `fmap` takes a function and an I/O action and returns a new I/O action
    that’s like the old one, except that the function is applied to its contained
    result.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `fmap` 仅限于 `IO`，其类型将是 `fmap :: (a -> b) -> IO a -> IO b`。`fmap` 接收一个函数和一个
    I/O 操作，并返回一个新的 I/O 操作，它类似于旧的操作，除了函数被应用于其包含的结果。'
- en: 'If you ever find yourself binding the result of an I/O action to a name, only
    to apply a function to that and call that something else, consider using `fmap`.
    If you want to apply multiple functions to some data inside a functor, you can
    declare your own function at the top level, make a lambda function, or, ideally,
    use function composition:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己将 I/O 操作的结果绑定到一个名称上，只是为了应用一个函数并称其为另一个名称，考虑使用 `fmap`。如果你想将多个函数应用于一个在函子内部的数据，你可以在顶层声明自己的函数，创建一个
    lambda 函数，或者，理想情况下，使用函数组合：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s what happens if we run this with the input `hello there`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用输入 `hello there` 运行它，会发生以下情况：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `intersperse ''-'' . reverse . map toUpper` function takes a string, maps
    `toUpper` over it, applies `reverse` to that result, and then applies `intersperse
    ''-''` to that result. It’s a prettier way of writing the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`intersperse ''-'' . reverse . map toUpper` 函数接收一个字符串，将其映射到 `toUpper`，然后对结果应用
    `reverse`，最后将 `intersperse ''-''` 应用到结果上。这是一种更优雅的写法，如下所示：'
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Functions As Functors
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数作为函子
- en: Another instance of `Functor` that we’ve been dealing with all along is `(->)
    r`. But wait! What the heck does `(->) r` mean? The function type `r -> a` can
    be rewritten as `(->) r a`, much like we can write `2 + 3` as `(+) 2 3`. When
    we look at it as `(->) r a`, we can see `(->)` in a slightly different light.
    It’s just a type constructor that takes two type parameters, like `Either`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在处理的一个 `Functor` 的另一个实例是 `(->) r`。但是等等！`(->) r` 究竟是什么意思？函数类型 `r -> a` 可以重写为
    `(->) r a`，就像我们可以将 `2 + 3` 写作 `(+) 2 3` 一样。当我们将其视为 `(->) r a` 时，我们可以以稍微不同的方式看待
    `(->)`。它只是一个类型构造器，它接受两个类型参数，就像 `Either` 一样。
- en: But remember that a type constructor must take exactly one type parameter so
    it can be made an instance of `Functor`. That’s why we can’t make `(->)` an instance
    of `Functor`; however, if we partially apply it to `(->) r`, it doesn’t pose any
    problems. If the syntax allowed for type constructors to be partially applied
    with sections (like we can partially apply `+` by doing `(2+)`, which is the same
    as `(+) 2`), we could write `(->) r` as `(r ->)`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，类型构造器必须恰好接受一个类型参数，以便它可以成为 `Functor` 的实例。这就是为什么我们不能将 `(->)` 作为 `Functor`
    的实例；然而，如果我们部分应用它到 `(->) r`，它不会引起任何问题。如果语法允许类型构造器通过部分应用（如我们可以通过 `(2+)` 部分应用 `+`，它等同于
    `(+) 2`），我们可以将 `(->) r` 写作 `(r ->)`。
- en: 'How are functions functors? Let’s take a look at the implementation, which
    lies in `Control.Monad.Instances`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数如何成为函子？让我们看看实现，它位于 `Control.Monad.Instances` 中：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, let’s think about `fmap`’s type:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们思考一下 `fmap` 的类型：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, let’s mentally replace each `f`, which is the role that our functor instance
    plays, with `(->) r`. This will let us see how `fmap` should behave for this particular
    instance. Here’s the result:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在心中将每个 `f`，即我们的函子实例所扮演的角色，替换为 `(->) r`。这将使我们能够看到 `fmap` 应该如何在这个特定实例中表现。以下是结果：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we can write the `(->) r a` and `(->) r b` types as infix `r -> a` and
    `r -> b`, as we normally do with functions:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将 `(->) r a` 和 `(->) r b` 类型写成中缀 `r -> a` 和 `r -> b`，就像我们通常处理函数一样：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Okay, mapping a function over a function must produce a function, just like
    mapping a function over a `Maybe` must produce a `Maybe`, and mapping a function
    over a list must produce a list. What does the preceding type tell us? We see
    that it takes a function from `a` to `b` and a function from `r` to `a` and returns
    a function from `r` to `b`. Does this remind you of anything? Yes, function composition!
    We pipe the output of `r -> a` into the input of `a -> b` to get a function `r
    -> b`, which is exactly what function composition is all about. Here’s another
    way to write this instance:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在函数上映射函数必须产生一个函数，就像在 `Maybe` 上映射函数必须产生一个 `Maybe`，以及在列表上映射函数必须产生一个列表一样。前面的类型告诉我们什么？我们看到它接受一个从
    `a` 到 `b` 的函数和一个从 `r` 到 `a` 的函数，并返回一个从 `r` 到 `b` 的函数。这让你想起了什么吗？是的，函数组合！我们将 `r
    -> a` 的输出管道输入到 `a -> b` 的输入中，以获得一个 `r -> b` 的函数，这正是函数组合的全部内容。这里有另一种编写此实例的方法：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This makes it clear that using `fmap` over functions is just function composition.
    In a script, import `Control.Monad.Instances`, since that’s where the instance
    is defined, and then load the script and try playing with mapping over functions:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地表明，在函数上使用 `fmap` 实际上就是函数组合。在脚本中，导入 `Control.Monad.Instances`，因为实例定义在那里，然后加载脚本并尝试在函数上应用映射：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can call `fmap` as an infix function so that the resemblance to `.` is clear.
    In the second input line, we’re mapping `(*3)` over `(+100)`, which results in
    a function that will take an input, apply `(+100)` to that, and then apply `(*3)`
    to that result. We then apply that function to `1`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `fmap` 调用为一个中缀函数，以便清楚地看到它与 `.` 的相似之处。在第二行输入中，我们正在将 `(*3)` 映射到 `(+100)`，这将产生一个函数，它将接受一个输入，将
    `(+100)` 应用到该输入上，然后将 `(*3)` 应用到该结果上。然后我们将该函数应用到 `1` 上。
- en: Just like all functors, functions can be thought of as values with contexts.
    When we have a function like `(+3)`, we can view the value as the eventual result
    of the function, and the context is that we need to apply the function to something
    to get to the result. Using `fmap (*3)` on `(+100)` will create another function
    that acts like `(+100)`, but before producing a result, `(*3)` will be applied
    to that result.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所有函子一样，函数可以被看作是有上下文的价值。当我们有一个像 `(+3)` 这样的函数时，我们可以将值视为函数的最终结果，上下文是我们需要将函数应用到某物上才能得到结果。使用
    `fmap (*3)` 在 `(+100)` 上将创建另一个像 `(+100)` 一样的函数，但在产生结果之前，`(*3)` 将被应用到该结果上。
- en: The fact that `fmap` is function composition when used on functions isn’t so
    terribly useful right now, but at least it’s very interesting. It also bends our
    minds a bit and lets us see how things that act more like computations than boxes
    (`IO` and `(->) r`) can be functors. The function being mapped over a computation
    results in the same sort of computation, but the result of that computation is
    modified with the function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当在函数上使用时，`fmap` 是函数组合的事实现在可能并不那么有用，但至少它非常有趣。它也让我们的大脑有点弯曲，并让我们看到那些更像计算而不是盒子的东西（`IO`
    和 `(->) r`）可以成为函子。被映射到计算上的函数会产生相同类型的计算，但该计算的结果会通过该函数进行修改。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802646.png.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802646.png.jpg)'
- en: 'Before we go on to the rules that `fmap` should follow, let’s think about the
    type of `fmap` once more:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到 `fmap` 应该遵循的规则之前，让我们再次思考一下 `fmap` 的类型：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The introduction of curried functions in [Chapter 5](ch05.html "Chapter 5. Higher-Order
    Functions") began by stating that all Haskell functions actually take one parameter.
    A function `a -> b -> c` takes just one parameter of type `a` and returns a function
    `b -> c`, which takes one parameter and returns `c`. That’s why calling a function
    with too few parameters (partially applying it) gives us back a function that
    takes the number of parameters that we left out (if we’re thinking about functions
    as taking several parameters again). So `a -> b -> c` can be written as `a ->
    (b -> c)`, to make the currying more apparent.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](ch05.html "第 5 章。高阶函数") 中引入柯里化函数时，首先声明所有 Haskell 函数实际上只接受一个参数。一个 `a
    -> b -> c` 函数只接受一个类型为 `a` 的参数，并返回一个 `b -> c` 的函数，该函数接受一个参数并返回 `c`。这就是为什么用太少的参数调用函数（部分应用它）会给我们返回一个接受我们省略的参数数量的函数（如果我们再次将函数视为接受多个参数）。因此，`a
    -> b -> c` 可以写成 `a -> (b -> c)`，以使柯里化更明显。
- en: 'In the same vein, if we write `fmap :: (a -> b) -> (f a -> f b)`, we can think
    of `fmap` not as a function that takes one function and a functor value and returns
    a functor value, but as a function that takes a function and returns a new function
    that’s just like the old one, except that it takes a functor value as a parameter
    and returns a functor value as the result. It takes an `a -> b` function and returns
    a function `f a -> f b`. This is called *lifting* a function. Let’s play around
    with that idea using GHCi’s `:t` command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '同样地，如果我们写`fmap :: (a -> b) -> (f a -> f b)`，我们可以把`fmap`不是看作是一个接受一个函数和一个函子值并返回一个函子值的函数，而是一个接受一个函数并返回一个新函数的函数，这个新函数与旧函数类似，除了它接受一个函子值作为参数并返回一个函子值作为结果。它接受一个`a
    -> b`函数并返回一个函数`f a -> f b`。这被称为*提升*一个函数。让我们使用GHCi的`:t`命令来玩这个想法：'
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The expression `fmap (*2)` is a function that takes a functor `f` over numbers
    and returns a functor over numbers. That functor can be a list, a `Maybe`, an
    `Either String`, or anything else. The expression `fmap (replicate 3)` will take
    a functor over any type and return a functor over a list of elements of that type.
    This is even more apparent if we partially apply, say, `fmap (++"!")` and then
    bind it to a name in GHCi.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`fmap (*2)`是一个函数，它接受一个数字上的函子`f`并返回一个数字上的函子。这个函子可以是列表、`Maybe`、`Either String`或其他任何东西。表达式`fmap
    (replicate 3)`将接受任何类型的函子并返回一个该类型元素列表的函子。如果我们部分应用，比如`fmap (++"!")`并将其绑定到GHCi中的一个名称，这会更加明显。
- en: 'You can think of `fmap` in two ways:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从两种方式来思考`fmap`：
- en: As a function that takes a function and a functor value and then maps that function
    over the functor value
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一种函数，它接受一个函数和一个函子值，然后在该函子值上映射该函数
- en: As a function that takes a function and lifts that function so it operates on
    functor values
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一种函数，它接受一个函数并将其提升，使其在函子值上操作
- en: Both views are correct.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种观点都是正确的。
- en: 'The type `fmap (replicate 3) :: (Functor f) => f a -> f [a]` means that the
    function will work on any functor. What it will do depends on the functor. If
    we use `fmap (replicate 3)` on a list, the list’s implementation for `fmap` will
    be chosen, which is just `map`. If we use it on `Maybe a`, it will apply `replicate
    3` to the value inside the `Just`. If it’s `Nothing`, it stays `Nothing`. Here
    are some examples:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '类型`fmap (replicate 3) :: (Functor f) => f a -> f [a]`意味着这个函数将在任何函子上工作。它将做什么取决于函子。如果我们对列表使用`fmap
    (replicate 3)`，将选择列表的`fmap`实现，这仅仅是`map`。如果我们对`Maybe a`使用它，它将对`Just`中的值应用`replicate
    3`。如果是`Nothing`，它将保持`Nothing`。以下是一些示例：'
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Functor Laws
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函子定律
- en: All functors are expected to exhibit certain kinds of properties and behaviors.
    They should reliably behave as things that can be mapped over. Calling `fmap`
    on a functor should just map a function over the functor—nothing more. This behavior
    is described in the *functor laws*. All instances of `Functor` should abide by
    these two laws. They aren’t enforced by Haskell automatically, so you need to
    test them yourself when you make a functor. All the `Functor` instances in the
    standard library obey these laws.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函子都应表现出某些类型的属性和行为。它们应该可靠地表现为可以被映射的对象。在函子上调用`fmap`应该只是将函数映射到函子——仅此而已。这种行为在*函子定律*中描述。所有`Functor`实例都应该遵守这两条定律。Haskell不会自动执行这些定律，所以当你创建一个函子时，你需要自己测试它们。标准库中的所有`Functor`实例都遵守这些定律。
- en: Law 1
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 法则1
- en: The first functor law states that if we map the `id` function over a functor
    value, the functor value that we get back should be the same as the original functor
    value. Written a bit more formally, it means that `fmap id = id`. So essentially,
    this says that if we do `fmap id` over a functor value, it should be the same
    as just applying `id` to the value. Remember that `id` is the identity function,
    which just returns its parameter unmodified. It can also be written as `\x ->
    x`. If we view the functor value as something that can be mapped over, the `fmap
    id = id` law seems kind of trivial or obvious.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条函子定律指出，如果我们将`id`函数映射到函子值上，我们得到的函子值应该与原始的函子值相同。更正式地说，这意味着`fmap id = id`。所以本质上，这表明如果我们对函子值执行`fmap
    id`，它应该与直接应用`id`到值上相同。记住`id`是恒等函数，它只是返回其参数未修改。它也可以写成`\x -> x`。如果我们把函子值看作是可以被映射的对象，`fmap
    id = id`定律似乎有点平凡或明显。
- en: Let’s see if this law holds for a few values of functors.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个定律对于几个函子的值是否成立。
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Looking at the implementation of `fmap` for `Maybe`, for example, we can figure
    out why the first functor law holds:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以`Maybe`的`fmap`实现为例，我们可以弄清楚为什么第一条函子定律成立：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We imagine that `id` plays the role of the `f` parameter in the implementation.
    We see that if we `fmap id` over `Just x`, the result will be `Just (id x)`, and
    because `id` just returns its parameter, we can deduce that `Just (id x)` equals
    `Just x`. So now we know that if we map `id` over a `Maybe` value with a `Just`
    value constructor, we get that same value back.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想象`id`在实现中扮演了`f`参数的角色。我们看到如果我们对`Just x`应用`fmap id`，结果将是`Just (id x)`，因为`id`只是返回其参数，我们可以推断出`Just
    (id x)`等于`Just x`。所以现在我们知道，如果我们对带有`Just`构造函数的`Maybe`值应用`id`，我们将得到相同的值。
- en: Seeing that mapping `id` over a `Nothing` value returns the same value is trivial.
    So from these two equations in the implementation for `fmap`, we find that the
    law `fmap id = id` holds.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 看到对`Nothing`值应用`id`返回相同的值是显而易见的。所以从`fmap`实现的这两个方程中，我们发现定律`fmap id = id`成立。
- en: Law 2
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 法则2
- en: 'The second law says that composing two functions and then mapping the resulting
    function over a functor should be the same as first mapping one function over
    the functor and then mapping the other one. Formally written, that means `fmap
    (f . g) = fmap f . fmap g`. Or to write it in another way, for any functor value
    `x`, the following should hold: `fmap (f . g) x = fmap f (fmap g x)`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第二定律表明，先组合两个函数，然后将结果函数映射到functor上，应该与首先将一个函数映射到functor上，然后映射另一个函数相同。形式上写成，这意味着`fmap
    (f . g) = fmap f . fmap g`。或者用另一种方式写，对于任何functor值`x`，以下应该成立：`fmap (f . g) x =
    fmap f (fmap g x)`。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802648.png.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802648.png.jpg)'
- en: If we can show that some type obeys both functor laws, we can rely on it having
    the same fundamental behaviors as other functors when it comes to mapping. We
    can know that when we use `fmap` on it, there won’t be anything other than mapping
    going on behind the scenes and that it will act like a thing that can be mapped
    over—that is, a functor.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以证明某个类型遵守了两个functor定律，我们就可以依赖它在映射时的基本行为与其他functors相同。我们可以知道，当我们对它使用`fmap`时，幕后不会有除了映射之外的其他操作，并且它将表现得像一个可以被映射的对象——即，一个functor。
- en: We figure out how the second law holds for some type by looking at the implementation
    of `fmap` for that type and then using the method that we used to check if `Maybe`
    obeys the first law. So, to check out how the second functor law holds for `Maybe`,
    if we use `fmap (f . g)` over `Nothing`, we get `Nothing`, because calling `fmap`
    with any function over `Nothing` returns `Nothing`. If we call `fmap f (fmap g
    Nothing)`, we get `Nothing`, for the same reason.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过查看某个类型的`fmap`实现，然后使用我们用来检查`Maybe`是否遵守第一定律的方法，来找出某个类型的第二定律是如何成立的。所以，为了检查`Maybe`的第二functor定律是如何成立的，如果我们对`Nothing`应用`fmap
    (f . g)`，我们得到`Nothing`，因为对`Nothing`应用任何函数都会返回`Nothing`。如果我们调用`fmap f (fmap g Nothing)`，我们得到`Nothing`，原因相同。
- en: Seeing how the second law holds for `Maybe` if it’s a `Nothing` value is pretty
    easy. But how about if it’s a `Just` value? Well, if we use `fmap (f . g) (Just
    x)`, we see from the implementation that it’s implemented as `Just ((f . g) x)`,
    which is `Just (f (g x))`. If we use `fmap f (fmap g (Just x))`, we see from the
    implementation that `fmap g (Just x)` is `Just (g x)`. Ergo, `fmap f (fmap g (Just
    x))` equals `fmap f (Just (g x))`, and from the implementation, we see that this
    equals `Just (f (g x))`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Maybe`是一个`Nothing`值，那么看到第二定律是如何成立的很容易。但是，如果它是一个`Just`值呢？嗯，如果我们对`(Just x)`应用`fmap
    (f . g)`，从实现中我们可以看到它被实现为`Just ((f . g) x)`，这是`Just (f (g x))`。如果我们对`(fmap g (Just
    x))`应用`fmap f`，从实现中我们可以看到`fmap g (Just x)`是`Just (g x)`。因此，`fmap f (fmap g (Just
    x))`等于`fmap f (Just (g x))`，从实现中我们可以看到这等于`Just (f (g x))`。
- en: If you’re a bit confused by this proof, don’t worry. Be sure that you understand
    how function composition works. Many times, you can intuitively see how these
    laws hold because the types act like containers or functions. You can also just
    try them on a bunch of different values of a type and be able to say with some
    certainty that a type does indeed obey the laws.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个证明有点困惑，不要担心。确保你理解了函数组合是如何工作的。很多时候，你可以直观地看到这些定律是如何成立的，因为类型表现得像容器或函数。你也可以在类型的许多不同值上尝试它们，并能够有把握地说一个类型确实遵守了定律。
- en: Breaking the Law
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 违反定律
- en: 'Let’s take a look at a pathological example of a type constructor being an
    instance of the `Functor` type class but not really being a functor, because it
    doesn’t satisfy the laws. Let’s say that we have the following type:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个类型构造函数是`Functor`类型类的实例但实际上并不是functor的病理例子，因为它不满足定律。假设我们有以下类型：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `C` here stands for counter. It’s a data type that looks much like `Maybe
    a`, but the `Just` part holds two fields instead of one. The first field in the
    `CJust` value constructor will always have a type of `Int`, and it will be some
    sort of counter. The second field is of type `a`, which comes from the type parameter,
    and its type will depend on the concrete type that we choose for `CMaybe a`. Let’s
    play with our new type:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `C` 代表计数器。它是一种数据类型，看起来很像 `Maybe a`，但 `Just` 部分包含两个字段而不是一个。`CJust` 值构造函数中的第一个字段将始终具有
    `Int` 类型，并且它将是一种计数器。第二个字段是类型 `a`，它来自类型参数，其类型将取决于我们为 `CMaybe a` 选择的具体类型。让我们来玩玩我们的新类型：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If we use the `CNothing` constructor, there are no fields. If we use the `CJust`
    constructor, the first field is an integer and the second field can be any type.
    Let’s make this an instance of `Functor` so that each time we use `fmap`, the
    function is applied to the second field, whereas the first field is increased
    by 1.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `CNothing` 构造函数，则没有字段。如果我们使用 `CJust` 构造函数，第一个字段是一个整数，第二个字段可以是任何类型。让我们将其作为
    `Functor` 的实例，这样每次我们使用 `fmap` 时，函数都应用于第二个字段，而第一个字段增加 1。
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is kind of like the instance implementation for `Maybe`, except that when
    we do `fmap` over a value that doesn’t represent an empty box (a `CJust` value),
    we don’t just apply the function to the contents; we also increase the counter
    by 1\. Everything seems cool so far. We can even play with this a bit:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点像 `Maybe` 的实例实现，除了当我们对不表示空盒（`CJust` 值）的值执行 `fmap` 时，我们不仅将函数应用到内容上；我们还增加计数器
    1。到目前为止，一切看起来都很酷。我们甚至可以玩玩这个：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Does this obey the functor laws? In order to see that something doesn’t obey
    a law, it’s enough to find just one counterexample:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否遵守函子定律？为了看到某物不遵守定律，只需找到一个反例就足够了：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As the first functor law states, if we map `id` over a functor value, it should
    be the same as just calling `id` with the same functor value. Our example demonstrates
    that this is not true for our `CMaybe` functor. Even though it’s part of the `Functor`
    type class, it doesn’t obey this functor law and is therefore not a functor.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 根据第一个函子定律，如果我们对函子值映射 `id`，它应该与直接用相同的函子值调用 `id` 相同。我们的例子表明，这并不适用于我们的 `CMaybe`
    函子。尽管它是 `Functor` 类型类的一部分，但它不遵守这个函子定律，因此它不是一个函子。
- en: Since `CMaybe` fails at being a functor even though it pretends to be one, using
    it as a functor might lead to some faulty code. When we use a functor, it shouldn’t
    matter if we first compose a few functions and then map them over the functor
    value or we just map each function over a functor value in succession. But with
    `CMaybe` it matters, because it keeps track of how many times it has been mapped
    over. Not cool! If we want `CMaybe` to obey the functor laws, we need to make
    it so that the `Int` field stays the same when we use `fmap`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `CMaybe` 即使假装是函子也未能成为函子，因此将其用作函子可能会导致一些错误的代码。当我们使用函子时，我们不应该关心我们首先组合几个函数然后映射到函子值，还是我们依次将每个函数映射到函子值。但与
    `CMaybe` 不同，这很重要，因为它跟踪它被映射了多少次。这很不酷！如果我们想让 `CMaybe` 遵守函子定律，我们需要确保在执行 `fmap` 时
    `Int` 字段保持不变。
- en: At first, the functor laws might seem a bit confusing and unnecessary. But if
    we know that a type obeys both laws, we can make certain assumptions about how
    it will act. If a type obeys the functor laws, we know that calling `fmap` on
    a value of that type will only map the function over it—nothing more. This leads
    to code that is more abstract and extensible, because we can use laws to reason
    about behaviors that any functor should have and make functions that operate reliably
    on any functor.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，函子定律可能看起来有些令人困惑且不必要。但如果我们知道一个类型遵守这两个定律，我们就可以对其行为做出某些假设。如果一个类型遵守函子定律，我们知道对那个类型的值调用
    `fmap` 只会将函数映射到它上面——仅此而已。这导致代码更加抽象和可扩展，因为我们可以使用定律来推理任何函子都应该具有的行为，并编写在任何函子上都能可靠运行的函数。
- en: The next time you make a type an instance of `Functor`, take a minute to make
    sure that it obeys the functor laws. You can go over the implementation line by
    line and see if the laws hold or try to find a counterexample. Once you’ve dealt
    with enough functors, you will begin to recognize the properties and behaviors
    that they have in common, and begin to intuitively see if a type obeys the functor
    laws.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下次你将一个类型作为 `Functor` 的实例时，花一分钟确保它遵守函子定律。你可以逐行检查实现，看看定律是否成立，或者尝试找到一个反例。一旦你处理了足够的函子，你将开始认识到它们共有的属性和行为，并开始直观地看到类型是否遵守函子定律。
- en: Using Applicative Functors
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用应用函子
- en: In this section, we’ll take a look at applicative functors, which are beefed-up
    functors.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨应用函子，它们是增强版的函子。
- en: So far, we have focused on mapping functions that take only one parameter over
    functors. But what happens when we map a function that takes two parameters over
    a functor? Let’s take a look at a couple of concrete examples of this.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于映射只接受一个参数的函数到函子。但是，当我们映射一个接受两个参数的函数到函子上时会发生什么？让我们看看这个的几个具体例子。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802650.png.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802650.png.jpg)'
- en: If we have `Just 3` and we call `fmap (*) (Just 3)`, what do we get? From the
    instance implementation of `Maybe` for `Functor`, we know that if it’s a `Just`
    value, it will apply the function to the value inside the `Just`. Therefore, doing
    `fmap (*) (Just 3)` results in `Just ((*) 3)`, which can also be written as `Just
    (3 *)` if we use sections. Interesting! We get a function wrapped in a `Just`!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有`Just 3`并调用`fmap (*) (Just 3)`，我们会得到什么？从`Maybe`的`Functor`实例实现中，我们知道如果它是一个`Just`值，它将把函数应用于`Just`内部的值。因此，执行`fmap
    (*) (Just 3)`的结果是`Just ((*) 3)`，如果我们使用部分应用，也可以写成`Just (3 *)`。有趣的是！我们得到了一个被`Just`包裹的函数！
- en: 'Here are some more functions inside functor values:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些函子值内部的更多函数：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we map `compare`, which has a type of `(Ord a) => a -> a -> Ordering`, over
    a list of characters, we get a list of functions of type `Char -> Ordering`, because
    the function `compare` gets partially applied with the characters in the list.
    It’s not a list of `(Ord a) => a -> Ordering` function, because the first `a`
    applied was a `Char`, and so the second `a` must decide to be of type `Char`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`compare`映射到一个字符列表上，它的类型是`(Ord a) => a -> a -> Ordering`，我们会得到一个类型为`Char
    -> Ordering`的函数列表，因为`compare`函数被部分应用于列表中的字符。它不是一个`(Ord a) => a -> Ordering`函数的列表，因为第一个`a`应用的是`Char`，因此第二个`a`必须决定其类型为`Char`。
- en: 'We see how by mapping “multiparameter” functions over functor values, we get
    functor values that contain functions inside them. So now what can we do with
    them? For one, we can map functions that take these functions as parameters over
    them, because whatever is inside a functor value will be given to the function
    that we’re mapping over it as a parameter:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到通过将“多参数”函数映射到函子值上，我们得到了包含函数在内的函子值。那么现在我们能对它们做什么呢？首先，我们可以映射接受这些函数作为参数的函数，因为函子值内部的东西将被提供给我们要映射的函数作为参数：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: But what if we have a functor value of `Just (3 *)` and a functor value of `Just
    5`, and we want to take out the function from `Just (3 *)` and map it over `Just
    5`? With normal functors, we’re out of luck, because they support only mapping
    normal functions over existing functors. Even when we mapped `\f -> f 9` over
    a functor that contained functions, we were just mapping a normal function over
    it. But we can’t map a function that’s inside a functor value over another functor
    value with what `fmap` offers us. We could pattern match against the `Just` constructor
    to get the function out of it and then map it over `Just 5`, but we’re looking
    for a more general and abstract approach that works across functors.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们有一个`Just (3 *)`的函子值和一个`Just 5`的函子值，而我们想要从`Just (3 *)`中提取函数并映射到`Just 5`上呢？使用普通的函子，我们就没有运气了，因为它们只支持在现有的函子上映射普通函数。即使当我们对包含函数的函子映射`\f
    -> f 9`时，我们只是在它上面映射了一个普通函数。但我们不能使用`fmap`提供的方法将一个函子值内部的函数映射到另一个函子值上。我们可以通过模式匹配`Just`构造函数来从中提取函数，然后映射到`Just
    5`上，但我们正在寻找一个更通用和抽象的方法，它可以在函子之间工作。
- en: Say Hello to Applicative
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问候应用函子
- en: 'Meet the `Applicative` type class, in the `Control.Applicative` module. It
    defines two functions: `pure` and `<*>`. It doesn’t provide a default implementation
    for either of them, so we need to define them both if we want something to be
    an applicative functor. The class is defined like so:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 认识一下`Applicative`类型类，它在`Control.Applicative`模块中定义。它定义了两个函数：`pure`和`<*>`。它不提供这两个函数的默认实现，所以如果我们想让某个东西成为一个应用函子，我们需要定义它们两个。类定义如下：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This simple three-line class definition tells us a lot! The first line starts
    the definition of the `Applicative` class, and it also introduces a class constraint.
    The constraint says that if we want to make a type constructor part of the `Applicative`
    type class, it must be in `Functor` first. That’s why if we know that a type constructor
    is part of the `Applicative` type class, it’s also in `Functor`, so we can use
    `fmap` on it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这简单的三行类定义告诉我们很多！第一行开始定义 `Applicative` 类，并且也引入了一个类约束。约束说，如果我们想使一个类型构造器成为 `Applicative`
    类型类的一部分，它必须首先在 `Functor` 中。这就是为什么如果我们知道一个类型构造器是 `Applicative` 类型类的一部分，它也在 `Functor`
    中，所以我们可以对它使用 `fmap`。
- en: 'The first method it defines is called `pure`. Its type declaration is `pure
    :: a -> f a`. `f` plays the role of our applicative functor instance here. Because
    Haskell has a very good type system, and because all a function can do is take
    some parameters and return some value, we can tell a lot from a type declaration,
    and this is no exception.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '它定义的第一个方法被称为 `pure`。它的类型声明是 `pure :: a -> f a`。在这里，`f` 扮演了我们应用函子实例的角色。因为 Haskell
    有一个非常好的类型系统，而且因为所有函数能做的只是接受一些参数并返回一些值，我们可以从类型声明中得知很多信息，这也不例外。'
- en: '`pure` should take a value of any type and return an applicative value with
    that value inside it. “Inside it” refers to our box analogy again, even though
    we’ve seen that it doesn’t always stand up to scrutiny. But the `a -> f a` type
    declaration is still pretty descriptive. We take a value and we wrap it in an
    applicative value that has that value as the result inside it. A better way of
    thinking about `pure` would be to say that it takes a value and puts it in some
    sort of default (or pure) context—a minimal context that still yields that value.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`pure` 应该接受任何类型的值，并返回一个包含该值的适用值的适用值。这里的“里面”再次指的是我们的盒子类比，尽管我们已经看到它并不总是经得起推敲。但
    `a -> f a` 的类型声明仍然相当描述性。我们接受一个值，并将其包裹在一个适用值中，这个适用值的结果里面就是那个值。关于 `pure` 的更好思考方式可能是说它接受一个值并将其放入某种默认（或纯）上下文中——一个最小的上下文，仍然产生那个值。'
- en: 'The `<*>` function is really interesting. It has this type declaration:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`<*>` 函数非常有趣。它有这个类型声明：'
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Does this remind you of anything? It’s like `fmap :: (a -> b) -> f a-> f b`.
    You can think of the `<*>` function as sort of a beefed-up `fmap`. Whereas `fmap`
    takes a function and a functor value and applies the function inside the functor
    value, `<*>` takes a functor value that has a function in it and another functor,
    and extracts that function from the first functor and then maps it over the second
    one.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '这让你想起什么吗？它就像 `fmap :: (a -> b) -> f a -> f b`。你可以把 `<*>` 函数看作是某种增强版的 `fmap`。而
    `fmap` 接受一个函数和一个函子值，并在函子值内部应用这个函数，`<*>` 接受一个包含函数的函子值和另一个函子，然后从第一个函子中提取那个函数，然后将其映射到第二个函子上。'
- en: Maybe the Applicative Functor
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可能的适用函子
- en: 'Let’s take a look at the `Applicative` instance implementation for `Maybe`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Maybe` 的 `Applicative` 实例实现：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, from the class definition, we see that the `f` that plays the role of
    the applicative functor should take one concrete type as a parameter, so we write
    `instance Applicative Maybe where` instead of `instance Applicative (Maybe a)
    where`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，从类定义中，我们看到扮演应用函子角色的 `f` 应该接受一个具体类型作为参数，所以我们写 `instance Applicative Maybe
    where` 而不是 `instance Applicative (Maybe a) where`。
- en: Next, we have `pure`. Remember that it’s supposed to take something and wrap
    it in an applicative value. We wrote `pure = Just`, because value constructors
    like `Just` are normal functions. We could have also written `pure x = Just x`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `pure`。记住，它应该接受一些东西并将其包裹在应用值中。我们写 `pure = Just`，因为像 `Just` 这样的值构造器是普通函数。我们也可以写成
    `pure x = Just x`。
- en: Finally, we have the definition for `<*>`. We can’t extract a function out of
    a `Nothing`, because it has no function inside it. So we say that if we try to
    extract a function from a `Nothing`, the result is a `Nothing`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `<*>` 的定义。我们不能从一个 `Nothing` 中提取一个函数，因为它里面没有函数。所以如果我们尝试从一个 `Nothing` 中提取一个函数，结果是
    `Nothing`。
- en: In the class definition for `Applicative`, there’s a `Functor` class constraint,
    which means that we can assume that both of the `<*>` function’s parameters are
    functor values. If the first parameter is not a `Nothing`, but a `Just` with some
    function inside it, we say that we then want to map that function over the second
    parameter. This also takes care of the case where the second parameter is `Nothing`,
    because doing `fmap` with any function over a `Nothing` will re turn a `Nothing`.
    So for `Maybe`, `<*>` extracts the function from the left value if it’s a `Just`
    and maps it over the right value. If any of the parameters is `Nothing`, `Nothing`
    is the result.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Applicative`类的类定义中，有一个`Functor`类约束，这意味着我们可以假设`<*>`函数的两个参数都是函子值。如果第一个参数不是一个`Nothing`，而是一个包含某些函数的`Just`，那么我们就可以说我们想要将这个函数映射到第二个参数上。这也处理了第二个参数是`Nothing`的情况，因为对任何函数在`Nothing`上执行`fmap`操作都会返回一个`Nothing`。所以对于`Maybe`，`<*>`会从左边的值中提取函数（如果它是`Just`），并将其映射到右边的值上。如果任一参数是`Nothing`，结果就是`Nothing`。
- en: 'Now let’s give this a whirl:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来试一试：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You see how doing `pure (+3)` and `Just (+3)` is the same in this case. Use
    `pure` if you’re dealing with `Maybe` values in an applicative context (using
    them with `<*>`); otherwise, stick to `Just`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到在这个情况下，执行`pure (+3)`和`Just (+3)`是相同的。如果你在应用式上下文中处理`Maybe`值（使用它们与`<*>`一起），请使用`pure`；否则，坚持使用`Just`。
- en: The first four input lines demonstrate how the function is extracted and then
    mapped, but in this case, they could have been achieved by just mapping unwrapped
    functions over functors. The last line is interesting, because we try to extract
    a function from a `Nothing` and then map it over something, which results in `Nothing`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前四行展示了函数是如何被提取然后映射的，但在这个情况下，它们可以通过仅仅将未包装的函数映射到函子上来实现。最后一行很有趣，因为我们尝试从一个`Nothing`中提取一个函数，然后将其映射到某个值上，结果是`Nothing`。
- en: With normal functors, when you map a function over a functor, you can’t get
    the result out in any general way, even if the result is a partially applied function.
    Applicative functors, on the other hand, allow you to operate on several functors
    with a single function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通函子，当你将一个函数映射到一个函子上时，你无法以任何通用方式得到结果，即使结果是部分应用函数。另一方面，应用式函子允许你用一个函数操作多个函子。
- en: The Applicative Style
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用式风格
- en: 'With the `Applicative` type class, we can chain the use of the `<*>` function,
    thus enabling us to seamlessly operate on several applicative values instead of
    just one. For instance, check this out:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Applicative`类型类，我们可以链式使用`<*>`函数，这样我们就可以无缝地对多个应用值进行操作，而不仅仅是单个值。例如，看看这个：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802652.png.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802652.png.jpg)'
- en: We wrapped the `+` function inside an applicative value and then used `<*>`
    to call it with two parameters, both applicative values.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`+`函数包裹在一个应用值中，然后使用`<*>`用两个参数（都是应用值）调用它。
- en: 'Let’s take a look at how this happens, step by step. `<*>` is left-associative,
    which means that this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地看看这是如何发生的。`<*>`是左结合的，这意味着这个：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'is the same as this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这与这个相同：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, the `+` function is put in an applicative value—in this case, a `Maybe`
    value that contains the function. So we have `pure (+)`, which is `Just (+)`.
    Next, `Just (+) <*> Just 3` happens. The result of this is `Just (3+)`. This is
    because of partial application. Only applying the `+` function to `3` results
    in a function that takes one parameter and adds 3 to it. Finally, `Just (3+) <*>
    Just 5` is carried out, which results in a `Just 8`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`+`函数被放入一个应用值中——在这个例子中，是一个包含函数的`Maybe`值。所以我们有`pure (+)`，它是`Just (+)`。接下来，`Just
    (+) <*> Just 3`发生了。这个结果是因为部分应用。只将`+`函数应用到`3`上会得到一个接受一个参数并将3加到它上面的函数。最后，执行`Just
    (3+) <*> Just 5`，结果是`Just 8`。
- en: Isn’t this awesome? Applicative functors and the applicative style of `pure
    f <*> x <*> y <*> ...` allow us to take a function that expects parameters that
    aren’t applicative values and use that function to operate on several applicative
    values. The function can take as many parameters as we want, because it’s always
    partially applied step by step between occurrences of `<*>`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是太棒了吗？应用式函子和`pure f <*> x <*> y <*> ...`的应用式风格允许我们使用一个期望参数不是应用值函数，并使用该函数对多个应用值进行操作。该函数可以接受我们想要的任意数量的参数，因为它总是在`<*>`出现之间逐步部分应用。
- en: 'This becomes even more handy and apparent if we consider the fact that `pure
    f <*> x` equals `fmap f x`. This is one of the applicative laws. We’ll take a
    closer look at the applicative laws later in the chapter, but let’s think about
    how it applies here. `pure` puts a value in a default context. If we just put
    a function in a default context and then extract and apply it to a value inside
    another applicative functor, that’s the same as just mapping that function over
    that applicative functor. Instead of writing `pure f <*> x <*> y <*> ...`, we
    can write `fmap f x <*> y <*> ...`. This is why `Control.Applicative` exports
    a function called `<$>`, which is just `fmap` as an infix operator. Here’s how
    it’s defined:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑这样一个事实，即 `pure f <*> x` 等于 `fmap f x`，这就会变得更加方便和明显。这是应用性定律之一。我们将在本章后面更详细地探讨应用性定律，但让我们先思考一下它在这里是如何应用的。`pure`
    将一个值放入默认上下文中。如果我们只是将一个函数放入默认上下文中，然后从中提取并应用到另一个应用性函子中的值，那么这和只是映射该函数到该应用性函子上是一样的。我们不需要写
    `pure f <*> x <*> y <*> ...`，我们可以写 `fmap f x <*> y <*> ...`。这就是为什么 `Control.Applicative`
    导出了一个名为 `<$>` 的函数，它只是作为中缀操作符的 `fmap`。下面是如何定义它的：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that type variables are independent of parameter names or other value
    names. The `f` in the function declaration here is a type variable with a class
    constraint saying that any type constructor that replaces `f` should be in the
    `Functor` type class. The `f` in the function body denotes a function that we
    map over `x`. The fact that we used `f` to represent both of those doesn’t mean
    that they represent the same thing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，类型变量与参数名称或其他值名称无关。这里函数声明中的 `f` 是一个带有类约束的类型变量，表示任何替换 `f` 的类型构造函数都应该在 `Functor`
    类型类中。函数体中的 `f` 表示一个映射到 `x` 的函数。我们使用 `f` 来表示这两者并不意味着它们表示相同的事物。
- en: By using `<$>`, the applicative style really shines, because now if we want
    to apply a function `f` between three applicative values, we can write `f <$>
    x <*> y <*> z`. If the parameters were normal values rather than applicative functors,
    we would write `f x y z`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `<$>`，应用性风格真正地闪耀，因为现在如果我们想在三个应用性值之间应用一个函数 `f`，我们可以写 `f <$> x <*> y <*>
    z`。如果参数是普通值而不是应用性函子，我们会写 `f x y z`。
- en: 'Let’s take a closer look at how this works. Suppose we want to join the values
    `Just "johntra"` and `Just "volta"` into one `String` inside a `Maybe` functor.
    We can do this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看它是如何工作的。假设我们想要将 `Just "johntra"` 和 `Just "volta"` 这两个值连接成一个 `String`，并在
    `Maybe` 函子内部。我们可以这样做：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Before we see how this happens, compare the preceding line with this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到它是如何发生之前，比较前面的行与这一行：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To use a normal function on applicative functors, just sprinkle some `<$>` and
    `<*>` about, and the function will operate on applicatives and return an applicative.
    How cool is that?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用性函子上使用普通函数，只需在周围撒一些 `<$>` 和 `<*>`，函数就会在应用性上操作并返回一个应用性。这有多酷？
- en: 'Back to our `(++) <$> Just "johntra" <*> Just "volta"`: First `(++)`, which
    has a type of `(++) :: [a] -> [a] -> [a]`, is mapped over `Just "johntra"`. This
    results in a value that’s the same as `Just ("johntra"++)` and has a type of `Maybe
    ([Char] -> [Char])`. Notice how the first parameter of `(++)` got eaten up and
    how the `a`s turned into `Char` values. And now `Just ("johntra"++) <*> Just "volta"`
    happens, which takes the function out of the `Just` and maps it over `Just "volta"`,
    resulting in `Just "johntravolta"`. Had either of the two values been `Nothing`,
    the result would have also been `Nothing`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '回到我们的 `(++) <$> Just "johntra" <*> Just "volta"`：首先 `(++)`，它有一个类型 `(++) ::
    [a] -> [a] -> [a]`，被映射到 `Just "johntra"` 上。这产生了一个与 `Just ("johntra"++)` 相同的值，其类型为
    `Maybe ([Char] -> [Char])`。注意 `(++)` 的第一个参数是如何被消耗掉的，以及 `a` 如何变成了 `Char` 值。现在 `Just
    ("johntra"++) <*> Just "volta"` 发生了，它从 `Just` 中提取出函数并将其映射到 `Just "volta"` 上，结果得到
    `Just "johntravolta"`。如果这两个值中的任何一个都是 `Nothing`，结果也会是 `Nothing`。'
- en: So far, we’ve used only `Maybe` in our examples, and you might be thinking that
    applicative functors are all about `Maybe`. There are loads of other instances
    of `Applicative`, so let’s meet them!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在示例中使用了 `Maybe`，你可能认为应用性函子都是关于 `Maybe` 的。实际上，`Applicative` 有很多其他实例，所以让我们来认识它们！
- en: Lists
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'Lists (actually the list type constructor, `[]`) are applicative functors.
    What a surprise! Here’s how `[]` is an instance of `Applicative`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表（实际上是列表类型构造函数 `[]`）是应用性函子。多么令人惊讶！下面是如何使 `[]` 成为 `Applicative` 的实例：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Remember that `pure` takes a value and puts it in a default context. In other
    words, it puts it in a minimal context that still yields that value. The minimal
    context for lists would be the empty list, but the empty list represents the lack
    of a value, so it can’t hold in itself the value on which we used `pure`. That’s
    why `pure` takes a value and puts it in a singleton list. Similarly, the minimal
    context for the `Maybe` applicative functor would be a `Nothing`, but it represents
    the lack of a value instead of a value, so `pure` is implemented as `Just` in
    the instance implementation for `Maybe`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`pure` 函数接受一个值并将其放入默认上下文中。换句话说，它将其放入一个最小的上下文中，但仍然可以产生该值。对于列表而言，最小的上下文将是空列表，但空列表代表没有值，因此它不能包含我们使用
    `pure` 的值。这就是为什么 `pure` 函数接受一个值并将其放入单元素列表中的原因。同样，`Maybe` 应用函子（applicative functor）的最小上下文将是
    `Nothing`，但它代表的是没有值而不是值，因此在 `Maybe` 的实例实现中 `pure` 被实现为 `Just`。
- en: 'Here’s `pure` in action:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `pure` 函数的实际应用：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'What about `<*>`? If the `<*>` function’s type were limited to only lists,
    we would get `(<*>) :: [a -> b] -> [a] -> [b]`. It’s implemented with a list comprehension.
    `<*>` must somehow extract the function out of its left parameter and then map
    it over the right parameter. But the left list can have zero functions, one function,
    or several functions inside it, and the right list can also hold several values.
    That’s why we use a list comprehension to draw from both lists. We apply every
    possible function from the left list to every possible value from the right list.
    The resulting list has every possible combination of applying a function from
    the left list to a value in the right one.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '那么 `<*>` 呢？如果 `<*>` 函数的类型仅限于列表，我们将会得到 `(<*>) :: [a -> b] -> [a] -> [b]`。它是通过列表推导实现的。`<*>`
    必须以某种方式从其左参数中提取函数，然后将其映射到右参数上。但左边的列表可以包含零个、一个或多个函数，右边的列表也可以包含多个值。这就是为什么我们使用列表推导从两个列表中抽取。我们将左列表中的每个可能的函数应用到右列表中的每个可能的值上。结果列表包含了将左列表中的函数应用到右列表中的每个值上的所有可能的组合。'
- en: 'We can use `<*>` with lists like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用 `<*>`：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The left list has three functions, and the right list has three values, so the
    resulting list will have nine elements. Every function in the left list is applied
    to every function in the right one. If we have a list of functions that take two
    parameters, we can apply those functions between two lists.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 左列表有三个函数，右列表有三个值，因此结果列表将有九个元素。左列表中的每个函数都会应用到右列表中的每个函数上。如果我们有一个接受两个参数的函数列表，我们可以在两个列表之间应用这些函数。
- en: 'In the following example, we apply two function between two lists:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们在两个列表之间应用了两个函数：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`<*>` is left-associative, so `[(+),(*)] <*> [1,2]` happens first, resulting
    in a list that’s the same as `[(1+),(2+),(1*),(2*)]`, because every function on
    the left gets applied to every value on the right. Then `[(1+),(2+),(1*),(2*)]
    <*> [3,4]` happens, which produces the final result.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`<*>` 是左结合的，所以 `[(+),(*)] <*> [1,2]` 首先发生，结果是一个与 `[(1+),(2+),(1*),(2*)]` 相同的列表，因为左边的每个函数都会应用到右边的每个值上。然后
    `[(1+),(2+),(1*),(2*)] <*> [3,4]` 发生，产生了最终结果。'
- en: Using the applicative style with lists is fun!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表的适用性风格很有趣！
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Again, we used a normal function that takes two strings between two lists of
    strings just by inserting the appropriate applicative operators.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们只是通过插入适当的适用性运算符，在两个字符串列表之间使用了一个普通函数来连接两个字符串列表。
- en: You can view lists as nondeterministic computations. A value like `100` or `"what"`
    can be viewed as a deterministic computation that has only one result, whereas
    a list like `[1,2,3]` can be viewed as a computation that can’t decide on which
    result it wants to have, so it presents us with all of the possible results. So
    when you write something like `(+) <$> [1,2,3] <*> [4,5,6]`, you can think of
    it as adding together two nondeterministic computations with `+`, only to produce
    another nondeterministic computation that’s even less sure about its result.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将列表视为非确定性计算。例如，值 `100` 或 `"what"` 可以被视为只有一个结果的确定性计算，而列表 `[1,2,3]` 可以被视为无法决定想要哪个结果的计算，因此它向我们展示了所有可能的结果。所以当你写
    `(+) <$> [1,2,3] <*> [4,5,6]` 这样的代码时，你可以将其视为使用 `+` 将两个非确定性计算相加，从而产生另一个结果更加不确定的非确定性计算。
- en: 'Using the applicative style on lists is often a good replacement for list comprehensions.
    In [Chapter 1](ch01.html "Chapter 1. Starting Out"), we wanted to see all the
    possible products of `[2,5,10]` and `[8,10,11]`, so we did this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表上使用应用式风格通常是一个很好的列表推导式的替代品。在[第1章](ch01.html "第1章。开始")中，我们想看到`[2,5,10]`和`[8,10,11]`的所有可能乘积，所以我们做了以下操作：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We’re just drawing from two lists and applying a function between every combination
    of elements. This can be done in the applicative style as well:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是从两个列表中抽取元素，并在每个元素组合之间应用一个函数。这也可以用应用式风格来完成：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This seems clearer to me, because it’s easier to see that we’re just calling
    `*` between two nondeterministic computations. If we wanted all possible products
    of those two lists that are more than 50, we would use the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我来说更清晰，因为更容易看出我们只是在两个非确定性计算之间调用`*`。如果我们想要所有大于50的两个列表的所有可能乘积，我们会使用以下代码：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It’s easy to see how `pure f <*> xs` equals `fmap f xs` with lists. `pure f`
    is just `[f]`, and `[f] <*> xs` will apply every function in the left list to
    every value in the right one, but there’s just one function in the left list,
    so it’s like mapping.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出`pure f <*> xs`与列表上的`fmap f xs`相等。`pure f`只是`[f]`，而`[f] <*> xs`将左列表中的每个函数应用到右列表中的每个值上，但由于左列表中只有一个函数，所以它就像映射。
- en: IO Is An Applicative Functor, Too
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IO 也是一个应用式函子
- en: 'Another instance of `Applicative` that we’ve already encountered is `IO`. This
    is how the instance is implemented:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到的另一个`Applicative`实例是`IO`。这是实例的实现方式：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802654.png.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802654.png.jpg)'
- en: Since `pure` is all about putting a value in a minimal context that still holds
    the value as the result, it makes sense that `pure` is just `return`. `return`
    makes an I/O action that doesn’t do anything. It just yields some value as its
    result, without performing any I/O operations like printing to the terminal or
    reading from a file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pure`的核心理念是将值置于最小的上下文中，同时仍然保持其作为结果的价值，因此`pure`仅仅是`return`是有意义的。`return`执行一个不进行任何操作的I/O操作。它只是作为其结果产生一些值，而不执行任何像向终端打印或从文件读取这样的I/O操作。
- en: 'If `<*>` were specialized for `IO`, it would have a type of `(<*>) :: IO (a
    -> b) -> IO a -> IO b`. In the case of `IO`, it takes the I/O action `a`, which
    yields a function, performs the function, and binds that function to `f`. Then
    it performs `b` and binds its result to `x`. Finally, it applies the function
    `f` to `x` and yields that as the result. We used `do` syntax to implement it
    here. (Remember that `do` syntax is about taking several I/O actions and gluing
    them into one.)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '如果`<*>`针对`IO`进行了特殊化，它将具有类型`(<*>) :: IO (a -> b) -> IO a -> IO b`。在`IO`的情况下，它接受一个产生函数的I/O操作`a`，执行该函数，并将该函数绑定到`f`。然后它执行`b`并将结果绑定到`x`。最后，它将函数`f`应用到`x`上，并产生这个结果。我们在这里使用了`do`语法来实现它。（记住，`do`语法是关于执行多个I/O操作并将它们粘合为一个。）'
- en: 'With `Maybe` and `[]`, we could think of `<*>` as simply extracting a function
    from its left parameter and then applying it over the right one. With `IO`, extracting
    is still in the game, but now we also have a notion of *sequencing*, because we’re
    taking two I/O actions and gluing them into one. We need to extract the function
    from the first I/O action, but to extract a result from an I/O action, it must
    be performed. Consider this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Maybe`和`[]`，我们可以将`<*>`视为简单地从其左参数中提取一个函数，然后将其应用到右参数上。对于`IO`，提取仍然在游戏中，但现在我们还有一个关于*序列化*的概念，因为我们正在将两个I/O操作粘合为一个。我们需要从第一个I/O操作中提取函数，但要从I/O操作中提取结果，它必须被执行。考虑以下情况：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is an I/O action that will prompt the user for two lines and yield as
    its result those two lines concatenated. We achieved it by gluing together two
    `getLine` I/O actions and a `return`, because we wanted our new glued I/O action
    to hold the result of `a ++ b`. Another way of writing this is to use the applicative
    style:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个会提示用户输入两行并作为其结果返回这两行连接的I/O操作。我们通过将两个`getLine` I/O操作和一个`return`粘合在一起来实现它，因为我们希望我们的新粘合I/O操作保留`a
    ++ b`的结果。另一种写法是使用应用式风格：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This is the same thing we did earlier when we were making an I/O action that
    applied a function between the results of two other I/O actions. Remember that
    `getLine` is an I/O action with the type `getLine :: IO String`. When we use `<*>`
    between two applicative values, the result is an applicative value, so this all
    makes sense.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '这和我们之前做的是一样的事情，当时我们在创建一个在两个其他 I/O 操作的结果之间应用函数的 I/O 操作。记住 `getLine` 是一个类型为 `getLine
    :: IO String` 的 I/O 操作。当我们使用 `<*>` 在两个应用值之间时，结果是另一个应用值，所以这一切都很有意义。'
- en: If we return to the box analogy, we can imagine `getLine` as a box that will
    go out into the real world and fetch us a string. Calling `(++) <$> getLine <*>
    getLine` makes a new, bigger box that sends those two boxes out to fetch lines
    from the terminal and then presents the concatenation of those two lines as its
    result.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到盒子类比，我们可以想象 `getLine` 是一个盒子，它会进入现实世界并为我们获取一个字符串。调用 `(++) <$> getLine <*>
    getLine` 会创建一个新的更大的盒子，它会将这两个盒子发送到终端去获取行，然后将其作为结果呈现这两个行的连接。
- en: 'The type of the expression `(++) <$> getLine <*> getLine` is `IO String`. This
    means that the expression is a completely normal I/O action like any other, which
    also yields a result value, just like other I/O actions. That’s why we can do
    stuff like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `(++) <$> getLine <*> getLine` 的类型是 `IO String`。这意味着该表达式是一个完全正常的 I/O 操作，就像其他任何操作一样，它也会产生一个结果值。这就是为什么我们可以做类似这样的事情：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Functions As Applicatives
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数作为应用
- en: Another instance of `Applicative` is `(->) r`, or functions. We don’t often
    use functions as applicatives, but the concept is still really interesting, so
    let’s take a look at how the function instance is implemented.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Applicative` 的另一个实例是 `(->) r`，或函数。我们并不经常将函数用作应用，但这个概念仍然非常有趣，所以让我们看看函数实例是如何实现的。'
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When we wrap a value into an applicative value with `pure`, the result it yields
    must be that value. A minimal default context still yields that value as a result.
    That’s why in the function instance implementation, `pure` takes a value and creates
    a function that ignores its parameter and always returns that value. The type
    for `pure` specialized for the `(->) r` instance is `pure :: a -> (r -> a)`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们用 `pure` 将一个值包裹成应用值时，它产生的结果必须是那个值。最小的默认上下文仍然会产生那个值作为结果。这就是为什么在函数实例实现中，`pure`
    接收一个值并创建一个忽略其参数并始终返回该值的函数。`pure` 对于 `(->) r` 实例的类型是 `pure :: a -> (r -> a)`。'
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Because of currying, function application is left-associative, so we can omit
    the parentheses.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于柯里化，函数应用是左结合的，所以我们可以省略括号。
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The instance implementation for `<*>` is a bit cryptic, so let’s just take
    a look at how to use functions as applicative functors in the applicative style:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`<*>` 的实例实现有点难以理解，所以我们只需看看如何以应用风格使用函数作为应用函子：'
- en: '[PRE50]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Calling `<*>` with two applicative values results in an applicative value, so
    if we use it on two functions, we get back a function. So what goes on here? When
    we do `(+) <$> (+3) <*> (*100)`, we’re making a function that will use `+` on
    the results of `(+3)` and `(*100)` and return that. With `(+) <$> (+3) <*> (*100)
    $ 5`, `(+3)` and `(*100)` are first applied to `5`, resulting in `8` and `500`.
    Then `+` is called with `8` and `500`, resulting in `508`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个应用值调用 `<*>` 会得到一个应用值，所以如果我们用它来操作两个函数，我们就会得到一个函数。那么这里发生了什么？当我们执行 `(+) <$>
    (+3) <*> (*100)` 时，我们创建了一个函数，它会在 `(+3)` 和 `(*100)` 的结果上使用 `+` 并返回那个结果。在 `(+) <$>
    (+3) <*> (*100) $ 5` 中，`(+3)` 和 `(*100)` 首先应用于 `5`，得到 `8` 和 `500`。然后 `+` 被调用，使用
    `8` 和 `500`，得到 `508`。
- en: 'The following code is similar:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码类似：
- en: '[PRE51]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We create a function that will call the function `\x y z -> [x,y,z]` with the
    eventual results from `(+3)`, `(*2)` and `(/2)`. The `5` is fed to each of the
    three functions, and then `\x y z -> [x, y, z]` is called with those results.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个函数，它会调用函数 `\x y z -> [x,y,z]`，使用 `(+3)`、`(*2)` 和 `(/2)` 的最终结果。`5` 被喂给这三个函数中的每一个，然后使用这些结果调用
    `\x y z -> [x, y, z]`。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802656.png.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802656.png.jpg)'
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It’s not very important that you get how the `(->) r` instance for `Applicative`
    works, so don’t despair if you don’t understand this all right now. Try playing
    with the applicative style and functions to get some insight into using functions
    as applicatives.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必完全理解 `Applicative` 的 `(->) r` 实例是如何工作的，所以如果你现在不理解这一切，不要绝望。尝试玩转应用风格和函数，以获得一些关于如何将函数作为应用使用的见解。
- en: Zip Lists
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩列表
- en: 'It turns out there are actually more ways for lists to be applicative functors.
    We’ve already covered one way: calling `<*>` with a list of functions and a list
    of values, which results in a list containing all the possible combinations of
    applying functions from the left list to the values in the right list.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，列表作为applicative函子有更多的方式。我们已经介绍了一种方法：使用函数列表和值列表调用`<*>`，这会产生一个包含所有可能的将左列表中的函数应用于右列表中的值的组合的列表。
- en: 'For example, if we write `[(+3),(*2)] <*> [1,2]`, `(+3)` will be applied to
    both `1` and `2`, and `(*2)` will also be applied to both `1` and `2`, resulting
    in a list that has four elements: `[4,5,2,4]`. However, `[(+3),(*2)] <*> [1,2]`
    could also work in such a way that the first function in the left list is applied
    to the first value in the right one, the second function is applied to the second
    value, and so on. That would result in a list with two values: `[4,4]`. You could
    look at it as `[1 + 3, 2 * 2]`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们编写`[(+3),(*2)] <*> [1,2]`，`(+3)`将被应用于`1`和`2`，而`(*2)`也将被应用于`1`和`2`，结果是一个包含四个元素的列表：`[4,5,2,4]`。然而，`[(+3),(*2)]
    <*> [1,2]`也可以以这种方式工作，即左列表中的第一个函数应用于右列表的第一个值，第二个函数应用于第二个值，依此类推。这将产生一个包含两个值的列表：`[4,4]`。你可以将其视为`[1
    + 3, 2 * 2]`。
- en: An instance of `Applicative` that we haven’t encountered yet is `ZipList`, and
    it lives in `Control.Applicative`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有遇到的一个`Applicative`实例是`ZipList`，它位于`Control.Applicative`中。
- en: 'Because one type can’t have two instances for the same type class, the `ZipList
    a` type was introduced, which has one constructor (`ZipList`) with just one field
    (a list). Here’s the instance:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因为一个类型不能为同一个类型类有两个实例，所以引入了`ZipList a`类型，它有一个构造函数（`ZipList`）和一个字段（一个列表）。以下是实例：
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`<*>` applies the first function to the first value, the second function to
    the second value, and so on. This is done with `zipWith (\f x -> f x) fs xs`.
    Because of how `zipWith` works, the resulting list will be as long as the shorter
    of the two lists.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`<*>`将第一个函数应用于第一个值，第二个函数应用于第二个值，依此类推。这是通过`zipWith (\f x -> f x) fs xs`完成的。由于`zipWith`的工作方式，结果列表的长度将等于两个列表中较短的那个。'
- en: '`pure` is also interesting here. It takes a value and puts it in a list that
    just has that value repeating indefinitely. `pure "haha"` results in `ZipList
    (["haha", "haha","haha"...`. This might be a bit confusing, since you’ve learned
    that `pure` should put a value in a minimal context that still yields that value.
    And you might be thinking that an infinite list of something is hardly minimal.
    But it makes sense with zip lists, because it must produce the value on every
    position. This also satisfies the law that `pure f <*> xs` should equal `fmap
    f xs`. If `pure 3` just returned `ZipList [3]`, `pure (*2) <*> ZipList [1,5,10]`
    would result in `ZipList [2]`, because the resulting list of two zipped lists
    has the length of the shorter of the two. If we zip a finite list with an infinite
    list, the length of the resulting list will always be equal to the length of the
    finite list.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`pure`在这里也很有趣。它接受一个值并将其放入一个只重复该值无限次的列表中。`pure "haha"`的结果是`ZipList (["haha",
    "haha","haha"...`。这可能会有些令人困惑，因为你已经了解到`pure`应该将值放入一个最小化但仍能产生该值的上下文中。你可能还在想，无限列表几乎不可能是最小化的。但是，在zip列表中，这是有意义的，因为它必须在每个位置上产生该值。这也满足了`pure
    f <*> xs`应该等于`fmap f xs`的法律。如果`pure 3`仅仅返回`ZipList [3]`，那么`pure (*2) <*> ZipList
    [1,5,10]`将导致`ZipList [2]`，因为两个zip列表组合后的列表长度等于两个列表中较短的那个。如果我们用一个有限列表和一个无限列表进行zip，结果列表的长度将始终等于有限列表的长度。'
- en: 'So how do zip lists work in an applicative style? Well, the `ZipList a` type
    doesn’t have a `Show` instance, so we need to use the `getZipList` function to
    extract a raw list from a zip list:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，zip列表在applicative风格中是如何工作的呢？嗯，`ZipList a`类型没有`Show`实例，因此我们需要使用`getZipList`函数从一个zip列表中提取一个原始列表：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `(,,)` function is the same as `\x y z -> (x,y,z)`. Also, the `(,)` function
    is the same as `\x y -> (x,y)`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`(,,)`函数等同于`\x y z -> (x,y,z)`。同样，`(,)`函数等同于`\x y -> (x,y)`。'
- en: Aside from `zipWith`, the standard library has functions such as `zipWith3`
    and `zipWith4`, all the way up to `zipWith7`. `zipWith` takes a function that
    takes two parameters and zips two lists with it. `zipWith3` takes a function that
    takes three parameters and zips three lists with it, and so on. By using zip lists
    with an applicative style, we don’t need to have a separate zip function for each
    number of lists that we want to zip together. We just use the applicative style
    to zip together an arbitrary amount of lists with a function, and that’s pretty
    handy.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `zipWith` 之外，标准库还有 `zipWith3`、`zipWith4` 等函数，一直可以到 `zipWith7`。`zipWith` 接受一个接受两个参数的函数，并用它来连接两个列表。`zipWith3`
    接受一个接受三个参数的函数，并用它来连接三个列表，以此类推。通过使用以应用风格连接的列表，我们不需要为想要连接的每个列表数量都有一个单独的连接函数。我们只需使用应用风格将任意数量的列表与一个函数连接起来，这非常方便。
- en: Applicative Laws
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用定律
- en: 'Like normal functors, applicative functors come with a few laws. The most important
    law is the one that `pure f <*> x = fmap f x` holds. As an exercise, you can prove
    this law for some of the applicative functors that we’ve met in this chapter.
    The following are the other applicative laws:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如正常的函子一样，应用函子附带一些定律。最重要的定律是 `pure f <*> x = fmap f x` 这个定律。作为一个练习，你可以为我们在本章中遇到的一些应用函子证明这个定律。以下是一些其他的应用定律：
- en: '`pure id <*> v = v`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pure id <*> v = v`'
- en: '`pure (.) <*> u <*> v <*> w = u <*> (v <*> w)`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pure (.) <*> u <*> v <*> w = u <*> (v <*> w)`'
- en: '`pure f <*> pure x = pure (f x)`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pure f <*> pure x = pure (f x)`'
- en: '`u <*> pure y = pure ($ y) <*> u`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u <*> pure y = pure ($ y) <*> u`'
- en: We won’t go over them in detail because that would take up a lot of pages and
    be kind of boring. If you’re interested, you can take a closer look at them and
    see if they hold for some of the instances.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细讨论它们，因为这会占用很多页面并且有点无聊。如果你感兴趣，你可以仔细看看它们，看看它们是否适用于某些实例。
- en: Useful Functions for Applicatives
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用函子的有用函数
- en: '`Control.Applicative` defines a function that’s called `liftA2`, which has
    the following type:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Control.Applicative` 定义了一个名为 `liftA2` 的函数，其类型如下：'
- en: '[PRE54]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It’s defined like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 它被定义为这样：
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It just applies a function between two applicatives, hiding the applicative
    style that we’ve discussed. However, it clearly showcases why applicative functors
    are more powerful than ordinary functors.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是在一个应用值之间应用一个函数，隐藏了我们讨论过的应用风格。然而，它清楚地展示了为什么应用函子比普通函子更强大。
- en: With ordinary functors, we can just map functions over one functor value. With
    applicative functors, we can apply a function between several functor values.
    It’s also interesting to look at this function’s type as `(a -> b -> c) -> (f
    a -> f b -> f c)`. When we look at it like this, we can say that `liftA2` takes
    a normal binary function and promotes it to a function that operates on two applicatives.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通函子，我们可以在一个函子值上映射函数。对于应用函子，我们可以在几个函子值之间应用一个函数。观察这个函数的类型 `(a -> b -> c) ->
    (f a -> f b -> f c)` 也很有趣。当我们这样看待它时，我们可以说 `liftA2` 接受一个正常的二元函数并将其提升为一个在两个应用值上操作的函数。
- en: 'Here’s an interesting concept: We can take two applicative values and combine
    them into one applicative value that has inside it the results of those two applicative
    values in a list. For instance, we have `Just 3` and `Just 4`. Let’s assume that
    the second one contains a singleton list, because that’s really easy to achieve:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的概念：我们可以取两个应用值并将它们组合成一个应用值，其中包含这两个应用值的结果列表。例如，我们有 `Just 3` 和 `Just 4`。让我们假设第二个包含一个单元素列表，因为这很容易实现：
- en: '[PRE56]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Okay, so let’s say we have `Just 3` and `Just [4]`. How do we get `Just [3,4]`?
    That’s easy:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以假设我们有 `Just 3` 和 `Just [4]`。我们如何得到 `Just [3,4]`？这很简单：
- en: '[PRE57]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Remember that `:` is a function that takes an element and a list and returns
    a new list with that element at the beginning. Now that we have `Just [3,4]`,
    could we combine that with `Just 2` to produce `Just [2,3,4]`? Yes, we could.
    It seems that we can combine any amount of applicative values into one applicative
    value that has a list of the results of those applicative values inside it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 `:` 是一个函数，它接受一个元素和一个列表，并返回一个新列表，其中包含该元素在开头。现在我们有了 `Just [3,4]`，我们能否将其与 `Just
    2` 结合以产生 `Just [2,3,4]`？是的，我们可以。看起来我们可以将任意数量的应用值组合成一个包含那些应用值结果列表的应用值。
- en: Let’s try implementing a function that takes a list of applicative values and
    returns an applicative value that has a list as its result value. We’ll call it
    `sequenceA`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试实现一个函数，它接受一个应用值列表并返回一个结果值为列表的应用值。我们将它称为 `sequenceA`。
- en: '[PRE58]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Ah, recursion! First, we look at the type. It will transform a list of applicative
    values into an applicative value with a list. From that, we can lay some groundwork
    for a base case. If we want to turn an empty list into an applicative value with
    a list of results, we just put an empty list in a default context. Now comes the
    recursion. If we have a list with a head and a tail (remember that `x` is an applicative
    value and `xs` is a list of them), we call `sequenceA` on the tail, which results
    in an applicative value with a list inside. Then we just prepend the value inside
    the applicative `x` into that applicative with a list, and that’s it!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，递归！首先，我们看看类型。它将一个applicative值的列表转换成一个包含列表的applicative值。从那以后，我们可以为基本情况打下一些基础。如果我们想将一个空列表转换成一个包含结果列表的applicative值，我们只需将一个空列表放入默认上下文中。现在轮到递归了。如果我们有一个包含头部和尾部的列表（记住`x`是一个applicative值，而`xs`是它们的列表），我们在尾部上调用`sequenceA`，这将产生一个包含列表的applicative值。然后我们只需将applicative
    `x`中的值作为列表的前缀添加到那个applicative中，这样就完成了！
- en: 'Suppose we do this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们这样做：
- en: '[PRE59]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'By definition, that’s equal to the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，这等于以下内容：
- en: '[PRE60]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Breaking this down further, we get this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步分解，我们得到以下内容：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We know that `sequenceA []` ends up as being `Just []`, so this expression
    is now as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`sequenceA []`最终会变成`Just []`，所以这个表达式现在如下所示：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'which is this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This equals `Just [1,2]`!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这等于`Just [1,2]`！
- en: 'Another way to implement `sequenceA` is with a fold. Remember that pretty much
    any function where we go over a list element by element and accumulate a result
    along the way can be implemented with a fold:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`sequenceA`的另一种方式是使用折叠。记住，几乎任何通过遍历列表元素并沿途累积结果的函数都可以使用折叠来实现：
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We approach the list from the right and start off with an accumulator value
    of `pure []`. We put `liftA2 (:)` between the accumulator and the last element
    of the list, which results in an applicative that has a singleton in it. Then
    we call `liftA2 (:)` with the now last element and the current accumulator and
    so on, until we’re left with just the accumulator, which holds a list of the results
    of all the applicatives.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从列表的右侧开始处理列表，并使用一个累加器值`pure []`作为起始值。我们在累加器和列表的最后一个元素之间放置`liftA2 (:)`，这会产生一个包含单例元素的applicative。然后我们使用现在的最后一个元素和当前的累加器调用`liftA2
    (:)`，以此类推，直到我们只剩下一个累加器，它包含所有applicative的结果列表。
- en: 'Let’s give our function a whirl on some applicatives:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一些applicative上试一下我们的函数：
- en: '[PRE65]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: When used on `Maybe` values, `sequenceA` creates a `Maybe` value with all the
    results inside it as a list. If one of the values is `Nothing`, then the result
    is also a `Nothing`. This is cool when you have a list of `Maybe` values, and
    you’re interested in the values only if none of them is a `Nothing`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于`Maybe`值时，`sequenceA`创建一个包含所有结果列表的`Maybe`值。如果一个值是`Nothing`，那么结果也是`Nothing`。当你有一系列`Maybe`值，并且你只对那些没有`Nothing`的值感兴趣时，这很酷。
- en: When used with functions, `sequenceA` takes a list of functions and returns
    a function that returns a list. In our example, we made a function that took a
    number as a parameter and applied it to each function in the list and then returned
    a list of results. `sequenceA [(+3),(+2),(+1)] 3` will call `(+3)` with `3`, `(+2)`
    with `3`, and `(+1)` with `3`, and present all those results as a list.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当与函数一起使用时，`sequenceA`接受一个函数列表，并返回一个返回列表的函数。在我们的例子中，我们创建了一个函数，它接受一个数字作为参数，并将其应用于列表中的每个函数，然后返回一个结果列表。`sequenceA
    [(+3),(+2),(+1)] 3`将使用`3`调用`(+3)`，使用`3`调用`(+2)`，使用`3`调用`(+1)`，并将所有这些结果作为列表展示。
- en: Doing `(+) <$> (+3) <*> (*2)` will create a function that takes a parameter,
    feeds it to both `(+3)` and `(*2)`, and then calls `+` with those two results.
    In the same vein, it makes sense that `sequenceA [(+3),(*2)]` makes a function
    that takes a parameter and feeds it to all of the functions in the list. Instead
    of calling `+` with the results of the functions, a combination of `:` and `pure
    []` is used to gather those results in a list, which is the result of that function.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`(+) <$> (+3) <*> (*2)`将创建一个函数，该函数接受一个参数，将其传递给`(+3)`和`(*2)`，然后使用这两个结果调用`+`。同样地，`sequenceA
    [(+3),(*2)]`创建一个函数，该函数接受一个参数，并将其传递给列表中的所有函数。而不是使用函数的结果调用`+`，而是使用`:`和`pure []`的组合来收集这些结果到一个列表中，这就是该函数的结果。
- en: 'Using `sequenceA` is useful when we have a list of functions and we want to
    feed the same input to all of them and then view the list of results. For instance,
    suppose that we have a number and we’re wondering whether it satisfies all of
    the predicates in a list. Here’s one way to do that:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一系列函数，并希望将相同的输入提供给所有这些函数，然后查看结果列表时，使用`sequenceA`是有用的。例如，假设我们有一个数字，我们想知道它是否满足列表中的所有谓词。这里有一种方法可以做到这一点：
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Remember that `and` takes a list of Booleans and returns `True` if they’re
    all `True`. Another way to achieve the same thing is with `sequenceA`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`and`接受一个布尔值列表，如果它们都是`True`，则返回`True`。另一种实现相同功能的方法是使用`sequenceA`：
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '`sequenceA [(>4),(<10),odd]` creates a function that will take a number and
    feed it to all of the predicates in `[(>4),(<10),odd]` and return a list of Booleans.
    It turns a list with the type `(Num a) => [a -> Bool]` into a function with the
    type `(Num a) => a -> [Bool]`. Pretty neat, huh?'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`sequenceA [(>4),(<10),odd]`创建一个函数，该函数将接受一个数字并将其提供给`[(>4),(<10),odd]`中的所有谓词，并返回一个布尔值列表。它将类型为`(Num
    a) => [a -> Bool]`的列表转换为类型为`(Num a) => a -> [Bool]`的函数。非常巧妙，不是吗？'
- en: Because lists are homogenous, all the functions in the list must be functions
    of the same type. You can’t have a list like `[ord, (+3)]`, because `ord` takes
    a character and returns a number, whereas `(+3)` takes a number and returns a
    number.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表是同质的，列表中的所有函数都必须是相同类型的函数。你不能有一个像`[ord, (+3)]`这样的列表，因为`ord`接受一个字符并返回一个数字，而`(+3)`接受一个数字并返回一个数字。
- en: 'When used with `[]`, `sequenceA` takes a list of lists and returns a list of
    lists. It actually creates lists that have all possible combinations of their
    elements. For illustration, here’s the preceding example done with `sequenceA`
    and then done with a list comprehension:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`[]`一起使用时，`sequenceA`接受一个列表的列表，并返回一个列表的列表。它实际上创建了包含所有可能元素组合的列表。为了说明，这里是用`sequenceA`和列表推导式完成的先前的例子：
- en: '[PRE68]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`(+) <$> [1,2] <*> [4,5,6]` results in a nondeterministic computation `x +
    y`, where `x` takes on every value from `[1,2]` and `y` takes on every value from
    `[4,5,6]`. We represent that as a list that holds all of the possible results.
    Similarly, when we call `sequenceA [[1,2],[3,4],[5,6]]`, the result is a nondeterministic
    computation `[x,y,z]`, where `x` takes on every value from `[1,2]`, `y` takes
    on every value from `[3,4]` and so on. To represent the result of that nondeterministic
    computation, we use a list, where each element in the list is one possible list.
    That’s why the result is a list of lists.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`(+) <$> [1,2] <*> [4,5,6]`的结果是一个非确定性计算`x + y`，其中`x`取自`[1,2]`中的每个值，`y`取自`[4,5,6]`中的每个值。我们将其表示为一个包含所有可能结果的列表。同样，当我们调用`sequenceA
    [[1,2],[3,4],[5,6]]`时，结果是`[x,y,z]`的非确定性计算，其中`x`取自`[1,2]`中的每个值，`y`取自`[3,4]`中的每个值，依此类推。为了表示这个非确定性计算的结果，我们使用一个列表，其中每个元素都是一个可能的列表。这就是为什么结果是列表的列表。'
- en: When used with I/O actions, `sequenceA` is the same thing as `sequence`! It
    takes a list of I/O actions and returns an I/O action that will perform each of
    those actions and have as its result a list of the results of those I/O actions.
    That’s because to turn an `[IO a]` value into an `IO [a]` value, to make an I/O
    action that yields a list of results when performed, all those I/O actions must
    be sequenced so that they’re then performed one after the other when evaluation
    is forced. You can’t get the result of an I/O action without performing it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当与I/O操作一起使用时，`sequenceA`与`sequence`相同！它接受一个I/O操作的列表，并返回一个I/O操作，该操作将执行每个操作，并将结果作为执行这些I/O操作的结果的列表。这是因为要将`[IO
    a]`值转换为`IO [a]`值，以使I/O操作在执行时产生一个结果列表，所有这些I/O操作都必须按顺序排列，以便在求值时依次执行。你无法在不执行的情况下获得I/O操作的结果。
- en: 'Let’s sequence three `getLine` I/O actions:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按顺序排列三个`getLine` I/O操作：
- en: '[PRE69]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In conclusion, applicative functors aren’t just interesting, they’re also useful.
    They allow us to combine different computations—such as I/O computations, nondeterministic
    computations, computations that might have failed, and so on—by using the applicative
    style. Just by using `<$>` and `<*>`, we can employ normal functions to uniformly
    operate on any number of applicative functors and take advantage of the semantics
    of each one.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，应用函子不仅有趣，而且有用。它们允许我们通过应用风格结合不同的计算——例如I/O计算、非确定性计算、可能失败的计算等等。仅仅通过使用`<$>`和`<*>`，我们就可以使用普通函数对任意数量的应用函子进行统一操作，并利用每个函子的语义。
