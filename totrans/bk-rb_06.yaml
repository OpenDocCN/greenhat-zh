- en: Chapter 6. Conditional Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Computer programs, like life itself, are full of difficult decisions waiting
    to be made. Things like “If I stay in bed, I will get more sleep, else I will
    have to go to work; if I go to work, I will earn some money, else I will lose
    my job,” and so on. You’ve already performed a number of `if` tests in previous
    programs. To take a simple example, this is from the Tax calculator in [Chapter 1](ch01.html
    "Chapter 1. Strings, Numbers, Classes, and Objects"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this program, the user was prompted to enter a value, `subtotal`, that was
    then used in order to calculate the tax due on it. If the user, in a fit of madness,
    enters a value less than 0, the `if` test spots this since the test `(subtotal
    < 0.0)` evaluates to true, which causes the body of the code between the `if`
    test and the `end` keyword to be executed; here, this sets the value of `subtotal`
    to 0.
  prefs: []
  type: TYPE_NORMAL
- en: if..then..else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple test like this has only one of two possible results. Either a bit
    of code is run or it isn’t, depending on whether the test evaluates to true or
    not. Often, you will need to have more than two possible outcomes. Let’s suppose,
    for example, that your program needs to follow one course of action if the day
    is a weekday and a different course of action if it is a weekend. You can test
    these conditions by adding an `else` section after the `if` section, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*if_else.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like many other programming languages, Ruby uses one equal sign (`=`) to assign
    a value and two (`==`) to test a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` condition here is straightforward. It tests two possible conditions:
    if the value of the variable `aDay` is equal to the string “Saturday” and if the
    value of `aDay` is equal to the string “Sunday.” If either of those conditions
    is true, then the next line of code executes `daytype = ''weekend''`; in all other
    cases, the code after `else` executes `daytype = ''weekday''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When an `if` test and the code to be executed are placed on separate lines,
    the `then` keyword is optional. When the test and the code are placed on a single
    line, the `then` keyword is obligatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '*if_then.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In Ruby 1.8, a colon character (`:`) was permitted as an alternative to `then`.
    This syntax is not supported in Ruby 1.9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'An `if` test isn’t restricted to evaluating just two conditions. Let’s suppose,
    for example, that your code needs to work out whether a certain day is a working
    day or a holiday. All weekdays are working days; all Saturdays are holidays, but
    Sundays are only holidays when you are not working overtime. This is my first
    attempt to write a test to evaluate all these conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*and_or_wrong.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this doesn’t have quite the effect intended. Remember that Saturday
    is always a holiday. But this code insists that Saturday is a working day. This
    is because Ruby takes the test to mean “If the day is Saturday and I am not working
    overtime or if the day is Sunday and I am not working overtime,” whereas what
    I really meant was “If the day is Saturday or if the day is Sunday and I am not
    working overtime.” The easiest way to resolve this ambiguity is to put parentheses
    around any code to be evaluated as a single unit, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*and_or.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: and, or, and not
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Incidentally, Ruby has two different syntaxes for testing Boolean (true/false)
    conditions. In the previous example, I’ve used the English-language style operators:
    `and`, `or`, and `not`. If you prefer, you could use alternative operators similar
    to those used in many other programming languages, namely, `&&` (and), `||` (or),
    and `!` (not).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful, though: The two sets of operators aren’t completely interchangeable.
    For one thing, they have different precedence, which means that when multiple
    operators are used in a single test, the parts of the test may be evaluated in
    different orders depending on which operators you use. For example, look at this
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '*days.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that the Boolean variable `working_overtime` is true, would this test
    succeed if the variable `aDay` were initialized with the string “Saturday”? In
    other words, would `daytype` be assigned the value “holiday” if `aDay` is “Saturday”?
    The answer is no, it wouldn’t. The test will succeed only if `aDay` is either
    “Saturday” or “Sunday” and `working_overtime` is not true. So, when `or` is used
    in the previous code, Saturday would be deemed to be a working day.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: On the face of it, this is the same test as the last one; the only difference
    is that this time I’ve used the alternative syntax for the operators. However,
    the change is more than cosmetic since if `aDay` is “Saturday,” this test evaluates
    to true and `daytype` is initialized with the value “holiday.” This is because
    the `||` operator has a higher precedence than the `or` operator. So, this test
    succeeds either if `aDay` is “Saturday” *or* if `aDay` is “Sunday” and `working_overtime`
    is not true. So, when `||` is used in the previous code, Saturday would be deemed
    to be a holiday.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [Digging Deeper](ch06s07.html#digging_deeper-id5 "Digging Deeper")
    in [Digging Deeper](ch06s07.html#digging_deeper-id5 "Digging Deeper") for more
    on this. As a general principle, you would do well to decide which set of operators
    you prefer—stick to them and use parentheses to avoid ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: Negation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, I used the negation operator (`!`) in the expression
    `!working_overtime`, which can be read as “not working_overtime.” The negation
    operator can be used at the start of an expression; as an alternative, you can
    use the “not equals” (`!=` ) operator between the left and right sides of an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '*negation.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `not` instead of `!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: if..elsif
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will no doubt be occasions when you will need to take multiple different
    actions based on several alternative conditions. One way of doing this is by evaluating
    one `if` condition followed by a series of other test conditions placed after
    the keyword `elsif`. The whole lot must then be terminated using the `end` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here I am repeatedly taking input from a user inside a `while`
    loop. An `if` condition tests whether the user enters “q” (I’ve used `chomp()`
    to remove the carriage return from the input). If “q” is not entered, the first
    `elsif` condition tests whether the integer value of the input (`input.to_i`)
    is greater than 800; if this test fails, the next `elsif` condition tests whether
    it is less than or equal to 800:'
  prefs: []
  type: TYPE_NORMAL
- en: '*if_elsif.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this program is that, even though it asks the user to enter
    a value between 1 and 1,000, it accepts values less than 1 (incidentally, if you
    really want a salary in negative figures, I’ll be glad to offer you a job!) and
    greater than 1,000 (in which case, don’t look to me for employment!).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can fix this by rewriting the two `elsif` conditions and adding an `else`
    section that executes if all the preceding tests fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '*if_elsif2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Shorthand Notation for if..then..else
  prefs: []
  type: TYPE_NORMAL
- en: Ruby also has a short-form notation for `if..then..else` in which a question
    mark (`?`) replaces the `if..then` part and a colon (`:`) acts as `else`. Formally,
    this may be known either as a *ternary operator* or as a *conditional operator*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When the test condition is complex (if it uses `and`s and `or`s), you should
    enclose it in parentheses. If the tests and code span several lines, the `?` must
    be placed on the same line as the preceding condition and the `:` must be placed
    on the same line as the code immediately following the `?`. In other words, if
    you put a newline before the `?` or the `:`, you will generate a syntax error.
    This is an example of a valid multiline code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*if_else_alt.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example of a longer sequence of `if..elsif` sections followed
    by a catchall `else` section. This time the trigger value, `i`, is an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*days2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that I’ve used the range `(6..7)` to match the two integer values for
    Saturday and Sunday. The `===` method (that is, three `=` characters) tests whether
    a value (here `i`) is a member of the range. In the previous example, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'could be rewritten as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `===` method is defined by the Object class and overridden in descendant
    classes. Its behavior varies according to the class. As you will see shortly,
    one of its fundamental uses is to provide meaningful tests for `case` statements.
  prefs: []
  type: TYPE_NORMAL
- en: unless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ruby also can also perform `unless` tests, which are the exact opposite of
    `if` tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '*unless.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Think of `unless` as being an alternative way of expressing “if not.” The following
    is equivalent to the previous code; both consider Saturday and Sunday to be the
    weekend and other days to be weekdays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: if and unless Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may recall the alternative syntax for `while` loops mentioned in [Chapter 5](ch05.html
    "Chapter 5. Loops and Iterators"). Instead of writing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'you can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This alternative syntax, in which the `while` keyword is placed between the
    code to execute and the test condition, is called a *while modifier*. It turns
    out that Ruby has `if` and `unless` modifiers too. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '*if_unless_mod.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The terseness of this syntax is useful when you repeatedly need to take some
    well-defined action if some condition is true. You might, for example, pepper
    your code with debugging output if a constant called `DEBUG` is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Case Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to take a variety of different actions based on the value of a
    single variable, multiple `if..elsif` tests are verbose and repetitive.
  prefs: []
  type: TYPE_NORMAL
- en: A neater alternative is provided by a `case` statement. This begins with the
    word `case` followed by the variable name to test. Then comes a series of `when`
    sections, each of which specifies a “trigger” value followed by some code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code executes only when the test variable equals the trigger value:'
  prefs: []
  type: TYPE_NORMAL
- en: '*case.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Constants
  prefs: []
  type: TYPE_NORMAL
- en: 'In principle, constants are objects whose values never change. For example,
    `PI` in Ruby’s `Math` module is a constant. Constants in Ruby begin with a capital
    letter. Class names are also constants. You can obtain a list of all defined constants
    using the `constants` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Ruby provides the `const_get` and `const_set` methods to get and set the value
    of named constants specified as symbols (identifiers preceded by a colon such
    as `:RUBY_VERSION`). Note that, unlike the constants in many other programming
    languages, Ruby’s constants may be assigned new values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous reassignment of the `RUBY_VERSION` constant produces an “already
    initialized constant” warning but not an error! You can even reassign constants
    declared in Ruby’s standard class library. For example, here I reassign the value
    of `PI`. Although this displays a warning, the assignment succeeds nonetheless:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You need to be aware that the constancy of Ruby’s constants is a programming
    *convention*, rather than a rigorously enforced *rule*. Naturally, it is not good
    programming practice to reassign constants.
  prefs: []
  type: TYPE_NORMAL
- en: '*constants.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '*math_pi.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, I’ve used the `then` keyword to separate each `when`
    test from the code to execute. In Ruby 1.8, just as with `if` tests mentioned
    earlier, you could use a colon as an alternative, but this syntax is not supported
    in Ruby 1.9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `then` can be omitted if the test and the code to be executed are on separate
    lines. Unlike `case` statements in C-like languages, there is no need to enter
    a `break` keyword when a match is made in order to prevent execution trickling
    down through the remainder of the sections. In Ruby, once a match is made, the
    `case` statement exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '*case_break.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can include several lines of code between each `when` condition, and you
    can include multiple values separated by commas to trigger a single `when` block,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The condition in a `case` statement is not obliged to be a simple variable;
    it can be an expression like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*case2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use noninteger types such as a string. If multiple trigger values
    are specified in a `when` section, they may be of varying types—for example, both
    string and integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a longer example, illustrating some of the syntactical elements mentioned
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '*case3.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The === Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the `when` tests on an object used in a `case` statement
    are performed using the `===` method. So, for example, just as the `===` method
    returns true when an integer forms part of a range, a `when` test returns true
    when an integer variable in a `case` statement forms part of a range expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If in doubt on the effect of the `===` method for a specific object, refer
    to the Ruby documentation on that object’s class. Ruby’s standard classes are
    documented in the core API here: [http://www.ruby-doc.org/](http://www.ruby-doc.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Case Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is an alternative form of the `case` statement that is like a shorthand
    form of a series of `if..then..else` statements. Each `when` section can perform
    some arbitrary test and execute one or more lines of code. No `case` variable
    is required. Each `when` section returns a value that, just like a method, is
    the result of the last piece of code that’s evaluated. This value can be assigned
    to a variable preceding the `case` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '*case4.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: There is more to Ruby comparison operators than meets the eye. Here you will
    learn about their effects and side effects and discover how to break out of blocks
    when a condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Operators
  prefs: []
  type: TYPE_NORMAL
- en: The following operators are available in Ruby for testing expressions that may
    yield true or false values.
  prefs: []
  type: TYPE_NORMAL
- en: '| `and` and `&&` | These operators evaluate the left-hand side; only if the
    result is true do they then evaluate the right side. `and` has lower precedence
    than `&&`. |'
  prefs: []
  type: TYPE_TB
- en: '| `or` and `&#124;&#124;` | These operators evaluate the left-hand side; if
    the result is false, then they evaluate the right side. `or` has lower precedence
    than `&#124;&#124;`. |'
  prefs: []
  type: TYPE_TB
- en: '| `not` and `!` | These operators negate a Boolean value; in other words, they
    return true when false and return false when true. |'
  prefs: []
  type: TYPE_TB
- en: Be careful when using the alternative Boolean operators. Because of the difference
    in precedence, conditions will be evaluated in different orders and may yield
    different results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*boolean_ops.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: These may look the same at first sight. In fact, Example 1 prints “false,” while
    Example 2 prints “true.” This is entirely because `or` has lower precedence than
    `||`. As a consequence, Example 1 tests “if 1 equals 3 [*false*] and (either 2
    equals 1 or 3 equals 3) [*true*].” Because one of these two necessary conditions
    is false, the entire test returns false.
  prefs: []
  type: TYPE_NORMAL
- en: Now look at Example 2\. This tests “(if 1 equals 3 and 2 equals 1) [*false*]
    or 3 equals 3 [*true*].” This time, you need only one of the two tests to succeed;
    the second test evaluates to true so the entire tests returns true.
  prefs: []
  type: TYPE_NORMAL
- en: 'The side effects of operator precedence in this kind of test can lead to very
    obscure bugs. You can avoid these by clarifying the meaning of the test using
    parentheses. Here, I have rewritten Examples 1 and 2; in each case, the addition
    of one pair of parentheses has inverted the initial Boolean value returned by
    the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Eccentricities of Boolean Operators
  prefs: []
  type: TYPE_NORMAL
- en: 'Be warned that Ruby’s Boolean operators can sometimes behave in a curious and
    unpredictable manner. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*eccentricities.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In many cases, you can avoid problems by sticking to one style of operator (either
    `and`, `or`, and `not` *or* `&&`, `||`, and `!`) rather than mixing the two. In
    addition, the generous use of parentheses is recommended!
  prefs: []
  type: TYPE_NORMAL
- en: catch and throw
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby provides a pair of methods, `catch` and `throw`, which can be used to
    break out of a block of code when some condition is met. This is Ruby’s nearest
    equivalent to a `goto` in some other programming languages. The block must begin
    with `catch` followed by a symbol (that is, a unique identifier preceded by a
    colon), such as `:done` or `:finished`. The block itself may be delimited either
    by curly brackets or by the keywords `do` and `end`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the block, you can call `throw` with a symbol as an argument. Normally
    you would call `throw` when some specific condition is met that makes it desirable
    to skip all the remaining code in the block. For instance, let’s assume the block
    contains some code that prompts the user to enter a number, divides some value
    by that number, and then goes on to do a multitude of other complex calculations
    with the result. Obviously, if the user enters 0, then none of the calculations
    that follow can be completed, so you would want to skip them all by jumping right
    out of the block and continuing with any code that follows it. This is one way
    of doing that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*catch_throw.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can, in fact, have a call to `throw` outside the block, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can have `catch` blocks nested inside other `catch` blocks, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As with `goto`s and jumps in other programming languages, `catch` and `throw`
    in Ruby should be used with great care because they break the logic of your code
    and can, potentially, introduce hard-to-find bugs.
  prefs: []
  type: TYPE_NORMAL
