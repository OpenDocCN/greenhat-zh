- en: Chapter 6. Conditional Statements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。条件语句
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: 'Computer programs, like life itself, are full of difficult decisions waiting
    to be made. Things like “If I stay in bed, I will get more sleep, else I will
    have to go to work; if I go to work, I will earn some money, else I will lose
    my job,” and so on. You’ve already performed a number of `if` tests in previous
    programs. To take a simple example, this is from the Tax calculator in [Chapter 1](ch01.html
    "Chapter 1. Strings, Numbers, Classes, and Objects"):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序，就像生活本身一样，充满了等待做出的艰难决定。比如“如果我待在床上，我会睡得更香，否则我不得不去工作；如果我去工作，我会赚些钱，否则我会失去我的工作”，等等。你已经在之前的程序中执行了许多
    `if` 测试。以一个简单的例子来说，这是来自第1章中的税计算器（[第1章](ch01.html "第1章。字符串、数字、类和对象")）：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this program, the user was prompted to enter a value, `subtotal`, that was
    then used in order to calculate the tax due on it. If the user, in a fit of madness,
    enters a value less than 0, the `if` test spots this since the test `(subtotal
    < 0.0)` evaluates to true, which causes the body of the code between the `if`
    test and the `end` keyword to be executed; here, this sets the value of `subtotal`
    to 0.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，用户被提示输入一个值，`subtotal`，然后用来计算其上的税额。如果用户在疯狂中输入一个小于0的值，`if` 测试会检测到这一点，因为测试
    `(subtotal < 0.0)` 评估为真，这会导致 `if` 测试和 `end` 关键字之间的代码块被执行；在这里，这会将 `subtotal` 的值设置为0。
- en: if..then..else
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if..then..else
- en: 'A simple test like this has only one of two possible results. Either a bit
    of code is run or it isn’t, depending on whether the test evaluates to true or
    not. Often, you will need to have more than two possible outcomes. Let’s suppose,
    for example, that your program needs to follow one course of action if the day
    is a weekday and a different course of action if it is a weekend. You can test
    these conditions by adding an `else` section after the `if` section, like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的简单测试只有两种可能的结果之一。要么运行一小段代码，要么不运行，这取决于测试是否评估为真。通常，你需要超过两种可能的结果。假设，例如，如果你的程序需要根据一天是工作日还是周末采取不同的行动方案。你可以在
    `if` 部分之后添加一个 `else` 部分，如下所示：
- en: '*if_else.rb*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*if_else.rb*'
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Like many other programming languages, Ruby uses one equal sign (`=`) to assign
    a value and two (`==`) to test a value.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他编程语言一样，Ruby 使用一个等号（`=`）来赋值，使用两个等号（`==`）来测试值。
- en: 'The `if` condition here is straightforward. It tests two possible conditions:
    if the value of the variable `aDay` is equal to the string “Saturday” and if the
    value of `aDay` is equal to the string “Sunday.” If either of those conditions
    is true, then the next line of code executes `daytype = ''weekend''`; in all other
    cases, the code after `else` executes `daytype = ''weekday''`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `if` 条件很简单。它测试两种可能的情况：如果变量 `aDay` 的值等于字符串“Saturday”，或者 `aDay` 的值等于字符串“Sunday”。如果这两个条件中的任何一个为真，则执行下一行代码
    `daytype = 'weekend'`；在其他所有情况下，执行 `else` 之后的代码 `daytype = 'weekday'`。
- en: 'When an `if` test and the code to be executed are placed on separate lines,
    the `then` keyword is optional. When the test and the code are placed on a single
    line, the `then` keyword is obligatory:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 `if` 测试和要执行的代码放在不同的行上时，`then` 关键字是可选的。当测试和代码放在同一行上时，`then` 关键字是必需的：
- en: '*if_then.rb*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*if_then.rb*'
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In Ruby 1.8, a colon character (`:`) was permitted as an alternative to `then`.
    This syntax is not supported in Ruby 1.9:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 1.8 中，冒号字符（`:`）被允许作为 `then` 的替代。这种语法在 Ruby 1.9 中不受支持：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'An `if` test isn’t restricted to evaluating just two conditions. Let’s suppose,
    for example, that your code needs to work out whether a certain day is a working
    day or a holiday. All weekdays are working days; all Saturdays are holidays, but
    Sundays are only holidays when you are not working overtime. This is my first
    attempt to write a test to evaluate all these conditions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 测试不仅限于评估两个条件。假设，例如，你的代码需要确定某一天是工作日还是假日。所有工作日都是工作日；所有周六都是假日，但周日只有在你不加班的情况下才是假日。这是我第一次尝试编写一个测试来评估所有这些条件：'
- en: '*and_or_wrong.rb*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*and_or_wrong.rb*'
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Unfortunately, this doesn’t have quite the effect intended. Remember that Saturday
    is always a holiday. But this code insists that Saturday is a working day. This
    is because Ruby takes the test to mean “If the day is Saturday and I am not working
    overtime or if the day is Sunday and I am not working overtime,” whereas what
    I really meant was “If the day is Saturday or if the day is Sunday and I am not
    working overtime.” The easiest way to resolve this ambiguity is to put parentheses
    around any code to be evaluated as a single unit, like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并没有达到预期的效果。记住，周六总是假日。但这段代码坚持认为周六是工作日。这是因为 Ruby 将测试理解为“如果这一天是周六并且我没有加班，或者如果这一天是周日并且我没有加班”，而我的真正意思是“如果这一天是周六，或者如果这一天是周日并且我没有加班”。解决这种歧义的最简单方法是将任何要作为单个单元评估的代码用括号括起来，如下所示：
- en: '*and_or.rb*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*and_or.rb*'
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: and, or, and not
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 且，或，非
- en: 'Incidentally, Ruby has two different syntaxes for testing Boolean (true/false)
    conditions. In the previous example, I’ve used the English-language style operators:
    `and`, `or`, and `not`. If you prefer, you could use alternative operators similar
    to those used in many other programming languages, namely, `&&` (and), `||` (or),
    and `!` (not).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，Ruby 有两种不同的语法来测试布尔（真/假）条件。在先前的例子中，我使用了英语风格的运算符：`and`、`or` 和 `not`。如果你愿意，你可以使用类似于许多其他编程语言中使用的替代运算符，即
    `&&`（且）、`||`（或）和 `!`（非）。
- en: 'Be careful, though: The two sets of operators aren’t completely interchangeable.
    For one thing, they have different precedence, which means that when multiple
    operators are used in a single test, the parts of the test may be evaluated in
    different orders depending on which operators you use. For example, look at this
    test:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如此，但这两组运算符并不完全可互换。首先，它们有不同的优先级，这意味着当在单个测试中使用多个运算符时，测试的不同部分可能会根据你使用的运算符以不同的顺序进行评估。例如，看看这个测试：
- en: '*days.rb*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*days.rb*'
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Assuming that the Boolean variable `working_overtime` is true, would this test
    succeed if the variable `aDay` were initialized with the string “Saturday”? In
    other words, would `daytype` be assigned the value “holiday” if `aDay` is “Saturday”?
    The answer is no, it wouldn’t. The test will succeed only if `aDay` is either
    “Saturday” or “Sunday” and `working_overtime` is not true. So, when `or` is used
    in the previous code, Saturday would be deemed to be a working day.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设布尔变量 `working_overtime` 为真，如果将变量 `aDay` 初始化为字符串 “Saturday”，这个测试会成功吗？换句话说，如果
    `aDay` 是 “Saturday”，`daytype` 会被赋值为 “holiday” 吗？答案是不会，不会成功。只有当 `aDay` 是 “Saturday”
    或 “Sunday” 且 `working_overtime` 不为真时，测试才会成功。因此，当在之前的代码中使用 `or` 时，周六会被视为工作日。
- en: 'Now consider this test:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑这个测试：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On the face of it, this is the same test as the last one; the only difference
    is that this time I’ve used the alternative syntax for the operators. However,
    the change is more than cosmetic since if `aDay` is “Saturday,” this test evaluates
    to true and `daytype` is initialized with the value “holiday.” This is because
    the `||` operator has a higher precedence than the `or` operator. So, this test
    succeeds either if `aDay` is “Saturday” *or* if `aDay` is “Sunday” and `working_overtime`
    is not true. So, when `||` is used in the previous code, Saturday would be deemed
    to be a holiday.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，这个测试和上一个测试是相同的；唯一的区别是这次我使用了运算符的替代语法。然而，这个变化不仅仅是表面的，因为如果 `aDay` 是 “Saturday”，这个测试会评估为真，并且
    `daytype` 会被初始化为值 “holiday”。这是因为 `||` 运算符的优先级高于 `or` 运算符。所以，这个测试在 `aDay` 是 “Saturday”
    或 `aDay` 是 “Sunday” 且 `working_overtime` 不为真时都会成功。所以，当在之前的代码中使用 `||` 时，周六会被视为假日。
- en: Refer to [Digging Deeper](ch06s07.html#digging_deeper-id5 "Digging Deeper")
    in [Digging Deeper](ch06s07.html#digging_deeper-id5 "Digging Deeper") for more
    on this. As a general principle, you would do well to decide which set of operators
    you prefer—stick to them and use parentheses to avoid ambiguity.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅 [Digging Deeper](ch06s07.html#digging_deeper-id5 "Digging Deeper")。作为一个一般原则，你最好决定你更喜欢哪一组运算符——坚持使用它们，并使用括号来避免歧义。
- en: Negation
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 否定
- en: 'In the previous example, I used the negation operator (`!`) in the expression
    `!working_overtime`, which can be read as “not working_overtime.” The negation
    operator can be used at the start of an expression; as an alternative, you can
    use the “not equals” (`!=` ) operator between the left and right sides of an expression:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我在表达式 `!working_overtime` 中使用了否定运算符 (`!`)，这可以读作“not working_overtime”。否定运算符可以用在表达式的开头；作为替代，你可以在表达式的左右两侧使用“不等于”
    (`!=`) 运算符：
- en: '*negation.rb*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*negation.rb*'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alternatively, you can use `not` instead of `!`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用`not`而不是`!`：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: if..elsif
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if..elsif
- en: There will no doubt be occasions when you will need to take multiple different
    actions based on several alternative conditions. One way of doing this is by evaluating
    one `if` condition followed by a series of other test conditions placed after
    the keyword `elsif`. The whole lot must then be terminated using the `end` keyword.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，会有一些时候你需要根据几个不同的条件执行多个不同的操作。实现这一点的其中一种方法是通过评估一个`if`条件，然后跟随一系列放在`elsif`关键字之后的测试条件。然后必须使用`end`关键字来结束整个结构。
- en: 'For example, here I am repeatedly taking input from a user inside a `while`
    loop. An `if` condition tests whether the user enters “q” (I’ve used `chomp()`
    to remove the carriage return from the input). If “q” is not entered, the first
    `elsif` condition tests whether the integer value of the input (`input.to_i`)
    is greater than 800; if this test fails, the next `elsif` condition tests whether
    it is less than or equal to 800:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里我在一个`while`循环中反复从用户那里获取输入。一个`if`条件测试用户是否输入了“q”（我已经使用了`chomp()`来移除输入中的回车符）。如果没有输入“q”，第一个`elsif`条件测试输入的整数值是否大于800；如果这个测试失败，下一个`elsif`条件测试它是否小于或等于800：
- en: '*if_elsif.rb*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*if_elsif.rb*'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The problem with this program is that, even though it asks the user to enter
    a value between 1 and 1,000, it accepts values less than 1 (incidentally, if you
    really want a salary in negative figures, I’ll be glad to offer you a job!) and
    greater than 1,000 (in which case, don’t look to me for employment!).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的问题在于，尽管它要求用户输入一个介于1到1,000之间的值，但它接受小于1（顺便说一句，如果你真的想要负数的薪水，我很乐意给你提供一份工作！）和大于1,000（在这种情况下，不要期待从我这里得到工作！）的值。
- en: 'You can fix this by rewriting the two `elsif` conditions and adding an `else`
    section that executes if all the preceding tests fail:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过重写两个`elsif`条件并添加一个在所有前面的测试失败时执行的`else`部分来修复这个问题：
- en: '*if_elsif2.rb*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*if_elsif2.rb*'
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Shorthand Notation for if..then..else
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: if..then..else的简写表示法
- en: Ruby also has a short-form notation for `if..then..else` in which a question
    mark (`?`) replaces the `if..then` part and a colon (`:`) acts as `else`. Formally,
    this may be known either as a *ternary operator* or as a *conditional operator*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby还有一个`if..then..else`的简写表示法，其中问号（`?`）替换了`if..then`部分，冒号（`:`）充当`else`。正式来说，这可以被称为*三元运算符*或*条件运算符*。
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When the test condition is complex (if it uses `and`s and `or`s), you should
    enclose it in parentheses. If the tests and code span several lines, the `?` must
    be placed on the same line as the preceding condition and the `:` must be placed
    on the same line as the code immediately following the `?`. In other words, if
    you put a newline before the `?` or the `:`, you will generate a syntax error.
    This is an example of a valid multiline code block:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试条件复杂（如果它使用了`and`s和`or`s）时，你应该将其括起来。如果测试和代码跨越多行，`?`必须放在先前的条件所在的同一行上，而`:`必须放在紧随其后的代码所在的同一行上。换句话说，如果你在`?`或`:`之前放置换行符，你会生成一个语法错误。这是一个有效的多行代码块的例子：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*if_else_alt.rb*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*if_else_alt.rb*'
- en: 'Here’s another example of a longer sequence of `if..elsif` sections followed
    by a catchall `else` section. This time the trigger value, `i`, is an integer:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个较长的`if..elsif`部分序列的例子，后面跟着一个通配的`else`部分。这次触发值`i`是一个整数：
- en: '*days2.rb*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*days2.rb*'
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice that I’ve used the range `(6..7)` to match the two integer values for
    Saturday and Sunday. The `===` method (that is, three `=` characters) tests whether
    a value (here `i`) is a member of the range. In the previous example, the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我使用了范围`(6..7)`来匹配周六和周日的两个整数值。`===`方法（即三个`=`字符）测试一个值（在这里是`i`）是否是该范围的成员。在先前的例子中，以下内容：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'could be rewritten as this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以重写为以下内容：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `===` method is defined by the Object class and overridden in descendant
    classes. Its behavior varies according to the class. As you will see shortly,
    one of its fundamental uses is to provide meaningful tests for `case` statements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`===`方法由Object类定义，并在子类中被覆盖。它的行为根据类而异。你很快就会看到，它的一个基本用途是为`case`语句提供有意义的测试。'
- en: unless
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: unless
- en: 'Ruby also can also perform `unless` tests, which are the exact opposite of
    `if` tests:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby还可以执行`unless`测试，这是`if`测试的完全相反：
- en: '*unless.rb*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*unless.rb*'
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Think of `unless` as being an alternative way of expressing “if not.” The following
    is equivalent to the previous code; both consider Saturday and Sunday to be the
    weekend and other days to be weekdays:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `unless` 视为表达“如果不”的另一种方式。以下代码与之前的代码等价；两者都将周六和周日视为周末，其他天视为工作日：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: if and unless Modifiers
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if 和 unless 修饰符
- en: 'You may recall the alternative syntax for `while` loops mentioned in [Chapter 5](ch05.html
    "Chapter 5. Loops and Iterators"). Instead of writing this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在 [第 5 章](ch05.html "第 5 章。循环和迭代") 中提到的 `while` 循环的替代语法。而不是这样写：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'you can write this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以写成这样：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This alternative syntax, in which the `while` keyword is placed between the
    code to execute and the test condition, is called a *while modifier*. It turns
    out that Ruby has `if` and `unless` modifiers too. Here are a few examples:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将 `while` 关键字放置在要执行的代码和测试条件之间的替代语法称为 *while 修饰符*。实际上，Ruby 还有 `if` 和 `unless`
    修饰符。以下是一些示例：
- en: '*if_unless_mod.rb*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*if_unless_mod.rb*'
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The terseness of this syntax is useful when you repeatedly need to take some
    well-defined action if some condition is true. You might, for example, pepper
    your code with debugging output if a constant called `DEBUG` is true:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要重复执行一些定义良好的操作时，这种语法的简洁性是有用的。例如，如果有一个名为 `DEBUG` 的常量是 true，你可能会在代码中添加调试输出：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Case Statements
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情况语句
- en: When you need to take a variety of different actions based on the value of a
    single variable, multiple `if..elsif` tests are verbose and repetitive.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要根据单个变量的值执行多种不同的操作时，多个 `if..elsif` 测试既冗长又重复。
- en: A neater alternative is provided by a `case` statement. This begins with the
    word `case` followed by the variable name to test. Then comes a series of `when`
    sections, each of which specifies a “trigger” value followed by some code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简洁的替代方案是 `case` 语句。它以单词 `case` 开头，后面跟着要测试的变量名。然后是一系列 `when` 部分，每个部分指定一个“触发”值和一些代码。
- en: 'This code executes only when the test variable equals the trigger value:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当测试变量等于触发值时，此代码才会执行：
- en: '*case.rb*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*case.rb*'
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Constants
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 常量
- en: 'In principle, constants are objects whose values never change. For example,
    `PI` in Ruby’s `Math` module is a constant. Constants in Ruby begin with a capital
    letter. Class names are also constants. You can obtain a list of all defined constants
    using the `constants` method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从原则上讲，常量是值永远不会改变的对象。例如，Ruby 的 `Math` 模块中的 `PI` 是一个常量。Ruby 中的常量以大写字母开头。类名也是常量。你可以使用
    `constants` 方法获取所有定义的常量的列表：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Ruby provides the `const_get` and `const_set` methods to get and set the value
    of named constants specified as symbols (identifiers preceded by a colon such
    as `:RUBY_VERSION`). Note that, unlike the constants in many other programming
    languages, Ruby’s constants may be assigned new values:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 提供了 `const_get` 和 `const_set` 方法来获取和设置以符号指定的命名常量的值（例如，以冒号开头的标识符 `:RUBY_VERSION`）。请注意，与许多其他编程语言中的常量不同，Ruby
    的常量可以分配新的值：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The previous reassignment of the `RUBY_VERSION` constant produces an “already
    initialized constant” warning but not an error! You can even reassign constants
    declared in Ruby’s standard class library. For example, here I reassign the value
    of `PI`. Although this displays a warning, the assignment succeeds nonetheless:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上次对 `RUBY_VERSION` 常量的重新赋值产生了一个“已初始化的常量”警告，但没有错误！你甚至可以重新赋值 Ruby 标准类库中声明的常量。例如，这里我重新赋值了
    `PI` 的值。尽管这会显示一个警告，但赋值仍然成功：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You need to be aware that the constancy of Ruby’s constants is a programming
    *convention*, rather than a rigorously enforced *rule*. Naturally, it is not good
    programming practice to reassign constants.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要意识到 Ruby 常量的不变性是一种编程 *约定*，而不是严格强制执行的 *规则*。自然地，重新赋值常量不是好的编程实践。
- en: '*constants.rb*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*constants.rb*'
- en: '*math_pi.rb*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*math_pi.rb*'
- en: 'In the previous example, I’ve used the `then` keyword to separate each `when`
    test from the code to execute. In Ruby 1.8, just as with `if` tests mentioned
    earlier, you could use a colon as an alternative, but this syntax is not supported
    in Ruby 1.9:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我使用了 `then` 关键字来将每个 `when` 测试与要执行的代码分开。在 Ruby 1.8 中，就像前面提到的 `if` 测试一样，你可以使用冒号作为替代，但这种语法在
    Ruby 1.9 中不受支持：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `then` can be omitted if the test and the code to be executed are on separate
    lines. Unlike `case` statements in C-like languages, there is no need to enter
    a `break` keyword when a match is made in order to prevent execution trickling
    down through the remainder of the sections. In Ruby, once a match is made, the
    `case` statement exits:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试和要执行的代码位于不同的行上，则可以省略 `then`。与 C 类语言中的 `case` 语句不同，当匹配成功时，无需输入 `break` 关键字以防止执行渗透到其余部分。在
    Ruby 中，一旦匹配成功，`case` 语句就会退出：
- en: '*case_break.rb*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*case_break.rb*'
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This displays the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下内容：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can include several lines of code between each `when` condition, and you
    can include multiple values separated by commas to trigger a single `when` block,
    like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在每个 `when` 条件之间包含多行代码，并且可以使用逗号分隔的多个值来触发单个 `when` 块，如下所示：
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The condition in a `case` statement is not obliged to be a simple variable;
    it can be an expression like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`case` 语句中的条件不一定是简单变量；它可以是一个像这样的表达式：'
- en: '*case2.rb*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*case2.rb*'
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can also use noninteger types such as a string. If multiple trigger values
    are specified in a `when` section, they may be of varying types—for example, both
    string and integers:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用非整数类型，例如字符串。如果在 `when` 部分指定了多个触发值，它们可能是不同类型的——例如，字符串和整数：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is a longer example, illustrating some of the syntactical elements mentioned
    earlier:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更长的示例，说明了前面提到的某些语法元素：
- en: '*case3.rb*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*case3.rb*'
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The === Method
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: === 方法
- en: 'As mentioned earlier, the `when` tests on an object used in a `case` statement
    are performed using the `===` method. So, for example, just as the `===` method
    returns true when an integer forms part of a range, a `when` test returns true
    when an integer variable in a `case` statement forms part of a range expression:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`when` 在 `case` 语句中测试的对象使用的是 `===` 方法。因此，例如，就像 `===` 方法在整数构成范围的一部分时返回 true
    一样，`when` 测试在 `case` 语句中的整数变量构成范围表达式的一部分时也返回 true：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If in doubt on the effect of the `===` method for a specific object, refer
    to the Ruby documentation on that object’s class. Ruby’s standard classes are
    documented in the core API here: [http://www.ruby-doc.org/](http://www.ruby-doc.org/).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对特定对象的 `===` 方法的效果有疑问，请参考该对象类的 Ruby 文档。Ruby 的标准类在核心 API 中有文档说明：[http://www.ruby-doc.org/](http://www.ruby-doc.org/)。
- en: Alternative Case Syntax
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交替的 Case 语法
- en: 'There is an alternative form of the `case` statement that is like a shorthand
    form of a series of `if..then..else` statements. Each `when` section can perform
    some arbitrary test and execute one or more lines of code. No `case` variable
    is required. Each `when` section returns a value that, just like a method, is
    the result of the last piece of code that’s evaluated. This value can be assigned
    to a variable preceding the `case` statement:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`case` 语句中的条件不一定是简单变量；它可以是一个像这样的表达式：'
- en: '*case4.rb*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*case4.rb*'
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Digging Deeper
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: There is more to Ruby comparison operators than meets the eye. Here you will
    learn about their effects and side effects and discover how to break out of blocks
    when a condition is met.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 的比较运算符比表面上要复杂。在这里，您将了解它们的效果和副作用，并学习如何在满足条件时退出代码块。
- en: Boolean Operators
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符
- en: The following operators are available in Ruby for testing expressions that may
    yield true or false values.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，以下运算符可用于测试可能返回真或假值的表达式。
- en: '| `and` and `&&` | These operators evaluate the left-hand side; only if the
    result is true do they then evaluate the right side. `and` has lower precedence
    than `&&`. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `and` 和 `&&` | 这些运算符评估左侧表达式；只有当结果为真时，才会评估右侧表达式。`and` 的优先级低于 `&&`。|'
- en: '| `or` and `&#124;&#124;` | These operators evaluate the left-hand side; if
    the result is false, then they evaluate the right side. `or` has lower precedence
    than `&#124;&#124;`. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `or` 和 `&#124;&#124;` | 这些运算符评估左侧表达式；如果结果为假，则评估右侧表达式。`or` 的优先级低于 `&#124;&#124;`。|'
- en: '| `not` and `!` | These operators negate a Boolean value; in other words, they
    return true when false and return false when true. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `not` 和 `!` | 这些运算符否定布尔值；换句话说，当为假时返回 true，当为真时返回 false。|'
- en: Be careful when using the alternative Boolean operators. Because of the difference
    in precedence, conditions will be evaluated in different orders and may yield
    different results.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替代布尔运算符时要小心。由于优先级不同，条件将按不同的顺序评估，并可能产生不同的结果。
- en: 'Consider the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '*boolean_ops.rb*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*boolean_ops.rb*'
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These may look the same at first sight. In fact, Example 1 prints “false,” while
    Example 2 prints “true.” This is entirely because `or` has lower precedence than
    `||`. As a consequence, Example 1 tests “if 1 equals 3 [*false*] and (either 2
    equals 1 or 3 equals 3) [*true*].” Because one of these two necessary conditions
    is false, the entire test returns false.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些看起来可能相同。实际上，示例 1 打印 “false”，而示例 2 打印 “true”。这完全是由于 `or` 的优先级低于 `||`。因此，示例
    1 测试的是“如果 1 等于 3 [*false*] 并且（2 等于 1 或 3 等于 3）[*true*]。”由于这两个必要条件中有一个是假的，整个测试返回
    false。
- en: Now look at Example 2\. This tests “(if 1 equals 3 and 2 equals 1) [*false*]
    or 3 equals 3 [*true*].” This time, you need only one of the two tests to succeed;
    the second test evaluates to true so the entire tests returns true.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看示例 2。它测试的是“（如果 1 等于 3 并且 2 等于 1）[*false*] 或 3 等于 3 [*true*]。”这次，只需要两个测试中的一个成功；第二个测试评估为
    true，因此整个测试返回 true。
- en: 'The side effects of operator precedence in this kind of test can lead to very
    obscure bugs. You can avoid these by clarifying the meaning of the test using
    parentheses. Here, I have rewritten Examples 1 and 2; in each case, the addition
    of one pair of parentheses has inverted the initial Boolean value returned by
    the test:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种测试中，运算符优先级带来的副作用可能会导致非常难以发现的错误。您可以通过使用括号来明确测试的含义来避免这些问题。在这里，我重新编写了示例 1 和
    2；在每种情况下，添加一对括号都反转了测试最初返回的布尔值：
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Eccentricities of Boolean Operators
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符的怪癖
- en: 'Be warned that Ruby’s Boolean operators can sometimes behave in a curious and
    unpredictable manner. For example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：Ruby 的布尔运算符有时可能会表现出一种奇特且不可预测的行为。例如：
- en: '*eccentricities.rb*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*eccentricities.rb*'
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In many cases, you can avoid problems by sticking to one style of operator (either
    `and`, `or`, and `not` *or* `&&`, `||`, and `!`) rather than mixing the two. In
    addition, the generous use of parentheses is recommended!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，通过坚持使用一种运算符风格（即 `and`、`or` 和 `not` 或 `&&`、`||` 和 `!`）而不是混合使用两种运算符，您可以避免问题。此外，推荐大量使用括号！
- en: catch and throw
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获和抛出
- en: 'Ruby provides a pair of methods, `catch` and `throw`, which can be used to
    break out of a block of code when some condition is met. This is Ruby’s nearest
    equivalent to a `goto` in some other programming languages. The block must begin
    with `catch` followed by a symbol (that is, a unique identifier preceded by a
    colon), such as `:done` or `:finished`. The block itself may be delimited either
    by curly brackets or by the keywords `do` and `end`, like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 提供了一对方法，`catch` 和 `throw`，当满足某些条件时，可以用来跳出代码块。这是 Ruby 在某些其他编程语言中 `goto`
    的近似等效。该块必须以 `catch` 开头，后跟一个符号（即一个由冒号前缀的唯一标识符），例如 `:done` 或 `:finished`。块本身可以由花括号或
    `do` 和 `end` 关键字界定，如下所示：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Inside the block, you can call `throw` with a symbol as an argument. Normally
    you would call `throw` when some specific condition is met that makes it desirable
    to skip all the remaining code in the block. For instance, let’s assume the block
    contains some code that prompts the user to enter a number, divides some value
    by that number, and then goes on to do a multitude of other complex calculations
    with the result. Obviously, if the user enters 0, then none of the calculations
    that follow can be completed, so you would want to skip them all by jumping right
    out of the block and continuing with any code that follows it. This is one way
    of doing that:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在块内部，您可以使用符号作为参数调用 `throw`。通常，您会在满足某些特定条件时调用 `throw`，这使得跳过块中剩余的所有代码变得可行。例如，假设块中包含一些代码，提示用户输入一个数字，将某个值除以该数字，然后继续进行一系列复杂的计算。显然，如果用户输入
    0，那么后续的所有计算都无法完成，因此您会希望跳过它们，直接跳出块并继续执行其后的任何代码。这是实现这一目标的一种方法：
- en: '*catch_throw.rb*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*catch_throw.rb*'
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can, in fact, have a call to `throw` outside the block, like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可以在块外部调用 `throw`，如下所示：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And you can have `catch` blocks nested inside other `catch` blocks, like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将 `catch` 块嵌套在其他 `catch` 块内部，如下所示：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As with `goto`s and jumps in other programming languages, `catch` and `throw`
    in Ruby should be used with great care because they break the logic of your code
    and can, potentially, introduce hard-to-find bugs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言中的`goto`跳转一样，Ruby中的`catch`和`throw`应该谨慎使用，因为它们会破坏你代码的逻辑，并且可能引入难以发现的错误。
