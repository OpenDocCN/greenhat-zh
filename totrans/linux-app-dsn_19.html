<html><head></head><body>
<div>&#13;
<p class="imgc"><a id="page331"/><img src="../images/355-1.jpg" alt=""/></p>&#13;
<p class="ch"><a id="app4"/><a href="toc.html#app4"><b>A DB - TO - FILE UTILITY</b></a></p>&#13;
<p class="imgc"><img src="../images/as.jpg" alt=""/></p>&#13;
<p class="nb">This appendix describes tbl2filed, a daemon that allows you to use SQL to read and write values in Linux configuration files as if those values were in a database instead of a file. This utility is convenient if you want to use RTA for new daemons and want to keep the same database metaphor for reading and writing values into traditional, non-RTA configuration files. Topics discussed in this appendix include:</p>&#13;
<ul>&#13;
<li>Overview</li>&#13;
<li>Table definitions</li>&#13;
<li>Usage and API</li>&#13;
<li>Security notes</li>&#13;
</ul>&#13;
<p class="secl"><a id="app4.1"/><a href="toc.html#app4.1"><b>Overview</b></a></p>&#13;
<p class="noindent"><a id="page332"/>The goal of the tbl2filed daemon is to allow your UI programs to use a PostgreSQL library to read or write (SELECT or UPDATE) an RTA table and have an underlying system configuration file scanned or modified as part of the SELECT or UPDATE. This utility tries to mimic the common tasks of:</p>&#13;
<ul>&#13;
<li>Viewing values in a configuration file (SELECT value . . .)</li>&#13;
<li>Editing the values in a configuration file (UPDATE value . . .)</li>&#13;
<li>Atomically writing a file to disk (UPDATE tbl2file SET do_commit . . .)</li>&#13;
<li>Restarting a service if necessary (UPDATE tbl2file SET do_script . . .)</li>&#13;
</ul>&#13;
<p class="indent">The tbl2filed daemon allows you to read and write configuration files by using PostgreSQL commands on two RTA tables. The first table, tbl2file, describes the files managed by the daemon, and the second table, tbl2field, describes the managed fields.</p>&#13;
<p class="indent">Figure D-1 illustrates how this utility maps two tables into text fields inside of disk files.</p>&#13;
<p class="imgc"><img src="../images/356-1.jpg" alt=""/></p>&#13;
<p class="cap"><i>Figure D-1: Use SQL to access data in files.</i></p>&#13;
<p class="indent">This daemon also lets us put all of the restart scripts for system services in a single file and use a single method (a write callback) to invoke them. This approach might help security because it allows a non-privileged UI program to safely change the system configuration files.</p>&#13;
<p class="secl"><a id="app4.2"/><a href="toc.html#app4.2"><b>Table Definitions</b></a></p>&#13;
<p class="noindent">An example is given later in this appendix, but for that example to make sense, you need some understanding of the contents of the two tbl2filed tables. Laddie uses tbl2filed to help with the networking configuration, and you may find the tables easier to understand by looking at them in a running Laddie system. Boot the Laddie CD and follow the tbl2filed link at 192.168.1.11/table_editor/rta/rta_apps.html.</p>&#13;
<p class="secs"><a id="app4.3"/><a href="toc.html#app4.3"><i><b>The tbl2file Table</b></i></a></p>&#13;
<p class="noindent"><a id="page333"/>The table of managed file information, tbl2file, has the following columns:</p>&#13;
<p class="imgl"><img src="../images/357-1.jpg" alt=""/></p>&#13;
<p class="indent">The name of the file is the name as seen by the UI. It is also used as part of the index into tbl2field table. This can just be shorthand or a mnemonic for the file, for example, <i>resolv.</i></p>&#13;
<p class="indent">The path is the full path to the file, including the filename. For example, the name field might be <i>resolv,</i> while the path might be <i>/etc/resolv. conf.</i></p>&#13;
<p class="indent">Writing a 1 to the do_commit flag causes the managed file’s values to be written back to the disk file. The file is written to a temporary file first and then rename() is called to move the temporary file to the destination file. This mechanism helps maintain consistency in the system by trying to make a write of the entire file as atomic as possible. A SELECT on do_commit always returns a zero.</p>&#13;
<p class="indent">Reading and parsing the values from a file is expensive in terms of time and CPU cycles. Since the files won’t change often, we can improve the system’s responsiveness by caching the file’s values in the tbl2field table and only rereading the file if it has been modified since the last time we read it. The timestamp marks the last time we read and parsed the file; time is measured as the number of seconds since the last write. When a UI asks for a value, our daemon compares the mtime (time of last modification) in the file’s inode to our time stamp, and either rescans the file if necessary or returns the values directly from the fields table, if the cached values are still valid.</p>&#13;
<p class="indent">Setting do_script to 1 starts the script /usr/local/tbl2filed/tbl2script.sh. (The script location is set in the tbl2filed Makefile.) The script_parms field has a set of space-separated parameters that are passed to the script. The parameters are not passed on the command line; rather, they are passed in on standard input and parsed into parameters using a cut command. This script is spawned and forgotten—that is, we ignore any return value from it. The script is only run by an explicit write of 1 to the do_script column, and the column is only used for its write callback. A SELECT on this column will always return a zero. Laddie uses this script, for example, to restart networking when the user changes the appliance’s IP address.</p>&#13;
<p class="secs"><a id="app4.4"/><a href="toc.html#app4.4"><i><b>The tbl2field Table</b></i></a></p>&#13;
<p class="noindent"><a id="page334"/>The tbl2field table that holds the values for the individual fields and has the following columns:</p>&#13;
<p class="imgl"><img src="../images/358-1.jpg" alt=""/></p>&#13;
<p class="indent">The name is the name of the file and must match the name column in the tbl2file table.</p>&#13;
<p class="indent">The field is the name of the field as seen by all of the UI programs. This is always used in a WHERE clause to identify the exact field to read and update.</p>&#13;
<p class="indent">The pattern is a regular expression that, in combination with the skip count, uniquely identifies the field in the file. The pattern should include exactly one set of parentheses to extract the value from the text of the line. For example, to get the first DNS name server from the resolv.conf file, we might use the following regular expression:</p>&#13;
<p class="ex">^nameserver[ \t]+([0-9\.]+)</p>&#13;
<p class="indent">The regerr field is nonzero if the pattern can not be parsed as a regular expression. It should be necessary to examine regerr only during development.</p>&#13;
<p class="indent">The skip column tells the daemon how many of the above patterns to skip before selecting a line as the source of the value. For example, we’d use a skip value of 1 to read the second DNS nameserver from resolv.conf. This would skip over one nameserver and read the second one.</p>&#13;
<p class="indent">The format field is used to reproduce the line of configuration data in the target file. We could get this from the regular expression, but having a printf format string is a lot easier. If this column is left blank, the field is considered a read-only field. Any of the read-only values in /proc or /sys should have a blank format field. You can see a good example of a read-only value by looking at the uptime field in tbl2field table. For a nameserver line in resolv.conf, the format string would be nameserver %s. There’s no need for a \n in the format string, since it is added automatically by the print statement.</p>&#13;
<p class="indent">The value is the current value of the field as a string. Doing a SELECT on this column will cause the file to be read and parsed if necessary (see timestamp in tbl2file above). If the cached value is still valid, the value is taken directly from the table. A write on this column saves the value in the table but does not actually write the value to the file; writing a 1 to do_commit does that.</p>&#13;
<p class="secl"><a id="app4.5"/><a href="toc.html#app4.5"><b>A tbl2filed Example</b></a></p>&#13;
<p class="noindent"><a id="page335"/>Let’s look at a complete example by continuing with the nameserver configuration for Laddie. The /etc/resolv.conf file on a running Laddie system looks like this:</p>&#13;
<p class="ex">nameserver 204.117.214.10<br/>nameserver 199.2.252.10<br/>nameserver 65.173.40.10</p>&#13;
<p class="indent">Our goal is to be able to read the first DNS nameserver with a SELECT statement as follows:</p>&#13;
<p class="ex">psql -h localhost -p 8885<br/>&gt; SELECT * FROM tbl2field where name = "nameserver_1";<br/>&gt; \q</p>&#13;
<p class="indent">Similarly, to modify the second DNS server, Laddie uses the following UPDATE statement:</p>&#13;
<p class="imgl"><img src="../images/359-1.jpg" alt=""/></p>&#13;
<p class="indent">You can verify the above by booting the Laddie CD, exiting from the frame-buffer menu, logging in as root, and executing the commands given above. Be sure to verify that the file has been modified after the UPDATE command.</p>&#13;
<p class="indent">Now let’s look at the tbl2file and tbl2field configuration that gives us the ability to read and write the nameserver IP addresses as if they were in a PostgreSQL database. We’ll start by listing the file we want to manage in the tbl2file table:</p>&#13;
<p class="exh">UPDATE tbl2file SET name=resolv, path=/etc/resolv.conf, script_parms="" LIMIT 1 OFFSET 0</p>&#13;
<p class="indent">We don’t need to run a script after editing the resolv.conf file, so we can leave script_parms blank. You can use either full or relative path names, but as a security precaution, it is a good idea to use the full path name.</p>&#13;
<p class="indent">In this example, we want to manage the three DNS nameservers. The SQL for this is taken from tbl2field.sql (perhaps use the full path, i.e., /opt/laddie/tbl2filed/. . .) and is as follows:</p>&#13;
<p class="imgl"><img src="../images/359-2.jpg" alt=""/></p>&#13;
<p class="indent"><a id="page336"/>The pattern recognizes the line with the parameter, and the single set of parentheses in the pattern extracts the actual field value. In the above examples, the value of a nameserver field must have only the digits zero through nine and/or decimal points. The parentheses are not part of the recognition—they are only used to extract the field value.</p>&#13;
<p class="indent">One nice feature of the tbl2filed daemon is that when you write a value to a field, the daemon uses the format string to build a copy of what the new configuration line will look like. Then it runs the pattern against the new line and rejects the update if the pattern doesn’t recognize the new line. In this example, an update for a nameserver of 11.22.33.44 would succeed, since it contains the required digits and decimal points; however a nameserver update of Bob's fun house would fail, since it does not contain the required digits and decimals.</p>&#13;
<p class="indent">The nameserver example also illustrates the use of the skip column. The primary nameserver has skip set to zero, meaning that we use the first line with a matching pattern. The secondary nameserver is specified with skip set to 1, meaning we skip one matching line and use the second matching line.<sup>1</sup></p>&#13;
<p class="secl"><a id="app4.6"/><a href="toc.html#app4.6"><b>Security Notes</b></a></p>&#13;
<p class="noindent">Depending on how you use it, this daemon can either enhance or hurt your system security. At first glance, having a daemon that runs with root privileges and accepts database connections seems like a bad idea. On the other hand, this might allow you to improve security by running only <i>one</i> daemon as root and running each of the UI programs as a non-root user. This way, if an attacker breaks into one of your UI programs, he or she only gains the privileges of that non-root user. Compare this to most Linux appliances, in which a UI needs to run as root in order to make system changes.</p>&#13;
<p class="indent">The daemon reads tbl2file.sql and tbl2field.sql when it starts, and then marks all of its configuration columns as read-only. Not allowing updates to the managed files or script parameters helps security, but it also means that you cannot update any part of the configuration after the program starts. You must edit the tbl2file.sql and tbl2field.sql files directly before starting the tbl2filed daemon. If you must mark any column as read-write to make development easier, be sure to change it back to read-only before you ship your product. Also, be sure to protect the write privileges on the directory and files with the daemon’s initial configuration.</p>&#13;
<p class="noindent1">__________________</p>&#13;
<p class="foot"><sup>1</sup> The resolv.conf file is different from most Linux configuration files in that switching to or from DHCP as the boot configuration protocol can completely destroy any values you’ve previously written into it. The simple solution to this problem is to keep a template file and copy it to /etc/resolv.conf when necessary.</p>&#13;
</div>&#13;
</body></html>