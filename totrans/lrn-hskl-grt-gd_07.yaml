- en: Chapter 7. Making Our Own Types and Type Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we’ve run into a lot of data types: `Bool`, `Int`, `Char`, `Maybe`,
    and so on. But how do we make our own? In this chapter, you’ll learn how to create
    custom types and put them to work!'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802592.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Defining a New Data Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to make our own type is to use the `data` keyword. Let’s see how the
    `Bool` type is defined in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using the `data` keyword like this means that a new data type is being defined.
    The part before the equal sign denotes the type, which in this case is `Bool`.
    The parts after the equal sign are value constructors. They specify the different
    values that this type can have. The `|` is read as *or*. So we can read this as
    saying that the `Bool` type can have a value of `True` or `False`. Note that both
    the type name and the value constructors must start with an uppercase letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar fashion, we can think of the `Int` type as being defined like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first and last value constructors are the minimum and maximum possible values
    of `Int`. It’s not actually defined like this—you can see I’ve omitted a bunch
    of numbers—but this is useful for illustrative purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s think about how we would represent a shape in Haskell. One way would
    be to use tuples. A circle could be denoted as `(43.1, 55.0, 10.4)`, where the
    first and second fields are the coordinates of the circle’s center and the third
    field is the radius. The problem is that those could also represent a 3D vector
    or anything else that could be identified by three numbers. A better solution
    would be to make our own type to represent a shape.
  prefs: []
  type: TYPE_NORMAL
- en: Shaping Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s say that a shape can be a circle or a rectangle. Here’s one possible
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What does it mean? Think of it like this: The `Circle` value constructor has
    three fields, which take floats. So when we write a value constructor, we can
    optionally add some types after it, and those types define the types of values
    it will contain. Here, the first two fields are the coordinates of its center,
    and the third one is its radius. The `Rectangle` value constructor has four fields
    that accept floats. The first two act as the coordinates to its upper-left corner,
    and the second two act as coordinates to its lower-right corner.'
  prefs: []
  type: TYPE_NORMAL
- en: Value constructors are actually functions that ultimately return a value of
    a data type. Let’s take a look at the type signatures for these two value constructors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So value constructors are functions like everything else. Who would have thought?
    The fields that are in the data type act as parameters to its value constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s make a function that takes a `Shape` and returns its area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First, note the type declaration. It says that the function takes a `Shape`
    and returns a `Float`. We couldn’t write a type declaration of `Circle -> Float`,
    because `Circle` is not a type, while `Shape` is (just as we can’t write a function
    with a type declaration of `True -> Int`, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Next, notice that we can pattern match against constructors. We’ve already done
    this against values like `[]`, `False`, and `5`, but those values didn’t have
    any fields. In this case, we just write a constructor and then bind its fields
    to names. Because we’re interested in only the radius, we don’t actually care
    about the first two fields, which tell us where the circle is.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Yay, it works! But if we try to just print out `Circle 10 20 5` from the prompt,
    we’ll get an error. That’s because Haskell doesn’t know how to display our data
    type as a string (yet). Remember that when we try to print a value out from the
    prompt, Haskell first applies the `show` function to it to get the string representation
    of our value, and then it prints that to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our `Shape` type part of the `Show` type class, we modify it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We won’t concern ourselves with `deriving` too much for now. Let’s just say
    that if we add `deriving (Show)` at the end of a data declaration (it can go on
    the same line or the next one—it doesn’t matter), Haskell automatically makes
    that type part of the `Show` type class. We’ll be taking a closer look at `deriving`
    in [Derived Instances](ch07s05.html "Derived Instances") in [Derived Instances](ch07s05.html
    "Derived Instances").
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Value constructors are functions, so we can map them, partially apply them,
    and so on. If we want a list of concentric circles with different radii, we can
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Improving Shape with the Point Data Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our data type is good, but it could be better. Let’s make an intermediate data
    type that defines a point in two-dimensional space. Then we can use that to make
    our shapes more understandable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that when defining a point, we used the same name for the data type
    and the value constructor. This has no special meaning, although it’s common if
    there’s only one value constructor. So now the `Circle` has two fields: One is
    of type `Point` and the other of type `Float`. This makes it easier to understand
    what’s what. The same goes for `Rectangle`. Now we need to adjust our `area` function
    to reflect these changes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The only thing we needed to change were the patterns. We disregarded the whole
    point in the `Circle` pattern. In the `Rectangle` pattern, we just used nested
    pattern matching to get the fields of the points. If we wanted to reference the
    points themselves for some reason, we could have used as-patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can test our improved version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How about a function that nudges a shape? It takes a shape, the amount to move
    it on the x axis, and the amount to move it on the y axis. It returns a new shape
    that has the same dimensions but is located somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty straightforward. We add the nudge amounts to the points that
    denote the position of the shape. Let’s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we don’t want to deal with points directly, we can make some auxiliary functions
    that create shapes of some size at the zero coordinates and then nudge those.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s make a function that takes a radius and makes a circle that is
    located at the origin of the coordinate system, with the radius we supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s make a function that takes a width and a height and makes a rectangle
    with those dimensions and its bottom-left corner located at the origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use these functions to make shapes that are located at the origin
    of the coordinate system and then nudge them to where we want them to be, which
    makes it easier to create shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Exporting Our Shapes in a Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also export your data types in your custom modules. To do that, just
    write your type along with the functions you are exporting, and then add some
    parentheses that specify the value constructors that you want to export, separated
    by commas. If you want to export all the value constructors for a given type,
    just write two dots (`..`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to export our shape functions and types in a module. We start
    off like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: By using `Shape(..)`, we export all the value constructors for `Shape`. This
    means that people who import our module can make shapes by using the `Rectangle`
    and `Circle` value constructors. It’s the same as writing `Shape (Rectangle, Circle)`,
    but shorter.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if we decide to add some value constructors to our type later on, we don’t
    need to modify the exports. That’s because using `..` automatically exports all
    value constructors for a given type.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we could opt to not export any value constructors for `Shape`
    by just writing `Shape` in the export statement, without the parentheses. That
    way, people who import our module could make shapes only by using the auxiliary
    functions `baseCircle` and `baseRect`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that value constructors are just functions that take the fields as
    parameters and return a value of some type (like `Shape`). So when we choose not
    to export them, we prevent the person importing our module from using those value
    constructors directly. Not exporting the value constructors of our data types
    makes them more abstract, since we’re hiding their implementation. Also, whoever
    uses our module can’t pattern match against the value constructors. This is good
    if we want people who import our module to be able to interact with our type only
    via the auxiliary functions that we supply in our module. That way, they don’t
    need to know about the internal details of our module, and we can change those
    details whenever we want, as long as the functions that we export act the same.
  prefs: []
  type: TYPE_NORMAL
- en: '`Data.Map` uses this approach. You can’t create a map by directly using its
    value constructor, whatever it may be, because it’s not exported. However, you
    can make a map by using one of the auxiliary functions like `Map.fromList`. The
    people in charge of `Data.Map` can change the way that maps are internally represented
    without breaking existing programs.'
  prefs: []
  type: TYPE_NORMAL
- en: But for simpler data types, exporting the value constructors is perfectly fine,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Record Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let’s look at how we can create another kind of data type. Say we’ve been
    tasked with creating a data type that describes a person. The information that
    we want to store about that person is first name, last name, age, height, phone
    number, and favorite ice cream flavor. (I don’t know about you, but that’s all
    I ever want to know about a person.) Let’s give it a go!
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802594.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first field is the first name, the second is the last name, the third is
    the age, and so on. Now let’s make a person.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That’s kind of cool, although slightly unreadable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now what if we want to create functions to get specific pieces of information
    about a person? We need a function that gets some person’s first name, a function
    that gets some person’s last name, and so on. Well, we would need to define them
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Whew! I certainly did not enjoy writing that! But despite being very cumbersome
    and *boring* to write, this method works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: “Still, there must be a better way!” you say. Well, no, there isn’t, sorry.
    Just kidding—there is. Hahaha!
  prefs: []
  type: TYPE_NORMAL
- en: 'Haskell gives us an alternative way to write data types. Here’s how we could
    achieve the same functionality with *record syntax*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So instead of just naming the field types one after another and separating
    them with spaces, we use curly brackets. First, we write the name of the field
    (for instance, `firstName`), followed by a double colon (`::`), and then the type.
    The resulting data type is exactly the same. The main benefit of using this syntax
    is that it creates functions that look up fields in the data type. By using record
    syntax to create this data type, Haskell automatically makes these functions:
    `firstName`, `lastName`, `age`, `height`, `phoneNumber`, and `flavor`. Take a
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There’s another benefit to using record syntax. When we derive `Show` for the
    type, it displays it differently if we use record syntax to define and instantiate
    the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have a type that represents a car. We want to keep track of the company
    that made it, the model name, and its year of production. We can define this type
    without using record syntax, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'A car is displayed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s see what happens when we define it using record syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make a car like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When making a new car, we don’t need to put the fields in the proper order,
    as long as we list all of them. But if we don’t use record syntax, we must specify
    them in order.
  prefs: []
  type: TYPE_NORMAL
- en: Use record syntax when a constructor has several fields and it’s not obvious
    which field is which. If we make a 3D vector data type by doing `data Vector =
    Vector Int Int Int`, it’s pretty obvious that the fields are the components of
    a vector. However, in our `Person` and `Car` types, the fields are not so obvious,
    and we greatly benefit from using record syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Type Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A value constructor can take some parameters and then produce a new value. For
    instance, the `Car` constructor takes three values and produces a `car` value.
    In a similar manner, type constructors can take types as parameters to produce
    new types. This might sound a bit too meta at first, but it’s not that complicated.
    (If you’re familiar with templates in C++, you’ll see some parallels.) To get
    a clear picture of how type parameters work in action, let’s take a look at how
    a type we’ve already met is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802596.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `a` here is the type parameter. And because there’s a type parameter involved,
    we call `Maybe` a *type constructor*. Depending on what we want this data type
    to hold when it’s not `Nothing`, this type constructor can end up producing a
    type of `Maybe Int`, `Maybe Car`, `Maybe String`, and so on. No value can have
    a type of just `Maybe`, because that’s not a type—it’s a type constructor. In
    order for this to be a real type that a value can be part of, it must have all
    its type parameters filled up.
  prefs: []
  type: TYPE_NORMAL
- en: So if we pass `Char` as the type parameter to `Maybe`, we get a type of `Maybe
    Char`. The value `Just 'a'` has a type of `Maybe Char`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, we don’t pass types as parameters to type constructors explicitly.
    That’s because Haskell has type inference. So when we make a value `Just 'a'`,
    for example, Haskell figures out that it’s a `Maybe Char`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to explicitly pass a type as a type parameter, we must do it in
    the type part of Haskell, which is usually after the `::` symbol. This can come
    in handy if, for example, we want a value of `Just 3` to have the type `Maybe
    Int`. By default, Haskell will infer the type `(Num a) => Maybe a` for that value.
    We can use an explicit type annotation to restrict the type a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You might not know it, but we used a type that has a type parameter before
    we used `Maybe`: the list type. Although there’s some syntactic sugar in play,
    the list type takes a parameter to produce a concrete type. Values can have an
    `[Int]` type, a `[Char]` type, or a `[[String]]` type, but you can’t have a value
    that just has a type of `[]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We say that a type is *concrete* if it doesn’t take any type parameters at all
    (like `Int` or `Bool`), or if it takes type parameters and they’re all filled
    up (like `Maybe Char`). If you have some value, its type is always a concrete
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s play around with the `Maybe` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Type parameters are useful because they allow us to make data types that can
    hold different things. For instance, we could make a separate `Maybe`-like data
    type for every type that it could contain, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: But even better, we could use type parameters to make a generic `Maybe` that
    can contain values of any type at all!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the type of `Nothing` is `Maybe a`. Its type is *polymorphic*, which
    means that it features type variables, namely the `a` in `Maybe a`. If some function
    requires a `Maybe Int` as a parameter, we can give it a `Nothing`, because a `Nothing`
    doesn’t contain a value anyway, so it doesn’t matter. The `Maybe a` type can act
    like a `Maybe Int` if it must, just as `5` can act like an `Int` or a `Double`.
    Similarly, the type of the empty list is `[a]`. An empty list can act like a list
    of anything. That’s why we can do `[1,2,3] ++ []` and `["ha","ha","ha"] ++ []`.
  prefs: []
  type: TYPE_NORMAL
- en: Should We Parameterize Our Car?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When does using type parameters make sense? Usually, we use them when our data
    type would work regardless of the type of the value it then holds, as with our
    `Maybe a` type. If our type acts as some kind of box, it’s good to use parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider our `Car` data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We could change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: But would we really benefit? Probably not, because we would just end up defining
    functions that work on only the `Car String String Int` type. For instance, given
    our first definition of `Car`, we could make a function that displays the car’s
    properties in an easy-to-read format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We could test it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It’s a good little function! The type declaration is cute, and it works nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Now what if `Car` was `Car a b c`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We would need to force this function to take a `Car` type of `(Show a) => Car
    String String a`. You can see that the type signature is more complicated, and
    the only actual benefit would be that we could use any type that’s an instance
    of the `Show` type class as the type for `c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In real life though, we would end up using `Car String String Int` most of the
    time. So, parameterizing the `Car` type isn’t worth it.
  prefs: []
  type: TYPE_NORMAL
- en: We usually use type parameters when the type that’s contained inside the data
    type’s various value constructors isn’t really that important for the type to
    work. A list of stuff is a list of stuff, and it doesn’t matter what the type
    of that stuff is. If we need to sum a list of numbers, we can specify later in
    the summing function that we specifically want a list of numbers. The same goes
    for `Maybe`, which represents an option of either having nothing or having one
    of something. It doesn’t matter what the type of that something is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of a parameterized type that you’ve already met is `Map k v`
    from `Data.Map`. The `k` is the type of the keys in a map, and `v` is the type
    of the values. This is a good example of where type parameters are very useful.
    Having maps parameterized enables us to have mappings from any type to any other
    type, as long as the type of the key is part of the `Ord` type class. If we were
    defining a mapping type, we could add a type class constraint in the data declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it’s a very strong convention in Haskell to never add type class constraints
    in data declarations. Why? Well, because it doesn’t provide much benefit, and
    we end up writing more class constraints, even when we don’t need them. If we
    put the `Ord k` constraint in the data declaration for `Map k v`, we still need
    to put the constraint into functions that assume the keys in a map can be ordered.
    If we don’t put the constraint in the data declaration, then we don’t need to
    put `(Ord k) =>` in the type declarations of functions that don’t care whether
    the keys can be ordered. An example of such a function is `toList`, which just
    takes a mapping and converts it to an associative list. Its type signature is
    `toList :: Map k a -> [(k, a)]`. If `Map k v` had a type constraint in its data
    declaration, the type for `toList` would need to be `toList :: (Ord k) => Map
    k a -> [(k, a)]`, even though the function doesn’t compare keys by order.'
  prefs: []
  type: TYPE_NORMAL
- en: So don’t put type constraints into data declarations, even if it seems to make
    sense. You’ll need to put them into the function type declarations either way.
  prefs: []
  type: TYPE_NORMAL
- en: Vector von Doom
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s implement a 3D vector type and add some operations for it. We’ll make
    it a parameterized type, because even though it will usually contain numeric types,
    it will still support several of them, like `Int`, `Integer`, and `Double`, to
    name a few.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Imagine a vector as an arrow in space—a line that points somewhere. The vector
    `Vector 3 4 5` would be a line that starts at the coordinates (0,0,0) in 3D space
    and ends at (and points to) the coordinates (3,4,5).
  prefs: []
  type: TYPE_NORMAL
- en: 'The vector functions work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `vplus` function adds two vectors together. This is done just by adding
    their corresponding components. When you add two vectors, you get a vector that’s
    the same as putting the second vector at the end of the first one and then drawing
    a vector from the beginning of the first one to the end of the second one. So
    adding two vectors together results in a third vector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dotProd` function gets the dot product of two vectors. The result of a
    dot product is a number, and we get it by multiplying the components of a vector
    pairwise and then adding all that together. The dot product of two vectors is
    useful when we want to figure out the angle between two vectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vmult` function multiplies a vector with a number. If we multiply a vector
    with a number, we multiply every component of the vector with that number, effectively
    elongating (or shortening it), but it keeps on pointing in the same general direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions can operate on any type in the form of `Vector a`, as long as
    the `a` is an instance of the `Num` type class. For instance, they can operate
    on values of type `Vector Int`, `Vector Integer`, `Vector Float`, and so on, because
    `Int`, `Integer`, and `Float` are all instances of the `Num` type class. However,
    they won’t work on values of type `Vector Char` or `Vector Bool`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you examine the type declaration for these functions, you’ll see that
    they can operate only on vectors of the same type, and the numbers involved must
    also be of the type that is contained in the vectors. We can’t add together a
    `Vector Int` and a `Vector Double`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we didn’t put a `Num` class constraint in the data declaration.
    As explained in the previous section, even if we put it there, we would still
    need to repeat it in the functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, it’s very important to distinguish between the type constructor
    and the value constructor. When declaring a data type, the part before the `=`
    is the type constructor, and the constructors after it (possibly separated by
    `|` characters) are value constructors. For instance, giving a function the following
    type would be wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This doesn’t work because the type of our vector is `Vector a`, and not `Vector
    a a a`. It takes only one type parameter, even though its value constructor has
    three fields.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s play around with our vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Derived Instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Type Classes 101](ch02s04.html "Type Classes 101") in [Type Classes 101](ch02s04.html
    "Type Classes 101"), you learned that a type class is a sort of an interface that
    defines some behavior, and that a type can be made an instance of a type class
    if it supports that behavior. For example, the `Int` type is an instance of the
    `Eq` type class because the `Eq` type class defines behavior for stuff that can
    be equated. And because integers can be equated, `Int` was made a part of the
    `Eq` type class. The real usefulness comes with the functions that act as the
    interface for `Eq`, namely `==` and `/=`. If a type is a part of the `Eq` type
    class, we can use the `==` functions with values of that type. That’s why expressions
    like `4 == 4` and `"foo" == "bar"` type check.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802598.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Haskell type classes are often confused with classes in languages like Java,
    Python, C++ and the like, which trips up a lot of programmers. In those languages,
    classes are a blueprint from which we create objects that can do some actions.
    But we don’t make data from Haskell type classes. Instead, we first make our data
    type, and then we think about how it can act. If it can act like something that
    can be equated, we make it an instance of the `Eq` type class. If it can act like
    something that can be ordered, we make it an instance of the `Ord` type class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how Haskell can automatically make our type an instance of any of
    the following type classes: `Eq`, `Ord`, `Enum`, `Bounded`, `Show`, and `Read`.
    Haskell can derive the behavior of our types in these contexts if we use the `deriving`
    keyword when making our data type.'
  prefs: []
  type: TYPE_NORMAL
- en: Equating People
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider this data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It describes a person. Let’s assume that no two people have the same combination
    of first name, last name, and age. If we have records for two people, does it
    make sense to see if they represent the same person? Sure it does. We can try
    to equate them to see if they are equal. That’s why it would make sense for this
    type to be part of the `Eq` type class. We’ll derive the instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When we derive the `Eq` instance for a type and then try to compare two values
    of that type with `==` or `/=`, Haskell will see if the value constructors match
    (there’s only one value constructor here though), and then it will check if all
    the data contained inside matches by testing each pair of fields with `==`. However,
    there’s a catch: The types of all the fields also must be part of the `Eq` type
    class. But since that’s the case with both `String` and `Int`, we’re okay.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s make a few people. Put the following in a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s test our `Eq` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Of course, since `Person` is now in `Eq`, we can use it as the `a` for all functions
    that have a class constraint of `Eq a` in their type signature, such as `elem`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Show Me How to Read
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Show` and `Read` type classes are for things that can be converted to or
    from strings, respectively. As with `Eq`, if a type’s constructors have fields,
    their type must be a part of `Show` or `Read` if we want to make our type an instance
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make our `Person` data type a part of `Show` and `Read` as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now we can print a person out to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If we had tried to print a person on the terminal before making the `Person`
    data type part of `Show`, Haskell would have complained, claiming it didn’t know
    how to represent a person as a string. But since we first derived a `Show` instance
    for the data type, we didn’t get any complaints.
  prefs: []
  type: TYPE_NORMAL
- en: '`Read` is pretty much the inverse type class of `Show`. It’s for converting
    strings to values of our type. Remember though, that when we use the `read` function,
    we might need to use an explicit type annotation to tell Haskell which type we
    want to get as a result. To demonstrate this, let’s put a string that represents
    a person in a script and then load that script in GHCi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We wrote our string across several lines like this for increased readability.
    If we want to `read` that string, we need to tell Haskell which type we expect
    in return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If we use the result of our `read` later in a way that Haskell can infer that
    it should read it as a person, we don’t need to use type annotation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also read parameterized types, but we must give Haskell enough information
    so that it can figure out which type we want. If we try the following, we’ll get
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, Haskell doesn’t know which type to use for the type parameter
    `a`. But if we tell it that we want it to be an `Int`, it works just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Order in the Court!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can derive instances for the `Ord` type class, which is for types that have
    values that can be ordered. If we compare two values of the same type that were
    made using different constructors, the value that was defined first is considered
    smaller. For instance, consider the `Bool` type, which can have a value of either
    `False` or `True`. For the purpose of seeing how it behaves when compared, we
    can think of it as being implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Because the `False` value constructor is specified first and the `True` value
    constructor is specified after it, we can consider `True` as greater than `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If two values were made using the same constructor, they are considered to be
    equal, unless they have fields. If they have fields, the fields are compared to
    see which is greater. (Note that in this case, the types of the fields also must
    be part of the `Ord` type class.)
  prefs: []
  type: TYPE_NORMAL
- en: In the `Maybe a` data type, the `Nothing` value constructor is specified before
    the `Just` value constructor, so the value of `Nothing` is always smaller than
    the value of `Just something`, even if that something is minus one billion trillion.
    But if we specify two `Just` values, then it will compare what’s inside them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: However, we can’t do something like `Just (*3) > Just (*2)`, because `(*3)`
    and `(*2)` are functions, which are not instances of `Ord`.
  prefs: []
  type: TYPE_NORMAL
- en: Any Day of the Week
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can easily use algebraic data types to make enumerations, and the `Enum`
    and `Bounded` type classes help us with that. Consider the following data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Because all the type’s value constructors are nullary (that is, they don’t have
    any fields), we can make it part of the `Enum` type class. The `Enum` type class
    is for things that have predecessors and successors. We can also make it part
    of the `Bounded` type class, which is for things that have a lowest possible value
    and highest possible value. And while we’re at it, let’s also make it an instance
    of all the other derivable type classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s see what we can do with our new `Day` type. Because it’s part of the
    `Show` and `Read` type classes, we can convert values of this type to and from
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Because it’s part of the `Eq` and `Ord` type classes, we can compare or equate
    days.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: It’s also part of `Bounded`, so we can get the lowest and highest day.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As it’s an instance of `Enum`, we can get predecessors and successors of days
    and make list ranges from them!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Type Synonyms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, when writing types, the `[Char]` and `String` types are
    equivalent and interchangeable. That’s implemented with *type synonyms*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type synonyms don’t really do anything per se—they’re just about giving some
    types different names so that they make more sense to someone reading our code
    and documentation. Here’s how the standard library defines `String` as a synonym
    for `[Char]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802600.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `type` keyword here might be misleading, because a new type is not being
    created (that’s done with the `data` keyword). Rather, this defines a synonym
    for an existing type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we make a function that converts a string to uppercase and call it `toUpperString`,
    we can give it a type declaration of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use this type declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The two are essentially the same, but the latter is nicer to read.
  prefs: []
  type: TYPE_NORMAL
- en: Making Our Phonebook Prettier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we were dealing with the `Data.Map` module, we first represented a phonebook
    with an association list (a list of key/value pairs) before converting it into
    a map. Here’s that version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The type of `phoneBook` is `[(String, String)]`. That tells us that it’s an
    association list that maps from strings to strings, but not much else. Let’s make
    a type synonym to convey some more information in the type declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the type declaration for our phonebook can be `phoneBook :: PhoneBook`.
    Let’s make a type synonym for `String` as well.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Haskell programmers give type synonyms to the `String` type when they want to
    convey more information about the strings in their functions—what they actually
    represent.
  prefs: []
  type: TYPE_NORMAL
- en: So now, when we implement a function that takes a name and a number and checks
    if that name and number combination is in our phonebook, we can give it a very
    pretty and descriptive type declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If we decided not to use type synonyms, our function would have this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the type declaration that takes advantage of type synonyms is
    easier to understand. However, you shouldn’t go overboard with these synonyms.
    We introduce type synonyms either to describe what some existing type represents
    in our functions (and thus our type declarations become better documentation)
    or when something has a longish type that’s repeated a lot (like `[(String, String)]`)
    but represents something more specific in the context of our functions.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing Type Synonyms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type synonyms can also be parameterized. If we want a type that represents
    an association list type, but still want it to be general so it can use any type
    as the keys and values, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now a function that gets the value by a key in an association list can have
    a type of `(Eq k) => k -> AssocList k v -> Maybe v`. `AssocList` is a type constructor
    that takes two types and produces a concrete type—for instance, `AssocList Int
    String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we can partially apply functions to get new functions, we can partially
    apply type parameters and get new type constructors from them. When we call a
    function with too few parameters, we get back a new function. In the same way,
    we can specify a type constructor with too few type parameters and get back a
    partially applied type constructor. If we wanted a type that represents a map
    (from `Data.Map`) from integers to something, we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we could do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Either way, the `IntMap` type constructor takes one parameter, and that is the
    type of what the integers will point to.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re going to try to implement this, you probably will want to do a qualified
    import of `Data.Map`. When you do a qualified import, type constructors also need
    to be preceded with a module name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that you really understand the distinction between type constructors
    and value constructors. Just because we made a type synonym called `IntMap` or
    `AssocList` doesn’t mean that we can do stuff like `AssocList [(1,2), (4,5),(7,9)]`.
    All it means is that we can refer to its type by using different names. We can
    do `[(1,2),(3,5),(8,9)] :: AssocList Int Int`, which will make the numbers inside
    assume a type of `Int`. However, we can still use that list in the same way that
    we would use any normal list that has pairs of integers.'
  prefs: []
  type: TYPE_NORMAL
- en: Type synonyms (and types generally) can be used only in the type portion of
    Haskell. Haskell’s type portion includes data and type declarations, as well as
    after a `::` in type declarations or type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Go Left, Then Right
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another cool data type that takes two types as its parameters is the `Either
    a b` type. This is roughly how it’s defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: It has two value constructors. If `Left` is used, then its contents are of type
    `a`; if `Right` is used, its contents are of type `b`. So we can use this type
    to encapsulate a value of one type or another. Then when we get a value of type
    `Either a b`, we usually pattern match on both `Left` and `Right`, and we do different
    stuff based on which one matches.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In this code, when we examine the type of `Left True`, we see that the type
    is `Either Bool b`. The first type parameter is `Bool`, because we made our value
    with the `Left` value constructor, whereas the second type parameter remains polymorphic.
    This is similar to how a `Nothing` value has the type `Maybe a`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you’ve seen `Maybe a` mostly used to represent the results of computations
    that could have failed. But sometimes, `Maybe a` isn’t good enough, because `Nothing`
    doesn’t convey much information other than that something has failed. That’s fine
    for functions that can fail in only one way, or if we’re not interested in how
    or why they failed. For instance, a `Data.Map` lookup fails only if the key wasn’t
    in the map, so we know exactly what happened.
  prefs: []
  type: TYPE_NORMAL
- en: However, when we’re interested in how or why some function failed, we usually
    use the result type of `Either a b`, where `a` is a type that can tell us something
    about the possible failure, and `b` is the type of a successful computation. Hence,
    errors use the `Left` value constructor, and results use `Right`.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, suppose that a high school has lockers so that students have
    some place to put their Guns N’ Roses posters. Each locker has a code combination.
    When students need to be assigned a locker, they tell the locker supervisor which
    locker number they want, and he gives them the code. However, if someone is already
    using that locker, the student needs to pick a different one. We’ll use a map
    from `Data.Map` to represent the lockers. It will map from locker numbers to a
    pair that indicates whether the locker is in use and the locker code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We introduce a new data type to represent whether a locker is taken or free,
    and we make a type synonym for the locker code. We also make a type synonym for
    the type that maps from integers to pairs of locker state and code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll make a function that searches for the code in a locker map. We’ll
    use an `Either String Code` type to represent our result, because our lookup can
    fail in two ways: The locker can be taken, in which case we can’t tell the code,
    or the locker number might not exist. If the lookup fails, we’re just going to
    use a `String` to indicate what happened.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We do a normal lookup in the map. If we get a `Nothing`, we return a value of
    type `Left String`, saying that the locker doesn’t exist. If we do find it, then
    we do an additional check to see if the locker is in use. If it is, we return
    a `Left` saying that it’s already taken. If it isn’t, we return a value of type
    `Right Code`, in which we give the student the correct code for the locker. It’s
    actually a `Right String` (which is a `Right [Char])`, but we added that type
    synonym to introduce some additional documentation into the type declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s try looking up some locker codes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We could have used a `Maybe a` to represent the result, but then we wouldn’t
    know why we couldn’t get the code. But now we have information about the failure
    in our result type.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you’ve seen, a constructor in an algebraic data type can have several fields
    (or none at all), and each field must be of some concrete type. So we can make
    types that have themselves as types in their fields! And that means we can create
    recursive data types, where one value of some type contains values of that type,
    which in turn contain more values of the same type, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about this list: `[5]`. That’s just syntactic sugar for `5:[]`. On the
    left side of the `:`, there’s a value; on the right side, there’s a list. In this
    case, it’s an empty list. Now how about the list `[4,5]`? Well, that desugars
    to `4:(5:[])`. Looking at the first `:`, we see that it also has an element on
    its left side and a list, `(5:[])`, on its right side. The same goes for a list
    like `3:(4:(5:6:[]))`, which could be written either like that or like `3:4:5:6:[]`
    (because `:` is right-associative) or `[3,4,5,6]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802602.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A list can be an empty list, or it can be an element joined together with a
    `:` with another list (that might be an empty list).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use algebraic data types to implement our own list!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This follows our definition of lists. It’s either an empty list or a combination
    of a head with some value and a list. If you’re confused about this, you might
    find it easier to understand in record syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'You might also be confused about the `Cons` constructor here. Informally speaking,
    `Cons` is another word for `:`. In lists, `:` is actually a constructor that takes
    a value and another list and returns a list. In other words, it has two fields:
    One field is of the type of `a`, and the other is of the type `List a`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We called our `Cons` constructor in an infix manner so you can see how it’s
    just like `:`. `Empty` is like `[]`, and ``4 `Cons` (5 `Cons` Empty)`` is like
    `4:(5:[])`.
  prefs: []
  type: TYPE_NORMAL
- en: Improving Our List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can define functions to be automatically infix by naming them using only
    special characters. We can also do the same with constructors, since they’re just
    functions that return a data type. There is one restriction however: Infix constructors
    must begin with a colon. So check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'First, notice a new syntactic construct: the fixity declaration, which is the
    line above our data declaration. When we define functions as operators, we can
    use that to give them a *fixity* (but we don’t have to). A fixity states how tightly
    the operator binds and whether it’s left-associative or right-associative. For
    instance, the `*` operator’s fixity is `infixl 7 *`, and the `+` operator’s fixity
    is `infixl 6`. That means that they’re both left-associative (in other words,
    `4 * 3 * 2` is the same as `(4 * 3) * 2`), but `*` binds tighter than `+`, because
    it has a greater fixity. So `5 * 4 + 3` is equivalent to `(5 * 4) + 3`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, we just wrote `a :-: (List a)` instead of `Cons a (List a)`. Now,
    we can write out lists in our list type like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s make a function that adds two of our lists together. This is how `++`
    is defined for normal lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We’ll just steal that for our own list. We’ll name the function `^++`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s see try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: If we wanted, we could implement all of the functions that operate on lists
    on our own list type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how we pattern matched on `(x :-: xs)`. That works because pattern matching
    is actually about matching constructors. We can match on `:-:` because it is a
    constructor for our own list type, and we can also match on `:` because it is
    a constructor for the built-in list type. The same goes for `[]`. Because pattern
    matching works (only) on constructors, we can match for normal prefix constructors
    or stuff like `8` or `''a''`, which are basically constructors for the numeric
    and character types, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's Plant a Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get a better feel for recursive data structures in Haskell, we’re going to
    implement a binary search tree.
  prefs: []
  type: TYPE_NORMAL
- en: In a binary search tree, an element points to two elements—one on its left and
    one on its right. The element to the left is smaller; the element to the right
    is bigger. Each of those elements can also point to two elements (or one or none).
    In effect, each element has up to two subtrees.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802604.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A cool thing about binary search trees is that we know that all the elements
    at the left subtree of, say, 5, will be smaller than 5\. Elements in the right
    subtree will be bigger. So if we need to find if 8 is in our tree, we start at
    5, and then because 8 is greater than 5, we go right. We’re now at 7, and because
    8 is greater than 7, we go right again. And we’ve found our element in three hops!
    If this were a normal list (or a tree, but really unbalanced), it would take us
    seven hops to see if 8 is in there.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sets and maps from `Data.Set` and `Data.Map` are implemented using trees, but
    instead of normal binary search trees, they use *balanced* binary search trees.
    A tree is balanced if its left and right subtrees are of approximately the same
    height. This makes searching through the tree faster. But for our examples, we’ll
    just be implementing normal binary search trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we’re going to say: A tree is either an empty tree or it’s an element
    that contains some value and two trees. Sounds like a perfect fit for an algebraic
    data type!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Instead of manually building a tree, we’ll make a function that takes a tree
    and an element and inserts an element. We do this by comparing the new value to
    the tree’s root node. If it’s smaller than the root, we go left; if it’s larger,
    we go right. We then do the same for every subsequent node until we reach an empty
    tree. Once we’ve reached an empty tree, we insert a node with our new value.
  prefs: []
  type: TYPE_NORMAL
- en: In languages like C, we would do this by modifying the pointers and values inside
    the tree. In Haskell, we can’t modify our tree directly, so we need to make a
    new subtree each time we decide to go left or right. In the end, the insertion
    function returns a completely new tree, because Haskell doesn’t have a concept
    of pointers, just values. Hence, the type for our insertion function will be something
    like `a -> Tree a - > Tree a`. It takes an element and a tree and returns a new
    tree that has that element inside. This might seem like it’s inefficient, but
    Haskell makes it possible to share most of the subtrees between the old tree and
    the new tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two functions for building the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '`singleton` is a utility function for making a singleton tree (a tree with
    just one node). It’s just a shortcut for creating a node that has something set
    as its root, and two empty subtrees.'
  prefs: []
  type: TYPE_NORMAL
- en: The `treeInsert` function is to insert an element into a tree. Here, we first
    have the base case as a pattern. If we’ve reached an empty subtree, that means
    we’re where we want to go, and we insert a singleton tree with our element. If
    we’re not inserting into an empty tree, then we need to do some checking. First,
    if the element we’re inserting is equal to the root element, we just return a
    tree that’s the same. If it’s smaller, we return a tree that has the same root
    value and the same right subtree, but instead of its left subtree, we put a tree
    that has our value inserted into it. We do the same if our value is bigger than
    the root element, but the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we’re going to make a function that checks if some element is in the
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: First, we define the base case. If we’re looking for an element in an empty
    tree, then it’s certainly not there. Notice how this is the same as the base case
    when searching for elements in lists. If we’re not looking for an element in an
    empty tree, then we check some things. If the element in the root node is what
    we’re looking for, great! If it’s not, what then? Well, we can take advantage
    of knowing that all the left elements are smaller than the root node. If the element
    we’re looking for is smaller than the root node, we check to see if it’s in the
    left subtree. If it’s bigger, we check to see if it’s in the right subtree.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s have some fun with our trees! Instead of manually creating one (although
    we could), we’ll use a fold to build a tree from a list. Remember that pretty
    much everything that traverses a list one item at a time and returns a value can
    be implemented with a fold! We’re going to start with the empty tree and then
    approach a list from the right and insert element after element into our accumulator
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you run this in GHCi, the result from `numsTree` will be printed in one long
    line. Here, it’s broken up into many lines; otherwise, it would run off the page!
  prefs: []
  type: TYPE_NORMAL
- en: In this `foldr`, `treeInsert` is the folding binary function (it takes a tree
    and a list element and produces a new tree), and `EmptyTree` is the starting accumulator.
    `nums`, of course, is the list we’re folding over.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we print our tree to the console, it’s not very readable, but we can still
    make out its structure. We see that the root node is `5` and that it has two subtrees:
    one with a root node of `3` and the other with a root node of `7`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check if certain values are contained in the tree, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, algebraic data structures are a really cool and powerful concept
    in Haskell. We can use them to make anything from Boolean values and weekday enumerations
    to binary search trees, and more!
  prefs: []
  type: TYPE_NORMAL
- en: Type Classes 102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you’ve learned about some of the standard Haskell type classes and seen
    which types they contain. You’ve also learned how to automatically make your own
    type instances of the standard type classes by asking Haskell to derive the instances.
    This section explains how to make your own type classes and how to make type instances
    of them by hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick type class recap: Type classes are sort of like interfaces. A type
    class defines some behavior (such as comparing for equality, comparing for ordering,
    and enumeration). Types that can behave in that way are made instances of that
    type class. The behavior of type classes is achieved by defining functions or
    just type declarations that we then implement. So when we say that a type is an
    instance of a type class, we mean that we can use the functions that the type
    class defines with that type.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802606.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that type classes have nothing to do with classes in languages like
    Java or Python. This confuses many people, so I want you to forget everything
    you know about classes in imperative languages right now!
  prefs: []
  type: TYPE_NORMAL
- en: Inside the Eq Type Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an example, let’s look at the `Eq` type class. Remember that `Eq` is for
    values that can be equated. It defines the functions `==` and `/=`. If we have
    the type `Car` and comparing two cars with the equality function `==` makes sense,
    then it makes sense for `Car` to be an instance of `Eq`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the `Eq` class is defined in the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Whoa! Some strange syntax and keywords here!
  prefs: []
  type: TYPE_NORMAL
- en: '`class Eq a where` means a new type class called `Eq` is being defined. The
    `a` is the type variable, so `a` will play the role of the type that will soon
    be made an instance of `Eq`. (It doesn’t need to be called `a`, and it doesn’t
    even need to be one letter—it just must be in all lowercase.)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, several functions are defined. Note that it’s not mandatory to implement
    the function bodies themselves; just their type declarations are required. Here,
    the function bodies for the functions that `Eq` defines are implemented—defined
    in terms of mutual recursion. It says that two values whose types are instances
    of `Eq` are equal if they are not different, and they are different if they are
    not equal. You’ll see how this helps us soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final type of the functions that we define in a type class is also worth
    noting. If we have, say, `class Eq a where`, and then define a type declaration
    within that class like `(==) :: a -> a -> Bool`, when we examine the type of that
    function later, it will have the type of `(Eq a) => a -> a -> Bool`.'
  prefs: []
  type: TYPE_NORMAL
- en: A Traffic Light Data Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So once we have a class, what can we do with it? We can make type instances
    of that class and get some nice functionality. Check out this type, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'It defines the states of a traffic light. Notice how we didn’t derive any class
    instances for it. That’s because we’re going to write some instances by hand.
    Here’s how we make it an instance of `Eq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We did it by using the `instance` keyword. So `class` is for defining new type
    classes, and `instance` is for making our types instances of type classes. When
    we were defining `Eq`, we wrote `class Eq a where`, and we said that `a` plays
    the role of whichever type will be made an instance later. We can see that clearly
    here, because when we’re making an instance, we write `instance Eq TrafficLight
    where`. We replace the `a` with the actual type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `==` was defined in terms of `/=` and vice versa in the class declaration,
    we needed to overwrite only one of them in the instance declaration. That’s called
    the *minimal complete definition* for the type class—the minimum of functions
    that we must implement so that our type can behave as the class advertises. To
    fulfill the minimal complete definition for `Eq`, we need to overwrite either
    `==` or `/=`. If `Eq` were defined simply like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: we would need to implement both of these functions when making a type an instance
    of `Eq`, because Haskell wouldn’t know how these two functions are related. The
    minimal complete definition would then be both `==` and `/=`.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that we implemented `==` simply by doing pattern matching. Since
    there are many more cases where two lights aren’t equal, we specified the ones
    that *are* equal, and then just did a catchall pattern saying that if it’s none
    of the previous combinations, then two lights aren’t equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make this an instance of `Show` by hand, too. To satisfy the minimal
    complete definition for `Show`, we just need to implement its `show` function,
    which takes a value and turns it into a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we used pattern matching to achieve our goals. Let’s see how it
    works in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: We could have just derived `Eq`, and it would have had the same effect (but
    we didn’t for educational purposes). However, deriving `Show` would have just
    directly translated the value constructors to strings. If we want our lights to
    appear as `Red light`, we need to make the instance declaration by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also make type classes that are subclasses of other type classes. The
    class declaration for `Num` is a bit long, but here’s the first part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, there are a lot of places where we can cram in class
    constraints. So this is just like writing `class Num a where`, but we state that
    our type `a` must be an instance of `Eq`. We’re essentially saying that we need
    to make a type an instance of `Eq` before we can make it an instance of `Num`.
    Before some type can be considered a number, it makes sense that we can determine
    whether values of that type can be equated.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all there is to subclassing—it’s just a class constraint on a class declaration!
    When defining function bodies in the class declaration or in instance declarations,
    we can assume that `a` is a part of `Eq`, so we can use `==` on values of that
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized Types As Instances of Type Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'But how are the `Maybe` or list types made as instances of type classes? What
    makes `Maybe` different from, say, `TrafficLight` is that `Maybe` in itself isn’t
    a concrete type—it’s a type constructor that takes one type parameter (like `Char`)
    to produce a concrete type (like `Maybe Char`). Let’s take a look at the `Eq`
    type class again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'From the type declarations, we see that `a` is used as a concrete type because
    all the types in functions must be concrete. Remember that you can’t have a function
    of the type `a -> Maybe`, but you *can* have a function of the type `a -> Maybe
    a` or `Maybe Int -> Maybe String`. That’s why we can’t do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The `a` must be a concrete type, and `Maybe` is not; it’s a type constructor
    that takes one parameter and then *produces* a concrete type.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would also be tedious if we needed to make a separate instance for every
    possible type that `Maybe`’s type parameter could take on. If we needed to write
    `instance Eq (Maybe Int) where`, `instance Eq (Maybe Char) where`, and so on for
    every type, we would get nowhere. That’s why we can just leave the parameter as
    a type variable, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This is like saying that we want to make all types of the form `Maybe something`
    an instance of `Eq`. We actually could have written `(Maybe something)`, but using
    single letters conforms to the Haskell style.
  prefs: []
  type: TYPE_NORMAL
- en: The `(Maybe m)` here plays the role of the `a` from `class Eq a where`. While
    `Maybe` isn’t a concrete type, `Maybe m` is. By specifying a type parameter as
    a type variable (`m`, which is in lowercase), we said that we want all types that
    are in the form of `Maybe m`, where `m` is any type, to be an instance of `Eq`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one problem with this though. Can you spot it? We use `==` on the contents
    of the `Maybe`, but we have no assurance that what the `Maybe` contains can be
    used with `Eq`! That’s why we modify our instance declaration like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: We needed to add a class constraint! With this instance declaration, we say
    that we want all types of the form `Maybe m` to be part of the `Eq` type class,
    but only those types where the `m` (what’s contained inside the `Maybe`) is also
    a part of `Eq`. This is actually how Haskell would derive the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, class constraints in class declarations are used for making
    a type class a subclass of another type class, and class constraints in instance
    declarations are used to express requirements about the contents of some type.
    For instance, here we required the contents of the `Maybe` to also be part of
    the `Eq` type class.
  prefs: []
  type: TYPE_NORMAL
- en: When making instances, if you see that a type is used as a concrete type in
    the type declarations (like the `a` in `a -> a -> Bool`), you need to supply type
    parameters and add parentheses so that you end up with a concrete type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take into account that the type you’re trying to make an instance of will replace
    the parameter in the class declaration. The `a` from `class Eq a where` will be
    replaced with a real type when you make an instance, so try to mentally put your
    type into the function type declarations as well. The following type declaration
    really doesn’t make much sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'But this does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just something to think about, because `==` will always have a type
    of `(==) :: (Eq a) => a -> a -> Bool`, no matter what instances we make.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Oh, and one more thing: If you want to see what the instances of a type class
    are, just type `:info YourTypeClass` in GHCi. For instance, typing `:info Num`
    will show which functions the type class defines, and it will give you a list
    of the types in the type class. `:info` works for types and type constructors,
    too. If you do `:info Maybe`, it will show you all the type classes that `Maybe`
    is an instance of. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: A Yes-No Type Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JavaScript and some other weakly typed languages, you can put almost anything
    inside an `if` expression. For example, in JavaScript, you can do something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Or like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Or like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: All of these will throw an alert of `NO!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the following code will give an alert of `YEAH!`, since JavaScript
    considers any nonempty string to be a true value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though strictly using `Bool` for Boolean semantics works better in Haskell,
    let’s try to implement this JavaScript-like behavior, just for fun! We’ll start
    out with a class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty simple. The `YesNo` type class defines one function. That function
    takes one value of a type that can be considered to hold some concept of trueness
    and tells us for sure if it’s true or not. Notice that from the way we use `a`
    in the function that `a` must be a concrete type.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let’s define some instances. For numbers, we’ll assume that (as in
    JavaScript) any number that isn’t `0` is true in a Boolean context and `0` is
    false.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Empty lists (and by extension, strings) are a no-ish value, while nonempty lists
    are a yes-ish value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we just put a type parameter `a` in there to make the list a concrete
    type, even though we don’t make any assumptions about the type that’s contained
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '`Bool` itself also holds trueness and falseness, and it’s pretty obvious which
    is which:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: But what’s `id`? It’s just a standard library function that takes a parameter
    and returns the same thing, which is what we would be writing here anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make `Maybe a` an instance, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802608.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We didn’t need a class constraint, because we made no assumptions about the
    contents of the `Maybe`. We just said that it’s true-ish if it’s a `Just` value
    and false-ish if it’s a `Nothing`. We still need to write out `(Maybe a)` instead
    of just `Maybe`. If you think about it, a `Maybe -> Bool` function can’t exist
    (because `Maybe` isn’t a concrete type), whereas a `Maybe a -> Bool` is fine and
    dandy. Still, this is really cool, because now any type of the form `Maybe something`
    is part of `YesNo`, and it doesn’t matter what that something is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we defined a `Tree a` type that represented a binary search tree.
    We can say an empty tree is false-ish, and anything that’s not an empty tree is
    true-ish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Can a traffic light be a yes or no value? Sure. If it’s red, you stop. If it’s
    green, you go. (If it’s yellow? Eh, I usually run the yellows because I live for
    adrenaline.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have some instances, let’s go play!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: It works!
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s make a function that mimics the `if` statement, but that works with
    `YesNo` values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes a `YesNo` value and two values of any type. If the yes-no--ish value
    is more of a yes, it returns the first of the two values; otherwise, it returns
    the second of them. Let’s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: The Functor Type Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve encountered a lot of the type classes in the standard library.
    We’ve played with `Ord`, which is for stuff that can be ordered. We’ve palled
    around with `Eq`, which is for things that can be equated. We’ve seen `Show`,
    which presents an interface for types whose values can be displayed as strings.
    Our good friend `Read` is there whenever we need to convert a string to a value
    of some type. And now, we’re going to take a look at the `Functor` type class,
    which is for things that can be mapped over.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802610.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You’re probably thinking about lists now, since mapping over lists is such a
    dominant idiom in Haskell. And you’re right, the list type is part of the `Functor`
    type class.
  prefs: []
  type: TYPE_NORMAL
- en: What better way to get to know the `Functor` type class than to see how it’s
    implemented? Let’s take a peek.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that it defines one function, `fmap`, and doesn’t provide any default
    implementation for that function. The type of `fmap` is interesting. In the definitions
    of type classes so far, the type variable that played the role of the type in
    the type class was a concrete type, like the `a` in `(==) :: (Eq a) => a -> a
    -> Bool`. But now, the `f` is not a concrete type (a type that a value can hold,
    like `Int`, `Bool`, or `Maybe String`), but a type constructor that takes one
    type parameter. (A quick refresher example: `Maybe Int` is a concrete type, but
    `Maybe` is a type constructor that takes one type as the parameter.)'
  prefs: []
  type: TYPE_NORMAL
- en: We see that `fmap` takes a function from one type to another and a functor value
    applied with one type and returns a functor value applied with another type. If
    this sounds a bit confusing, don’t worry—all will be revealed soon when we check
    out a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hmm . . . the type declaration for `fmap` reminds me of something. Let’s look
    at the type signature of the `map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Ah, interesting! It takes a function from one type to another and a list of
    one type and returns a list of another type. My friends, I think we have ourselves
    a functor! In fact, `map` is just a `fmap` that works only on lists. Here’s how
    the list is an instance of the `Functor` type class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it! Notice how we didn’t write `instance Functor [a] where`. This is
    because `f` must be a type constructor that takes one type, which we can see in
    the following type declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '`[a]` is already a concrete type (of a list with any type inside it), while
    `[]` is a type constructor that takes one type and can produce types such as `[Int]`,
    `[String]`, or even `[[String]]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since for lists, `fmap` is just `map`, we get the same results when using these
    functions on lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: What happens when we `map` or `fmap` over an empty list? Well, of course, we
    get an empty list. It turns an empty list of type `[a]` into an empty list of
    type `[b]`.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe As a Functor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Types that can act like a box can be functors. You can think of a list as a
    box that can be empty or have something inside it, including another box. That
    box can also be empty or contain something and another box, and so on. So, what
    else has the properties of being like a box? For one, the `Maybe a` type. In a
    way, it’s like a box that can hold nothing (in which case it has the value of
    `Nothing`), or it can contain one item (like `"HAHA"`, in which case it has a
    value of `Just "HAHA"`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how `Maybe` is a functor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Again, notice how we wrote `instance Functor Maybe where` instead of `instance
    Functor (Maybe m) where`, as we did when we were dealing with `YesNo`. `Functor`
    wants a type constructor that takes one type, and not a concrete type. If you
    mentally replace the `f`s with `Maybe`s, `fmap` acts like a `(a -> b) -> Maybe
    a -> Maybe b` for this particular type, which looks okay. But if you replace `f`
    with `(Maybe m)`, then it would seem to act like a `(a -> b) -> Maybe m a -> Maybe
    m b`, which doesn’t make sense, because `Maybe` takes just one type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fmap` implementation is pretty simple. If it’s an empty value of `Nothing`,
    then just return a `Nothing`. If we map over an empty box, we get an empty box.
    If we map over an empty list, we get an empty list. If it’s not an empty value,
    but rather a single value packed in a `Just`, then we apply the function on the
    contents of the `Just`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Trees Are Functors, Too
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another thing that can be mapped over and made an instance of `Functor` is
    our `Tree a` type. It can be thought of as a box (it holds several or no values),
    and the `Tree` type constructor takes exactly one type parameter. If you look
    at `fmap` as if it were a function made only for `Tree`, its type signature would
    look like this: `(a -> b) -> Tree a -> Tree b`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to use recursion on this one. Mapping over an empty tree will produce
    an empty tree. Mapping over a nonempty tree will produce a tree consisting of
    our function applied to the root value, and its left and right subtrees will be
    the previous subtrees, but with our function mapped over them. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Be careful though! If you use the `Tree a` type to represent a binary search
    tree, there is no guarantee that it will remain a binary search tree after mapping
    a function over it. For something to be considered a binary search tree, all the
    elements to the left of some node must be smaller than the element in the node,
    and all the elements to the right must be greater. But if you map a function like
    `negate` over a binary search tree, the elements to the left of the node suddenly
    become greater than its element, and your binary search tree becomes just a normal
    binary tree.
  prefs: []
  type: TYPE_NORMAL
- en: Either a As a Functor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How about `Either a b`? Can this be made a functor? The `Functor` type class
    wants a type constructor that takes only one type parameter, but `Either` takes
    two. Hmmm . . . I know, we’ll partially apply `Either` by feeding it only one
    parameter, so that it has one free parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how `Either a` is a functor in the standard libraries, more specifically
    in the `Control.Monad.Instances` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Well well, what do we have here? You can see how `Either a` was made an instance
    instead of just `Either`. That’s because `Either a` is a type constructor that
    takes one parameter, whereas `Either` takes two. If `fmap` were specifically for
    `Either a`, the type signature would be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Because that’s the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The function is mapped in the case of a `Right` value constructor, but it isn’t
    mapped in the case of a `Left`. Why is that? Well, looking back at how the `Either
    a b` type is defined, we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to map one function over both of them, `a` and `b` would need
    to be the same type. Think about it: If we try to map a function that takes a
    string and returns a string, and `b` is a string but `a` is a number, it won’t
    really work out. Also, considering what `fmap`’s type would be if it operated
    only on `Either a b` values, we can see that the first parameter must remain the
    same, while the second one can change, and the first parameter is actualized by
    the `Left` value constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: This also goes nicely with our box analogy if we think of the `Left` part as
    sort of an empty box with an error message written on the side telling us why
    it’s empty.
  prefs: []
  type: TYPE_NORMAL
- en: Maps from `Data.Map` can also be made into functor values, because they hold
    values (or not!). In the case of `Map k v`, `fmap` will map a function `v -> v'`
    over a map of type `Map k v` and return a map of type `Map k v'`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `'` character has no special meaning in types, just as it has no special
    meaning when naming values. It’s just used to denote things that are similar,
    but slightly changed.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, you can try to figure out how `Map k` is made an instance of
    `Functor` by yourself!
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen from the examples, with `Functor`, type classes can represent
    pretty cool higher-order concepts. You’ve also had some more practice with partially
    applying types and making instances. In [Chapter 11](ch11.html "Chapter 11. Applicative
    Functors"), we’ll take a look at some laws that apply for functors.
  prefs: []
  type: TYPE_NORMAL
- en: Kinds and Some Type-Foo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type constructors take other types as parameters to eventually produce concrete
    types. This behavior is similar to that of functions, which take values as parameters
    to produce values. Also like functions, type constructors can be partially applied.
    For example, `Either String` is a type constructor that takes one type and produces
    a concrete type, like `Either String Int`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802612.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we’ll take a look at formally defining how types are applied
    to type constructors. You don’t really need to read this section to continue on
    your magical Haskell quest, but it may help you to see how Haskell’s type system
    works. And if you don’t quite understand everything right now, that’s okay, too.
  prefs: []
  type: TYPE_NORMAL
- en: Values like `3`, `"YEAH"`, or `takeWhile` (functions are also values—we can
    pass them around and such) each has their own types. Types are little labels that
    values carry so that we can reason about the values. But types have their own
    little labels called *kinds*. A kind is more or less the type of a type. This
    may sound a bit weird and confusing, but it’s actually a really cool concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'What are kinds, and what are they good for? Well, let’s examine the kind of
    a type by using the `:k` command in GHCi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: What does that `*` mean? It indicates that the type is a concrete type. A concrete
    type is a type that doesn’t take any type parameters. Values can have only types
    that are concrete types. If I had to read `*` out loud (I haven’t had to do that
    yet), I would say “star,” or just “type.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now let’s see what the kind of `Maybe` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'This kind tells us that the `Maybe` type constructor takes one concrete type
    (like `Int`) and returns a concrete type (like `Maybe Int`). Just as `Int -> Int`
    means that a function takes an `Int` and returns an `Int`, `* -> *` means that
    the type constructor takes one concrete type and returns a concrete type. Let’s
    apply the type parameter to `Maybe` and see what the kind of that type is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Just as you might have expected, we applied the type parameter to `Maybe` and
    got back a concrete type (that’s what `* -> *` means). A parallel (although not
    equivalent—types and kinds are two different things) to this is if we call `:t
    isUpper` and `:t isUpper 'A'`. The `isUpper` function has a type of `Char -> Bool`,
    and `isUpper 'A'` has a type of `Bool`, because its value is basically `False`.
    Both those types, however, have a kind of `*`.
  prefs: []
  type: TYPE_NORMAL
- en: We used `:k` on a type to get its kind, in the same way as we can use `:t` on
    a value to get its type. Again, types are the labels of values, and kinds are
    the labels of types, and there are parallels between the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the kind of `Either`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us that `Either` takes two concrete types as type parameters to
    produce a concrete type. It also looks somewhat like the type declaration of a
    function that takes two values and returns something. Type constructors are curried
    (just like functions), so we can partially apply them, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: When we wanted to make `Either a` part of the `Functor` type class, we needed
    to partially apply it, because `Functor` wants types that take only one parameter,
    while `Either` takes two. In other words, `Functor` wants types of kind `* ->
    *`, so we needed to partially apply `Either` to get this instead of its original
    kind, `* -> * -> *`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the definition of `Functor` again, we can see that the `f` type
    variable is used as a type that takes one concrete type to produce a concrete
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: We know it must produce a concrete type, because it’s used as the type of a
    value in a function. And from that, we can deduce that types that want to be friends
    with `Functor` must be of kind `* -> *`.
  prefs: []
  type: TYPE_NORMAL
