["```\nghci> max 4 5\n5\nghci> (max 4) 5\n5\n```", "```\nghci> :t max\nmax :: (Ord a) => a -> a -> a\n```", "```\nmax :: (Ord a) => a -> (a -> a)\n```", "```\nmultThree :: Int -> Int -> Int -> Int\nmultThree x y z = x * y * z\n```", "```\nmultThree :: Int -> (Int -> (Int -> Int))\n```", "```\nghci> let multTwoWithNine = multThree 9\nghci> multTwoWithNine 2 3\n54\n```", "```\ncompareWithHundred :: Int -> Ordering\ncompareWithHundred x = compare 100 x\n```", "```\nghci> compareWithHundred 99\nGT\n```", "```\ncompareWithHundred :: Int -> Ordering\ncompareWithHundred = compare 100\n```", "```\ndivideByTen :: (Floating a) => a -> a\ndivideByTen = (/10)\n```", "```\nghci> divideByTen 200\n20.0\nghci> 200 / 10\n20.0\nghci> (/10) 200\n20.0\n```", "```\nisUpperAlphanum :: Char -> Bool\nisUpperAlphanum = (`elem` ['A'..'Z'])\n```", "```\nghci> multThree 3 4\n<interactive>:1:0:\n    No instance for (Show (a -> a))\n      arising from a use of `print' at <interactive>:1:0-12\n    Possible fix: add an instance declaration for (Show (a -> a))\n    In the expression: print it\n    In a 'do' expression: print it\n```", "```\napplyTwice :: (a -> a) -> a -> a\napplyTwice f x = f (f x)\n```", "```\nghci> applyTwice (+3) 10\n16\nghci> applyTwice (++ \" HAHA\") \"HEY\"\n\"HEY HAHA HAHA\"\nghci> applyTwice (\"HAHA \" ++) \"HEY\"\n\"HAHA HAHA HEY\"\nghci> applyTwice (multThree 2 2) 9\n144\nghci> applyTwice (3:) [1]\n[3,3,1]\n```", "```\nzipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWith' _ [] _ = []\nzipWith' _ _ [] = []\nzipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys\n```", "```\nghci> zipWith' (+) [4,2,5,6] [2,6,2,3]\n[6,8,7,9]\nghci> zipWith' max [6,3,2,1] [7,3,1,5]\n[7,3,2,5]\nghci> zipWith' (++) [\"foo \", \"bar \", \"baz \"] [\"fighters\", \"hoppers\", \"aldrin\"]\n[\"foo fighters\",\"bar hoppers\",\"baz aldrin\"]\nghci> zipWith' (*) (replicate 5 2) [1..]\n[2,4,6,8,10]\nghci> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]\n[[3,4,6],[9,20,30],[10,12,12]]\n```", "```\nflip' :: (a -> b -> c) -> (b -> a -> c)\nflip' f = g\n    where g x y = f y x\n```", "```\nflip' :: (a -> b -> c) -> b -> a -> c\nflip' f y x = f x y\n```", "```\nghci> zip [1,2,3,4,5] \"hello\"\n[(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]\nghci> flip' zip [1,2,3,4,5] \"hello\"\n[('h',1),('e',2),('l',3),('l',4),('o',5)]\nghci> zipWith div [2,2..] [10,8,6,4,2]\n[0,0,0,0,1]\nghci> zipWith (flip' div) [2,2..] [10,8,6,4,2]\n[5,4,3,2,1]\n```", "```\nmap :: (a -> b) -> [a] -> [b]\nmap _ [] = []\nmap f (x:xs) = f x : map f xs\n```", "```\nghci> map (+3) [1,5,3,1,6]\n[4,8,6,4,9]\nghci> map (++ \"!\") [\"BIFF\", \"BANG\", \"POW\"]\n[\"BIFF!\",\"BANG!\",\"POW!\"]\nghci> map (replicate 3) [3..6]\n[[3,3,3],[4,4,4],[5,5,5],[6,6,6]]\nghci> map (map (^2)) [[1,2],[3,4,5,6],[7,8]]\n[[1,4],[9,16,25,36],[49,64]]\nghci> map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]\n[1,3,6,2,2]\n```", "```\nfilter :: (a -> Bool) -> [a] -> [a]\nfilter _ [] = []\nfilter p (x:xs)\n    | p x       = x : filter p xs\n    | otherwise = filter p xs\n```", "```\nghci> filter (>3) [1,5,3,2,1,6,4,3,2,1]\n[5,6,4]\nghci> filter (==3) [1,2,3,4,5]\n[3]\nghci> filter even [1..10]\n[2,4,6,8,10]\nghci> let notNull x = not (null x) in filter notNull\n [[1,2,3],[],[3,4,5],[2,2],[],[],[]]\n[[1,2,3],[3,4,5],[2,2]]\nghci> filter (`elem` ['a'..'z']) \"u LaUgH aT mE BeCaUsE I aM diFfeRent\"\n\"uagameasadifeent\"\nghci> filter (`elem` ['A'..'Z']) \"i LAuGh at you bEcause u R all the same\"\n\"LAGER\"\n```", "```\nghci> filter (<15) (filter even [1..20])\n[2,4,6,8,10,12,14]\n```", "```\nghci> [x | x <- [1..20], x < 15, even x]\n[2,4,6,8,10,12,14]\n```", "```\nquicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n    let smallerOrEqual = filter (<= x) xs\n        larger = filter (> x) xs\n    in  quicksort smallerOrEqual ++ [x] ++ quicksort larger\n```", "```\nlargestDivisible :: Integer\nlargestDivisible = head (filter p [100000,99999..])\n    where p x = x `mod` 3829 == 0\n```", "```\nghci> takeWhile (/=' ') \"elephants know how to party\"\n\"elephants\"\n```", "```\nghci> sum (takeWhile (<10000) (filter odd (map (^2) [1..])))\n166650\n```", "```\nghci> sum (takeWhile (<10000) [m | m <- [n^2 | n <- [1..]], odd m])\n166650\n```", "```\nchain :: Integer -> [Integer]\nchain 1 = [1]\nchain n\n    | even n =  n:chain (n `div` 2)\n    | odd n  =  n:chain (n*3 + 1)\n```", "```\nghci> chain 10\n[10,5,16,8,4,2,1]\nghci> chain 1\n[1]\nghci> chain 30\n[30,15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1]\n```", "```\nnumLongChains :: Int\nnumLongChains = length (filter isLong (map chain [1..100]))\n    where isLong xs = length xs > 15\n```", "```\nghci> let listOfFuns = map (*) [0..]\nghci> (listOfFuns !! 4) 5\n20\n```", "```\nnumLongChains :: Int\nnumLongChains = length (filter (\\xs -> length xs > 15) (map chain [1..100]))\n```", "```\nghci> map (+3) [1,6,3,2]\n[4,9,6,5]\nghci> map (\\x -> x + 3) [1,6,3,2]\n[4,9,6,5]\n```", "```\nghci> zipWith (\\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]\n[153.0,61.5,31.0,15.75,6.6]\n```", "```\nghci> map (\\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]\n[3,8,9,8,7]\n```", "```\naddThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\n\naddThree :: Int -> Int -> Int -> Int\naddThree' = \\x -> \\y -> \\z -> x + y + z\n```", "```\nflip' :: (a -> b -> c) -> b -> a -> c\nflip' f = \\x y -> f y x\n```", "```\nghci> zipWith (flip (++)) [\"love you\", \"love me\"] [\"i \", \"you \"]\n[\"i love you\",\"you love me\"]\nghci> map (flip subtract 20) [1,2,3,4]\n[19,18,17,16]\n```", "```\nsum' :: (Num a) => [a] -> a\nsum' xs = foldl (\\acc x -> acc + x) 0 xs\n```", "```\nghci> sum' [3,5,2,1]\n11\n```", "```\nsum' :: (Num a) => [a] -> a\nsum' = foldl (+) 0\n```", "```\nmap' :: (a -> b) -> [a] -> [b]\nmap' f xs = foldr (\\x acc -> f x : acc) [] xs\n```", "```\nmap' :: (a -> b) -> [a] -> [b]\nmap' f xs = foldl (\\acc x -> acc ++ [f x]) [] xs\n```", "```\nelem' :: (Eq a) => a -> [a] -> Bool\nelem' y ys = foldr (\\x acc -> if x == y then True else acc) False ys\n```", "```\nmaximum' :: (Ord a) => [a] -> a\nmaximum' = foldl1 max\n```", "```\nreverse' :: [a] -> [a]\nreverse' = foldl (\\acc x -> x : acc) []\n```", "```\nreverse' :: [a] -> [a]\nreverse' = foldl (flip (:)) []\n```", "```\nproduct' :: (Num a) => [a] -> a\nproduct' = foldl (*) 1\n```", "```\nfilter' :: (a -> Bool) -> [a] -> [a]\nfilter' p = foldr (\\x acc -> if p x then x : acc else acc) []\n```", "```\nlast' :: [a] -> a\nlast' = foldl1 (\\_ x -> x)\n```", "```\nf 3 (f 4 (f 5 (f 6 z)))\n```", "```\n3 + (4 + (5 + (6 + 0)))\n```", "```\n(+) 3 ((+) 4 ((+) 5 ((+) 6 0)))\n```", "```\ng (g (g (g z 3) 4) 5) 6\n```", "```\nflip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6\n```", "```\nand' :: [Bool] -> Bool\nand' xs = foldr (&&) True xs\n```", "```\nTrue && (False && (True && True))\n```", "```\nFalse && (False && (False && (False ...\n```", "```\n(&&) :: Bool -> Bool -> Bool\nTrue && x = x False && _ = False\n```", "```\nghci> and' (repeat False)\nFalse\n```", "```\nghci> scanl (+) 0 [3,5,2,1]\n[0,3,8,10,11]\nghci> scanr (+) 0 [3,5,2,1]\n[11,8,3,1,0]\nghci> scanl1 (\\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1]\n[3,4,5,5,7,9,9,9]\nghci> scanl (flip (:)) [] [3,2,1]\n[[],[3],[2,3],[1,2,3]]\n```", "```\nsqrtSums :: Int\nsqrtSums = length (takeWhile (<1000) (scanl1 (+) (map sqrt [1..]))) + 1\n```", "```\nghci> sqrtSums\n131\nghci> sum (map sqrt [1..131])\n1005.0942035344083\nghci> sum (map sqrt [1..130])\n993.6486803921487\n```", "```\n($) :: (a -> b) -> a -> b\nf $ x = f x\n```", "```\nghci> sum (filter (> 10) (map (*2) [2..10]))\n80\n```", "```\nghci> sum $ filter (> 10) (map (*2) [2..10])\n80\n```", "```\nghci> sum $ filter (> 10) $ map (*2) [2..10]\n80\n```", "```\nghci> map ($ 3) [(4+), (10*), (^2), sqrt]\n[7.0,30.0,9.0,1.7320508075688772]\n```", "```\n(.) :: (b -> c) -> (a -> b) -> a -> c\nf . g = \\x -> f (g x)\n```", "```\nghci> map (\\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24]\n[-5,-3,-6,-7,-3,-2,-19,-24]\n```", "```\nghci> map (negate . abs) [5,-3,-6,7,-3,2,-19,24]\n[-5,-3,-6,-7,-3,-2,-19,-24]\n```", "```\nghci> map (\\xs -> negate (sum (tail xs))) [[1..5],[3..6],[1..7]]\n[-14,-15,-27]\n```", "```\nghci> map (negate . sum . tail) [[1..5],[3..6],[1..7]]\n[-14,-15,-27]\n```", "```\nsum (replicate 5 (max 6.7 8.9))\n```", "```\n(sum . replicate 5) max 6.7 8.9\n```", "```\nsum . replicate 5 $ max 6.7 8.9\n```", "```\nreplicate 2 (product (map (*3) (zipWith max [1,2] [4,5])))\n```", "```\nreplicate 2 . product . map (*3) $ zipWith max [1,2] [4,5]\n```", "```\nzipWith max [1,2] [4,5]\n```", "```\nmap (*3) $ zipWith max [1,2] [4,5]\n```", "```\nproduct . map (*3) $ zipWith max [1,2] [4,5]\n```", "```\nreplicate 2 . product . map (*3) $ zipWith max [1,2] [4,5]\n```", "```\nsum' :: (Num a) => [a] -> a\nsum' xs = foldl (+) 0 xs\n```", "```\nsum' :: (Num a) => [a] -> a\nsum' = foldl (+) 0\n```", "```\nfn x = ceiling (negate (tan (cos (max 50 x))))\n```", "```\nfn = ceiling . negate . tan . cos . max 50\n```", "```\noddSquareSum :: Integer\noddSquareSum = sum (takeWhile (<10000) (filter odd (map (^2) [1..])))\n```", "```\noddSquareSum :: Integer\noddSquareSum = sum . takeWhile (<10000) . filter odd $ map (^2) [1..]\n```"]