- en: '![](../images/101-1.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/101-1.jpg)'
- en: '[**LOGGING**](toc.html#chapter6)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[**日志记录**](toc.html#chapter6)'
- en: '![](../images/as.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/as.jpg)'
- en: A *log message* is an asynchronous report of an event of interest. This chapter
    discusses logging in general and then looks in some detail at syslog, the default
    logging system on Linux. We also describe how to control logging thresholds while
    a daemon is running.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*日志消息*是对感兴趣事件的异步报告。本章讨论了日志记录的一般概念，然后详细探讨了 syslog，Linux 上的默认日志系统。我们还描述了如何在守护进程运行时控制日志阈值。'
- en: 'We’ve organized this chapter into the following sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章组织成以下部分：
- en: Do You Need Logging?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否需要日志记录？
- en: Architecture of a Logging System
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志系统架构
- en: syslog
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: syslog
- en: On-Demand Logging
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按需日志记录
- en: '[**Do You Need Logging?**](toc.html#chapter6.1)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[**你是否需要日志记录？**](toc.html#chapter6.1)'
- en: Before getting into the mechanics of logging, let’s discuss why you might want
    logging on your appliance.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨日志记录的机制之前，让我们讨论一下为什么您可能想在您的设备上启用日志记录。
- en: '**Uptime**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统运行时间**'
- en: The number one reason for logging is to increase the system availability of
    your appliance. Proper routing and displaying of log messages like *CPU fan speed
    below 1000 RPM* can help your end users keep their systems up and running. A regression
    or trend analysis of the system’s collected log messages can help identify problems
    before they interrupt service. Trend analysis is particularly useful in spotting
    problems with fans, disks, and power supplies.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录的首要原因是提高您的设备系统的可用性。正确路由和显示如“CPU 风扇转速低于 1000 RPM”之类的日志消息可以帮助您的最终用户保持系统运行。对系统收集的日志消息进行回归或趋势分析可以帮助在服务中断之前识别问题。趋势分析在发现风扇、磁盘和电源供应的问题特别有用。
- en: '**Security**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全**'
- en: If your appliance is on a network, it will almost certainly come under attack
    at some point. You can use log messages to trigger changes in the firewall rules
    or to notify the system operator or the end user that the system is under attack.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的设备连接到网络，它几乎肯定会在某个时候受到攻击。您可以使用日志消息来触发防火墙规则的变化，或者通知系统操作员或最终用户系统正在受到攻击。
- en: '**Debug**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试**'
- en: The first step in fixing a bug is recognizing that a bug exists. Log messages
    that report any inconsistency in input or output of a subroutine are invaluable
    for finding bugs. You can use the on-demand logging described later in this chapter
    to trace program execution and to record subroutine inputs and outputs when a
    bug is detected.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 修复错误的第一个步骤是认识到存在错误。报告子程序输入或输出任何不一致性的日志消息对于查找错误非常有价值。您可以使用本章后面描述的按需日志记录来跟踪程序执行，并在检测到错误时记录子程序的输入和输出。
- en: '**Integral to the application**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**与应用程序集成**'
- en: Laddie is a good example of an application with integrated logging and event
    processing. It simplified our design of the ladd daemon to have it report all
    alarm transitions using only a log message.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Laddie 是一个集成了日志记录和事件处理的应用的优秀例子。它简化了 ladd 守护进程的设计，使其仅通过日志消息报告所有警报转换。
- en: You may be unable to use logging on some deeply embedded Linux systems with
    limited connectivity and limited disk space. But for most systems, logging will
    be a real asset for your appliance.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能无法在一些具有有限连接性和有限磁盘空间的深度嵌入式 Linux 系统上使用日志记录。但对于大多数系统，日志记录将是您设备的一个真正资产。
- en: '[**Architecture of a Logging System**](toc.html#chapter6.2)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[**日志系统架构**](toc.html#chapter6.2)'
- en: This section describes the architecture and properties of an “ideal” logging
    system. The next section describes syslog and compares it to the ideal presented
    below.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了一个“理想”日志系统的架构和特性。下一节将描述 syslog 并将其与下面提出的理想系统进行比较。
- en: 'A logging system can be divided into three major sections: one to collect log
    messages, one to route them, and one to deliver them (or to start other actions).
    Figure 6-1 illustrates the architecture of a logging system.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 日志系统可以分为三个主要部分：一个用于收集日志消息，一个用于路由它们，一个用于交付它们（或启动其他操作）。图 6-1 展示了日志系统的架构。
- en: Let’s consider each of these three sections in more detail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地考虑这三个部分。
- en: '[***Message Sources***](toc.html#chapter6.3)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[***消息来源***](toc.html#chapter6.3)'
- en: The ideal logging system is a clearing house for messages from anywhere on the
    appliance, and it should be able to accept messages from many sources, including
    Unix sockets, UDP and TCP sockets, named pipes, and from following a file (the
    output of tail -f).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的日志系统是来自设备任何位置的日志消息的汇总中心，并且它应该能够接受来自许多来源的消息，包括 Unix 套接字、UDP 和 TCP 套接字、命名管道，以及通过跟踪文件（tail
    -f 的输出）。
- en: '![](../images/103-1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/103-1.jpg)'
- en: '*Figure 6-1: Log message flow in an appliance*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：设备中的日志消息流程*'
- en: The source code of the logging system should be well documented and modular
    to make it easy to add new types of message sources. The configuration of the
    system should make it easy to add new sources while the system is running.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 日志系统的源代码应该有良好的文档记录和模块化，以便于添加新的消息类型源。系统的配置应该使得在系统运行时添加新源变得容易。
- en: Let’s discuss three common message sources in a little more detail.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论三种常见的消息源。
- en: '**Unix sockets**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unix套接字**'
- en: Syslog, the most popular logging system on Linux, uses a Unix socket as its
    message collection point. Stream-oriented communication channels, such as a Unix
    socket, must have a delimiter to separate the messages. The two most common delimiters
    are a null character, which syslog uses, and a carriage return.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Syslog，Linux上最受欢迎的日志系统，使用Unix套接字作为其消息收集点。面向流的通信通道，如Unix套接字，必须有分隔符来分隔消息。最常见的两个分隔符是一个空字符，syslog使用它，以及一个回车符。
- en: '**Network sockets**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络套接字**'
- en: Network messages might arrive in a UDP datagram or over a TCP connection. Some
    applications accept TCP connections and broadcast their log messages to all connected
    sockets. The logging system should be able to accept TCP connections as well as
    initiate them. If the log messages are going to traverse an insecure network link,
    the system should encrypt them in transit using either Stunnel or SSH with port
    forwarding.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 网络消息可能以UDP数据报或TCP连接的形式到达。一些应用程序接受TCP连接并将它们的日志消息广播到所有连接的套接字。日志系统应该能够接受TCP连接以及发起它们。如果日志消息将要穿越一个不安全的网络链路，系统应该使用Stunnel或SSH端口转发在传输过程中加密它们。
- en: '**Following a file**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**跟踪文件**'
- en: 'Many applications write log messages directly to a file. If you want to capture
    the events reported in these log messages, you must watch the file for new messages.
    The tail -f command does this. Most often, you’ll see this as the command string:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序直接将日志消息写入文件。如果你想捕获这些日志消息中报告的事件，你必须监视文件以获取新消息。tail -f命令就是这样做。你通常看到这个命令字符串：
- en: tail -f app_log_file | logger
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: tail -f app_log_file | logger
- en: It seems a waste to create two processes just to capture an application’s log
    messages, and a good logging system should handle following a file as part of
    its core functionality.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了捕获应用程序的日志消息而创建两个进程似乎是一种浪费，一个好的日志系统应该将跟踪文件作为其核心功能的一部分来处理。
- en: '[***Message Routing***](toc.html#chapter6.4)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[***消息路由***](toc.html#chapter6.4)'
- en: The routing section identifies the appropriate destinations for each message.
    The routing criteria vary from one system to another, but most systems include
    the ability to route based on event importance and source programs (such as mail,
    cron, kernel, and authentication). Some systems include filters that recognize
    and route based on the text in the log message.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 路由部分确定每个消息的适当目标。路由标准因系统而异，但大多数系统包括基于事件重要性和源程序（如邮件、cron、内核和身份验证）进行路由的能力。一些系统包括识别并基于日志消息中的文本进行路由的过滤器。
- en: In this chapter, we define a *filter* as a set of routing rules and the destination
    associated with each rule. The routing rules and their associated destinations
    are stored in a configuration file (or, in the case of Laddie, in an RTA table).
    Filters only make sense if the system supports (and you use) multiple message
    destinations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将*过滤器*定义为一系列路由规则及其各自关联的目标。路由规则及其关联的目标存储在配置文件中（或者在Laddie的情况下，存储在RTA表中）。如果系统支持（并且你使用）多个消息目标，则过滤器才有意义。
- en: '[***Message Destinations***](toc.html#chapter6.5)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[***消息目标***](toc.html#chapter6.5)'
- en: A logging system finishes processing a message by sending it to a destination.
    Common destinations are discussed below. While the following list of message destinations
    may seem quite long, there are in fact many possible destinations not described.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个日志系统通过将消息发送到目标来结束对消息的处理。以下将讨论一些常见的目标。虽然以下消息目标列表可能看起来相当长，但实际上还有许多未描述的可能目标。
- en: '**Files**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件**'
- en: 'Files are the most common destination for log messages. Log files are the accepted
    norm, perhaps because they are so easy to access for periodic post-processing
    analysis. Unfortunately, files pose a problem for many embedded systems that do
    not have hard disks: RAM is volatile, and flash memory is too expensive to use
    for archiving log messages. Your choices for a diskless appliance are to filter
    messages heavily and only save a few to flash, to send them to a server on the
    network, or to just not save log messages.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 文件是日志消息最常用的目标。日志文件是接受的规范，可能是因为它们非常容易访问，可以进行定期的后处理分析。不幸的是，文件对许多没有硬盘的嵌入式系统来说是一个问题：RAM是易失的，而闪存对于存档日志消息来说太昂贵了。对于无盘设备的选择是：大量过滤消息，只保存少量到闪存，将它们发送到网络上的服务器，或者根本不保存日志消息。
- en: If you save log messages to a file, you can use logrotate to periodically remove
    the oldest file, rotate the newest file into a numbered archive, and send a SIGHUP
    signal to the process that is the source of the messages. A SIGHUP should cause
    the application to open a new log file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将日志消息保存到文件中，可以使用logrotate定期删除最旧的文件，将最新的文件旋转到编号的存档中，并向消息来源的进程发送SIGHUP信号。SIGHUP应该导致应用程序打开一个新的日志文件。
- en: '**Named pipes**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名管道**'
- en: Named pipes are an easy way to pass your filtered log messages to another program.
    A helper application opens the named pipe for reading and then blocks while waiting
    for log messages to arrive. When the logging system has a message to send, it
    writes the message to the named pipe, unblocking the helper application. Make
    sure your helper application can handle “broken pipe” errors, since they can occur
    if the logging system is restarted.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 命名管道是传递过滤后的日志消息到另一个程序的简单方法。辅助应用程序打开命名管道进行读取，然后等待日志消息到达时阻塞。当日志系统有消息要发送时，它会将消息写入命名管道，解除辅助应用程序的阻塞。确保您的辅助应用程序可以处理“损坏的管道”错误，因为如果日志系统重新启动，它们可能会发生。
- en: Named pipes and helper applications are very useful for destinations that are
    too big or too complex for inclusion in the logging daemon itself. A named pipe
    is a great way to tie the logging system to a custom application that is specific
    to your appliance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 命名管道和辅助应用程序对于太大或太复杂而无法包含在日志守护进程本身中的目标非常有用。命名管道是将日志系统绑定到特定于您的设备的自定义应用程序的绝佳方式。
- en: One alternative to a named pipe is a *fanout* device, a kernel module and associated
    /dev entries that act as a one-to-many multiplexer. Unlike named pipes, fanout
    devices let many readers get the same message (hence the name *fanout*). This
    book’s website hosts the fanout project, including source files and more detailed
    documentation. Please visit [http://www.linuxappliancedesign.com](http://www.linuxappliancedesign.com/)
    for more information.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 命名管道的一个替代方案是*扇出*设备，这是一个内核模块和相关/dev条目，充当一对一的多路复用器。与命名管道不同，扇出设备允许许多读者获取相同的信息（因此得名*扇出*）。本书的网站托管了扇出项目，包括源文件和更详细的文档。请访问[http://www.linuxappliancedesign.com](http://www.linuxappliancedesign.com/)获取更多信息。
- en: '**Remote UDP/syslog host**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程UDP/syslog主机**'
- en: If your appliance is a network appliance designed for a large data center, be
    sure to include the ability to forward log messages to another host in the network.
    The syslogd logging daemon can receive and/or forward log messages to other hosts
    using UDP.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的设备是设计用于大型数据中心网络的网络设备，请确保包括将日志消息转发到网络中另一个主机的功能。syslogd日志守护进程可以使用UDP接收和/或转发日志消息到其他主机。
- en: '**TCP multiplexer**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCP多路复用器**'
- en: If you want to route some reports to other programs, you can define a listening
    TCP socket that accepts connections. When a message arrives at the multiplexer,
    it is replicated and sent down each open TCP connection on the socket.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将一些报告路由到其他程序，可以定义一个监听TCP套接字以接受连接。当消息到达多路复用器时，它会复制并发送到套接字上每个打开的TCP连接。
- en: For example, in our Laddie appliance we have a command line interface (CLI)
    that can show Laddie alarm messages.¹ When a CLI user gives the command set logs
    on, the CLI opens a TCP connection to logmuxd, Laddie’s logging daemon, and log
    messages are sent down each accepted TCP connection to the CLI at the other end.
    (logmuxd is described in the next chapter.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的Laddie设备中，我们有一个命令行界面（CLI），可以显示Laddie警报消息。¹ 当CLI用户输入开启日志的命令时，CLI打开到logmuxd（Laddie的日志守护进程）的TCP连接，并将日志消息发送到另一端的CLI接受的每个TCP连接。（logmuxd将在下一章中描述。）
- en: '**Email**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**电子邮件**'
- en: It is nice to have significant events reported to you via email, since email
    is ubiquitous, if not timely. Also, email is often used as a gateway to pagers
    and cell phones (so that really important disasters can find you no matter where
    you hide).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 很高兴通过电子邮件收到重要事件的报告，因为电子邮件无处不在，即使不是及时的。此外，电子邮件通常被用作传呼机和手机的入口（这样真正重要的灾难无论你藏在哪里都能找到你）。
- en: '**Console**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制台**'
- en: Output to /dev/console or to a serial port is a must for debugging. Some large
    network centers still prefer to collect log messages over a physically secure
    and non-shared channel like an RS-232 cable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出发送到/dev/console或串行端口是调试的必要条件。一些大型网络中心仍然更喜欢通过物理安全且非共享的通道（如RS-232电缆）收集日志消息。
- en: '**Database**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库**'
- en: Some messages require an immediate response, but most of the time you are interested
    more in trends or changes in the pattern of a system’s events. A relational database
    is an ideal repository for log messages, since it has a wide range of tools to
    sort and count log messages. Since databases can use a lot of CPU cycles while
    they are sorting and counting, you might want to put the DB somewhere else on
    the network instead of on your appliance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有些消息需要立即响应，但大多数时候你更感兴趣的是系统事件模式的趋势或变化。关系数据库是日志消息的理想存储库，因为它具有广泛排序和计数日志消息的工具。由于数据库在排序和计数时可能会消耗大量CPU周期，你可能希望将数据库放在网络上的其他位置，而不是在你的设备上。
- en: '**SNMP traps**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**SNMP陷阱**'
- en: Most large networks have one or more dedicated network-management workstations
    that run an SNMP manager. The operators of these networks often insist that all
    network equipment use SNMP for status, configuration, and error reporting.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数大型网络都有一台或多台专用网络管理工作站，运行SNMP管理器。这些网络的运营商通常坚持要求所有网络设备使用SNMP进行状态、配置和错误报告。
- en: '**system()**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**system()**'
- en: A system() call to run a utility is another common destination. While simple
    and flexible, this approach uses more memory and CPU cycles than the other destinations
    and is not appropriate for processing large numbers of log messages.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 调用system()运行实用程序是另一个常见的目的地。虽然简单灵活，但这种方法比其他目的地使用更多的内存和CPU周期，不适合处理大量日志消息。
- en: The use of system() is almost always considered a security risk. We mention
    system() for completeness, but discourage its use. If you must run an external
    command, try to use popen() in place of system(). We solve this problem on Laddie
    by using the RTA-to-file utility described in Appendix D.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用system()几乎总是被认为是一个安全风险。我们提到system()是为了完整性，但劝阻其使用。如果你必须运行外部命令，尽量使用popen()代替system()。我们在Laddie上通过使用附录D中描述的RTA-to-file实用程序来解决这个问题。
- en: We do not have space here to describe all of the many possible destinations.
    For example, we did not discuss pagers, voice mail, or instant messaging.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有足够的空间来描述所有可能的目的地。例如，我们没有讨论传呼机、语音邮件或即时消息。
- en: '[**syslog**](toc.html#chapter6.6)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[**syslog**](toc.html#chapter6.6)'
- en: A logging system needs a standard way to report events, a *lingua franca* for
    log messages. That standard, for most of us, is syslog. There are several advantages
    to syslog. It is the primary event-reporting mechanism used by all legacy Linux
    applications, and it is well known and understood. In conjunction with the kernel
    logging daemon, klogd, syslog captures kernel and other system log messages that
    you may want to make visible to the appliance user.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 日志系统需要一个标准的方式来报告事件，日志消息的通用语言。对我们大多数人来说，这个标准就是syslog。syslog有几个优点。它是所有遗留Linux应用程序使用的首选事件报告机制，并且它广为人知且易于理解。与内核日志守护进程klogd结合使用，syslog可以捕获您可能希望对设备用户可见的内核和其他系统日志消息。
- en: This section describes how syslog works, how to use it in your applications,
    and how to configure its message filters. We give enough detail that you should
    have no trouble using syslog as the basis for your logging system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了syslog的工作原理，如何在应用程序中使用它，以及如何配置其消息过滤器。我们提供了足够详细的说明，你应该不会在使用syslog作为日志系统基础时遇到任何麻烦。
- en: '[***syslog Architecture***](toc.html#chapter6.7)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[***syslog架构***](toc.html#chapter6.7)'
- en: Messages from syslog are generated in your program by a call to the glibc C-library
    routine syslog(). Then, glibc formats the message and tries to write it to /dev/log,
    a Unix socket that is opened when syslogd starts. syslogd reads the message from
    /dev/log and handles it according to filters defined in /etc/syslog.conf, the
    syslogd configuration file. Figure 6-2 shows the overall architecture and message
    flow of syslog.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 系统日志消息是通过调用glibc C库例程syslog()在您的程序中生成的。然后，glibc格式化消息并尝试将其写入 /dev/log，这是一个在syslogd启动时打开的Unix套接字。syslogd从
    /dev/log 读取消息并根据 /etc/syslog.conf中定义的过滤器进行处理。图6-2显示了syslog的整体架构和消息流。
- en: '![](../images/106-1.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/106-1.jpg)'
- en: '*Figure 6-2: Message flow with syslog*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：使用syslog的消息流*'
- en: '[***Using syslog***](toc.html#chapter6.8)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[***使用syslog***](toc.html#chapter6.8)'
- en: Almost all Linux programming languages have a routine to send a syslog message.
    The C-library prototype shown below is fairly typical of most languages.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的Linux编程语言都有一个发送syslog消息的例程。下面显示的C库原型是大多数语言的典型代表。
- en: void syslog(int priority, const char *format, ...);
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: void syslog(int priority, const char *format, ...);
- en: '*Priority* is combination of the log level, the importance or severity of the
    event, and the *facility,* the type of program that generated the message.² Most
    programmers specify only the log level when using the syslog routine. There are
    eight log levels, ranging in importance from emergency to debug. This excerpt
    from syslog.h shows the eight levels available.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*优先级*是日志级别、事件的紧急程度或严重性以及*设施*的组合，即生成消息的程序类型。² 大多数程序员在使用syslog例程时只指定日志级别。有八个日志级别，从紧急到调试的重要性依次递减。以下是从syslog.h中摘录的八个可用级别。'
- en: '![](../images/107-1.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/107-1.jpg)'
- en: The syslog() routine uses a printf style format string that can have a variable
    number of arguments. The text in the format string should form a clear, unambiguous
    description of the event, and any arguments to the format string should give further
    details of the event.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: syslog()例程使用printf样式格式字符串，可以具有可变数量的参数。格式字符串中的文本应形成一个清晰、无歧义的事件描述，并且任何传递给格式字符串的参数应提供事件的更多详细信息。
- en: When we build appliances, a big part of what we deliver is documentation, and
    a big part of our documentation is a list of all the appliance log messages and
    their meanings. This list is easy to generate using grep on the source code. A
    list of log messages will be exceptionally valuable to your customers, and generating
    it requires only a little discipline on your part.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建设备时，我们交付的部分内容是文档，我们文档的一部分是所有设备日志消息及其含义的列表。使用grep在源代码中生成此列表非常容易。日志消息列表对您的客户来说将非常有价值，并且生成它只需要您的一点点自律。
- en: '**NOTE**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Generate a list of all log messages in your appliance as part of your appliance’s
    documentation.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*将您的设备中所有日志消息作为设备文档的一部分生成列表。*'
- en: 'You have more control over what is sent to syslogd than just the priority and
    text of the message. In particular, you can also use the optional openlog() routine
    to control the syslog facility, the message prefix, and whether or not to include
    the process ID with the log message. The openlog() calling syntax is:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您对发送到syslogd的内容的控制不仅限于消息的优先级和文本。特别是，您还可以使用可选的openlog()例程来控制syslog设施、消息前缀以及是否在日志消息中包含进程ID。openlog()调用语法是：
- en: void openlog(const char *ident, int option, int facility);
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: void openlog(const char *ident, int option, int facility);
- en: 'The ident is a short string that syslog prepends to each log message. If you
    do not specify one, ident defaults to the name of the program that called syslog().
    The option parameter lets you control things such as what to do if /dev/log is
    not available and whether or not to include the PID of the calling program. The
    option is the bitwise OR of zero or more of the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ident是一个短字符串，syslog将其添加到每个日志消息的开头。如果您没有指定，ident默认为调用syslog()的程序名称。option参数允许您控制诸如如果
    /dev/log 不可用时该做什么以及是否包含调用程序的PID等问题。选项是以下一个或多个选项的按位或：
- en: LOG_CONS—write log to console on failure to write to /dev/log
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LOG_CONS—在无法写入 /dev/log 时将日志写入控制台
- en: LOG_NDELAY—open socket to /dev/log immediately
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LOG_NDELAY—立即打开到 /dev/log 的套接字
- en: LOG_ODELAY—wait until first message to open socket to /dev/log
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LOG_ODELAY—在将消息写入 /dev/log 之前等待第一个消息打开套接字
- en: LOG_PERROR—write log to standard error as well as /dev/log
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LOG_PERROR—将日志写入标准错误以及 /dev/log
- en: LOG_PID—include PID with each message
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LOG_PID—在每个消息中包含PID
- en: The facility is meant to correspond to the type of program sending the log message.
    It defaults to LOG_USER if openlog() is not called. There are 24 standard facilities
    defined in syslog.h; the following excerpt shows the definitions for the most
    common ones. Note that the values are shifted up by three bits to keep the lower
    three bits reserved for the log level.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 设施旨在对应于发送日志消息的程序类型。如果没有调用openlog()，则默认为LOG_USER。syslog.h中定义了24个标准设施；以下摘录显示了最常见的定义。请注意，值向上移动了三位，以保留低三位位用于日志级别。
- en: '![](../images/108-1.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/108-1.jpg)'
- en: While the priority and facility are used by syslogd for routing, their values
    are not part of the saved text; however, you can infer the priority and facility
    of saved log messages by setting up syslogd to save messages with different priority
    and facility values to different files.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然优先级和设施被syslogd用于路由，但它们的值不是保存文本的一部分；然而，您可以通过设置syslogd将不同优先级和设施值的消息保存到不同的文件中来推断保存的日志消息的优先级和设施。
- en: '[***The syslog Protocol***](toc.html#chapter6.9)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[***syslog协议***](toc.html#chapter6.9)'
- en: Before going into a description of how to set up syslogd, let’s examine the
    protocol used to send syslog messages. As mentioned earlier, syslogd opens a Unix
    datagram socket on /dev/log and blocks while waiting for messages to arrive on
    the socket. The information passed from the application to the syslogd daemon
    includes a facility, a log level, and the message itself. The daemon uses the
    facility and level as its sole filtering criteria.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍如何设置syslogd之前，让我们先考察用于发送syslog消息的协议。如前所述，syslogd在/dev/log上打开一个Unix数据报套接字，并在等待套接字上到达消息时阻塞。从应用程序传递给syslogd守护进程的信息包括一个设施、一个日志级别以及消息本身。守护进程使用设施和级别作为其唯一的过滤标准。
- en: The original authors of syslog combined the priority and facility into a 32-bit
    integer, with the priority using the low three bits for the log level. The combined
    facility/level is ASCII encoded and placed between angle brackets before being
    written to /dev/log.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: syslog的原作者将优先级和设施组合成一个32位整数，其中优先级使用低三位位作为日志级别。组合的设施/级别是ASCII编码的，并在写入/dev/log之前放在尖括号之间。
- en: For example, say your program sets the facility to LOG_USER and sends an INFO
    log message with the following code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您的程序将设施设置为LOG_USER，并使用以下代码发送INFO日志消息。
- en: '![](../images/109-1.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/109-1.jpg)'
- en: 'If we looked at the message just after syslogd reads it from its Unix socket,
    we would see:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在syslogd从其Unix套接字读取消息后立即查看该消息，我们会看到：
- en: '<14>Aug 2 13:18:31 my_prog: abc=2'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '<14>Aug 2 13:18:31 my_prog: abc=2'
- en: Notice how LOG_USER (8) and LOG_INFO (6) are combined into <14>. A newline or
    other termination character is not needed, since syslog() adds a null character
    before writing the message to the /dev/log socket. If you don’t include a newline,
    syslogd will append one before writing the message to the log file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意LOG_USER（8）和LOG_INFO（6）是如何组合成<14>的。不需要换行符或其他终止字符，因为syslog()在将消息写入/dev/log套接字之前会添加一个空字符。如果您不包括换行符，syslogd将在将消息写入日志文件之前添加一个。
- en: '[***Using the syslogd Daemon***](toc.html#chapter6.10)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[***使用syslogd守护进程***](toc.html#chapter6.10)'
- en: The syslog daemon reads the messages from the /dev/log Unix socket and routes
    the messages based on their facility and log level. The destinations for a syslog
    message are called *actions* and include files, named pipes, the system console
    (or other TTY port), other syslogd systems on the network, and users.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: syslog守护进程从/dev/log Unix套接字读取消息，并根据它们的设施和日志级别路由消息。syslog消息的目的地被称为*动作*，包括文件、命名管道、系统控制台（或其他TTY端口）、网络上的其他syslogd系统以及用户。
- en: 'The filters and actions for syslogd are defined in /etc/syslog.conf. The configuration
    file usually has one line per destination, with a list of as many facilities and
    levels as needed for that destination. The facilities in the action are separated
    by commas, followed by a dot and then a log level. An asterisk can be used to
    represent all facilities or levels, and specifying a log level implies including
    that level and all the levels more severe than it. For example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: syslogd的过滤器和动作定义在/etc/syslog.conf中。配置文件通常每行一个目的地，包含所需目的地的设施和级别的列表。动作中的设施由逗号分隔，然后是一个点和一个日志级别。可以使用星号来表示所有设施或级别，指定一个日志级别意味着包括该级别及其所有更严重的级别。例如：
- en: '![](../images/109-2.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/109-2.jpg)'
- en: 'The most common destinations for syslog messages include files, pipes, and
    other log daemons on the network. Pipes are specified by giving a pipe symbol,
    |, at the start of the destination. A network destination starts with an at symbol,
    @. The man page for syslog.conf gives a more complete description on how to specify
    which facility and priorities are routed to which actions. The lines of syslog.conf
    that route all mail logs to /var/log/mail and all critical or higher print spooler
    and FTP logs to a network log server are:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: syslog 消息最常见的目的地包括文件、管道和网络上的其他日志守护进程。管道通过在目的地开始处给出管道符号 | 来指定。网络目的地以 at 符号 @
    开头。syslog.conf 的手册页提供了关于如何指定哪些设施和优先级被路由到哪些动作的更完整描述。将所有邮件日志路由到 /var/log/mail 以及将所有关键或更高优先级的打印假脱机程序和
    FTP 日志路由到网络日志服务器的 syslog.conf 行如下：
- en: '![](../images/109-3.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/109-3.jpg)'
- en: 'Recall that the facility is part of the priority integer passed from syslog()
    to syslogd, and that you can define your own facilities. This lets you build a
    private logging system on top of syslog. You could add the new facility integer
    and name to syslog.h, then rebuild glibc and syslogd. However, it is probably
    easier to use an explicit integer for the new facility. There are 24 predefined
    facilities, so choose a number much larger, say 1,000\. The code that sends an
    INFO log with this facility might look like the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，设施是作为从 syslog() 传递到 syslogd 的优先级整数的一部分，并且你可以定义自己的设施。这让你可以在 syslog 之上构建一个私有日志系统。你可以在
    syslog.h 中添加新的设施整数和名称，然后重新构建 glibc 和 syslogd。然而，使用新的设施显式整数可能更容易。有 24 个预定义的设施，所以选择一个很大的数字，比如
    1,000。使用这个设施发送 INFO 日志的代码可能看起来像以下这样：
- en: syslog((1000<<3) | LOG_INFO, "an event occurred");
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: syslog((1000<<3) | LOG_INFO, "an event occurred");
- en: We’ve shown the shift and OR explicitly to illustrate what is happening. We
    suggest that you use the equivalent LOG_MAKEPRI*(facility, level)* macro.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经明确展示了位移和 OR 操作，以说明正在发生的情况。我们建议你使用等效的 LOG_MAKEPRI*(设施, 级别)* 宏。
- en: To continue with this example, say you have a program listening for your new
    log messages on the named pipe /usr/local/private_pipe. You could configure syslogd
    to deliver all logs with the new facility by adding the following line to syslog.conf
    and restarting syslogd.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 继续以这个例子为例，假设你有一个程序正在监听名为 /usr/local/private_pipe 的命名管道上的新日志消息。你可以通过在 syslog.conf
    中添加以下行并重新启动 syslogd 来配置 syslogd 以通过新设施发送所有日志。
- en: '![](../images/110-1.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/110-1.jpg)'
- en: Desktop developers might cringe at the thought of using syslog for event processing.
    But then again, Linux desktop systems typically have more RAM and CPU resources
    than an appliance, so they can afford the (relatively) high disk, memory, and
    CPU overhead of D-Bus. We recommend syslog for its simplicity, availability in
    almost all programming languages, and its small memory and CPU overhead.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面开发者可能对使用 syslog 进行事件处理的想法感到不适。但另一方面，Linux 桌面系统通常比设备有更多的 RAM 和 CPU 资源，因此它们可以承担
    D-Bus 的（相对）高磁盘、内存和 CPU 负担。我们推荐使用 syslog，因为它简单、几乎所有编程语言都可用，并且内存和 CPU 负担小。
- en: '[***Limitations, Advantages, and Alternatives to syslogd***](toc.html#chapter6.11)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[***syslogd 的限制、优点和替代方案***](toc.html#chapter6.11)'
- en: There are a few limitations with the default syslogd daemon. As mentioned previously,
    it does not save the message level or facility (although you can get them indirectly
    by routing based on them). Syslogd can not route based on regular expressions,
    it only accepts messages from Unix sockets, and it has a somewhat limited set
    of actions. Some programmers find the limited numbers of levels a problem when
    setting up debug and trace mechanisms. On the plus side, syslogd is universally
    accepted and is thoroughly debugged, tested, and secure.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 syslogd 守护进程有一些限制。如前所述，它不保存消息级别或设施（尽管你可以通过基于它们的路由间接地获取它们）。Syslogd 不能基于正则表达式进行路由，它只接受来自
    Unix 套接字的消息，并且它有一组相对有限的动作。一些程序员在设置调试和跟踪机制时发现级别的数量有限是一个问题。优点方面，syslogd 被普遍接受，并且经过彻底的调试、测试和安全验证。
- en: The logger utility (which we saw briefly in the beginning of this chapter) lets
    you work around the limited set of message sources for syslogd. Logger sends log
    messages to syslogd, getting the log messages from either its command line or
    from each line of its standard input. If you wish, you can specify level, facility,
    and a prefix string. See the logger man page for more details. You can also combine
    netcat (a simple utility to read and write from network connections) and a logger
    to accept log messages from a single accepted TCP connection using a command similar
    to the one shown below.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录器实用程序（我们在本章开头简要介绍过）允许您绕过 syslogd 的有限消息源。日志记录器将日志消息发送到 syslogd，从其命令行或其标准输入的每一行获取日志消息。如果您愿意，可以指定级别、设施和前缀字符串。有关更多详细信息，请参阅
    logger 的 man 页面。您还可以将 netcat（一个用于从网络连接中读取和写入的简单实用程序）与日志记录器结合使用，以使用类似于以下命令的命令接受单个已接受的
    TCP 连接的日志消息。
- en: nc -l -p 2250 | logger
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: nc -l -p 2250 | logger
- en: The logger utility lets you “watch” other log files. For example, say you want
    to have each line that is added to /usr/www/error.log to also be sent to syslog.
    The following command line does this.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录器实用程序允许您“监视”其他日志文件。例如，假设您希望将添加到 /usr/www/error.log 的每一行也发送到 syslog。以下命令行可以完成此操作。
- en: tail -f /usr/www/error.log | logger
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: tail -f /usr/www/error.log | logger
- en: One other logging helper program worth mentioning is klogd. Since the Linux
    kernel does not use glibc, it cannot use syslog() to send kernel log messages.
    Instead, kernel log messages are made available either with the system call sys_syslog()
    or from the circular buffer visible in /proc/kmsg. The daemon klogd translates
    kernel log messages from either source into syslog messages. In addition, klogd
    translates the hex addresses in the kernel log messages into their equivalent
    symbolic names. To get the symbol from a hex address, klogd reads the memory map
    in the System.map file. If you load or unload kernel modules after starting klogd,
    be sure to tell klogd to reload its symbol table using the command klogd -i.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提及的日志辅助程序是 klogd。由于 Linux 内核不使用 glibc，因此它不能使用 syslog() 发送内核日志消息。相反，内核日志消息可以通过系统调用
    sys_syslog() 或从 /proc/kmsg 中可见的循环缓冲区获得。守护进程 klogd 将来自任一来源的内核日志消息转换为 syslog 消息。此外，klogd
    将内核日志消息中的十六进制地址转换为它们的等效符号名称。要从十六进制地址获取符号，klogd 读取 System.map 文件中的内存映射。如果您在启动 klogd
    之后加载或卸载内核模块，请确保使用命令 klogd -i 告诉 klogd 重新加载其符号表。
- en: Popular alternatives to syslogd include nsyslog, which supports TCP using SSL;
    minirsyslogd, which is a minimalist logger that can handle a very high volume
    of traffic; and syslog-ng, which can filter on regular expressions, does message
    rewriting, and supports TCP sources and destinations. The evlog package is one
    of the best in terms of recognizing and responding to log messages. The latest
    information on these alternatives can be found with a web search on the package
    name.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: syslogd 的流行替代方案包括 nsyslog，它支持使用 SSL 的 TCP；minirsyslogd，这是一个可以处理极高流量量的最小化日志记录器；以及
    syslog-ng，它可以基于正则表达式进行过滤，支持消息重写，并支持 TCP 源和目标。evlog 软件包在识别和响应日志消息方面表现最佳。有关这些替代方案的最新信息，可以通过在网络上搜索软件包名称来找到。
- en: '[**On-Demand Logging**](toc.html#chapter6.12)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[**按需日志记录**](toc.html#chapter6.12)'
- en: Wouldn’t it be nice if you could dynamically control how verbose the logging
    is in your program? Sure, you can use a -v switch on the command line when starting
    the program, but that’s not exactly dynamic. Also, it would be nice if you could
    independently control the log level in different parts of your program. That way,
    you could zoom in to study a particular piece of code. This section describes
    how you use an RTA table called Logit and code from the Laddie appliance to independently
    control the log thresholds in different parts of your code, while your program
    is running. Figure 6-3 illustrates the idea of giving different parts of a program
    different thresholds for logging.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能动态控制程序中日志记录的详细程度，那岂不是很好？当然，您可以在启动程序时使用命令行上的 -v 开关，但这并不完全动态。此外，如果您能独立控制程序不同部分的日志级别，那也会很方便。这样，您就可以聚焦于研究特定的代码片段。本节描述了如何使用名为
    Logit 的 RTA 表和 Laddie 设备的代码来独立控制程序不同部分的日志阈值，同时程序正在运行。图 6-3 阐述了为程序的不同部分提供不同日志阈值的理念。
- en: 'Here is the definition for a row in the Logit table:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Logit 表中行的定义：
- en: '![](../images/111-1.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/111-1.jpg)'
- en: '![](../images/112-1.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/112-1.jpg)'
- en: '*Figure 6-3: Independent control of logging in each program section*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：每个程序部分的独立日志控制*'
- en: The idea is to have a separate logging threshold for each section of code, and
    to send a log message only if the message’s level is numerically below the log
    threshold for that section. Our implementation of Logit has 12 rows, the first
    five of which are used internally by the Laddie prototype daemon. You can easily
    change LOGIT_NROWS in logit.c to add more rows if you wish.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是为代码的每个部分设置一个单独的日志阈值，并且只有当消息的级别在数值上低于该部分的日志阈值时才发送日志消息。我们Logit的实现有12行，前五行被Laddie原型守护进程内部使用。如果您愿意，可以轻松地更改logit.c中的LOGIT_NROWS以添加更多行。
- en: Let’s work through an example. Say you want to add on-demand logging control
    to two different sections of code, image processing (IM) and buffer management
    (BM). During its initialization your program must create its entries in the Logit
    table. You can do this directly, or you can use the wrapper function logitSetEntry().
    The code below shows both methods.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来操作。假设您想在代码的两个不同部分中添加按需日志控制，即图像处理（IM）和缓冲区管理（BM）。在初始化过程中，您的程序必须在Logit表中创建其条目。您可以直接这样做，或者可以使用包装函数logitSetEntry()。下面的代码展示了这两种方法。
- en: '![](../images/112-2.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/112-2.jpg)'
- en: With the above initialization in place, you can now add log messages that you
    can control by raising or lowering the threshold in the Logit table.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在以上初始化设置到位后，您现在可以添加可以通过在Logit表中提高或降低阈值来控制的日志消息。
- en: The LOG() macro defined in the Laddie empty daemon header file, empd.h, will
    send a message to syslog() or send a standard error if the threshold set in the
    LOG call is numerically lower than the threshold in Logit for that section of
    code. For example, to selectively trace the operation of the image-processing
    and buffer-management code, you might have a few lines like the following.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Laddie空守护进程头文件empd.h中定义的LOG()宏，如果LOG调用中设置的阈值在数值上低于Logit中该代码部分的阈值，则会将消息发送到syslog()或发送标准错误。例如，为了选择性地跟踪图像处理和缓冲区管理代码的操作，您可能有一些如下所示的几行代码。
- en: LOG(LOG_DEBUG, IM, "Deep into image processing");
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: LOG(LOG_DEBUG, IM, "深入图像处理");
- en: LOG(DBG_2, BM, "Freeing buffer ID=%d", buf_id);
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: LOG(DBG_2, BM, "释放缓冲区ID=%d", buf_id);
- en: The file empd.h defines five additional log levels (DBG_0 to DBG_4) below LOG_DEBUG
    to give you more precise control over the verbosity of debug messages.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 文件empd.h定义了五个额外的日志级别（DBG_0到DBG_4），位于LOG_DEBUG之下，以便您能够更精确地控制调试消息的详细程度。
- en: 'With all of the above in place, you can enable and disable log messages in
    individual sections of your program. For example, the SQL commands to disable
    all logging except for the IM section might be:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在以上所有设置到位后，您可以在程序的各个独立部分中启用和禁用日志消息。例如，禁用除IM部分之外所有日志记录的SQL命令可能如下所示：
- en: UPDATE Logit SET thres = 0
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE Logit SET thres = 0
- en: UPDATE Logit SET thres = 10 WHERE sect = "IM"
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE Logit SET thres = 10 WHERE sect = "IM"
- en: '[**Summary**](toc.html#chapter6.13)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[**总结**](toc.html#chapter6.13)'
- en: Logging is a valuable addition to almost all appliances, even those with limited
    disk, memory, and CPU power. An ideal logging system has many sources and destinations
    for log messages and allows for the addition of new sources and destinations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录几乎可以添加到所有设备中，即使这些设备磁盘、内存和CPU功率有限。一个理想的日志系统具有许多日志消息的来源和目的地，并允许添加新的来源和目的地。
- en: 'There are two components to syslog, the default logging system on Linux: a
    library routine to send log messages, and a daemon to process them. The syslog()
    library routine is available in every major programming language available on
    Linux. The syslog daemon, syslogd, routes messages based on the source of the
    message (the facility) and on the severity of the event reported (the log level).
    In this chapter, you learned how to add your own facility to syslog in order to
    route log messages specific to your appliance.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: syslog是Linux上的默认日志系统，有两个组件：一个发送日志消息的库例程和一个处理它们的守护进程。syslog()库例程在Linux上每个主要编程语言中都是可用的。syslog守护进程syslogd根据消息的来源（设施）和报告事件的严重性（日志级别）来路由消息。在本章中，您学习了如何向syslog添加自己的设施，以便路由特定于您的设备的日志消息。
- en: On-demand logging gives us the ability to dynamically control the verbosity
    of logging in different parts of our application. While RTA makes on-demand logging
    easier, it is not required for on-demand logging.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按需日志记录使我们能够动态控制应用程序不同部分的日志记录详细程度。虽然RTA使按需日志记录变得更容易，但它不是按需日志记录所必需的。
- en: This chapter reviewed logging and the collection and archiving of log messages.
    The next chapter describes a logging system that can recognize specific text in
    log messages and then rewrite and route the messages on a case-by-case basis.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本章回顾了日志记录以及日志消息的收集和归档。下一章将描述一个能够识别日志消息中特定文本的日志系统，并根据具体情况重写和路由消息。
- en: '![](../images/114-1.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/114-1.jpg)'
- en: __________________
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: __________________
- en: ¹ *Log messages* give a report of an event. An *alarm* is a system state of
    failure or reduced availability. Log messages are used to report the transitions
    in to and out of an alarm state, and the two terms are sometimes confused.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ *日志消息* 提供了事件报告。*警报* 是系统故障或可用性降低的系统状态。日志消息用于报告进入和退出警报状态的变化，这两个术语有时会被混淆。
- en: ² Unfortunately, the documentation for syslog and syslog.conf are not in full
    agreement. One defines *priority* as the bitwise OR of facility and log level,
    and the other defines *priority* as what we call log level. While this book is
    self-consistent, you should use care when reading other syslog documentation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ² 很遗憾，syslog 和 syslog.conf 的文档并不完全一致。一个将 *优先级* 定义为设施和日志级别的按位或运算，而另一个将 *优先级*
    定义为我们所说的日志级别。虽然本书内部一致，但在阅读其他 syslog 文档时请谨慎。
