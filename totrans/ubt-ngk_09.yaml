- en: Chapter 9. SIMPLE KITTEN WAYS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting to Know the Linux Terminal and Command Line . . . and the Cool Things
    It Can Do
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages656092.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Many people shy away from Linux because they envision it as a system for compu-geeks,
    an environment in which you do everything the hard way—by command line. In this
    era of graphical interfaces, the idea of typing commands to get things done seems
    like a dreadful throwback to the days of DOS, and that puts many people off, especially
    those who remember what it was like in the "old days."
  prefs: []
  type: TYPE_NORMAL
- en: This reaction is fair enough, but it is not really an accurate reflection of
    the reality of the Linux world. After all, most Linux users today utilize some
    sort of graphical interface. They can, and often do, achieve all that they hope
    to achieve through drop-down menus and mouse clicks alone. Many are able to survive
    quite happily without ever once opening their Terminal. The same could be true
    of you.
  prefs: []
  type: TYPE_NORMAL
- en: Be that as it may, there is still much to be said for the power and convenience
    of the command line. The fact that the command line can now be utilized within
    a graphical environment also makes it much less forbidding. The Terminal is just
    a tiny text-based island in a sea of graphical bodies (see [Figure 9-1](ch09.html#putting_the_terminal_in_perspective
    "Figure 9-1. Putting the Terminal in perspective")). Using the command line can
    be as pain-free as anything else you do on your system, and it can actually provide
    you with a little fun if you are willing to give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting the Terminal in perspective](httpatomoreillycomsourcenostarchimages656363.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1. Putting the Terminal in perspective
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, many guides to using the command line are written by hard-core
    command-line junkies, whose enthusiasm for what they see as a really good thing
    inadvertently makes what they write seem even more off-putting to the recent Linux
    immigrant or wanna-be.
  prefs: []
  type: TYPE_NORMAL
- en: For your sake, I will try to curb my own enthusiasm so as not to scare you right
    back to [Chapter 6](ch06.html "Chapter 6. ROUNDING OUT THE BIRD") and the more
    comfortable world of the Ubuntu Software Center. I will also try to help you keep
    things in perspective by teaching you, whenever possible, to use the command line
    as a complement to the various graphical tools that you have at your disposal,
    rather than presenting it as the sole way of going about things. Of course, I
    am not going to cover every possible angle in this regard—just enough to give
    you some exposure and experience and, ideally, make you feel at least a little
    more at ease with the command line. Who knows; could you actually come to think
    of using the command line as . . . fun? Well, I won't get too carried away.
  prefs: []
  type: TYPE_NORMAL
- en: Meet the Terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can run the Linux command-line Terminal application in your Ubuntu system
    by selecting **Applications** ▸ **Accessories** ▸ **Terminal**. When the Terminal
    opens, it will, in all its simplicity, look much like [Figure 9-2](ch09.html#the_terminal_application
    "Figure 9-2. The Terminal application").
  prefs: []
  type: TYPE_NORMAL
- en: '![The Terminal application](httpatomoreillycomsourcenostarchimages656365.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2. The Terminal application
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, all it says is `rg@rg-desktop:˜$`. In this case, `rg` is my
    username, `rg-desktop` is the name I gave my computer during installation, and
    the tilde (`˜`) signifies that I am in my home folder. If it were to say `˜/Music`,
    for example, it would mean that I am currently in the *Music* folder within my
    home folder. Of course, all this will be different in your case, because your
    username and computer name will be different. If your username is *frog* and your
    computer''s name is *wetrock*, for example, the command line will say `frog@wetrock:˜$`.
    If all this is sounding rather obtuse to you, just think of it this way: *`user-name`*`@`*`computer_name`*`:˜$`
    in the Terminal is the equivalent of your home folder in Nautilus.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typing in the Terminal is straightforward enough; you just type as you usually
    do. You can also delete and insert letters or phrases by using the **delete**
    and **backspace** keys and the arrow keys. For practice, try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Type **`I like strawberries so very much`**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change `strawberries` to `cherries` (because cherries are, in fact, so much
    better). Just use your left arrow key to move the cursor in front of the first
    *s* in `strawberries`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap your **delete** key as many times as necessary to erase the word `strawberries`
    (uh, that would be 12 times, methinks).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **`cherries`**, and then use your right arrow key to move the cursor back
    to the end of this meaningful sentence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that you''ve completed this fascinating bit of typing practice, press the
    **enter** key. As you will almost immediately see, the Terminal''s response to
    your efforts thus far is merely a dismissive `I: command not found`. Although
    you''ve typed a string of text that has meaning to you, it means absolutely nothing
    to your system. In fact, the system was so shortsighted that it could see nothing
    other than the first word you typed in the Terminal (`I`); and because `I` is
    not a valid command, the system had no idea what do to with it.'
  prefs: []
  type: TYPE_NORMAL
- en: Some Goofy Yet Useful Fun with the Command Terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A rather cool thing about typing in the command Terminal is that it has what
    you might call *short-term memory*. Try it by typing the word **`cherry`** and
    then pressing **enter**. Ignoring the command-not-found message, go on and type
    **`vanilla`**, and press **enter**. Now type **`gelato`**, and press **enter**.
    So far, so dumb, right? Well, not really. Let's type everything we've typed thus
    far again, but this time let's do it with only one key.
  prefs: []
  type: TYPE_NORMAL
- en: Huh?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, just press the up arrow key once, and what do you see? That's right—the
    last command you typed appears, which in this case would be `gelato`. Press the
    up arrow key again, and the command that you typed before that will appear—`vanilla`.
    One more time? Yes, `cherry`. And one more time for the grand finale . . . `I
    like cherries so very much`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering what we have thus far, this may all seem a bit silly, but imagine
    that you''re not typing goofy little words and instead have to deal with considerably
    longer strings, such as a simple copy command (which you''ll learn about later
    in this chapter) like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By typing that string, you are copying an image called *onthebeach1_27.jpg*
    from the *coastal* folder to another folder called *stpierre*. If you wanted to
    copy another photo in the *coastal* folder, *onthebeach1_16.jpg*, for instance,
    you could simply press the up arrow key once, use the left arrow key and **delete**
    key to move over to and delete the `27`, and replace it with **`16`**. All in
    all, it would be much simpler and much faster. It would also help you avoid mistakes
    in typing. Not so dumb anymore, eh?
  prefs: []
  type: TYPE_NORMAL
- en: Nontoxic Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you now know, all of this typing is easy enough, but to actually do something
    useful with your Terminal, you need to type commands—and there are more of them
    than you could ever hope or need to know. To get you started, we will begin with
    some commands that are easy to understand, nontoxic, and completely kitten-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: $ whoami
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no command as easy, safe, or even as seemingly useless as `whoami`.
    Rather than help those with multiple-personality disorders discover who they are
    at any given moment, the `whoami` command simply tells you which user is currently
    logged in. Try it by typing **`whoami`** after the `$` and then pressing the **enter**
    key. Remember that commands are case sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: The Terminal will now tell you the username of the person currently logged in.
    If you are logged in as *frog*, you should get `frog` as the answer to your command.
  prefs: []
  type: TYPE_NORMAL
- en: $ finger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you enjoyed discovering who you are with the `whoami` command, then you might
    enjoy finding out even more about yourself using the `finger` command. You can
    use the `finger` command in a number of ways, but a very simple one is finding
    out about a particular user. Try this on yourself by typing **`finger`** and then
    your username. In my case, that would be **`finger rg`**. Once you've typed the
    command, press **enter**, and see what you get. You can see my results in [Figure 9-3](ch09s03.html#output_from_the_finger_command
    "Figure 9-3. Output from the finger command").
  prefs: []
  type: TYPE_NORMAL
- en: '![Output from the finger command](httpatomoreillycomsourcenostarchimages656367.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-3. Output from the `finger` command
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, my login name is *rg*, my real name is Rickford Grant, my home
    directory is */home/rg*, and I am using the Bash shell for typing my commands.
    I have been logged on since Wednesday, April 14, at 19:59 Eastern daylight time
    (EDT), and I've had my Terminal session open since Thursday, April 15, at 19:26\.
    I have no mail or plan. It doesn't tell you my Social Security number or my mother's
    maiden name, but it is pretty cool, don't you think?
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Shell?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you noticed, I mentioned that the results of the `finger` command showed
    I was using the Bash shell, so you may be understandably wondering just what Bash
    is. Well, Bash (Bourne Again Shell) is one of the many shells that are used in
    Linux systems, and it's the one that happens to come with your Ubuntu distro (and
    most others, for that matter). A *shell* is a program that interprets the commands
    you type into the Terminal and delivers them, so to speak, to your system so that
    it can act upon them. I like to think of it as a command-handling subsystem, for
    which the Terminal acts as a graphical frontend.
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Plan?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I also mentioned that the results said I had no plan, so you may also be wondering
    what that is all about. A *.plan* file is a small file kept in your home folder
    that other users see when they use the `finger` command on you. Traditionally,
    a *.plan* file contained information about where you were going to be or what
    you were working on. These days, however, most people use them to leave odd little
    messages, quotations, or whatever, much as they do in email signatures. Take a
    look at [Figure 9-4](ch09s03.html#output_from_the_finger_command_with_a_pl "Figure 9-4. Output
    from the finger command with a plan") to see what happens after I add a *.plan*
    file to my home folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Output from the finger command with a plan](httpatomoreillycomsourcenostarchimages656369.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-4. Output from the `finger` command with a plan
  prefs: []
  type: TYPE_NORMAL
- en: You can now see my plan, which is a quotation from Kurt Vonnegut's *The Sirens
    of Titan* (or Al Stewart's song by the same name, for that matter), though you
    can put anything you want in your own. You will get the chance to create your
    own plan file in Project 9A, so if this all seems fun to you, just hang in there.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, I should mention that you can also use the `finger` command
    to do a little domestic espionage of sorts. Let's say your child, Chris, has a
    user account on your machine. Chris, who wants your permission to go to the movies,
    claims to have been hard at work on the computer all day writing a report for
    school. Having your doubts, you could type **`finger chris`** to see what the
    facts actually are. It may be a bit underhanded and rotten, but it works. It also
    works both ways; others can check up on you as well. You can try it by seeing
    when the last time you logged in to your graphika account was (assuming you created
    such an account in [Chapter 8](ch08.html "Chapter 8. DRESSING UP THE BIRD")).
    Just type **`finger graphika`**, and then press **enter**.
  prefs: []
  type: TYPE_NORMAL
- en: You can even use the `finger` command to find out facts about people on other
    systems, providing their network's finger service is active and you know their
    email address. Typing something like **`finger`** *`username@hostname.com`* would
    do the trick. It's kind of cool but also kind of spooky, I suppose.
  prefs: []
  type: TYPE_NORMAL
- en: $ pwd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you know who you are but aren't exactly sure where you are, `pwd` (print
    working directory) should come in handy. The `pwd` command tells you exactly where
    the Terminal is in your directory tree.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say, for example, that my Terminal is in my personal home directory (which
    is actually called *rg*) in the system's home directory (which is actually called
    *home* and which is where all the user account directories are located) when I
    use the `pwd` command; I would, after pressing the **enter** key, get `/home/rg`
    printed to my Terminal. You should get similar results if you try it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The word *print*, in this case, has nothing to do with your printer; it merely
    means that the response will be printed to, or displayed in, the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: $ df
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another safe and easy, but much more useful, command is `df` (disk filesystem).
    The `df` command tells you how much disk space you have used, as well as how much
    space you still have available, on each of the partitions on your various mounted
    disks. Try it by typing **`df`** and then pressing **enter**. Your output should
    look something like that shown in [Figure 9-5](ch09s03.html#output_from_the_df_command
    "Figure 9-5. Output from the df command") (depending, of course, on the size of
    your mounted disks and how they are set up).
  prefs: []
  type: TYPE_NORMAL
- en: '![Output from the df command](httpatomoreillycomsourcenostarchimages656371.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-5. Output from the `df` command
  prefs: []
  type: TYPE_NORMAL
- en: As you will notice, the sizes are given in kilobytes (KB) rather than the gigabytes
    (GB) and megabytes (MB) you are probably more used to, but there is a way around
    this. Many commands accept a *flag*, or *option*, to further fine-tune how the
    command performs. These flags are written directly after the main command and
    are preceded by a space and a hyphen.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you can try using the `-h` (human readable) flag to have your
    figures come out in the way you are most familiar with. Try this by typing **`df
    -h`** on the command line and pressing **enter**. The output should now appear
    in a more familiar format (see [Figure 9-6](ch09s03.html#output_from_the_df_command_with_the_-h_f
    "Figure 9-6. Output from the df command with the -h flag")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Output from the df command with the -h flag](httpatomoreillycomsourcenostarchimages656373.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-6. Output from the `df` command with the `-h` flag
  prefs: []
  type: TYPE_NORMAL
- en: $ ls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another harmless but handy command is `ls` (list directory contents). The `ls`
    command shows you what is in your current directory. This is the nongraphical
    equivalent of double-clicking a folder in Nautilus to see what is inside. Try
    it by typing **`ls`** and then pressing the **enter** key.
  prefs: []
  type: TYPE_NORMAL
- en: If you've been following *my* commands so far, your results should list all
    of the folders in your home directory. You can also use the `-R` flag to show
    not only the list of files in the folder but also what is within the subfolders.
    Of course, you should have no subfolders in any of the folders you created in
    [Chapter 7](ch07.html "Chapter 7. A TIDY NEST") and [Chapter 8](ch08.html "Chapter 8. DRESSING
    UP THE BIRD"), so you can hold off experimenting with this for a while. Instead,
    try typing **`ls -a`** to see your invisible, or *hidden*, files.
  prefs: []
  type: TYPE_NORMAL
- en: $ calendar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I'll let you experiment with this one on your own. Just type **`calendar`**,
    and press **enter** to see the somewhat interesting results.
  prefs: []
  type: TYPE_NORMAL
- en: $ exit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `exit` command is a simple one that allows you to exit the Terminal. Just
    type **`exit`**, and press **enter**. The Terminal window will close.
  prefs: []
  type: TYPE_NORMAL
- en: Commands with Some Teeth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simple commands you have tried so far are all of the safe-and-sane, fire
    marshal–approved variety; they merely print information to your Terminal. Now
    you are going to try to get some real tangible results from the commands you use.
    These commands are also essentially safe and sane if you follow my instructions.
  prefs: []
  type: TYPE_NORMAL
- en: $ mkdir
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have already learned how to create folders by means of menus and your mouse,
    but you can also do this using the command line. The command is `mkdir` (make
    directory), and it is easy as pie to use (though I've never been quite sure how
    pie is easy).
  prefs: []
  type: TYPE_NORMAL
- en: To see how this command works and to work with the commands that follow, use
    the `mkdir` command now to create a folder called *command_exp* (for command experiments).
    All you have to do is type **`mkdir command_exp`** in a new Terminal window and
    press **enter**. The new folder should appear in your home folder, so go ahead
    and check to see whether it is there by clicking the home icon on your desktop.
  prefs: []
  type: TYPE_NORMAL
- en: OK, good, *bra*, *bueno*! Now let's create another new folder within that new
    folder—a *subfolder*, if you will. We'll call this one *sub*. So, just type **`mkdir
    command_exp/sub`**, and press **enter**. You can now take a peek and see whether
    the *sub* folder appears within the *command_exp* folder, if you like.
  prefs: []
  type: TYPE_NORMAL
- en: $ mv
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next command is the `mv` (move) command, but before you experiment with
    it, you need to create a dummy file—you need something to move, after all. You
    can do this by using another command—`touch`. To make the file—let's call it *expfile.txt—*go
    to the Terminal, type **`touch expfile.txt`**, and press **enter**. The new file
    will now appear in your home folder.
  prefs: []
  type: TYPE_NORMAL
- en: To move the file that you've just created, you will use the `mv` command, of
    course. Just type **`mv expfile.txt command_exp/sub`** (this tells the system
    which file to move and where to move it to), and press **enter**. The file will
    now be in your *sub* folder.
  prefs: []
  type: TYPE_NORMAL
- en: $ cd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, you have been using the command line from your home folder. With
    the `cd` command, you can change your Terminal's location to another folder. This
    is a very handy command that you will be using quite a lot when doing the projects
    in this book. To take it out for a spin, let's get inside the *command_exp* folder
    by typing **`cd command_exp`** and pressing **enter**. If you've done this correctly,
    the prompt in your Terminal should now read *`username`*`@`*`computer_name`*`:˜/command_exp$`.
    If so, you can pat yourself on the back.
  prefs: []
  type: TYPE_NORMAL
- en: While you are there, you might as well try the `ls` command with the `R` (recursive)
    flag to see how that works. Just type **`ls -R`**, and press **enter**. Your Terminal
    should now show that you have a subfolder there called *sub* and a file inside
    that subfolder called *expfile.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: That is all you really want to do in there for now, so to get back to your home
    directory, just type **`cd`** and press **enter**, which will take you back home,
    so to speak.
  prefs: []
  type: TYPE_NORMAL
- en: For future reference, it is worth noting a couple of other `cd` command shortcuts.
    If you are within a subfolder of a subfolder and want to move back a step (from
    */home/rg/peas/pudding* to */home/rg/peas*, for example), you can do so by typing
    **`cd ..`** (with a space between `cd` and `..`) and pressing **enter**. You can
    also type **`cd -`** (with a space between `cd` and `-`) in order to get back
    to a directory where you were previously (from */home/rg* to */home/rg/peas/pudding*,
    for example).
  prefs: []
  type: TYPE_NORMAL
- en: $ cp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being fickle, as humans are by nature, you might decide that not only do you
    want your *expfile.txt* file in the subfolder but that you also want a copy in
    your home directory, where it was in the first place. To copy *expfile.txt*, you
    can use the `cp` (copy) command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, the command needs to know where the file you want to copy is, what
    it is called, and where you want to copy it, which in this case is to your home
    folder. Normally you would type `cp command_exp/sub/expfile.txt /home/`*`username`*
    to do this, but if you recall my mention of it near the beginning of this chapter,
    you can abbreviate the `/home/`*`username`* portion of the command string to `˜/`,
    which means the same thing and is an important tip to remember, because the tilde
    is frequently used in online instructions. Because reducing wear and tear on the
    fingers is always a desirable goal, type the following command, and then press
    **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to put a space between the file you are copying and its destination
    (in this case, between `expfile.txt` and `˜/`).
  prefs: []
  type: TYPE_NORMAL
- en: Once you've done this, you should have two copies of *expfile.txt*, one in your
    home folder and one in your *sub* folder. Go take a look to see the fruit of your
    endeavors.
  prefs: []
  type: TYPE_NORMAL
- en: $ rm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you were a kid, you may well have experienced the joy of building a castle
    out of LEGO bricks and then the even greater joy of tearing the whole thing down
    (preferably by hurling D cell batteries at it). You will now embark on a similar
    move. The first tool in this nostalgic endeavor is the `rm` (remove) command,
    with which you can trash files.
  prefs: []
  type: TYPE_NORMAL
- en: The `rm` command, albeit very useful and easy to use, should be used with caution.
    Once you remove a file with this command, there is no going back—the file will
    not be placed in the Trash; it is gone for good.
  prefs: []
  type: TYPE_NORMAL
- en: To play it safe, let's try the `rm` command by getting rid of that new copy
    of *expfile.txt* that we just created in the home folder. The basic `rm` command
    structure consists of the command itself, `rm`, followed by the name of the file
    you want to remove. In this case, you want to remove the file called *expfile.txt*
    located in your home folder. Assuming your Terminal shows you to be home, remove
    the file by typing **`rm expfile.txt`** followed by a tap on the ol' **enter**
    key. The file will then be gone, and gone for good.
  prefs: []
  type: TYPE_NORMAL
- en: Now, double your pleasure by getting rid of the version of *expfile.txt* that
    is located in the subfolder *sub*. In this case, you need to specify where the
    file is because it isn't in the folder that the Terminal is in. Just type **`rm
    command_exp/sub/expfile.txt`**, and then press **enter**. Oooh, very cool. Brings
    ya back, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: $ rmdir
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will now continue the fun with the `rmdir` (remove directory) command, which
    is a bigger and more powerful version of the `rm` command.
  prefs: []
  type: TYPE_NORMAL
- en: You should use the `rmdir` command, like the `rm` command, with caution. There
    are no do-overs with `rmdir`. Once you remove a directory or folder with this
    command, it is gone for good.
  prefs: []
  type: TYPE_NORMAL
- en: To try this command, you can get rid of that *sub* folder you created. Type
    **`rmdir command_exp/sub`**, and press **enter**. The *sub* folder should now
    be gone. Finally, to round out the fun, use the `rmdir` command once more to get
    rid of the *command_exp* folder you created earlier. You've probably got it down
    by now, but just in case you don't, type **`rmdir command_exp`**, and then press
    **enter**.
  prefs: []
  type: TYPE_NORMAL
- en: $ chmod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 7](ch07.html "Chapter 7. A TIDY NEST"), you learned how to change
    file permissions via the Nautilus interface. This is without a doubt the easiest
    way to go about such things, but you might find times when it is easier to use
    the command-line approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command for changing file permissions is `chmod` (change mode). To use
    it, just type the command followed by the permissions you want to extend to a
    file and then the location of the file itself. For example, let''s say you copied
    a JPEG file, *mybirthday.jpg*, from a CD to the *personal* subfolder within the
    *Photos* folder on your hard disk, and the file is write protected. To change
    the file so that you have write permissions (meaning that you can alter the file),
    you would type the following and then press **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the permissions of all the files and subfolders (and all the files
    within those subfolders) in one fell swoop, you can add the `-R` (recursive) flag
    to the `chmod` command. The command would thus be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The number `744`, by the way, extends read, write, and execute (run) permissions
    to you, the owner, but gives read-only rights to everyone else—a pretty safe choice
    when in doubt. If you want to figure out permission numbers for yourself, it is
    pretty easy. You are basically dealing with three number positions, each of which
    has eight numerical possibilities (`0`–`7`). The left slot represents permissions
    for the owner, the center slot represents permissions for the group, and the third
    slot represents permissions for others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The meanings of the numbers themselves are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `7` | Read, write, and execute permissions |'
  prefs: []
  type: TYPE_TB
- en: '| `6` | Read and write permissions |'
  prefs: []
  type: TYPE_TB
- en: '| `5` | Read and execute permissions |'
  prefs: []
  type: TYPE_TB
- en: '| `4` | Read-only permissions |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | Write and execute permissions |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | Write-only permissions |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | Execute-only permissions |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | No permissions |'
  prefs: []
  type: TYPE_TB
- en: '[Figure 9-7](ch09s04.html#the_meaning_of_permission_numbers "Figure 9-7. The
    meaning of permission numbers") points out the meaning of each of these numbers
    and what each number slot represents. In fact, if you don''t mind a bit of simple
    addition, things are even easier to understand. To start with, remember that 1
    = execute, 2 = write, and 4 = read. Add any of those numbers together, and you
    get the other permission combos. For example, 1 (execute) + 4 (read) = 5 (read
    and execute). As you can see, permissions aren''t all that complicated.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The meaning of permission numbers](httpatomoreillycomsourcenostarchimages656375.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-7. The meaning of permission numbers
  prefs: []
  type: TYPE_NORMAL
- en: Now if you're more of a letters than numbers sort of person, you'll be happy
    to know that there is another way to change permissions that is probably even
    easier. In this approach, you have to deal only with two groups of letters and
    the symbols `+` and `-`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first group consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `u` | User (owner of the file) |'
  prefs: []
  type: TYPE_TB
- en: '| `g` | Group (specified group of users) |'
  prefs: []
  type: TYPE_TB
- en: '| `o` | Others (anyone who is not the user or a member of the group) |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | All (all of the above) |'
  prefs: []
  type: TYPE_TB
- en: 'The second group consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `r` | Read |'
  prefs: []
  type: TYPE_TB
- en: '| `w` | Write |'
  prefs: []
  type: TYPE_TB
- en: '| `x` | Execute |'
  prefs: []
  type: TYPE_TB
- en: You might already be able to figure out how this is all going to work, but I'll
    spell it out just in case your intuition is worn out for the day. Let's say you
    want to change the permissions of a file (*butterhaters.txt*, for example) so
    that all users on your machine can read and write to it. After opening a Terminal
    window, you can make the change by typing **`chmod a+rw butterhaters.txt`** and
    pressing **enter**.
  prefs: []
  type: TYPE_NORMAL
- en: Oops! Just remembered that you don't want anyone changing the content of the
    file, eh? Well, to take back the write permissions for that file, you just need
    to type **`chmod a-w butterhaters.txt`** and then press **enter**. As you can
    see, the `+` gives permissions, while the `-` taketh away.
  prefs: []
  type: TYPE_NORMAL
- en: That's much simpler, you've got to admit.
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you ran the Ubuntu Software Center in [Chapter 6](ch06.html "Chapter 6. ROUNDING
    OUT THE BIRD"), you were first asked to input your password before you could run
    the program. The reason for this, as I mentioned then, is that the Ubuntu Software
    Center installs the files it downloads in various folders throughout your system,
    almost all of which are write protected. By supplying your password, you are telling
    your system that you, as holder of the password, have the right to allow the Ubuntu
    Software Center to do that.
  prefs: []
  type: TYPE_NORMAL
- en: The command version of that same password-giving process is the `sudo` command.
    To perform an operation in a folder that is write protected, you would first type
    **`sudo`** and then the command you want to perform. For example, if you wanted
    to copy an icon image, let's call it *myicon.png*, to the globally located and
    write-protected *pixmaps* folder (*/usr/share/pixmaps*), you would type **`sudo
    cp myicon.png /usr/share/pixmaps`**.
  prefs: []
  type: TYPE_NORMAL
- en: After typing a command preceded by the `sudo` command and pressing **enter**,
    you will be prompted for your password. Once you type your password and press
    **enter** again, the command will be executed. I should mention that once you
    input your password, it will stay in memory for about five minutes. This means
    that you will not be prompted for your password when using the `sudo` command
    again within that time frame.
  prefs: []
  type: TYPE_NORMAL
- en: $ locate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you are familiar with the `sudo` command, let''s take it out for a
    spin by working with the `locate` command. The `locate` command is essentially
    a command-line alternative to the graphical Search tool found in the Places menu.
    Using the command is quite easy: Simply type the command followed by a space and
    the name of the file you want to find.'
  prefs: []
  type: TYPE_NORMAL
- en: Before you can use this command, though, you will need to create a database
    of filenames for `locate` to use. This is where using the `sudo` command, along
    with yet another command, `updatedb`, comes into play. Just type **`sudo updatedb`**,
    and press **enter**. After you type your password when asked to do so, it will
    seem that nothing is happening for a while, but don't worry. As long as the cursor
    in your Terminal is blinking, progress is being made, and when your user prompt
    returns, you will have successfully created the database file. After that, you
    can use the `locate` command.
  prefs: []
  type: TYPE_NORMAL
- en: Oh, and in the future if you think that the process seems to be taking longer
    and longer, don't worry—it is. The more files and applications you add to your
    system, the longer it will take your system to catalog them all.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take this new command for a test drive, let''s look for the *openofficeorg3-writer.png*
    file that you worked with in [Chapter 3](ch03.html "Chapter 3. A NEW PLACE TO
    CALL HOME"). Just type the following, and press **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Your results should look like those in [Figure 9-8](ch09s04.html#the_results_of_a_locate_search
    "Figure 9-8. The results of a locate search").
  prefs: []
  type: TYPE_NORMAL
- en: '![The results of a locate search](httpatomoreillycomsourcenostarchimages656377.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-8. The results of a `locate` search
  prefs: []
  type: TYPE_NORMAL
- en: $ apt-get
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s move on to a command that might seem a bit familiar to you: `apt-get`.
    Yes, this command is indeed a means of controlling the powerful package download
    and installation tool, APT, which I covered in [Chapter 6](ch06.html "Chapter 6. ROUNDING
    OUT THE BIRD"). Although it might not be as pleasing to use APT via the command
    line as it is via the Ubuntu Software Center, doing so can come in handy. I''ll
    cover the basics for you here.'
  prefs: []
  type: TYPE_NORMAL
- en: Just for fun and to get a bit of nontoxic practice with `apt-get`, open a Terminal
    window, type **`apt-get moo`**, and press **enter**. The result of this endeavor,
    as you will see, is an example of another Easter egg lurking within your system
    ([Figure 9-9](ch09s04.html#discovering_an_easter_egg_via_apt-get "Figure 9-9. Discovering
    an Easter egg via apt-get")). Useless, yes, but a safe first step in working with
    `apt-get`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Discovering an Easter egg via apt-get](httpatomoreillycomsourcenostarchimages656379.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-9. Discovering an Easter egg via `apt-get`
  prefs: []
  type: TYPE_NORMAL
- en: To actually put the `apt-get` command to use, start by making sure to close
    any APT frontends you might have open, such as the Ubuntu Software Center. As
    I mentioned, you can run only one APT tool at a time. Once the coast is clear,
    you should always start out any operations involving `apt-get` with an update
    of the APT database so that you will be downloading the newest stuff. To do this,
    just type the command **`sudo apt-get update`**.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to install a single package without heading over to the Ubuntu Software
    Center, you can do so by typing **`sudo apt-get install`** *`package-name`*. For
    example, if you want to download and install the Shufflepuck game clone, Tuxpuck,
    you would type **`sudo apt-get install tuxpuck`**. If you eventually get annoyed
    with Tuxpuck after having lost one too many times, you can uninstall it by typing
    **`sudo apt-get remove tuxpuck`**.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, bearing in mind all the warnings offered in [Chapter 6](ch06.html "Chapter 6. ROUNDING
    OUT THE BIRD"), if you want to upgrade your entire system via the command line,
    you can do so by typing **`sudo apt-get dist-upgrade`** (but only after doing
    a **`sudo apt-get update`** first).
  prefs: []
  type: TYPE_NORMAL
- en: $ aptitude
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To wrap up this section, let's finish with an increasingly popular alternative
    to `apt-get`, called `aptitude`. One of the differences responsible for `aptitude`'s
    popularity is that it is considered to have superior dependency handling to `apt-get`;
    in addition, it is arguably easier to use, because of its semigraphical interface
    ([Figure 9-10](ch09s04.html#the_semigraphical_interface_of_aptitude "Figure 9-10. The
    semigraphical interface of aptitude")). Because of this hybrid graphical interface,
    a lengthy discussion of how to use `aptitude` would take us from the main purpose
    of this chapter, which is learning to work with commands. That being the case,
    I will only briefly touch upon its use.
  prefs: []
  type: TYPE_NORMAL
- en: Start `aptitude` by typing **`sudo aptitude`** in a Terminal window and pressing
    **enter**. To install a package, you would click **Search** in the blue menu ribbon
    at the top of the window, select **Find** in the drop-down menu that appears,
    type the name of the package you are looking for in the search box, and then click
    **Ok** ([Figure 9-11](ch09s04.html#performing_a_package_search_in_aptitude "Figure 9-11. Performing
    a package search in aptitude")).
  prefs: []
  type: TYPE_NORMAL
- en: '![The semigraphical interface of aptitude](httpatomoreillycomsourcenostarchimages656381.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-10. The semigraphical interface of `aptitude`
  prefs: []
  type: TYPE_NORMAL
- en: '![Performing a package search in aptitude](httpatomoreillycomsourcenostarchimages656383.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-11. Performing a package search in `aptitude`
  prefs: []
  type: TYPE_NORMAL
- en: Back in the main `aptitude` screen, you would select the package you want, click
    **Package** in the blue menu strip at the top of the page, and then select **Install**.
    If you prefer, you can just press the + key after selecting the target package
    to accomplish the same thing. Your package should now appear in green text. You
    may select other packages to install at the same time in the same way. Once done,
    press G on your keyboard, and the download and installation process will begin.
    If you are first presented with a screen telling you that certain packages will
    also be installed or removed, read through that screen, and then press G again
    to move on to the actual installation.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to use `aptitude` strictly in command mode in almost the
    same manner as `apt-get`, using pretty much the same arguments. To make sure the
    package lists that `aptitude` uses are up-to-date, you would start with the command
    **`sudo aptitude update`**. To install a package, such as the puzzle game Tangrams
    (aka gtans), you would type **`sudo aptitude install gtans`**. You would uninstall
    the package by typing **`sudo aptitude remove gtans`**.
  prefs: []
  type: TYPE_NORMAL
- en: A Couple of Other Biters You'll Be Using Soon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is as good a place as any to introduce two more commands that you will
    be called upon to use in this chapter and elsewhere in the book: `ln` and `tar`.
    You needn''t practice with these yet, because you will be using them very soon,
    but you might as well know what they are all about.'
  prefs: []
  type: TYPE_NORMAL
- en: $ ln
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You use the `ln` (link) command to create a link file that launches or activates
    another file located in a separate folder. This is very useful when trying to
    activate a file that is buried deep in the subfolder of a subfolder of a subfolder
    somewhere on your hard disk. The command is very often used with the `-s` (symbolic)
    flag, which provides essentially the same thing as the shortcut you've come to
    know in Windows or the alias on the Mac.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to use the `ln` command is to first use the `cd` command to
    change the Terminal's location to the folder where you want to place the link.
    Then you can type the **`ln`** command on the command line, followed by the path
    of the file to which you want to link. For example, let's say you want to put
    a link in your home folder for an OpenOffice.org Writer file of your autobiography
    called *myLife.odt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file is pretty well buried in a nest of subfolders deep within your home
    folder: */home/*username*/Documents/personal/self/autobiography/myLife.odt*. To
    create the link, you would open a new Terminal window, type the following command
    string, and then press **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once you are finished, the link will appear in your home folder as an icon matching
    the original file in appearance, albeit sporting an arrow to signify that it is
    a link.
  prefs: []
  type: TYPE_NORMAL
- en: $ tar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 7](ch07.html "Chapter 7. A TIDY NEST") you learned to create and
    extract archives, or *tarballs*, but did you know that you can also create and
    extract tarballs using the command line? The `tar` command is your key to doing
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an archive, you would simply type **`tar -cvf`**, followed by the
    name the final tarball will be, and then the name of the folder or file you are
    trying to archive. For example, let''s say you want to create an archive of your
    photos folder, and you want to call it *pics4pals*. In this case, you would type
    the following command and then press **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you no doubt noticed, there are some flags after the `tar` command in that
    string. The `c` tells the tar program to *create* a new archive. The `v` tells
    the program to be *verbose*, or, in other words, to tell you what it is doing
    in the Terminal as it is doing it. Finally, the `f` tells the program that what
    follows is the *file information*.
  prefs: []
  type: TYPE_NORMAL
- en: If, after creating the archive, you suddenly remember that there is one more
    file you want to add to the mix, you can use the `-r` flag to append the archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to add a file called *cranky.png* to the archive, you would type
    the following and then press **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, chances are that you will be doing more tarball extracting than
    creating, so you no doubt want to know how to do that. Fortunately, the process
    is pretty similar to what you use when creating the tarball. The main difference
    is in the first flag. Rather than using the `tar` command with the `-c` flag,
    you would instead use it with the `-x` flag, which tells the tar program to *extract*
    the specified archive. So if you want to extract a tarball called *spicyfood.tar*,
    type the following command, and press **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'What you have been doing thus far is creating and extracting archives, which
    are basically just collections of files. They are not, however, compressed. In
    fact, most tarballs you find will be compressed, and you can tell by the ending
    *tar.gz*. That *gz* means that the archive was compressed using the gzip program.
    Extracting a compressed tarball is just as easy as extracting a straight tar archive;
    all you have to do is add the `-z` flag, which tells your system to use the gzip
    program to decompress the archive. For example, if you want to extract a compressed
    tarball called *goosedown.tar.gz*, type the following command, and press **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, now that you know how to decompress and extract a gzipped tarball, you
    probably want to know how to create one. This is, again, little different than
    creating the tar archive itself; you would just add the `-z` tag to tell the program
    to use gzip to compress the folder. For example, to create a compressed version
    of your *Documentia* folder, which we''ll call *tightdocs.tar.gz*, you would type
    the following and press **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It's worth mentioning at this point that you may also come across some files
    compressed with the bzip program. Such files are recognizable by some variation
    on the *.bz* or .*bz2* file extension. Dealing with these files should pose no
    problem, because the commands are almost identical to those for gzip. Just substitute
    `-j` for `-z` in the command string.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing and Extracting Compressed Single Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to compress or decompress a single file, you don't really need to
    use the tar program at all, since its purpose is to create archives consisting
    of several files. You can instead use the `gzip` and `gunzip` commands directly.
    For example, to compress a file called *matilda.png*, you would type **`gzip matilda.png`**
    and press **enter**. The *matilda.png* file would then become *matilda.jpg.gz*.
    To decompress the file, you would type **`gunzip matilda.jpg.gz`** and press **enter**,
    after which the *matilda.jpg* file would be back to normal.
  prefs: []
  type: TYPE_NORMAL
- en: So, can you compress an archive you've already created with the `tar` command?
    Sure. For example, to compress the *spicyfood.tar* archive mentioned earlier,
    you would type **`gzip spicyfood.tar`**, and *voila*—you've got yourslf a compressed
    *spicyfood.tar.gz* archive. Pretty cool, don't you think?
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 9A: Creating a Plan'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a bit of command experience, it's time to get some practice
    and put all those commands to good use. In this project, you'll start off easy
    by creating a *.plan* file, like the one mentioned earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The actual *.plan* file is a hidden file (as you can see by the dot before its
    name), which contains the plan or message that you add to that file. That message
    will appear in the output of someone's Terminal when they use the `finger` command
    to find out more about you. You may not need such a *.plan* file, but it is an
    easy enough way to get started working a bit more with commands and the Terminal
    itself, so let's give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: To start out, you'll open the Terminal-based Pico editor to create the *.plan*
    file. To do this, open a Terminal window, type **`pico .plan`** (being sure to
    put a space between `pico` and `.plan`), and press **enter**. Your Terminal should
    now look a bit different, as you can see in [Figure 9-12](ch09s06.html#the_pico_editor
    "Figure 9-12. The Pico editor").
  prefs: []
  type: TYPE_NORMAL
- en: You will now be looking at your new, and totally empty, *.plan* file within
    the Pico editor. All you have to do now is type your plan or message. Once you've
    done that, press **ctrl**-X to exit the Pico editor, and it will ask you whether
    you want to save your work. You do, so type **`Y`**, after which you will be presented
    with a set of save options. You have already named the file *.plan*, as you can
    see near the bottom of the screen, so all you have to do is press **enter**. You
    will be back at your now-familiar user prompt in the Terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Pico editor](httpatomoreillycomsourcenostarchimages656385.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-12. The Pico editor
  prefs: []
  type: TYPE_NORMAL
- en: To wrap things up, you want to change the permission of the new *.plan* file
    by typing **`chmod 644 .plan`** in the Terminal window and then pressing **enter**.
    The *.plan* file should now be in your home folder and readable (see Note below)
    by all, so go on and test your work by typing **`finger`** *`username`* and pressing
    **enter**. The message you entered in your *.plan* file should now appear in the
    results in place of the `no Plan` you found there earlier. If you want to change
    the contents of your *.plan* file later, just follow the same steps, and change
    the text when the *.plan* appears in the Pico editor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name of the *.plan* file is preceded by a period, which means that it is
    a hidden file. Thus, if you take a look in your home folder, you will not be able
    to see the file unless you have checked the *Show hidden and backup files* box
    in the Nautilus Preferences window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 9B: More Command Practice with pyWings'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's get some more experience with the Terminal by installing a simple,
    and admittedly kind of silly, oracle program called pyWings (see [Figure 9-13](ch09s07.html#seeking_wisdom_from_pywings
    "Figure 9-13. Seeking wisdom from pyWings")). pyWings will give you cryptic guidance
    in response to whatever questions you may ask it.
  prefs: []
  type: TYPE_NORMAL
- en: To use pyWings, type whatever your confusion is in the input box, click one
    of the concern icons on the left (self, another, world), click one of the realm
    icons on the right (love, work, truth), and hit the big button that looks like
    half an eye. The oracle will then tell you what it has to say. As an example,
    I asked the oracle why I feel so down when the skies are so sunny, and I picked
    *self* as my concern and *truth* as the realm. [Figure 9-14](ch09s07.html#pywings_bestows_its_wisdom
    "Figure 9-14. pyWings bestows its wisdom.") shows the wisdom that was bestowed
    upon me.
  prefs: []
  type: TYPE_NORMAL
- en: '![Seeking wisdom from pyWings](httpatomoreillycomsourcenostarchimages656387.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-13. Seeking wisdom from pyWings
  prefs: []
  type: TYPE_NORMAL
- en: '![pyWings bestows its wisdom.](httpatomoreillycomsourcenostarchimages656389.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-14. pyWings bestows its wisdom.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the oracle told me, "What we bring closer, grows to us," which
    I will interpret as . . . well, I'm not sure what to interpret it as.
  prefs: []
  type: TYPE_NORMAL
- en: Hmmm.
  prefs: []
  type: TYPE_NORMAL
- en: pyWings was written in a programming language called Python, which actually
    creates scripts rather than true conventional programs. You will learn a little
    more about this distinction in later in the chapter, but one of the differences
    I can mention right off the bat is that you don't actually have to install pyWings;
    you are simply going to put it on your hard drive in your home folder and run
    it from there, more or less as is.
  prefs: []
  type: TYPE_NORMAL
- en: '9B-1: Getting Ready for pyWings (Installing Tkinter)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I mentioned, one difference between pyWings and most of the other applications
    you know is that pyWings is a Python script. To create a graphical interface for
    itself, pyWings uses a toolbox known as *Tkinter*, which is the de facto standard
    (though not the only) GUI toolbox for Python. Tkinter, however, no longer comes
    bundled with Ubuntu, so you will need to download and install it yourself. Fortunately,
    this is quite easily done.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is possible to whip open the Ubuntu Software Center and install
    Tkinter by the simple means learned in [Chapter 6](ch06.html "Chapter 6. ROUNDING
    OUT THE BIRD"), it seems more appropriate in this command line–oriented chapter
    to . . . yeah, you got it, use the command line. That said, open a Terminal window,
    type **`sudo apt-get install python-tk`**, and then press **enter**. When asked
    for your password, type it, and then press **enter**. APT will search the online
    repositories and find your file, along with anything else it requires to function
    properly. Once it is ready, it will ask you whether you want to continue. You
    do, so type **`y`**, and then press **enter**. When your username prompt reappears,
    you'll know the job is done, and you can go on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you prefer, you can perform this installation using `aptitude` instead, using
    the techniques we discussed earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '9B-2: Getting pyWings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are just about ready to begin "installing" pyWings, but before you do, you
    need to get it from [http://sourceforge.net/projects/pywings/](http://sourceforge.net/projects/pywings/).
    Once there, click the **View all files** button, and then download the file *pywings-1.1.tar.gz*.
    Then place the file in your home folder so that you can follow along easily with
    the rest of this project.
  prefs: []
  type: TYPE_NORMAL
- en: '9B-3: Creating a LocalApps Folder for pyWings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I mentioned earlier, you will be installing the pyWings program locally in
    your home folder. Installing a program *locally* means that you are installing
    the program and all its support and data files in your home folder. This makes
    things a bit easier, but it also means that the program will not be available
    to other users. It also means that if you're not careful, you might inadvertently
    delete it.
  prefs: []
  type: TYPE_NORMAL
- en: To make things a bit easier and safer for you, you are going to create a folder
    in your home folder in which to place pyWings and all other applications that
    you install locally on your machine in the future. You will, logically enough,
    call the folder *LocalApps*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the folder using a command in order to get some more practice.
    Go to the Terminal, make sure you are in your home folder, type the following
    command, and then press **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '9B-4: Extracting the pyWings Tarball'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it is time to extract the tarball. You could do this by the double-click
    method you learned in [Chapter 7](ch07.html "Chapter 7. A TIDY NEST"), but since
    you're working with the command line here, let's use that instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, you''re going to place the tarball in the same folder into which
    you extract its files. Usually this isn''t necessary because the contents of most
    tarballs are already packaged in a folder of their own. By double-clicking the
    tarball to open it in File Roller, you can see whether things are packed in a
    folder or simply as a group of files. In the case of pyWings, it is the latter,
    so follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a *pywings* folder by typing **`mkdir pywings`** and pressing **enter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the pyWings tarball into that folder by typing **`mv pywings*.gz pywings`**
    and pressing **enter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see that in this step you used an asterisk (**`*`**) to save some wear
    and tear on your fingers. The asterisk is a wildcard character that in this case
    told your system to move any file beginning in *`pywings`* and ending in *`.gz`*.
    Fortunately you had only one item matching those criteria.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Move to the new *pywings* folder by typing **`cd pywings`** and pressing **enter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you get down to the process of extracting the tarball itself using the `tar`
    command. To do this, type **`tar –xzvf pywings*.gz`**, and press **enter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, notice that you used the asterisk to save youself some keystrokes, though
    you could just as well have typed **`-1.1.tar`** in its stead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, type **`cd`**, and press **enter** to bring the Terminal back to your
    home folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '9B-5: Moving the pyWings Folder to Your LocalApps Folder'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The extraction process is now complete. Before going on to running pyWings,
    however, let''s move it to the new *LocalApps* folder you created in Project 9B-3\.
    To do this, type the following command, and then press **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '9B-6: Running pyWings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have pyWings in place and ready for action, let's start up the
    great oracle right now so that you can get a better perspective on how to deal
    with the aspects of life that trouble you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Terminal, make sure you are in your home directory, type the following
    command string, and then press **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since *pywings.py* is a Python script, rather than an application, you are calling
    Python's attention to that fact so that Python will know it needs to deal with
    that script. If all went according to plan, pyWings should be up and running and
    will soon be making you a wiser person.
  prefs: []
  type: TYPE_NORMAL
- en: '9B-7: Creating a Launchable Link for pyWings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The method of running pyWings that you've just used works well enough, but it
    is a pain to open your Terminal and type that somewhat lengthy string every time
    you want to find out what fate has in store for you. Let's find a way to make
    things easier in the future.
  prefs: []
  type: TYPE_NORMAL
- en: To run an application from the Terminal, you generally type the name of that
    application, or, to put it more precisely, the name of that program's executable
    file; the application's name thus acts as a sort of command. For your system to
    recognize that command, however, the command (the executable file or a link to
    it) must be in a location where the system can find it. Whenever you run a command
    of any sort, your system checks a series of locations (most of which are *bin
    folders*, where executable files are located) to find that command.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily find out where these locations are by typing **`echo $PATH`**
    in a new Terminal window and then pressing **enter**. As you will see, on your
    Ubuntu system, these locations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| */usr/local/bin* | */bin* |'
  prefs: []
  type: TYPE_TB
- en: '| */usr/local/sbin* | */usr/bin* |'
  prefs: []
  type: TYPE_TB
- en: '| */sbin* | */usr/games* |'
  prefs: []
  type: TYPE_TB
- en: '| */usr/sbin* |   |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The results of the `echo $PATH` command will not appear as they do in the easier-to-read
    chart shown here but, rather, in a single line divided by colons. The actual output
    shown in the Terminal is *`/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games`*.
  prefs: []
  type: TYPE_NORMAL
- en: If the command you typed is in one of those locations, the program, or script,
    will run. As you no doubt know, however, pyWings is not in any of those locations.
    It is in */home/*username*/LocalApps/pyWings* and is thus, in a sense, out of
    your system's sight.
  prefs: []
  type: TYPE_NORMAL
- en: To remedy this situation, you could add the path of your pyWings script to the
    list of paths that the system checks for run commands, so as to make the system
    aware of your new application's existence. However, let's try another method that
    I think is easier. What you will do is create a link to pyWings, a sort of launchable
    alias, in one of the locations your system does check for commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this link, you will be using three commands: `cd` (to change directories),
    `sudo` (to give yourself write access to the destination folder), and `ln -s`
    (to create the link).'
  prefs: []
  type: TYPE_NORMAL
- en: In the Terminal, type **`cd /usr/games`**, and press **enter**. This puts you
    in one of the folders your system searches when you enter commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **`sudo ln -s /home/`***`username`***`/LocalApps/pywings/pywings.py pywings`**,
    and press **enter**. (Note that there is a space between the words `pywings.py`
    and `pywings` at the end of that command string.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `pywings` at the end of that command string is the name that you are giving
    the link; the name of the link thus becomes the command you will use to run the
    application. If you type nothing, the link will be called *pywings.py*, which
    would mean three more keystrokes for you every time you wanted to start the program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type your password when prompted to do so, and then press **enter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **`cd`**, and press **enter** to return the Terminal to your home folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '9B-8: Running pyWings Again'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have created the link, you should be able to run the pyWings program
    much more easily. To try it, quit pyWings (if it is still running), type **`pywings`**
    in the Terminal window, and press **enter**. Your personal pyWings oracle should
    appear again.
  prefs: []
  type: TYPE_NORMAL
- en: You've managed to cut down on the number of keystrokes required to run pyWings
    from the Terminal. However, if you are really into this pyWings thing and want
    to use it often, it will probably be handiest to add a launcher to your panel,
    a drawer, or the Applications menu.
  prefs: []
  type: TYPE_NORMAL
- en: To add a pyWings panel launcher, for example, right-click any open space in
    the panel, and select **Add to Panel**. When the Add to Panel window appears,
    click the **Custom Application Launcher** item, and click **Add**. In the Create
    Launcher window that appears, type **`pyWings`** in the Name section, anything
    you want in the Comment section (**`Your Obtuse Guru`**, for example), and, assuming
    you created a launchable link in Project 9B-7, type **`pywings`** in the Command
    section. For an icon, click the **No Icon** button, and then look around until
    you find an icon that suits your fancy. I like *gnome-eog.png* myself. Once you've
    made your selection, click **Add** in the Browse icons window, and then click
    **OK** in the Create Launcher window.
  prefs: []
  type: TYPE_NORMAL
- en: '9B-9: Adding Emblems to Your LocalApps Folder'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that pyWings is successfully installed and working, it is probably a good
    idea to add an emblem to your new *LocalApps* folder so that you don't inadvertently
    dump it in the Trash someday. You already learned how to do this in [Chapter 8](ch08.html
    "Chapter 8. DRESSING UP THE BIRD"), so I won't give you the step-by-step instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 9C: Command Practice Review with Briscola'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to reinforce the skills you've put to use in the previous project,
    why not go a bit Continental and try Briscola—a simple, yet very traditional,
    Italian card game (see [Figure 9-15](ch09s08.html#briscola "Figure 9-15. Briscola"))?
    Unlike pyWings, which is a Python script, Briscola is a script of a different
    flavor, written in a scripting language called Tcl, which uses something called
    Tk to create its graphical interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![Briscola](httpatomoreillycomsourcenostarchimages656391.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-15. Briscola
  prefs: []
  type: TYPE_NORMAL
- en: '9C-1: Getting Briscola'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are just about ready to begin "installing" Briscola, but before you do,
    you must get it. You can get Briscola by going to the project''s home page at
    [http://www.rigacci.org/comp/software/](http://www.rigacci.org/comp/software/)
    and downloading it in the traditional manner, but since we''re working with commands,
    let''s instead get Briscola by using a new command: `wget`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, just open a Terminal window, type the following command string,
    and then press **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have any trouble downloading Briscola in this way, you can also download
    it from the site for this book: [http://www.edgy-penguins.org/UFNG/](http://www.edgy-penguins.org/UFNG/).'
  prefs: []
  type: TYPE_NORMAL
- en: In your Terminal window, you will see `wget` in action as it connects to the
    site where Briscola is stored and then downloads the file. When it's done, you
    will find the Briscola tarball in your home folder.
  prefs: []
  type: TYPE_NORMAL
- en: '9C-2: Extracting the Briscola Tarball and Renaming the Briscola Folder'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extracting the Briscola tarball is essentially the same process as that for
    pyWings; however, Briscola is already packaged within its own folder, so you won't
    have to create a special folder for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although I am sure you now know the drill, I''ll tell you again. Just open
    a Terminal window, type the following command, and press **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A new folder, *Briscola-4.1*, will now appear in your home folder with all the
    Briscola files in it. To make things easier to deal with in the future, let's
    shorten the name of the folder to simply *briscola*. You already know how to do
    this via the right-click method, but this time around let's to do it via the command
    line. To do this, you use, perhaps surprisingly, the `mv` command followed by
    the name of the file whose name you are going to change, followed by the new name
    of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Give it a go by typing the following command and pressing **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '9C-3: Preparing the Briscola Script'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most applications that come in tarball form include a README file, which includes
    information on what you need to do to install and use the application. If you
    double-click the **README** file in the *briscola* folder in Nautilus, you will
    see that the "HOW TO START" section tells you to adjust the first line of the
    *briscola.tk* script to point it to your Tk shell, and to adjust the second line
    of the script to point to the directory where the various Briscola files are located.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the adjustments as instructed in the README file, just follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the Tk shell, called Wish, by typing **`locate wish`** in the Terminal
    window and pressing **enter**, and then note the location given on a piece of
    paper. You may get a number of locations in your search results, but the one you
    want is `/usr/bin/wish`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Direct the Terminal to the *briscola* folder by typing **`cd briscola`** and
    pressing **enter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the Pico editor, which we used in Project 9A, to edit the *briscola.tk*
    file by typing **`pico briscola.tk`** and pressing **enter**. The *briscola.tk*
    file will appear in the Pico editor in your Terminal window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the very first line of the *briscola.tk* file from `#!/usr/local/bin/wish`
    to **`#!/usr/bin/wish`**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the second line, change `/usr/local/games/briscola` to **`/usr/share/games/briscola`**,
    which is where you will place Briscola in just a bit. Your editor window should
    now look like [Figure 9-16](ch09s08.html#configuring_briscola_with_the_pico_edito
    "Figure 9-16. Configuring Briscola with the Pico editor").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Configuring Briscola with the Pico editor](httpatomoreillycomsourcenostarchimages656393.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9-16. Configuring Briscola with the Pico editor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press **ctrl**-X on your keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **`y`**, and press **enter** to save your changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **`cd`**, and press **enter** to return the Terminal to your home folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '9C-4: Moving the Briscola Folder to a Global Location'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You could move the *briscola* folder to the *LocalApps* folder and play it from
    there, as you did with pyWings, but this time around, let's do things a bit differently
    by moving the whole thing to global territory. This not only keeps it safe from
    any obsessive housekeeping tendencies but also allows all users on the same computer
    to play the game. You will need to use the `sudo` command to do this so that you
    can have write access in those protected folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, just type the following command in the Terminal window, and press
    **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When you are prompted for your password, type it, and press **enter**.
  prefs: []
  type: TYPE_NORMAL
- en: '9C-5: Creating a Launchable Link for Briscola'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though you''ve moved Briscola to a global location, you still can''t run
    it with a simple one-word command because the *briscola.tk* file is not in the
    system''s command search path. Just as you did for pyWings, you will now create
    a launchable link for Briscola to solve that problem. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Terminal, type **`cd /usr/games`**, and press **enter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now create the link by typing **`sudo ln -s /usr/share/games/briscola/briscola.tk
    briscola`**, and press **enter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **`cd`**, and press **enter** to return the Terminal to your home folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now easily run Briscola by typing **`briscola`** in the Terminal and
    pressing **enter**.
  prefs: []
  type: TYPE_NORMAL
- en: Can You Do the Same Thing with pyWings?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sure. If you want to move pyWings to a global location, just follow the same
    procedure for moving the *pywings* folder and creating the link as you did for
    Briscola, making the necessary substitutions, of course. You will have to remove
    the previously created pyWings link, though, by typing the following command and
    pressing **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After that, move the *pywings* folder to global territory by typing **`sudo
    mv ˜/LocalApps/pywings /usr/share/games/pywings`** and pressing **enter**. When
    prompted for your password, type it, and press **enter**. You can then create
    the launchable link by typing **`cd /usr/games`**, pressing **enter**, typing
    **`sudo ln -s /usr/share/games/pywings/pywings.py pywings`**, and pressing **enter**
    once more.
  prefs: []
  type: TYPE_NORMAL
- en: Playing Briscola
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I already mentioned, Briscola is easy—about as easy a card game as there
    is. It is a trick-taking game, which means that you put out a card and then your
    opponent puts out a card, and the one who puts out the higher point-value card
    wins the hand, or *trick*. Points are awarded on the basis of the cards involved
    in that trick. The winner of the trick then goes on to *lead* the next trick,
    meaning that the winner puts out his or her card first the next time around. When
    all the cards are played, the points for each player are then tallied, and the
    player with the higher points wins. It's much simpler to do than it is to describe.
  prefs: []
  type: TYPE_NORMAL
- en: Want to Know More?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you would like a more detailed set of rules for playing Briscola (and just
    about any other card game in the world), check out [http://www.pagat.com/](http://www.pagat.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 9D: Compiling and Installing Programs from Source: Xmahjongg'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though it was far more common in the earlier days, *compiling programs from
    source* seems to be a phrase you still hear more in the Linux world than in any
    other. For the beginner, just the mention of compiling a program from source seems
    off-putting enough. The words *compile* and *source* seem to instill a sense of
    foreboding in the heart of the new user. That certainly was the case for me, anyway.
  prefs: []
  type: TYPE_NORMAL
- en: You can live long and prosper without ever bothering to compile anything on
    your system. You can move along quite happily with your system as is, or you can
    just install programs by means of the much more convenient Ubuntu Software Center.
    Still, once in the Linux world, you are likely to come across this installation
    method and may well become curious, especially if you move into the geekier side
    of the community.
  prefs: []
  type: TYPE_NORMAL
- en: So, What Is Source?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, it is probably a good idea to understand what *source* is so
    as to help you to understand a bit about how a program actually gets from its
    primitive state on the programmer's computer to an up-and-running application
    on your machine. First the programmer writes a program in a programming language.
    You have probably heard of programming languages such as BASIC or C, and there
    are many others. What the programmer actually writes with such a language is a
    set of instructions called the *source code*, or *source*. Your computer, however,
    cannot actually understand any of that source on its own. It is as if the computer
    speaks ancient Greek, and the source code is all written in French. The computer
    therefore needs some sort of interpreter to help it out.
  prefs: []
  type: TYPE_NORMAL
- en: The various languages that programmers use are called *high-level languages*—they
    are relatively easy for programmers to read. The computer, on the other hand,
    only understands *low-level languages*, which are quite difficult for most mere
    mortal programmers to deal with. To convert the high-level language instructions
    to a low-level language, the computer needs some other program to translate.
  prefs: []
  type: TYPE_NORMAL
- en: If this translation process actually takes place while a program is running,
    the translator program is called an *interpreter*. Applications that run using
    an interpreter are usually called *scripts*. The pyWings and Briscola applications
    earlier in this chapter are examples of such script applications.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with such scripts is that they can be slower than most of the applications
    you're familiar with—the computer must run an interpreter, interpret the source
    code, and run the actual application all at the same time. This is like having
    a French book translated into Greek by a live interpreter; it's very slow indeed.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative, most programs use a compiler instead of an interpreter. A
    *compiler* translates the high-level source code into low-level *machine code*,
    or *object code*, that the computer can understand before the application is actually
    run. Once this translation is done, the computer never has to bother with the
    high-level instructions again; it can merely read the translated version each
    time it runs the program. This is like having a translated version of a foreign
    book that you can read any time you want. Because computers can run compiled programs
    without simultaneously using an interpreter, compiled programs run faster than
    scripts. Most applications for all operating systems are, therefore, compiled.
  prefs: []
  type: TYPE_NORMAL
- en: The Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The actual process of compiling an application from source and then installing
    it is quite simple—a truly "one, two, three" bit of presto change-o. Basically,
    after extracting the source code from an archived file (usually in the form of
    a tarball), you would use the following commands to accomplish the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`./configure`**'
  prefs: []
  type: TYPE_NORMAL
- en: To configure a *makefile*, which provides instructions for the `make` command
  prefs: []
  type: TYPE_NORMAL
- en: '**`make`**'
  prefs: []
  type: TYPE_NORMAL
- en: To translate the source code into object code that the computer can understand
  prefs: []
  type: TYPE_NORMAL
- en: '**`sudo make install`**'
  prefs: []
  type: TYPE_NORMAL
- en: To give yourself write privileges in protected folders and then install the
    application
  prefs: []
  type: TYPE_NORMAL
- en: '**`make clean`**'
  prefs: []
  type: TYPE_NORMAL
- en: To tidy up the leftovers once the process is complete (to clean up the mess)
  prefs: []
  type: TYPE_NORMAL
- en: I know that sounds like a lot of commands, but as I always say, it is easier
    to actually do than it looks like on the page, so fear not.
  prefs: []
  type: TYPE_NORMAL
- en: '9D-1: Installing the Tools You Need'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before doing anything else, you have to get your system ready to do what you''re
    about to ask of it. Because Ubuntu is designed with the average computer user
    in mind, it does not come with the various applications and libraries you need
    to compile applications from source. Fortunately, however, everything you need
    to get the job done is available via the Ubuntu Software Center. To get ready
    for the work at hand in this chapter (and many other jobs you are likely to do
    on your own in the future), perform searches for and install the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: build-essential
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: libgtk2.0-dev
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '9D-2: Downloading and Extracting the Xmahjongg File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get some hands-on experience with compiling a program from source, you will
    be working with a game called *Xmahjongg*, which you can see in [Figure 9-17](ch09s09.html#the_xmahjongg_game
    "Figure 9-17. The Xmahjongg game"). If you've tried the version of Mahjongg that
    comes with your Ubuntu distribution, you will notice that this one is much easier
    on your eyes and is a bit more colorful (check out the project site at [http://www.lcdf.org/xmahjongg/](http://www.lcdf.org/xmahjongg/)
    to catch a glimpse of it in its full-color glory).
  prefs: []
  type: TYPE_NORMAL
- en: '![The Xmahjongg game](httpatomoreillycomsourcenostarchimages656395.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-17. The Xmahjongg game
  prefs: []
  type: TYPE_NORMAL
- en: Xmahjongg is available via the Ubuntu Software Center, so it is not absolutely
    necessary to install it in the way you are about to, but doing so provides a perfect
    opportunity to learn how to compile a program from source. The amount of source
    code isn't all that great, so it won't take too much time to do, and it requires
    no tinkering.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, you will first have to download the Xmahjongg source code. You
    can get this from the Xmahjongg project page at [http://www.lcdf.org/xmahjongg/](http://www.lcdf.org/xmahjongg/).
    Download the tarball *xmahjongg-3.7.tar.gz*, or a newer version if there is one.
    Do not download any of the other file types available on that page.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer, you can instead download the Xmahjongg tarball by using the
    `wget` command that you learned in Project 9C-1\. Just open a Terminal window,
    type the following command, and then press **enter**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once you have the file on your hard disk, untar the *xmahjongg-3.7.tar.gz* file.
    You can do this either by using the command line, as you learned to do earlier
    in the chapter, or by double-clicking the file and dragging its contents into
    the appropriate folder. To make it easier for you to follow along with the directions
    I'll be giving you, be sure to place the untarred Xmahjongg folder in your home
    folder. Then you will be ready to roll.
  prefs: []
  type: TYPE_NORMAL
- en: Normally at this point, you would look through the folder to find some instructions
    for dealing with the package, just as you did earlier in the chapter for Briscola.
    In most source code packages, this information is included in an INSTALL file,
    like the one in the *xmahjongg-3.7* folder ([Figure 9-18](ch09s09.html#identifying_a_package_apostrophy_s_insta
    "Figure 9-18. Identifying a package's INSTALL file")). To read the INSTALL file,
    just double-click it, and it will open in Gedit.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you can simply close the INSTALL file, because it prescribes the
    same steps I've listed next. However, in the future, when you install other programs
    from source, you will need to follow the instructions in the INSTALL files that
    come with the source files. However, with most INSTALL files, the instructions
    will match the process I am about to describe.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it may well happen that you take a look at the contents of the INSTALL
    file and start wondering what alien tongue it is written in. In cases when you
    have no idea what the INSTALL file is going on about, just look for a *configure*
    file in the package folder. If you find one, you should be able to follow the
    instructions in this project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying a package''s INSTALL file](httpatomoreillycomsourcenostarchimages656397.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-18. Identifying a package's INSTALL file
  prefs: []
  type: TYPE_NORMAL
- en: '9D-3: Running configure and make for Xmahjongg'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have downloaded and untarred the Xmahjongg tarball, installation
    is pretty standard. Here''s what you need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a Terminal window, and then move into the new folder by typing **`cd xmahjongg*`**
    and pressing **enter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is sort of a setup phase that runs the configure script in the
    *xmahjongg-3.7* folder. The configure script checks what files, compilers, and
    other things it needs, and then it searches your computer to see whether those
    things are there and, if so, where. Based on this information, it writes a file
    called a *makefile*, which is a set of instructions that will tell the `make`
    command in the subsequent step how to set things up specifically for your system
    configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Configure the program by typing **`./configure`** and pressing **enter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While you are running `configure`, you will see lots of odd and mysterious things
    flowing through your Terminal window; this is essentially a running account of
    what is going on, each step of the way. This can take a bit of time, but don't
    worry. As long as the mysterious text keeps flowing and you don't get an error
    message at the very end of the whole process, all will be well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When `configure` has done its thing, you will see your prompt again, and you
    can go on to the next step, which is the translation, or *compilation*, step.
    The `make` command reads the makefile created by `configure` to see how things
    need to be set up on your machine. Then it proceeds to call on the compiler to
    translate the high-level source code into low-level, machine-readable files that
    can be installed in the subsequent step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To perform this translation, type **`make`**, and press **enter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, you will be treated to even more mysterious text flowing through the
    window and a short wait, usually a tad longer than for the configure process.
    Once `make` has done its job and you see your prompt again, you are ready to install
    the program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Up to this point, you have not changed your system in any way. All the changes
    thus far have taken place in the *xmahjongg-3.7* folder only—your system is still
    as pure as the day you started. Of course, all that is going to end right now
    when you perform the final installation step.
  prefs: []
  type: TYPE_NORMAL
- en: '9D-4: Installing and Running Xmahjongg'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you've come to the last step in this part of the process, `make install`.
    Here you are telling your system to install what you have created, or *compiled*,
    in the `make` step. Note that because installation takes place in permissions-protected
    parts of your system, you will need to add `sudo` to the command string to give
    yourself administrative privileges.
  prefs: []
  type: TYPE_NORMAL
- en: To perform the installation, type **`sudo make install`**, and press **enter**.
    You will then be prompted for your password. After typing it and pressing **enter**,
    the installation process will take place. Once your Terminal brings you back to
    your user prompt, Xmahjongg will be installed and ready to run. As a general rule,
    programs compiled from source do not automatically install a launcher in your
    Applications menu; you must instead run them by command. Although you can run
    a program for the first time by typing a command in the Run Application panel
    applet, it is better to run the program for the first time by typing the command
    in your Terminal window. If anything has gone amiss during installation, the Terminal
    will tell you what the problem is, whereas the Run Application method would just
    leave you wondering what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: To run Xmahjongg, just type **`xmahjongg`** in a Terminal window, and then press
    **enter**. If everything goes as it should, you can then create a program launcher
    for Xmahjongg in your Applications menu, on the GNOME Panel, or in a panel drawer.
  prefs: []
  type: TYPE_NORMAL
- en: '9D-5: Cleaning Up and/or Uninstalling Xmahjongg'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you are done and everything seems to be working as it should, you would
    normally tidy things up in the Xmahjongg folder by getting rid of any unnecessary
    files. You can do this via the Terminal by using the `cd` command to go back into
    the Xmahjongg folder, typing **`make clean`**, and then pressing **enter**.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to uninstall Xmahjongg, open a Terminal window, go back to the Xmahjongg
    folder by using the `cd` command, type **`sudo make uninstall`**, and finally
    press **enter**. The routine is essentially the same for any applications installed
    in this way, though as you might imagine, uninstallation isn't always as smooth
    a process as what I've just described (and it's definitely not as easy as it is
    via the Ubuntu Software Center).
  prefs: []
  type: TYPE_NORMAL
- en: The main reason for the uninstallation process being less than cooperative is
    that the `make uninstall` routine requires you to keep the original project folder,
    which means you have to keep a bit of clutter you normally wouldn't need to bother
    with. On top of this, some projects do not provide a `make uninstall` routine
    at all. This means that you have to keep track of where everything has been installed
    in your system and then remove each item using a series of `sudo rm` commands.
  prefs: []
  type: TYPE_NORMAL
- en: All that negativity aside, go ahead, have some fun, and put your command-line
    skills to the test. You'll have something to tell your grandkids about in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Terminal is a very simple application in terms of looks, though you can
    spice things up a bit if you're so inclined. Not only can you change the background
    and text colors in the Terminal, but you can even display one of your favorite
    photos as a background (as shown in [Figure 9-19](ch09s10.html#a_terminal_window_with_customized_backgr
    "Figure 9-19. A Terminal window with customized background and font colors"))
    or make the background transparent.
  prefs: []
  type: TYPE_NORMAL
- en: To change the Terminal background, go to the Terminal, and select **Edit** ▸
    **Profiles**. When the Profiles window appears, select the profile you want to
    edit, which the first time out would be Default, and then click the **Edit** button.
    In the Editing Profile window that appears, click the **Background** tab, select
    **Background image** ([Figure 9-20](ch09s10.html#customizing_the_terminal_window
    "Figure 9-20. Customizing the Terminal window")), and then navigate to the photo
    you want to use as your background by clicking the **Menu** button next to the
    words *Image file* and then finding the file in the Select Background Image window.
    When you've found the photo of your choice, click **Open**. Depending on the image
    you use for your background, you may find it rather difficult to see the text
    once your image appears in the Terminal. If so, try moving the slider under the
    words *Shade transparent or image background* in the Editing Profile window. If
    that still doesn't do the trick, click the **Colors** tab, deselect **Use colors
    from system theme**, and then try some of the preset Foreground and Background
    combinations from the menu button next to the words *Built-in schemes*.
  prefs: []
  type: TYPE_NORMAL
- en: '![A Terminal window with customized background and font colors](httpatomoreillycomsourcenostarchimages656399.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-19. A Terminal window with customized background and font colors
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing the Terminal window](httpatomoreillycomsourcenostarchimages656401.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-20. Customizing the Terminal window
  prefs: []
  type: TYPE_NORMAL
- en: If you just want to make the background transparent, go back to the **Background**
    tab, select **Transparent background**, and drag the slider to the right. You
    can also use the slider to adjust the shading of your background image if you
    choose to go that route.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the colors present in your background image or in your desktop
    wallpaper (if you've gone the transparent route), you may also want to change
    the font color for your Terminal to make things easier to see. To do this, click
    the **Colors** tab, deselect **Use colors from system theme**, and then make the
    appropriate font color selection.
  prefs: []
  type: TYPE_NORMAL
- en: Tabbed Shell Sessions in the Terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To wrap things up in this chapter, I thought I might mention one particularly
    convenient feature of the GNOME Terminal: tabs. Just as you can view multiple
    web pages in one Firefox web browser window through the use of tabs, tabs in the
    Terminal application allow you to have more than one shell session running at
    the same time without having more Terminal windows open (see [Figure 9-21](ch09s11.html#running_multiple_shell_sessions_in_tabs
    "Figure 9-21. Running multiple shell sessions in tabs within the GNOME Terminal")).
    This reduces the amount of desktop clutter and generally makes things easier to
    deal with. You can open a new tab within the Terminal by going to the Terminal
    and selecting **File** ▸ **Open Tab**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running multiple shell sessions in tabs within the GNOME Terminal](httpatomoreillycomsourcenostarchimages656403.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-21. Running multiple shell sessions in tabs within the GNOME Terminal
  prefs: []
  type: TYPE_NORMAL
