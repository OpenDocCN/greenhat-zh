- en: Chapter 5. The Boot Process
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Single-user mode*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*unscheduled in the nighttime?*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '*Something just went “boom”!*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) In order to properly
    manage any computing platform, you must understand the boot process. Many systems
    administration tasks cannot be done while the system is running. OpenBSD specifically
    requires that certain tasks be done before the boot process has completed. And,
    of course, on any operating system, sometimes a process starting up prevents the
    system from completing its boot. The only way to fix these problems is to interrupt
    the boot partway through.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll look at the key to OpenBSD’s booting process: the boot loader.
    Then we’ll move on to single-user mode, and finally multiuser startup. You can
    perform useful work at any of these stages.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: I recommend playing with the OpenBSD boot process on a test machine *before*
    one of your machines won’t boot. That way, when something breaks in the wee hours
    of the morning, you can spend your time fixing the problem instead of fumbling
    around with unfamiliar commands.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Power-On and the Boot Loader
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, when a PC-style computer first boots, it starts the BIOS. The BIOS
    is a small piece of software that figures out things like which drives are attached
    and what they’re attached to, what sort of CPU is installed, and how much memory
    is available. After getting that information, the BIOS loads a minimal boot loader
    from some kind of storage device.^([[11](#ftn.id369126)])
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The *boot loader* is a small program that handles initial system configuration
    and boots the kernel. It finds and starts the kernel, which in turn detects hardware,
    attaches device drivers, and performs other core setup. Finally, the kernel calls
    `init(8)`, which starts processes and enables user programs, network interfaces,
    server software, and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: While most of this process cannot be managed—no one actually configures `init`!—there’s
    plenty you can do before the system finishes booting and dumps you at the login
    screen.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The OpenBSD boot loader lets you interrupt the boot process, configure the system
    before it boots, adjust kernel settings, and even boot an alternate kernel.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'When the hardware hands control of the boot process over to the OpenBSD partition,
    you’ll see the boot loader prompt, which looks something like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The boot loader’s main purpose is to find the kernel, load it into memory, and
    start it. Because it runs before the kernel starts, the boot loader can pass instructions
    to the kernel itself.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the things you can do before booting is complete:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Use built-in help
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the `help` function to print a brief list of commands that the boot loader
    supports.
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Delay the boot process
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By default, the loader waits five seconds for instructions, and then boots the
    kernel. To pause the boot at the prompt, press the spacebar.
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Set the boot timeout
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To set a new boot idle timeout, specify a number of seconds with the `set timeout`
    command.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After the boot prompt is idle for 10 seconds, the system should boot.
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Boot the system
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you’ve paused the boot process, the system won’t boot until you tell it
    to. When you’re ready to boot, use the `boot` command:'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ll use various permutations of `boot` to configure the kernel, boot single-user
    mode, and so on. I’ll cover other boot commands in the appropriate sections. For
    full details on what you can do at the boot loader prompt, read the `boot(8)`
    man page.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Booting in Single-User Mode
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Single-user mode is the earliest point when OpenBSD can give you a Unix-style
    shell prompt. At this point, the kernel has probed all the hardware, attached
    drivers to all the hardware that it’s going to acknowledge, and started `init`.
    The system hasn’t mounted any filesystems except for the root partition, which
    is mounted in read-only mode. The network isn’t started, no services are running,
    security is not implemented, and filesystem permissions are ignored.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: To boot OpenBSD in single-user mode, enter **`boot -s`** at the loader prompt.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Why would you want to boot into single-user mode? If your computer has a problem
    that is preventing it from booting, you should be able to access single-user mode
    and fix the problem. Suppose a failed disk is preventing the system from booting
    during a multiuser boot, or you changed your terminal settings in */etc/ttys*
    and now you can’t log on to the system. Or maybe you put a daft setting in *rc.conf.local*,
    and the boot process hangs because it’s trying to do something impossible. At
    times like these, single-user mode is your best friend.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Also, some system administration tasks, such as clearing filesystem flags (see
    [Chapter 8](ch08.html "Chapter 8. Disks and Filesystems")), can be done only in
    single-user mode.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Mounting Disks in Single-User Mode
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usually, you should have a fully functional filesystem before doing anything
    in single-user mode. If your system crashed, be sure to check the integrity of
    your filesystems before mounting them:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`fsck` and `mount` have many more options. We’ll cover them in more detail
    in [Chapter 8](ch08.html "Chapter 8. Disks and Filesystems").'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve mounted all of your filesystems, all usual command-line software
    should be available. You should be able to edit configuration files, start and
    stop programs, and generally do whatever you like to the system (including destroy
    it).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Network in Single-User Mode
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the shell script */etc/netstart* to configure the network while in singleuser
    mode. (You could run all the appropriate commands by hand, but */etc/netstart*
    will read your system’s configuration files and do the grunt work for you.) You
    must explicitly run this script through `sh`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you’re booting into single-user mode because of network problems, this script
    will conveniently reproduce the issue for you.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Booting an Alternate Kernel
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ll cover in tedious detail in [Chapter 18](ch18.html "Chapter 18. Kernel
    Configuration"), you *can* configure the OpenBSD kernel, but before you do so,
    be sure that you can boot alternate kernels. You’ll need to be able to boot a
    different kernel if, say, you hose your filesystem so badly that it won’t even
    boot to single-user mode, and you need to recover using the installation kernel.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Booting a Different Kernel File
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An OpenBSD installation includes three kernels out of the box: the single-processor
    kernel */bsd*, the multiprocessor kernel */bsd.mp*, and the upgrade and install
    kernel */bsd.rd*. (If your machine has multiple processors, the installer renames
    */bsd* to */bsd.sp* and */bsd.mp* to */bsd*.)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'To boot a nonstandard kernel, first reboot and interrupt the boot process at
    the boot loader prompt. Run `boot`, and give the full path to the kernel you want
    to boot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will start the system using your chosen kernel. You can use other boot
    options as well, such as booting the alternate kernel in single-user mode:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will let you recover from a bad kernel, try a new kernel, or anything in
    between.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Booting from an Alternate Hard Disk
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose you’ve really fouled everything up beyond all recognition, and you
    don’t have a usable kernel on your root partition. Fortunately, if you have a
    usable kernel on a different hard drive, you can boot from that. (Usually, this
    kernel lives on an alternate root partition, */altroot*, as discussed in [Chapter 8](ch08.html
    "Chapter 8. Disks and Filesystems").) In this section, I’ll break the task of
    booting from that alternate kernel into a few steps: finding the hard disk with
    the partition, finding the partition with the file, and booting the right file
    on that partition.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Disk
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you’re familiar with OpenBSD, you may begin to think of the hard drives
    in your system by their device names, such as */dev/sd0*, */dev/wd1*, and so on.
    Unfortunately, those are the kernel’s names for the disks; the boot loader recognizes
    only the BIOS’s disk names.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'To ask the boot loader about disks, use the `machine diskinfo` command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the boot loader has found four disk devices. The first, `fd0`, is a floppy
    disk drive. This drive might or might not have a disk in it, but whatever it has,
    it’s almost certainly not your alternate kernel. (It might be an installation
    disk, though, so don’t automatically rule out using it for disaster recovery.)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The other three devices—`hd0`, `hd1`, and `hd2`—are hard disks. The first, `hd0`,
    is the default system boot disk. If you can’t boot from that disk, you need to
    find the hard disk that contains your kernel.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Partition
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Vague stirrings of memory in this output lead me to think that `hd2` might
    be the disk that holds my backup root partition. To try it, tell the loader that
    disk partition `hd2a` is the new root partition:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Before trying to boot from this partition, look at its contents:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Apparently, disk `hd2` has no partition `a`. After service is restored, I’ll
    take this disk out behind my garage and beat its weakness out of it. For now,
    let’s try the only remaining disk, `hd1`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，磁盘 `hd2` 没有分区 `a`。在服务恢复后，我会把这块磁盘放在车库后面，把它的问题打掉。现在，让我们尝试剩下的唯一磁盘，`hd1`。
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This looks like an actual root partition (`altroot` offers a hint).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个实际的根分区（`altroot` 提供了提示）。
- en: Booting the Kernel
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 引导内核
- en: At this point, we could boot a different kernel, but we’ll just boot the */bsd*
    kernel on this partition in single-user mode, because the filesystem table would
    have the incorrect entry for the root filesystem, which would mess up all sorts
    of stuff.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以引导不同的内核，但我们将只以单用户模式引导这个分区上的 */bsd* 内核，因为文件系统表将会有错误的根文件系统条目，这会搞砸各种东西。
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, you could give the device name at the boot prompt:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以在引导提示符处给出设备名称：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As a general rule, you should mount the actual root partition on */mnt*, make
    the necessary changes for normal operation, and reboot into the proper root partition.
    You could also boot the */bsd.rd* kernel, giving you a cleaner boot at the cost
    of having fewer tools available.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，您应该在 */mnt* 上挂载实际的根分区，进行必要的更改以进行正常操作，然后重新引导到正确的根分区。您还可以引导 */bsd.rd* 内核，这将使引导更加干净，但可用的工具会减少。
- en: Making Boot Loader Settings Permanent
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将引导加载程序设置永久化
- en: To make boot loader options permanent, edit */etc/boot.conf*. The boot loader
    reads and runs entries from this file before giving you the `boot>` prompt, which
    means you can use it to automatically run boot loader commands every time your
    computer boots. (Although if you would rather sit at your computer and enter your
    settings every time you reboot, don’t let me stop you.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使引导加载程序选项永久化，请编辑 */etc/boot.conf*。引导加载程序在给您 `boot>` 提示符之前读取并运行此文件中的条目，这意味着您可以使用它来在每次计算机启动时自动运行引导加载程序命令。（尽管如果您宁愿每次重新启动时都坐在电脑前输入设置，请不要阻止我。）
- en: 'Any command you might give at the loader prompt is a valid *boot.conf* entry.
    For example, if the default boot speed is too slow for your liking, you can set
    your boot timeout to two seconds by adding this line to *boot.conf*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您在引导加载程序提示符下可能给出的任何命令都是有效的 *boot.conf* 条目。例如，如果默认的引导速度太慢，您可以通过在 *boot.conf*
    中添加此行来将引导超时设置为两秒：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can also tell the system to boot a different kernel with the correct *boot.conf*
    command.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用正确的 *boot.conf* 命令告诉系统引导不同的内核。
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By far, *boot.conf* is most often used to configure a serial console.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，*boot.conf* 最常用于配置串行控制台。
- en: Serial Consoles
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 串行控制台
- en: All of these nifty boot functions let you do useful stuff when your system is
    in trouble, but how can you use them when your computer isn’t right in front of
    you? If your computer is in a data center on the other side of the country, or
    sitting in the basement behind the last decade of payroll records, a serial console
    will make your life far more pleasant.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些巧妙的引导功能都让您在系统出现问题时能够做些有用的事情，但您如何在不坐在电脑前的情况下使用它们呢？如果您的电脑在国家的另一边的数据中心，或者坐在十年工资记录背后的地下室里，串行控制台会让您的生活更加愉快。
- en: A hardware serial console allows you to run a serial cable between a computer
    and a terminal server (on another computer) to access BIOS messages and operating
    system boot and startup messages which simplifies managing remote systems. Serial
    consoles are invaluable when debugging system crashes, too; error messages come
    over the serial port, where you can easily capture them.^([[12](#ftn.id418996)])
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件串行控制台允许您在计算机和终端服务器（在另一台计算机上）之间运行串行电缆，以访问 BIOS 消息和操作系统引导和启动消息，从而简化远程系统的管理。在调试系统崩溃时，串行控制台也极其宝贵；错误消息通过串行端口发送，您可以轻松地捕获它们。[^[[12](#ftn.id418996])]
- en: True UNIX hardware has serial console capabilities, as does most server-grade
    i386 and amd64 hardware. Most desktop-grade hardware, however, does not. But fortunately,
    even if you don’t have a hardware serial console, you can access all of OpenBSD’s
    startup messages with a serial port and a software serial console. While OpenBSD’s
    software serial console won’t give you access to the hardware BIOS, it will let
    you interface with the boot loader and remotely access the system console, even
    when the network is down.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的 UNIX 硬件具有串行控制台功能，大多数服务器级 i386 和 amd64 硬件也是如此。然而，大多数桌面级硬件则没有。但幸运的是，即使您没有硬件串行控制台，您也可以通过串行端口和软件串行控制台访问
    OpenBSD 的所有启动消息。虽然 OpenBSD 的软件串行控制台不会让您访问硬件 BIOS，但它会允许您与引导加载程序接口，并在网络断开时远程访问系统控制台。
- en: Other Platform Serial Consoles
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every hardware platform has its own standards for serial consoles. If you’re
    running a less common platform, check your hardware’s documentation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: If your hardware supports a real serial console, you should usually configure
    it in the BIOS. OpenBSD supports whatever the hardware supports, so your Sparc64
    hardware will support OpenBSD’s serial console just as well as it supports any
    other operating system’s serial console.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Serial Console Physical Setup
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A serial console requires a null modem cable, which you should be able to get
    from any computer store or an online vendor. While gold-plated cables aren’t worth
    the money, don’t buy the cheapest cable you can find either. If you have an emergency
    and need the serial console right *now*, you won’t be in the mood to deal with
    a defective cable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Plug one end of the null modem cable into your OpenBSD machine’s first serial
    port. (The serial console is supported on only the first serial port, or `com0`
    on i386 and amd64 hardware.) Plug the null modem cable’s other end into an open
    serial port on another system. (For simplicity’s sake, use either another OpenBSD
    or Unix-like system.)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: If you have two OpenBSD machines at a remote location and you want to use serial
    consoles on both, you can have each machine act as the console client for the
    other. Attach the first serial port on each server to the second serial port on
    the other. If you have three machines, you can daisy-chain them in a loop. If
    you have four or more machines, pick up a used terminal server from your favorite
    auction site.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: You can also use two DB9-to-RJ45 converters, one standard and one crossover,
    which will allow you to run your console connections over a standard CAT5 cable.
    If you have a lights-out data center where human beings are forbidden unless they
    are installing or removing equipment, you can stretch your serial console cables
    about 12 meters, which should reach into your warm room. (Most modern data facilities
    are better equipped to handle CAT5 cables than serial cables.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Serial Console Configuration
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have the console physically ready, the next step is to configure
    your client to access the serial console. Then you can set up the serial console.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Serial Console Client
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following are the default settings for an OpenBSD i386 or amd64 system:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 9600 baud
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 bits
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No parity
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 stop bit
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter these values into any terminal emulator on the client computer, and the
    serial console should Just Work. You can find terminal emulators for Microsoft
    platforms (I recommend PuTTY), OS X, and just about any other operating system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenBSD includes the terminal emulator `tip(1)`, which reads its configuration
    from */etc/remote*. The configuration `tty00` in */etc/remote* matches the default
    OpenBSD serial console configuration for i386 and amd64 systems (as well as several
    other platforms). If you’ve attached your null modem cable to the first serial
    port on the client, connect with this command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD包括终端模拟器`tip(1)`，它从`/etc/remote`读取其配置。`/etc/remote`中的`tty00`配置与i386和amd64系统的默认OpenBSD串行控制台配置相匹配（以及几个其他平台）。如果您将null调制解调器电缆连接到客户端的第一个串行端口，请使用以下命令连接：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If it doesn’t say `connected`, your serial client is misconfigured. Fix your
    client before enabling your serial console on the server. You want your serial
    client ready before configuring the console.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有显示`connected`，您的串行客户端配置不正确。在服务器上启用串行控制台之前，请修复您的客户端。您希望在配置控制台之前准备好串行客户端。
- en: Setting Up the Serial Console
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置串行控制台
- en: OpenBSD normally uses the local physical keyboard, video, and mouse as the console,
    but it can also use the first serial port as a serial console.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD通常使用本地物理键盘、视频和鼠标作为控制台，但它也可以使用第一个串行端口作为串行控制台。
- en: 'To set the console, use the boot loader. You must know the loader’s device
    name for your preferred console: `com0` for the first serial port or `pc0` for
    the physically attached video and keyboard.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置控制台，请使用引导加载程序。您必须知道您首选控制台的加载程序设备名称：`com0`用于第一个串行端口或`pc0`用于物理连接的视频和键盘。
- en: 'The first time you try to use a serial console, use a local test machine. Set
    up your client beforehand and start your terminal emulator, and then boot your
    test machine. At the boot loader prompt, enter this command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试使用串行控制台时，请使用本地测试机器。事先设置您的客户端并启动您的终端模拟器，然后引导测试机器。在引导加载程序提示符下，输入以下命令：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Your server’s monitor and keyboard should stop responding, and if you’ve set
    up everything correctly, you should see the boot loader prompt in your terminal
    emulator.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您服务器的显示器和键盘应该停止响应，如果您设置正确，您应该在终端模拟器中看到引导加载程序提示符。
- en: 'To switch back to the physical console, tell the boot loader to use the `pc0`
    device:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换回物理控制台，告诉引导加载程序使用`pc0`设备：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Poof! The server’s keyboard and monitor should work again.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 嘭！服务器的键盘和显示器应该又能工作了。
- en: 'To have your machine use the serial console at every boot, add this statement
    in */etc/boot.conf*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要在每次引导时让您的机器使用串行控制台，请在`/etc/boot.conf`中添加此语句：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Be sure to test your serial console after the machine is installed in its permanent
    location, and always screw the serial cables to the server. A loose serial cable
    provides only a comforting illusion that betrays you when it will hurt the most.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在机器安装到永久位置后测试您的串行控制台，并且始终将串行电缆拧紧在服务器上。松散的串行电缆只能提供一种安慰的错觉，但在最需要的时候会背叛您。
- en: Testing the Serial Configuration
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试串行配置
- en: 'After configuring your serial console, return to your serial client and press
    ENTER. You should see something like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置您的串行控制台后，返回您的串行客户端并按回车键。您应该看到类似以下内容：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Changing the Serial Console Speed
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改串行控制台速度
- en: Newer serial ports (meaning anything made within the past 10 years) can run
    at speeds far above 9600 baud. I have servers with serial consoles that run only
    at 115,200 baud. The BIOS messages display at 115,200 baud, but then the OpenBSD
    console runs at 9600 baud. My client displays one or the other as gibberish. (A
    lot of OpenBSD folks think that anything that won’t do serial at 9600 baud is
    broken, but you won’t always have control over the hardware you work with.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 较新的串行端口（意味着在过去10年内制造的任何端口）可以以远高于9600波特的速度运行。我有一些串行控制台运行速度仅为115,200波特的服务器。BIOS信息以115,200波特显示，但OpenBSD控制台以9600波特运行。我的客户端显示为乱码。（许多OpenBSD用户认为不能以9600波特进行串行通信的任何东西都是损坏的，但您并不总是能控制您所使用的硬件。）
- en: To use these ports, I can either change my connection speed in my serial console
    client when switching between the BIOS messages and the OpenBSD messages, or change
    the speed of my OpenBSD console to match the hardware.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些端口，我可以在在切换BIOS信息和OpenBSD信息时更改我的串行控制台客户端的连接速度，或者更改OpenBSD控制台的速度以匹配硬件。
- en: 'At the boot loader, tell the serial console to run at 115,200 baud:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在引导加载程序中，告诉串行控制台以115,200波特运行：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If these settings work, copy them to */etc/boot.conf*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些设置有效，请将它们复制到`/etc/boot.conf`。
- en: 'Now configure your serial client. Modify `tip` to use the higher speed. First,
    find the entry for `tty00` in */etc/remote*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在配置您的串行客户端。修改`tip`以使用更高的速度。首先，在`/etc/remote`中找到`tty00`条目：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: But don’t modify this entry! We’ll use it to illustrate the style of */etc/remote*
    entries.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*/etc/remote* is designed much like a `termcap(5)` database. If you ever need
    to write your own *`termcap`* entries from scratch, you’re living your life wrong.
    But you can recognize the contents and modify existing entries without much pain.
    If you really want to learn everything about these entries, read the *`remote(5)`*
    man page.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Backslashes (`\`) in this entry mean “continued on the next line.” Colons separate
    fields. Each line after the first must start with a colon, and each field is a
    key/value pair.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to create a console entry that runs at 115,200 baud, use the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first field in an */etc/remote* entry is the name, and every entry must
    have a unique name. I named this entry `console`. The second field is the `br`
    value. According to `remote(5)`, `br` stands for bit rate. I’ve set the bit rate
    to 115,200 baud. The third field is `tc`, for “table continues,” which is equal
    to `tty00`. This means that the description of this entry continues in entry `tty00`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Taken as a whole, this entry means “copy the `tty00` entry, and add a bit rate
    of 115,200.”
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Client Serial Port
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have two OpenBSD machines, each sending its serial console out its first
    serial port to the other machine’s second serial port, you must tell `tip` to
    connect to the second serial port. The command `tip tty00` doesn’t actually connect
    to the serial port named `tty00`—it connects to a port defined by the */etc/remote*
    entry named `tty00`. That means that you can’t run, say, `tip tty03` and connect
    to serial port tty03 unless you have an */etc/remote* entry named `tty03`. By
    default, there isn’t one, but you can define one easily, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This entry is named `tty01`. The `dv` setting tells */etc/remote* the physical
    device to use. Other than this, all settings are copied from the entry called
    `tty00`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: With these examples, you should be able to use OpenBSD’s `tip` to connect to
    almost any serial console.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Serial Logins
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The serial console lets you interact with the boot process. Once your machine
    is fully multiuser, however, a default serial console will not let you actually
    log in to OpenBSD. In multiuser mode, OpenBSD uses `getty(8)` to initialize terminals
    and handle logins, and in order to log in to your machine over a serial port,
    you will need to tell `getty` to take charge of the serial line by configuring
    */etc/ttys*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll discuss */etc/ttys* further in [Chapter 14](ch14.html "Chapter 14. Everything
    /etc"), but for now, here’s how to allow logins over the first serial port. Find
    the entry for `tty00`, which should look like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Remove the last two words, and replace them to match the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now run `kill -1 1`, and you should get a login prompt over your serial line.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Multiuser Startup
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the kernel finishes its core setup and hands control over to userland,
    `init(8)` runs the shell script */etc/rc*. This script handles all system setup,
    including mounting filesystems, configuring device nodes, identifying shared libraries,
    and any other task required to make the system usable. Some tasks are delegated
    to separate scripts; for example, */etc/netstart* is used to configure the network.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll cover how */etc/rc* and other startup scripts function,
    and the flow of the startup process. Armed with this understanding, you should
    be able to easily configure your OpenBSD machine to start exactly what you need—no
    more, no less.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Startup System Scripts
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The startup system includes the scripts */etc/rc*, */etc/rc.conf*, */etc/rc.conf.local*,
    */etc/netstart*, */etc/rc.securelevel*, */etc/rc.local*, */etc/rc.shutdown*, */etc/rc.firsttime*,
    */etc/fastboot*, and the contents of the */etc/rc.d* directory.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The /etc/rc Script
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On OpenBSD, everything outside the kernel is configured with a shell command,
    from setting the hostname to starting server daemons. The master script is */etc/rc*,
    and it runs all of these commands in the correct order, ensuring that the system
    is configured exactly the same way at every boot. As a final step, */etc/rc* runs
    `getty(8)` to present login prompts on all the appropriate terminals.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Never edit */etc/rc* unless you’re a very experienced systems administrator
    with truly unique needs. This is one of the several files in */etc* that is technically
    editable, but mere mortals are well advised to *treat as binary*. Instead, whenever
    you need to disable functions, deactivate them in */etc/rc.conf.local*. To add
    new functionality to the startup process, use the shell scripts */etc/rc.securelevel*
    and */etc/rc.local,* or write a shell script for */etc/rc.d*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The /etc/rc.conf Script
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The */etc/rc.conf* file contains nothing but the default values for all other
    startup scripts. Read this file to see the configuration options for different
    system services. Here’s a small snippet of what you’ll find in *rc.conf*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If a variable is set to `NO`, the associated service is disabled by default.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, OpenBSD turns off almost everything by default, with one exception:
    the SSH daemon. Setting the variable to a pair of quotes, as shown after each
    entry in the preceding snippet, is enough to enable most daemons, and most daemons
    will run just fine without any command-line flags. However, if a daemon requires
    a command-line argument in order to run, that argument will be shown as it is
    in the `-a` attached to `rarpd_flags`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the risk of beating my dead server senseless, never edit */etc/rc.conf* (treat
    as binary—remember?). It will be replaced wholesale during a system upgrade. Instead,
    place your local values in */etc/rc.conf.local*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The /etc/rc.conf.local Script
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I’ve mentioned this before, but I’m going to beat you over the head with it:
    Place your changes to *rc.conf* in *rc.conf.local*. Entries in *rc.conf.local*
    override the defaults in *rc.conf*.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say that on a particular machine, you want to run `sshd(8)` with
    extra debugging, and you also want to run `named(8)`. Additionally, you want to
    run the time server `ntpd(8)`, and have it correct the time at boot by using the
    `-s` flag. After consulting the documentation for those programs, you add the
    following lines to *rc.conf.local*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: OpenBSD will start the programs with the flags specified here. If you specify
    invalid, incorrect, or incompatible flags, the daemon will print error messages
    to the console.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The /etc/netstart Script
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While its name differs from the other scripts, */etc/netstart* is definitely
    a system startup script. It reads */etc/mygate*, */etc/myname*, and all the */etc/hostname.if*
    files, and uses the information in them to configure all network interfaces, bridges,
    routing, and so forth. The file */etc/rc* runs this script before starting any
    server daemons, network filesystems, and so on. In single-user mode, you’ll run
    this script by hand to bring up the network.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The /etc/rc.securelevel Script
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The */etc/rc.securelevel* shell script runs early in the boot process, before
    */etc/rc* raises the system securelevel, but after starting the network. Many
    programs, particularly those that touch the kernel or intimately affect the filesystem,
    will not run once the securelevel is raised. If you run such a program, you can
    add the command to start it to this script. If your local program doesn’t need
    to run before the system securelevel is raised, you’re better off starting it
    from *rc.local* or writing a proper *rc.d* script for it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: One important entry in *rc.securelevel* is the definition of the system securelevel.
    We’ll discuss securelevels in [Chapter 10](ch10.html "Chapter 10. Securing Your
    System"). For now, don’t touch the line that sets the securelevel unless you’re
    already familiar with BSD-based systems and know exactly which toe you’re shooting
    off.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The /etc/rc.local Script
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After */etc/rc* does just about everything else, it runs */etc/rc.local*. You
    can put commands to start local daemons in *rc.local*, but you’re better off writing
    an *rc.d* script to start local daemons so you can easily and consistently restart
    them later. Of course, if you’re lazy, you can get by with *rc.local*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The /etc/rc.shutdown Script
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whenever you use `reboot(8)` or `halt(8)`, OpenBSD runs the */etc/rc.shutdown*
    script, which you can count on to run extra commands needed to safely shut down
    your server. Most server software shuts down cleanly without any special intervention,
    but software that requires data integrity (like databases) may need help shutting
    down without losing data. Again, if at all possible, write an *rc.d* script to
    manage your software.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The /etc/rc.firsttime Script
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*/etc/rc* runs the script */etc/rc.firsttime* once, mails the output to root,
    and deletes *rc.firsttime*. The installer uses *rc.firsttime* for tasks such as
    fetching firmware that can’t be legally redistributed. While you won’t normally
    use *rc.firsttime*, you should know that it exists and that you can use it to
    perform one-time tasks when a machine boots.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The /etc/fastboot Script
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the */etc/fastboot* file exists, OpenBSD assumes that all filesystems are
    clean (see [Chapter 8](ch08.html "Chapter 8. Disks and Filesystems")), and the
    boot process skips checking filesystem integrity.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The /etc/rc.d Directory
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The */etc/rc.d* directory contains shell scripts for managing software, as discussed
    in the next section. While the system comes with scripts for software included
    in OpenBSD, add-on packages can provide their own scripts (see [Chapter 13](ch13.html
    "Chapter 13. Software Management")).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Software Startup Scripts
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenBSD uses shell scripts to start, stop, restart, check, and reconfigure server
    software. These scripts are found in the directory */etc/rc.d*. Every piece of
    server software that comes with OpenBSD has a script in this directory, as do
    most ports and packages that need scripts for proper startup and shutdown. Use
    these scripts to manage integrated software without rebooting the server.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The *rc.d* scripts read their configuration from *rc.conf* and *rc.conf.local*.
    Most servers run the SSH daemon `sshd`, which can be enabled by adding the line
    `sshd_enable=""` to *rc.conf.local*. Look in */etc/rc.d*, and you’ll find the
    shell script *sshd*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: If you change your `sshd` configuration, you must restart the daemon. Use the
    shell script to do this consistently.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Of course, you could do the same thing without the shell script simply by identifying
    the currently running `sshd(8)` process, reading the man page to see how to shut
    it down properly, and then restarting it with the same command-line flags. In
    the case of `sshd`, that’s easy: Running `pkill -1 sshd` would tell the daemon
    to reread its configuration file. But restarting a daemon that requires all sorts
    of flags *is* a big deal. Automating these system administration tasks ensures
    that your daemons run consistently.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'To see if a daemon is running, use the `check` command to check your shell
    for the return value. The script will return a `0` if the daemon is running and
    a `1` if it isn’t, as shown here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see by the `1`, `nfsd` is not running.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The most common use for `check` is in shell scripts. You can start the daemon
    with the argument `start` and terminate it with `stop`. Use the `restart` argument
    to tell the daemon to reload its configuration.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: In OpenBSD, *rc.d* scripts run when the system boots and again when it shuts
    down. (Something needs to unmount all those hard drives, shut down daemons, and
    clean up.) At shutdown, every script in the */etc/rc.d* folder is called with
    the `stop` argument.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Third-Party rc.d Scripts
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OpenBSD packages for third-party software include *rc.d* scripts as necessary.
    For example, the popular database server MySQL `mysql-server` package installs
    the script */etc/rc.d/mysqld*. To use the package, you must enable it in *rc.conf.local*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 的第三方软件包包括必要的 *rc.d* 脚本。例如，流行的数据库服务器 MySQL 的 `mysql-server` 软件包安装了脚本
    */etc/rc.d/mysqld*。要使用该软件包，你必须将其在 *rc.conf.local* 中启用：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once the package is enabled, you can manage your MySQL server just like any
    other OpenBSD daemon. However, packaged software will still not start automatically
    at boot, so you must tell OpenBSD to run this particular *rc.d* script at boot
    and shut down with the `pkg_scripts` variable in *rc.conf.local*:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用该软件包，你就可以像管理任何其他 OpenBSD 守护进程一样管理你的 MySQL 服务器。然而，软件包化的软件在启动时仍然不会自动启动，所以你必须告诉
    OpenBSD 在启动时运行这个特定的 *rc.d* 脚本，并在 *rc.conf.local* 中的 `pkg_scripts` 变量中关闭：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The startup process runs the scripts in this variable, in the order given, at
    boot. The order is important for certain daemons. For example, if you have a database-driven
    website, you should start the database before the web server. At shutdown, it
    runs these scripts in reverse order.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 启动过程在启动时按给定顺序运行此变量中的脚本。对于某些守护进程，顺序很重要。例如，如果你有一个数据库驱动的网站，你应该在启动 web 服务器之前启动数据库。在关闭时，它以相反的顺序运行这些脚本。
- en: Force-Starting Software
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制启动软件
- en: Sometimes you don’t want to enable software globally; you just want to run a
    certain daemon for a short time or to address a specific situation. You can use
    *rc.d* scripts to manage this software using the `-f` flag to force the software
    to run.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你不想全局启用软件；你只想运行某个守护进程一段时间或解决特定情况。你可以使用 *rc.d* 脚本通过 `-f` 标志强制软件运行。
- en: 'Now for a real-life example. I previously ran PostgreSQL on my server, but
    someone kidnapped my pet rats and blackmailed me into using MySQL in exchange
    for their safe return. I needed to check some data in the old database, however,
    so I force-started the disabled PostgreSQL server:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个现实生活中的例子。我之前在我的服务器上运行 PostgreSQL，但有人绑架了我的宠物老鼠，并威胁我使用 MySQL 以换取它们的平安归来。然而，我需要检查旧数据库中的某些数据，所以我强制启动了禁用的
    PostgreSQL 服务器：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you package or install your own software, I strongly recommend writing your
    own *rc.d* script. A few minutes spent reading the existing scripts will tell
    you most of what you need to know. For the rest, read the `rc.d(8)` and `rc.subr(8)`
    man pages.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打包或安装自己的软件，我强烈建议编写你自己的 *rc.d* 脚本。花几分钟阅读现有的脚本将告诉你你需要知道的大部分内容。对于其余部分，请阅读 `rc.d(8)`
    和 `rc.subr(8)` 手册页。
- en: Now that you can start OpenBSD, let’s set up some user accounts.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以启动 OpenBSD 了，让我们设置一些用户账户。
- en: '* * *'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[11](#id369126)]) On i386 and amd64 systems, this is where the MBR comes
    in.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[11](#id369126)]) 在 i386 和 amd64 系统上，这就是 MBR 出现的地方。
- en: ^([[12](#id418996)]) Granted, a remote keyboard-video-mouse (KVM) system can
    give you all of this, but very few KVM applications let you copy and paste text
    from the remote console. That means you’ll need to copy error messages by hand.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[12](#id418996)]) 当然，一个远程键盘视频鼠标（KVM）系统可以给你所有这些功能，但非常少的 KVM 应用程序允许你从远程控制台复制和粘贴文本。这意味着你需要手动复制错误信息。
