- en: Chapter 4. Arrays and Hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Up to now, you’ve generally been using objects one at a time. In this chapter,
    you’ll find out how to create a list of objects. You’ll start by looking at the
    most common type of list structure: an array.'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An *array* is a sequential collection of items in which each item can be indexed.
    In Ruby (unlike many other languages), a single array can contain items of mixed
    data types such as strings, integers, and floats or even a method call that returns
    some value. For example, the final element in `a1` shown here calls my method,
    `array_length`, which returns the length of the array, `a0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*array0.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first item in an array has the index 0, which means the final item has
    an index equal to the total number of items in the array minus 1\. Given the array
    `a1`, shown previously, this is how to obtain the values of the first and last
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ve already used arrays a few times—for example, in *2adventure.rb* you
    used an array to store a map of Room objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like many other programming languages, Ruby uses square brackets to delimit
    an array. You can easily create an array, fill it with some comma-delimited values,
    and assign it to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As with most other things in Ruby, arrays are objects. They are defined, as
    you might guess, by the Array class and, just like strings, they are indexed from
    0\. You can reference an item in an array by placing its index between square
    brackets. If the index is invalid, `nil` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '*array1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Displaying nil
  prefs: []
  type: TYPE_NORMAL
- en: 'When you attempt to display a `nil` value using `print` or `puts`, Ruby 1.8
    displays “nil,” whereas Ruby 1.9 displays an empty string. If you want to be sure
    that the string representation of `nil` is displayed, use `p` or the `inspect`
    method instead of `print`. You may also display its class (`nil` is an instance
    of `NilClass`) or test whether it is `nil` using the `nil?` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*array1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: 'An array may include expressions that yield values. Let’s assume you have already
    created this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*array2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now declare this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first element is a mathematical expression that yields the integer
    3, and the second is the string “hello world” (returned by the method `hello`).
    If you run this on Windows, the third array element will be a string containing
    a directory listing. This is because `` `dir` `` is a back-quoted string, which
    is executed by the operating system (see [Chapter 3](ch03.html "Chapter 3. Strings
    and Ranges")). The final “slot” in the array is, therefore, filled with the value
    returned by the `dir` command, which happens to be a string of filenames. If you
    are running on a different operating system, you may need to substitute an appropriate
    command at this point. (For example, if you’re running a Unix-like operating system,
    you could substitute `` `ls` `` to get a similar string of filenames.)
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Array of Filenames
  prefs: []
  type: TYPE_NORMAL
- en: 'A number of Ruby classes have methods that return arrays of values. For example,
    the `Dir` class, which is used to perform operations on disk directories, has
    the `entries` method. Pass a directory name to the method, and it returns a list
    of files in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*dir_array.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create an array of single-quoted strings but can’t be bothered
    to type all the quotation marks, a shortcut is to put unquoted text separated
    by spaces between parentheses preceded by `%w` (or use a capital `%W` for double-quoted
    strings, as explained in [Chapter 3](ch03.html "Chapter 3. Strings and Ranges")).
  prefs: []
  type: TYPE_NORMAL
- en: '*array2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code assigns the array shown next to the variable, `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create arrays using the usual object construction method, `new`.
    Optionally, you can pass an integer to `new` to create an empty array of a specific
    size (with each element set to `nil`), or you can pass two arguments: the first
    to set the size of the array and the second to specify the element to place at
    each index of the array, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Multidimensional Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a multidimensional array, you can create one array and then add other
    arrays to each of its “slots.” For example, this creates an array containing two
    elements, each of which is itself an array of two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also create an Array object by passing an array as an argument to the
    `new` method. Be careful, though: Ruby considers it a syntax error if you fail
    to leave a space between the `new` method and the opening square bracket. In other
    words, this works: `a = Array.new [1,2,3]`. However, this doesn’t: `a = Array.new[1,2,3]`.
    But using parentheses always works, no matter where you put a space: `a = Array.new([1,2,3])`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to nest arrays inside one another using square brackets.
    This creates an array of four arrays, each of which contains four integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, I have placed the four “subarrays” on separate lines.
    This is not obligatory, but it does help clarify the structure of the multidimensional
    array by displaying each subarray as though it were a row, similar to the rows
    in a spreadsheet. When talking about arrays within arrays, it is convenient to
    refer to each nested array as a “row” of the “outer” array.
  prefs: []
  type: TYPE_NORMAL
- en: 'For some more examples of using multidimensional arrays, load the *multi_array.rb*
    program. This starts by creating an array, `multiarr`, containing two other arrays.
    The first of these arrays is at index 0 of `multiarr`, and the second is at index
    1:'
  prefs: []
  type: TYPE_NORMAL
- en: '*multi_array.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next you need to find some way to locate the individual elements within arrays,
    which are themselves contained inside other arrays. You’ll consider this problem
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can access the elements of an array by iterating over them using a `for`
    loop. In many programming languages, a `for` loop counts over a fixed number of
    elements from a starting number (such as 0) to an ending number (such as 10),
    incrementing a counter variable (such as `i`) at each pass through the loop. So,
    in other languages, you might be used to writing a loop something like this: `for
    i = 1 to 10`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ruby, the normal `for` loop counts over all the items *in* a collection
    and may be referred to as a `for..in` loop. Its counter variable is assigned each
    object in a collection, one by one, at each pass through the loop. The syntax
    may be summarized as `for` *`anObject`* `in` *`aCollection`*, and at each turn
    through the loop, the variable `anObject` is assigned a new item from the collection
    `aCollection` until no more items remain. The loop shown next iterates over two
    elements, namely, the two subarrays at index 0 and 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So, how do you iterate over the items (the strings and integers) in each of
    the two subarrays? If there is a fixed number of items, you could specify a different
    iterator variable for each, in which case each variable will be assigned the value
    from the matching array index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you have four subarray slots, so you could use four variables like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also use a `for` loop to iterate over all the items in each subarray
    individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '*multi_array2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these techniques (multiple iterator variables and multiple `for` loops)
    have two requirements: that you know how many items there are in either the “rows”
    or the “columns” of the grid of arrays and that each subarray contains the same
    number of items as each other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more flexible way of iterating over multidimensional arrays, you could
    use nested `for` loops. An outer loop iterates over each row (subarray), and an
    inner loop iterates over each item in the current row. This technique works even
    when subarrays have varying numbers of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You’ll be looking at `for` loops and other iterators in more depth in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing into Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with strings (see [Chapter 3](ch03.html "Chapter 3. Strings and Ranges")),
    you can index from the end of an array using negative numbers, where −1 is the
    index of the last element, −2 is the second-to-last, and so on. You can also use
    ranges, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*array_index.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that the output displayed by `print` or `puts` may vary depending on your
    version of Ruby. When Ruby 1.8 displays the elements in an array, it shows them
    one after the other so they look like a single string, as in `hello`. Ruby 1.9,
    however, shows the items in array format, as in `["h", "e", "l", "l", "o"]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use `p` instead of `print` to inspect the array, both Ruby 1.8 and 1.9
    display the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As with strings, when you provide two integers in order to return a number
    of contiguous items from an array, the first integer is the start index, while
    the second is a *count* of the number of items (*not* an index):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also make assignments by indexing into an array. Here, for example,
    I first create an empty array and then put items into indexes 0, 1, and 3\. The
    “empty” slot at index 2 will be filled with a `nil` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '*array_assign.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, you can use start-end indexes, ranges, and negative index values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Copying Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note that when you use the assignment operator (`=`) to assign one array variable
    to another variable, you are actually assigning a *reference* to the array; you
    are not making a copy. For example, if you assign one array called `arr1` to another
    array called `arr2`, any changes made to either variable will also alter the value
    of the other because *both variables refer to the same array*. If you want the
    variables to reference two different arrays, you can use the `clone` method to
    make a new copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '*array_copy.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Testing Arrays for Equality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The comparison operator for arrays is `<=>`. This compares two arrays—let’s
    call them `arr1` and `arr2`. It returns −1 if `arr1` is less than `arr2`, it returns
    0 if `arr1` and `arr2` are equal, and it returns 1 if `arr2` is greater than `arr1`.
    But how does Ruby determine whether one array is “greater than” or “less than”
    another? It compares each item in one array with the corresponding item in the
    other. When two values are not equal, the result of their comparison is returned.
    In other words, if this comparison were made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: the value −1 would be returned. This means the first array is “less than” the
    second, since the integer at index 1 of the first array (10) is less than the
    integer at index 1 in the second array (20).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to make a comparison based on the array’s length rather than the
    value of its elements, you can use the `length` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you are comparing arrays of strings, then comparisons are made on the ASCII
    values of the characters that make up those strings. If one array is longer than
    another and the elements in both arrays are equal, then the longer array is deemed
    to be “greater.” However, if two such arrays are compared and one of the elements
    in the shorter array is greater than the corresponding element in the longer array,
    then the *shorter* array is deemed to be greater.
  prefs: []
  type: TYPE_NORMAL
- en: '*array_compare.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Sorting Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `sort` method compares adjacent array elements using the comparison operator
    `<=>`. This operator is defined for many Ruby classes, including Array, String,
    Float, Date, and Fixnum. The operator is not, however, defined for *all* classes
    (that is to say, it is not defined for the Object class from which all other classes
    are derived). One of the unfortunate consequences of this is that it cannot be
    used to sort arrays containing `nil` values. However, it is possible to get around
    this limitation by defining your own sorting routine. This is done by sending
    a *block* to the `sort` method. You’ll learn about blocks in detail in [Chapter 10](ch10.html
    "Chapter 10. Blocks, Procs, and Lambdas"), but for now it’s enough to know a block
    is a chunk of code delimited either by curly brackets or by the keywords `do`
    and `end`. The following block determines the comparison used by the `sort` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here `arr` is an array object, and the variables `a` and `b` represent two contiguous
    array elements. I’ve converted each variable to a string using the `to_s` method;
    this converts `nil` to an empty string that will be sorted “low.” Note that although
    my sorting block defines the sort order of the array items, it does not change
    the array items themselves. So, `nil` will remain as `nil`, and integers will
    remain as integers. The string conversion is used only to implement the comparison,
    not to change the array items.
  prefs: []
  type: TYPE_NORMAL
- en: '*array_sort.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the array created and displayed by the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The *array_sort.rb* program supplied in the code archive also contains a method
    to sort in descending order. This is done simply by changing the order of the
    items on either side of the comparison operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Comparing Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The comparison “operator” `<=>` (which is, in fact, a method) is defined in
    the Ruby module named `Comparable`. For now, you can think of a module as a sort
    of reusable code library. You’ll be looking more closely at modules in [Chapter 12](ch12.html
    "Chapter 12. Modules and Mixins").
  prefs: []
  type: TYPE_NORMAL
- en: 'You can include the `Comparable` module in your own classes. This lets you
    override the `<=>` method to enable you to define exactly how comparisons will
    be made between specific object types. For example, you may want to subclass Array
    so that comparisons are made based purely on the length of two arrays rather than
    on the value of each item in the array (which is the default, as explained in
    See Testing Arrays for Equality). This is how you might do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*comparisons.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can initialize two MyArray objects like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can use the `<=>` method defined in MyArray to make comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This comparison returns 0, which indicates that the two arrays are equal (since
    our `<=>` method evaluates equality according to length alone). If, on the other
    hand, you were to initialize two standard arrays with exactly the same integer
    values, the Array class’s own `<=>` method would perform the comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here the comparison returns −1, which indicates that the first array evaluates
    to “less than” the second array, since the Array class’s `<=>` method compares
    the numerical values of each item in `arr1` and these are less than the values
    of the items at the same indexes in `arr2`.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you want to make “less than,” “equal to,” and “greater than” comparisons
    using the traditional programming notation?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the MyArray class, you can make comparisons of this sort without writing
    any additional code. This is because the `Comparable` module, which has been included
    in the MyArray class, automatically supplies these three comparison methods; each
    method makes its comparison based on the definition of the `<=>` method. Since
    our `<=>` makes its evaluation based on the number of items in an array, the `<`
    method evaluates to true when the first array is shorter than the second, `==`
    evaluates to true when both arrays are of equal length, and `>` evaluates to true
    when the second array is longer than the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The standard Array class does not include the `Comparable` module. So if you
    try to compare two ordinary arrays using `<`, `==`, or `>`, Ruby will display
    an error message telling you that the method is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it’s easy to add these three methods to a subclass of Array. All you
    have to do is include Comparable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The Array2 class will now perform its comparisons based on the `<=>` method
    of Array—that is, by testing the values of the items stored in the array rather
    than merely testing the length of the array. Assuming that the Array2 objects,
    `arr1` and `arr2`, are initialized with the same arrays that you previously used
    for `myarr1` and `myarr2`, you would now see these results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Array Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several of the standard array methods modify the array itself rather than returning
    a modified copy of the array. These include the methods marked with a terminating
    exclamation point, such as `sort!`, `reverse!`, `flatten!`, and `compact!`. These
    also include the `<<` method, which modifies the array to its left by adding to
    it the array on its right; `clear`, which removes all the elements from the given
    array; and `delete` and `delete_at`, which remove selected elements. [Table 4-1](ch04.html#commonly_used_array_methods
    "Table 4-1. Commonly Used Array Methods") shows some of the more commonly used
    Array methods.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1. Commonly Used Array Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Array | Task |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | Returns common elements of two arrays, no duplicates |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Returns array concatenating two arrays |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | Returns array with items in second array removed from first |'
  prefs: []
  type: TYPE_TB
- en: '| `<<` | Modifies first array by appending items from second array |'
  prefs: []
  type: TYPE_TB
- en: '| `clear` | Modifies array by removing all elements |'
  prefs: []
  type: TYPE_TB
- en: '| `compact` | Returns array with `nil` items removed |'
  prefs: []
  type: TYPE_TB
- en: '| `compact!` | Modifies array by removing `nil` items |'
  prefs: []
  type: TYPE_TB
- en: '| `delete( object )` | Modifies array by deleting object |'
  prefs: []
  type: TYPE_TB
- en: '| `delete_at( index )` | Modifies array by deleting item at index |'
  prefs: []
  type: TYPE_TB
- en: '| `flatten` | Unpacks nested array items and returns array |'
  prefs: []
  type: TYPE_TB
- en: '| `flatten!` | Modifies array by unpacking nested array items |'
  prefs: []
  type: TYPE_TB
- en: '| `length` | Returns number of elements in array |'
  prefs: []
  type: TYPE_TB
- en: '| `reverse` | Returns array with elements in reverse order |'
  prefs: []
  type: TYPE_TB
- en: '| `reverse!` | Modifies array by reversing element order |'
  prefs: []
  type: TYPE_TB
- en: '| `sort` | Returns array sorted using `<=>` |'
  prefs: []
  type: TYPE_TB
- en: '| `sort!` | Modifies array sorted using `<=>` |'
  prefs: []
  type: TYPE_TB
- en: 'You can try the previous methods in the *array_methods.rb* sample program.
    Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '*array_methods.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Although most of the behavior array methods may be deduced from their names,
    the `flatten` and `compact` methods need some explanation. An array is said to
    be *flattened* when it contains no subarrays. So if you have an array like `[1,[2,3]]`,
    you can call `[1,[2,3]].flatten` to return this array: `[1,2,3]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An array is said to be *compacted* when it contains no `nil` items. So if you
    have an array like `[1,2,nil,3]`, you can call `[1,2,nil,3].compact` to return
    this array: `[1,2,3]`. The methods of Array can be chained together by placing
    one method call directly after the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '*flatten_compact.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although arrays provide a good way of indexing a collection of items by number,
    sometimes it would be more convenient to index them in some other way. If, for
    example, you were creating a collection of recipes, it would be more meaningful
    to have each recipe indexed by name, such as “Rich Chocolate Cake” and “Coq au
    Vin,” rather than by numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby has a class that lets you do just that, called a *hash*. This is the equivalent
    of what some other languages call a dictionary or associative array. Just like
    a real dictionary, each entry is indexed by a unique *key* (in a real-life dictionary,
    this would be a word) that is associated with a value (in a dictionary, this would
    be the definition of the word).
  prefs: []
  type: TYPE_NORMAL
- en: Creating Hashes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like an array, you can create a hash by creating a new instance of the
    Hash class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash1.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Both the previous examples create an empty Hash object. A Hash object always
    has a default value—that is, a value that is returned when no specific value is
    found at a given index. In these examples, `h2` is initialized with the default
    value `"Some kind of ring"`; `h1` is not initialized with a value, so its default
    value will be `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having created a Hash object, you can add items to it using an arraylike syntax—that
    is, by placing the index in square brackets and using `=` to assign a value. The
    obvious difference is that, with an array, the index (or *key*) must be an integer;
    with a hash, it can be any unique data item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, the key may be a number or, as in the previous code, a string. In principle,
    however, a key can be any type of object. For example, given some class X, the
    following assignment is perfectly legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Unique Keys?
  prefs: []
  type: TYPE_NORMAL
- en: 'Take care when assigning keys to hashes. If you use the same key twice in a
    hash, you will end up overwriting the original value. This is just like assigning
    a value twice to the same index in an array. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the key `''treasure1''` has been used twice. As a consequence, the original
    value, `''Silver ring''`, has been replaced by `''Sapphire ring''`, resulting
    in this hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a shorthand way of creating Hashes and initializing them with key-value
    pairs. Just add a key followed by `=>` and its associated value; each key-value
    pair should be separated by a comma and the whole lot placed inside a pair of
    curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Indexing into a Hash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To access a value, place its key between square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you specify a key that does not exist, the default value is returned. Recall
    that you have not specified a default value for `h1`, but you have for `h2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `default` method to get the default value and the `default=` method
    to set it (see [Chapter 2](ch02.html "Chapter 2. Class Hierarchies, Attributes,
    and Class Variables") for more information on `get` and `set` accessor methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Copying a Hash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with an array, you can assign one Hash variable to another, in which case
    both variables will refer to the same hash, and a change made using either variable
    will affect that hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash2.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want the two variables to refer to the same items in different Hash
    objects, use the `clone` method to make a new copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Hash Order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ordering of elements in a hash varies according to which version of Ruby
    you are using. In Ruby 1.8, a hash is generally stored in the order defined by
    its key where, for example, key 1 is less than key 2\. When new items are added,
    these are inserted in key order. In Ruby 1.9, the hash is stored in the order
    in which it is defined. When new items are added, these are appended to the end
    of the hash.
  prefs: []
  type: TYPE_NORMAL
- en: As a general principle, it is best to make no assumptions about the order of
    elements in a hash. Most programming languages treat hashes or dictionaries as
    unordered collections. If you make the assumption that hash order is unpredictable,
    not only will you avoid bugs that may occur when running programs with different
    Ruby implementations, but you will also avoid problems that may arise when keys
    are of different types. Remember, a single hash may contain a mix of integer,
    string, and floating-point keys whose relative orders may not be self-evident.
  prefs: []
  type: TYPE_NORMAL
- en: '*hash_order.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'When this code is run, Ruby 1.8 produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'But Ruby 1.9 shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Sorting a Hash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to ensure that the elements of a hash are in a specific order,
    you may sort them. As with the Array class, you may find a slight problem with
    the `sort` method of Hash. It expects to be dealing with keys of the same data
    type, so if, for example, you merge two arrays, one of which uses integer keys
    and another of which uses strings, you won’t be able to sort the merged hash.
    The solution to this problem is, as with Array, to write some code to perform
    a custom type of comparison and pass this to the `sort` method. You might give
    it a method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash_sort.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This performs the sort based on the string representation (`to_s`) of each key
    in the hash. In fact, the Hash `sort` method converts the hash to a nested array
    of *[key, value]* arrays and sorts them using the Array `sort` method.
  prefs: []
  type: TYPE_NORMAL
- en: Hash Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Hash class has numerous built-in methods. For example, to delete an item
    from a hash using its key, use the `delete` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To combine two hashes, use the `merge` method: `hash1.merge( hash2 )`.'
  prefs: []
  type: TYPE_NORMAL
- en: To return a new hash created using the original hash’s values as keys and its
    keys as values, use `aHash.invert`. To return an array populated with the hash’s
    keys or values, use `aHash.keys` and `aHash.values`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that uses some of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash_methods.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to find the position of an item in a hash, use the `index` method
    with Ruby 1.8 and the `key` method in Ruby 1.9\. The `index` method is still present
    in Ruby 1.9 but is deprecated, so it may be removed in future versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Digging Deeper
  prefs: []
  type: TYPE_NORMAL
- en: In this section you will learn more ways of manipulating arrays and hashes as
    well as the fundamentals of matrices, vectors and sets.
  prefs: []
  type: TYPE_NORMAL
- en: Treating Hashes as Arrays
  prefs: []
  type: TYPE_NORMAL
- en: 'The `keys` and `values` methods of Hash each return an array, so you can use
    various Array methods to manipulate them. Here are a few simple examples (remember
    the order of the keys and value may differ according to the version of Ruby being
    used):'
  prefs: []
  type: TYPE_NORMAL
- en: '*hash_ops.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Appending vs. Concatenating
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful to note the difference between concatenating using `+` to add the
    *values* from the second array to the first and appending using `<<` to add the
    second *array* itself as the final element of the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '*append_concat.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In addition, `<<` modifies the first (the *receiver*) array, whereas `+` returns
    a new array but leaves the receiver array unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In object-oriented terminology, the object to which a method belongs is called
    the *receiver*. The idea is that instead of calling functions as in procedural
    languages, “messages” are sent to objects. For example, the message `+ 1` might
    be sent to an integer object, while the message `reverse` might be sent to a string
    object. The object that “receives” a message tries to find a way (that is, a *method*)
    of responding to the message. A string object, for example, has a `reverse` method
    and so is able to respond to the `reverse` message, whereas an integer object
    has no such method so cannot respond.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `flatten` method to clean up two arrays you’ve combined with
    `<<`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Vectors and Matrices
  prefs: []
  type: TYPE_NORMAL
- en: For the benefit of mathematicians, Ruby provides a Vector class and a Matrix
    class. A *vector* is an ordered set of elements upon which certain mathematical
    operations may be performed. A *matrix* is a collection of rows and columns, and
    each row is itself a vector. Matrices allow you to perform matrix manipulations,
    which is a subject beyond the scope of this book and is only likely to be of interest
    to mathematical programmers. However, you’ll look at some simple examples here.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, given two Matrix objects, `m1` and `m2`, you can add the values of each
    corresponding cell in the matrices with the plus sign, like this: `m3 = m1+m2`.
    You must import Matrix using a `require` directive in order to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '*matrix.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example creates a matrix from two vectors. By passing vectors
    to the `Matrix.columns()` method, you construct a matrix whose rows are arrays
    of arrays. Here the matrix has two columns created from the vectors `v` and `v2`,
    with each row containing two items, one from each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If, on the other hand, you pass the same two vectors to the `Matrix.rows()`
    method, you would end up by creating a matrix that contains two rows, each of
    which is a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Sets
  prefs: []
  type: TYPE_NORMAL
- en: 'The Set class implements a collection of unordered values with no duplicates.
    You can initialize a Set with an array of values, in which case duplicates are
    ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '*sets.rb*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add new values using the `add` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `merge` method combines values of one set with another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `==` to test for equality. Two sets that contain the same values
    (remembering that duplicates will be removed when a set is created) are considered
    to be equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If you display the contents of a set, the order may differ according to the
    version of Ruby being used. If order is important, you may convert a set to an
    array using the `to_a` method and use a standard or custom sort, as explained
    in [Sorting Arrays](ch04.html#sorting_arrays "Sorting Arrays") in [Sorting Arrays](ch04.html#sorting_arrays
    "Sorting Arrays"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
