<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;GEOCODING"><div class="titlepage"><div><div><h1 class="title"><a id="geocoding"/>Chapter 3. GEOCODING</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e2544"/><img src="httpatomoreillycomsourcenostarchimages671943.png.jpg" alt="image with no caption"/></div></div><p>I've demonstrated some fun map examples in the first two chapters of this book, but there's been an elephant in the room. Those latitude and longitude points I explained in <a class="xref" href="ch01s02.html" title="Describe a Point on the Earth">Describe a Point on the Earth</a> in <a class="xref" href="ch01s02.html" title="Describe a Point on the Earth">Describe a Point on the Earth</a> are obviously useful to a computer, but not to humans. How often have you been invited to a party at a location designated by only geographic coordinates?</p><p>In this chapter, I'll show how you can take something that makes sense to you—addresses, city names, and even postal codes—and turn them into the latitude and longitude points that Mapstraction needs. The conversion is called <span class="emphasis"><em>geocoding</em></span>, and we'll look at several methods you can put to use in your own mapping projects.<a id="IDX-CHP-3-0001" class="indexterm"/></p><div class="sect1" title="How Do Geocoders Work?"><div class="titlepage"><div><div><h1 class="title"><a id="how_do_geocoders_work_question"/>How Do Geocoders Work?</h1></div></div></div><p>At first glance, a geocoder looks like an oracle. You pass it an address, it looks into its crystal ball, and then it replies with a pair of numbers. Like magic, the coordinates, when plotted on a map, are exactly where the address is located. Let's take a look behind the curtain and see how a geocoder works.<a id="IDX-CHP-3-0002" class="indexterm"/></p><p>As with most magic, you may be disappointed to find out that most geocoding is really just estimation. Geocoding isn't elegant—it's sort of brute force.</p><p>First, the geocoder breaks the address into pieces. For example, consider Graceland's address:</p><div class="blockquote"><blockquote class="blockquote"><p>3734 Elvis Presley Blvd, Memphis, TN</p><p>Street number, Street name, Suffix, City, State</p></blockquote></div><p>The city is important because, believe it or not, other cities have an Elvis Presley Blvd. When you think of even more common names (say, Main Street), you can see how this step becomes important. In fact, within cities a road's suffix can be an issue, with a single street name being an Avenue, Street, Circle, and more. If you think those variations are confusing while navigating, think about how they confuse a geocoder.</p><p>A street name match might be the toughest part of fixing a location. Dealing with misspellings and other ways of formatting a name can be difficult. Like many other major cities, my hometown of Portland, Oregon, has a street named after Martin Luther King, Jr. The street, both in Portland and in other cities, is commonly referred to as <span class="emphasis"><em>MLK</em></span>. Whether a geocoder should recognize this abbreviation is debatable, but that gives you an idea of the sort of things you have to consider.</p><p>Now that you've zeroed in on the correct street and know its city, you need to find the actual address on the street. Storing every last address in the world isn't necessary and would be difficult since new ones are created all the time. Instead, most geocoders use street segments, as shown in <a class="xref" href="ch03.html#geocoders_use_street_segments_to_estimat" title="Figure 3-1. Geocoders use street segments to estimate location.">Figure 3-1</a>.</p><div class="figure"><a id="geocoders_use_street_segments_to_estimat"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e2596"/><img src="httpatomoreillycomsourcenostarchimages671983.png.jpg" alt="Geocoders use street segments to estimate location."/></div></div><p class="title">Figure 3-1. Geocoders use street segments to estimate location.</p></div><p>Using our Graceland example, we might know that a segment of Elvis Presley Blvd begins at 3700 and ends at 3799. We also know the latitude and longitude points at each end of the segment. Using those pieces of information, we can estimate that Graceland, at 3734, is about a third of the way between 3700 and 3799. Using the two points, the geocoder can then calculate an approximate location.<a id="IDX-CHP-3-0003" class="indexterm"/><a id="IDX-CHP-3-0004" class="indexterm"/><a id="IDX-CHP-3-0005" class="indexterm"/></p></div></div>
<div class="sect1" title="JavaScript vs. HTTP Geocoding"><div class="titlepage"><div><div><h1 class="title"><a id="javascript_vs._http_geocoding"/>JavaScript vs. HTTP Geocoding</h1></div></div></div><p>In this chapter, I will cover two major methods of retrieving latitude and longitude results from an address: via a JavaScript geocoding API or via a geocoding web service over HTTP. On the surface, these methods are very similar because the data that comes back is the same. The difference is in what you can do with the results.</p><p><span class="emphasis"><em>JavaScript geocoders</em></span> call an external server with client-side code, meaning the code runs in the browser. This method is the same one used by Mapstraction and every mapping API. In this sense, JavaScript geocoders are extremely convenient for the web-mapping developer.</p><p><span class="emphasis"><em>HTTP geocoders</em></span> also call an external server, but do so from your server, so the code runs outside the browser. This method is similar to the one used by PHP, the web programming language I've employed to show examples in <a class="xref" href="ch09.html" title="Chapter 9. GO SERVER-SIDE">Chapter 9</a>. In fact, you might use PHP to interpret the results from an HTTP geocoder.</p><p>Why would you use one type of geocoder over another? The quality of the data is similar, assuming the geocoders come from the same provider (i.e., Google). A JavaScript geocoder is usually just a wrapper for a server-side geocoder. In other words, both types end up calling upon the same dataset.</p><p>The decision about which geocoder to use comes down to how much freedom you want with input and output. You can use a JavaScript geocoder in only a narrow band of ways. The input likely comes from the user via a form. The output almost certainly goes to a web page or to a map on the web page.</p><p>Most of your location data will end up on a map, of course. You may want to do many things before that happens, however. Gaining control of the output is the biggest reason why you would use an HTTP geocoder. When the result is retrieved server-side, you have the option to store it to a database, cache the data, share the data over SMS or email, or send it off to a third-party service. Some of these options may be possible with a JavaScript geocoder, but they aren't easy to implement because they are outside the JavaScript geocoder's normal use—inside the browser.</p><p>By using an HTTP geocoder, you control where you get your input. For example, you might retrieve it from a database, a third-party service, or a list of addresses. With a JavaScript geocoder, the input likely comes directly from data the user enters in an input box on a website. For many uses, that's all you'll need, but other times you'll want more freedom.</p><p>If you spend enough time producing web maps, you'll probably combine JavaScript and HTTP geocoding. The rest of this chapter will focus on the different services you can use as you convert human-readable addresses to geographic coordinates (and vice versa).<a id="IDX-CHP-3-0006" class="indexterm"/><a id="IDX-CHP-3-0007" class="indexterm"/></p></div>
<div class="sect1" title="#12: Geocode with JavaScript"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_12_colon_geocode_with_java"/>#12: Geocode with JavaScript</h1></div></div></div><p>When you want geocoding that stays within the web browser, you use JavaScript, the same programming language used by Mapstraction and every mapping provider it supports. You can retrieve a city name or address from a user and send it off to be geocoded. The response goes to a JavaScript callback function that you declare.</p><p>As with mapping APIs, you can choose your own JavaScript geocoder. Predictably, I'll show Mapstraction's geocoder, which will use whichever provider you specify and give you the same flexibility that you get from using Mapstraction for creating maps: Write the code once and easily switch between providers.<a id="IDX-CHP-3-0008" class="indexterm"/></p><p>Because not every map requires geocoding, the geocoder is kept separate from the main Mapstraction code. Also, not every provider has a geocoder, so each is stored individually. In this example, we'll be using Google. You can download <code class="literal">mxn.google.geocoder.js</code> from <a class="ulink" href="http://mapstraction.com/">http://mapstraction.com/</a>.</p><p>You include the Mapstraction geocoder in your code much like you include your mapping provider and Mapstraction proper. Add this line (assuming the file is in the current directory) within the <code class="literal">&lt;head&gt;</code> section of your basic map:</p><a id="I_programlisting3_d1e2675"/><pre class="programlisting">&lt;script src="mxn.google.geocoder.js"&gt;&lt;/script&gt;</pre><p>With the script included, use this code to initialize the map, geocode an address, and mark the result on the map:</p><a id="I_programlisting3_d1e2679"/><pre class="programlisting">var mapstraction, geocoder;
  function create_map() {
    mapstraction = new mxn.Mapstraction('mymap', 'googlev3');
    geocoder = new MapstractionGeocoder(❶add_point, ❷'googlev3');
    // Create address object
❸   var address = {
      street : "38 Ringold Street",
      locality : "San Francisco",
      region : "CA",
      country : "US"
    };
❹   geocoder.geocode(address);
  }
  function add_point(loc) {
    var mk = new mxn.Marker(❺loc.point);
    mk.setInfoBubble(❻loc.address);
    mapstraction.addMarker(mk);
    mk.openBubble();
    mapstraction.autoCenterAndZoom();
  }</pre><p>As with most map examples in this book, I use the <code class="literal">create_map</code> function to initialize the map. You can name this function whatever you want, as long as the function is called when the page loads.<a id="IDX-CHP-3-0009" class="indexterm"/></p><p>To create the Mapstraction geocoder object, we need to provide a callback function ❶ and tell Mapstraction which provider ❷ we want to use (the provider's JavaScript still needs to be included). The callback function receives the geocoded results. First, we need to give an address or city name to the geocoder.</p><p>We create a generic JavaScript object ❸ to hold the textual location information. Then, we add attributes for the parts of the address. The names may be slightly odd because Mapstraction is attempting to work not just in your country but around the world.</p><p>Once the address's parts are filled in, you can send it to the geocoder ❹. Then, your callback function will be passed the results as a location object, which itself has some attributes of interest. Most important is the <code class="literal">LatLonPoint</code> of the address ❺. In this example, I've used the point to create a new marker.</p><p>The marker needs a description, which I'll put inside a message box. I'm using the full address ❻, which the geocoder has cleaned up. As you can see in <a class="xref" href="ch03s03.html#geocoded_results_of_no_starch_press_offi" title="Figure 3-2. Geocoded results of No Starch Press offices">Figure 3-2</a>, the geocoder has added the ZIP Code, converted "Street" to "St" and refers to the country as "USA" instead of "US."</p><div class="figure"><a id="geocoded_results_of_no_starch_press_offi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e2708"/><img src="httpatomoreillycomsourcenostarchimages671985.png.jpg" alt="Geocoded results of No Starch Press offices"/></div></div><p class="title">Figure 3-2. Geocoded results of No Starch Press offices</p></div><p>Of course, this example is only so useful. The address is hard-coded. You will likely be taking input from a user.<a id="IDX-CHP-3-0010" class="indexterm"/><a id="IDX-CHP-3-0011" class="indexterm"/><a id="IDX-CHP-3-0012" class="indexterm"/><a id="IDX-CHP-3-0013" class="indexterm"/><a id="IDX-CHP-3-0014" class="indexterm"/></p><div class="sect2" title="Geocode User Input"><div class="titlepage"><div><div><h2 class="title"><a id="geocode_user_input"/>Geocode User Input</h2></div></div></div><p>JavaScript geocoders most commonly require user input to be helpful. Let's tweak the code from the previous section to take a textual location from an input box and geocode it.</p><p>To start, you'll need a place for the user to enter data. Let's add a form to our HTML, either above or below the map <code class="literal">div</code>:</p><a id="I_programlisting3_d1e2744"/><pre class="programlisting">&lt;form id="addrform"&gt;
  &lt;input type="text" id="newpt" /&gt;
  &lt;input type="submit" id="butnew" value="Geocode" /&gt;
&lt;/form&gt;</pre><p>Now we need to do something when the user types in an address or city name. Here's a new version of the <code class="literal">create_map</code> function with a few changes:</p><a id="I_programlisting3_d1e2751"/><pre class="programlisting">function create_map() {
    mapstraction = new mxn.Mapstraction('mymap', 'googlev3');
    mapstraction.setCenterAndZoom(new mxn.LatLonPoint(0, 0), 1);
    mapstraction.addSmallControls();
    geocoder = new MapstractionGeocoder(add_point,'google');
❶     document.getElementById('addrform').onsubmit = function() {
      var address = {
❷     document.getElementById('newpt').value
      }
      geocoder.geocode(address);
      return false; // avoids posting form to the server
    };
  }</pre><p>We can't geocode until we get input, which won't happen until the user submits the form. So we wait for submission ❶ and then jump into action with an anonymous function. We could have used a named function, but with only a few lines writing the code inline is easiest.</p><p>In the previous section, I separated each piece of the address. In the case of input from a user, that is not always possible. Instead, I've provided the entire value of the input box to the geocoder ❷.</p><p>The callback function, <code class="literal">add_point</code>, can remain the same. Enter an address and it adds a marker to the geocoded point. Do it again and now you have two markers. This geocoding could get addicting.</p></div></div>
<div class="sect1" title="#13: Geocode with an HTTP Web Service"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_13_colon_geocode_with_an"/>#13: Geocode with an HTTP Web Service</h1></div></div></div><p>JavaScript is convenient when you want to geocode in the browser. You gain more control of your geocoding by using a web service, however. The addresses can come from anywhere, including a list of places. The results can be stored anywhere, including a database, so you can access them anytime and plot them on a map.<a id="IDX-CHP-3-0015" class="indexterm"/><a id="IDX-CHP-3-0016" class="indexterm"/><a id="IDX-CHP-3-0017" class="indexterm"/><a id="IDX-CHP-3-0018" class="indexterm"/><a id="IDX-CHP-3-0019" class="indexterm"/></p><p>Several geocoders are available to choose from, including one each from Google and Yahoo!. The input for each is slightly different, as are the results. In the next sections, I outline how to use these two geocoders and point you to a few others.</p><div class="sect2" title="Use Google's Geocoding Web Service"><div class="titlepage"><div><div><h2 class="title"><a id="use_google_apostrophy_s_geocoding_web_se"/>Use Google's Geocoding Web Service</h2></div></div></div><p>Google is the king of the web-mapping world, so of course, Google has a geocoding web service. You can use it to convert an address or city into latitude and longitude points and grab the result in one of several data formats. As an added benefit, Google pretties up the address for you and provides multiple options when the query is ambiguous.<a id="IDX-CHP-3-0020" class="indexterm"/></p><p>One of the additional freedoms of using a web service to geocode is that you can look at results in a web browser, without writing any actual code. Check out the following URL in your browser:</p><a id="I_programlisting3_d1e2802"/><pre class="programlisting">http://maps.google.com/maps/geo?<strong class="userinput"><code>q</code></strong>=38+Ringold+Street+San+Francisco+CA&amp;<strong class="userinput"><code>output</code></strong>
=xml&amp;<strong class="userinput"><code>sensor</code></strong>=false</pre><p>The parameters you can send to Google are shown in bold, along with all possible parameters that are shown in <a class="xref" href="ch03s04.html#google_geocoder_parameters" title="Table 3-1. Google Geocoder Parameters">Table 3-1</a>. The entire address is passed as the <code class="literal">q</code> query argument. You could also simply include a city name or postal code here.</p><div class="table"><a id="google_geocoder_parameters"/><p class="title">Table 3-1. Google Geocoder Parameters</p><div class="table-contents"><table summary="Google Geocoder Parameters" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Parameter</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">q</code></p></td><td style="text-align: left" valign="top"><p><span class="emphasis"><em>Required</em></span>. Query to search, such as address or city name</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">sensor</code></p></td><td style="text-align: left" valign="top"><p><span class="emphasis"><em>Required</em></span>. Whether from a mobile device: <code class="literal">true</code> or <code class="literal">false</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">output</code></p></td><td style="text-align: left" valign="top"><p>Format of results: <code class="literal">json</code> (default), <code class="literal">xml</code>, <code class="literal">kml</code>, or <code class="literal">csv</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">gl</code></p></td><td style="text-align: left" valign="top"><p>Country code as a top-level domain. E.g., <code class="literal">us</code>, <code class="literal">ca</code>, <code class="literal">uk</code></p></td></tr></tbody></table></div></div><p>The <code class="literal">output</code> we want is XML, which can be read by most any programming language. And unless you are using this geocoder from a mobile device, set <code class="literal">sensor</code> to false.</p><p>Now let's look at the XML results from the above call to Google's HTTP geocoder:<a id="IDX-CHP-3-0021" class="indexterm"/><a id="IDX-CHP-3-0022" class="indexterm"/><a id="IDX-CHP-3-0023" class="indexterm"/><a id="IDX-CHP-3-0024" class="indexterm"/></p><a id="I_programlisting3_d1e2921"/><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
 &lt;kml &gt;
   &lt;Response&gt;
     &lt;name&gt;37.7740486,-122.4101883&lt;/name&gt;
     &lt;Status&gt;
       &lt;code&gt;200&lt;/code&gt;
       &lt;request&gt;geocode&lt;/request&gt;
     &lt;/Status&gt;
❶    &lt;Placemark id="p1"&gt;
❷     &lt;address&gt;38 Ringold St, San Francisco, CA 94103, USA&lt;/address&gt;
       &lt;AddressDetails Accuracy="8"
                       &gt;
        &lt;Country&gt;
         &lt;CountryNameCode&gt;US&lt;/CountryNameCode&gt;
         &lt;CountryName&gt;USA&lt;/CountryName&gt;
         &lt;AdministrativeArea&gt;
❸         &lt;AdministrativeAreaName&gt;CA&lt;/AdministrativeAreaName&gt;
           &lt;Locality&gt;
❹           &lt;LocalityName&gt;San Francisco&lt;/LocalityName&gt;
             &lt;Thoroughfare&gt;
❺             &lt;ThoroughfareName&gt;38 Ringold St&lt;/ThoroughfareName&gt;
             &lt;/Thoroughfare&gt;
             &lt;PostalCode&gt;
❻             &lt;PostalCodeNumber&gt;94103&lt;/PostalCodeNumber&gt;
             &lt;/PostalCode&gt;
           &lt;/Locality&gt;
         &lt;/AdministrativeArea&gt;
       &lt;/Country&gt;
     &lt;/AddressDetails&gt;
     &lt;ExtendedData&gt;
       &lt;LatLonBox north="37.7773156" south="37.7710204"
                  east="-122.4071324" west="-122.4134276" /&gt;
     &lt;/ExtendedData&gt;
     &lt;Point&gt;
❼     &lt;coordinates&gt;-122.4102800,37.7741680,0&lt;/coordinates&gt;
     &lt;/Point&gt;
   &lt;/Placemark&gt;
  &lt;/Response&gt;
 &lt;/kml&gt;</pre><p>The results are actually in <span class="emphasis"><em>Keyhole Markup Language</em></span> (KML), a flavor of XML (see <a class="xref" href="ch08s04.html" title="#55: Use KML">#55: Use KML</a> in <a class="xref" href="ch08s04.html" title="#55: Use KML">#55: Use KML</a>). The coordinates and other information about the geocoded place are stored as Placemarks. In our example, we only have one Placemark ❶, because only one result is possible for a complete address. In ambiguous cases (say we searched for simply "Springfield"—many places have that name), the best result will be listed as the first Placemark, with others receiving incremented ids (i.e., p2, p3, etc.).<a id="IDX-CHP-3-0025" class="indexterm"/></p><p>In fact, if you want your application to show possible results, as <a class="ulink" href="http://maps.google.com/">http://maps.google.com/</a> does, use the full formatted address ❷ of each Placemark. You can see here that Google cleaned up even my specific address, converting the "Street" to "St" and adding the postal code.<a id="IDX-CHP-3-0026" class="indexterm"/><a id="IDX-CHP-3-0027" class="indexterm"/><a id="IDX-CHP-3-0028" class="indexterm"/><a id="IDX-CHP-3-0029" class="indexterm"/></p><p>The pieces of the address can also be accessed individually, yet the tag names might seem strange to you. That's because Google has made them generic, so the tags aren't confusing to people not in the United States. The state abbreviation ❸ is called an <span class="emphasis"><em>Administrative Area Name</em></span>, for example.</p><p>Accessing the values individually makes showing just the city ❹ or only the address ❺ easier. Also, accessing them individually is a quick way to determine a place's postal code ❻ (called a ZIP Code in the US).</p><p>Finally, the most important part of geocoding is the latitude and longitude points. These points are stored together within a single tag ❼. You can use a split function (one using PHP is shown in the next section) to retrieve the coordinates' individual pieces.</p><p>Did you notice that Google provides three numbers instead of just two? The third represents altitude and is a property of the KML format. The geocoder does not send this value, so it will always be zero.<a id="IDX-CHP-3-0030" class="indexterm"/></p><p>If you need help bringing these geocoder results into your applications, <a class="xref" href="ch09.html" title="Chapter 9. GO SERVER-SIDE">Chapter 9</a> can show you how to do so in PHP. Or, if you only need the coordinates, read on to see Google's approach to really simple geocoding.</p><div class="sect3" title="Alternate Data Formats"><div class="titlepage"><div><div><h3 class="title"><a id="alternate_data_formats"/>Alternate Data Formats</h3></div></div></div><p>I love XML, but it's not always the preferred data format. Google's web service geocoder gives you a choice of several formats, including JavaScript Object Notation (JSON) and comma-separated values (CSV). The latter is great when you want "just the facts."<a id="IDX-CHP-3-0031" class="indexterm"/></p><p>Plop an <code class="literal">output</code> argument in the URL and set its value to be the desired format, for example:</p><a id="I_programlisting3_d1e2985"/><pre class="programlisting">http://maps.google.com/maps/geo?q=38+Ringold+St+San+Francisco
+CA&amp;output=<strong class="userinput"><code>csv</code></strong>&amp;sensor=false</pre><p>Here, we ask for CSV. Unlike other result formats, we don't get a rewritten address, a postal code, or any other niceties. We do, however, get the four most important values separated by commas:</p><a id="I_programlisting3_d1e2992"/><pre class="programlisting">200,8,37.7741680,-122.4102800</pre><p>The first part is the code from the server. A <code class="literal">200</code> means we have a good result. Anything else, and we likely have an error.</p><p>The second part is a number that represents the granularity of our result. Is it street-level (an address), postal-level, or city-level? The possible results are roughly equivalent to zoom levels, as shown in <a class="xref" href="ch03s04.html#levels_codes_for_geocoding_accuracy" title="Table 3-2. Levels Codes for Geocoding Accuracy">Table 3-2</a>.</p><div class="table"><a id="levels_codes_for_geocoding_accuracy"/><p class="title">Table 3-2. Levels Codes for Geocoding Accuracy</p><div class="table-contents"><table summary="Levels Codes for Geocoding Accuracy" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Code<a id="IDX-CHP-3-0032" class="indexterm"/><a id="IDX-CHP-3-0033" class="indexterm"/></p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>0</p></td><td style="text-align: left" valign="top"><p>Unknown</p></td></tr><tr><td style="text-align: left" valign="top"><p>1</p></td><td style="text-align: left" valign="top"><p>Country</p></td></tr><tr><td style="text-align: left" valign="top"><p>2</p></td><td style="text-align: left" valign="top"><p>State (or similar region)</p></td></tr><tr><td style="text-align: left" valign="top"><p>3</p></td><td style="text-align: left" valign="top"><p>County (or other subregion)</p></td></tr><tr><td style="text-align: left" valign="top"><p>4</p></td><td style="text-align: left" valign="top"><p>City</p></td></tr><tr><td style="text-align: left" valign="top"><p>5</p></td><td style="text-align: left" valign="top"><p>Postal code</p></td></tr><tr><td style="text-align: left" valign="top"><p>6</p></td><td style="text-align: left" valign="top"><p>Street</p></td></tr><tr><td style="text-align: left" valign="top"><p>7</p></td><td style="text-align: left" valign="top"><p>Intersection</p></td></tr><tr><td style="text-align: left" valign="top"><p>8</p></td><td style="text-align: left" valign="top"><p>Address</p></td></tr><tr><td style="text-align: left" valign="top"><p>9</p></td><td style="text-align: left" valign="top"><p>Building (such as landmarks)</p></td></tr></tbody></table></div></div><p>The last two numbers of the CSV results might look familiar. They are the latitude and longitude points (in that order). These results are probably the most important because geocoding is all about turning a city name or address into plotable coordinates.</p><p>Here's some simple PHP code that calls out to the Google geocoder web service, parses the CSV results, and saves the coordinates to variables:</p><a id="I_programlisting3_d1e3101"/><pre class="programlisting">&lt;?
  $url = "http://maps.google.com/maps/geo?q=38+Ringold+St+San+Francisco+CA";
❶ $url += "&amp;output=csv&amp;sensor=false";
  $csvtxt = ❷get_url($url);
  $llarray = ❸explode(",", $csvtxt);
  if (❹count($llarray) == 4 &amp;&amp; ❺$llarray[0] == "200") {
    $lat = $llarray[2];
    $lon = $llarray[3];
    // Now do something here with the $lat and $lon variables
  }
  // Additional PHP code/functions could go here
 ?&gt;</pre><p>This code is just a snippet to give you an idea of how to separate simple CSV results like those in this example. If you run this code, nothing will happen because all I have shown here is storing the results in variables.</p><p>To begin, we create a variable to hold the URL we'll use to call Google. Because the variable is long and this book's pages are only so wide, I split it into two lines ❶, but to PHP, the variable is all one text string.</p><p>The URL is then passed to the <code class="literal">get_url</code> function ❷, one I will show you how to write in <a class="xref" href="ch09s03.html" title="#61: Retrieve a Web Page">#61: Retrieve a Web Page</a> in <a class="xref" href="ch09s03.html" title="#61: Retrieve a Web Page">#61: Retrieve a Web Page</a>. You'll need to include a file with that code or paste a copy of the function near the bottom of your PHP file.</p><p>Once we have a result from Google, we explode the text ❸ into several pieces, all stored in a single array variable. Because a comma is used to separate the data, that's the delimiter we'll use to split the text.<a id="IDX-CHP-3-0034" class="indexterm"/><a id="IDX-CHP-3-0035" class="indexterm"/><a id="IDX-CHP-3-0036" class="indexterm"/></p><p>With the pieces stored as elements of an array, we're almost ready to get our latitude and longitude. We need to make sure the array variable has four results ❹, as expected. Also, the first number in the results needs to be <code class="literal">200</code> ❺, the code for a good result.</p><p>Because arrays in PHP start counting at the zeroth spot, our latitude and longitude are stored as the second and third indexes of the explode result variable. With very little PHP code and even less text, you've now successfully turned an address into geographic coordinates.</p></div></div><div class="sect2" title="Use Yahoo!'s Geocoding Web Service"><div class="titlepage"><div><div><h2 class="title"><a id="use_yahoo_exclamation_apostrophy_s_geoco"/>Use Yahoo!'s Geocoding Web Service</h2></div></div></div><p>Though Google may get the lion's share of the press, Yahoo's geo-developer tools are exceptional. Such is the case with its easy-to-use, full-featured geocoding web service. You pass a city name or full address and Yahoo! spits out simple XML with coordinates and other geographic data.<a id="IDX-CHP-3-0037" class="indexterm"/></p><p>Because the result is just plain XML, you can check it out in your web browser to get a feel for how the service works. Visit this URL:</p><a id="I_programlisting3_d1e3148"/><pre class="programlisting">http://local.yahooapis.com/MapsService/V1/geocode?<strong class="userinput"><code>appid</code></strong>=<em class="replaceable"><code>YOURKEY</code></em>&amp;
<strong class="userinput"><code>street</code></strong>=38+Ringold+St&amp;<strong class="userinput"><code>city</code></strong>=San+Francisco&amp;<strong class="userinput"><code>state</code></strong>=CA</pre><p>The arguments are shown in bold. You'll need your API key as the <code class="literal">appid</code>. This ID is the same as for the Yahoo! Maps API. I showed you how to sign up for an ID in <a class="xref" href="ch01s03.html#create_a_yahoo_exclamation_map" title="Create a Yahoo! Map">Create a Yahoo! Map</a> in <a class="xref" href="ch01s03.html#create_a_yahoo_exclamation_map" title="Create a Yahoo! Map">Create a Yahoo! Map</a>.</p><p>In this example, the pieces of the address are segmented into <code class="literal">street</code>, <code class="literal">city</code>, and <code class="literal">state</code>. You can also use a single argument for an address, similar to Google's geocoder:</p><a id="I_programlisting3_d1e3185"/><pre class="programlisting">http://local.yahooapis.com/MapsService/V1/geocode?appid=<em class="replaceable"><code>YOURKEY</code></em>&amp;
<strong class="userinput"><code>location</code></strong>=38+Ringold+St+San+Francisco+CA</pre><p>The <code class="literal">location</code> argument contains all the pieces in the previous example but puts them in one place. If you are receiving an address as input from a user, you will prefer this option unless you have a way to separate the address into pieces (such as multiple form fields).</p><p>No matter which way you call the API, the results will be formatted the same way:</p><a id="I_programlisting3_d1e3200"/><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;ResultSet ...&gt;
  &lt;Result precision="address"&gt;
    &lt;Latitude&gt;37.774155&lt;/Latitude&gt;
    &lt;Longitude&gt;-122.410230&lt;/Longitude&gt;
    &lt;Address&gt;38 Ringold St&lt;/Address&gt;
    &lt;City&gt;San Francisco&lt;/City&gt;
    &lt;State&gt;CA&lt;/State&gt;
    &lt;Zip&gt;94103-4403&lt;/Zip&gt;
    &lt;Country&gt;US&lt;/Country&gt;
  &lt;/Result&gt;
&lt;/ResultSet&gt;</pre><p>Compared to Google's XML results, these results are very simple. The latitude and longitude are shown separately, as are the pieces of the address (even if you send the location as one string of text, Yahoo! separates things out for you). Each field makes sense as long as you are geocoding addresses or cities in the United States. In Canada, for example, you have to know that provinces are stored in the <code class="literal">&lt;state&gt;</code> tag.<a id="IDX-CHP-3-0038" class="indexterm"/><a id="IDX-CHP-3-0039" class="indexterm"/><a id="IDX-CHP-3-0040" class="indexterm"/></p><p>If your search has ambiguous results, such as a non-unique city name, Yahoo! will put the best result first. Other results will follow inside their own <code class="literal">&lt;Result&gt;</code> tag.</p><p>Because you're working with simple XML here, you can parse them as you would any other XML. <a class="xref" href="ch08.html#number_symble_52_colon_use_xml" title="#52: Use XML">#52: Use XML</a> in <a class="xref" href="ch08.html#number_symble_52_colon_use_xml" title="#52: Use XML">#52: Use XML</a> shows this process in PHP and JavaScript. If you want other formats, Yahoo! does provide results as JSON or Serialized PHP. The first is covered in <a class="xref" href="ch08s02.html" title="#53: Use JSON">#53: Use JSON</a> in <a class="xref" href="ch08s02.html" title="#53: Use JSON">#53: Use JSON</a>, whereas the second is explained at <a class="ulink" href="http://developer.yahoo.com/common/phpserial.html/">http://developer.yahoo.com/common/phpserial.html/</a>.</p></div><div class="sect2" title="Other Geocoding Web Services"><div class="titlepage"><div><div><h2 class="title"><a id="other_geocoding_web_services"/>Other Geocoding Web Services</h2></div></div></div><p>The previous examples show the two most likely choices for geocoders, but you have other options, especially if you are willing to pay for the service. Why shell out dough when Google and Yahoo! give away geocoding? Your choice really comes down to the terms of service and rate limits, which can restrict your use of a geocoder for high traffic, commercial purposes.</p><p>You won't necessarily need to crush that piggy bank to use a for-pay geocoder. For example, <span class="emphasis"><em>geocoder.us</em></span> only charges a quarter of a US cent to geocode an address. For an up-to-date list of geocoder services, see <a class="ulink" href="http://mapscripting.com/geocoders/">http://mapscripting.com/geocoders/</a>.<a id="IDX-CHP-3-0041" class="indexterm"/></p></div></div>
<div class="sect1" title="#14: Reverse Geocoding: Get an Address from a Point"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_14_colon_reverse_geocoding"/>#14: Reverse Geocoding: Get an Address from a Point</h1></div></div></div><p>So far we have used human-readable information—a city name or address—to retrieve latitude and longitude points, which are easier for a computer to understand. From time to time, you may want to go the other way. If all you have is a set of coordinates, you can use them to reverse geocode to get the address and other geographic information that will make sense to a human.</p><p>Regular geocoding is complicated and imprecise, but reverse geocoding is more so. First, the geocoder finds the street that is closest to the coordinates; then, it determines which address belongs to that point. Truthfully, the result is more often a range of addresses.<a id="IDX-CHP-3-0042" class="indexterm"/></p><p>Reverse geocoding may seem a little silly given that it is imperfect. But as location becomes more prevalent on the Web, reverse geocoding will become more common. For example, consider <a class="xref" href="ch07s02.html" title="#48: Get Location Using JavaScript">#48: Get Location Using JavaScript</a> in <a class="xref" href="ch07s02.html" title="#48: Get Location Using JavaScript">#48: Get Location Using JavaScript</a>. In many cases, the GPS or other device reporting someone's whereabouts will only provide the latitude and longitude points. That information is enough to plot it on a map, but not enough to make much sense to humans viewing the information.<a id="IDX-CHP-3-0043" class="indexterm"/><a id="IDX-CHP-3-0044" class="indexterm"/><a id="IDX-CHP-3-0045" class="indexterm"/><a id="IDX-CHP-3-0046" class="indexterm"/><a id="IDX-CHP-3-0047" class="indexterm"/></p><p>In the following sections, I'll show two services, both from Google, that will provide reverse geocoding, helping you create geographic information from computer-readable data.</p><div class="sect2" title="Reverse Geocode with JavaScript"><div class="titlepage"><div><div><h2 class="title"><a id="reverse_geocode_with_javascript"/>Reverse Geocode with JavaScript</h2></div></div></div><p>If you use Google as your mapping provider, reverse geocoding can happen within your JavaScript code without even loading Mapstraction's geocoder (which only supports <span class="emphasis"><em>forward</em></span> geocoding). In this example, we'll still use Mapstraction because the reverse geocoding is only a small part of a map's code.</p><p>Let's create a basic Mapstraction map, with Google as the provider. We'll convert the center of the map to a Google point and send it off to be reverse geocoded.</p><p>Assuming you have your HTML set up as in <a class="xref" href="ch01s03.html#create_a_mapstraction_map" title="Create a Mapstraction Map">Create a Mapstraction Map</a> in <a class="xref" href="ch01s03.html#create_a_mapstraction_map" title="Create a Mapstraction Map">Create a Mapstraction Map</a>, here is the JavaScript to create the map and call the Google geocoder:</p><a id="I_programlisting3_d1e3310"/><pre class="programlisting">var mapstraction;
 function create_map() {
   mapstraction = new mxn.Mapstraction('mymap', 'googlev3');
   mapstraction.setCenterAndZoom(
     new mxn.LatLonPoint(37.7740486,-122.4101883), 15);
   // Google-specific calls
❶  var geocoder = new GclientGeocoder();
   geocoder.getLocations(❷mapstraction.getCenter().toProprietary(mapstraction.api),
      ❸found_address);
 }
 function found_address(response) {
   if (response &amp;&amp; ❹response.Status.code == 200) {
❺    var pt = response.Placemark[0].Point;
     var marker = new mxn.Marker(new mxn.LatLonPoint(pt.coordinates
[1], pt.coordinates[0]));
     marker.setInfoBubble(❻response.Placemark[0].address);
     mapstraction.addMarker(marker);
     marker.openBubble();
   }
 }</pre><p>As promised, much of this code is comprised of Mapstraction functions. The Google-specific calls are separated out. For example, we create a geocoder object ❶ and then make the call to get the location. Even this contains some Mapstraction, as we use it to get the center of the map ❷ and convert that point to one Google understands.</p><p>With the call to the geocoder, we need to provide a callback function ❸. This function is used when the result comes back from Google. Because we created a named function, we also need to create the function with that name.<a id="IDX-CHP-3-0048" class="indexterm"/><a id="IDX-CHP-3-0049" class="indexterm"/><a id="IDX-CHP-3-0050" class="indexterm"/><a id="IDX-CHP-3-0051" class="indexterm"/><a id="IDX-CHP-3-0052" class="indexterm"/></p><p>The <code class="literal">found_address</code> function takes one argument, which is the results object that Google's geocoder sends to us. Once we've determined we have a good response ❹ (a status code of <code class="literal">200</code>), we can grab the point ❺, which contains our coordinates.</p><p>You might wonder why the point is even necessary, seeing as this is the piece of data that you started with. In many cases, Google isn't able to find an address at your <span class="emphasis"><em>exact</em></span> point (imagine the center of a large park, for example), so it chooses one nearby. In that case, you'll want to know the point it used, so you can plot accordingly.</p><p>Google might actually send multiple results, which would be stored in the <code class="literal">response.Placemark</code> array. The first is its best guess and probably the one to use, though in some situations you could allow the user to select the most accurate result.</p><p>Most of the remaining code in <code class="literal">found_address</code> will look familiar, as it's standard Mapstraction functions from <a class="xref" href="ch02.html" title="Chapter 2. PLOTTING MARKERS AND MESSAGE BOXES">Chapter 2</a>. We put a marker at the location Google returned. Then, we use the most important piece of information, the address ❻, as the message inside the marker's box.</p><p>To get a good feel for reverse geocoding, try changing the coordinates you pass to Google by altering the center of the map. Or, read on to make a map that reverse geocodes wherever you click.</p></div><div class="sect2" title="Reverse Geocode in a Click"><div class="titlepage"><div><div><h2 class="title"><a id="reverse_geocode_in_a_click"/>Reverse Geocode in a Click</h2></div></div></div><p>Want to play around with reverse geocoding? Attempting to click exactly on your own address to see how close you can come to your exact location can be fun. Also, giving yourself quick access to reverse geocoding can be a good developer tool to get a better idea of how the process works.</p><p>You can use most of the previous example. In fact, <code class="literal">found_address</code> can stay exactly the same. Replace the <code class="literal">create_map</code> function with this slightly altered version:</p><a id="I_programlisting3_d1e3378"/><pre class="programlisting">function create_map() {
   mapstraction = new mxn.Mapstraction('mymap', 'googlev3');
❶  mapstraction.addSmallControls();
   mapstraction.setCenterAndZoom(
     new mxn.LatLonPoint(37.7740486,-122.4101883), 15);
❷  mapstraction.addEventListener('click', function(clickpoint) {
     // Google-specific calls
     var geocoder = new GclientGeocoder();
     geocoder.getLocations(❸clickpoint.toProprietary
(mapstraction.api), found_address);
   });
 }</pre><p>I added some zoom controls ❶ to the map, so you can find specific places to click (in San Francisco, unless you change the map's center or scroll the map to another location). Then I wrote some code that waits for a click event ❷ on the map. When the click occurs, it calls an anonymous, inline function. This function could be named, but with only a few simple lines, writing it inline is easier.<a id="IDX-CHP-3-0053" class="indexterm"/><a id="IDX-CHP-3-0054" class="indexterm"/></p><p>Within the anonymous function, we make a call to the Google geocoder very similar to the one we used before. In this instance, we pass the point where the user clicked ❸ instead of the center of the map. Note that we need to convert the point to the proprietary Google coordinate type because Mapstraction captures the clickpoint but then needs to pass it off to a Google geocoder. Mapstraction speaks Google, but Google does not speak Mapstraction.</p><p>Because the other code is the same, clicking the map adds a marker with the address in an opened message box. Click a few more times and additional markers will appear on the map, containing the geographic information provided by the reverse geocoder.</p><p>Are you beginning to see the usefulness of a reverse geocoder? In the next section, you'll be able to access that data outside of JavaScript, with Google's HTTP geocoder.</p></div><div class="sect2" title="Reverse Geocode with Google's Web Service"><div class="titlepage"><div><div><h2 class="title"><a id="reverse_geocode_with_google_apostrophy_s"/>Reverse Geocode with Google's Web Service</h2></div></div></div><p>As I've mentioned elsewhere in this chapter, power and flexibility come from being able to control the input and output of a geocoder. You can have the same freedom using the reverse geocoding provided by Google's web service.</p><p>With a tiny tweak to the URL, Google's geocoder becomes a reverse geocoder:</p><a id="I_programlisting3_d1e3405"/><pre class="programlisting">http://maps.google.com/maps/geo?q=<strong class="userinput"><code>37.7740486,-122.4101883</code></strong>&amp;output=xml&amp;sensor=false</pre><p>We're still using the <code class="literal">q</code> query argument, as we did in the Google portion of <a class="xref" href="ch03s04.html" title="#13: Geocode with an HTTP Web Service">#13: Geocode with an HTTP Web Service</a> in <a class="xref" href="ch03s04.html" title="#13: Geocode with an HTTP Web Service">#13: Geocode with an HTTP Web Service</a>. Instead of passing an address, we send the latitude and longitude, in that order and separated by a comma (bolded in the above URL).</p><p>The results are virtually the same as with the forward geocoder:</p><a id="I_programlisting3_d1e3421"/><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;kml &gt;
  &lt;Response&gt;
    &lt;name&gt;37.7740486,-122.4101883&lt;/name&gt;
    &lt;Status&gt;
      &lt;code&gt;200&lt;/code&gt;
      &lt;request&gt;geocode&lt;/request&gt;
    &lt;/Status&gt;
    &lt;tPlacemark id="p1"&gt;
      &lt;address&gt;38 Ringold St, San Francisco, CA 94103, USA&lt;/address&gt;
      &lt;AddressDetails Accuracy="8"
                      &gt;
        ...
      &lt;/AddressDetails&gt;
      &lt;Point&gt;
        &lt;coordinates&gt;-122.4102800,37.7741680,0&lt;/coordinates&gt;
      &lt;/Point&gt;
    &lt;/Placemark&gt;
    &lt;Placemark id="p2"&gt;
      ...
    &lt;/Placemark&gt;
    ...
 &lt;/Response&gt;
&lt;/kml&gt;</pre><p>The biggest difference is that you are bound to have multiple Placemarks, because reverse geocoding is much less precise than standard geocoding. Otherwise, the content you receive within each Placemark is the same, right down to the postal code—as, of course, is the address (or range), which is the entire point of the process in the first place.<a id="IDX-CHP-3-0055" class="indexterm"/><a id="IDX-CHP-3-0056" class="indexterm"/><a id="IDX-CHP-3-0057" class="indexterm"/></p><p>No longer will you have to leave users attempting to decipher strange numbers that are made for a computer to understand. Whether you choose JavaScript or a server-side web service, you can go from coordinates to text with a quick call to a reverse geocoder.</p></div></div>
<div class="sect1" title="#15: Get Postal Code Coordinates"><div class="titlepage"><div><div><h1 class="title"><a id="number_symble_15_colon_get_postal_code"/>#15: Get Postal Code Coordinates</h1></div></div></div><p>Have you ever been to a website that asked you to enter your ZIP Code to find a store's nearest location? Probably yes, I'd guess. This section will help you take the first step toward creating something like that yourself. You need a way to turn a postal code into geographic coordinates.</p><p>You may be thinking that a large area cannot be turned into a single geographic point. You're right, though the same could be said about any address where the geocode result tends to be a point near the street. What about your backyard?</p><p>Remember, geocoding is not a precise science. For an address, a point is chosen that makes sense. For a postal code, the most logical point is somewhere near the center. Even the center is difficult to determine for the amorphous boundaries of some places, however. Hence, the latitude and longitude represent a spot <span class="emphasis"><em>near</em></span> the center.</p><p>The easiest method for getting coordinates of a postal code is to search using a geocoding service. For example, if you wanted to look up the most famous ZIP Code in Beverly Hills using a Yahoo! geocoder, you'd use this URL:</p><a id="I_programlisting3_d1e3452"/><pre class="programlisting">http://local.yahooapis.com/MapsService/V1/geocode?appid=<em class="replaceable"><code>YOURKEY</code></em>&amp;location=90210</pre><p>And your results would look something like this:<a id="IDX-CHP-3-0058" class="indexterm"/><a id="IDX-CHP-3-0059" class="indexterm"/><a id="IDX-CHP-3-0060" class="indexterm"/></p><a id="I_programlisting3_d1e3474"/><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;ResultSet ...&gt;
  &lt;Result precision="zip"&gt;
    &lt;Latitude&gt;34.092807&lt;/Latitude&gt;
    &lt;Longitude&gt;-118.411115&lt;/Longitude&gt;
    &lt;Address /&gt;
    &lt;City&gt;Beverly Hills&lt;/City&gt;
    &lt;State&gt;CA&lt;/State&gt;
    &lt;Zip&gt;90210&lt;/Zip&gt;
    &lt;Country&gt;US&lt;/Country&gt;
  &lt;/Result&gt;
&lt;/ResultSet&gt;</pre><p>Note that the precision is ZIP-level and the address tag is empty. Otherwise, the results are similar to what gets returned when you search for a complete address.</p><div class="sect2" title="Install a Postal Code Database"><div class="titlepage"><div><div><h2 class="title"><a id="install_a_postal_code_database"/>Install a Postal Code Database</h2></div></div></div><p>If you need to perform a lot of lookups, or want faster access to the results, having a database table to geocode postal codes without the use of another service makes sense. The United States has fewer than 50,000 ZIP Codes, a reasonably small number of records to store and access. Other countries have more unique postal codes (Canada, for example, has nearly a million, which is still small enough to be worth it).</p><p>You will need a database to keep your postal codes and their corresponding coordinates. In <a class="xref" href="ch09.html" title="Chapter 9. GO SERVER-SIDE">Chapter 9</a>, I describe how to install MySQL and import data from a CSV file. The book's website contains links where you can download postal code databases for free. See <a class="ulink" href="http://mapscripting.com/postal-code-database">http://mapscripting.com/postal-code-database</a>.<a id="IDX-CHP-3-0061" class="indexterm"/><a id="IDX-CHP-3-0062" class="indexterm"/></p><p>The fields contained in the databases will vary, but here's an example structure of a US ZIP Code database:</p><table border="0" summary="Simple list" class="simplelist"><tr><td><span class="strong"><strong>ZIP Code</strong></span> The postal code</td></tr><tr><td><span class="strong"><strong>name</strong></span> A textual description of this ZIP Code, such as neighborhood or city name</td></tr><tr><td><span class="strong"><strong>latitude</strong></span> The north/south portion of the coordinates</td></tr><tr><td><span class="strong"><strong>longitude</strong></span> The east/west portion of the coordinates</td></tr></table><p>A very basic database may not even contain a name field, as the most important part of a postal code database is converting from the code to a point.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>You'll want to pay attention to whether the ZIP Code field is stored as text or a number. Some prefer text because text can better represent ZIP Codes that begin with a zero. Databases are able to search for numbers more efficiently, however, so you'll need to make sure to strip off any zeros at the beginning of user input.</p></div><p>With a full database of postal codes loaded into the <code class="literal">zipcoord</code> table (a name I made up), the SQL to find the coordinates for Beverly Hills, 90210, would look something like this:<a id="IDX-CHP-3-0063" class="indexterm"/></p><a id="I_programlisting3_d1e3533"/><pre class="programlisting">select latitude, longitude from zipcoord where zipcode='90210';</pre><p>You should only get one set of coordinates from that database call because only one 90210 postal code exists. To learn more about accessing the SQL results with PHP, see <a class="xref" href="ch09s07.html" title="#65: Use MySQL from PHP">#65: Use MySQL from PHP</a> in <a class="xref" href="ch09s07.html" title="#65: Use MySQL from PHP">#65: Use MySQL from PHP</a>.</p><p>Now that you can get postal code coordinates, you're ready to do something with them. At the beginning of this project, I mentioned websites that have a search box to find locations near your ZIP Code. Combine your postal code result with <a class="xref" href="ch06s11.html" title="#46: Get Nearest Locations from Your Own Database">#46: Get Nearest Locations from Your Own Database</a> in <a class="xref" href="ch06s11.html" title="#46: Get Nearest Locations from Your Own Database">#46: Get Nearest Locations from Your Own Database</a>, and you'll have built a store locator, just like you've seen on those sites.</p></div></div></body></html>