- en: '34'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 3 4 5 5 12 13'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: $wrts
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0 0 0 0 0 0'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: attr(,"class")
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '40'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "bookvec"'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: b[2]
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '42'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 4'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'b[2] <- 88 # try writing'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '44'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'b[2] # worked?'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '45'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 88'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '46'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'b$wrts # write count incremented?'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '47'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0 1 0 0 0 0'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: We have named our class "bookvec", because these vectors will do their own bookkeeping—that
    is, keep track of write counts. So, the subscripting functions will be [.bookvec()
    and [<-.bookvec().
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: R Programming Structures
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**185**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Our function newbookvec() (line 7) does the construction for this class. In
    it, you can see the structure of the class: An object will consist of the vector
    itself, vec (line 9), and a vector of write counts, wrts (line 10).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: By the way, note in line 11 that the function class() itself is a replacement
    function!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The functions [.bookvec() and [<-.bookvec() are fairly straightforward.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Just remember to return the entire object in the latter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**7.11 Tools for Composing Function Code**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are writing a short function that’s needed only temporarily, a quick-and-dirty
    way to do this is to write it on the spot, right there in your interactive terminal
    session. Here’s an example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: g <- function(x) {
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: +
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: return(x+1)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: + }
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: This approach obviously is infeasible for longer, more complex functions. Now,
    let’s look at some better ways to compose R code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '***7.11.1 Text Editors and Integrated Development Environments***'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: You can use a text editor such as Vim, Emacs, or even Notepad, or an editor
    within an integrated development environment (IDE) to write your code in a file
    and then read it into R from the file. To do the latter, you can use R’s source()
    function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, suppose we have functions f() and g() in a file *xyz.R*. In R,
    we give this command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: source("xyz.R")
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This reads f() and g() into R as if we had typed them using the quick-and-dirty
    way shown at the beginning of this section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have much code, you can cut and paste from your editor window to
    your R window.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Some general-purpose editors have special plug-ins available for R, such as
    ESS for Emacs and Vim-R for Vim. There are also IDEs for R, such as the commercial
    one by Revolution Analytics, and open source products such as StatET, JGR, Rcmdr,
    and RStudio.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '***7.11.2 The edit() Function***'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: A nice implication of the fact that functions are objects is that you can edit
    functions from within R’s interactive mode. Most R programmers do their code editing
    with a text editor in a separate window, but for a small, quick change, the edit()
    function can be handy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '**186**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we could edit the function f1() by typing this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: f1 <- edit(f1)
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This opens the default editor on the code for f1, which we could then edit and
    assign back to f1\.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, we might be interested in having a function f2() very similar to f1() and
    thus could execute the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: f2 <- edit(f1)
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This gives us a copy of f1() to start from. We would do a little editing and
    then save to f2(), as seen in the preceding command.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The editor involved will depend on R’s internal options variable editor.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'In UNIX-class systems, R will set this from your shell’s EDITOR or VISUAL environment
    variable, or you can set it yourself, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: options(editor="/usr/bin/vim")
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For more details on using options, see the online documentation by typing the
    following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: ?options
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can use edit() to edit data structures, too.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '**7.12 Writing Your Own Binary Operations**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: You can invent your own operations! Just write a function whose name begins
    and ends with %, with two arguments of a certain type, and a return value of that
    type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: For example, here’s a binary operation that adds double the second
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'operand to the first:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '"%a2b%" <- function(a,b) return(a+2*b)'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3 %a2b% 5
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 13'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: A less trivial example is given in the section about set operations in Section
    8.5\.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '**7.13 Anonymous Functions**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'As remarked at several points in this book, the purpose of the R function function()
    is to create functions. For instance, consider this code: inc <- function(x) return(x+1)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: R Programming Structures
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '**187**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: It instructs R to create a function that adds 1 to its argument and then assigns
    that function to inc. However, that last step—the assignment—is not always taken.
    We can simply use the function object created by our call to function() without
    naming that object. The functions in that context are called *anonymous*, since
    they have no name. (That is somewhat misleading, since even nonanonymous functions
    only have a name in the sense that a variable is pointing to them.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Anonymous functions can be convenient if they are short one-liners and are
    called by another function. Let’s go back to our example of using apply in Section
    3.3:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: z
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[3,]'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: f <- function(x) x/c(2,8)
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y <- apply(z,1,f)
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 0.5 1.000 1.50'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0.5 0.625 0.75'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s bypass the middleman—that is, skip the assignment to f—by using an anonymous
    function within our call to apply(), as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: y <- apply(z,1,function(x) x/c(2,8))
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 0.5 1.000 1.50'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0.5 0.625 0.75'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: What really happened here? The third formal argument to apply() must be a function,
    which is exactly what we supplied here, since the return value of function() is
    a function!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Doing things this way is often clearer than defining the function externally.
    Of course, if the function is more complicated, that clarity is not attained.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '**188**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 20](index-215_1.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: '**8**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '**DOING MATH AND SIMULATIONS IN R**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: R contains built-in functions for your
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: favorite math operations and, of course,
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: for statistical distributions. This chapter
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: provides an overview of using these functions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Given the mathematical nature of this chapter, the
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: examples assume a slightly higher-level knowledge
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: than those in other chapters. You should be familiar
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: with calculus and linear algebra to get the most out
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: of these examples.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1 Math Functions**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'R includes an extensive set of built-in math functions. Here is a partial list:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'exp(): Exponential function, base e'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'log(): Natural logarithm'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'log10(): Logarithm base 10'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'sqrt(): Square root'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'abs(): Absolute value'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'sin(), cos(), and so on: Trig functions'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'min() and max(): Minimum value and maximum value within a vector'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'which.min() and which.max(): Index of the minimal element and maximal element
    of a vector'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'pmin() and pmax(): Element-wise minima and maxima of several vectors'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'sum() and prod(): Sum and product of the elements of a vector'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'cumsum() and cumprod(): Cumulative sum and product of the elements of a vector'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'round(), floor(), and ceiling(): Round to the closest integer, to the closest
    integer below, and to the closest integer above'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'factorial(): Factorial function'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '***8.1.1 Extended Example: Calculating a Probability***'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: As our first example, we’ll work through calculating a probability using the
    prod() function. Suppose we have *n* independent events, and the *i* th event
    has the probability *pi* of occurring. What is the probability of exactly one
    of these events occurring?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose first that *n* = 3 and our events are named A, B, and C. Then we break
    down the computation as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: P(exactly one event occurs)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '='
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: P(A and not B and not C)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: +
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: P(not A and B and not C)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: +
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: P(not A and not B and C)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: P(A and not B and not C) would be *pA*(1 *− pB*)(1 *− pC*), and so on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'For general *n*, that is calculated as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '*n*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '*pi*(1 *−p* 1) *...* (1 *−pi−* 1)(1 *−pi*+1) *...* (1 *−pn*) *i*=1'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: (The *i* th term inside the sum is the probability that event *i* occurs and
    all the others do *not* occur.)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s code to compute this, with our probabilities *pi* contained in the vector
    p:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: exactlyone <- function(p) {
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: notp <- 1 - p
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: tot <- 0.0
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:length(p))
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: tot <- tot + p[i] * prod(notp[-i])
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: return(tot)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**190**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: How does it work? Well, the assignment
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: notp <- 1 - p
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: creates a vector of all the “not occur” probabilities 1 *− pj*, using recycling.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The expression notp[-i] computes the product of all the elements of notp, except
    the *i* th—exactly what we need.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '***8.1.2 Cumulative Sums and Products***'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, the functions cumsum() and cumprod() return cumulative sums and
    products.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: x <- c(12,5,13)
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: cumsum(x)
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 12 17 30'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: cumprod(x)
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 12 60 780'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: In x, the sum of the first element is 12, the sum of the first two elements
    is 17, and the sum of the first three elements is 30\.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The function cumprod() works the same way as cumsum(), but with the product
    instead of the sum.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '***8.1.3 Minima and Maxima***'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: There is quite a difference between min() and pmin(). The former simply combines
    all its arguments into one long vector and returns the minimum value in that vector.
    In contrast, if pmin() is applied to two or more vectors, it returns a vector
    of the pair-wise minima, hence the name pmin.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: z
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[3,]'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: min(z[,1],z[,2])
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: pmin(z[,1],z[,2])
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 3 2'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, min() computed the smallest value in (1,5,6,2,3,2). But the
    call to pmin() computed the smaller of 1 and 2, yielding 1; then the smaller of
    5 and 3, which is 3; then finally the minimum of 6 and 2, giving 2\. Thus, the
    call returned the vector (1,3,2).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '**191**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use more than two arguments in pmin(), like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: pmin(z[1,],z[2,],z[3,])
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 2'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The 1 in the output is the minimum of 1, 5, and 6, with a similar computation
    leading to the 2\.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The max() and pmax() functions act analogously to min() and pmin().
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Function minimization/maximization can be done via nlm() and optim().
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s find the smallest value of *f* ( *x*) = *x* 2 *−* sin( *x*).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: nlm(function(x) return(x^2-sin(x)),8)
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $minimum
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[1] -0.2324656'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: $estimate
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0.4501831'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: $gradient
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 4.024558e-09'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: $code
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: $iterations
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 5'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Here, the minimum value was found to be approximately *−* 0.23, occurring at
    *x* = 0.45\. A Newton-Raphson method (a technique from numerical analysis for
    approximating roots) is used, running five iterations in this case.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The second argument specifies the initial guess, which we set to be 8\. (This
    second argument was picked pretty arbitrarily here, but in some problems, you
    may need to experiment to find a value that will lead to convergence.)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '***8.1.4 Calculus***'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: R also has some calculus capabilities, including symbolic differentiation and
    numerical integration, as you can see in the following example.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'D(expression(exp(x^2)),"x") # derivative'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: exp(x^2) * (2 * x)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: integrate(function(x) x^2,0,1)
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 0.3333333 with absolute error < 3.7e-15
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '**192**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Here, R reported
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '*d ex* 2 = 2 *xex* 2'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '*dx*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: and
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '*x* 2 *dx ≈* 0 *.* 3333333'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: You can find R packages for differential equations (odesolve), for interfacing
    R with the Yacas symbolic math system (ryacas), and for other calculus operations.
    These packages, and thousands of others, are available from the Comprehensive
    R Archive Network (CRAN); see Appendix B.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '**8.2 Functions for Statistical Distributions**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: R has functions available for most of the famous statistical distributions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Prefix the name as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: With d for the density or probability mass function (pmf)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: With p for the cumulative distribution function (cdf)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: With q for quantiles
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: With r for random number generation
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the name indicates the distribution. Table 8-1 lists some common
    statistical distribution functions.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-1:** Common R Statistical Distribution Functions'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '**Distribution**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '**Density/pmf**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '**cdf**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantiles**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '**Random Numbers**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Normal
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: dnorm()
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: pnorm()
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: qnorm()
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: rnorm()
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Chi square
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: dchisq()
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: pchisq()
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: qchisq()
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: rchisq()
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Binomial
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: dbinom()
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: pbinom()
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: qbinom()
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: rbinom()
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s simulate 1,000 chi-square variates with 2 degrees of freedom
    and find their mean.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: mean(rchisq(1000,df=2))
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1.938179'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: The r in rchisq specifies that we wish to generate random numbers—
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: in this case, from the chi-square distribution. As seen in this example, the
    first argument in the r-series functions is the number of random variates to generate.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**193**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: These functions also have arguments specific to the given distribution families.
    In our example, we use the df argument for the chi-square family, indicating the
    number of degrees of freedom.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '*Consult R’s online help for details on the arguments for the statistical distribution*
    *functions. For instance, to find our more about the chi-square function for quantiles,*
    *type ?qchisq at the command prompt.*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also compute the 95th percentile of the chi-square distribution with
    two degrees of freedom:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: qchisq(0.95,2)
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 5.991465'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Here, we used q to indicate quantile—in this case, the 0.95 quantile, or the
    95th percentile.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The first argument in the d, p, and q series is actually a vector so that we
    can evaluate the density/pmf, cdf, or quantile function at multiple points.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Let’s find both the 50th and 95th percentiles of the chi-square distribution
    with 2 degrees of freedom.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: qchisq(c(0.5,0.95),df=2)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1.386294 5.991465'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '**8.3 Sorting**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Ordinary numerical sorting of a vector can be done with the sort() function,
    as in this example:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: x <- c(13,5,12,5)
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: sort(x)
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 5 5 12 13'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: x
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 13 5 12 5'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Note that x itself did not change, in keeping with R’s functional language philosophy.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the indices of the sorted values in the original vector, use the
    order() function. Here’s an example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: order(x)
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 2 4 3 1'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: This means that x[2] is the smallest value in x, x[4] is the second smallest,
    x[3] is the third smallest, and so on.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '**194**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use order(), together with indexing, to sort data frames, like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: y
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: V1 V2
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 1 def 2
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: ab 5
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 3 zzzz 1
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: r <- order(y$V2)
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: r
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 3 1 2'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: z <- y[r,]
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: z
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: V1 V2
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 3 zzzz 1
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 1 def 2
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: ab 5
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: What happened here? We called order() on the second column of y,
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: yielding a vector r, telling us where numbers should go if we want to sort them.
    The 3 in this vector tells us that x[3,2] is the smallest number in x[,2]; the
    1 tells us that x[1,2] is the second smallest; and the 2 tells us that x[2,2]
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: is the third smallest. We then use indexing to produce the frame sorted by column
    2, storing it in z.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use order() to sort according to character variables as well as numeric
    ones, as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: d
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: kids ages
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 1 Jack
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 2 Jill
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 3 Billy
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: d[order(d$kids),]
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: kids ages
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 3 Billy
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 1 Jack
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 2 Jill
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: d[order(d$ages),]
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: kids ages
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 2 Jill
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 1 Jack
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 3 Billy
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: A related function is rank(), which reports the rank of each element of a vector.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '**195**'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: x <- c(13,5,12,5)
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: rank(x)
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 4.0 1.5 3.0 1.5'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: This says that 13 had rank 4 in x; that is, it is the fourth smallest. The value
    5 appears twice in x, with those two being the first and second smallest, so the
    rank 1.5 is assigned to both. Optionally, other methods of handling ties can be
    specified.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '**8.4 Linear Algebra Operations on Vectors and Matrices**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying a vector by a scalar works directly, as you saw earlier. Here’s
    another example:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: y
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 3 4 10'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 2*y
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 2 6 8 20'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to compute the inner product (or dot product) of two vectors, use
    crossprod(), like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: crossprod(1:3,c(5,12,13))
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1]'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '68'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: The function computed 1 *·* 5 + 2 *·* 12 + 3 *·* 13 = 68\.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Note that the name crossprod() is a misnomer, as the function does not compute
    the vector cross product. We’ll develop a function to compute real cross products
    in Section 8.4.1\.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'For matrix multiplication in the mathematical sense, the operator to use is
    %*%, not *. For instance, here we compute the matrix product:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 1 2
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 1 *−* 1
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 1 1
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 3 4
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '='
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 3 1
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: a
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: b
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '-1'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '**196**'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: a %*% b
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'The function solve() will solve systems of linear equations and even find matrix
    inverses. For example, let’s solve this system:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '*x* 1 + *x* 2 = 2'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '*−x* 1 + *x* 2 = 4'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'Its matrix form is as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '*x* 1'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '*−* 1 1'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '='
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '*x* 2'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: a <- matrix(c(1,1,-1,1),nrow=2,ncol=2)
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b <- c(2,4)
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: solve(a,b)
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 3 1'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: solve(a)
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 0.5 0.5'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] -0.5 0.5'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: In that second call to solve(), the lack of a second argument signifies that
    we simply wish to compute the inverse of the matrix.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few other linear algebra functions:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 't(): Matrix transpose'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'qr(): QR decomposition'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'chol(): Cholesky decomposition'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'det(): Determinant'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'eigen(): Eigenvalues/eigenvectors'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'diag(): Extracts the diagonal of a square matrix (useful for obtaining variances
    from a covariance matrix and for constructing a diagonal'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: matrix).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'sweep(): Numerical analysis sweep operations'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the versatile nature of diag(): If its argument is a matrix, it returns
    a vector, and vice versa. Also, if the argument is a scalar, the function returns
    the identity matrix of the specified size.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '**197**'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: m
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: dm <- diag(m)
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: dm
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 8'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: diag(dm)
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: diag(3)
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[3,]'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: The sweep() function is capable of fairly complex operations. As a simple example,
    let’s take a 3-by-3 matrix and add 1 to row 1, 4 to row 2, and 7 to row 3\.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: m
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[3,]'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: sweep(m,1,c(1,4,7),"+")
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[3,]'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two arguments to sweep() are like those of apply(): the array and
    the margin, which is 1 for rows in this case. The fourth argument is a function
    to be applied, and the third is an argument to that function (to the'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '"+" function).'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '***8.4.1 Extended Example: Vector Cross Product***'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the issue of vector cross products. The definition is very simple:
    The cross product of vectors ( *x* 1 *, x* 2 *, x* 3) and ( *y* 1 *, y* 2 *, y*
    3) in three-dimensional space is a new three-dimensional vector, as shown in Equation
    8.1\.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: ( *x* 2 *y* 3 *− x* 3 *y* 2 *, −x* 1 *y* 3 + *x* 3 *y* 1 *, x* 1 *y* 2 *− x*
    2 *y* 1) (8.1)
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '**198**'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: This can be expressed compactly as the expansion along the top row of the determinant,
    as shown in Equation 8.2\.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: ⎛
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: ⎞
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '*− − −*'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: ⎝ *x* 1 *x* 2 *x* 3 ⎠
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: (8.2)
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '*y* 1'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '*y* 2'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '*y* 3'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Here, the elements in the top row are merely placeholders.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry about this bit of pseudomath. The point is that the cross product
    vector can be computed as a sum of subdeterminants. For instance, the first component
    in Equation 8.1, *x* 2 *y* 3 *− x* 3 *y* 2, is easily seen to be the determinant
    of the submatrix obtained by deleting the first row and first column in Equation
    8.2, as shown in Equation 8.3\.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '*x* 2 *x* 3'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: (8.3)
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '*y* 2'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '*y* 3'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: Our need to calculate subdeterminants—that is determinants of
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: submatrices—fits perfectly with R, which excels at specifying submatrices.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: 'This suggests calling det() on the proper submatrices, as follows:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: xprod <- function(x,y) {
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: m <- rbind(rep(NA,3),x,y)
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: xp <- vector(length=3)
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:3)
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: xp[i] <- -(-1)^i * det(m[2:3,-i])
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: return(xp)
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: Note that even R’s ability to specify values as NA came into play here to deal
    with the “placeholders” mentioned above.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: All this may seem like overkill. After all, it wouldn’t have been hard to code
    Equation 8.1 directly, without resorting to use of submatrices and determinants.
    But while that may be true in the three-dimensional case, the approach shown here
    is quite fruitful in the *n*-ary case, in *n*-dimensional space. The cross product
    there is defined as an *n*-by- *n* determinant of the form shown in Equation 8.1,
    and thus the preceding code generalizes perfectly.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '***8.4.2 Extended Example: Finding Stationary Distributions of Markov Chains***'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: A Markov chain is a random process in which we move among various *states*,
    in a “memoryless” fashion, whose definition need not concern us here. The state
    could be the number of jobs in a queue, the number of items stored in inventory,
    and so on. We will assume the number of states to be finite.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: As a simple example, consider a game in which we toss a coin repeatedly and
    win a dollar whenever we accumulate three consecutive heads.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: Our state at any time *i* will the number of consecutive heads we have so far,
    so our state can be 0, 1, or 2\. (When we get three heads in a row, our state
    reverts to 0.)
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '**199**'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: The central interest in Markov modeling is usually the long-run state distribution,
    meaning the long-run proportions of the time we are in each state. In our coin-toss
    game, we can use the code we’ll develop here to calculate that distribution, which
    turns out to have us at states 0, 1, and 2 in proportions 57.1%, 28.6%, and 14.3%
    of the time. Note that we win our dollar if we are in state 2 and toss a head,
    so 0.143 *×* 0.5 = 0.071 of our tosses will result in wins.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Since R vector and matrix indices start at 1 rather than 0, it will be convenient
    to relabel our states here as 1, 2, and 3 rather than 0, 1, and 2\. For example,
    state 3 now means that we currently have two consecutive heads.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Let *pij* denote the *transition probability* of moving from state *i* to state
    *j* during a time step. In the game example, for instance, *p* 23 = 0 *.* 5, reflecting
    the fact that with probability 1/2, we will toss a head and thus move from having
    one consecutive head to two. On the other hand, if we toss a tail while we are
    in state 2, we go to state 1, meaning 0 consecutive heads; thus *p* 21 = 0 *.*
    5\.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: We are interested in calculating the vector *π* = ( *π* 1 *, ..., πs*), where
    *πi* is the long-run proportion of time spent at state i, over all states i. Let
    *P*
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: denote the transition probability matrix whose *i* th row, *j* th column element
    is *pij*. Then it can be shown that *π* must satisfy Equation 8.4, *π* = *πP*
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: (8.4)
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'which is equivalent to Equation 8.5:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: ( *I − P T* ) *π* = 0
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: (8.5)
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: Here *I* is the identity matrix and *P T* denotes the transpose of *P*.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: Any single one of the equations in the system of Equation 8.5 is redundant.
    We thus eliminate one of them, by removing the last row of *I −P* in Equation
    8.5\. That also means removing the last 0 in the 0 vector on the right-hand side
    of Equation 8.5\.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: But note that there is also the constraint shown in Equation 8.6\.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '*πi* = 1'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: (8.6)
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '*i*'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'In matrix terms, this is as follows:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: 1 *Tnπ* = 1
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: where 1 *n* is a vector of *n* 1s.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: So, in the modified version of Equation 8.5, we replace the removed row with
    a row of all 1s and, on the right-hand side, replace the removed 0 with a 1\.
    We can then solve the system.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: 'All this can be computed with R’s solve() function, as follows:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: findpi1 <- function(p) {
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: n <- nrow(p)
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: imp <- diag(n) - t(p)
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '**200**'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: imp[n,] <- rep(1,n)
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: rhs <- c(rep(0,n-1),1)
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: pivec <- solve(imp,rhs)
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: return(pivec)
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the main steps:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: Calculate *I − P T* in line 3\. Note again that diag(), when called with a scalar
    argument, returns the identity matrix of the size given by that argument.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: Replace the last row of *P* with 1 values in line 4\.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: Set up the right-hand side vector in line 5\.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: Solve for *π* in line 6\.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: Another approach, using more advanced knowledge, is based on eigen-
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: values. Note from Equation 8.4 that *π* is a left eigenvector of *P* with eigenvalue
    1\. This suggests using R’s eigen() function, selecting the eigenvector corresponding
    to that eigenvalue. (A result from mathematics, the Perron-Frobenius theorem,
    can be used to carefully justify this.)
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: 'Since *π* is a left eigenvector, the argument in the call to eigen() must be
    *P* transpose rather than *P*. In addition, since an eigenvector is unique only
    up to scalar multiplication, we must deal with two issues regarding the eigenvector
    returned to us by eigen():'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: It may have negative components. If so, we multiply by *−* 1\.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: It may not satisfy Equation 8.6\. We remedy this by dividing by the length of
    the returned vector.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: findpi2 <- function(p) {
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: n <- nrow(p)
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: find first eigenvector of P transpose
  id: totrans-624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: pivec <- eigen(t(p))$vectors[,1]
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: guaranteed to be real, but could be negative
  id: totrans-628
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: if (pivec[1] < 0) pivec <- -pivec
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: normalize to sum to 1
  id: totrans-632
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: pivec <- pivec / sum(pivec)
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: return(pivec)
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: The return value of eigen() is a list. One of the list’s components is a matrix
    named vectors. These are the eigenvectors, with the *i* th column being the eigenvector
    corresponding to the *i* th eigenvalue. Thus, we take column 1 here.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '**201**'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '**8.5 Set Operations**'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: 'R includes some handy set operations, including these:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: 'union(x,y): Union of the sets x and y'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: 'intersect(x,y): Intersection of the sets x and y'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: 'setdiff(x,y): Set difference between x and y, consisting of all elements of
    x that are not in y'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: 'setequal(x,y): Test for equality between x and y'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: 'c %in% y: Membership, testing whether c is an element of the set y'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: 'choose(n,k): Number of possible subsets of size k chosen from a set of size
    n'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some simple examples of using these functions:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: x <- c(1,2,5)
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y <- c(5,1,8,9)
  id: totrans-659
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: union(x,y)
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 2 5 8 9'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: intersect(x,y)
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 5'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: setdiff(x,y)
  id: totrans-664
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 2'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: setdiff(y,x)
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 8 9'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: setequal(x,y)
  id: totrans-668
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] FALSE'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: setequal(x,c(1,2,5))
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] TRUE'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: 2 %in% x
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] TRUE'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 2 %in% y
  id: totrans-674
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] FALSE'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: choose(5,2)
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 10'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: Recall from Section 7.12 that you can write your own binary operations.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: For instance, consider coding the symmetric difference between two sets—
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: that is, all the elements belonging to exactly one of the two operand sets.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the symmetric difference between sets x and y consists exactly of those
    elements in x but not y and vice versa, the code consists of easy calls to setdiff()
    and union(), as follows:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: symdiff
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: function(a,b) {
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: sdfxy <- setdiff(x,y)
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: sdfyx <- setdiff(y,x)
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '**202**'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: return(union(sdfxy,sdfyx))
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try it.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: x
  id: totrans-692
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 2 5'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: y
  id: totrans-694
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 5 1 8 9'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: symdiff(x,y)
  id: totrans-696
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 2 8 9'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example: a binary operand for determining whether one set u
    is a subset of another set v. A bit of thought shows that this property is equivalent
    to the intersection of u and v being equal to u. Hence we have another easily
    coded function:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '"%subsetof%" <- function(u,v) {'
  id: totrans-699
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: +
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: return(setequal(intersect(u,v),u))
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: + }
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: c(3,8) %subsetof% 1:10
  id: totrans-703
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] TRUE'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: c(3,8) %subsetof% 5:10
  id: totrans-705
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] FALSE'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: The function combn() generates combinations. Let’s find the subsets of
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '{1,2,3} of size 2\.'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: c32 <- combn(1:3,2)
  id: totrans-709
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c32
  id: totrans-710
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: class(c32)
  id: totrans-720
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "matrix"'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: The results are in the columns of the output. We see that the subsets of
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '{1,2,3} of size 2 are (1,2), (1,3), and (2,3).'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: 'The function also allows you to specify a function to be called by combn()
    on each combination. For example, we can find the sum of the numbers in each subset,
    like this:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: combn(1:3,2,sum)
  id: totrans-725
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 3 4 5'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: The first subset, {1,2}, has a sum of 2, and so on.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: '**203**'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '**8.6 Simulation Programming in R**'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common uses of R is simulation. Let’s see what kinds of tools
    R has available for this application.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: '***8.6.1 Built-In Random Variate Generators***'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, R has functions to generate variates from a number of different
    distributions. For example, rbinom() generates binomial or Bernoulli random variates.1
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we want to find the probability of getting at least four heads out
    of five tosses of a coin (easy to find analytically, but a handy example).
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can do this:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: x <- rbinom(100000,5,0.5)
  id: totrans-737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: mean(x >= 4)
  id: totrans-738
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.18829'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: First, we generate 100,000 variates from a binomial distribution with five trials
    and a success probability of 0.5\. We then determine which of them has a value
    4 or 5, resulting in a Boolean vector of the same length as x. The TRUE
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: and FALSE values in that vector are treated as 1s and 0s by mean(), giving us
    our estimated probability (since the average of a bunch of 1s and 0s is the proportion
    of 1s).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: Other functions include rnorm() for the normal distribution, rexp() for the
    exponential, runif() for the uniform, rgamma() for the gamma, rpois() for the
    Poisson, and so on.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another simple example, which finds *E*[max( *X, Y* )], the expected
    value of the maximum of independent N(0,1) random variables X and Y:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: sum <- 0
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: nreps <- 100000
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:nreps) {
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: 'xy <- rnorm(2) # generate 2 N(0,1)s'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: sum <- sum + max(xy)
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: print(sum/nreps)
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: We generated 100,000 pairs, found the maximum for each, and aver-
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: aged those maxima to obtain our estimated expected value.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code, with an explicit loop, may be clearer, but as before, if
    we are willing to use some more memory, we can do this more compactly.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: 1 A sequence of independent 0- and 1- valued random variables with the same
    probability of 1
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: for each is called *Bernoulli*.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: '**204**'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: emax
  id: totrans-759
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: function(nreps) {
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: x <- rnorm(2*nreps)
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: maxxy <- pmax(x[1:nreps],x[(nreps+1):(2*nreps)])
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: return(mean(maxxy))
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: Here, we generated double nreps values. The first nreps value simulates X, and
    the remaining nreps value represents Y. The pmax() call then computes the pair-wise
    maxima that we need. Again, note the contrast here between max() and pmax(), the
    latter producing pair-wise maxima.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: '***8.6.2 Obtaining the Same Random Stream in Repeated Runs***'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: According to the R documentation, all random-number generators use
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: 32-bit integers for seed values. Thus, other than round-off error, the same
    initial seed should generate the same stream of numbers.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, R will generate a different random number stream from run to run
    of a program. If you want the same stream each time—important in debugging, for
    instance—call set.seed(), like this:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: 'set.seed(8888) # or your favorite number as an argument'
  id: totrans-770
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***8.6.3 Extended Example: A Combinatorial Simulation***'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following probability problem:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: Three committees, of sizes 3, 4 and 5, are chosen from 20 people.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: What is the probability that persons A and B are chosen for the
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: same committee?
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: This problem is not hard to solve analytically, but we may wish to check our
    solution using simulation, and in any case, writing the code will demonstrate
    how R’s set operations can come in handy in combinatorial settings.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: sim <- function(nreps) {
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: 'commdata <- list() # will store all our info about the 3 committees 3'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: commdata$countabsamecomm <- 0
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: for (rep in 1:nreps) {
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: 'commdata$whosleft <- 1:20 # who''s left to choose from'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: 'commdata$numabchosen <- 0 # number among A, B chosen so far'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: choose committee 1, and check for A,B serving together
  id: totrans-790
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: commdata <- choosecomm(commdata,5)
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '**205**'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: if A or B already chosen, no need to look at the other comms.
  id: totrans-797
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '10'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: if (commdata$numabchosen > 0) next
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: choose committee 2 and check
  id: totrans-801
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '12'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: commdata <- choosecomm(commdata,4)
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: if (commdata$numabchosen > 0) next
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: choose committee 3 and check
  id: totrans-807
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '15'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: commdata <- choosecomm(commdata,3)
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: print(commdata$countabsamecomm/nreps)
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: choosecomm <- function(comdat,comsize) {
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: choose committee
  id: totrans-820
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '22'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: committee <- sample(comdat$whosleft,comsize)
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: count how many of A and B were chosen
  id: totrans-824
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '24'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: comdat$numabchosen <- length(intersect(1:2,committee))
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: if (comdat$numabchosen == 2)
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: comdat$countabsamecomm <- comdat$countabsamecomm + 1
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: delete chosen committee from the set of people we now have to choose from 28
  id: totrans-832
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: comdat$whosleft <- setdiff(comdat$whosleft,committee)
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: return(comdat)
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: We number the potential committee members from 1 to 20, with per-
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: 'sons A and B having ID 1 and 2\. Recalling that R lists are often used to store
    several related variables in one basket, we se up a list comdat. Its components
    include the following:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: 'comdat$whosleft: We simulate the random selection of the committees by randomly
    choosing from this vector. Each time we choose a committee, we remove the committee
    members’ IDs. It is initialized to 1:20, indicating that no one has been selected
    yet.'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: 'comdat$numabchosen: This is a count of how many among the people A and B have
    been chosen so far. If we choose a committee and find this to be positive, we
    can skip choosing the remaining committees for the following reason: If this number
    is 2, we know definitely that A and B are on the same committee; if it is 1, we
    know definitely that A and B are *not* on the same committee.'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: 'comdat$countabsamecomm: Here, we store a count of the number of times A and
    B are on the same committee.'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: Since committee selection involves subsets, it’s not surprising that a couple
    of R’s set operations—intersect() and setdiff()—come in handy here.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: Note, too, the use of R’s next statement, which tells R to skip the rest of
    this iteration of the loop.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: '**206**'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 21](index-233_1.png)'
  id: totrans-851
  prefs: []
  type: TYPE_IMG
- en: '**9**'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: '**OBJECT-ORIENTED PROGRAMMING**'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: Many programmers believe that object-
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: oriented programming (OOP) makes for
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: clearer, more reusable code. Though very
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: different from the familiar OOP languages like
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: C++, Java, and Python, R is very much OOP in outlook.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: 'The following themes are key to R:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: Everything you touch in R—ranging from numbers to character strings to matrices—is
    an object.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: R promotes *encapsulation*, which is packaging separate but related data items
    into one class instance. Encapsulation helps you keep track of related variables,
    enhancing clarity.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: R classes are *polymorphic*, which means that the same function call leads to
    different operations for objects of different classes. For instance, a call to
    print() on an object of a certain class triggers a call to a print function tailored
    to that class. Polymorphism promotes reusability.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: R allows *inheritance*, which allows extending a given class to a more specialized
    class.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers OOP in R. We’ll discuss programming in the two types of
    classes, S3 and S4, and then present a few useful OOP-related R
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: utilities.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: '**9.1 S3 Classes**'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: The original R structure for classes, known as S3, is still the dominant class
    paradigm in R use today. Indeed, most of R’s own built-in classes are of the S3
    type.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: An S3 class consists of a list, with a class name attribute and *dispatch* capability
    added. The latter enables the use of generic functions, as we saw in Chapter 1\.
    S4 classes were developed later, with goal of adding *safety*, meaning that you
    cannot accidentally access a class component that is not already in existence.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.1 S3 Generic Functions***'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, R is polymorphic, in the sense that the same function can lead
    to different operations for different classes. You can apply plot(), for example,
    to many different types of objects, getting a different type of plot for each.
    The same is true for print(), summary(), and many other functions.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: In this manner, we get a uniform interface to different classes. For example,
    if you are writing code that includes plot operations, polymorphism may allow
    you to write your program without worrying about the various types of objects
    that might be plotted.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: In addition, polymorphism certainly makes things easier to remem-
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: ber for the user and makes it fun and convenient to explore new library functions
    and associated classes. If a function is new to you, just try running plot() on
    the function’s output; it will likely work. From a programmer’s viewpoint, polymorphism
    allows writing fairly general code, without worrying about what type of object
    is being manipulated, because the underlying class mechanisms take care of that.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: The functions that work with polymorphism, such as plot() and print(), are known
    as *generic functions*. When a generic function is called, R will then dispatch
    the call to the proper class method, meaning that it will reroute the call to
    a function defined for the object’s class.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.2 Example: OOP in the lm() Linear Model Function***'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s look at a simple regression analysis run via R’s lm()
    function. First, let’s see what lm() does:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: ?lm
  id: totrans-882
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The output of this help query will tell you, among other things, that this function
    returns an object of class "lm".
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: '**208**'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try creating an instance of this object and then printing it:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: x <- c(1,2,3)
  id: totrans-888
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y <- c(1,3,8)
  id: totrans-889
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lmout <- lm(y ~ x)
  id: totrans-890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: class(lmout)
  id: totrans-891
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "lm"'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: lmout
  id: totrans-893
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Call:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: lm(formula = y ~ x)
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: 'Coefficients:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: (Intercept)
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: x
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '-3.0'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: '3.5'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: Here, we printed out the object lmout. (Remember that by simply typing the name
    of an object in interactive mode, the object is printed.) The R interpreter then
    saw that lmout was an object of class "lm" and thus called print.lm(), a special
    print method for the "lm" class. In R terminology, the call to the generic function
    print() was dispatched to the method print.lm() associated with the class "lm".
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the generic function and the class method in
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: 'this case:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: print
  id: totrans-904
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: function(x, ...) UseMethod("print")
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: '<environment: namespace:base>'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: print.lm
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: function (x, digits = max(3, getOption("digits") - 3), ...)
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: cat("\nCall:\n", deparse(x$call), "\n\n", sep = "") if (length(coef(x))) {
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: cat("Coefficients:\n")
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: print.default(format(coef(x), digits = digits), print.gap = 2,
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: quote = FALSE)
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: else cat("No coefficients\n")
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: cat("\n")
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: invisible(x)
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: '<environment: namespace:stats>'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: You may be surprised to see that print() consists solely of a call to UseMethod().
    But this is actually the dispatcher function, so in view of print()’s role as
    a generic function, you should not be surprised after all.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: '**209**'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry about the details of print.lm(). The main point is that the printing
    depends on context, with a special print function called for the
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: '"lm" class. Now let’s see what happens when we print this object with its class
    attribute removed:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: unclass(lmout)
  id: totrans-926
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $coefficients
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: (Intercept)
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: x
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '-3.0'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '3.5'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: $residuals
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: 0.5 -1.0 0.5
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: $effects
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: (Intercept)
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: x
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: '-6.928203'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: '-4.949747'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: '1.224745'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: $rank
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 2'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: I’ve shown only the first few lines here—there’s a lot more. (Try running this
    on your own!) But you can see that the author of lm() decided to make print.lm()
    much more concise, limiting it to printing a few key quantities.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.3 Finding the Implementations of Generic Methods***'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all the implementations of a given generic method by calling methods(),
    like this:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: methods(print)
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] print.acf*'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: '[2] print.anova'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: '[3] print.aov*'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: '[4] print.aovlist*'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: '[5] print.ar*'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: '[6] print.Arima*'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: '[7] print.arima0*'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: '[8] print.AsIs'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: '[9] print.aspell*'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: '[10] print.Bibtex*'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: '[11] print.browseVignettes*'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: '[12] print.by'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: '[13] print.check_code_usage_in_package*'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: '[14] print.check_demo_index*'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: '[15] print.checkDocFiles*'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: '**210**'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: '[16] print.checkDocStyle*'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: '[17] print.check_dotInternal*'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: '[18] print.checkFF*'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: '[19] print.check_make_vars*'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: '[20] print.check_package_code_syntax*'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: Asterisks denote *nonvisible* functions, meaning ones that are not in the default
    namespaces. You can find these functions via getAnywhere() and then access them
    by using a namespace qualifier. An example is print.aspell().
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: 'The aspell() function itself does a spellcheck on the file specified in its
    argument. For example, suppose the file *wrds* consists of this line: Which word
    is mispelled?'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, this function will catch the misspelled word, as follows: aspell("wrds")'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: mispelled
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: wrds:1:15
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: The output says that there is the indicated spelling error in line 1, character
    15 of the input file. But what concerns us here is the mechanism by which that
    output was printed.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: The aspell() function returns an object of class "aspell", which does have its
    own generic print function, print.aspell(). In fact, that function was invoked
    in our example, after the call to aspell(), and the return value was printed out.
    At that time, R called UseMethod() on the object of class "aspell".
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we call that print method directly, R won’t recognize it:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: aspout <- aspell("wrds")
  id: totrans-982
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print.aspell(aspout)
  id: totrans-983
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Error: could not find function "print.aspell"'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can find it by calling getAnywhere():'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: getAnywhere(print.aspell)
  id: totrans-986
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A single object matching 'print.aspell' was found
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: It was found in the following places
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: registered S3 method for print from namespace utils
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: namespace:utils
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: with value
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: function (x, sort = TRUE, verbose = FALSE, indent = 2L, ...)
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: if (!(nr <- nrow(x)))
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: '**211**'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the function is in the utils namespace, and we can execute it by adding
    such a qualifier:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: utils:::print.aspell(aspout)
  id: totrans-1000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: mispelled
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: wrds:1:15
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see all the generic methods this way:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: methods(class="default")
  id: totrans-1004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.4 Writing S3 Classes***'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: 'S3 classes have a rather cobbled-together structure. A class instance is created
    by forming a list, with the components of the list being the member variables
    of the class. (Readers who know Perl may recognize this ad hoc nature in Perl’s
    own OOP system.) The "class" attribute is set by hand by using the attr() or class()
    function, and then various implementations of generic functions are defined. We
    can see this in the case of lm() by inspecting the function:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: lm
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: z <- list(coefficients = if (is.matrix(y))
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: matrix(,0,3) else numeric(0L), residuals = y,
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: fitted.values = 0 * y, weights = w, rank = 0L,
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: df.residual = if (is.matrix(y)) nrow(y) else length(y))
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: class(z) <- c(if(is.matrix(y)) "mlm", "lm")
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: Again, don’t mind the details; the basic process is there. A list was created
    and assigned to z, which will serve as the framework for the "lm" class instance
    (and which will eventually be the value returned by the function).
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: Some components of that list, such as residuals, were already assigned when
    the list was created. In addition, the class attribute was set to "lm" (and possibly
    to "mlm", as will be explained in the next section).
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of how to write an S3 class, let’s switch to something simpler.
    Continuing our employee example from Section 4.1, we could write this:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: j <- list(name="Joe", salary=55000, union=T)
  id: totrans-1021
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: class(j) <- "employee"
  id: totrans-1022
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'attributes(j) # let''s check'
  id: totrans-1023
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**212**'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: $names
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "name" "salary" "union"'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: $class
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "employee"'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write a print method for this class, let’s see what happens when
    we call the default print():'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: j
  id: totrans-1032
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $name
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "Joe"'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: $salary
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 55000'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: $union
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: '[1] TRUE'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: attr(,"class")
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "employee"'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, j was treated as a list for printing purposes.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s write our own print method:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: print.employee <- function(wrkr) {
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: cat(wrkr$name,"\n")
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: cat("salary",wrkr$salary,"\n")
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: cat("union member",wrkr$union,"\n")
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: 'So, any call to print() on an object of class "employee" should now be referred
    to print.employee(). We can check that formally:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: methods(,"employee")
  id: totrans-1049
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] print.employee'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, of course, we can simply try it out:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: j
  id: totrans-1052
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Joe
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: salary 55000
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: union member TRUE
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: '**213**'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.5 Using Inheritance***'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of inheritance is to form new classes as specialized versions of old
    ones. In our previous employee example, for instance, we could form a new class
    devoted to hourly employees, "hrlyemployee", as a subclass of "employee", as follows:'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: k <- list(name="Kate", salary= 68000, union=F, hrsthismonth= 2) class(k) <-
    c("hrlyemployee","employee")
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new class has one extra variable: hrsthismonth. The name of the new class
    consists of two character strings, representing the new class and the old class.
    Our new class inherits the methods of the old one. For instance, print.employee()
    still works on the new class:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: k
  id: totrans-1063
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Kate
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: salary 68000
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: union member FALSE
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: Given the goals of inheritance, that is not surprising. However, it’s important
    to understand exactly what transpired here.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: Once again, simply typing k resulted in the call print(k). In turn, that caused
    UseMethod() to search for a print method on the first of k’s two class names,
    "hrlyemployee". That search failed, so UseMethod() tried the other class name,
    "employee", and found print.employee(). It executed the latter.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that in inspecting the code for "lm", you saw this line: class(z) <-
    c(if(is.matrix(y)) "mlm", "lm")'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: You can now see that "mlm" is a subclass of "lm" for vector-valued response
    variables.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.6 Extended Example: A Class for Storing Upper-Triangular Matrices***'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time for a more involved example, in which we will write an R class
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: '"ut" for upper-triangular matrices. These are square matrices whose elements
    below the diagonal are zeros, such as shown in Equation 9.1\.'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: ⎛
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: ⎞
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: 1 5 12
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: ⎝0 6 9 ⎠
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: (9.1)
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: 0 0 2
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: Our motivation here is to save storage space (though at the expense of a little
    extra access time) by storing only the nonzero portion of the matrix.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: '*The R class "dist" also uses such storage, though in a more focused context
    and without the class functions we have here.*'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: '**214**'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: The component mat of this class will store the matrix. As mentioned, to save
    on storage space, only the diagonal and above-diagonal elements will be stored,
    in column-major order. Storage for the matrix (9.1), for instance, consists of
    the vector (1,5,6,12,9,2), and the component mat has that value.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: We will include a component ix in this class, to show where in mat the various
    columns begin. For the preceding case, ix is c(1,2,4), meaning that column 1 begins
    at mat[1], column 2 begins at mat[2], and column 3 begins at mat[4]. This allows
    for handy access to individual elements or columns of the matrix.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: The following is the code for our class.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: class "ut", compact storage of upper-triangular matrices 2
  id: totrans-1090
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: utility function, returns 1+...+i
  id: totrans-1092
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: sum1toi <- function(i) return(i*(i+1)/2)
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: create an object of class "ut" from the full matrix inmat (0s included) 7
  id: totrans-1097
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ut <- function(inmat) {
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: n <- nrow(inmat)
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: 'rtrn <- list() # start to build the object'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: class(rtrn) <- "ut"
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: rtrn$mat <- vector(length=sum1toi(n))
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: rtrn$ix <- sum1toi(0:(n-1)) + 1
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:n) {
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: store column i
  id: totrans-1112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '15'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: ixi <- rtrn$ix[i]
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: rtrn$mat[ixi:(ixi+i-1)] <- inmat[1:i,i]
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: return(rtrn)
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: uncompress utmat to a full matrix
  id: totrans-1125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '22'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: expandut <- function(utmat) {
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: 'n <- length(utmat$ix) # numbers of rows and cols of matrix'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: fullmat <- matrix(nrow=n,ncol=n)
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: for (j in 1:n) {
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: fill jth column
  id: totrans-1135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '27'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: start <- utmat$ix[j]
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: fin <- start + j - 1
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: 'abovediagj <- utmat$mat[start:fin] # above-diag part of col j'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: fullmat[,j] <- c(abovediagj,rep(0,n-j))
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: return(fullmat)
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: print matrix
  id: totrans-1152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '36'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: print.ut <- function(utmat)
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: print(expandut(utmat))
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: '**215**'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: multiply one ut matrix by another, returning another ut instance; 40
  id: totrans-1162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: implement as a binary operation
  id: totrans-1163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '41'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: '"%mut%" <- function(utmat1,utmat2) {'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: 'n <- length(utmat1$ix) # numbers of rows and cols of matrix'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: utprod <- ut(matrix(0,nrow=n,ncol=n))
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: 'for (i in 1:n) { # compute col i of product'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: '45'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: let a[j] and bj denote columns j of utmat1 and utmat2, respectively, 46
  id: totrans-1173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: so that, e.g. b2[1] means element 1 of column 2 of utmat2
  id: totrans-1174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '47'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: then column i of product is equal to
  id: totrans-1176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '48'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: '#'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: bi[1]*a[1] + ... + bi[i]*a[i]
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: '49'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: find index of start of column i in utmat2
  id: totrans-1181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '50'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: startbi <- utmat2$ix[i]
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: '51'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: initialize vector that will become bi[1]*a[1] + ... + bi[i]*a[i]
  id: totrans-1185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '52'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: prodcoli <- rep(0,i)
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: '53'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: 'for (j in 1:i) { # find bi[j]*a[j], add to prodcoli'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: '54'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: startaj <- utmat1$ix[j]
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: '55'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: bielement <- utmat2$mat[startbi+j-1]
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: '56'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: prodcoli[1:j] <- prodcoli[1:j] +
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: '57'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: bielement * utmat1$mat[startaj:(startaj+j-1)]
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: '58'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: '59'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: now need to tack on the lower 0s
  id: totrans-1201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '60'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: startprodcoli <- sum1toi(i-1)+1
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '61'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: utprod$mat[startbi:(startbi+i-1)] <- prodcoli
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: '62'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: '63'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: return(utprod)
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: '64'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test it.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: test
  id: totrans-1213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: function() {
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: utm1 <- ut(rbind(1:2,c(0,2)))
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: utm2 <- ut(rbind(3:2,c(0,1)))
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: utp <- utm1 %mut% utm2
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: print(utm1)
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: print(utm2)
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: print(utp)
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: utm1 <- ut(rbind(1:3,0:2,c(0,0,5)))
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: utm2 <- ut(rbind(4:2,0:2,c(0,0,1)))
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: utp <- utm1 %mut% utm2
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: print(utm1)
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: print(utm2)
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: print(utp)
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: '**216**'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: test()
  id: totrans-1231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 1 2'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0 2'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 3 2'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0 1'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 3 4'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0 2'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 1 2 3'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0 1 2'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: '[3,] 0 0 5'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 4 3 2'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0 1 2'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: '[3,] 0 0 1'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 4 5 9'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0 1 4'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: '[3,] 0 0 5'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the code, we take into account the fact that the matrices involved
    have a lot of zeros. For example, we avoid multiplying by zeros simply by not
    adding terms to sums when the terms include a 0 factor.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: The ut() function is fairly straightforward. This function is a *constructor*,
    which is a function whose job it is to create an instance of the given class,
    eventually returning that instance. So in line 9, we create a list that will serve
    as the body of the class object, naming it rtrn as a reminder that this will be
    the class instance to be constructed and returned.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, the main member variables of our class will be mat and idx,
    implemented as components of the list. Memory for these two components is allocated
    in lines 11 and 12\.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: The loop that follows then fills in rtrn$mat column by column and
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: 'assigns rtrn$idx element by element. A slicker way to do this for loop would
    be to use the rather obscure row() and col() functions. The row() function takes
    a matrix input and returns a new matrix of the same size, but with each element
    replaced by its row number. Here’s an example:'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: m
  id: totrans-1258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 1 4'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 2 5'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: '[3,] 3 6'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: '**217**'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: row(m)
  id: totrans-1266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 1 1'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 2 2'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: '[3,] 3 3'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: The col() function works similarly.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this idea, we could replace the for loop in ut() with a one-liner: rtrn$mat
    <- inmat[row(inmat) <= col(inmat)]'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: Whenever possible, we should exploit vectorization. Take a look at
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: 'line 12, for example:'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: rtrn$ix <- sum1toi(0:(n-1)) + 1
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: Since sum1toi() (which we defined on line 4) is based only on the vectorized
    functions "*"() and "+"(), sum1toi() itself is also vectorized. This allows us
    to apply sum1toi() to a vector above. Note that we used recycling as well.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: 'We want our "ut" class to include some methods, not just variables. To this
    end, we have included three methods:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: The expandut() function converts from a compressed matrix to an ordinary one.
    In expandut(), the key lines are 27 and 28, where we use rtrn$ix to determine
    where in utmat$mat the *j* th column of our matrix is stored.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: That data is then copied to the *j* th column of fullmat in line 30\. Note the
    use of rep() to generate the zeros in the lower portion of this column.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: The print.ut() function is for printing. This function is quick and easy, using
    expandut(). Recall that any call to print() on an object of type "ut"
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: will be dispatched to print.ut(), as in our test cases earlier.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: The "%mut%"() function is for multiplying two compressed matrices (without uncompressing
    them). This function starts in line 39\. Since this is a binary operation, we
    take advantage of the fact that R accommodates user-defined binary operations,
    as described in Section 7.12, and implement our matrix-multiply function as %mut%.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the details of the "%mut%"() function. First, in line 43, we allocate
    space for the product matrix. Note the use of recycling in an unusual context.
    The first argument of matrix() is required to be a vector of a length compatible
    with the number of specified rows and columns, so the 0 we provide is recycled
    to a vector of length *n* 2\. Of course, rep() could be used instead, but exploiting
    recycling makes for a bit shorter, more elegant code.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: For both clarity and fast execution, the code here has been written around the
    fact that R stores matrices in column-major order. As mentioned in the comments,
    our code then makes use of the fact that column *i* of the **218**
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: product can be expressed as a linear combination of the columns of the first
    factor. It will help to see a specific example of this property, shown in Equation
    9.2\.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: ⎛
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: ⎞ ⎛
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: ⎞
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: ⎛
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: ⎞
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: 1 2 3
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: 4 3 2
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: 4 5 9
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: ⎝ 0 1 2 ⎠ ⎝ 0 1 2 ⎠ = ⎝ 0 1 4 ⎠
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: (9.2)
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: 0 0 5
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: 0 0 1
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: 0 0 5
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: 'The comments say that, for instance, column 3 of the product is equal to the
    following:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: ⎛
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: ⎞
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: ⎛
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: ⎞
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: ⎛
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: ⎞
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: 2 ⎝ 0 ⎠ + 2 ⎝ 1 ⎠ + 1 ⎝ 2 ⎠
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: Inspection of Equation 9.2 confirms the relation.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: Couching the multiplication problem in terms of columns of the
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
- en: two input matrices enables us to compact the code and to likely increase the
    speed. The latter again stems from vectorization, a benefit discussed in detail
    in Chapter 14\. This approach is used in the loop beginning at line 53\. (Arguably,
    in this case, the increase in speed comes at the expense of readability of the
    code.)
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.7 Extended Example: A Procedure for Polynomial Regression***'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: As another example, consider a statistical regression setting with one predictor
    variable. Since any statistical model is merely an approximation, in principle,
    you can get better and better models by fitting polynomials of higher and higher
    degrees. However, at some point, this becomes over-fitting, so that the prediction
    of new, future data actually deteriorates for degrees higher than some value.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: The class "polyreg" aims to deal with this issue. It fits polynomials of various
    degrees but assesses fits via cross-validation to reduce the risk of over-fitting.
    In this form of cross-validation, known as the *leaving-one-out method*, for each
    point we fit the regression to all the data *except* this observation, and then
    we predict that observation from the fit. An object of this class consists of
    outputs from the various regression models, plus the original data.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: The following is the code for the "polyreg" class.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: '"polyreg," S3 class for polynomial regression in one predictor variable 2'
  id: totrans-1326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: polyfit(y,x,maxdeg) fits all polynomials up to degree maxdeg; y is 4
  id: totrans-1328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: vector for response variable, x for predictor; creates an object of 5
  id: totrans-1329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: class "polyreg"
  id: totrans-1330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: polyfit <- function(y,x,maxdeg) {
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: form powers of predictor variable, ith power in ith column
  id: totrans-1334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: 'pwrs <- powers(x,maxdeg) # could use orthog polys for greater accuracy 9'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
- en: 'lmout <- list() # start to build class'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
- en: 'class(lmout) <- "polyreg" # create a new class'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: '**219**'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:maxdeg) {
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: lmo <- lm(y ~ pwrs[,1:i])
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: extend the lm class here, with the cross-validated predictions
  id: totrans-1348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '14'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: lmo$fitted.cvvalues <- lvoneout(y,pwrs[,1:i,drop=F])
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: lmout[[i]] <- lmo
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: lmout$x <- x
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: lmout$y <- y
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: return(lmout)
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: 'print() for an object fits of class "polyreg": print'
  id: totrans-1365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '23'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: cross-validated mean-squared prediction errors
  id: totrans-1367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '24'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: print.polyreg <- function(fits) {
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: maxdeg <- length(fits) - 2
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(fits$y)
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: tbl <- matrix(nrow=maxdeg,ncol=1)
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: colnames(tbl) <- "MSPE"
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:maxdeg) {
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: fi <- fits[[i]]
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: errs <- fits$y - fi$fitted.cvvalues
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: 'spe <- crossprod(errs,errs) # sum of squared prediction errors'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
- en: tbl[i,1] <- spe/n
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: cat("mean squared prediction errors, by degree\n")
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: print(tbl)
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: forms matrix of powers of the vector x, through degree dg
  id: totrans-1398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '40'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: powers <- function(x,dg) {
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: pw <- matrix(x,nrow=length(x))
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: prod <- x
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 2:dg) {
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: prod <- prod * x
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: '45'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: pw <- cbind(pw,prod)
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: '46'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: '47'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: return(pw)
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: '48'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: '49'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: finds cross-validated predicted values; could be made much faster via 51
  id: totrans-1419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: matrix-update methods
  id: totrans-1420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '52'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: lvoneout <- function(y,xmat) {
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: '53'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(y)
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: '54'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: predy <- vector(length=n)
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: '55'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:n) {
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: '56'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: regress, leaving out ith observation
  id: totrans-1430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '57'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: lmo <- lm(y[-i] ~ xmat[-i,])
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: '58'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: betahat <- as.vector(lmo$coef)
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: '**220**'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: '59'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: the 1 accommodates the constant term
  id: totrans-1439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '60'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: predy[i] <- betahat %*% c(1,xmat[i,])
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: '61'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: '62'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: return(predy)
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: '63'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: '64'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: '65'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: polynomial function of x, coefficients cfs
  id: totrans-1450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '66'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: poly <- function(x,cfs) {
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: '67'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: val <- cfs[1]
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: '68'
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: prod <- 1
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: '69'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: dg <- length(cfs) - 1
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: '70'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:dg) {
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: '71'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: prod <- prod * x
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: '72'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: val <- val + cfs[i+1] * prod
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: '73'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: '74'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, "polyreg" consists of polyfit(), the constructor function, and
    print.polyreg(), a print function tailored to this class. It also contains several
    utility functions to evaluate powers and polynomials and to perform cross-validation.
    (Note that in some cases here, efficiency has been sacrificed for clarity.)
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: As an example of using the class, we’ll generate some artificial data and create
    an object of class "polyreg" from it, printing out the results.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: n <- 60
  id: totrans-1471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: x <- (1:n)/n
  id: totrans-1472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y <- vector(length=n)
  id: totrans-1473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for (i in 1:n) y[i] <- sin((3*pi/2)*x[i]) + x[i]^2 + rnorm(1,mean=0,sd=0.5)
  id: totrans-1474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: dg <- 15
  id: totrans-1475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (lmo <- polyfit(y,x,dg))
  id: totrans-1476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: mean squared prediction errors, by degree
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: MSPE
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 0.4200127'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0.3212241'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: '[3,] 0.2977433'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: '[4,] 0.2998716'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: '[5,] 0.3102032'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: '[6,] 0.3247325'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: '[7,] 0.3120066'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: '[8,] 0.3246087'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: '[9,] 0.3463628'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: '[10,] 0.4502341'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: '[11,] 0.6089814'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: '[12,] 0.4499055'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: '[13,]'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: NA
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: '[14,]'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: NA
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: '[15,]'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: NA
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: '**221**'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: 'Note first that we used a common R trick in this command:'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: (lmo <- polyfit(y,x,dg))
  id: totrans-1501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By surrounding the entire assignment statement in parentheses, we get the printout
    and form lmo at the same time, in case we need the latter for other things.
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: The function polyfit() fits polynomial models up through a specified degree,
    in this case 15, calculating the cross-validated mean squared prediction error
    for each model. The last few values in the output were NA, because roundoff error
    considerations led R to refuse to fit polynomials of degrees that high.
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: So, how is it all done? The main work is handled by the function
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: polyfit(), which creates an object of class "polyreg". That object consists
    mainly of the objects returned by the R regression fitter lm() for each degree.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: 'In forming those objects, note line 14:'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: lmo$fitted.cvvalues <- lvoneout(y,pwrs[,1:i,drop=F])
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, lmo is an object returned by lm(), but we are adding an extra component
    to it: fitted.cvvalues. Since we can add a new component to a list at any time,
    and since S3 classes are lists, this is possible.'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: We also have a method for the generic function print(), print.polyreg() in line
    24\. In Section 12.1.5, we will add a method for the plot() generic function,
    plot.polyreg().
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: 'In computing prediction errors, we used cross-validation, or the leaving-one-out
    method, in a form that predicts each observation from all the others. To implement
    this, we take advantage of R’s use of negative subscripts in line 57:'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: lmo <- lm(y[-i] ~ xmat[-i,])
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: So, we are fitting the model with the *i* th observation deleted from our data
    set.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: '*As mentioned in the comment in the code, we could make a much faster implementation
    by using a matrix-inverse update method, known as the Sherman-Morrison-Woodbury
    formula. For more information, see J. H. Venter and J. L. J. Snyman,*'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: '*“A Note on the Generalised Cross-Validation Criterion in Linear Model Selection,”*'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: Biometrika *, Vol. 82, no. 1, pp. 215–219\.*
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: '**9.2 S4 Classes**'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers feel that S3 does not provide the safety normally associated
    with OOP. For example, consider our earlier employee database **222**
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: 'example, where our class "employee" had three fields: name, salary, and union.'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some possible mishaps:'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: We forget to enter the union status.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: We misspell *union* as *onion*.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: We create an object of some class other than "employee" but accidentally set
    its class attribute to "employee".
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: In each of these cases, R will not complain. The goal of S4 is to elicit a complaint
    and prevent such accidents.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: S4 structures are considerably richer than S3 structures, but here we present
    just the basics. Table 9-1 shows an overview of the differences between the two
    classes.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** Basic R Operators'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation**'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: '**S3**'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: '**S4**'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: Define class
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: Implicit in constructor code
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: setClass()
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: Create object
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: Build list, set class attr
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: new()
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: Reference member variable
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: $
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: '@'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: Implement generic f()
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: Define f.classname()
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: setMethod()
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: Declare generic
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: UseMethod()
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: setGeneric()
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: '***9.2.1 Writing S4 Classes***'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: 'You define an S4 class by calling setClass(). Continuing our employee example,
    we could write the following:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: setClass("employee",
  id: totrans-1552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: +
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: representation(
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: +
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: name="character",
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: +
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: salary="numeric",
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: +
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: union="logical")
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: + )
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "employee"'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: This defines a new class, "employee", with three member variables of the specified
    types.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s create an instance of this class, for Joe, using new(), a built-in
    constructor function for S4 classes:'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: joe <- new("employee",name="Joe",salary=55000,union=T)
  id: totrans-1565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: joe
  id: totrans-1566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An object of class "employee"
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "name":'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "Joe"'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: '**223**'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "salary":'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 55000'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "union":'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: '[1] TRUE'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the member variables are called *slots*, referenced via the @ symbol.
    Here’s an example:'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: joe@salary
  id: totrans-1578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 55000'
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the slot() function, say, as another way to query Joe’s salary:'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: slot(joe,"salary")
  id: totrans-1581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 55000'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: 'We can assign components similarly. Let’s give Joe a raise:'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: joe@salary <- 65000
  id: totrans-1584
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: joe
  id: totrans-1585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An object of class "employee"
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "name":'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "Joe"'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "salary":'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 65000'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "union":'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: '[1] TRUE'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: 'Nah, he deserves a bigger raise that that:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: slot(joe,"salary") <- 88000
  id: totrans-1594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: joe
  id: totrans-1595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An object of class "employee"
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "name":'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "Joe"'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "salary":'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 88000'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "union":'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: '[1] TRUE'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: '**224**'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted, an advantage of using S4 is safety. To illustrate this, suppose we
    were to accidentally spell *salary* as *salry*, like this:'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: joe@salry <- 48000
  id: totrans-1607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Error in checkSlotAssignment(object, name, value) :'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: '"salry" is not a slot in class "employee"'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, in S3 there would be no error message. S3 classes are just lists,
    and you are allowed to add a new component (deliberately or not) at any time.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: '***9.2.2 Implementing a Generic Function on an S4 Class***'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: To define an implementation of a generic function on an S4 class, use setMethod().
    Let’s do that for our class "employee" here. We’ll implement the show() function,
    which is the S4 analog of S3’s generic "print".
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know, in R, when you type the name of a variable while in interactive
    mode, the value of the variable is printed out:'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: joe
  id: totrans-1614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An object of class "employee"
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "name":'
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "Joe"'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "salary":'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 88000'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "union":'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: '[1] TRUE'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: 'Since joe is an S4 object, the action here is that show() is called. In fact,
    we would get the same output by typing this:'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
- en: show(joe)
  id: totrans-1623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s override that, with the following code:'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: setMethod("show", "employee",
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: function(object) {
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: inorout <- ifelse(object@union,"is","is not") cat(object@name,"has a salary
    of",object@salary,
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: '"and",inorout, "in the union", "\n")'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: The first argument gives the name of the generic function for which we will
    define a class-specific method, and the second argument gives the class name.
    We then define the new function.
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: '**225**'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it out:'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: joe
  id: totrans-1636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Joe has a salary of 55000 and is in the union
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: '**9.3 S3 Versus S4**'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: The type of class to use is the subject of some controversy among R programmers.
    In essence, your view here will likely depend on your personal choice of which
    you value more—the convenience of S3 or the safety of S4\.
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
- en: John Chambers, the creator of the S language and one of the central developers
    of R, recommends S4 over S3 in his book *Software for Data Analysis* (Springer,
    2008). He argues that S4 is needed in order to write “clear and reliable software.”
    On the other hand, he notes that S3 remains quite popular.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: Google’s R Style Guide, which you can find at *http://google-styleguide*
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: '*.googlecode.com/svn/trunk/google-r-style.html*, is interesting in this regard.
    Google comes down squarely on the S3 side, stating “avoid S4 objects and methods
    when possible.” (Of course, it’s also interesting that Google even has an R'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: style guide in the first place!)
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: '*A nice, concrete comparison of the two methods is given in Thomas Lumley’s*'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: '*“Programmer’s Niche: A Simple Class, in S3 and S4,”* R News *, April 1, 2004,*
    *pp. 33–36\.*'
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: '**9.4 Managing Your Objects**'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: 'As a typical R session progresses, you tend to accumulate a large number of
    objects. Various tools are available to manage them. Here, we’ll look at the following:'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: The ls() function
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: The rm() function
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: The save() function
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: Several functions that tell you more about the structure of an object, such
    as class() and mode()
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: The exists() function
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: '***9.4.1 Listing Your Objects with the ls() Function***'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: The ls() command will list all of your current objects. A useful named argument
    for this function is pattern, which enables *wildcards*. Here, you tell ls() to
    list only the objects whose names include a specified pattern. The following is
    an example.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: '**226**'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: ls()
  id: totrans-1664
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "acc"'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: '"acc05"'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: '"binomci"'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: '"cmeans"'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: '"divorg"'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: '"dv"'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: '[7] "fit"'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: '"g"'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: '"genxc"'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: '"genxnt"'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: '"j"'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: '"lo"'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: '[13] "out1"'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: '"out1.100" "out1.25"'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: '"out1.50"'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: '"out1.75"'
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: '"out2"'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: '[19] "out2.100" "out2.25"'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: '"out2.50"'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: '"out2.75"'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: '"par.set"'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: '"prpdf"'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: '[25] "ratbootci" "simonn"'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: '"vecprod"'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: '"x"'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: '"zout"'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: '"zout.100"'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: '[31] "zout.125" "zout3"'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: '"zout5"'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: '"zout.50"'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: '"zout.75"'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: ls(pattern="ut")
  id: totrans-1696
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "out1"'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: '"out1.100" "out1.25" "out1.50" "out1.75" "out2"'
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: '[7] "out2.100" "out2.25" "out2.50" "out2.75" "zout"'
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: '"zout.100"'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: '[13] "zout.125" "zout3"'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: '"zout5"'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: '"zout.50" "zout.75"'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, we asked for a list of all objects whose names include the
    string "ut".
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: '***9.4.2 Removing Specific Objects with the rm() Function***'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove objects you no longer need, use rm(). Here’s an example:'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: rm(a,b,x,y,z,uuu)
  id: totrans-1707
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This code removes the six specified objects (a, b, and so on).
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the named arguments of rm() is list, which makes it easier to remove
    multiple objects. This code assigns all of our objects to list, thus removing
    everything:'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: rm(list = ls())
  id: totrans-1710
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using ls()’s pattern argument, this tool becomes even more powerful.
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: ls()
  id: totrans-1713
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "doexpt"'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: '"notebookline"'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: '"nreps"'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
- en: '"numcorrectcis"'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: '[5] "numnotebooklines" "numrules"'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: '"observationpt"'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: '"prop"'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: '[9] "r"'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: '"rad"'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: '"radius"'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: '"rep"'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: '[13] "s"'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
- en: '"s2"'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: '"sim"'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: '"waits"'
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: '[17] "wbar"'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: '"x"'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: '"y"'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: '"z"'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: ls(pattern="notebook")
  id: totrans-1733
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "notebookline"'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: '"numnotebooklines"'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: rm(list=ls(pattern="notebook"))
  id: totrans-1736
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ls()
  id: totrans-1737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "doexpt"'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: '"nreps"'
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
- en: '"numcorrectcis" "numrules"'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: '[5] "observationpt" "prop"'
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
- en: '"r"'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: '"rad"'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: '[9] "radius"'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: '"rep"'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: '"s"'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: '"s2"'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: '[13] "sim"'
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: '"waits"'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: '"wbar"'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: '"x"'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
- en: '[17] "y"'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
- en: '"z"'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: '**227**'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
- en: Here, we found two objects whose names include the string "notebook"
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: and then asked to remove them, which was confirmed by the second call to ls().
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
- en: '*You may find the function browseEnv() helpful. It will show in your web browser
    your* *globals (or objects in a different specified environment), with some details
    on each.*'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: '***9.4.3 Saving a Collection of Objects with the save() Function***'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling save() on a collection of objects will write them to disk for later
    retrieval by load(). Here’s a quick example:'
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
- en: z <- rnorm(100000)
  id: totrans-1763
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: hz <- hist(z)
  id: totrans-1764
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: save(hz,"hzfile")
  id: totrans-1765
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ls()
  id: totrans-1766
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "hz" "z"'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: rm(hz)
  id: totrans-1768
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ls()
  id: totrans-1769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "z"'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: load("hzfile")
  id: totrans-1771
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ls()
  id: totrans-1772
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "hz" "z"'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: 'plot(hz) # graph window pops up'
  id: totrans-1774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here, we generate some data and then draw a histogram of it. But
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: we also save the output of hist() in a variable, hz. That variable is an object
    (of class "histogram", of course). Anticipating that we will want to reuse this
    object in a later R session, we use the save() function to save the object to
    the file *hzfile*. It can be reloaded in that future session via load(). To demonstrate
    this, we deliberately removed the hz object, then called load() to reload it,
    and then called ls() to show that it had indeed been reloaded.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: I once needed to read in a very large data file, each record of which required
    processing. I then used save() to keep the R object version of the processed file
    for future R sessions.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: '***9.4.4 “What Is This?”***'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: Developers often need to know the exact structure of the object returned by
    a library function. If the documentation does not give sufficient details, what
    can we do?
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: 'The following R functions may be helpful:'
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: class(), mode()
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
- en: names(), attributes()
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
- en: unclass(), str()
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: •
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: edit()
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: '**228**'
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go through an example. R includes facilities for constructing *contingency
    tables*, which we discussed in Section 6.4\. An example in that section involved
    an election survey in which five respondents are asked whether they intend to
    vote for candidate X and whether they voted for X in the last election. Here is
    the resulting table:'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: cttab <- table(ct)
  id: totrans-1793
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: cttab
  id: totrans-1794
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Voted.for.X.Last.Time
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: Vote.for.X No Yes
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: Not Sure 0
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: For instance, two respondents answered no to both questions.
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: The object cttab was returned by the function table and thus is likely of class
    "table". A check of the documentation (?table) confirms this. But what is in the
    class?
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the structure of that object cttab of class "table".
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: ctu <- unclass(cttab)
  id: totrans-1808
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ctu
  id: totrans-1809
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Votes.for.X.Last.Time
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: Vote.for.X No Yes
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
- en: Not Sure 0
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
- en: class(ctu)
  id: totrans-1820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "matrix"'
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
- en: So, the counts portion of the object is a matrix. (If the data had involved
    three or more questions, rather than just two, this would have been a higher-dimensional
    array.) Note that the names of the dimensions and of the individual rows and columns
    are there, too; they are associated with the matrix.
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
- en: The unclass() function is quite useful as a first step. If you simply print
    an object, you are at the mercy of the version of print() associated with that
    class, which may in the name of succinctness hide or distort some valuable information.
    Printing the result of calling unclass() allows you to work around this problem,
    though there was no difference in this example. (You saw an instance in which
    it did make a difference in the section about S3
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
- en: generic functions in Section 9.1.1 earlier.) The function str() serves the same
    purpose, in a more compact manner.
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
- en: Note, though, applying unclass() to an object still results in an object with
    some basic class. Here, cttab had the class "table", but unclass(cttab) still
    had the class "matrix".
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try looking at the code for table(), the library function that produced
    cttab. We could simply type table, but since this is a somewhat longish Object-Oriented
    Programming
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: '**229**'
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
- en: 'function, a lot of the function would zoom by on the screen too fast for us
    to absorb it. We could use page() to solve this problem, but I prefer edit():'
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
- en: edit(table)
  id: totrans-1830
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This allows you to browse through the code with your text editor. In doing
    so, you’ll find this code at the end:'
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
- en: y <- array(tabulate(bin, pd), dims, dimnames = dn)
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: class(y) <- "table"
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: y
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
- en: 'Ah, interesting. This shows that table() is, to some extent, a wrapper for
    another function, tabulate(). But what might be more important here is that the
    structure of a "table" object is really pretty simple: It consists of an array
    created from the counts, with the class attribute tacked on. So, it’s essentially
    just an array.'
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
- en: The function names() shows the components in an object, and attributes() gives
    you this and a bit more, notably the class name.
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
- en: '***9.4.5 The exists() Function***'
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
- en: The function exists() returns TRUE or FALSE, depending on whether the argument
    exists. Be sure to put the argument in quotation marks.
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code shows that the acc object exists:'
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
- en: exists("acc")
  id: totrans-1840
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] TRUE'
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
- en: Why would this function be useful? Don’t we always know whether or
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
- en: not we’ve created an object and whether it’s still there? Not necessarily. If
    you are writing general-purpose code, say to be made available to the world in
    R’s CRAN code repository, your code may need to check whether a certain object
    exists, and if it doesn’t, then your code must create it. For example, as you
    learned in Section 9.4.3, you can save objects to disk files using save() and
    then later restore them to R’s memory space by calling load().
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
- en: You might write general-purpose code that makes the latter call if the object
    is not already present, a condition you could check by calling exists().
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
- en: '**230**'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 22](index-257_1.png)'
  id: totrans-1848
  prefs: []
  type: TYPE_IMG
- en: '**10**'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: '**INPUT/OUTPUT**'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
- en: One of the most underemphasized topics
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
- en: in many university programming courses
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
- en: is input/output (I/O). I/O plays a central
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
- en: role in most real-world applications of comput-
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
- en: ers. Just consider an ATM cash machine, which uses
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
- en: multiple I/O operations for both input—reading your
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
- en: card and reading your typed-in cash request—and
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
- en: output—printing instructions on the screen, printing
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
- en: your receipt, and most important, controlling the
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
- en: machine to output your money!
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
- en: R is not the tool you would choose for running an ATM, but it features a highly
    versatile array of I/O capabilities, as you will learn in this chapter.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the basics of access to the keyboard and monitor, and then
    go into considerable detail on reading and writing files, including the navigation
    of file directories. Finally, we discuss R’s facilities for accessing the Internet.
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从键盘和监视器的基本访问方法开始，然后深入探讨读取和写入文件，包括文件目录的导航。最后，我们讨论 R 访问互联网的功能。
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**10.1 Accessing the Keyboard and Monitor**'
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.1 访问键盘和监视器**'
- en: R provides several functions for accesssing the keyboard and monitor. Here,
    we’ll look at the scan(), readline(), print(), and cat() functions.
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: R 提供了几个用于访问键盘和监视器的函数。在这里，我们将查看 scan()、readline()、print() 和 cat() 函数。
- en: '***10.1.1 Using the scan() Function***'
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.1.1 使用 scan() 函数*** '
- en: You can use scan() to read in a vector, whether numeric or character, from a
    file or the keyboard. With a little extra work, you can even read in data to form
    a list.
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 scan() 从文件或键盘读取一个向量，无论是数值还是字符。通过一些额外的工作，您甚至可以读取数据以形成一个列表。
- en: 'Suppose we have files named *z1.txt*, *z2.txt*, *z3.txt*, and *z4.txt*. The
    *z1.txt* file contains the following:'
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些名为 *z1.txt*、*z2.txt*、*z3.txt* 和 *z4.txt* 的文件。*z1.txt* 文件包含以下内容：
- en: '123'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: '123'
- en: 4 5
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 4 5
- en: '6'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: 'The *z2.txt* file contents are as follows:'
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: '*z2.txt* 文件内容如下：'
- en: '123'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: '123'
- en: 4.2 5
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: 4.2 5
- en: '6'
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: 'The *z3.txt* file contains this:'
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: '*z3.txt* 文件包含以下内容：'
- en: abc
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: abc
- en: de f
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: de f
- en: g
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: g
- en: 'And finally, the *z4.txt* file has these contents:'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*z4.txt* 文件包含以下内容：
- en: abc
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: abc
- en: 123 6
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 123 6
- en: y
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: y
- en: Let’s see what we can do with these files using the scan() function.
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 scan() 函数可以对这些文件做些什么。
- en: scan("z1.txt")
  id: totrans-1885
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: scan("z1.txt")
- en: Read 4 items
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 读取了 4 个项目
