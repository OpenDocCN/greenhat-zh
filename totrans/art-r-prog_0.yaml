- en: '34'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '34'
- en: '[1] 3 4 5 5 12 13'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 3 4 5 5 12 13'
- en: '35'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '35'
- en: '36'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '36'
- en: $wrts
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: $wrts
- en: '37'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '37'
- en: '[1] 0 0 0 0 0 0'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0 0 0 0 0 0'
- en: '38'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '38'
- en: '39'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '39'
- en: attr(,"class")
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: attr(,"class")
- en: '40'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '40'
- en: '[1] "bookvec"'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "bookvec"'
- en: '41'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '41'
- en: b[2]
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b[2]
- en: '42'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: '[1] 4'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 4'
- en: '43'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '43'
- en: 'b[2] <- 88 # try writing'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'b[2] <- 88 # try writing'
- en: '44'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '44'
- en: 'b[2] # worked?'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'b[2] # worked?'
- en: '45'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '45'
- en: '[1] 88'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 88'
- en: '46'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '46'
- en: 'b$wrts # write count incremented?'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'b$wrts # 写入次数增加了吗？'
- en: '47'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '47'
- en: '[1] 0 1 0 0 0 0'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0 1 0 0 0 0'
- en: We have named our class "bookvec", because these vectors will do their own bookkeeping—that
    is, keep track of write counts. So, the subscripting functions will be [.bookvec()
    and [<-.bookvec().
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的类命名为 "bookvec"，因为这些向量将执行自己的簿记——也就是说，跟踪写入次数。因此，索引函数将是 [.bookvec() 和 [<-.bookvec()。
- en: R Programming Structures
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: R 编程结构
- en: '**185**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**185**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'Our function newbookvec() (line 7) does the construction for this class. In
    it, you can see the structure of the class: An object will consist of the vector
    itself, vec (line 9), and a vector of write counts, wrts (line 10).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新书向量函数 newbookvec()（第 7 行）为这个类执行构造。在其中，你可以看到类的结构：一个对象将包括向量本身，vec（第 9 行），以及写入次数向量，wrts（第
    10 行）。
- en: By the way, note in line 11 that the function class() itself is a replacement
    function!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，注意第 11 行中函数 class() 本身就是一个替换函数！
- en: The functions [.bookvec() and [<-.bookvec() are fairly straightforward.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 [.bookvec() 和 [<-.bookvec() 相当直接。
- en: Just remember to return the entire object in the latter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住在后者中返回整个对象。
- en: '**7.11 Tools for Composing Function Code**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.11 编写函数代码的工具**'
- en: 'If you are writing a short function that’s needed only temporarily, a quick-and-dirty
    way to do this is to write it on the spot, right there in your interactive terminal
    session. Here’s an example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个短期的函数，只需要临时使用，一种快速而简陋的方法是在你的交互式终端会话中现场编写它。以下是一个例子：
- en: g <- function(x) {
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: g <- function(x) {
- en: +
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: return(x+1)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: return(x+1)
- en: + }
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: + }
- en: This approach obviously is infeasible for longer, more complex functions. Now,
    let’s look at some better ways to compose R code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于更长、更复杂的函数显然是不可行的。现在，让我们看看一些更好的方法来编写 R 代码。
- en: '***7.11.1 Text Editors and Integrated Development Environments***'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.11.1 文本编辑器和集成开发环境***'
- en: You can use a text editor such as Vim, Emacs, or even Notepad, or an editor
    within an integrated development environment (IDE) to write your code in a file
    and then read it into R from the file. To do the latter, you can use R’s source()
    function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Vim、Emacs 或甚至记事本这样的文本编辑器，或者集成开发环境（IDE）中的编辑器来在文件中编写你的代码，然后从文件中将其读入 R。要执行后者，你可以使用
    R 的 source() 函数。
- en: 'For instance, suppose we have functions f() and g() in a file *xyz.R*. In R,
    we give this command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们在文件 *xyz.R* 中有函数 f() 和 g()。在 R 中，我们给出以下命令：
- en: source("xyz.R")
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: source("xyz.R")
- en: This reads f() and g() into R as if we had typed them using the quick-and-dirty
    way shown at the beginning of this section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 f() 和 g() 读入 R，就像我们使用本节开头所示快速而简陋的方式输入它们一样。
- en: If you don’t have much code, you can cut and paste from your editor window to
    your R window.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有太多代码，你可以从你的编辑器窗口剪切并粘贴到你的 R 窗口中。
- en: Some general-purpose editors have special plug-ins available for R, such as
    ESS for Emacs and Vim-R for Vim. There are also IDEs for R, such as the commercial
    one by Revolution Analytics, and open source products such as StatET, JGR, Rcmdr,
    and RStudio.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一些通用编辑器为 R 提供了特殊插件，例如为 Emacs 的 ESS 和为 Vim 的 Vim-R。还有为 R 的 IDE，例如 Revolution
    Analytics 的商业版本，以及开源产品如 StatET、JGR、Rcmdr 和 RStudio。
- en: '***7.11.2 The edit() Function***'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.11.2 edit() 函数***'
- en: A nice implication of the fact that functions are objects is that you can edit
    functions from within R’s interactive mode. Most R programmers do their code editing
    with a text editor in a separate window, but for a small, quick change, the edit()
    function can be handy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为对象的事实有一个很好的推论，那就是你可以在 R 的交互模式下编辑函数。大多数 R 程序员使用单独窗口中的文本编辑器进行代码编辑，但对于一些小而快速的改变，`edit()`
    函数可能很有用。
- en: '**186**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**186**'
- en: Chapter 7
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第七章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'For instance, we could edit the function f1() by typing this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过输入以下内容来编辑函数 f1()：
- en: f1 <- edit(f1)
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: f1 <- edit(f1)
- en: This opens the default editor on the code for f1, which we could then edit and
    assign back to f1\.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开默认的编辑器，用于 f1 的代码，然后我们可以编辑它并将其重新分配给 f1\。
- en: 'Or, we might be interested in having a function f2() very similar to f1() and
    thus could execute the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可能对有一个与 f1() 非常相似但可以执行以下操作的函数 f2() 感兴趣：
- en: f2 <- edit(f1)
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: f2 <- edit(f1)
- en: This gives us a copy of f1() to start from. We would do a little editing and
    then save to f2(), as seen in the preceding command.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个 f1() 的副本来开始。我们会进行一些编辑，然后保存到 f2()，如前一个命令所示。
- en: The editor involved will depend on R’s internal options variable editor.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的编辑器将取决于 R 的内部选项变量 editor。
- en: 'In UNIX-class systems, R will set this from your shell’s EDITOR or VISUAL environment
    variable, or you can set it yourself, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UNIX 类系统中，R 将从你的 shell 的 EDITOR 或 VISUAL 环境变量中设置它，或者你可以自己设置，如下所示：
- en: options(editor="/usr/bin/vim")
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: options(editor="/usr/bin/vim")
- en: 'For more details on using options, see the online documentation by typing the
    following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于使用选项的详细信息，请通过输入以下内容查看在线文档：
- en: ?options
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ?选项
- en: You can use edit() to edit data structures, too.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 edit() 编辑数据结构。
- en: '**7.12 Writing Your Own Binary Operations**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.12 编写自己的二元运算**'
- en: You can invent your own operations! Just write a function whose name begins
    and ends with %, with two arguments of a certain type, and a return value of that
    type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以发明自己的操作！只需编写一个以 % 开头和结尾的函数名，具有特定类型的两个参数，以及该类型的返回值。
- en: For example, here’s a binary operation that adds double the second
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个二元运算，它将第二个操作数的两倍加到第一个操作数上。
- en: 'operand to the first:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数到第一个：
- en: '"%a2b%" <- function(a,b) return(a+2*b)'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"%a2b%" <- function(a,b) return(a+2*b)'
- en: 3 %a2b% 5
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3 %a2b% 5
- en: '[1] 13'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 13'
- en: A less trivial example is given in the section about set operations in Section
    8.5\.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 8.5 节关于集合运算的章节中给出了一个不太平凡的例子。
- en: '**7.13 Anonymous Functions**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.13 匿名函数**'
- en: 'As remarked at several points in this book, the purpose of the R function function()
    is to create functions. For instance, consider this code: inc <- function(x) return(x+1)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书中几个地方所提到的，R 函数 function() 的目的是创建函数。例如，考虑以下代码：inc <- function(x) return(x+1)
- en: R Programming Structures
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: R 编程结构
- en: '**187**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**187**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: It instructs R to create a function that adds 1 to its argument and then assigns
    that function to inc. However, that last step—the assignment—is not always taken.
    We can simply use the function object created by our call to function() without
    naming that object. The functions in that context are called *anonymous*, since
    they have no name. (That is somewhat misleading, since even nonanonymous functions
    only have a name in the sense that a variable is pointing to them.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它指示 R 创建一个将 1 加到其参数上的函数，并将该函数赋值给 inc。然而，最后一步——赋值——并不总是执行。我们可以简单地使用由我们的 function()
    调用创建的函数对象，而不命名该对象。在那个上下文中，这些函数被称为 *匿名函数*，因为它们没有名字。（这有点误导，因为即使是匿名函数也只是在变量指向它们的意义上有名字。）
- en: 'Anonymous functions can be convenient if they are short one-liners and are
    called by another function. Let’s go back to our example of using apply in Section
    3.3:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匿名函数是简短的行内代码，并且被另一个函数调用，那么它们会很有用。让我们回到 3.3 节中使用 apply 的例子：
- en: z
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z
- en: '[,1] [,2]'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,]'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '1'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '4'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '[2,]'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '2'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '5'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '[3,]'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,]'
- en: '3'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '6'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: f <- function(x) x/c(2,8)
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: f <- function(x) x/c(2,8)
- en: y <- apply(z,1,f)
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y <- apply(z,1,f)
- en: y
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y
- en: '[,1] [,2] [,3]'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2] [,3]'
- en: '[1,] 0.5 1.000 1.50'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,] 0.5 1.000 1.50'
- en: '[2,] 0.5 0.625 0.75'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,] 0.5 0.625 0.75'
- en: 'Let’s bypass the middleman—that is, skip the assignment to f—by using an anonymous
    function within our call to apply(), as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在 apply() 调用中使用匿名函数来跳过中间人——即跳过对 f 的赋值——如下所示：
- en: y <- apply(z,1,function(x) x/c(2,8))
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y <- apply(z,1,function(x) x/c(2,8))
- en: y
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y
- en: '[,1] [,2] [,3]'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2] [,3]'
- en: '[1,] 0.5 1.000 1.50'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,] 0.5 1.000 1.50'
- en: '[2,] 0.5 0.625 0.75'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,] 0.5 0.625 0.75'
- en: What really happened here? The third formal argument to apply() must be a function,
    which is exactly what we supplied here, since the return value of function() is
    a function!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里到底发生了什么？apply()的第三个形式参数必须是一个函数，这正是我们在这里提供的，因为 function() 的返回值是一个函数！
- en: Doing things this way is often clearer than defining the function externally.
    Of course, if the function is more complicated, that clarity is not attained.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式做事通常比在外部定义函数更清晰。当然，如果函数更复杂，那么这种清晰性就无法达到。
- en: '**188**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**188**'
- en: Chapter 7
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第七章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 20](index-215_1.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图像 20](index-215_1.png)'
- en: '**8**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**8**'
- en: '**DOING MATH AND SIMULATIONS IN R**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 R 中进行数学和模拟**'
- en: R contains built-in functions for your
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: R 包含了用于你的
- en: favorite math operations and, of course,
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最喜欢的数学运算，当然，
- en: for statistical distributions. This chapter
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 统计分布。本章
- en: provides an overview of using these functions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了使用这些函数的概述。
- en: Given the mathematical nature of this chapter, the
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章具有数学性质，因此
- en: examples assume a slightly higher-level knowledge
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例子假设有稍微高一级的知识水平
- en: than those in other chapters. You should be familiar
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: than those in other chapters. You should be familiar
- en: with calculus and linear algebra to get the most out
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: with calculus and linear algebra to get the most out
- en: of these examples.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: of these examples.
- en: '**8.1 Math Functions**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.1 数学函数**'
- en: 'R includes an extensive set of built-in math functions. Here is a partial list:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: R 包含了大量的内置数学函数。以下是一个部分列表：
- en: •
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'exp(): Exponential function, base e'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'exp(): 指数函数，底数为 e'
- en: •
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'log(): Natural logarithm'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'log(): 自然对数'
- en: •
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'log10(): Logarithm base 10'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'log10(): 以 10 为底的对数'
- en: •
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'sqrt(): Square root'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'sqrt(): 平方根'
- en: •
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'abs(): Absolute value'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'abs(): 绝对值'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: •
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'sin(), cos(), and so on: Trig functions'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: sin(), cos() 和等等：三角函数
- en: •
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'min() and max(): Minimum value and maximum value within a vector'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: min() 和 max()：向量内的最小值和最大值
- en: •
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'which.min() and which.max(): Index of the minimal element and maximal element
    of a vector'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: which.min() 和 which.max()：向量中元素的最小值和最大值的索引
- en: •
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'pmin() and pmax(): Element-wise minima and maxima of several vectors'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: pmin() 和 pmax()：多个向量的逐元素最小值和最大值
- en: •
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'sum() and prod(): Sum and product of the elements of a vector'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: sum() 和 prod()：向量的元素之和和乘积
- en: •
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'cumsum() and cumprod(): Cumulative sum and product of the elements of a vector'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: cumsum() 和 cumprod()：向量的累积和和累积乘积
- en: •
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'round(), floor(), and ceiling(): Round to the closest integer, to the closest
    integer below, and to the closest integer above'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 'round(), floor(), and ceiling(): 四舍五入到最接近的整数，到最接近的整数以下，和到最接近的整数以上'
- en: •
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'factorial(): Factorial function'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'factorial(): 阶乘函数'
- en: '***8.1.1 Extended Example: Calculating a Probability***'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '***8.1.1 扩展示例：计算概率***'
- en: As our first example, we’ll work through calculating a probability using the
    prod() function. Suppose we have *n* independent events, and the *i* th event
    has the probability *pi* of occurring. What is the probability of exactly one
    of these events occurring?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，我们将通过使用 prod() 函数计算一个概率。假设我们有 *n* 个独立事件，第 *i* 个事件发生的概率是 *pi*。这些事件中恰好有一个发生的概率是多少？
- en: 'Suppose first that *n* = 3 and our events are named A, B, and C. Then we break
    down the computation as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设首先 *n* = 3，并且我们的事件命名为 A、B 和 C。然后我们按以下方式分解计算：
- en: P(exactly one event occurs)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: P(exactly one event occurs)
- en: '='
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '='
- en: P(A and not B and not C)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: P(A and not B and not C)
- en: +
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: P(not A and B and not C)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: P(not A and B and not C)
- en: +
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: P(not A and not B and C)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: P(not A and not B and C)
- en: P(A and not B and not C) would be *pA*(1 *− pB*)(1 *− pC*), and so on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: P(A and not B and not C) 将是 *pA*(1 *− pB*)(1 *− pC*)，依此类推。
- en: 'For general *n*, that is calculated as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一般的 *n*，计算如下：
- en: '*n*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*'
- en: '*pi*(1 *−p* 1) *...* (1 *−pi−* 1)(1 *−pi*+1) *...* (1 *−pn*) *i*=1'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*pi*(1 *−p* 1) *...* (1 *−pi−* 1)(1 *−pi*+1) *...* (1 *−pn*) *i*=1'
- en: (The *i* th term inside the sum is the probability that event *i* occurs and
    all the others do *not* occur.)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: (求和中的第 *i* 项是事件 *i* 发生且其他所有事件都不发生的概率。)
- en: 'Here’s code to compute this, with our probabilities *pi* contained in the vector
    p:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是计算这个的代码，其中我们的概率 *pi* 包含在向量 p 中：
- en: exactlyone <- function(p) {
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: exactlyone <- function(p) {
- en: notp <- 1 - p
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: notp <- 1 - p
- en: tot <- 0.0
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: tot <- 0.0
- en: for (i in 1:length(p))
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:length(p))
- en: tot <- tot + p[i] * prod(notp[-i])
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: tot <- tot + p[i] * prod(notp[-i])
- en: return(tot)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: return(tot)
- en: '}'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**190**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**190**'
- en: Chapter 8
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: How does it work? Well, the assignment
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的呢？嗯，赋值
- en: notp <- 1 - p
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: notp <- 1 - p
- en: creates a vector of all the “not occur” probabilities 1 *− pj*, using recycling.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回收机制创建一个包含所有“不发生”概率 1 *− pj* 的向量。
- en: The expression notp[-i] computes the product of all the elements of notp, except
    the *i* th—exactly what we need.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 notp[-i] 计算除了第 *i* 个元素之外的所有 notp 元素的乘积——这正是我们所需要的。
- en: '***8.1.2 Cumulative Sums and Products***'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '***8.1.2 累积和与累积乘积***'
- en: As mentioned, the functions cumsum() and cumprod() return cumulative sums and
    products.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，函数 cumsum() 和 cumprod() 返回累积和和累积乘积。
- en: x <- c(12,5,13)
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- c(12,5,13)
- en: cumsum(x)
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cumsum(x)
- en: '[1] 12 17 30'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 12 17 30'
- en: cumprod(x)
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cumprod(x)
- en: '[1] 12 60 780'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 12 60 780'
- en: In x, the sum of the first element is 12, the sum of the first two elements
    is 17, and the sum of the first three elements is 30\.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在向量 x 中，第一个元素的总和是 12，前两个元素的总和是 17，前三个元素的总和是 30。
- en: The function cumprod() works the same way as cumsum(), but with the product
    instead of the sum.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 cumprod() 与 cumsum() 的工作方式相同，但使用乘积而不是和。
- en: '***8.1.3 Minima and Maxima***'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '***8.1.3 最小值和最大值***'
- en: There is quite a difference between min() and pmin(). The former simply combines
    all its arguments into one long vector and returns the minimum value in that vector.
    In contrast, if pmin() is applied to two or more vectors, it returns a vector
    of the pair-wise minima, hence the name pmin.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: min() 和 pmin() 之间有很大的区别。前者简单地将所有参数组合成一个长向量，并返回该向量中的最小值。相比之下，如果将 pmin() 应用到两个或多个向量上，它将返回一个包含成对最小值的向量，因此得名
    pmin。
- en: 'Here’s an example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: z
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z
- en: '[,1] [,2]'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,]'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '1'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '[2,]'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '5'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '3'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '[3,]'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,]'
- en: '6'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '2'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: min(z[,1],z[,2])
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: min(z[,1],z[,2])
- en: '[1] 1'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1'
- en: pmin(z[,1],z[,2])
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pmin(z[,1],z[,2])
- en: '[1] 1 3 2'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 3 2'
- en: In the first case, min() computed the smallest value in (1,5,6,2,3,2). But the
    call to pmin() computed the smaller of 1 and 2, yielding 1; then the smaller of
    5 and 3, which is 3; then finally the minimum of 6 and 2, giving 2\. Thus, the
    call returned the vector (1,3,2).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，min() 计算了 (1,5,6,2,3,2) 中的最小值。但 pmin() 的调用计算了 1 和 2 中的较小值，得到 1；然后计算
    5 和 3 中的较小值，即 3；最后计算 6 和 2 的最小值，得到 2。因此，调用返回了向量 (1,3,2)。
- en: Doing Math and Simulations in R
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中进行数学和模拟
- en: '**191**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**191**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'You can use more than two arguments in pmin(), like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 pmin() 中使用超过两个参数，如下所示：
- en: pmin(z[1,],z[2,],z[3,])
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pmin(z[1,],z[2,],z[3,])
- en: '[1] 1 2'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 2'
- en: The 1 in the output is the minimum of 1, 5, and 6, with a similar computation
    leading to the 2\.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的 1 是 1、5 和 6 的最小值，类似的计算导致了 2。
- en: The max() and pmax() functions act analogously to min() and pmin().
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: max() 和 pmax() 函数与 min() 和 pmin() 类似。
- en: Function minimization/maximization can be done via nlm() and optim().
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 函数最小化/最大化可以通过 nlm() 和 optim() 完成。
- en: For example, let’s find the smallest value of *f* ( *x*) = *x* 2 *−* sin( *x*).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们找到 *f* ( *x*) = *x* 2 *−* sin( *x*) 的最小值。
- en: nlm(function(x) return(x^2-sin(x)),8)
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: nlm(function(x) return(x^2-sin(x)),8)
- en: $minimum
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: $minimum
- en: '[1] -0.2324656'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] -0.2324656'
- en: $estimate
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: $estimate
- en: '[1] 0.4501831'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.4501831'
- en: $gradient
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: $gradient
- en: '[1] 4.024558e-09'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 4.024558e-09'
- en: $code
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: $code
- en: '[1] 1'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1'
- en: $iterations
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: $iterations
- en: '[1] 5'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 5'
- en: Here, the minimum value was found to be approximately *−* 0.23, occurring at
    *x* = 0.45\. A Newton-Raphson method (a technique from numerical analysis for
    approximating roots) is used, running five iterations in this case.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，最小值被找到大约为 *−* 0.23，发生在 *x* = 0.45。这里使用了牛顿-拉夫森方法（一种数值分析技术，用于近似根），在这种情况下运行了五次迭代。
- en: The second argument specifies the initial guess, which we set to be 8\. (This
    second argument was picked pretty arbitrarily here, but in some problems, you
    may need to experiment to find a value that will lead to convergence.)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数指定初始猜测值，我们将其设置为 8。 (这里第二个参数的选择相当随意，但在某些问题中，你可能需要实验以找到导致收敛的值。)
- en: '***8.1.4 Calculus***'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '***8.1.4 微积分***'
- en: R also has some calculus capabilities, including symbolic differentiation and
    numerical integration, as you can see in the following example.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: R 还有一些微积分功能，包括符号微分和数值积分，如下面的例子所示。
- en: 'D(expression(exp(x^2)),"x") # derivative'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'D(expression(exp(x^2)),"x") # 导数'
- en: exp(x^2) * (2 * x)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: exp(x^2) * (2 * x)
- en: integrate(function(x) x^2,0,1)
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: integrate(function(x) x^2,0,1)
- en: 0.3333333 with absolute error < 3.7e-15
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 0.3333333，绝对误差小于 3.7e-15
- en: '**192**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**192**'
- en: Chapter 8
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Here, R reported
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，R报告了
- en: '*d ex* 2 = 2 *xex* 2'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*d ex* 2 = 2 *xex* 2'
- en: '*dx*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*dx*'
- en: and
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '1'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '*x* 2 *dx ≈* 0 *.* 3333333'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* 2 *dx ≈* 0 *.* 3333333'
- en: '0'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: You can find R packages for differential equations (odesolve), for interfacing
    R with the Yacas symbolic math system (ryacas), and for other calculus operations.
    These packages, and thousands of others, are available from the Comprehensive
    R Archive Network (CRAN); see Appendix B.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找到用于微分方程（odesolve）、用于将R与Yacas符号数学系统接口（ryacas）以及其他微积分操作的R包。这些包以及成千上万的其他包，都可以从综合R存档网络（CRAN）获得；参见附录B。
- en: '**8.2 Functions for Statistical Distributions**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.2 统计分布函数**'
- en: R has functions available for most of the famous statistical distributions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: R 有大多数著名统计分布的函数可用。
- en: 'Prefix the name as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式添加名称前缀：
- en: •
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: With d for the density or probability mass function (pmf)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 d 表示密度或概率质量函数（pmf）
- en: •
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: With p for the cumulative distribution function (cdf)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 p 表示累积分布函数（cdf）
- en: •
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: With q for quantiles
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 q 表示分位数
- en: •
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: With r for random number generation
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 r 生成随机数
- en: The rest of the name indicates the distribution. Table 8-1 lists some common
    statistical distribution functions.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 名称的其余部分表示分布。表8-1列出了一些常见的统计分布函数。
- en: '**Table 8-1:** Common R Statistical Distribution Functions'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**表8-1：常见的R统计分布函数**'
- en: '**Distribution**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布**'
- en: '**Density/pmf**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**密度/概率质量函数**'
- en: '**cdf**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**累积分布函数**'
- en: '**Quantiles**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**分位数**'
- en: '**Random Numbers**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机数**'
- en: Normal
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正态
- en: dnorm()
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: dnorm()
- en: pnorm()
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: pnorm()
- en: qnorm()
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: qnorm()
- en: rnorm()
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: rnorm()
- en: Chi square
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 卡方
- en: dchisq()
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: dchisq()
- en: pchisq()
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: pchisq()
- en: qchisq()
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: qchisq()
- en: rchisq()
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: rchisq()
- en: Binomial
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 二项式
- en: dbinom()
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: dbinom()
- en: pbinom()
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: pbinom()
- en: qbinom()
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: qbinom()
- en: rbinom()
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: rbinom()
- en: As an example, let’s simulate 1,000 chi-square variates with 2 degrees of freedom
    and find their mean.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们模拟 1,000 个具有 2 个自由度的卡方变量，并找到它们的平均值。
- en: mean(rchisq(1000,df=2))
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mean(rchisq(1000,df=2))
- en: '[1] 1.938179'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1.938179'
- en: The r in rchisq specifies that we wish to generate random numbers—
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: rchisq 中的 r 表示我们希望生成随机数——
- en: in this case, from the chi-square distribution. As seen in this example, the
    first argument in the r-series functions is the number of random variates to generate.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，来自卡方分布。如本例所示，r 系列函数中的第一个参数是要生成的随机变量的数量。
- en: Doing Math and Simulations in R
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中进行数学和模拟
- en: '**193**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**193**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: These functions also have arguments specific to the given distribution families.
    In our example, we use the df argument for the chi-square family, indicating the
    number of degrees of freedom.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数也有针对给定分布族特定的参数。在我们的例子中，我们使用 df 参数来表示卡方分布的自由度数。
- en: '**NOTE**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Consult R’s online help for details on the arguments for the statistical distribution*
    *functions. For instance, to find our more about the chi-square function for quantiles,*
    *type ?qchisq at the command prompt.*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关统计分布函数参数的详细信息，请咨询 R 的在线帮助。例如，要了解更多关于分位数卡方函数的信息，请在命令提示符中输入 ?qchisq。*'
- en: 'Let’s also compute the 95th percentile of the chi-square distribution with
    two degrees of freedom:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也计算具有两个自由度的卡方分布的 95% 分位数：
- en: qchisq(0.95,2)
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: qchisq(0.95,2)
- en: '[1] 5.991465'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 5.991465'
- en: Here, we used q to indicate quantile—in this case, the 0.95 quantile, or the
    95th percentile.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 q 来表示分位数——在这种情况下，0.95 分位数或 95% 分位数。
- en: The first argument in the d, p, and q series is actually a vector so that we
    can evaluate the density/pmf, cdf, or quantile function at multiple points.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: d, p, 和 q 系列中的第一个参数实际上是一个向量，这样我们就可以在多个点上评估密度/概率质量函数、累积分布函数或分位数函数。
- en: Let’s find both the 50th and 95th percentiles of the chi-square distribution
    with 2 degrees of freedom.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到具有 2 个自由度的卡方分布的 50% 和 95% 分位数。
- en: qchisq(c(0.5,0.95),df=2)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: qchisq(c(0.5,0.95),df=2)
- en: '[1] 1.386294 5.991465'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1.386294 5.991465'
- en: '**8.3 Sorting**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.3 排序**'
- en: 'Ordinary numerical sorting of a vector can be done with the sort() function,
    as in this example:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 普通数值排序可以使用 sort() 函数完成，如下例所示：
- en: x <- c(13,5,12,5)
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- c(13,5,12,5)
- en: sort(x)
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sort(x)
- en: '[1] 5 5 12 13'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 5 5 12 13'
- en: x
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x
- en: '[1] 13 5 12 5'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 13 5 12 5'
- en: Note that x itself did not change, in keeping with R’s functional language philosophy.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，x 本身没有改变，这符合 R 的函数式语言哲学。
- en: 'If you want the indices of the sorted values in the original vector, use the
    order() function. Here’s an example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要原始向量中排序值的索引，请使用 order() 函数。以下是一个示例：
- en: order(x)
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: order(x)
- en: '[1] 2 4 3 1'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2 4 3 1'
- en: This means that x[2] is the smallest value in x, x[4] is the second smallest,
    x[3] is the third smallest, and so on.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 x[2] 是 x 中最小的值，x[4] 是第二小的，x[3] 是第三小的，依此类推。
- en: '**194**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**194**'
- en: Chapter 8
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'You can use order(), together with indexing, to sort data frames, like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 order() 与索引一起对数据框进行排序，如下所示：
- en: y
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y
- en: V1 V2
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: V1 V2
- en: 1 def 2
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 1 def 2
- en: '2'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: ab 5
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ab 5
- en: 3 zzzz 1
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 3 zzzz 1
- en: r <- order(y$V2)
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: r <- order(y$V2)
- en: r
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: r
- en: '[1] 3 1 2'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 3 1 2'
- en: z <- y[r,]
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z <- y[r,]
- en: z
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z
- en: V1 V2
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: V1 V2
- en: 3 zzzz 1
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 3 zzzz 1
- en: 1 def 2
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 1 def 2
- en: '2'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: ab 5
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ab 5
- en: What happened here? We called order() on the second column of y,
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？我们对 y 的第二列调用了 order()，
- en: yielding a vector r, telling us where numbers should go if we want to sort them.
    The 3 in this vector tells us that x[3,2] is the smallest number in x[,2]; the
    1 tells us that x[1,2] is the second smallest; and the 2 tells us that x[2,2]
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 得到一个向量 r，告诉我们如果我们要排序这些数字，它们应该放在哪里。这个向量中的 3 告诉我们 x[3,2] 是 x[,2] 中最小的数字；1 告诉我们
    x[1,2] 是第二小的；2 告诉我们 x[2,2]
- en: is the third smallest. We then use indexing to produce the frame sorted by column
    2, storing it in z.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 是第三小的。然后我们使用索引来生成按列 2 排序的框架，将其存储在 z 中。
- en: 'You can use order() to sort according to character variables as well as numeric
    ones, as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 order() 根据字符变量以及数值变量进行排序，如下所示：
- en: d
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d
- en: kids ages
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 孩子的年龄
- en: 1 Jack
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 1 Jack
- en: '12'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: 2 Jill
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 2 Jill
- en: '10'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: 3 Billy
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 3 Billy
- en: '13'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: d[order(d$kids),]
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d[order(d$kids),]
- en: kids ages
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 孩子的年龄
- en: 3 Billy
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 3 Billy
- en: '13'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: 1 Jack
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 1 Jack
- en: '12'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: 2 Jill
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 2 Jill
- en: '10'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: d[order(d$ages),]
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d[order(d$ages),]
- en: kids ages
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 孩子的年龄
- en: 2 Jill
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 2 Jill
- en: '10'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: 1 Jack
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 1 Jack
- en: '12'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: 3 Billy
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 3 Billy
- en: '13'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: A related function is rank(), which reports the rank of each element of a vector.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相关的一个函数是rank()，它报告向量的每个元素的秩。
- en: Doing Math and Simulations in R
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中进行数学和模拟
- en: '**195**'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**195**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: x <- c(13,5,12,5)
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- c(13,5,12,5)
- en: rank(x)
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: rank(x)
- en: '[1] 4.0 1.5 3.0 1.5'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 4.0 1.5 3.0 1.5'
- en: This says that 13 had rank 4 in x; that is, it is the fourth smallest. The value
    5 appears twice in x, with those two being the first and second smallest, so the
    rank 1.5 is assigned to both. Optionally, other methods of handling ties can be
    specified.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在x中13的秩是4；也就是说，它是第四小的。值5在x中出现了两次，这两个是第一和第二小的，所以秩1.5被分配给这两个。可选地，可以指定其他处理平局的方法。
- en: '**8.4 Linear Algebra Operations on Vectors and Matrices**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.4 向量和矩阵的线性代数运算**'
- en: 'Multiplying a vector by a scalar works directly, as you saw earlier. Here’s
    another example:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 将向量乘以标量可以直接进行，就像你之前看到的。这里还有一个例子：
- en: y
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y
- en: '[1] 1 3 4 10'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 3 4 10'
- en: 2*y
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2*y
- en: '[1] 2 6 8 20'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2 6 8 20'
- en: 'If you wish to compute the inner product (or dot product) of two vectors, use
    crossprod(), like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想计算两个向量的内积（或点积），使用crossprod()，如下所示：
- en: crossprod(1:3,c(5,12,13))
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: crossprod(1:3,c(5,12,13))
- en: '[,1]'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1]'
- en: '[1,]'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '68'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '68'
- en: The function computed 1 *·* 5 + 2 *·* 12 + 3 *·* 13 = 68\.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 函数计算了1 *·* 5 + 2 *·* 12 + 3 *·* 13 = 68。
- en: Note that the name crossprod() is a misnomer, as the function does not compute
    the vector cross product. We’ll develop a function to compute real cross products
    in Section 8.4.1\.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 注意crossprod()函数的名称是一个误称，因为这个函数并不计算向量的叉积。我们将在第8.4.1节开发一个计算实数叉积的函数。
- en: 'For matrix multiplication in the mathematical sense, the operator to use is
    %*%, not *. For instance, here we compute the matrix product:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数学意义上的矩阵乘法，应使用%*%运算符，而不是*。例如，这里我们计算矩阵乘积：
- en: 1 2
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2
- en: 1 *−* 1
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 1 *−* 1
- en: 1 1
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 1 1
- en: 3 4
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 3 4
- en: '0'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '='
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '='
- en: 3 1
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 3 1
- en: 'Here’s the code:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: a
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a
- en: '[,1] [,2]'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,]'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '1'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '[2,]'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '3'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: b
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b
- en: '[,1] [,2]'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,]'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '1'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '-1'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '-1'
- en: '[2,]'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '0'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '**196**'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**196**'
- en: Chapter 8
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: a %*% b
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a %*% b
- en: '[,1] [,2]'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,]'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '1'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '[2,]'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '3'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '1'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'The function solve() will solve systems of linear equations and even find matrix
    inverses. For example, let’s solve this system:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 函数solve()将解决线性方程组，甚至找到矩阵的逆。例如，让我们解这个系统：
- en: '*x* 1 + *x* 2 = 2'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* 1 + *x* 2 = 2'
- en: '*−x* 1 + *x* 2 = 4'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '*−x* 1 + *x* 2 = 4'
- en: 'Its matrix form is as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 它的矩阵形式如下：
- en: '1'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '*x* 1'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* 1'
- en: '2'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '*−* 1 1'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '*−* 1 1'
- en: '='
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '='
- en: '*x* 2'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* 2'
- en: '4'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'Here’s the code:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: a <- matrix(c(1,1,-1,1),nrow=2,ncol=2)
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a <- matrix(c(1,1,-1,1),nrow=2,ncol=2)
- en: b <- c(2,4)
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b <- c(2,4)
- en: solve(a,b)
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: solve(a,b)
- en: '[1] 3 1'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 3 1'
- en: solve(a)
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: solve(a)
- en: '[,1] [,2]'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,] 0.5 0.5'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,] 0.5 0.5'
- en: '[2,] -0.5 0.5'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,] -0.5 0.5'
- en: In that second call to solve(), the lack of a second argument signifies that
    we simply wish to compute the inverse of the matrix.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次调用solve()时，缺少第二个参数表示我们只想计算矩阵的逆。
- en: 'Here are a few other linear algebra functions:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些其他的线性代数函数：
- en: •
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 't(): Matrix transpose'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 't(): 矩阵转置'
- en: •
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'qr(): QR decomposition'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 'qr(): QR分解'
- en: •
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'chol(): Cholesky decomposition'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 'chol(): Cholesky分解'
- en: •
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'det(): Determinant'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 'det(): 行列式'
- en: •
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'eigen(): Eigenvalues/eigenvectors'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 'eigen(): 特征值/特征向量'
- en: •
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'diag(): Extracts the diagonal of a square matrix (useful for obtaining variances
    from a covariance matrix and for constructing a diagonal'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 'diag(): 提取方阵的对角线（用于从协方差矩阵中获取方差和构建对角矩阵）。'
- en: matrix).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵）。
- en: •
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'sweep(): Numerical analysis sweep operations'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 'sweep(): 数值分析扫掠操作'
- en: 'Note the versatile nature of diag(): If its argument is a matrix, it returns
    a vector, and vice versa. Also, if the argument is a scalar, the function returns
    the identity matrix of the specified size.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 注意diag()函数的通用性：如果其参数是一个矩阵，它返回一个向量，反之亦然。此外，如果参数是标量，该函数返回指定大小的单位矩阵。
- en: Doing Math and Simulations in R
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中进行数学和模拟
- en: '**197**'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '**197**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: m
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m
- en: '[,1] [,2]'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,]'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '1'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '[2,]'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '7'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '8'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: dm <- diag(m)
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dm <- diag(m)
- en: dm
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dm
- en: '[1] 1 8'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 8'
- en: diag(dm)
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: diag(dm)
- en: '[,1] [,2]'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,]'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '1'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '0'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '[2,]'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '0'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '8'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: diag(3)
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: diag(3)
- en: '[,1] [,2] [,3]'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2] [,3]'
- en: '[1,]'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '1'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '0'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '[2,]'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '0'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '0'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '[3,]'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,]'
- en: '0'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: The sweep() function is capable of fairly complex operations. As a simple example,
    let’s take a 3-by-3 matrix and add 1 to row 1, 4 to row 2, and 7 to row 3\.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: sweep()函数可以进行相当复杂的操作。作为一个简单的例子，让我们取一个3x3矩阵，并将1加到第1行，4加到第2行，7加到第3行。
- en: m
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m
- en: '[,1] [,2] [,3]'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2] [,3]'
- en: '[1,]'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '1'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '[2,]'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '4'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '[3,]'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,]'
- en: '7'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '8'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '9'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: sweep(m,1,c(1,4,7),"+")
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sweep(m,1,c(1,4,7),"+")
- en: '[,1] [,2] [,3]'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2] [,3]'
- en: '[1,]'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '2'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '[2,]'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '8'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '9'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: '10'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: '[3,]'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,]'
- en: '14'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '15'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '16'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: 'The first two arguments to sweep() are like those of apply(): the array and
    the margin, which is 1 for rows in this case. The fourth argument is a function
    to be applied, and the third is an argument to that function (to the'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: sweep()的前两个参数类似于apply()的参数：数组和对齐，在这种情况下对齐为1。第四个参数是要应用的函数，第三个是该函数的参数（到
- en: '"+" function).'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: “+”函数）。
- en: '***8.4.1 Extended Example: Vector Cross Product***'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '***8.4.1 扩展示例：向量叉积***'
- en: 'Let’s consider the issue of vector cross products. The definition is very simple:
    The cross product of vectors ( *x* 1 *, x* 2 *, x* 3) and ( *y* 1 *, y* 2 *, y*
    3) in three-dimensional space is a new three-dimensional vector, as shown in Equation
    8.1\.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑向量叉积的问题。定义非常简单：在三维空间中，向量( *x* 1 *, x* 2 *, x* 3)和( *y* 1 *, y* 2 *, y*
    3)的叉积是一个新的三维向量，如方程8.1所示。
- en: ( *x* 2 *y* 3 *− x* 3 *y* 2 *, −x* 1 *y* 3 + *x* 3 *y* 1 *, x* 1 *y* 2 *− x*
    2 *y* 1) (8.1)
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: ( *x* 2 *y* 3 *− x* 3 *y* 2 *, −x* 1 *y* 3 + *x* 3 *y* 1 *, x* 1 *y* 2 *− x*
    2 *y* 1) (8.1)
- en: '**198**'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '**198**'
- en: Chapter 8
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: This can be expressed compactly as the expansion along the top row of the determinant,
    as shown in Equation 8.2\.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以简洁地表示为行列式顶行的展开，如方程8.2所示。
- en: ⎛
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: ⎛
- en: ⎞
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: ⎞
- en: '*− − −*'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '*− − −*'
- en: ⎝ *x* 1 *x* 2 *x* 3 ⎠
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: ⎝ *x* 1 *x* 2 *x* 3 ⎠
- en: (8.2)
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: (8.2)
- en: '*y* 1'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* 1'
- en: '*y* 2'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* 2'
- en: '*y* 3'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* 3'
- en: Here, the elements in the top row are merely placeholders.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，顶行中的元素仅仅是占位符。
- en: Don’t worry about this bit of pseudomath. The point is that the cross product
    vector can be computed as a sum of subdeterminants. For instance, the first component
    in Equation 8.1, *x* 2 *y* 3 *− x* 3 *y* 2, is easily seen to be the determinant
    of the submatrix obtained by deleting the first row and first column in Equation
    8.2, as shown in Equation 8.3\.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心这段伪数学。重点是叉积向量可以计算为子行列式的和。例如，方程8.1中的第一个分量，*x* 2 *y* 3 *− x* 3 *y* 2，很容易看出是删除方程8.2中第一行和第一列得到的子矩阵的行列式，如方程8.3所示。
- en: '*x* 2 *x* 3'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* 2 *x* 3'
- en: (8.3)
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: (8.3)
- en: '*y* 2'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* 2'
- en: '*y* 3'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* 3'
- en: Our need to calculate subdeterminants—that is determinants of
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要计算子行列式——即子矩阵的行列式
- en: submatrices—fits perfectly with R, which excels at specifying submatrices.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 子矩阵——与R完美匹配，R擅长指定子矩阵。
- en: 'This suggests calling det() on the proper submatrices, as follows:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明可以在适当的子矩阵上调用det()，如下所示：
- en: xprod <- function(x,y) {
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: xprod <- function(x,y) {
- en: m <- rbind(rep(NA,3),x,y)
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: m <- rbind(rep(NA,3),x,y)
- en: xp <- vector(length=3)
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: xp <- vector(length=3)
- en: for (i in 1:3)
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:3)
- en: xp[i] <- -(-1)^i * det(m[2:3,-i])
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: xp[i] <- -(-1)^i * det(m[2:3,-i])
- en: return(xp)
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: return(xp)
- en: '}'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Note that even R’s ability to specify values as NA came into play here to deal
    with the “placeholders” mentioned above.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使R指定NA值的能力也在这里发挥作用，以处理上面提到的“占位符”。
- en: All this may seem like overkill. After all, it wouldn’t have been hard to code
    Equation 8.1 directly, without resorting to use of submatrices and determinants.
    But while that may be true in the three-dimensional case, the approach shown here
    is quite fruitful in the *n*-ary case, in *n*-dimensional space. The cross product
    there is defined as an *n*-by- *n* determinant of the form shown in Equation 8.1,
    and thus the preceding code generalizes perfectly.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些可能看起来有些过度。毕竟，直接编码方程8.1并不困难，无需使用子矩阵和行列式。但是，虽然这在三维情况下可能是正确的，但这里展示的方法在*n*-元情况下，在*n*-维空间中非常有成效。那里的叉积被定义为形式如方程8.1的*n*-by-
    *n*行列式，因此前面的代码完美地推广了。
- en: '***8.4.2 Extended Example: Finding Stationary Distributions of Markov Chains***'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '***8.4.2 扩展示例：寻找马尔可夫链的平稳分布***'
- en: A Markov chain is a random process in which we move among various *states*,
    in a “memoryless” fashion, whose definition need not concern us here. The state
    could be the number of jobs in a queue, the number of items stored in inventory,
    and so on. We will assume the number of states to be finite.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫链是一种随机过程，我们在其中在各种*状态*之间移动，以“无记忆”的方式，其定义在此处不必关心。状态可以是队列中的作业数量，库存中存储的项目数量，等等。我们将假设状态的数量是有限的。
- en: As a simple example, consider a game in which we toss a coin repeatedly and
    win a dollar whenever we accumulate three consecutive heads.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简单的例子，考虑一个游戏，我们反复掷硬币，每次积累三个连续正面时赢得一美元。
- en: Our state at any time *i* will the number of consecutive heads we have so far,
    so our state can be 0, 1, or 2\. (When we get three heads in a row, our state
    reverts to 0.)
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，我们的状态*i*将表示到目前为止连续出现正面的次数，因此我们的状态可以是0、1或2。（当我们连续出现三个正面时，我们的状态将重置为0。）
- en: Doing Math and Simulations in R
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中进行数学和模拟
- en: '**199**'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**199**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The central interest in Markov modeling is usually the long-run state distribution,
    meaning the long-run proportions of the time we are in each state. In our coin-toss
    game, we can use the code we’ll develop here to calculate that distribution, which
    turns out to have us at states 0, 1, and 2 in proportions 57.1%, 28.6%, and 14.3%
    of the time. Note that we win our dollar if we are in state 2 and toss a head,
    so 0.143 *×* 0.5 = 0.071 of our tosses will result in wins.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在马尔可夫建模中，通常关注的中心问题是长期状态分布，即我们在每个状态中花费的长期时间比例。在我们的掷币游戏中，我们可以使用我们在这里开发的代码来计算这个分布，结果是我们有57.1%，28.6%，和14.3%的时间处于状态0，1和2。请注意，如果我们处于状态2并且掷出正面，我们将赢得一美元，所以0.143
    *×* 0.5 = 0.071的投掷将导致胜利。
- en: Since R vector and matrix indices start at 1 rather than 0, it will be convenient
    to relabel our states here as 1, 2, and 3 rather than 0, 1, and 2\. For example,
    state 3 now means that we currently have two consecutive heads.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 由于R向量和矩阵索引从1开始而不是0，在这里将我们的状态重新标记为1，2和3而不是0，1和2将很方便。例如，状态3现在表示我们目前有两个连续的正面。
- en: Let *pij* denote the *transition probability* of moving from state *i* to state
    *j* during a time step. In the game example, for instance, *p* 23 = 0 *.* 5, reflecting
    the fact that with probability 1/2, we will toss a head and thus move from having
    one consecutive head to two. On the other hand, if we toss a tail while we are
    in state 2, we go to state 1, meaning 0 consecutive heads; thus *p* 21 = 0 *.*
    5\.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 让 *pij* 表示在时间步长中从状态 *i* 转移到状态 *j* 的 *转移概率*。例如，在游戏示例中，*p* 23 = 0 *.* 5，反映了有1/2的概率我们会掷出正面，从而从连续一个正面转移到两个正面。另一方面，如果我们处于状态2时掷出反面，我们将转移到状态1，这意味着0个连续正面；因此
    *p* 21 = 0 *.* 5\。
- en: We are interested in calculating the vector *π* = ( *π* 1 *, ..., πs*), where
    *πi* is the long-run proportion of time spent at state i, over all states i. Let
    *P*
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的是计算向量 *π* = ( *π* 1 *, ..., πs*), 其中 *πi* 是在所有状态 i 中花费的长期时间比例，即状态 i 的长期比例。让
    *P*
- en: denote the transition probability matrix whose *i* th row, *j* th column element
    is *pij*. Then it can be shown that *π* must satisfy Equation 8.4, *π* = *πP*
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 表示转移概率矩阵，其 *i* 行， *j* 列的元素是 *pij*。然后可以证明 *π* 必须满足方程8.4，*π* = *πP*
- en: (8.4)
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: (8.4)
- en: 'which is equivalent to Equation 8.5:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这与方程8.5等价：
- en: ( *I − P T* ) *π* = 0
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: ( *I − P T* ) *π* = 0
- en: (8.5)
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: (8.5)
- en: Here *I* is the identity matrix and *P T* denotes the transpose of *P*.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 *I* 是单位矩阵，*P T* 表示 *P* 的转置。
- en: Any single one of the equations in the system of Equation 8.5 is redundant.
    We thus eliminate one of them, by removing the last row of *I −P* in Equation
    8.5\. That also means removing the last 0 in the 0 vector on the right-hand side
    of Equation 8.5\.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 方程组8.5中的任何一个方程都是多余的。因此，我们通过从方程8.5中的 *I −P* 去掉最后一行来消除其中一个方程。这也意味着去掉方程8.5右侧0向量中的最后一个0。
- en: But note that there is also the constraint shown in Equation 8.6\.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，还有方程8.6中显示的约束。
- en: '*πi* = 1'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '*πi* = 1'
- en: (8.6)
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: (8.6)
- en: '*i*'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '*i*'
- en: 'In matrix terms, this is as follows:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 用矩阵术语来说，如下所示：
- en: 1 *Tnπ* = 1
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 1 *Tnπ* = 1
- en: where 1 *n* is a vector of *n* 1s.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 1 *n* 是一个包含 *n* 个 1 的向量。
- en: So, in the modified version of Equation 8.5, we replace the removed row with
    a row of all 1s and, on the right-hand side, replace the removed 0 with a 1\.
    We can then solve the system.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在修改后的方程8.5版本中，我们用全1的行替换被移除的行，在右侧，用1替换被移除的0。然后我们可以求解这个系统。
- en: 'All this can be computed with R’s solve() function, as follows:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以使用R的solve()函数计算，如下所示：
- en: '1'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: findpi1 <- function(p) {
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: findpi1 <- function(p) {
- en: '2'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: n <- nrow(p)
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: n <- nrow(p)
- en: '3'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: imp <- diag(n) - t(p)
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: imp <- diag(n) - t(p)
- en: '**200**'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '**200**'
- en: Chapter 8
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '4'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: imp[n,] <- rep(1,n)
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: imp[n,] <- rep(1,n)
- en: '5'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: rhs <- c(rep(0,n-1),1)
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: rhs <- c(rep(0,n-1),1)
- en: '6'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: pivec <- solve(imp,rhs)
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: pivec <- solve(imp,rhs)
- en: '7'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: return(pivec)
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: return(pivec)
- en: '8'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '}'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Here are the main steps:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是主要步骤：
- en: 1\.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: Calculate *I − P T* in line 3\. Note again that diag(), when called with a scalar
    argument, returns the identity matrix of the size given by that argument.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行计算 *I − P T*。注意再次，当diag()用标量参数调用时，返回由该参数给定大小的单位矩阵。
- en: 2\.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: Replace the last row of *P* with 1 values in line 4\.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4行将 *P* 的最后一行替换为1值。
- en: 3\.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: Set up the right-hand side vector in line 5\.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5行设置右侧向量。
- en: 4\.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: Solve for *π* in line 6\.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6行求解 *π*。
- en: Another approach, using more advanced knowledge, is based on eigen-
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，基于更高级的知识，是基于特征-
- en: values. Note from Equation 8.4 that *π* is a left eigenvector of *P* with eigenvalue
    1\. This suggests using R’s eigen() function, selecting the eigenvector corresponding
    to that eigenvalue. (A result from mathematics, the Perron-Frobenius theorem,
    can be used to carefully justify this.)
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: values. 注意从方程式 8.4 中，*π* 是 *P* 的特征值为 1 的左特征向量。这表明可以使用 R 的 eigen() 函数，选择与该特征值对应的特征向量。（来自数学的一个结果，Perron-Frobenius
    定理可以用来仔细证明这一点。）
- en: 'Since *π* is a left eigenvector, the argument in the call to eigen() must be
    *P* transpose rather than *P*. In addition, since an eigenvector is unique only
    up to scalar multiplication, we must deal with two issues regarding the eigenvector
    returned to us by eigen():'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *π* 是一个左特征向量，调用 eigen() 时必须使用 *P* 的转置而不是 *P*。此外，由于特征向量仅在上标乘法下是唯一的，我们必须处理
    eigen() 返回给我们的特征向量涉及的两个问题：
- en: •
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: It may have negative components. If so, we multiply by *−* 1\.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能包含负分量。如果是这样，我们乘以 *−* 1\。
- en: •
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: It may not satisfy Equation 8.6\. We remedy this by dividing by the length of
    the returned vector.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能不满足方程式 8.6。我们通过除以返回向量的长度来解决这个问题。
- en: 'Here is the code:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '1'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: findpi2 <- function(p) {
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: findpi2 <- function(p) {
- en: '2'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: n <- nrow(p)
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: n <- nrow(p)
- en: '3'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: find first eigenvector of P transpose
  id: totrans-624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找 P 转置的第一个特征向量
- en: '4'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: pivec <- eigen(t(p))$vectors[,1]
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: pivec <- eigen(t(p))$vectors[,1]
- en: '5'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: guaranteed to be real, but could be negative
  id: totrans-628
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保证是真实的，但可能是负数
- en: '6'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: if (pivec[1] < 0) pivec <- -pivec
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: if (pivec[1] < 0) pivec <- -pivec
- en: '7'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: normalize to sum to 1
  id: totrans-632
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归一化，使总和为 1
- en: '8'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: pivec <- pivec / sum(pivec)
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: pivec <- pivec / sum(pivec)
- en: '9'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: return(pivec)
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: return(pivec)
- en: '10'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: '}'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The return value of eigen() is a list. One of the list’s components is a matrix
    named vectors. These are the eigenvectors, with the *i* th column being the eigenvector
    corresponding to the *i* th eigenvalue. Thus, we take column 1 here.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: eigen() 的返回值是一个列表。列表的一个组件是一个名为 vectors 的矩阵。这些是特征向量，其中第 *i* 列是与第 *i* 个特征值对应的特征向量。因此，我们在这里取第
    1 列。
- en: Doing Math and Simulations in R
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中进行数学和模拟
- en: '**201**'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '**201**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**8.5 Set Operations**'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.5 集合操作**'
- en: 'R includes some handy set operations, including these:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: R 包含一些方便的集合操作，包括这些：
- en: •
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'union(x,y): Union of the sets x and y'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 'union(x,y): 集合 x 和 y 的并集'
- en: •
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'intersect(x,y): Intersection of the sets x and y'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 'intersect(x,y): 集合 x 和 y 的交集'
- en: •
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'setdiff(x,y): Set difference between x and y, consisting of all elements of
    x that are not in y'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 'setdiff(x,y): 集合 x 和 y 的差集，由 x 中不在 y 中的所有元素组成'
- en: •
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'setequal(x,y): Test for equality between x and y'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 'setequal(x,y): 测试 x 和 y 是否相等'
- en: •
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'c %in% y: Membership, testing whether c is an element of the set y'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 'c %in% y: 检查 c 是否是集合 y 的元素'
- en: •
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'choose(n,k): Number of possible subsets of size k chosen from a set of size
    n'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 'choose(n,k): 从大小为 n 的集合中选择大小为 k 的可能子集的数量'
- en: 'Here are some simple examples of using these functions:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用这些函数的一些简单示例：
- en: x <- c(1,2,5)
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- c(1,2,5)
- en: y <- c(5,1,8,9)
  id: totrans-659
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y <- c(5,1,8,9)
- en: union(x,y)
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: union(x,y)
- en: '[1] 1 2 5 8 9'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 2 5 8 9'
- en: intersect(x,y)
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: intersect(x,y)
- en: '[1] 1 5'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 5'
- en: setdiff(x,y)
  id: totrans-664
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: setdiff(x,y)
- en: '[1] 2'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2'
- en: setdiff(y,x)
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: setdiff(y,x)
- en: '[1] 8 9'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 8 9'
- en: setequal(x,y)
  id: totrans-668
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: setequal(x,y)
- en: '[1] FALSE'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] FALSE'
- en: setequal(x,c(1,2,5))
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: setequal(x,c(1,2,5))
- en: '[1] TRUE'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] TRUE'
- en: 2 %in% x
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2 %in% x
- en: '[1] TRUE'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] TRUE'
- en: 2 %in% y
  id: totrans-674
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2 %in% y
- en: '[1] FALSE'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] FALSE'
- en: choose(5,2)
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: choose(5,2)
- en: '[1] 10'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 10'
- en: Recall from Section 7.12 that you can write your own binary operations.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 回想第 7.12 节，你可以编写自己的二元操作。
- en: For instance, consider coding the symmetric difference between two sets—
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑编码两个集合的对称差集—
- en: that is, all the elements belonging to exactly one of the two operand sets.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 即，恰好属于两个操作数集合之一的所有元素。
- en: 'Because the symmetric difference between sets x and y consists exactly of those
    elements in x but not y and vice versa, the code consists of easy calls to setdiff()
    and union(), as follows:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 因为集合 x 和 y 的对称差集正好由 x 中的元素组成，这些元素不在 y 中，反之亦然，所以代码由对 setdiff() 和 union() 的简单调用组成，如下所示：
- en: symdiff
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: symdiff
- en: function(a,b) {
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: function(a,b) {
- en: sdfxy <- setdiff(x,y)
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: sdfxy <- setdiff(x,y)
- en: sdfyx <- setdiff(y,x)
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: sdfyx <- setdiff(y,x)
- en: '**202**'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '**202**'
- en: Chapter 8
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: return(union(sdfxy,sdfyx))
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: return(union(sdfxy,sdfyx))
- en: '}'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Let’s try it.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。
- en: x
  id: totrans-692
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x
- en: '[1] 1 2 5'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 1 2 5'
- en: y
  id: totrans-694
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y
- en: '[1] 5 1 8 9'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 5 1 8 9'
- en: symdiff(x,y)
  id: totrans-696
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: symdiff(x,y)
- en: '[1] 2 8 9'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2 8 9'
- en: 'Here’s another example: a binary operand for determining whether one set u
    is a subset of another set v. A bit of thought shows that this property is equivalent
    to the intersection of u and v being equal to u. Hence we have another easily
    coded function:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个另一个例子：一个二元操作符，用于确定集合 u 是否是另一个集合 v 的子集。一点思考表明，这个属性等价于 u 和 v 的交集等于 u。因此，我们又有另一个容易编码的函数：
- en: '"%subsetof%" <- function(u,v) {'
  id: totrans-699
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"%subsetof%" <- function(u,v) {'
- en: +
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: return(setequal(intersect(u,v),u))
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: return(setequal(intersect(u,v),u))
- en: + }
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: + }
- en: c(3,8) %subsetof% 1:10
  id: totrans-703
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c(3,8) %subsetof% 1:10
- en: '[1] TRUE'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] TRUE'
- en: c(3,8) %subsetof% 5:10
  id: totrans-705
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c(3,8) %subsetof% 5:10
- en: '[1] FALSE'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] FALSE'
- en: The function combn() generates combinations. Let’s find the subsets of
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: combn() 函数生成组合。让我们找到 {1,2,3} 的子集。
- en: '{1,2,3} of size 2\.'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '{1,2,3} 的大小为 2\.'
- en: c32 <- combn(1:3,2)
  id: totrans-709
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c32 <- combn(1:3,2)
- en: c32
  id: totrans-710
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c32
- en: '[,1] [,2] [,3]'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2] [,3]'
- en: '[1,]'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,]'
- en: '1'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '[2,]'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,]'
- en: '2'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '3'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: class(c32)
  id: totrans-720
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: class(c32)
- en: '[1] "matrix"'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "matrix"'
- en: The results are in the columns of the output. We see that the subsets of
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在输出列中。我们看到 {1,2,3} 的子集有 (1,2)，(1,3)，(2,3)，(1,2,3)。
- en: '{1,2,3} of size 2 are (1,2), (1,3), and (2,3).'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 大小为 2 的 {1,2,3} 的子集是 (1,2)，(1,3) 和 (2,3)。
- en: 'The function also allows you to specify a function to be called by combn()
    on each combination. For example, we can find the sum of the numbers in each subset,
    like this:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数还允许您指定一个由 combn() 在每个组合上调用的函数。例如，我们可以找到每个子集的数字之和，如下所示：
- en: combn(1:3,2,sum)
  id: totrans-725
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: combn(1:3,2,sum)
- en: '[1] 3 4 5'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 3 4 5'
- en: The first subset, {1,2}, has a sum of 2, and so on.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个子集 {1,2} 的和为 2，以此类推。
- en: Doing Math and Simulations in R
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中进行数学和模拟
- en: '**203**'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '**203**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**8.6 Simulation Programming in R**'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.6 R 中的模拟编程**'
- en: One of the most common uses of R is simulation. Let’s see what kinds of tools
    R has available for this application.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: R 最常见的用途之一是模拟。让我们看看 R 为此应用提供了哪些工具。
- en: '***8.6.1 Built-In Random Variate Generators***'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '***8.6.1 内置随机变量生成器***'
- en: As mentioned, R has functions to generate variates from a number of different
    distributions. For example, rbinom() generates binomial or Bernoulli random variates.1
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，R 有函数可以生成来自多种分布的变量。例如，rbinom() 生成二项分布或伯努利随机变量。1
- en: Let’s say we want to find the probability of getting at least four heads out
    of five tosses of a coin (easy to find analytically, but a handy example).
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要找到在五次抛硬币中至少得到四个正面的概率（虽然可以通过解析方法找到，但这是一个方便的例子）。
- en: 'Here’s how we can do this:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做到：
- en: x <- rbinom(100000,5,0.5)
  id: totrans-737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- rbinom(100000,5,0.5)
- en: mean(x >= 4)
  id: totrans-738
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mean(x >= 4)
- en: '[1] 0.18829'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 0.18829'
- en: First, we generate 100,000 variates from a binomial distribution with five trials
    and a success probability of 0.5\. We then determine which of them has a value
    4 or 5, resulting in a Boolean vector of the same length as x. The TRUE
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从具有五次试验和成功概率为 0.5 的二项分布中生成 100,000 个变量。然后我们确定其中哪些具有值 4 或 5，结果是一个与 x 长度相同的布尔向量。TRUE
- en: and FALSE values in that vector are treated as 1s and 0s by mean(), giving us
    our estimated probability (since the average of a bunch of 1s and 0s is the proportion
    of 1s).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在该向量中的 TRUE 和 FALSE 值由 mean() 处理为 1 和 0，从而得到我们的估计概率（因为一串 1 和 0 的平均值是 1 的比例）。
- en: Other functions include rnorm() for the normal distribution, rexp() for the
    exponential, runif() for the uniform, rgamma() for the gamma, rpois() for the
    Poisson, and so on.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 其他函数包括 rnorm() 用于正态分布，rexp() 用于指数分布，runif() 用于均匀分布，rgamma() 用于伽马分布，rpois() 用于泊松分布等等。
- en: 'Here is another simple example, which finds *E*[max( *X, Y* )], the expected
    value of the maximum of independent N(0,1) random variables X and Y:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子，它找到 *E*[max( *X, Y* )]，独立 N(0,1) 随机变量 X 和 Y 的最大值的期望值：
- en: sum <- 0
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: sum <- 0
- en: nreps <- 100000
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: nreps <- 100000
- en: for (i in 1:nreps) {
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:nreps) {
- en: 'xy <- rnorm(2) # generate 2 N(0,1)s'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 'xy <- rnorm(2) # 生成 2 个 N(0,1)'
- en: sum <- sum + max(xy)
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: sum <- sum + max(xy)
- en: '}'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: print(sum/nreps)
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: print(sum/nreps)
- en: We generated 100,000 pairs, found the maximum for each, and aver-
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成了 100,000 对，找到每一对的最大值，并平均这些最大值以获得我们的估计期望值。
- en: aged those maxima to obtain our estimated expected value.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些最大值平均以获得我们的估计期望值。
- en: The preceding code, with an explicit loop, may be clearer, but as before, if
    we are willing to use some more memory, we can do this more compactly.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码，使用显式循环可能更清晰，但正如之前所说，如果我们愿意使用更多内存，我们可以更紧凑地完成这项工作。
- en: 1 A sequence of independent 0- and 1- valued random variables with the same
    probability of 1
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 1 一系列独立的 0-和 1-值随机变量，具有相同的 1 概率
- en: for each is called *Bernoulli*.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个称为 *伯努利*。
- en: '**204**'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '**204**'
- en: Chapter 8
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: emax
  id: totrans-759
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: emax
- en: function(nreps) {
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: function(nreps) {
- en: x <- rnorm(2*nreps)
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: x <- rnorm(2*nreps)
- en: maxxy <- pmax(x[1:nreps],x[(nreps+1):(2*nreps)])
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: maxxy <- pmax(x[1:nreps],x[(nreps+1):(2*nreps)])
- en: return(mean(maxxy))
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: return(mean(maxxy))
- en: '}'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Here, we generated double nreps values. The first nreps value simulates X, and
    the remaining nreps value represents Y. The pmax() call then computes the pair-wise
    maxima that we need. Again, note the contrast here between max() and pmax(), the
    latter producing pair-wise maxima.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们生成了双倍的nreps值。第一个nreps值模拟X，剩余的nreps值代表Y。pmax()调用然后计算所需的成对最大值。再次注意这里max()和pmax()之间的对比，后者产生成对最大值。
- en: '***8.6.2 Obtaining the Same Random Stream in Repeated Runs***'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '***8.6.2 在重复运行中获得相同的随机流***'
- en: According to the R documentation, all random-number generators use
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 根据R文档，所有随机数生成器都使用
- en: 32-bit integers for seed values. Thus, other than round-off error, the same
    initial seed should generate the same stream of numbers.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 32位整数用于种子值。因此，除了舍入误差外，相同的初始种子应该生成相同的数字流。
- en: 'By default, R will generate a different random number stream from run to run
    of a program. If you want the same stream each time—important in debugging, for
    instance—call set.seed(), like this:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，R将在程序的每次运行中生成不同的随机数流。如果您希望每次都生成相同的流——例如在调试中很重要——请调用set.seed()，如下所示：
- en: 'set.seed(8888) # or your favorite number as an argument'
  id: totrans-770
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'set.seed(8888) # 或者使用你喜欢的数字作为参数'
- en: '***8.6.3 Extended Example: A Combinatorial Simulation***'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '***8.6.3 扩展示例：组合模拟***'
- en: 'Consider the following probability problem:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下概率问题：
- en: Three committees, of sizes 3, 4 and 5, are chosen from 20 people.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 从20个人中选择3个、4个和5个规模的委员会。
- en: What is the probability that persons A and B are chosen for the
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: A和B被选中的概率是多少？
- en: same committee?
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 同一委员会？
- en: This problem is not hard to solve analytically, but we may wish to check our
    solution using simulation, and in any case, writing the code will demonstrate
    how R’s set operations can come in handy in combinatorial settings.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题从理论上解决并不难，但我们可能希望使用模拟来检查我们的解决方案，并且无论如何，编写代码将展示R的集合操作如何在组合设置中派上用场。
- en: 'Here is the code:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '1'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: sim <- function(nreps) {
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: sim <- function(nreps) {
- en: '2'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: 'commdata <- list() # will store all our info about the 3 committees 3'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 'commdata <- list() # 将存储关于3个委员会的所有信息 3'
- en: commdata$countabsamecomm <- 0
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: commdata$countabsamecomm <- 0
- en: '4'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: for (rep in 1:nreps) {
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: for (rep in 1:nreps) {
- en: '5'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: 'commdata$whosleft <- 1:20 # who''s left to choose from'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 'commdata$whosleft <- 1:20 # 剩余可供选择的人'
- en: '6'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: 'commdata$numabchosen <- 0 # number among A, B chosen so far'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 'commdata$numabchosen <- 0 # 到目前为止A、B中被选中的数量'
- en: '7'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: choose committee 1, and check for A,B serving together
  id: totrans-790
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择委员会1，并检查A、B是否共同服务
- en: '8'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: commdata <- choosecomm(commdata,5)
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: commdata <- choosecomm(commdata,5)
- en: Doing Math and Simulations in R
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中进行数学和模拟
- en: '**205**'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '**205**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '9'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: if A or B already chosen, no need to look at the other comms.
  id: totrans-797
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果A或B已经被选中，则不需要查看其他委员会。
- en: '10'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: if (commdata$numabchosen > 0) next
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: if (commdata$numabchosen > 0) next
- en: '11'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: choose committee 2 and check
  id: totrans-801
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择委员会2并检查
- en: '12'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: commdata <- choosecomm(commdata,4)
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: commdata <- choosecomm(commdata,4)
- en: '13'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: if (commdata$numabchosen > 0) next
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: if (commdata$numabchosen > 0) next
- en: '14'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: choose committee 3 and check
  id: totrans-807
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择委员会3并检查
- en: '15'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: commdata <- choosecomm(commdata,3)
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: commdata <- choosecomm(commdata,3)
- en: '16'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: '}'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '17'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: print(commdata$countabsamecomm/nreps)
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: print(commdata$countabsamecomm/nreps)
- en: '18'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: '}'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '19'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: '20'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: choosecomm <- function(comdat,comsize) {
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: choosecomm <- function(comdat,comsize) {
- en: '21'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: choose committee
  id: totrans-820
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择委员会
- en: '22'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: committee <- sample(comdat$whosleft,comsize)
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 委员会 <- sample(comdat$whosleft,comsize)
- en: '23'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: count how many of A and B were chosen
  id: totrans-824
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算选择A和B的数量
- en: '24'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: comdat$numabchosen <- length(intersect(1:2,committee))
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: comdat$numabchosen <- length(intersect(1:2,committee))
- en: '25'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: if (comdat$numabchosen == 2)
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: if (comdat$numabchosen == 2)
- en: '26'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '26'
- en: comdat$countabsamecomm <- comdat$countabsamecomm + 1
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: comdat$countabsamecomm <- comdat$countabsamecomm + 1
- en: '27'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '27'
- en: delete chosen committee from the set of people we now have to choose from 28
  id: totrans-832
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从我们现在需要从中选择的人的集合中删除已选择的委员会 28
- en: comdat$whosleft <- setdiff(comdat$whosleft,committee)
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: comdat$whosleft <- setdiff(comdat$whosleft,committee)
- en: '29'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '29'
- en: return(comdat)
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: return(comdat)
- en: '30'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: '}'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: We number the potential committee members from 1 to 20, with per-
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将潜在的委员会成员编号为1到20，每个
- en: 'sons A and B having ID 1 and 2\. Recalling that R lists are often used to store
    several related variables in one basket, we se up a list comdat. Its components
    include the following:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 具有ID 1和2的儿子A和B。回忆一下，R列表通常用于将多个相关变量存储在一个篮子里，我们设置了comdat列表。其组件包括以下内容：
- en: •
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'comdat$whosleft: We simulate the random selection of the committees by randomly
    choosing from this vector. Each time we choose a committee, we remove the committee
    members’ IDs. It is initialized to 1:20, indicating that no one has been selected
    yet.'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: comdat$whosleft：我们通过从这个向量中随机选择来模拟委员会的随机选择。每次我们选择一个委员会，我们就移除委员会成员的ID。它初始化为1:20，表示还没有人被选中。
- en: •
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'comdat$numabchosen: This is a count of how many among the people A and B have
    been chosen so far. If we choose a committee and find this to be positive, we
    can skip choosing the remaining committees for the following reason: If this number
    is 2, we know definitely that A and B are on the same committee; if it is 1, we
    know definitely that A and B are *not* on the same committee.'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: comdat$numabchosen：这是A和B中至今已选择的人数。如果我们选择一个委员会并发现这个数字是正数，我们可以跳过选择剩余的委员会，以下原因：如果这个数字是2，我们知道A和B肯定在同一委员会上；如果是1，我们知道A和B肯定不在同一委员会上。
- en: •
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: 'comdat$countabsamecomm: Here, we store a count of the number of times A and
    B are on the same committee.'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: comdat$countabsamecomm：在这里，我们存储A和B在同一委员会上出现的次数。
- en: Since committee selection involves subsets, it’s not surprising that a couple
    of R’s set operations—intersect() and setdiff()—come in handy here.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 由于委员会选择涉及子集，因此R的几个集合操作——intersect()和setdiff()——在这里非常有用。
- en: Note, too, the use of R’s next statement, which tells R to skip the rest of
    this iteration of the loop.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，R的下一个语句的使用，它告诉R跳过循环的这一迭代剩余部分。
- en: '**206**'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '**206**'
- en: Chapter 8
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 第八章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 21](index-233_1.png)'
  id: totrans-851
  prefs: []
  type: TYPE_IMG
  zh: '![图像21](index-233_1.png)'
- en: '**9**'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '**9**'
- en: '**OBJECT-ORIENTED PROGRAMMING**'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**'
- en: Many programmers believe that object-
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员认为面向对象编程（OOP）使得
- en: oriented programming (OOP) makes for
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）使得
- en: clearer, more reusable code. Though very
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 更清晰、更可重用的代码。尽管非常
- en: different from the familiar OOP languages like
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 与熟悉的OOP语言（如
- en: C++, Java, and Python, R is very much OOP in outlook.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: C++、Java和Python，R在表现上非常面向对象。
- en: 'The following themes are key to R:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 以下主题是R的关键：
- en: •
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: Everything you touch in R—ranging from numbers to character strings to matrices—is
    an object.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，您接触到的每一件事——从数字到字符字符串到矩阵——都是一个对象。
- en: •
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: R promotes *encapsulation*, which is packaging separate but related data items
    into one class instance. Encapsulation helps you keep track of related variables,
    enhancing clarity.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: R促进*封装*，这意味着将不同的但相关的数据项打包到一个类实例中。封装有助于您跟踪相关变量，提高清晰度。
- en: •
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: R classes are *polymorphic*, which means that the same function call leads to
    different operations for objects of different classes. For instance, a call to
    print() on an object of a certain class triggers a call to a print function tailored
    to that class. Polymorphism promotes reusability.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: R类是*多态的*，这意味着相同的函数调用会导致不同类别的对象执行不同的操作。例如，对某个类对象的print()调用将触发对该类定制的print函数的调用。多态性促进了重用性。
- en: •
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: R allows *inheritance*, which allows extending a given class to a more specialized
    class.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: R允许*继承*，这允许将给定的类扩展到更专业的类。
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: This chapter covers OOP in R. We’ll discuss programming in the two types of
    classes, S3 and S4, and then present a few useful OOP-related R
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了R中的面向对象编程（OOP）。我们将讨论两种类型的类编程，S3和S4，然后介绍一些有用的与OOP相关的R
- en: utilities.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 工具。
- en: '**9.1 S3 Classes**'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.1 S3 类**'
- en: The original R structure for classes, known as S3, is still the dominant class
    paradigm in R use today. Indeed, most of R’s own built-in classes are of the S3
    type.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 原始R结构中的类，称为S3，仍然是R使用中的主导类范式。事实上，R的大部分内置类都是S3类型。
- en: An S3 class consists of a list, with a class name attribute and *dispatch* capability
    added. The latter enables the use of generic functions, as we saw in Chapter 1\.
    S4 classes were developed later, with goal of adding *safety*, meaning that you
    cannot accidentally access a class component that is not already in existence.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: S3类由一个列表组成，其中添加了类名属性和*调度*能力。后者使得可以使用泛型函数，正如我们在第一章中看到的。S4类是在后来开发的，目的是增加*安全性*，这意味着您不能意外地访问一个尚未存在的类组件。
- en: '***9.1.1 S3 Generic Functions***'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '***9.1.1 S3 泛型函数***'
- en: As mentioned, R is polymorphic, in the sense that the same function can lead
    to different operations for different classes. You can apply plot(), for example,
    to many different types of objects, getting a different type of plot for each.
    The same is true for print(), summary(), and many other functions.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: In this manner, we get a uniform interface to different classes. For example,
    if you are writing code that includes plot operations, polymorphism may allow
    you to write your program without worrying about the various types of objects
    that might be plotted.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: In addition, polymorphism certainly makes things easier to remem-
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: ber for the user and makes it fun and convenient to explore new library functions
    and associated classes. If a function is new to you, just try running plot() on
    the function’s output; it will likely work. From a programmer’s viewpoint, polymorphism
    allows writing fairly general code, without worrying about what type of object
    is being manipulated, because the underlying class mechanisms take care of that.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: The functions that work with polymorphism, such as plot() and print(), are known
    as *generic functions*. When a generic function is called, R will then dispatch
    the call to the proper class method, meaning that it will reroute the call to
    a function defined for the object’s class.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.2 Example: OOP in the lm() Linear Model Function***'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s look at a simple regression analysis run via R’s lm()
    function. First, let’s see what lm() does:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: ?lm
  id: totrans-882
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The output of this help query will tell you, among other things, that this function
    returns an object of class "lm".
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: '**208**'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try creating an instance of this object and then printing it:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: x <- c(1,2,3)
  id: totrans-888
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y <- c(1,3,8)
  id: totrans-889
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lmout <- lm(y ~ x)
  id: totrans-890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: class(lmout)
  id: totrans-891
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "lm"'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: lmout
  id: totrans-893
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Call:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: lm(formula = y ~ x)
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: 'Coefficients:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: (Intercept)
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: x
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '-3.0'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: '3.5'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: Here, we printed out the object lmout. (Remember that by simply typing the name
    of an object in interactive mode, the object is printed.) The R interpreter then
    saw that lmout was an object of class "lm" and thus called print.lm(), a special
    print method for the "lm" class. In R terminology, the call to the generic function
    print() was dispatched to the method print.lm() associated with the class "lm".
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the generic function and the class method in
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: 'this case:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: print
  id: totrans-904
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: function(x, ...) UseMethod("print")
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: '<environment: namespace:base>'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: print.lm
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: function (x, digits = max(3, getOption("digits") - 3), ...)
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: cat("\nCall:\n", deparse(x$call), "\n\n", sep = "") if (length(coef(x))) {
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: cat("Coefficients:\n")
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: print.default(format(coef(x), digits = digits), print.gap = 2,
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: quote = FALSE)
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: else cat("No coefficients\n")
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: cat("\n")
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: invisible(x)
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: '<environment: namespace:stats>'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: You may be surprised to see that print() consists solely of a call to UseMethod().
    But this is actually the dispatcher function, so in view of print()’s role as
    a generic function, you should not be surprised after all.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: '**209**'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '**209**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Don’t worry about the details of print.lm(). The main point is that the printing
    depends on context, with a special print function called for the
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心print.lm()的细节。主要点是打印依赖于上下文，并调用一个特殊的打印函数。
- en: '"lm" class. Now let’s see what happens when we print this object with its class
    attribute removed:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '"lm"类。现在让我们看看当我们移除该对象的类属性时打印这个对象会发生什么：'
- en: unclass(lmout)
  id: totrans-926
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: unclass(lmout)
- en: $coefficients
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: $coefficients
- en: (Intercept)
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: (Intercept)
- en: x
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: x
- en: '-3.0'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '-3.0'
- en: '3.5'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '3.5'
- en: $residuals
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: $residuals
- en: '1'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: 0.5 -1.0 0.5
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 0.5 -1.0 0.5
- en: $effects
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: $effects
- en: (Intercept)
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: (Intercept)
- en: x
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: x
- en: '-6.928203'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '-6.928203'
- en: '-4.949747'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '-4.949747'
- en: '1.224745'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '1.224745'
- en: $rank
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: $rank
- en: '[1] 2'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 2'
- en: '...'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: I’ve shown only the first few lines here—there’s a lot more. (Try running this
    on your own!) But you can see that the author of lm() decided to make print.lm()
    much more concise, limiting it to printing a few key quantities.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里只展示了前几行——还有很多。（试着在自己的机器上运行一下！）但你可以看到，lm()的作者决定使print.lm()更加简洁，仅打印几个关键量。
- en: '***9.1.3 Finding the Implementations of Generic Methods***'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '***9.1.3 寻找泛型方法的实现***'
- en: 'You can find all the implementations of a given generic method by calling methods(),
    like this:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用methods()来找到给定泛型方法的所有实现，如下所示：
- en: methods(print)
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: methods(print)
- en: '[1] print.acf*'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] print.acf*'
- en: '[2] print.anova'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] print.anova'
- en: '[3] print.aov*'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] print.aov*'
- en: '[4] print.aovlist*'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] print.aovlist*'
- en: '[5] print.ar*'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] print.ar*'
- en: '[6] print.Arima*'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '[6] print.Arima*'
- en: '[7] print.arima0*'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '[7] print.arima0*'
- en: '[8] print.AsIs'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '[8] print.AsIs'
- en: '[9] print.aspell*'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '[9] print.aspell*'
- en: '[10] print.Bibtex*'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '[10] print.Bibtex*'
- en: '[11] print.browseVignettes*'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '[11] print.browseVignettes*'
- en: '[12] print.by'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: '[12] print.by'
- en: '[13] print.check_code_usage_in_package*'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '[13] print.check_code_usage_in_package*'
- en: '[14] print.check_demo_index*'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '[14] print.check_demo_index*'
- en: '[15] print.checkDocFiles*'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '[15] print.checkDocFiles*'
- en: '**210**'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '**210**'
- en: Chapter 9
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 第9章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[16] print.checkDocStyle*'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '[16] print.checkDocStyle*'
- en: '[17] print.check_dotInternal*'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '[17] print.check_dotInternal*'
- en: '[18] print.checkFF*'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '[18] print.checkFF*'
- en: '[19] print.check_make_vars*'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '[19] print.check_make_vars*'
- en: '[20] print.check_package_code_syntax*'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '[20] print.check_package_code_syntax*'
- en: '...'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Asterisks denote *nonvisible* functions, meaning ones that are not in the default
    namespaces. You can find these functions via getAnywhere() and then access them
    by using a namespace qualifier. An example is print.aspell().
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 星号表示*不可见*函数，意味着它们不在默认命名空间中。您可以通过getAnywhere()找到这些函数，然后通过使用命名空间限定符来访问它们。例如，print.aspell()。
- en: 'The aspell() function itself does a spellcheck on the file specified in its
    argument. For example, suppose the file *wrds* consists of this line: Which word
    is mispelled?'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: aspell()函数本身对其参数中指定的文件进行拼写检查。例如，假设文件*wrds*包含以下行：哪个单词拼写错误？
- en: 'In this case, this function will catch the misspelled word, as follows: aspell("wrds")'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，该函数将捕获拼写错误的单词，如下所示：aspell("wrds")
- en: mispelled
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 拼写错误
- en: wrds:1:15
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: wrds:1:15
- en: The output says that there is the indicated spelling error in line 1, character
    15 of the input file. But what concerns us here is the mechanism by which that
    output was printed.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明输入文件的第1行第15个字符存在拼写错误。但这里我们关心的是该输出是如何打印出来的机制。
- en: The aspell() function returns an object of class "aspell", which does have its
    own generic print function, print.aspell(). In fact, that function was invoked
    in our example, after the call to aspell(), and the return value was printed out.
    At that time, R called UseMethod() on the object of class "aspell".
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: aspell()函数返回一个类为"aspell"的对象，该对象确实有自己的泛型打印函数，即print.aspell()。实际上，该函数在我们的示例中在调用aspell()之后被调用，并且返回值被打印出来。当时，R在类"aspell"的对象上调用UseMethod()。
- en: 'But if we call that print method directly, R won’t recognize it:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们直接调用该打印方法，R将无法识别它：
- en: aspout <- aspell("wrds")
  id: totrans-982
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: aspout <- aspell("wrds")
- en: print.aspell(aspout)
  id: totrans-983
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print.aspell(aspout)
- en: 'Error: could not find function "print.aspell"'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：找不到函数"print.aspell"
- en: 'However, we can find it by calling getAnywhere():'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过调用getAnywhere()来找到它：
- en: getAnywhere(print.aspell)
  id: totrans-986
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: getAnywhere(print.aspell)
- en: A single object matching 'print.aspell' was found
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个匹配'print.aspell'的单个对象
- en: It was found in the following places
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 它在以下位置被发现
- en: registered S3 method for print from namespace utils
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间utils中的注册S3方法print
- en: namespace:utils
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间：utils
- en: with value
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: with value
- en: function (x, sort = TRUE, verbose = FALSE, indent = 2L, ...)
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: function (x, sort = TRUE, verbose = FALSE, indent = 2L, ...)
- en: '{'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (!(nr <- nrow(x)))
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: if (!(nr <- nrow(x)))
- en: '...'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Object-Oriented Programming
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: '**211**'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '**211**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'So, the function is in the utils namespace, and we can execute it by adding
    such a qualifier:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该函数位于utils命名空间中，我们可以通过添加这样的限定符来执行它：
- en: utils:::print.aspell(aspout)
  id: totrans-1000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: utils:::print.aspell(aspout)
- en: mispelled
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: mispelled
- en: wrds:1:15
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: wrds:1:15
- en: 'You can see all the generic methods this way:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以看到所有通用方法：
- en: methods(class="default")
  id: totrans-1004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: methods(class="default")
- en: '...'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '***9.1.4 Writing S3 Classes***'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '***9.1.4 编写S3类***'
- en: 'S3 classes have a rather cobbled-together structure. A class instance is created
    by forming a list, with the components of the list being the member variables
    of the class. (Readers who know Perl may recognize this ad hoc nature in Perl’s
    own OOP system.) The "class" attribute is set by hand by using the attr() or class()
    function, and then various implementations of generic functions are defined. We
    can see this in the case of lm() by inspecting the function:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: S3类有一个相当拼凑的结构。一个类实例是通过形成一个列表来创建的，列表的组件是类的成员变量。 (了解Perl的读者可能会在Perl自己的OOP系统中认识到这种临时性质。)
    "class"属性是通过使用attr()或class()函数手动设置的，然后定义了各种通用函数的实现。我们可以通过检查lm()函数来看到这一点：
- en: lm
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lm
- en: '...'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: z <- list(coefficients = if (is.matrix(y))
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: z <- list(coefficients = if (is.matrix(y))
- en: matrix(,0,3) else numeric(0L), residuals = y,
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: matrix(,0,3) else numeric(0L), residuals = y,
- en: fitted.values = 0 * y, weights = w, rank = 0L,
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: fitted.values = 0 * y, weights = w, rank = 0L,
- en: df.residual = if (is.matrix(y)) nrow(y) else length(y))
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: df.residual = if (is.matrix(y)) nrow(y) else length(y))
- en: '}'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '...'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: class(z) <- c(if(is.matrix(y)) "mlm", "lm")
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: class(z) <- c(if(is.matrix(y)) "mlm", "lm")
- en: '...'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Again, don’t mind the details; the basic process is there. A list was created
    and assigned to z, which will serve as the framework for the "lm" class instance
    (and which will eventually be the value returned by the function).
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，不必在意细节；基本过程是存在的。创建了一个列表并将其分配给z，它将作为"lm"类实例的框架（并且最终将是函数返回的值）。
- en: Some components of that list, such as residuals, were already assigned when
    the list was created. In addition, the class attribute was set to "lm" (and possibly
    to "mlm", as will be explained in the next section).
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的某些组件，如residuals，在列表创建时就已经分配了。此外，类属性被设置为"lm"（以及可能在下一节中解释的"mlm"）。
- en: 'As an example of how to write an S3 class, let’s switch to something simpler.
    Continuing our employee example from Section 4.1, we could write this:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 作为如何编写S3类的一个例子，让我们转向一个更简单的东西。继续我们4.1节中的员工示例，我们可以编写如下：
- en: j <- list(name="Joe", salary=55000, union=T)
  id: totrans-1021
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: j <- list(name="Joe", salary=55000, union=T)
- en: class(j) <- "employee"
  id: totrans-1022
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: class(j) <- "employee"
- en: 'attributes(j) # let''s check'
  id: totrans-1023
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'attributes(j) # let''s check'
- en: '**212**'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '**212**'
- en: Chapter 9
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 第九章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: $names
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: $names
- en: '[1] "name" "salary" "union"'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "name" "salary" "union"'
- en: $class
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: $class
- en: '[1] "employee"'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "employee"'
- en: 'Before we write a print method for this class, let’s see what happens when
    we call the default print():'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为这个类编写打印方法之前，让我们看看当我们调用默认的print()时会发生什么：
- en: j
  id: totrans-1032
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: j
- en: $name
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: $name
- en: '[1] "Joe"'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "Joe"'
- en: $salary
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: $salary
- en: '[1] 55000'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 55000'
- en: $union
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: $union
- en: '[1] TRUE'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] TRUE'
- en: attr(,"class")
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: attr(,"class")
- en: '[1] "employee"'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "employee"'
- en: Essentially, j was treated as a list for printing purposes.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，j在打印目的上被当作一个列表处理。
- en: 'Now let’s write our own print method:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写自己的打印方法：
- en: print.employee <- function(wrkr) {
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: print.employee <- function(wrkr) {
- en: cat(wrkr$name,"\n")
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: cat(wrkr$name,"\n")
- en: cat("salary",wrkr$salary,"\n")
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: cat("salary",wrkr$salary,"\n")
- en: cat("union member",wrkr$union,"\n")
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: cat("union member",wrkr$union,"\n")
- en: '}'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'So, any call to print() on an object of class "employee" should now be referred
    to print.employee(). We can check that formally:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在对"employee"类对象的print()调用应该被重定向到print.employee()。我们可以通过正式检查来验证这一点：
- en: methods(,"employee")
  id: totrans-1049
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: methods(,"employee")
- en: '[1] print.employee'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] print.employee'
- en: 'Or, of course, we can simply try it out:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，当然，我们也可以简单地尝试一下：
- en: j
  id: totrans-1052
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: j
- en: Joe
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: Joe
- en: salary 55000
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: salary 55000
- en: union member TRUE
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: union member TRUE
- en: Object-Oriented Programming
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: '**213**'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '**213**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***9.1.5 Using Inheritance***'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '***9.1.5 使用继承***'
- en: 'The idea of inheritance is to form new classes as specialized versions of old
    ones. In our previous employee example, for instance, we could form a new class
    devoted to hourly employees, "hrlyemployee", as a subclass of "employee", as follows:'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的想法是通过形成旧类的特殊版本来形成新类。例如，在我们之前的员工示例中，我们可以形成一个新类，专门用于小时工，即"hrlyemployee"，作为"employee"的子类，如下所示：
- en: k <- list(name="Kate", salary= 68000, union=F, hrsthismonth= 2) class(k) <-
    c("hrlyemployee","employee")
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: k <- list(name="Kate", salary= 68000, union=F, hrsthismonth= 2) class(k) <-
    c("hrlyemployee","employee")
- en: 'Our new class has one extra variable: hrsthismonth. The name of the new class
    consists of two character strings, representing the new class and the old class.
    Our new class inherits the methods of the old one. For instance, print.employee()
    still works on the new class:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新类有一个额外的变量：hrsthismonth。新类的名称由两个字符字符串组成，代表新类和旧类。我们的新类继承了旧类的所有方法。例如，print.employee()仍然适用于新类：
- en: k
  id: totrans-1063
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: k
- en: Kate
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: Kate
- en: salary 68000
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: salary 68000
- en: union member FALSE
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 联合成员 FALSE
- en: Given the goals of inheritance, that is not surprising. However, it’s important
    to understand exactly what transpired here.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到继承的目标，这并不奇怪。然而，理解这里发生了什么非常重要。
- en: Once again, simply typing k resulted in the call print(k). In turn, that caused
    UseMethod() to search for a print method on the first of k’s two class names,
    "hrlyemployee". That search failed, so UseMethod() tried the other class name,
    "employee", and found print.employee(). It executed the latter.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，简单地输入k导致调用print(k)。反过来，这导致UseMethod()在k的两个类名中的第一个上搜索print方法，即"hrlyemployee"。该搜索失败，所以UseMethod()尝试另一个类名"employee"，并找到了print.employee()。它执行了后者。
- en: 'Recall that in inspecting the code for "lm", you saw this line: class(z) <-
    c(if(is.matrix(y)) "mlm", "lm")'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在检查"lm"的代码时，你看到了这一行：class(z) <- c(if(is.matrix(y)) "mlm", "lm")
- en: You can now see that "mlm" is a subclass of "lm" for vector-valued response
    variables.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以看到"mlm"是"lm"的子类，用于向量值响应变量。
- en: '***9.1.6 Extended Example: A Class for Storing Upper-Triangular Matrices***'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '***9.1.6 扩展示例：存储上三角矩阵的类***'
- en: Now it’s time for a more involved example, in which we will write an R class
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候写一个更复杂的例子了，我们将编写一个R类
- en: '"ut" for upper-triangular matrices. These are square matrices whose elements
    below the diagonal are zeros, such as shown in Equation 9.1\.'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '"ut"代表上三角矩阵。这些是下三角元素为零的方阵，如方程9.1所示。'
- en: ⎛
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: ⎛
- en: ⎞
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: ⎞
- en: 1 5 12
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 1 5 12
- en: ⎝0 6 9 ⎠
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: ⎝0 6 9 ⎠
- en: (9.1)
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: (9.1)
- en: 0 0 2
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0 2
- en: Our motivation here is to save storage space (though at the expense of a little
    extra access time) by storing only the nonzero portion of the matrix.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的动机是通过只存储矩阵的非零部分来节省存储空间（尽管这会稍微增加一些访问时间）。
- en: '**NOTE**'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The R class "dist" also uses such storage, though in a more focused context
    and without the class functions we have here.*'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '*The R class "dist" also uses such storage, though in a more focused context
    and without the class functions we have here.*'
- en: '**214**'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: '**214**'
- en: Chapter 9
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 第9章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The component mat of this class will store the matrix. As mentioned, to save
    on storage space, only the diagonal and above-diagonal elements will be stored,
    in column-major order. Storage for the matrix (9.1), for instance, consists of
    the vector (1,5,6,12,9,2), and the component mat has that value.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的组件mat将存储矩阵。如前所述，为了节省存储空间，只存储对角线和上三角元素，按列主序存储。例如，矩阵（9.1）的存储由向量（1,5,6,12,9,2）组成，而组件mat具有该值。
- en: We will include a component ix in this class, to show where in mat the various
    columns begin. For the preceding case, ix is c(1,2,4), meaning that column 1 begins
    at mat[1], column 2 begins at mat[2], and column 3 begins at mat[4]. This allows
    for handy access to individual elements or columns of the matrix.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在该类中包含一个组件ix，以显示在mat中各种列的起始位置。对于前面的情况，ix是c(1,2,4)，这意味着第1列从mat[1]开始，第2列从mat[2]开始，第3列从mat[4]开始。这允许方便地访问矩阵的各个元素或列。
- en: The following is the code for our class.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们类的代码。
- en: '1'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: class "ut", compact storage of upper-triangular matrices 2
  id: totrans-1090
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: class "ut"，上三角矩阵的紧凑存储 2
- en: '3'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: utility function, returns 1+...+i
  id: totrans-1092
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效用函数，返回1+...+i
- en: '4'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: sum1toi <- function(i) return(i*(i+1)/2)
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: sum1toi <- function(i) return(i*(i+1)/2)
- en: '5'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: create an object of class "ut" from the full matrix inmat (0s included) 7
  id: totrans-1097
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从完整的矩阵inmat（包括0）创建一个类"ut"的对象 7
- en: ut <- function(inmat) {
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: ut <- function(inmat) {
- en: '8'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: n <- nrow(inmat)
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: n <- nrow(inmat)
- en: '9'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: 'rtrn <- list() # start to build the object'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 'rtrn <- list() # 开始构建对象'
- en: '10'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: class(rtrn) <- "ut"
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: class(rtrn) <- "ut"
- en: '11'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: rtrn$mat <- vector(length=sum1toi(n))
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: rtrn$mat <- vector(length=sum1toi(n))
- en: '12'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: rtrn$ix <- sum1toi(0:(n-1)) + 1
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: rtrn$ix <- sum1toi(0:(n-1)) + 1
- en: '13'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: for (i in 1:n) {
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:n) {
- en: '14'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: store column i
  id: totrans-1112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储第i列
- en: '15'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: ixi <- rtrn$ix[i]
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: ixi <- rtrn$ix[i]
- en: '16'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: rtrn$mat[ixi:(ixi+i-1)] <- inmat[1:i,i]
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: rtrn$mat[ixi:(ixi+i-1)] <- inmat[1:i,i]
- en: '17'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: '}'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '18'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: return(rtrn)
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: return(rtrn)
- en: '19'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: '}'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '20'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: '21'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: uncompress utmat to a full matrix
  id: totrans-1125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: uncompress utmat to a full matrix
- en: '22'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: expandut <- function(utmat) {
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: expandut <- function(utmat) {
- en: '23'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: 'n <- length(utmat$ix) # numbers of rows and cols of matrix'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 'n <- length(utmat$ix) # 矩阵的行数和列数'
- en: '24'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: fullmat <- matrix(nrow=n,ncol=n)
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: fullmat <- matrix(nrow=n,ncol=n)
- en: '25'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: for (j in 1:n) {
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: for (j in 1:n) {
- en: '26'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: '26'
- en: fill jth column
  id: totrans-1135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充第j列
- en: '27'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '27'
- en: start <- utmat$ix[j]
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: start <- utmat$ix[j]
- en: '28'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '28'
- en: fin <- start + j - 1
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: fin <- start + j - 1
- en: '29'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '29'
- en: 'abovediagj <- utmat$mat[start:fin] # above-diag part of col j'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 'abovediagj <- utmat$mat[start:fin] # 上三角部分为列 j'
- en: '30'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: fullmat[,j] <- c(abovediagj,rep(0,n-j))
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: fullmat[,j] <- c(abovediagj,rep(0,n-j))
- en: '31'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '31'
- en: '}'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '32'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '32'
- en: return(fullmat)
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 返回(fullmat)
- en: '33'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '33'
- en: '}'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '34'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '34'
- en: '35'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '35'
- en: print matrix
  id: totrans-1152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印矩阵
- en: '36'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '36'
- en: print.ut <- function(utmat)
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: print.ut <- function(utmat)
- en: '37'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: '37'
- en: print(expandut(utmat))
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(expandut(utmat))
- en: Object-Oriented Programming
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: '**215**'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '**215**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '38'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '38'
- en: '39'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '39'
- en: multiply one ut matrix by another, returning another ut instance; 40
  id: totrans-1162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一个 ut 矩阵乘以另一个，返回另一个 ut 实例；40
- en: implement as a binary operation
  id: totrans-1163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将其实现为二进制运算
- en: '41'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: '41'
- en: '"%mut%" <- function(utmat1,utmat2) {'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '"%mut%" <- function(utmat1,utmat2) {'
- en: '42'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: 'n <- length(utmat1$ix) # numbers of rows and cols of matrix'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 'n <- length(utmat1$ix) # 矩阵的行数和列数'
- en: '43'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '43'
- en: utprod <- ut(matrix(0,nrow=n,ncol=n))
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: utprod <- ut(matrix(0,nrow=n,ncol=n))
- en: '44'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '44'
- en: 'for (i in 1:n) { # compute col i of product'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (i in 1:n) { # 计算乘积的列 i'
- en: '45'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '45'
- en: let a[j] and bj denote columns j of utmat1 and utmat2, respectively, 46
  id: totrans-1173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 令 a[j] 和 bj 分别表示 utmat1 和 utmat2 的列 j，46
- en: so that, e.g. b2[1] means element 1 of column 2 of utmat2
  id: totrans-1174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 因此，例如，b2[1] 表示 utmat2 的第 2 列的第 1 个元素
- en: '47'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '47'
- en: then column i of product is equal to
  id: totrans-1176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 因此，乘积的列 i 等于
- en: '48'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '48'
- en: '#'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: bi[1]*a[1] + ... + bi[i]*a[i]
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: bi[1]*a[1] + ... + bi[i]*a[i]
- en: '49'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: '49'
- en: find index of start of column i in utmat2
  id: totrans-1181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 utmat2 中找到列 i 的起始索引
- en: '50'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '50'
- en: startbi <- utmat2$ix[i]
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: startbi <- utmat2$ix[i]
- en: '51'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '51'
- en: initialize vector that will become bi[1]*a[1] + ... + bi[i]*a[i]
  id: totrans-1185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化一个向量，该向量将成为 bi[1]*a[1] + ... + bi[i]*a[i]
- en: '52'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '52'
- en: prodcoli <- rep(0,i)
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: prodcoli <- rep(0,i)
- en: '53'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '53'
- en: 'for (j in 1:i) { # find bi[j]*a[j], add to prodcoli'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (j in 1:i) { # 找到 bi[j]*a[j]，添加到 prodcoli'
- en: '54'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '54'
- en: startaj <- utmat1$ix[j]
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: startaj <- utmat1$ix[j]
- en: '55'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: '55'
- en: bielement <- utmat2$mat[startbi+j-1]
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: bielement <- utmat2$mat[startbi+j-1]
- en: '56'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '56'
- en: prodcoli[1:j] <- prodcoli[1:j] +
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: prodcoli[1:j] <- prodcoli[1:j] +
- en: '57'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: '57'
- en: bielement * utmat1$mat[startaj:(startaj+j-1)]
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: bielement * utmat1$mat[startaj:(startaj+j-1)]
- en: '58'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '58'
- en: '}'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '59'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: '59'
- en: now need to tack on the lower 0s
  id: totrans-1201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在需要添加下方的 0
- en: '60'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '60'
- en: startprodcoli <- sum1toi(i-1)+1
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: startprodcoli <- sum1toi(i-1)+1
- en: '61'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: '61'
- en: utprod$mat[startbi:(startbi+i-1)] <- prodcoli
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: utprod$mat[startbi:(startbi+i-1)] <- prodcoli
- en: '62'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: '62'
- en: '}'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '63'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '63'
- en: return(utprod)
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 返回(utprod)
- en: '64'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: '64'
- en: '}'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Let’s test it.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试它。
- en: test
  id: totrans-1213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 测试
- en: function() {
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: function() {
- en: utm1 <- ut(rbind(1:2,c(0,2)))
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: utm1 <- ut(rbind(1:2,c(0,2)))
- en: utm2 <- ut(rbind(3:2,c(0,1)))
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: utm2 <- ut(rbind(3:2,c(0,1)))
- en: utp <- utm1 %mut% utm2
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: utp <- utm1 %mut% utm2
- en: print(utm1)
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(utm1)
- en: print(utm2)
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(utm2)
- en: print(utp)
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(utp)
- en: utm1 <- ut(rbind(1:3,0:2,c(0,0,5)))
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: utm1 <- ut(rbind(1:3,0:2,c(0,0,5)))
- en: utm2 <- ut(rbind(4:2,0:2,c(0,0,1)))
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: utm2 <- ut(rbind(4:2,0:2,c(0,0,1)))
- en: utp <- utm1 %mut% utm2
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: utp <- utm1 %mut% utm2
- en: print(utm1)
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(utm1)
- en: print(utm2)
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(utm2)
- en: print(utp)
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(utp)
- en: '}'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**216**'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: '**216**'
- en: Chapter 9
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 第九章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: test()
  id: totrans-1231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 测试()
- en: '[,1] [,2]'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,] 1 2'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,] 1 2'
- en: '[2,] 0 2'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,] 0 2'
- en: '[,1] [,2]'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,] 3 2'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,] 3 2'
- en: '[2,] 0 1'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,] 0 1'
- en: '[,1] [,2]'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,] 3 4'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,] 3 4'
- en: '[2,] 0 2'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,] 0 2'
- en: '[,1] [,2] [,3]'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2] [,3]'
- en: '[1,] 1 2 3'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,] 1 2 3'
- en: '[2,] 0 1 2'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,] 0 1 2'
- en: '[3,] 0 0 5'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,] 0 0 5'
- en: '[,1] [,2] [,3]'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2] [,3]'
- en: '[1,] 4 3 2'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,] 4 3 2'
- en: '[2,] 0 1 2'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,] 0 1 2'
- en: '[3,] 0 0 1'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,] 0 0 1'
- en: '[,1] [,2] [,3]'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,] 4 5 9'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,] 4 5 9'
- en: '[2,] 0 1 4'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,] 0 1 4'
- en: '[3,] 0 0 5'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,] 0 0 5'
- en: Throughout the code, we take into account the fact that the matrices involved
    have a lot of zeros. For example, we avoid multiplying by zeros simply by not
    adding terms to sums when the terms include a 0 factor.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个代码中，我们考虑到涉及的矩阵有很多零。例如，我们通过在包含 0 因子的项中不添加项到和中来避免乘以零。
- en: The ut() function is fairly straightforward. This function is a *constructor*,
    which is a function whose job it is to create an instance of the given class,
    eventually returning that instance. So in line 9, we create a list that will serve
    as the body of the class object, naming it rtrn as a reminder that this will be
    the class instance to be constructed and returned.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: ut() 函数相当直接。这是一个 *构造函数*，其任务是创建给定类的实例，最终返回该实例。因此，在第 9 行，我们创建了一个列表，它将作为类对象的主体，命名为
    rtrn 以提醒这将是要构建和返回的类实例。
- en: As noted earlier, the main member variables of our class will be mat and idx,
    implemented as components of the list. Memory for these two components is allocated
    in lines 11 and 12\.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们类的主要成员变量将是 mat 和 idx，它们作为列表的组件实现。这两个组件的内存分配在第 11 和 12 行。
- en: The loop that follows then fills in rtrn$mat column by column and
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的循环将按列填充 rtrn$mat
- en: 'assigns rtrn$idx element by element. A slicker way to do this for loop would
    be to use the rather obscure row() and col() functions. The row() function takes
    a matrix input and returns a new matrix of the same size, but with each element
    replaced by its row number. Here’s an example:'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 按元素分配rtrn$idx元素。为此循环的一个更简洁的方法是使用相对晦涩的row()和col()函数。row()函数接受一个矩阵输入并返回一个大小相同的新矩阵，但每个元素都被其行号替换。以下是一个示例：
- en: m
  id: totrans-1258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m
- en: '[,1] [,2]'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,] 1 4'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,] 1 4'
- en: '[2,] 2 5'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,] 2 5'
- en: '[3,] 3 6'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,] 3 6'
- en: Object-Oriented Programming
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: '**217**'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '**217**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: row(m)
  id: totrans-1266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: row(m)
- en: '[,1] [,2]'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '[,1] [,2]'
- en: '[1,] 1 1'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,] 1 1'
- en: '[2,] 2 2'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,] 2 2'
- en: '[3,] 3 3'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,] 3 3'
- en: The col() function works similarly.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: col()函数的工作方式类似。
- en: 'Using this idea, we could replace the for loop in ut() with a one-liner: rtrn$mat
    <- inmat[row(inmat) <= col(inmat)]'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个想法，我们可以用一行代码替换ut()中的for循环：rtrn$mat <- inmat[row(inmat) <= col(inmat)]
- en: Whenever possible, we should exploit vectorization. Take a look at
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，我们应该利用向量化。看看
- en: 'line 12, for example:'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，第12行：
- en: rtrn$ix <- sum1toi(0:(n-1)) + 1
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: rtrn$ix <- sum1toi(0:(n-1)) + 1
- en: Since sum1toi() (which we defined on line 4) is based only on the vectorized
    functions "*"() and "+"(), sum1toi() itself is also vectorized. This allows us
    to apply sum1toi() to a vector above. Note that we used recycling as well.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 由于sum1toi()（我们在第4行定义）仅基于向量化的函数"*()"和"+()"，因此sum1toi()本身也是向量化的。这允许我们将sum1toi()应用于上面的向量。请注意，我们同样使用了循环利用。
- en: 'We want our "ut" class to include some methods, not just variables. To this
    end, we have included three methods:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望"ut"类包含一些方法，而不仅仅是变量。为此，我们包含了三个方法：
- en: •
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: The expandut() function converts from a compressed matrix to an ordinary one.
    In expandut(), the key lines are 27 and 28, where we use rtrn$ix to determine
    where in utmat$mat the *j* th column of our matrix is stored.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: expandut()函数将压缩矩阵转换为普通矩阵。在expandut()中，关键行是27和28，我们使用rtrn$ix来确定矩阵的第j列在utmat$mat中的存储位置。
- en: That data is then copied to the *j* th column of fullmat in line 30\. Note the
    use of rep() to generate the zeros in the lower portion of this column.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 那些数据随后被复制到第30行中的fullmat的第j列。注意使用rep()生成该列下部的零。
- en: •
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: The print.ut() function is for printing. This function is quick and easy, using
    expandut(). Recall that any call to print() on an object of type "ut"
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: print.ut()函数用于打印。这个函数快速简单，使用了expandut()。回想一下，对类型为"ut"的对象的任何print()调用
- en: will be dispatched to print.ut(), as in our test cases earlier.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 将被转发到print.ut()，就像我们之前的测试用例中那样。
- en: •
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: The "%mut%"() function is for multiplying two compressed matrices (without uncompressing
    them). This function starts in line 39\. Since this is a binary operation, we
    take advantage of the fact that R accommodates user-defined binary operations,
    as described in Section 7.12, and implement our matrix-multiply function as %mut%.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: '"%mut%"()函数用于乘以两个压缩矩阵（不进行解压缩）。此函数从第39行开始。由于这是一个二元操作，我们利用R支持用户定义的二元操作，如第7.12节所述，并将我们的矩阵乘法函数实现为%mut%。'
- en: Let’s look at the details of the "%mut%"() function. First, in line 43, we allocate
    space for the product matrix. Note the use of recycling in an unusual context.
    The first argument of matrix() is required to be a vector of a length compatible
    with the number of specified rows and columns, so the 0 we provide is recycled
    to a vector of length *n* 2\. Of course, rep() could be used instead, but exploiting
    recycling makes for a bit shorter, more elegant code.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看"%mut%"()函数的细节。首先，在第43行，我们为乘积矩阵分配空间。注意在非典型情况下使用循环利用。matrix()的第一个参数需要是一个长度与指定行数和列数兼容的向量，所以我们提供的0被循环利用成一个长度为*n*
    2的向量。当然，可以使用rep()代替，但利用循环利用可以使代码更短、更优雅。
- en: For both clarity and fast execution, the code here has been written around the
    fact that R stores matrices in column-major order. As mentioned in the comments,
    our code then makes use of the fact that column *i* of the **218**
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰和快速执行，这里的代码是围绕R以列主序存储矩阵的事实编写的。如注释中所述，我们的代码利用了这一点，即**218**列
- en: Chapter 9
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 第九章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: product can be expressed as a linear combination of the columns of the first
    factor. It will help to see a specific example of this property, shown in Equation
    9.2\.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 乘积可以表示为第一个因子列的线性组合。查看这个属性的特定示例将有所帮助，如方程9.2所示。
- en: ⎛
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: ⎛
- en: ⎞ ⎛
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: ⎞ ⎛
- en: ⎞
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: ⎞
- en: ⎛
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: ⎛
- en: ⎞
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: ⎞
- en: 1 2 3
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 3
- en: 4 3 2
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 4 3 2
- en: 4 5 9
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 4 5 9
- en: ⎝ 0 1 2 ⎠ ⎝ 0 1 2 ⎠ = ⎝ 0 1 4 ⎠
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: ⎝ 0 1 2 ⎠ ⎝ 0 1 2 ⎠ = ⎝ 0 1 4 ⎠
- en: (9.2)
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: (9.2)
- en: 0 0 5
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0 5
- en: 0 0 1
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0 1
- en: 0 0 5
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0 5
- en: 'The comments say that, for instance, column 3 of the product is equal to the
    following:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 注释说明，例如，乘积的第三列等于以下内容：
- en: ⎛
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: ⎛
- en: ⎞
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: ⎞
- en: ⎛
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: ⎛
- en: ⎞
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: ⎞
- en: ⎛
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: ⎛
- en: ⎞
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: ⎞
- en: '1'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: 2 ⎝ 0 ⎠ + 2 ⎝ 1 ⎠ + 1 ⎝ 2 ⎠
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 2 ⎝ 0 ⎠ + 2 ⎝ 1 ⎠ + 1 ⎝ 2 ⎠
- en: '0'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '0'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '5'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: Inspection of Equation 9.2 confirms the relation.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 检查方程9.2确认了该关系。
- en: Couching the multiplication problem in terms of columns of the
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 将乘法问题用列的形式表达
- en: two input matrices enables us to compact the code and to likely increase the
    speed. The latter again stems from vectorization, a benefit discussed in detail
    in Chapter 14\. This approach is used in the loop beginning at line 53\. (Arguably,
    in this case, the increase in speed comes at the expense of readability of the
    code.)
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 两个输入矩阵使我们能够压缩代码并可能提高速度。后者再次源于向量化，这是在第14章中详细讨论的好处。这种方法从第53行开始的循环中使用。（可以说，在这种情况下，速度的提高是以代码的可读性为代价的。）
- en: '***9.1.7 Extended Example: A Procedure for Polynomial Regression***'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: '***9.1.7 扩展示例：多项式回归的步骤***'
- en: As another example, consider a statistical regression setting with one predictor
    variable. Since any statistical model is merely an approximation, in principle,
    you can get better and better models by fitting polynomials of higher and higher
    degrees. However, at some point, this becomes over-fitting, so that the prediction
    of new, future data actually deteriorates for degrees higher than some value.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，考虑一个只有一个预测变量的统计回归设置。由于任何统计模型本质上只是一个近似，原则上，你可以通过拟合更高次的多项式来获得更好的模型。然而，在某个点上，这会变成过度拟合，以至于对于高于某个值的度数，对新、未来数据的预测实际上会恶化。
- en: The class "polyreg" aims to deal with this issue. It fits polynomials of various
    degrees but assesses fits via cross-validation to reduce the risk of over-fitting.
    In this form of cross-validation, known as the *leaving-one-out method*, for each
    point we fit the regression to all the data *except* this observation, and then
    we predict that observation from the fit. An object of this class consists of
    outputs from the various regression models, plus the original data.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: '"polyreg" 类旨在解决这个问题。它拟合各种次数的多项式，但通过交叉验证来评估拟合，以减少过度拟合的风险。在这种形式的交叉验证中，称为 *留一法*，对于每个点，我们将回归拟合到所有数据
    *除了* 这个观测值，然后从拟合中预测这个观测值。这个类的对象由各种回归模型的输出以及原始数据组成。'
- en: The following is the code for the "polyreg" class.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为 "polyreg" 类的代码。
- en: '1'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '"polyreg," S3 class for polynomial regression in one predictor variable 2'
  id: totrans-1326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '"polyreg"，一个预测变量中的多项式回归的S3类 2'
- en: '3'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: polyfit(y,x,maxdeg) fits all polynomials up to degree maxdeg; y is 4
  id: totrans-1328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: polyfit(y,x,maxdeg) 拟合所有最高次数为maxdeg的多项式；y是4
- en: vector for response variable, x for predictor; creates an object of 5
  id: totrans-1329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应变量的向量，x为预测变量；创建一个包含5个输出的对象
- en: class "polyreg"
  id: totrans-1330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: class "polyreg"
- en: '6'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: polyfit <- function(y,x,maxdeg) {
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: polyfit <- function(y,x,maxdeg) {
- en: '7'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: form powers of predictor variable, ith power in ith column
  id: totrans-1334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形成预测变量的幂，第i个幂在第i列
- en: '8'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: 'pwrs <- powers(x,maxdeg) # could use orthog polys for greater accuracy 9'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 'pwrs <- powers(x,maxdeg) # 可使用正交多项式以获得更高的精度 9'
- en: 'lmout <- list() # start to build class'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 'lmout <- list() # 开始构建类'
- en: '10'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: 'class(lmout) <- "polyreg" # create a new class'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 'class(lmout) <- "polyreg" # 创建一个新的类'
- en: Object-Oriented Programming
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: '**219**'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: '**219**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '11'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: for (i in 1:maxdeg) {
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:maxdeg) {
- en: '12'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: lmo <- lm(y ~ pwrs[,1:i])
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: lmo <- lm(y ~ pwrs[,1:i])
- en: '13'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: extend the lm class here, with the cross-validated predictions
  id: totrans-1348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在这里扩展lm类，带有交叉验证的预测
- en: '14'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: lmo$fitted.cvvalues <- lvoneout(y,pwrs[,1:i,drop=F])
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: lmo$fitted.cvvalues <- lvoneout(y,pwrs[,1:i,drop=F])
- en: '15'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: lmout[[i]] <- lmo
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: lmout[[i]] <- lmo
- en: '16'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: '}'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '17'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: lmout$x <- x
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: lmout$x <- x
- en: '18'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: lmout$y <- y
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: lmout$y <- y
- en: '19'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: return(lmout)
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: return(lmout)
- en: '20'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: '}'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '21'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: '22'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: 'print() for an object fits of class "polyreg": print'
  id: totrans-1365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: print() 对于类 "polyreg" 的对象 fits：打印
- en: '23'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: cross-validated mean-squared prediction errors
  id: totrans-1367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交叉验证均方预测误差
- en: '24'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: print.polyreg <- function(fits) {
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: print.polyreg <- function(fits) {
- en: '25'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: maxdeg <- length(fits) - 2
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: maxdeg <- length(fits) - 2
- en: '26'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: '26'
- en: n <- length(fits$y)
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(fits$y)
- en: '27'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: '27'
- en: tbl <- matrix(nrow=maxdeg,ncol=1)
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: tbl <- matrix(nrow=maxdeg,ncol=1)
- en: '28'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: '28'
- en: colnames(tbl) <- "MSPE"
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: colnames(tbl) <- "MSPE"
- en: '29'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: '29'
- en: for (i in 1:maxdeg) {
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:maxdeg) {
- en: '30'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: fi <- fits[[i]]
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: fi <- fits[[i]]
- en: '31'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '31'
- en: errs <- fits$y - fi$fitted.cvvalues
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: errs <- fits$y - fi$fitted.cvvalues
- en: '32'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '32'
- en: 'spe <- crossprod(errs,errs) # sum of squared prediction errors'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 'spe <- crossprod(errs,errs) # 预测误差的平方和'
- en: '33'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: '33'
- en: tbl[i,1] <- spe/n
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: tbl[i,1] <- spe/n
- en: '34'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: '34'
- en: '}'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '35'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: '35'
- en: cat("mean squared prediction errors, by degree\n")
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: cat("均方预测误差，按度数\n")
- en: '36'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: '36'
- en: print(tbl)
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: print(tbl)
- en: '37'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: '37'
- en: '}'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '38'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: '38'
- en: '39'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: '39'
- en: forms matrix of powers of the vector x, through degree dg
  id: totrans-1398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形成向量x的幂矩阵，通过度dg
- en: '40'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: '40'
- en: powers <- function(x,dg) {
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: powers <- function(x,dg) {
- en: '41'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: '41'
- en: pw <- matrix(x,nrow=length(x))
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: pw <- matrix(x,nrow=length(x))
- en: '42'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: prod <- x
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: prod <- x
- en: '43'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: '43'
- en: for (i in 2:dg) {
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 2:dg) {
- en: '44'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: '44'
- en: prod <- prod * x
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: prod <- prod * x
- en: '45'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: '45'
- en: pw <- cbind(pw,prod)
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: pw <- cbind(pw,prod)
- en: '46'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: '46'
- en: '}'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '47'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: '47'
- en: return(pw)
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: return(pw)
- en: '48'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: '48'
- en: '}'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '49'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: '49'
- en: '50'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: '50'
- en: finds cross-validated predicted values; could be made much faster via 51
  id: totrans-1419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: finds cross-validated predicted values; could be made much faster via 51
- en: matrix-update methods
  id: totrans-1420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: matrix-update methods
- en: '52'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: '52'
- en: lvoneout <- function(y,xmat) {
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: lvoneout <- function(y,xmat)
- en: '53'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: '53'
- en: n <- length(y)
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: n <- length(y)
- en: '54'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: '54'
- en: predy <- vector(length=n)
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: predy <- vector(length=n)
- en: '55'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: '55'
- en: for (i in 1:n) {
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:n) {
- en: '56'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: '56'
- en: regress, leaving out ith observation
  id: totrans-1430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: regress, leaving out ith observation
- en: '57'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: '57'
- en: lmo <- lm(y[-i] ~ xmat[-i,])
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: lmo <- lm(y[-i] ~ xmat[-i,])
- en: '58'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: '58'
- en: betahat <- as.vector(lmo$coef)
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: betahat <- as.vector(lmo$coef)
- en: '**220**'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '**220**'
- en: Chapter 9
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter 9
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '59'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: '59'
- en: the 1 accommodates the constant term
  id: totrans-1439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: the 1 accommodates the constant term
- en: '60'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: '60'
- en: predy[i] <- betahat %*% c(1,xmat[i,])
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: predy[i] <- betahat %*% c(1,xmat[i,])
- en: '61'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: '61'
- en: '}'
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '62'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: '62'
- en: return(predy)
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: return(predy)
- en: '63'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: '63'
- en: '}'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '64'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: '64'
- en: '65'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: '65'
- en: polynomial function of x, coefficients cfs
  id: totrans-1450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: polynomial function of x, coefficients cfs
- en: '66'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: '66'
- en: poly <- function(x,cfs) {
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: poly <- function(x,cfs) {
- en: '67'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: '67'
- en: val <- cfs[1]
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: val <- cfs[1]
- en: '68'
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: '68'
- en: prod <- 1
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: prod <- 1
- en: '69'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: '69'
- en: dg <- length(cfs) - 1
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: dg <- length(cfs) - 1
- en: '70'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: '70'
- en: for (i in 1:dg) {
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: for (i in 1:dg) {
- en: '71'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: '71'
- en: prod <- prod * x
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: prod <- prod * x
- en: '72'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: '72'
- en: val <- val + cfs[i+1] * prod
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: val <- val + cfs[i+1] * prod
- en: '73'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: '73'
- en: '}'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '74'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: '74'
- en: '}'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: As you can see, "polyreg" consists of polyfit(), the constructor function, and
    print.polyreg(), a print function tailored to this class. It also contains several
    utility functions to evaluate powers and polynomials and to perform cross-validation.
    (Note that in some cases here, efficiency has been sacrificed for clarity.)
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: As you can see, "polyreg" consists of polyfit(), the constructor function, and
    print.polyreg(), a print function tailored to this class. It also contains several
    utility functions to evaluate powers and polynomials and to perform cross-validation.
    (Note that in some cases here, efficiency has been sacrificed for clarity.)
- en: As an example of using the class, we’ll generate some artificial data and create
    an object of class "polyreg" from it, printing out the results.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: As an example of using the class, we’ll generate some artificial data and create
    an object of class "polyreg" from it, printing out the results.
- en: n <- 60
  id: totrans-1471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: n <- 60
- en: x <- (1:n)/n
  id: totrans-1472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x <- (1:n)/n
- en: y <- vector(length=n)
  id: totrans-1473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y <- vector(length=n)
- en: for (i in 1:n) y[i] <- sin((3*pi/2)*x[i]) + x[i]^2 + rnorm(1,mean=0,sd=0.5)
  id: totrans-1474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: for (i in 1:n) y[i] <- sin((3*pi/2)*x[i]) + x[i]^2 + rnorm(1,mean=0,sd=0.5)
- en: dg <- 15
  id: totrans-1475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dg <- 15
- en: (lmo <- polyfit(y,x,dg))
  id: totrans-1476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (lmo <- polyfit(y,x,dg))
- en: mean squared prediction errors, by degree
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: mean squared prediction errors, by degree
- en: MSPE
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: MSPE
- en: '[1,] 0.4200127'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: '[1,] 0.4200127'
- en: '[2,] 0.3212241'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: '[2,] 0.3212241'
- en: '[3,] 0.2977433'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: '[3,] 0.2977433'
- en: '[4,] 0.2998716'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: '[4,] 0.2998716'
- en: '[5,] 0.3102032'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: '[5,] 0.3102032'
- en: '[6,] 0.3247325'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: '[6,] 0.3247325'
- en: '[7,] 0.3120066'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: '[7,] 0.3120066'
- en: '[8,] 0.3246087'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: '[8,] 0.3246087'
- en: '[9,] 0.3463628'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: '[9,] 0.3463628'
- en: '[10,] 0.4502341'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: '[10,] 0.4502341'
- en: '[11,] 0.6089814'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: '[11,] 0.6089814'
- en: '[12,] 0.4499055'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: '[12,] 0.4499055'
- en: '[13,]'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: '[13,]'
- en: NA
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: NA
- en: '[14,]'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: '[14,]'
- en: NA
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: NA
- en: '[15,]'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: '[15,]'
- en: NA
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: NA
- en: Object-Oriented Programming
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: Object-Oriented Programming
- en: '**221**'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: '**221**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'Note first that we used a common R trick in this command:'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 'Note first that we used a common R trick in this command:'
- en: (lmo <- polyfit(y,x,dg))
  id: totrans-1501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (lmo <- polyfit(y,x,dg))
- en: By surrounding the entire assignment statement in parentheses, we get the printout
    and form lmo at the same time, in case we need the latter for other things.
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: By surrounding the entire assignment statement in parentheses, we get the printout
    and form lmo at the same time, in case we need the latter for other things.
- en: The function polyfit() fits polynomial models up through a specified degree,
    in this case 15, calculating the cross-validated mean squared prediction error
    for each model. The last few values in the output were NA, because roundoff error
    considerations led R to refuse to fit polynomials of degrees that high.
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: The function polyfit() fits polynomial models up through a specified degree,
    in this case 15, calculating the cross-validated mean squared prediction error
    for each model. The last few values in the output were NA, because roundoff error
    considerations led R to refuse to fit polynomials of degrees that high.
- en: So, how is it all done? The main work is handled by the function
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: So, how is it all done? The main work is handled by the function
- en: polyfit(), which creates an object of class "polyreg". That object consists
    mainly of the objects returned by the R regression fitter lm() for each degree.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: polyfit(), which creates an object of class "polyreg". That object consists
    mainly of the objects returned by the R regression fitter lm() for each degree.
- en: 'In forming those objects, note line 14:'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 'In forming those objects, note line 14:'
- en: lmo$fitted.cvvalues <- lvoneout(y,pwrs[,1:i,drop=F])
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: lmo$fitted.cvvalues <- lvoneout(y,pwrs[,1:i,drop=F])
- en: 'Here, lmo is an object returned by lm(), but we are adding an extra component
    to it: fitted.cvvalues. Since we can add a new component to a list at any time,
    and since S3 classes are lists, this is possible.'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 'Here, lmo is an object returned by lm(), but we are adding an extra component
    to it: fitted.cvvalues. Since we can add a new component to a list at any time,
    and since S3 classes are lists, this is possible.'
- en: We also have a method for the generic function print(), print.polyreg() in line
    24\. In Section 12.1.5, we will add a method for the plot() generic function,
    plot.polyreg().
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个用于通用函数 print() 的方法，第 24 行的 print.polyreg()。在第 12.1.5 节中，我们将为通用函数 plot()
    添加一个方法，plot.polyreg()。
- en: 'In computing prediction errors, we used cross-validation, or the leaving-one-out
    method, in a form that predicts each observation from all the others. To implement
    this, we take advantage of R’s use of negative subscripts in line 57:'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算预测误差时，我们使用了交叉验证或留一法，以从所有其他观测值预测每个观测值的形式。为此，我们利用了 R 在第 57 行使用负下标的特性：
- en: lmo <- lm(y[-i] ~ xmat[-i,])
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: lmo <- lm(y[-i] ~ xmat[-i,])
- en: So, we are fitting the model with the *i* th observation deleted from our data
    set.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们正在从我们的数据集中删除第 *i* 个观测值来拟合模型。
- en: '**NOTE**'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As mentioned in the comment in the code, we could make a much faster implementation
    by using a matrix-inverse update method, known as the Sherman-Morrison-Woodbury
    formula. For more information, see J. H. Venter and J. L. J. Snyman,*'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: '*如代码注释中所述，我们可以通过使用称为 Sherman-Morrison-Woodbury 公式的矩阵逆更新方法来创建一个更快的实现。更多信息，请参阅
    J. H. Venter 和 J. L. J. Snyman，*'
- en: '*“A Note on the Generalised Cross-Validation Criterion in Linear Model Selection,”*'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: '*“关于线性模型选择中广义交叉验证准则的注释，”*'
- en: Biometrika *, Vol. 82, no. 1, pp. 215–219\.*
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: Biometrika *, 第 82 卷，第 1 期，第 215–219 页\.*
- en: '**9.2 S4 Classes**'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.2 S4 类**'
- en: Some programmers feel that S3 does not provide the safety normally associated
    with OOP. For example, consider our earlier employee database **222**
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员认为 S3 不提供与 OOP 通常相关的安全性。例如，考虑我们之前的员工数据库 **222**
- en: Chapter 9
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 第九章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'example, where our class "employee" had three fields: name, salary, and union.'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的类 "employee" 有三个字段：姓名、工资和工会。
- en: 'Here are some possible mishaps:'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可能的问题：
- en: •
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: We forget to enter the union status.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忘记输入工会状态。
- en: •
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: We misspell *union* as *onion*.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 *union* 错误地拼写成 *onion*。
- en: •
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: We create an object of some class other than "employee" but accidentally set
    its class attribute to "employee".
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个不属于 "employee" 类别的对象，但意外地将它的类属性设置为 "employee"。
- en: In each of these cases, R will not complain. The goal of S4 is to elicit a complaint
    and prevent such accidents.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，R 不会抱怨。S4 的目标是引发抱怨并防止此类事故。
- en: S4 structures are considerably richer than S3 structures, but here we present
    just the basics. Table 9-1 shows an overview of the differences between the two
    classes.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: S4 结构比 S3 结构丰富得多，但在这里我们只介绍基础知识。表 9-1 展示了两个类之间的差异概述。
- en: '**Table 9-1:** Basic R Operators'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1:** 基本R运算符'
- en: '**Operation**'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作**'
- en: '**S3**'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: '**S3**'
- en: '**S4**'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: '**S4**'
- en: Define class
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类
- en: Implicit in constructor code
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数代码中隐含
- en: setClass()
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: setClass()
- en: Create object
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象
- en: Build list, set class attr
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 构建列表，设置类属性
- en: new()
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: new()
- en: Reference member variable
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 引用成员变量
- en: $
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: $
- en: '@'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: '@'
- en: Implement generic f()
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 f() 通用函数
- en: Define f.classname()
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 f.classname()
- en: setMethod()
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: setMethod()
- en: Declare generic
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 声明通用
- en: UseMethod()
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: UseMethod()
- en: setGeneric()
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: setGeneric()
- en: '***9.2.1 Writing S4 Classes***'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: '***9.2.1 编写 S4 类***'
- en: 'You define an S4 class by calling setClass(). Continuing our employee example,
    we could write the following:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过调用 setClass() 定义 S4 类。继续我们的员工示例，我们可以编写以下内容：
- en: setClass("employee",
  id: totrans-1552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: setClass("employee",
- en: +
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: representation(
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: representation(
- en: +
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: name="character",
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: name="character",
- en: +
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: salary="numeric",
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: salary="numeric",
- en: +
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: +
- en: union="logical")
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: union="logical")
- en: + )
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: + )
- en: '[1] "employee"'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "employee"'
- en: This defines a new class, "employee", with three member variables of the specified
    types.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个新的类 "employee"，具有指定类型的三个成员变量。
- en: 'Now let’s create an instance of this class, for Joe, using new(), a built-in
    constructor function for S4 classes:'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 new()，S4 类的内置构造函数，为 Joe 创建这个类的实例：
- en: joe <- new("employee",name="Joe",salary=55000,union=T)
  id: totrans-1565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: joe <- new("employee",name="Joe",salary=55000,union=T)
- en: joe
  id: totrans-1566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: joe
- en: An object of class "employee"
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 "employee" 类的对象
- en: 'Slot "name":'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '槽位 "name":'
- en: '[1] "Joe"'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "Joe"'
- en: Object-Oriented Programming
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: '**223**'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: '**223**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'Slot "salary":'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: '槽位 "salary":'
- en: '[1] 55000'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 55000'
- en: 'Slot "union":'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: '槽位 "union":'
- en: '[1] TRUE'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] TRUE'
- en: 'Note that the member variables are called *slots*, referenced via the @ symbol.
    Here’s an example:'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，成员变量被称为 *槽位*，通过 @ 符号引用。以下是一个示例：
- en: joe@salary
  id: totrans-1578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: joe@salary
- en: '[1] 55000'
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 55000'
- en: 'We can also use the slot() function, say, as another way to query Joe’s salary:'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 slot() 函数，例如，作为查询 Joe 工资的另一种方式：
- en: slot(joe,"salary")
  id: totrans-1581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: slot(joe,"salary")
- en: '[1] 55000'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 55000'
- en: 'We can assign components similarly. Let’s give Joe a raise:'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以类似地分配组件。让我们给 Joe 加薪：
- en: joe@salary <- 65000
  id: totrans-1584
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: joe@salary <- 65000
- en: joe
  id: totrans-1585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: joe
- en: An object of class "employee"
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 类 "employee" 的对象
- en: 'Slot "name":'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: '插槽 "name":'
- en: '[1] "Joe"'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "Joe"'
- en: 'Slot "salary":'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: '插槽 "salary":'
- en: '[1] 65000'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 65000'
- en: 'Slot "union":'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: '插槽 "union":'
- en: '[1] TRUE'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] TRUE'
- en: 'Nah, he deserves a bigger raise that that:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 不，他应该得到更高的加薪：
- en: slot(joe,"salary") <- 88000
  id: totrans-1594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: slot(joe,"salary") <- 88000
- en: joe
  id: totrans-1595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: joe
- en: An object of class "employee"
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 类 "employee" 的对象
- en: 'Slot "name":'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: '插槽 "name":'
- en: '[1] "Joe"'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "Joe"'
- en: 'Slot "salary":'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: '插槽 "salary":'
- en: '[1] 88000'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 88000'
- en: 'Slot "union":'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: '插槽 "union":'
- en: '[1] TRUE'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] TRUE'
- en: '**224**'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: '**224**'
- en: Chapter 9
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 第九章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'As noted, an advantage of using S4 is safety. To illustrate this, suppose we
    were to accidentally spell *salary* as *salry*, like this:'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所提到的，使用 S4 的一个优点是安全性。为了说明这一点，假设我们不小心将 *salary* 写成了 *salry*，如下所示：
- en: joe@salry <- 48000
  id: totrans-1607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: joe@salry <- 48000
- en: 'Error in checkSlotAssignment(object, name, value) :'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 'Error in checkSlotAssignment(object, name, value) :'
- en: '"salry" is not a slot in class "employee"'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: '"salry" 不是类 "employee" 的插槽'
- en: By contrast, in S3 there would be no error message. S3 classes are just lists,
    and you are allowed to add a new component (deliberately or not) at any time.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在 S3 中不会有错误信息。S3 类只是列表，你可以在任何时候添加新的组件（故意或非故意）。
- en: '***9.2.2 Implementing a Generic Function on an S4 Class***'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: '***9.2.2 在 S4 类上实现泛型函数***'
- en: To define an implementation of a generic function on an S4 class, use setMethod().
    Let’s do that for our class "employee" here. We’ll implement the show() function,
    which is the S4 analog of S3’s generic "print".
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 S4 类上定义泛型函数的实现，使用 setMethod()。在这里，我们将为我们的 "employee" 类做这件事。我们将实现 show()
    函数，这是 S3 的泛型 "print" 的 S4 对应物。
- en: 'As you know, in R, when you type the name of a variable while in interactive
    mode, the value of the variable is printed out:'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，在 R 中，当你处于交互模式并输入变量的名称时，会打印出变量的值：
- en: joe
  id: totrans-1614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: joe
- en: An object of class "employee"
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 类 "employee" 的对象
- en: 'Slot "name":'
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: '插槽 "name":'
- en: '[1] "Joe"'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "Joe"'
- en: 'Slot "salary":'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: '插槽 "salary":'
- en: '[1] 88000'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 88000'
- en: 'Slot "union":'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: '插槽 "union":'
- en: '[1] TRUE'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] TRUE'
- en: 'Since joe is an S4 object, the action here is that show() is called. In fact,
    we would get the same output by typing this:'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 joe 是 S4 对象，这里的操作是调用 show()。实际上，我们可以通过输入以下内容得到相同的结果：
- en: show(joe)
  id: totrans-1623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: show(joe)
- en: 'Let’s override that, with the following code:'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下代码来覆盖它：
- en: setMethod("show", "employee",
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: setMethod("show", "employee",
- en: function(object) {
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: function(object) {
- en: inorout <- ifelse(object@union,"is","is not") cat(object@name,"has a salary
    of",object@salary,
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: inorout <- ifelse(object@union,"is","is not") cat(object@name,"has a salary
    of",object@salary,
- en: '"and",inorout, "in the union", "\n")'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: '"and",inorout, "in the union", "\n")'
- en: '}'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: )
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: The first argument gives the name of the generic function for which we will
    define a class-specific method, and the second argument gives the class name.
    We then define the new function.
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数给出了我们将为其定义特定类方法的泛型函数的名称，第二个参数给出了类名。然后我们定义新的函数。
- en: Object-Oriented Programming
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: '**225**'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: '**225**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'Let’s try it out:'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看：
- en: joe
  id: totrans-1636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: joe
- en: Joe has a salary of 55000 and is in the union
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: Joe 的工资是 55000，并且他是工会的成员
- en: '**9.3 S3 Versus S4**'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.3 S3 与 S4**'
- en: The type of class to use is the subject of some controversy among R programmers.
    In essence, your view here will likely depend on your personal choice of which
    you value more—the convenience of S3 or the safety of S4\.
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用的类类型是 R 程序员之间的一些争议的主题。本质上，你在这里的观点可能取决于你个人的选择——你更重视 S3 的便利性还是 S4 的安全性。
- en: John Chambers, the creator of the S language and one of the central developers
    of R, recommends S4 over S3 in his book *Software for Data Analysis* (Springer,
    2008). He argues that S4 is needed in order to write “clear and reliable software.”
    On the other hand, he notes that S3 remains quite popular.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰·查普曼，S 语言创造者，R 语言的核心开发者之一，在他的书 *《数据分析软件》*（Springer，2008年）中推荐使用 S4 而不是 S3。他认为，为了编写“清晰和可靠的软件”，需要
    S4。另一方面，他指出 S3 仍然相当流行。
- en: Google’s R Style Guide, which you can find at *http://google-styleguide*
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *http://google-styleguide* 找到谷歌的 R 风格指南
- en: '*.googlecode.com/svn/trunk/google-r-style.html*, is interesting in this regard.
    Google comes down squarely on the S3 side, stating “avoid S4 objects and methods
    when possible.” (Of course, it’s also interesting that Google even has an R'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: '*.googlecode.com/svn/trunk/google-r-style.html*，在这方面很有趣。谷歌明确地站在 S3 一边，表示“尽可能避免使用
    S4 对象和方法。”（当然，谷歌甚至有 R 风格指南也是很令人感兴趣的！）'
- en: style guide in the first place!)
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 首先考虑的是风格指南本身！）
- en: '**NOTE**'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A nice, concrete comparison of the two methods is given in Thomas Lumley’s*'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: '*托马斯·卢米利的文章中给出了两种方法的良好、具体的比较*。'
- en: '*“Programmer’s Niche: A Simple Class, in S3 and S4,”* R News *, April 1, 2004,*
    *pp. 33–36\.*'
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: '*“程序员的小天地：一个简单的类，在 S3 和 S4 中，”* R News *, April 1, 2004,* *pp. 33–36\.*'
- en: '**9.4 Managing Your Objects**'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.4 管理您的对象**'
- en: 'As a typical R session progresses, you tend to accumulate a large number of
    objects. Various tools are available to manage them. Here, we’ll look at the following:'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 随着典型的 R 会话的进行，你往往会积累大量的对象。有各种工具可以帮助你管理它们。在这里，我们将查看以下内容：
- en: •
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: The ls() function
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: The ls() function
- en: •
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: The rm() function
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: rm() 函数
- en: •
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: The save() function
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: save() 函数
- en: •
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: Several functions that tell you more about the structure of an object, such
    as class() and mode()
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 几个函数可以告诉你更多关于对象结构的信息，例如 class() 和 mode()
- en: •
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: The exists() function
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: exists() 函数
- en: '***9.4.1 Listing Your Objects with the ls() Function***'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: '***9.4.1 使用 ls() 函数列出您的对象***'
- en: The ls() command will list all of your current objects. A useful named argument
    for this function is pattern, which enables *wildcards*. Here, you tell ls() to
    list only the objects whose names include a specified pattern. The following is
    an example.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: ls() 命令将列出您当前的所有对象。此函数的一个有用的命名参数是 pattern，它启用 *通配符*。在这里，您告诉 ls() 仅列出名称中包含指定模式的对象。以下是一个示例。
- en: '**226**'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: '**226**'
- en: Chapter 9
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 第九章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: ls()
  id: totrans-1664
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ls()
- en: '[1] "acc"'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "acc"'
- en: '"acc05"'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: '"acc05"'
- en: '"binomci"'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: '"binomci"'
- en: '"cmeans"'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: '"cmeans"'
- en: '"divorg"'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: '"divorg"'
- en: '"dv"'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: '"dv"'
- en: '[7] "fit"'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: '[7] "fit"'
- en: '"g"'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: '"g"'
- en: '"genxc"'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: '"genxc"'
- en: '"genxnt"'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: '"genxnt"'
- en: '"j"'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: '"j"'
- en: '"lo"'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: '"lo"'
- en: '[13] "out1"'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: '[13] "out1"'
- en: '"out1.100" "out1.25"'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: '"out1.100" "out1.25"'
- en: '"out1.50"'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: '"out1.50"'
- en: '"out1.75"'
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: '"out1.75"'
- en: '"out2"'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: '"out2"'
- en: '[19] "out2.100" "out2.25"'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: '[19] "out2.100" "out2.25"'
- en: '"out2.50"'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: '"out2.50"'
- en: '"out2.75"'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: '"out2.75"'
- en: '"par.set"'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: '"par.set"'
- en: '"prpdf"'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: '"prpdf"'
- en: '[25] "ratbootci" "simonn"'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: '[25] "ratbootci" "simonn"'
- en: '"vecprod"'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: '"vecprod"'
- en: '"x"'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: '"x"'
- en: '"zout"'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: '"zout"'
- en: '"zout.100"'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: '"zout.100"'
- en: '[31] "zout.125" "zout3"'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: '[31] "zout.125" "zout3"'
- en: '"zout5"'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: '"zout5"'
- en: '"zout.50"'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: '"zout.50"'
- en: '"zout.75"'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: '"zout.75"'
- en: ls(pattern="ut")
  id: totrans-1696
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ls(pattern="ut")
- en: '[1] "out1"'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "out1"'
- en: '"out1.100" "out1.25" "out1.50" "out1.75" "out2"'
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: '"out1.100" "out1.25" "out1.50" "out1.75" "out2"'
- en: '[7] "out2.100" "out2.25" "out2.50" "out2.75" "zout"'
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: '[7] "out2.100" "out2.25" "out2.50" "out2.75" "zout"'
- en: '"zout.100"'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: '"zout.100"'
- en: '[13] "zout.125" "zout3"'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: '[13] "zout.125" "zout3"'
- en: '"zout5"'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: '"zout5"'
- en: '"zout.50" "zout.75"'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: '"zout.50" "zout.75"'
- en: In the second case, we asked for a list of all objects whose names include the
    string "ut".
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们要求列出所有名称中包含字符串 "ut" 的对象。
- en: '***9.4.2 Removing Specific Objects with the rm() Function***'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: '***9.4.2 使用 rm() 函数删除特定对象***'
- en: 'To remove objects you no longer need, use rm(). Here’s an example:'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除不再需要的对象，请使用 rm()。以下是一个示例：
- en: rm(a,b,x,y,z,uuu)
  id: totrans-1707
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: rm(a,b,x,y,z,uuu)
- en: This code removes the six specified objects (a, b, and so on).
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码删除了六个指定的对象（a、b 等等）。
- en: 'One of the named arguments of rm() is list, which makes it easier to remove
    multiple objects. This code assigns all of our objects to list, thus removing
    everything:'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: rm() 函数的一个命名参数是 list，这使得删除多个对象变得更容易。此代码将所有对象分配给列表，从而删除所有内容：
- en: rm(list = ls())
  id: totrans-1710
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: rm(list = ls())
- en: Using ls()’s pattern argument, this tool becomes even more powerful.
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ls() 的模式参数，这个工具变得更加强大。
- en: 'Here’s an example:'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: ls()
  id: totrans-1713
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ls()
- en: '[1] "doexpt"'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "doexpt"'
- en: '"notebookline"'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: '"notebookline"'
- en: '"nreps"'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: '"nreps"'
- en: '"numcorrectcis"'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: '"numcorrectcis"'
- en: '[5] "numnotebooklines" "numrules"'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] "numnotebooklines" "numrules"'
- en: '"observationpt"'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: '"observationpt"'
- en: '"prop"'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: '"prop"'
- en: '[9] "r"'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: '[9] "r"'
- en: '"rad"'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: '"rad"'
- en: '"radius"'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: '"radius"'
- en: '"rep"'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: '"rep"'
- en: '[13] "s"'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: '[13] "s"'
- en: '"s2"'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: '"s2"'
- en: '"sim"'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: '"sim"'
- en: '"waits"'
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: '"waits"'
- en: '[17] "wbar"'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: '[17] "wbar"'
- en: '"x"'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: '"x"'
- en: '"y"'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: '"y"'
- en: '"z"'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: '"z"'
- en: ls(pattern="notebook")
  id: totrans-1733
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ls(pattern="notebook")
- en: '[1] "notebookline"'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "notebookline"'
- en: '"numnotebooklines"'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: '"numnotebooklines"'
- en: rm(list=ls(pattern="notebook"))
  id: totrans-1736
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: rm(list=ls(pattern="notebook"))
- en: ls()
  id: totrans-1737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ls()
- en: '[1] "doexpt"'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "doexpt"'
- en: '"nreps"'
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: '"nreps"'
- en: '"numcorrectcis" "numrules"'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: '"numcorrectcis" "numrules"'
- en: '[5] "observationpt" "prop"'
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] "observationpt" "prop"'
- en: '"r"'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: '"r"'
- en: '"rad"'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: '"rad"'
- en: '[9] "radius"'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: '[9] "radius"'
- en: '"rep"'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: '"rep"'
- en: '"s"'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: '"s"'
- en: '"s2"'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: '"s2"'
- en: '[13] "sim"'
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: '[13] "sim"'
- en: '"waits"'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: '"waits"'
- en: '"wbar"'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: '"wbar"'
- en: '"x"'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: '"x"'
- en: '[17] "y"'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: '[17] "y"'
- en: '"z"'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: '"z"'
- en: Object-Oriented Programming
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: '**227**'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: '**227**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Here, we found two objects whose names include the string "notebook"
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们找到了两个名称中包含字符串 "notebook" 的对象
- en: and then asked to remove them, which was confirmed by the second call to ls().
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 然后要求删除它们，这通过第二次调用 ls() 得到确认。
- en: '**NOTE**'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: '**NOTE**'
- en: '*You may find the function browseEnv() helpful. It will show in your web browser
    your* *globals (or objects in a different specified environment), with some details
    on each.*'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: '*您可能会发现 browseEnv() 函数很有用。它将在您的网页浏览器中显示您的* *全局变量（或不同指定环境中的对象），并提供每个对象的详细信息。*'
- en: '***9.4.3 Saving a Collection of Objects with the save() Function***'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: '***9.4.3 使用 save() 函数保存对象集合***'
- en: 'Calling save() on a collection of objects will write them to disk for later
    retrieval by load(). Here’s a quick example:'
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个对象集合上调用 save() 函数会将它们写入磁盘，以便稍后通过 load() 函数检索。以下是一个快速示例：
- en: z <- rnorm(100000)
  id: totrans-1763
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: z <- rnorm(100000)
- en: hz <- hist(z)
  id: totrans-1764
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hz <- hist(z)
- en: save(hz,"hzfile")
  id: totrans-1765
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: save(hz,"hzfile")
- en: ls()
  id: totrans-1766
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ls()
- en: '[1] "hz" "z"'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "hz" "z"'
- en: rm(hz)
  id: totrans-1768
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: rm(hz)
- en: ls()
  id: totrans-1769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ls()
- en: '[1] "z"'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "z"'
- en: load("hzfile")
  id: totrans-1771
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: load("hzfile")
- en: ls()
  id: totrans-1772
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ls()
- en: '[1] "hz" "z"'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "hz" "z"'
- en: 'plot(hz) # graph window pops up'
  id: totrans-1774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'plot(hz) # 弹出图形窗口'
- en: Here, we generate some data and then draw a histogram of it. But
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们生成一些数据，然后绘制其直方图。但是
- en: we also save the output of hist() in a variable, hz. That variable is an object
    (of class "histogram", of course). Anticipating that we will want to reuse this
    object in a later R session, we use the save() function to save the object to
    the file *hzfile*. It can be reloaded in that future session via load(). To demonstrate
    this, we deliberately removed the hz object, then called load() to reload it,
    and then called ls() to show that it had indeed been reloaded.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还保存了 hist() 的输出到一个变量 hz。这个变量是一个对象（当然，是 "histogram" 类的对象）。考虑到我们将在未来的 R 会话中重用这个对象，我们使用
    save() 函数将对象保存到文件 *hzfile*。它可以在未来的会话中通过 load() 重新加载。为了演示这一点，我们故意删除了 hz 对象，然后调用
    load() 重新加载它，然后调用 ls() 来显示它确实被重新加载了。
- en: I once needed to read in a very large data file, each record of which required
    processing. I then used save() to keep the R object version of the processed file
    for future R sessions.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经需要读取一个非常大的数据文件，每个记录都需要处理。然后我使用 save() 来保存处理后的 R 对象版本，以便未来的 R 会话使用。
- en: '***9.4.4 “What Is This?”***'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: '***9.4.4 “这是什么？”***'
- en: Developers often need to know the exact structure of the object returned by
    a library function. If the documentation does not give sufficient details, what
    can we do?
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者经常需要知道库函数返回的对象的确切结构。如果文档没有提供足够的细节，我们该怎么办？
- en: 'The following R functions may be helpful:'
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 R 函数可能会有所帮助：
- en: •
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: class(), mode()
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: class(), mode()
- en: •
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: names(), attributes()
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: names(), attributes()
- en: •
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: unclass(), str()
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: unclass(), str()
- en: •
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: •
- en: edit()
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: edit()
- en: '**228**'
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: '**228**'
- en: Chapter 9
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: 第九章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'Let’s go through an example. R includes facilities for constructing *contingency
    tables*, which we discussed in Section 6.4\. An example in that section involved
    an election survey in which five respondents are asked whether they intend to
    vote for candidate X and whether they voted for X in the last election. Here is
    the resulting table:'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来讲解。R 包含构建 *列联表* 的功能，我们在第 6.4 节中讨论了这一点。该节中的一个例子涉及一个选举调查，其中五位受访者被问及他们是否打算为候选人
    X 投票，以及他们是否在上次选举中为 X 投票。以下是结果表：
- en: cttab <- table(ct)
  id: totrans-1793
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cttab <- table(ct)
- en: cttab
  id: totrans-1794
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cttab
- en: Voted.for.X.Last.Time
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: 投票.X.上次时间
- en: Vote.for.X No Yes
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 投票.X 是否
- en: 'No'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: 'No'
- en: '2'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '0'
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: Not Sure 0
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 不确定 0
- en: '1'
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'Yes'
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 'Yes'
- en: '1'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: For instance, two respondents answered no to both questions.
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，两位受访者对两个问题都回答了“否”。
- en: The object cttab was returned by the function table and thus is likely of class
    "table". A check of the documentation (?table) confirms this. But what is in the
    class?
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 table 返回的对象 cttab 很可能是 "table" 类。检查文档 (?table) 可以确认这一点。但是类中有什么内容呢？
- en: Let’s explore the structure of that object cttab of class "table".
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一下那个对象 cttab 的结构，它是 "table" 类。
- en: ctu <- unclass(cttab)
  id: totrans-1808
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ctu <- unclass(cttab)
- en: ctu
  id: totrans-1809
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ctu
- en: Votes.for.X.Last.Time
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 投票.X.上次时间
- en: Vote.for.X No Yes
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 投票.X 是否
- en: 'No'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: 'No'
- en: '2'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '0'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: Not Sure 0
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: 不确定 0
- en: '1'
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'Yes'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: 'Yes'
- en: '1'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: class(ctu)
  id: totrans-1820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: class(ctu)
- en: '[1] "matrix"'
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] "matrix"'
- en: So, the counts portion of the object is a matrix. (If the data had involved
    three or more questions, rather than just two, this would have been a higher-dimensional
    array.) Note that the names of the dimensions and of the individual rows and columns
    are there, too; they are associated with the matrix.
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对象的计数部分是一个矩阵。（如果数据涉及三个或更多问题，而不是仅仅两个，这将是一个更高维度的数组。）请注意，维度的名称以及单个行和列的名称也在这里；它们与矩阵相关联。
- en: The unclass() function is quite useful as a first step. If you simply print
    an object, you are at the mercy of the version of print() associated with that
    class, which may in the name of succinctness hide or distort some valuable information.
    Printing the result of calling unclass() allows you to work around this problem,
    though there was no difference in this example. (You saw an instance in which
    it did make a difference in the section about S3
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: unclass() 函数作为第一步非常有用。如果你只是打印一个对象，你将受该类关联的 print() 版本的影响，它可能会为了简洁而隐藏或扭曲一些有价值的信息。调用
    unclass() 的结果可以让你绕过这个问题，尽管在这个例子中没有差异。（你在一个关于 S3 的部分中看到了它确实有差异的一个例子。）
- en: generic functions in Section 9.1.1 earlier.) The function str() serves the same
    purpose, in a more compact manner.
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: （如第 9.1.1 节中较早讨论的）通用函数。函数 str() 以更紧凑的方式完成相同的目的。
- en: Note, though, applying unclass() to an object still results in an object with
    some basic class. Here, cttab had the class "table", but unclass(cttab) still
    had the class "matrix".
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管将 unclass() 应用到一个对象上仍然会得到一个具有某些基本类的对象。在这里，cttab 的类是 "table"，但 unclass(cttab)
    仍然具有 "matrix" 类。
- en: Let’s try looking at the code for table(), the library function that produced
    cttab. We could simply type table, but since this is a somewhat longish Object-Oriented
    Programming
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: 输出——在屏幕上打印指令，打印
- en: '**229**'
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image 22](index-257_1.png)'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'function, a lot of the function would zoom by on the screen too fast for us
    to absorb it. We could use page() to solve this problem, but I prefer edit():'
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: 角色，很多功能在屏幕上会飞快地闪过，以至于我们无法吸收。我们可以使用 page() 来解决这个问题，但我更喜欢 edit()：
- en: edit(table)
  id: totrans-1830
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们是否创建了一个对象，以及它是否仍然存在？不一定。如果你正在编写通用代码，比如要将其发布到 R 的 CRAN 代码库中，你的代码可能需要检查是否存在某个对象，如果不存在，则你的代码必须创建它。例如，正如你在
    9.4.3 节中学到的，你可以使用 save() 将对象保存到磁盘文件中，然后通过调用 load() 将它们恢复到 R 的内存空间中。
- en: 'This allows you to browse through the code with your text editor. In doing
    so, you’ll find this code at the end:'
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: edit(table)
- en: y <- array(tabulate(bin, pd), dims, dimnames = dn)
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 的角色
- en: class(y) <- "table"
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: '***9.4.5 exists() 函数***'
- en: y
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: y
- en: 'Ah, interesting. This shows that table() is, to some extent, a wrapper for
    another function, tabulate(). But what might be more important here is that the
    structure of a "table" object is really pretty simple: It consists of an array
    created from the counts, with the class attribute tacked on. So, it’s essentially
    just an array.'
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，有趣。这表明 table() 在某种程度上是另一个函数 tabulate() 的包装器。但在这里可能更重要的是，"table" 对象的结构实际上非常简单：它由从计数创建的数组组成，类属性附加在其上。所以，它本质上只是一个数组。
- en: The function names() shows the components in an object, and attributes() gives
    you this and a bit more, notably the class name.
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 names() 显示对象中的组件，而 attributes() 给你更多，特别是类名。
- en: '***9.4.5 The exists() Function***'
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: 第九章
- en: The function exists() returns TRUE or FALSE, depending on whether the argument
    exists. Be sure to put the argument in quotation marks.
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: class(y) <- "table"
- en: 'For example, the following code shows that the acc object exists:'
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码显示 acc 对象存在：
- en: exists("acc")
  id: totrans-1840
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: exists("acc")
- en: '[1] TRUE'
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: 最被忽视的话题之一
- en: Why would this function be useful? Don’t we always know whether or
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个函数会有用？难道我们总是不知道或者
- en: not we’ve created an object and whether it’s still there? Not necessarily. If
    you are writing general-purpose code, say to be made available to the world in
    R’s CRAN code repository, your code may need to check whether a certain object
    exists, and if it doesn’t, then your code must create it. For example, as you
    learned in Section 9.4.3, you can save objects to disk files using save() and
    then later restore them to R’s memory space by calling load().
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 exists() 返回 TRUE 或 FALSE，取决于参数是否存在。请确保将参数放在引号内。
- en: You might write general-purpose code that makes the latter call if the object
    is not already present, a condition you could check by calling exists().
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写的通用代码需要调用后者，如果对象尚未存在，你可以通过调用 exists() 来检查这个条件。
- en: '**230**'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: '**230**'
- en: Chapter 9
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: y <- array(tabulate(bin, pd), dims, dimnames = dn)
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 22](index-257_1.png)'
  id: totrans-1848
  prefs: []
  type: TYPE_IMG
  zh: '**输入/输出**'
- en: '**10**'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: '**10**'
- en: '**INPUT/OUTPUT**'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] TRUE'
- en: One of the most underemphasized topics
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你使用文本编辑器浏览代码。在这样做的时候，你会在代码的末尾找到以下代码：
- en: in many university programming courses
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多大学编程课程中
- en: is input/output (I/O). I/O plays a central
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: 是输入/输出 (I/O)。I/O 在大多数实际应用中扮演着核心
- en: role in most real-world applications of comput-
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数实际应用中计算
- en: ers. Just consider an ATM cash machine, which uses
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: ers。只需考虑一个自动柜员机现金机，它使用
- en: multiple I/O operations for both input—reading your
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: 多个 I/O 操作，包括输入——读取你的
- en: card and reading your typed-in cash request—and
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片并读取你输入的现金请求——
- en: output—printing instructions on the screen, printing
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: '**229**'
- en: your receipt, and most important, controlling the
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: 你的收据，最重要的是，控制
- en: machine to output your money!
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: 机器来输出你的钱！
- en: R is not the tool you would choose for running an ATM, but it features a highly
    versatile array of I/O capabilities, as you will learn in this chapter.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: R 并不是运行自动柜员机的工具，但它具有高度灵活的 I/O 功能，你将在本章中了解到。
- en: We’ll start with the basics of access to the keyboard and monitor, and then
    go into considerable detail on reading and writing files, including the navigation
    of file directories. Finally, we discuss R’s facilities for accessing the Internet.
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从键盘和监视器的基本访问方法开始，然后深入探讨读取和写入文件，包括文件目录的导航。最后，我们讨论 R 访问互联网的功能。
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**10.1 Accessing the Keyboard and Monitor**'
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.1 访问键盘和监视器**'
- en: R provides several functions for accesssing the keyboard and monitor. Here,
    we’ll look at the scan(), readline(), print(), and cat() functions.
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: R 提供了几个用于访问键盘和监视器的函数。在这里，我们将查看 scan()、readline()、print() 和 cat() 函数。
- en: '***10.1.1 Using the scan() Function***'
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.1.1 使用 scan() 函数*** '
- en: You can use scan() to read in a vector, whether numeric or character, from a
    file or the keyboard. With a little extra work, you can even read in data to form
    a list.
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 scan() 从文件或键盘读取一个向量，无论是数值还是字符。通过一些额外的工作，您甚至可以读取数据以形成一个列表。
- en: 'Suppose we have files named *z1.txt*, *z2.txt*, *z3.txt*, and *z4.txt*. The
    *z1.txt* file contains the following:'
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些名为 *z1.txt*、*z2.txt*、*z3.txt* 和 *z4.txt* 的文件。*z1.txt* 文件包含以下内容：
- en: '123'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: '123'
- en: 4 5
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 4 5
- en: '6'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: 'The *z2.txt* file contents are as follows:'
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: '*z2.txt* 文件内容如下：'
- en: '123'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: '123'
- en: 4.2 5
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: 4.2 5
- en: '6'
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: 'The *z3.txt* file contains this:'
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: '*z3.txt* 文件包含以下内容：'
- en: abc
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: abc
- en: de f
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: de f
- en: g
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: g
- en: 'And finally, the *z4.txt* file has these contents:'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*z4.txt* 文件包含以下内容：
- en: abc
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: abc
- en: 123 6
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 123 6
- en: y
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: y
- en: Let’s see what we can do with these files using the scan() function.
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 scan() 函数可以对这些文件做些什么。
- en: scan("z1.txt")
  id: totrans-1885
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: scan("z1.txt")
- en: Read 4 items
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 读取了 4 个项目
