- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 3 4 5 5 12 13'
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  prefs: []
  type: TYPE_NORMAL
- en: $wrts
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0 0 0 0 0 0'
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  prefs: []
  type: TYPE_NORMAL
- en: attr(,"class")
  prefs: []
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "bookvec"'
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  prefs: []
  type: TYPE_NORMAL
- en: b[2]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '42'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 4'
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  prefs: []
  type: TYPE_NORMAL
- en: 'b[2] <- 88 # try writing'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '44'
  prefs: []
  type: TYPE_NORMAL
- en: 'b[2] # worked?'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '45'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 88'
  prefs: []
  type: TYPE_NORMAL
- en: '46'
  prefs: []
  type: TYPE_NORMAL
- en: 'b$wrts # write count incremented?'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '47'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0 1 0 0 0 0'
  prefs: []
  type: TYPE_NORMAL
- en: We have named our class "bookvec", because these vectors will do their own bookkeeping—that
    is, keep track of write counts. So, the subscripting functions will be [.bookvec()
    and [<-.bookvec().
  prefs: []
  type: TYPE_NORMAL
- en: R Programming Structures
  prefs: []
  type: TYPE_NORMAL
- en: '**185**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our function newbookvec() (line 7) does the construction for this class. In
    it, you can see the structure of the class: An object will consist of the vector
    itself, vec (line 9), and a vector of write counts, wrts (line 10).'
  prefs: []
  type: TYPE_NORMAL
- en: By the way, note in line 11 that the function class() itself is a replacement
    function!
  prefs: []
  type: TYPE_NORMAL
- en: The functions [.bookvec() and [<-.bookvec() are fairly straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Just remember to return the entire object in the latter.
  prefs: []
  type: TYPE_NORMAL
- en: '**7.11 Tools for Composing Function Code**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are writing a short function that’s needed only temporarily, a quick-and-dirty
    way to do this is to write it on the spot, right there in your interactive terminal
    session. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: g <- function(x) {
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: return(x+1)
  prefs: []
  type: TYPE_NORMAL
- en: + }
  prefs: []
  type: TYPE_NORMAL
- en: This approach obviously is infeasible for longer, more complex functions. Now,
    let’s look at some better ways to compose R code.
  prefs: []
  type: TYPE_NORMAL
- en: '***7.11.1 Text Editors and Integrated Development Environments***'
  prefs: []
  type: TYPE_NORMAL
- en: You can use a text editor such as Vim, Emacs, or even Notepad, or an editor
    within an integrated development environment (IDE) to write your code in a file
    and then read it into R from the file. To do the latter, you can use R’s source()
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, suppose we have functions f() and g() in a file *xyz.R*. In R,
    we give this command:'
  prefs: []
  type: TYPE_NORMAL
- en: source("xyz.R")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This reads f() and g() into R as if we had typed them using the quick-and-dirty
    way shown at the beginning of this section.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have much code, you can cut and paste from your editor window to
    your R window.
  prefs: []
  type: TYPE_NORMAL
- en: Some general-purpose editors have special plug-ins available for R, such as
    ESS for Emacs and Vim-R for Vim. There are also IDEs for R, such as the commercial
    one by Revolution Analytics, and open source products such as StatET, JGR, Rcmdr,
    and RStudio.
  prefs: []
  type: TYPE_NORMAL
- en: '***7.11.2 The edit() Function***'
  prefs: []
  type: TYPE_NORMAL
- en: A nice implication of the fact that functions are objects is that you can edit
    functions from within R’s interactive mode. Most R programmers do their code editing
    with a text editor in a separate window, but for a small, quick change, the edit()
    function can be handy.
  prefs: []
  type: TYPE_NORMAL
- en: '**186**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we could edit the function f1() by typing this:'
  prefs: []
  type: TYPE_NORMAL
- en: f1 <- edit(f1)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This opens the default editor on the code for f1, which we could then edit and
    assign back to f1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, we might be interested in having a function f2() very similar to f1() and
    thus could execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: f2 <- edit(f1)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This gives us a copy of f1() to start from. We would do a little editing and
    then save to f2(), as seen in the preceding command.
  prefs: []
  type: TYPE_NORMAL
- en: The editor involved will depend on R’s internal options variable editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In UNIX-class systems, R will set this from your shell’s EDITOR or VISUAL environment
    variable, or you can set it yourself, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: options(editor="/usr/bin/vim")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For more details on using options, see the online documentation by typing the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: ?options
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can use edit() to edit data structures, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**7.12 Writing Your Own Binary Operations**'
  prefs: []
  type: TYPE_NORMAL
- en: You can invent your own operations! Just write a function whose name begins
    and ends with %, with two arguments of a certain type, and a return value of that
    type.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here’s a binary operation that adds double the second
  prefs: []
  type: TYPE_NORMAL
- en: 'operand to the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '"%a2b%" <- function(a,b) return(a+2*b)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3 %a2b% 5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 13'
  prefs: []
  type: TYPE_NORMAL
- en: A less trivial example is given in the section about set operations in Section
    8.5\.
  prefs: []
  type: TYPE_NORMAL
- en: '**7.13 Anonymous Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As remarked at several points in this book, the purpose of the R function function()
    is to create functions. For instance, consider this code: inc <- function(x) return(x+1)'
  prefs: []
  type: TYPE_NORMAL
- en: R Programming Structures
  prefs: []
  type: TYPE_NORMAL
- en: '**187**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: It instructs R to create a function that adds 1 to its argument and then assigns
    that function to inc. However, that last step—the assignment—is not always taken.
    We can simply use the function object created by our call to function() without
    naming that object. The functions in that context are called *anonymous*, since
    they have no name. (That is somewhat misleading, since even nonanonymous functions
    only have a name in the sense that a variable is pointing to them.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Anonymous functions can be convenient if they are short one-liners and are
    called by another function. Let’s go back to our example of using apply in Section
    3.3:'
  prefs: []
  type: TYPE_NORMAL
- en: z
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '[3,]'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: f <- function(x) x/c(2,8)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y <- apply(z,1,f)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 0.5 1.000 1.50'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0.5 0.625 0.75'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s bypass the middleman—that is, skip the assignment to f—by using an anonymous
    function within our call to apply(), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: y <- apply(z,1,function(x) x/c(2,8))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 0.5 1.000 1.50'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0.5 0.625 0.75'
  prefs: []
  type: TYPE_NORMAL
- en: What really happened here? The third formal argument to apply() must be a function,
    which is exactly what we supplied here, since the return value of function() is
    a function!
  prefs: []
  type: TYPE_NORMAL
- en: Doing things this way is often clearer than defining the function externally.
    Of course, if the function is more complicated, that clarity is not attained.
  prefs: []
  type: TYPE_NORMAL
- en: '**188**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 20](index-215_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**8**'
  prefs: []
  type: TYPE_NORMAL
- en: '**DOING MATH AND SIMULATIONS IN R**'
  prefs: []
  type: TYPE_NORMAL
- en: R contains built-in functions for your
  prefs: []
  type: TYPE_NORMAL
- en: favorite math operations and, of course,
  prefs: []
  type: TYPE_NORMAL
- en: for statistical distributions. This chapter
  prefs: []
  type: TYPE_NORMAL
- en: provides an overview of using these functions.
  prefs: []
  type: TYPE_NORMAL
- en: Given the mathematical nature of this chapter, the
  prefs: []
  type: TYPE_NORMAL
- en: examples assume a slightly higher-level knowledge
  prefs: []
  type: TYPE_NORMAL
- en: than those in other chapters. You should be familiar
  prefs: []
  type: TYPE_NORMAL
- en: with calculus and linear algebra to get the most out
  prefs: []
  type: TYPE_NORMAL
- en: of these examples.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1 Math Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'R includes an extensive set of built-in math functions. Here is a partial list:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'exp(): Exponential function, base e'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'log(): Natural logarithm'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'log10(): Logarithm base 10'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'sqrt(): Square root'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'abs(): Absolute value'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'sin(), cos(), and so on: Trig functions'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'min() and max(): Minimum value and maximum value within a vector'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'which.min() and which.max(): Index of the minimal element and maximal element
    of a vector'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'pmin() and pmax(): Element-wise minima and maxima of several vectors'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'sum() and prod(): Sum and product of the elements of a vector'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'cumsum() and cumprod(): Cumulative sum and product of the elements of a vector'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'round(), floor(), and ceiling(): Round to the closest integer, to the closest
    integer below, and to the closest integer above'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'factorial(): Factorial function'
  prefs: []
  type: TYPE_NORMAL
- en: '***8.1.1 Extended Example: Calculating a Probability***'
  prefs: []
  type: TYPE_NORMAL
- en: As our first example, we’ll work through calculating a probability using the
    prod() function. Suppose we have *n* independent events, and the *i* th event
    has the probability *pi* of occurring. What is the probability of exactly one
    of these events occurring?
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose first that *n* = 3 and our events are named A, B, and C. Then we break
    down the computation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: P(exactly one event occurs)
  prefs: []
  type: TYPE_NORMAL
- en: '='
  prefs: []
  type: TYPE_NORMAL
- en: P(A and not B and not C)
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: P(not A and B and not C)
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: P(not A and not B and C)
  prefs: []
  type: TYPE_NORMAL
- en: P(A and not B and not C) would be *pA*(1 *− pB*)(1 *− pC*), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For general *n*, that is calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*n*'
  prefs: []
  type: TYPE_NORMAL
- en: '*pi*(1 *−p* 1) *...* (1 *−pi−* 1)(1 *−pi*+1) *...* (1 *−pn*) *i*=1'
  prefs: []
  type: TYPE_NORMAL
- en: (The *i* th term inside the sum is the probability that event *i* occurs and
    all the others do *not* occur.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s code to compute this, with our probabilities *pi* contained in the vector
    p:'
  prefs: []
  type: TYPE_NORMAL
- en: exactlyone <- function(p) {
  prefs: []
  type: TYPE_NORMAL
- en: notp <- 1 - p
  prefs: []
  type: TYPE_NORMAL
- en: tot <- 0.0
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:length(p))
  prefs: []
  type: TYPE_NORMAL
- en: tot <- tot + p[i] * prod(notp[-i])
  prefs: []
  type: TYPE_NORMAL
- en: return(tot)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**190**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: How does it work? Well, the assignment
  prefs: []
  type: TYPE_NORMAL
- en: notp <- 1 - p
  prefs: []
  type: TYPE_NORMAL
- en: creates a vector of all the “not occur” probabilities 1 *− pj*, using recycling.
  prefs: []
  type: TYPE_NORMAL
- en: The expression notp[-i] computes the product of all the elements of notp, except
    the *i* th—exactly what we need.
  prefs: []
  type: TYPE_NORMAL
- en: '***8.1.2 Cumulative Sums and Products***'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, the functions cumsum() and cumprod() return cumulative sums and
    products.
  prefs: []
  type: TYPE_NORMAL
- en: x <- c(12,5,13)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: cumsum(x)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 12 17 30'
  prefs: []
  type: TYPE_NORMAL
- en: cumprod(x)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 12 60 780'
  prefs: []
  type: TYPE_NORMAL
- en: In x, the sum of the first element is 12, the sum of the first two elements
    is 17, and the sum of the first three elements is 30\.
  prefs: []
  type: TYPE_NORMAL
- en: The function cumprod() works the same way as cumsum(), but with the product
    instead of the sum.
  prefs: []
  type: TYPE_NORMAL
- en: '***8.1.3 Minima and Maxima***'
  prefs: []
  type: TYPE_NORMAL
- en: There is quite a difference between min() and pmin(). The former simply combines
    all its arguments into one long vector and returns the minimum value in that vector.
    In contrast, if pmin() is applied to two or more vectors, it returns a vector
    of the pair-wise minima, hence the name pmin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: z
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '[3,]'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: min(z[,1],z[,2])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1'
  prefs: []
  type: TYPE_NORMAL
- en: pmin(z[,1],z[,2])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 3 2'
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, min() computed the smallest value in (1,5,6,2,3,2). But the
    call to pmin() computed the smaller of 1 and 2, yielding 1; then the smaller of
    5 and 3, which is 3; then finally the minimum of 6 and 2, giving 2\. Thus, the
    call returned the vector (1,3,2).
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  prefs: []
  type: TYPE_NORMAL
- en: '**191**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use more than two arguments in pmin(), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: pmin(z[1,],z[2,],z[3,])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 2'
  prefs: []
  type: TYPE_NORMAL
- en: The 1 in the output is the minimum of 1, 5, and 6, with a similar computation
    leading to the 2\.
  prefs: []
  type: TYPE_NORMAL
- en: The max() and pmax() functions act analogously to min() and pmin().
  prefs: []
  type: TYPE_NORMAL
- en: Function minimization/maximization can be done via nlm() and optim().
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s find the smallest value of *f* ( *x*) = *x* 2 *−* sin( *x*).
  prefs: []
  type: TYPE_NORMAL
- en: nlm(function(x) return(x^2-sin(x)),8)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $minimum
  prefs: []
  type: TYPE_NORMAL
- en: '[1] -0.2324656'
  prefs: []
  type: TYPE_NORMAL
- en: $estimate
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 0.4501831'
  prefs: []
  type: TYPE_NORMAL
- en: $gradient
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 4.024558e-09'
  prefs: []
  type: TYPE_NORMAL
- en: $code
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1'
  prefs: []
  type: TYPE_NORMAL
- en: $iterations
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 5'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the minimum value was found to be approximately *−* 0.23, occurring at
    *x* = 0.45\. A Newton-Raphson method (a technique from numerical analysis for
    approximating roots) is used, running five iterations in this case.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument specifies the initial guess, which we set to be 8\. (This
    second argument was picked pretty arbitrarily here, but in some problems, you
    may need to experiment to find a value that will lead to convergence.)
  prefs: []
  type: TYPE_NORMAL
- en: '***8.1.4 Calculus***'
  prefs: []
  type: TYPE_NORMAL
- en: R also has some calculus capabilities, including symbolic differentiation and
    numerical integration, as you can see in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'D(expression(exp(x^2)),"x") # derivative'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: exp(x^2) * (2 * x)
  prefs: []
  type: TYPE_NORMAL
- en: integrate(function(x) x^2,0,1)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 0.3333333 with absolute error < 3.7e-15
  prefs: []
  type: TYPE_NORMAL
- en: '**192**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, R reported
  prefs: []
  type: TYPE_NORMAL
- en: '*d ex* 2 = 2 *xex* 2'
  prefs: []
  type: TYPE_NORMAL
- en: '*dx*'
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* 2 *dx ≈* 0 *.* 3333333'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: You can find R packages for differential equations (odesolve), for interfacing
    R with the Yacas symbolic math system (ryacas), and for other calculus operations.
    These packages, and thousands of others, are available from the Comprehensive
    R Archive Network (CRAN); see Appendix B.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.2 Functions for Statistical Distributions**'
  prefs: []
  type: TYPE_NORMAL
- en: R has functions available for most of the famous statistical distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prefix the name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: With d for the density or probability mass function (pmf)
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: With p for the cumulative distribution function (cdf)
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: With q for quantiles
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: With r for random number generation
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the name indicates the distribution. Table 8-1 lists some common
    statistical distribution functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-1:** Common R Statistical Distribution Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distribution**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Density/pmf**'
  prefs: []
  type: TYPE_NORMAL
- en: '**cdf**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantiles**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Random Numbers**'
  prefs: []
  type: TYPE_NORMAL
- en: Normal
  prefs: []
  type: TYPE_NORMAL
- en: dnorm()
  prefs: []
  type: TYPE_NORMAL
- en: pnorm()
  prefs: []
  type: TYPE_NORMAL
- en: qnorm()
  prefs: []
  type: TYPE_NORMAL
- en: rnorm()
  prefs: []
  type: TYPE_NORMAL
- en: Chi square
  prefs: []
  type: TYPE_NORMAL
- en: dchisq()
  prefs: []
  type: TYPE_NORMAL
- en: pchisq()
  prefs: []
  type: TYPE_NORMAL
- en: qchisq()
  prefs: []
  type: TYPE_NORMAL
- en: rchisq()
  prefs: []
  type: TYPE_NORMAL
- en: Binomial
  prefs: []
  type: TYPE_NORMAL
- en: dbinom()
  prefs: []
  type: TYPE_NORMAL
- en: pbinom()
  prefs: []
  type: TYPE_NORMAL
- en: qbinom()
  prefs: []
  type: TYPE_NORMAL
- en: rbinom()
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s simulate 1,000 chi-square variates with 2 degrees of freedom
    and find their mean.
  prefs: []
  type: TYPE_NORMAL
- en: mean(rchisq(1000,df=2))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1.938179'
  prefs: []
  type: TYPE_NORMAL
- en: The r in rchisq specifies that we wish to generate random numbers—
  prefs: []
  type: TYPE_NORMAL
- en: in this case, from the chi-square distribution. As seen in this example, the
    first argument in the r-series functions is the number of random variates to generate.
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  prefs: []
  type: TYPE_NORMAL
- en: '**193**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: These functions also have arguments specific to the given distribution families.
    In our example, we use the df argument for the chi-square family, indicating the
    number of degrees of freedom.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Consult R’s online help for details on the arguments for the statistical distribution*
    *functions. For instance, to find our more about the chi-square function for quantiles,*
    *type ?qchisq at the command prompt.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also compute the 95th percentile of the chi-square distribution with
    two degrees of freedom:'
  prefs: []
  type: TYPE_NORMAL
- en: qchisq(0.95,2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 5.991465'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we used q to indicate quantile—in this case, the 0.95 quantile, or the
    95th percentile.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument in the d, p, and q series is actually a vector so that we
    can evaluate the density/pmf, cdf, or quantile function at multiple points.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s find both the 50th and 95th percentiles of the chi-square distribution
    with 2 degrees of freedom.
  prefs: []
  type: TYPE_NORMAL
- en: qchisq(c(0.5,0.95),df=2)
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 1.386294 5.991465'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.3 Sorting**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ordinary numerical sorting of a vector can be done with the sort() function,
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: x <- c(13,5,12,5)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: sort(x)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 5 5 12 13'
  prefs: []
  type: TYPE_NORMAL
- en: x
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 13 5 12 5'
  prefs: []
  type: TYPE_NORMAL
- en: Note that x itself did not change, in keeping with R’s functional language philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the indices of the sorted values in the original vector, use the
    order() function. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: order(x)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 2 4 3 1'
  prefs: []
  type: TYPE_NORMAL
- en: This means that x[2] is the smallest value in x, x[4] is the second smallest,
    x[3] is the third smallest, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**194**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use order(), together with indexing, to sort data frames, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: y
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: V1 V2
  prefs: []
  type: TYPE_NORMAL
- en: 1 def 2
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: ab 5
  prefs: []
  type: TYPE_NORMAL
- en: 3 zzzz 1
  prefs: []
  type: TYPE_NORMAL
- en: r <- order(y$V2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: r
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 3 1 2'
  prefs: []
  type: TYPE_NORMAL
- en: z <- y[r,]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: z
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: V1 V2
  prefs: []
  type: TYPE_NORMAL
- en: 3 zzzz 1
  prefs: []
  type: TYPE_NORMAL
- en: 1 def 2
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: ab 5
  prefs: []
  type: TYPE_NORMAL
- en: What happened here? We called order() on the second column of y,
  prefs: []
  type: TYPE_NORMAL
- en: yielding a vector r, telling us where numbers should go if we want to sort them.
    The 3 in this vector tells us that x[3,2] is the smallest number in x[,2]; the
    1 tells us that x[1,2] is the second smallest; and the 2 tells us that x[2,2]
  prefs: []
  type: TYPE_NORMAL
- en: is the third smallest. We then use indexing to produce the frame sorted by column
    2, storing it in z.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use order() to sort according to character variables as well as numeric
    ones, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: kids ages
  prefs: []
  type: TYPE_NORMAL
- en: 1 Jack
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: 2 Jill
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: 3 Billy
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: d[order(d$kids),]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: kids ages
  prefs: []
  type: TYPE_NORMAL
- en: 3 Billy
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: 1 Jack
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: 2 Jill
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: d[order(d$ages),]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: kids ages
  prefs: []
  type: TYPE_NORMAL
- en: 2 Jill
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: 1 Jack
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: 3 Billy
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: A related function is rank(), which reports the rank of each element of a vector.
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  prefs: []
  type: TYPE_NORMAL
- en: '**195**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: x <- c(13,5,12,5)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: rank(x)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 4.0 1.5 3.0 1.5'
  prefs: []
  type: TYPE_NORMAL
- en: This says that 13 had rank 4 in x; that is, it is the fourth smallest. The value
    5 appears twice in x, with those two being the first and second smallest, so the
    rank 1.5 is assigned to both. Optionally, other methods of handling ties can be
    specified.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.4 Linear Algebra Operations on Vectors and Matrices**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying a vector by a scalar works directly, as you saw earlier. Here’s
    another example:'
  prefs: []
  type: TYPE_NORMAL
- en: y
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 3 4 10'
  prefs: []
  type: TYPE_NORMAL
- en: 2*y
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 2 6 8 20'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to compute the inner product (or dot product) of two vectors, use
    crossprod(), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: crossprod(1:3,c(5,12,13))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '68'
  prefs: []
  type: TYPE_NORMAL
- en: The function computed 1 *·* 5 + 2 *·* 12 + 3 *·* 13 = 68\.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the name crossprod() is a misnomer, as the function does not compute
    the vector cross product. We’ll develop a function to compute real cross products
    in Section 8.4.1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'For matrix multiplication in the mathematical sense, the operator to use is
    %*%, not *. For instance, here we compute the matrix product:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 2
  prefs: []
  type: TYPE_NORMAL
- en: 1 *−* 1
  prefs: []
  type: TYPE_NORMAL
- en: 1 1
  prefs: []
  type: TYPE_NORMAL
- en: 3 4
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '='
  prefs: []
  type: TYPE_NORMAL
- en: 3 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: a
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '-1'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '**196**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: a %*% b
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function solve() will solve systems of linear equations and even find matrix
    inverses. For example, let’s solve this system:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* 1 + *x* 2 = 2'
  prefs: []
  type: TYPE_NORMAL
- en: '*−x* 1 + *x* 2 = 4'
  prefs: []
  type: TYPE_NORMAL
- en: 'Its matrix form is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* 1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '*−* 1 1'
  prefs: []
  type: TYPE_NORMAL
- en: '='
  prefs: []
  type: TYPE_NORMAL
- en: '*x* 2'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: a <- matrix(c(1,1,-1,1),nrow=2,ncol=2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b <- c(2,4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: solve(a,b)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 3 1'
  prefs: []
  type: TYPE_NORMAL
- en: solve(a)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 0.5 0.5'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] -0.5 0.5'
  prefs: []
  type: TYPE_NORMAL
- en: In that second call to solve(), the lack of a second argument signifies that
    we simply wish to compute the inverse of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few other linear algebra functions:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 't(): Matrix transpose'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'qr(): QR decomposition'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'chol(): Cholesky decomposition'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'det(): Determinant'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'eigen(): Eigenvalues/eigenvectors'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'diag(): Extracts the diagonal of a square matrix (useful for obtaining variances
    from a covariance matrix and for constructing a diagonal'
  prefs: []
  type: TYPE_NORMAL
- en: matrix).
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'sweep(): Numerical analysis sweep operations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the versatile nature of diag(): If its argument is a matrix, it returns
    a vector, and vice versa. Also, if the argument is a scalar, the function returns
    the identity matrix of the specified size.'
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  prefs: []
  type: TYPE_NORMAL
- en: '**197**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: m
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: dm <- diag(m)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: dm
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 8'
  prefs: []
  type: TYPE_NORMAL
- en: diag(dm)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: diag(3)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '[3,]'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: The sweep() function is capable of fairly complex operations. As a simple example,
    let’s take a 3-by-3 matrix and add 1 to row 1, 4 to row 2, and 7 to row 3\.
  prefs: []
  type: TYPE_NORMAL
- en: m
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '[3,]'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: sweep(m,1,c(1,4,7),"+")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '[3,]'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two arguments to sweep() are like those of apply(): the array and
    the margin, which is 1 for rows in this case. The fourth argument is a function
    to be applied, and the third is an argument to that function (to the'
  prefs: []
  type: TYPE_NORMAL
- en: '"+" function).'
  prefs: []
  type: TYPE_NORMAL
- en: '***8.4.1 Extended Example: Vector Cross Product***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the issue of vector cross products. The definition is very simple:
    The cross product of vectors ( *x* 1 *, x* 2 *, x* 3) and ( *y* 1 *, y* 2 *, y*
    3) in three-dimensional space is a new three-dimensional vector, as shown in Equation
    8.1\.'
  prefs: []
  type: TYPE_NORMAL
- en: ( *x* 2 *y* 3 *− x* 3 *y* 2 *, −x* 1 *y* 3 + *x* 3 *y* 1 *, x* 1 *y* 2 *− x*
    2 *y* 1) (8.1)
  prefs: []
  type: TYPE_NORMAL
- en: '**198**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: This can be expressed compactly as the expansion along the top row of the determinant,
    as shown in Equation 8.2\.
  prefs: []
  type: TYPE_NORMAL
- en: ⎛
  prefs: []
  type: TYPE_NORMAL
- en: ⎞
  prefs: []
  type: TYPE_NORMAL
- en: '*− − −*'
  prefs: []
  type: TYPE_NORMAL
- en: ⎝ *x* 1 *x* 2 *x* 3 ⎠
  prefs: []
  type: TYPE_NORMAL
- en: (8.2)
  prefs: []
  type: TYPE_NORMAL
- en: '*y* 1'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* 2'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* 3'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the elements in the top row are merely placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry about this bit of pseudomath. The point is that the cross product
    vector can be computed as a sum of subdeterminants. For instance, the first component
    in Equation 8.1, *x* 2 *y* 3 *− x* 3 *y* 2, is easily seen to be the determinant
    of the submatrix obtained by deleting the first row and first column in Equation
    8.2, as shown in Equation 8.3\.
  prefs: []
  type: TYPE_NORMAL
- en: '*x* 2 *x* 3'
  prefs: []
  type: TYPE_NORMAL
- en: (8.3)
  prefs: []
  type: TYPE_NORMAL
- en: '*y* 2'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* 3'
  prefs: []
  type: TYPE_NORMAL
- en: Our need to calculate subdeterminants—that is determinants of
  prefs: []
  type: TYPE_NORMAL
- en: submatrices—fits perfectly with R, which excels at specifying submatrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'This suggests calling det() on the proper submatrices, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: xprod <- function(x,y) {
  prefs: []
  type: TYPE_NORMAL
- en: m <- rbind(rep(NA,3),x,y)
  prefs: []
  type: TYPE_NORMAL
- en: xp <- vector(length=3)
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:3)
  prefs: []
  type: TYPE_NORMAL
- en: xp[i] <- -(-1)^i * det(m[2:3,-i])
  prefs: []
  type: TYPE_NORMAL
- en: return(xp)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Note that even R’s ability to specify values as NA came into play here to deal
    with the “placeholders” mentioned above.
  prefs: []
  type: TYPE_NORMAL
- en: All this may seem like overkill. After all, it wouldn’t have been hard to code
    Equation 8.1 directly, without resorting to use of submatrices and determinants.
    But while that may be true in the three-dimensional case, the approach shown here
    is quite fruitful in the *n*-ary case, in *n*-dimensional space. The cross product
    there is defined as an *n*-by- *n* determinant of the form shown in Equation 8.1,
    and thus the preceding code generalizes perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: '***8.4.2 Extended Example: Finding Stationary Distributions of Markov Chains***'
  prefs: []
  type: TYPE_NORMAL
- en: A Markov chain is a random process in which we move among various *states*,
    in a “memoryless” fashion, whose definition need not concern us here. The state
    could be the number of jobs in a queue, the number of items stored in inventory,
    and so on. We will assume the number of states to be finite.
  prefs: []
  type: TYPE_NORMAL
- en: As a simple example, consider a game in which we toss a coin repeatedly and
    win a dollar whenever we accumulate three consecutive heads.
  prefs: []
  type: TYPE_NORMAL
- en: Our state at any time *i* will the number of consecutive heads we have so far,
    so our state can be 0, 1, or 2\. (When we get three heads in a row, our state
    reverts to 0.)
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  prefs: []
  type: TYPE_NORMAL
- en: '**199**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The central interest in Markov modeling is usually the long-run state distribution,
    meaning the long-run proportions of the time we are in each state. In our coin-toss
    game, we can use the code we’ll develop here to calculate that distribution, which
    turns out to have us at states 0, 1, and 2 in proportions 57.1%, 28.6%, and 14.3%
    of the time. Note that we win our dollar if we are in state 2 and toss a head,
    so 0.143 *×* 0.5 = 0.071 of our tosses will result in wins.
  prefs: []
  type: TYPE_NORMAL
- en: Since R vector and matrix indices start at 1 rather than 0, it will be convenient
    to relabel our states here as 1, 2, and 3 rather than 0, 1, and 2\. For example,
    state 3 now means that we currently have two consecutive heads.
  prefs: []
  type: TYPE_NORMAL
- en: Let *pij* denote the *transition probability* of moving from state *i* to state
    *j* during a time step. In the game example, for instance, *p* 23 = 0 *.* 5, reflecting
    the fact that with probability 1/2, we will toss a head and thus move from having
    one consecutive head to two. On the other hand, if we toss a tail while we are
    in state 2, we go to state 1, meaning 0 consecutive heads; thus *p* 21 = 0 *.*
    5\.
  prefs: []
  type: TYPE_NORMAL
- en: We are interested in calculating the vector *π* = ( *π* 1 *, ..., πs*), where
    *πi* is the long-run proportion of time spent at state i, over all states i. Let
    *P*
  prefs: []
  type: TYPE_NORMAL
- en: denote the transition probability matrix whose *i* th row, *j* th column element
    is *pij*. Then it can be shown that *π* must satisfy Equation 8.4, *π* = *πP*
  prefs: []
  type: TYPE_NORMAL
- en: (8.4)
  prefs: []
  type: TYPE_NORMAL
- en: 'which is equivalent to Equation 8.5:'
  prefs: []
  type: TYPE_NORMAL
- en: ( *I − P T* ) *π* = 0
  prefs: []
  type: TYPE_NORMAL
- en: (8.5)
  prefs: []
  type: TYPE_NORMAL
- en: Here *I* is the identity matrix and *P T* denotes the transpose of *P*.
  prefs: []
  type: TYPE_NORMAL
- en: Any single one of the equations in the system of Equation 8.5 is redundant.
    We thus eliminate one of them, by removing the last row of *I −P* in Equation
    8.5\. That also means removing the last 0 in the 0 vector on the right-hand side
    of Equation 8.5\.
  prefs: []
  type: TYPE_NORMAL
- en: But note that there is also the constraint shown in Equation 8.6\.
  prefs: []
  type: TYPE_NORMAL
- en: '*πi* = 1'
  prefs: []
  type: TYPE_NORMAL
- en: (8.6)
  prefs: []
  type: TYPE_NORMAL
- en: '*i*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In matrix terms, this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 *Tnπ* = 1
  prefs: []
  type: TYPE_NORMAL
- en: where 1 *n* is a vector of *n* 1s.
  prefs: []
  type: TYPE_NORMAL
- en: So, in the modified version of Equation 8.5, we replace the removed row with
    a row of all 1s and, on the right-hand side, replace the removed 0 with a 1\.
    We can then solve the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this can be computed with R’s solve() function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: findpi1 <- function(p) {
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: n <- nrow(p)
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: imp <- diag(n) - t(p)
  prefs: []
  type: TYPE_NORMAL
- en: '**200**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: imp[n,] <- rep(1,n)
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: rhs <- c(rep(0,n-1),1)
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: pivec <- solve(imp,rhs)
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: return(pivec)
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the main steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Calculate *I − P T* in line 3\. Note again that diag(), when called with a scalar
    argument, returns the identity matrix of the size given by that argument.
  prefs: []
  type: TYPE_NORMAL
- en: 2\.
  prefs: []
  type: TYPE_NORMAL
- en: Replace the last row of *P* with 1 values in line 4\.
  prefs: []
  type: TYPE_NORMAL
- en: 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the right-hand side vector in line 5\.
  prefs: []
  type: TYPE_NORMAL
- en: 4\.
  prefs: []
  type: TYPE_NORMAL
- en: Solve for *π* in line 6\.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach, using more advanced knowledge, is based on eigen-
  prefs: []
  type: TYPE_NORMAL
- en: values. Note from Equation 8.4 that *π* is a left eigenvector of *P* with eigenvalue
    1\. This suggests using R’s eigen() function, selecting the eigenvector corresponding
    to that eigenvalue. (A result from mathematics, the Perron-Frobenius theorem,
    can be used to carefully justify this.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Since *π* is a left eigenvector, the argument in the call to eigen() must be
    *P* transpose rather than *P*. In addition, since an eigenvector is unique only
    up to scalar multiplication, we must deal with two issues regarding the eigenvector
    returned to us by eigen():'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: It may have negative components. If so, we multiply by *−* 1\.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: It may not satisfy Equation 8.6\. We remedy this by dividing by the length of
    the returned vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: findpi2 <- function(p) {
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: n <- nrow(p)
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: find first eigenvector of P transpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: pivec <- eigen(t(p))$vectors[,1]
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: guaranteed to be real, but could be negative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: if (pivec[1] < 0) pivec <- -pivec
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: normalize to sum to 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: pivec <- pivec / sum(pivec)
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: return(pivec)
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: The return value of eigen() is a list. One of the list’s components is a matrix
    named vectors. These are the eigenvectors, with the *i* th column being the eigenvector
    corresponding to the *i* th eigenvalue. Thus, we take column 1 here.
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  prefs: []
  type: TYPE_NORMAL
- en: '**201**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.5 Set Operations**'
  prefs: []
  type: TYPE_NORMAL
- en: 'R includes some handy set operations, including these:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'union(x,y): Union of the sets x and y'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'intersect(x,y): Intersection of the sets x and y'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'setdiff(x,y): Set difference between x and y, consisting of all elements of
    x that are not in y'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'setequal(x,y): Test for equality between x and y'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'c %in% y: Membership, testing whether c is an element of the set y'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'choose(n,k): Number of possible subsets of size k chosen from a set of size
    n'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some simple examples of using these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: x <- c(1,2,5)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y <- c(5,1,8,9)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: union(x,y)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 2 5 8 9'
  prefs: []
  type: TYPE_NORMAL
- en: intersect(x,y)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 5'
  prefs: []
  type: TYPE_NORMAL
- en: setdiff(x,y)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 2'
  prefs: []
  type: TYPE_NORMAL
- en: setdiff(y,x)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 8 9'
  prefs: []
  type: TYPE_NORMAL
- en: setequal(x,y)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] FALSE'
  prefs: []
  type: TYPE_NORMAL
- en: setequal(x,c(1,2,5))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] TRUE'
  prefs: []
  type: TYPE_NORMAL
- en: 2 %in% x
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] TRUE'
  prefs: []
  type: TYPE_NORMAL
- en: 2 %in% y
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] FALSE'
  prefs: []
  type: TYPE_NORMAL
- en: choose(5,2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 10'
  prefs: []
  type: TYPE_NORMAL
- en: Recall from Section 7.12 that you can write your own binary operations.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, consider coding the symmetric difference between two sets—
  prefs: []
  type: TYPE_NORMAL
- en: that is, all the elements belonging to exactly one of the two operand sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the symmetric difference between sets x and y consists exactly of those
    elements in x but not y and vice versa, the code consists of easy calls to setdiff()
    and union(), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: symdiff
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: function(a,b) {
  prefs: []
  type: TYPE_NORMAL
- en: sdfxy <- setdiff(x,y)
  prefs: []
  type: TYPE_NORMAL
- en: sdfyx <- setdiff(y,x)
  prefs: []
  type: TYPE_NORMAL
- en: '**202**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: return(union(sdfxy,sdfyx))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try it.
  prefs: []
  type: TYPE_NORMAL
- en: x
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 1 2 5'
  prefs: []
  type: TYPE_NORMAL
- en: y
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 5 1 8 9'
  prefs: []
  type: TYPE_NORMAL
- en: symdiff(x,y)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 2 8 9'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example: a binary operand for determining whether one set u
    is a subset of another set v. A bit of thought shows that this property is equivalent
    to the intersection of u and v being equal to u. Hence we have another easily
    coded function:'
  prefs: []
  type: TYPE_NORMAL
- en: '"%subsetof%" <- function(u,v) {'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: return(setequal(intersect(u,v),u))
  prefs: []
  type: TYPE_NORMAL
- en: + }
  prefs: []
  type: TYPE_NORMAL
- en: c(3,8) %subsetof% 1:10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] TRUE'
  prefs: []
  type: TYPE_NORMAL
- en: c(3,8) %subsetof% 5:10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] FALSE'
  prefs: []
  type: TYPE_NORMAL
- en: The function combn() generates combinations. Let’s find the subsets of
  prefs: []
  type: TYPE_NORMAL
- en: '{1,2,3} of size 2\.'
  prefs: []
  type: TYPE_NORMAL
- en: c32 <- combn(1:3,2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,]'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,]'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: class(c32)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "matrix"'
  prefs: []
  type: TYPE_NORMAL
- en: The results are in the columns of the output. We see that the subsets of
  prefs: []
  type: TYPE_NORMAL
- en: '{1,2,3} of size 2 are (1,2), (1,3), and (2,3).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function also allows you to specify a function to be called by combn()
    on each combination. For example, we can find the sum of the numbers in each subset,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: combn(1:3,2,sum)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 3 4 5'
  prefs: []
  type: TYPE_NORMAL
- en: The first subset, {1,2}, has a sum of 2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  prefs: []
  type: TYPE_NORMAL
- en: '**203**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.6 Simulation Programming in R**'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common uses of R is simulation. Let’s see what kinds of tools
    R has available for this application.
  prefs: []
  type: TYPE_NORMAL
- en: '***8.6.1 Built-In Random Variate Generators***'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, R has functions to generate variates from a number of different
    distributions. For example, rbinom() generates binomial or Bernoulli random variates.1
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we want to find the probability of getting at least four heads out
    of five tosses of a coin (easy to find analytically, but a handy example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: x <- rbinom(100000,5,0.5)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: mean(x >= 4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 0.18829'
  prefs: []
  type: TYPE_NORMAL
- en: First, we generate 100,000 variates from a binomial distribution with five trials
    and a success probability of 0.5\. We then determine which of them has a value
    4 or 5, resulting in a Boolean vector of the same length as x. The TRUE
  prefs: []
  type: TYPE_NORMAL
- en: and FALSE values in that vector are treated as 1s and 0s by mean(), giving us
    our estimated probability (since the average of a bunch of 1s and 0s is the proportion
    of 1s).
  prefs: []
  type: TYPE_NORMAL
- en: Other functions include rnorm() for the normal distribution, rexp() for the
    exponential, runif() for the uniform, rgamma() for the gamma, rpois() for the
    Poisson, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another simple example, which finds *E*[max( *X, Y* )], the expected
    value of the maximum of independent N(0,1) random variables X and Y:'
  prefs: []
  type: TYPE_NORMAL
- en: sum <- 0
  prefs: []
  type: TYPE_NORMAL
- en: nreps <- 100000
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:nreps) {
  prefs: []
  type: TYPE_NORMAL
- en: 'xy <- rnorm(2) # generate 2 N(0,1)s'
  prefs: []
  type: TYPE_NORMAL
- en: sum <- sum + max(xy)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: print(sum/nreps)
  prefs: []
  type: TYPE_NORMAL
- en: We generated 100,000 pairs, found the maximum for each, and aver-
  prefs: []
  type: TYPE_NORMAL
- en: aged those maxima to obtain our estimated expected value.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code, with an explicit loop, may be clearer, but as before, if
    we are willing to use some more memory, we can do this more compactly.
  prefs: []
  type: TYPE_NORMAL
- en: 1 A sequence of independent 0- and 1- valued random variables with the same
    probability of 1
  prefs: []
  type: TYPE_NORMAL
- en: for each is called *Bernoulli*.
  prefs: []
  type: TYPE_NORMAL
- en: '**204**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: emax
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: function(nreps) {
  prefs: []
  type: TYPE_NORMAL
- en: x <- rnorm(2*nreps)
  prefs: []
  type: TYPE_NORMAL
- en: maxxy <- pmax(x[1:nreps],x[(nreps+1):(2*nreps)])
  prefs: []
  type: TYPE_NORMAL
- en: return(mean(maxxy))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we generated double nreps values. The first nreps value simulates X, and
    the remaining nreps value represents Y. The pmax() call then computes the pair-wise
    maxima that we need. Again, note the contrast here between max() and pmax(), the
    latter producing pair-wise maxima.
  prefs: []
  type: TYPE_NORMAL
- en: '***8.6.2 Obtaining the Same Random Stream in Repeated Runs***'
  prefs: []
  type: TYPE_NORMAL
- en: According to the R documentation, all random-number generators use
  prefs: []
  type: TYPE_NORMAL
- en: 32-bit integers for seed values. Thus, other than round-off error, the same
    initial seed should generate the same stream of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, R will generate a different random number stream from run to run
    of a program. If you want the same stream each time—important in debugging, for
    instance—call set.seed(), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'set.seed(8888) # or your favorite number as an argument'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***8.6.3 Extended Example: A Combinatorial Simulation***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following probability problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Three committees, of sizes 3, 4 and 5, are chosen from 20 people.
  prefs: []
  type: TYPE_NORMAL
- en: What is the probability that persons A and B are chosen for the
  prefs: []
  type: TYPE_NORMAL
- en: same committee?
  prefs: []
  type: TYPE_NORMAL
- en: This problem is not hard to solve analytically, but we may wish to check our
    solution using simulation, and in any case, writing the code will demonstrate
    how R’s set operations can come in handy in combinatorial settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: sim <- function(nreps) {
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: 'commdata <- list() # will store all our info about the 3 committees 3'
  prefs: []
  type: TYPE_NORMAL
- en: commdata$countabsamecomm <- 0
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: for (rep in 1:nreps) {
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: 'commdata$whosleft <- 1:20 # who''s left to choose from'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: 'commdata$numabchosen <- 0 # number among A, B chosen so far'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: choose committee 1, and check for A,B serving together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: commdata <- choosecomm(commdata,5)
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math and Simulations in R
  prefs: []
  type: TYPE_NORMAL
- en: '**205**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: if A or B already chosen, no need to look at the other comms.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: if (commdata$numabchosen > 0) next
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: choose committee 2 and check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: commdata <- choosecomm(commdata,4)
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: if (commdata$numabchosen > 0) next
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: choose committee 3 and check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: commdata <- choosecomm(commdata,3)
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: print(commdata$countabsamecomm/nreps)
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: choosecomm <- function(comdat,comsize) {
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: choose committee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: committee <- sample(comdat$whosleft,comsize)
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: count how many of A and B were chosen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: comdat$numabchosen <- length(intersect(1:2,committee))
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: if (comdat$numabchosen == 2)
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: comdat$countabsamecomm <- comdat$countabsamecomm + 1
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: delete chosen committee from the set of people we now have to choose from 28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: comdat$whosleft <- setdiff(comdat$whosleft,committee)
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: return(comdat)
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: We number the potential committee members from 1 to 20, with per-
  prefs: []
  type: TYPE_NORMAL
- en: 'sons A and B having ID 1 and 2\. Recalling that R lists are often used to store
    several related variables in one basket, we se up a list comdat. Its components
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'comdat$whosleft: We simulate the random selection of the committees by randomly
    choosing from this vector. Each time we choose a committee, we remove the committee
    members’ IDs. It is initialized to 1:20, indicating that no one has been selected
    yet.'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'comdat$numabchosen: This is a count of how many among the people A and B have
    been chosen so far. If we choose a committee and find this to be positive, we
    can skip choosing the remaining committees for the following reason: If this number
    is 2, we know definitely that A and B are on the same committee; if it is 1, we
    know definitely that A and B are *not* on the same committee.'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: 'comdat$countabsamecomm: Here, we store a count of the number of times A and
    B are on the same committee.'
  prefs: []
  type: TYPE_NORMAL
- en: Since committee selection involves subsets, it’s not surprising that a couple
    of R’s set operations—intersect() and setdiff()—come in handy here.
  prefs: []
  type: TYPE_NORMAL
- en: Note, too, the use of R’s next statement, which tells R to skip the rest of
    this iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**206**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 21](index-233_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**9**'
  prefs: []
  type: TYPE_NORMAL
- en: '**OBJECT-ORIENTED PROGRAMMING**'
  prefs: []
  type: TYPE_NORMAL
- en: Many programmers believe that object-
  prefs: []
  type: TYPE_NORMAL
- en: oriented programming (OOP) makes for
  prefs: []
  type: TYPE_NORMAL
- en: clearer, more reusable code. Though very
  prefs: []
  type: TYPE_NORMAL
- en: different from the familiar OOP languages like
  prefs: []
  type: TYPE_NORMAL
- en: C++, Java, and Python, R is very much OOP in outlook.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following themes are key to R:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: Everything you touch in R—ranging from numbers to character strings to matrices—is
    an object.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: R promotes *encapsulation*, which is packaging separate but related data items
    into one class instance. Encapsulation helps you keep track of related variables,
    enhancing clarity.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: R classes are *polymorphic*, which means that the same function call leads to
    different operations for objects of different classes. For instance, a call to
    print() on an object of a certain class triggers a call to a print function tailored
    to that class. Polymorphism promotes reusability.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: R allows *inheritance*, which allows extending a given class to a more specialized
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers OOP in R. We’ll discuss programming in the two types of
    classes, S3 and S4, and then present a few useful OOP-related R
  prefs: []
  type: TYPE_NORMAL
- en: utilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.1 S3 Classes**'
  prefs: []
  type: TYPE_NORMAL
- en: The original R structure for classes, known as S3, is still the dominant class
    paradigm in R use today. Indeed, most of R’s own built-in classes are of the S3
    type.
  prefs: []
  type: TYPE_NORMAL
- en: An S3 class consists of a list, with a class name attribute and *dispatch* capability
    added. The latter enables the use of generic functions, as we saw in Chapter 1\.
    S4 classes were developed later, with goal of adding *safety*, meaning that you
    cannot accidentally access a class component that is not already in existence.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.1 S3 Generic Functions***'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, R is polymorphic, in the sense that the same function can lead
    to different operations for different classes. You can apply plot(), for example,
    to many different types of objects, getting a different type of plot for each.
    The same is true for print(), summary(), and many other functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this manner, we get a uniform interface to different classes. For example,
    if you are writing code that includes plot operations, polymorphism may allow
    you to write your program without worrying about the various types of objects
    that might be plotted.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, polymorphism certainly makes things easier to remem-
  prefs: []
  type: TYPE_NORMAL
- en: ber for the user and makes it fun and convenient to explore new library functions
    and associated classes. If a function is new to you, just try running plot() on
    the function’s output; it will likely work. From a programmer’s viewpoint, polymorphism
    allows writing fairly general code, without worrying about what type of object
    is being manipulated, because the underlying class mechanisms take care of that.
  prefs: []
  type: TYPE_NORMAL
- en: The functions that work with polymorphism, such as plot() and print(), are known
    as *generic functions*. When a generic function is called, R will then dispatch
    the call to the proper class method, meaning that it will reroute the call to
    a function defined for the object’s class.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.2 Example: OOP in the lm() Linear Model Function***'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s look at a simple regression analysis run via R’s lm()
    function. First, let’s see what lm() does:'
  prefs: []
  type: TYPE_NORMAL
- en: ?lm
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The output of this help query will tell you, among other things, that this function
    returns an object of class "lm".
  prefs: []
  type: TYPE_NORMAL
- en: '**208**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try creating an instance of this object and then printing it:'
  prefs: []
  type: TYPE_NORMAL
- en: x <- c(1,2,3)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y <- c(1,3,8)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lmout <- lm(y ~ x)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: class(lmout)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "lm"'
  prefs: []
  type: TYPE_NORMAL
- en: lmout
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Call:'
  prefs: []
  type: TYPE_NORMAL
- en: lm(formula = y ~ x)
  prefs: []
  type: TYPE_NORMAL
- en: 'Coefficients:'
  prefs: []
  type: TYPE_NORMAL
- en: (Intercept)
  prefs: []
  type: TYPE_NORMAL
- en: x
  prefs: []
  type: TYPE_NORMAL
- en: '-3.0'
  prefs: []
  type: TYPE_NORMAL
- en: '3.5'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we printed out the object lmout. (Remember that by simply typing the name
    of an object in interactive mode, the object is printed.) The R interpreter then
    saw that lmout was an object of class "lm" and thus called print.lm(), a special
    print method for the "lm" class. In R terminology, the call to the generic function
    print() was dispatched to the method print.lm() associated with the class "lm".
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the generic function and the class method in
  prefs: []
  type: TYPE_NORMAL
- en: 'this case:'
  prefs: []
  type: TYPE_NORMAL
- en: print
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: function(x, ...) UseMethod("print")
  prefs: []
  type: TYPE_NORMAL
- en: '<environment: namespace:base>'
  prefs: []
  type: TYPE_NORMAL
- en: print.lm
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: function (x, digits = max(3, getOption("digits") - 3), ...)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: cat("\nCall:\n", deparse(x$call), "\n\n", sep = "") if (length(coef(x))) {
  prefs: []
  type: TYPE_NORMAL
- en: cat("Coefficients:\n")
  prefs: []
  type: TYPE_NORMAL
- en: print.default(format(coef(x), digits = digits), print.gap = 2,
  prefs: []
  type: TYPE_NORMAL
- en: quote = FALSE)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else cat("No coefficients\n")
  prefs: []
  type: TYPE_NORMAL
- en: cat("\n")
  prefs: []
  type: TYPE_NORMAL
- en: invisible(x)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '<environment: namespace:stats>'
  prefs: []
  type: TYPE_NORMAL
- en: You may be surprised to see that print() consists solely of a call to UseMethod().
    But this is actually the dispatcher function, so in view of print()’s role as
    a generic function, you should not be surprised after all.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs: []
  type: TYPE_NORMAL
- en: '**209**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry about the details of print.lm(). The main point is that the printing
    depends on context, with a special print function called for the
  prefs: []
  type: TYPE_NORMAL
- en: '"lm" class. Now let’s see what happens when we print this object with its class
    attribute removed:'
  prefs: []
  type: TYPE_NORMAL
- en: unclass(lmout)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $coefficients
  prefs: []
  type: TYPE_NORMAL
- en: (Intercept)
  prefs: []
  type: TYPE_NORMAL
- en: x
  prefs: []
  type: TYPE_NORMAL
- en: '-3.0'
  prefs: []
  type: TYPE_NORMAL
- en: '3.5'
  prefs: []
  type: TYPE_NORMAL
- en: $residuals
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: 0.5 -1.0 0.5
  prefs: []
  type: TYPE_NORMAL
- en: $effects
  prefs: []
  type: TYPE_NORMAL
- en: (Intercept)
  prefs: []
  type: TYPE_NORMAL
- en: x
  prefs: []
  type: TYPE_NORMAL
- en: '-6.928203'
  prefs: []
  type: TYPE_NORMAL
- en: '-4.949747'
  prefs: []
  type: TYPE_NORMAL
- en: '1.224745'
  prefs: []
  type: TYPE_NORMAL
- en: $rank
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 2'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve shown only the first few lines here—there’s a lot more. (Try running this
    on your own!) But you can see that the author of lm() decided to make print.lm()
    much more concise, limiting it to printing a few key quantities.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.3 Finding the Implementations of Generic Methods***'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all the implementations of a given generic method by calling methods(),
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: methods(print)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] print.acf*'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] print.anova'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] print.aov*'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] print.aovlist*'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] print.ar*'
  prefs: []
  type: TYPE_NORMAL
- en: '[6] print.Arima*'
  prefs: []
  type: TYPE_NORMAL
- en: '[7] print.arima0*'
  prefs: []
  type: TYPE_NORMAL
- en: '[8] print.AsIs'
  prefs: []
  type: TYPE_NORMAL
- en: '[9] print.aspell*'
  prefs: []
  type: TYPE_NORMAL
- en: '[10] print.Bibtex*'
  prefs: []
  type: TYPE_NORMAL
- en: '[11] print.browseVignettes*'
  prefs: []
  type: TYPE_NORMAL
- en: '[12] print.by'
  prefs: []
  type: TYPE_NORMAL
- en: '[13] print.check_code_usage_in_package*'
  prefs: []
  type: TYPE_NORMAL
- en: '[14] print.check_demo_index*'
  prefs: []
  type: TYPE_NORMAL
- en: '[15] print.checkDocFiles*'
  prefs: []
  type: TYPE_NORMAL
- en: '**210**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[16] print.checkDocStyle*'
  prefs: []
  type: TYPE_NORMAL
- en: '[17] print.check_dotInternal*'
  prefs: []
  type: TYPE_NORMAL
- en: '[18] print.checkFF*'
  prefs: []
  type: TYPE_NORMAL
- en: '[19] print.check_make_vars*'
  prefs: []
  type: TYPE_NORMAL
- en: '[20] print.check_package_code_syntax*'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: Asterisks denote *nonvisible* functions, meaning ones that are not in the default
    namespaces. You can find these functions via getAnywhere() and then access them
    by using a namespace qualifier. An example is print.aspell().
  prefs: []
  type: TYPE_NORMAL
- en: 'The aspell() function itself does a spellcheck on the file specified in its
    argument. For example, suppose the file *wrds* consists of this line: Which word
    is mispelled?'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, this function will catch the misspelled word, as follows: aspell("wrds")'
  prefs: []
  type: TYPE_NORMAL
- en: mispelled
  prefs: []
  type: TYPE_NORMAL
- en: wrds:1:15
  prefs: []
  type: TYPE_NORMAL
- en: The output says that there is the indicated spelling error in line 1, character
    15 of the input file. But what concerns us here is the mechanism by which that
    output was printed.
  prefs: []
  type: TYPE_NORMAL
- en: The aspell() function returns an object of class "aspell", which does have its
    own generic print function, print.aspell(). In fact, that function was invoked
    in our example, after the call to aspell(), and the return value was printed out.
    At that time, R called UseMethod() on the object of class "aspell".
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we call that print method directly, R won’t recognize it:'
  prefs: []
  type: TYPE_NORMAL
- en: aspout <- aspell("wrds")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print.aspell(aspout)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Error: could not find function "print.aspell"'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can find it by calling getAnywhere():'
  prefs: []
  type: TYPE_NORMAL
- en: getAnywhere(print.aspell)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A single object matching 'print.aspell' was found
  prefs: []
  type: TYPE_NORMAL
- en: It was found in the following places
  prefs: []
  type: TYPE_NORMAL
- en: registered S3 method for print from namespace utils
  prefs: []
  type: TYPE_NORMAL
- en: namespace:utils
  prefs: []
  type: TYPE_NORMAL
- en: with value
  prefs: []
  type: TYPE_NORMAL
- en: function (x, sort = TRUE, verbose = FALSE, indent = 2L, ...)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (!(nr <- nrow(x)))
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs: []
  type: TYPE_NORMAL
- en: '**211**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the function is in the utils namespace, and we can execute it by adding
    such a qualifier:'
  prefs: []
  type: TYPE_NORMAL
- en: utils:::print.aspell(aspout)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: mispelled
  prefs: []
  type: TYPE_NORMAL
- en: wrds:1:15
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see all the generic methods this way:'
  prefs: []
  type: TYPE_NORMAL
- en: methods(class="default")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.4 Writing S3 Classes***'
  prefs: []
  type: TYPE_NORMAL
- en: 'S3 classes have a rather cobbled-together structure. A class instance is created
    by forming a list, with the components of the list being the member variables
    of the class. (Readers who know Perl may recognize this ad hoc nature in Perl’s
    own OOP system.) The "class" attribute is set by hand by using the attr() or class()
    function, and then various implementations of generic functions are defined. We
    can see this in the case of lm() by inspecting the function:'
  prefs: []
  type: TYPE_NORMAL
- en: lm
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: z <- list(coefficients = if (is.matrix(y))
  prefs: []
  type: TYPE_NORMAL
- en: matrix(,0,3) else numeric(0L), residuals = y,
  prefs: []
  type: TYPE_NORMAL
- en: fitted.values = 0 * y, weights = w, rank = 0L,
  prefs: []
  type: TYPE_NORMAL
- en: df.residual = if (is.matrix(y)) nrow(y) else length(y))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: class(z) <- c(if(is.matrix(y)) "mlm", "lm")
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: Again, don’t mind the details; the basic process is there. A list was created
    and assigned to z, which will serve as the framework for the "lm" class instance
    (and which will eventually be the value returned by the function).
  prefs: []
  type: TYPE_NORMAL
- en: Some components of that list, such as residuals, were already assigned when
    the list was created. In addition, the class attribute was set to "lm" (and possibly
    to "mlm", as will be explained in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of how to write an S3 class, let’s switch to something simpler.
    Continuing our employee example from Section 4.1, we could write this:'
  prefs: []
  type: TYPE_NORMAL
- en: j <- list(name="Joe", salary=55000, union=T)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: class(j) <- "employee"
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'attributes(j) # let''s check'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**212**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: $names
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "name" "salary" "union"'
  prefs: []
  type: TYPE_NORMAL
- en: $class
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "employee"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write a print method for this class, let’s see what happens when
    we call the default print():'
  prefs: []
  type: TYPE_NORMAL
- en: j
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: $name
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "Joe"'
  prefs: []
  type: TYPE_NORMAL
- en: $salary
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 55000'
  prefs: []
  type: TYPE_NORMAL
- en: $union
  prefs: []
  type: TYPE_NORMAL
- en: '[1] TRUE'
  prefs: []
  type: TYPE_NORMAL
- en: attr(,"class")
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "employee"'
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, j was treated as a list for printing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s write our own print method:'
  prefs: []
  type: TYPE_NORMAL
- en: print.employee <- function(wrkr) {
  prefs: []
  type: TYPE_NORMAL
- en: cat(wrkr$name,"\n")
  prefs: []
  type: TYPE_NORMAL
- en: cat("salary",wrkr$salary,"\n")
  prefs: []
  type: TYPE_NORMAL
- en: cat("union member",wrkr$union,"\n")
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, any call to print() on an object of class "employee" should now be referred
    to print.employee(). We can check that formally:'
  prefs: []
  type: TYPE_NORMAL
- en: methods(,"employee")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] print.employee'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, of course, we can simply try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: j
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Joe
  prefs: []
  type: TYPE_NORMAL
- en: salary 55000
  prefs: []
  type: TYPE_NORMAL
- en: union member TRUE
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs: []
  type: TYPE_NORMAL
- en: '**213**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.5 Using Inheritance***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of inheritance is to form new classes as specialized versions of old
    ones. In our previous employee example, for instance, we could form a new class
    devoted to hourly employees, "hrlyemployee", as a subclass of "employee", as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: k <- list(name="Kate", salary= 68000, union=F, hrsthismonth= 2) class(k) <-
    c("hrlyemployee","employee")
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new class has one extra variable: hrsthismonth. The name of the new class
    consists of two character strings, representing the new class and the old class.
    Our new class inherits the methods of the old one. For instance, print.employee()
    still works on the new class:'
  prefs: []
  type: TYPE_NORMAL
- en: k
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Kate
  prefs: []
  type: TYPE_NORMAL
- en: salary 68000
  prefs: []
  type: TYPE_NORMAL
- en: union member FALSE
  prefs: []
  type: TYPE_NORMAL
- en: Given the goals of inheritance, that is not surprising. However, it’s important
    to understand exactly what transpired here.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, simply typing k resulted in the call print(k). In turn, that caused
    UseMethod() to search for a print method on the first of k’s two class names,
    "hrlyemployee". That search failed, so UseMethod() tried the other class name,
    "employee", and found print.employee(). It executed the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that in inspecting the code for "lm", you saw this line: class(z) <-
    c(if(is.matrix(y)) "mlm", "lm")'
  prefs: []
  type: TYPE_NORMAL
- en: You can now see that "mlm" is a subclass of "lm" for vector-valued response
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.6 Extended Example: A Class for Storing Upper-Triangular Matrices***'
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time for a more involved example, in which we will write an R class
  prefs: []
  type: TYPE_NORMAL
- en: '"ut" for upper-triangular matrices. These are square matrices whose elements
    below the diagonal are zeros, such as shown in Equation 9.1\.'
  prefs: []
  type: TYPE_NORMAL
- en: ⎛
  prefs: []
  type: TYPE_NORMAL
- en: ⎞
  prefs: []
  type: TYPE_NORMAL
- en: 1 5 12
  prefs: []
  type: TYPE_NORMAL
- en: ⎝0 6 9 ⎠
  prefs: []
  type: TYPE_NORMAL
- en: (9.1)
  prefs: []
  type: TYPE_NORMAL
- en: 0 0 2
  prefs: []
  type: TYPE_NORMAL
- en: Our motivation here is to save storage space (though at the expense of a little
    extra access time) by storing only the nonzero portion of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The R class "dist" also uses such storage, though in a more focused context
    and without the class functions we have here.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**214**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: The component mat of this class will store the matrix. As mentioned, to save
    on storage space, only the diagonal and above-diagonal elements will be stored,
    in column-major order. Storage for the matrix (9.1), for instance, consists of
    the vector (1,5,6,12,9,2), and the component mat has that value.
  prefs: []
  type: TYPE_NORMAL
- en: We will include a component ix in this class, to show where in mat the various
    columns begin. For the preceding case, ix is c(1,2,4), meaning that column 1 begins
    at mat[1], column 2 begins at mat[2], and column 3 begins at mat[4]. This allows
    for handy access to individual elements or columns of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the code for our class.
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: class "ut", compact storage of upper-triangular matrices 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: utility function, returns 1+...+i
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: sum1toi <- function(i) return(i*(i+1)/2)
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: create an object of class "ut" from the full matrix inmat (0s included) 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ut <- function(inmat) {
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: n <- nrow(inmat)
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: 'rtrn <- list() # start to build the object'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: class(rtrn) <- "ut"
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: rtrn$mat <- vector(length=sum1toi(n))
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: rtrn$ix <- sum1toi(0:(n-1)) + 1
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:n) {
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: store column i
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: ixi <- rtrn$ix[i]
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: rtrn$mat[ixi:(ixi+i-1)] <- inmat[1:i,i]
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: return(rtrn)
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: uncompress utmat to a full matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: expandut <- function(utmat) {
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: 'n <- length(utmat$ix) # numbers of rows and cols of matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: fullmat <- matrix(nrow=n,ncol=n)
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: for (j in 1:n) {
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: fill jth column
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: start <- utmat$ix[j]
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: fin <- start + j - 1
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: 'abovediagj <- utmat$mat[start:fin] # above-diag part of col j'
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: fullmat[,j] <- c(abovediagj,rep(0,n-j))
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: return(fullmat)
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  prefs: []
  type: TYPE_NORMAL
- en: print matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '36'
  prefs: []
  type: TYPE_NORMAL
- en: print.ut <- function(utmat)
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  prefs: []
  type: TYPE_NORMAL
- en: print(expandut(utmat))
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs: []
  type: TYPE_NORMAL
- en: '**215**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  prefs: []
  type: TYPE_NORMAL
- en: multiply one ut matrix by another, returning another ut instance; 40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: implement as a binary operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '41'
  prefs: []
  type: TYPE_NORMAL
- en: '"%mut%" <- function(utmat1,utmat2) {'
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  prefs: []
  type: TYPE_NORMAL
- en: 'n <- length(utmat1$ix) # numbers of rows and cols of matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  prefs: []
  type: TYPE_NORMAL
- en: utprod <- ut(matrix(0,nrow=n,ncol=n))
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  prefs: []
  type: TYPE_NORMAL
- en: 'for (i in 1:n) { # compute col i of product'
  prefs: []
  type: TYPE_NORMAL
- en: '45'
  prefs: []
  type: TYPE_NORMAL
- en: let a[j] and bj denote columns j of utmat1 and utmat2, respectively, 46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: so that, e.g. b2[1] means element 1 of column 2 of utmat2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '47'
  prefs: []
  type: TYPE_NORMAL
- en: then column i of product is equal to
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '48'
  prefs: []
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: bi[1]*a[1] + ... + bi[i]*a[i]
  prefs: []
  type: TYPE_NORMAL
- en: '49'
  prefs: []
  type: TYPE_NORMAL
- en: find index of start of column i in utmat2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '50'
  prefs: []
  type: TYPE_NORMAL
- en: startbi <- utmat2$ix[i]
  prefs: []
  type: TYPE_NORMAL
- en: '51'
  prefs: []
  type: TYPE_NORMAL
- en: initialize vector that will become bi[1]*a[1] + ... + bi[i]*a[i]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '52'
  prefs: []
  type: TYPE_NORMAL
- en: prodcoli <- rep(0,i)
  prefs: []
  type: TYPE_NORMAL
- en: '53'
  prefs: []
  type: TYPE_NORMAL
- en: 'for (j in 1:i) { # find bi[j]*a[j], add to prodcoli'
  prefs: []
  type: TYPE_NORMAL
- en: '54'
  prefs: []
  type: TYPE_NORMAL
- en: startaj <- utmat1$ix[j]
  prefs: []
  type: TYPE_NORMAL
- en: '55'
  prefs: []
  type: TYPE_NORMAL
- en: bielement <- utmat2$mat[startbi+j-1]
  prefs: []
  type: TYPE_NORMAL
- en: '56'
  prefs: []
  type: TYPE_NORMAL
- en: prodcoli[1:j] <- prodcoli[1:j] +
  prefs: []
  type: TYPE_NORMAL
- en: '57'
  prefs: []
  type: TYPE_NORMAL
- en: bielement * utmat1$mat[startaj:(startaj+j-1)]
  prefs: []
  type: TYPE_NORMAL
- en: '58'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '59'
  prefs: []
  type: TYPE_NORMAL
- en: now need to tack on the lower 0s
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '60'
  prefs: []
  type: TYPE_NORMAL
- en: startprodcoli <- sum1toi(i-1)+1
  prefs: []
  type: TYPE_NORMAL
- en: '61'
  prefs: []
  type: TYPE_NORMAL
- en: utprod$mat[startbi:(startbi+i-1)] <- prodcoli
  prefs: []
  type: TYPE_NORMAL
- en: '62'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '63'
  prefs: []
  type: TYPE_NORMAL
- en: return(utprod)
  prefs: []
  type: TYPE_NORMAL
- en: '64'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test it.
  prefs: []
  type: TYPE_NORMAL
- en: test
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: function() {
  prefs: []
  type: TYPE_NORMAL
- en: utm1 <- ut(rbind(1:2,c(0,2)))
  prefs: []
  type: TYPE_NORMAL
- en: utm2 <- ut(rbind(3:2,c(0,1)))
  prefs: []
  type: TYPE_NORMAL
- en: utp <- utm1 %mut% utm2
  prefs: []
  type: TYPE_NORMAL
- en: print(utm1)
  prefs: []
  type: TYPE_NORMAL
- en: print(utm2)
  prefs: []
  type: TYPE_NORMAL
- en: print(utp)
  prefs: []
  type: TYPE_NORMAL
- en: utm1 <- ut(rbind(1:3,0:2,c(0,0,5)))
  prefs: []
  type: TYPE_NORMAL
- en: utm2 <- ut(rbind(4:2,0:2,c(0,0,1)))
  prefs: []
  type: TYPE_NORMAL
- en: utp <- utm1 %mut% utm2
  prefs: []
  type: TYPE_NORMAL
- en: print(utm1)
  prefs: []
  type: TYPE_NORMAL
- en: print(utm2)
  prefs: []
  type: TYPE_NORMAL
- en: print(utp)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**216**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: test()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 1 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 3 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0 1'
  prefs: []
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 3 4'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 1 2 3'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0 1 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[3,] 0 0 5'
  prefs: []
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 4 3 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0 1 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[3,] 0 0 1'
  prefs: []
  type: TYPE_NORMAL
- en: '[,1] [,2] [,3]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 4 5 9'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0 1 4'
  prefs: []
  type: TYPE_NORMAL
- en: '[3,] 0 0 5'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the code, we take into account the fact that the matrices involved
    have a lot of zeros. For example, we avoid multiplying by zeros simply by not
    adding terms to sums when the terms include a 0 factor.
  prefs: []
  type: TYPE_NORMAL
- en: The ut() function is fairly straightforward. This function is a *constructor*,
    which is a function whose job it is to create an instance of the given class,
    eventually returning that instance. So in line 9, we create a list that will serve
    as the body of the class object, naming it rtrn as a reminder that this will be
    the class instance to be constructed and returned.
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, the main member variables of our class will be mat and idx,
    implemented as components of the list. Memory for these two components is allocated
    in lines 11 and 12\.
  prefs: []
  type: TYPE_NORMAL
- en: The loop that follows then fills in rtrn$mat column by column and
  prefs: []
  type: TYPE_NORMAL
- en: 'assigns rtrn$idx element by element. A slicker way to do this for loop would
    be to use the rather obscure row() and col() functions. The row() function takes
    a matrix input and returns a new matrix of the same size, but with each element
    replaced by its row number. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: m
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 1 4'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 2 5'
  prefs: []
  type: TYPE_NORMAL
- en: '[3,] 3 6'
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs: []
  type: TYPE_NORMAL
- en: '**217**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: row(m)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[,1] [,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 1 1'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 2 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[3,] 3 3'
  prefs: []
  type: TYPE_NORMAL
- en: The col() function works similarly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this idea, we could replace the for loop in ut() with a one-liner: rtrn$mat
    <- inmat[row(inmat) <= col(inmat)]'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever possible, we should exploit vectorization. Take a look at
  prefs: []
  type: TYPE_NORMAL
- en: 'line 12, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: rtrn$ix <- sum1toi(0:(n-1)) + 1
  prefs: []
  type: TYPE_NORMAL
- en: Since sum1toi() (which we defined on line 4) is based only on the vectorized
    functions "*"() and "+"(), sum1toi() itself is also vectorized. This allows us
    to apply sum1toi() to a vector above. Note that we used recycling as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want our "ut" class to include some methods, not just variables. To this
    end, we have included three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: The expandut() function converts from a compressed matrix to an ordinary one.
    In expandut(), the key lines are 27 and 28, where we use rtrn$ix to determine
    where in utmat$mat the *j* th column of our matrix is stored.
  prefs: []
  type: TYPE_NORMAL
- en: That data is then copied to the *j* th column of fullmat in line 30\. Note the
    use of rep() to generate the zeros in the lower portion of this column.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: The print.ut() function is for printing. This function is quick and easy, using
    expandut(). Recall that any call to print() on an object of type "ut"
  prefs: []
  type: TYPE_NORMAL
- en: will be dispatched to print.ut(), as in our test cases earlier.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: The "%mut%"() function is for multiplying two compressed matrices (without uncompressing
    them). This function starts in line 39\. Since this is a binary operation, we
    take advantage of the fact that R accommodates user-defined binary operations,
    as described in Section 7.12, and implement our matrix-multiply function as %mut%.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the details of the "%mut%"() function. First, in line 43, we allocate
    space for the product matrix. Note the use of recycling in an unusual context.
    The first argument of matrix() is required to be a vector of a length compatible
    with the number of specified rows and columns, so the 0 we provide is recycled
    to a vector of length *n* 2\. Of course, rep() could be used instead, but exploiting
    recycling makes for a bit shorter, more elegant code.
  prefs: []
  type: TYPE_NORMAL
- en: For both clarity and fast execution, the code here has been written around the
    fact that R stores matrices in column-major order. As mentioned in the comments,
    our code then makes use of the fact that column *i* of the **218**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: product can be expressed as a linear combination of the columns of the first
    factor. It will help to see a specific example of this property, shown in Equation
    9.2\.
  prefs: []
  type: TYPE_NORMAL
- en: ⎛
  prefs: []
  type: TYPE_NORMAL
- en: ⎞ ⎛
  prefs: []
  type: TYPE_NORMAL
- en: ⎞
  prefs: []
  type: TYPE_NORMAL
- en: ⎛
  prefs: []
  type: TYPE_NORMAL
- en: ⎞
  prefs: []
  type: TYPE_NORMAL
- en: 1 2 3
  prefs: []
  type: TYPE_NORMAL
- en: 4 3 2
  prefs: []
  type: TYPE_NORMAL
- en: 4 5 9
  prefs: []
  type: TYPE_NORMAL
- en: ⎝ 0 1 2 ⎠ ⎝ 0 1 2 ⎠ = ⎝ 0 1 4 ⎠
  prefs: []
  type: TYPE_NORMAL
- en: (9.2)
  prefs: []
  type: TYPE_NORMAL
- en: 0 0 5
  prefs: []
  type: TYPE_NORMAL
- en: 0 0 1
  prefs: []
  type: TYPE_NORMAL
- en: 0 0 5
  prefs: []
  type: TYPE_NORMAL
- en: 'The comments say that, for instance, column 3 of the product is equal to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: ⎛
  prefs: []
  type: TYPE_NORMAL
- en: ⎞
  prefs: []
  type: TYPE_NORMAL
- en: ⎛
  prefs: []
  type: TYPE_NORMAL
- en: ⎞
  prefs: []
  type: TYPE_NORMAL
- en: ⎛
  prefs: []
  type: TYPE_NORMAL
- en: ⎞
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: 2 ⎝ 0 ⎠ + 2 ⎝ 1 ⎠ + 1 ⎝ 2 ⎠
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: Inspection of Equation 9.2 confirms the relation.
  prefs: []
  type: TYPE_NORMAL
- en: Couching the multiplication problem in terms of columns of the
  prefs: []
  type: TYPE_NORMAL
- en: two input matrices enables us to compact the code and to likely increase the
    speed. The latter again stems from vectorization, a benefit discussed in detail
    in Chapter 14\. This approach is used in the loop beginning at line 53\. (Arguably,
    in this case, the increase in speed comes at the expense of readability of the
    code.)
  prefs: []
  type: TYPE_NORMAL
- en: '***9.1.7 Extended Example: A Procedure for Polynomial Regression***'
  prefs: []
  type: TYPE_NORMAL
- en: As another example, consider a statistical regression setting with one predictor
    variable. Since any statistical model is merely an approximation, in principle,
    you can get better and better models by fitting polynomials of higher and higher
    degrees. However, at some point, this becomes over-fitting, so that the prediction
    of new, future data actually deteriorates for degrees higher than some value.
  prefs: []
  type: TYPE_NORMAL
- en: The class "polyreg" aims to deal with this issue. It fits polynomials of various
    degrees but assesses fits via cross-validation to reduce the risk of over-fitting.
    In this form of cross-validation, known as the *leaving-one-out method*, for each
    point we fit the regression to all the data *except* this observation, and then
    we predict that observation from the fit. An object of this class consists of
    outputs from the various regression models, plus the original data.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the code for the "polyreg" class.
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '"polyreg," S3 class for polynomial regression in one predictor variable 2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: polyfit(y,x,maxdeg) fits all polynomials up to degree maxdeg; y is 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: vector for response variable, x for predictor; creates an object of 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: class "polyreg"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: polyfit <- function(y,x,maxdeg) {
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: form powers of predictor variable, ith power in ith column
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: 'pwrs <- powers(x,maxdeg) # could use orthog polys for greater accuracy 9'
  prefs: []
  type: TYPE_NORMAL
- en: 'lmout <- list() # start to build class'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: 'class(lmout) <- "polyreg" # create a new class'
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs: []
  type: TYPE_NORMAL
- en: '**219**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:maxdeg) {
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: lmo <- lm(y ~ pwrs[,1:i])
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: extend the lm class here, with the cross-validated predictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: lmo$fitted.cvvalues <- lvoneout(y,pwrs[,1:i,drop=F])
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: lmout[[i]] <- lmo
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: lmout$x <- x
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: lmout$y <- y
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: return(lmout)
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: 'print() for an object fits of class "polyreg": print'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: cross-validated mean-squared prediction errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: print.polyreg <- function(fits) {
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: maxdeg <- length(fits) - 2
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(fits$y)
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: tbl <- matrix(nrow=maxdeg,ncol=1)
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: colnames(tbl) <- "MSPE"
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:maxdeg) {
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: fi <- fits[[i]]
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: errs <- fits$y - fi$fitted.cvvalues
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: 'spe <- crossprod(errs,errs) # sum of squared prediction errors'
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: tbl[i,1] <- spe/n
  prefs: []
  type: TYPE_NORMAL
- en: '34'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '35'
  prefs: []
  type: TYPE_NORMAL
- en: cat("mean squared prediction errors, by degree\n")
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  prefs: []
  type: TYPE_NORMAL
- en: print(tbl)
  prefs: []
  type: TYPE_NORMAL
- en: '37'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  prefs: []
  type: TYPE_NORMAL
- en: '39'
  prefs: []
  type: TYPE_NORMAL
- en: forms matrix of powers of the vector x, through degree dg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: powers <- function(x,dg) {
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  prefs: []
  type: TYPE_NORMAL
- en: pw <- matrix(x,nrow=length(x))
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  prefs: []
  type: TYPE_NORMAL
- en: prod <- x
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 2:dg) {
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  prefs: []
  type: TYPE_NORMAL
- en: prod <- prod * x
  prefs: []
  type: TYPE_NORMAL
- en: '45'
  prefs: []
  type: TYPE_NORMAL
- en: pw <- cbind(pw,prod)
  prefs: []
  type: TYPE_NORMAL
- en: '46'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '47'
  prefs: []
  type: TYPE_NORMAL
- en: return(pw)
  prefs: []
  type: TYPE_NORMAL
- en: '48'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '49'
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  prefs: []
  type: TYPE_NORMAL
- en: finds cross-validated predicted values; could be made much faster via 51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: matrix-update methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '52'
  prefs: []
  type: TYPE_NORMAL
- en: lvoneout <- function(y,xmat) {
  prefs: []
  type: TYPE_NORMAL
- en: '53'
  prefs: []
  type: TYPE_NORMAL
- en: n <- length(y)
  prefs: []
  type: TYPE_NORMAL
- en: '54'
  prefs: []
  type: TYPE_NORMAL
- en: predy <- vector(length=n)
  prefs: []
  type: TYPE_NORMAL
- en: '55'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:n) {
  prefs: []
  type: TYPE_NORMAL
- en: '56'
  prefs: []
  type: TYPE_NORMAL
- en: regress, leaving out ith observation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '57'
  prefs: []
  type: TYPE_NORMAL
- en: lmo <- lm(y[-i] ~ xmat[-i,])
  prefs: []
  type: TYPE_NORMAL
- en: '58'
  prefs: []
  type: TYPE_NORMAL
- en: betahat <- as.vector(lmo$coef)
  prefs: []
  type: TYPE_NORMAL
- en: '**220**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '59'
  prefs: []
  type: TYPE_NORMAL
- en: the 1 accommodates the constant term
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '60'
  prefs: []
  type: TYPE_NORMAL
- en: predy[i] <- betahat %*% c(1,xmat[i,])
  prefs: []
  type: TYPE_NORMAL
- en: '61'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '62'
  prefs: []
  type: TYPE_NORMAL
- en: return(predy)
  prefs: []
  type: TYPE_NORMAL
- en: '63'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '64'
  prefs: []
  type: TYPE_NORMAL
- en: '65'
  prefs: []
  type: TYPE_NORMAL
- en: polynomial function of x, coefficients cfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '66'
  prefs: []
  type: TYPE_NORMAL
- en: poly <- function(x,cfs) {
  prefs: []
  type: TYPE_NORMAL
- en: '67'
  prefs: []
  type: TYPE_NORMAL
- en: val <- cfs[1]
  prefs: []
  type: TYPE_NORMAL
- en: '68'
  prefs: []
  type: TYPE_NORMAL
- en: prod <- 1
  prefs: []
  type: TYPE_NORMAL
- en: '69'
  prefs: []
  type: TYPE_NORMAL
- en: dg <- length(cfs) - 1
  prefs: []
  type: TYPE_NORMAL
- en: '70'
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1:dg) {
  prefs: []
  type: TYPE_NORMAL
- en: '71'
  prefs: []
  type: TYPE_NORMAL
- en: prod <- prod * x
  prefs: []
  type: TYPE_NORMAL
- en: '72'
  prefs: []
  type: TYPE_NORMAL
- en: val <- val + cfs[i+1] * prod
  prefs: []
  type: TYPE_NORMAL
- en: '73'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '74'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, "polyreg" consists of polyfit(), the constructor function, and
    print.polyreg(), a print function tailored to this class. It also contains several
    utility functions to evaluate powers and polynomials and to perform cross-validation.
    (Note that in some cases here, efficiency has been sacrificed for clarity.)
  prefs: []
  type: TYPE_NORMAL
- en: As an example of using the class, we’ll generate some artificial data and create
    an object of class "polyreg" from it, printing out the results.
  prefs: []
  type: TYPE_NORMAL
- en: n <- 60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: x <- (1:n)/n
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y <- vector(length=n)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for (i in 1:n) y[i] <- sin((3*pi/2)*x[i]) + x[i]^2 + rnorm(1,mean=0,sd=0.5)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: dg <- 15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (lmo <- polyfit(y,x,dg))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: mean squared prediction errors, by degree
  prefs: []
  type: TYPE_NORMAL
- en: MSPE
  prefs: []
  type: TYPE_NORMAL
- en: '[1,] 0.4200127'
  prefs: []
  type: TYPE_NORMAL
- en: '[2,] 0.3212241'
  prefs: []
  type: TYPE_NORMAL
- en: '[3,] 0.2977433'
  prefs: []
  type: TYPE_NORMAL
- en: '[4,] 0.2998716'
  prefs: []
  type: TYPE_NORMAL
- en: '[5,] 0.3102032'
  prefs: []
  type: TYPE_NORMAL
- en: '[6,] 0.3247325'
  prefs: []
  type: TYPE_NORMAL
- en: '[7,] 0.3120066'
  prefs: []
  type: TYPE_NORMAL
- en: '[8,] 0.3246087'
  prefs: []
  type: TYPE_NORMAL
- en: '[9,] 0.3463628'
  prefs: []
  type: TYPE_NORMAL
- en: '[10,] 0.4502341'
  prefs: []
  type: TYPE_NORMAL
- en: '[11,] 0.6089814'
  prefs: []
  type: TYPE_NORMAL
- en: '[12,] 0.4499055'
  prefs: []
  type: TYPE_NORMAL
- en: '[13,]'
  prefs: []
  type: TYPE_NORMAL
- en: NA
  prefs: []
  type: TYPE_NORMAL
- en: '[14,]'
  prefs: []
  type: TYPE_NORMAL
- en: NA
  prefs: []
  type: TYPE_NORMAL
- en: '[15,]'
  prefs: []
  type: TYPE_NORMAL
- en: NA
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs: []
  type: TYPE_NORMAL
- en: '**221**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note first that we used a common R trick in this command:'
  prefs: []
  type: TYPE_NORMAL
- en: (lmo <- polyfit(y,x,dg))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By surrounding the entire assignment statement in parentheses, we get the printout
    and form lmo at the same time, in case we need the latter for other things.
  prefs: []
  type: TYPE_NORMAL
- en: The function polyfit() fits polynomial models up through a specified degree,
    in this case 15, calculating the cross-validated mean squared prediction error
    for each model. The last few values in the output were NA, because roundoff error
    considerations led R to refuse to fit polynomials of degrees that high.
  prefs: []
  type: TYPE_NORMAL
- en: So, how is it all done? The main work is handled by the function
  prefs: []
  type: TYPE_NORMAL
- en: polyfit(), which creates an object of class "polyreg". That object consists
    mainly of the objects returned by the R regression fitter lm() for each degree.
  prefs: []
  type: TYPE_NORMAL
- en: 'In forming those objects, note line 14:'
  prefs: []
  type: TYPE_NORMAL
- en: lmo$fitted.cvvalues <- lvoneout(y,pwrs[,1:i,drop=F])
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, lmo is an object returned by lm(), but we are adding an extra component
    to it: fitted.cvvalues. Since we can add a new component to a list at any time,
    and since S3 classes are lists, this is possible.'
  prefs: []
  type: TYPE_NORMAL
- en: We also have a method for the generic function print(), print.polyreg() in line
    24\. In Section 12.1.5, we will add a method for the plot() generic function,
    plot.polyreg().
  prefs: []
  type: TYPE_NORMAL
- en: 'In computing prediction errors, we used cross-validation, or the leaving-one-out
    method, in a form that predicts each observation from all the others. To implement
    this, we take advantage of R’s use of negative subscripts in line 57:'
  prefs: []
  type: TYPE_NORMAL
- en: lmo <- lm(y[-i] ~ xmat[-i,])
  prefs: []
  type: TYPE_NORMAL
- en: So, we are fitting the model with the *i* th observation deleted from our data
    set.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As mentioned in the comment in the code, we could make a much faster implementation
    by using a matrix-inverse update method, known as the Sherman-Morrison-Woodbury
    formula. For more information, see J. H. Venter and J. L. J. Snyman,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*“A Note on the Generalised Cross-Validation Criterion in Linear Model Selection,”*'
  prefs: []
  type: TYPE_NORMAL
- en: Biometrika *, Vol. 82, no. 1, pp. 215–219\.*
  prefs: []
  type: TYPE_NORMAL
- en: '**9.2 S4 Classes**'
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers feel that S3 does not provide the safety normally associated
    with OOP. For example, consider our earlier employee database **222**
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'example, where our class "employee" had three fields: name, salary, and union.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some possible mishaps:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: We forget to enter the union status.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: We misspell *union* as *onion*.
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: We create an object of some class other than "employee" but accidentally set
    its class attribute to "employee".
  prefs: []
  type: TYPE_NORMAL
- en: In each of these cases, R will not complain. The goal of S4 is to elicit a complaint
    and prevent such accidents.
  prefs: []
  type: TYPE_NORMAL
- en: S4 structures are considerably richer than S3 structures, but here we present
    just the basics. Table 9-1 shows an overview of the differences between the two
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** Basic R Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation**'
  prefs: []
  type: TYPE_NORMAL
- en: '**S3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**S4**'
  prefs: []
  type: TYPE_NORMAL
- en: Define class
  prefs: []
  type: TYPE_NORMAL
- en: Implicit in constructor code
  prefs: []
  type: TYPE_NORMAL
- en: setClass()
  prefs: []
  type: TYPE_NORMAL
- en: Create object
  prefs: []
  type: TYPE_NORMAL
- en: Build list, set class attr
  prefs: []
  type: TYPE_NORMAL
- en: new()
  prefs: []
  type: TYPE_NORMAL
- en: Reference member variable
  prefs: []
  type: TYPE_NORMAL
- en: $
  prefs: []
  type: TYPE_NORMAL
- en: '@'
  prefs: []
  type: TYPE_NORMAL
- en: Implement generic f()
  prefs: []
  type: TYPE_NORMAL
- en: Define f.classname()
  prefs: []
  type: TYPE_NORMAL
- en: setMethod()
  prefs: []
  type: TYPE_NORMAL
- en: Declare generic
  prefs: []
  type: TYPE_NORMAL
- en: UseMethod()
  prefs: []
  type: TYPE_NORMAL
- en: setGeneric()
  prefs: []
  type: TYPE_NORMAL
- en: '***9.2.1 Writing S4 Classes***'
  prefs: []
  type: TYPE_NORMAL
- en: 'You define an S4 class by calling setClass(). Continuing our employee example,
    we could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: setClass("employee",
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: representation(
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: name="character",
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: salary="numeric",
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: union="logical")
  prefs: []
  type: TYPE_NORMAL
- en: + )
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "employee"'
  prefs: []
  type: TYPE_NORMAL
- en: This defines a new class, "employee", with three member variables of the specified
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s create an instance of this class, for Joe, using new(), a built-in
    constructor function for S4 classes:'
  prefs: []
  type: TYPE_NORMAL
- en: joe <- new("employee",name="Joe",salary=55000,union=T)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: joe
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An object of class "employee"
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "name":'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "Joe"'
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs: []
  type: TYPE_NORMAL
- en: '**223**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "salary":'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 55000'
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "union":'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] TRUE'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the member variables are called *slots*, referenced via the @ symbol.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: joe@salary
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 55000'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the slot() function, say, as another way to query Joe’s salary:'
  prefs: []
  type: TYPE_NORMAL
- en: slot(joe,"salary")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] 55000'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can assign components similarly. Let’s give Joe a raise:'
  prefs: []
  type: TYPE_NORMAL
- en: joe@salary <- 65000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: joe
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An object of class "employee"
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "name":'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "Joe"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "salary":'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 65000'
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "union":'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] TRUE'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nah, he deserves a bigger raise that that:'
  prefs: []
  type: TYPE_NORMAL
- en: slot(joe,"salary") <- 88000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: joe
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An object of class "employee"
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "name":'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "Joe"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "salary":'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 88000'
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "union":'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] TRUE'
  prefs: []
  type: TYPE_NORMAL
- en: '**224**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted, an advantage of using S4 is safety. To illustrate this, suppose we
    were to accidentally spell *salary* as *salry*, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: joe@salry <- 48000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Error in checkSlotAssignment(object, name, value) :'
  prefs: []
  type: TYPE_NORMAL
- en: '"salry" is not a slot in class "employee"'
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, in S3 there would be no error message. S3 classes are just lists,
    and you are allowed to add a new component (deliberately or not) at any time.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.2.2 Implementing a Generic Function on an S4 Class***'
  prefs: []
  type: TYPE_NORMAL
- en: To define an implementation of a generic function on an S4 class, use setMethod().
    Let’s do that for our class "employee" here. We’ll implement the show() function,
    which is the S4 analog of S3’s generic "print".
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know, in R, when you type the name of a variable while in interactive
    mode, the value of the variable is printed out:'
  prefs: []
  type: TYPE_NORMAL
- en: joe
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An object of class "employee"
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "name":'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] "Joe"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "salary":'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] 88000'
  prefs: []
  type: TYPE_NORMAL
- en: 'Slot "union":'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] TRUE'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since joe is an S4 object, the action here is that show() is called. In fact,
    we would get the same output by typing this:'
  prefs: []
  type: TYPE_NORMAL
- en: show(joe)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s override that, with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: setMethod("show", "employee",
  prefs: []
  type: TYPE_NORMAL
- en: function(object) {
  prefs: []
  type: TYPE_NORMAL
- en: inorout <- ifelse(object@union,"is","is not") cat(object@name,"has a salary
    of",object@salary,
  prefs: []
  type: TYPE_NORMAL
- en: '"and",inorout, "in the union", "\n")'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: The first argument gives the name of the generic function for which we will
    define a class-specific method, and the second argument gives the class name.
    We then define the new function.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs: []
  type: TYPE_NORMAL
- en: '**225**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: joe
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Joe has a salary of 55000 and is in the union
  prefs: []
  type: TYPE_NORMAL
- en: '**9.3 S3 Versus S4**'
  prefs: []
  type: TYPE_NORMAL
- en: The type of class to use is the subject of some controversy among R programmers.
    In essence, your view here will likely depend on your personal choice of which
    you value more—the convenience of S3 or the safety of S4\.
  prefs: []
  type: TYPE_NORMAL
- en: John Chambers, the creator of the S language and one of the central developers
    of R, recommends S4 over S3 in his book *Software for Data Analysis* (Springer,
    2008). He argues that S4 is needed in order to write “clear and reliable software.”
    On the other hand, he notes that S3 remains quite popular.
  prefs: []
  type: TYPE_NORMAL
- en: Google’s R Style Guide, which you can find at *http://google-styleguide*
  prefs: []
  type: TYPE_NORMAL
- en: '*.googlecode.com/svn/trunk/google-r-style.html*, is interesting in this regard.
    Google comes down squarely on the S3 side, stating “avoid S4 objects and methods
    when possible.” (Of course, it’s also interesting that Google even has an R'
  prefs: []
  type: TYPE_NORMAL
- en: style guide in the first place!)
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A nice, concrete comparison of the two methods is given in Thomas Lumley’s*'
  prefs: []
  type: TYPE_NORMAL
- en: '*“Programmer’s Niche: A Simple Class, in S3 and S4,”* R News *, April 1, 2004,*
    *pp. 33–36\.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**9.4 Managing Your Objects**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a typical R session progresses, you tend to accumulate a large number of
    objects. Various tools are available to manage them. Here, we’ll look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: The ls() function
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: The rm() function
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: The save() function
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: Several functions that tell you more about the structure of an object, such
    as class() and mode()
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: The exists() function
  prefs: []
  type: TYPE_NORMAL
- en: '***9.4.1 Listing Your Objects with the ls() Function***'
  prefs: []
  type: TYPE_NORMAL
- en: The ls() command will list all of your current objects. A useful named argument
    for this function is pattern, which enables *wildcards*. Here, you tell ls() to
    list only the objects whose names include a specified pattern. The following is
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: '**226**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: ls()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "acc"'
  prefs: []
  type: TYPE_NORMAL
- en: '"acc05"'
  prefs: []
  type: TYPE_NORMAL
- en: '"binomci"'
  prefs: []
  type: TYPE_NORMAL
- en: '"cmeans"'
  prefs: []
  type: TYPE_NORMAL
- en: '"divorg"'
  prefs: []
  type: TYPE_NORMAL
- en: '"dv"'
  prefs: []
  type: TYPE_NORMAL
- en: '[7] "fit"'
  prefs: []
  type: TYPE_NORMAL
- en: '"g"'
  prefs: []
  type: TYPE_NORMAL
- en: '"genxc"'
  prefs: []
  type: TYPE_NORMAL
- en: '"genxnt"'
  prefs: []
  type: TYPE_NORMAL
- en: '"j"'
  prefs: []
  type: TYPE_NORMAL
- en: '"lo"'
  prefs: []
  type: TYPE_NORMAL
- en: '[13] "out1"'
  prefs: []
  type: TYPE_NORMAL
- en: '"out1.100" "out1.25"'
  prefs: []
  type: TYPE_NORMAL
- en: '"out1.50"'
  prefs: []
  type: TYPE_NORMAL
- en: '"out1.75"'
  prefs: []
  type: TYPE_NORMAL
- en: '"out2"'
  prefs: []
  type: TYPE_NORMAL
- en: '[19] "out2.100" "out2.25"'
  prefs: []
  type: TYPE_NORMAL
- en: '"out2.50"'
  prefs: []
  type: TYPE_NORMAL
- en: '"out2.75"'
  prefs: []
  type: TYPE_NORMAL
- en: '"par.set"'
  prefs: []
  type: TYPE_NORMAL
- en: '"prpdf"'
  prefs: []
  type: TYPE_NORMAL
- en: '[25] "ratbootci" "simonn"'
  prefs: []
  type: TYPE_NORMAL
- en: '"vecprod"'
  prefs: []
  type: TYPE_NORMAL
- en: '"x"'
  prefs: []
  type: TYPE_NORMAL
- en: '"zout"'
  prefs: []
  type: TYPE_NORMAL
- en: '"zout.100"'
  prefs: []
  type: TYPE_NORMAL
- en: '[31] "zout.125" "zout3"'
  prefs: []
  type: TYPE_NORMAL
- en: '"zout5"'
  prefs: []
  type: TYPE_NORMAL
- en: '"zout.50"'
  prefs: []
  type: TYPE_NORMAL
- en: '"zout.75"'
  prefs: []
  type: TYPE_NORMAL
- en: ls(pattern="ut")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "out1"'
  prefs: []
  type: TYPE_NORMAL
- en: '"out1.100" "out1.25" "out1.50" "out1.75" "out2"'
  prefs: []
  type: TYPE_NORMAL
- en: '[7] "out2.100" "out2.25" "out2.50" "out2.75" "zout"'
  prefs: []
  type: TYPE_NORMAL
- en: '"zout.100"'
  prefs: []
  type: TYPE_NORMAL
- en: '[13] "zout.125" "zout3"'
  prefs: []
  type: TYPE_NORMAL
- en: '"zout5"'
  prefs: []
  type: TYPE_NORMAL
- en: '"zout.50" "zout.75"'
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, we asked for a list of all objects whose names include the
    string "ut".
  prefs: []
  type: TYPE_NORMAL
- en: '***9.4.2 Removing Specific Objects with the rm() Function***'
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove objects you no longer need, use rm(). Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: rm(a,b,x,y,z,uuu)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This code removes the six specified objects (a, b, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the named arguments of rm() is list, which makes it easier to remove
    multiple objects. This code assigns all of our objects to list, thus removing
    everything:'
  prefs: []
  type: TYPE_NORMAL
- en: rm(list = ls())
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using ls()’s pattern argument, this tool becomes even more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: ls()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "doexpt"'
  prefs: []
  type: TYPE_NORMAL
- en: '"notebookline"'
  prefs: []
  type: TYPE_NORMAL
- en: '"nreps"'
  prefs: []
  type: TYPE_NORMAL
- en: '"numcorrectcis"'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] "numnotebooklines" "numrules"'
  prefs: []
  type: TYPE_NORMAL
- en: '"observationpt"'
  prefs: []
  type: TYPE_NORMAL
- en: '"prop"'
  prefs: []
  type: TYPE_NORMAL
- en: '[9] "r"'
  prefs: []
  type: TYPE_NORMAL
- en: '"rad"'
  prefs: []
  type: TYPE_NORMAL
- en: '"radius"'
  prefs: []
  type: TYPE_NORMAL
- en: '"rep"'
  prefs: []
  type: TYPE_NORMAL
- en: '[13] "s"'
  prefs: []
  type: TYPE_NORMAL
- en: '"s2"'
  prefs: []
  type: TYPE_NORMAL
- en: '"sim"'
  prefs: []
  type: TYPE_NORMAL
- en: '"waits"'
  prefs: []
  type: TYPE_NORMAL
- en: '[17] "wbar"'
  prefs: []
  type: TYPE_NORMAL
- en: '"x"'
  prefs: []
  type: TYPE_NORMAL
- en: '"y"'
  prefs: []
  type: TYPE_NORMAL
- en: '"z"'
  prefs: []
  type: TYPE_NORMAL
- en: ls(pattern="notebook")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "notebookline"'
  prefs: []
  type: TYPE_NORMAL
- en: '"numnotebooklines"'
  prefs: []
  type: TYPE_NORMAL
- en: rm(list=ls(pattern="notebook"))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ls()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "doexpt"'
  prefs: []
  type: TYPE_NORMAL
- en: '"nreps"'
  prefs: []
  type: TYPE_NORMAL
- en: '"numcorrectcis" "numrules"'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] "observationpt" "prop"'
  prefs: []
  type: TYPE_NORMAL
- en: '"r"'
  prefs: []
  type: TYPE_NORMAL
- en: '"rad"'
  prefs: []
  type: TYPE_NORMAL
- en: '[9] "radius"'
  prefs: []
  type: TYPE_NORMAL
- en: '"rep"'
  prefs: []
  type: TYPE_NORMAL
- en: '"s"'
  prefs: []
  type: TYPE_NORMAL
- en: '"s2"'
  prefs: []
  type: TYPE_NORMAL
- en: '[13] "sim"'
  prefs: []
  type: TYPE_NORMAL
- en: '"waits"'
  prefs: []
  type: TYPE_NORMAL
- en: '"wbar"'
  prefs: []
  type: TYPE_NORMAL
- en: '"x"'
  prefs: []
  type: TYPE_NORMAL
- en: '[17] "y"'
  prefs: []
  type: TYPE_NORMAL
- en: '"z"'
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs: []
  type: TYPE_NORMAL
- en: '**227**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we found two objects whose names include the string "notebook"
  prefs: []
  type: TYPE_NORMAL
- en: and then asked to remove them, which was confirmed by the second call to ls().
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You may find the function browseEnv() helpful. It will show in your web browser
    your* *globals (or objects in a different specified environment), with some details
    on each.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***9.4.3 Saving a Collection of Objects with the save() Function***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling save() on a collection of objects will write them to disk for later
    retrieval by load(). Here’s a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: z <- rnorm(100000)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: hz <- hist(z)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: save(hz,"hzfile")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ls()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "hz" "z"'
  prefs: []
  type: TYPE_NORMAL
- en: rm(hz)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ls()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "z"'
  prefs: []
  type: TYPE_NORMAL
- en: load("hzfile")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ls()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "hz" "z"'
  prefs: []
  type: TYPE_NORMAL
- en: 'plot(hz) # graph window pops up'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here, we generate some data and then draw a histogram of it. But
  prefs: []
  type: TYPE_NORMAL
- en: we also save the output of hist() in a variable, hz. That variable is an object
    (of class "histogram", of course). Anticipating that we will want to reuse this
    object in a later R session, we use the save() function to save the object to
    the file *hzfile*. It can be reloaded in that future session via load(). To demonstrate
    this, we deliberately removed the hz object, then called load() to reload it,
    and then called ls() to show that it had indeed been reloaded.
  prefs: []
  type: TYPE_NORMAL
- en: I once needed to read in a very large data file, each record of which required
    processing. I then used save() to keep the R object version of the processed file
    for future R sessions.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.4.4 “What Is This?”***'
  prefs: []
  type: TYPE_NORMAL
- en: Developers often need to know the exact structure of the object returned by
    a library function. If the documentation does not give sufficient details, what
    can we do?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following R functions may be helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: class(), mode()
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: names(), attributes()
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: unclass(), str()
  prefs: []
  type: TYPE_NORMAL
- en: •
  prefs: []
  type: TYPE_NORMAL
- en: edit()
  prefs: []
  type: TYPE_NORMAL
- en: '**228**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go through an example. R includes facilities for constructing *contingency
    tables*, which we discussed in Section 6.4\. An example in that section involved
    an election survey in which five respondents are asked whether they intend to
    vote for candidate X and whether they voted for X in the last election. Here is
    the resulting table:'
  prefs: []
  type: TYPE_NORMAL
- en: cttab <- table(ct)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: cttab
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Voted.for.X.Last.Time
  prefs: []
  type: TYPE_NORMAL
- en: Vote.for.X No Yes
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: Not Sure 0
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, two respondents answered no to both questions.
  prefs: []
  type: TYPE_NORMAL
- en: The object cttab was returned by the function table and thus is likely of class
    "table". A check of the documentation (?table) confirms this. But what is in the
    class?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the structure of that object cttab of class "table".
  prefs: []
  type: TYPE_NORMAL
- en: ctu <- unclass(cttab)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ctu
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Votes.for.X.Last.Time
  prefs: []
  type: TYPE_NORMAL
- en: Vote.for.X No Yes
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: Not Sure 0
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: class(ctu)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] "matrix"'
  prefs: []
  type: TYPE_NORMAL
- en: So, the counts portion of the object is a matrix. (If the data had involved
    three or more questions, rather than just two, this would have been a higher-dimensional
    array.) Note that the names of the dimensions and of the individual rows and columns
    are there, too; they are associated with the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: The unclass() function is quite useful as a first step. If you simply print
    an object, you are at the mercy of the version of print() associated with that
    class, which may in the name of succinctness hide or distort some valuable information.
    Printing the result of calling unclass() allows you to work around this problem,
    though there was no difference in this example. (You saw an instance in which
    it did make a difference in the section about S3
  prefs: []
  type: TYPE_NORMAL
- en: generic functions in Section 9.1.1 earlier.) The function str() serves the same
    purpose, in a more compact manner.
  prefs: []
  type: TYPE_NORMAL
- en: Note, though, applying unclass() to an object still results in an object with
    some basic class. Here, cttab had the class "table", but unclass(cttab) still
    had the class "matrix".
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try looking at the code for table(), the library function that produced
    cttab. We could simply type table, but since this is a somewhat longish Object-Oriented
    Programming
  prefs: []
  type: TYPE_NORMAL
- en: '**229**'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'function, a lot of the function would zoom by on the screen too fast for us
    to absorb it. We could use page() to solve this problem, but I prefer edit():'
  prefs: []
  type: TYPE_NORMAL
- en: edit(table)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This allows you to browse through the code with your text editor. In doing
    so, you’ll find this code at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: y <- array(tabulate(bin, pd), dims, dimnames = dn)
  prefs: []
  type: TYPE_NORMAL
- en: class(y) <- "table"
  prefs: []
  type: TYPE_NORMAL
- en: y
  prefs: []
  type: TYPE_NORMAL
- en: 'Ah, interesting. This shows that table() is, to some extent, a wrapper for
    another function, tabulate(). But what might be more important here is that the
    structure of a "table" object is really pretty simple: It consists of an array
    created from the counts, with the class attribute tacked on. So, it’s essentially
    just an array.'
  prefs: []
  type: TYPE_NORMAL
- en: The function names() shows the components in an object, and attributes() gives
    you this and a bit more, notably the class name.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.4.5 The exists() Function***'
  prefs: []
  type: TYPE_NORMAL
- en: The function exists() returns TRUE or FALSE, depending on whether the argument
    exists. Be sure to put the argument in quotation marks.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code shows that the acc object exists:'
  prefs: []
  type: TYPE_NORMAL
- en: exists("acc")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[1] TRUE'
  prefs: []
  type: TYPE_NORMAL
- en: Why would this function be useful? Don’t we always know whether or
  prefs: []
  type: TYPE_NORMAL
- en: not we’ve created an object and whether it’s still there? Not necessarily. If
    you are writing general-purpose code, say to be made available to the world in
    R’s CRAN code repository, your code may need to check whether a certain object
    exists, and if it doesn’t, then your code must create it. For example, as you
    learned in Section 9.4.3, you can save objects to disk files using save() and
    then later restore them to R’s memory space by calling load().
  prefs: []
  type: TYPE_NORMAL
- en: You might write general-purpose code that makes the latter call if the object
    is not already present, a condition you could check by calling exists().
  prefs: []
  type: TYPE_NORMAL
- en: '**230**'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 22](index-257_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '**10**'
  prefs: []
  type: TYPE_NORMAL
- en: '**INPUT/OUTPUT**'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most underemphasized topics
  prefs: []
  type: TYPE_NORMAL
- en: in many university programming courses
  prefs: []
  type: TYPE_NORMAL
- en: is input/output (I/O). I/O plays a central
  prefs: []
  type: TYPE_NORMAL
- en: role in most real-world applications of comput-
  prefs: []
  type: TYPE_NORMAL
- en: ers. Just consider an ATM cash machine, which uses
  prefs: []
  type: TYPE_NORMAL
- en: multiple I/O operations for both input—reading your
  prefs: []
  type: TYPE_NORMAL
- en: card and reading your typed-in cash request—and
  prefs: []
  type: TYPE_NORMAL
- en: output—printing instructions on the screen, printing
  prefs: []
  type: TYPE_NORMAL
- en: your receipt, and most important, controlling the
  prefs: []
  type: TYPE_NORMAL
- en: machine to output your money!
  prefs: []
  type: TYPE_NORMAL
- en: R is not the tool you would choose for running an ATM, but it features a highly
    versatile array of I/O capabilities, as you will learn in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the basics of access to the keyboard and monitor, and then
    go into considerable detail on reading and writing files, including the navigation
    of file directories. Finally, we discuss R’s facilities for accessing the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1 Accessing the Keyboard and Monitor**'
  prefs: []
  type: TYPE_NORMAL
- en: R provides several functions for accesssing the keyboard and monitor. Here,
    we’ll look at the scan(), readline(), print(), and cat() functions.
  prefs: []
  type: TYPE_NORMAL
- en: '***10.1.1 Using the scan() Function***'
  prefs: []
  type: TYPE_NORMAL
- en: You can use scan() to read in a vector, whether numeric or character, from a
    file or the keyboard. With a little extra work, you can even read in data to form
    a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have files named *z1.txt*, *z2.txt*, *z3.txt*, and *z4.txt*. The
    *z1.txt* file contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '123'
  prefs: []
  type: TYPE_NORMAL
- en: 4 5
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *z2.txt* file contents are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '123'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 5
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *z3.txt* file contains this:'
  prefs: []
  type: TYPE_NORMAL
- en: abc
  prefs: []
  type: TYPE_NORMAL
- en: de f
  prefs: []
  type: TYPE_NORMAL
- en: g
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, the *z4.txt* file has these contents:'
  prefs: []
  type: TYPE_NORMAL
- en: abc
  prefs: []
  type: TYPE_NORMAL
- en: 123 6
  prefs: []
  type: TYPE_NORMAL
- en: y
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what we can do with these files using the scan() function.
  prefs: []
  type: TYPE_NORMAL
- en: scan("z1.txt")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Read 4 items
  prefs: []
  type: TYPE_NORMAL
