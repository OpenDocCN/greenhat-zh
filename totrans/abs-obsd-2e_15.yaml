- en: Chapter 15. System Maintenance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*When hardware complains,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*OpenBSD listens.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*You should listen too.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) No computer runs itself.
    If it did, you would be out of a job. Even the best-configured server generates
    a constant low burn of maintenance needs.'
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD includes a variety of tools to make maintenance easier, to alert you
    when maintenance is needed, and to tell you about the system’s status. Every day,
    week, and month, OpenBSD performs maintenance tasks and notifies you of the results.
    OpenBSD takes daily backups of critical system features and files, and uses them
    to monitor system integrity. It can manage its own log files, keep its own time,
    and alert you when the hardware is failing.
  prefs: []
  type: TYPE_NORMAL
- en: All of this starts with scheduled maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduled Tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenBSD includes scheduled tasks that run once a day, week, and month. These
    jobs run as root and email the results to root. The daily maintenance script is
    the most complicated; the monthly script is the simplest.
  prefs: []
  type: TYPE_NORMAL
- en: If a server runs well, I might not log in to it for weeks or even months. In
    fact, I’ve had a few servers run for more than a year without a human being ever
    logging in to it. I read the daily reports from the machine and say “Yep, it’s
    okay,” and get on with my day, confident that what the regular status reports
    don’t tell me the monitoring system will.
  prefs: []
  type: TYPE_NORMAL
- en: The scheduled maintenance jobs email their results to the local root user, but
    if no one ever logs in to the machine, no one will see those results. Always set
    an email alias for root in */etc/aliases*, so that these messages go to someone
    who will actually read them.
  prefs: []
  type: TYPE_NORMAL
- en: Reading every email message from every machine every day is annoying, but much
    less annoying than finding out that I have a bad service by a user telling me
    about it. These messages often alert me to system problems before anyone (including
    me) notices them. Sites with hundreds of machines often write scripts to parse
    incoming email messages and flag interesting details.
  prefs: []
  type: TYPE_NORMAL
- en: You should send maintenance email to the person ultimately responsible for the
    system—whoever is most interested in system changes and most likely to be aware
    of any day-to-day system changes. If you delegate the job of reading maintenance
    email to a minion who is less aware of the system, he will either annoy you with
    endless questions about what you did yesterday or learn to ignore anything actually
    in the status mail messages.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ll take a look at how the daily, weekly, and monthly routines work.
    Complete documentation of the maintenance jobs appears in `daily(8)`.
  prefs: []
  type: TYPE_NORMAL
- en: Daily Maintenance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The daily maintenance job starts by running any custom maintenance jobs (covered
    at the end of this section) from */etc/daily.local*. Daily maintenance includes
    checking partitions, running the reminder service `calendar(1)`, running `rdist(1)`,
    removing scratch files, and a few other boring things.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenBSD can also do a few other interesting things as part of its daily maintenance:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a backup root filesystem, */altroot*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform system security checks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Back up vital system files in */var/backup*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check for changes in vital system files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check filesystem integrity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `rdist(1)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I discussed */altroot* in [Chapter 9](ch09.html "Chapter 9. More Filesystems")
    because it requires a dedicated filesystem partition. Each of the other tasks
    can be configured later.
  prefs: []
  type: TYPE_NORMAL
- en: Security Checks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some things that go wrong don’t necessarily mean your system has experienced
    an intrusion, but are nonetheless suspicious. The daily security check looks for
    a whole slew of misconfigurations and problems that arise from either malice or
    incompetence. You can read the list of checks in `security(8)`, but they break
    down into fairly broad categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Device node changes and privileges
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: New device nodes, changed permissions on device nodes, new software packages,
    and new or altered disks or partitions might indicate malicious activity or might
    just be normal system management. The security script flags all of these. If you
    made such changes, you’ll nod and go on with your day. If you requested a minion
    perform the change and the change doesn’t appear, this is when you ask them what
    they did all day yesterday. If you didn’t make a change that appears, you want
    to know about it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Insecure NFS exports
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: OpenBSD includes a lot of software to export filesystems and run commands remotely.
    These services, like printing and NFS, should not allow access from any host just
    anywhere, but only from hosts you approve. The security job checks for configurations
    that permit global access.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Misconfigured accounts
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Another popular attack route has been the password database and related files.
    Accounts without passwords, duplicate entries, improperly closed accounts, and
    so on could all be used to compromise a system. The script checks for these issues.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Permissions
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Poor permissions can lead to privilege escalation. For example, is there a new
    `setuid` or `setgid` file on the system? If so, the security script notifies you.
    If you installed that file with those privileges, you’re okay. If it’s unexpected,
    you should investigate.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: User environment
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you can change a user’s environment, whether that’s root or another account,
    you can trick him into giving away his authentication credentials or running suspect
    commands. If an intruder can edit a user’s dotfiles, like *.cshrc* or *.login*,
    he can change which versions of a command he runs. Perhaps his shell is set to
    run a program that asks the user for his password and sends it to the intruder’s
    anonymous email account. By having correct permissions on home directories, dotfiles,
    mail files, and so on, you make this class of attack more difficult. The security
    script verifies that permissions are set up correctly.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that the security check is *not* an intrusion-detection system. The changes
    it checks for are the sort that script kiddies and newbie intruders are most likely
    to make, but skilled intruders familiar with OpenBSD could get around it. They
    could even replace the security check with a shell script that sends a daily email
    message that looks like an innocuous security check.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, competent intruders are relatively rare. Just keep in mind that
    receiving a security check with no mention of problems is encouraging, but it’s
    not proof that your server is secure.
  prefs: []
  type: TYPE_NORMAL
- en: Vital File Backup and Testing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The daily security check tests for changes in the files listed in */etc/changelist*
    and rotates their backups, since these files are generally critical system files,
    such as */etc/master.passwd*, */etc/boot.conf*, and */var/cron/tabs/root*. It
    also checks for changes to disk partitioning and mounted filesystems, as well
    as changes to device nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look in */var/backups*, and you’ll see files like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The files ending in *.current* are copies of these files as they existed when
    the daily maintenance job was last run. The files ending in *.backup* are the
    previous version of those files.
  prefs: []
  type: TYPE_NORMAL
- en: The first time the security script runs, it copies all of these files to */var/backup*.
    Following that initial setup, the security script checks the original file against
    the current copy for changes. If the file changes, the previous version of the
    file is copied to the *.backup* filename, and the new version is copied to the
    *.current* file.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the list shows that I edited my */etc/fstab* at some
    time, prompting the security script to move its copy of the old filesystem table
    to a *.backup* file. I have never edited */etc/ftpchroot* or */etc/ftpusers*,
    so there is no *.backup* version of these files, but only the *.current* one.
  prefs: []
  type: TYPE_NORMAL
- en: The security script doesn’t copy all of the files that it watches. For example,
    files containing private keys or that might contain private keys are not copied,
    but the security script does take a checksum. (Files monitored by checksum have
    a plus sign before their name in */etc/changelist*.) There’s no reason to manually
    edit */etc/ssh/ssh_host_ecdsa_key*, and if the file changes, either you know why
    or you need to restore from a trusted backup.
  prefs: []
  type: TYPE_NORMAL
- en: '*/etc/changelist* is itself listed in */etc/changelist*. This seems recursive,
    but the system backs up the list of files you want backed up, and also notifies
    you when someone adds or removes a file in */etc/changelist*.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Vital Files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can add files to the change list and even use wildcards to back up all the
    files in a directory. But note that if you did use wildcards in */etc/changelist*,
    you won’t be notified when a file is removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example of using wildcards. In [Chapter 13](ch13.html "Chapter 13. Software
    Management"), I added the `apache2` port to one of my machines. I put the configuration
    files in */etc/apache2*. I could add a line like this to the change list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This would automatically copy all files in the *apache2* configuration directory
    to */var/backup* and test them for changes. However, I would not be notified when
    files are removed from this directory. If you’re using a configuration mechanism
    that says, “include all the *.conf* files in such-and-such directory,” this might
    not be desirable. A better option would be to list each file individually and
    update the list when you add critical files.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most convenient things about the file-integrity check is that it
    automatically creates a local backup of critical system files. That means that
    if you decide to learn how to use `vipw(8)` and utterly trash your user database
    in doing so, you can grab yesterday’s copy out of */var/backups*, install it,
    and no one will be the wiser. The same applies to every other critical system
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem Integrity Checks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can’t run a full-on Unix File System (UFS) check while a system is in multiuser
    mode, but you can have `fsck(8)` perform filesystem integrity checks to try to
    identify problems before they’re serious. Doing so won’t fix any problems, but
    it will notify you that they exist so you can schedule downtime for repairs.
  prefs: []
  type: TYPE_NORMAL
- en: To enable these checks, set `CHECKFILESYSTEMS` to `1` in */etc/daily.local*.
  prefs: []
  type: TYPE_NORMAL
- en: Copying Files with rdist
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `rdist(1)` program is used to copy files to other servers, letting you maintain
    identical copies of critical files on many servers. If you’re interested in using
    it, see `rdistd(8)`.
  prefs: []
  type: TYPE_NORMAL
- en: Silencing /etc/daily
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some of us have monitoring systems that track a server’s disk, network, and
    other basic information. If you don’t need this sort of information to appear
    in your daily status mail, set `VERBOSESTATUS` to `0` in */etc/daily.local*. This
    turns off these parts of daily maintenance, reducing the amount you need to read.
  prefs: []
  type: TYPE_NORMAL
- en: If the remaining daily maintenance doesn’t generate any output, the server should
    not send a status email that day. In environments where you don’t trust the monitoring
    system, you could use the daily status messages to assure you that the system
    is running as expected. OpenBSD gives you the choice.
  prefs: []
  type: TYPE_NORMAL
- en: Weekly Maintenance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The weekly script is simpler than the daily script with only three common functions:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it runs the custom weekly script */etc/weekly.local*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, it updates the `locate(1)` database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it rebuilds the `whatis(1)` man page database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monthly Maintenance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenBSD doesn’t need any generic monthly maintenance, but for consistency, the
    */etc/monthly* script runs the custom script */etc/monthly.local*.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Maintenance Scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each maintenance script runs a custom script before performing any other tasks.
    You can put any tasks you need in */etc/daily.local*, */etc/weekly.local*, and
    */etc/monthly.local*. These commands are run by root, so don’t use them for tasks
    that should be performed by another user. If your database needs to be backed
    up, create a separate script, and have the unprivileged user running your database
    run that script via `cron(8)`.
  prefs: []
  type: TYPE_NORMAL
- en: Some sites use the scheduled maintenance jobs to run complex software that perform
    site-specific duties. For example, I know of one security firm that collects data
    from hundreds of machines, and uses the daily jobs to send that data to a central
    management system. Really, you can use the local scripts any way you choose.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a maintenance task that can run under another user account, but
    you want to attach it to the scheduled maintenance jobs, you can have the local
    script call another script. Start that script by using `su(1)` to switch users
    and drop privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Custom maintenance scripts may be most useful for altering the way the standard
    maintenance scripts perform their work. For example, say you have a system with
    many scratch directories containing temporary files. The weekly maintenance script
    updates the locate database, but you don’t want these scratch files included in
    locate results. You could use a custom maintenance script to remove all the scratch
    files immediately before */etc/weekly* creates the new locate database, and schedule
    this as a separate task. By adding it to */etc/weekly.local*, you would know that
    it will finish before */etc/weekly* runs any other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: System Logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The system log used by Unix-like operating systems has become the industry standard
    for logging, but that’s not necessarily a good thing, because the log mechanism
    can be cantankerous. Once you properly configure log collection and rotation,
    however, OpenBSD’s logging system mostly manages itself.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD uses the standard logging system for Unix-like (and many embedded) systems,
    `syslog(3)`. The syslog protocol marks messages with a facility and a priority,
    and hands those messages to a daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Any program can write to the local `syslogd(8)` server, but the key in log management
    is deciding how those messages are sorted and stored. OpenBSD’s `syslogd` can
    sort messages based on facility, priority, and source program.
  prefs: []
  type: TYPE_NORMAL
- en: Facilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *facility* indicates the source of a message. In most cases, each program
    that needs a separate log file uses a different facility. Many programs or protocols,
    such as FTP, have facilities dedicated to them. The syslog protocol also has a
    variety of generic facilities that you can use as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 15-1](ch15.html#standard_openbsd_facilities "Table 15-1. Table 15-1:
    Standard OpenBSD Facilities") lists the standard facilities and provides some
    notes on their usage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15-1. Table 15-1: Standard OpenBSD Facilities'
  prefs: []
  type: TYPE_NORMAL
- en: '| Facility | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `auth` | Public information about authentication, such as when someone logged
    on or when someone uses `su`. |'
  prefs: []
  type: TYPE_TB
- en: '| `authpriv` | Private information about user authentication, normally accessible
    only to privileged users. |'
  prefs: []
  type: TYPE_TB
- en: '| `cron` | Messages from the system scheduler `cron(8)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `daemon` | A catchall for processes that neither need nor require a dedicated
    facility. |'
  prefs: []
  type: TYPE_TB
- en: '| `ftp` | Messages from FTP and Trivial File Transfer Protocol (TFTP) servers.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `kern` | Kernel-generated messages. |'
  prefs: []
  type: TYPE_TB
- en: '| `local0` through `local7` | These facilities are provided for the sysadmin.
    Many programs let sysadmins configure their facility. Use these eight facilities
    for such programs. |'
  prefs: []
  type: TYPE_TB
- en: '| `lpr` | Messages from the printing system. |'
  prefs: []
  type: TYPE_TB
- en: '| `mail` | Messages from mail servers. |'
  prefs: []
  type: TYPE_TB
- en: '| `mark` | This special facility writes a message every 20 minutes. |'
  prefs: []
  type: TYPE_TB
- en: '| `news` | Messages from Usenet news servers. |'
  prefs: []
  type: TYPE_TB
- en: '| `syslog` | Messages from the syslog server itself. |'
  prefs: []
  type: TYPE_TB
- en: '| `user` | The catchall message facility. If a userland program doesn’t specify
    a logging facility, the messages wind up here. |'
  prefs: []
  type: TYPE_TB
- en: '| `uucp` | Messages from the Unix-to-Unix Copy Protocol (UUCP) servers. You
    will probably never encounter this pre-Internet email protocol. |'
  prefs: []
  type: TYPE_TB
- en: While most programs have sensible defaults, it’s your job as the system administrator
    to manage which programs log to which facilities. If possible, use the local facilities
    for your server-specific daemons. While it’s entirely possible to use facilities
    for purposes other than originally intended, try not to reassign the `uucp` facility
    to some other daemon unless you really have no other option.
  prefs: []
  type: TYPE_NORMAL
- en: Priority
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A log message’s priority represents its importance. Programs usually send their
    logging data to `syslogd`, but `syslogd` decides what to retain and what to discard.
    You get to decide how much detail you want in your logs. Use the following nine
    `syslog` levels to decide what to record and what to discard (in order from most
    to least important):'
  prefs: []
  type: TYPE_NORMAL
- en: '****`emerg`****. System emergency. This message appears on every active terminal.
    The computer might be crashing, or it may have some other error that requires
    immediate attention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`alert`****. An emergency. The system can continue to function, but attend
    to this error very soon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`critical`****. Critical problems. These indicate serious errors, such
    as hard-drive failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`err`****. Errors. These are in regard to problems that require attention
    but won’t destroy your system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`warning`****. Miscellaneous warnings. These could be attended to, but
    will not prevent the process that generated them from running normally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`notice`****. Important information, such as daemon startup and shutdown
    notifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`info`****. Basic information. This usually includes transactional data,
    such as individual messages in a mail server or individual queries to a web server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`debug`****. Trivia. This level is usually of interest only to programmers,
    but occasionally useful to sysadmins trying to figure out why a program is behaving
    in a certain way. Debugging logs can contain anything, including information that
    violates user privacy, such as plaintext passwords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`none`****. Don’t log anything from this facility here. This is most commonly
    used to exclude information from log files, as discussed shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By combining levels with priority, you can sort log messages into individual
    files or other targets.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting Messages via syslogd(8)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`syslogd` compares received messages to entries in */etc/syslog.conf*. This
    file has two columns: the first (the *selector*) describes a type of log message,
    and the second (the *action*) tells `syslogd` what to do when a message matches
    the description. Neither column can have whitespace; whitespace can appear only
    between the columns. For example, here’s a line from the default *syslog.conf*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Any log message that has a facility of daemon and a priority of `info` or higher
    is appended to the file */var/log/daemon*. Of course, if all logs were so easily
    managed, this would be a short section.
  prefs: []
  type: TYPE_NORMAL
- en: '`syslogd` compares all log messages to all *syslog.conf* entries. If a log
    message matches multiple selectors, it is sent to all matching destinations.'
  prefs: []
  type: TYPE_NORMAL
- en: Wildcards
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use wildcards in either the facility or priority. For example, this
    line logs every message from the mail facility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To capture messages of a given priority or higher from all facilities, use
    an asterisk (`*`). Here’s how to send all priority `err` and higher messages to
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can also use a double-wildcard to send all log messages to one place.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Logging everything to one location isn’t terribly useful or wise. You should
    *not* send `authpriv` debugging to a world-readable file.
  prefs: []
  type: TYPE_NORMAL
- en: Excluding Information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use the `none` level to exclude information from a log. For example, the following
    line excludes private authentication information from an otherwise all-inclusive
    log.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The semicolon (`;`) allows you to combine selection criteria on a single line.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you combine entries with a semicolon like this, do not put whitespace after
    the semicolon. The only whitespace can appear between the selector and the destination.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Facilities
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can combine multiple facilities in a single entry by using commas. Here’s
    how to capture all messages of `info` priority or higher from several facilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Any log message from the `auth`, `daemon`, `syslog`, and `user` facilities,
    and of priority `info` or higher, is sent across the network to the host `loghost`.
  prefs: []
  type: TYPE_NORMAL
- en: Marking Time
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While all log messages have a timestamp, you might want a marker in a log file
    to indicate that time has passed. The special facility `mark` creates a message
    every 20 minutes, letting you add an extra timestamp to a file. Here’s how to
    add a timestamp to the mail log every 20 minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Local Facilities
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The eight facilities `local0` through `local7` are for your use. Many programs
    can be configured to use a specific facility, so you can aim them at a particular
    file. I’ve configured a daemon to use the facility `local7`. Here, I send messages
    from that facility to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Some programs have a hard-coded preference for a specific facility. For example,
    the flow-tools package (see my book *Network Flow Analysis*, No Starch Press,
    2010) has facility `local6` hard-wired into the code. Don’t be shocked when you
    see something like this. Fortunately, OpenBSD’s `syslogd` can filter based on
    program name, so you can easily filter your logs despite this sort of daftness.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting by Program Name
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’re out of facilities, you can use the name of the program generating
    the syslog messages as a selector. Using a program name requires two lines: The
    first contains the program name with a leading exclamation mark, and the second
    sets up logging. OpenBSD offers the following example of `sudo(8)` logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: All log messages from `sudo` go to the specified log file.
  prefs: []
  type: TYPE_NORMAL
- en: You can also select by program name and stop all subsequent selections of matching
    messages by using two exclamation points (`!!`) before the program name. This
    example sends all messages from `sudo` to */var/log/sudo*, but prevents `sudo`
    messages from going to any other log.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `!*` after the end of the `sudo` entry is a way to say “all programs”—in
    other words, don’t sort by program name anymore. You need this only if you use
    the double-exclamation-point “stop processing matching messages here” syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Log Actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know how to sort your log messages into different buckets, let’s
    see how to take different actions with those messages. Messages can be written
    to a file, piped to a program, sent to another host, or written to users.
  prefs: []
  type: TYPE_NORMAL
- en: Logging to Files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most of our examples so far send log messages to a file, giving the full path
    to the file as the action. Here’s how to send all of the messages from facility
    `local6` to a log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can also send the messages to a device by giving the full path to the device
    node, but this will make sense to very few devices, such as the console. This
    is because writing the log message to the disk device */dev/wd0d* will not store
    the message on disk.
  prefs: []
  type: TYPE_NORMAL
- en: Logging to a Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To send selected logs to a program, use a pipe (`|`) and the full path to the
    program, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The logging system should start the destination program, and then feed log messages
    into the program’s standard input.
  prefs: []
  type: TYPE_NORMAL
- en: Notifying Users
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also direct log messages to logged-in users by listing multiple users
    in a comma-separated list. For example, to send a message to all users, use an
    asterisk.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This example will notify all logged-in users of real emergencies, but deeply
    annoy `lasnyder`.^([[41](#ftn.id367882)])
  prefs: []
  type: TYPE_NORMAL
- en: Logging to a Remote Host
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I usually have a logging host that collects log messages from everywhere—not
    only from my OpenBSD boxes, but from all my other Unix-like systems, as well as
    routers, switches, and anything else that speaks syslog. This reduces my maintenance
    needs and conserves disk space. And, since, every log message includes a hostname,
    I can easily sort them out later.
  prefs: []
  type: TYPE_NORMAL
- en: To send messages to another host, use the `@` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This dumps everything of priority `info` and above to my logging host.
  prefs: []
  type: TYPE_NORMAL
- en: Your logging host must accept syslog messages from the network. If your host
    is an OpenBSD machine, run `syslogd` with the `-u` flag. And be sure to protect
    your log host with a packet filter, so random hosts can’t write logs to it and
    fill up your disks.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing syslogd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenBSD runs `syslogd` by default, and you can customize how `syslogd` behaves.
    Common customizations include adding more log sockets and listening to the network.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Extra Log Sockets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Programs write log messages to the socket */dev/log*, but software inside a
    `chroot` won’t be able to access that device. To have a program that’s locked
    inside a `chroot` send messages to `syslogd`, you must put an additional log socket
    at */dev/log* inside the `chroot`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, since the integrated BIND DNS server is `chroot`ed into */var/named*,
    the DNS server expects to find the log socket at */dev/log*, which means that
    the new log socket should be at */var/named/dev/log*. To create this log socket,
    use `syslogd`’s `-a` option, and give the full path to the log socket in */etc/rc.conf.local*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can use about 20 additional logging sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to the Network
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want your OpenBSD box to act as a log host, accepting logs from remote
    hosts, use the `-u` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Because the syslog protocol has no access control, anyone with access to port
    514/UDP on the log host can write to your log files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Filling a host’s logs with junk to fill the hard disk is an old attack. Use
    OpenBSD’s packet filtering system (discussed in [Chapter 21](ch21.html "Chapter 21. Packet
    Filtering") and [Chapter 22](ch22.html "Chapter 22. Advanced PF")) to protect
    your logging host.
  prefs: []
  type: TYPE_NORMAL
- en: Syslog and Embedded Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenBSD supports writing log messages to an in-memory buffer, which allows logging
    on systems that have no writable disk, such as diskless systems and embedded routers
    and firewalls. `syslogd` retains these logs in a memory buffer, and clients can
    connect to `syslogd` through a reporting socket and read the logs. As you would
    expect, logs in memory disappear when `syslogd` is shut down.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `syslogd` for reporting, first provide a reporting socket with the `-s`
    option and give it a full path to a reporting socket. Here’s an *rc.conf.local*
    entry for a reporting socket in */var/run/syslog*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To log to the buffer, make a *syslog.conf* action. Specify logging to a buffer
    with a colon (`:`), the number of kilobytes to give the buffer, another colon,
    and the name of the memory buffer. (The maximum buffer size is 256KB.)
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here we capture all log messages of `err` priority or higher and
    write them to the 128KB memory buffer called `errors`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `syslogc(8)` to read a memory buffer, and use the `-s` option to tell `syslogc`
    where to find `syslogd`’s reporting socket, and provide the name of the log buffer.
    Here’s how to read the reporting socket */var/run/syslog* and read the `errors`
    buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you’ve forgotten the name of the buffer you want to read, ask `syslogc` to
    query the list of available memory logs with `-q`. Be sure to provide the reporting
    socket.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if you’re not a programmer, you can still use real syslog features. Logging
    to syslog is available to shell scripts via the `logger(1)` program. See the `logger`
    man page for details.
  prefs: []
  type: TYPE_NORMAL
- en: Log File Maintenance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can capture logs. Fantastic! Now just let the log files grow until they
    fill your hard disk and leave room for nothing else, right? Or you can discard
    old logs and have the system keep the logs to a manageable size. This is called
    *log rotation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the system messages log, */var/log/messages*, and you should see six
    *messages* files: *messages*, *messages.0.gz*, *messages.1.gz*, *messages.2.gz*,
    *messages.3.gz*, and *messages.4.gz*. The plain *messages* file is the current
    log file. The other files are older logs; *messages.0.gz* is the newest, and *messages.4.gz*
    is the oldest.'
  prefs: []
  type: TYPE_NORMAL
- en: When the current log file hits either a certain age or a specific size, log
    rotation discards the oldest log file (*messages.4.gz*), and the second-oldest
    file, *messages.3.gz*, is renamed to *messages.4.gz*; *messages.2.gz* is renamed
    to *messages.3.gz*; and so on. The existing *messages* file is renamed to *messages.0*
    and compressed, and a new *messages* file is created.
  prefs: []
  type: TYPE_NORMAL
- en: The `newsyslog(8)` program rotates log files, restarts daemons, runs commands,
    shuffles old files into other directories, and handles all routine tasks. `root`
    runs `newsyslog` once per hour via `cron(8)`. When `newsyslog` starts, it reads
    */etc/newsyslog.conf* and examines each log file listed. If the conditions for
    rotating the log file are met, the log is rotated and other configured actions
    are taken.
  prefs: []
  type: TYPE_NORMAL
- en: newsyslog.conf Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*newsyslog.conf* uses one line per log file. Each line has seven fields, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: From left to right, the fields are log file, owner, permissions, number of files
    to retain, size, time, and flags. After the flags field, you might see a number
    of optional arguments. We’ll look at each of the fields in order.
  prefs: []
  type: TYPE_NORMAL
- en: Log File
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first entry on each line is the full path to the log file to be processed
    (`/var/log/authlog` in this example). This must exactly match the current log
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Owner
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second field (`root:wheel` in our example) lists the log file’s owner and
    group, separated by a colon. This field is optional, and is not present in many
    of the default entries.
  prefs: []
  type: TYPE_NORMAL
- en: By default, log files are owned by the root user and the `wheel` group, but
    `newsyslog` can change the owner of log files. While changing ownership isn’t
    common, you might want to explicitly declare it for specific files.
  prefs: []
  type: TYPE_NORMAL
- en: You can choose to change only the owner or only the group. In these cases, use
    a colon with a name on only one side of it, such as `:wheel` or `root:`. You must
    always include the colon if you’re changing ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The third field (`640` in our example) gives the rotated file’s permissions
    in standard octal notation, as discussed in `chmod(1)`. This field is optional,
    and it is not present in many default entries.
  prefs: []
  type: TYPE_NORMAL
- en: Count
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The fourth field specifies the number of archived log files that *newsyslog*
    keeps. In our example, */var/log/messages* has the current log file and five archives,
    numbered 0 through 4\. *newsyslog.conf* has a count of `5` for */var/log/messages*.
  prefs: []
  type: TYPE_NORMAL
- en: Size
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The fifth field is a file size in kilobytes. When `newsyslog` runs, it checks
    the size of the log file. If the log is larger than the size given here, `newsyslog`
    rotates the log. If you don’t want the file size to affect when `newsyslog` rotates
    the file, put an asterisk here.
  prefs: []
  type: TYPE_NORMAL
- en: Time
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To rotate the log based on time, use the sixth field, which has four possible
    values: an asterisk, a number, and a time in one of two standard formats. If you
    rotate the log based on size rather than age, put an asterisk here. If you put
    a number here, you are specifying a number of hours after which the log will rotate.
    Our example of */var/log/authlog* rotates every 168 hours.'
  prefs: []
  type: TYPE_NORMAL
- en: The time formats—ISO 8601 restricted and `newsyslog`-specific—are a little more
    complicated.
  prefs: []
  type: TYPE_NORMAL
- en: ISO 8601 restricted
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A time entry beginning with an `@` symbol is in the ISO 8601 restricted time
    format. The ISO 8601 restricted time format is used by `newsyslog` on most Unix-like
    systems, because it was the time format used in MIT’s primordial `newsyslog`.
    The ISO 8601 format is a bit obtuse, but every Unix-like operating system I’m
    aware of supports it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A full date in ISO 8601 format is 14 digits with a `T` in the middle. The first
    four digits are the year, the next two are the month, and the next two are the
    day of the month. (The `T` serves as a sort of decimal point, separating whole
    days from fractions of a day.) The next two digits are hours, the next two are
    minutes, and the last two are seconds. For example, the date September 13, 2013,
    at 3:18 and 58 seconds PM is expressed as `20130913T151858`. (Specifying a specific
    date and time to rotate a log wouldn’t be terribly useful because the log would
    rotate only once.)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can choose to specify only the fields near the `T`, leaving fields farther
    away blank. Again, if you think of the `T` as a decimal point, you don’t need
    to write 5.87 as 005.8700; the leading and trailing zeros are irrelevant.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the case of `newsyslog`, empty fields are wildcards. For example, `4T00`
    matches midnight on the fourth day of every month, and `T23` matches the twenty-third
    hour, or 11 PM, every day. If *newsyslog.conf* lists the time `@T2359`, the log
    rotates at 11:59 PM every day. (Of course, `newsyslog` runs once an hour, so the
    log won’t rotate exactly then.)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As with `cron(8)`, specify time units in detail. For example, `@9T`, the ninth
    day of the month, rotates the log once an hour, every hour, on the ninth day of
    the month, which would mean it rotates the log all day on that day. It would probably
    be better to specify a time of `@9T01`, which would rotate the log at 1 AM on
    the ninth day of the month. You don’t need to specify times any more closely than
    the hour, as `newsyslog` runs only hourly.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: newsyslog times
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because ISO 8601 time doesn’t let you easily specify weekly jobs, and it’s impossible
    to specify the last day of the month, OpenBSD includes a `newsyslog`-specific
    time format that lets you easily specify these common times.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Any entry with a leading dollar sign (`$`) is written in *month week day* format.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This particular format uses three identifiers: *`M`* (day of month), *`W`*
    (day of week), and *`H`* (hour of day). Each identifier is followed by a number
    indicating the unit you’re using. Hours range from `0` to `23`, and days run from
    `0` (Sunday) to `6` (Saturday). Days of the month start at `1` and go to `31`,
    with `L` or `l` representing the last day of the month. For example, to rotate
    a log on the fifth of each month at noon, use `$M5H12`. To start the month-end
    accounting at 11 PM on the last day of the month, use `$MLH23`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you don’t specify an hour, the time defaults to midnight on the chosen day.
    And if a *newsyslog.conf* entry lists both a time and a size for file rotation,
    `newsyslog` rotates the log if either requirement is met.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Flags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The seventh field, which is optional, instructs `newsyslog` on special processing
    for the file itself. OpenBSD uses four flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`Z`****. Compress the file with `gzip(1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`B`****. Do not add a “log file turned over” message to the file (for binary
    files).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`F`****. Follow symlinks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`M`****. A user is monitoring this log.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the `B` and `Z` flags are not, strictly speaking, mutually incompatible,
    most log files need only one of them, and most binary files don’t compress well
    anyway. (The default *newsyslog.conf* compresses the packet filtering log file,
    but that’s something of an oddity.) If you see the `Z` flag with the `M` flag,
    the old log file will be sent to the user before the log is compressed.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring Logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OpenBSD’s `newsyslog` can email logs to a user before rotating them. If you
    carefully control how you sort your logs, this feature can be useful. For example,
    `sudo(8)` logs successful uses at priority `notice`, but failed uses at priority
    `alert`. You might split these into separate log files in *syslog.conf*, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The file */var/log/sudofail* should now contain only `sudo` failures, such as
    users entering incorrect passwords or exceeding their privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Now you could tell `newsyslog` to check for monitored logs by running it with
    the `-m` flag. (`newsyslog` runs as one of root’s cron jobs.)
  prefs: []
  type: TYPE_NORMAL
- en: To have the `sudo` failure log emailed to you every time the log rotates, you
    can put your account in the monitor field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This assumes that email to the account `mwlucas` on this machine reaches me.
    The simplest way to ensure that would be to forward the email in */etc/mail/aliases*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re serious about watching these kinds of failures, monitor logs on a
    logging host that end users cannot access. A user who becomes root on the local
    machine can edit logs before they are emailed and rotated.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a PID File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If `newsyslog` tries to rotate and compress a file, but the process writing
    the file is still writing to the file, the file can become corrupted. Some programs
    need a right proper slapping before they will let go of their log files. How?
    Just list a PID file here, and `newsyslog` will send that process ID a `SIGHUP`
    (like a `kill -1`).
  prefs: []
  type: TYPE_NORMAL
- en: Note that PID files are not a terribly secure way to identify specific processes
    because they are subject to race conditions and other attacks. If the server has
    a command for rotating its logs, that’s probably a wiser choice than signaling
    a process indicated in a PID file.
  prefs: []
  type: TYPE_NORMAL
- en: Signal Name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To send a signal other than `SIGHUP` to a process with a PID file, use a different
    *signal name*. The signal name must begin with `SIG` and be specified by name.
    You can find a full list of signals in `signal(3)`, but the software documentation
    should tell you which signal the process needs to release in order to restart
    its log file. This field is optional, but if you use it, you must enter a full
    path to a PID file immediately before it.
  prefs: []
  type: TYPE_NORMAL
- en: Command to Execute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than signaling a process, you can have `newsyslog` run a command when
    rotating logs by giving the full path to the command in double quotes. While this
    field is optional, it cannot be combined with a PID file. You can use a PID file
    or a command name, but not both.
  prefs: []
  type: TYPE_NORMAL
- en: System Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s no excuse for a system having incorrect time. Once you set the time
    zone, having OpenBSD correct its own clock on an ongoing basis from any number
    of freely available network time servers is easy. Virtual machines in particular
    are notorious for skewing clocks, but time correction works on them as well, so
    as I said, no excuse.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD includes its own NTP client, OpenNTPD, which is written to be safe and
    secure. Before `ntpd(8)` can do anything though, it needs some configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ntpd(8)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenBSD comes with a perfectly acceptable generic `ntpd` configuration that
    uses public time servers. If your host is on the public Internet and you only
    want to set your system time, not provide time to other hosts, use the defaults.
    Otherwise, you must customize */etc/ntpd.conf* by selecting time sources and deciding
    if `ntpd` will accept time requests from other machines.
  prefs: []
  type: TYPE_NORMAL
- en: Time Redundancy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: NTP gets the time by querying remote servers. If you have a single server, that
    time is assumed to be correct. However, if you have multiple time servers, the
    times are not simply averaged. If one time server is wildly off from all of the
    other time servers, the results from that server are discarded, and a median from
    the remainder is selected. If you have only two time servers, and the times obtained
    from them differ, `ntpd` can’t determine which one is correct. To help `ntpd`
    make sensible decisions, always list at least three time servers.
  prefs: []
  type: TYPE_NORMAL
- en: Time Sources
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Choose your time sources with the `server`, `servers`, and `sensor` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: The `server` option tells `ntpd` to get the time from a single server, which
    might have multiple IP addresses. If that’s the case, `ntpd` tries to use the
    first IP address. If the first address doesn’t work, it tries the second, and
    so on, until it gets an answer. Use the `server` option if you have specific time
    servers to use, and be sure to list at least three time servers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `servers` option tells `ntpd` to get the time from multiple hosts that
    share a common hostname. The default *ntpd.conf* includes this entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The host *pool.ntp.org* has four IP addresses, and `ntpd` will try to get time
    from all of those hosts.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a hardware time sensor, you can tell `ntpd` to read time from it.
    Hardware time sensors include `nmea(4)`, `udcf(4)`, and `mbg(4)`. The `sensor`
    option tells `ntpd` to use a hardware sensor. If you’ve invested in a hardware
    time sensor, you might be sufficiently concerned about time to measure the distance
    between the transmitter and the receiver, and adjust the time based on the speed
    of light delay. The `correction` keyword lets you specify a number of microseconds
    that your sensor is behind.
  prefs: []
  type: TYPE_NORMAL
- en: As I wrote this, a 40-millisecond (ms) delay caused a furor in the scientific
    world when researchers thought they might have seen a neutrino go faster than
    light, so we’ll put a 40 ms correction into our time sensor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be warned that OpenBSD is not a real-time operating system. You should not be
    measuring neutrino speed with it anyway!
  prefs: []
  type: TYPE_NORMAL
- en: Serving Time
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I run time servers on only closed networks, where very few hosts have access
    to the public Internet. I would also run time servers if I had hardware time sensors,
    but most of the time, I just use the public time servers.
  prefs: []
  type: TYPE_NORMAL
- en: To have `ntpd` answer time queries from other hosts, use the `listen on` directive.
    You can either specify an IP address or use an asterisk to say “every IP on the
    system.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Because `ntpd` has no access controls, any host that can connect to port 123/UDP
    can get time from this server. If this worries you, use packet filtering (discussed
    in [Chapter 21](ch21.html "Chapter 21. Packet Filtering") and [Chapter 22](ch22.html
    "Chapter 22. Advanced PF")) to limit time checks to hosts on your network. The
    author of OpenNTP served time to his entire company and to the public on a MicroVAX
    3100 with 16MB (yes, that’s an *M*) of RAM without the NTP process using more
    than 5 percent of the processor, so the load imposed by NTP is negligible on modern
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Now that `ntpd` is configured, let’s use it.
  prefs: []
  type: TYPE_NORMAL
- en: Using ntpd(8)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can correct time slowly or do it in one fell swoop. I recommend fully correcting
    time at boot, and then letting `ntpd` slowly adjust the system clock as the system
    runs. This corrects time before anything relies on it, but keeps everything synchronized
    on an ongoing basis.
  prefs: []
  type: TYPE_NORMAL
- en: To correct time when starting `ntpd`, use the `-s` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You’ll get a command prompt back once `ntpd` receives a response from a time
    server and adjusts the clock. At boot, this delays other software starting so
    that it has the correct time, and when you check your clock, you should see the
    correct time. You can configure this at boot with `ntpd_flags` in */etc/rc.conf.local*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If the clock is off on a running system and you’re running software that would
    be corrupted by the clock moving backward or a time jump forward (as with many
    databases), you might need to tell `ntpd` to correct the clock more slowly. To
    do so, run `ntpd` without any flags, or set it in *rc.conf.local* to have it run
    in this mode at boot.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your starting time may be so far off that it will be impossible to make a gradual
    adjustment to the correct time in any reasonable period. To fix the clock, schedule
    a clock change when you can shut down your sensitive software, and make sure NTP
    runs afterwards so that the problem remains fixed. It’s better to fix your clock
    right away and be done with it.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware Sensors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sensors are physical probes that check the health and status of hardware. Manufacturers
    have put more and more sensors in hardware, providing low-level hardware information
    to the operating systems. OpenBSD supports a wide variety of hardware sensors,
    and uses the `sensorsd` daemon to query them and act upon error states.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving many hardware errors requires shutting down the machine, but advance
    warning that a component has stopped working changes a hardware failure from an
    unexpected middle-of-the-day catastrophe to an after-hours annoyance. Some hardware,
    such as hot-swappable hard drives, can be replaced without interrupting service
    once you know the hardware has failed.
  prefs: []
  type: TYPE_NORMAL
- en: Device Drivers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each physical sensor has a device driver. The device driver extracts information
    from the hardware and publishes it in a sysctl (discussed in [Chapter 18](ch18.html
    "Chapter 18. Kernel Configuration")). `sensorsd` reads the sysctl values and can
    act when they change or cross critical values. For example, here are the sensor-related
    sysctl values from my laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This comparatively simple and generic hardware has two temperature sensors and
    all kinds of power sensors. You can get hundreds of lines of sensor output, depending
    on your hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many RAID controllers have their own sensors, and will report when an array
    has failed. Here, we see three virtual disks provided by an AMI RAID controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you didn’t have sensors, you would need to look at the blinking lights on
    the drive enclosure. Or you could listen for the really annoying “beep, beep,
    beep,” which is *so* easy to hear over the roar of 5,000 server fans, the air
    conditioners, and someone else’s hardware that has been beeping every time you’ve
    come in for the last six months.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some sensors require the Intelligent Platform Management Interface (IPMI). This
    is a kernel feature that’s disabled by default in OpenBSD, because it makes some
    machines behave really badly. [Chapter 18](ch18.html "Chapter 18. Kernel Configuration")
    discusses enabling IPMI.
  prefs: []
  type: TYPE_NORMAL
- en: The device drivers attach to sensors automatically, and the values get into
    the kernel automatically, but to do anything with these results in any automated
    manner, you need `sensorsd(8)`, or you need to configure an external SNMP-based
    management system and use `snmpd(8)`. We’ll look at using `sensorsd(8)` here.
    Using `snmpd(8)` is discussed in [Chapter 16](ch16.html "Chapter 16. Network Servers").
  prefs: []
  type: TYPE_NORMAL
- en: Sensor Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sensors daemon `sensorsd(8)` watches sensor monitoring data. It logs changes
    and can execute commands if needed. Because all hardware is different and all
    environments are different, by default, `sensorsd` notices changes only in sensor
    readings. To take action, you must configure `sensorsd` in */etc/sensorsd.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: Sensor Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'OpenBSD supports many types of sensors, as listed in [Table 15-2](ch15.html#supported_sensor_types
    "Table 15-2. Table 15-2: Supported Sensor Types").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15-2. Table 15-2: Supported Sensor Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Function |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| temp | Temperature (C) |'
  prefs: []
  type: TYPE_TB
- en: '| fan | Fan speed (RPM) |'
  prefs: []
  type: TYPE_TB
- en: '| volt | DC voltage |'
  prefs: []
  type: TYPE_TB
- en: '| acvolt | AC voltage |'
  prefs: []
  type: TYPE_TB
- en: '| resistance | Ohms resistance |'
  prefs: []
  type: TYPE_TB
- en: '| power | Wattage |'
  prefs: []
  type: TYPE_TB
- en: '| current | Amperage |'
  prefs: []
  type: TYPE_TB
- en: '| watthour | Power capacity |'
  prefs: []
  type: TYPE_TB
- en: '| amphour | Power capacity |'
  prefs: []
  type: TYPE_TB
- en: '| indicator | Device-dependent yes/no |'
  prefs: []
  type: TYPE_TB
- en: '| raw | Device-dependent value |'
  prefs: []
  type: TYPE_TB
- en: '| percentage | Device-dependent percentage |'
  prefs: []
  type: TYPE_TB
- en: '| illuminance | Lighting |'
  prefs: []
  type: TYPE_TB
- en: '| drive | Hard drives |'
  prefs: []
  type: TYPE_TB
- en: '| timedelta | Time difference between operating system and hardware |'
  prefs: []
  type: TYPE_TB
- en: '| humidity | Percent humidity |'
  prefs: []
  type: TYPE_TB
- en: '| frequency | Microhertz |'
  prefs: []
  type: TYPE_TB
- en: '| angle | Microdegrees |'
  prefs: []
  type: TYPE_TB
- en: You’ll need to check your hardware manual in order to learn how to use some
    of these sensors effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Some sensors appear to overlap. For example, why does OpenBSD have all those
    separate values for power, when you could probably do some math and get a common
    power gauge? The reason is that these are the values that the actual sensors report,
    and the developers would prefer to give you the actual measurements. OpenBSD does
    perform some data rationalization, but only for simple data; all temperature sensors
    are normalized to degrees Celsius, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see what you can do with these sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Settings in sensorsd.conf
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The file *sensorsd.conf* has example entries, but because environments differ
    so widely, they’re all commented out. It uses a `termcap`-style configuration
    syntax, much like */etc/remote* (see [Chapter 5](ch05.html "Chapter 5. The Boot
    Process")) or */etc/login.access* (see [Chapter 6](ch06.html "Chapter 6. User
    Management")), with colons separating the terms in an entry. Each entry starts
    with the sensor to be measured, followed by attribute names and settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s an entry for a temperature sensor in the default *sensorsd.conf*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For the sensor `lm0.temp0`, the attribute `high` is set to `50C`.
  prefs: []
  type: TYPE_NORMAL
- en: '`sensorsd` supports four attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`high`****. An upper limit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`low`****. A lower limit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`command`****. A command to run when a limit is crossed or a state changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`istatus`****. Ignore this status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values reported for a sensor type depend on what makes sense. Where high
    and low limits make sense for temperature and voltage, some sensors report specific
    values instead. The RAID controller shown earlier reports drives as degraded,
    failed, or healthy. A hard-drive sensor that reports a scalar value isn’t useful,
    as you want to know if a RAID container is healthy or if drives have failed. There’s
    no middle ground.
  prefs: []
  type: TYPE_NORMAL
- en: You can have both high and low values for a single sensor. For example, whereas
    temperature might not have a low value in most data centers, voltage certainly
    will. I work in all sorts of weird places, and not all of them have clean power.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With a line like this, if the electricity supply to my laptop drops below 11
    volts or goes above 13 volts, I will know.
  prefs: []
  type: TYPE_NORMAL
- en: Some systems might have dozens of sensors of a given type, which could make
    configuration tricky. If my motherboard has 15 temperature sensors, I don’t want
    to configure each separately. Fortunately, you can configure sensors en masse
    by type, and since I don’t care which temperature sensor goes above 80 degrees
    Celsius (if any of them do, I want an alarm), that works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When this rule is applied, `sensorsd` first looks for a configuration item
    for a specific sensor. If it doesn’t find that specific rule, it looks for a general
    rule. You can have one rule for most of your temperature sensors, and then override
    it for specific sensors, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This rule says that most of my temperature sensors alarm at 80 degrees, but
    one specific sensor doesn’t alarm until 90 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: I care about temperature, but I don’t care if my fancy keyboard sees that there’s
    no light and wants to trigger its back lighting. You can ignore a sensor, or a
    type of sensor, with the `istatus` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You should categorically ignore certain types of alarms based on your environment
    and gear. Make up your own mind.
  prefs: []
  type: TYPE_NORMAL
- en: Sensors Triggering Action
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Having an entry in */var/log/daemon* for when a hard drive fails is nice, but
    it would be better if the system would send email, page you, or trigger your monitoring
    system. It should do something—*anything*—that doesn’t require you to log in and
    look at a log file. Fortunately, `sensorsd` can run arbitrary commands upon detecting
    a problem or crossing a threshold, using the `command` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the wide variety of sensors and their possible error states and conditions,
    `sensorsd` doesn’t have a fine-grained “run this command for an error, but run
    that other command for recovery.” There are too many possible error states and
    conditions for this to make any sense. Instead, `sensorsd` runs a single command
    upon crossing any threshold or upon any state change, including when it starts
    up and the state of an individual sensor goes from “unknown” to whatever it starts
    at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this *sensorsd.conf* entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this reads “If the temperature is high, reboot the machine.”
    You think that will unquestionably kill whatever runaway process is saturating
    your heat-generating CPU (completely setting aside the fact that other hardware
    besides CPUs generate heat), but `sensorsd` will run the command whenever the
    temperature state changes. The state changes at boot time, when the first temperature
    reading is taken, which means that your system will boot, and then immediately
    reboot. Your script needs intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make scripting easier, `sensorsd` has a set of variables it can pass to
    a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`%1`****. Is the value within the limit set in *sensorsd.conf*? This can
    be one of `below`, `above`, `within`, `invalid`, or `uninitialized`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`%n`****. Sensor number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`%s`****. Sensor status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`%x`****. Which device the sensor sits on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`%t`****. Sensor type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`%2`****. Sensor’s current value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`%3`****. Sensor’s low limit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`%4`****. Sensor’s high limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might run a temperature command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Your script */usr/local/script/temp* would take three arguments: the error
    condition, the temperature, and the sensor name. Your script would check these
    values and see if a reboot is warranted.'
  prefs: []
  type: TYPE_NORMAL
- en: With `sensorsd`, proper timekeeping, and log file management, your OpenBSD system
    can largely look after itself.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at how OpenBSD can take care of other hosts.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[41](#id367882)]) Hey, I was running out of ways to annoy lasnyder—plausible
    ways, at least.
  prefs: []
  type: TYPE_NORMAL
